Sick, this is totally awesome!
tox + [shiningpanda](https://www.shiningpanda-ci.com/) makes for a great combination.
that’s awesome. i’ll do a archlinux pkgbuild. forthwith. /e: unfortunately, it’s broken. i guess it calls `python` instead of `python2` somewhere? please fix this, as `python` means `python3` in some places /e2: done: https://aur.archlinux.org/packages.php?ID=62161 i didn’t look into the makefile, but calling setup.py without it was easy enough
Yeah, we're experimenting with Travis as well... the pull request testing thing is killer!
ah, ok. nevertheless it’s more correct to use python2 if you don’t run a bilingual python script. PKGBUILD will be up shortly, i’ll keep you posted.
I was just about to post that Ubuntu doesn't provide a `python2` symlink, but I checked, and it finally does. :-) Still, I think only the latest version (12.04) does, so I would remain cautious about calling `python2` for a while.
they didn’t? silly canonical, what were they thinking! i once read that optimally, you should use the lowest known version on which it works, but i guess ubuntu doesn’t link python2.3 → python2.7 neither, or does it?
jython is an implementation of the python language on top of the java VM. it can use java classes per design, but has to be maintained and extended, and is some versions behind cpython. cpython (the thing that does the job whenever you use python from the command line or IDLE) is *the* reference implementation of the python language. pyjnius runs on cpython, but can interface with java.
Very nice, this actually looks quite useful. It's nice to be able to decode UTF-8 properly the moment it comes in, but sometimes that's not feasible. It might even be worth creating a separate Github repo just for your fixit.py, since I imagine this would be helpful to a lot of people who aren't involved in natural language work.
Awesome idea! However: `for pos in xrange(len(text))` Somewhere the creator of `enumerate` is weeping a little.
this x 1000
My android 4.0 browser is getting stuck in your last code part. I think it has to do with a floating toolbar stealing the touch events. The browser is responsive, eg I can pinch zoom in and out and scroll left/right, just not up/down.
This looks like a very complicated solution for a simple problem or am I missing something? You could simply reverse the wrong decode-encode-transformation applied by the buggy program like this: &gt;&gt;&gt; text = "If numbers arenâ€™t beautiful, I donâ€™t know what is. â€“Paul ErdÅ‘s" &gt;&gt;&gt; text.encode("cp1252").decode("utf8") 'If numbers aren’t beautiful, I don’t know what is. –Paul Erdős'
Yes, you're missing the fact that you manually provided Windows-1252 as the source encoding and you're working from a non-unicode string (in Python 2 anyways). The entire point of this code is: Knowing absolutely nothing about the encoding, take a string **already** marked as Unicode (but the encoding from the source material failed) - and make a good guess as to what it **should** be and fix it. Compare what you wrote vs. his example: &gt;&gt;&gt; print fix_bad_unicode(u'This â€” should be an em dash') This — should be an em dash Even though the sample string was already marked as Unicode, "fix_bad_unicode(...)" detected it was a malformed conversion from a Windows-1252 encoding and automatically (without passing "cp1525" as an argument) fixed it.
&gt;Yes, you're missing the fact that you manually provided Windows-1252 as the source encoding and you're working from a non-unicode string (in Python 2 anyways). No, the string is Unicode. The example I've given is written for Python 3. It really doesn't make much sense to call "encode" for a bytestring, now, does it? Also, the article states "The three most commonly-confused codecs are UTF-8, Latin-1, and Windows-1252. [...] We’ll focus on fixing cases where text was encoded as one of these three codecs and decoded as another." With only these three codecs, a simple trial-and-error to find the right combination should be very easy. At least a lot easier and less error-prone than guessing the encoding of fragments of a bytestring.
&gt;With only these three codecs, a simple try-and-error to find the right combination should be very simple. At least a lot simpler and less error-prone than the guessing the encoding of fragments of a bytestring. Trial and error is exactly what this code does. It tries every un-encoding that might be correct (based on the byte values it finds), and then checks for errors. It's the checking for errors part that is complicated, but it only looks overly complicated because the ability for a human to easily spot these sort of encoding errors in text is something we can take for granted. Really, the code is using a heuristic analysis very similar to what a person reading over each test transformation would do in trying to pick the best one.
"Give back to the python/django community to give back to the MS community." Awesome.
Kansas City, MO
great idea man. i did python tutoring in the past, never thought to make it for charity.
What's a ball-park donation level you are hoping for? I'm extremely interested in this offer. 
Honestly, I really don't have a set dollar value in mind, but my fundraising goal is $200, so whatever size dent you want to help make in that goal would be awesome. If I help save you a few hours of banging your head against your desk, take whatever that time is worth to you and donate based on that :-) No amount is too small or too large, I just appreciate you helping me to help others.
Giving examples to people with borken security is the worst you can do. Even with thousand red warnings, people will copy/paste around. PS: why do you want code to be reviewed if you already claim it's insecure?
Arkaein basically says it, but I'll elaborate: trial and error *without* a heuristic would do the wrong thing on some of those examples. So most of that code is the heuristic. Is it just accounting for obscure edge cases? Sure, maybe. But I want it to be something I'm comfortable running *anything* through and being better off than I started. If I get some unknown text: step 1, chardet. Step 2, fix\_bad\_unicode. Also, Python will refuse to encode characters like \x81 as Windows-1252 (because there is no technically correct encoding), while other programs will just leave it as \x81. So relying on .encode('cp1252') will give you an error or a replacement character that you can't decode as UTF-8. See the "this text is sad" example. 
Wow, thank you so much! I will DM you my contact info, feel free to call in the favor any time. You rock!
Thanks! I really appreciate your support. I messaged you my email in case you ever need it.
Was bored, so here's a shortened form of the Caesar implementation. import string alpha = string.uppercase def caesar(s, n): return "".join(alpha[(alpha.index(c) + n) % len(alpha)] for c in s.upper()) print caesar("ZXQP", 23) &gt;&gt;&gt; CATS I used `index()` instead of `find()` because it raises an exception if the element can't be found. And the mod operator is used for wrapping around. edit: To handle spaces: def caesar(s, n): return "".join(alpha[(alpha.index(c) + n) % len(alpha)] if c != " " else c for c in s.upper()) 
Well, I'm not quite capable of MrVonBuren's giving level, but I gave what I thought I could. Good luck in your BikeMS, and if I'm ever completely stuck on something, I'll look you up. Thanks,
Thanks, but I want to keep the code as simple for complete beginners to both programming and Python. From the post: &gt; Efficient and elegant code is also **not** a primary concern. For example, I don’t use list comprehensions because it would add another programming topic to explain in the book. The code uses more lines than it probably needs too, but I’d rather have more-but-readable code than less-but-elegant code.
I'll donate if I get home in a week, I think I could very much use your help at certain times...
I figured. Your examples definitely look good for beginners to Python. I wasn't trying to suggest changes to the book or anything, I just wanted to see how short I could make it.
Sounds good, feel free to ping me before than if you need me. I'll send you my email in a direct message. Thanks!
And Done. I sent you an email on where I need help.
Any plans to implement Jython-style keyword argument initializers? e.g. Foo(bar=baz) -&gt; Foo().setBar(baz)? Or property setting, i.e. aFoo.bar = baz translating to a setBar() call under the hood? How about idiomatic translation of Python iteration and item access to common Java iteration and mapping/indexing interfaces? (Yeah, I know, I'm greedy.) 
Someday, this is going to be going on when I'm not prepping for a conference or major life event.
Thank you very much. I have met my goal, thanks to the awesome community here, and all the extra donations are just awesome! I'll DM you my email so you can hit me up when/if you need to. 
Just let me know your timetable for next year and I'll give it my best shot! :-)
Dang Al!, Met you a few years ago at Maker Fair and downloaded your first book as a result. You keep coming up with amazing topics for beginners !
This is much easier... 'secret'.encode('rot13') 'frperg'
TFA: &gt; The Yada Project Protocol allows you to host your identity on any device capable of sending, receiving and storing data. Once hosted, you are able to create relationships and communicate with other identities hosted elsewhere on the internet.
 TypeError: encoder did not return a bytes object (type=str) (doesn't work in python 3 anymore)
Reckless people gonna be reckless.
I sent a message hours ago but not sure if it went through
I want to hear details about [Project Hexapod](http://www.kickstarter.com/projects/projecthexapod/stompy-the-giant-rideable-walking-robot-0), the giant Python-powered robot.
"Common problems and solutions using mocking while testing."
"Using python to learn x" To learn calculus, biology, economics, who knows. The python community is one of the largest group of autodidacts and this sort of topic comes up pretty frequently in python chats.
More low level talks along the lines of last years [Stepping Through CPython](http://pyvideo.org/video/635/stepping-through-cpython) and David Beazley's GIL talks. * Walking through `Python/ceval.c` * CPython memory internals * Using llvm-py for codegen * PyPy JIT internals * Porting C Extensions to PyPy with CFFI * Cython related topics ( fused types, memoryviews ) * ObjSpaces in PyPy * Integrating Python with other language runtimes ( JVM, Julia, etc ) And Armin Rigo giving a talk on his STM work, that would be awesome as well.
How do people feel about PyCon re-runs? Is it cheesy or helpful for a speaker to give the same talk he/she did (let's say) three years ago?
Deploying Python code (particularly web applications). Compared to Java and Ruby Python seems to be a little more freewheeling when it comes to getting code onto the server. I'd be curious to hear what the common practices are in the community.
Practical Packaging &amp; Deploying, current and future-ready practices. Please.
Something about contributing to Python open source projects. Maybe highlight some popular projects in need of help (on github or wherever), how to go about contributing to CPython, etc. I'd love to hear more about a contributor's workflow so I can learn from it to start contributing more.
I know. I thought of that. But the tutorials are expensive plus a lot of people can't get the extra days off work. So I'm suggesting it would. E good to bring a few tutorials (or other longer talks) right into the main three days. Who's with me!
This would be really cool! I see a lot of posts over in /learningpython questioning about *how* to get involved with open source projects. 
I'd love to see something like an intro to Computer Vision. 
If it is updated, sure. Esp if they also give a rundown on what specifically changed (the delta, just not the current snapshot) and what they learned (aka how mistakes effect their current judgement).
funny idiomatic new tricks like this one http://fr.slideshare.net/dabeaz/python-generator-hacking but with *new* tricks Like for instance «yield from» used in an unexpected way?
I'm new to programming conventions (recent CS grad) any talks you'd recommend checking out?
as much about pypy as possible, something about replacing the cpython C api with CFFI.
So far I have only seen three talks so can't say much about the others. I did enjoy the "Spotify pipelining your music" was a lot of interesting things about how their database works. * https://ep2012.europython.eu/conference/talks/spotify-pipelining-your-music * https://ep2012.europython.eu/conference/talks/postsql-using-postgresql-as-a-better-nosql * https://ep2012.europython.eu/conference/talks/javascript-for-pythonistas (If you like javascript) 
A “Python in the real world“ talk would be awesome. With that I mean a talk about how one can use Python for everyday company and private scripting, that and related quick and dirty GUIs or webinterfaces etc...
I'm all in favour of anything that makes it easy for more people to get involved in open source projects. But I suspect the audience at PyCon is mostly people who're already contributing, or at least know about it. Pretty much all open source projects would love to get more contributors. [Openhatch](http://openhatch.org/) is one site that tries to make it easy to get started, but it's still quite new. If there's a specific project you're interested in, hang around its mailing lists and bug trackers to get a feel for what they're working on, and how development works. Many projects tag some bugs 'quickfix' or 'bitesize' to indicate that newcomers can probably fix them. For CPython itself, the [developer guide](http://docs.python.org/devguide/) is a great place to get started.
More focus on advocasy and teaching non-programmers.
I'd like to see a comparison of freezing tools -- py2exe, py2app, cx_Freeze, PyInstaller, etc. On a program with large dependencies that has to be deployed on multiple operating systems.
"Running Plone and Pyramid on common PaaS platforms" I'd love to be able to set up autoscaling with Amazon'e Elastic Beanstalk now that it works with WSGI, but most PaaS that offer Python support rely on "pip install -r requirements.txt" style installs. I'm not sure if it can be done, but, if it is, it would be wonderful.
You might enjoy [this](http://programmingcomputervision.com/). You can currently get the book drafts for free!
pylab + scikit learn for rapid prototyping and visualization of computer vision and machine learning algorithms. Also, any idea if previous talks are archived online somewhere?
In my experience, it depends on what your hosting folks want to get. Mine wanted RPM files and that's what they got. With virtualization, containers and cloud computing becoming mainstream, you don't need to deal with conflicts that come from having multiple products deployed on a single server. Even if it's a single image machine, it's trivial to set different apps inside different containers.
Don't forget the first Hexy! http://www.kickstarter.com/projects/arcbotics/hexy-the-hexapod-low-cost-six-legged-open-robot
I read through the comments and would like to +1 vote the following: * "Using python to learn x" * "Common problems and solutions using mocking while testing." * "Something about contributing to Python open source projects." * "Python in the real world" For my choice, definitely something about Pyramid or SQLAlchemy.
I'd like to see something along the lines of [Unix as IDE](http://blog.sanctum.geek.nz/series/unix-as-ide/) with a Python twist; e.g "Unix as Python IDE"
So can you actually create a website from the data resulting from this framework?
Awesome. I tried to write this about a year ago using ctypes but got stuck debugging some difficult crashes… I'll definitely check this out and have several things I'd use it for. Is there/will there be Python 3 support?
I would like to hear David Beazley talk. I don't care about the topic.
Shameless plug: http://github.com/patrys/great-justice
That's only rot13 though.
BTW, can we have the 2012 videos in a more offline-friendly format? I usually keep a couple videos on my iPod for long commutes, flights and gym sessions. YouTube more or less limits me to a working internet connection. If it's a problem with Blip.tv and bandwidth usage, I wouldn't oppose having ads on the video file. 
I wrote something like this for work, however i have a much simpler code and also generate rst documents from the schema. I cannot however open source it :)
Python's OS library and Django. 
Nice. can you contrast this to [flatland](http://discorporate.us/projects/flatland/) and [colander](http://docs.pylonsproject.org/projects/colander/en/latest/?awesome) ?
More data analysis talks, the Quantitative finance one that they did previously was very interesting. Also AI, very interesting to hear how it can be implemented in Python
/u/kemitche pointed your comment out to me. It's not super clever or anything, but I just open sourced reddit's deploy tool today if you'd like to take a look: http://www.reddit.com/r/redditdev/comments/ynoxx/reddits_code_deploy_tool_is_now_open_source/
i would LOVE to see the python+GIS talks updated, as often as annually (given community interest)
To me, flatland seemed like it was best suited for validating form data. It was difficult to make it work for an arbitrary schema (e.g. nesty JSON documents). I made a [post](https://groups.google.com/forum/?fromgroups=#!topic/flatland-users/60j0FPWYaiQ) on the flatland mailing list about some of my problems. Colander, this library, and [validictory](https://github.com/sunlightlabs/validictory/) all seem good at validating arbitrary schemas.
Machine Learning techniques, tips, and tricks with Python would be nice. 
Concurrency and packaging. Python's biggest weakspots.
My problem with validictory was that the errors it generates were hard to deal with. I'm currently looking at [[an implementation of] jsonschema](https://github.com/Julian/jsonschema) which is nice enough to give you a path *to* the offending value. I'll have to look at these other ones though!
This will make your life better: https://launchpad.net/~fkrull/+archive/deadsnakes
I'd love to see this if they like showed exactly how maybe in jest, of how to go about doing this.
Totally agree being a person who tries to use Python as that initial foot in the door to demonstrate the feasibility and ease of building internal tools / scripts to make lives easier. Especially for people who are used to implementation times of months and not days. 
Maybe in the same vein, Python Best Practices on Beanstalk?
Would you pay for this service?
Concurrency is not parallelism. No GIL would be nice but it's a different issue.
You may have better success using virtualenv to install any Python packages not included with OS X, especially if you're using a different version. You may be getting conflicts with packages that are already installed but not at the required version.
Maybe this ? [stackoverflow](http://stackoverflow.com/questions/6999105/mac-os-x-lion-psycopg2-symbol-not-found-pqbackendpid)
I have the impression that validictory is oriented specifically toward JSON documents, is that wrong?
I had issues with psycopg2 on Snow Leopard as well. Mine were due to out of date GCC installs and the [documented issues](https://code.djangoproject.com/ticket/16250) in Snow Leopard with psycopg2 2.4.2 and Django 1.3. You may want to try using version 2.4.1 if nothing else is working.
Thanks everyone, I was able to get it working by creating a new virtual env, then using pip to install psycopg2. Now it works just fine. A follow up question would be that I would like this to work in the system as well, but i realized that when i use yolk -l on my system python version. I get an incredibly long list of useless site-packages, i dont know where they are from. I would like to be able to clean it out and start fresh. Any ideas?
What a great idea. I took your idea a little farther and added the ability to composite schemas: https://github.com/ericmoritz/violet
Really good! For windows, put ffmpeg.exe in the path. For some reason it is not deleting the temp files.
&gt;The idea behind violet is to create a composition of directives using the &amp; and | operators as well as container types. **violet:** schema1 &amp; schema2 "age": cast(int) &amp; passes(lambda x: 18 &lt;= x &lt;= 99), **schema:** And(schema1, schema2) 'age': And(int, lambda n: 18 &lt;= n &lt;= 99), potato/potata. now let me do this: 'age': int &amp; lambda n: 18 &lt;= n &lt;= 99, 
*potato/potata*? Is this the correct link: http://pypi.python.org/pypi/potato Not sure how `int &amp; lambda n: 18 &lt;= n &lt;= 99` works—is `int` monkey-patched by violet/potato?
This sounds very useful. I know a few Python mocking frameworks but I still mostly just roll my own and monkey patch.
I wouldn't advocate monkey patching `int` that would be bad. In violet, you have to use the is_type directive to compose it with other directives: is_adult = is_type(is_type(int) &amp; passes(lambda x: 18 &lt;= x &lt;= 99)) I don't think he was mentioning the project potato. He was using an American idiom. I'll admit that my project is a derivative of halst's good idea. I wrote it last night because I wanted to explore how I could improve the syntax of the schema declaration. Violet is just a proof of concept and not a competing project.
&gt; But sometimes the extra work to install a third party module is not warranted pip install requests I think the problem with urllib2 is that each time you had to do something you would need to read the docs. 
every slide? really? :) I could argue about slide 29. the HTTP protocol is not and never will be as simple as the print statement because so many vendors and organizations are writing/negotiating the spec, it's a nice dream though. I would rather have transparency in the api, and nice pythonic ways to build the http request that gets shot to either a wsgi callable, or website or 0mq socket or whateever. The message format does not have to be coupled to the transport. 
Is this what people are talking about when they say "packaging"? I think deployment on Windows vs Unix, for instance, is so wildly different that it would be really hard to cover both. And then web deployment seems like a totally different animal (no experience there).
Part of the message he's advocating is that for 90% of cases, you don't need to know the complexities of the HTTP protocol. Nothing is stopping you from using urllib or urllib2 - and much of that complexity is available in Requests _if you look for it_. For me, "Pythonic" means that I don't have to think about implementation details when it isn't necessary. Requests allows me to do that. When it _is_ necessary, there are tools for that as well.
&gt;Part of the message he's advocating is that for 90% of cases, you don't need to know the complexities of the HTTP protocol. the problem is, your 90% is not the same as my 90% which is not the same as someone else's 90% and all three are really just opinions as to what the sweet spot of usefulness actually is, and programmers aren't socialists.
I have a feeling Bottle has stopped growing. Is that true?
Thanks for the resources. I've looked at the CPython developer guide recently and I think it's great how they list easy issues. Something about it is still daunting (bugs spanning multiple releases, etc.), but I just need to do the damn thing. 
As for the first, migrate to 3.2+ or "pip install configparser".
In many real-world organizations, it's not as easy as "pip install requests". There's layers of bureaucracy, filing a ticket with the ops guys to get it installed, have them create a custom rpm for your organization (since third-party rpms not in a sanctioned repository could be a "security risk"), and having them add the ticket to puppet or whatever.
Not sure why you're getting downvoted when the statement is completely true. We're talking about a standard library that doesn't have OpenGL or any image manipulation capability at all but does provide several modules to read obscure audio formats, like Sun .au files which nobody has used since about 1997.
There's a couple things that bug me about Requests as well. It is not very well documented. To stream a (big) result instead of reading it in all at one time is not well documented, the api has changed over time, and every time I go to use it I still have to read the source to understand how to use it and worry if I'm even using it right. I also have no idea how it interacts with the .content method of getting the whole body. And the biggest bugger is why do I have to call raise_for_status? Why is that not done automatically? That's not very pythonic.
Is there a talk that goes with these slides?
Sneak preview: http://www.reddit.com/r/redditdev/comments/ynoxx/reddits_code_deploy_tool_is_now_open_source/
For concurrency are you referring to something as simple as, "ways to make things non-blocking" or are you referring to something more specific than that? I think I had to come up with five or six ways to do things in a non-blocking manner in [Gate One](https://github.com/liftoff/GateOne). Everything from the basics (os.fork, pty.fork, Subprocess, multiprocessing) to highly sophisticated callback mechanisms utilizing Tornado's IOLoop in conjunction with the aforementioned items. Why so many different methods in a single project? Because it spans the gamut of non-blocking webserver functions (multiple simultaneous users), spawning interactive terminal programs, offloading CPU-intensive tasks, scheduling tasks to run at a later time, and constant vigilance in keeping the clients in sync with what's on the server. I recently stopped using the threading module in favor of Tornado's PeriodiCallback mechanism. Combine that with multiprocessing and you've got yourself a way to schedule tasks to run at a later time if a condition is met :)
If anything, that's an argument for **not** putting any further multimedia APIs in the stdlib. All that obsolete zombie shit in the stdlib can't be removed or changed because someone somewhere might be using it; you can only add, never remove. If OpenGL were added today I'm sure you'd see someone in 15 years bitching about why the stdlib has this obscure graphics API that nobody uses any more. The bar for adding something should be extremely high. Guido and others have said that as a library author the last thing you should ever want is for your code to be adopted into the stdlib, because it means you're stuck with it in its current form forever. 
I think you're correct, because the README says that the validictory schema format is based on [JSON-Schema](http://json-schema.org/), which is for validating JSON documents.
Honestly, no. I haven't, but Loved your username so much that I had to come look anyway. :D Wish I could help...
What are you trying to do exactly? If people are to give advice any better than that which is Google-able they need a little more info on your application/requirements.
Pretty slick. Now figure out how to apply it so you can generate [those white board videos](http://www.youtube.com/watch?v=zDZFcDGpL4U) and you'll be a bajillionaire! (or rather keep it open source and make the world a better place then feel like a bajillionaire!)
Who would need that kind of software?
Link FTW
I picked up [Pipe](https://github.com/JulienPalard/Pipe) a few months ago and have been using it for more and more things. I've even been replacing day-to-day shell stuff (grep, sort, awk, etc.) with a custom command I made that pipes stdin into a python interpreter where I can run Pipe functions on it.
- no source - no changelog - no docs - source files downloadable individually(last updated 2009) why would you even consider this a solution? It's clearly been abandoned. 
No joke. My wife loves to blast it in her car while driving on the freeway. =D
Another factor to consider is that reddit's subreddit system makes it so that smaller subreddits like this one will still show links pretty far at the top even if they have no net upvotes. If you posted this in a bigger subreddit like /r/programming, or maybe posted something in /r/technology or /r/wtf, you probably would've seen far fewer views. Unless those submissions somehow got a lot of upvotes, then you would've been seeing far more views.
How about utilizing analytics which [respects your freedom &amp; the privacy of your readers](https://piwik.org/) instead?
You got fewer hits from Slashdot because your submission was a self-contained paragraph. You didn't need to click on any of the links to be able to understand the topic and form an opinion. Your Reddit submission said only "Fuck it, I'm learning Python" which is completely impenetrable and required clicking on the headline to learn that it was just a meandering blog post saying not much more than "I've decided to learn Python." I don't think you can draw any conclusions about Reddit vs. Slashdot from that, except that perhaps Reddit is more susceptible to click-bait headlines leading to meandering blog posts that don't really have anything interesting to say. 
Toastdriven gave us great projects like Haystack and Tastypie. Help fund more open source development please! Daniel Lindsley and Ben Spaulding are awesome.
This is pretty impressive. Are you planning on releasing your source?
it is open source :) the download link is in the description of the video.
Does libsass support scss? Have they completely moved away from the YAML version now? (weirdly, I quite liked it, though I can understand why it was ditched.
oh I forgot: - how to push malicious code on pypi (I will do it soon for testing purpose) and how it could be avoided, - a talk to convince packager a good readme tells what a module does, source telling nothing, - how to force local test before install - python packaging platform compared to Perl/R/Ruby. I love all languages and I would like to see python community awareness raise on the packaging/QA topic because we are obviously not the best ... yet. 
If you are interested you can download the program here: https://sourceforge.net/projects/pythonimagedraw/ Source files are included.
While I agree with everything else you said, this isn't computer science.
What else is computer science? 
This is perfect! Thanks a lot.
Django or flask with pluggable ORM? 
any normal web framework can deal with this issue just fine. The wierder your app is (for no justified reasons), the more your successors hate you.
Pointless my ass, I really hate using SF's web interface and layout :/
Yeah, there's probably no algorithms or anything behind this.
I made one like this before. There's a Finnish online java game where they give you a word, you draw it and others have to guess it. Then I added a google image search to it so I can find a right picture fast enough. Had some fun with it.
Anything involving pyramid, especially in the form of real-world examples. Mainly covering the thought process behind the code structure of a given pyramid app. That would definitely help me.
http://pypi.python.org/pypi/collective.transmogrifier
Get someone from Udacity to talk about "teaching thousands of people at a time, with python"...
Looks interesting, but what are some practical uses for it? Also, what are some practical uses of pathoc?
Reminds me (loosely) of the robot-drawing in I, Robot... 
Thanks for not giving me the [lmgtfy link](http://lmgtfy.com/?q=python+for+humans). Though, it wouldn't have been uncalled for. 
i played around with schema yesterday and i think it's a really nice project. keep going! some ideas for future extensions: * Nor/ Not to combine schemas * some primitive helper function for common lambda functions such as: between = lambda low,high : lambda n : low &lt;= n &lt;= high # used like this: 'age': And(int, between(18, 99)), have a look at: https://github.com/davidgtonge/backbone_query for inspiration. 
I agree. I produce Software, that has no use yet, too. But you present it on public space and expected me and others to like it for what it is. But I just cannot imagine any use (of gluing together vectorization algorithms and controlling the mouse) for which I should like it. *To me it just looks like not-so-new components composed into something irrelevant.* Sure is creative though.
Check out [Kamaelia](http://www.kamaelia.org/)
Well, it's a nice visual effect. As a video editor I could see using it as an interesting transition.
Never gonna give it up, never gonna let you down ;) 
The .content logic is very well documented: http://docs.python-requests.org/en/latest/user/advanced/#body-content-workflow The API changes infrequently, but is bound to since it is pre-1.0 (sem ver). You have to call raise_for_status because a 404 is a perfectly valid HTTP response. Your browser doesn't raise an exception and neither should Python.
For example writing a http-client and having something to test against.. In the "about" of that page I've read they used it to test their proxy (that's why they need both client and server for testing)
There is an example of running bottle.py in the [uwsgi example docs](http://projects.unbit.it/uwsgi/wiki/Example) 
thanks for the support :)
thanks for the link and for suggestions!
Thanks _Mark_, I'm definitely going to participate in these. 
looks like a python copy of jmeter
I know that, I use it on Windows myself. But to get pip in the first place you have to figure out that you need to install Distribute, and doing that isn't very clear to people who stop reading after "upon a command prompt and ..." because they don't know what that means, or Python isn't in their PATH, etc. For these people, using Python means clicking on the IDLE icon from the desktop or start menu, and then typing stuff or loading a file from the file menu. 
But this isn't even applied computer science, it's a nifty bit of programming. Applied computer science includes things like AI, ML, Computer Engineering or Software Engineering. Unless we now know something we didn't know before it's not science. I'm not even saying this to shit on moccajoghurt's parade. I think it's a cool little program and that's exactly what this subreddit is for.
Uhm... Bottle *does* support automatic reloading. Fun fact: Bottle supported auto-reloading a year before Flask was released. Werkzeug's debugger is a WSGI middleware. There is even an example in the docs on how to use it with bottle. http://bottlepy.org/docs/dev/recipes.html#debugging-with-style-debugging-middleware 
How did I miss that?! Thanks. Wouldn't using Werkzeug middleware require python 2? That defeats the point of using bottle.py for me. Otherwise, these frameworks are so similar. 
It's relatively easy to configure bottle to run with nginx, uwsgi, which is currently a good combo. Under Debian, this should be even easier, just apt-get install nginux and uwsgi and you are set.
I have never seen anyone using Flup in production for years now.
Debian's [nginx packages](http://packages.debian.org/squeeze/nginx) are woefully out of date: 0.7.x versus 1.2.x. You should use the latest stable tarball or build from source. The uswgi packages are more up to date, but uwsgi can also be installed cleanly and easily using `pip`, which is handy on shared hosting.
Flask auto-reloading works perfectly in my experience. &gt; The perfect design for automatic reloading is using .... gasp ... "exec" to run the controllers, etc. every time; aka web2py. In fact this is a nice thing about web2py: changes give you immediate results. It's reactive programming for web dev. Does web2py really `exec` your controllers *every time* they are called?! Can you explain how you think that's actually a good idea? EDIT: Wow, it really does. It even string modifies your source code first. No wonder everyone complains how un-pythonic it is.
turbogears is using object dispatch rather than routing. for example you have a url like "/users/signin?next=/home". this is how you work on it: class UserController(BaseController): def signin(self, next=None): # login user here. pass which means "/user" is your controller class and the next segment of the url is your controller action. other than that turbogears is orm and template language agnostic. you can use mako, jinja2, genshi or anything else you want for templating or sqlalchemy, elixir or sqlobject for orm library. for a little bit more reading check out my [blog post](http://www.mengu.net/post/whats-going-on-with-turbogears) and the [turbogears documentation](http://www.turbogears.org/2.2/docs/).
Was it just me, or was there absolutely *nothing* related to Python on that page?
One good thing is it's reactive. This is not a problem if you have "light-weight" controllers. Be careful with saying "everyone complains"; web2py has a non-trivial number of followers. It's a framework. And a framework does things for you, unlike a library that lets you use it to do your own things. Be careful, however, with thinking that libraries somehow aren't "opinionated". Lots of folks make statements like "my thing has no opinions", while in fact a lot of design decisions are so obvious in their things. Take Flask for example, it's supposed to have "no opinions", but in fact, if you use it to build a non-trivial system, you will have to deal with all of its peculiarities. 
Sorry, I'm using testing (wheezy), and it's 1.2.x.
They both can be used to ensure your code will work well with misbehaving http servers or clients. So, if you're writing a http client, you can test against pathod to ensure that if your client receives weird or random data, it will still behave properly. If you're writing an http server, you can use pathoc in a similar way. So, if I was writing something like mechanize, I can use pathod to ensure that if I send mechanize a request that will hang forever at a random location, it will catch that error properly. This is actually really interesting because it makes creating complicated or randomized requests and responses really easy, manually or programmatically. Does your http client accept [CRAZY stuff like this](http://pathod.net/response_preview?spec=200:b@100:h@1k,ascii_letters='foo')? Now you can check! 
I thought TurboGears married Pylons and gave birth to Pyramid. What happened?
Can you explain your reasoning a bit about why it is flawed? Say I'm doing a get on some URL. That URL will return some data. But say I get the infamous too many connections mysql db message because that URL is being overloaded, and that is accompanied by an appropriate HTTP status code. The data I expect isn't returned to me. Something else is. Without explicitly checking the status code, I can not trust what the 'get' provided for me. I'm just not understanding how this is any different than the classic debate between 'silent' return codes v.s. 'noisy' exceptions. Is it flawed because I should always need to check to make sure the returned body is what I expect regardless of status code? Also, how does your reasoning fit in with some of your biggest proponents in this thread talking about how it is nice that your library abstracts away all the HTTP crap from the user and leaves them with a relatively HTTP agnostic interface?
A rough transition to 2.0 is understandable; I don't hold that against them, just sharing my limited experience. The problem I have with the quickstart application is that it seems to require so many different components just to get started. When using a "Megaframework," I fear that I will spend as much learning the framework and adapting it to my needs as I would actually writing the components myself. In comparison to django, many of TurboGears design decisions make sense but I personally prefer simpler, more single-purpose tools. 
What do you mean by "reactive?" I am familiar with the term in regards to reactive programming, but I am not seeing how that applies here. I am currently using Flask to build a non-trivial application and I haven't found it "opinioned" at all. It routes urls to controllers and renders templates, what's there to be opinionated about?
That was repoze.bfg. TurboGears is still built on top of Pylons, though.
Dispatch mechanism in this version is moved to crank. TurboGears 2.3 will be pylonsless.
How about linking to the [actual blog](https://n-1.cc/pg/blog/read/1424347/massive-open-online-course-a-gentle-introduction-to-python) instead of just copying them verbatim on your own?
Thank you for adding it to pip as well.
on a related side note; how the hell I did not know about pip? thanks, I guess.
You should also know about virtualenv and fabric if you are just learning about pip. :)
I think the standard lib is nice for general file I/O, and it has some cool stuff like the webbrowser module, platform/os, itertools, collections, etc. For interacting with the outside world though I agree it's a bit lacking.
Yes, but there is also SystemError, and of course IOErrror can be pretty much anything.. chain: iter1 + iter2 + iter3. hmm.. groupby in inconvenient because it returns an iterator. I prefer to use a "classify" function that returns a dictionary.
yes, i found about them too after I googled pip!
&gt;What happened? what happened is you made that up. 
The forum link on yadaproject redirects to the home page -- are there forums? Is there a mailing list? Who is yadaproject? What are the techinical details?
Because it has no sigil, because indentation matters, because the Zen of python, because the code I read in python is always clearer than the code I read in other language.
in this case we just shoot the author.
Python is explicitly designed to be a language for beginners. Someone is not a "clinically braindead idiot" if they have not yet been exposed to a command line, they're just a beginner, and Python is a language meant for them to begin with. 
Read "A Curious Course in Coroutines", you should be able to roll whatever pipeline-like setup you need with coroutines and generators.
With no updates in 2.5 years, is it not effectively a dead project?
I made what up?
What are you waiting on?
Just to make it clear, Numpy has supported Python 3 for __two years__.
err, 2011 post: http://mail.python.org/pipermail/image-sig/2011-August/006849.html
matplotlib development version works fine in python 3 FYI
That's great, but generally we don't deploy things that are not available via PyPI to production. Why don't they do a release if they are ready for Python 3 support?
Based on that post, it looks like he installed a modified version of PIL. http://www.pythonware.com/products/pil/ says: &gt;The current free version is PIL 1.1.7. This release supports Python 1.5.2 and newer, including 2.5 and 2.6. A version for 3.X will be released later.
I saw. Seems strange that pythonware is having difficulty getting a 3.x compat version released when this fellow didn't have much trouble...
I put this module together so that I could easily share the contents of a directory in a secure ~~manor~~ manner that supported authentication and rate limiting. Additionally, I decided to add support for the http `range` header to allow for resuming downloads. All the functionality is implemented by extending the existing HTTPServer, BaseHTTPHandler, and SimpleHTTPHandler classes. Implementing the [range header support](https://github.com/bboe/extended_http_server/blob/master/ext_http_server.py#L137) required the most thought to avoid duplicating much of the SimpleHTTPHandler code. You might ask, why use this instead of lighttpd? There really isn't a reason. Lighttpd accomplishes everything I desired in a pretty easy to configure manor. However, its rate limiting didn't seem very stable as it seems it's based on congestion window size. I'm happy with the result.
I only have one for Lua: http://coffeeghost.net/2010/11/01/lua-cheat-sheet-for-programmers/
PIL is effectively dead. It doesn't work with virtualenv, let alone Python 3. I know the python-imaging folks are actively working on Py3 compat in Pillow, which you should probably be using anyway. Last target I heard was PyCon 2013, so next March.
Was not aware of that. Certainly good to know.
Biopython have been 'implicitly' supporting Python 3 for a while now. It's never been publicly posted, since I think there are some corner-case bugs that haven't been squashed. But if you look at the tests, the build matrix now include Python 3. Have you run into any bugs when using it in Python 3?
Do you think this cold be wrapped into SimpleHTTPServer? Forking is nice but more capability in the original code is always nice. 
Well, it absolutely _can_ be added to `SimpleHTTPServer`. However, I don't think python's maintainers would support such a change. I get the impression that `SimpleHTTPServer` is intended to be a _simple_ example of how to extend the `BaseHTTPServer` module. By including any of these changes, `SimpleHTTPServer` would open itself up to all the small changes people have good reason to add such as proxy, or caching support. Eventually, it may become feature complete, unreliable or incredibly complicated to understand. In either case, as soon as any additional functionality is added, the module is no longer simple and thus does not provide as excellent a reference as it currently does for extending `BaseHTTPServer`.
&gt; secure manor [umm…](http://farm5.static.flickr.com/4081/4893474928_c67d772133.jpg)
Give me a freaking break. It was speculated, and eventually announced everywhere that TurboGears and Pylons merged. Read this post for example: https://groups.google.com/forum/?fromgroups=#!topic/turbogears/pu9x6-pOvLA It was also apparent that Pyramid was a new thing that these developers worked on. Tell me how that is "so very far from the truth". 
Infrastructure not supporting Python 3, for example. I need to deploy in a professionally managed environment where Python is a niche. There's a book of standards. Everything else needs to be approved which at least takes ages. So for me it's RedHat with packages from the RedHat repro only. No Python 3, no nginx, ... but thank god for virtual env. EDIT: With 'professionally managed' I want to express that there's a large organisation including IT-security behind it all. That's why there're no exceptions to the rules.
nice! actually, i wanted to extend it, too, but with a different capability: [304: Not modified](http://getpython3.com/diveintopython3/http-web-services.html#last-modified)
That's pretty clever with the lock in RateLimitWriter, if the base server were to ever be multi-threaded. Unfortunately it's generally not useful to add rate limiting and download resuming to a (despite what the docstring says) single-threaded HTTP server. HTTPServer is very poorly-suited to serving large files in the first place, since it only serves one client at a time, and these two features are only useful for large files. 
&gt; That's pretty clever with the lock in RateLimitWriter, if the base server were to ever be multi-threaded. I am actually using the `ThreadingMixIn` in the `MyServer` object that the actual server uses ([source](https://github.com/bboe/extended_http_server/blob/master/ext_http_server.py#L219)). However, you indirectly raised an excellent point that I didn't consider: my locking approach only works with the `ThreadingMixIn` and won't apply if the `ForkingMixIn` is used. I'll have to make a note of that and see if there is a more generic way of handling locking in that case.
:) TIL that all these times I've used _manor_ in place of _manner_. Thanks!
`multiprocessing.lock`
heh, no problem. i’m no native speaker myself, so i’m glad if i get stuff right :)
Does this package take care of that?
Who said about "pylons + tg == pyramid"? From the announcement, people mentioned "merging", "moving repos", "consolidating infrastructures", "migrating tickets", and "working on new things". It was more or less clear that the two projects merged, joined force, or "married" if you will. It was a light-hearted comment on my part, but it wasn't "so very far from the truth". You seem to be offended. What's the problem?
Yes, exactly. The Python-level `Lock` object is copied on fork. That object is a wrapper around a handle to an underlying OS semaphore. After forking, both processes have a distinct `Lock` object that is pointing to the same semaphore. That is what I meant by saying they were sharing a lock. If you get it working for processes, it should work fine for multithreading as well. For a single datetime, the simplest thing to do is convert it back and forth to a Unix timestamp and store that in a `Value` as an int or float.
I'm not offended at all, I was answering your question. this... &gt; I thought TurboGears married Pylons and gave **birth** to Pyramid. to me looks like.... &gt; pylons + tg == pyramid if that's not what you meant, fine. But that's how I read it(and probably others), and it is false, so I was pointing out that what you thought, is in fact incorrect. Which is for the benefit of others who may jump in this thread trying to make sense of the whole pylons project thing and how turbogears fits in and the larger web framework ecosystem. 
Nice! Thanks a lot :-)
Please try it out. 'wheel keygen' and 'wheel sign/verify package.whl' work. The only missing pieces are the scripts needed to easily build wheels en masse.
"Snake Wrangling For Kids" was very misleading. 
Python *has* signed package management. Anyone can sign their package on upload. Hardly anyone uses it. python setup.py sdist upload --sign 
Damn! I just bought one of those books... Oh well, at least it went to a good cause.
And of course, you know about [GNU Octave](http://www.gnu.org/software/octave/)? If you end up somewhere that allows you a choice of tools, but no budget, GNU Octave might be a good way to put your Matlab experience to good use.
Is there any way to import stuff into Pythonista other than typing? Clipboard? Something?
i'm not implying he/she is purposely spreading misinformation, only that his/her brain manufactured it on it's own. The thread he/she refers to doesnt even remotely imply what he/she was asserting. The only place I have seen that implies pylons and tg got married and gave birth to pyramid is his/her comment. I'm not denying that the history of these projects is complicated. But I don't really see why it should keep anyone from using any of the frameworks. just read the docs and write some code. 
&gt; Bottle supported auto-reloading a year before Flask was released. Fun fact: Werkzeug (what's Flask is based on) supports auto-reloading since 2007 and before that Colubrid and wsgiutils which were the precursors. :P
This looks useful. I'm going to give it a try tonight, to chase down a recently introduced bug in my game.
I used it to connect my garage door opener to the internet. I was constantly worried that I left my garage door open. So I connected some sensors to a Pic Micro and then attached it to a netbook running bottle.py. It has been running, using a paste server for over a year with out a reboot. bottle.py is awesome and works great for that project. 
A dead simple [todo list manager](https://github.com/dAnjou/simple-todo) ([screenshot](https://raw.github.com/dAnjou/simple-todo/master/screenshot.png)) using CouchDB.
I use it to prototype or make a simple API for Backbone to use. For bigger projects I prefer Django.
Maybe I'm asking something very silly, but here goes. I get this error when trying to install the package (using Win 7 64-bit and the latest version of mingw): &gt;C:\MinGW\bin\gcc.exe -mdll -O -Wall -Ilib -IC:\Python32\include -IC:\Python32\PC -c lib/marisa/grimoire/io\mapper.cc -o build\temp.win32-3.2\Release\lib\marisa\grimoire\io\mapper.o &gt;lib/marisa/grimoire/io\mapper.cc: In member function 'void marisa::grimoire::io::Mapper::open_(const char*)': &gt;lib/marisa/grimoire/io\mapper.cc:110:19: error: aggregate 'marisa::grimoire::io::Mapper::open_(const char*)::__stat64 st' has incomplete type and cannot be defined &gt;lib/marisa/grimoire/io\mapper.cc:111:3: error: '::_stat64' has not been declared &gt;error: command 'gcc' failed with exit status 1 Am I doing something wrong?
Thanks for the report ( https://github.com/kmike/marisa-trie/issues/1 ). The library was not tested under Windows and I don't have access to Windows machine now; I'll be able to take a look in an about a week. Pull requests are welcome by the way :)
Clipboard's the only way - that's down to Apple's restrictions unfortunately.
Internal build-and-deploy system for a startup I've used to work. Also an API that let us keep virtual server on tabs.
funny... I can't seem to paste into Pythonista... edit: ignore me... I had to pull the keyboard out first. hadn't used Pythonista before.
www.foreverremember.me was written with bottle.py
I've only tested with python 2.7 on linux. What are you running?
I built a [tiny URL shortener](https://gist.github.com/2356912) in it. Unfortunately, Flask has taken over it in popularity by a long shot.
Actually, Flask looks quite similar to Bottle. Bottle predates Flask.
Please don't use "import *".
Public source?
I'm not sure if it will help you, but I uploaded my form3.py file so you could take a look at it and maybe figure out what's causing the error. http://www.freefilehosting.net/form3
can this replace PIL? how do they compare?
for me it works on Win 7 (64-bit) (not using Mingw but VS Express 2008)
I built a CRUD application for editing metadata associated with data analysis for [DataGristle](https://github.com/kenfar/DataGristle). Not nearly ready for prime-time yet though. I'd love to see more examples of bottle code, because I don't have a lot of faith in what I've written - given that I spend all my time writing back-end apps and none on the front-end.
I recently started off with bottle.py on a project and I quickly became frustrated by it's very little documentation, especially around testing. Hence why I just switched to Flask. 
I built a cookie dropping service with bottle.py for work (I work in online advertising). I am hopeful that I get to open source it
The first web framework I learned in python was pylons, because it had a awesome book for it. Pyramid is based on pylons and its a awesome framework, but way more heavy that I needed for something like this. I love that bottle is a single file, that doesn't need setup tools or anything else to start. This server never gets more load than me checking it every once in a while, so I can't say about the performance. 
What is the Pylons book you worked with? Is it available in PDF, aka free? I spent my physical book money on Djangoo book that has gotten a lot of use, but, I want one or more web frameworks to work with in Python. 
Oh cool, so it's the same one I got when I Googled pylons.. Looking at Pyramid I can't help but cringe after looking at the crummy design(layout/design) and get a bit turned off. But, I suppose a good API and what appears to be good documentation from the pyramid group makes up for their site's layout.
The "database locked" problem is the biggest frustration I had with SQLite, which is otherwise a very versatile piece of work.
It's a significantly smaller codebase (bottle is a single source file), it's got a significantly simpler API to work with (Pyramid requires multiple steps to achieve similar goals like routing.) In fact I considered Pyramid to be so much more work that I didn't even include it in my roundup of Python web micro frameworks last year. Of course, YMMV. http://www.slideshare.net/r1chardj0n3s/web-microframework-battle
come on, you did understand what he said... so, public source?
Is there a problem with just using a try...except with threads? I started on a larger project a few weeks ago and wrapped up pretty much everything I could touch with a try...except. That way, when it fails, I know pretty much where it will fail at and handle it accordingly. Not as familiar with threads at this time, hence the question. Thanks!
you can get multithreaded access on a single pysqlite connection by passing "check_same_thread=False" to `connect()`. It appears to be super undocumented these days though - it's present [here](http://docs.python.org/library/sqlite3.html#sqlite3.connect) only in the function signature with no explanation, and is removed in [these docs](http://pysqlite.readthedocs.org/en/latest/sqlite3.html#sqlite3.connect) totally. It's still right here [in the source](http://hg.python.org/cpython/file/7fa6336e9864/Modules/_sqlite/connection.c#l1077) though.
So it's QDialog. It'll catch Esc key and call reject(). Then you have two solutions: 1. Overide reject(), check the key pressed then ignore if it's Esc, then call reject() 2. Overide keyPressEvent, do the same as 1 You should ask this in stackoverflow to have faster reponse, and for the code, use something like pastebin 
Nice! I've been wondering why the standard library doesn't have something like this.
I wouldn't start development with a bunch of try/except blocks. You might catch errors that you don't mean to. Let the errors occur at least once while you're developing, and ensure that you catch only the errors that you intend to catch or a bug might slip by unnoticed. Once you know where the errors will pop up, I'd refactor the point of entry to that code to as few functions as possible, and wrap the body of *those* functions in your try/except statements.
I think there is no a single solution that fits all. MARISA-Trie is very memory-efficient, but static (you build it once) and slower than other tries. Double-Array-based tries are much faster but use more memory (and inserts may be slow). HAT-tries are even faster and have fast inserts but they don't natively support all trie operations. There are many other trie variants (including more traditional Patricia-Trie and basic "naive" trie) and it is not clear what features should "standard" trie provide. There was a discussion about this in Python bug tracker: http://bugs.python.org/issue9520
`ext_http_server` doesn't _yet_ support python three. I just need to write a simple compatibility layer. I plan to do that sometime within the next month. Watch the project on github for python3 related updates.
Nice...yes, I meant PHP to Python....
a simple todo/vote/rating web app using bottle.py or Flask
I wonder if this is why firefox locks up for ages on me (pretty sure it uses sqlite internally).
I never thought of that possibility. On my home computer, which should be my fastest computer, there is always an observable lag as I navigate my bookmarks. I sync them to all my computers, so it's not a matter of the quantity or my folder structure. 
My apologies to anyone who viewed the page in the past couple of hours. I made the edit above from my phone and it rolled the page back to a much older version. I fixed the issue and the correct version is showing.
Did you publish the source anywhere, and if so, may you link it?
I disagree. "Flat is better than nested" should apply to all architectural considerations including namespaces. It's an admonishment against nesting too deeply (with 'too deeply' obviously determined by your personal taste). The Java world has a cultural fondness for deeply nested namespaces and this is probably a partial reaction to that excess.
This looks like a mingw bug/feature: http://www.mail-archive.com/fedora-mingw@lists.fedoraproject.org/msg00741.html I reported this to the bug tracker of C++ library ( https://code.google.com/p/marisa-trie/issues/detail?id=10&amp;thanks=10&amp;ts=1346158553 )
Have a close look at my original post ;)
Ah. I guess your back and forth distracted me.
pysqlite doesn't support using the same connection across multiple threads anyway. In any event even when you have multiple connections open write operations are still serialized since there can only be one writer at a time (WAL allows multiple readers while there are writers). And using multiple writers with multiple connections is actually slower since heavy weight locking has to be used. One solution is to make each connection use a completely different database so there is no locking contention and populate each one with a subset of data (eg split by thread). Then at the very end attach all the separate databases to the main database and copy the data in as a single transaction. Those different databases can all be created as temporary so you don't have to worry about cleanup, and you can disable all forms of journalling/ACID which makes them faster too.
I think you misread the article. The article is complaining about people who write: sorted(results, reverse=True)[:10] Although Python has a fast sort, it's still worst-case O(n*log(n)) (it uses Timsort, written in C). Whereas a heap / priority queue is O(n) if k is small. He's just pointing out that pure python can run faster than python's built-in C functions, if you use a better (or more appropriate) algorithm.
On the other hand, 99% of programmers are not dealing with lists 10 million items long. Everything is fast for small n, and if I'm trying to get the 10 most played songs out of my 20,000 song music collection, I'm not going to bother writing and testing a priority queue function when I can just slam down that one line and be done with it. EDIT: that said, if I happen to be using the awesome python language where I can just do heapq.nlargest, there's really no reason not to.
Technically it is opinionated about using Jinja2. That's all I can come up with though. It's about as minimal as it gets as far as being opinionated. Obviously you can use other template libraries, but it makes your life easier by encouraging you to make the same decision that Flask made for you. Moreover, I think he is saying that, when you build a non-trivial system with Bottle/Flask, chances are you are going to be opinionated towards certain libraries based on the decisions of other developers. Take Django for example, which is obviously an opinionated framework because it makes quite a large number of decisions for you. Technically though, you can use other libraries if you wanted to, but the framework makes it easier for you to just use Django's ORM, for example. One of the main reasons it is easier to just use Django's ORM is that most other Django people will be using it, because it is default. This means that if you are going to build a non-trivial application with Django, you will probably want to use the default ORM, since it's the decision most developers made, and if you ever need help, you are going to be running a similar technology to more developers, so they can offer more help. Same kind of thing applies to Bottle, Flask, and other microframeworks. The only difference is that the communities made the technology stack decisions, not the developers of the framework (even that isn't entirely true. Often the developer of the framework gets the ball rolling on providing libraries that interact with things like SQLAlchemy). Regardless, if you are going to build a non-trivial application with Bottle or Flask, you will make the same technology decisions most Bottle/Flask developers make, which means using SQLAlchemy as your backend and likely using WTForms for form validation. Basically it creates the illusion of freedom from opinion, but in reality, you are going to want support and if everyone uses Flask/Bottle+SQLAlchemy in their stack, then chances are for your larger, non-trivial project, you will make the same decision they did for support purposes. In this regard, Bottle/Flask are opinionated as well, and it's not too different from Django.
m1ss1ontomars2k4's comment doesn't exclude that. The author of the article does make mention of both things that m1ss1ontomars2k4's pointed out on top of what you're pointing out. It's also worth pointing out that the snippit of code that makes him sad is perfectly reasonable for a reasonable size N, which makes it "good enough" for some applications (which is mentioned by the author, but not directly).
maybe this can help: http://stackoverflow.com/questions/189555/how-to-use-python-to-login-to-a-webpage-and-retrieve-cookies-for-later-usage
&gt; The author of the article does make mention of both things that m1ss1ontomars2k4's pointed out He mentions big O complexity, and rewriting in a faster language; but I don't think he confuses them. As for the priority queue vs heap, I can't see any claim that a priority queue isn't a heap, he just mentions that as the STL template he uses in C++ when he would use heap in python. I could ask for quotes, and you could probably find something that sounds a little confused, but I don't see any big problem with the article. 
Use [Mechanize](http://pypi.python.org/pypi/mechanize/). Simple example: import mechanize br = mechanize.browser() br.open('http://login-page-url') br.select_form('formname') br['username_field_name'] = 'username' br['password_field_name'] = 'password' br.submit() After that, any requests you make with the br object should be authenticated. Edit: If it's not obvious, you need to replace all of the strings in that example with the real deal. Edit 2: Or, if it relies on the authentication to be sent along with the initial request (sometimes used to authenticate via Windows): br.add_password(url, user, password) res = br.open(url) 
&gt; and I suspect that when I get a job I wont be able to use MATLAB Depends on where you work. As a Python user at Seagate I am definitely in the minority as lots of the engineers use MATLAB. That resource and numpy/scipy in general are great if you plan on doing the same kind of numerical computing, but Python is much more than that, and I recommend checking out the [documentation](http://www.python.org/doc/) for a broader overview.
&gt; EDIT: for what its worth, I ran the benchmarks on my laptop. They were 12s for linear, 2.6s for heap, and 8.9 for selection Sure, but the fun part is showing the different growths as the size of the input changes.
&gt; about 20% faster Since we're talking about asymptotic differences, you should probably look at the way these values change as the input size grows, and whether there is a crossover point. Trying out your code on a list of size one million, averaging over five runs, I get the following datapoints: randomly ordered input: .196 s reverse sorted input: .018 s sorted input: 1.739 s
Also odd that he brought up C++ to mention the priority queue without mentioning partial_sort, the actual C++ solution to this problem.
It's executing pretty much the same algorithm as heapq is, the only major difference is overhead in the data structure. So the educated guess is that the relative speed will stay about the same for any input. Clearly if you suspect that your data is likely to be almost sorted, you want to use the sort method that the article recommends against, since timsort handles such cases well.
Many thanks for this article!
You can do similar things with Django. You just make your Django views serve/receive JSON instead of templates, and implement your front-end entirely as a client to that JSON API. I've done this with Piston (I don't think it is actively maintained anymore) in the past. Well, specifically, Piston and an iPhone app as the entire frontend, with the only web interface being the Django administration page. You aren't forced to work with design structure expectations with Django either. There was a blog post posted either here or some other subreddit I subscribe to that discussed how you could create a minimal Django app that behaves a lot like Flask/Bottle does. One pyfile. I think it was [this](http://softwaremaniacs.org/blog/2011/01/07/django-micro-framework/en/). My point is that even microframework developers do have some design expectations, but give you the freedom to ignore those design expectations. It's not very different from Django in that regard. If your application is drastically different from those design expectations, both with Django and Flask/Bottle, it is harder to get support for those design decisions. The only difference is how suggestive they are. Flask/Bottle, it's not completely unreasonable to have very different looking applications because they don't suggest much. I assume a lot are pretty traditional MVC though. With Django it's pretty safe to say the link I provided is well outside the norm for Django apps. In that regard you have even less support for doing things outside Django's suggestion. The piston thing is a bit more common. But regardless, all frameworks are opinionated in some way or the other, even if only because the community that provides support is opinionated towards certain design decisions/libraries.
I did some screwing around with this and came up with something slightly faster. I got rid of the nasty ifs inside the loop and ended up with this (it assumes that the length of bigArray is larger than k). def Search(bigArray, k): heap = [] for i in xrange(k): heapq.heappush(heap, i) for item in bigArray: if item &gt; heap[0]: heapq.heappushpop(heap, item) return heap It takes 1.45959 s. The author's algorithm takes 1.95441 s on my machine and Cosmologicon's takes 1.61828 s. The "Linear Search" (what?) took 9.64863 s. Also, I really don't agree with the article. There's a big point of using the standard library as much as possible and that is that it's **rigorously** tested. I just expanded 1 pretty foolproof line of code to 7 or 8 lines that are more complex and untested. And I'm pretty sure someone in this very thread will point out some bug in them. The standard library is really one of the biggest strengths of python I think it should be utilized as much as possible. Moreover, if you're handling huge amounts of data like this in performance critical applications, then python is probably quite frankly the wrong choice of language. I'm pretty sure these algorithms in C++ would be something like 50 times faster. Makes the 4 times speedup the author speaks of seem pretty irrelevant. **edit:** So I wrote that C++ version just for fun (here's the [source](http://hastebin.com/lorehiqono.cpp)). It clocks in at 0.0104665s when compiled with -O3. That's a whopping 139.5 times faster than the article author's optimized python code. Sort of makes you just want to just stick with what's easier, less complex, and less error prone in python rather than screwing around with optimization.
I agree with you that the standard-library functions should be preferred. But to be fair, the author was recommending replacing one standard-library one-liner (sorted/slice) with another standard-library one-liner (heapq.nlargest). The multi-line function was only for illustration purposes.
I missed your claim that it's the same runtime complexity. It's not. Yours is &amp;Omega;(n * k), no matter how good Timsort is. For an already-sorted input, your outer for loop runs n times, and your inner sort takes at least &amp;Omega;(k) time to slide k-1 many elements over one space to the right. Quadratic growth is verified empirically. Fixing k as 1/2 n, and averaging over five runs, we have at n = 2000, time = .055 s n = 4000, time = .201 s n = 8000, time = .811 n = 16000, time = 2.867 n = 32000, time = 11.491
Well obviously all frameworks are opinionated in *some* way. They are web frameworks, after all. You can strip Django down to work like Flask, but you throw away most of what makes Django, Django. Likewise, you can build Flask up to what Django offers, but you'll have to write/compose your own components. That's what the developers mean by unopinionated.
The performance depends on the relative number of items (n) and the number of "first" items (k). Here are the various results on my system. Rows are N and Columns are K. Each cell is given by the following expression `timeit(lambda: sorted(items)[:k], number=10) / timeit(lambda: heapq.nsmallest(k, items), number=10)`. 2 4 8 16 32 64 128 256 512 1024 2048 1000 1.3114 1.7354 1.3601 1.1362 0.9003 0.6545 0.5014 0.3409 0.3080 10000 2.2212 1.9988 2.1900 1.9448 1.8537 1.7238 1.4803 1.1523 0.8404 0.5633 0.4176 100000 2.1301 2.2154 2.1971 2.1771 2.2816 2.1765 1.8135 2.0241 1.8478 1.6104 1.3014 1000000 2.9396 2.8750 2.8634 2.8597 2.8645 2.8535 2.7751 2.8745 3.0556 2.7143 2.6126 The advantage is pretty small, 3x in the worst case. If this is your bottleneck, you're almost certainly doing something very wrong. But hey, `heapq.nsmallest` is included in the standard library so it's not too hard to use it.
Oh boy, go for Ghost.py, you won't look back : )
Could you maybe add an Nginx config generator and not just a parser? Maybe have the API use Apache terminology? i.e. gen = nginx.generator(APACHE_SYNTAX) apache_config = { 'MaxClients' =&gt; '256', //convert this to worker_connections 'DocumentRoot' =&gt; '/path/to/htdocs/' //et cetera } &gt;vhost = gen.vhost(apache_config) or maybe a vhost from a file. &gt;vhost = gen.vhost_from_apache_vhost('/etc/httpd/conf.d/some_vhost.conf') Another thing is I can't figuire out what is wrong with my nginx config. I need it to work with CodeIgniter and php-fpm/nginx. If there was a way to have it generate configs for php-fpm. I know this is very granular and may be out of scope, but I'm not sure if this is simple or hard, so just bringing it up in case it's something you might find worth your time. Don't worry about my specific case as I will figure it out eventually. 
You're right that it's probably not the usleep thing, but for the sake of completeness, here's what I did to diagnose my sqlite: - Load the application in gdb (in my case, attaching to a running Python REPL). - (gdb) disas unixSleep - Look for the call to C stdlib. Here, I saw a call to &lt;dyld_stub_usleep&gt; on my machine, which indicates it's calling usleep (correctly). I hope this helps!
I don't see how this is a complaint. If you have a number of vim plugins that an IDE has a replacement for, you're likely not going to use an IDE anyway and/or the IDE is going to be a hindrance to your productivity. 
If you use mac dash is the best snippet and documentation manager evartr
Actually PyCharm does allow you to record macros and assign keybindings to them. You can also write plugins for it. You can just as easily switch between PyCharm and a terminal as between multiple terminals in tmux.
http://www.pythonect.org/
If you wanna complain complain about something real, like not being able to develop remotely, which vim+ssh+tmux is good for. Forwarding PyCharm is hassle due to X. 
Could you please try marisa-trie 0.3.4? 
I cannot upvote this program enough.
This is from a presentation I did at PyOhio last month. Shows how to use the pkg_resources modules to load config files. Solves similar problems as this post. https://github.com/mw44118/really-good-logging/blob/master/topics/configure-logging-with-config-file.txt#L30
Supporting development directly on a remote host is a non-goal for PyCharm. Instead, we offer flexible support for remote interpreters and auto-deployment, which lets you keep PyCharm and a copy of your source code on your local machine, and to run/debug it on the remote host.
Yes, but sometimes you're not allowed to bring in a copy of source code to your local machine for legal reasons. Ive tried sshfs but then pycharm was slow as eclipse. 
&gt; but they refused on the grounds that someone somewhere could be depending on the error code and message holding across threads. A code and message are simple things to just copy locally, are they not ? or are they trying to lazily evaluate these to avoid extra database conversation? 
PyCharm is a fantastic IDE for Python development. Yes, I am a happy user.
I like how Flask did config files/modules. So much so that I stole it for my own stuff. http://flask.pocoo.org/docs/api/#configuration Your code appears to be similar in concept to the 'from_pyfile' method. Upside (for me) is that my config's are now regular python modules. With all the bonus features that allows. I've extended my stuff to first import &lt;pkg&gt;.`defaults` then a config file (source from command line arg --config, or from env.var.) and although it's name is "*something*.config", it's really python source. I do like how your importer does file format conversion as part of the importing - that could be handy. (A little too much magic for my needs at the moment) 
One word comes to mind when thinking about development on the mac: Aaaaaaaaaaaaaarrrrrrgghhhhh!
It's doable but it's a lot more trouble then its worth. You'll just end up running linux in a VM and developing there. Ruby seems to have the best native support for developing on a mac because of its developer base.
With snow leopard I didn't have any problems with virutalenv. With mysql-python it's just a tweak to to get it to work. I believe this has two possible solutions to get around. http://stackoverflow.com/questions/7335853/mysql-python-installation-problems-on-mac-os-x-lion The solution I used was the one that AJJ used so it's just a case of fixing it during install and not having to mod your bash profile (not that there is anything wrong with that). The only thing that I could say was a pain was that fact that wxpython only works on 32-bit python so you need to set an environmental variable or, do what I did, and make a bash file to execute wxpython scripts. #! /bin/bash # Usage: ./osx_launch.sh my_program.py export VERSIONER_PYTHON_PREFER_32_BIT=yes /usr/bin/python "$@" OS X is still unix based so it's going to be at least 100 times better than doing it on windows and I'm sure there are some issues with some python packages but it's never been a real issue for me. I suspect most most issues revolve around GUI libs.
Using a library function like heapq.nlargest does make sense, but I've found that trying to optimize algorithms like this in an interpreted language frequently leads to counterintuitive results. Your algorithm may have a better asymptotic complexity, but be slower in practice because the VM is so much slower than compiled code. See http://lemire.me/blog/archives/2011/06/14/the-language-interpreters-are-the-new-machines/ for a worked example. BTW, thanks for heapq.nlargest! I hadn't seen that before, and it should save time.
People really did get burned by using Macports, but now with homebrew developing on a mac is easy.
That happens in both Python 2.7 and Python 3.2. Though in Python 3 you can do char, *_ = chars Not exactly Pythonic either, but it does work.
Honestly i dont seem to have any problem with ubuntu, i spend most of my time in chrome and sublime text editor.
I use snow leopard and I have never had any compilation problems, with or without virtualenv. MySQL-python compiled just fine, but recently I swapped it with pymysql.
What do you use to maintain the system wide packages? Homebrew ?
I haven't had any issues with Mac ports, been using them for past 3 years, been lazy to switch to homebrew. Then again I used to use FreeBSD.
Why? Mac is by far the best development desktop I have ever used. Native Unix support with the ability to run things like Photoshop natively.. Power or Unix + working desktop, best of both worlds. I have used Linux for work for about 10 years before I switched to Mac and I never looked back. OS X offers a much better desktop experience, which makes me much more productive.
Can someone remind me what's wrong with using the ConfigParser, again? I seem to have forgotten. All this magic people seem to love injecting into Python just bewilders me.
Do you use macbook for home machine or imac?
The code and message are stored as part of the "connection" (the [sqlite3 pointer](http://www.sqlite.org/c3ref/sqlite3.html)) which means every thread sees the same values, as opposed to using something like thread local storage to ensure that the thread that caused the problem is the one that sees its code and message. Consequently any code using SQLite that just willy nilly uses multiple threads has race conditions since the code and message can be different by the time they are read in the thread. Worst case the program can crash - if for example the pointer to the message is read and then the memory it points to is unmapped before the contents are copied. (Or random garbage until the first null is used.) As I showed earlier, a wrapper around SQLite can only be safe if it ensures that no other threads run after an operation until after the code and message are copied. APSW does that. (py)sqlite does not which why it is not thread safe (amongst other reasons).
If you are already used to Linux there are some key combinations you might never get used to. When you have been using ctrl+c to copy for 20+ years you might never get used to cmd+c, and there are many other similar things that will bug you. On the bright side the track pad on the Mac books is almost worth dealing with a weird keyboard. In any case if you find OSX is a bit to weird for you its not terribly difficult to get Ubuntu installed and running smoothly.
I use a mac for dev, but I don't use virtualenv. I have a small shell script that sets up my environment prefix that I dev against(new python installation). It's portable across osx and freebsd and retains the build source in a consistent location(in case debugging takes me into someone else's project). Arguably, "realenv". If I need to install my "packages" on another box of consistent architecture, I just rsync it over. I hear homebrew is great, but I generally dislike all formal package managers as they will eventually diverge from my expectations or my needs.
Creating tries like this: words = ['aaa', 'aab', 'aba', 'abb'] trie_basic = marisa_trie.Trie(words) trie_record = marisa_trie.RecordTrie('&lt;H', [(word, (1,)) for word in words]) trie_bytes = marisa_trie.BytesTrie([(word, b'abc') for word in words]) Pickling them, like so: with open(trie_path, 'wb') as f: pickle.dump(trie_basic, f) with open(trie_path, 'rb') as f: trie2 = pickle.load(f) works for Trie and BytesTrie but unpickling results in the following exception for RecordTries (both when using mingw and VS2008): &gt; File "marisa_trie.pyx", line 472, in marisa_trie.RecordTrie.__init__ (src\marisa_trie.cpp:7963) &gt;TypeError: __init__() takes at least 1 positional argument (0 given) Writing the tries with with open(trie_path, 'wb', buffering=0) as f: trie.write(f) works fine in VS2008, but in results in: &gt;File "marisa_trie.pyx", line 142, in marisa_trie._Trie.write (src\marisa_trie.cpp:2505) &gt;RuntimeError: Unknown exception for all Trie types when using mingw. Saving the tries with trie.save(trie_path) works fine in VS2008 but for mingw it results in (for all trie types): &gt; File "marisa_trie.pyx", line 146, in marisa_trie._Trie.save (src\marisa_trie.cpp:2665) &gt; File "marisa_trie.pyx", line 147, in marisa_trie._Trie.save (src\marisa_trie.cpp:2612) &gt; File "marisa_trie.pyx", line 142, in marisa_trie._Trie.write (src\marisa_trie.cpp:2505) &gt;RuntimeError: Unknown exception
because implicit is better than explicit /sarcasm
Osx works great for python hacking. Windows boxes in our shop generate as much hassle with some libraries, just in different ways. 
Teach a man to fish, would you. :-P Just run "help('random.choice')" at the Python prompt to see documentation for that function. Or "help(thing_you_are_curious_about)" more generally.
At home I use a Hackintosh. I have a Mac Mini but my overclocked hackintosh is way faster. For work I use a Mac Book Pro.
http://phaseit.net/claird/comp.lang.python/python_varieties.html might also interest you.
My biggest currently is Almir - bacula backup web interface. Source: https://github.com/iElectric/almir/ Docs: http://almir.readthedocs.org/en/latest/index.html Demo: http://almir-demo.domenkozar.com/
In my case python development on a Mac is sweet. I switched to the 3.x series long ago as I had nothing dependent on lagging libraries. I also use PyDev via Eclipse, very nice. Frankly the projects I work with are probably dirt simple compared to what some guys are doing here, but we each have our own focus. I use the Python package from the Python.org web site and only concern myself with a few Python packages. As to package managers for Mac OS the only avenue I can recommend is HomeBrew. I've not been happy with Mac Ports and as such literally ripped it out of my system one day. HomeBrew isn't perfect but it does have the things I want. Frankly HomeBrew is thin on Python packages but as I've said I don't use a lot. 
It is a pain, don't bother. Use linux to develop python. It is a much smoother experience.
I've never understood what problems people have with the system python. I've been doing python web development on Mac OS X for about 5 years now and never had the desire to turn to a linux VM
I do a lot of image processing for work and school. numpy, scipy, and matplotlib don't build easily on OSX. I eventually just downloaded the free EPD (Enthought Python Distribution--www.enthought.com) to preserve my sanity. I never could get OpenCV's Python bindings to work. I eventually used Ubuntu in VMWare on my Mac. 
Then let me help you ... done.
Others may be able to chime in much better than I, but I'll give you my understanding based on what I've been reading over the past few weeks. **Pyramid is designed for speed.** It has some mechanisms that cause certain chunks of code to not execute if they are not needed, which provides a [speed advantage](http://blog.curiasolutions.com/the-great-web-framework-shootout/). **It is not a microframework** like flask or bottle, but it doesn't come with as many batteries included as Django. It's somewhere in between, I suppose. **There isn't a concept of a "pluggable app"** and there probably won't ever be something exactly like that in pyramid since pyramid app design will vary. **It isn't as opinionated as Django.** it doesn't make many assumptions, so you get to do a lot more in your own way. Someone else explained it to me as "Pyramid doesn't hold your hand". Apparently, there are some "rails" available, but nothing like Django/RoR. **It allows flexibility in your app configuration**. The biggest advantage of the various non-django python frameworks is that they allow switching out chunks of the app (data storage, template system, etc). My friend that built the Xonotic Stats interface is a DBA for his day job and he really likes SQLAlchemy. That is the main reason he went with Pyramid rather than Django. That and he liked using Pylons before and Pyramid takes some ideas from Pylons. He is also a fan of Jinja2 for templates, so he uses that in his Pyramid projects. I've been keeping my eye on Django for a number of years with the plan to jump into it. I even bought a couple Django books. But a few of my friends kept talking in my ear about Django's limitations. Then I kept reading comments from developers who worked on advanced Django projects claiming that any major Django project uses custom Django code because **you end up having to rewrite parts of Django** to make it work for your app. That is probably the final straw that convinced me to give Pyramid a shot. Oh, and Pyramid supports Python 3. **Some oddities.** Pyramid uses more of a MV structure rather than MVC. [Explanation is here](http://docs.pylonsproject.org/projects/pyramid/en/1.0-branch/designdefense.html?highlight=mvc#pyramid-gets-its-terminology-wrong-mvc). Pyramid uses some libraries from Zope, which puts some people off unnecessarily. There are a lot of misunderstandings of Pyramid floating around, including some inaccurate claims about Zopisms. It has been made very clear that [Pyramid is nothing like Zope](http://docs.pylonsproject.org/projects/pyramid/en/1.0-branch/designdefense.html?highlight=mvc#pyramid-has-zope-things-in-it-so-it-s-too-complex), even though it uses some Zope libraries. That whole page clarifies a lot of misconceptions about Pyramid. **The biggest legitimate criticisms I've heard about Pyramid so far:** - It isn't as easy to pickup as Django because it doesn't do as much hand-holding - The community is relatively small right now. That means fewer "tips and tricks" articles written, and fewer places to get assistance. But I understand the #pyramid channel on freenode has some very helpful people in it. I'm personally a big fan of robust communities. If I end up putting my time into Pyramid, I'll do what I can to add to the community. - Too many dependencies. This sets it apart from Django and the microframeworks. I personally don't see this as a big problem. - Documentation, while robust, has been written with too much technical language and with not enough examples. But this is something they have been working on improving. In fact, the main pyramid doc maintainer [is on reddit](http://www.reddit.com/user/mcdonc) and has commented on this numerous times in /r/python. **Pyramid people**, Let me know if I got any of that wrong. :-)
How does this stack up against PyPy?
Pretty solid summary. I've been using Pylons for years. I originally evaluated it against TurboGears and Django. I have a DBA background so I tend to stuff a lot of logic in database stored functions. I didn't want an ORM getting in the way and Pylons was the most accommodating. I originally really fought giving up Pylons (primarly due to previous exposure to Plone/Zope), but Pyramid 1.3 + Ahket is really slick. It's a very clean framework with just the right amount of "magic" under the hood for experienced developers (Django is like RoR with too much magic. Flask means I'm spending too much time reinventing the wheel for anything but trivial apps).
What's been your experience with packaging and distributing a Pyramid app? Everything I've written has been for internal/client usage and isn't distributed.
Not on hand, no. Basically, you get to avoid carrying around the generator along with the instance or managing the generator within the instance. Naturally, this only makes sense when the state is unique per instance. Consider event callbacks that want to retain some information about past events that have been processed. Without a generator, you would just set attributes on your instance. With a generator(statefulmethod), you would use the generator's locals().
May his soul RIP!
Given that Pylons is now Pyramid, and Reddit itself uses Pylons, does Reddit count?
This is quite sad. 
This is absolute bunkum. Mac is probably the **easiest** platform to work with for python dev. See my post.
wow, diagnosed the end of july, died a month later. fucking cancer.
Firefox Sync's back-end service and a number of other supporting web services are implemented with Pyramid (https://docs.services.mozilla.com/).
Just for comparison of different approaches Valideer: product_schema = { "+id": "number", "+name": "string", "+price": Range("number", min_value=0), "tags": ["string"], "stock": { "warehouse": "number", "retail": "number", } } [python schema](https://github.com/halst/schema) (pip install schema): schema = Schema({ 'id': int, 'name': str, 'price': lambda n: n &gt;= 0, Optional('tags'): [str], Optional('stock'): { 'warehouse': int, 'retail': Or(float, int)}}) 
'cause birthday gift, that's why
Thanks for the python schema link. From a quick look it seems more similar to valideer than the half a dozen or so other libraries we looked into before deciding to roll our own.
Damn that's sad, and an emotional piece of writing. I hope that the donation fund can raise enough to adequately provide for his family.
I think that LLVM is Richard M. Stallman's most important contribution to software development. Now everyone and their grandma can easily use a state-of-the-art optimizing compiler to implement whatever programming language or language modification they can come up with.
python schema is only 2 weeks old, so it probably didn't exist at the time you were looking for a schema validation library.
Well, for this I've tried to get things down to a simple git clone &amp;&amp; make install to automate everything into a running state. I don't actually package the web app up and push to pypi because I need a lot of file based work to run things and I've not mastered package_resources yet. My goal at some point is to generate a tarball with the deps included so that you'd download, untar, and then make install to get things running, but haven't had the time yet.
How old was he? He looks young. Also what type of cancer?
He was diagnosed with colon cancer and died of complications during the first round of chemotherapy. Both the diagnosis and his sudden death must have been a massive shock to his family.
Not yet but we only need add new features. Everything else works as documented. Anyway wait for 2.0.3 later today ironing some corners...
Thanks again! I'll take a look at these issues.
I've had no issues with this. Just install everything through [homebrew](http://mxcl.github.com/homebrew/). You can use [pythonbrew](https://github.com/utahta/pythonbrew) to use different versions of python; I've used this to fix some issues on Mountain Lion. Also, [zshell](https://github.com/robbyrussell/oh-my-zsh) is awesome, especially if you're using version management. It shows you what branch you're on and has a bunch of extra functions, makes working with the command line less painful.
reload(john.hunter) 
similarly I'm not sure what your FAQ quote is responding to. I'm quoting the pysqlite source code.
The way you get max and minimum values for a field of a table seems to have changed. I'm getting: min_priority = db().select(min_priority).first()[min_priority] File "/home/leo/virt_env/web2py/web2py/gluon/dal.py", line 8679, in select return self(fields[0]._table).select(*fields,**attributes) AttributeError: 'Expression' object has no attribute '_table' From this code in the controller: min_priority = db.foo.menu_priority.min() min_priority = db().select(min_priority).first()[min_priority] priority_foo = db(db.foo.menu_priority == min_priority).select().first() This worked with 1.99.7. and I did this code by following this book section: http://web2py.com/books/default/chapter/29/6#sum,-min,-max-and-len Thanks for the great framework btw, I'm quite enjoying using it. 
Fuck. I know I'm not giving anything to the conversation, but I can't think of anything else. Fuck.
matplotlib is a great project. Sad news indeed. 
Dammit. It's such a solid project, and I hope it keeps moving forward. I'm definitely going to give a little to the fund for his kids.
The article touts the api of the library, but I don't really think it is all that great. A lot of the methods that I saw should have actually been properties, while that isn't a big deal by itself they were named as if they were properties. I know that would definitely throw me off at first. Also I don't entirely understand the point of the `Players` class. It seems to mostly just reimpliment things that could easily be done on a regular list, `filter` and `sort` specifically. The `Player` and `Game` classes seem like they could just be a `namedtuple` since it is mostly the constructor, the helpers for it and what could be properties. I might be missing something about the `Player` part though since I don't entirely understand why you would use its `__add__`. If it is being geared toward people who haven't done a lot of programming I can kind of understand why some of the things are they way they are, but it would make the library much simpler to not make everything a special class.
Mmm...after going (deep?) into django, I can now see the difference of philosophy between the 2 frameworks. Whatever their respective specifics, web2py is really a good lib.
We ll fix it later today. This is accidental
Django: explicit is better than implicit. Lots of 3d party add-ons Web2py: never repeat youtself, everything has a default behavour. Web based id. All inclusive approach.
&gt; I'm not sure Player would be the right name for that class then. You don't add or concatenate two players. If anything the Player class should contain a collection of something similar to what is now known as the Player class. Actually, I like this idea. I may take you up on it. A better name might be `PlayerStats`. &gt; If you had set up a namedtuple well enough sorting wouldn't be as bad as that example you used. That is a little better. But a group of players still has additional operations that require a bit more than just your simple `sorted` or `filter`, such as finding all players with a touchdown---which requires looking at many fields. I can definitely foresee similar operations cropping up in the future. &gt; EDIT: This might also be relevant. Apparently using words like "decoupling" and "implementation hiding" is grounds for "pulling a fast one." That's bullshit. Maybe they are overused in support of OOP, but they are extremely important concepts in many language paradigms. Also, from the video: "When you have a bundle of mutable data, and a bunch of related functions that you want to use with that data, then yes, classes are the right thing to do." Classes in Python are useful for grouping related functions. That is what I'm doing. It's possible to massage some of my library into namedtuples, but at the cost (IMO) of additional API complexity. Moreover, this is my first release: I expect the functionality to grow, but I do not expect the number of classes to expand proportionally. I actually agree with most of the content in the video. But it's more about fixing stupid code than declaring war on classes.
An actual code example (something that actually does something, something with complexity similar to Fibonacci --- not `Foo`) would be nice to help us see how we should look at it. Right now, I don't even know what to make of your explanatory comments.
Assuming most of us (including me) aren't experts or familiar with LabWindows, Could you argue *for* LabWindows for a minute. Let us hear what it's about and at the same time talking through what hurdles you'd have to overcome switching to Python. 
I find this a pretty bad blog post. There appears to be a lot of info if you want to get started with 'django-jenkins', but it does not make clear -in any way- what the advantage is of using 'django-jenkins', or 'jenkins' in general. Yeah, 'continous integration' has a nice ring to it, but do I really have to build a dozen of test cases, configure 'web drivers' and all kinds of environments when I'm still busy finding out how I'm going to operate my web application, and URL schema's and page layouts get turned upside down every day? Or is this just the umptheenth test suite which doesn't survive anything more complex than a simple blog? Also, quotes like &gt;But enabling this task is not enough, a Web Driver environment is also required. An environment declares all the necessary parameters to create a new Web Driver. See selenose documentation for more details.' with a snippet of a config file below feel like you have to go on a fishing expedition to get things running. 
TBH, I'm a little confused at the confusion. It's a decorator that lets you treat a generator method as if it were a regular method... An example of @statefulmethod is simply an example of a generator...
Dang. You have me dominated. I'm a lowly 1488th. :-(
If you've derived benefit from John's hard work on matplotlib I'd strongly urge you to contribute *whatever you can* to the John Hunter Memorial Fund. *Especially* if you've used matplotlib in a commercial project: John was a strong advocate of the BSD license so that exchange with the private sector was as easy as possible. As his death was both tragically early and extremely sudden, he can't have had very much time to prepare for and provide for his family in his absence. Any help the Python (scientific and beyond) community can provide for his daughters' education (his eldest daughter is 14, and will be starting college in a few years) would be a profound way to honour John's memory.
link to the account page on twitter: http://twitter.com/ghettojurk
I get an error from BitBucket stating that I cannot access the repo. 
As far as I know, Jenkins is the most popular continuous integration server out there. You can think of it as a way to chain together various build/deployment/test steps (generally nothing much more than shell scripts). These steps can execute on a particular schedule like a cron job or after an even like a post-commit hook. Selenium/Webdriver is a browser automation and test suite. It works like a macro recorder (Firefox plug-in) that allows you to export your recordings as a PyUnit script. We use Jenkins + SVN + Selenium + Win7 virtual machines + home grown test code. Every time someone commits, the project is checked out on a test server and rebuilt using a sample database. A browser is then launched on a Windows7 box and various steps are performed (creating a user account, going through a checkout process, etc). If one of these processes fails to complete, the dev team is emailed a link to a Flash video of the failed test. These automated regression tests generally run several times per day. The tests can take a lot of tweaking to get right, so we only run them on stable portions of the application. But it ensures that the current build always works in an actual web browser.
Valedictory is based on [JSON schemas](http://en.wikipedia.org/wiki/JSON#Schema) which are programming-language-agnostic (+1), but are very verbose (-1) and hard-to-read (-2). {"id": {"type": "number", "minimum": 0}} Valideer is loosely based on JSON schemas, more succinct, but (as many validation libraries around) reinvents all basic python types (`Boolean()`, `Number()`, `Datetime()`, etc.) {'id': Range(Number(), min_value=0)} [python schema](https://github.com/halst/schema) is based around python data types, built-in functions and lambdas: {'id': And(int, lambda n: n &gt;=0)} or simply: {'id': lambda n: n &gt;= 0} (if you don't want to enforce `int` type, just anything that is `&gt;= 0`) Disclaimer: I can be biased since I'm the author of [python schema](https://github.com/halst/schema)
Gentlemen, could you consider joining your efforts ? This would make the resulting lib more solid and more supported. And there is some much fragmentation out there...
Valideer accepts regular Python types as well, e.g. if you want to enforce Python ints you can do it using: {'id': Range(int, min_value=0)} The custom "reinvented" validators are there to (a) provide a string alias (e.g. "datetime" instead of having to "from datetime import datetime") and/or (b) slightly different semantics (e.g. "integer" accepts both int and long, but not bool instances).
Which project would that be?
I'm affraid that you have confused GCC and LLVM. Stallman have contributions in GCC (http://en.wikipedia.org/wiki/GNU_Compiler_Collection), but not in the LLVM project, that born as a research project in the University of Illinois (http://llvm.org/docs/FAQ.html)
There is a nice [advocacy summary](http://www.python.org/~gbrandl/build/html2/howto/advocacy.html) at python.org. This could address some of the issues your company's management may bring up. 
&gt; Fuck. Yeah that's pretty much the response from like, the entire Python community. Even those who didn't know him, knew of his project and certainly knew of its impact on Python adoption in the world.
No, I meant that RMS should be fairly credited for: * Trying to bully Apple into releasing their ObjC frontend for GCC under GPL (mostly unsuccessfully: they did release the frontend, but withhold the standard library). * Encouraging the policy of keeping GCC internal APIs undocumented, uncommented, unstable, and generally intentionally incomprehensible, to prevent outsiders from writing proprietary plugins (until the release of GPLv3). That, of course, also prevented outsiders from contributing meaningfully, but RMS's goal is not having more free software, it's having less non-free software. Which made it sure that even if Apple could forget the initial slight, they still had very serious technical reasons to try and make their own non-GCC-based compiler, and when they did (transforming LLVM from a research project to a product able to support their entire software ecosystem), they would rather stab themselves in the eye with a fork than release it under any kind of kopyleft license.
Well done! I'm a tad upset that none of my Python projects rank... then again, I don't promote them so it's my own fault!
This is really terrible, and while I'm donating, please, guys, LIFE INSURANCE IF YOU HAVE KIDS. (I also recommend cryonics, but that's not for everyone.
&lt;trollface&gt;No need: [python schema](https://github.com/halst/schema) is perfect: solid, supported, extensible, small, heavily-tested, production-quality, pythonic library. From now on all other schema-validation-libraries are obsolete and unnecessary.&lt;/trollface&gt; If you encounter imperfection in [python schema](https://github.com/halst/schema), please [create an issue on github](https://github.com/halst/schema/issues).
It's amazing how many of those most popular Python projects are related to the Sublime Text 2 editor.
&gt; avoid macports and fink at all costs Just curious, what's your beef with macports? I've been using that on the Mac for Python development for a couple of years now, without any real problems. Compiling pypy from scratch was bothersome, but they since included binaries, so I really can't complain.
&gt; Who's talking about a mouse? And what does a mouse have to do with OS X. It means that the desktop is catered toward people who use the mouse. It's the same for Windows, GNOME, KDE, etc... (Unless you swap out the window managers in the latter two.) &gt; As far as tiling goes, OS X has something called Exposé.. you should give it a try. LOL. You have no idea what tiling is. [A brief demo](http://www.youtube.com/watch?gl=GB&amp;hl=en-GB&amp;v=LN4Ov6ZLcrI). Skip ahead to the 30 second mark to start seeing the juicy bits.
Begs the questsion of rather than profiling and gluing together Python calls to C functions, why not just write the whole ``html`` function in C or Cython and just call it from Python.
&gt; It means that the desktop is catered toward people who use the mouse. It's the same for Windows, GNOME, KDE, etc... as opposed to what? OS X is very keyboard shortcut friendly. In fact it's better than Windows, GNOME and KDE at it. CMD-W always closes a window/tab, CMD-Space starts any document or app you type.. countless examples of why OS X is very keyboard friendly, more so than the examples you stated. &gt; LOL. You have no idea what tiling is. No you have no idea what [expose](http://switchtoamac.com/guides/images/expose_all_01.jpg) is.
Would someone please tell me what program make work python code with apache?
&gt; CMD-W always closes a window/tab, CMD-Space starts any document or app you type.. countless examples of why OS X is very keyboard friendly, more so than the examples you stated. Are you a troll? I haven't used Windows in years, and I know Alt-F4 and Win+R do the same thing. And I wasn't saying OS X was better or worse than Windows/GNOME/KDE. I use **none** of those. I was saying they are all mouse-centric. This isn't about keyboard shortcuts. It's about window management. (Hint: On Linux, I can bind *whatever I want* to *any* keyboard shortcut by adding two lines to a configuration file.) &gt; No you have no idea what expose is. If you aren't even going to bother watching the video, then please don't respond. I know what expose is. I've used it. I've used differing implementations of it on Linux too. It isn't tiling. Tiling is *window management*. Expose is a neat utility when you're using a stacking window management policy.
&gt; No it doesn't. Can you actually read? I can, but you can't. You said **Ctrl+L**. I said **Alt+D**. I just opened a VM with Windows 7, and **Alt+D** highlights the address bar in Chrome, Explorer and IE. How can you be such an ignoramus? &gt; On OS X copy and paste works in vim too. One of the most popular terminal clients on Windows is Putty and it doesn't use ctrl-c/v for copy and paste, it uses right click which is utterly moronic. The problem is the OS should enforce this but it doesn't so we have people who write shitty apps fuck it up for everyone, which causes annoying inconsistencies. Same problem on Linux. You're too much. There is a much stronger convention than copying for what **Ctrl+C** does in a terminal. I'll let you figure it out. (But I won't hold my breath.) &gt; I am a software engineer as well, I kind of know what I am talking about as well. Being a programmer means nothing in this discussion. I wasn't just saying I'm a programmer---I'm saying that I've actually built software (that is fairly popular in niche communities) that does window management. All you've done is show me a screenshot of expose. &gt; Which is partly the reason why all Linux window managers suck. I have used Linux as my primary desktop from 1998 to 2010. I am a software engineer as well, I kind of know what I am talking about as well. I know what window tiling is, to me it's not a big deal, to you it is. But you can do that and more on OS X with Apple Script as I demonstrated. You demonstrated nothing. And you know nothing about tiling. You still haven't watched the video or read my tiling manager link. You couldn't even be bothered to respond to all of my points. You're a Mac fanboy. Fuck off.
&gt; I know what window tiling is, to me it's not a big deal, to you it is (I watched and I see a lot of issues with it). To me the only time I need tiling is when I work in terminal. And iTerm2 does tiling. Also like I said Apple Script allows for a lot of customization. We have a winner Johnny! You've finally shown some semblance of understanding tiling window management. Now, take your new found understanding of my position and re-evaluate my initial comment: &gt; I disagree. I think it offers a much prettier desktop, but I'd feel crippled on a Mac desktop. I'm one of those that uses tiling to manage windows---and I hate the mouse. Unlike you, I've made no bullshit fanatical claims about the "Mac desktop blowing everything else out of the water." I've merely stated that ***I*** feel crippled on a Mac (along with standard setups of Windows/GNOME/KDE/etc.) because of the stacking window management policies and therefore mouse centric navigation. Hell, I even admitted that it was pretty. Isn't that your primary concern as a Mac fanboy? /jab I am far more productive with proper tiling window management, and it can only be found on Linux. Whenever I use something else, I feel so slow. And it isn't for lack of knowing the keyboard shortcuts---I've already shown that I at least know more than you. Tiling isn't just about adding a few shortcuts to rearrange windows---it's an entire placement policy that effectively and automatically reorganizes your windows into a non-overlapping display. A tiling window manager then usually provides functions (bound to keyboard shortcuts) that allow one to rearrange, resize, add or remove windows from tiling.
I have disproved every single point, you have done nothing but thrown red herrings at me. You're right about alt+d but that doesn't fucking mean shit when I gave you other examples of the broken convention. Also you're actually arguing that Windows enforces a convention which is factually wrong. When we know any app can use different shortcuts and Windows doesn't give a shit. &gt; Being a programmer means nothing in this discussion. I wasn't just saying I'm a programmer---I'm saying that I've actually built software (that is fairly popular in niche communities) that does window management. All you've done is show me a screenshot of expose. This is an appeal to authority argument and it actually neither proves or denies anything in our entire argument. &gt; You're a Mac fanboy. Fuck off. Stay classy. 
&gt; I am far more productive with proper tiling window management, and it can only be found on Linux. I am far more productive on OS X, because every app uses the same keyboard shortcut convention, I can do windows tiling with Apple Script, which gives me best of both worlds. Windows tiling is not the most optimal style of windows management for all application types, in fact only one application type I can think of benefits from it (terminal). or I could use http://www.irradiatedsoftware.com/sizeup/ if I really wanted a tiling window manager, which like I said is not all that useful. Besides all these things. OS X is actually a desktop OS which doesn't suck, unlike Linux. We get working sound, video acceleration and working power management. I am not saying this to hate on Linux, I love Linux, but the fact is Linux desktop sucks. &gt; Tiling isn't just about adding a few shortcuts to rearrange windows---it's an entire placement policy that effectively and automatically reorganizes your windows into a non-overlapping display. A tiling window manager then usually provides functions (bound to keyboard shortcuts) that allow one to rearrange, resize, add or remove windows from tiling. You can do all this with AppleScript.
&gt; I have disproved every single point LOL. You have? &gt; you have done nothing but thrown red herrings at me. You're right about alt+d but that doesn't fucking mean shit when I gave you other examples of the broken convention. Also you're actually arguing that Windows enforces a convention which is factually wrong. When we know any app can use different shortcuts and Windows doesn't give a shit. Yeah, I'm the one who tossed out red herrings... You're the one who: * Said my criticism of mouse-centric navigation was bunk because Apple's mouse is similar to other mice. * Said Apple has better keyboard shortcuts when tiling window management has nothing to do with keyboard shortcuts. * Said Apple offers more customization than Linux when there isn't a single tiling window manager available for Mac. (Hint: It's impossible!) So yeah, look in a mirror bub. &gt; This is an appeal to authority argument and it actually neither proves or denies anything in our entire argument. Then why did you bother to tell me you were a software engineer? In this case, I said it to *add to my credibility* since you refused to go and figure out what tiling window management was. Therefore, it wasn't an appeal to authority, because I didn't use it to justify any of my points. So, you're wrong again. &gt; Stay classy. Ditto. Bring the fanboyism down a notch, K?
Ditto these...there are several Python meetups in my town and easily several thousand people who hold themselves out to the public (via linkedin, meetup participation, etc.) as python developers. I got 11 hits when i searched for labwindows on a linkedin profile...
&gt; I never said this, you're making shit up. Yes you did: &gt; But OS X offers so much customization you're not even aware of. It's called Apple Script, you can make windows do whatever the fuck you want. And: &gt; I always knew what tiling management was, I just didn't know what you were referring to. You just called it tiling at first and you even referenced Windows. I said "manage", and I didn't reference Windows initially: &gt; I'm one of those that uses tiling to manage windows An initial misunderstanding is acceptable. But you continue to misunderstand because you haven't bothered to follow my links that I offered. &gt; I have actually zero bias. You're the one who has bias. You're just another Apple hater, whereas I actually love Linux. I actually haven't disparaged Apple once, whereas you've blown your ass out about how much the Linux desktop sucks. What I've been saying, and will continue to say, is that tiling window management is how I am most productive, **and** that kind of workflow is only achievable on Linux. The same criticisms I've lodged against your precious Apple apply equally to Windows, GNOME and KDE. Which is precisely why I referenced them initially so you wouldn't flip your shit because I "hated on Apple." Obviously that back-fired, there was no stopping your inner fanboy. &gt; Also I know more about Linux than you do about OS X, so take this opportunity to learn something. Like the power of Apple Script. The thing is, I didn't say Apple Script wasn't powerful. I said you can rearrange windows in Linux without even learning a programming language.
&gt; So if I alt tab between a Chrome window and I want to paste into Konsole, I have to do Ctrl-c and shift-insert. Do you get my point? On Mac it's ALWAYS CMD+C CMD+V. If you don't know why Ctrl+C doesn't copy in a terminal, there's no hope for you. &gt; Yeah it is, which is why I use a terminal that supports tiling.. so I get the best of both worlds. Tiling for where it works, without fucking up the rest of the desktop. Tiling works quite well with a variety of windows. &gt; I have been making sound work on Linux since late 90s, I've actually written some drivers for Linux back then. But when a major distribution breaks everyone's sound with the introduction of Pulse Audio like Ubuntu did a few years ago.. after 10 years of fixing sound I kind of got tired of it, I just want shit to work and not only does OS X works, it works really fucking well. This sounds like a criticism of Ubuntu, which is a *linux distribution*. Maybe if you used a distribution that didn't force such things on you, you'd be all set. Don't blame Linux for your stupid decisions. &gt; As far as energy management goes, Linux has a long way to go to even come close to OS X. I can get about 12 hours on my Linux laptop. Sounds competitive to me. &gt; In fact I don't think it will ever catch up because it's not Linux's fault but hardware manufacturer's fault. I know. Which makes what the Linux folks have done all the more impressive. There have been a ton of energy management improvements in the last few years. &gt; If your result is tiled windows, you can do that on OS X. That's not my result. I want tiling *window management*. It's a policy enforced by the window manager. New windows are automatically adjusted and fit into the layout. When windows close, the rest of the windows automatically adjust. This is only possible from within the window manager, as it must coerce windows into a certain size and position. Moreover, this description only applies to *automatic* tiling management. There is also *manual* tiling management which I like to use sometimes. Manual tiling management allows one to readily add, remove and resize containers that hold windows---and those containers are tiled. You can then cycle through windows in each container (if there are more than one) either in a stacking or tabbed fashion. Automatic and manual tiling are two sides to the same coin, though. The essence of tiling is to always keep windows in a non-overlapping orientation, and to control window placement through use of the keyboard. &gt; Like when I switch my iTerm2 into a full screen mode, it literally looks no different than your xmonads video. Full screen windows are always the same in a stacking or a tiling window manager. By definition. &gt; If I want to macro bunch of shit, like for instance, when I reboot I need all my windows to open in the same location and reconnect to existing tmux/screen sessions I can do that with Apple Script. Yes yes. And the same can be done with `wmctrl`. Which is just a command. You'd have to write a few lines of bash to save window positions and restore them, of course. &gt; There is a reason why so many engineers use OS X, why NASA's curiosity room was 90% Macs, it's because you are more productive on a Mac. There you go again with your bold-faced assertions. Not only is that an appeal to authority and an argumentum ad populum, but people have different workflows. My point---**this entire fucking time**---is that the workflow that suits ***ME*** best is not possible or too difficult on a Mac. The Mac desktop, along with most others, is designed for use with a mouse. I do not like that. The mouse slows me down. (I even have an extension that lets me control my browser with the keyboard.) &gt; And I am not an Apple fanboy by OS X You certainly act like one. You've simmered down, but your blinding love for Mac was distasteful a few comments up. You refused to acknowledge that Macs might not be able to accomplish all workflows as well as other desktops. You've also stated, *repeatedly*, that the Mac is the best by far. This is the mark of a fanboy.
&gt; You're the one who bitched about them forcing Pulse Audio on you. Not me. You're essentially saying, "Ubuntu forced me to use Pulse Audio which broke things. Therefore, the Linux desktop sucks." Which is silly. The Linux desktop doesn't make you use Pulse Audio. (I've never used Pulse Audio.) Again red herring and a troll attack. It was also an example of countless problems with Linux and sound over the years. It's a well established fact, Linux generally has driver issues. Pulse Audio is just an example of a well known one. &gt; Actually, highlighting text and middle clicking is ubiquitous on Linux. It works in all scenarios I can think of. Not a substitute for a keyboard shortcut. Removing your typing hand to use a mouse is not a convenience. Also I highly doubt it works in most apps. There are definitely things Mac's running OS X don't do well, gaming, servers.. but Desktop is not one of them. You keep trying to paint me as a fanboy Mac user, but I am not a fanboy, I have verifiable reasons for my preference. I have used all common operating systems extensively (including many Linux window managers) and I am without bias stating the reasons why OS X is by far the superior productivity desktop OS. Meanwhile you have demonstrated your anti Mac bias already.
&gt; Again red herring and a troll attack. A red herring is an irrelevant point. I was attacking your logic, which was faulty. Which is certainly relevant. &gt; It's a well established fact, Linux generally has driver issues. Pulse Audio is not an example of a driver issue. Pulse Audio is a sound server. And like I've said, I've never experienced these driver issues. Things have worked out of the box for me. &gt; Not a substitute for a keyboard shortcut. Removing your typing hand to use a mouse is not a convenience. Coming from a user of a mouse-centric desktop... Lol. Like I said, I don't use it. But it fits your unreasonable bill of "consistency." &gt; Also I highly doubt it works in most apps. Well your doubt is misplaced. I'm using Linux right now. It works. Believe it. &gt; There are definitely things Mac's running OS X don't do well, gaming, servers.. but Desktop is not one of them. This is why you're a fanboy. I've outlined a very specific case where the Mac desktop fails (i.e., my workflow). You just can't admit it. How can you sit there and say the Mac desktop is superior in all things with a straight face and deny a charge of fanboyism? &gt; You keep trying to paint me as a fanboy Mac user, but I am not a fanboy, I have verifiable reasons for my preference. I'm not fucking *knocking your preference*. You're knocking mine. I've never said, "Your preferences are wrong and you don't work productively because the Mac desktop sucks." What I've said is, "My workflow is not possible or too difficult to achieve on the Mac desktop, and it is therefore not superior to me." All you can manage to do is garble out some bullshit about how you never learned how to use the Linux desktop, and it therefore sucks. Moreover, we aren't talking about *your* preferences. We're talking about *mine*. And you've shown your fanboyism by concluding that my preferences are wrong, even when **I** have shown verifiable reasons for my preference. &gt; I have used all common operating systems extensively (including many Linux window managers) and I am without bias stating the reasons why OS X is by far the superior productivity desktop OS. But you refuse to acknowledge that other people work differently (and probably more productively) than you. And that different environments may be more well suited to those workflows. In my case, Linux tiling window managers are the best. **I have never stated that tiling window management was the best possible way to organize a desktop. I have only ever stated that it suits my workflow best, and since Mac/Window/GNOME/KDE don't have tiling window managers readily available, the Mac desktop is inferior in accordance with my workflow.** &gt; Meanwhile you have demonstrated your anti Mac bias already. Lol. Every single one of my criticisms of Mac apply equally to Windows, GNOME and KDE. I'm not sure how that's "bias." You're the one touting and defending Mac---I'm merely saying mouse-centric navigation is not optimal for me.
&gt; Pulse Audio is not an example of a driver issue. Pulse Audio is a sound server. Red Herring again and a troll. These are your arguments. Let me give you a hint. What talks to the Pulse Audio sound server? The rest of your post is backpedaling. 
The link you posted makes it clear that Pyramid (like its predecessor re*poze*.bfg) is marked in all kinds of ways by Zope's intellectual heritage and exposes many Zope-isms. The link says the authors found nothing suitable *other than Zope*. In a box, it says 'Coming up with a marker type that was something like an interface that allowed for this functionality seemed like it was just reinventing the wheel.' All of this is only obvious from the perspective of a person who thinks Zope had the right way to do things. Then there is the heavy emphasis that Pyramid's docs place on traversal and how essential it is. This is absolutely a Zope-ism. All the mandatory and complex view lookup, auth, registry, XML config language - clear Zope-isms. In the above examples, I mention nothing that isn't in the doc you linked. If you read the Pyramid docs it is pretty clear that these things really aren't optional, they are at the core of the framework and the way Pyramid recommends to do things. You can plug your own stuff into Pyramid but, as you say, it's not a microframework. You do have to do things the Pyramid way. And in order to plug into the framework, as you must do, you have to understand ZCA. It isn't irrational or unfair to talk about Zope-isms in Pyramid. They are there. The authors preferred them. Own it. Pyramid can't be everything to everybody. Please do not stigmatize the correct observation that Pyramid contains Zope-isms as 'illegitimate.' 
Seems to work pretty well for thousands of Facebook and Google employees. Are you sure you know what you're talking about? 
Can you please cite any instance in our conversation where I disparaged Apple specifically? No? But you said: &gt; the fact is Linux desktop sucks. Who's the zealot now? Like I said, fuck off.
&gt; it sounded rude as hell and got the hackles of noiserr up It was a legitimate laugh. I've never heard of anyone suggest expose as a replacement for a tiling window manager. It's just one of those things you hear that's so absurd that you giggle a little bit. &gt; devolved into a platform war of old. I never disparaged any platform---I criticized desktops that were mouse centric and only mouse centric for not allowing the kind of workflow that suits ***me*** best. I made no such claims of generality like noiserr did. The problem here was that noiserr took this as an insult against the holiest of holies: the Mac desktop. But it was never about Mac---only that there are some workflows that can't be described in mouse centric desktops. I didn't even claim that this made the Linux desktop "better"---only that it was the only thing to suit my needs. noiserr continued with thinking that I was assaulting Macs, even though he was the only one proclaiming that things sucked. &gt; civility turning to flames, seemingly for no reason There were plenty of reasons. Being an annoying fanboy is one. &gt; noiserr was calm and rational He may have been calm at first, but he certainly wasn't rational. &gt; and burntsushi, you kept egging him on Tis my specialty :-) **EDIT**: Go back and look through noiserr's user page. He's practically defending or promoting Apple in every comment. And when he's not doing that, he's disparaging Android, Linux or Windows. I think it's pretty clear he's a fanboy, and any possibly legitimate discussion with him is going to devolve into bullshit. He seems to love raving about the supposed "copy and paste" issue on Linux (wtf?) Some more of his comments: &gt; Linux for desktop is the worst piece of shit ever. &gt; Hate it for desktop, weather it runs on a laptop or an actual desktop computer I think Linux sucks. &gt; While I love Linux, Linux desktop sucks, I know I've used it for 10 something years as my main workstation and I really tried to make it work, but **OS X is sooo much better in every single aspect**.
Oh you're so politically correct.
django + wsgi?
Linux as a desktop does suck.. For all the reasons I stated.. and more. The Linux community agrees as well: http://www.youtube.com/watch?v=Sh-cnaJoGCw Like I said OS X is a much better user experience why does that make me a fanboy? Somehow after 10 years of using Linux as my workstation and finally realizing what the entire Linux community already knows and also giving apple credit for making the best desktop OS makes me a fanboy and a Linux hater unlike the blinded reddit community who must always jump on the anti apple hate wagon. I have no bias what so ever actually. You as well as the majority of reddit is anti apple bias. So I often end up looking like i am defending Apple when in fact I am just correcting all the misinformation about Apple being spread every day. You are such a Apple hater that you can't even admit that keyboard shortcut consistency is a good thing.
Just use botbrew basil. The author of that software is a bro and it's so much better than sl4a
The only thing that I can do is give my admittedly *newcomer* impression based on what I've recently read. I think I made that clear enough. Perhaps you skimmed over that part of my post. **That said**, I'm going to push back on some claims you just made that don't appear to add up. It seems illegitimate to complain about traversal because it is *optional*. The docs likely place emphasis on traversal because it provides a unique feature that makes Pyramid stand out from other frameworks. Are you suggesting that traversal is mandatory? Regarding ZCA, they do make it clear that an application developer (like me, and most people using Pyramid) doesn't need to know ZCA. They provide a wrapper API around it for our purposes. You only need to understand ZCA if you are extending the framework. Still, and this applies to *any* complaints I've read about Zope-isms in Pyramid, I haven't read any direct complaints about the things they borrow from Zope...aside from the fact that they come from Zope. It would help if you could explain more directly **what exactly do you find wrong with ZCA?** The Pyramid devs cover a [pretty clear overview](http://docs.pylonsproject.org/projects/pyramid/en/1.3-branch/designdefense.html#rationale) of features that ZCA provides. Do you refute any of that? Do you think the repoze registry was a better idea? &gt; Pyramid can't be everything to everybody. I never said anything of the sort. I said that Pyramid is less opinionated and more flexible than Django, which appears to be true. If someone doesn't like the trappings within Pyramid architecture, they run into more of them in Django. Do you feel that Pyramid is *less flexible* than Django? (The person I responded to was asking specifically about differences between Pyramid and Django). &gt; Please do not stigmatize the correct observation that Pyramid contains Zope-isms as 'illegitimate.' The Pyramid devs openly admit that things were borrowed from Zope. Saying that Pyramid has some "zope stuff" in it is a correct observation. But saying that, in itself, isn't a legitimate complaint. Until I see more clear arguments made about said Zope-isms, I'm going to see them as a red herring. In your case, I would ask for more clear explanation of this &gt; All the mandatory and complex view lookup, auth, registry, XML config language - clear Zope-isms. 
I'm pretty proud of the Acknowledgement Button I made; pressing it sends the text "Acknowledged." to the last person to send me a text. Other than that it has BeautifulSoup installed by default so it's great for creating a quick notification of a small piece of info from a website. And my largest project was making a program that keeps track of the scores for an arbitrary number of players.
What's the point? You can't write releasable apps since the platform is so locked down.
i made my company's webapp hostable on an android phone. it was cool, but ultimately useless.
If you just want somewhere to play with code you can do it locally...the app engine dev server is easy to use or you can set up apache or similar (if you have a mac it is already set up and can be turned on through the control panel.) App engine and appfog both have free plans for hosting but I've only used appengine which i nice but also a non standard environment. If you actually want a domain name I tend to buy them through google apps so I have gmail set up for them from the start and can then point the cnames (ie www.yourdomain.com or blog.yourdomain.com) or bare domain to whatever webserver/app. IE I have www.mydomain.com and hillmap pointing to app engine and blog.mydomain.com pointing to blogspot but you can point things to wherever. 
Nicely written. Good information. I enjoyed reading it.
that sounds highly useful! is the button in the market? 
https://groups.google.com/forum/?fromgroups=#!topic/mpmath/3bVKcrBGYiU
Would you care to share?
You should definitely go for [webfaction](https://www.webfaction.com/?affiliate=delizseemack). They are cheap, they have great python support and they support mostly everything.
Found this on an autodesk forum. Maybe it will get you started. [autodesk forum](http://area.autodesk.com/forum/autodesk-motionbuilder/python/issues-with-nose-test/) suggestion is to "remove all my mobu python modules before each test." # remove my modules for m in sys.modules.keys(): if m.find('my_mobu_tests') &gt; -1: del(sys.modules[m]) good luck
I did this: http://www.youtube.com/watch?v=7l0mo6jvSEU and this: http://www.youtube.com/watch?v=JOLO3anX8kU
oh. i had no fun working with PIL so far. i don’t like the api. i’d really like to see a numpy-based imaging library for python, where every operation is just a smart-but-shallow wrapper around numpy array operations.
I'd recommend virtualbox + OS of your choice. Or locally as recommended. I personally use Gondor.io but if you're just getting started, Heroku has a free level. 
Mine is through [VPSDeploy](http://www.vpsdeploy.com) but I'd recommend looking through all the providers on [LowendBox](http://www.lowendbox.com/) and see if there's any special offers on etc
Thank you
https://sites.google.com/site/dlampetest/python/vectorized-particle-system-and-geometry-shaders was in the YouTube description. (once you skip past the workaround at the top for some missing opengl bindings, it is actually a pretty small chunk of demo code...)
Did you try writing a Python app for Android and then releasing it as an app? 
Experiments like this, even if they have no practical application, are a great way to discover the inner workings of languages, frameworks or libraries. I love this kind of useless fun stuff :) More of that please! Edit: Fun fact: lua basically works like this. You don't have classes, just tables and a bit of syntactic sugar.
Perfect, thank you very much! 
Please don't do this in real code, objects and dictionaries are fundamentally different structures. I consider the failure of languages like Javascript and Lua to differentiate between dicts and objects to be incredibly sad.
The place to look for updates is the code.google repository - which you'll see are primarily bugfix changes: http://code.google.com/p/kamaelia/source/list You'll see a number of checkins this year &amp; last year. The lack of checkins doesn't reflect dead though, just stability in the systems we've had - from managing multiple locked off cameras for capturing 3D scenes live through to twitter analysis for identification of hotspots in programmes that people find interesting/exciting :-) The codebase has reached a plateau in terms of functionality, but is still used in projects that I use at work, in projects others use at work and by others. I recently made an announcement on the mailing list that it was going to go into maintenance mode and probably move to github, and comments here are encouraging. In terms of maintenance in that announcement I promised to accept patches and fix bugs for the cycle of the current ubuntu LTS release - which means the next 5 years. This means that anyone using it currently can have an assurance that any problems found will be fixed, and that anyone wanting to use it for a project will probably be using something new in 5 years or want to take over the project. (That 5 year figure also indicates the level confidence I have in the code stability) Full message is here: https://groups.google.com/d/msg/kamaelia/nIGaKiRVuQ8/dOWI0JTBFDYJ The biggest change that I want to do - when Ubuntu includes python 3.3 is transform the main part of the codebase (ie "import Kamaelia.(whatever)") to being python 3 compatible. (Axon - the core concurrency framework is python 3 friendly today and runs on python 2 and 3 with the same code - and if it doesn't a bug report - or fix - is welcome) So it's not dead, just resting :-) There are plans in some current work to take the things I've learnt from Kamaelia and roll them into something newer, and importantly featuring nicer syntactic sugar, but I don't really want to say more about that right now until I've got some running code I'd want to release to the wild, nor without some concrete examples of usage and docs. By definition, as you'd expect I'll also want to have a bridge between the old and the new - but since Kamaelia systems can run in a background thread concurrently happily already, this is already taken care of. (The reason for Kamaelia's slightly baroque syntax - from a modern perspective - incidentally comes out of a need to support a machine I have running python 2.3 which for reasons not worth going into I wanted to leave running 2.3. It performs quite an important task :-)
&gt; I read something about how objects in Python are essentially dictionaries with syntactical sugar. Ehhh... no. Instances (usually) have an instance dictionary, and their type (class) also is defined using a dictionary and has a dictionary-like interface once it is defined. But neither instance nor class behavior is close enough to dictionary behavior to call it "syntactic sugar". In particular, there's no way to override the get/set behavior of a "attribute" when you're using a plain dictionary. Maybe that statement was more of a backstory and not anything crucial to your understanding of the experiment, but I just wanted to get that out there.
This was a while ago, and I seem to have deleted the code. But I should have it somewhere in my backups. I'll get back to you guys later today with that.
Okay then, how would one use `Foo().some_transformation`? And how is it different from not useing `@statefulmethod`? Because it's still not clear to me.
If I am ever reading your code, and you use these instead of classes, I will likely facepalm and shout "WHO THOUGHT THIS WAS A GOOD IDEA!"
Forgive me if I am incorrect here, but wouldn't a compiled language be much more appropriate for large-particle systems? From what I understand, Python is extremely slow when applied to performance-intensive tasks. Perhaps it is easier to use with OpenGL though. **tl;dr:** Why Python?
The best thing I can think of - it's generally really easy to see where the bug was. Is the bug in the driver, or your testing framework? If everything is C, it may not be obvious (and you'll have to break out a debugger). In python, there's an exception (Python error) or stack dump (driver error). 
I did OGL in college, and and have been learning python this year, thanks in part to the udacity AI class last fall. I will now get nothing done this weekend around my house! What have you done?!
That's not a bad idea. I just bought my books for this year, but I might do that next year. Maybe we could help each other out then. I just cleaned up the code and updated the repo: https://github.com/doubledubba/isbn 
absolutely. I posted the new repo in the comments
https://github.com/doubledubba/isbn
https://github.com/doubledubba/isbn
https://github.com/doubledubba/isbn
It is locked down. Try compiling an app with gcc. Try writing a Python program with native look-and-feel which can be distributed to users. You can't do it. The phones are 100% locked down to Dalvik. This is a fact and downvoting does not change it. Rewarding Android for supporting Python when it really doesn't actually support Python for any serious purpose is not right
 class Foo(object): def raw_generator(self, arg): arg = (yield arg + 1) yield arg + 2 @statefulmethod def stateful(self, arg): arg = (yield arg + 1) yield arg + 2 foo = Foo() g = foo.raw_generator(10) first_result = next(g) second_result = g.send(20) first_result = foo.stateful(10) second_result = foo.stateful(20)
Great thanks!
I've never tried it, but I know you can compile python scripts with SL4A http://code.google.com/p/android-scripting/wiki/CompilingASE Basically, it involves embedding a python interpreter + SL4A and bundling it in an .apk file, which is kind of like the android equivalent of a .exe/.msi So in theory, you could upload it as an app on the appstore. But it would be a lot easier and more efficient to just install SL4A and python 4 android, and use the script directly with that.
catcradle5 beat me to it. Learn Python the Hard Way is a great book for beginners. I started programming with that myself, as an absolute beginner, and I highly recommend it. I think it did a great job of introducing programming fundamentals, through python. Like catcradle5 said, it's probably best to start out small, and learn the fundamentals before you move on to widely used libraries/modules. But once you feel comfortable with the fundamentals of python, you might want to look into the tutorials on the [django website] (https://www.djangoproject.com/). Being the largest web framework for python, Django is **widely** used and has a great community, and excellent documentation. They have a very comprehensive, multi-part tutorial on their page that teaches by example (building a polling web app).
Good to hear that it's not joined the choir invisible. I was quite excited about it when I saw it at PyCon a few years back. You really need to update kamaelia.org so that it points people to code.google.com. Else they will get the same thoughts I had.
Like another commenter stated, this demo probably uses shaders for 99% of the work, which will be faster than even C or C++.
Excellent go to list if you ever find yourself needing one. I personally find the lack of a tree in python disturbing.
Check this out for inspiration: http://eli.thegreenplace.net/2012/08/07/fundamental-concepts-of-plugin-infrastructures/ 
You could take a look at the Stevedore library, either as inspiration or actually using it. http://stevedore.readthedocs.org/en/latest/index.html
You might take a look a [MusicBrainz Picard](http://musicbrainz.org/doc/MusicBrainz_Picard), it is written in in Python and PyQt4 and supports plugins (written in python). There is a list of all the [handlers](http://musicbrainz.org/doc/MusicBrainz_Picard/Plugins/API) that can be registered. I don't have any real experience with this stuff so I hope you can find some inspiration. I can imagine lots of ways to plumb everything together, but I don't really have any suggestions for best practices, sorry.
Thank you! The only reason I upgraded to 12.04 is because I spent 4 hours trying to get vpython running on 10.12 with no luck. My notebook running 12.04 had no trouble so I figured that would be the trick. I was ready to throw my desktop through the wall when it gave me that error.
I wrote a Python tutorial that takes some existing game code and goes through improving it while explaining the reasons for the changes I made: http://inventwithpython.com/blog/2012/08/09/source-code-makeover-square-shooter-part-1/ Other than that, I'm not sure something like what you're looking for exists.
oh hell no. reddit's written like a hardcore high-speed web app. that is *not* something I would show to beginners when teaching.
I saw the wiki on github, however those are for apis. Is there a wiki or a guide on helping to understand reddit's code?
A dictionary is a mapping of arbitrary keys to values. An object is something with a fixed set of named properties. If you follow that, your code will be conceptually cleaner. It'll also be faster, CPython, PyPy, and IronPython all optimize on this philosophy
codecademy.com 
I wrote an application with a GUI that would let you roam around my college's campus and catalog wifi signal strength along with GPS coordinates, uploading it to a server. With enough data, we added a second mode that let you overlay a heatmap onto google maps, showing where wifi signal strength is good and bad on campus. Unfortunately it doesn't work too well. But it was enough for the class I was taking on android application development that wanted us to do it in Java. Total project ended up being &lt; 1000 lines of code.
I absolutely love the service that I receive from them. Their custom UI makes it *too* easy to get things started. Shew, I feel like I'm on an infomercial. 
http://www.lfd.uci.edu/~gohlke/pythonlibs/ is the solution
What are the problems do you face??
first, Apple breaks the terminal every release, last version they fucked the UTF-8 support so every keypress would generate a warning if you are ssh'ed into a modern linux. The severly lack on the driver side of things, gfx-drivers have less functionality then the counterpart on windows or linux, for example my media-computer got exchanged for a mac mini back when i was flirting with the apple-cult, after a few weeks i had to change back as mac's cant handle arbitrary overscan pixels. you can choose "off" witch ment black borders around the image, or "on" which ment about a inch of the screen was outside the display. on windows i can set it to a pixelvalue getting a perfect image. on linux i've changed the pixel value myself as the driver was open source. My non-apple monitor flat-out did not work for half a year and HP warns to not try to use their stuff with apple hardware, there are reports of apple computers *destroying* HP-monitors so they wont turn back on. Keyboard shortcuts are broken, they are all made for US keyboards and doesnt always work with international layouts, some of their default-keybindings is with keys *that doesnt exist on the international, or slim (airbook) keyboards* with sound and video in the same cable to my apple-display i have to pull it out and plug it in again to move sound to the display from the headphones which is annoying as osx can take its time to notice its a external monitor plugged in. etc etc, i wish i kept a log over all the problems, But at the end of the day its still a good OS and very capable platform. anyway, dont use *one* os all the time, i change every day between windows, linux and osx. It keeps plattform quirks out of your code and you get out of touch with what the others are doing. Ive been programming since the 80ies and seen a lot of OSes come and go, dont get too stuck in one of them or you find yourself lost when the next one hits. If i could have stayed with i liked most i would still write code for my amiga. 
Not directly related, but check out [this video](http://pyvideo.org/video/884/python-metaprogramming-for-mad-scientists-and-evi).
For it to be technically true, yes, for it to be conceptually true, no. Python give us a lot of flexibility, but if you take "fixed set of named properties" to be your starting point, I think you'll have a good mental model for objects.
Manipulate would have been a much better word than mutate. `datetime.timedelta` is definitely a great example of what you are saying, since it methods like `__add__`, `__repr__`, etc. 
Have you tried compiling python interpreter from sourcecode? 
I'm taking back my kiss. Now it seems to work for awhile, then fail to work again until I restart Maya. That's even more frustrating, because it's hard to realize when it stops working, so I think for a few runs that something's wrong in my code, and I keep trying to fix it. I think I'm going to bug the nose devs directly.
I always bring this book up to everyone I see looking to learn python pretty easily. Someone did the same for me and I've loved it ever since.
May I ask what Python has to do with Phidgets? Is there some sort of Python library for their SBCs?
&gt;Never ever ran in to those and i switch between my osx, linux and windows -computers every day, you might be doing something wrong. Not surprisingly you assumed I can't get around it so you waggle your programming e-peen. If you're dealing with other people's code you can't guarantee anything. While not related to Python, I believe some of the issues with node.js originally were with the assumption of unix file paths. Is a fault of the operating system? Not really, that is a school boy error but that's reality. And the other problem is Windows sort of supports unix paths so you get people who always use that which is all fine until you do something with a native CLI utility. &gt; This has nothing to do with python development, but anyway, bash is a click away and works perfectly. and ive good great IDE tooling, irrelevant. True, it's not strictly Python. I'd argue development, full stop, is superior on unix based systems and yes, if all you is some hobbyist who has full control over everything from beginning to end, things can be easier. But when you deal with company that builds something that's largely a Linux based system but cuts corners for word doc conversion and therefore requires cygwin you become more aware of bugs and issues that crop up from version to version. Sure enough they do deserve blame for a cacky solution but to be fair to them it worked perfectly fine for awhile and the problems would exist cygwin with or without their code. &gt;Ive had no problems with those, or building them from source. similar amount as on osx. again YMMV. There is less problem now. Node.js for instance had help from Microsoft but inititally it required cygwin and quite frankly, isn't what I'd have called production ready. redis will compile on Windows. I won't dispute that. It's also not supported and clearly states it's not considered ready for production. Again, that's fine for playing around but I'd be concerned if anyone wanted to deploy that into production environment for something of value. You're free to like whatever you want. I have no problem doing development on Windows. After all I'm doing it in my current job. But my preference by far is to have pretty much any unix based system over Windows. Not because it's impossible on windows but because it'll be less hassle. I can go into a new Unix system and have my environment up and running in no time. I can certainly get something more than usable on Windows but it will take longer even with little things like having to download putty for ssh and scp and setting up paths and everything and depending on the project I may still run into issues because spaces in file paths still cause issues and unfortunately Windows home directories in "Document and Settings". And to note this is an issue even when using Microsoft's own tools: https://connect.microsoft.com/VisualStudio/feedback/details/585089/visual-studio-2010-does-not-parse-variables-correctly-in-build-event-scripts-when-path-contains-spaces Which of course is easy to by pass if you dump you code elsewhere but people shouldn't really be doing that. They should be locked down to their home directory except for exceptional instances. That is one of the other things that make me say Unix development is better. There is a stronger enforcement of keeping your stuff where it should be. It's pretty much always been my experience if I take over someone's Windows machine there are things everywhere and on Linux they'll usually have everything in their home dir and perhaps a documented software path if development code runs in the same path as production.
If you want the most control and the least amount of "Well, I can't do that here" I suggest setting up an instance on Amazon Web Services. You can use Ubuntu 12.04 Server Edition, which is eligible for the free tier. With it, you can do anything and everything because you have an actual server to work with. You can customize your Python install, mix with other languages, install packages, etc. If you're looking to build Python-based web applications, I'd go with Heroku using one dyno (which is free). It doesn't give you the same amount of control as AWS does, but it is designed for Python-based applications, and has a pretty cool git-based deployment system. I've seen a few people recommend Google App Engine: unless you plan on integrating with Google APIs, I'd advise against it because you have even less control than on Heroku.
 from collections import defaultdict def tree(): return defaultdict(tree) [It's... beautiful :')](https://gist.github.com/2012250)
Note: I've tried '==' as well. Same result.
How can you expect one number to equal the other while in a loop that dictates they are not equal
chuckstudios is right. You should move the selected *if* block below the two inequalities you have below it.
Upon quick glance, it looks like the while user != intg criteria is no longer being met, so it's exiting the while loop. Have you thought about moving the "You guessed correctly" outside of the while loop, right before the "It took you" + x + "tries to answer?"
Good points... despite their limitations, these are good "try before you buy" options... Personally, I'd throw another nugget on the WebFaction lovefest above (use 'em, love 'em) but I looked pretty hard at these three options before I moved forward... Still will probably build something for GAE before the year is out. My existing PHP host provider wanted me to spring for a business class VPS. For like $50. Seriously?
Also, be warned: once you build something on GAE it's *really* hard to port it to something else because of all the Google specific conventions.
try [r/programminghorror](http://www.reddit.com/r/programminghorror/).
Yah...I'm struggling with that one. Question...and I haven't given GAE a full test yet, so I'm ignorant. One of my projects has a computationally intensive graph object at the kernel of the application; with webfaction, I build this as a shared object once and persist it across requests. It's working great for my current server load. With GAE, can I do this or would I need to rebuild this object for each request (similar to a basic PHP / MySql script). I was able to figure out how to do a python "in the style of" PHP / MySQL on GAE but the environment didn't seem to unleash the full power of the language...
A few tips for your code: * Try using "if ans.lower() == 'no'". It simplifies your code, is easier to read, and covers more corner cases ("nO", "NO"). * Try to use more descriptive variables. Instead of using "user" try "userChoice". Instead of "intg" try "correctValue". * Try using "It took you %d tries to guess the number" % (tries). It's more flexible than the backtick solution, requires less boilerplate with the stopping and starting of the string, and is more readable. * Using "!=" can be a headache. I always try to use "==" whenever necessary. Change the first "user != intg" to "else", change the second "user != intg" to "True" or "1". Then include a break statement below the congratulations message. I try to never use != unless it's absolutely necessary because it can complicate code and make it less readable. Try to use positive assertions in if statements. 
Isn't there a homework help subreddit for this kind of thing? Anyway, when you want help, you'll maximize your chances of getting a response if you include as much information as possible about the symptoms of the problem. In this case, I have no idea what "isn't running in the program" means. Is it causing the interpreter to stop immediately, like a syntax error? Is it causing a crash when you get to that line of code? Is the logic always skipping over that line of code?
PHP hosting is basically a race to the bottom right now. Completely commoditized with big demand coming from the Wordpress crowd. From a pragmatic perspective, this is still useful - I crank out a lot of "dumb content" sites using Wordpress and other PHP scripts. It's easier to recycle existing PHP infrastructure than build new stuff. Naturally, I prefer to use Python for anything important or that will require significant customization.
Sadly, I can't adequately answer your question, but I'm pretty sure you're not going to be able to do that without writing some serious GAE-specific code. But like I said, I'm really not sure as I've always avoided production GAE applications that don't require it.
Ah, yeah. I forgot Wordpress was PHP based.
Note that your break statement will only exit the innermost while loop, after which it will continue running the outer loop (continuing with the "It took you" print statement).
In the future... "apt-get build-dep python" usually does the trick for getting the required stuff to compile Python from source on Debian-based distros like Ubuntu.
They have a library for all of their items. I'm looking into using their I/O boards and controlling them with Python.
I don't really have anything against Wordpress! I'm just not really a fan of PHP.
I wrote about 10,000 lines of PHP last year for my main side project - until October, when I decided to blow it up and rewrite in Python. It took me about one month to replicate the work of the previous 10. We're at about 2K of server side Python code; client side javascript LOC has had big growth, with matching increase in awesomeness...
Yeah, our web app is PHP, but we're not using anything fancy, so I kind of want to move it to Python, but I *really* want to move all the processing client-side!
I really like dreamhost. (You can message me for a coupon if you want.) DotCloud might be something to look into as well.
nice tutorial, very simple and easy. Done with least hassle!!
I wonder why they didn't try putting the whitelisted characters (mapping to themselves) into the cache as well, avoiding the separate set lookup.
have you thought about building a labview like gui once the functional part is done?
Maybe if you're working within C. In Python that approach would involve all kinds of type conversions, each of which implies object construction.
Ah, now I see how it would be useful. Pretty cool.
It should work for anything in the repositories. That's how the packaging system knows how to build the package. You can also do `apt-get source python` to get the source used to build the python package. In this case, you might need to specify `python2.7`, as I think `python` is an empty package that depends on the latest version of Python 2.
Tornado?
It's simpler, because every Python programmer knows comprehensions. They are probably faster too. Also your code computes f twice. It should be [g(x) for x in [f(x) for x in mylist] if f1(x)].
Make the inner comprehension a generator instead to be even better off.
Isn't this just the same as following functional programming idioms? (Not meant as a snark.)
Check out Scrapy: http://scrapy.org/
good luck!
but either way, I think kivy is the most appropriate tool to date if you want to build "real" apps with python.
hahaha that is glorious. Did you feed the pickup lines from a txt file? Do you mind sharing? I agree, most python stuff is more suitable personal or server side. Luckily, compiling python to OS specific binaries is getting to be pretty damn easy with pyinstaller.
If remote debugging/autocomplete is still the dog's breakfast it was two months ago, I'm not sure this is worth even a quarter of the discounted price! 
Some of its methods return itself, instead of a new copy of it. Unlike Ruby or JavaScript, Python tends to return nothing when it manipulates itself to indicate that the operation is indeterministic and would manipulate itself. This isn’t a good idea also in the way this breaks that convention. Plus: in most cases you’d better use list comprehenstions/generator expressions as mirashii wrote.
Sublime Text 2 is not free. It's free for evaluation. And maybe if you're using it as a student you can morally justify not paying for it in your head. Otherwise, you need to face the fact that you owe the individual developer money for his or her (although I'm pretty sure it's a his) hardwork on a program that is essential to a lot of developer workflows. 
I haven't tried it yet. What was broken?
I like jQuery and underscore.js, and I think we should learning from them, instead of saying it's Javascript idioms and close the door. I agree that this module is not very pythonic, but I still like chaining. Especially when you typing code in the interpreter. Without chaining, you will find yourself moving cursor back and forth, and wasting energy on matching brackets. 
Curious about Sublime Text 2, I downloaded it and gave it a shot. It's a pretty slick and impressive text editor, but it isn't an IDE. Code completion, insight, refactoring options, none of that is in there. It's not really a fair comparison -- fair to ST2 I mean. In PyCharm I can open a directory as a project, point it to my virtualenv and have immediate code completion for modules project-wide. I can type "from myapp.models." and get a list of available models, and when using them, get drop-down lists of available methods and properties. It integrates with Django for templates and custom template tags and supports both git and subversion. It's also plugable so my Bash and Perl scripts all have basic syntax higlighting too. If all you're looking for is a slick text editor, maybe PyCharm isn't your thing, but lets be a little more forthcoming with our comparisons here.
[itertools FTW](http://docs.python.org/library/itertools.html) 
1) PyCharm costs $99, whereas Sublime Text costs $59. I don't see how PyCharm's price is out of line with what it does. 2) I'm looking at the list of headline features at http://www.jetbrains.com/pycharm/ and I don't see remote anything listed among the headlines . Support for remote interpreters is listed as a new feature in PyCharm 2.5. "New" meaning "there are still kinks". "Remote" meaning "it needs to work with any user's environment, and users are famous for setting up all kinds of crazy stuff on their machines". So, indeed, we'd really appreciate reports about what didn't work for you, and we'll do our best to resolve the problems you've run into.
What's PyCharm got that Wing doesn't?
I like several smaller things, like the SQL Console, the tool to update / install Python packages or the result presentation of the find usage and find in path features. Also, I prefer the general layout. But Wing is a really great IDE as well. I still think the debugger is better.
Oh gotcha, thanks for the clarifying that.
Thanks - I'm on a Mac and just tried PyCharm using Python 3.2.3 . I've been tolerating IDLE long enough which keeps crashing on Mountain Lion when I try to copy and paste and is just too funky for a Mac app. Great to see something better. Will also need to try Wing. Right Now PyCharm is looking pretty good at $59. Any other suggestions would be great before committing to an IDE. edit: really liked [the BashSupport plugin](http://www.ansorg-it.com/en/products_bashsupport.html) for PyCharm... leaning more towards this after playing with it this evening. edit2: enjoyed the debugging feature... and [bought a personal license](http://i.imgur.com/oWBSb.png)! Thanks for everyone's help! Also great to see PyCharm devs reading this subreddit.
What I really care about is whether or not it can use vim commands. I'm installing the free trial to check it out. EDIT: Yes, it can. There's a plugin called IdeaVim that offers vim keymapping. Very trivial to install.
I've been a pretty much daily vi/vim user for 24 years. Obviously, I do a ton of my work in vim. That said, I've been using PyCharm regularly (with the IdeaVim plugin active) for the past six months or so, and I've been pleasantly surprised by some of the bells and whistles. I'd say it's worth trying out for us old men. Try the breakpoint/step debugging, for example.
Sorry, I didn't see your comment. I got everything working great, thanks.
would you say it's stable enough to use it in an application, yet?
There's nothing built in for this. Why do you need it though? There's no harm in passing in too many keys, so why wouldn't you just pass them all the first time if you have them? If you don't have them, well, that's the end.
Post 2.6, this is accessed via string.Formatter.parse http://docs.python.org/library/string.html#string.Formatter Something like: from string import Formatter f = Formatter() print [i[1] for i in f.parse("{hello} {world}")] That said, this is meant more for formatter subclasses than used to extract those names. A regular expression (or re-evaluation of why you need the variable names in the first place) may make more sense.
&gt; [edit formatting] how appropriate!
because the base function here does more than just get the field name, and the docs specifically layout they are intended to be used by subclasses. I don't know enough about the Formatter internals to lay either which way, but if it just implements a re itself, it may make sense to cut out the extra middle steps.
Are you perhaps using string formatting for something it wasn't designed for -- say, as a template system? There is an actual template system in the stdlib (`string.Template`) that you should probably consider using instead. Among other features, it can be told to ignore fields without a matching value in the variable list.
Upcoming soon (2.6 should be coming this week) or already in: Jinja support, Flask support, SQLAlchemy support, NumPy support, code inspection/analysis, setup.py support, virtualenv support. And definitely a much better UI (very personal of course).
I see ST2 and PyCharm as complimentary software packages. Too bad too many people conflate the concepts of IDE and editor.
HTML/CSS/JavaScript (as well as HAML/SASS/CoffeeScript) is a biggie. Not just syntax highlighting, but full code analysis/completion stuff. Yeah, and SQL too.
Sorry that PyQt still doesn't work properly. One of the problems we ran into was that we were getting a C++ exception from the guts of PyQt when trying to introspect the PyQt models, and we were unable to figure out what exactly we were doing wrong or whether it was a bug in PyQt rather than our code. Another is that the way PyQt modules are generated doesn't allow us to distinguish between class and instance methods, which hurts PyCharm's inspections a lot.
ahh, thank you. Exactly what I am looking for; big failure I missed this in the documentation :(
Using this kind of stuff in "programms writing programs". I.e. semi-automatically create the data-accessing functions for outputs.
You should add list comprehension and map , filter, reduce , enumerate. 
But it is great !
Thanks. Is there a PDF or html version. Docs is blocked at work.
[Here I hope this helps!](http://www.pdfhost.net/index.php?Action=Download&amp;File=03a7e5871ddfa97eb4cea31cb9ba9d68)
Thanks! I really appreciate this. 
A string's .find() method has a bit of an odd interface for Python, returning -1 if the needle wasn't found. Instead use if substr in wholestring: If you need to test whether substring is inside another string and use .index() to find an index if you need one. Similarly don't use dict.has_key(key), use `key in dict`. has_key() is gone in Python 3. There are quite a few big Python subjects that are missing in your sheet - generators and generator expressions, decorators, sets, modules, Unicode handling. Probably more.
Niiiicccceeee 
Damn. *OP's been hacked!*
I did one a while ago (based on yet another one ;-) https://github.com/ralsina/python-cheatsheet
I think it's safe to say Yes. Having said that, debugging and troubleshooting Pythonect code can be a bit difficult. Give it a go and see how far you get, and if you run into any problems, just ask on the mailing list. I already heard about companies using it for tasks automation, QA, and research.
X?
The sysadmins must be Redditors or the legal department found out about people sharing stuff on Google docs.
Was going to buy/test. Then &gt; Sun JDK 1.6. (OpenJDK is not supported) Wait. I don't want Java trouble when coding in Python...
This project seems to be a similar idea. http://www.phzbox.com/moka/index.html The jquery functional style (also sqlalchemy is a nice one).
I gotcha. But that's hardly clearer than OPs.
Depends what you're used to, I guess. I find it perfectly clear, but I'd still use the slicing :)
This is great! Here's some feedback. * math.sqrt, math.floor, and round take floating-point arguments, not necessarily integers. (It's pretty useless to take the floor of a number you know is an integer.) * I would add `'string1' in 'string2'` for substring testing, and `len('string1')` for string length. Also include these two things for lists. * Explanation for `list.extend` doesn't really make it clear why it's different from `list.append`. I think you should make it clear that `extend` takes an iterable argument. * A description of `for` loops would be great, since it's different from many other languages. * Not clear, but I think your explanation for dictionary.clear has it backward. * Get rid of the * at the beginning of names in the functions section. Like you say in the third bullet, that means something else. * Variables in a function are only assumed local if they're assigned a value. Global variables don't require the use of `global` if you only access them and don't assign them a value.
EDIT: Okay, I have a bit more than a few issues with this cheat sheet. This was written by someone with only a cursory knowledge of python and contains multiple glaring errors. I appreciate that user created content should be acknowledged but this post is not helpful to beginners and there are similar resources available made by more knowledgeable authors. I've quite a few issues with this cheat sheet (didn't read further than first two pages): &gt; list1.extend(object1): Extends list1 with object1 creating a whole list instead of append which jams a an object inside the list. Extend takes an iterable and not an object. &gt; dictionary1.update(dictionary2): updates dictionary1 with values from identical keys in dictionary2 Identical to what? Update adds all key-value pairs from dictionary2. Are you referring to the overwriting of existing keys? &gt; ‘string1’.strip(): Returns one string with whitespace removed. Only at the start and end of the string. &gt; ’string1’.count(object1): Returns the number of times that object1 appears in string1. This method doesn't exist as far as I can tell and I'm not sure how an object "appears" in a string. You note in the title that you made this for yourself, but you're doing every beginner who reads this a disservice by giving information that is "kinda" correct.
Being a scientific programmer, I would only use a tiny bit of of your list, but it seems really great. However, I would change "range" to "xrange". Isnt range deprecated?
Sounds like you might want GNUMake ;-) (only sort of half-kidding)
Wing has an amazing debugger and refactor capability. The rename in Wing works across the entire project. I really wish pyCharm did that.
Nice, but why do you use the cmath versions of pi and e? You use math.* for everything else, and both pi and e are defined in math.
I probably learnt more from this than my teacher was able to teach me in 3 Months. And some things he said were apparently false.
Why thank you.
Oh hai :) That's one thing I really like of Jetbrains, you guys really try hard to reach out ! On PyQt: maybe you could have a look at how Eric deals with it -- they generate a sort of static "api catalogue" and use that to do autocompletion. It should probably be done in a plugin, if there's a suitable hook into the autocompletion machinery, so normal introspection can carry on doing what it does today. I guess in the spirit of Open Source, I should now roll up my sleeves, download the IDEA community edition, refresh my java and write a plugin...
&gt; Extend takes an iterable and not an object. An iterable is an object. &gt; This method doesn't exist as far as I can tell and I'm not sure how an object "appears" in a string. It certainly does exist. Tested in 2.7 and 3.2.
Can you break down s[::-1] for me? All the slicing I've done has had just one colon.
You can hook into the completion machinery. We also generate what is essentially an API catalogue, but we don't use any other sources beyond the actual PyQt binary modules. We might be able to do better by using some additional sources of information. (And by the way, the generation script is written in Python - helpers/generator3.py under the PyCharm installation directory - so you don't even need IntelliJ IDEA to hack on it.)
It's [start:stop:step]. Step is 1 by default (i.e. if you just type [start:stop]). &gt;&gt;&gt; "hello reddit"[::2] 'hlordi' &gt;&gt;&gt; "hello reddit"[1::2] 'el edt' &gt;&gt;&gt; "hello reddit"[6::2] 'rdi' A negative step value goes backwards.
I would be shocked if anyone claimed to prefer Google Code.
I do, it's simple.
more: 1. idk why `dict.has_key(key)` exists if we have `key in dict`. also if you just want to find out if a substring is in another string, use `s2 in s1` instead of `s1.find(s2) &gt; -1`. 2. the math stuff at the beginning says `integer` all the time. integers are whole numbers, and the math modules does accept any kind of number. 3. avoid `isinstance` and `issubclass` if possible. python is duck typed, so rely on checking for functionality, not classes (e.g. instead of checking if something is a list or tuple, check if it has the method `__getitem__` if you want random access, or `__iter__` if you want to loop over it) 4. use just `raise` to re-raise an exception in an `except` block if you find out you can’tT handle it after all.
1\. `key in dict` wasn't always available.
Stay away from Google Code. It appears to have little support from Google nowadays: rarely updated, never migrated to the new Google UI, etc. Remember that Git approaches source control very differently than SVN. Instead of a central remote repository that all developers commit against, Git uses numerous local repositories that are pulled from and pushed to the master. For open source development, a DVCS like Git makes life much easier by allowing external developers to work on the code without needing commit access and providing tools for merging that work back into the main repository. GitHub is by far the most popular source code hosting site, followed by Gitorious, BitBucket and Google Code in some order. BitBucket allows free closed source projects, so that's what I use, but GitHub is probably the best for open source code.
I personally use Mercurial, with Bitbucket, but I'd choose Git between the two...
[doit](http://python-doit.sourceforge.net) doesnt have all the features but has the core functionality. You could easily code your own "description language" in json. The big missing feature is the monitoring and web interface (I wish I had time to work on that).
I've edited it :)
Someone will have to confirm but I'm almost positive this is incorrect in the list slicing section: &gt;You don’t have to specify either value, list1[5:] or list1[-5:] would reference entries 5 onwards. list[5:] actually specifies slicing *6th* entry onward, since Python lists use zero-based indices. list1[-5:] specifies slicing entries starting from 5 entries *before* the end of the list to the end of the list.
I find github to be a lot simpler.
Heh. I'm wrapping up a project right now that has taken great advantage of the ease at which you can transition between dicts (perhaps, say, rendered as JSON strings over a network connection) and objects (perhaps, say, inside your application). `dict[key] = value` and `object.attribute` have a lot of semantic similarities and are *not* fundamentally different structures, but more correctly are different perspectives on similar concepts. I consider the lack of differentiation between a collection of properties/values and a collection of properties/values to be an indication of the potential power in languages like Javascript, Lua and Python. What do you think is the essential, important difference between an `object` and a `dict` and why is it sad if they are not markedly different? Edit: sorry, nevermind - I see you've had this discussion 2 days ago. 
I like this because it isnt simply the method name and its args, but includes a definition of what it does. 
* [Git Repo](https://github.com/mitechie/pyohio_2012) * [Slides](https://docs.google.com/presentation/d/1oKXk3XGlbfpLMOY09pxH9RAujcIy2BYpw63ywwqorMI/edit?pli=1#slide=id.p)
thanks. so there is really no reason not to use `in`?
&gt; I'd like to submit some code to the community then use github. 
Are these "raw" sockets? How do permissions work?
Mostly bugfixes. Only new feature that caught my eye was break &amp; continue in the templating language.
these are sockets from the standard lib. If you want a port from 1 to 1024 I believe you need root access.
I thought the code would be self explanatory. I was wrong. User() is the object you'll use when creating sockets either for listening or sending packets. I chose User() because UDP stands for User Datagram Protocol. Regarding the binding question I believe that what you are looking for is something like this: s = User(host="10.0.0.2") Where "s" will be listening on the interface with that ip. Whatever you set as the host parameter will be used on the [socket.bind()](http://docs.python.org/library/socket.html#socket.socket.bind) [The source code for SocketServer.py.](http://hg.python.org/cpython/file/2.7/Lib/SocketServer.py#l422) On Twisted: I don't know much about twisted to compare the two extensively. This module is pure Python, it wraps standard library objects and provides an easy interface to work with. Also, thanks for commenting. I'll try to improve the code comments and the README.
The idea is to facilitate the development of other libs using UDP. So yes this is meant to be used in other personal projects. I don't know why I put those defaults there, I think I was trying to get self.server to be more flexible. The default timeout is 0.5 for the BaseServer. I use "for humans" so has not to forget why I am doing this. I want an UDP lib that maps to my brain and how I see UDP working. That's a good point regarding the generators and yes the idea is to mimic generators.
X-Windows. 
Oh good! I was hoping they'd start working in Numpy again.
what do you have against xwin?
Since it is mostly just a wrapper you might want to look into minimizing the any overhead an extra layer might add. I would say check out the use of [`__slots__`](http://dev.svetlyak.ru/using-slots-for-optimisation-in-python-en/) specifically.
I see it's a GUI of some kind, maybe it's a thing for Linux eh? Just has bad performance or something then?
Thank you! It took me a minute to realize that the git repo had everything in branches. 
Why would someone use this instead of Scapy ?
I'm really getting tired of the Networking -&gt; Twisted train of thought. Yes Twisted does networking well, but that doesn't mean there's other options. And next to that you don't always need Twisted, especially not for simpler stuff.
You don't indeed have to use Twisted but you still should know it before you roll your own. Python is all about practical things and compatibility with existing contraptions is the most practical thing you can do.
I've tried to install it: pip install -e hg+ssh://hg@bitbucket.org/duangle/pysdl-cffi#egg=pysdl-cffi pip install cffi And then run (from the Python shell): &gt;&gt;&gt; import sdl Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/Users/kmike/envs/kmike.ru/src/pysdl-cffi/sdl/__init__.py", line 3, in &lt;module&gt; from ._sdl import * File "/Users/kmike/envs/kmike.ru/src/pysdl-cffi/sdl/_sdl.py", line 2327, in &lt;module&gt; """) File "/Users/kmike/envs/kmike.ru/src/pysdl-cffi/sdl/internal.py", line 46, in load_lib _ffi.cdef(cdefs) File "/Users/kmike/envs/kmike.ru/lib/python2.7/site-packages/cffi/api.py", line 79, in cdef self._parser.parse(csource, override=override) File "/Users/kmike/envs/kmike.ru/lib/python2.7/site-packages/cffi/cparser.py", line 71, in parse self._internal_parse(csource) File "/Users/kmike/envs/kmike.ru/lib/python2.7/site-packages/cffi/cparser.py", line 102, in _internal_parse realtype = self._get_type(decl.type, name=decl.name) File "/Users/kmike/envs/kmike.ru/lib/python2.7/site-packages/cffi/cparser.py", line 226, in _get_type return self._get_enum_type(type) File "/Users/kmike/envs/kmike.ru/lib/python2.7/site-packages/cffi/cparser.py", line 418, in _get_enum_type nextenumvalue = self._parse_constant(enum.value) File "/Users/kmike/envs/kmike.ru/lib/python2.7/site-packages/cffi/cparser.py", line 370, in _parse_constant return int(exprnode.value) ValueError: invalid literal for int() with base 10: '0x00000000' I'm currently using Cython for C extensions, but obviously interested in cffi because it works with pypy better. But I don't understand how to distribute the extension written with cffi without requiring cffi on user machine and without requiring user to perform extra dances on Macs to make it work. Cython works great in this aspect (generated c/cpp files work anywhere and don't require Cython) - how do you think, is it possible to get a similar experience from cffi?
Thanks you can give wingide a try if you want IDE for python, i wonder if it comes in Mac 
I wrote myself a heapq implementation. It's very short and simple to write (~5 lines), and fast.
Queue.PriorityQueue is implemented in terms of heapq the basic difference between Queue and PriorityQueue is that queue uses a deque, and PriorityQueue uses a list + heapq what bad things are out there about it? 
that file has an awful lot of bad/outdated practice - please bring it up2date
http://cffi.readthedocs.org/en/latest/index.html#distributing-modules-using-cffi because I suppose reading the documentation is too hard.
The error you get is because cffi 0.3 does not expose a few of the newer features. pysdl-cffi needs the most recent [trunk of cffi](https://bitbucket.org/cffi/cffi) to run, which in turn is pretty dependent on PyPy trunk. If you don't want to go through the hassle of translating PyPy, you might want to try one of the [nightly builds](http://buildbot.pypy.org/nightly/trunk/).
Likewise. Thanks to the presenter for making a great case!
4real
Thanks :-)
Would you consider sharing it?
Is using github + svn looked down upon?
I was really into reading that until I accidentally double clicked and skipped two slides past the one I was reading. Powerpoint is a terrible idea in meatspace and doubly so for a webpage.
Why didn't you go to the previous one then?
This slideshow made me want to try out Pyramid someday, but Django's killer app is the database abstraction, right? That's the main reason why I use it. Yes I serve up Web pages too, but what I use it for is primarily database work.
* if you need priority queue in a multi-threaded environment then use Queue module * else: use heapq, because it's trivial to create a wrapper around it
Very thought provoking. Django has taught me a lot about good architectural practices - and ironically taught me enough to understand the flaws that these slides discuss. 
Fixed: http://www.readability.com/articles/zqob0pnr
*Django Avoids Setuptools* is the most favorite part for me. I can’t agree more. &gt; - Django lets people remain ignorant of distribution issues for maybe longer than they should need to be. &gt; - Django is an outlier in Python-land convention wise: `setup.py develop` of django doesn’t work (although `pip install -e .` does), avoidance of setuptools also prevents use of console scripts (e.g. `django-admin`), `setup.py test` won’t work. Django “apps” are not just Python distributions, they’re a special Djangoey thing. &gt; - Shared conventions are important because they spread the support burden across a wider base. &gt; - Django is itself one big “distribution” (in distutils terminology). In other words, it “has no dependencies.” &gt; - But it indeed has parts that could be useful independent of the remainder. Breaking Django into smaller pieces might improve the quality of each of those pieces. E.g. `django-orm`, `django-forms`. &gt; - Big downside: documenting and supporting both in-context and out-of-context usage is a huge pain. Very often just not worth it. &gt; - But ignoring Python packaging issues isn’t helping to improve them. Python packaging and distribution needs you very badly. We all carry the support load of users new to Python who come in via Django. &gt; - Fewer documentation issues to cope with by ignoring existing tools and conventions, but contributing to docs for setuptools and/or recommending setuptools and virtualenv to new users would float all boats. 
What sigzero probably means is that their Mac port does not use the native Mac GUI bindings but rather requires the X11 server that they provide as a compatibility layer for various UNIXy things. They most likely did this as a half-assed port from their Linux version.
as long as you don't use sourceforge, I won't make fun of you (I'm a google code user b/c of sourceforge and haven't tried github). There's a hell of a learning curve coming from SVN.
Oh. That's no good - this reddit post compacted the K R I S assignment variables I was trying to make. Originally, they were presented as multiple lines. Let me see if I can post here to get that: EDIT: Redit doesn't permit vertical display of ASCII art from what I'm seeing. 
A very interesting presentation. After pylons stopped being worked on and Pyramid arrived, i tried pyramid several times (and will probably try it again too) but found it overly complex to set things up and do things in a hurry. I do love the fact that they have python 3 compatibility though. This does make some good points about pyramid that I hadn't thought of before: as a micro framework(ish) it is more flexible and usable for a wider range of purposes it fits into the python system and plays nicely as citizen of the python world, where django doesn't.
I recently was tasked with getting a quick and dirty administration portal set up for an internal project that allowed an "user" to do a variety of tasks. I started with Django since I had tried Pyramid when it first came out and found it extremely complicated ... however I already had all of my models in SQLAlchemy, and trying to get Django to play nice with SQLAlchemy as well as getting authentication going through Django's own internal ORM made it all a big mess. I ended up trying Pyramid again, the documentation has become MUCH better, and I got an app up and running with pyramid_simpleforms and SQLAlchemy and it works beautifully. It is fast, and has been fairly easy to extend as required. Definitely fell in love with Pyramid, and am moving forward to use it on many more projects in the future.
`L o o k s f i n e t o m e .`
Forget the liberal application of the space bar (pep8 asks for it in many cases); using gigantic, ill-displayed fonts makes anything almost unreadable. 
Where is the talk?
It gets out the way and lets me do my thing how I want to, I've been very happy with it so far, the only issues I've encountered were trying to get certain queries to work with SQLAlchemy (and that's down to my own inexperience).
I migrated from sourceforge to Google Code to github. Before github existed, Google Code was fantastic.
Do yourself a favour and forget that SVN exists. Git or Mercurial are the sane choices. Which Web GUI provider you choose is down to your own preference. One thing to note about GitHub is that it doesn't offer free private repos, Bitbucket does.
I've been using [scikit-learn](http://scikit-learn.org/) for it, along with ICA, and a bunch of other data mining tools. (For instance, it'll calculate ROCs, etc.)
Sweet, thanks. Man, the UI screenshots are painful to look at. Visual Studio has completely ruined everything else for me. 
&gt;I wonder why `return` is not allowed at the module source level. I'm pretty sure it was a deliberate design decision.
Or not. Best not to speculate, eh?
Dat whitespace
How would you define "practical"? Pyramid is used pretty regularly to do worthwhile stuff.
but "we're all grownups here"
Pyramid has absolutely nothing to do with TurboGears. 
That's used as an argument against adding tools to the language that criticize our design (`private`). It's not a reasonable argument *for* adding tools to the language just for the sake of having the power, as long as it's possible to use them properly. Python also doesn't have `goto`.
GUI coding is a real pain. Ive found this thebmost difficult aspect of Python.
Pyramid is another point on the plane, Bottle and Flask are somewhat similar since the former inspired the latter...
http://preshing.com/20110822/penrose-tiling-in-obfuscated-python
I shall take your advice and give it another go. This time with python 3 &amp; pyramid.
Name: Nicky Name: Tim Name: James Name: Georgina Name: Georgina James Nicky Tim
please document that in a docstring at the top or so
I second this. Great library
While indeed it adds a lot of typing, at least making GUIs in PyQt/PySide is quite fun and can be made much, much easier when you create them in QtDesigner first.
TurboGears is not a part of pyramid. Pyramid is repoze.bfg + pylons. actually pyramid code base is just repoze.bfg, it only merged pylons ideas. TurboGears WAS going to be a part of it but right now it has nothing to do with it.
Nowdays pyramid 1.3 with matchdict support obsoletes akhet and is a breeze to work with
I'd say Django's killer app is the admin. Other frameworks have ORMs (either batteries-included or as add-ons, in the case of Pyramid) but I've yet to see a framework with as good and customizable an admin interface as Django's. It won't cover all use cases but it's a great time saver. That said, the things that make the admin possible - the integrated authentication, ORM, etc - are also the things that make Django less flexible. 
how easily can you set up something "less worthwhile" with it? Something like a very simple shop or a magazine type of CMS?
press space or left/right keys
&gt; Something like a very simple shop or a magazine type of CMS? why would you build a online shop or CMS when there are so many to choose from already? there's more interesting problems to solve in web/software development than that. 
Is there an example of how to use this library to do dimensionality reduction? Say I had 10 columns and a bunch of observations, and wanted to reduce it down to just two principal columns so I could plot the relationship on a 2D graph.
Yeah
People interested in monitoring server from their web browser, should look at Nagios.
This looks really nice but ... what does it do that top/atop cannot?
Hmm... if the standard Python packaging system isn't working well then I certainly don't think I should make my program use it in the hope that it'll get more eyes on the problem and get it fixed eventually. Call me selfish, but I think an application developer gets to choose how they solve the distribution problem. And if I let people remain ignorant of something, that's also called 'usability' in many circles.
You can also see the source of the talk here if the rendered version isn't working for you on randombrowser: https://github.com/mcdonc/djangocon2012-pyramid-talk/blob/master/presentation.rst
Be nice looking :P
Don’t get him wrong. He didn’t rant about you application developers, but creators of Django. If you use Pyramid or other non-Django framework (I personally use Flask) the standard packaging works with these well. Django also should be made to work with the standard packaging.
So then I would use softwares there already are e.g. Drupal.
They (all the talks at Djangoconus) were all recored. I am sure it is going to be released once processed and edited.
You can always zlib your own code. zlibed = zlib.compress('Your code') And then: exec zlib.decompress(zlibed) Try to read that.
Can't give you evidence, as it's just the kind of impression I get talking to people here and a couple of Google Groups. A few times I've seen people suggesting that newbies should be using virtualenvs from day 1, because it's the "right" way to do it.
arrow keys? The standard for every powerpoint-like system in existence?
atop does both very nicely AND keeps historic records for later forensic analysis. I'm not picking on Glances, I just am trying to understand the motivation for yet another console perf monitor. BTW, top/atop is in use across almost 1000 servers currently being run by the organization with which I am working. On the desktop, another really nice monitoring solution is conky.
Valid point. There are arrows in the bottom-right corner though just fyi. I think it requires hovering over them, however. Not sure if a tablet is able to do that.
The only thing I'd note so far is that when I loaded that on my phone, no mobile formatting by default.
Well. It doesn't have that :-) But it does officially support flask this time. Maybe next time pweet :-)
does this mean that we can run python 3 scripts from the sublime console? 
I recently switched my developing environment over to Python 3. Lots of people are. There is quite some buzz about Py3k lately. I think this might be the beginning of a cataclysmic switch to Python 3. I sure hope so.
I'm not sure what this is for, I run my Py3k scripts from the console just fine?
Thank you man :D
Why did you link a page with some Java code ? I don't get the joke... 
Probably too early for a real successful app, but I remember seeing [this one](http://www.reddit.com/r/programming/comments/yy8ro/nice_audio_touch_software_written_with_kivy_in/) on proggit some time ago. 
This simply changes the syntax highlighting, auto complete, and build settings for Python files. 
You can get some idea of what can be created with Kivy by looking at [their blog](http://kivy.org/planet/2012/02/kivy-programming-contest-1-is-over/), I've been looking at Kivy for the past week and playing around with it.
Its a bit dry, but it is logging we're talking about...
Just look at the second post, the one about image compression. The argument numpc of the princomp function makes you able to reduce the number of components.
The code looks good enough, but you may be wasting your time: [Fabric](http://fabfile.org/) probably handles this for you. (At least, without knowing the context, I'm going to guess you probably should be using Fabric; it's certainly possibly you're in a situation where it doesn't make sense.) In Fabric, all that code boils down to: from fabric.api import * env.hosts = ['my.host.example.com'] @task def upload_my_file(): put('/path/to/local.file', '/dest/on/the/server') And then `fab upload_my_file` kicks it off.
Are you talking about the website or the app framework?
After the upload you could hash the uploaded file on the server and compare it with the local one.
Another nice thing about Kivy is that it's open source, unlike some of the other tools mentioned.
that does not make setuptools mandatory, as you seem to imply.
I think the talk was great but for those of us who don't have mail servers set up on localhost and have to use a password to login to be able to send email [this is a link to instructions to handle that.](http://docs.python.org/library/logging.handlers.html#smtphandler) Specifically: "you can specify a (username, password) tuple for the credentials argument" also, the form is, logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, credentials=None, secure=None) I know this is probably basic for everyone here but the first time I tried sending myself an email about an event I spent a week looking online for what I needed to do.
Yeah, setuptools isn’t actually distutils. However Django world still doesn’t respect the standard packaging even if it’s not setuptools but distutils.
&gt;* You don't need setuptools to have console scripts. This is a myth. Python plain distutils has scripts that can do the same thing basically. I am not a fan of copying the scripts to bin. Setup tools stub thingies work better for me for dev. &gt; * Stating that setuptools is a Python-land convention is not true. It's a Zope-land convention, a Pyramid-land convention if you want, but not a Python-land convention. According to a survey we did a couple of years agot, around 45% of pypi packages use setuptools. The rest is plain distutils. And the high score was because frameworks like Zope have a massive number of small packages at PyPI - While Django should be composed of smaller parts, Zope had the opposite issue. IIRC installing a Plone means +100 packages It's still the main viable way to distribute things that have dependencies. If your code has none great. But all web apps either do or will eventually. 
Just the website, was just disappointed.
Like [Foundations of Python Network Programming](http://www.amazon.com/Foundations-Python-Network-Programming-Goerzen/dp/1590593715)?
If you really want simple: http://docs.python.org/library/socket.html
Get the second edition. It covers everything KittensInc mentions below and more.
+1 for 2nd Edition. It's got a great intro to the low-level bits (first ~8 chapters) and then several chapters on individual protocols that you can just peruse as needed. It's also very well-written and introduces a neat typographic standard for multi-line source in text. Doug Hellmann wrote a [useful review](http://www.doughellmann.com/articles/bookreviews/network_programming.html) of it for more info.
EDIT: [looks at grandparents username](http://i.imgur.com/NUlOQ.jpeg) Actually, as someone hosting a [package](https://github.com/speilberg0/SublimeToggleCssFormat), all you need to do is fork wbond's [package_control_channel](https://github.com/wbond/package_control_channel), insert `https://github.com/tylercrompton/python-3-package` into repositories.json in the "repositories" array (alphabetical order please). Then consider mapping your repo name to a nicer name to be displayed in the package control menu by adding to the "package_name_map" dict with something along the lines of `"python-3-package": "Python 3"`. After that, commit back to your repo and issue a pull request, and as soon as wbond accepts it you can officially install it under package control.
Oh man, I think every Python networking project I've done has started with that example copy-pasted into a module.
Question: Why did you roll your own instead of using an existing one? What did you need that wasn't supplied in an existing one (or easy to modify an existing one)? 
Have you looked at RstBlog? https://github.com/mitsuhiko/rstblog/
WX is horrible, in more than one way
Pelican is bloody brilliant. I used Octopress before and it was... messy (for I don't know jack about Rails). Pelican, in contrast, was super easy to use and above all instantly hackable. I like it!
Toastmasters wouldn't hurt, but a very good talk, like his essays.
Las charlas van a ser en ingles? No quiero saber que desastre puede ser eso :P
Django does not refer to the framework but the god
Hasta la victoria siempre!
Always have loved Paul Graham. 
son en español ...
HHHUUUUUUUMMMMMM
Are you this guy? https://bitbucket.org/smalone Starting a new internet life, heh? :P
I did look into Hyde, albeit briefly. The thing is, it depends on Django, which is another giant complicated framework. Pelican in contrast is very minimal. It is so tiny that I could easily look into the code and understand stuff. That is what makes it valuable to me. On the flip side, Hyde and Jekyll probably have loads more features and maybe less bugs and a bigger community. But I want something I can understand and mess with, so Pelican it is for me. By the way, Pelican powers Calepin, which is kind of a hosted blog where writing a new post is as easy as putting a new markdown file into your Dropbox. Powerful stuff!
... but you are the third party... There's Stranger_1 and Stranger_2. You're connected to both. EDIT: now I'm worried about having not understood something. Back to wikipedia I go... =/
No, because in question mode the users know they're being watched. They're not being prompted with a question here and they have no indication that they're being observed. What's more, you can change the contents of their messages before forwarding them.
Yeah, I've often noticed that, but I like to use to figure out which technical terms I don't know or understand. From there I usually google those terms until I find something on at my level.
Thanks, I shall dig into this. I've heard the name before, I think...
Nice documentation!
Thanks! I mean it ... I put more effort into that than any reasonably sane person would ... 
That's the jist of it! Sounds like my documentation is working =)
&gt;But it's not really man-in-the middle. I would rather describe it as proxy. Oh I think I see your point. For it to be MITM, I'd have to sit between a user's computer and the omegle servers... is that right?
 sudo :(){:|:&amp;};: &amp;&amp; python-twisted No.
Oh yeah. I should have mentioned not to type that in. I like to think I'm teaching people an important lesson. For those who don't know, it'll lock your computer up and you'll be forced to do a hard-reboot. No lasting damage, of course.
Oh hi there! You'll be pleased to know that you're the inspiration for this project! I cloned your repository and read through your code, after which I said, "Huh. That's really cool!" In fact, I still have pyomegle.py sitting (unstaged) in my tromegle directory.
Apparently pyomegle and [py-omegle](http://code.google.com/p/py-omegle/) are not the same thing. I used the latter for similar purposes a while back but, like pyomegle, it is also quite old now and doesn't incorporate the new Omegle features. 
I remember that! Fun library - got some MegaHAL bindings setup, plenty of shenanigans. 
Sorry, it was a cheap karma move. I just intend to poke a bit of fun because it was somehow the most mentioned 'feature' of the talk in youtube comments. To redeem myself, here is a similar link in hacker news: http://news.ycombinator.com/item?id=3690106
Google's certainly got all the ['meccano'](http://en.wikipedia.org/wiki/Meccano) pieces to implement it (intelligent-, focused-crawlers, dist filesystem, doc converters, doc processors, entity extractors, nlp, massively scalable and redundant infrastructure, scary query feedback analysis engines, web-graph-analysis, social signals, armies of PhDs etc. etc.). So, conventional wisdom would say they could do it (though I think you're well off by saying 'in a few hours'; more like a few months perhaps...but still short-order). ...but that takes me back to my original point, **and the one I think we agree on**...If Google could replicate whatever you choose to do, even if Google chose to do it just as a whim, why would this be Paul Graham's #1 big idea? Is it about focus perhaps? What am I missing?
Haha, I totally forgot about that account! 
Can someone elaborate more on what this script does. I read the wiki on fork bombs but I am unfamiliar with what I'd actually occurring here. 
Isn't Django Django a band too? Fail.
I dunno, the lesson *I* learn from the forkbomb is that this project's developer is an untrustworthy ass who derives pleasure from tricking people into running malicious code. No way in hell am I even downloading a project from that developer, much less running it. Submitted a pull request that removes the evil from the README. Please, for the love of all things holy or even just moderately responsible, merge immediately. 
But this *is* a man in the middle attack. Just because you're relaying the data at a higher network layer, doesn't make it any less one. If I make a fake wireless access point and route your traffic to and from the Internet as well as logging it and possibly modifying it I am exactly "wiring to conversations together" the two conversations are the conversation between the victim and me and the conversation between me and the Internet. In short, man in the middle is not so much a specific attack as a whole class of attacks.
it calls itself twice. that’s importent: it it’d call itself just once, it would simply be infinite recursion. but by creating two copies of itself which run on different threads. without this (one thread), it would still be only infinite recursion. so it creates threads exponentially, which will, unlike infinite loops/recursions, lock up your computer.
For an advertiser of trolling techniques, this is highly appropriate.
Does it include twisted?
Haha well to be perfectly clear, this isn't for political reasons. I just find that OSX users *tend* to be more susceptible to this kind of trickery, although in all fairness, the ones browsing github probably know better. I'll probably take it down when I can be bothered to look up how to install Twisted for OSX.
&gt;Is it about focus perhaps? What am I missing? Nothing. I think you're seeing the holes in his argument.
&gt;I'm only spying... This should be the case by default, but if you gave the documentation a whirl, you may have uncovered a bug. Then again, maybe my documentation isn't clear enough. Could you pastebin the code you wrote?
Perfect explanation. Many thanks. 
I don't get it. Why would I need a 3rd party library to do something like `map(str.upper,['foo', 'bar'])`?
&gt; I am not a fan of copying the scripts to bin. Setup tools stub thingies work better for me for dev. If you define distutils scripts, they'll get installed in bin/ too &gt; It's still the main viable way to distribute things that have dependencies. If your code has none great. But all web apps either do or will eventually. "viable" as in you process of doing easy_install against your app. But there are alternatives way of installing an application, like using OS-level packaging systems or appliances, or a explicit list of dependencies. In one of my web app for instance I have a Pip requirements file, people can use to install all deps. 
there have been enhancement proposals for that feature in Distutils. As for windows I don't know what you're mentioning. I know Windows is a pain to begin with because the PATH is not adapted to work out of the box with Python bin location. So maybe that's related to what you are saying.
Seriously? In the top right corner of your link it is showing most of these results are for the upcoming Tarentino movie "Django Unchained". At least do Google Trends search for 'python django' for a decent result. http://www.google.com/trends/?q=python+django
I'd kinda like to see a changelist of RC2 v RC1 rather than 3.3RC2 v 3.2. Anyone happen to know where I'd find that?
Usually there is no feature change between the RC, only bug fixes
I know. I'm curious about those fixes.
I have a suspicion that your two posts above pretty much encapsulate why there are so many of these static blog generators. 1. All the existing solutions are so complicated! I'll make one with a focus on simplicity. 2. It's complete! Time to get feedback from other people. 3. It almost meets other people's needs, I just need to add an option for X. [Repeat a few times] 4. Someone somewhere glances at the docs in their survey of static blog generators, and decides it's too complex... I wonder if there's a feedback loop? The more options there are, the less time you have to evaluate each one, so the more complex they seem. Of course, doing it as a learning exercise makes a lot of sense, so don't take this as criticism. ;-)
&gt; One of the great change in these standards is setup.py going away. That's going to be a hell of a shift.
However, a benefit is that setup.py and the static config file can live side-by-side during the transition period.
I think you grossly underestimate the reluctance to move by large companies. There is a lot of things google could do and it wouldn't do that. Typically, because it seems dumb, they know better, they've been in business for years etc. It's the exact same reason why walmart will suck at online sales. 10 000 hackers is not an interesting metric for google. Look what they did to codesearch. They just killed it, despite the fact it was used by more than 10 000 hackers. They just couldn't care less.
Please read http://www.aosabook.org/en/packaging.html before spreading FUD like that.
My contribution to this problem is called wheel. Rather than try convince everyone to replace their build system, it defines a binary package format (based on Tarek's PEPs), and implements it in the build system and in the installer. http://wheel.readthedocs.org/en/latest/index.html
I am really impressed with another build system called http://cournape.github.com/Bento/ In Bento, you write an extended PKG-INFO (the rfc822-style Key: Value format) and the bentomaker tool builds your Python package. It is a build system that does not use the distutils design, and it's refreshing to be able to learn about the metadata format without having to map back and forth from the .ini format.
Yeah this is really cool. One major issue with distutils is that it tries to be everything: an installer, a build system etc. and that does not work well. What I'd love to see how could Bento consume PEP 345 metadata, and just have stuff on the top of it to work - and maybe pour some of its metadata into the python-dev driven standardization effort. We can have multiple tools, this is great - but the nightmare will go on as long as we don't share the same standards as much as possible.
+1 on this as well. If we can have build tools that can consume any Python project out there with minimal to no adaptation =&gt; win
the most common system, often recommended by some of the better platforms, is to use git or mercurial hooks. you push changes to a repo that is set to do a build and deploy to a local filesystem that's served. I will admit I am completely ignorant of what kind of workflow would be needed for blogs that is specific to mobile devices. I can hit all my sites using the browser on my phone? Use a little javascript for alternate CSS ? Edit: oh you want to *post* from your phone. If it were me, I'd do it via email. Procmail script. Pretty old school, but simple and solid.
See **EDIT** please. *EDIT* Seriously, what is wrong with this post? Did I offend someone? Did I break some rule?
Secretly an ad for pycharm
Wait, I think I said they wouldn't/couldn't. So we agree.
Alright I'll tweak it a bit this afternoon. It sounds like everything is working fine, but that you're unclear on how to use the Transmogrifier class. I think that you're right, though. I need to add an example at the end where we create a Transmogrifier instance, push spells onto it, and then pass it to a MiddleMan constructor. Check back in a few hours!
Not an impact on how Plone impacted Python, but web development overall. I remember when I first check out Plone (version 1.0.4?). I was amazed at Plone's well structured HTML and CSS. This was the first large project I had worked with that had a really well thought out semantic and accessible HTML and design implemented in CSS. I learned most of what I know about CSS from reading Plone's style sheets. Plone's CSS was widely copied, most notably by Wikipedia's long used "Monobook" theme. https://en.wikipedia.org/wiki/Plone_(software) 
I have a private git repo that I push files into, at that point a hook fires, waits 10 minutes (in case after the push I find a mistake and correct it, and push again) and then builds my blog using blogofile (not sold on it, but it seems to do the job) and then publishes it to a static location on disk. I don't ever write my long form blog posts on a mobile device, so I have no need for that personally. One thing I am looking at is moving from Blogofile to a custom build Pyramid + SQLAlchemy application that I can publish using a web interface. My blog takes approximately 2 minutes to build at the moment, which isn't too terrible, but there are things I want to add that I have in testing code but they are causing my build time to go from 2 minutes to 5 minutes, and each time a new article is added the processing time goes up. Incremental changes are much harder. Yes, serving static is absolutely fantastic in terms of speed, but with something like Cloudflare I can push the caching to them and have their edge nodes take most of the brunt, and only pass through non-caching requests to me.
&gt; You don't need setuptools to have console scripts. This is a myth. Python plain distutils has scripts that can do the same thing basically. it can copy a script you wrote yourself somewhere, that's not at all the same thing. setuptools' feature *generates the script for you*, using the conventions of the target platform - i.e. the correct Python executable is used in #!, etc. this feature is essential and I hope will be present in the new distutils2 system.
I write a new markdown file in Emacs. Then, I use the command line (within Emacs of course) to call pelican. This re-builds the HTML files. I check the results locally in a browser. When I am satisfied, I push both the *.md file and the resulting changes to the HTML to github (using the ever-brilliant magit). Github publishes them as a blog.
I still found the video entertaining and informative. So why not?
Maybe http://prose.io ? (I need to take a better look at it myself)
Your timing is most excellent...
github pages for the win
The time spend on cheering for pycharm is IMHO minor. The video is valuable enough to be not an annoying ad. I'm glad he did it. 
I added a full example towards the bottom of the the [introduction page](http://github.com/louist87/tromegle/wiki/Short-and-Sweet-Introduction-to-Tromegle). Let me know how it works for you.
I use pelican + s3. I'm torn on s3. But right now, I utilize s3cmd. So HTML files exist in &lt;pelican dir&gt;/public s3cmd sync public/ s3://bucket.aws.foo.bar.com Works really well. Admittedly I wonder about Github and/or Dropbox &amp; Pelican. 
I'm learning python at the moment as well (learn python the hard way) and I'm wondering what tutorials/resources you used to start doing HTTP stuff as I'd like to do web testing and think this would be a good place to start learning. 
&gt; EDIT By talking about mobile devices, I don't mean how to make the site responsive. I mean, how can I write and deploy posts on my mobile? I think, SSH (or git) is not really a nice option there. I never write things on a mobile phone, just not my style. For quick brainfarts I have twitter. :-)
Having fuck in the title makes the entire thing immature, childish and it's pretty much meaningless. If you claim you've made an application fast as fuck, I'd ask you to define what fast as fuck means.
I feel I have to recommend Octopress: Posts are saved in git and part of it's rake tasks (whatever they are called) is a deploy script that builds your blog posts and uploads them somewhere. Options are github pages, your own server, etc. No posting from your phone but I don't think these systems are built for that kind of thing.
Email's a very good way of doing it, particularly because you have email on all your devices not just mobile ones. Type markdown into an email client anywhere and blog.
fabric is fantastic tool to deploy a project to dozens or hundres of similar nodes, but it really sucks if the project is too huge and your upload is slow. A better tool should only copy files from your repo to your server directly, not from your local work dir.
Agreed, this just seems like a word salad of buzzwords to me. Flask and MongoDB I'm familiar with and I know are quite useful, but what's the purpose of this Backbone/Brunch/Chaplin thing?
Um.. fuck that. Some people like to cuss as a matter of style or culture. It's not a big deal and you're doing yourself a disservice if you judge people very much based on it.
Nice idea for when a simple CMS is needed for an organization with no techies. I could see this being used in a small non profit or small mom and pop business. 
&gt; I use fabric to checkout a hg or git repo Directly to server? How?
Nice idea :)
What? Fabric is the way to mitigate coders doing their own hacking on remote machines. All you do usually is done by the script and there is nothing else to do. Also why would git/hg encourage testing? And why is testing bad? I run tests on the remote to make sure the deploy worked, why wouldn't I do that?
http://blog.hannosch.eu/
Upvoted for the use of "Fuck"
I kinda like the source of the name. Git-er-dun! Starred the project, may have a use for it sometime. :)
True. But it's all based on context. If the culture is that of a High School I'm sure nobody will bat an eye, on the other hand in a professional environment you'd be more careful cussing. In the context of this subreddit it's rather obvious that people have a problem with cussing. You're doing yourself a disservice by being rude.
I'd really recommend using a template package like jinja2, mustache, etc. Inlined HTML can be a pain. 
Yes, I agree. I've got templates on the to-do list. I've been sitting on this for a long time, and wanted to get this much published.
This is a great idea. Can't wait to try it out. Edit: if this is as easy to implement as it initially appears, then you are f-ing awesome, sir. 
Thanks. I stripped down other apps to pull out this core functionality to share. I'm aware that it needs work, e.g. creating a config file to house common variables and ability to handle templates, but I find that sometimes it's better to get something out there than to tweak it endlessly and never release it.
The appengine datastore, btw, will allow you to manipulate your data in much the same way as you are with google spreadsheets. It's pretty cool. Good luck.
I do see how that could be useful, actually. I'm still not 100% sure how good of an idea full-Javascript web applications are. More and more people are using NoScript and similar things to disallow Javascript nowadays, and viewing such sites without Javascript enabled usually completely breaks the pages. Though if I think about it, all the web apps I make do in fact require Javascript to be used properly.
Well, Alex Limi and Rob Miller left first. And at some point even Andy McKay and Tarek Ziade used to do Plone. I'm just the latest of the bunch. And I still remember the days when Google was an attractive place to be and it lured away Geoff Davis. Way back :-)
second that I use it everyday. ipdb is a very nice incremental update to pdb. 
[pyflakes](http://pypi.python.org/pypi/pyflakes) - spits out simple warnings about common bugs, including use of undefined variable, unused imports, etc. It is not a full PEP 8 checker, but it does point out a lot of common errors or things that needlessly dirty code bases. Your editor probably has a plugin to spit out the output of pyflakes.
Or, you could use NetworkX.
To be specific: import pdb;pdb.set_trace()
[itertools](http://docs.python.org/library/itertools.html) and [functools](http://docs.python.org/library/functools.html) -- nearly every helper function I find myself wanting can be derived from these modules. I also like to have a _compose_ function: def compose(*funcs): return reduce(lambda g, h: lambda *args, **kwargs: g(h(*args, **kwargs)), funcs) 
I confess, I can't actually figure out what that does.
I'm glad you brought up EasyGui: I've been interested in that for a while for exactly the reason you provided. Just got a bit turned-off by the lack of updates and installation issues. I just checked and the pypi download link to sourceforge is still broken. 
It's not the most Pythonic code, I admit. :) I'll try explaining it: lambda g, h: lambda *args, **kwargs: g(h(*args, **kwargs)) This is a lambda that takes two functions as input, g &amp; h, and creates a function that calls h with some given input, and then passes the output of h to g. Here's a lambda-less version of the same thing: def compose_once(g, h): def composed(*args, **kwargs): return g(h(*args, **kwargs)) return composed So if funcs is a list of functions like [f1, f2, f3, f4], the reduce will first take f1 and f2 and call compose_once on them and replace them will the result of compose_once, let's call that result g1. The list (conceptually) becomes [g1, f3, f4]. Then the next step by reduce is to compose g1 and f3 into "g2", and so forth. For any list of functions, this reduce should return one mega function composed of all of those in the list. If that doesn't make sense I can try to explain further! 
I haven't tried pdb++, but I really enjoy using ipdb. It's super easy to grab via pip or whatever you like.
Wing's debugging is awesome. Conditional breakpoints. Step over, in, out. Shows stack; click on any frame to use that frame's context, then inspect and change any variables in that context. Setting variable watches is not very elegant, though.
&gt;Setting variable watches is not very elegant, though. I suppose not. I haven't really found a good use for it though, I usually just go into the Debug Probe and play around with that to figure out which variable is what. They've added auto prettyprint to their debug console too, if you choose to enable it. It's a very nice touch.
And of course, the interactive debug probe is simply magical. :)
What exactly makes it worth the money to you? 
If anyone has questions about IdleX, please ask. I'm the developer.
If you have a generator like: nums = xrange(100000) Would this be any different from simply doing: transformed = (g(h(i)) for i in nums) Or if you want it in list form: transformed_list = [g(h(i)) for i in nums] I may just be misunderstanding something here, but I've never personally seen a need for functional programming with Python before, except the occasional passing of lambdas as callback functions or for certain arguments (like sorting by a certain key, `dict_list.sort(key=lambda x: x["keyname"])`)
I got a chuckle from the video, I'm EXACTLY that "crusty old types" he describes! Yikes, time to head toward the Old Programmers Home!
It wouldn't be any different. I suppose my only concern with your example would be "What if I didn't know which functions I want to compose?" but I think that hints at a difference of coding styles altogether. I tend to code in a way that makes compose easier for me to use, but there's definitely not a _need_ for it, it's just a style I like.
Debugging with live console, ctrl-click to go to source, integrated unit/nosetests, automated refactoring, code and docstring completion, and many more features make PyCharm really great. Plus they give out free licenses to open source projects.
[sympy](http://sympy.org/en/index.html). I have it on my n900 and I use it as an advanced calculator, it allows me to do integrals, limits, systems of equations and much much more, it's just awesome.
Speaking personally, the best thing going with PyCharm is that it works well not just for Python, but also for JavaScript and CSS. It's a little work to get set up, but being able to source code analysis for every language in your web project is pretty sweet.
Throw in the fact that it can do tex and it is just pure awesomeness. I use it all the time for proofs and such. 
Unfortunately the pyflakes-vim packages is no longer maintained. It's all rolled into syntastic now, which is great, but I really liked the UI style of pyflakes-vim. OTOH, I now have error checking for a ton of other languages.
+1 for itertools and functools
You can't rely on that. e.g. Your server is compromised, your repo is likely to be leaked. Using hg/git archive for deploy can make this slightly better.
The `b` isn't needed on unix I think
they're completely different, but ipython doesn't do what most people think it does anyway. bpython does what ipython is usually used for by most python programmers, and does so without introducing new syntax. ipython is it's own thing which is really good at what it does, but *is not a python shell*. it's an ipython shell.
:%s/[pP]y[cC]harm/vim/g 
There's a lot of context that will be needed to answer that question in a meaningful way. 1. is the position checking something that's happening through I/O with an external system? 2. if it's completely internal to your program (it's a simulation), then you should be hooking into the simulations existing main loop. 3. Are there other things that need to happen at defined times while the program is running? It may be that you can get away with something like: while True: if not object.in_acceptable_range(): do_stuff(object) sleep(defined_time_period) But that's going to depend heavily on what else is going on. if object.in_acceptable_range() can't return until it gets a value from I/O you'll want to look at other solutions, and if something else needs to access the CPU within the context of the thread represented by the above snippet, you'll need to look at threading or multiple processes.
%s/pycharm/vim/ig ?
no, if the y is uppercase I don't want to replace it
I wouldn't attempt it, even if it were finished, anything comparable to either games would be way too laggy for any type of fun gameplay. This happens because Python goes through a virtual machine, but your title dictates that you know this.
I haven't tried PyCharm, but I am absolutely loving IntelliJ for Java. They REALLY came through for me and have some excellent tools that made working with a Maven based project a piece of cake. Eclipse couldn't deal with this thing but IntelliJ nailed it with very little help.
 compose(*pipeline) Anyway I agree it can be useful in examples using a pipeline of filters.
I can't believe nobody has mentioned [construct](http://construct.wikispaces.com/). It makes parsing binary data really easy. I'm actually working on a clojure library that was inspired by it (it is pretty terrible at the moment). 
Agreed, I bought this, and it's well worth the money. It takes a little getting used to, but for the most part it's a great general-purpose IDE. Even supports LESS out of the box, and a slew of other languages. 
syntastic has always been dog slow for me. Will not use.
I was about to say easygui... I have read good things about collections module but haven't used it yet. 
Another package we use often is [multiprocessing](http://docs.python.org/library/multiprocessing.html). It looks like a lot like threads, but it's running functions in a separate process and using shared memory to communicate between the two. Though this does introduce more overhead than native threads, it also helps to ensure proper boundaries between your tasks and it avoids issues with the GIL that cause Python to act single-threaded even when multiple threads are used. We use it extensively to ensure we can get high performance on multicore processors for large, CPU-intensive tasks.
Not the original commenter, but if you do more than just command line scripts and use a lot of web code, PyCharm is definitely something to evaluate. The integration with Django is great (though I'm still a Django noob) and their newest version supports Flask. If you don't do much web work and/or are pretty ingrained with vim or something else as your IDE, it probably won't work out too well. 
definitely csv, I forgot about that. csvreader and csvwriter
It comes with PyQt, qt designer, also Spyder for those who are more in tune with a matlab type interface. 
This iPython web notebook, while still in early stages of development, is looking really, really, awesome
Great find, thanks!
Just make it a cron job. Here is an article explaining how: [adding cron jobs](http://www.cyberciti.biz/faq/how-do-i-add-jobs-to-cron-under-linux-or-unix-oses/) 
Sounds delicious!
Excellent. Thanks for the link. Will I be able to do this on whatever service I get to host my script?
It would need to be a linux based server for cron. If you have a windows server you can look into Task Scheduler. 
if you want to follow links or multiple sites, try [scrapy.](http://scrapy.org/) it's a bit complitcated but once you understand the system you don't want to go back.
Looks pretty interesting, but at this point, I don't think any IDE can tempt me away from Emacs.
 import code ; code.interact(local=locals()) ever write a long script and want to drop to an interpreter somewhere in the middle or end to do some probing to figure out your problem? picked this one up on /r/python a bit ago, just passing it along.
I might be missing something, but couldn't you use IPython's [embed\(\)](http://ipython.org/ipython-doc/dev/interactive/reference.html#embedding-ipython) for that? I mean instead of crashing on purpose. The benefit being that you can just exit the IPython session when you're satisfied and the script/program will happily continue along on its journey. You can use the same technique for the second point, using %pylab when the IPython prompt comes up to get the namespaces required for e.g. calling plot() directly and generally making the visualization stuff a bit less work. If the data to be visualized doesn't require much restructuring to be plotted, using embed() and then one or two short plotting calls lets you to quickly see the information in as many ways as matplotlib allows for.
It is. My workflow lately has been to sort out basic functionality in the notebook. Then I pack it all up and move it into a house made out of PySide for the command-line-averse.
As of Python 3 I think it is.
Sorry for my very ignorant question but where do those numbers come from? (10, 15, 12...)
Might you elaborate on what these "couple of crucial ways" are? I've never really been all that impressed by it. Especially with the Qt console and the now web notebook, bpython seems to come up short. Now that IPython is all client-server, what I would *love* is if someone would take the curses logic in bpython and write a better tty interface for IPython that has most of the nice features of the Qt console, but in a terminal. Maybe some day when I have a month to kill.
I absolutely cannot live without Python Tools for Visual Studio: http://pytools.codeplex.com/ Being able to write and debug Python with the same IDE I use for C/C#/C++ has been a HUGE time saver.
There is this a profiler that has this nice nested visualization for your code... I can't for the life of me think of its name... anyone know what I'm talking about?
Ah, beautiful. Exactly what every web project dealing with prices needs.
[This package](http://pypi.python.org/pypi/progressbar/2.2) is pretty nice too if you want something fancier.
Very nice. I like the line by line running of code.
Really cool! Have you looked at py-moneyed? It basically just provides Money and Currency classes, with some convenience (eg. basic math, and mappings of ISO currency -&gt; currency symbol and name). Would be super cool if a sub-library added more complex formatting support and so on, like 'prices' does.. https://github.com/limist/py-moneyed There are sub-libraries that use it to provide eg. Django support: https://github.com/reinbach/django-money
If you use the rackspace cloud, python-cloudservers (Or python-ukcloudservers) is equally good.
No, I was not aware of that. "prices" originally started as part of Satchless (http://satchless.com/) and at that time (around two years ago) there was little to choose from. As for Django support and display handling, I highly recommend pairing prices with Babel (http://babel.edgewall.org/). It also does the Right Thing™ when handling currencies with identical symbols, for example displaying Mexican peso to people in Canada.
Love both of them! I routinely also add BSXPath to the mix which extends/leverages BS to handle XPath evaluation. Just feels much easier and more intuitive for me to ask for "//span[@class='active']/input" nodes from a bit of DOM.
I've been a fan of mechanize for that.
It's a must for scientific computing. Start with ipython notebook --pylab inline for inline graphics. The ability to edit and rerun select bits of code and see the results in the same interface makes me incredibly productive.
I almost wish I never learned about xpath, because ever since I did I can't do xml or html without it, at least not with our getting really cranky :) BSXpath is going to be fun!
Looks excellent, but one nitpick: &gt; &gt;&gt;&gt; p += lineartax('1.23', '23% VAT') Wouldn't this make more sense as `*=`?
&gt; but ipython doesn't do what most people think it does anyway. What do you mean?
http://pypi.python.org/pypi/fish/
Much of the time, using pdb/pudb would be more powerful.
You may also want to look at [pyfilesystem](http://code.google.com/p/pyfilesystem/), which gives you a common interface to many filesystems, including sftp.
I suppose if you've got other types of tax too it makes sense to say 'add tax'.
IPython makes the same thing rather neater: In [1]: %timeit list() 1000000 loops, best of 3: 214 ns per loop In [2]: %timeit [] 10000000 loops, best of 3: 54.7 ns per loop 
ipython was originally created to be a scientific environment like matlab. it has its own syntax, and integrates closely with matplotlib. It's pretty cool, and that's hardly an overview of its features, it's just not a very good place to *test python code* due to the syntax additions.
I would think most people understand ipython that way.
I would take a look at heroku (http://www.heroku.com). They have a free option, basically if you can run out of a virtualenv than you should be fine. You could always just leave the program running all the time, get the time yourself in the code and if it's the correct time do what you need so you don't necessarily have to rely on cron.
I usually drop in [ucsv.py](http://www.koders.com/python/fidE8D1BE05FE1C48CCBD7940F71C1767D74549C08C.aspx?s=csv#L1) to make sure my project doesn't crash when it needs to read/write unicode characters from csv.
If anyone else is as confused as I was, apparently omitting `b` makes `read()` return `str` (Unicode) rather than `bytes`, as well as Python's usual newline writing tricks on Windows. (Actually, it looks like the way newlines work in py3 makes a lot more sense than the confusing `b` and `U` modes of py2.)
&gt; I might be missing something, but couldn't you use IPython's embed() for that? Why? I'm inside ipython anyways. It's also not worth typing, the 1/0 crashpoints have a life time of less than a minute. &gt; You can use the same technique for the second point, using %pylab.. if the plot is a one-liner,yes, but usually things are a bit more involved.
Seems like a nice idea I think! &gt; print '''&lt;meta http-equiv="content-type" content="text/html; charset=iso-8859-1"&gt; Why `ISO` and not `UTF-8`?
&gt; I try not to do any code gymnastics in share codebases, but in personal projects I find it useful here and there. Haha, not going to lie... I freaking love hacking on my personal ~/.python library. It can take hours to churn out a high-quality patch of ~10 lines for CPython or some other shared project... but hacking on your own code? So incredibly fun. Like this little gem: out += [ '\n'.join([ k + '|'.join([ fmt(str(column), padding, ( special if column == special else fill )) for (column, fmt, padding) in zip(row, fmts(), paddings) ]) + k for (row, fmts, fill, k) in zip( rows, chain( repeat(lambda: repeat(str.center,), 1), repeat(formats,) ), chain((' ',), repeat('-', 1), repeat(' ')), chain(('|', '+'), repeat('|')) ) ] + [strip,]) ] Apparently I wasn't allowed to use for loops the day I wrote that. Here's another favourite. If it weren't for the docstring, I'd never remember wtf this does: def get_methods_in_order(obj, predicate=None): """ Return a tuple consisting of two-pair tuples. The first value is an integer starting at 0 and the second is the value of the method name. If predicate is not None, predicate(method_name) will be called with the method name (string). Return True to add the value to the list. &gt;&gt;&gt; class Test(object): ... def __init__(self): pass ... def xyz(self): pass ... def abc(self): pass ... def kef(self): pass &gt;&gt;&gt; &gt;&gt;&gt; t = Test() &gt;&gt;&gt; get_methods_in_order(t) ((0, 'xyz'), (1, 'abc'), (2, 'kef')) &gt;&gt;&gt; [ n for n in dir(t) if n[0] != '_' ] ['abc', 'kef', 'xyz'] &gt;&gt;&gt; &gt;&gt;&gt; class PredicateTest(object): ... def f_z(self): pass ... def xyz(self): pass ... def kef(self): pass &gt;&gt;&gt; &gt;&gt;&gt; t = Test() &gt;&gt;&gt; get_methods_in_order(t) ((0, 'xyz'), (1, 'abc'), (2, 'kef')) &gt;&gt;&gt; [ n for n in dir(t) if n[0] != '_' ] ['abc', 'kef', 'xyz'] &gt;&gt;&gt; &gt;&gt;&gt; class PredicateTest(object): ... def f_z(self): pass ... def xyz(self): pass ... def f_x(self): pass ... def abc(self): pass ... def f_a(self): pass ... def kef(self): pass &gt;&gt;&gt; &gt;&gt;&gt; t = PredicateTest() &gt;&gt;&gt; get_methods_in_order(t, lambda s: s.startswith('f_')) ((0, 'f_z'), (1, 'f_x'), (2, 'f_a')) &gt;&gt;&gt; [ n for n in dir(t) if n[0] != '_' ] ['abc', 'f_a', 'f_x', 'f_z', 'kef', 'xyz'] &gt;&gt;&gt; """ return tuple( (i, m) for (i, m) in enumerate( m[1] for m in sorted( (m[1].im_func.func_code.co_firstlineno, m[0]) for m in ( inspect.getmembers(obj, lambda v: inspect.ismethod(v) and v.im_func.func_name[0] != '_' ) ) ) if not predicate or predicate(m[1]) ) ) 
You should add some syntax-highlighting to your README. :)
pytest! We use it at work and I like it so much I've [become](http://www.slideshare.net/pfctdayelise/funcargs-other-fun-with-pytest) a bit of a fangirl.
You might also like SubCodes which allows you to block off code with ## markers. Press Ctrl+Enter to run code in between these markers.
Understandable. Emacs offers a lot of functionality.
Never really used R, but I know Sage supports it.
This isn't really answering your question but...I've used eclipde/pydev for 5 years now. A lot of my coworkers are now using pycharm and some of them switched from eclipse; I wish I could and maybe I will because pycharm is(just feels) better. While eclipse actually has everything I need, I have this feeling that pycharm just does everything alittle bit better. I've tested it thrice now already, but it all comes down to that I'm too comfy with my keyboard shortcuts to actually make the switch. 
There was an article from Tarek Ziadé linked from his letter to Django about what he sees as the issues. http://www.aosabook.org/en/packaging.html
You may not ask questions like that, because then you get some immature turds yelling that you're spreading FUD. All hail the new setuptools! We don't know why, and thus we won't explain why, but the new solution is better and you should not stand in the way of Progress. /sarcasm. 
Yeah. I mean, if only Tarek would actually *do* something for the python community.... Damn non-contributing freeloader. 
Thanks for the easygui tip. I just went through the tutorial. It is much faster than tkinter for prototyping and wireframing.
I see that this has already spawned a parody: https://github.com/dcramer/numbers It seems David's Python includes a builtin for currency- and tax-aware decimals.
 import decimal import warnings __version__ = "1.0" warnings.warning("You are an idiot") class Number(decimal.Decimal): pass would be at least a little closer..
Careful though - multiprocessing has some weird gotchas. When used in conjunction with the subprocess module it will change one of the default parameters to its opposite which caused me to lose a bunch of time trying to figure out why FDs weren't being inherited. (I still use multiprocessing all over the place - it's great! Just much more hesitantly than before...)
Again, as far as I can tell, IPython's [Qt console](http://ipython.org/ipython-doc/dev/interactive/qtconsole.html) offers a strict superset of the functionality of bpython. Most of that is also available in the [web notebook](http://ipython.org/ipython-doc/dev/interactive/htmlnotebook.html). What I'm trying to determine is what, if anything, is left in bpython that isn't duplicated here. The only thing I can see is the pastebin stuff, and that's trivial to add to IPython via a user-defined "magic command". Some of bpython's cooler functionality is available at the IPython on the terminal, but not the syntax highlighting and tooltips currently because they rely on readline instead of custom stuff, but it would be straightforward to add given the protocol that exists for the other frontends.
import pdb ...code... pdb.set_trace() Starts a pdb interpreter when it hits that line.
awesome, thanks!
Things are still pretty messy if you're a Windows user. There's no package manager, so you have to first install Distribute yourself, and then you need to easy_install pip. Pip will generally work fine for source-only modules, until you attempt to install a module with a C library dependency, such as lxml. Then pip will bail out and die because you probably don't have a working C toolchain installed and even if you did you probably haven't manually configured and built the prerequisite libraries; there might be binary eggs but pip can't install those. But easy_install *will* work for that, so after some head scratching you use the tool that everyone said you shouldn't use and it works where the one they said to use didn't. In sum, that's at least two third party things that need to be installed and a great deal of non-intuitive behavior. These things should be in the standard library, and there should be one tool to learn. 
Does anyone know where packaging development discussions are happening? I'd thought it was [The Fellowship of the Packaging](https://groups.google.com/forum/?fromgroups#!forum/the-fellowship-of-the-packaging), but it looks rather low-traffic for last year. I was mainly wondering because I'd attempted to contribute some code for specifying compiler/compiler-version specific flags during the C-extension build process, but I think it (understandably) fell of the packaging teams' radar, and I'm not sure who/where to post a message about it.
I think it's worth clarifying this a bit: ipython adds new syntax, but the new syntax is 100% orthogonal to python syntax. So it does not in any way alter the semantics of valid python code you type. What it does is recognize things that are *not* valid python and let you use them for convenience: %magic functions, auto-parens, !shell access, etc. But from day one, we've had a policy (I initially, but that has been kept as the team has grown) that IPython should be a 100% replacement for the plain python shell, just better. And that if you only use it to type pure python, you shouldn't be able to tell the difference with the default shell. In fact if you start it with --classic, it will even mock the prompt behavior of the python shell. Now, if you prefer bpython, by all means use that! Nobody is forcing ipython down people's throats :) But I want to make sure that people don't get the wrong impression, becase saying that ipython is not a python shell can be easily misconstrued. As for the scientific support, it's 100% optional, and only loaded if you explicitly require it with the --pylab flag or %pylab command. In fact, IPython can be installed on a plain python installation with nothing other than the standard library (plus readline on windows/osx that don't ship readline). We also have a very strict policy on this: *all* the fancier enhancements, qt console, notebook, parallel computing, etc, are completely optional. The basic IPython should work on an unmodified standard Python installation with full functionality, without requiring anything else. I hope this clarifies things.
Hey @dwf, we've had pretty much that plan for a while, and a few times people have popped on the list to say they were going to build a curses/urwid client. It's just that nobody has come through. I've always said that my view of clients would be complete when we'd have: readline console, curses console, gui console (qt) and notebook. We now have 3 out of 4, only the curses one is missing. It shouldn't be that hard to do... I once spoke with the bpython author about code sharing, and he was very cool about it (plus it's MIT licensed). So it would be no problem to use bits and pieces of useful curses code in there. I would *love* to have a better text interface with proper multiline editing for server situations, but keeping all of the 'ipython flavor'. I hope that 'month to kill' comes soon :)
I just did, this is awesome! Thanks!
Wow, I didn't know that. I didn't really have time yet to check out the docs to see all of the things it can do, I really should.
Okay, I see. I'll try to rephrase that next time. Thanks.
Indeed, if you find that it doesn't suit you, by all means don't use it. Interestingly, in over 10 years of development and extensive interaction with users, this is the first time I hear this particular concern. For me it's never been an issue, as the syntax extensions are very few and well isolated. But it's always very useful for us to know why IPython doesn't work well for any particular group of users: sometimes it will indicate things we can do better, sometimes we may decide it simply defines a use case that is not ours to cover. But critical feedback is always good to hear. I'm not going to get into a hair-splitting argument on whether someone considers ipython a 'python shell' or not (over 10 years, everyone I'd seen seemed to think so, but I'm perfectly OK if you think it's not). I think the most useful way to phrase it unambiguously is: "IPython understands a strict superset of the python language syntax; all valid python is executed without any semantic difference to how python works, and a few extensions provide additional functionality beyond the Python syntax for things like operating system access and control of IPython itself". I think this is the most accurate, uncontroversial characterization I can make of it.
Look at Amazon EC2. I think there's a free pricing tier if you don't need much cpu or data transfer. They'll give you a linux server you can log into to set up your cron job. You can even get apps to control it from your phone if you want.
&gt; and a few times people have popped on the list to say they were going to build a curses/urwid client. It's just that nobody has come through. I assume that's probably because they underestimate the amount of work involved in first learning the ins and outs of the protocol and then making everything work right. My estimate of a month comes from an initial guess of 2 weeks and then doubling it, but for getting all of the little things working, I imagine my estimate could still be conservative. One thing that comes to mind is the whole issue of input to external processes and the pexpect issue in the Qt console. I guess that if the client and the server were on the same machine, the terminal client could bypass the kernel in most cases (unless output was being captured). I did notice that bpython is MIT licensed, though -- hopefully that would speed things along. &gt; I hope that 'month to kill' comes soon :) Oh goodness, so do I. It always seems just around the corner. Now back to preparing that thesis proposal...
Oh yes, getting all the details polished would likely happen slowly over time. But in a month, I'm sure you could get a very satisfactory client off the ground that would do the 80% job really nicely, and that many people would find super useful. Good luck with the thesis proposal :)
the differentiation I'm making is that ipython is a different language, which is of course a superset of python. it's a shell for the language it implements. and, this is pretty much The Complaint with ipython that I've heard. I'm rather surprised you haven't run into it - it's brought up any time ipython is in #python.
You're welcome. Amazing how much time it saves me.
Check that they are *exactly* the same versions it's looking for - they have to match the DLL versions Python was compiled with.
When I first pulled it down it was barking about python 2.6+ (using 2.7) versions needing PyWin32, which seems to be another IDE. Not 100% sure why that would be, hell I could write it in notepad if I wanted to, but it works nontheless.
and [construct](http://construct.wikispaces.com/)
&gt; the syntax extensions are very few and well isolated is there a page that lists all syntax additions?
&gt; A lot of problems can be represented as graphs and solved with a path search algorithm what are some examples?
Java has the advantage that what you distribute is platform independent bytecode. Python extensions still cling on to native code parts, which need to be distributed as source code and then compiled locally. But yeah, eggs were supposed to do this. Part of the confusion is that this is not just about packaging, but about distribution, and the needs of more complex distribution are spilling over into new requirements for packaging. 
Eggs are pretty similar to jars. Jars benefit from being simpler in that they only concern themselves with platform independant Java code, while eggs need to deal with binary code compiled from C in addition to platform independant python code. Jars don't get all the flack because the Jar tool that ships with Java just makes Jar files, it doesn't have scope creep up the wazoo like setuptools does which also attempts to be a package installation tool and development tool. You don't see the Java folks trying to get Ant or Maven included as part of the core Java distribution. 
That seems a bit mean and passive-aggressive of dcramer. Your module is useful in that it makes dealing with currencies dead simple and it can prevent conversion errors. If he had a point to make in writing 'numbers', I don't get it.
[PyWin32.](http://sourceforge.net/projects/pywin32/)
and, as (s)he said, there is no way to accidentally use its syntax between python code and wondering later why it wouldn’t work if executed by python. the additional syntax is to be used in interactive mode, to control ipython’s functions or interact with the system.
I used gnuplot a lot 20 years ago. Since matplotlib I never looked back at it. gnuplot generates eps (vectorial graphs) while matplotlib generates raster images (png) but for high dpi the quality is great and is much more flexible. Plots look much better in matplotlib. Both can use latex in labels. I use Canvas on top of matplotlib for a simpler syntax: https://github.com/mdipierro/canvas. Here are two screenshots [1](https://github.com/mdipierro/canvas/blob/master/screenshots/img1.png) and [2](https://github.com/mdipierro/canvas/blob/master/screenshots/img3.png). bars and hist can be superimposed as in your example.
Gnuplot can output to many different formats including png, pdf, eps, canvas, latex, etc. I disagree that plots look better in matplotlib. I think its just personal preference though. I typically heavily tweak my plots (colors, line styles, etc) and I think the defaults in gnuplot and matplotlib are horrible! The nice thing about a program like this outputting gnuplot commands, is that the user can modify how the plotting works without modifying the program. You just save the programs output to a file, instead of piping into gnuplot and then you have a perfect template to work on your custom plot.
it isn't an ide, but a collection of modules for working with win32
Just a thought, how about connecting to a well-known exchange-rate source automatically, and then allowing the conversion, comparison or other functions for different kinds of money? Then, you actually could allow a comparison between GBP and USD, or allow them to be added, etc. 
Every money-related library for python seem to use Decimal. The problem with Decimal is that it's slow. I also have a homegrown money class in my app, but although I started out using Decimal, I ended up using integers (representing subunits of the currency) for speed. I also ended up implementing it in C.
atd if it's a one-off
He needs to create that search engine and use it to look up Toastmasters.
Wait so this doesn't buffer the download? Can't the encryption software process the file in chunks? I've got another more general question: If we start uploading and the file upload takes a couple of minutes, does that mean that flask will not serve any other connections until your file-upload is complete? Or is everything threaded/asynchronous?
I started working on an Emacs interface, but interpreting the zmq "protocol" in Emacs got to be non-fun.
To the first question...I chose to use Flask, which is built atop the werkzeug wsgi toolkit. If you go digging into werkzeug's formparser.py module, uploads encoded as multipart using the default stream processor will store uploads in memory if they are less than 500K. Files larger will be stored in a temporary file. [source](https://github.com/mitsuhiko/werkzeug/blob/master/werkzeug/formparser.py#L37) -- I don't confess to have studied the [MultiPartParser](https://github.com/mitsuhiko/werkzeug/blob/master/werkzeug/formparser.py#L265) but it appears there are hooks there for processing the stream. I would look at the parse and start_file_streaming methods. I found an [interesting post](http://flask.pocoo.org/mailinglist/archive/2011/9/9/any-way-to-stream-file-uploads/#d3f5efabeb0c20e24012605e83ce28ec) on the flask mailing list that provides an alternate approach. Armin proposes that, since the werkzeug parser reads from wsgi.input, you could just wrap the read() method and do the encrypting on the fly. I am not sure how this would work and a subsequent message indicates that werkzeug is actually calling the readline() method (see werkzeug.wsgi.LimitedStream). To the second question, it depends on how you are serving your flask wsgi app, but basically, provided you aren't using a single-threaded "debugging" server you should be fine. Almost any "production" server like gevent's wsgi server or gunicorn will respond to requests concurrently
PIP goes a long way toward a uniform package configuration philosophy. Maven configures dependencies on an application or project basis. The PIP/setuptools philosophy necessarily differs from Java's Maven in that configuration is done on a version of the Python interpreter, not the project. However the idea of having a uniform package configuration and upgrade mechanism, (capable of removing a package), is common to both Maven and PIP. Maven also provides a common scripting mechanism (the pom file) which makes the process repeatable from developer to developer. 
Python 3.3 has 'A C implementation of the "decimal" module, with up to 80x speedup for decimal-heavy applications'. As I understand it, one of the difficulties in rolling one's own comes when dealing with various legal requirements for rounding and precision. The Decimal module captures that, while most integer-based solution do not (nor need to).
Friendly advice: use Linux or BSD for your servers, not Windows.
What is the license?
It appears to be in the public domain according to the LICENSE file that was recently added.
One major problem with pip and setuptools in general is that they can't do any dependency resolution until you are actually running the setup function from setup.py
Even on Linux a binary install would be appreciated. Sometimes I don't want my deploys taking 20-30 minutes with most the time spent compiling libraries. I also don't want a bunch of unnecessary compilers, compiler tools, and libraries sitting on my web servers.
You are right, it's not that it acts single-threaded; I should have said that it acts single-core. Although the OS can execute multiple threads simultaneously across multiple cores, even in a single process, that won't work with multiple threads in a Python process, since only one thread can be holding the GIL. It works okay if your other threads are running code outside of Python (such as a large matrix inversion on a numpy array, which is implemented in a FORTRAN library), or if your threads are I/O bound, since the GIL can be released in these cases, but multiple threads running Python code cannot execute concurrently. This is unexpected for anybody not familiar with the GIL and it adds additional complication to taking advantage of multiple cores for CPU-intensive applications. While I agree that multiprocessing has some issues, it's easy to migrate from threads to processes using it. As a tool in the toolbox, it's handy, and that's why I suggested it. When you say that parallel processing has many mature solutions, what types of solutions do you have in mind? Multiple threads and multiple processes are certainly two of the oldest solutions, and the two we have been talking about. Depending on your use case, you could use a distributed computing platform like LSF or SGE, but it's a considerable amount of work to convert your multi-threaded application to something that uses those platforms. Likewise if you want to offload your CPU-intensive parallel processes to something like a GPU. Were there other alternatives to threading and multiprocessing that you had in mind? I'm not aware of any others as simple and general purpose as those two.
There's also the problem of sometimes having to work with cents and sometimes requiring a fairly higher precision (we've dealt with products that are sold in very high quantities but which have a unit price set with 5 or 6 digits of decimal precision). I have to say I have yet to hit a hard speed limit of the Decimal when used for financial stuff and not for scientific crunching.
I'm an avid ipython user, and for what it's worth, I couldn't live without the ```%paste``` command. You guys rule. That is all. EDIT: same goes for ```cd```, ```ls```, and the ```?``` operator.
Really? Honestly this has never been a problem for me. I can't even begin to imagine why someone writing pure python code would be putting ```%paste``` in the middle of his script. Could you give me an example of where this could be problematic? EDIT: I should clarify that I do use ipython for non-scientific programming as well.
why do you assume they're developers? maybe they're end users
I have limited completion, stock vim ships with local code completion. C-p in insert mode completes with function and variable names from the local file. I don't think I had to do much if anything to enable it. I agree that depending on it isn't so hot, but I do have just enough to automate typing things like `response` or `request.user.get_profile` when I am using an idiom that requires some repetition. I have pdb for debugging, exuberent-ctags and C-] to jump to source. Unit tests I end up running in a vertical split to get line numbers, but I've had unit test coverage show up using vim's signs feature. Ropevim gives me rename refactoring and moving functions between modules. I don't understand the downvotes, do I come across as haughty? I'm not mad, I'm curious.
Not in a nicely organized way, but @takluyver is working on an IPEP to formalize this more explicitly and organize the internals of the implementation: https://github.com/ipython/ipython/issues/2293
Sage does have R support, though I've never used it. Starting in 0.13, IPython also has builtin R support via an extension: http://nbviewer.ipython.org/urls/raw.github.com/ipython/ipython/master/docs/examples/notebooks/rmagic_extension.ipynb
Wow, will have to see the ipython thing.
Not sure why you were downvoted either, that's reddit I suppose,wouldn't worry about it. Upvoted you to 0 anyway. I know about the basic completion, but for some reason it just annoyed me and didn't feel as smooth as when using an ide. For things like C# / Java I tend to just stick to an ide unless it's a tiny program to test something. Never tried using ctags with python, but as I haven't worked on any very large projects, probably didn't need it. I'm going to check out ropevim when I have a chance! Thanks for the reply. 
Try using [PyInstaller](http://www.pyinstaller.org/) and see if your issues go away. I've never used cx_freeze, but pyinstaller has been able to handle anything I throw at it!
On second thought, it could make sense to apply all modifiers using something like `|` combinator. What do you think?
are you kidding ? I spent 3 years of my life working on this almost every night. is +500 commits in distutils is something called non-contributing ? https://www.ohloh.net/p/python/contributors/111669151876 and that's 10% of the whole work (discussions, other repositories like distribute, etc)