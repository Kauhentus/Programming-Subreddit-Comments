&gt; here are all sorts of weird quircks with wsgi that make a lot of deployment suck. I inherited responsibilities of a uWSGI/Flask/NGinX stack. It was somewhat complicated to make it "easy" to maintain (i.e. no hanging sockets, max performance tuning, static routes). To be honest, I found the Tornado way (just serve directly on port 8080) and configure an ELB at port 80 to point to the Tornado box much simpler to grok. It also was nicer to debug.
Because using Python is pure joy and using PHP is like pure torture. Syntactically, it's like comparing filet mignon to a McRib, or a fresh garden salad to an old and rotting potato (if you're the meat-less type).
like I said, you need to know what you're doing... matlabs xcorr algorithm uses an FFT, which is going to thrash a direct correlation on large input no matter what language you're implementing it in. numpy gives you all the building blocks to do this yourself, or you can try scipy.signal.fftconvolve.
Read this and tell me you'd choose in 2015 to use PHP, ever, for anything: http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/
You can perfectly set up your application so that PHP will never read from disk. This is one very common setting to enable.
Using python over php to create a web app is absolutely silly. Current PHP is fast, super easy to deploy, easy to maintain and learn, and widely supported. I can't think of a single reason why somebody would choose Python over PHP when creating a Web Application other than "hurr durr, php is *weird* and *broken*".
PHP should be left for dead. It was a hastily put together scripting language that was made to be an alternative to ASP. The creator openly says he had no idea what he was doing. They've now taken it and built it into monstrosity. It used to be that PHP had the advantage in some areas, especially quick pages. But now there's no reason to use it unless you want a PHP job for some reason. Of course you can make great sites in it, someone could make a great site in brainfuck, doesn't mean it's good. If you want to try something new, I recommend Flask, Node, Go, Rust, Clojure. In that order of adventurism. Sorry, I don't pull punches on this stuff. Tired of the "every language is a tool" mentality. Sure, but some tools just plain suck.
But again that's not true... With new PHPs opcache it can keep the "compiled" code in cache and refine that compilation with each request. It's actually better than Python's pyc in many aspects (and worse in others). And that "clean slate with every request" is exactly what allows linear scaling. If you need to you can serialize and cache massively complex objects between requests but for 99% of people that will never be required.
I checked and their accounts in Soundcloud have no tracks. https://soundcloud.com/d-drizzy-1 https://soundcloud.com/lil-wayne 
"But... But there are $ symbols! That means its bad design!!"
Yes, I have, through the ctypes modules and the CFFI library. Just because you couldn't make it work doesn't mean nobody else could. Doesn't it strike you as at all strange that a programming language that was originally designed as a glue language for C couldn't interface with C? If I encountered such a situation, the first thing I would assume is that I was doing something wrong.
I'm no PHP fan, but there is blind fanboyism in every group of programmers. Once point doesn't make a correlation.
This was interesting thanks. 
Yes, that is what I said, GPL or closed license. Commercial users are still allowed to use the GPL version if they want, and individual users who want commercial support or don't want to follow the GPL need to get a closed license. There is no distinction between individual and corporate users in either the GPL or closed license. And I am still waiting for you to provide anything from the Anaconda license that makes a distinction between individual and corporate users. You do understand the difference between "individual vs. corporate" and "open source vs. closed source", right? They are not the same thing. 
That is not good code.
How?
TIL I am a nobody :(
I can make useful things with it alright. It's just that it's a lot more difficult than with, say, C++ or Haskell, and the results tend to be of lower quality. And it's not just me; pretty much every other developer I've worked with who is proficient at more than one programming language produces similar output: their PHP work tends to be slower, of lower quality, or both.
What was previously preventing you from opening Python modules in your text editor from the command line?
Oh, I can do the linear scaling thing in every other programming language if that's what's needed. But I can also do a lot of other things when *those* are needed - my current project involves a giant lock-free in-memory ring buffer that workers talk to over ZeroMQ; that thing is designed to run "forever", and having a huge long-lived data structure is the core idea. There is absolutely no way I could do that in PHP, for a million reasons. But this is not why PHP does it anyway; "it allows for linear scaling" is a retrofit bullshit excuse for not being able to implement proper memory management 20 years into development. PHP gives you a clean slate for each request because that is the only way it can avoid subtle memory leaks. Or maybe because people can't imagine doing things any other way.
In my opinion, this is good advice. Starting a crusade against Matlab where you're on one side and the entire company is on the other side is an astoundingly bad idea, even if you were not a junior. If they're going to be convinced, it'll have to be gradual, and the smartest course of action will be to first use Python where Matlab is completely terrible, which is everything *other* than scientific code. Deploy with Python, process data with Python, automate procedures with Python. You're going to be doing all these things anyway, so why not use Python for them? They're likely being done by hand these days. Take what you can get. Convincing Matlab people to go the Python way is hard. They are in love with their IDE and can't imagine working without it. Everything you see as a negative, they see as a positive. I know one person who worked with Matlab for his entire career, and lately he's been writing mostly Python, because he needs to deploy something on the web, so he's writing Django. A while ago he asked me a question about Pandas syntax. Change will not come because you'll convince your company that Python is superior to Matlab in numerical computations. The thing is that Matlab is sufficiently good when it comes to numbers, and for scientists and algorithms engineers, sufficient is as good as they want. They're largely not interested in the software engineering side of thing when they think about numbers - but they'll kiss your feet when they see you convert an XML to a CSV in 10 lines of code, or set up a Python daemon that periodically loads data into some database. These are things that they likely can't do. You'll have a much easier time. The rest may come later. If nothing else, you'll have improved the process in your company, which is never a bad thing.
PHP is weird and broken, but most of all, anti-intellectualist. It is the perfect tool for people who are afraid of abstract thinking, and don't mind doing a lot of repetitive work. The economics of the software market are such that doing repetitive work and telling customers that this is necessary can be quite profitable, but, idk, somehow the idea of getting the maximum amount of money out of customers for the minimum amount of thinking isn't what I'm after.
It may just be that you're hitting Python's expressiveness limit. Zen Of Python says "explicit is better than implicit", but unfortunately, the language itself doesn't put its money where its mouth is in this regard. I believe the Pythonic way of going about this, whether you like it or not, would be to just call the relevant methods, failing with a suitable exception when the method doesn't exist, and documenting and unit-testing things into oblivion. Making it explicit to the human reader as well as the interpreter would be better IMO, but it doesn't quite match up with Python's "consenting adults" assumption.
(Now I admit this is crazy), but I have a daemon running in PHP on one of my servers (doesn't have python installed and it was better than bash). It's currently been running for 5 month without all those memory issues you seem to think it'll have. PHP can be written in a more "python" manner with a server implemented in PHP and a long running process responding to queries but that's not how most do it for a bunch of reasons.
I assumed typo on the first occurrence. It was pretty clear that you skipped English grammar 1.0.2 when I saw it the second time in a row. 
Without this, you'd have to know where the module is installed, and possibly type a long path - e.g. `~/.local/lib/python3.4/site-packages/...`. This opens it based on the import name. I've definitely wanted that before. For bonus points, it would be good if it had hooks to tab complete import names in popular shells like bash.
The proper use in this case would be "anti-intellectual", not "anti-intellectualist", and your argument is complete nonsense. There is nothing in the language itself that makes working with it more repetitive than working with any other language.
The base ideas are nice. Abstract and make code reusable. Where it shows weaknesses are dependancies on simplistic examples. Check out the [error handler](http://pycoder.net/bospy/presentation.html#bonus-material). Create a user with an email address that already exists and missing a field. Which error is returned first? The [email decorator] is also an ideal case. What if your email sending fails? You've returned `OK` with zero error handling on if the email fails. I don't suggest Django is a perfect fit for every case, but with an API there's a lot of small details, such as content type handling, permissions, authentication, filtering, pagination, etc. Class-based views in Django make it very easy to extend and reuse functionality. [DRF](http://www.django-rest-framework.org) does a lot of that for free out of the box. Also not to belabor an implementation point, but more then 1-2 decorators on a function makes me question the usefulness of the pattern being implemented. 
You can hold the absolute truth in your head, if you express it like a peasant then it'll be perceived like the opinion of a peasant. If your excuse was legitimate in any way, there would be more misspelled words than the usual "your, you're" ignorance. I'll take the mathematically-insignificant chances that this wasn't the case. English is my third language by the way. 
MKL is free for everyone as of a couple of days ago: 
MKL has been available for years. That site has been up for a long time.
What is the intent of posting this code? Just to share it with everyone or get it reviewed to improve it/yourself? If it's the latter, I would suggest posting this to /r/learnpython.
I went looking for a cheap laptop first, but it was a bit expensive for what it is.
The *or* keyword does exactly what you are seeing, it executes the if statement if any of the conditions are met. Try the *and* keyword. It will execute your if statement when all conditions are met.
First thing I noticed switching to python. "I need x. Oh dang, x is available through open source on github. My life is easy." *drinks a beer*.
I'd say that the argument boils down to the sanity of the language design. This is a direct result of how the two languages came to be. PHP was created by a guy to meet his specific need for some dynamic content on his home page, (used to mean Personal Home Page). Whereas Python was conceived as a fully fleshed out general purpose language and was thus planned out further. That said though, both languages have their quirks and oddities to them and modern PHP is a perfectly fine language, it's just that the legacy code can really be terrible.
Ah yes, two years before, good catch. At the time, it felt like PHP was the open source alternative to ASP.
What you are seeing is called [short circuiting](https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not).
Are you for real? You ask how to avoid any disk access to PHP files and then complains that it's not picking up file modifications? You have the choice to use that setting… Usually you do it in production, where code does not change! (I thought it was obvious). If you want to benefit from code reloading, you just keep the default and stop complaining.
oh, thanks!
Redis?
MKL has been available for years, but as far as I can tell it has only been available free for everyone for a month or so. At least I can't find any mention of it prior to the beginning of August, not on Google, not on Wikipedia, and not on Intel's website. The articles on Intel's website, the articles on their support forums, the link on wikipedia, and all the google results are from August or September.
Nobody accused your friends of being intelligent/qualified
Again, no. They weren't putting out binaries, but you could get them prebuilt without paying. I've been doing it for years.
or logic gates
Yes, you can get prebuilt binaries for certain open-source packages. But you couldn't get the library to build your own software against for free until recently. So you could download someone elses' numpy linked against MKL, if they got approval from Intel, but you couldn't make your own numpy build for free unless you were in academics. And due to the hoops developers had to jump through it tended to be hard to find even pre-compiled open-source packages. There are only a couple of sources that offered them. This is no longer an issue. Anyone can provide them now.
&gt; Anyone who simply says "go NoSQL" should be ignore: they very likely don't understand relational databases Completely agree with this. Even my long standing reason for going with NoSQL--distributed instances--is not terribly relevant anymore with reliable distributed relational DBs.
I think you mean asynchronous? Since asymmetrical threading isn't a thing outside of coat sewing.
&gt;It's easier to split up modules. In python, modules quickly grow to thousands of lines long, and you can't easily split them up without creating circular imports. Not an issue in PHP. I've...never encountered this, and I've built multiple reasonably sized webapps. I've had a circular import issue once, and it was solved easily with a factory class. &gt;Type-hinting function arguments. Python (3) has these &gt;Interfaces. Python has these, you can do interfaces, mixins, ABCs, etc. That people don't is their fault.
I mean, no? But most of these people are college-level CS students or junior-level developers. Hell, even most of the senior-level people I've spoken to about it are of the same opinion, yes, they know about all the benefits of it, but at the end of the day, most people who use Node are probably there because it's JavaScript, and all the benefits that people talk about besides it being JS are secondary. Pretty much every article I've ever read about why someone should consider using Node start out with, and usually emphasize the most, that it's JavaScript.
Spot on; this is useful for opening 3rd-party libs. Before, I would import the module in IPython, then run `%edit module`. This streamlines that process. Big +1 to tab-complete. Pull requests welcome. =) UPDATE: Still no tab complete, but partial name matching was just added. UPDATE: Tab complete has been added
Maybe English isn't his first language, I would like to see you do a technical reply in say Mandarin. 
OP already HAD the PHP-biased answers! Seems for some reason they just wanted to make their decision harder. &gt; Guys over /r/web_design seems to have a hard-on for PHP
it would make the mistake even less likely because non-natives put conscious effort when learning English. You're is not a bunch of sounds to us, it's clearly "you are" that stands for the 2nd person of "to be" and "your" is entirely different and describes possession. It's the undereducated natives who in school weren't smacked upside their heads enough for sleeping in grammar classes and now believe that being sloppy is a-ok are who makes the vast majority of blatant your/you're they're/their/there errors.
Never heard of it. Ill check it out, thanks for the suggestion...
Popular php micro-frameworks specifically for APIs: http://lumen.laravel.com/ http://www.slimframework.com/ http://silex.sensiolabs.org/ 
Have you looked at Django's tutorial?
Nah, this one https://docs.djangoproject.com/en/1.8/intro/tutorial01/
Thank you! That needs more googlejuice.
The only thing not mentioned in comments before this (afaik even around the interwebz) is Python's module system. In short, it's a functionality which sometimes makes you think why a usual Python codebase looks so simple and why do Python developers do not favor one of the most popular OO architectural patterns - Dependency Injection and Inversion of Control. In long, one of the benefits of dynamic runtime is the dynamic interface binding. Most programming languages with dynamic runtime provide a system which exposes interfaces to objects which types are not defined until they are executed by a machine within a controlled environment usually called Virtual Machine. Occasionally, since it provides an interface (similar to API functionality) at which point modules behave like microservices, they are encapsulated in their own namespaces. That's why it would be absolutely illogical to introduce Namespaces as language constructs to some languages that have a module system or at least something that works that way. Let's take some steps back. In PHP you can't write unit test for a Class if you didn't write that Class in a certain way so that you can manipulate its dependencies at the runtime (DI). If you do that with more than one Class, you will shortly realise that you're cluttering your code at the point where it's already doing something else really hard and you know that it's becoming unreadable (i.e. too complicated controllers), and you figure out that you will need some sort of a factory which constructs those objects on a fly when you need them and that you simply need not to care about their dependencies when all you want is to use objects as tools for the job at hand (IoC). Welcome to the module pattern. Important thing to realize is that no one ever said that DI or IoC are not important. You can use them in Python too, but for it to make sense, the codebase would need to become really heavy which often (web backends) is not the case. You also don’t need to put everything in a Class, which you would need to do in PHP even if you didn’t want to write unit tests but just wanted to include encapsulated functionalities. On the other hand, it would be completely sane to construct your app with DI/IoC in Python even if you just want to have a generally better picture of the code structure/flow as you're practically wiring components in one central place and it's usually simpler to graph (visualize). Even then, the implementation is very trivial in Python. You don't need a whole framework for that. If you want to test a module, but it has so called 'hard coded' dependencies, you simply mock those dependencies when you import that module in a test runtime. I feel like that PHP is missing one of the greatest benefits of his dynamic typing. Sometimes I feel like I am programming in Java, but without the benefits of static typing. Somehow it all feels wrong. Like someone decided to put diesel engine in my bicycle and even though I am pedaling, I constantly have to fuel it because it's just there. And it has, it has a lot of dynamic and some functional capabilities, which are nice, even though sometimes awkward or inconsistent (people usually say that PHP has most awkward moments and inconsistencies), it really doesn’t have anything that other languages already don’t have or do it better. You will never find anyone transiting from another language to PHP because it has some better capabilities (e.g. I’m transiting from Python to Elixir and Phoenix, not that much because of the syntax and powerful functional paradigm but more because of the platform). But you will always have people turning back to PHP because it works fine and the client wants his CMS with a trendy designed frontend, and he wants it yesterday.
&gt; You can write normal functions without wrapping it in a class You can do that in PHP too, since always. That's how you would write PHP in old non-OO days. &gt; Strong typing. You can't just add an int and a string, or concatenate a string with a boolean. Why is this an advantage? &gt; It's easier to split up modules. In python, modules quickly grow to thousands of lines long, and you can't easily split them up without creating circular imports. Not an issue in PHP. What's difference in PHP? You can create the same circular mess in PHP or anywhere else. What makes PHP better at solving or preventing it? &gt; Type-hinting function arguments. Afaik, you can only hint non-scalar types (example are interfaces and classes), which is not considered as type-hinting but rather a static binding. &gt; Interfaces. You can write interfaces in Python by declaring abstract classes but it's rarely needed. Of course, it's much more needed in PHP, and if you're interested in 'why', check out my comment to the OP's post.
Thanks; also elsewhere in the thread: https://docs.djangoproject.com/en/1.8/intro/tutorial01/ is supposedly what I should have been able to find googling (um, no comment.)
I am really enjoying this. I like its APPEND command, it is very useful Thank you for the suggestion /u/wowowewuh. You just solved my problem
I'm not really sure what that means. I haven't kept up with Matlab much recently, but isn't matplotlib based on the Matlab style of plotting? What does it mean for Matlab to base their graphics on a thing that is based on them in the first place?
yeah sure test server could be set up in 10 min with few command line but I has been spending the better of last couple months wrestling with django+uwsgi+nginx while learning to setup domain names, automatic linux DNS client(domain company i'm using doesn't have free DNS...), live with SELinux, CLI admin, securing SSH login, etc.... And now with everything running I finally get to build some web site.
Python code related to [this](https://www.reddit.com/r/Python/comments/3jxe7r/a_visualization_of_the_curvature_of_spacetime/) posting on /r/physics
Not really. matplotlib uses an object-oriented plotting system. It offers a matlab-style state machine wrapper on top of that object-oriented interface, but this is mostly just a wrapper. Pretty much all the real business logic happens in this object-oriented system, which is completely different than the system MATLAB originally used. For the last 5 years or so, MATLAB has been moving in the same direction by building an object-oriented replacement for its original plotting system. This new system, called HG2, is very similar in principle to how matplotlib has always worked. It became the default in MATLAB R2014b.
/r/learnpython might be more helpful, but here are some common considerations. You'd use IronPython for compatibility with .net libraries, Jython for easy java interop, CPython if you need C extensions that use the CPython API (like numpy), and PyPy if you have pure python code or if your C extensions don't depend on the CPython C API. In short, people use PyPy when they can, but often they can't.
Just to make it explicit for this particular situation: In the case of a logical `or` expression, if there are two conditions and the first one is known to be `True` then the overall `or` expression will be `True` regardless of the second condition. Therefore in that case Python does not bother to evaluate the second conditional. If the first one were `False` then it would check the second one.
`time.get_clock_info()` will report on the precision of the clock. I would consider using `time.monotonic()` in case of clock adjustments while the program is running (internet NTP sync, daylight savings, etc). A car race might last for multiple hours. Monotonic can't run backwards and is unaffected by clock changes. Since /u/IronManMark20 asked about Mac OS: Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import time &gt;&gt;&gt; time.get_clock_info('time') namespace(adjustable=True, implementation='gettimeofday()', monotonic=False, resolution=1e-06) &gt;&gt;&gt; time.get_clock_info('monotonic') namespace(adjustable=False, implementation='mach_absolute_time()', monotonic=True, resolution=1e-09) 
Here's the output I get: &gt;&gt;&gt; print(cov_list) [[1073741824 1073741824 1073741824] [1073741824 1073741824 1073741824] [1073741824 1073741824 1073741824]] &gt;&gt;&gt; print(cov_list+cov_list) [[2147483648 2147483648 2147483648] [2147483648 2147483648 2147483648] [2147483648 2147483648 2147483648]] &gt;&gt;&gt; print(cov_list+cov_list+cov_list) [[3221225472 3221225472 3221225472] [3221225472 3221225472 3221225472] [3221225472 3221225472 3221225472]] &gt;&gt;&gt; print(cov_list+cov_list+cov_list+cov_list) [[4294967296 4294967296 4294967296] [4294967296 4294967296 4294967296] [4294967296 4294967296 4294967296]] It's exactly what I expected. Did you get something different? If so, could you post it?
Integers can go negative if there's an overflow. When I run the code, it works as expected, and the result of `cov_list.dtype` is `int64`. This means the values in the array are stored using 64-bit signed integers, for which none of these values overflow. If I force 32-bit integers, I get the following: &gt;&gt;&gt; print(cov_list) [[1073741824 1073741824 1073741824] [1073741824 1073741824 1073741824] [1073741824 1073741824 1073741824]] &gt;&gt;&gt;print(cov_list+cov_list) [[-2147483648 -2147483648 -2147483648] [-2147483648 -2147483648 -2147483648] [-2147483648 -2147483648 -2147483648]] Basically, numbers that are too big to be represented cycle around to negative numbers. This is a common feature in many programming languages, and the common fixes for it cause big drops in performance, so it's just something you have to be careful about. 
So what the argument? You say PHP has more frameworks but that doesn't matter yet it looks like you're using it as an argument for why PHP is better. 
Lol maybe you should use some other libraries and languages then. 
Then he should ask /r/frontend why Python is better.
OK. Tell me. Why do you have to use autoloading? Or in otherwords, what is the feature of php that makes things like autoloading and all the baggage that comes with it necessary?
Exactly, nobody says writing vanilla php is a good way to go about web dev here either.
Things that an IDE like PyCharm would do. [directory structured like this](http://as.ynchrono.us/2007/12/filesystem-structure-of-python-project_21.html)
God help us all. How do we know when the thing is writing to disk? WHERE ARE MY CLICKS? \*runs into living room, hugs old Dell towercase\*
... Baggage?
Autoloading is necessary because in PHP there is no concept of a whole application. I.e. you can't tell the interpreter "load all these files" like it would be in a Java application. So autoloading means PHP files will be loaded when the class it contains is used. By the way, "loaded" doesn't mean actually read from disk or even parsed because of the cache (hence the previous discussion). So in production "loading" a file just means executing the pre-compiled opcode it contains. In the end, with modern tools like Composer you don't have to deal with autoloading. And with the opcode cache, you don't have the penalty of reading and parsing files on each request.
This website is horseshit. Does anyone remember their awesome R vs Python infographic?
I really want to like Falcon but find it to be to verbose for my liking and I never end up actually using it. :(
This is a good list https://www.staticgen.com/
I sometimes use ironpython because of multithreading performance. 
but it's just an application server. Is there something like http://python-eve.org ? 
Tried it, didn't work. Anyways, I got it sorted out with py2exe now, finally.
&gt; Don't do everything in the end point for testing purposes. ...yet the example proceeds to do everything in the end point. Sure, there's decorators, but they're only hiding complexity, not reducing it. It's analogous to cleaning your bedroom by shoving everything into boxes. It's "clean" but it's not organized. &gt; Rest API... sessions Lol &gt; Directory structure of Apiv1, models, views, endpoints "What does this app do?" "Well, it's got some models and views..."
If you just use Django, Django-Rest-API, Django-Rest-Auth and Django-Allauth you can have a good restful API with users, authentication, a admin panel, re-useable models etc. up and running within a day, including the API endpoints for registration, login, social auth, password forgotten, etc. and even documentation, writing unit tests for the API is easy as well. Even for just setting up an API Django isn't overkill, there are a lot of features you can use that come in handy and a lot of stuff that's already thought out for you. Nothing wrong with good old Postgres if you ask me.
Not really hiding, they're decoupled and reusable bits of logic, wrapping the endpoint but that's a detail now, isn't it ?
To be honest, from a dev POV, PSR-4 is more about using the same standard to organize code rather than solving autoloading. If there wasn't autoloading, there would probably still be a PSR on how to organize classes in projects so that everybody follows the same standard. Just like PSR-1 and PSR-2 are a code guide style. Composer solves autoloading. As I said, you don't have to deal with it. You keep trying to make it sound like it's a huge deal and OMG it's so complicated but it's not. &gt; They want a system where they can easily update live code and are willing to pay the price for it by writing boiler plate code and following bolted on conventions. We don't have boilerplate code. Autoloading hasn't been a problem in PHP for years. It's gone. Done. Basta. You have in mind a problem that doesn't exist. Regarding following "bolted on conventions", we do the same for code style. That's a way to improve the situation when discovering a project: everything is always organized and formatted the same way. And that exists in plenty other languages too.
Python2, why?
1. Tell your project manager(s) that you plan to hold a set of lunchtime python coding dojos simply for the fun of it. Make sure that initially these dojo's illustrate how to that which is currently being done in Matlab/SAS. 2. Tell your project manager(s) that there are companies out there who can provide good quality in-house python training courses. This will provide a pathway to rolling out python skills en masse. 3. Tell your project manager(s) that amongst your fellow graduates python is the number one general purpose programming language and that it will be difficult to attract good people in the future if you cannot offer them a chance to further improve their python skills on the job.
&gt; As your systems scale, your architecture gets more exotic. Planning for change is not premature optimization He pointed that django lock you to the relational database. Django does not fit well for https://www.nginx.com/blog/introduction-to-microservices/ Im sorry, just really pissed off by usual zealous comments towards NoSQL like it just drop off replacement to traditional RDBMS.
Oh my ... yes, I wonder how I didn't recognize these errors u_u;;; It's indeed a bad decomposition and even definition of the problem. The limiter bugs you mention are true too, but I think he wasn't showing full fledged network topology agnostic logic, more a PoC. Thanks for your light anyway.
I've tried getting econ phd students interested in Python for scientific computing. They mostly acknowledge that it would be ideal to switch, but they're deterred by the startup costs of learning a new language. I have my money on [Julia](http://julialang.org/) as the heir to the scientific computing throne. It was created to replace the "prototype in matlab/python/r, then write in C/fortran" workflow -- it has the speed and the user-friendly syntax (also, loops are as fast as vectorization!). Just look at the very highly regarded [Quantitative Economics site](http://quant-econ.net): it started out as a series of Python lessons, and now they have a Julia track. If Python can't kill matlab, I think Julia ultimately will.
&gt; You can't mock/patch it at runtime, so usually it's avoided except for pure utility functions. Ok, then that's the another point. We previously stated that you can have functions in PHP without them being a part of a Class/Object, and that they are treated as first class objects. But, I'll have to ask (I really don't know), what would you gain from patching functions only? And can you really 'patch' standalone functions in python? What would it look like? Would you only override a function with another that's named the same? In regular monkey patching, you swap a method on an instanced object during the runtime. It usually happens when you need the whole object but one method is doing something you don't like. But what's the purpose of changing one function only? Are you sure you can even do that in Py? Afaik, you have decorator syntax in python, but that doesn't mean you can't write decorators in PHP. I'm confused a bit. &gt; Explicit over implicit. That's right. It's always better to be explicit in order to avoid any possible mistakes from implicit behavior which may result in unwanted results or confused colleagues. But how that has to do anything with a flexibility of a language to offer something that's implicit? You can't blame something for being flexible :) &gt; You're encouraged to have one class per file, but they can share namespaces. While these classes can reference eachother, it's not a problem unless the circular dependency is something explicit such as constructor arguments. There's nothing stopping you from doing all of that in Python, without any overhead and probably even with less syntax. &gt;Whatever you want to call it. I think it's an advantage. Since you're only type hinting interfaces/objects/classes at the Class constructors in PHP while creating your usual DI graph resolved by IoC, that means that someone who decides to refactor the codebase can have a better understanding of what type of functionality he has to implement, drop or split, which is nice and elegant. There's nothing stopping you from doing the same in Python if you utilize the power of docstrings (which you also write in PHP) and IDE that can type hint you. Nevertheless, it's occasional in Python that for a regular web app backend you never have to write a single dependency resolving container as it happens that it's mostly not neeeded. At which point even refactoring goes easier as you're just replacing imports in a single place. PHP has to always adhere to composite patterns such as DI/IoC as you don't have a module system in PHP. In that case it is better to bind interfaces explicitly so that you don't mess it up when it's not obvious what comes from where ... ofc. again if you don't docstring it :)
Integer overflow. Did you never learn C?
&gt; Just image where the scientific and big data communities could be &gt; today if it wasn't held back by using the C API. That's one way to look at it, and if the PyPy devs continue to think like this then the scientific python ecosystem will continue to happily ignore PyPy. PyPy made their bed a long time ago when they decided numpy wasn't all that important. They are slowly realising the error, but statements like the above make me thing the core devs don't understand how python is used outside of the web sphere.
Please please please open your mind a little and listen: - if you use namespaced classes, there is no "deal with the mess". There is nothing to deal with, it just works. I don't know how I can be more clear about this. - if you want to specify filesystem paths directly (and not use namespaces), you perfectly can!
CS students != professionals. You and your homies operate within a completely different project scope that will never be touched by real humans outside of school, will never turn a profit, will never be asked to scale to handle real human traffic. The concept that nobody uses Node except because "it's JS" is just absurd especially considering the billions that have been made on JS in the last 20 years compared to the few years node has existed. Come work at the Groupon building where I'm at and talk about how nobody gives a shit about Node except because it's JS, you'd get eaten alive. 
I believe WinPython is better because it's compatible with PyPi the offical repository for libraries. And WinPython includes most scientific libs as well, like scupy, matplpotlib, pandas etc And you can install different versions of WinPython, by register/unregister them 
 My statement about framework count generally applies to any programming language. We all know of those cases where there are 12 libraries that do the same thing, but break in different ways. We also know of cases where everyone simply says to use library X because it's the best option. We also know of cases where people say that you can use X, Y, or Z and it doesn't really make a difference because the language has several great options. The point is that an argument of quantity has no relationship to the quality of a language's libraries. For the record, I'm personally not a fan of PHP. My point was that the statement about it having fewer frameworks isn't correct, but the number of frameworks doesn't really matter as much as the quality.
Not heroku any time. 
Sometimes one needs to know how the rubber meets the road.
Why do people from India use "doubt" instead of "question"? Sometimes this bothers me more than the lack of formatting. 
How is it python2 specific?
I mean djngo+uwsgi+nginx setup alone doesn't take that much time but getting it to actually run on real server while making sure it play nice with everything else is a little harder than it seems. Now with that up and runnin I can finally start playing with django.
`NoteToSelfNotifier().notify('kurashu89', 'checkout go!')` I've been meaning to checkout Go, do you have any good resources for a Pythonista?
&gt; it just works. No it doesn't just work. You had to create an autoloader in userland. That you have composer and it will create one for you does not change the fact. And, you had to use an auto loader because the poorly designed or rather undesigned semantics of include/require. There is absolutely no automatic namespacing of symbols. For that you need to shoe horn stuff into a class. (Even after 20 years of existance!). And I don't know, does functions support autoloading yet? So the fact is that, php took something that should be used for name spacing, and used it to solve the problem of autoloading (Which you wouldn't have in the first place if it were not for the restart-everything-for-every-request feature). So you are stuck with a poor solution to both that require external dependencies and what not.. It is sad that you and the rest of the community cannot identify the poor state the language is in. 
Probably it is not, but why say it specifically then? I did not try, but I am 100% sure it will work with python3, so why not use python3, but say that python2 is a requirement? It useless talk, but today usually there is no reason not to use python3, only some non standard cases with non-easily portable libraries and such.
My bad, I did not read the README, just the code, and since there is `#!/usr/bin/env python` I was not expecting python2 as a requirement. Apart from that, I totally agree with you. Even though I still use Python2 (because my team won't switch, and it was difficult enough to make them switch to Python…), I try to use the `__future__` as much as possible…
&gt; Jython for easy java interop Been there, tried that, but the harder Python interoperability was a deal-breaker: Got fed up of using version 2.5 for just that one program, and 2.7 (at that time) for everything else. Once I found that [pyjnius](https://github.com/kivy/pyjnius) allowed me all the Java interaction I needed, I was quick to drop Jython.
The problem that I see is that: Imagine if a software engineer needed to use physics for some simulation. They would go to a physics resource, ask the experts there and incorporate the knowledge into their code. Everyone's happy. Now imagine if a domain expert needed to write code for their research project. They teach themselves to code, and then shit all over the the web making "programming" sites. WHY?!
Python's native int class has arbitrary precision and will never overflow. That's why it works outside the array.
I write performance scientific python code daily. I know what I am talking about. &gt; everyone seams to expect its the PyPy dev's job to make sure &gt; NumPy, SciPy, etc all work under PyPy Because it is. PyPy is a curious distraction, nothing we take seriously. The best thing to come from the PyPy project was that CFFI got more visibility. 
Mentioning their name origin is so random and out of place in that article.
I found this article(slide show?) to be a little to absolutist for my taste. I think any experienced programmer learns very quickly that there is no "one size meets all" solution. There is just a box of tools with certain tools addressing specific problems. Only by understanding the tool and the reason it addresses a specific problem and understanding the nature of various problems can you really be effective. Microservices? Is it the best? Sure if you have the class of problems that microservices addresses. Otherwise you get all the cost/overhead of implementing and maintaining microservices without any real bottom line benefit. The versioning bit makes no sense at all to me. Sounds like they just have poor versioning practices. The implication of inherit superiority of Flask over Django. I've used both I generally prefer Flask, but Django has its place. Django is a total package and doesn't abuse decorators in the way Flask does. I think there are some decent points, but I was generally blah. 
+1 for pelican
It all depends on your goals. I used PythonAnywhere for years. I was reportedly at the top of their CPU usage charts. I used PA because of the ease with which you can deploy apps, run them... whatever. It was before I was comfortable with my own servers. Then, as I grew comfortable with running my own servers, I did that alongside using PA. Then, PA began failing me. My scripts would just... stop. They needed to be re-started. I was using PA for long-running tasks, basically infinite loops. They limit(ed?) the # of scheduled tasks you can run, vs infinite cron jobs on any VPS. I hope they either already have, or eventually do, get rid of the limiting of scheduled tasks. Kind of a silly constraint IMO. For small servers, I think the price is fair. Even for larger servers, having the "tarpit" was nice. In the end, you get what you pay for with them, though I should add that I left with 220,000 computing seconds, paying $100 a month, which is considerably less than what you'd pay now. I was with them from the earlier days. I kept the account for a bit longer than I should have, just because of the value of the 220K seconds. I would have stayed, had my scripts not kept stopping. Shifting from any server, but especially something like PA to a real server is a real pain. I do not regret leaving though. PA customer service is pretty darn good. You can talk to the founder relatively easily, but everyone is available. No matter how good the customer service is, they still couldn't fix my script stoppage problem, and I gave them ~ 1 year to handle it with multiple notices of the issue from me. In the end, I do not think they are trying to service people like me. People like me should just be on a VPS. The exact same scripts run just fine on the VPS I have now, and I have a total of 18 VPS spread across a variety of hosts. Never once have I had a problem like I did with PA. People like you, comparing heroku to pythonanywhere tells me you are more interested in deploying web apps than doing number crunching. I think PA is easy, deploying apps is a breeze. You don't have to really learn anything to get any tutorials to set things up. That said, setting up a Flask or Django server is also very easy. There are shell scripts and simple step-by-step instructions for deploying either, where you just follow the instructions, copying and pasting the lines into the terminal for about 5 minutes and you are done. I know nothing about Heroku, but I believe it is a little more challenging to set up. I see absolutely no point in doing that, when you can pay $5 a month for digital ocean and have full reign. Sorry if that was not the most useful review for helping you make a decision. In summary, I really think you would be best served paying $5 a month for DO. If you want free, and you want *ease*, then PA, from my understanding of what is required with Heroku, is going to be the easiest option. Best wishes! 
"Reality trumps theory." You are so blinded by what you consider an absolute horror that you fail to understand that there is no actual problem in reality. PHP is actually faster than Python, and will be much more faster in v7. Autoloading and namespaces are standard practices, completely taken care of, and there is no problem related to it. Thanks to that, developers can focus on producing value at a very fast rate (thanks to the "each-request-from-scratch" design of PHP) on fast and easy to scale applications. I've worked with Java for a long time. The productivity is half what you can get with PHP, developers have just as much rope to hang themselves, if not more thanks to concurrency issues due to the shared state, and production is usually much harder to scale.
https://github.com/python/cpython/blob/master/Tools/gdb/libpython.py
Like many here have said, PA is much better than Heroku. The think I dont like about Heroku is that they charge a lot for extras. So if you want to use a database, extra. Want to use Postgres, but also Redis? Extra money. I know people who pay $99/month for a basic app. PA has much limited options, but their price is fixed. They are also really easy to get started with. I agree with with what /u/sentdex is saying. Start with PA, and move on to your own servers once you become big enough.
And your point is? Do you even realize the difference between Node and any other Javascript framework? It sounds like you're a bit confused or generally technically disqualified to properly weigh in on this discussion.
look at openshift too if I guess your needs correctly :) Or digitalocean if you want more control
For starters, Travis stores your CI stuff in a .travis.yml file in your repository whereas Semaphore stores it in their web app. 
Pathologically Eclectic Rubbish Lister?
You need to maintain some sort of state. Just keep track of what the key was last iteration, and then `if lastpress = not pressed and now = pressed then do something; lastpress = pressed`
This is integer overflow. NumPy uses C and Fortran for speed, and integer overflow is common in C/Fortran. To get around this, you can say `x = np.array(..., dtype=object)`. Python supports arbitrarily large integers and the `dtype=object` allows that by treating the array elements as Python objects. 
Each "press" is comprised of a "key down" and "key up" event.\* The key down event is generated when the key is pushed in, and key up when it is released. Whatever library your using should expose those events. If you listen to one or the other, you *should* be able to execute just once for each key press. That said, I may be wrong based on how key-repetition gets handled (key-repetition being, when I hold down "e" and get "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"). \* Not to be confused with the up/down arrow keys
I'm not a PyPy dev and I use what ever tool is appropriate to get the job done. I have used PyPy, Cython, Numba, and the other 20+ tools that exist to make code run faster. I tend to defend PyPy because I believe their approach at the end of the day is best for the Python community but I can also see that in a short-mid term it may not be the best approach for the scientific community. But there is nothing inherently wrong with PyPy approach that would prevent it from being an excellent choice for the scientific community in the long run as it is just a bunch of work and some technical challenges that are solvable that need to get done. Part of the reason why I defend the PyPy devs is that I have seen them, time and time again, to do their best to understand the viewpoints from the different Python sub communities but only the scientific sub community seams to have a closed mind and not interested in discussing real issues. Yet they are quick to say the PyPy devs are closed minded when that is clearly not the case. The PyPy devs don't have a political agenda and are only interested in creating a great tool for everyone. I'm personally tired of the various tools that are created to make Python code run faster. New tools seam to be created every few months. Each seams to solve some part of the problem but they all end up having a number of cons. It's just as bad as it was 5-8 years ago when new web frameworks were being built on nearly a monthly basis. The madness of creating all these tools needs to stop and once and for all all sides need to come together with the goal of solving these performance issue for good. Ideally, I just want Python to run fast and be able to interface code in other languages. At the end of the day I'm sure we could all agree to that goal. Is PyPy really trying to create a new ecosystem? I don't think so. They are dedicated to making PyPy a fully compliant Python implementation. Now unfortunately CPython did not hide many implementation details as they are clearly visible from the CAPI. These leaky implementation details have real consequences and are the cause of many head aches. That is the main compatibility issue that prevents the scientific libraries from running on PyPy. It's also why a large number of modules that depend on the CAPI either don't run or run slowly under PyPY. What was PyPy going to do, just give up and the goal of creating a faster Python implementation or do they study all the issues and come up with a practical solution. CFFI was created to address a number of these issues. CFFI's adoption rate has been phenomenal and is currently one of the most popular modules. It has become popular as many are interested in running PyPy in production environments which meant a large number of libraries have been required to port to CFFI. Is this really a bad thing that a large number of modules are losing a dependency to the CAPI. Once a module gets converted it can support CPython 2.x, and 3.x as well a PyPy. This is a blessing in disguise for CPython as it means one day it may very well get the chance to change some implementation details like getting a better GC or better support for multi cores. I also been getting the feeling as of late that the CPython core devs are finally starting to see the issues that the CAPI has been creating as they more often now discouraging the use of the CAPI and have been warming up to CFFI. The only community I don't see adopting CFFI is the scientific community. Which comes to no surprise to me as CFFI was created by the PyPy devs and considering the distrust that exists between the scientific community and the PyPy devs. A distrust that really shouldn't exists but has occurred as many times in the past each sided has just talked past each other.
You're touching on a fundamental issue with buttons which is something that's fun to look into. The quick answer here is to listen to other people and use some library that already deals with this for you. The long answer is a bit more fun. Check out these graphs https://goo.gl/0D8yWP basically what you will see is that when a button is pressed down the physical button is literally just a metal (Or whatever material the keyboard is made with) piece touching another metal piece, when these two things hit they don't touch and become glued together they actually bounce away from eachother (Every action has an equal and opposite reaction blah blah). Similarly when you slam a ball on the ground it bounces up and down, this is the same exact idea as a button. That's why everyone recommends using some library to do this because it's not as straight forward as saying wait for this key to be pressed as the answer can mean a lot of different things (Does that mean we wait for you to first press the button down, or does that mean we double check that the hit was accurate with at least 3 "bounces" registering and report that as a hit, or do we wait for the button to register as being pressed down and then tell you when the person let go of the button? ) 
The CFFI project is interesting, but I largely don't use it because my work almost always involves Numpy arrays and if I want to write code to deal with performance hotspots, it's almost always easier for me to use Numba or Cython than write C code by hand and call it via CFFI. Likewise, if I'm wrapping external C code, I tend to use Cython, but that's mostly habit than anything else, so there's a point that I might consider adopting CFFI, but only if I don't take a performance hit. It might be useful for you, especially since it sounds like you have experience with both CFFI and cython, to write a blog post showing how one could use CFFI in place of Cython, how it could be used with both CPython and PyPy, and how the performance compares. I'd certainly be interested and it might be a good place to start in terms of convincing someone to reach for CFFI next time. 
As other people mentined, it's overflowing and you can use another numeric type. Take a look here for default ones: http://docs.scipy.org/doc/numpy/user/basics.types.html In your example, you could use `int64` if you want to keep using integers (or `float` if you're fine with the floating-point representation): cov_list=numpy.array( [[1073741824,1073741824,1073741824], [1073741824,1073741824,1073741824], [1073741824,1073741824,1073741824]], dtype='int64') Note that you can use 64-bit integers in a 32-bit installation just fine.
You made similar claims about "FUD" two years ago [1] and Travis Oliphant and Peter Wang tried to address your concern then, but you did not appear to publicly respond. Also, no one hates PyPy. It's just not interesting as a practical tool at this point because it doesn't solve any real domain specific problems for a lot of people. If your code is pure python and doesn't have any scientific stack dependencies, then it's quite nice. Personally, I don't find myself in that situation very often. [1] http://continuum.io/blog/numba_performance#comment-906120115
Completely wrong. PyPy has a garbage collector that moves things around in memory. That alone does not allow use of the C API without forcing one to freeze objects (and their dependents) in memory. By freezing objects in memory, you hobble the JITs ability to optimize. This is not a matter of "making ones bed". This is a matter of practicality towards obtaining high-performance python using a tracing JIT. Nor did PyPy ignore scientific computing because they wanted to. They had to get other pieces working well enough to prove it was worth porting to a faster infrastructure. **Without proof that PyPy performed better for general purpose python** code, there would be no point for making it work in scientific environments. Because of that, it is required the reimplementation of certain sections of numpy and friends to be less coupled to the C API and allow for the JIT to optimize appropriately. Please take your FUD elsewhere.
The original reason for inconsistent function naming is that the founder originally used length for hash function. See: http://news.php.net/php.internals/70691
&gt; The == operator is the core of loosely typed languages, and is immensely powerful. You really wanted to make me laugh ?
Looks like (the now sadly dead) Editra!
http://www.webhook.com/ handles the editing interface as an Ember SPA. Netlify has one in the works. I think it is or will be open on github at some point.
That's correct; I should have mentioned that earlier.
No one in the scipy ecosystem gives a rats arse about how cool the PyPy implementation is if it doesn't perform better for our workloads, and forces us to throw away decades of accumulated trust in our stack. PyPy could learn a lot from how new projects make their way into use here. PyPy rewrote the world, they need to show why the new world is as trustworthy as the old one. Because unlike bullshit web services so you can facetweek your likes to snapchat, it matters that our results are repeatable, reliable, fast and correct - you know, for knowledge and that sort of thing.
Yeah, we're working on an open-source CMS for static site generators. It's currently in private beta, until we feel the whole getting started path is easy enough to open it up to the world. We're happy to give people interested in this field early access. Just ping me at matt@netlify.com and let me know your github username. The idea is to make a general UI for website content editing where the content is stored in a Git repository and built with a static site generator. it works with any staticgen and we focus on keeping the UI very clean and simple for end users, and make it easy to adapt the UI to your specific site.
Good job. If you and the OP are what constitutes the majority of PyPy supporters, you have just convinced me that jackasses are part of every language/community, no matter how friendly the overall community is in all.
I didn't want to public state the guilty ones. Especially as one of them has made many meaningful contributions to Python and I generally have great respect for him but was highly disappointed with the smear campaign he ran. Your code doesn't have to be purely Python to run fast on PyPy but unfortunately at this time if you are using the scientific libraries your not likely to find PyPy helpful. I believe at this point about 80% of NumPy tests are running correctly on PyPy and some tool needs to be built to rebuild the glue/wrapper code for the scipy libraries to make them compatibility with PyPy. Matplotlib is already compatible except for the GUI backends. Someone is working on a cffi module for wx so so soon it should be easy to get the wx backend up and running. Recently PyPy has added SIMD so when when the remaining test failures are resolved in PyPy's NumPy module it should run faster than NumPy under CPython. Plus when that state is reached the PyPy devs can re-enable some improvements to the JIT that were designed to optimize operations over multiple arrays without creating temporary arrays which will significantly improve performance.
keep telling yourself that, you fucking queer. 
 You shit on people's work, proclaim falsehoods and *you're the victim*? If I were representative of the PyPy community, I wouldn't want toxic people like you anyways. All you do is take and lie. Good riddance. At least I can use Google as opposed to talking out of my ass. 
&gt; All you do is take and lie. Good job talking out of your ass. I'm talking shit because your attitude is shit. I have seen your other replies in this thread; instead of answering questions you are just like a blind follower preaching your propaganda. I hope the PyPy community kicks out suckers like you who give them a bad name. I am done with your childish games. I hope that instead of replying to this post you'll go and do something constructive.
Try tone policing some more. That might be productive. I'll keep on coding and enjoying the closest thing we have to a JVM. And it works.
Have a look at this. It's for pygame, which is what I think you're using. http://stackoverflow.com/questions/312263/effective-keyboard-input-handling 
This is really one of the coolest things I've seen done with python. 
bb should work
Thanks for the clarifications. It seems that PyPy community is indeed in dire straits. With little to no funding, I'm not sure how many external contributors you would require to get the entire body of work done when it comes to re-writing the old API modules (which includes Numpy and others). What do you think are the problems with PyPy adoption as a whole? Is it the whole slew of external libraries which use a lot of old API or is it just the scientific tools adoption? Was there ever a poll conducted to understand from existing Python users why they are not using PyPy? Also, if there is a lot of work still done, any reason why you folks don't have a weekly newletter release just to let everyone out there know that PyPy is live and kicking? Any chances of moving the STM research money to accelerate the NumPy adoption?
I guess I should have said Windows store app. Deploying on windows is easy, deploying a Windows App, not so much. Ninja edit: Well, I have found a version of Python that [runs on the Windows Runtime](https://hg.python.org/sandbox/loewis/branches). It is actually pretty cool. I am thinking that figuring out how to bundle that and a file is the next step.
Why should I use netlify and not github pages? https://pages.github.com/ --- EDIT: ahh... sorry - I get it... you'll have also an online editor for the static content.
Netlify CMS is not tied to our hosting platform in any way, it's simply an open-source CMS for static site generators. You could definitively use it with plain Jekyll and Github pages. As for why you would use netlify over github pages, apart from their terms of service limiting you to sites for your open-source project, there's a ton of reasons: HTTPS Redirects/Rewrite rules Deploy without polluting your git repository with build assets Proxying Asset fingerprinting and far future caching header (gets you better page speed, better page rank, etc) Builds anything (Middleman, Roots, Pelican, etc, etc), not just Jekyll with no plugins Instant Cache Invalidation (Github pages will set a 10 minute max age on all your files) Built-in Form Processing Browse any old deploy and do instant rollbacks Triggering builds via webhooks (super useful if you're integrating with external content sources like Contentful, Prismic, Google Docs, etc) And much much more... We're the most fully featured static hosting platform and aim to keep pushing the limits for what you can do with a static approach.
Disclaimer: This is an unofficial client package. I'm not affiliated with the folks at Robinhood Markets Inc.
I wouldn't say PyPy is in dire straits. It's support for the science community is not great at this time but it does well in many other areas. From what I experience, PyPy has been adopted at a much higher rate than Python 3 for production systems, so it's doing something right. Ever since CFFI has been released PyPy has been picking up steam, especially as more cffi modules become available. So I expect to see PyPy go more and more into the main stream. For quite a while only the projects that could afford to be on the bleeding edge would use it. In a year or 2 I wouldn't be surprise if 20-30% of production Python systems are using it. I don't recall every seeing the PyPy project perform such a poll. I don't think it is absolutely necessary for them to perform one as they get lots of feedback through the mailing list and IRC channel. They generally know where the pain points are and are constantly reducing them. They are also quite useful if you have any issues with trying to adopt PyPy. They tend to bend over backwards to help anyone and if you find any issues they generally handle them very quickly. Many times they have fixed issues brought up on the IRC channel in less than 10 minutes of when they were reported. I don't necessarily think there is a huge amount of work that is left to get NumPy and scipy working to make it usable for a lot of scientific applications. It's likely less than a man year of effort but the two who generally work on this effort do so on a part time basis. Outside of release notices the PyPy community has been fairly quite about keeping the larger Python community up to date on what it has been working on. The last NumPy blog post was back in February and I know a decent amount of work on NumPy has been done since then. They definitely need to increase their communications. They have been working on some big refactoring projects and new features that should soon will be available so I'm sure they will be blogging about them soon. I highly doubt they would move the STM funds to help the NumPy adoption. The money was donated for the STM effort and it would be wrong for them to use it for something else. Plus why would you want them to do that. If their STM plans ends up producing a working solution that can be used for production systems it would be a game changer. They would be solving the holy grail issue for Python. Finally having a way to essentially eliminate the GIL. I guarantee if they get STM working the whole scientific ecosystem will be ported so fast to PyPy as everyone will want the benefits. The scientific community ignoring PyPy would be a thing of the past as it would disappear over night. But before you get any hopes up, STM is a highly research project at this time and there is high risk it may never be used in production although some results do look promising. We just have to be patient and see what becomes of STM.
Damn there are a few out there. Im a major in info science so my programming knowledge is not enough to build form scratch. In terms of putting a UI on top of markdown i was thinking i build a javascript based html to markdown? seems somewhat working backwards but right now its the only thing i can think of. Although pelican and jekyll support html as the markdown, my other difficulty is the way i would go about making custom templates in similar manner that would allow for customization.
This is laughable. People use asynchronous events in JS (I believe it's what you meant), because there is no other option since JavaScript does not support multithreading nor multiprocessing. With only asynchronous events your application can't for example respond to two requests at the same time i.e. if one user makes a request that takes long time, everyone else has to wait until that request completes. The best approach is to use mix. It's also silly to mention asynchronous events as a strong reason to use it, when the language doesn't support anything else and that's the only way to handle multiple requests.
Interesting. It would be an expensive but interesting exercise to create a day trader bot.
What is that asymmetrical threading you are talking about?
Can you do a list comprehension inside of a list comprehension?
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
Yes 
There's something important about caring about writing good code. But even more important is to know when not to bother. =)
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
Having trouble setting up. Can't find the option in the interpreter to include github folder. Help!?
I read the architecture comparison and still lost. Except for embedded, when to use SuperServer, SuperClassic, and Classic?
I think there's a website that is the real stock market but fake money and you start off with a certain amount. You could have the bot to trade on that as a test. I don't remember the name of the site though. 
I recommend as a beginner you use Ubuntu and PyCharm. Ubuntu is easy to set up in terms of Linux and has a big community. Managing virtual environments and pip is also easy in Ubuntu and it can be used as a deployment platform. PyCharm is the best out of the box Python IDE. You can start using it right away without configuration. You can use the free community version. When you have your Ubuntu python virtual environments set up you can add specific interpreters in your PyCharm project for code completion and testing.
In supercollider? Edit-&gt;Preferences-&gt;Interpreter
Ah, that's a great idea! Free training!
In Py3 a range is a generator (xrange, iirc, in Py2), so there you do need to convert it to a list.
Oh wow. I'm shocked at how badly that person missed the point.
The physics post was interesting, but I felt like it was missing something - the path of the ball on the spacetime plot. You talk about it - how the ball would initially travel along the blue arrow, but I'm having trouble imagining why it would depart - why the path towards the earth (the normal gravity path) is the "straightest" path in this curved space.
It costs money to download the libraries yourself and do the building/linking, but it looks like there are places like this where you can download libraries someone else has linked.
[removed]
Quantopian. Great place to get started. You can backtest your Python algorithms on their servers to use their repository of historical data and get fancy graphs. Once you fine tune your algorithm on their server, you should be able to download the code and run it locally without modification using their open-source trading library: https://github.com/quantopian/zipline Using zipline, you can just import robinhood, replace / supplement their "order_target()" methods with "Robinhood.place_buy_order()", and run your algorithm live using Robinhood's API. Edit: Deleted and reposted this comment because it seems to have been caught in the spam filter. Reworded instructions to make it clearer how to use benkroop/robinhood with quantopian/zipline. I'll probably add instructions for this to the README.md because I know others will want to combine the two.
[removed]
No, it's not a generator, it's a range object. &gt;&gt;&gt; sys.version '3.4.3 (v3.4.3:9b73f1c3e601, Feb 24 2015, 22:43:06) [MSC v.1600 32 bit (Intel)]' &gt;&gt;&gt; foo = range(10) &gt;&gt;&gt; type(foo) range &gt;&gt;&gt; foo[3] 3 &gt;&gt;&gt; len(foo) 10 &gt;&gt;&gt; 3 in foo True &gt;&gt;&gt; foo.index(5) 5 &gt;&gt;&gt; foo.count(1) 1 Again, you don't need to convert this to a list unless you intend to mutate it. 
* https://github.com/cmattoon/scrapy-craigslist * https://github.com/mjhea0/Scrapy-Samples * https://github.com/masterfung/scrapy-craigslist 
Will 3.5 be a drop-in replacement for 3.4?
- *IronPython*: My application is mostly written in C# (or VB.NET), but I want to add the plugin architecture into the app. Plugins would be written in Python. - *Jython*: The same to above, except for Java instead of C#. - *PyPy*: I have enough memory, and my app does so many computations rather than I/O. - *CPython*: I have no idea.
is it backwards compatible with 2.7?
This is great. I tried making something like this about six months ago but, when trying to read the packets (with [Charles](http://www.charlesproxy.com/)) the app would consistently fail to connect. How did you go about figuring out the API?
Yes, please no one ruin this for the rest of us. :-)
PyAudio is pretty clunky to use, I find. I would recommend `sounddevice` instead, which also interfaces with portaudio, but with a much nicer API and providing wheels (i.e. `pip install sounddevice` will work on Windows and OSX even though there are binary dependencies). PyAudio is simply a wrapper for portaudio, sounddevice is a wrapper that tries to make portaudio pythonic. It provides a proper Stream class with `play` and `record` methods and callbacks for long-running interactive recordings. Additionally, there are some high level `play` and `record` standalone functions if all you need is play or record one short sample. Finally, sounddevice uses CFFI, and is thus compatible with CPython *and* PyPy. Full disclosure: I contributed to PyAudio back in the day (did the Py3 port), then built my own successor much like sounddevice, called PySoundCard, to which the creator of sounddevice contributed heavily. He then built sounddevice as a successor to PySoundCard since I didn't have enough time to develop it fast enough. I now heartily recommend you use sounddevice!
Cool, I'll have to look into that! Looks like it was released after I was trying to find alternatives to PyAudio-- which I agree is pretty clunky, but at the time it was the best I was able to find.
Python 3 broke backwards capability with Python 2. That's why they bumped the major version to 3.
Jython is the best for testing Java code. It's a beautiful tool for this purpose.
Are you implying that I might be a homosexual? Would that be a problem for you? You appear somewhat offended.
Cool! Yeah, that's what I had figured w.r.t. resisting the MITM traffic. It totally skipped my mind that both the Android version was released and that I'd be able read its source directly from that.
The downside of `time.time` is that it might jump around since it's subject to changes from time adjusting tools like ntp. This would be devastating in the use case described by OP. It seems to me that a monotonic timer would be more appropriate here. A monotonic timer doesn't jump around in time. The speed at which the monotonic timer advances will only be adjusted slightly in order to stay in sync with the flow of the time of the real world. But it will never jump from like 6 to 9 like `time.time` does. This is also why monotonic timers are preferred in benchmark tools.
For me, the downoad of [python-3.5.0rc3-amd64.exe](https://www.python.org/ftp/python/3.5.0/python-3.5.0rc3-amd64.exe) has a bad gpg signature (and a bad md5sum). The webinstall version has a good gpg signature.
What point are you trying to make?
Have an upvote for a sense of humor =D
ASN-1? S-expressions?
Have a downvote for a poor sense of humour =D
I actually have an LD_PRELOAD wrapper which I was working on that gives python and c/c++ callstacks, if there is interest I will see about open sourcing this.
Hey all, i'm the author of the post. Feel free to ask me any questions directly and I'll try and keep an eye on other comments here. Enjoy!
Both of you have a no-vote because I find this entire situation hilarious and don't want to ruin the downvoted 'upvote' post and the upvoted 'downvote' post juxtaposition.
If you want to display the values you can iterate over them in the function that generates the output. That doesn't mean you should store lists in your actual data structure though. 
You're going to have to keep a reference to the past user entered on the system, unless the API offers that functionality. 
Does Anaconda support 3.5 yet?
you can remove ".ratio() * 100"
Robinhood is the broker here. They hold your funds. That's partially how they make any money. Unused funds are lent out / invested with by them.
I liked click and started to use it but went right back to argparse because I couldn't find a way to support variable amount of options. like for eg: * python prog.py -x 1 2 3 -y 6 5 4 3 * python prog.py -x 1 -y 0 Only made this work in argparse using nargs='*' option. Is this even possible in click?
Thanks! And I totally agree -- image blur detection sounds pretty dull and boring, but it's super useful when you've got a big dataset of images to sort through.
[docopt](http://docopt.org/) all the way! :D
Then it wouldn't be 5 lines of code anymore, would it. The function that generates the output is `pprint.pprint`. This is the wrong context for doctrinal purity.
What is Robinhood Markets' business model?
excellent post. would be nice to see a robinhood HFT system to level the playing field
Well, how are you computing the cross-correlation?
Retried. Same result. I'm using latest Firefox on Win7. Tried Chrome and downloaded exe with right md5sum and it verified with gpg. Remembered previous similar problem with Firefox. Cleared cache, restarted Firefox. Now it downloads the correct executable too. I'm glad I routinely verify my downloads. Not sure if I'm ready to switch my primary browser from Firefox to Chrome though.
no problem with {}, but [] is perfectly fine for me as well, so i don’t really see the need for new syntax here. and yeah, i agree: they shouldn’t have added those meaningful comments at all. no matter if it takes another release to first get the syntax for inline type annotation in place and only then implement the typing module.
Since they have so many pictures, they could use deconvolution deblurring to fix the blur.
I don't work on their backend, or for them. Don't have that answer for you. They are not a HFT solution, so I have never been too concerned with who their channels are, but they are a real licensed broker along with Securities Investor Protection Corporation (SIPC) insurance, the same as any other broker you might use, and probably would never ask about their channels. The main crux of what robinhood does is bringing post 2005 technology to the trading world. There's no reason why you need to pay $7 for a trade to occur... other than extreme inefficiency as well as the lack of incentive to do away with that model. Robinhood's point is to show that you can trade for free and do it as a company, showing that they can make money just like every other bank does. 
$sdl-config returns: Usage: sdl-config [--prefix[=DIR]] [--exec-prefix[=DIR]] [--version] [--cflags] [--libs] [--static-libs] I've both SDL 1.2.15 and 2.0 frameworks installed...
Great analysis. Even with the libraries, there's so much code involved, it's hard to see what the benefit is over just rolling your own parsing logic.
I found [this stackoverflow question regarding my topic](http://stackoverflow.com/questions/4476373/simple-url-get-post-function-in-python) It seems like the library "requests" could solve my problem? Any verification on that?
&gt; I know nothing about Heroku, but I believe it is a little more challenging to set up. I see absolutely no point in doing that, when you can pay $5 a month for digital ocean and have full reign. You just create a Heroku app and push to it (using Git). It's a lot easier than setting up your own server with, e.g., Digital Ocean (although it's also more expensive).
I just got back from vacation with thousands of photos as I just spray-and-pray all the time, this code will help me a lot, thanks!
Great work, congrats! Will you include countries in the future? 
Computing the slope of the orientation collapsed Fourier coefficients is actually quite robust. There have been about a dozen papers on this and a slope of -2 for clicky, click images is ubiquitous. If your slope is steeper, determining the cutoff is simple because its dramatically different, you are out of focus. And yes, the slope is one floating point number without the need for convolution, which in this case happens in the image domain. Far less efficient than going into the Fourier domain first.
As a developer primarily on Windows, hearing about this a few weeks ago was HUGE! The Visual Studio dependency is the biggest pain in the ass while working with Python on Windows. One of the nicest features of Python is, "it just works." Except when it doesn't...which is almost always when installing C-based modules.
Besides introducing a lot more potential for bugs, it would be quite a bit more code to roll your own. You're right, though, that they require similar amounts of work to use. I tend to always pick argparse and save my users a dependency. Beyond that, it's just personal style preference, I think.
Cool !
The thinking was that `{}` would sidestep the issue of duplicate meaning (since there is no existing use for `x{}`) and therefore avoid having to capitalise list, dict, etc. Yep, feels like the rush to get it in quickly will bite us in the backside when (inevitably) a *better* way to do it comes along. Not that Python is against reversing earlier decisions (e.g. `u'strings'`) but it makes for a bit of a headache for backwards compatibility. If this change was coming in 3.0..3 it wouldn't be so strange, but 3.4 was the first really solid implementation of the 3.x line, and here comes more iffiness. But decisions made, no point whining now :)
use pastebin
was it [this file](http://svn.code.sf.net/p/fceultra/code/fceu/trunk/SConstruct)? If modified properly it should look like [this](http://pastebin.com/phgrBLw2)([raw](http://pastebin.com/raw.php?i=phgrBLw2))
This would be great to work into a Lightroom Plugin. It could scan the library and add the blurriness to metadata, then allow you to use Lightroom's library filters to quickly search for + delete blurry photos. If I had time, I'd look into implementing it.
Haha, I'll add Python 3 support in a few days
Nice.
Can you put the error msg on pastebin or imgur?
What happens of an image of a small object with a lot of background, but clicked with an aperture setting that causes the background to remain blurred? Like, [a macro image of a beetle]( http://7-themes.com/data_images/out/51/6945680-macro-photography-wallpaper-free.jpg ).
If you have any links handy to those papers I would love to check them out.
Been working professionally with PHP for some time now. Agree largely with the fractal. Sure, some is dated, but a lot of it still applies in full-force.[This](http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/#error-handling) is still a massive hassle to me all the time. I have had to try and use htmlentities on a potentially empty input string before. Guess what? That means that this: $var = htmlentities($input); has to become if ($var !== NULL and $var !== "" and $var = htmlentities($var)) return $var else throw new Exception('bad input'); to ensure I don't catch a genuine empty-string as an error, and don't catch an empty string as valid when it was signalling an error. If I use the silent replacing flag on it then I risk some other issues, and it may well be a bad idea in many contexts to use the unicode replacement char, so I can't trust either of those behaviours. And how about the fact I need to set a handler to give me a stack trace on uncaught exception? Really? Similarly the php_uname deal where it gives you two vastly different pieces of information that are superficially the same depending on its ability to determine the system it's on. And won't tell you if it does this switch in behaviour. The inability to trust the function can't even be fixed with boilerplate to check a few conditions out, it's just unusable. The module system is still... well still *isn't*. Most of the other criticisms still also apply in general. Most will still apply when PHP 7 is out. 
I was curious to what this would look like, so I put together a quick and dirty version. I really can't see how rolling your own parsing logic would be simpler or better if your program isn't super simple. #!/usr/bin/env python """Usage: greet.py hello [--caps] [--greeting &lt;greeting&gt;] &lt;name&gt; greet.py goodbye [--caps] [--greeting &lt;greeting&gt;] &lt;name&gt; greet.py (-h | --help) greet.py (-v | --version) Options: -h --help Show this screen -v --version Show version number --caps Uppercase the output --greeting &lt;greeting&gt; Greeting to use [default: Hello/Goodbye]""" import sys def error(msg): print('error: {}'.format(msg)) sys.exit(1) def parse_args(): if len(sys.argv) &lt; 2: error('missing subcommand (hello|goodbye)') elif sys.argv[1] in ('-h', '--help'): print(__doc__) sys.exit(0) elif sys.argv[1] in ('-v', '--version'): print('1.0.0') sys.exit(0) elif sys.argv[1] not in ('hello', 'goodbye'): error('incorrect subcommand, should be (hello|goodbye)') try: sys.argv.remove('--caps') except ValueError: caps = False else: caps = True try: sys.argv.remove('--greeting') greeting = sys.argv.pop(2) except ValueError: greeting = sys.argv[1].title() except IndexError: error('missing --greeting paramenter') if len(sys.argv) &lt; 3: error('missing argument &lt;name&gt;') elif len(sys.argv) &gt; 3: error('too many arguments') else: name = sys.argv[2] return greeting, name, caps def greet(): greeting, name, caps = parse_args() output = '{0}, {1}!'.format(greeting, name) if caps: output = output.upper() print(output) if __name__ == '__main__': greet() 
Great article! Having a comparable value for blurryness appears very useful and interesting for a multitude of reasons. Out of curiosity, what are the bounds of the "blurryness" value? I assume you would get a 0.0 if the picture would be only one color? What would be the maximum value and under what circumstances would that happen? I could imagine some sort of grid, perhaps?
&gt;Current PHP is fast On par with most other similar languages, but it doesn't matter. If speed really did matter to you, then you'd use Java, Go, Rust or similar. &gt;super easy to deploy, Only in the broken model of mod_php which is throwing reasonable, simple security measures out the window. The web server should have the least amount of access that it can possibly have to get its job done, and leaving code in the webroot is just asking for mistakes. (Like a big one Tumblr made a year or so ago.) &gt;easy to maintain How so? How so *in any way that doesn't apply equally or more so to other languages?* &gt;and learn So easy to learn a language that doesn't even have the decency to give a good stack trace as default unhandled exception behaviour. &gt; I can't think of a single reason why somebody would choose Python over PHP when creating a Web Application other than "hurr durr, php is weird and broken". NumPy. Virtualenv. Interfacing with Java with Jython. Interfacing with .net through IronPython. 
HFT is about executing thousands of trades per second, having colocated servers, and getting the most real-time order book and tick data. Executing a bunch of market orders over the course of several seconds through the Robin hood API and calling it HFT would be wildly inaccurate.
Even Guido said idle sucked and needed to be replaced. I admit, though, I still use IDLE for some small programs.
Sure! http://pastebin.com/EAY3nVhW
I was just saying its a good starting place if you just wanna create some cmd applications.
I personally would not use Python for games, at least not on the client side. The interpreter performance is mediocre. The multimedia ecosystem is lackluster. Distribution is a nightmare. As far as a 2D MMORPG goes... Java isn't a bad choice (with a good framework like LibGDX). The rockstar new hotness is to build your game client in JavaScript to run in web browsers. I've played a few 2D online multiplayer games done this way. There's no reason you can't use Python for the server code, though. In fact, I encourage it!
its almost the same, but now it seems pkg-config is not installed
I'm sure it's something quirky with Mac OS X.... I've run into so many strange, quirky problems with this build.
Very nice, man! It does give me a lot of insight on updates I can make on my own youtube-dl based scripts.
[blargs](https://github.com/gyllstromk/blargs) and [Argh](https://pypi.python.org/pypi/argh) are my 2 favorites.
Very nice introduction to requests and JSON!
Fair enough.
I've tried both and I prefer WinPython because it's easier to get Python v3.4 up and running. I'm a new convert to Python with no legacy code and I don't care about the old v2.7 standard. It's inferior and people need to move on.
What happens when I don't follow through after the course?
&gt; Distribution is a nightmare. Honestly all other reasons take a back seat to this one here. 
&gt; So the concerns regarding the typing module[1] and how extremely unpythonic it is haven't been addressed? And this will be going in 3.5? That would take people starting a discussion with devs on the core mailing lists (which anyone is absolutely free to do), and suggesting concrete improvements. Rather than purely complaining on reddit. I suggested that last time when Rc2 came up, and it was complained about in the reddit comment thread, obviously no-one cares enough to actually raise a discussion behind their complaint.
Nope! I think it's great there are some packages demanding to be able to use python 3 features in their implementation.
I wouldn't recommend using Python for making a complex game. Maybe try Java or C++ instead
Have you been to that site? Its full of ads begging for money.
When running under PyPy the error messages should be the same you would get while running your code under CPython so you shouldn't end up with horrible error messages. Unless you were running code as it it were RPython code instead of Python code. Only those who are writing code for an interpreter should be writing RPython. PyPy does support most of NumPy, most of matplotlib unless you need the GUI backends, does not support scipy today but there have been discussion on how to add it so maybe it will be available in the short to mid term, I'm not sure about VTK. Work is currently being done on a CFFI module for wx so once that is done it likely wouldn't take long before the wx GUIs work in matplotlib. 
I remember when we used to say what KIND of API we were talking about. When did the web developers get to co-opt that term for their own? I was using APIs before the web was even a thing. Damn kids. Get off my lawn. Etc.
Apply a profiler. Figure out where your code is spending the most of its time. Optimize the methods and functions the profiler exposes. Examine opportunities to avoid extraneous computation. Same as any other software.
I'm comfortable with argparse but I'm annoyed that the help doesn't list the help for all the subcommands. you have to specify which subcommand you want help for.
I'm really not sure about this one. As far as smallish artists go who don't exactly make a killing doing this, I'm not sure how their music can be good enough to worth downloading the stream (at 128kbps MP3 - not really worth saving) but not good enough to be worth paying for it and downloading the FLAC.
I mostly made it as a learning experience and because I use bandcamp a lot. I also never buy digital music because I don't see the point, If I like the music I usually buy a physical item from the artist. Edit: Also I have a lot of audiophile equipment and I strongly believe that FLAC doesn't really make a difference and is never worth the huge file size. The streaming files are on the lower quality side but they're not too bad and don't notice a huge difference either. 
I have done many reviews to assist the people asking but I never have had to pay for them. You would be better off vetting potential reviewers and offering the course for free in return for the review.
&gt; Especially when it's too late for that. Yet again, as I mentioned in the previous thread, it's still not too late. The implementation is provisional for the whole of 3.5 so it could still be changed around for 3.6 before it gets 'set in stone'. It's following [pep 411](https://www.python.org/dev/peps/pep-0411/)
No love for [argh](https://pypi.python.org/pypi/argh)? :(
Why sad face?
For quick questions, quick answers I often go bug the good people at IRC #python. be considerate - help people help you, follow the etiquettes, keep your questions succinct and precise (unlike the silly rambling you have here), use paste boards. 
Wakari
[Standards](https://imgs.xkcd.com/comics/standards.png)
So get your editor to syntax-highlight F-strings in a different color. That's how vim handles interpolated strings in ES6. Strings were never really black boxes where nothing can happen, at least since % formatting's been around. `'%(foo)s %(bar)s'` is literal text by itself, but if passed to a function that does `text % mydict`, it requires that mydict have keys foo and bar.
The clearest milestone in programming is "no longer sure it's broken". Some people mistakenly call that "done". Testing is what goes between those.
hey is the python logo on top left not too big? edit: nevermind. look like my browser stop loading and make the image too big.
And I thought having two primary string formatting methods was already hypocritical. Now we have three. (I'm not counting string.Template, as it seems little used to me) Can Python retain its ethos of simplicity and obviousness when it seems like the only major improvements made to it are in the form of additional complexity?
:)
Sweet! Now I can write Perl using Python!
We have 3 ways to format string in Python. Why so many? Let'd introduce only one general format to replace all others! Ok, now we have 4 ways to format strings in Python
Just like reading an article from a writer that's just a little too into synonyms
&gt; This pep appears to enhances readability by having the place holders inside the strings themselves and eliminating an explicit list of variables. But in reality, while reading code, we usually don't care what is inside the strings. We do not 'scan' strings. Exactly. What happened to explicit over implicit. I'm very surprised to see this approved.
I've seen enough people do `"%(foo)s %(bar)s" % locals()` that it just might be a harm reduction approach. I do agree that implicitly encouraging people to use this when they would have done something more reasonable is a worry.
You should post this in r/learnpython too
I prefer this to the other two methods, but sort of agree that having three is a bit crazy. I don't know the history behind this, but to me it reads like something that should have probably been looked at with the switch to Python 3 - add this new method, drop the %s method. 
webfaction is pretty decent. Focus on the important stuff, let them do the rest. Good support.
With the type hint syntax, async* keywords, and now this, it seems Python3 is just becoming an ugly wasteland of "let's pick stuff from other languages and shoehorn them in as quick as we can". It's a shame. 
Not until we get strings between '/' to to automatically re.compile and add support for =~ operator. And allow variable names to start with '$'
It makes it more convenient to write code that has SQL injection issues. The new syntax is much more compact than the query/parameter split in the database query functions, so people will be tempted to use it. It would have been much better not to construct a string immediately, and build a special format-with-holes-and-parameters object instead.
explicit over implicit &lt; practicality beats purity. don't be a bible basher
&gt; In reality, when reading code, we are often looking for variables when I'm reading about the creation of a string, I' m wondering which variables are placed where within the string and ctrl+F will find the variables every single time as well - - - &gt; Strings are no longer black boxes where nothing can happen. they still are and they always will be, f-"strings" are just implicit concatenation (if you quote zen at this you are a silly person) of multiple expressions, there is nothing "stringy" about that, its just that strings have the best representation for such a structure, in terms of where it sits mentally
&gt;they still are and they always will be, f-"strings" are just implicit concatenation.. it is not only implicit concatenation. It is implicit 'extraction of variables from current scope + concatenation'. So you take the same f-string and put it in another scope, and it can *evaluate* to another thing. Before this, string literals could not do that. Before this pep, you can take a string literal and put in anywhere and it will be exactly the same. 
Yeah OK, when you put it that way. I also agree somewhat with the clutter comments below. Not so much that this is a bad way to do things but do we really need yet another?
&gt; IMO this will be a big win for Python's readability. I don't disagree that the new method is incrementally better. I simply believe that the minor improvement is not worth introducing yet another method of string interpolation into the core language.
&gt;string interpolation is superior to the existing alternatives This kind string interpolation is the first thing that noobishly pops to your mind when you are presented with this problem. It takes a bit more real world experience and foresight to see the problem with it and limit it with things like format() function and % that require an explicit list of variables. Python originally had that kind of wisdom in its design. Now it is giving that all up with things like this.
Yeah, I know how `%` works; we're just talking about different things. `%(foo)` is totally just a placeholder with no inherent semantics regarding what it references; agreed :D However, when this operator is actually *used*, the format string and the interpolation operation usually occur within the same scope. That is, when the format string is created, it *semantically* references something named `foo` within the same scope, and that semantic reference is soon resolved—often on the same line. Maybe it would be clearer to say that the common idiom `"passed=%(passed), failed=%(failed)" % counts` suffers from the same readability problem as f-strings, rather than the `%` operator itself. I'm kinda curious how you feel about that idiom: is it bad in the same way that f-strings are?
Python is evolving, what a shame...
I think this is more a thing for debug print or log messages which you won't translate anyway
You make my blackjack game look like shit.
I like the motivation of this PEP but some part of it is weird as fuck. &gt;&gt;&gt; anniversary = datetime.date(1991, 10, 12) &gt;&gt;&gt; 'my anniversary is {anniversary:%A, %B %d, %Y}.' What's up with the mini syntax? Why can't one write normal python expressions like `anniversary.strftime(%A, %B %d, %Y)`? Why not adopt Ruby's *sane* way of string interpolation? It's not Zen of Python anymore. Obscure NIH DSL syntax over explicit. Edit: Shit is more fucked than I thought: `f'abc{expr1:spec1}{expr2!r:spec2}def{expr3:!s}ghi` Some people really wanted to extend life span of their keyborad.
`str.format(arg)` was introduced as a replacement for `str % arg`, which was intended to be deprecated and eventually removed. But too many people balked at that notion, so those plans were shelved. It's unfortunate, because `str.format()` is superior in every way and it does go against the Zen of Python to have two ways of doing something. (There is a separate argument about the need to do %-string formatting with byte strings, which was made impossible in Python 3, but reinstated in 3.5 after much uproar [see PEP 461], so you could say that things have somewhat regressed in this area.) I'm not really clear what you're counting as the third way; perhaps `string.Template`? That predates `str.format()` by a number of years. It's a much simpler system that lacks a lot of the power and expressiveness of both `str % arg` and `str.format(arg)`, so it was never intended to be a replacement for either, but a complementary way of doing string interpolation for simple cases. It never really caught on.
Thanks :D 
Really? Haven't really noticed.
&gt; `str.format()` is superior in every way It's slower
If you're on Windows, you can download it. http://www.lfd.uci.edu/~gohlke/pythonlibs/
People read from left to right. I don't like the way it looks and think that it does complicate the syntax by adding a new rule, but it makes sense. "I got a new {0} today ... requires the reader to look to the end of the line.
What happened to "there should only one obvious way to do things"? 
Not to me it doesn't, especially since it doesn't work (generator expressions aren't sized). You get a TypeError: object of type 'generator' has no len(). You need a list comp, `len([ ... ])` but why are you building a potentially huge temporary list just to get the length of it?
This also sounded interesting so I tried googling for it. The term 'orientation collapsed Fourier coefficients' has only ever been used, by u/homercles337, on reddit. Is there a better term for this, maybe that other people use? If I had to guess, It would involve taking the Fourier transform, collapsing to a 1D intensity vs distance plot and then looking at the gradient around zero frequency?
That's a nonsense argument. Virtually everything about Python is different than C. Python doesn't have value types, only references. Compound statements don't use braces. Whitespace is significant. Comments are different. String literals are different. Name resolution is different. Function semantics are different. And so on; the list goes on and on. What does this one trivial aspect being vaguely similar to C hold any significance whatsoever when everything else is radically different? That's like claiming that English is more familiar to people that speak Arabic because there are a handful of words in English like 'algebra' or 'alcohol' that are Arabic in origin than it would be without them.
There are actually more than 3 ways: - print() let you make some basic formating - + let you format manually - str.methods have a bunch of utilities to format - string.format and str.format can be used - % operator can be used - Template can be used - str.replace can be used if you are brave enough - and in 3.6, we will have f-string So why so many ? As usual the answer is history. Some basic formating have been made, then improved, then improved... And the old ways have never been removed. For some (like Template, zfill and the string module), it's just nobody took the time to do it during the 2/3 rewrite. We should have. But it required so much energy and time, and so few people were ready to give theirs. Python team is small compared to most languages. For others, it's because people like them: - print() is handy for quick print. - % is easier to write than format(): much less specal car to type for the common use cases, and shorter. - str.methods: we don't have format() equivalent for some such as upper(). - "+" is because eveybody expects it to work. You would get a riot by getting rid of it. - format() is just the most powerful method that we have. - f-string is a replacement for format(). Except you can't translate the strings, so we keep format(). It is less than ideal. But to be honest, when 3.6 is out, I'll only teach f-strings and print(). The other ones are circonstantial and can be learned on the way. 
Actually, it's complicated. Take something like OpenGrok- searching via symbols would find a variable being used in all the old string formatting, but not find the variable being used inside a string like that.
&gt; Why was this NOT done like this in the first place Unsurprisingly I can't read Guido's mind. 
I would guess that it's because the previous solutions were lightweight: it's hard to justify changing the core syntax when a simple String method would suffice. It could be that they tried the lightweight option first in hopes that it would be sufficient, but have discovered through experience that it's not, and finally decided that the overhead of new syntax is worth it. Total speculation, mind you, but there *are* explanations other than the crazy youths of today just trying to look cool.
Woah, how awesome! 
There's no requirement that the map is created explicitly for interpolation: it can be (and often is) passed in from some other source. For example, here's a very common way to format or otherwise create a debug printout of data from MySQL: def dump_rows(format, db_params) conn = MySQLdb.connect(**db_params, cursorclass=MySQLdb.cursors.DictCursor) c = conn.cursor() c.execute('SELECT * FROM table') return '\n'.join(format % row for row in c.fetchall()) And here's a way to reformat a list of anchor tags as either a table, definition list, or regular list: def reformat(html, global_format, row_format): links = BeautifulSoup(html).find('a') return global_format % ''.join(row_format % tag for tag in links) print(reformat(html, '&lt;table&gt;&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;URL&lt;/th&gt;&lt;/tr&gt;%s&lt;/table', '&lt;tr&gt;&lt;td&gt;%(id)s&lt;/td&gt;&lt;td&gt;%(href)s&lt;/td&gt;&lt;/tr&gt;')) print(reformat(html, '&lt;dl&gt;%s&lt;/dl&gt;', '&lt;dt&gt;%(id)s&lt;/dt&gt;&lt;dd&gt;%(href)s&lt;/dd&gt;')) print(reformat(html, '&lt;ul&gt;%s&lt;/ul&gt;', '&lt;li&gt;&lt;b&gt;%(id)s&lt;/b&gt;: %(href)s&lt;/li&gt;')) In each case, the analogues of 'foo' and 'bar' *never* appear explicitly in the source code. In the first, they are implicit in the database schema. In the second, they are implicit in the HTML spec. In both cases, leaving them implicit gives you *a lot* of power for very little code, at the cost of possibly pissing off your maintenance programmer (and then you can run your cost/benefit analysis over whether this is worth it...it's most useful for quick one-off utilities). You could, for example, take the format string from a command-line argument and end up with a generic tool for reformatting any sort of HTML attributes. You can make reports out of your DB with almost no effort. Connecting this back to your original point - the reason you're afraid of F-strings is that previously you've been able to treat strings as opaque data, and be certain that it won't break if you, for example, rename a variable. I'm pointing out that this guarantee doesn't even exist now, in the presence of format strings. The first example above will break if the DB schema changes; the second will break if the input HTML does. You can institute coding standards to protect against this sort of silent breakage, but then, you can do that with F-strings as well, and it's *easier* because there's a syntactic marker that interpolation is going on.
Frankly, I've always really wanted something like: pat = R/some_regex_pattern/g pat =~ data As ugly as regexes can be, `re.compile` isn't really high-value.
 print('stuff {0} thing {1} stuff'.format(num, name)) Why did you do it otherwise? Seems clean to me. Not arguing either way, your example just seems strange.
Well, you know how Lisp is often touted as simple? This is still nowhere near what the Lisp's format function allowed, e.g.: (format t "~{~a~^, ~}" list) which will take sequence list, and add commas in between each element -- except the last. At least you don't have a formatting character to output numbers as Roman numerals. PS another example, formatting [1,2,3] into "1, 2 and 3": ~{~#[~;~a~;~a and ~a~:;~@{~a~#[~;, and ~:;, ~]~}~]~} More fun in Practical Common Lisp: http://www.gigamonkeys.com/book/ 
Coming from Perl, I do really miss Perl regexes!
I'd say there's still unambiguously one and only one way to do things, just allowances for different situations. In each of those situations, the one way rule is still held. If you want to construct a string that contains information about the current context, use f-strings. If you want to construct a string that can contain information about a *future* context, use a normal string and the format placeholders. If you have a context and you want to insert it into an already-written formattable string, use the format method. There are other ways to do it, but the %-formatting system at this point is largely backwards compatibility, and the Formatter API is for complex formatting situations.
It seems to be a subset of requirements files: it specifies which versions of a package should be installed but not *that* a version of a package should be installed, so you can have organisation-wide constraints file to specify which versions of *possible* dependencies should be installed, but then each project can still have its own dependencies, you don't have to share a requirements file and install a crapton of dependencies you don't need just because that's what the org's requirements file lists.
Similar, for Python 2, and from a long long time ago is [optfunc](https://github.com/simonw/optfunc)
Perl had the motto "there's more than one way to do it" and look at all the good that's done; everybody has their own style of Perl and you either get unreadable code because you have no idea what the hell you're reading or you get unreadable code because it's so overly explicit about everything it does (in an attempt to compensate). One thing that Python really did well over Perl is to strongly prefer one way of doing things. We are humans with human brains and human brains like familiar patterns because we start recognising them without effort. It makes code easier to understand. Now we have 3 ways to format strings in Python. It just fragments coding styles and practices for no good reason. I personally don't use `.format()` much in my own code and consequently I can't read those format strings at a glance (or at least not to the degree with which I can read printf-style format strings). It's a small issue, but it means that sharing code (or simply reading others' code) is slightly more difficult than it really ought to be.
You can't compare % interpolation to something that looks like a string itself being executable code. "%s" is just data. It doesn't do anything. I can pass it to a function that does something, which includes the % operator, but alone it is just data. f"" looks like a string, but it's actually code. Apart from side-effects, it's code guaranteed to return a string, but it's still code.
No to mention the parallelism...
Nothing wrong with that code snippet. When PEP 498 was first proposed, before it was PEP 498, it was asked to just evaluate *names* and names only. That would have been nice. But, feature creep, and now it's a nanometer away from `str(eval(s))`. As an exercise, it's worth going through the Zen of Python and seeing how many of the Zen it violates. By my count, I make it 10.
As a PyPy dev I'd rather you argued against the body of this, and all other comments here, rather than having fun dismissing us all because you think Julia supports your view. We are busy using a stack that we trust. What can you do for us again?
What about this? mytemplate = 'stuff {}s thing {}s stuff' ... mytemplate.format(num, name)
How am I being dismissive?
Please respond to the points about trust.
If you use external log aggregators such as Sentry, they will group together messages that use the same format string (so you end up with the overview telling there were "1234 occurences of 'Sent email to %s' today" rather than a ton of separate messages).
well yes, but now it will be *even more convenient* and so it will happen even more
&gt; If you don't like it, don't use it. And don't read/maintain anyone else's code that uses it, right?
Plenty of love for argh here!
There must be some subtlety I'm missing here because the abstract says runtime and I'm not really clear on how that's different from compile time in python.
&gt; 3 different styles of string interpolation Four ways. Everyone forgets string.Template :-)
&gt; I'm talking about 100's of wordpress sites with same db's. Mostly never updated because of weird custom modules. Enjoy getting pwned.
You can do the same thing, but it's a bit different syntax. You cannot have the expression inside the string literal. The equivalent format works like this: "{}".format(x) "{}".format(x+1)
And what's wrong with `locals()`? Do you freak out when you see `len()` too? They're both simple functions with well-defined semantics.
Go got strings wrong (8 bit ASCII only). Then they added "runes", their name for text strings, but they got that wrong too. If Go was invented back in the 1990s, like Java, they'd have an excuse. But now? Too hopeless for words.
it's not even remotely the same. using locals to format is very bad, because you are passing a lot more variables than you actually need, it IS a security issue.
Are you being sarcastic? print("\x7b\x78\x2b\x31\x7d" f"") Take a guess what that will do. 
Yes! This is the best comment I read so far. Python is a pot full of great ideas. The folks behind these new f-strings are the same that filled that pot. The odds this is another good idea are very high. This is a concept stolen from other languages? As long as it is good, who cares. What other languages don't do is steal good ideas from Python. 
Depends what level it is parsed on, I doubt its going to run on postparsed strings https://www.python.org/dev/peps/pep-0498/#concatenating-strings Also eval already exists edit: &gt;&gt;&gt; '\"' r'\"' '"\\"' there is no precedence for infection even
arbitrary yet standard expressions?
Some sort of global/local difference?
ah the good old argument “my syntax highlighting hasn’t been updated so obviously it’s the syntax’ fault”. [please tell me how exactly the first example is worse than the following ones](http://image.slidesharecdn.com/codeoptimizations-100610031450-phpapp02/95/ruby-code-optimizations-for-beginners-5-728.jpg?cb=1276140613)
&gt; now it's a nanometer away from str(eval(s)). lolwat. you missed a very important detail which is that string interpolation happens at the position of the string literal. it’s syntactic sugar for an expression that combines a literal string with holes in it and some other expressions into a string.
exactly how you can with [string interpolation](http://image.slidesharecdn.com/codeoptimizations-100610031450-phpapp02/95/ruby-code-optimizations-for-beginners-5-728.jpg?cb=1276140613). so your point is that syntax highlighting definitions need to be updated? big whoop.
I don't get the rationale behind `!s`, `!r` and `!a`. Why add this piece of arcane syntax instead of just writing `str(expression)`, for example? The double brace is also super weird. Why would escaping braces not use backslashes, like, y'know, *every other thing* that needs to be escaped?
you don’t get it. maybe it helps to see proper syntax highlighting or read up on how ES6 does template strings. `f'foo{bar}baz{1}'` doesn’t mean “parse the string and then eval the part in the braces” it is simply syntactic sugar for `'foo{}baz{}'.format(bar, 1)`. no more, no less. the expressions get evaluated and then the format function is called with the non-expression parts of the string and the results of the expression, just like a function call works.
Thanks for persisting with that!
So because ruby has it, it's automatically a good idea?
UGH! The comments on this article are annoying! Why can't the author say he's tried many languages but always feels more productive when he's using Python without everyone trying to tell him to use their favorite language!? And so many of them pushing .Net languages. Really? C# is nice, it certainly pays my bills, but it isn't in the same league as Python in terms of elegance. 
Nope, I'm on Linux.
Highlighting still makes you to scan through the entire length of the string. So take your example and make it two or three lines long with 3 or 4 variables per line. Contrast that case with the case where you have nice, compact dictionary at the end of the string with a list of variables that is used for that particular interpolation. Which one do you prefer to read during the course of a frantic debugging session? Also, you didn't answer my question. I would like to know your thoughts regarding why, during the course of nearly 30 years and implementing two solutions to this problem, no one has thought to follow the most simple and straight forward way this pep proposes. Remember that PHP had this thing since the beginning, so this is not something new. 
This reads better: f'My name is {name}, my age next year is {age+1}, my anniversary is {anniversary:%A, %B %d, %Y}.' than this: 'My name is {name}, my age next year is {age}, my anniversary is {anniversary:%A, %B %d, %Y}.'.format(name=name, age=age+1, anniversary=anniversary) because you need two hops to see what's `{name}` in the second example: once to kwargs of `.format()`, second to actual variable definition. Given `name` is only used in `.format()`, you could write it as: 'My name is {name}, my age next year is {age}, my anniversary is {anniversary:%A, %B %d, %Y}.'.format(name='Foo Bar', age=age+1, anniversary=anniversary) 
would be a case for tagged templates like in ES2105: class SQLQuery { ... exec() { ... } } function SQL(strings, ...values) { values = SQLEscape(values) return new SQLQuery(...) } let query = SQL`from foo select ${bar}` query.exec()
The argument is that you now have static string content and variables mixed up. In the first example, they're clearly separate. Makes it more difficult to locate variable references. Not that I agree at all, syntax highlighting should easily solve that problem, but that seems to be the largest complaint.
Thx especially the possible use for testing really helps!
&gt; Highlighting still makes you to scan through the entire length of the string. no, that’s not how perception works. you see black blobs in a red line and can jump from spot to spot without having to waste brain cycles on the rest of the string. &gt; I would like to know your thoughts regarding why, during the course of nearly 30 years and implementing two solutions to this problem, no one has thought to follow the most simple and straight forward way this pep proposes. before the {} syntax there was only the horrible % syntax that nobody wanted to use for string interpolation
I liked the pep. But you do make good points. I can imagine renaming a variable and forgetting its used in a string template. The linter will have to be smarter. 
I want more limited feature. * feature is new string method. * new method can embed just variable. expression cannot be embedded. &gt;&gt;&gt; name = "Bob" &gt;&gt;&gt; age = 25 &gt;&gt;&gt; "{name} is {age} years old.".embed() "Bob is 25 years old."
I have always been annoyed by the verbosity, redundancies and inconsistencies in the current string-formatting methods (passing a tuple to `%`, the whole `"{a}".format(a=a)` thing etc.). In various situations, I ended up using a mix of those methods, whatever produced the most 'readable' and compact code, in my opinion. Both suffer from the left-to-right reading issue, `%` seems outdated but `.format()` is just so verbose that it often requires ugly line-breaks to keep the 80-character limit. The main benefit of f-strings is that syntax highlighting will be easily possible, as there is no ambiguity whether the string is going to interpreted. Once we have syntax highlighting in our major editors and viewers, most of the perceived readability issues will become non-issues.
python use to be simple. when go is half the age of python it will no longer be simple.
&gt; it’s an expression ... &gt; {age + 1}, my anniversary is {anniversary:%A, %B %d, %Y} This is why I'm pretty sure why I agree with :( --- edit: In other words, I think this opens the door to some wacky stuff being placed inside a string. e.g., f'this is my {funky.wacky(foo, round(bar * 1.0)/baz.function(): %d}.' and directly from the PEP: &gt; While it's true that very ugly expressions could be included in the f-strings, this PEP takes the position that such uses should be addressed in a linter or code review: &gt; &gt;&gt;&gt; f'mapping is { {a:b for (a, b) in ((1, 2), (3, 4))} }' I just disagree with opening that door. --- another edit: an even worse string i didn't realize was allowed: f'this is my {funky.wacky(foo, round(bar * 1.0)/baz.function(): {'%' + get.myformatter()}}.'
Most, if not all, languages allow you to purposefully write unreadable code. It's a side-effect that comes with turing-completeness.
When using ``locals()``, the keys of the dictionary returned by ``locals`` is completely decided at runtime. First by looking up what the variable locals itself refers to (people could have assigned anything else to locals), second by inspecting the current frame. f-strings are part of the grammar and are checked at compile time. Pylint could show a warning when an f-string contains an undefined variable. That is impossible, using ``locals()``.
&gt; So, format doesn't automagically pick up variables from the current scope, you have to explicitly pass them. How about this? There is nothing "automagicall" about f-string. You explicitly specify the variable name. The fact that you don't use the ordinnary syntax to do so and repeat it 3 times like in format doesn't make it magic. &gt; Okay, so format doesn't support arbitrary expressions either. But it does. It's just not at the same place: "{x}".format(x=x+1) Again, the fact that you have not the same syntax doesn't mean it's magic. It's not leaking scope, it's not playing with frames, it's just syntaxic sugar. 
Look, the proper analog is this: print('stuff {num} thing {name} stuff'.format(**parameters)) It doesn't take up any additional room and isn't harder to read, but it does obfuscate what exactly is being formatted, just like with f-strings. Like, where exactly is num and name coming from? num = 4 def f_string(): num = 3 print(f'{num}') if __name__ == '__main__': f_string() What should this return?
I still don't get it. You already can specify versions of the package you want in the requirement files and in setup.py. What the benefit of specifying "possible" dependancies VS actual dependancies ?
What?
There are two major issues with this: - `embed()` doesn't know about the `name` and `age` locals. It'd need to use some horrible magic to use the previous stack frame's locals, and even then, the limitations from https://www.python.org/dev/peps/pep-0498/#no-use-of-globals-or-locals apply. - Highlighters can't know whether `embed()` will be called, so they're limited.
That syntax is from the `format`. Already legal python. Nothing to do with this PEP.
there is no door. the same horrible expressions can be put e.g. into `format` calls: 'this is my {: %d}.'.format(funky.wacky(foo, round(bar * 1.0)/baz.function())) or string concatenations: 'this is my ' + str(funky.wacky(foo, round(bar * 1.0)/baz.function())) + '.' and this is exactly as bad. nothing changes here.
Okay, I could also imagine someone renaming a variable literally anywhere and forgetting it's being used literally anywhere else. What does that have to do with this PEP? I have faith in tool developers... don't you?
It really boggles the mind that Go managed to mess up strings. Pike was there when Thompson invented UTF-8 for crying out loud.
Are they really forgetting, or is it more like "intentionally ignoring"?
As others have pointed out, it was easy to write ridiculous `.format` calls that included all those things as well. If you encounter garbage like that, call it out and/or fix it.
&gt;But f"..." makes available all the locals No, it makes available only exactly the variables used in the string.
So it's some kind of override of the requirement file ?
If you're a web programmer, would you be okay coming across that formatting in your HTML Templating Language? This opens the door for code in strings.
The goal is not to make a template, it's just syntaxic sugar for format(), like @stuff is syntaxic sugar for regular decorators. Bacically "{foo}".format(foo=foo) is shor for f"{foo}". That's all. Nothing fancy.
Because who wants a language that requires an IDE to be usable? If I wanted that, I'd be writing Smalltalk.
you shouldn’t view the expressions as “inside the string”. [look here](http://jsbin.com/tayakoxesu/1/edit?output): f-strings are basically interleaved segments of string literals and expressions, just like `'a' + str(b) + 'c'` is, but prettier
It took me some time to begin to trust Numba. I prototyped a version of our system that used Numba instead of Cython about one and a half years ago and there were too many rough edges and limitations. I gave it another shot recently and it's vastly improved, although I've run into some scary silent errors in the previous release that silently returned garbage due to a bug in the new array memory management. That seems to have been resolved in the newest release although you can be sure that I have a very extensive py.test suite with complete coverage of anything that Numba touches. I think adoption has been rapid because it solves a very clear problem and it takes little effort to get it working in most people's current setup. Cython is fantastic, but involves a lot of boilerplate and causes you to have to keep two systems in mind while you program. It's not hard to do, but there is an overhead to it. Numba is more limited, but mostly involves just adding a decorator and being aware of Numba's limitations. I've also played with Julia and one of their stated reasons for existence is to solve the "two language" problem. For me at least, Julia and PyPy are in a similar place. Promising, but not in a state where I can do everything I need to do on a daily basis. But out of curiosity, I am going to sit down and update my version of PyPy and numpypy and benchmark it against some of our numba code since it should just involve removing the numba jit decorators and swapping the interpreter and I'll see how things stack up. It's an isolated piece of the code that unfortunately plugs into stuff that pypy can't interface with now, but I'm curious to know what pypy is capable of at this point since I haven't tested it lately. 
[look](http://jsbin.com/tayakoxesu/1/edit?output) it is “outside”, just like it would be in the case of `'a' + str(b+1) + 'c'` or `print('a', b+1, 'c')`. `f'a{b+1}c'` is just another syntax for the same; the `b+1` isn’t actually part of the literal, but a sub-expression of the f-string expression, just like it is a sub-expression of the operator expression in the first, and the function call expression in the second example
Pretty much. I wish Templates and "%" could die and be replaced by f-string but we can't, compat and all that...
You make your own decisions about readability. If the rest of your code is readable, what makes you think you're suddenly going to start cramming things into f-strings and making them unreadable? Write your code with an eye to it being read by other people and you'll be fine.
Who's using a Javascript obfuscator? Lots of places use minifiers, and with good reason, but that's why source maps are a thing.
Where's Laravel noodling the password stuff together with Eloquent? Lets see: namespace Illuminate\Hashing; use RuntimeException; use Illuminate\Contracts\Hashing\Hasher as HasherContract; class BcryptHasher implements HasherContract Nope.. no ORM there.
So how is this any different than format in that respect?
Exactly. I completely agree with you. But this that is what people tell when I mentions the readability hit associated with type of strings. 
Yes, but we don't all subscribe to that school of thought. This is no different than using `.format()` except that it's less redundant and easier to read. It's very Pythonic. Yes you can do Bad Things™, but nothing you couldn't do with `.format()` or string concatenation. In a way you could think of f-strings as a macro for assignment. What difference is there between these two? age = 30 x = f'My age is {age}' print(x) x = lambda age: "My age is " + str(age) print(x(age)) Edit: Fixed `int` to `str` conversion.
I fully understand what they are to the interpreter. The whole thing is treated as an expression. I get it. But to a human reading the code, they're "strings". They're called "strings", they're being used to create "strings", they're strings in your brain. They're strings. But they have Python code in them. This is the third try at string formatting in Python. It's okay that we disagree on this. I have other options. But to me this would seem to violate a lot of strongly held opinions you find in other "templating" languages. I think if people use it judiciously it will lead to some really nice, readable code. But there will be a lot of code written that will abuse this syntax and make for some PITA code. So why open that door?
I think you're inserting opinions regarding this change into my simple statement about f-types compatibility with more advanced symbol aware searching. 
Never heard about Dask and Castra before, they look really interesting. And it's always nice to see people using bokeh, it's such a cool library.
Everyone has seen the syntax yeah, but I think it is often the case that people are not aware that its extensible, or that the standard library extends it. `{:&lt;20}` is a standard string operation, `{:0.5f}` is standard too, both have pre-existing reasons to be there. `date.__format__`is a bit more esoteric, even if useful. The "only" way to find about it is to read the __format__ section of the datetime docs
&gt; and it takes little effort to get it working in most people's current setup I think that's what's important and what we have to improve on : reduce the switching cost, trust is not really an issue (yet?).
So the only difference is that you now have to scan inside "string literals"? If your editor is already highlighting strings differently, then it will probably start highlighting f-strings differently in the very near future. If it's not, how are you "skipping" the string literals now? Frankly, I'm **FAR** more upset by the 'mini-language' used by `.format` than by this; people make fun of regexes, but the formatting mini-language is the true abomination. I don't think I would have spent any time implementing this, and would rather they abolished '%'-style string-formatting before adding yet another way to do it, but once it lands, I'll probably use it, because it's just handier for the sorts of things I do with string formatting.
There are also a few different ways to write loops.
&gt; preferably
While you perfectly describe the PHP world 5-10 years ago (including crappy opensource projects that are still popular but outdated like Joomla or Wordpress), this is just not valid today. I'm probably very much living in a Symphony2/Laravel/r/php filter bubble. But coming from a Java background, PHP is a perfectly usable OOP language with features that Java users are still waiting for (like traits). The currently available ecosystem is just perfect for webapps. To see some examples for the code and package quality you see nowadays, have a look at [these packages](https://thephpleague.com/#packages) or the new [OctoberCMS](https://github.com/octobercms/october). What you see is thoroughly tested code, applying modern design patterns and development strategies. The whole ecosystem is built around *not* doing repetitive work but getting well-written webapps out of the door as quickly as possible. I'm not saying PHP is better than other languages. I'm just saying it's really not shitty anymore and perfectly suited for webapp development. As an experienced Java/Spring developer, I'd still need a couple of days for a working prototype that PHP/Laravel allows me to write in a couple of hours.
Okay, but stuff like '{}'.format(g() + 'hi' + '{}{:.2f}'.format(g(), (lambda n: n + .1)(2))) is already valid python (of course). Should every new feature be denied if there's a possibility that somebody might write ugly code? Opening what door? Should this be disallowed? 'blah blah ' + oh_no_a_function_call() Or is it that you don't trust Python programmers to not write ugly code? I think most, if not all, languages allow somebody to write ugly code if they want to.
Go has been designed with KISS in mind, while I have no doubt that Go 2 will introduce language features I very much doubt Go's authors would let it abandon its philosophy. There's good reason to believe that, since we're talking about the authors of Unix, B, Plan 9 and UTF-8 and they have heavily promoted Go as a language that's simple by design.
There is one obvious way to do things. Evidently the obvious way to do it is str.format(), str % fmt and the new string interpolation approval.
&gt; Source: 4 years highload production php development, 10 years of general python. Not using php since 2012 and happy with it. Similar background here. Except I looked at PHP again and it really made leaps since 2012. It's pretty much like two seperate communities now. There are those that live in the past and think it's still okay to run PHP 5.2 and there are those that write 100% OOP, decoupled, well-tested code following modern design patterns. It's really like a new world. So.. me: back to using PHP since 2014 and happy with it. ;-)
&gt; Code is **read** more often than it is written Yes, yes, yes!!! Typographer and programmer here.
Apples, meet oranges. 
That kind of did happen - this is based on the .format() syntax, which was introduced for Python 3, and the %s syntax was deprecated. But then they realised that there's loads and loads of code out there using %s, so it got un-deprecated again.
So much for "There should be one-- and preferably only one --obvious way to do it."
&gt; anti-intellectualist I have the feeling the PHP community is split along this line. Even in the core dev team of PHP itself. Strict typing in PHP7 was prevented by those people (who don't want to piss off their old users). At least PHP7 gives us a flag to turn on strict scalar type hinting.
The same place `foo` was coming from in the `.format` example. So long as the editor highlights the variable inside the string, I don't see this being a problem at all.
they’re not, once highlighters stop highlighting the nested expressions as part of the string. but good point about the name. technically they’re `expressions that evaluate to strings`, which doesn’t exactly roll off the tongue ;)
&gt; In the context of web development, here are the main python advantages in my eyes: &gt; &gt; * Clear separation between STDOUT and the stream being used to send a HTTP response. If you print something in Python it'll go in your terminal or a log somewhere, not the browser. In PHP, [PSR-3](http://www.php-fig.org/) takes care of that. So nothing you'll have to worry about in any modern framework &gt; * Much more flexible language. &gt; * You can write normal functions without wrapping it in a class &gt; * You can patch/decorate/mock all functions at run time without problems You don't have to wrap functions in a class. And if you want to pass by reference, Closures are your friend. &gt; * You can utilize magic methods and context managers to make your code very compact and readable What's different in PHP? The Laravel framework built their entire ORM around that. &gt; * Strong typing. You can't just add an int and a string, or concatenate a string with a boolean. Thankfully possible with PHP7. &gt; * Healthier ecosystem. Python packages are generally of higher quality than PHP packages. How so? Looking at packagist.org all popular packages are high quality and well-tested. I would even argue this is one of the strongest points in favour of PHP, these days.
I understood method issues. but one more point, I think a ugly that is format including expression. In now PEP, f-string syntax is able to too free anything. I don't love a below example that might valid. &gt;&gt;&gt; (f"{bob.nickname if bob.nickname else bob.firstname+' '+bob.familyname}'s " ... f"life goes on {(today()-bob.birthday).days} days from birthday.")
The same place "foo" is comming from where you write "foo" outside of an f-string. Just because you got f"" around foo does make it more magical. An f-string is NOT a string litteral. It's an expression evaluated at run time, just like format() is.
So what does this print? b = 24 a = f"b is {b}" b = 42 print(a)
The name sucks. It sounds like fuck-string honestly. The reason is nobody could agree on a better one on the mailling list, that's all. The string part is just that the syntax look like a string, which is a bit misleading from the semantic point of view, but is useful to avoid introducing too much technicity to a new comer. But having a bad name doesn't make it a bad proposal, just a poorly introduced one. But there is a reason it's poorly introduced : it has almost not been introduced at all. It's been propagated so fast as soon as the PEP was official you didn't have any article to explain it to laymen. And I beleive the reason everybody talked about it so quickly, is because many are actually super enthousiasts about this.
I think `"{}:{}, {}".format(foo, bar, foobar)` is less readable than `f"{foo}:{bar}, {foobar}"`. Yeah, you can abuse it to be unreadable, but you can abuse *anything* to be unreadable. I could put the entirety of my program in a multiline string and have a function called on it which evals it with some string replacements. That would be horrible, but I can do it. Imo python shouldn't not do something because it can be abused.
&gt; no. everything that’s highlighted in red is the string, everything else is code. is that different for you? why? edit: ~~I'm not talking about syntax highlighting done by the editor. In fact, I would hope the editor would apply python highlighting, not just "red".~~ Got confused here rebutted something you weren't saying, apologies. What's different to me is the context of what starts off as a string then finding Python expressions inside of it. It'll be colorized, yes, but you can't format it, and you'll have "nested" expressions on the formatting side of the colon. I see it differently than you. &gt; one idea to separate code and presentation? Yes, that idea... &gt; remember: it’s an expression. To the interpreter. To a human, it's a string. It has the same syntax as every other string in python. If it's truly meant to be thought of as an expression, then why not make it look like one? The reason it looks like it's a string is because it's meant to be thought of as a string (template). &gt; the only problem I'm not sweating gettext issues with this. That has it's own set of challenges un-related to this. &gt; what prevents people from abusing other syntaxes? What other syntactic sugar does Python have that is similar to this? &gt; how is this especially exploit-prone? Not sure where you got that from. No one has said anything about expoits.
Is it hard not to write code that is somewhat ambiguous like that? hey what does this print void main() { int x = 4; printf("%d\n", x++); } Yeah, you can have stupidly complex code using this. (Nested .format strings, I've done that before!). But it's bad form, so hopefully you won't. It's not python's job to prevent you from writing bad code. It should guide you in the direction of good code, but I can write some really messed up python if I wanted (likely involving list comprehensions). Edit: Oh, also! What is the difference between `a = f"b is {b}"` and `a = "b is {}".format(a)`? Nothing. They're basically exactly the same thing. So why would it be any different? Like someone else said, it's the exact same thing as .format, but different syntax. 
youtube-dl handles bandcamp too. It downloads the previews.
My suggestion : f-expressions. Because they are evaluated at run time.
f**ing strings ? Just kidding. Format string ? But it's still "string". So maybe not.
I make fairly heavy use of decorators in some of my Python code, in particular, when I'm following a more functional style of coding. I would still criticize the decorator syntactic sugar as being much more magical and much less explicit than is typical for Python. I find them useful in some contexts, so I use them, but I am always intensely aware of the downsides. The biggest downside in my experience is related to training new developers. I've recently been onboarding a new junior developer at my dayjob and the single most difficult part of the codebase for him to understand has been a portion I wrote that made heavy use of decorators. For that reason I sincerely question whether or not new comers will love it too. Elegant, magical-looking syntactic sugar is a convenience for experienced developers who understand what its doing under the hood. I don't think it helps new comers at all. Its counter-productive for them, in my experience.
I'm actually learning python right now as my first language, will this affect my learning?
Here's an easier version. nums = [] for i in range(10): n = input("number %s" % i) nums.append(int(n)) If you really want to use while then you can do this: nums = [] while len(nums) &lt; 10: n = input("number %s:" % len(nums)) nums.append(int(n)) 
That doesn't make it not complicated. Why are you so determined to argue about this?
Am I horrible for liking this? I hate the %% % % look.
 "{} was on a {}".format(date, date.strftime("%A")) But what if you have a reason to use the same string format in multiple places? myformat = "{} is on a {}" myformat.format(date1, date1.strftime("%A")) myformat.format(date2, date2.strftime("%A")) What's the best solution using f-strings? **edit**: Added a missing paren.
Already adding? What do you mean?
&gt; I think it's harmful to development to take the position that anything new that could possibly be used in a bad way shouldn't be allowed at all. I agree with that statement, but it's not my position. We're introducing a ~~3rd~~ 4th way to format strings. This new method allows and encourages nesting Python code inside what walks and quacks like a string. It's my opinion that nesting Python code inside strings introduces more problems than it solves. You disagree. The PEP is approved. But that doesn't change my opinion of this syntactic change. In time, we'll know how helpful or painful this change is. And we'll either rejoice in it's awesomeness or end up introducing a 5th method. 
You said that it broke symbol-aware searching. I said it did not, only that tool authors would have to make their tools support all the features of the language.
https://www.python.org/dev/peps/pep-0492/ It's not goroutines exactly, but it's a great step forward.
It breaks all current symbol aware searches, and support for it would have to be added to future versions, then people need to update their search service to that version. You're being argumentative and obstinate. The discussion was on how easy it is to find things with current search tools, I pointed out an exception. Go be argumentative somewhere else.
Here's one of the things the PEP pointed out: &gt; In the discussions on python-dev, a number of solutions where presented that used locals() and globals() or their equivalents. All of these have various problems. Among these are referencing variables that are not otherwise used in a closure. &gt;Consider: &gt; &gt;&gt;&gt; def outer(x): ... def inner(): ... return 'x={x}'.format_map(locals()) ... return inner ... &gt;&gt;&gt; outer(42)() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 3, in inner KeyError: 'x' &gt; This returns an error because the compiler has not added a reference to x inside the closure.
https://www.reddit.com/r/Python/comments/3k6qi8/pep_498_approved/cuvfx1y
u/SalishSailor never said anything about "current tools", only that "search" could find all instances of a token. You said "Actually, it's complicated" and claimed that searching via symbols would not find the new usage. You didn't make any mention of "current symbol aware searches" until just now. Given that context, it seems reasonable for readers to understand your comment to mean "the new stuff will break symbol aware searches", which is simply not true: It will break old versions that don't yet know how to parse the new syntax. That is a problem that should be easy enough to solve, and one that applies to any number of possible changes to the language, as well as a multitude of tools. Responding to changes in the language is one of the tasks one undertakes when you choose to write a tool like OpenGrok (or pylint, or PyCharm, or whatever), so I don't think concerns about such things are particularly relevant when discussing the details of a specific proposed change. Note that I have not once called you names, questioned your motives, or downvoted your comments (until this most recent one, which is needlessly combative and rude). I would appreciate the same courtesy from you.
frings
&gt; I just disagree with opening that door. Easy things should be easy. Hard things should be possible. 
This discussion is in present tense, at the current time no symbol aware search tools understand this. The behavior that you are rightly saying will get patched into (at least some) of those search engines currently does not exist, it is hypothetical (but again, doable). The rest of the discussion is in concrete facts. My concern is not with your statement that search engines can patch this behavior in, but your insistence that my earlier statement was incorrect. It is a complication- shit just doesn't magically work right now like control-F will. Calling you out as argumentative and obstinate is hardly name calling. 
Does the newcomer in question understand bla = bla(func) ? If yes, then it's just syntaxic sugar for this. If not, the problem doesn't lie in the syntaxic sugar part but in the concept of the decorator pattern itself, which is another debate entirely and has nothing to do with magic since it's purely a design pattern debate.
Still has string it it. People will still see them as strings, which leads to confusion.
For some reason, I feel like they'll need to update the pycon anti-arrassement rules after this one.
Interesting, but histograms of the inter-arrival times seem like they'd also show a lot of the same information?
&gt; That's a nonsense argument. Virtually everything about Python is different than C. It's actually a very good one. Virtually everything is different, but some things are the same. All languages that I know use something similar to that for formatted string printing. Now maybe there's alternatives, but it should at least be familiar.
&gt; What's different to me is the context of what starts off as a string then finding Python expressions inside of it. It'll be colorized, yes, but you can't format it, and you'll have "nested" expressions on the formatting side of the colon. I see it differently than you. got it, but i have no problem with the concept of having “holes” in a literal in which expressions go. doesn’t differ much from “a method that treats certain syntax as placeholders to insert values into”, it just eliminates the placeholders. &gt; The reason it looks like it's a string is because it's meant to be thought of as a string (template). well, that’s the whole issue, right? how pure it is. and yeah, gettext has everything to do with this: if you’re an extremist of the opinion “no string shall violate the purity of my code for it is data and data is a separate concern”, then of course you’ll hate it. but for usecases where i18n, separately authorable templates, and so on are a concern, it’s simply not the tool for the job. this is a practical replacement for the tedium of writing quick stuff like `'i have encountered {} of my {} eggs'.format(e + 1, len(eggs))` over and over again, and enhances the readability of those things. no more, no less. once you need to be more dynamic, it’s trivial to exorcise the expressions and use gettext or a fancy template loader. &gt; What other syntactic sugar does Python have that is similar to this? you tell me. (and about exploit: i didn’t mean the security kind)
Well, I've yet to see it used in the wild, so I don't consider it as one of the methods of interpolation that a python programmer would need to learn to read arbitrary code. I see your point though :) (There's also a million and one 3rd party methods for string interpolation, if you include templating stuff like mako, etc.)
It prints the same as this: b = 24 a = 'b is {}'.format(b) b = 42 print(a)
too bad `logging` relies on the % syntax…
\&gt;braces \&gt;semicolons \&gt;declaring variable type \&gt;everything [mfw not python](http://www.codethinked.com/wp-content/uploads/WindowsLiveWriter/TheProgrammerDressCode_10D17/Guido%20van%20Rossum_24969b7a-fffc-4e0d-92e8-c5fd803ea274.jpg) Not using python when showing code analagous to a python feature is (in this context) incredibly silly.
How about this? def outer(x): def inner(x=x): return 'x={x}'.format_map(locals()) return inner print(outer(10)()) http://ideone.com/To3tn2
so does `Template` and `str.__mod__`. so python has three. string interpolation did however not add a new one.
&gt; Does the newcomer in question understand bla = bla(func) ? yes. that pattern is relatively common in Javascript (except usually done with an anonymous function, which Python doesn't properly have), so he had seen it before. ultimately that is what helped him understand the decorator sugar. don't get me wrong, we still use decorators. they are very elegant and once you understand how they work it makes your code much more readable. its a learning curve issue, though. 
What is implicit? You have to explicitly put the f in front of the string to use it.
Stylin' fedora
Seriously? Of course they would. Learning a natural language is way more difficult than learning Python and gives a benefit that a child is incapable of fully appreciating. I would argue that the 6 out of 10 parents interviewed here are doing their children a disservice. French might not be as widely spoken as other languages but it would allow you to operate in a number of countries with thriving economies that would otherwise be inaccessible. Either way, the amount of effort required to achieve even basic conversational competency in a natural language is at least an order of magnitude more than that required to "control a robot using Python."
I was showing how a feature of a programming language (that isn't python) can be used to be confusing. But the best way to write that would be to move the `x++` to a line before the printf. Just like /u/balkierode's code changes the variable to be intentonally confusing, this code does. Being able to write bad code isn't that much of a problem, just shout at people who do.
Yeah, interesting visualization. I think you can come to a similar conclusion just plotting the histogram of the diff of the array of arrival times. What this does show is some aspect when the event occurred, which could be done by a 2d histogram (hour of day on y axis, diff in event time on x). The 2d histogram would also be better for showing the time of day aspect, since positional wins out over color for differentiating values.
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
That's not really true. [String formatting in C#](https://msdn.microsoft.com/en-us/library/txafckwd.aspx) and [string formatting in Rust](http://rustbyexample.com/hello/print/fmt.html) both work like Python's `str.format()` and not like C's `printf()`. Even C++ rejects the C way since it's not typesafe, and uses its own peculiar iostreams form of formatting (which I'm not claiming is superior, just that it's not the C way.) The C style is widely copied, yes, but regrettably so. For example, it does not play nicely with localization, because often the translator needs to change the order of arguments. That's trivial using `str.format()` style formatting, but with C style formatting you have to invent ugly extensions, like `printf("foo %1$s bar %0$s", a, b);` which is just hideous to look at, and again, hasn't been adopted everywhere that borrowed plain `%s`. 
Damn. Looks like they caught a major bug. Good thing they fixed it in time for Sunday.
I love crossbar. I think they have gone through a little bit of some rework to move the server components out of autobahn, so autobahn is only a client library, but that should be settled now. If you need ongoing communication (pub/sub or rpc) between javascript and python, this is a great option. Another benefit is the availability of client libraries across multiple languages.
Nice catch, ~~IDE~~ grandzooby.
Well the Python community is far more friendly than the Francophone community...
Is there any other construct in Python that takes the form [A-Za-z]+".*" that isn't a string literal? The ones that I'm aware of all are: r"A raw string literal" u"A unicode string literal" b"A bytes string literal (ignored in Python2)" ur"..." br"...." Because it seems very messy to take something that **looks like** a string literal and suddenly make it evaluate code. Especially code that can call functions that may have side effects. try: message = f"The result is: {get_from_database()}" except UncaughtDatabaseException: .... 
/r/learnpython
Sorry, I thought this was the sub for all around python. Thanks for the redirect!
Oh man nail on head here, at my high school and college you could tell (for the most part) who was taking french, even worse if you were in the class they had subdivisions with the Snootiest being those that were natural speakers, and the lesser being kids who were picking up the language for the first time, terrible.
It's true that "f-string" is a bad name for them. As rlamy points out, the fundamental problem is that it suggests that these things *are* strings, which is technically true but fails to indicate that they're *expressions* which evaluate to strings, and are only literal strings in the degenerate/border case of no parameters. It suggests a false analogy with other single-letter-prefixed strings, r-strings and b-strings. r-strings are raw strings; b-strings are byte strings; both are almost always literal strings. The current name makes newcomers to "f-strings" (which we all are) wonder whether the 'f' stands for some datatype (and then, which? float?). Even the expanded "format string" is not a good name, as that's taken already: it refers to the template-y string used by any of the three existing str-formatting styles. Unfortunately, "string comprehensions" is also quite a bad name (an even worse one, I think), as it too suggests a (very) false analogy. To even propose it reveals incomprehension of why comprehensions are so-called. All existing comprehensions in Python involve iteration and optional filtering by a condition, but these do not. "Comprehension" alludes to "set comprehension" in set theory, for example a term like: {x \in X | x**2 &gt; 4 and x+17 \in X} (Zermelo first used the word in this sense, in 1908 -- he's the 'Z' in "ZFC" -- and it has been used ever since.) In existing Python, all comprehensions are on that model: the elements `e` in `iterable` such that `some_predicate(iterable, e)`, collected into a list, dict or set, or yielded successively by a generator. These "f-string" expressions have *nothing* to do with that, per se. "String expressions" is too broad, as `'abc' + 'def'` is one of those too. But "s-expressions" (or "s-exprs", even though that's used by LISP for something different) is ok. Problem is, the prefix character should then be `s`. I've considered and said "Nah" to a few other possibilities - "dynamic strings" (confusing, sounds mutable), "delayed strings" (sounds vaguely async-y). "parameterized strings"? Of the names already mentioned, I like desmoulinmichel's "f-expressions" most. In fact, I like it. The `f` for "format" in their existing name is well-chosen, as the author of PEP 498 has gone to great lengths to be compatible with the functionality and specs of the `format` function and `__format__` methods. 
Yeah, the PEP lists a very similar fix. But the point is that these errors can creep in. Maybe your closure gets invoked far away in the program. And so a few months later someone refactors this code, but forgets to leave in the "unnecessary" variable reference. Now an innocent change has caused a hard-to-debug crash somewhere random. Even worse, it could cause a crash in a codepath that you don't normally test, so that you don't even know which change was at fault. This is edge case stuff, to be fair, but it's bad enough to disqualify this approach as the Official Recommendation I think.
&gt; Why was this NOT done like this in the first place Well, hindsight is 20/20, isn't it? Given the approval of this PEP, my guess is that if Guido actually had a time machine, he would add string interpolation to Python 1. Alas, that is not the case and this is the best that can be done today.
Nope it won't
I don't believe this will affect your learning. It may take a little while for this to make it into a release. On another note, welcome to Python! If you need any help feel free to pm me or post in /r/learnpython
Hard to find, I don't remember where I got my info when I wrote these comments. But https://www.odoo.com/fr_FR/forum/help-1/question/difference-between-enterprise-and-community-editions-86455 has some more details. Basically, Odoo is doing a classical Enterprise/Community split, with Enterprise being the proprietary part.
&gt; 'f' may also be combined with 'u', in either order, although adding 'u' has no effect. Despite that, I can think of at least one use, for when you really hate the guy who will maintain your code...
You know, maybe I'll get a Rasberry Pi 2 and do something like that!
You can try QT (pyQt or pySide) and http://doc.qt.io/qt-4.8/qgraphicsview.html
I know ☺
 &gt;&gt;&gt; c'i for i in range(11)' '012345678910' That would be a "string comprehension" to me. Also, please don't take this suggestion as something we should add to python, we already have something like 96 ways to make a string in 3.6 if you count the 4 different quote styles and the number of combinations of prefix letters you can put on a literal. 
The line next t &lt;-- this bit? That would be your input, the program is attempting to collect the value D (decrypt) or E (encrypt) Later it is used in an if statement to determine if to increment or decrement a character count. Also this code is pretty poor implementation of a ceaser cypher. For instance if your input character is the letter 'z' and you wish to increment by 5555 it breaks, also if z is the last char but there are more to increment it should cycle back around to the 'a' with the next increment in order to maintain alphabet output. Worse off there is no input validation. Hope that helps. Edit: I just noticed the lines "#this line". What is happening there is that the string of input is being iterated over (character by character). In the loop an order of operations is happening first ord(ch) is translating the letter to an integer (ascii encoded) then increments/decrements the integer representation of the letter by `shift_by` (this is the part that changes the character) then chr() will cast it back from an integer to a character. end="" just means that a new line will not be printed so that all your new character will print out beside each letter.
Read the sidebar.
because according to the pep, an f string will be expanded to (probably): 'b is ' + b.__format__()
strexpressions.
That isn't a fault with f-strings. Anyone that would write that side effect containing f-string would still do the same idiotic shit with format(). 
You'll still need to have an FTP/SFTP service running for pysftp to connect to. You could simply screen scrape the files, but I would not recommend that.
Using ssh keys?
Those are incredibly different. Writing python code to be "pythonic" is less difficult than getting an accent, you can see your code, it's in front of you, using accent is within your vocal chords, and you don't really hear yourself.
perhaps it's possible to do this with the right `__format__` method? I could imagine something like: q = Query() q.execute(f"select * from mytable where mycolumn = {q.param(hello)}") Where the param function/method returns a custom object with a `__format__` method that adds the string to the parameter list: def __format__(self, format_spec): self.query.param_list.append(self.value) return format(self.value, format_spec) You can probably make this more ergonomic, but you get the idea.
Nope.. ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(target_host, username=user, password=pw)
http://stackoverflow.com/questions/250283/how-to-scp-in-python Check this out.
String Expressions. Strex. 
These are concurrent, but not parallell, unfortunately.
C'est pas terrible!
Yup, but that depends on the implementation, so PyPy will hopefully be the savior of those stuck maintaining Python infrastructure with scalability problems.
&gt; just barely ended with a C. Could've been you couldn't remember a lot of the words, I know C has a few issues with manual memory management...
&gt; that a majority of advanced search tools* that work with python will be modified to understand symbol usage Why do you think they won't be modified in regards to *this* syntax change as opposed to prior syntax (say 2-&gt;3) changes?
The same thing it stands for in "f-strings": "format", as I just said. (Read PEP 498, it's very clear what 'f' stands for and why.)
Yeah that would be a better candidate for the term "string comprehension" -- something that let you dispense with the outermost `''.join(...)`, for example. But that's would be just a little shorthand.
Yes, the `%(...)%` is a weird choice...it's just the first thing that came to mind that I was pretty sure didn't already mean something in Python. (I'd prefer to use backticks, but they had a meaning and are now deprecated...so they're not really an option.) On the other hand, for some folks, `_("some string")` is a common shorthand for `gettext()`. If we followed that pattern, I could really get behind `f("some f-string {magic}")` where `f()` was the common shorthand for some magic `format` function that automatically has access to the in-scope variables. Typing the parens should be a pretty good reminder that we're executing code and not just entering a literal value, and even without syntax highlighting you'd quickly differentiate it from other places. Plus, you'd suddenly regain the ability to store a template-string and re-use it: user_name = "Billy" my_template = u"{ name } is { age } years old." people = ( ("Bob", 43), ("Sally", 44), ) for (name, age) in people: print f("Hi { user_name }. Meet { name }.") print f(my_template) 
&gt;But in reality, while reading code, we usually don't care what is inside the strings. We do not 'scan' strings. In reality, when reading code, we are often looking for variables, where they are initialized, where they are used etc. In reality, when I see a call to a `.format()` method, my first instinct is to skip back and see if it's being called on a string literal, and if it is, to scan that literal to find the places where the data was inserted. If the format string isn't a literal, then there's more work to do, of course; but this PEP doesn't address this case, and `.format()` isn't going anywhere. In the common case where the format string *is* a literal, I'm saved the effort of mentally re-parsing that line, as well as possibly some redundancy. Plus, when people are using f-strings consistently, a `.format()` call will stick out and alert me to the use of some more sophisticated templating.
Yes but for tool sunder active develpment its not like its any different. PyCharm *needs* to support everything python has. It supports all of they syntax python supports. A lot of the syntax engines are open source too, so I have little doubt that the *good* tools will support these changes before they come out. Or in other words: "maintains compatibility with the most recent version of python" is still "maintains compatibility with the most recent version of python"
Using that logic, we could just trash the whole language. Afterall, you can write shitty code using almost anything.
I'm not entirely sure - but there are probably a number of options whihc depend on what you want to achieve. NIPALS is great if you want to calculate the first few components, but not all. EM-PCA is similar to NIPALS in scaling but is more stable under missing/noisy data. Randomized-PCA (with a randomized SVD) is much much faster than the standard SVD generally used in PCA - but may break your memory requirements. Scikit-learn has a lot of decent implementations of PCA algorithms - maybe start there?
Whooosh!
People don't always learn about new language features from the PEP, which means they don't necessarily learn about it in full - only the aspects they need to comprehend that strange new bit of code they saw the other day, or take advantage of it in the way that seems interesting to them personally.
 print ''.join('%(pre)s%(num)s %(bot)s on the wall, %(nul)s %(bot)s,\n%(tak)s\n' % (lambda c,b: {'pre':['','%s %s on the wall.\n\n' % (c,b)][abs(cmp(c,'Ninety-nine'))], 'num':c, 'nul':c.lower(), 'bot':b, 'tak':['Go to the store and buy some more... Ninety-nine %s.' % b,'Take one down, pass it around,'][abs(cmp(x,0))] })((lambda x,o: [(['Twenty','Thirty','Forty','Fifty', 'Sixty','Seventy','Eighty','Ninety'][x/10-2]+'-'+o.lower()).replace('-no more',''), o][int(x&lt;20)])(x, ['No more','One','Two', 'Three','Four','Five','Six','Seven','Eight', 'Nine','Ten','Eleven','Twelve','Thirteen','Fourteen', 'Fifteen','Sixteen','Seventeen','Eighteen','Nineteen'][[x,x%10][int(x&gt;=20)]]),'bottle%s of beer' % ['','s'][abs(cmp(x,1))]) for x in xrange(99,-1,-1)) You're right, using the old methods, its impossible to write bad code! Though I think we should remove strings entirely, just to be safe. Wouldn't want anyone getting any ideas.
Head over to /r/learnprogramming . Please don't be offended if this post gets deleted, as it is a touch off-topic for this sub. To answer your question, learn python the hard way is free. Use python 2 and get started. The finer details between python 2 and 3 are irrelevant to understanding the foundations.
Nice examples; it's important also to consider the ease of writing correct code - I'd say that's somewhat more objective than readability, anyway.
its even worse than that. the code contains this bit if j.entities.urls: for k in j.entities.urls: # stuff which is completely redundant. if j.entities.urls is an empty list its iterator will just no op on the for loop, so the conditional check is unnecessary. if j.entities.urls might possibly be None then the conditional check should be explict "if j.entities.urls is not None", and hopefully entities.urls just can't ever be none since it looks like it is supposed to be an iterable, but I suppose that's the responsibility of the library developer (looks like Twitter Python SDK) rather than the application developer. basically the code snippet looks like it was coded by a very inexperienced Python dev. 
That probably covers most use-cases. (Like if you want to do them in back-to-back or if the surrounding code is also repeated.) So, while I can come up with edge cases that work better for `.format()` or even `str % (params)`, I concede that the differences in this front aren't significant enough to be considered a step back. 
can we have a new PEP to include regex on those too, and how about `restrex` as the name?
Yeah it still works, but.. The point of kwargs is to avoid the performance hit of the string interpolation for messages which will never end up being logged anyway. That feature can't be used anymore. 
&gt;Why add this piece of arcane syntax It is not being added. This "conversion" step has always been a part of the [format string syntax](https://docs.python.org/3.4/library/string.html#format-string-syntax) for `.format()`. Only the `a` conversion is being "added", and that's [already in 3.5](https://docs.python.org/3.5/library/string.html#format-string-syntax) - which I'd say is just correcting an oversight, given that the builtin `ascii` does the same sort of thing that `str` and `repr` do. &gt;The double brace is also super weird. It's again the same escaping that `.format()` uses. &gt;Why would escaping braces not use backslashes, like, y'know, every other thing that needs to be escaped? Because that isn't even true for the other main method of formatting: &gt;&gt;&gt; "spam \%s spam %s and spam" % "eggs" Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: not enough arguments for format string &gt;&gt;&gt; "spam %%s spam %s and spam" % "eggs" 'spam %s spam eggs and spam' See? It even uses the same doubling-up approach. It can't just use a single backslash because that's interpreted (to determine the contents of the format string) at compile-time, while the interpolation is done at run-time. But it doesn't work with a double backslash, either: &gt;&gt;&gt; "spam \\%s spam %s and spam" % "eggs" Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: not enough arguments for format string Sure, it works for regexes, but that's more for traditional/historical reasons. (And it's awkward enough that people end up using raw strings for their regexes anyway.)
It is not a new syntax. It's fundamentally the same syntax as for `.format()`, only *accessed* differently.
If you define an object for each mass and you have lots of masses, your code is going to be super slow. You're not taking advantage of numpy and it's probably making your code slower than had you not used numpy at all. I'm recommend doing it like: from numpy import asarray xyz = asarray(xyz) m = asarray(m) xyzm = (xyz.T * m).T # multiply the mass by the xyz coordinate; add some transposes to deal with array dimensions xyzm_sum = xyzm.sum(axis=0) # find the total xyz*m for each element cg = xyzm_sum / m.sum() # divide by the total mass 
A large part of my day is helping developers write better code. I can see this scenario tripping up a good chunk of them. 
If I was at work today I'd find an example for you but I'm almost certain there's a way to make this work
Yes, I do suppose these criticisms are valid for the earlier string formatting methods too, then. Interesting point about the compile-time vs. runtime thing, though I do think that difference shouldn't really have to shine through to the user. 
Why can't you just remove all the other string formatting methods from your own personal toolbox. Why does it have to be removed from the language entirely?
Thank you! Sorry about that. I'm still sort of new to subreddits and Reddit all together when it comes to posting
did you fail out of your first computer science class?
Actually PyCharm doesn't support some minor python functions- even some ones relevant to this discussion. Do a rename on a format kwarg- the bracketed keyword in the string will be treated like a normal string, not a symbol.
"s strings" that stands for **s**uper **strings** :) s'foo {bar}'
In the UK I'd of rather learned Spanish than either of them as it would have been 1000 times more useful than French for most of us over here. Learning people languages is easier at yonger ages.. learning programming languages is easy/hard at any age. 
It's local. I posted the code above. Could it be just printing strings? Or the million other string functions?
G-strings for Pythong.
Excellent. Reading a little further, I could cur.commit() outside of the loop... say on every 1000th iteration. I love the idea of separating the functions. I could even convert the initial data into something a mysql table could read natively. Either way, I feel much more confident now. Thank you for your input!
I'm similarly quite convinced about `f""` which is: * a function with an incredibly vague name * a function masquerading as a string literal * a function that has implicit access to `locals()` This conversation has convinced me that we really should stick with one of the existing options and not go down this road.
And that's how you get perl6. Or rather, don't get perl6 because nobody was passionate about changing because perl5 was good enough. We're "curiously passionate" because there is a shining example of what happens if we're not - by the time we *need* to migrate, it will be too late. If there are two good languages with little to choose objectively, then all the more reason to use 3, because otherwise you get a language 15 years too late and a community that has moved on to something else.
If your input data is pretty safe to format into SQL, consider just reading the CSV file and outputting it to a file in a format suitable for MySQL's [LOAD DATA](https://dev.mysql.com/doc/refman/5.1/en/load-data.html). Definitely don't do this across a wire either. Definitely don't do one `INSERT` per row. If you prefer `INSERT INTO` to `LOAD DATA`, at least batch up the inserts - maybe 1000 rows at a time. Read up on [bulk data insert](https://dev.mysql.com/doc/refman/5.5/en/optimizing-innodb-bulk-data-loading.html) tips. Consider disabling any extraneous indexes or constraints on the table you're inserting into. Create those indexes/constraints after the data has been loaded. Ditch the print statements. It's not helping the import speed. If you need some visual confirmation that work is being done, consider doing something like outputting a period `sys.out.write('.')` or the estimated percentage complete, but only every 1000th record. I can also see you're repeating string searches a few places with `name.find('(')` (3x) and `srcNode.find('_')` (2x) and splitting a string twice with `cat.split(' ')` (2x). Store that stuff in a variable and re-use it. It's minor, but it adds up when you're dealing with millions of rows.
Hmm... touche. The name is vague, but it does follow an already established convention with u, r, and b string specifiers. So it has a tiny bit of leeway there from me. The other two I have no way to refute in the slightest. tl;dr - shit is wacky. Hard to form a solid argument for or against it.
This is hilarious: [someone thought it was pseudocode](https://np.reddit.com/r/programming/comments/3k7zjv/what_is_code_according_to_the_economist/cuvhhfn).
I've found that people use `None` when an empty collection would be easier. 
French is one of the easier languages to learn for native English speakers. Compared to other languages, its rules are relatively regular. Much of its grammar, including most notably word-order, are similar to English's, not least because of the outsize influence French had on English during the Middle Ages. The only real complication is spelling/pronunciation, since French spelling was dictated by etymology-obsessed scholars. And guess which other European language was dominated by etymology-obsessed scholars, resulting in a convoluted language with lots of weird spellings?
Relevant xkcd: https://xkcd.com/927/
According to the PEP this will just print {x+1}. The first string literal doesn't magically become an f-string literal just by concatenation.
&gt; And that's how you get perl6. Or rather, don't get perl6 because nobody was passionate about changing because perl5 was good enough. [Perl 6 will be out next month](http://perl6releasetalk.ticketleap.com/perl-tech-talk/details), fwiw.
I wish backticks were an option (`) because that would solve a lot of the understanding problem, though I already know that backticks are a no-go, and would also conflict with python2 code to way too much of a degree 
&gt; With an explicit list of variables, you still have to scan the inside of the string looking for where the variable is actually used You misunderstood. I was not referring to the places the variable is used inside the string. But cases where you want to see where the variable is used in code. With an explicit list of variables, it is easy to spot that variable being used in a string interpolation. Where does that variable occur in the string, can often be skipped, because it is often irrelevant. 
As a french native : french is a much less useful than Python. If you need to learn a language, learn spanish or chinese when you already know english.
There is another PEP for this one, currently in debate. It's not decided yet, nor if it's going to be implemented. Checkout the other x-strings discussions on the mailling list. 
Because french people will take the time to learn english. English is the business language. It can take you almost everywhere... 
&gt; But the point is that these errors can creep in. That can happen with this pep also. What is stopping someone from removing the variable in the external scope because it is hard to find its reference in the closure. With the default argument method, at least the importing of variable from external scope is explicit and nearer to the use. 
I didn't understand how the scoping of the f-string worked. Shoo troll.
&gt; I wish people took a step back and look and see if the minor convenience offered is really worth the hassle. they have
Yeeeah, got to agree with the frowney face. Syntactic sugar is nice, but too much becomes saccharine. There's a reason "There should be one-- and preferably only one --obvious way to do it." is a Python koan.
That's quite the compliment for Python. Often I'll begin writing pseudocode in a wiki page at my company only to realise I might as well just write it in Python and start from there when I move on to actually implementing the software.
You can defend against that with: for k in (j.entities.urls or ()): # stuff
You're right, I shouldn't have growled, shoulda let someone else reply. On re-reconsidering, it made me realize that maybe "f-expression" isn't ideal either. It's a valuable question after all.
What hassle? They're easy to describe, and they appear to be a lot easier to read and write than `format`, with no loss of power and maybe even a net gain. These expressions look like they'll be very useful and no hassle at all. They also don't seem at all hard to explain. Other than their name, I see nothing not like about them. I think both "f-expressions" and "format expressions" are perfectly good names and not confusing. &gt; If it is between quotes, it is a string. End of story. That's disingenuous: consider `'Hi, %s !'` and `"Is that you, {}?"`. Sure they're strings, but neither one is the end of any story: each one awaits substitution for its placeholder in some larger expression. 
Maybe they were given the wrong arguments. French is awesome because: - you have a lot of freedom with swear words and insults - for some reason, American girls love the French accent. However, tell an American girl you “talk Python” and you probably won't even make it to first base!
Groovy beat you to that one. :)
Well maybe you should have clicked what OP directly linked to which is literally the explanation of how it would be implemented and is basically psuedo documentation ...? But okay, I guess I'll leave, just be sure to study up on those tricky "if-else" statements before your class this week!
People don't seem to realize they aren't mutually exclusive. In fact, they are so similar that learning one takes you 98% of the way through learning the other. I learned Python 3, but will drop down to py2 when required. You should be using environments anyways so there is zero cost. I will often try to make code compatible with both versions where reasonable anyways.
Pfff... kids today! Solution: Give them a fresh french python manual.
Those variable names look like Java.
Is Spanish so common in the UK? If anything I would have guessed Arabic
ftrings
Your question got me thinking, though: even after all this discussion, the term still wasn't self-explanatory. I think an even better term would be "format expression", with "f-expression" accepted as slang but not the official name.
Why not use Fabric instead of Paramiko directly? http://www.fabfile.org/ As long as you can execute the commands on Machine A without having to 'su' (i.e. - your remote user has appropriate privileges or can sudo) you could issue the scp or rsync command from Machine A inside of your script. The Fabric docs are pretty good, but chime back if you need more help. Also, what does your code look like so far?
The thing about Japanese is that words are so heavily context dependent that misunderstandings can result in such wildly different meanings. I'm constantly seeing in anime where a misunderstanding results in the character thinking "did they just insult me, or did they mean this &lt;completely off the wall thing&gt;"? I find it really difficult to learn.
&gt;I don't see why people would be any more apt to put large expressions into f-strings if they don't do it into .format() For one thing, putting a large expression in a format() function makes it easy to reuse the template string elsewhere, with other values and expressions.
I don't see why you couldn't do the same thing with an f-string. total_string = f"Your total comes to {total}" total = 4 print(total_string) total = 9 print(total_string)
&gt;avoid introducing too much technicity to a new comer. Catering too much towards the newcomers is the last thing I want in a language I use for professional use. 
&gt; If I'm working with a long string, I'd rather see {x + 1} inline than {2} and scroll to the bottom to find the .format() Open the file in a vertical split. You can do it even in vanilla vi over ssh.
well, its basically printf without the print part so... f ? :) 
Did we need a second thread for this?
&gt; Eh. No more friction than between %-users and format users So it is OK to add more fragmentation, because there is already *some* fragmentation? The rest of your reply I can only see as handwaving. &gt;You seem to find the new construct very hard to read, and up there with climate change as an existential threat. I don't. He he. Why? Because I speak my mind? EDIT: Parent post has been edited/expanded. 
Safest to start with Python 3 with the rationale explained here [Porting Python 2 Code to Python 3](https://docs.python.org/3/howto/pyporting.html) far better than I'd manage. Note especially the first sentence under "Details" *A key point about supporting Python 2 &amp; 3 simultaneously is that you can start today!*.
Nobody is going to write your for loop, except to prove it can be done. Everyone is going to stuff arbitrary expressions into f-strings. That's the whole point of them.
&gt; learning programming languages is easy/hard at any age how so? You would expect that you don't teach programming to kids as you do to students.
Fex has a... "different" meaning in Latin.
One more way to string formatting... Thanks to those didn't read the zen of python. 
/r/learnpython moderator here. No, this is a bad idea. OP is pretty clearly a spammer (new account; posts in an /r/WTF thread about a python (snake) eating a porcupine to say "you should try python courses"; then starts posting in /r/learnpython and attaching a signature to every post). I have banned this user and made a report to /r/spam.
I've seen kids that can do what students do.
It's quite logical to call a programming language a language in my opinion. When making an application, you're creating a story (software behaviour) with words and characters (depending on how high level the programming language is). Each programming language has also its own set of 'grammar' and 'vocabulary' (syntax). And upon executing an application, the interpreter/ compiler must be able to understand the syntax in the programming language in order to know what the purpose is, just when having a conversation in a foreign language. 
Not learning any other language than English is one of the reasons why U.S. people are mocked in the rest of the world. They're seen as lazy, not even trying to learn a few words in the local language when they travel. (Obviously this is probably a cliché that's not true for everyone)
Have you looked at golang? They seem to have done pretty great things with the concept of keeping your language simple. Its also nice knowing you can onboard a new developer in a much shorter amount of time--they don't have to learn a bunch of 'magic' to understand a code base. 
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp; best of luck!
Obviously he's talking about the percentage of people that speak French on a global scale. And although it's a good deed, what fraction of the population is realistically going to Africa to help people. There's many other languages that opens more doors, and French is definitely not one of them.
I was always frustrated when setting up a logger from the stdlib logging module, and never really needed much more than the functionality in tinylog for most projects. So, instead of re-implementing a file append logger every time I wanted some very basic logging, I wrote tinylog to keep things stupid simple. It isn't any harder than: from tinylog import Logger log = Logger(debug='~/debug.log') log.debug('debug message') log.info('info message') log.warning('warning message') log.error('error message') log.critical('situation critical!') $ cat ~/debug.log 2015-09-10T00:05:31.288241 [DEBUG] debug message 2015-09-10T00:05:31.288368 [INFO] info message 2015-09-10T00:05:31.288416 [WARNING] warning message 2015-09-10T00:05:31.288455 [ERROR] error message 2015-09-10T00:05:31.288492 [CRITICAL] situation critical! Options are available for changing the format, and using unixtimestamp, with milli/micro, and it comes with what `format` has. So, you can do `logger(fmt="{level:*^10} {message}", ...)` and you'll get it formatted like: In [1]: "{level:*^10}".format(level='INFO') Out[1]: '***INFO***' So, maybe useful for those who like the log level to align. Anyway, it's not meant to have crazy features. It's meant to be feature-poor, and just get a text file written to. Most of all, it's meant to be easy, so here's another option if you want your small script to have basic logging!
16 Million? That's really not that long. That takes up what, `16 M lines * 4 values/line * 4 bytes/word = 246 MB`? Now you might have 10+ columns, OK, double that, but it's still small. It should still be fast. If it's not, your algorithm sucks, but you don't need MYSQL for that. Just use some pandas or numpy and load the thing into memory.
&gt;&gt; You don't have to wrap functions in a class. And if you want to pass by reference, Closures are your friend. &gt; You do, if you want to mock the function. Use namespaces. You can mock functions without problems and without having to put them in classes, by putting them in appropriate namespaces. Pretty much every PHP mocking library supports this or you just mock it yourself. &gt; PHP implements parts of it I was just saying PHP *does* have magic methods because your post read like it didn't. There are `__get` and `__set`, btw. While context managers are nice, in any case I'd use them, I already use a library that takes care of that for me. IMO ArrayAccess takes care of `__contains__` and `__len__` which leaves `__eq__`. I'm really missing that. Apparently this is already [available](https://wiki.php.net/internals/engine/objects#compare_objects) for inbuilt objects. &gt; No, in PHP7 "foo" + 1 is still valid. When I define an interface with `foo(int $bar)`, `foo("1")` will throw an error. &gt; The average quality in Python is higher. Again. How so? What is your metric for that?
You can use aiogevent or aioeventlet to run synchronous style code on the event loop
fstrings? That's a funny name, I'd've called em chazwazzas.
I shifted to 3 because of a better support for unicode and async. It showed that other aspects are better supported as well. It's true what /u/fishburne said &gt; It is a language that has incorporated lessons learned during a course of 30 years of widespread use, 
Those guys were never really too much into open source before too. They want too much control for even commercial open source.
This might be of help to you: https://github.com/mozilla/pdf.js Combine this with websockets to share the hightlighted parts across users.
&gt; If you don't know with certainty the full set of packages you need They're generally learning python as a beginner. They hardly even need to worry about packages. Besides, practically all the *good* packages, worth worrying about, have all had python 3 ports, or have an analogue package in python 3 that does the same job. &gt; there's some people who are curiously passionate about Python 3 Wonder why? Because it's the future of the language? Does [PEP 404](https://www.python.org/dev/peps/pep-0404/) mean absolutely nothing to you? &gt; Someday the cost of moving to Python 3 will go below the benefits, and the migration will happen faster. The cost of starting new projects on 3 is already better, and as a beginner new projects are what you should be looking to do.
Awesome. 
[PEP 461](https://docs.python.org/3.5/whatsnew/3.5.html#pep-461-formatting-support-for-bytes-and-bytearray) may be of interest. It's aimed at people processing data down the wire, and is another way to simplify the move from 2 to 3.
not a disservice at all. in 2015, it's drastically more valuable to be able to talk to a computer in python than talk to a human in french.
Probably encourage you to keep it short. eg you might prefer kbparser to keyboardparser without an underscore (I've no idea what a keyboard parser is either).
This is my guess: * `from foo import bar` : no Shift * `from Foo import bar` : Shift * `foo.bar` : no Shift * `Foo.bar` : Shift * `from foo_it import bar` : Shift * `from fooit import bar` : no Shift "Because modules are namespaces that are frequently accessed, let's make them as quick and easy to type as possible. Chorded keypresses are inherently slower and arguably harder than single keypresses, so minimizing them is one good way to help that."
My guess would be to avoid confusion wrt things like filenames, URLs, module names, identifiers, etc. "Lowercase ASCII characters only" is the safest possible subset that is guaranteed to not be mangled in any way and to clash as little as possible with naming conventions in the wider ecosystem. For example, many Linux distributions use `lower-case-with-dashes` for their package names, so underscores would break that convention. But using dashes instead would break other restrictions, e.g. some filesystems do not allow dashes in filenames, and Python itself would interpret them as subtraction. Camel case would suffer whenever case-insensitive comparisons are required, and wouldn't survive a non-case-preserving transformation such as what happens on old FAT file systems, or with things like internet domain names.
You should follow it. Many IDEs, such as PyCharm warn you by default. Style guides are important. But if you run across a different style from an older codebase, you should use the existing style as a matter of consistency.
Yeah, I think about 6 months or so ago I was finding examples that no longer worked with the more recent changes, but figured things out by focusing on the crossbar examples. I used it to build a demo with [cesiumjs](http://cesiumjs.org/), which triggered calls to python and python+matlab clients to perform some processing and send data back for rendering in cesium.
The 80 character line limit. It's stupid, and makes for uglier code. I try to keep it under 120 characters, personally. The only reason 80 characters would be reasonable is if you were somehow transported back to 1985 and had to work on a 640x480 monitor. 
 1. Line length. 2. Spaces after commas, e.g. I prefer my_function(1, 2, tuple_argument=("foo","bar")) 
They don't even need to read the sidebar. It tells you at the top of the page you use to post not to post what you're about to post. Making that post sticky isn't going to make people read it either.
ah, my bad, I thought theres whole range of peps dealing with good practices
I don't know about that. We can specify what the module we're importing will named with the 'as' statement.
Sure, I can sticky a reminder. Sorry if this sounds cynical, but be prepared for it to make no difference. We found no particular change in the number of posts like this when something was stickied or not. Please use the report button when you see posts better suited to /r/learnpython.
maybe you should move to /r/ialreadyknowpython
He just gave you e reasons.
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
French leaving in Paris here, you are way more likely to get some help - in English - from French people (which are non fluent in English) if you engage them with some french sentence, even if they are poorly pronounced with horrible syntax. Most of french are quite embarrassed by their English level so they are reluctant to speak in English. If you show them some bad french before, they will be way more comfortable to switch to English. In my experience, this is true for most country.
Different regional dialects of English don't even have the same number of phonemes. The only way to make English orthography systematic would be to choose one dialect as the official one. France did exactly that in previous centuries, forcing the rest of the country to conform to the dialect and accent of the rulers in the capitol. Frankly, I think that would be a shame to do to English.
Screw Potter! Voldemort agrees.
I hope this makes pypy more alluring in benchmarks, but it's kind of ironic when I use pypy for things that are going to run for a very long time...so reducing the warm up time by a few seconds is relatively insignificant. Keep up the great work though!
I worked in Africa, and yes it helped me a lot to speak french. But how many people will need french VS spanish or english ? The occasions where you need it are rare, so let's think Pareto here. Unless you have a particular objetive in mind of course, but that's not the case most of the time at this age.
New syntax is not automagic. It's just new syntax. Magic happens when you do something very implicitly so it leave you with no context to evaluate what's going and it seems to come out of nowhere. Not the case here.
There is a balance to find, and Python is usually right on it. Plus, you do want new comer to find it easy to use, as many professionnals will need to switch paradigm, speciality or language and must learn Python to be integrating working with other python team. Integration in a team has a cost, and Python si fantastic at keeping it low. Plus, I don't see how this improvement weaken in any way power users. 
Oh, very interesting, not sure how I missed that discussion. I could see function composition being much more useful with the 3.5 type annotations. Being able to enforce that return types and argument types of the composed functions would remove a lot of the mental overhead. Not surprised they decided against having function composition included in the language though, it seems like they are trying to distance themselves from a heavily functional style. At least it isn't hard to implement in the cases you need it!
That's ridiculous. No one would be arrogant enough to say they know everything about a language, we're all on some scale between "started today" and "wrote the language myself". For example, I've been writing in python for my job for ~3 years, but I'm discovering stuff I've never heard of all the time. Am I still beginning? How is it delineated? Wouldn't we need an expert to be able to judge our status?
More than sticky, it should show up on the submit page (...if it doesn't already. I'm on mobile and can't tell)
By failing to match my subjective views ;-)
It *is* superior to a solution based on %, since that doesn't let you do the `:%A` bit *in the template string* (you would have to call `date.strftime(%A)` every time you do `template % (...)`). But it is equivalent, aside from naming and the extra function call, to `do_my_format = "{0} is on a {0:%A}".format` (you could use `date` instead of `0`, but you would need to pass it in as a keyword argument). 
I think that the powers-that-be would allow a method like `format` to pull from the local namespace when called without arguments. That is too radically different from how any other method operates. Keeping things as consistent as possible is considered very important in Python.
It is on the submit page. As a moderator of several subreddits, here are some universal, comically intended truths: * people who can't figure out how to do something trivial like pip install aren't going to follow rules * new users don't read man pages * mobile iOS users are *just the worst* with respect to knowing rules, and it isn't their fault. I blame Apple. Some other things: * half the time when I remove something here on /r/python, the user is kind and thankful in a reply or PM * most of the remaining people don't say anything * maybe one user out of every hundred is angry 1% angry about rules is a pretty *amazing* ratio in a subreddit, which is mostly why my universal truths above are more comically intended.
If a class is getting long enough that this becomes necessary it usually a code smell that indicates to me that I should split it into multiple classes or otherwise refactor.
I thank you all for your replies, this is generating some great discussion and is helping me learn a lot about python and I hope it helps others too
&gt; python golden rule: Do not PEP 8 unto others; only PEP 8 thy self. &gt; Don't let PEP 8 make you insanely intolerant of other people's code. https://twitter.com/raymondh/status/486247110870695936
[**@raymondh**](https://twitter.com/raymondh/) &gt; [2014-07-07 20:35 UTC](https://twitter.com/raymondh/status/486247110870695936) &gt; \#python golden rule: Do not PEP 8 unto others; only PEP 8 thy self. &gt; Don't let PEP 8 make you insanely intolerant of other people's code. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I think 89-90 is a good compromise. The code block of an if statement in a for loop in a class method is really really cramped at 80 characters. If you use descriptive variable names (as you damn well should), the argument splitting and line continuations (with `()` not `\`, I'm not a barbarian) to maintain pep8 really ends up hurting readability. This is why google's python style uses 2-space indents instead of 4. I'd much rather keep the extra indents for readability and move out the column limit a bit.
I think using the try-except import is more idiomatic, and is the approach I usually use. It is also the approach I usually see in other projects I have looked at.
The problem is coming from inside the workplace!
Generally comments are not used to separate parts of a class declaration.
Or, you know, just read the sidebar. It's the very first thing you're supposed to do when you're in a new subreddit.
Here are the things that have made me feel like I 'know' python. 1. Can you write up a simple program, without Googling, and explain how it works? 2. When you make mistakes, can you explain why you made them and how to prevent them in the future? 3. Can you tutor/mentor or help someone who is learning by explaining how python (or general programming) works? I could probably add a few questions but I think think these three cover basics. You will always be learning, always finding better ways to solve problems. I think another way to think of it is that a beginner is learning syntax and keywords and how python works, while someone who is intermediary/advance is learning how to solve specific problems with python.
I think they call that being a "script kiddie" ;) I love how it's overly complex for what it's doing, as many point out, the code is to the point of redundancy.
Tools &gt; Python Integrated Tools &gt; Package requirements file I assume you'd want to change that to something like: requirements/local.txt I always have this as a comment in my root requirements.txt file.
Man, because it just feels _so_ wrong!
Agreed. And I think the consistent coding style is all that PEP8 is trying to enforce in this case. 
A colleague used the form-feed character (i.e. `^L` or C-q C-l in vim and emacs) to separate logical sections in code. It seems pretty archaic, but there is even a paragraph in PEP8 that suggests that `^L` could be used for that (see [here](https://www.python.org/dev/peps/pep-0008/#blank-lines)). 
&gt; This limit is still very useful because the human eye scan code faster when it's on a small column. I agree with you, but I often find that my long lines of code are long for a reason. There's usually something happening which just *feels* like it should stay on the same line for clarity. In these cases I find that it's so specific to that line of code that I probably don't need to 'scan' it too closely if I'm reading through, and if I need a closer look at least it's all contained in that one spot. That being said, I think I'm just describing a use-case for code folding.
Two newlines after function definition, one is definitely enough
This is a very verbose API. If you have some time to spare this winter, give pytest a try. It makes testing almost fun. Almost.
Why would inexperienced programmers ask for help from other inexperienced programmers? Are there experienced programmers in r/learnpython to help me with my noob question? 
Yes. A lot of Python programmers love nothing more than to tell others how to program in Python.
Lots of experienced helpers, including some published authors and people who actually teach coding for a living. Most posts get multiple experts reviewing it too. It's a much, much better place to get questions answered than here, as long as you approach it properly. Explain what you've done, where you had problems, and what you imagine the path to a solution is, and you'll usually have no problems there. When we allowed questions here, it was much less helpful. People would answer in a variety of ways, many of which were not particularly helpful. Answers were often terse, and frequently were written at a level that the person with questions couldn't understand them. 
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
Good stuff. Like my copy. Glad it's updated.
Try using six - http://pythonhosted.org/six/
What kinds (or level) of questions be before being allowed here? Or would you prefer everything go there?
this is not about user input interpolated into the strings, but user provided strings. currently, it's perfectly safe to do this: def send_greeting_card_mail(..., user_provided_greeting=None): greeting = user_provided_greeting or "Hello {name}, you have received a greeting card!") complete_message = "Subject: " + greeting.format(name=name, ...) + ... send_mail(complete_message) this is perfectly safe right now (as far as string interpolation is concerned), but if f-string interpolation were used on "Hello {name}, somebody set up us the {sys.exit()}", bad things happen. f-strings are safe because they are not passed around, but are always part of the program code. doing all the f-string magic on regular .format() calls would change semantics of existing code to unsafe. (of course, we could have a .formatexec() method that people must only call on trusted strings, but that'd be handing people an even bigger gun to shoot themselves into their feet, and would still not solve the issues outlined in the first paragraph).
Does this allow highlighting? I messed around with it and seems it doesnt have that option
Thanks. Yes, I contacted Intel, but they're slow to respond. They've specified some particular linking commands, which seem to break things at the compilation stage... which might actually be a good sign to be honest. I'll look for the AVX symbols in the meantime.
You can leave "Python" out of that sentence entirely. ;) Thus we find the basic principle which stackoverflow was founded on.
Sorry
&gt; you have a lot of freedom with swear words and insults Criss oui, maudit bloque! [the phoque? He's alone, he looks at the sun...](https://youtu.be/3Kf2WMgVFR4?t=29s)
For best results of any questions about how to write a particular piece of code, I would always recommend going to /r/learnpython. There are people there who can help you figure it out no matter what level you are at, and the entire subreddit is devoted to making sure that there are people around who can help you find your answers. /r/Python isn't really set up like that. You might get disjointed answers, there is no particular oversight to the answers, and the answers you get may not be useful to you, because people don't take into account the level that you're at. So it's less a "what is sufficiently important to get on /r/python" and more "/r/python isn't really set up to help you figure out how to code at any level, but /r/learnpython is". That said, my quick test for removal is either "do I know the answer" or I do a quick scan for a number of users who are active and whose judgment I trust to see if they have already directed people to /r/learnpython.
Good luck!
&gt;define useful. Profitable. Capitalism, baby, __YEAH!__
&gt; I couldn't muster a fully proper French accent and thus lost points for it. What the shit. In french schools, they have a tradition of [never giving a student a grade higher than 99%](https://www.youtube.com/watch?v=F2vup9sm_ls) "because perfection is impossible". The national animal of France is the cock (for serious).
I also just found this [recipe for defining infix operators in Python](http://code.activestate.com/recipes/384122-infix-operators/), that could be a better way to define the composition operator while allowing to operate on arbitrary functions (rather than just composable ones). Will explore this and possibly update if it is interesting.
Wow, seriously? That is...kind of bullshit in my opinion. If someone fully meets all the requirements for a perfect score, then they should receive said score.
My workplace decided that 100 characters is an acceptable compromise for the PyCharm users and everyone else. Pep8 is rather nice in getting a rather consistent style. Style wars aside, I've noticed that things like `go fmt` have led to really consistent packaging and I am beginning to wonder if a consistent style everywhere is better than arbitrary choice.
Better off using existing EC packages like [DEAP](http://deap.readthedocs.org/en/master/) IMO. Here's [an example](https://raw.githubusercontent.com/DEAP/deap/b46dde2b74a3876142fdcc40fdf7b5caaa5ea1f4/examples/ga/onemax_short.py) of DEAP on a OneMax problem -- piece of cake to use, and has tons of EC features implemented (multi-objective, several mutation and crossover operators, genetic algorithms, genetic programming, particle swarm optimization, etc. etc.).
This was when I first got on reddit. Its all a little overwhelmingly big. I imagine you've never made a mistake in your life. Congrats I hope everything keeps going your way. 
I'm aware of that. I use that when I deal with a library that insists on returning values like { None, [], [a,b,...,c] }, when it would be more appropriate to return { [] , [a,b, ... c] } and have another property that would signal what None was meant to (like 'never_defined_urls' = (True|False) ).
try just this: for link in br.links(): req = br.follow_link(link) print req.has_data() and see what you get.
its not a mistake of the editor docstring chosen to serve for commenting in pep 257 is just docstring.. a string that gets used on runtime, it does not get removed like normal comments.. but do post picture of your syntax highlight with shown difference between regular string and docstring for comment
I prefer using a single quote (') instead of double quotes ("). It looks less noisy and I try to keep my code as quiet as possible.
Why not get a job somewhere that uses a lot of python. Do you live near to a big city? Python is big in banking. 
Glad you like it. Do raise any issues you find with it including but not limited to all typo or factual errors.
We can also employ the trick used on /r/java which you can see if you have subreddit styles enabled.
&gt; You'll have to be more specific about what kinds of infrastructure are necessary. My limited knowledge tells me that `gofmt` is just something you run after editing or shove in your pre-commit hook. Well, for one thing you'd have to consider rejecting or reformatting incoming packages on PyPI to begin the process of enforced consistency. I would not want to be present at roll out for that. The butthurt would probably fill encyclopedias.
What is that quote from?
This reminds of some advice I saw on how to get a good answer to a question. 1) Find someone else who had the same problem 2) Answer the question _completely wrong_ 3) There will inevitably be someone who can't stand that someone was wrong on the internet and answers the original question correctly and thoroughly just to prove you wrong I should be clear that I am not characterizing those in /r/learnpython as these sorts of must-be-right people. I think that idea came from how to get a good answer on stack overflow.
&gt;If it is between quotes, it is a string. End of story. We would never have had list comprehensions with this reasoning. Actually, we'd have to have invented something different for indexing, I suppose. Also, naming things is even harder than explaining them, IMO. ;)
&gt;(No criticism: I do my best to forget about them too.) Rather wish they'd put up a package on PyPI to support them in 3.x instead of putting them back in the standard library in 3.2. :(
Thanks!
If your app has no knowledge of the token creation, it can't be used to login to your app unless it is first associated with the user. This is typically done through some one-time login with a separate password while passing the token too. 
[PEP 484 Type Hints](https://www.python.org/dev/peps/pep-0484/)
It's called [Poe's Law](https://meta.wikimedia.org/wiki/Cunningham's_Law), really interesting to see it in action. Also, [relevant XKCD](https://xkcd.com/386/)
That is the correct approach. You should store that token on your server (probably in some database), and then on every request the user makes to your API it should check that that token is in fact associated with the correct user and that the token is still valid. So, in summary, only generate the token when a user logs in, keep the token active for a given amount of time, and verify the state of the token on every request from the user (store the token as a cookie or similar).
Hahaha, I love this. Best answer.
I saw a [talk on this topic by Guido](https://www.youtube.com/watch?v=2wDvzy6Hgxg), earlier this year. I'm excited for the optionality.
Don't have an answer for you but I use the following to make my life better. &gt; PageAdapter pattern for Python Selenium browser test abstraction &gt; https://github.com/tysonclugg/selenium-page-adapter
Impressive benchmarks, and the plotting system looks very solid. Yeah, I need to give this a shot.
I can't help directly here (because I always found oauth extremely fucking confusing), but you might want to look at the source code for [django allauth](https://github.com/pennersr/django-allauth). Could help.
Exactly. Python is great because it focuses so much on *readable* code, not necessarily concise code.
Thanks! I will definitely check this out. I feel kind of stupid, I wasn't selecting the table row above it correctly so this next step was failing. 3 hours of my life I won't get back haha. Thank you!
I find googles guidelines way too restrictive. I tried to follow them and quickly found that importing only modules was ridiculous and avoiding line continuations with `\` often lead to less readable code. You can't write: from collections import OrderedDict data = OrderedDict() You have write: import collections data = collections.OrderedDict() Which means you run up against the character limit quickly and have a bunch of extra visual noise that adds practically nothing. It is kosher to alias: import collections as col data = col.OrderedDict() That not only leads to code filled with incomprehensible abbreviations, but taken as a style guide, can lead to a culture where abbreviations creep into everything else. Not just module aliases, but function names, class names, and variable names. I don't have a vendetta against abbreviations, but they can get out of hand.
So, I just got around to starting to build a version that should actually work, and guess what? The first line is `Initializing submodules for PySide version 2.0.0.dev0`
You can always clean up the names at import. Pretty much all the science packages do it (annoyingly). My code usually starts with something annoying like, but at least it's consistent with the naming other people use: import numpy as np from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt 
1) /r/learnpython 2) ask a specific question. Try doing something and ask about where you are stuck.
More importantly, you don't need to hit shift.
Mine does it. One sec. https://imgur.com/w8Xzl2d I use Kate as my text editor. It's part of KDE. I use it on windows at work too.
Sorry if this is a very basic question, but what is a backdoor and what is it generally used for?
&gt; The only excuse for using Python2 is supporting a legacy codebase. And the fact that it's 80% of the market, so all the libraries support it.
Uhm... what happened? Both the github link and /u/benkroop's reddit profile have poofed. Ben, if you have an alt account, can you explain? Or maybe I'm the only one experiencing the issue?
&gt; It will not happen so long as the unwashed insist upon using tab characters for indentation ;) Bah. You either have to press the keys more, your editor literally disregards your actual keypresses and replaces it with something else, and you make it impossible for someone to change how indents appear for their own personal preferences (for example, I prefer two spaces for indents, which can be easily handled by setting tab width to 2 in my IDE if we use tabs rather than spaces). And your code with spaces takes up more bytes. tl;dr you and Guido are the devil. Intellectuals use tabs. The canaille uses spaces.
I prefer single quotes, and I use tabs instead of spaces because only Nazi swine who wish to enforce their preferred indentation width upon everyone else use spaces.
It is really as simple as madskillsmonk said. Save the token returned by the web service and make sure the client confirms that token with each request it makes. The easiest way to do that is to set the token in a cookie and verify that cookie value against the value you saved on the server side. Easiest place to save to token on the server is in a database. Flask-Security does basically the same thing when you use the token based authentication feature.
About abbreviations, I totally agree, except now I use variable names that are multiple words connected with underscores. Is there a guideline on choosing short variable or function names that still makes their use obvious and/or still makes the code "self documenting"?
I don't have the foggiest idea what real problem you think the novice thinks is getting solved this way; nor how you can look at a code construct that selectively uses escape sequences in order to arrange two different substitutions that work in different ways without seeing "sheer ugliness"; nor still why this putative novice knows of `eval` (which is necessary in order to write code that uses it - the exact opposite of missing the point!); nor why the existence of fstrings is somehow going to magically cause people to start using `eval` recklessly when its implementation has nothing to do with `eval`; nor more generally how language features can "guide a thought process" towards using totally different language features. I can make a guess at why you think "this feature revels in implicitly doing so", but you've already had it explained to you repeatedly, both in this thread and the one you started, why that's wrong. Seriously, what you're suggesting is that, because creating an analogous variable leak to the `**locals` one with fstrings (granted, it *also* introduces something analogous to SQL injection) requires jumping through all of these hoops - including the use of a function that is literally never mentioned by anyone sane without a ten-minute session of warnings and attempts to talk the other party out of it - this is supposed to make people *more* likely to write insecure code? Absolutely nothing about your argument makes the tiniest amount of sense.
https://wiki.python.org/moin/2.x-vs-3.x-survey?action=AttachFile&amp;do=view&amp;target=2013-2014+Python+2.x-3.x+survey.pdf It's the best survey we have (as far as I know)
&gt; A list comprehension is no more a list than an f-string is a string. Both are code expressions that evaluate to the respective types. List comprehension evaluates to a List. So it is called "List comprehension'. This new thing evaluates to a string. So it should have a string in its name. What is so confusing? Me saying "It is withn quotes, so it is a string" does not mean that it is a real str object. But for the programmer, for the most part, it IS a string, just like list comprehension can, for the most part, act like a List. Anyway. I don't want to go further into this topic.
Yes - I agree that Py2 is still widely used, and has good library support. However: * Many Py2 users have a lot of Py2 code to deal with. OP doesn't. * There's going to be a migration cost someday. OP can avoid that entirely. * Module support for Py3 is now very good. * IMO, the unported long tail is less valuable than the core language improvements (and I have to deal with such modules regularly) * There are libraries and language features that only support Py3, and the number is only growing.
Where I'm writing a service rather than just an application, I might offer command-line interface for developers to easily tweak configuration but also use environment variables to allow running on servers. My preference for precedence here is (i) command-line option, (ii) envvar, followed by (iii) argument default. I currently construct these using argparse which is quite repetitive (yet to try [ConfigArgParse](https://pypi.python.org/pypi/ConfigArgParse/)) in the manner of `add_argument(..., default=os.environ.get('ENVVAR') or 'real default')` -- potentially passing the fallback default into the get call, depending on whether I want empty envvars to override the default. I'd love to read about how these libraries (and some of the others mentioned) help you utilise environment variables.
Fantastic piece of work! Well done.
&gt; Module support for Py3 is now very good. Depends. There are plenty of libraries I use that still don't support Python 3 to my liking and nothing out there replaces them without a ton of work (and even then). I'd say the OP should do some research and choose cross 2/3 libraries (which also tend to be popular) where possible to avoid that issue. I write Python 2/3 compatible code because it's easy once you know how. I support old versions of numpy, vtk, scipy, and PyQt in my open source project as well as Python 2/3. It''s really not hard and it gives me flexibility. &gt; There are libraries and language features that only support Py3, and the number is only growing. You'll be able to take advantage of new features you don't have the time or need to learn (e.g. tulip/async). It's neat stuff, but you can do without. I'm still waiting for the Python 3 killer feature. I suspect it will be a 3rd party library dropping support for Python 2.7 that makes people finally switch. Upgrading for the sake of upgrading is a waste of resources. Using the version nobody knows or supports explicitly is a bad idea. &gt; There's going to be a migration cost someday. OP can avoid that entirely. And hopefully there will be a decent unicode tutorial someone puts together by then. The migration cost is minimal if you use `__future__` and `six`. 
Is there a tool to 'translate' something into its long form? For one off fast scripts I'll do ```from ____ import *``` but for stuff that is going to go into the corporate vault it needs to be called out explicitly. &gt; have a bunch of extra visual noise that adds practically nothing. Tell that to the person trying to figure out how your script works in a decade. There's a reason Google has that standard.
I think that was one of the main reasons it was rejected. Nobody was able to demonstrate a good use-case. Add to that the fact that it is easy to do with a decorator if someone really wants.
&gt; and you get the feedback as soon as you write the code, automatically. This is such a big influence on code quality. It becomes *annoying* to write poorly formatted code, because it gets flagged with wiggly lines all over the place.
The easiest way is probably to simply store the token in a cookie. They are done for that. (Of course you need HTTPS, which is mandatory anyway as soon as you begin to add users authentication to your website)
is it what you envision for your SQL code ?
The f-string way is the obvious way to format string.
Excellent! I love Command and Conquer!
google search and stackoverflow search is also a valuable tool
Even better, you can have three open with 80 chars! It's not about a specific screen size, it's about some people preferring to pack more windows in rather than to make existing ones wider, especially coupled with e.g. finding short lines better to read.
if it's a one shot script, committing only every 1000 or 100000 iteration should do the job. Another possibility is to use executemany. 
Didn't know it existed - looks dead in there though - only one question 3 years ago. 
Damn, I used to love Red Alert :D
Check out [sphinxcontrib-napoleon](http://sphinxcontrib-napoleon.readthedocs.org/en/latest/). Turn that on, and write in numpydoc or Google style.
I mostly disagree with template strings in general for all the reasons that were given in the other comments. I think it's even worse in JavaScript due to the syntax they chose that uses backticks. Backticks are horrible to use in programming languages because they are hard to differentiate visually from apostrophes and are hard to type with a lot of keyboards. In short: they are hard to read and hard to write. That was the worst choice ever.
Python 3 library support list: https://python3wos.appspot.com/ Not comprehensive but useful.
Highcharts is good, d3.js is the macdaddy of them all and you can get pretty granular with that, you could use django rest framework to create an api on your server where you will post the old data using your JSON array into the DB storage and then would be able to use a javascript frontend for your charts by accessing your new API, good luck
1st thing, which library is the best for this application? I have heard mixed ideas.
Indian or Polish would be more useful than Arabic over here we have more of them.
Wow, warm transfers would be such a massive improvement if they were used everywhere.
&gt; naming things is even harder than explaining them, IMO. Yep, IMO too. A good name *is* a concise explanation.
 @click.argument('src', envvar='SRC', ...
It's just syntactic sugar, and is much clearer to look at when you have multiple named functions. For example, in a project that I work on called SHARE, we have a metadata normalization pipeline, where we take in API/scraped data in a variety of data formats, and transform them to our own schema. To do this, we use a pathing language, and then specify any additional data transformations that need to be performed (these are just functions). So for example, if we are normalizing data that has a date stored in a `publicationDate` attribute, which when resolved gives us a list with a single string representation of a date, rather than writing a function that takes a list, parses the first element into a date and returns it, we can use a composition of smaller, more general functions. So say we have the functions def single_result(l): return l[0] if l else None def date_formatter(datestring): return dateutils.parser.parse(datestring).date() we can then use this syntax to specify our transformation: schema = { 'date': ('/publicationDate', compose(date_formatter, single_result)) } (I don't use dot syntax or anything like that in my real projects, since the syntax would confusing for new developers on the project, that's why I wrote a blog about it instead :)) This, when applied to a result in our normalization logic, will rip out the `publicationDate` attribute, grab the first result, and return the date. Since we have nearly 60 data harvesters (and have potentially hundreds to thousands more in the pipeline), being able to compose functions is actually very useful. The dot syntax just makes it even easier to compose the functions, but again it's just syntactic sugar. Another benefit of composing `f` and `g`, rather than calling `f(g(x))`, is that the return value of `f . g` is a function, and at the time of defining a schema, we have no values to apply to the function. So we would either have to define a new function, `date_format_first_result`, or use a `lambda`, to get the equivalent meaning to the above code. I personally find function composition much easier to work with and conceptualize, but it's a stylistic thing I think. It has saved us a lot of time in the SHARE codebase though. Here are what the two alternative implementations to composition might look like, btw: def date_format_first_result(result): return date_formatter(single_result(result)) schema = { 'date': ('/publicationDate', date_format_first_result) } or schema = { 'date': ('/publicationDate', lambda x: date_formatter(single_result(x))) } Hope that answers your question, and if you have any others I am happy to answer them!
Question for the more experienced folks: What's the most malicious thing you could get through that regex filter?
This is really cool! TimelineJS looks so interesting! One question I have is why return at line 129 if there's nothing to return? It looks a bit out of place in the code.
Oh, no argument! I just with it had been a language with a little more usefulness.
"Although that way may not be obvious at first unless you're Dutch." I'm not dutch, but I suppose if Guido bless this new way, it is because it's intent is to make it the obvious way 
It's not used in practice because Python 3.5 hasn't been released yet.
you can import the module in python 3.3 and 3.4 (if I am not mistaken for the versions)
The histogram of arrival times does not contain information about the relationship between neighboring inter-arrival times. For example, a time map can tell you that a time difference of 5 hours frequently follows a time difference of 2 minutes. In the paper itself, there's a more complicated example involving a twitterbot, where a triangle pattern in the time map reveals some interesting behavior: https://github.com/maxcw/time-maps/blob/master/time_maps_paper.pdf
From [https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html): &gt;Matches the end of the string or just before the newline at the end of the string, and in MULTILINE mode also matches before a newline. foo matches both ‘foo’ and ‘foobar’, while the regular expression foo$ matches only ‘foo’. More interestingly, searching for foo.$ in 'foo1\nfoo2\n' matches ‘foo2’ normally, but ‘foo1’ in MULTILINE mode; searching for a single $ in 'foo\n' will find two (empty) matches: one just before the newline, and one at the end of the string. So in this case, it'll match the end of the string, not the end of the line.
Yes, especially in Python, where many software engineering jobs that don't involve web development are very QA oriented. A number of teammates at my job (I work in "Quality Automation") have a 100% quality background and only learned Python at work. When I'm interviewing candidates for that role, I will always prefer someone with a QA background who became a programmer over a someone with just a programming background. It will be more difficult for you than most people and you'll see a lot of rejections because of your lack of a relevant degree and how long you have been doing other things, but definitely possible. You're going to have to be patient about that, big companies are probably a worse bet for you. You're probably also going to have take a fresh-graduate level of pay unless you can really sell your QA experience as valuable.
It's terrible as an actual opensource license because you can still get sued.
For future reference, the only regex characters you need to escape inside a character class are those that have special meaning in a character class, so - (e.g. 0-9) ] (ending the class) ^ (not) \ (escape) the rest of the normal regex special characters (`*`, `.`, etc) don't need to be escaped inside there Also related, your calculator doesn't appear to support division. Perhaps you need more test cases :)
I tried dozens of JS charting libraries, but found Google Charts to be the easiest to use. Most of the others require a lot of fiddling. I am not a JS expert, I just want the libraries to work out of the box. Highcharts failed (at least for me), d3.js is too complex. Flotcharts worked, but looks a bit dated. Google Charts surprised me: It worked out of the box, and produces beautiful graphs. Here is an example of Google charts with Flask: http://www.twitteranalytics.org.uk/
 def calculator(): while True: eval(input("&gt; ")) 
WOW! Incredible! Thank you so much for this, I will be using it *A LOT* :-)
Yeah but isn't it just mypy added to the core language?
[It doesn't actually check anything.](https://www.python.org/dev/peps/pep-0484/#non-goals)
I guess I wasn't the only one who thought this was somehow related to Command and Conquer. :(
Well, you can get sued with any license. A ham sandwich can be sued, as they say. You meant to say, you can lose a lawsuit. Theoretically anyway. It's never actually happened once in the history of the world, but hey, I'm sure your 50-line calculator app is what's going to make copyright history.
Woah dude. I'm not an application. I'm just a Rudy.
also: result = calc.calculate("1+-+-+2") U mad bro 
Great to hear that!
`numexpr` is a good library, but `ast` is built-in making it useful in a pinch or in a coding challenge that requires you to implement it yourself.
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
I think I have a crush on this thing. ;-; It's so beautiful. Look at those registers. ;A;
Funny thing is, I know this already. But I was hoping there was an external tool that does it. I tried mypy. But it died with an error that said cannot import Undefined. Probably because it is using the typing module that came with 3.5.
`calculate` is a function. It has no reason to be a method attached to a class.
You can build your own framework to understand the background. It's not so hard as you may think. Some of the things you will need to know: The little basic about HTTP protocol and [WSGI](http://wsgi.readthedocs.org/en/latest/) - the most important. 
&gt; Uh, no? typing is a new module in 3.5. (Not to be confused with types, which contains a bunch of references to CPython internals and has nothing to do with type hinting.) Its in pypi as well.
I use it at work along with mypy for checking. Mypy is still quite immature, so some valid python will make it fail but I've found it worth it for all the bug it catches. I write my code around mypy since I know it will become official with Python 3.5. The comment syntax for variables isn't great but I mainly annotate function parameters and return values so I rarely use it (apart for # type: ignore to skip type checking on an imported module).
It was probably put in there due to project requirements. As someone who's had experience programming for school classes, they make you include the most superfluous things.
Thank you! I can't believe none of my googling brought me this. 
When I tried using it with 3.5 it failed with a 'Cannot import Undefined' Error. Is it because is using 3.5's typing module instead of it's own.
&gt; The comment syntax for variables isn't great but I mainly annotate function parameters and return values so I rarely use it (apart for # type: ignore to skip type checking on an imported module). I'm using it with python 3.4 so thats possible :). I know the BDFL had mypy in mind when adding the typing module to 3.5 so it will probably fixed soon.
i never heard of anyone having a problem with backticks but no matter: what other reasons do you mean?
Here's a `RuntimeError` too: eval('()' * 2998) Edit: actually my Python froze upon running `eval('()' * 9999999999999)` and made my computer awfully sluggish. Edit 2: actually that must've been just the string multiplication. `eval('-' * 1500)` causes this though: s_push: parser stack overflow Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; MemoryError
PyCharm already understands type hints
No. It's mypy with additional features and formalization. If I understand it right, it largely follows mypy's style, so ints/floats/Lists/Dicts are the same, but objects are a bit different. If you're in Python 3.3+, you can use mypy or search for things that use mypy for examples.
ahhh, oh well. I don't see any other holes in the regex
 eval('((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))') This does the trick for me: s_push: parser stack overflow Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; MemoryError 
What I mean that even in python 2, the numbers are nearly transparently transformed back and forth between `int` and `long` so the int/long unification is a kind of implementation detail.
Awesome work mate ! Keep it up !
Yes, but when you're messing with `int32` and `int64`, you do need to be concerned about overflow
Maybe "traits"? I confess to no meaningful experience with it myself...
From this sub, 4hours ago: [Sparklines in pandas](https://www.reddit.com/r/Python/comments/3kjxkz/sparklines_in_pandas_dataframe/)
`entry_points` is a feature provided by setuptools. If you don't want a runtime dependency on setuptools, you can't use `entry_points`. Instead, you should create a script in the way you suggested. This needs to be installed into a 'bin' folder, which can be done using the `scripts` parameter to `setup`: https://pythonhosted.org/setuptools/setuptools.html#basic-use 
Or coding in split screen.
Consider using not Windows.
Are you kidding me right now? All the FBI have to do is trace the outgoing connections then send Reddit a message to shut the account down. You clearly have no idea what you're talking about, just stop.
Note that pip will convert those entrypoints to a static wrapper script (so no runtime dependency on `pkg_resources` to run `console_scripts`). Not sure from what pip version but it feels like it was like that for long time. Generally, using `scripts` is a bad idea as it's not portable, almost impossible to get it right on Windows and easy to get it wrong even on Linux.
yep, 100%
I would probably watch all the videos from David Beazley before these. :)
Another solid entry. Thanks. Also, what up crazy man? I'll txt ya.
did you use `sudo pip uninstall`?
I hope you at least use spaces for alignment.
In Haskell, you can use it to compose two functions into one, essentially creating a new function that can then be passed into a function that accepts an argument. For example, to turn a list of integers into all negative numbers: map (negate . abs) [1, -10, 5, 4, -1] This turns out to be very useful in functional programming. In Python (which isn't as well-suited for functional programming, and, in fact, is discouraged by GvR) it's more syntactic sugar than anything.
Eerie, I was just writing specs for this (for php5 though). Great job.
If you have to make a class with no `__init__` and only one function, you don't need a class
There's a lot more than what's on PyPI. Now that wheels are a thing, hopefully more projects will be on PyPI. Things like VTK and wxPython are not supported yet. &gt; Python 3 support for the top 200 PyPI packages I've looked in the past...where is this fabled list? They don't let you sort by popularity. I figure I can read up on the top 200. I occasionally go though things like WinPython's list, but it'd be neat to see what's out there in a better way.
 def settings_with_precidence(modules: List=None, overwrite: bool=True): It's precedence, not precidence. 
why don't use anaconda as your python distribution? then you can have environments and a package manager.
d3 is the mac. there is a wrapper called nvd3 and even a shitty python wrapper for that called python nvd3. it spits out the html js css code from python. I've used many things before and typically use matplotlib for initial plots. when you want to get good looking graphics then learn the javascript (or tell the front end people at work to make something nice with this dataframe)
Does it crash as badly as the TUI does?
Good god, that looks horrific. 9 lines of code just to define the function parameters for __req().
The class was due to the requirements https://github.com/EIK-LUG/PythonCodeClub/blob/master/2015-09-09-calculator/challenge.pdf
Bad tutorial/challenge then :/ It is teaching people to make classes without specific reason to, which just leads to needless extra verbosity and complexity. It's one of Python's advantages that it's able to avoid that sort of stuff effortlessly - whereas in a language like Java, one must *always* create a create class to hold functionality, because Java is *pure* Object-Oriented.
Amazing stuff. Well done! What blog software are you using? Love the look of the embedded code with surrounding commentary referencing line numbers. Much nicer than IPython-notebook/Jupyter.
I'll give it a try later, but I've little experience with it, thanks!
.git/hooks On mobile, but that should be helpful. If a hook returns non-zero exit status, git fails to do what you asked it to do. Also, remember to re add the files after fixing them, or git will commit the broken files, as the ones on disk are good.
Ahh I checked the documentation, it does not support operators! I didn't quite remember that. So probably you can't use it directly!
good to know
Whoever wrote the requirements needs to learn python themselves. Things like this: class Thing(object): def __init__(self): self.x = 'yes' def somemethod(self): # do things Do not need to be a class.
Yeah, it's not great. If you put them all on one line it's unreadable, and when you put them on their own line....it's barely readable. I wanted to embrace the future, and I love how PyCharm picks them up..but I feel like this implementation could be a flop. You can fiddle with the formatting a little bit more, but then it's a huge trade off just to make it look nice. def __req(self , url: AnyStr , method: AnyStr = 'GET', , as_json: bool = True, , raw: bool = False, , timeout: Union[float, tuple] = (5.0, 20.0), , **params ) -&gt; ReqResponse : pass
Where did GvR discourage functional programming? 
This seems like a situation where an object-oriented approach would be cleaner still. You define container formats that includes your operations as methods. Then you can just do: lambda x: x.date_formatter().single_result() This also makes it easier to organize your code, and avoids issues with typing since only the correct container will have the appropriate methods.
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
It's always amused me that traditionally when I used to talk of elk [1] or traits [2], I would be accused of not knowing python properly. [1] https://github.com/frasertweedale/elk [2] http://code.enthought.com/projects/traits/
Doesn't produce any output print(eval(input("&gt; "))) FTFY
nearly anything you want &gt;&gt;&gt;print (re.match(r"^[0-9\+\-\\\*\(\)\.]*$", r"\160\162\151\156\164\50\47\150\145\154\154\157\40\167\157\162\154\144\47\51")) &lt;_sre.SRE_Match object at 0x7fb11a8c5510&gt; 
I just wondered if it was using the TUI curses stuff and was inherently as unstable, or it was separate. You seem to have more views available which is good. I was always annoyed there wasn't a good view into the stack that followed the stack pointer.
Is that an input error? Usually it just means repeat last result. I do see your point though. It is something I didn't check for.
It could be decorated as @staticmethod. I am happy with it being inside the class as it's associated with it. The staticmethod decorator makes it clearer. Although to be honest, it doesn't need to be a class at all.
&gt; Although to be honest, it doesn't need to be a class at all. Yes, that's my entire point
https://github.com/gunthercox/ChatterBot Might be good
Oh, no no it does not use TUI mode. This is just plain GDB commands + the Python API.
&gt; Chapter 15: Generating Non-HTML Content Chapter 16 – Django sessions One has : seperator, one has - seperator.. Is that intentional?
And with flake8 you will get pyflakes and others as well https://pypi.python.org/pypi/flake8
This is a really good book. I like how it breaks down the concepts, and explains how code flows throughout the entire app. Many books say 'URLs are structured like this' and the student is left scratching their head at the mess in front of them. But this says, URL settings are defined in settings.py, the r stands for raw, the ^ is the beginning, the $ is the end, variables are passed with (), etc. One piece of feedback (if you are the author) is to add in apostrophes where necessary. For instance 'if youre used to languages'. It looks like apostrophes were stripped from the entire document. It takes a lot of the polish away seeing so many of those errors.
&gt; You've reached the static mirror of https://pypi.python.org god damn it. It's in my distro's repos, which is much better than installing through pip.
I agree with the post, but I have to mention that I've successfully packaged complex apps (PyQt, ZeroMQ, gevent, +) on Windows, Linux and OSX. No solution would work without some configuration, but in my experience cx_Freeze works the best in general, especially for Linux. py2exe gave me the best experience on Windows (last I checked it did work for Python 2), and py2app on OSX (this one was actually the biggest headache for me, but I did get it to work). Yes, they do tend to bundle everything up into large packages, but that's often what you want when you want to distribute something that "just works". And on Windows, at least, none of that stuff is likely to be there anyway. My point is only that the situation is not quite as hopeless as he makes it seem, but there is definitely a lot of room for improvement.
Using anaconda is strictly easier than using the default distribution, you should give it a try!
The typing module is available in pip for 3.2 or higher.
You may want to try pyal, which is a wrapper for OpenAL. You don't need to bother with the positional audio bits if you don't need them. It will require a bit of learning the OpenAL api for what you're talking about. Hth
I believe that [pysoundfile](http://pysoundfile.readthedocs.org/en/0.7.0/) is the best library for reading wav, ogg, and flac files (any format that [libsndfile](http://www.mega-nerd.com/libsndfile/#Features) supports, notably *not* mp3). This is a shameless plug since I wrote this library. Notably, this can be installed as a pip wheel and bundles libsndfile on Windows and OSX, and can open any file-like object, including e.g. pipes or PyMongo instances. For playing sound, there are a couple of [portaudio](http://www.portaudio.com/) bindings, of which I believe that [sounddevice](http://python-sounddevice.readthedocs.org/en/0.2.0/) is the best by far. This is only slightly shameless, since I contributed to [PyAudio](http://people.csail.mit.edu/hubert/pyaudio/), then created [pysoundcard](https://github.com/bastibe/PySoundCard) as a successor, to which the creator of sounddevice contributed heavily, and then created sounddevice as a successor to pysoundcard. Sounddevice can also be installed as a pip wheel and bundles portaudio on Windows and OSX.
py2exe (v0.6.9) does work for Python 2.x, it's just that it appears to be no longer developed. But so what? (And it can always be patched or forked if there is a need for it).
This might have been a more appropriate question for /r/learnpython . 
Deleting 3.5rc3 installer that I forgot to install. Gosh, I'll have ~~4~~ 7 versions of Python installed. EDIT: actually it is 7. 4 CPython, jython, PyPy and IronPython.
There are some factual inaccuracies in this post. PyInstaller __does__ support Python 3 (3.3+, in fact). Additionally, isn't this made easier by zipapp? Then you "only" need to package the interpreter to run from the zips, right? I do think there is room for improvement, but I think the author does not take into account that people do not like large binaries. Not everyone can download a megabyte quickly.
I Love how you've answered your own question ;D! Thanks for sharing though I've never heard of this before but got some cool idea which could quite work out! Like a bot which sends you highlights from a certain newsite every x amount of time! Or like recent soccer scores, some sort of rss-feed notifier! Thank man!
Yay for PEP 465, a.k.a. matrix multiplication with @!
&gt; Is this even possible? Yes. &gt; If so, any ideas for how to start? Get a graduate degree in natural language processing or artificial intelligence. I kid. It depends on how tightly linked you want input and output to be, but you're entering into a potentially complicated space right here. The simple solution would just be to do [Markov chains](https://en.wikipedia.org/wiki/Markov_chain). 
&gt; mkvirtualenv I actually am not. I know I should, I just never get around to it. I like to live life dangerously. :)
Oh no I barely studied!
More importantly, yay for it being customizable! Just override `__matmul__` in any class to make use of a cool new operator!
I think what he is referring to is what is more commonly known as the slope of the power spectrum. As he mentioned, the average frequency exponent of the power spectrum for natural images is approximately 2, which corresponds to -2 in log-log coordinates. Take a look at [this paper](http://static-content.springer.com/esm/art%3A10.1007%2Fs00530-013-0316-2/MediaObjects/530_2013_316_MOESM5_ESM.pdf) which discusses that a bunch in Section 3.3.
Looks good!
I will try that. I am actually glad to know that it is compatible with numpy, since most of the processing will be done using numpy! Thanks :)
You should start by learning everything you can about natural language processing. Then tighten the idea up a bit more and then get cracking on the artificial intelligence and machine learning aspects.
Any particular reason why this version is .post1 at the end: 1.9.0.post1? See on [pypi] [pypi]: https://pypi.python.org/pypi/oauth2/1.9.0.post1
I have a question that is probably dumb. Why not deploy a virtualenv? I've only done this a few times and only for CLI applications and on Linux but it shouldn't be an issue on Windows or OSX.
I have a fair amount of experience with python freeze modules like py2exe, cxfreeze and pyinstaller. I started out with py2exe when switch over to cxfreeze. Then I stumbled with a problem with a program developed in Windows with cxfreeze like matplotlib and lxml modules. Then pyinstaller resolved the issue by analyzing my modules and creating a configuration file for me. I found out that pyinstaller was the easiest one to use amongst all 3 of them.
Declarative programming with Haskell syntax? I'm in.
Pencils down.
congratulate all python teams to.
I am looking forward to trying out the [Embedded Distribution](https://docs.python.org/3.5/using/windows.html#embedded-distribution)... *The embedded distribution is a ZIP file containing a minimal Python environment. It is intended for acting as part of another application, rather than being directly accessed by end-users.* *When extracted, the embedded distribution is (almost) fully isolated from the user’s system, including environment variables, system registry settings, and installed packages. The standard library is included as pre-compiled and optimized .pyc files in a ZIP, and python3.dll, python35.dll, python.exe and pythonw.exe are all provided. Tcl/tk (including all dependants, such as Idle), pip and the Python documentation are not included.* 
once you have it installed: http://conda.pydata.org/docs/_downloads/conda-pip-virtualenv-translator.html
It's `operator.any_operator(a, b)`: import operator a = 1 b = 2 c = operator.add(a, b) print c &gt;&gt; 3 ----&gt; 1 a.add AttributeError: 'int' object has no attribute 'add'
&gt;the vast majority of desktop activity happens within browsers Python is pretty much only useful in a desktop sense. So what does that mean? Python is already a thing of the past?
ill send screen shots if that works better? i could post the whole code but it's filled with a lot of garbage. Which is probably why I'm having the problem but i really don't think so.
You can encrypt the messages but the bot will be listening to the subreddit so using wireshark you can intercept outgoing connections. Then send a friendly mail to reddit and there you go. You don't even have to be FBI, I'm sure it's agains reddits TOS to use reddit as a c&amp;c
&gt; PEP 486 , making the **Widnows** Python launcher aware of virtual environments
I think /u/lengau forgot to put \\ in front of their \_\_ and actually meant a.\_\_add\_\_
yeah, how do you expect a programmer to know about escaping? he's not a burglar.
I suppose it depends on what you're intending to build. E.g. really sophisticated games or other performance intense tasks will probably continue to be run directly on the OS (though asm.js and others make me hopeful), question is whether Python is the right language for that or whether you want some more low-level such as C/C++. The Web-platform has come far and I'm honestly amazed at how powerful JS engines such as Chrome's V8 have become. Frontend libraries such as React.js also don't fail to amaze. Just targeting the browsers (some hassle there, too. I admit) instead of different operating systems (and versions!) and being able to continuously improve your software (users just have to reload) to me seems like the better approach.
Pushing your code to github, then asking on /learnpython is the best way to get an answer. This sub is for news &amp; announcements, whereas /learnpython is for code critique.
Lots of Data Analysis/Data Science + scripts of all kinds still also are large Python use-cases for the Desktop
That might actually be enough for me to finally abandon Python 2.7 for 3.5
where's the love for await?
I think it's stalled.
dang, I was looking forward to it Edit: [pep says it's in final stages!](https://www.python.org/dev/peps/pep-0492)
Actually looking forward to that a lot myself, even though it's just syntactical sugar. 
Meh. This falls into a similar vein as the Flask API post. &gt; It means my REST API knows little about the Django or Flask project that is being implemented. * Why are you duplicating model definitions? * Validation? * Access logic? It just doesn't make sense. You can definitely thin out the Django stack to speed it up, but frankly something like Varnish and appropriate purge signals is going to give you better results with less effort.
[Everything you need to know.](https://docs.python.org/3.5/whatsnew/3.5.html) Don't despair. You can learn all that within a day. Good luck for tomorrow!
I always found their symbol names such as "add" and "matmul" unfortunate, when their semantic can be user-defined. It would make more sense to decouple their semantic meaning from their symbol name, so instead of "add" you call it "plus", since its a plus symbol with default semantic of addition. Once the user overrides the "@" operator, the name `__matmul__` becomes meaningless in all cases except when the new behavior is again a matrix multiplication.
Plus it eliminates the whole "Oh shit, is that * going to do elementwise or matrix multiplication?" issue.
I finished my degree 25 years ago, and I still got a sick feeling in my stomach when I read the title.
thanks for the help, but when I do python kickstart.py it says No such file or directory. e maybe I didn't configure it right. by configuring it do you mean "buy hosting and domain server, and follow this https://www.digitalocean.com/community/tutorials/how-to-install-and-manage-supervisor-on-ubuntu-and-debian-vps ??" Is there anyway I can run this as local host? I want to break it and see what happens with local host 
Indeed I did. And then I put my phone in my pocket and didn't proofread.
Seeing that it's a product that they charge for, trust that they'll do it ASAP in order to make bare cash.
The normal way would be to embed the Python interpreter in whatever program you're writing. For example, for IronPython, one can use Python code in C# by embeding the interpreter in your program. For ruby, I found [rubypython](http://rubypython.rubyforge.org/), which similarly embeds the Python interpreter in the other program. 
It never goes away, does it? The fear of forgetting to do a school assignment?
Once it's available, you can just create a new environment with python 3.5 and any packages you want; e.g. $ conda create -n py35 python=3.5 numpy scipy matplotlib ipython-notebook $ source activate py35 $ ipython And you should be going in Python 3.5
Thanks! What directory should I put 3.5 in on a Mac?
Interesting question. Got a specific use case in mind? Unless the intercommunication is with interprocess stuff like xmlrpc/stdio pipes/RESTful client servers, this rarely comes up for languages that are speedwise about the same and at about the same abstraction level. I imagine that's not because of specific difficulty implementing the language bridge, but because the benefit is not as compelling as it is with say the C/python combination (high level orchestration language + very fast but not as expressive lower level language). There are exceptions, but it seems likely they are experimental toys. A quick search reveals [this](http://rubypython.rubyforge.org/) and if I remember correctly Julia can inline python.
conda will automatically put it in the right place within the directory you set up when you installed Anaconda/miniconda. On my system, it's ``~/anaconda/envs/`` More info here: http://conda.pydata.org/docs/using/envs.html
That is true, except for the public service anaconda.org (which is running Anaconda Server).
Thanks for telling me! Right from the horse's mouth.
In fact, this is the @ operator's only use. There isn't anything builtin that uses it.
Encrypt the connection to reddit? That exists, you know.
Oh I did not know the [Using Python on Windows](https://docs.python.org/3.5/using/windows.html) it's full of useful information
No, i love decorators, but the new @ operator for matrix multiplication isn't actually used by any python builtins. I don't even think is used by anything in the standard library. It's just so that you gave another infix operator to overload.
Don't be. Although the Linux kernel has *fantastic* backwards compatibility, differences between the various distros--and even between versions of the same distro!--make distributing compatible binaries on Linux a challenge. Also, there's a lot less need for it under Linux, as every Linux distribution (ignoring embedded things like Android) ships with a compiler. So a src distribution is smaller, and if you compile it yourself it'll be slightly faster.
I haven't tested it at all, but this should work: scores = [] while True: score = int(input("Enter a test score between 1 and 100, or 0 to stop: ")) if score == 0: break else: scores.append(score) avg = float(sum(scores))/len(scores) print("The average test score is {0:0.02f}%".format(avg)) Since `0` is Falsy, we can rewrite it a little more nicely like so: scores = [] while True: score = int(input("Enter a test score between 1 and 100, or 0 to stop: ")) if score: scores.append(score) else: break avg = float(sum(scores))/len(scores) print("The average test score is {0:0.02f}%".format(avg)) And I personally don't really like the idea of a specific sentinel value, so I would write it like this: scores = [] while True: score = input("Enter a test score between 0 and 100, or any non-numeral to stop: ") try: scores.append(int(input)) except ValueError: break avg = float(sum(scores))/len(scores) print("The average test score is {0:0.02f}%".format(avg)) 
Fixed! Thanks for pointing it out. p.s. It may take a while before the HTML is regenerated. But it's fixed in the source for the document.
I still use Perl 5.
I've been wondering this too! I've been missing out on the 3.5 betas out of fear of leaving my anaconda cocoon
We release conda packages regularly --- there will likely be a conda update available with Python 3.5 within hours of the final release (we have been tracking the release candidates). A full Anaconda installer with Python 3.5 will have to wait until the next Anaconda release which is scheduled for October. 
Thank you for your reply, I truly do appreciate your help
Thank you for your reply, you basically answered my question perfectly. I guess the only gripe I have is this - my professor said that the number of tests can vary and shouldn't be set by user input, and basically told us to use a while loop and a sentinel value of zero to stop any test scores from being submitted further. His instructions just seem plain vague to me, so as a result I'm not sure if this code is doing is what he requested.
What the hell else would you call said methods? The symbols themselves aren't allowed in identifiers, so the next best thing is to call the methods what the symbols mean. And yes, `@` really does mean matrix multiplication. If anyone involved in the continuing design of the language really wanted an arbitrarily-meaningful operator for programmer use, then Python would have long ago had a generalized operator definition system. Such a thing has been explicitly banned by the BDFL, so thinking that `@` means anything other than matrix multiplication is merely kidding yourself.
&gt; Circular imports involving relative imports are now supported. (Contributed by Brett Cannon and Antoine Pitrou in issue 17636.) Wait what. This is a big deal, how didn't we hear about it before?
This is the async/await thread, not the matmul thread 😝
&gt; if you compile it yourself it'll be slightly faster Last time I compiled 2.6, it was 30% slower than distro's default. Compiling for every install is waste of CO2 emission. A yum or apt package is much better and more easier administrated.
Several people, I imagine.
I've never bothered with logging to a db however, my approach world be to add a custom handler to your logger. That way you retain all the logger module's built in goodness.
https://docs.python.org/3/ http://www.diveintopython3.net/ Try with these :)
And by configuring it do you mean "buy hosting and domain server, and follow this https://www.digitalocean.com/community/tutorials/how-to-install-and-manage-supervisor-on-ubuntu-and-debian-vps ??"
No worry, we all started somewhere! Are you on windows? I've no windows computer here, so I can't check my recommendations. If there are errors just post the whole error output, so that I can help you as fast as possible. If you started your terminal you are probably in ~ or in Desktop. Where is the flask app located? You have to navigate there, because otherwise your pc does not know where to find it. So let's assume you started in `C:/User/Me/Desktop` and your app is in `C:/User/Me/Desktop/flask/flask_reddit/`. You can then **c**hange **d**irectory with `cd [dir]`. So you have to execute: `cd flask`, `cd flask_reddit` or just `cd flask/flask_reddit`. You should now be in the directory where the `__init__.py` file is located. If you cloned the repository it is in `repository_dir/flask_reddit`, so if you cloned the repository into `flask_reddit` it is in `flask_reddit/flask_reddit`. Now execute `python __init__.py` and it should run. If there are errors or something doesn't work as expected don't hesitate to ask.
Pretty much all Linux distros ship Python by default.
Wrong sub. This should be in /r/learnpython 
You can absolutely distribute a python program as a binary if you just want a "regular .exe file" that other users can run. But you are not going to see a lot of it in the Python community. And the reason is a Community is about working together, and so sharing code, not binaries, is going to be the norm. It might seem like that is all there is, but that is simply not true at all. There are tons of programs out there made with Python, but most of them are proprietary. In other words, someone is selling them for money, in which case you are not going to find them here. 
I really appreciate your help :) I'm on Ubuntu 14.04 . I did sudo-s to be in a root folder, then I cd ~/Desktop/new_folder/flask_reddit, and ran python __init__.py but it gives me [Errno 2] No such file or directory. I tried to rename __init__.py but coudln't for some reason 
It is __init__.py So 2 underlines in front and 2 after "init". (you can also use tab to complete a line)
idk if this helps. that horror doesn’t leave you alone all the way through secondary school and college
oh thank I did ls, and realized I had to go one deeper. now python __init.py__ works but get bunch of errors : http://i.imgur.com/I0C7mCM.png ....maybe this project is too hard for me , I have no idea how to fix these errors
Use 3. No reason to use 2 unless you get chucked onto an existing project using it. In PHP you might be used to being able to chuck things onto a server via FTP and everything just starts working. Not like that in Python, it's a general language, not specifically designed to work straight off the bat for web development. You'll practically *always* be using a web framework, rather than "flat code". You will almost always be using python's package manager, [pip](https://pip.pypa.io) to get packages. This is the same as always using PHP's composer for development. The most popular lightweight framework is [Flask](http://flask.pocoo.org/), the most popular batteries-included one is [Django](https://www.djangoproject.com/) (although there are quite a few others). Composer's package installs are directory/project-local by default, in python you'd normally use [virtualenv](https://virtualenv.pypa.io) to enable this (usually desired) behavior. One popular webstack might be Nginx (webserver) &gt; uWSGI (application server) &gt; Django (web framework) &gt; PostgreSQL (database) But you can change this up wildly. The "web protocol" python uses is called WSGI, it's similar to how PHP uses FCGI.
oh thank I did ls, and realized I had to go one deeper. now python init.py works but get bunch of errors : http://i.imgur.com/I0C7mCM.png ....maybe this project is too hard for me , I have no idea how to fix these errors. Is it the code that's giving me errors? or I didn't set up properly? 
Once you forget it for real the fear goes away. Now if I could just stop eating a box of Oreos/doughnuts in my sleep.
Thank you I've been trying to fix the errors, so I am little but confused I re-downloaded. So first thing I do is in terminal I do sudo-s to be in root, then cd ~/flask_reddit-master/flask_reddit. Then I put my database info into config.py. And finally run __init__.py? I installed MySQL,nginx,supervisor previously that I didn't do it. And skipped virtualenv this time. Are these right??
Hello sorry for late reply, yes I would love to chat online, I'm on right now. I will give it a shot. I really really appreciate your help thank you thank you :)
Hi /u/CarpeOmniAurum , please post to /r/learnpython next time for homework-style questions. See the sticky at the top of the subreddit.
I have had the exact same dream multiple times. And, I was over 10 years out of school. Though, now that I think about it, I have not had that dream recently. So, maybe there is hope. After 10 years or so, it will stop.
&gt; the vast majority of desktop activity happens within browsers Not at my workplace it doesn't. Desktop apps are not dead, and your attitude is ridiculous.
I am adding support for this to [Pynsist](http://pynsist.readthedocs.org/en/latest/), and I've worked with Steve Dower during the betas to iron out a few details with the embedded distributions. It should allow people to make smaller, more reliable installers for Python applications.
This doesn't seem to offer real static analysis. For varying definitions of the term "static analysis," yes, it does do that, but it performs no investigation into code quality, only refactoring. And even so, I don't really see the use cases for this library.
If you're working corporate python 2.7.x If you're homebrewing/small company python 3.x I personally prefer 2.7.x but I'm probably in the small minority specifically on reddit.
Well, as I've specifically outlined there are many use cases for Python and your workplace is not representative of the overall population, so I don't see your point.
Imagine you've written a game using pygame, for instance. Your friend wants to try it out. She has a Windows computer, and she's not a programmer. To install it using virtualenv, she has to: 1. Download Python (make sure she gets the right version) 2. Install Python (make sure she ticks the option during install to add it to PATH) 3. Open a command prompt, which she's probably never used before. 4. Create a virtualenv. 5. Install the packages you specify into a virtualenv 6. Start your game from the command line, because virtualenv doesn't know about adding things to the start menu. Maybe your friend will care enough to go through that, but lots of people who might enjoy your game will look at the instructions and give up, and many more will try it, but do something wrong and get in a mess. You want them to download one thing that contains everything they need. For a more concrete example: the Dropbox client is written in Python. Do you think Dropbox would have taken off if that was how you needed to install it?
You're nitpicking too much. Refactoring does need static analysis and it's pretty clear from the description that library's support for static analysis is confined to this particular problem. I also don't understand how you can't see use cases for it. It's basically [coccinelle](http://coccinelle.lip6.fr/) for Python. I saw coccinelle doing amazing things with Linux large code base and there's no reason why the posted library couldn't be equally useful for large Python projects.
Complete Python noob here. I spent all day programming a shitty calculator. I ended up using regex to get data out of an entered input string. What you have done here is so much simpler. I don't regret learning regex, but I knew Python could be more elegant. Thank you for showing me this.
It's not easy to adapt zipapp to include the Python interpreter - it's really designed to work with an external interpreter. Zipapp also doesn't work with extension modules, which is a pretty major limitation if you're using it to distribute applications. Download size does matter, but we need to have reliable, usable distribution mechanisms. Big but working beats small but broken every time.
So what are the tools that the proprietary people use to compile Python? Are there professional grade ones? I honestly don't think there is anything wrong compiling. Obviously there is a security risk, but the vast majority of people that could benefit from your program have no idea how to install a programming language.
Thanks for the shout-out! [Here's the docs](http://flit.readthedocs.org/en/latest/).
That's exactly what I'm talking about. 99% of people don't care about "libre code". They just want something that will make their lives easier.
It's be pretty nice to be able to override `@` as a prefix operator. So you can implement `@foo`, where foo is not a function. 
Desktop apps aren't dead, but if you're focusing on desktop, isn't it a no-brainer to go native?
Eh, I thought it was obvious, sorry. It's like a very simple game of life. cells[i].x and cells[i].y are the cell's coordinates, cells[i].kind is its kind. x and y are supposed to contain the distance from the origin of the plane, which is represented by the list of lists called "xy". I know, it's messy, but I've only been pythoning for a couple of weeks. This might help a little more though
[I ran your script through PEP8, made a few tweaks to make it and made a few suggestions in comments that might help you discover your actual bug](http://pastebin.com/qPCNhAbk). Now the error it gives me is a little more clear.
Awesome. Thanks for all the effort that you guys put into the distro!
Switch language just because one compiles, and one (kinda) doesn't? That's a terrible idea.
What is wrong with "\*" for *multiplication*? It's how MATLAB works. I can't imagine going "I should multiply two arrays together... with an At symbol".
Oh, because I transposed the `]` with the `)` in the closing. Edited to fix.
What makes you prefer 2.7.x for corporate development?
Hah! I studied! EDIT: but seriously, excellent job to the Python devs!
Not saying that upgrading is very difficult but there is a big difference of being installed by default on every installation of the OS vs installed by a user in terms of ease of deployment.
https://docs.python.org/3.5/library/typing.html#module-typing
True. I meant "just works" for the end-user which is arguably the most important bit. I would love it to just work for devs, but given Python's dynamic nature there's always bound to be some way to confuse any given solution. Still it could be much better than it is.
**Regarding points 1 and 2:** People are already used to have to install Java, flash etc so i don't consider that an issue. **Regarding points 3 to 6:** Couldn't that be easily solvable with an "install" script and a "play" script? 
The * symbol is already used for elementwise multiplication.
Yes, it would be fixable with an "install" script. But coming up with that install script is a very hard problem to solve.
PHP web applications gets a clean slate at the start of every request. With python, this will be different. If you do not keep this in mind until you completely forget that model from PHP, you might end up with weird bugs. Also, understand how modules work in python. How to use relative imports and stuff like that. Also, understand the edge cases with circular imports. Understand these things before you start a big project. You don't want to figure that stuff in a hurry. Do not restrict yourself to classes. and one class/file rules. You will learn to organize things as modules. A sensible combination of classes, functions and even smaller modules. This might feel a bit odd at first, because of how it is done in PHP. But just keep at it. Apart from these things, you are in for a treat. A big breath of clean, fresh air! EDIT: This is the build steps that I usually use (Using Ubuntu LTS 14.04) I assume you are familiar with Vagrant and virtual machines. Fireup one, download the python3.5 source tar.gz. First Install pip: sudo apt-get install python-pip Install virtualenv: pip install virtualenv Install build essential: apt-get install build-essential python-dev Install python3: Download source.tar.gz and extract it, ./config and make and make install. Provide a prefix to config if necessary apt-get build-dep python3 ./config --prefix=/home/vagrant/python3 make install Now you will have python in the path you provided as prefix. Now you can create a virtualenv using the executable in that folder using the -p flag. 
Py2Exe, Py2App, Pyinstaller and Cx_freeze are all free to use. Some companies may make their own, transfer the python code to C and compile like that, or just package the code without really making a binary. (Pyinstaller does this) 
I'll give it a shot and let you know how it goes. Brian
And if you are on Linux or MacOSX, and use conda, you can: conda create -n py35 python=3.5
Oh, OK. So your point is really that C, C++, C#, Objective C, Java, Ruby, Go, Swift, Rust, Erlang, Lua, Julia, Haskell, Visual Basic .NET, PHP, and everything else that aren't JavaScript are all "things of the past" because they don't run in the browser. OK, then.
Yes it is possible, although not recommended, because it will already installed Python packages won't work.
its not backward compatible to 2.7 so nobody cares. let the downvotes begin..
Now I don't really do work with matrices, but apparently a lot of libraries use * for elementwise multiplication, and have a .dot() method for regular matrix multiplication or something. This is an attempt to give people an infix operator for matrix multiplication without breaking existing code.
I love that the community neatly fragmented based on incredibly poor initial design decisions. I still use 2.7 out of necessity, as the packages I need don't work with 3.
The initial design is not all that bad and improvements should have being backwards compatible. Sacrificing backwards compatibility for some subjective aesthetic advantage is such a douche thing to do. I have being working with python in wall street companies and they don't give damn about anything that would break their huge 2.7 code base. all the 3.* supporters are such a group of phonies.
Funny you should mention! One of the sources I drew heavily from - particularly for the Fabric portion of the environment - is [Kickstarting Flask on Ubuntu - Setup and Deployment](https://realpython.com/blog/python/kickstarting-flask-on-ubuntu-setup-and-deployment/).
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
In addition to what other people have said here, I suggest you check out /r/learnpython.
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
Is there a good tutorial covering the async stuff (yield from, async, await)? 
IPython notebook support would be great.
Yes yes yes. This guy gets it! So many people in the Python community are okay with "good enough". When you compare Python to other languages right now, being "good enough" just doesn't cut it.
No no no. I'm saying that Python seems to be a thing of the past because it isn't even good at what it is *supposed* to be good at. Most of those languages you listed up there are infinitely better and getting programs/applications into the hands of users. And yes, Javascript runs well in the browser. But guess what, it runs better than Python on the desktop too!
&gt; because it is honestly easier to learn an entirely new programming language and toolchain, and rewrite an entire application than to figure out how to build a self-contained executable in Python right now. This is what I was talking about in [my thread](https://www.reddit.com/r/Python/comments/3kpqts/why_is_the_state_of_program_distributionsharing/) the other day. I like Python a lot, but it can be so discouraging when you build something that you want to share with your friends, but just don't know how to share it.
Python's WAY better than "good enough"... For developers. For end users it's pretty shit.
People put up with installing Java and Flash, but it's not a great user experience, and they don't need to use the command line afterwards. Also, those tools are/were ubiquitous, so most potential users already had the plugin when they hit *your* site. There aren't many desktop apps in Python, Windows doesn't come with Python, and no platform reliably has Python 3 (though it's going that way on Linux). How will you people download and run your install script? If you double click a .py file, it's likely to open in a text editor instead of running. If you ask the user to open a command prompt, `cd` to their downloads directory and run `python install-foo.py`, you haven't really made things any easier for non-technical users. The install script needs to come in a form they can easily use, and that's exactly the problem - building user-friendly, reliably installation mechanisms isn't easy.
I'm partial to Cookiecutter-powered packaging tools. - https://github.com/audreyr/cookiecutter-pypackage (good for projects that have a directory of Python modules) - https://github.com/pydanny/cookiecutter-pymodule (good for projects that are just a single Python module)
I know very little of python libraries, but pygame and cocos2d come to mind, I believe kivy also allows to make games and if you are willing to use Jython, libgdx could do the trick.
Yes (on Linux and Mac)
I'm trying it, but it still has 3.4.3 as default. How can I set 3.5.0 as the default environment and remove 3.4.3?
I'm sure this has a lot to offer, but the first thing I look for in any code is documentation...at least *some* documentation. When I see code with absolutely *zero* documentation, I don't even bother going on. 
Anyone know if pylint already supports type hints, or is that something coming soon?
Python is an old language. If you don't want it to end up like cobol, you need to make some drastic changes. Yes, it's could have been done better. But given what happen with PHP 7 and Perl 6, I'd say it was not that bad. And while the price to pay was high, the result is indeed really nice.
they are saying that they are helping python developers but in affect are just causing damage by forcing developers spend scarce resources in thinking about making move to 3.*. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/titlegore] [Got " File "C:\\Python27\\lib\\site-packages\\PIL\\ImageFile.py", line 501, in \_save raise IOError("encoder error %d when writing image file" % s) IOError: encoder error -2 when writing image file" error?](https://np.reddit.com/r/titlegore/comments/3ktigy/got_file_cpython27libsitepackagespilimagefilepy/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)