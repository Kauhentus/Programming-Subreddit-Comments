Feeling a bit... promiscuous? 
What platform are you using? (This is always required information that you should never leave out.) If this is Windows, then you should have two different Python install paths, and you can pick which one you want to run based on that, e.g. `C:\python-27\Scripts\easy_install foo` will install under 2.x, and `C:\python-34\Scripts\easy_install foo` will install under 3.x. The same applies for pip, but with pip you can also invoke it directly from the python interpreter, e.g. `C:\python-27\python -m pip install foo` vs `C:\python-34\python -m pip install foo`. The `pip` command is just a tiny wrapper that does the same thing as this. By doing it this way you avoid any ambiguity as to which version you're dealing with. Edit: and never do nonsense like this: &gt; I've tried simply copy/pasting the PIL scripts from the Python3 scripts folder to the Python27 Modules should always be installed with pip, easy_install, or by running `python setup.py install`. You can't just cowboy around by manually extracting/moving files. 
Better go buy a Lotto ticket right now!
Lots of good stuff in this space on pyvideo.org - A quick search will leave you in a good place.
import pdb; pdb.set_trace() Now chase down the bug!
Oh hmm... I don't know much about windows. ...but here's a thread from SO that might help: http://stackoverflow.com/questions/4750806/how-to-install-pip-on-windows Anything I could write to try and clarify matters would only muddy the waters more.
You can get installers for Pillow for Python 2 and 3 here: http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow You'll still need pip for both distributions. Instructions here: https://pip.pypa.io/en/stable/installing.html#install-pip Just be sure you invoke *both* Python installs individually when installing pip, so you get a pip for both. You'll probably need to rename one (or both) of them so they don't clash (either to pip2 or pip3, for Python 2 and 3 respectively). They will be installed here: * Python 3: C:\Python34\Scripts * Python 2: C:\Python27\Scripts
&gt; it's Javascript that makes the little text box pop up not &gt; it's Javascript that creates the little text box
What colour are _your_ bits? ;)
Reddit is a indirect censorship hell, by downvoting. I like especially /r/Python but the downvoting thing, because we can, is ugly. 
No clue, I haven't had the time to flash one of mine and try it out myself. What I remember from the Arduino code is setting the ESP in a specific mode, don't know if that is required in MP too.
Awesome PEP.
Thanks for clarifying that. 
What is a rest API?
Docs?
Finally a real reason to switch to python 3.x :)
Python changes fast these days... or is it just getting back to what it used to be like before 3000 slowed/stopped 2.x? I hope docs, tutorials, books keep up... thats important for beginners/growth.
Where do you define laenge and maximum? It's early in the morning where I am.. My brain isn't working I need someone to point it out to me before I have a brain fart... Also you don't need line 9. Line 9 is like me saying to you "pick a number between 1 and 50" and you saying "25" and then me saying, "ok, now it's 0, pick a random number between 1 and 50", when really I would just say "Pick another number". You could argue that line 11 and 12 could be missed out and but in all that's good work though for an absolute beginner! Keep it up!
It's Python https://www.python.org/doc/ https://github.com/rfk/pypyjs/blob/master/README.dist.rst
This is a very strange attitude coming from a Pythonista. For what it's worth: &gt; The best things in life are free. The second best things are very, very expensive -- Coco Chanel
The best thing is Python, the second best is PyCharm. Just kidding. :)
Nice snark. You knew what I meant. 
Having a really decent HTML + CSS editor wouldn't be amiss either.
These are great. I also like the Sargent-Stachurski notes on quantitative macroeconomics: http://quant-econ.net/
What does static checking mean?
I am the article author here. This is apples to apples comparison in a sense as both tools are popular for programming Python by professional Python developers.
PyCharm community edition is 100% open source. Sublime Text, not so much. I tried both Emacs and Vim and in the end of the day their productivity was so low for me after few weeks that I'd rather pay the buck and stay relevant in the job market. Or: You get more open source software written by me if I don't need to do it in the traditional UNIX editors. I consider that as a win for the world.
If I understood you correctly you want to build a terminal based browser. You do not need web scrapping for that, because web scrapping is the technique to automatically extract infromation from the web. You don't want to extract information automatically, but you want to enable a user to get and understand HTTP.
Thanks! I was not aware of the minimap plugin. 
I am not the OC, but here's some instructions I found on GitHub page: https://github.com/rfk/pypyjs/blob/master/README.dist.rst
I could see that there is some convenience associated with having binary freezing capabilities directly in CPython. On the other hand, I don’t yet see why this constitutes a major flaw in CPython or other interpreters. I would fathom freezing works just as well if maintained in a different project, of which we have a few.
I have been using PyDev extensively long time ago and I also contributed to it. But that was 10 years ago. The comparison would have been unfair because I don't have enough experience of using PyDev professional on this decade. I still included the link to PyDev though.
This is a really nice idea, I made a fork and am having fun playing around with it! 
I don't want to completely replace a browser but some application running on it. for example, at work, I use hipchat to get in touch with coworkers and I don't want either the desktop application nor the web application. so I intend write something that would "simulate" the browser in my CLI program. wouldn't I "scrap" all the details of an hipchat session to output in on my terminal then?
Ryan Kelly, the creator of PyPy.js, gave a talk about it PyCon Montréal: https://www.youtube.com/watch?v=8C9q94F6Uqo . It's worth checking out, IMHO. He talks about more of the rationale in the talk.
Uh, wrong link, that one is from PyCon Australia. Here's the PyCon 2015 one: https://www.youtube.com/watch?v=PiBfOFqDIAI
For one thing, if I'm making a fun little interactive Python learning game on the web, it makes it a lot easier since I can do it all client-side rather than have some server running, have a connection, worry about security, etc. EDIT: I'm thinking of games like: http://alexnisnevich.github.io/untrusted/ https://www.bloc.io/ruby-warrior/#/
http://i.imgur.com/Cv9nB79.png
Nah, I think you should feel that way. It's common enough, but it's also a method of last resort, being that there's nothing strict and documented about pages designed for eyeballs instead of machines. Start throwing in the increasingly common js requirements and it gets hairy pretty fast. And very few exceptions aside, things that depend on scraping are ultimately a house of cards. I much prefer playing with API's that return well-considered, documented, reliable structures. Then I can really focus on what I *do* with that data.
vim http://vim.wikia.com/wiki/Use_Vim_like_an_IDE
Exactly my point. I was just surprised to see so many people saying they had fun working with BS4. I agree that if you're stuck scraping, then yes it's probably the best tool for the job, but I'd much rather be working with proper api libraries (like PRAW) than doing it myself.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Use Vim like an IDE**](https://vim.wikia.com/wiki/Use%20Vim%20like%20an%20IDE) (from Vim wikia): [](#sfw) --- &gt; &gt;__created__ 2006 · __complexity__ intermediate · __author__ Matt Zyzik · __version__ 6.0 &gt;I use Vim for all text editing, even software development. At one point I stopped using IDEs. One major reason is that Vim can do all the major things I need from IDEs (tabs, file trees, greping, syntax highlighting, indentation, completion, "quickfix"ing, etc). &gt;^Interesting: [^Using ^vim ^as ^an ^IDE ^all ^in ^one](https://vim.wikia.com/wiki/Using vim as an IDE all in one) ^| [^Use ^glimpse ^from ^within ^Vim](https://vim.wikia.com/wiki/Use glimpse from within Vim) ^| [^Quickly ^look ^up ^Vim ^help](https://vim.wikia.com/wiki/Quickly look up Vim help) ^| [^Make ^Vim ^completion ^popup ^menu ^work ^just ^like ^in ^an ^IDE](https://vim.wikia.com/wiki/Make Vim completion popup menu work just like in an IDE) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.reddit.com/message/compose?to=autowikiabot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cr06nv4) ^or[](#or) [^delete](http://www.reddit.com/message/compose?to=autowikiabot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cr06nv4)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.reddit.com/r/autowikiabot/wiki/index) ^| [^Source](https://github.com/Timidger/autowikiabot-py) ^(Please note this bot is in testing. Any help would be greatly appreciated, even if it is just a bug report! Please checkout the) [^source ^code](https://github.com/Timidger/autowikiabot-py) ^(to submit bugs)
No worries, glad you liked it :)
&gt; import pdb; pdb.set_trace() this is what i got when i ran the script &lt;module&gt;() -&gt; REGULAR = 11.50 (Pdb) 
line 120, in process mainprocess(adults,meal) NameError: name 'meal' is not defined
The people demand a Python 2.8!
so in other words, more meaningless buzzword shit.
You have to step through your script to interpret each line of syntax. Try typing 'n' and pressing Enter.
Please refrain from posting non-compliant comments. Thank you for your attention.
Yep. All it takes is a few downvotes on a new link/textpost to have your topic sent where no one will read it.
Never any love for Visual Studio.
no, it means it's very compatible with python language, unlike a lot of other python-in-JS implementations
Oh my oh my Python implemented in Python implemented in JS Mind blown I sometimes teach Python to students who don't have their own computers. Sometimes I'm teaching from library computers where we have no rights to install anything. They can login to sites like wakari.io to use Python remotely, but then they're dependent on sometimes flaky internet connection quality. I could see this being used to build a webpage-as-Python-programming-environment that could be downloaded once and saved to disk.
I don't think we know but I would imagine that the Profiler will be Pro, but the debugger improvements will be Community, based on previous updates.
Good luck! I know talking about a twitter bot helped me get my job!
Imagine you want to play with python. You have a webbrowser. You can't install python, because it's, say, an android phone. Now you can play with python.
I have been working with ab-initio codes for 5 years, and this is the first time I've heard anyone trying to get them to run on Windows. Typically, nobody writes these codes to run on Windows. They are written to be compiled and ran on Linux (since that is what clusters run). Some of them can be compiled and ran on Windows, but for many reasons, that is a very bad idea. If you have an option to run it on Linux, do it. If Windows is your only option, I think the best bet for you is to install Cygwin which will provide POSIX compliant environment on Windows. Once you have it installed, use its package manager to install everything you need to compile python modules (gcc, python, python development files...) and probably MPI, BLAS and LAPACK for LAMMPS. You can then follow the Linux compilation instructions to build LAMMPS as a shared library and then the Python wrapper. 
If you built a house you may want to call it "compliant" with building standards, so people who live in it can expect the roof to not cave in randomly. "Compliant" means it follows a specific standard and set of rules, rather than following the developer's whims and being full of gotchas. In the case of re-implementing a standard runtime environment (like implementing Python in a browser using JS), standards compliance is very important, because the better its "compliance" with expected Python behavior is, the better of an implementation it is.
http://www.housingcompliance.org
It's amazing how often this question comes up. PyCharm every time.
From the third paragraph in the PEP: &gt;This PEP assumes that the asynchronous tasks are scheduled and coordinated by an Event Loop similar to that of stdlib module asyncio.events.AbstractEventLoop . While the PEP is not tied to any specific Event Loop implementation, it is relevant only to the kind of coroutine that uses "yield" as a signal to the scheduler, indicating that the coroutine will be waiting until an event (such as IO) is completed. So this is not replacing asyncio -- in fact it requires it (or a similar scheduler/event loop). It is only attempting to streamline some otherwise cumbersome patterns that are required if you only have access to `yield from`. The rationale section in the pep is pretty clear on the benefits: https://www.python.org/dev/peps/pep-0492/#rationale-and-goals &gt; Is the plan to reimplement all of asyncio with the new paradigm? If you are using the `@coroutine` decorator and `yield from` on top of asyncio today, then yes, you should use the new keywords instead (though your current code will still work, see https://www.python.org/dev/peps/pep-0492/#asyncio ) 
On similar note: what would be a better idea?
Ah okay, then scraping the information you need would work. It can be some hassle because the webside HTTP is generally directed to web browsers (and humans). But you have a better option (regarding hipchat)! They offer [a REST API](https://www.hipchat.com/docs/apiv2) which basically already does for what you would have used web scrapping. And you are lucky - there is already a [python library](https://github.com/RidersDiscountCom/HypChat) which makes dealing with hypchat as easy as it gets. (I neither used hipchat or the hypchat library, so take my words with a grain of salt) If you have any other applications you want to write a terminal app for I suggest looking for rest apis and python libraries that already do the heavy lifting for you. 
i can't believe nobody linked to /r/learnpython
Also worth adding on to this that LAMMPS works well on Mac OS X as well
&gt; If you are using the @coroutine decorator and yield from on top of asyncio today, then yes, you should use the new keywords instead (though your current code will still work, see https://www.python.org/dev/peps/pep-0492/#asyncio[2] ) No, I mean... currently, asyncio's event loop is 100% callback based. It doesn't actually know about coroutines. All the coroutine stuff happens by `asyncio.Task` scheduling `next(coro)` callbacks in the loop. When I say are we going to rewrite asyncio, I mean are we going to see all the asyncio stuff rewritten to use the new paradigm, or will we see a new library with all the new primitives? Will `asyncio.open_connection` use await/async? Will streamreader have a new `async for line in stream` interface? All these changes are backwards incompatible, because of all the new magic methods... will we instead see a new `asyncio` successor library, based on `await` and `async`, and essentially have a repeat of the `argparse`/`optparse` situation?
As a general rule (and thanks to javascript frameworks and the like, less and less); HTML is the data. CSS is what it looks like Javascript is what it (and the user) can do. More modern and/or hipstery web apps use Less or Sass to make the CSS for the same use Javascript to describe the interactions And JSON to carry the data. .. but the browser still sees HTML, CSS and Javascript. 
Google docs is great if you want to share. Otherwise, I recommend [xlwings](http://xlwings.org/) for Excel.
The setup.py runs twice. Once when the package is generated and once when it's installed. Most of the time when i see this behavior is because the requirements are being read from a file that's not included in the package and isn't present at install time.
1. I know. I was trying to be concise. 2. As I said, I am aware that some of them can run on Windows, but doing so is not a good idea.
Actually I think for the purposes of learning Python without requiring a binary to be installed on client systems, this is a pretty good idea. For the purposes of writing client side web applications in Python, it's a terrible idea. A better idea? Learn JavaScript.
check: * pyschool.net (brython based and the code is on github). * http://reeborg.ca/docs/begin_py_en/ (brython based) * trinket (I think it is skulpt based) P.D.: Sorry for not posting the links, I am on mobile.
Yeah, I think early versions of dotabuff and datdota were actually built off this. There's a pretty good chance that someone young and who's interested in programming on reddit plays video games so I just looked through your profile.
Yeah there's a pin you need to ground to enter flashing mode and the flashing procedure should be exactly the same. I mentioned the specific command [here](https://www.reddit.com/r/esp8266/comments/34ucwj/micropython_now_has_networking_support_for_the/cqz9jqi). BTW there's a newer firmware out that's supposed to fix a few things, so you should update and recompile. 
Infinite loop, homie. 
What's the difference?
It's also faster than Python... http://benchmarksgame.alioth.debian.org/u32/compare.php?lang=v8&amp;lang2=python3
It's a subset, not superset. 
 $ time python -c 'import ssl, requests' 0m1.72s real 0m1.65s user 0m0.02s system $ time python -c 'import ssl, urllib3' 0m0.13s real 0m0.08s user 0m0.03s system 
You clearly haven't taken 5 minutes to read the PEP
I think it's that we're starting to see the end of [PEP 3003](http://legacy.python.org/dev/peps/pep-3003/), the Python Language Moratorium. This was a deliberate slowing of feature development in Python 3 until at least Python 3.3, to allow some breathing room for other python implementations (PyPy, Jython, etc) to catch up.
woww that's great, didn't wow that you could have access to API's thanks that was great help!!!
I mostly agree, except in the cases where the language being compiled down to JavaScript is itself statically typed. That to me could be worth the trade-offs. I like Python, but frankly compiling from one dynamically typed language to another is just pointless from my perspective.
I clearly have. There's nothing wrong in principle with the proposal, but I don't really understand why it was made in the first place besides "yield from" is too confusing to people who don't bother to read docs. It's not the first thing that python does syntactically different from other language (`for-else`, `with`, whitespace, `A if pred() else B`), and people dont have trouble with those things, so why is this being displaced so soon after being released?
https://www.dropbox.com/s/3yqd558hecerlo0/2015FINAL.py?dl=0
http://www.patvdleer.nl/wp-content/uploads/2015/05/build-MP-esp8266-2015-05-06.tar.gz :)
SHIIIIIIIIIIIT SON!
https://xkcd.com/927/
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 1506 times, representing 2.4090% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cr0fpxm)
Well, for the examples I was referring to, having a "loading" a the start isn't that big of a deal. The game itself would have assets to load too. But you do have a point though that performance wouldn't matter much and Brython would probably do a good enough job.
Buy a rasberry pi and some sensors and play with motion detection, making sound, taking pictures, switching on light, etc. Create a website with Python to control it. It's fun.
And Atom is IMHO even better. It's open-source, so you don't have to pay a license like Sublime Text. Maybe a little slower, but compared to an IDE is still pretty fast.
~~Nothing, i also tried:~~ import time i=0 while i&lt;10: print("Test {}".format(i)) time.sleep(1) ~~Still nothing~~ **EDIT:** Just running time.sleep(1) by itself doesn't even sleep for a second, so both the looping and sleep functions are broken. **EDIT2:** Thanks /u/mrstone56, that was a little embarrassing. Works fine. Seems like it doesn't print one print command at a time, but puts it in a buffer and draw it when the loop is done. Still, time.sleep doesn't actually sleep.
No love for spyder? For data analysis, spyder aims to be the python equivalent of RStudio ... but admittedly it has a long way to go. 
Well I can't seem to even connect to the damn thing.... git'ed the tool your mentioned from https://github.com/themadinventor/esptool but I keep getting a "Failed to connect"... How did you connect yours? I'm trying to connect via a pretty standard USB/TTL 
to be honest I'm using tornado as an async framework, and it's pretty similar to asyncio. But I'm also not perfectly happy with it. I think making coroutines a first class member of the language might make coding with them a bit more friendly.
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
I fixed that problem by running "conda install" inside the pythonocc environment!
The context for discussion here is very vague indeed. I was responding to your reply to [/u/henrebotha](http://www.reddit.com/user/henrebotha), saying that the words on your screen are NOT in HTML. You are right, it could be using AJAX to call or lazyload additional images or text, but in the end it's all displayed in HTML. You are also right about only scraping the initial HTML from a webpage, however I don't believe it's a fact that "an enormous amount of data is loaded after the HTML is sent to your browser", unless we are talking solely about 10 million dollar websites like Amazon or any Google derivatives. The majority of websites (the 99%) only use AJAX for submitting forms or loading additional comments. Most data worth scraping (in my opinion and past experience) will be there on the initial load.
This is the coolest use of Python I've ever seen: [Militarizing Your Backyard with Python: Computer Vision and the Squirrel Hordes | YouTube](https://www.youtube.com/watch?v=QPgqfnKG_T4)
Definitely Pycharm. 
Here's one I wrote to look for a phrase in a filename or directory. import os, fnmatch startTime = datetime.now() print startTime output = '////this.txt' a = open(output,'wb') matches=[] phrase = 'findThis*' try: for root, dirnames, filenames in os.walk(r'x://'): for filename in fnmatch.filter(filenames,phrase): matches.append(os.path.join(root,filename)) f = (root+'\\'+filename) print f a.write(str(f)+os.linesep) except: print 'failtality' a.close() 
tl;dr: &gt; The [range] object also implements the object.__contains__ hook, and calculates if your number is part of its range. So calling "in" without the "for" clause goes to the `.\_\_contains\_\_` method. So it's just one function call and then presumably a couple lines of logic to see if the current range logic would generate a specified integer.
I am guessing most Python developers working in tech aren't using Windows. Not saying this to argue, but should note that there's no JRE in the *nix version and I don't know what's in the mac one.
The check.io editor is awesome too ;P I should play that again some time, I got up to Level 7 in about 3 hours, but have not been back since. 
It's fast in Python 3.4, it's slow in Python 2.7 (even when you use xrange).
Emacs of course ! http://wikemacs.org/wiki/Python we can also do "difficult" things like refactoring and running appropriate tests. There are all in one solutions that can be interesting, like Elpy (discussed in the link). But with emacs we have the whole ecosystem of a programmable editor, which is awesome and allows for some great stuff, and endless customization. Dunno… check out helm-swoop https://github.com/ShingoFukuyama/helm-swoop , check out Dired the file manager, check out the shells in emacs (they're all text !), and most of all check out magit, the awesome git management !
While awesome, there are particular requirements that necessitate running this on a local machine.
Neat! These are also much faster than I would have thought: &gt;&gt;&gt; range(0, 100000000000000000000, 3) == range(0, 100000000000000000001, 3) True &gt;&gt;&gt; 2106163781110092666 in range(100000000000000000000)[::17] True However, this is apparently not optimized: &gt;&gt;&gt; min(range(10000000000000000))
No doubt, but it's a good habit to be in anyway, I think (and to demonstrate to people who are learning), even if it is not taken full advantage of in example code. &gt; (which is what 'with' is supposed to aid with given that yield could not be used in try/finally blocks prior to 2.5 - do we even still need this bit of syntactic sugar - not clear to me) I see context-managed blocks as more of a mechanism to aid in not needing to remember to repeat the same mundane cleanup tasks, such as closing a file when you're done with it. As far as that goes, I rather like having it. As an example, I recently wrote and used a context manager function that writes out a pidfile for the currently running process, and removes it when the block is exited (or bails out if the pidfile already exists and the pid written to it is still running), and found that to be a very clean looking solution. Another example, in PGPy, I have set up unlocking password protected PGP private keys as a context manager as well. That way, once the key is done being used and execution falls out of the managed block, the developer using PGPy doesn't have to remember to manually clear the decrypted private key material from memory - the task is handled for them, and the Right Thing^tm is done every time without having to think about it, and I think that is supremely valuable.
&gt; However, this is apparently not optimized: &gt; &gt; &gt;&gt;&gt; min(range(10000000000000000)) Well, `min` works by running over the entire iterable, and doing value comparisons. There isn't any magic `__min_` method which can be used to bypass this. 
Yep – that's exactly what I found out earlier today (thanks to some other kind redditors) when I was trying to calculate primality. The function worked fine, but as the number got bigger, the time to calculate got much much bigger. So when I ran 139075234, everything stopped. http://www.reddit.com/r/learnpython/comments/351j08/why_does_this_process_take_so_long/
Sublime Text has an Anaconda plugin that offers auto-complete, but I never got it working well for me. I should probably give it another shot. RStudio is meant for R development, not python. As far as I can tell, RStudio is what Spyder is wanting to be the python equivalent of. That said, the debugger in Spyder is soooooo nice. 
Wrote about this in the [FAQs](https://github.com/qw3rtman/p#faqs). :)
`p` allows you to go beyond that. You can install the latest development version with `p latest` and use it with the standard `python` command. Additionally, you can have multiple Python 2 versions, such as 2.7.6 and 2.7.7, which you can switch between with ease (see `p prev`).
I'm cheating a little and using a development board that has a 3.3 volt regulator and FTDI pins, so that makes it a lot easier. The first thing I did was test the 'native' firmware, which should give you some boot messages at 76800 baud and then probably switch to 115200 and answer AT commands. That proved out my serial connection, and then I moved on to esptool. 
I'm pretty sure Atom is not fully open-source. [Source](http://discuss.atom.io/t/why-is-atom-closed-source/82/8).
Ok that's not creepy then. Thanks for getting me a personalized answer. I love statistics and I will definitely be trying this to look at stats for really simple stupid things about my dota profile. Thank you!
Is it also html that deals with what you enter into the text box?
If it's just to calculate their checksum, then don't use read() without argument. Use res = read(number), and then your_hash.update(res), then read(number) again, and update(res) again, until the whole file is processed. You don't need to store any part of the file, and it updates your checksum incrementally. 
All true, but none of that has anything to do with what I was trying to achieve - give an example of using Beautiful Soup. You're on a soap box with "proper Python" here and it completely misses the point.
It would be nice if `min` were a generic function, so that rather than having one implementation, it could have one default implementation but you could freely override it for any type you wanted. Are you familiar with `functools.singledispatch` in 3.4? This is actually possible with what `singledispatch` gives you, without adding to the already large list of dunder-methods: from functools import singledispatch _min = __builtins__.min # The generic_min(x) == min(x) if no specialization exists for type(x) @singledispatch def generic_min(sequence): return _min(sequence) # Specialize min() to work on range types @generic_min.register(range) def _(the_range): return _min([the_range.start, the_range.stop]) # Override the builtin `min` - okay, since it does the same thing # as the original in most cases __builtins__.min = generic_min # Use the improved min() - much faster than before min(range(9999999)) 
This seems promising, I'll look into it. Thank you!
how about using flask
Out of curiosity, why would you think DRF is overkill? Sounds like you would just be re-implementing most things DRF already does. Plus, one of its biggest strengths is serialization.
[SQLAlChemy REST](https://www.google.com/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=sqlalchemy%20rest) brings up some interesting libraries.
Just using everything Django comes with might be a little overkill.
Here's [the docs](https://docs.python.org/3/library/functools.html#functools.singledispatch) for more info.
Think they switched gears and the whole thing is open source now. Your link is back from when it was debuted. 
Yeah, and a subset is decidedly not the set it was derived from. :P
I have reached a new level of cringe.
WELL DONE! It took me longer than I care to admit to grok what is really going on here. Excellent use of overriding a builtin. Excellent use of singledispatch. Thank You.
My favorite tech book is updated to Django 1.8 and was released as a PDF last week. Also a new django tutorial book came out this week: [Hello Web App](http://hellowebapp.com)
for some reason downloading a giant file just for the sake of computing its checksum feels like a giant waste of network resources are you sure you're solving the right problem?
Sure, here it is: https://gist.github.com/anonymous/b36b29442f42c1575130 It's in my github account too but I prefer not linking my reddit account with my non-anonymous accounts. NOTE: this is a script that I've run on Debian based systems, specifically Ubuntu and Mint. The download code should work anywhere, provided you've installed the Requests module. The code that sets the image as the wallpaper will only work on Linux, possibly any Debian based system but I've only run it on Ubuntu and Mint. 
I delivered. :)
I think this was already posted, not so long ago
Holy crap. wrong three by like 10 miles I'm sorry. 
Ha ha, there's a first for everything. :)
75GB is a lot of memory usage for a laptop... A standard SQL join in database land might do the trick better. You could maybe spin up a really beefy EC2 instance with 100s of gigs of RAM and do it there if you want to do it in memory.
&gt; You're on a soap box with "proper Python" here and it completely misses the point. If that's how I've come across, then I apologize - that wasn't my point at all. My point originally was just that we should be demonstrating good habits to newbies, even if they are incomplete, because they are going to take the things that we show them and run with them, maybe not even realizing that simple things like that are available or handy, or the "preferred way" to do them. I mean, I don't think I said anything that would sound like I was intending to do anything other than offer a (hopefully) helpful minor critique, and you've essentially told me twice now that it's a bunch of nonsense. I hope that this interaction is not taken as indicative of what the Python community is like in general. I'm sorry for stomping all over the intent of your example with my simple suggestion.
Chuck Norris doesn't need computers. He can crunch numbers with his head.
Are you worried about performance or just batteries? because if its just about batteries you cannot go wrong with Flask or Django. If you want pure speed then look at something like [Falcon](http://falconframework.org/) but be ready to implement a lot of stuff yourself.
Alternatively, buy a raspberry pi ([or two, or three](http://i.imgur.com/l57fPiX.jpg)), and just run python stuff on them...try to maximize your throughput on physically limited hardware.
For serialization/deserialization, I recommend giving marshmallow a try: https://marshmallow.readthedocs.org/en/latest/ (full disclosure: I am the author). You can use it with any framework or ORM, and if you've used DRF's serializers, marshmallow's API should feel familiar.
Why are you (Nimit Kalra) attributing copyright to someone else (TJ Holowaychuk)? You're supposed to change that bit in the license.
Sorry I finally got to see the thread you posted on. OP delivered! Thanks. 
Thanks for linking the docs. This was a very interesting read. Can you think of more situations to use single dispatch?
No problem, have fun! There's so much cool stuff you can do with Python. BTW, in the off chance that you're interested, I do freelancing on the side (in addition to my day job). I do a lot of automation/DevOps/web programming for my side work but I also do tutoring. I'm tutoring a guy right now in Python. Not a problem if you're not interested, just wanted to mention it. :)
Hi there, I'm one of the co-authors. :-) If you buy the early release PDF, that means you will be able to purchase the print from us directly at the same discount we are extending to buyers of the ebook/print bundle. As for making the code examples copy+pasta-able (yum... pasta), the answer is "The PDF format does not appear to like copy/paste". However, we provide all the code samples at https://github.com/twoscoops/two-scoops-of-django-1.8 Hope that helps! 
Tested and well maintained doesn't mean overkill. You don't have to use everything Django comes with. I would rather use Django and other proven frameworks than roll my own.
There is no black magic and it could be written directly by simple monkey-patching without use of functools. What makes the difference is the existence of `start` and `stop` attributes in python3 `range` object. Python2's `xrange` unfortunately returns just a plain iterator and `range` builds immediately a list. Subclassing `xrange` type to mimic python3's behavior would be fairly easy.
Why not try to get this included into python directly?
Indeed. This is very annoying, as PyOpenSSL generally provides much better security than the stdlib does. The PyCA folks consider this import time to be a bug, so it *will* be fixed, I promise.
it is a word, it has a meaning and it's being used according to the meaning. If you make the house according to some standard, you would say it's compliant with that standard.
It's because min doesn call a __min__ method, since there is no such thing. It is designed to accept any iterable and find a the minimum using a key function (which default to lambda x:x). So min() has to iterate other the whole iterable to perform it's task. On a range object, you can have the minimum by doing your_range.start.
I'm not sure I would call it better, but it's definitely more compliant (things work as expected, including pdb, the import system etc. etc.)
it's not rpython, it's a full pypy (which is written in RPython, but implements full python)
well, check it out yourself. http://imgur.com/a/LCB1K
Buy more ram or repartition your data so the merge isn't so large.
...or instead of taking all the time to download, install and configure a million plugins, you could just install a great IDE like PyCharm that just works straight out of the box.
Probably best to install Anaconda, a version of python with scientific libraries bundled with the installer (including numpy, scipy and ipython). Installation for mac is detailed at: http://docs.continuum.io/anaconda/install.html#mac-install it also includes an IDE for developing scientific python code.
Snapchat does not have a public API. So if they change something in the API these python libraries may stop working.
You're welcome, btw see my comment about tutoring too: http://www.reddit.com/r/Python/comments/34xlou/what_are_some_fun_apis_and_libraries_to_screw/cr15kzv No problem if you're not interested. :)
We're constantly adding new missions, you might even see some changes in editor (not to mention that we have plugin that makes it possible to use your favorite IDE with CHeckiO) 
You need some backslashes around your underscores, so Markdown doesn't try to parse them as emphasis: &gt;&gt; The [range] object also implements the object.\_\_contains\_\_ hook, and calculates if your number is part of its range. gives: &gt;&gt; The [range] object also implements the object.\_\_contains\_\_ hook, and calculates if your number is part of its range.
I'm working on converting reactive-extensions.github.io/learnrx/ code examples to Python to see how well it works. Main drawback learning it was lack of documentation.
Your answer is wrong. The correct answer is that Beautiful Soup broke the rule that variables should not be reserved words. If a module foo redefines "+" and you get 1+2 = 17, it is not a beginner's confusion about python's addition.
https://www.python.org/dev/peps/pep-0443/#rationale-and-goals
urgghhh fuck python. I followed the install and everything seemed fine until i have to enter "bash Anaconda3-2.2.0-MacOSX-x86_64.sh" and this results in "no such file or directory" 
And it is powerful enough for Google because...?
wait i think i got it. Thanks!!!
Go
Thanks for doing this!
honestly I was disappointed with this article. its very shallow and really comes across as a buzzfeed style list article designed as click bait. there's not a whole lot of substance here.
Awesome!
[Numba](http://numba.pydata.org/) sounds interesting. Is someone here using it? How is it in practice?
nvm, got it! I can't even read_mac without grounding the GPIO0
Maybe looking on somone code would be good for you: https://github.com/aidraj/twitch-bot
Sounds cool, thanks for sharing. I would reach for numpy/scipy first though. Realistically it's more likely to be the algorithms or implementation issues like memory allocation that slow you down, not interpreted code per se, so a well written library should be the first resort.
when do you anticipate the book version being released? 
It's good enough, it's smart enough, and doggone it, people like it!
Everyone knows list articles are the best articles.
I'm not doing any scientific computing. I'd just like to speed-up my apps in general.
No problem, for further topics you should use https://www.reddit.com/r/learnpython :)
As far as I'm aware there doesn't appear to be any means to do a sha1 or md5 from the remote end (these files are being pushed to a CDN).
I'm afraid I can't help you - I'm inexperienced in more advanced Python.
Yeah, but that is because they wrote their own language they are shifting too probably.
I've been toying with the idea of learning Go for a couple years now. Every few months, I take a peek at /r/golang but I'm turned off within a few minutes. The language seems fun but the community is pretty unfriendly. If I had any pressure to learn the language, it wouldn't matter, but I'm just interested in it as a hobby.
I've used Jython at work where a task required that I have access to libraries that aren't available with native Python (a couple of JDBC drivers, specifically). I would have written it in Java, but using the Python language saved me a huge amount of time. To me, the Python language combined with the Java ecosystem is a killer combination for certain tasks.
I literally posted this couple days ago. Doesn't reddit tell you when you post an already posted link?
Have you ever been able to connect to the board? I think your issue is that you're using the 3.3 V from the USB-serial adapter, and it can't provide enough current for the ESP. I had that issue too, so I ended up getting my Vcc from 5V using a regulator. 
It is good fun, and a good compliment to Python. Don't be put off by a few bad apples.
Cool. You may still have power issues when you use WiFi though, 'cus it uses a lot of current. main.py is for if you want code to run at boot up, but you can just use the REPL if you connect using a terminal program.
Because Google uses Python duh.
Not sure what you mean, but main.py is entirely optional. 
okay, let me put it differently. I've just flashed the image I uploaded yesterday, now what? How do I get my own code (or yours for example) onto the ESP up and running
They say this month! http://twoscoopspress.com/pages/two-scoops-of-django-1-8-faq#what-formats I'm in Bangalore, shipping will be expensive or can wait longer for it to come out on Flipkart. 
You are not a good person. why dont you go write your own book and give it away?
Numba probably isn't what you're looking for then -- at least, not yet. Have you looked at pypy? Numba is designed to speed up iterative calculations involving arrays of numbers. It can't really speed up generic python code, and it doesn't handle more complicated objects like `dict`s (yet -- last I checked, they are working on it). So unless you're doing some heavy number crunching, Numba probably isn't applicable.
Use putty or another serial terminal to connect to the ESP at 115200 baud. Then you'll have a Python shell you can type stuff into. 
Must be nice to travel a lot. Where do you go? How do you do it?
That's a horrible article. It lies. Most people aren't using anything other than plain old CPython so performance is going to be ass slow unless you're using s library that has native C calls on the backend like numpy. Sometimes ass slow is just fine. Sometimes it's not. That's why it's a tool. Further it's ignorant of the fact that Google uses more C++ and increasingly Go code for their performance intensive needs. Python is a wonderful tool; but, it's not meant to be the only language in the tool kit. 
Pfffft, give me 5 reasons why...
i see what you mean, and it makes sense. this is probably a perfectly valid use of the word. I just see it in buzzword soup capacity too often now, though :/
I know about PyPy. I think I'll start with it. Thanks.
Didn't know that, thanks! It makes sense why Guido left now. I know dropbox uses a lot of python in their dev work. Why did Python diminish in importance at Google?
I went ahead and posted a question to the mailing list. I'll update here when they get back to me.
http://www.patvdleer.nl/esp8266-and-micropython/ check it out and let me know what you think :)
I looked at it for a bit but then I got turned off by the insane package management idiocy and the lack of generics (and the hacks they built around to compensate for that). I have my complaints about pypi and pip but it could be *so* much worse.
Well, is Spotify running?
In IPython, we have custom code to do something similar for pretty-printing objects. It's in [IPython.lib.pretty](https://github.com/ipython/ipython/blob/master/IPython/lib/pretty.py).
I'm speculating that it's for a few reasons: 1. They tried to make Python faster with [unladen-swallow](https://code.google.com/p/unladen-swallow/wiki/ProjectPlan) but couldn't. Dropbox is now trying to do the same thing with [Pyston](https://blogs.dropbox.com/tech/2014/04/introducing-pyston-an-upcoming-jit-based-python-implementation/). Google approved alternatives: C++, Java, Go 1. Python language development is really slow, probably because a lot of companies use it so GvR prefers stability over new features. - asyncio in 2014 (IMO still kinda shitty implementation, but I'll leave details for later) - optional typing in 2015 as an experimental feature Google approved alternatives (languages they control): Go, Dart, internal DSL 1. Static, or optional typing has proven to be _really_ useful the past few years for robustness--especially for larger codebases. JavaScript has a bunch of alternatives (TypeScript, Closure, Dart), Clojure has core.typed. Python has...something experimental that's a year away[0]. Google's primary use languages are all static. On a personal note, I've been using Python for: work (MMLOC Python codebase, many smaller 10 - 50 KLOC services), contract work, open source, personal projects for ~7 years now. It's my bread and butter, but I'm done struggling with the same systematic / language design issues. To *me*, I want a language with these features: - 1st class functional language support - static or at least optional typing - easy concurrency - no GIL - performant'ish [0] Not entirely fair comparing a language's std lib to 3rd party libraries, but MyPy requires Python 3 (which is another sticking point).
NumPy, a mathematical library for Python, is one of the most popular data-analysis tools out there. Pandas is a Python library for manipulating tabular data, but atop NumPy. The combination of the two, and the ease of learning Python, especially for non-programmers, make it ideal for working with financial data.
I think it's less that it's unfriendly and more that it's inaccessible. The "Tour of Go" is useful at learning some of the basics, but it does less for you than reading the packages at golang.org/src, which you'll have to do because the documentation is nowhere near the quality of the java or python standard libraries. There's no support for a community, either. There's no official organizational tools like a wiki or forum, the best you get is the golang-nuts mailing list. It's a great language, but I don't think that it's being set up for success.
Personally, I liked it. I particularly liked the link to the generators article. Here it again in case you missed it. http://www.dabeaz.com/generators-uk/GeneratorsUK.pdf
It would be better if said generic company used it though. Google does. 
agreed, very simply put!
Ah, yes. Fixed. I'm aware of this in general, but I wrote and viewed the post on mobile via redditisfun, which didn't interpret underscores as emphasis inside back ticks
Do people try googling anymore? This is the first result that turned up for "any colony simulation python": https://www.youtube.com/watch?v=tPD9duy7PzM
Sounds like an awesome project! You should write one :)
I agree with all the points above. The other component that pandas supports that is probably useful in a finance capacity, is it's ability to support time series data - http://pandas.pydata.org/pandas-docs/stable/timeseries.html
Because Python is the new Excel? But like much better. I think any company hiring a position in finance with a requirement for Python is probably a good bet that they're on the ball.
&gt; I think it's less that it's unfriendly and more that it's inaccessible. Interesting, I found Go to be one of the most accessible languages I have touched in the last 20 years, maybe **the** most accessible. A [50 page spec](https://golang.org/ref/spec) and only a handful of keywords. Rarely have I been able to feel I completely understand a language in the first week. &gt; There's no support for a community, either. There's no official organizational tools like a wiki or forum, the best you get is the golang-nuts mailing list. Many (most?) languages don't have top-down community control. I don't want an official wiki and I don't see how the [golang-nuts group](https://groups.google.com/forum/#!forum/golang-nuts) differs from a forum. There is an active IRC community, an active slack community, an active group of people doing [golang challenges](http://golang-challenge.com/) where you turn in code and get it reviewed and win prizes. &gt; It's a great language, but I don't think that it's being set up for success. It is already successful. It hasn't really replaced too much C++ outside of Google, but I see it replacing Ruby and Python in tons of shops -- and startups are flocking to it. The only language Go is behind in startup land is Javascript at the moment. 
This shows no such thing.
Sure, what would you like you see? _Roger posted some code below
Aha I am currently writing one now. I was hoping to find someone who had some experience and I could bother with questions about how they did it
I found you on Stack Overflow and posted an answer there. http://stackoverflow.com/a/30108358/403554
Can't go wrong with import this :D
It may have (probably was since you were so specific) been serialization. I remember that I was trying to putting something into a database, or serve some JSON and it seemed like the only way (to me) to do it required dropping in like 30 lines of code. Sorry I can't be more specific than that, I used it for about an hour, noped out of there, then was able to do what I was trying to do in Falcon in a couple lines easily as I had expected. 
The authors do a lot of work for the open source community (including funding the multiple template kickstarter among other things).
Sorry, should have mentioned it, that's the free version.
you may be interested in http://reactivex.io/ and https://github.com/ReactiveX/RxPY
Nim?
Play with Marshmallow some. It's a framework and ORM independent object serialization library. It'll also handle parsing dictionaries back to objects and validation. 
No problem at all. The paid version is just GPU opt I think so unless youve got a workhorse compute GPU and a shitload of data it doesnt really matter anyways
Yes, and a big advantage is that you can now use relative file paths in your README files to open up notebooks from your local repository or view the rendered version from GitHub website. Btw. the rendering is also pretty fast -- I appreciate the free nbviewer service, but it was always a little bit flaky.
Seems like it doesn't work for gists which would be handy. Still, a very cool feature.
This is great...
I wonder if mobile is coming soon. 
It'd be fun to see your real world case for a `namedtuple` with inheritance, behavior, etc. I ask because I usually find myself preferring boring, unadorned data (in the form of dicts, tuples, lists, whatever) in Python. So, in your example (which I'm sure is a lot simpler than your real use case) I'd probably just do something like: point = namedtuple("point", "x y x_len y_len") def make_point(x, y): length = (x*x + y*y) ** 0.5 return point(x, y, x / length, y / length) So in your actual code, I'm guessing you've got a whole bunch of fields and a whole bunch of associated behaviors? It's always an interesting puzzle to find the cleanest way to handle such situations in Python.
It's easy to modularize and organize your code, reminiscent of how it works in Python or Java. However, the first party **go get** command does not have any versioning functionality, which is a... byzantine design decision, to say the least. Godep, a 3rd party util, provides versioned dependency management.
Nifty. May want to check if namedtuple exists in the inheritance chain already though. The biggest problem I see is if someone has setup in new (uncommon but still) as namedtuple only calls tuple's new, not `super().__new__`. You should also migrate the doc string from the wrapped class to this one. Other than that, looks interesting. I have to admit, I've been considering how to dynamically insert parents during instantiation (scalas with keyword basically). Purely for my own amusement more than anything serious.
Well, he didn't import XML directly into Python, so maybe not.
God I love this library for all the wrong reasons. It's import hook was apparently part of the inspiration for hy as well.
This will be great for lecturers.
You could do it as a function, but considering that it is a decorator with arguments, it would be a function like this: def caseclass(*names): def wrapper(cls): ... return wrapper One uses higher order functions, the other uses classes. The class formulation might be more approachable for some people, and anybody familiar with HOFs can do the translation easily.
[Freenode / #go-nuts](http://irc.lc/freenode/go-nuts) -- 1200+ people in it at the moment. [Golang Slack](http://blog.gopheracademy.com/gophers-slack-community/) -- Needs an invite... form for invite on that page. 
&gt; tear-jerkingly boring Exceptionally unexceptional! My favorite quote about it is “Go is not meant to innovate programming theory. It’s meant to innovate programming practice.” – Samuel Tesla 
That's pretty slick. I haven't decided if I think its an abuse of the language ([I've been known to commit language atrocities once in a while](http://www.reddit.com/r/Python/comments/23532l/evil_python_coding_a_scanner_utility_entirely_in/)), but I'll make a note to read the implementation this weekend. Even if linguistic butchery is ugly under the hood, their inner workings can still be enlightening.
Check if the CDN returns the `Etag` header. If you're lucky the CDN generates `Etag` using the same checksum algorithm you are, or at least uses something standard like md5 or sha1. You could always ask them. If so, you could achieve this by a `HEAD` request - profit!
antigravity is pretty fun
I don't have cash either and I don't like answering to someone when it comes to stuff that I am self motivated to do. I love learning this stuff and I will run rampant with it. I feel like getting a tutor would confuse both of us and eventually slow me down. Thanks for the offer though! 
That was my first exposure to Spyder as well, was just trying to move away from Matlab...and Spyder was the closest thing to the Matlab editor I saw.
This just made my repo of IPython notebooks a lot more impressive!
&gt; I don't like answering to someone Ha ha, well I wouldn't put it like that. It's not like I'm bossing anyone around. :) No worries though, enjoy the Python!
&gt; why is it returning everything in a unicode string It's using the XML output mode of nmap. The XML file is encoded in UTF-8, so that any string can be represented. The result of parsing that XML file is unicode strings, as it should be. &gt; how can i correct this? There is nothing to correct, it's working as it should. &gt; it now expects 'tcp' to be unicode instead of a string No it does not. &gt;&gt;&gt; foo = {u'tcp': 42} &gt;&gt;&gt; foo['tcp'] 42 
Wow this is awesome. Maybe the final straw to get me to switch from mostly using hg and BitBucket.
yeah I actually did something similar to this to solve the issue - I had thousands of records in each table with the same value in each dataframe -many do to the way I was accidentally converting nan to string - and some due to the data - billions of extraneous matches. By grouping by and counting duplicates in one dataframe I was able to eliminate this issue. Still ended up using ~60GB of virtual memory to do the merge - I'm curious how to increase the virtual memory limitations in the future, but at least it works for now.
I'd be interested in testing this as well, but in practice - with the same resources, a well optimized sql database is almost certainly going to be faster on merges. that being said, if you aren't joining or filtering on indexes, a sql merge can easily be exponentially slower. The other challenge of a sql database is other concurrent sessions - if other users are using the database at the same time, you are effectively sharing resources. additionally, by default inserts to the database usually create table locks which can effectively halt your query until the table is accessible. Also db configuration can define session or transaction memory/process resource restricts that can be much less than your personal machine.
/r/learnpython
You forgot a couple of `self` when computing `length`. ~~Oh, and please derive classes from `object`.~~ Just sayin'. ;) ^(edit: py3k always derives from `object`)
Do you use it in your daily programming?
Can you please clarify "it can't find the PIL library" and/or verify you are importing PIL via ``from PIL import Image`` and not ``import Image``? - http://pillow.readthedocs.org/installation.html#warnings If you happened to be using PIL in 2.x and Pillow in 3.x along with ``import Image`` instead of ``from PIL import Image`` you could potentially experience an issue like this.
Python3 has excellent support for scientific computing. Numpy/Pandas/Scipy are all well supported. I would recommend Python2 only if it was impossible to install python3 on your machine (e.g. if this is an old work machine, and your IT staff refuses to let you upgrade it) EDIT: Also, please check out Anaconda (https://store.continuum.io/cshop/anaconda/), and virtualenvironments (http://docs.python-guide.org/en/latest/dev/virtualenvs/)
 It is my own laptop and there is no problem with virtualenvs. The python 2.7 is Linux's default one. Python 3 also seem to be installed, but we have to explicitly call it. My main concern is with SAGE. Mainly, for number theory, elliptic curves, algebraic geometry etc., than large scale simulation and numerical estimations. Thus the interest in PARi/GP also. As SAGE builds on Numpy/Pandas/Scipy, can we assume that Python 3 is ok? At the [Sage docs](http://www.sagemath.org/doc/faq/faq-usage.html) it is mentioned that Python 3 is not supported, but this is old, from 2010. 
I think this would better fit on /r/learnpython, but thanks for sharing! 
Neither is better, Python 3 is the way forward and should be your first choice. I say first choice because there may be requirements place upon you to do something in Python 2.X. 
Windows 7 or Windows XP? Same reasons. Stick with python3 if you have no good reason why you need 2.7. Then you will avoid lots of pain in the future.
Both. If you're headed for a career as a Python programmer you are going to end up dealing with both in the wild. For new projects, as long as the libraries you need have been converted, use 3.4, but there is still a lot of legacy code out there.
try export $ PATH=$PATH:/path/to/twisted
Ahh, forgot that Py3k always derives from `object`. I'd have been very surprised if Py3k allowed member access without `self`, though.
[Learn Python The Hard Way](Http://learnpythonthehardway.org) (which is really the easy way) swears by Python 2. Why? Because 3 still isn't well adopted and most of the programs out there are written in 2. It came down to eventually you're going to need to learn both anyway. Learn 2, because that's what the programs are written in, and you're going to have a much easier time being able to go into programs and figure out how they tick. If you find a time where you're going to need to do something in python 3, then go learn it. No meaningless catchphrases like "it's the way forward." Learn what the vast majority of python programs are written in and don't gimp yourself.
Curious, what specifically are you going to do with Python? Since you are a mathematician, have you thought about doing data science or data analysis work? Consulting doing computational work?
Data Analysis is an option. I have to look into it. My main domain is problem solving in abstract situations. So, yeah, consulting work if I can somehow market it. I had once considered possible routing algorithms for a particular type wireless device company. Afterwards it occurred to me that Python and a certain library would have been particularly suitable for simulating it. I may blog about it sometime and will let you know then if you want the details. My own mathematical interests are closest to number theory and algebraic geometry and it seems the closest to it in applications is cryptographic algorithms. But, really, python is suitable for most mathematical computations, for example for almost all applications listed on [Jeremy Kun's blog, math int. programming](http://jeremykun.com). 
It doesn't, that's just some of the Scala seeping in. I stay consistent working in one language or the other, but foreign-isms seep in trying to write both.
If you're using PyPy, you probably also want to consider making `config` and `bid_request` objects.
Adding to what /u/spinwizard69 said: if you so find something that requires python2, please be a good sport and move it to python3. fantastic way to keep learning.
I was just wondering when this would happen. Very glad for it.
!PATH = $PATH:C/Users/Alexander/AppData/Local/Enthought/Canopy/User/lib/site-packages/twisted Tried this with no such luck.
I would be more inclined to believe the 5 year value about 4 years ago. Even today there's a headline in this subreddit that Ubuntu is changing to Python 3 as the default installation. The entire scientific stack has been ported and can easily downloaded in one go in the Anaconda distribution linked above. There are a handful of libraries that aren't ported yet, but for most users such as myself (engineering/lab work), Python 3 has been the way to go for a while.
Great news. Python 3's new features are fantastic, and it needs to go mainstream. What packages are people still using that haven't yet been implemented in Python 3? I know that list is getting shorter, and it would be cool to see the open source community rally to finish them off.
Glad to hear it as more distro's making moves like this will probably be thing to finally start forcing people off of 2.x over the next few years. Well not forcing but twisting their hand to adapt a little.
wxPython I think, though I gave up waiting. Does this mean `python` will refer to python3? I thought it would always point to python2.
can you please delete this thread?
What does this change exactly for a Python dev using Ubunutu? Why not include both version families (2.x and 3.x) for greater comfort? Since the reality forces devs more than often to be able to use both, why not take away the hassle of including the missing one into the system? Because that is IMHO the only hassle with python under any OS. After that, it's only a matter of setting up the needed virtualenvs, activating the currently needed one and we're ready to go. TL;DR: An OS should be agnostic in such matters and make it easier to use the version you need, rather than imposing such choice on the user.
Scrapy.
The person you are responding to was giving you a Linux shell command to modify your path during a shell session. Based on your answer, you're on Windows. You need to follow windows-specific instructions for including the twistd directory in your windows system path. Try this info: http://www.computerhope.com/issues/ch000549.htm 
Now it'd be great if they'd stop breaking pip and virtualenvs: https://bugs.launchpad.net/ubuntu/+source/python3.4/+bug/1290847
noob question: Will this impact my Apache PHP code?
Numpy :( Edit: wow I guess its been a while since I tried it, glad numpy works with python3
Good answer. tl;dr * Python 2 only scripts should either be updated to be source compatible with Python 3 or else to use `python2` in the shebang line. * all new code that needs to invoke the Python interpreter should not specify `python` , but rather should specify either `python2` or `python3`
Numpy does support python3 (as does scipy). http://www.scipy.org/scipylib/faq.html#do-numpy-and-scipy-support-python-3-x
If you want to make money, then go with 2.7. I work almost exclusively with python and all new projects are in 2.7 with no plans to move on to 3.x But, in my opinion, the two are nearly identical so learning 2.7 should in no way impair your ability to learn 3.x
Protip don't use it in a `except` sentence especially if it has `random` inside the generator.
Using the crunchbang (#!) at the top of your files you can specify to use python3 by pointing to the directory to which you have python3 installed.
To my understanding, the only changes will be: * `python` will launch python 3 instead of python2, just like it does in Arch * python2 will not be part of the install iso, but will still be in the archive, and apt-get intall python2 away.
Python3 is the current version to use. Python2.7 is still supported for use by legacy projects, but new projects should use python3. 
In my own projects I had mixed experiences, in some cases it is trivial to support Python 2 and 3, but it can also be quite unpleasant. In a recent [podcast with Kenneth Reitz](http://www.talkpythontome.com/episodes/show/6/requests-pycon-and-python-s-future), author of requests, he said something along the line, that porting requests to Python 3 was the most painful task since he started this project. And there are a lot larger projects in terms of amount of code that deal with binary data, networking, different encodings etc.
&gt; python will launch python 3 instead of python2, just like it does in Arch At least for me that won't change anything as I always use a python&lt;X.X&gt; command, e.g. python3.3 or python2.7...just to keep awareness what I'm using atm &gt; python2 will not be part of the install iso, but will still be in the archive, and apt-get intall python2 away Fair enough, if they keep maintaining it in their repos then it's fine. I thought they are going to remove it from there too...
Bottle and flask both work in py3 now, twisted works in py3, requests works, beautifulsoup works, SQLAlchemy works, pyqt works, PIL works thanks to pillow taking up where they left off, basically everything you need. All/most of these work without 2to3 hacks either, they are coded as native works-in-both code. edit: Apparently only a subset of twisted, list of modules here http://twistedmatrix.com/trac/browser/tags/releases/twisted-15.1.0/twisted/python/dist3.py#L33
If you're interested in learning how to do this, /r/learnpython would be a good place to start. If you're interested in hiring someone to do this, then /r/forhire is a good place to try.
 Guess its time to port over my projects then.
Not public, sorry. 
Originally, this wasn't so. This is one of the pages that has a python runtime allocated to the reader, so if I had to guess they did it to limit access to the running kernels during their beta launch.
I don't understand why people see them as being exclusive. If you know Python 3, you will know python 2 with an additional 10 minutes of getting up to speed. I've got both py2 and py3 running in conda environments and use both. Whenever I write Python 2 code, I do my best to make it run in python 3 as well. Its not like your choice commits you to a single version for the rest of eternity. Hell, if you are learning python the only difference you are likely to come across is print_function.
It doesn't look like it. Why do you say this? Is there a secret port? 
Good to know. I know the transition to Python3 has been long and arduous - I only migrated my company to it over the last few months. But I do feel it's worth it. The separation of strings and bytestreams alone has made my life vastly easier - everytime I do anything unicode related and the encoding works correctly or throws an intelligent exception, I'm glad I made the switch.
twisted mostly works on Python 3, AIUI, even though it isn't supported.
Thanks! I was not aware of /r/learnpython. Will post there.
I think ``python`` will still be point to Python 2, since this is what PEP0394 recommends. The idea is to not have any script in default installation of Ubuntu to depend on Python 2, so they can remove it from install media and save some space.
I always marvel how outsiders seem to know so much more about what happens at Google that actual Googlers.
`#!/usr/bin/python2` Anyone who doesn't specify 2 or 3 with this is doing it wrong.
My body is ready 
Well, you need to remember that Arch did the switch a long time ago ([5 years](https://www.archlinux.org/news/python-is-now-python-3/)). At that time there was no recommendation of which version of Python ``/usr/bin/python`` should match, and the fact that ``/usr/bin/python3`` was actually Python 3 was more something that every distro was doing instead of a recommendation from Python developers. PEP0394, that recommends everything I said above, was only released 6 months later (https://www.python.org/dev/peps/pep-0394/). So this more a fault of Arch Linux than anything, but I can understand why Arch developers did this.
protip astro code school lemme watch your video at 2x speed or write a tutorial... grrrrrrr. 
i think getting a properly working opencv in python3 was a problem for me awhile ago
 #!/usr/bin/env python2
Only in 3.3+ though. It's a syntax error before that.
And I still find bugs....
Python wall of superpowers: https://python3wos.appspot.com/ List of all packages in green that have been ported to python 3, and in red for the ones that haven't.
What's the difference there? (honest question) 
According to the [WOS](https://python3wos.appspot.com/), the biggest package not in compliance is pika, and then supervisor and then carbon and mysql-python then Fabric...all packages I use for most of my larger projects. *sigh*
Doesn't help if you're trying to *delete* `.pyc` files.
print('God damn it') Welcome to the future. 
from __future__ import print_function
Gotta love the php "programmers".
It's soon to be ported. http://www.fabfile.org/roadmap.html#invoke-fabric-2-x-and-patchwork
Anaconda works great for portable installs too...
Works fine now.
Agreed here. Python 2.X End Of Life has been extended to 2020. And it looks as if the major OS' including Ubuntu and Debian will be porting over to Python 3 shortly as well. If the Python 2.X modules were fully converted to Python 3.X, Python 3.X would become the new standard.
We do talk about our processes publicly quite a lot, and /u/ProfessorPhi's comment was understandable. I don't think we use Python for a lot of new stuff...it's just not draconian.
Elborghesan, I have found a great website for some advice with editing PDFs in Python: https://www.binpress.com/tutorial/manipulating-pdfs-with-python/167 If you want to use PDFMiner, one way to handle this problem is to dump the PDFs into files, and then extract the emails from the dumped PDFs. Sorry for not being able to assist any further, as I came across this library yesterday.
It's like how when they made `sh` not point to `bash` anymore, everyone's scripts with bashisms stopped working. If you need a specific thing, use it specifically.
Ah that's why then. Thanks!
Unless I'm mistaked, Fabric is more of a tool than a library, right? Does anyone use it as a library? (not trying to be facetious here.)
SyntaxError: Why the hell did we make print a statement in the first place
Python 3 code is mostly compatible with Python 2.7 whereas the reverse is a lot less so. I'm mostly using Python 3 and I've used SAGE for over 2 years and never knew it was still using 2.7 until very recently. 2.7 lets you get away with bad code and inconsistent shortcuts/hacks that have been fixed in Python 3. Then there is the whole forward momentum with Python 3 having all the cool new stuff and development. I see no reason to learn 2.7 as a newbie, although knowing the main differences after learning 3 certainly helps. Python 3 encourages you to do things the right way, and learning the right way from get go is a lot more beneficial and less frustrating than trying to forget bad practices in the future.
You know what's funny? In Python 2, there is a [print](https://docs.python.org/2/library/functions.html#print) function. But the grammar overrides it to make it a statement; the `from __future__ import print_function` just disables the statement.
I wonder when OS X will start at least including python3 out of the box.
Nope. The whole point is to make the "default python," that is, `python`, be `python3`.
About time.
Or just get in the habit of using `print()` as a function now. You don't need to import anything. Python 2.7.5 (default, May 15 2013, 22:43:36) [MSC v.1500 32 bit (Intel)] on win32 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; print('Verily, this is a print function.') Verily, this is a print function.
Finally.
Honestly, what does Python 3 really offer over 2? I feel like 2 was just so wonderful and complete that you'd need to offer a very compelling feature to get people to change. Instead the changes seem trivial and nitpicky more than anything. Yes, the improved language consistency will be great for newcomers, but I got used to the idiosyncrasies a long time ago.
Hi, thank you for trying it out. You will have to add to your python path ($PYTHONPATH) the ica folder you got from github, The ica module is the one I wrote there.
It only took since 2008!
[Explicit is better than implicit]( https://www.python.org/dev/peps/pep-0020/)
I ran into that, but it's fixed now. In any case there's 2 different ways to get venv and only one was broken.
It should get ported this summer as part of GSoC
Good news, they will actually switch for 19.10.
Everything works if you only use official packages or AUR packages. The problem is that many projects that don't have a package assume that python is python2 if you just clone them raw from their repos. For python2-only code, the Arch package maintainers often have to do some not-so-beautiful `sed`-fu to make python point to the right version.
Dear /u/jstrong, Python 2 will not be installed on any future servers, please fix your shit. Love, BOFH
It actually matters a ton with python. `#!/usr/bin/python2` will do the wrong thing in a virtualenv. `#!/usr/bin/env python2` will find the first python on the path, meaning the right one for your currently active virtualenv. System packages should probably stick with `#!/usr/bin/python3`, so that they always use the system version of python 3, regardless of whether you have an active virtualenv. Unless you are packaging for a particular OS, though, `#!/usr/bin/env python[23]` is the way to go.
Could have been fixed a time ago if they had made python able to use a different runtime for each file in a project and made you put import python3 At the top of any source file that was python 3. It would allow projects to be moved over one unit at a time, it would allow new unites to be added in python 3 with zero code rewrite and it would mean we didn't have this insane waste over more than a decade. But hey somehow everybody always thinks they are the exception to the rule: you shit has to be backwards-compatible. No. Exceptions.
No oauth2? Well no python3 for pretty much anything web, then.
https://1000diamonds.files.wordpress.com/2010/06/braveheart.jpg
 sudo apt-get remove --purge python2.7 python-pip http://i.dailymail.co.uk/i/pix/2012/02/10/article-2099577-0249C527000004B0-421_468x301.jpg
Isn't PyMySQL a drop in replacement? It dropped in quite easily when I ported my (admittedly small) Django site to Python 3...
Huh. TIL. I guess this means that Ubuntu installations with the default python deployment simply won't have a `python`.
I'm fine with the move, it has to happen. But why choose an LTS to do it on?
There are talks within Debian about making the switch for stretch, as the ETA for buster is 2021 which is after python2's EOL
In Python 3, `csv` handles unicode just fine. For Python 2, there's [`unicodecsv`](https://github.com/jdunck/python-unicodecsv), a drop-in replacement that handles unicode. What, exactly, do you plan on doing with these CSVs? If it involves operations that lend themselves well to SQL, you might want to consider loading them into an RDBMS and doing whatever you want to do there.
Thanks for letting me know about the unicodecsv. I can't believe that hasn't come up in any of my desperate searches. The tasks vary widely from simple transformations to large scale web scraping and XML processing. Unfortunately, I'm quite tech-limited and unsupported over here, so having SQL up isn't an easy option (portability, admin rights, software limits, etc.).
See, this is something I'd classify under "trivial and nitpicky". Perhaps "niche" would have been a better word to describe the concept. If you're dealing with CSV files along with unicode, sure, you've got a compelling reason to upgrade. But, isn't that a little esoteric to suggest as a reason as to why everyone should upgrade?
Shit. I really need to get hip and move to Python 3. 
I think he wants: from past import print_statement
It's a real nice feature I've been looking forward to for a long time! You could also totally backport it to Python 2.8 without requiring everyone to rewrite the world.
There's a python3 port of pika that works fine. I use it every day.
I actually had an idea- too late to implement now- where instead of being a generator, map detected if the underlying iterable was a sequence, and if it is, the map is also a sequence which calls the function on-demand for the individual elements. Basically, this would be valid code, without map returning a list: map((lambda x: x+2), [1,2,3,4])[1] == ~~3~~ 4 This would allow for greater compatibility with Python 2 while still giving the memory efficiency benefits of iterables instead of lists. EDIT: goddamn it even as I was typing I was thinking "don't make an off-by-one error don't make an off-by-one error"
unicode in CSV is pretty common use of CSV, which is pretty common in business. (Because businesses run on Excel and there's not a standard library module that reads and writes .xlsx files.) The fact that the [documentation for the CSV module](https://docs.python.org/2/library/csv.html#examples) ends with this giant blob of code showing you how to not break with unicode, instead of that code being *in* the CSV module, is pretty dumb. But that could be in the CSV module without breaking compatibility. Or just `pip install` [unicodecsv](https://pypi.python.org/pypi/unicodecsv/0.12.0). Yes, it'd be nice to have in stdlib, but not nice enough to obsolete python2.
An OS should not ship unsupported deprecated versions of software. Python2 support is going to run out before the end of the LTS lifetime of Ubuntu16.04. Also, Debian started having this conversation a few weeks ago. As their support timelines are longer.
We've thought about that one, but have held off for now because of our own time limitations: * Simply adding correct references between book and online example is going to take a while * Managing the formatting changes by adding dozens of new lines of text is also going to take much effort So we've put it as something on our 'maybe' list. 
I get what you're saying. If it were the only reason, I wouldn't think anything of it. The problem is that It's also just reflective of a general level of cruft that has built up in python2. Text encoding issues, for one, are all over the place, not just in the CSV module. I guess it's one of those things where you don't realize how many issues you've been working around until you don't have to do it anymore, and then you breathe a sigh of relief. The reason I bring up the CSV module is that I've run into this problem at least five separate times, at three companies and helping out two friends with code that is subtly and only occasionally broken. It's not a compelling reason to switch, but beginners often encounter CSV as their first serialization format ("I have this excel spreadsheet..."), and they're the least equipped to deal with obnoxious inconsistencies. Like you said, on its own, it's not much of a reason to switch, but for me, it's a compelling reason to start people out on python3. As for more paradigmatic changes, `yield from` is a wonderful construction. Once you start getting into the mode of working with generators, it opens up a very elegant style of programming. Having a built-in asyncio library is also nice. 
Awesome, it's about damn time. Those who insist on Python 2 first are holding back progress.
 &gt;&gt;&gt; __builtins__.__dict__['print'] &lt;built-in function print&gt; Oh my gosh, it's really there. I didn't know.
I stopped targeting 2 entirely with my open source projects. If other people want to use it with 2 they can submit a PR but I'm tired of supporting a version that should be on its last legs.
It's not just talks anymore, a core dev of Debian was on HN recently talking about how the next release will be Python 3 first (thought the next stable will be in 2-3 years.)
Cute, like devs won't tell the CEO how the big, bad sysadmin is preventing them from doing their work.
Do you use them as apps or libraries? It shouldn't matter what language they are written in if you aren't directly importing them into your projects.
My first thought: &gt; What! Too soon! Some packages I use hasn't been ported yet! My second thought: &gt; Hmm, python 3 was released 7 years ago, and my favourite packages hasn't been ported yet :(
This is a really good point and I think it's probably the central issue here. Python 3 has a lot of nice features and syntactic sugar that make certain things easier to throw together more concisely (dictionary comprehensions, for example), but Python 2 worked well enough that people could live without the little bonuses they would get from 3. In other words, P3 may be better, but not enough to be worth the cost of switching. I think that if they would release a new version that could really offer a compelling reason to switch, they would want to do something like what Scala is doing, adding built-in support for distributed computing. Right now Python is great for writing scripts that can be plugged into Hadoop or other frameworks, but if you could launch nodes on a cluster and aggregate the outputs, all from within a single Python script, that would definitely grab people's attention.
Is the code result False?
I have to say, I think I'm still waiting for CentOS.
Well, currently it's a TypeError, because `map` doesn't have a `__getitem__`. My hypothetical idea is that, if map is applied to a sequence, it applies the function to the elements on demand via a sequence interface, rather than strictly in order as an iterator. In this hypothetical, my example would return True.
Does that work, ever?
Sounds vaguely like lazy evaluation in Haskell, but I'm not really well-versed in either language to do more than make the connection. 
Haven't we been over this lots of times? Remember the site that pointed out the changelists come out to over a pound when printed out, and played the Jeopardy theme song as you scrolled through all the combined changelists? Here we go: http://sealedabstract.com/rants/python-3-is-fine/ &gt;Now if this entire 192-page document is “nothing really amazing” and “you’re not &gt;blown away by it” then that is your prerogative. Perhaps you’re simply not a very &gt;excitable person. I suggest an ordinary person would probably find something in &gt;there amazing. &gt; &gt;Nickous Ventouras’s rebuttal to Alex’s post includes such suggestions as “fix &gt;long-standing annoyances”, “shake the API” and “improve speed”. I guarantee &gt;you, there is page after page after page of that stuff in the changelog. Python 3 &gt;doesn’t need more features–it needs a better PR campaign. The features are &gt;already there; people just don’t know about them. &gt; &gt;But it is wrong statement of the decade to call this set of release notes “not &gt;much”. It’s much. The release notes weigh two pounds. I challenge you to find &gt;another project where release notes can be measured by the pound.... 
No problem :) Parsing packets i python usually leads me over to dpkt or scapy and not socket obviously. What is it you're trying to create, and why do you specifically need a raw socket? Some of the posts I read (I agree with you, everything ends up the same, or derivatives thereof...) hinted on a libcap-based approach. I'm guessing you've already been down that road? Keep me posted and I'll do what I can to help. Problems are there to be solved :)
This is funny, as sysadmin I'm pushing early adoption of Py3 and more. Developers are the ones not wanting to port/test/update.
Because the LTS has to be supported past the time Py2 is no longer.
&gt; for a Python dev Nothing. As a dev you should **never** use the distro's python. Install your own, use virtualenv. Or better yet docker, vm of choice.
Doesn't Python 3 already include fine multiprocessing support, new asynchonous support, etc.? 
I wouldn't know, I've never been a professional developer or a CEO.
And the variable length internal encoding for strings can save a lot of memory as well.
as a Python web programmer, I would say 2.7 since some of the cool libraries do not support python 3 yet. 
&gt; if they had made python able to use a different runtime for each file in a project That would be a hell to manage. Do you know of any language that allows that?
Gevent is by far the biggest reason for me.
No he's right. I made an off by one error.
....oops
Python 3 asyncio support might make twisted unnecessary in the future.
To each their own =). I tend to use folders to group ignored files that I don't want `git clean` to nuke, and everything else I'm generally okay with.
It's incredible that there are still people with their head in the sand about python3.
Gevent
This is very short-sighted. Python2 is reaching its end of life, and all major distros are moving or have moved to python3 as the default. All new code should be in python3.
A guy on my team tried to use it as a library, but man does it try really hard to not work as a library. He beat it into submission, but to this day I wonder if we should have just used paramiko and added our own layer for the features we needed from fabric.
I don't know if this was the case back then, but it sounds like they've rolled out the "task running components" into a separate library called Invoke, which as it happens, *does* support Python 3 http://www.fabfile.org/roadmap.html#invoke-fabric-2-x-and-patchwork
&gt; This is something I've actually never even heard mentioned before. I'll check it out. https://docs.python.org/3/whatsnew/
Tell that to the folks paying the bills. Personally, I really don't care since, as I've said before, there is very little difference between 2 and 3. 
The general pattern I've seen- and I know there are countless exceptions, in both directions, so don't bother listing them at me- is that things that alter an object are methods, whereas things that examine it in some very general way are globals. See also `sorted` vs `.sort` and (arguably) `next` vs `.send`. Personally, I think the cases where it unequivocally calls some method (`len`, `next`) should be methods, whereas the things that use smarter behavior (`iter`, `str`) should be globals.
Ant tips for transitioning from 2.7 to 3?
Paramiko has supported Python 3 [for over a year now](https://github.com/paramiko/paramiko/commit/337f4432d3aef1230ecb588dace0afd445a262c6).
ggplot2 maybe? It has so many dependencies it's not even funny. 
Progress graph: https://twistedmatrix.com/trac/milestone/Python-3.x Also, I thought this dependencies graph was pretty awesome: https://rawgit.com/mythmon/twisted-py3-graph/master/index.html You can clearly see that most of the easy modules are done, but the really interwoven and nested ones aren't even close.
For what it's worth, I'd love help from your community to make Caddy able to front Python apps. What technology/protocol/methods you recommend for fronting a Python web app these days? I've been looking into wsgi... but existing Go wsgi libraries are a bit frail/lacking. So far I can find https://github.com/mattn/go-uwsgi and http://godoc.org/bitbucket.org/classroomsystems/wsgi.
&gt; Because businesses run on Excel There's also the benefit of CSV being human-readable, formated and cross-platform
OpenCV would be nice, but I don't really care enough to learn how to use it to let that stop me from using Python 3 all the time.
maybe it is supposed to be uncomfortable to use py2
From also the FAQ: "**Can Caddy be used to serve PHP sites?** Yep, Caddy has a [fastcgi](https://caddyserver.com/docs/fastcgi) directive that makes it really easy to serve PHP sites." I'd love to see a web server that serves Python sites just as easy as PHP sites.
I don't get why people are saying one or the other. It's fairly trivial to get to know both. And you will likely have to use both as you come across libraries still stuck in 2.x or perhaps 3.1 as opposed to the current 3.4. 
/u/ragnarocka wrote &gt; I think that if they would release a new version that could really offer a compelling &gt;reason to switch which suggests they're contending that there are still no significant benefits to Python 3.4. They're also suggesting this new version include support for distributed computing. 
I use the phoenix project version of wx for python 3, works great.
WOS is quite meaningless, It only shows what they claim are the top 200 packages. A large percentage of these packages are just useful for developers and don't add much value to the end user requirements. Also no non IT domain specific libraries are on that list so a large number of projects can't use that site to gauge the likelihood that the packages they use have likely been ported. If these domain specific libraries were ported to the same level as these 200 packages have been, Python 3 would be in heavy use today. I also have to question how the list of 200 packages were selected as I find it interesting that the cffi package which is very popular does not show up on the list yet it's last months down load rate alone almost qualifies it to be on the list even though the list is made from all time download numbers. Also, if you look at the top 200 packages listed on [PyPI Ranking](http://pypi-ranking.info/alltime) website you will find a large number of them missing on WOS. The PyPi ranking website looks right to me where as WOS looks like it was filtered to make the ratio of ported packages look better. Plus there are a number of packages that are green on WOS which don't have all there features ported over to 3.x but they are marked as if they fully support 3.x.
The OS X userland has some incredibly old software in it. I'm shocked they're even on 2.7.6. 
Forgive me BDFL, for I have sinned. I once literally UN-installed python2 from a new mint machine. I thought; "well, I'm only going to be using python 3 anyway, so let's get rid of it!" 
? That's a framework for writing applications.
That PyPI Ranking site looks terribly off. It lists several packages as not supporting 3 when they definitely do, like boto for example.
I never consider using the system's Python, Perl, etc. for anything. (Even if it was the latest version)
it="it" print(I("God damn #{it}"), file=sys.stderr) I don't remember the implementation of I but it involves re and eval.
Wow, nice. There's a bit of trivia for the trivia bucket.
Pycharm comes with Javascript support
I bought both...WebStorm is nice for Node stuff, but not necessary for primarily JavaScript included in web applications. WebStorm is a god-send for debugging Node applications.
True, i was gonna say the same but I'm guessing he wants to make something with a more intuitive api. Working with email does seem just a bit janky
Time to switch to Postgres ;) 
print function is annoying as fuck when you just want some quick debug prints. Also in REPLs when you want the str instead of the repr.
In general, unicode-anything. It's a massive pain in Python 2, made much simpler in Python 3.
Caddy looks great. It could be a good alternative on windows servers because nginx isn't production ready on windows. So i will give it a chance.
I agree, it's really annoying to not have a `__getitem__` on map objects. The two main reasons I still code in Python 2 is that I end up having to write list() a gazillion times, and... fuckit, print makes sense as a keyword. When you're doing smaller project, printf debugging is fine.
The main issue with SageMath is, that Python 3 did remove some functionalities which are heavily used. In particular, the coercion framework. http://www.sagemath.org/doc/reference/coercion/ So, for Sage, you get it's 2.7 and outside of Sage, you can happily work with anaconda or canopy in Python 3. 
Uhh, the one written and maintained by the MySQL people is python3
You can pip install twisted for Python 3 and all of the ported modules will work.
I concur that using sympy and numpy directly makes much more sense, but there are many features in SageMath which aren't in any python library (Sage itself is a python lib). Also, software like Pari/GP is not bundled with anaconda.
Lol, when Debian's switching you know it's finally over. :)
The built-in email modules are *very* awkward to use.
Go right ahead.
How does blogspot manage to show a completely blank page if JavaScript is limited to the same domain? It's a blog, not a full blown web application. Really annoying. That said, great job! Now go on, 3.x is waiting.
Blaze should do it. https://plot.ly/~balzer82/20/how-long-does-it-take-to-load-a-csv-file-with-python-pandas-blaze-and-matlab/
As always, should you or any of your developers be criticized or flamebaited, /r/python will disavow any knowledge of your actions. This comment will self-destruct in five seconds.
Not for 1d, but for 2d I've recently coded in python. https://github.com/ctengiz/pygol The article which is explaining it is in Turkish, so I think it would not help you anyway so I'm not linking it here. But I think code is self-explanatory. HTH.
It needs that shit to put some stupid menu ON TOP OF THE SCROLLBAR. What the fuck is wrong with these people?
Good. I've already started porting all my 2.x, .NET and PHP (lower your pitchforks!) to 3.4. Why I didn't do this long ago, I don't know. I'm quicker writing and learning all the libraries than just maintaining/writing old code in .NET/PHP for 
~~Seems logical to me. Once you're inside the except block you're already "handling" the exception and it's up to you what happens next. Not much different from putting a `pass` in there IMO.~~ Edit: I didn't pay enough attention. I thought the return was inside the except not the finally block.
There's no `except` block in that code.
But there is no except block. That is the problem as I see it. If there was a matching exception block, then assuming that the exception as handled would have been fine. But without that, doesn't implicitly assuming the exception as 'handled' look a bit dangerous? What if I had forgot to put that except block? There will no uncaught exception to remind me of this omission. Also doesn't this skip all kinds of exceptions? because we are not providing an except block to denote what kinds of exceptions we intend to handle. Doesn't this also go against the 'there should be only one way to do a thing' rule. So In this case, there should be only one way to suppress an Exception, which is to have a pass in the corresponding except block. Is it desirable to have this undocumented behavior add another way to skip an exception in a very non intuitive way? What I am saying is very simple. 1. Exceptions are handled in except blocks. No more, no less. 2. Exceptions without matching except blocks are un-handled. 3. If there is no except block, it means that we do not intend to handle no exceptions what-so-ever. So what ever exceptions produced in the corresponding try block will be un-handled. 4. All Un-handled exceptions should bubble up to the top and blow up in your face without any exceptions (no pun). This is my understanding of the exception mechanism. What am I missing? 
Well a year ago I said that Jython wasn't looking to healthy after 2.7 was in beta for years. I'm glad to be proved wrong
iirc, Java and C# have the same behavior
Supported in version 3.0.0! It's currently in alpha stage. Try pip install protobuf==3.0.0-alpha-1 
I'm referring mostly to the people who should know better.
You are right. I misread the example. This is indeed confusing and unexpected behavior.
It is widely considered to be surprising, often referenced in "do you really know Python" articles, but it is [documented](https://docs.python.org/2/reference/compound_stmts.html#the-try-statement): &gt; If the finally clause raises another exception or executes a return or break statement, the saved exception is discarded
It seems that c# [forbids a return statement](http://stackoverflow.com/questions/4305753/will-try-finally-without-the-catch-bubble-the-exception) in the finally block. Java seems to allow it. But it seems that [it is advised not to do so](http://stackoverflow.com/questions/15225819/try-catch-finally-return-clarification-in-java). 
By definition, finally block means "no matter what happens, execute the contents of this block before carrying on". Once you are in the finally block and you "return", you basically are "skipping" anything which would have followed, which in your case is the exception. If it did throw an exception, you will be faced with another faction of people demanding why the finally block is not upholding it's contract... Java IDEs usually have a setting to flag this sort of return in finally (I'm sure there will be something in Visual studio for this).
Thanks for the suggestion, I haven't dug though the code at all and I'll do that!
Do you know if it was tweepy or the Twitter API that changed?
Ermmm not for sure, but I'm thinking it was tweepy, since some of the method names were straight up different from what's in the old docs, but do the same stuff.
&gt;no matter what happens, execute the contents of this block before carrying on.. I am not sure how re-raising the exception after executing the finally block conflicts that contract. I see that executing the block involve executing the return statement also. But I don't see why the saved exception have to be discarded. Of course it nullify the return, but so does something like this 'return func_that_throws_exception()'. &gt;Once you are in the finally block and you "return", you basically are "skipping" anything which would have followed,... I did not explicitly ask it to skip anything. If I wanted that exception to be skipped, then I would have added a blank except block. The assumption that I want that exception to be skipped just because I added a return statement in the finally block seems pretty far fetched and dangerous assumption to me. Because a return statement has nothing to do with skipping an exception. 
Yes boto should say it supports Python 3. I looked at the [code](https://github.com/wiggin15/pypi_rankings/blob/develop/src/pypi_rankings/crawlers/pypi.py#L29) for the site and it looks fine as well as the [json](https://pypi.python.org/pypi/boto/json) for the package. So I don't know why its wrong on the site. It's likely some bug in the code I don't see from a quick code review. However the package ranking looks good which can't be said for the WOS which is clearly missing many of the top 200 packages. For instance it is missing setuptools, certifi, wincertstore, pbr, awscli, and cffi which are packages which should show up in a listing of the top 200 packages. The WOS site seams like its partial auto-generated with a lot of hand modifications which smells like deception is going on there so I ignore it. Even if they didn't remove a large number of popular packages and actually displayed the top 200 packages they would still have deception going on as the top 200 packages wouldn't even come close to showing all the packages that the majority of projects depend on. I'm sure they would have to display 2000-5000 packages to come close to supporting at least 50% of all Python projects.
That's not really a precedent because use strict does something completely different. 
&gt; I did not explicitly ask it to skip anything You did. What you write in your code and what you *intend* to do may not always be the same hence bugs. That's like saying why `1/2.0 - 1/3.0 == 1/6.0` gives false instead of true. That's the implementation detail you need to keep in mind when writing code. A procedure can either return a value or throw an exception which blows through the call stack till a handler is found. When you throw an exception, the stacktrace is collected and the method is ready to throw it back up to the caller. But as per the contract, control moves to the `finally` block which unfortunately has a `return` which when executed implies discarding the exception trace. Again to reiterate, the piece of code is doing *exactly* what it was asked for i.e. return a value after discarding the exception. Whether or not it makes sense depends on the familiarity with the language constructs rather than gut-feeling...
May want to check spelling: openyxl or openpyxl?
I'm so sorry that typing those parenthesis is such a pain. You might like this, though: in IPython, in the interactive shell, there's a setting called %autocall that lets you call functions without parenthesis, so you can be slightly quicker.
So, the reason it probably doesn't is that it would only work on certain objects. Obviously you want it to work with generators and other non-sequence iterables, and they probably preferred to have a consistent interface. I'm surprised to hear you have to write list everywhere- do you really use random[access] instead of iteration that much? Also, I can't agree that print makes sense as a statement. Statements should be for control flow (if-else, for, try-except, yield, with) or for cases where it's useful to have the exact expression syntax that was passed in (assert). They made eval and exec functions as well, for the same reason- there's no reason for them to be statements. They want to keep the set of statements as small as possible.
Pycharm gets all webstorm features, but it just lags behind a bit.
What use case would you use `try/finally` without an `except` and NOT want the finally to work? 
Cool, I'll look into it, thanks
pyinstaller for me. Or if cx_freeze would support single binary compiles.
The problem on mobile has been the python interpreter running on Android/IOS and I think the Riverbank guys have been working to get around that via a tool that compiles down to native binaries: pyqtdeploy As far as Qt5 on Android, it'll look the same whether it's Python Qt5 or normal Qt5. The hangup will be on whether or not pyqtdeploy is going to work for you and the packages you're using. So I'd probably spend a few days playing around with that and seeing if it's usable for what you're doing. You'll probably get a lot more feedback on the Riverbank mailing list too. 
Always do, but do not discard the unhandled exception no matter what.
The example given is clearly a case you wouldn't want this, but the real use case isn't a bad one - ensuring used resources can be cleaned up before exiting. However a more pythonic and modern approach would be to use a [context manager](https://docs.python.org/2/library/contextlib.html). 
Not to be that guy, but it can't really be called "progress" if it took this long to get us here. We got here kicking and screaming, because the "progress" simply broke things too much.
Not consistently in Python yet - beyond toying, recently my time has been spent heavily in Java and Go for some work projects.
I used to use it a lot when I was in financial planning, ultimately using it convinced me to switch careers because I loved solving problems using code. My primary uses were projections and some basic modeling, but now that I know more about programming and data analysis I could see using it much more heavily for automated trend spotting (some technical analysis type of things) and such for fun.
Those two statements seem logically at odds to me. How can you be fine with the finally block executing the return, but then also expect the exception to be handled? &gt;Explicit is better than implicit. If the exception needs to be handled, then explicitly handle it with the exception block. If I see a `try` without an `except` I just assume the person doesn't care if the code in the `try` block succeeds. 
&gt; But isn't high level languages all about hiding low level details from the programmer (when possible?) I used the low-level details to illustrate. Here's the important thing: there are two ways a method can terminate: *normally* (where it returns its value up the call stack) or *abnormally* (where an unhandled exception unwinds the stack until it's caught). &gt; How can a function return a value when there is an unhandled exception pending?… So the only logical thing to do seem to be to discard the return statement and proceed with bubbling the exception... But if you do that, then the finally block doesn't mean what you claim it means. A finally block *always executes, no matter what*. There is nothing that prevents a finally block from executing- even if the try or catch tries to return, the finally block executes before them. Let's set aside the problem of exception handling and look at this function: def demo(): try: return "Try" except: return "Except" finally: return "Finally" The return value of this function is "Finally", because the finally block executes before *anything* leaves the function. And since the finally contains a return, that return fires and clears this frame off the stack before anything else happens. It's *surprising* and arguably *unclear*, but it's not confusing: finally blocks execute before anything causes the function to terminate, so if the finally block terminates the function, *nothing else happens after*. This means a return trumps a throw. Note that throws don't trump throws: since exceptions can contain exceptions, an exception raised in the finally block will contain the exception raised by the try/catch blocks.
So very true.
I sent it to some of the large scientific python mailing lists like scipy-user (http://thread.gmane.org/gmane.comp.python.scientific.user/35882/focus=35886) hoping that people on that list in different fields would pass it on to colleagues via more efficient channels. I will repeat this survey in future again, so just so I know in advance, where would be a good place to advertise this to reach out to biologists?
From the article: &gt; Almost two thirds of users who are still using Python 2 do not have any motivation to update to Python 3. That's the essence of it, really. I work for a large company and we use Python 2.7 extensively. It's what's on our linux servers/desktops by default, and all our code does what we want. There hasn't been a feature that we've needed that's only in Python 3. EDIT: With that said, in the code we write we try to support both Python 2 and 3, such as by using the "print()" function. That way when we do move to Python 3 someday, we will have less to deal with.
C++, on the other hand, forbids the equivalent situation outright [1], though only at runtime, by abnormally terminating the program. [1] The equivalent being an exception raised from a destructor of local object while the stack is unwinding due to another exception having been raised.
Check out simpy for a general framework for simulations with python.
I see. Thanks.
We use Python for pretty much everything these days - web applications, data analysis, systems administration. We have a certain amount of legacy PHP, and for a quick-n-dirty dynamic page, PHP is still hard to beat, but nearly everything else is Python. 
I must disagree with your 2nd bullet point, because (and especially so since 3.3) you can write code that's compatible with both major versions. To quote from the PEP: &gt; One exception to this is scripts that are deliberately written to be source compatible with both Python 2.x and 3.x. Such scripts may continue to use python on their shebang line without affecting their portability. 
Interesting results, I didn't realize that python 2 was still overwhelmingly popular in the scientific community, and especially among new users.
&gt;And since the finally contains a return, that return fires and clears this frame off the stack before anything else happens... Ok. I see our misunderstanding now. The return operation actually have two aspects. One is to end the function so that the calling code can proceed. When you consider this aspect of return, then current behavior is not so bad. I think this is the aspect you have in mind, when you said this.. &gt; so if the finally block terminates the function, nothing else happens after. But that is only half of what return does. Another higher level (and hence more relevant to a high level language like python) aspect of a return statement is that it can also return a value to the calling code. This value is only valid if and only if function was able to completely successfully. And a function can complete successfully if and only if no exception occurred, or any exception that occurred could be handled by the function. So when you consider that aspect of return statement, it is clear that a function that encountered an exception, that it was not prepared for, was not able to run to completion, hence it does not have a valid return value. Right? So should it be allowed to return a value from an unfinished function? I think allowing it to do so is allowing an error to propagate. It seems that many other languages prevent a return statement in a finally block altogether. Which appear to be the better thing to do, considering that the return value of the function will be the the return value of last executed return statement. Which mean, if you want to return a value from an except block you can still do so, despite the finally block executing after that return statement. And lastly, I am not saying that it is confusing. It is not. But it feels like a trap, that one needs to consciously avoid. 
i don’t think you did read it, because you would otherwise have understood that pretty much the only stuff that changes for the user is that the new, canonical way to write coroutines is `async def` instead of `@asyncio.coroutine` now, and `x = await y` instead of `x = yield from y`. the other changes are subtle and mainly for easily dispatching more specific error messages and debug info, and then there are magic methods that leverage the fact that support is now language level instead of library level.
It's pure python. So it should just work for your distribution. Just pip install it https://pypi.python.org/pypi/mysql-connector-python/2.0.3
New language constructs- a new keyword and a new statement, both of which will potentially break other people's code, plus a whole handful of new magic methods. These are not small changes. They are, in fact, huge changes. All for, what, so we can be aesthetically more like other languages, even though we have a pure-library solution that works? If this stuff was introducing something really new- something that could only be done at the language level, like `with`, I'd be totally OK with it. But all this is doing is making something that works perfectly because, what, people can't figure out what "yield from" means?
Then again it's the "always do" that takes precedence. You can't return cleanly *and* reraise. There has to be a well defined behaviour for all cases. I admit, this might be confusing, but IMO this is the right way to handle things.
Thanks for the feedback! Leaving out bioinformatics was a mistake indeed, and I'll make sure I include it for the next survey. I did add a sentence that I think we shouldn't drop support for 3.3 since it's actually not a negligible fraction of Python 3 users, so I agree with you. I will be releasing all the info on Numpy/SciPy at some point in the next week or so (the reason for not releasing everything in one go is that it takes a little while to sanitize the data) - stay tuned!
&gt;...the great migration has begun! It's like Oregon Trail, just with less dysentery.
yep, I want something useful and not painful to use, similar to requests, but for email. :)
Sounds like a fine goal. Id be happy to lend a hand as well
you’re right in that, but i simply addressed your concern about asyncio 
I'm honestly jealous you get to use MySQL. In my last two jobs, I've had to use SQLServer and Oracle...
I've now added Biology to the graph - as you can see, it's vastly under-represented, due to my advertising bias (I am much more familiar with Astronomy-specific channels).
Again windows users are just 9% (~70/781) and about 39% (~27/70) are using python 3. My guess is these are people who are new to python -- not maintaining legacy projects, my experience is people who are great at scripting tend to move to linux/unix (incl os x) environments for the comparative ease of scripting stuff up. Granted, it seems with python3.5 that personally I'm having a strong motivation to migrate projects up.
The greatest feature of 2.7 is that we'll never have to deal with 2.8. This is almost as good as getting python "ansi" standardised. 
That's not the point. Manually raising an exception with a clear and explicit error message for the current context is far better for debugging than some generic exception about the class hierarchy. If this use case happens often, use ABC, if not, raise something manually. The people using your code will love you for this. The people using your code may, or may not, be you tired and confused at 3 am because production fucked up after the last commit.
Just curious, what packages do you use most often (not standard library)?
&gt;Support for Python 2.6 as well as 3.1 and 3.2 can essentially be dropped Please don't. People in industry with locked-down Red Hat 5/6 machines without internet access are probably not the ones replying to online surveys. If I want anything newer than 2.6 I need to go through bureaucracy hell then version-conflict hell, and by the time we get around to upgrading you'll probably have dropped support for whatever version we'd finally installed. Over-eager developers constantly trying to use the latest features are one of the reasons excel and matlab are so widely used for stuff sane people ordinarily wouldn't use them for. I know this is a less common problem in academia, but not everyone doing science has the benefit of a lax IT policy...
Twisted is very well designed. The public API is very low level, and hence not beginner friendly, but it's the best IO lib in the Python world, and maybe in a lot of other worlds too. I personally hated it when I first met with it. Now I think it's like VIM or Emacs : it's a tradeoff between the learning curve and the tool power. It's both ok to decide to invest in it or to use something easier. I use Sublime text, but I understand very well people using VIM/Emacs. 
We is python 2.7 on Windows at work, primarily because we prefer python XY as our main installer. It gives us basically every library we need, and includes a couple that anaconda doesn't come with. Simplicity of setup is a big thing for us, our use case involves setting up our exact environment on lots of computers. We have recently discussed the possibility of putting together a pypi server, as our corporate proxy blocks pip (ntlm sucks). If we can do that, it opens up the door for migrating to 3.4, or even 3.5 if possible. I'd love async and await primitives. 
This thread has been linked to from another place on reddit. - [/r/linuxcirclejerk] [Arch Linux led the way with Python 3 over 5 years ago...what is taking Ubuntu so long?](https://np.reddit.com/r/LinuxCirclejerk/comments/35fjpf/arch_linux_led_the_way_with_python_3_over_5_years/) [](#footer)*^(If you follow any of the above links, respect the rules of reddit and don't vote.) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
I'm the same guy as above. I just delete my account occasionally. The major scientific computing libraries we use are NumPy, SciPy, Pandas, NLTK, and matplotlib. I also use [MR-MPI](http://mapreduce.sandia.gov/) for efficient large-scale data processing on our clusters (it has Python bindings), although the code that makes use of that is still some older Python 2.7 stuff that I haven't bothered porting yet, so I'm not sure if MR-MPI supports Python 3 (even it doesn't, though, I'm happy to update it since it's a really simple wrapper). I also routinely use things like Django, Beautiful Soup, lxml, python-dateutil, requests, requests-oauthlib, and xlrd.
Hmm, I'm a Python developer and use the system Python versions exclusively. Just because that's not how you do it doesn't mean it's wrong
`.format_dict(locals())` also works
Sometimes it is worth looking for another job if the IT policy is too restrictive. Frankly if you still have hardware running Python versions less than 2.7 it is time to get out. 
Eh, I've never really found Nginx to be complicated. Quite the opposite, actually; the defaults for settings in Nginx will work for pretty much anybody that is prioritizing ease of setup over anything else. 
No, sysadmins generally have everyone by the balls
It literally gives you root permissions.
There is that well documented privilege escalation thing, that is totally not a security concern.
I work in the nuclear industry - restrictive IT policy is inevitable whatever the company. The most common language for code we use is still FORTRAN 77 so I'm pretty happy when using Python of any version… The projects I work on are pretty great in most respects though - ultimately the language is just a tool, not something that makes or breaks a job, and the security/QA requirements are completely understandable. Still a pain, especially when getting a new version of a program to work means going through a bunch of code replacing the fancy new features… I get that you'd want to start a new project with the best tools for the job, but when someone breaks compatibility with a minor update it's a major ball-ache.
[Nope; not until 3.7.](http://legacy.python.org/dev/peps/pep-0479/#transition-plan)
This doesn't make sense to me. What is an "`except` sentence"? What does "if it has `random` inside the generator` mean? Can you rephrase?
Huh. Right you are.
First, /r/learnpython might be a better place for this. Or the matplotlib mailing list. Or another stackoverflow question. I also highly recommend just playing with things until you have a specific question. Second, is the java (javascript?) web interface required? If it's python doing the updating of the web interface would that work too? Also, there are probably other/better ways to communicate data from a python process to a java process. For the number of points questions, tick labels are separate from the data points so you can have whatever labels you want, but I can't remember the specific method for doing this in mpl. Also, I suggest only storing/showing the last X records unless you need to keep all of them for some reason (see numpy.roll when performance isn't an issue). You could easily store all the data on disk, but only show the last 200 in a real time dashboard. If you do look in to storing this information long term I suggest using comma-separated files (google CSV) as it is used more often than JSON for storing data like this and numpy and pandas have functions for loading entire CSVs in to a numpy array. As for your `TypeError` exception, your json is a list of dictionaries so first you need to index the record you want: `y = data[0]["tempF"]`. If you're confused about how to update the plots with new data maybe look at the animation operations of matplotlib. You could also easily update a figure that you have by using the `set_ydata(...)` and `set_xdata(...)` method on the axis object (I think it's the axis object). Lastly, if you want to play with python-driven plots in a browser check out [bokeh](http://bokeh.pydata.org/en/latest/). It's something I've been meaning to get in to, but am not yet an expert. Wow this got long.
No it's a reasonable goal, but you should probably just use [six](https://pythonhosted.org/six/), it will make your life a lot easier. 
I've posted before on learn python and completely forgot to post there. Sorry! Thanks for the answer though. I'm making progress. I'm using Java because I made a nice web GUI with Intels XDK for mobile devices that scales and everything and it's written in java.
Thank you! six looks very usefull.
supervisor has a py3 branch, works quite well.
[SCL](http://willie.dftba.net/python3-centos7.html) supported since RHEL6 as far as I know.
I would just read in all the parameters of your file into a dictinary: var_dict = {} for line in f: (variable, _ , value = line.split(" ") dict[variable] = float(value) After you have all your values in there you put your processing code in a function def prcoess_val(val): val = bin(round(Z0/Xlsb)*Xnbits) ... and then make a function that processes a list def process_list(list_of_variables, variable_dict: for item in variable list: process_val(variable_dict[item]) 
Good news! https://packages.debian.org/jessie/spyder3
Thanks for the feedback :) I will certainly look into YAML, I've never heard of it before. I will also look into psutil, but i was trying to make everything myself instead of relying on 3rd party libraries. Ill also look into putting it up on pypi, thanks :)
It is good, but your code snippet is not the best way from __future__ import print_function print(text) "The features recognized by Python 2.6 are unicode_literals, print_function, absolute_import, division, generators, nested_scopes and with_statement. generators, with_statement, nested_scopes are redundant in Python version 2.6 and above because they are always enabled" (see https://docs.python.org/2/reference/simple_stmts.html#future)
Hasn't been worked on for a few years, but here's [ARE](https://github.com/takluyver/ARE), 'An R Environment'. I think people who want more polished GUIs tend to use something like PyQt. Tkinter is simple but a bit ugly, so I suspect it's mainly used for internal applications which don't need to look too good.
Just what I was looking for, thank you. Yeah, I think you're right about Tkinter but its simple ugliness works well for the project I'm doing right now. :)
It works if you apply this fix: from . import husl Other than that, ggplot still has a lot of ways to go. Seems like not a lot of people are contributing to it unfortunately.
Didn't even think to look for that! Thanks!
&gt; Remember what a finally block means This is my problem with your argument. It doesn't have to mean anything more than what we(python) define it to be. And we are discussing a problem with one aspect of how python defines it. &gt;I mean, you might in the sense that your code contains a logic bug, Exactly.. &gt;but semantically, because you did this in the finally, you are asserting that it is valid.. But that conflicts with the fact that there is no except block. The language should be asking 'If you wanted to do this despite of any thrown exception, why are you not putting an empty except block?'
&gt; Unicode is actually variable length now, just to fuck with people and their minds. You've probably heard that in relation to UTF-8, in which a single unicode codepoint encodes to a variable number of bytes. This is not what I'm referring to. On *some* builds of Python (but not all, e.g. this will work on most Linux distribution), `len(u"\U0001D11E")`, e.g. the "length" (in unicode codepoints, one would assume?) of the string with the single unicode codepoint "musical symbol G clef", is 2 (on Linux, you'll probably get 1). &gt; Doing incorrect encoding/decoding will raise errors, yes UTF-8 is capable of encoding any unicode string, even if it uses a lot of bytes to encode some codepoints. That's the point of UTF-8. It can encode all of them. Well, some of Python 3's `str` objects can't be encoded; `str` objects are not necessarily unicode at all. &gt;&gt;&gt; import os; s,=os.listdir('.'); s 'r\udce9mi' &gt;&gt;&gt; s.encode('utf-8') Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; UnicodeEncodeError: 'utf-8' codec can't encode character '\udce9' in position 1: surrogates not allowed
&gt; This is my problem with your argument. It doesn't have to mean anything more than what we(python) define it to be. It doesn't *have* to, but you probably shouldn't deviate from the standard. Python isn't the only language with a finally block, and they all work basically the same way. &gt; But that conflicts with the fact that there is no except block. It's not a *conflict*. You're not required to catch every possible exception, and since Python doesn't have checked exceptions, Python can't tell if you caught all of the possible exceptions. The no-except-block case is a simplified example- this "confusion" can arise *even if you have except blocks*. *It's not about the except block*. It's about the return from the finally. The return from the finally fires *even if* you have except blocks. If you allow returns from finally blocks, you are saying, "NO MATTER WHAT, return normally." Semantically, that's what that means. If that isn't what you want your logic to be, don't put returns in your finally (which, I have to be honest, I never have, which is why I think all the hand-wringing over this trivial source of bugs is silly).
This isn't the best idea - lots of people don't have Python 3 on their machine because they don't need it and it's not a default for their distro.
The flexible string representation is actually *simpler* to work with than the old guessing game of "am I on a wide or narrow build", since you know that the internal representation of the string is always wide enough to handle the highest codepoint it contains. Source: am someone who maintains a library where being able to identify Unicode codepoints in an input string matters, and boy howdy does that suck to do in a way that works in the wide/narrow versions of Python. And if you were promiscuously mixing bytestrings and Unicode in Python 2, you were already likely to be either getting a lot of errors or spending too much time avoiding getting errors, so I really don't see what you're complaining about. Meanwhile, [here are some of the features you lose by not being on Python 3](https://news.ycombinator.com/item?id=9518391).
&gt; UTF-8 is capable of encoding any unicode string Except UTF-16, UTF-32 and UTF-64, which exist because UTF-8 doesn't have enough code points for some languages (hint: the most spoken language in the world) 
Supporting 2 doesn't really mean adding new features into Python 2. It just means that if there is a bug or security patch that needs to be performed, they will create that patch to the best of their abilities. From the [Python wiki website:](https://wiki.python.org/moin/Python2orPython3) &gt; Guido van Rossum (the original creator of the Python language) decided to clean up Python 2.x properly, with less regard for backwards compatibility than is the case for new releases in the 2.x range. The most drastic improvement is the better Unicode support (with all text strings being Unicode by default) as well as saner bytes/Unicode separation. &gt;Besides, several aspects of the core language (such as print and exec being statements, integers using floor division) have been adjusted to be easier for newcomers to learn and to be more consistent with the rest of the language, and old cruft has been removed (for example, all classes are now new-style, "range()" returns a memory efficient iterable, not a list as in 2.x). If you want to think about it this way, Python 3 release was what it supposed to be "2.8"; however, the change was so dramatic that it really needed a new version of its own (it's not backward compatible).
imbox is pretty good
utf-16, 65536 codepoints tops is a solution to the scalable utf-8? really? And since when paying 4 or even 8 bytes per char to encode plain ascii is a good thing? Utf-8 is superior because it's backwards compatible with ascii and requires upping the width only when necessary. Get a clue.
my favorite packages are messytables and unidecode. they take a lot of work out of figuring out what data is represented in your CSV table, and handing unidecode issues.
The main, **breaking change** of Python 3 was the switch to unicode strings. Given their current flaws, it's easy to argue that it was definitely not worth it. The other changes could have totally made it gradually into the language, either \_\_future\_\_ gates, or via simple deprecation for the stdlib renames.
&gt; UTF-8 is capable of encoding any unicode string, even if it uses a lot of bytes to encode some codepoints. That's the point of UTF-8. It can encode all of them. Well, some of Python 3's str objects can't be encoded; str objects are not necessarily unicode at all. &gt; &gt;&gt;&gt; import os; s,=os.listdir('.'); s 'r\udce9mi' &gt;&gt;&gt; s.encode('utf-8') Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; UnicodeEncodeError: 'utf-8' codec can't encode character '\udce9' in position 1: surrogates not allowed Your problem here isn't with utf-8 or pythons implementation. Your problem is a broken unicode string. The unicode codepoints U+D800 to U+DFFF are for surrogate pairs and aren't actual characters. They are solely reserved for utf-16 and shouldn't be encoded in utf-8 or utf-32. It is even broken for utf-16 in your case because they are surrogate pairs, you always got a low and a high surrogate, a single surrogate like in your string is invalid. You might have thought it valid since most software actually doesn't correctly handles surrogates and just ignores them, silently allowing whatever you throw at it **but according to the unicode standard it is supposed to give an encoding error**. So python isn't broken but actually better in this case than most other softwares claiming to support unicode. &gt; On some builds of Python (but not all, e.g. this will work on most Linux distribution), len(u"\U0001D11E"), e.g. the "length" (in unicode codepoints, one would assume?) of the string with the single unicode codepoint "musical symbol G clef", is 2 (on Linux, you'll probably get 1). Yes, it uses codeunits of the encoding as length, not codepoints. &gt; &gt; Unicode is actually variable length now, just to fuck with people and their minds. &gt; You've probably heard that in relation to UTF-8, in which a single unicode codepoint encodes to a variable number of bytes. This is not what I'm referring to. I think he meant it as he said it. For utf-8 and utf-16 it's obvious, you might need multiple codeunits to represent a single codepoint. For utf-32 you got a single codeunit for every codepoint but it's still variable length if you look at displayed characters, thanks to the combining characters within unicode, they get added to the previous codepoint and you can put as many together as you want. In most cases you can get a single utf-32 codeunit through normalization but not for all cases and all languages where you have to use multiple codeunits. Also some use it just for the fun of it, see Zalgo.
We totally agree on a lone surrogate being broken unicode. This is exactly my point. The fact that Python can put this into `str` objects under perfectly normal conditions is the issue. Using codeunits as length proves that Python 3 went halfway in their "unicode everywhere" move, where silly encoding details are still leaking everywhere, and things like their 'surrogateescape' error handler mean that `str` objects might not be valid unicode at all. But then, why force the Python 3 effort onto us at all? Should we expect a Python 4 with more changes soon? It is disconcerting, it is awkward, and in most cases just not enough of an improvement.
Eh... I'll be that guy: don't use Tkinter. Examples are tough to find because most people use more mature libraries like Wx or Qt. You can find tons of projects in either with a quick Google. If you're going to be making stuff that people will see -- or, god forbid, targeting multiple platforms, you're probably going to want something that has an active development community. (Also, these types of questions should really go in /r/learnpython) 
I've updated the code to support a custom breed of YAML. It is documented in the github repo.
Thanks!
&gt; Who cares about 2.6? Package developers who realize that many of their users are tied to older linux distros.
"Will someone please do this for me?"
Awesome.
In many cases it can be a good idea. But please try to avoid explicit tests of version numbers. Use code that works on both: print(text) # function on 3.x, print statement with redundant parentheses on 2.x. print("{} {} {}".format(a, b, c)) # multiple args, explicit control of spacing/formatting Use explicit backward compatibility features: from __future__ import &lt;feature&gt; Use exceptions that match the specific functionality you want rather than assuming what versions of python have it: try: reduce except NameError: from functools import reduce It is not too hard to master these tricks for writing short and robust scripts with no dependencies other than the standard library that should run out of the box anywhere without explicitly checking for python version. For bigger projects, use compatibility libraries like [six](https://pypi.python.org/pypi/six) - or just settle on a specific version, based on the requirements and environment where people are going to use it. It is often 2.x for organizations with large installed base, 3.x for anything else. 
I do use 3rd party libraries, but only when i can't make the same type of thing myself. I like to build my own things to learn. Saying this, ill download psutil and give it a shot.
As others have pointed out, for this specific example you can just do: from __future__ import print_function print(text) Now in the more general case that you want to have an if statement for Python 2 vs 3, if you are going to be doing this a lot in your script, then you can define the following constant once and for all: PY2 = sys.version_info[0] == 2 Then in your code you can do: if PY2: # do Python 2 stuff else: # do Python 3 stuff It turns out that if you use the [six](https://pythonhosted.org/six/) library that others have mentioned, there are very few times when you will *actually* need to branch the code. Note that the six library also includes the ``PY2`` constant so you can do: import six if six.PY2: # do Python 2 stuff else: # do Python 3 stuff An example of a useful six feature is that if you want to check if a variable is a string, you can do: if isinstance(variable, six.string_types): # do things I encourage you to read the [six documentation](http://pythonhosted.org/six/) to find out more about it.
i think (s)he just means that `python` starts python2. this somehow seems to be an argument for many people. maybe for someone not accustomed to it, calling sth. with a version number feels dirty.
Behaviour can be surprising even if it's documented.
I personally prefer [pyenv](https://github.com/yyuu/pyenv-installer) for this. Virtualenv is better used for creating separate package sets, not for managing Python executables. 
alternatively use [python-future](http://python-future.org/), which can do a bit more
Someone else suggested twython. Haven't looked into it yet myself.
&gt; It is not always just shitty IT policy that prevent people from upgrading. Many times is dealing with a large legacy software stack that is just simply to costly to upgrade everything when the upgrades break compatibility with other things. If the software stack is legacy, then the stack is legacy. Why is anything that anyone else does of any consequence? You won't be using it, you're frozen at particular versions of libraries. Those old releases don't disappear just because the development moves on. I see this argument repeatedly, and I just don't understand it.
if you need to do anything with analyzing numbers .. Python rocks - its your "must have" tool as for building websites ... Python is decent but there are plenty of alternatives 
OK. Thanks.
Springfield Poker - Tkinter based Simpsons themed game: http://i.imgur.com/tvtmWug.jpg
I sure do, the [A Year of PyPI Downloads](https://caremad.io/2015/04/a-year-of-pypi-downloads/) blog post is one of the latest sources that shows the sad reality Of Python 3.x adoption. The relevant information is towards the end of the post. The problem with sites like WOS and py3readiness is that they only show a small number of the most popular packages. They limit the number of packages they show in the hopes that you don't recognize the trend that the percentage of packages that support Python 3 falls off like a cliff as you go down the popular list of packages. So they limit the number they show you so that it shows a high rate of packages supporting Python 3 so that you will make the conclusion that a high level of support exists. The WOS site initial showed the first 100 packages and then only once a reasonable percentage of the next 100 packages supported Python 3 did they show 200 packages. If someone was willing to create and openly share a plot that shows the percentage of packages supporting Python 3 in a sliding window of say 100 packages and shows at least the first few thousand popular packages it would be easy to see that only a small fraction of packages support Python 3. I have seen such a plot but the author does not want to share it as he does not want to make waves. You can actually start to see the trend in the py3readiness site. Look at the number of packages that don't support Python 3 in the first column vs the second and then vs the third. See how the support falls off quickly, You can also see the pattern if you look at the image at the top of the site where the most popular package starts at 12 o'clock and as you go clockwise you go down the rank of packages. See how it starts off mostly green and becomes increasing white the further down you go. A reasonably large number of packages that are popular are what I call "infrastructure packages". These are projects that are mainly for developers, and don't contribute much to meeting customer requirements. Of course they are important to improving the developers experience and are the ones that typically supported Python 3 first. Initially, when WOS showed 100 packages, a fairly large percentage of the packages fell in this category and there were lots of people saying at the time look at the WOS site, see how most packages are supporting Python 3 and now there is little excuse for everyone to not supporting Python 3. Yeah right, as if the majority of us work on projects to support developer needs. The PSF has thrown lots of funds to help many of the most popular projects to add Python 3 support and many Python supported SOC projects that promoted adoption. There was also a lot of behind the scene peer pressure that was applied to many of the core developers of these projects. For the past couple of years we have been in the desperation phase. If Python 3 had a much better adoption rate I doubt Guido would have pushed for asyncio. In the past, for a package like this to be included in the standard library it would have had to been proven first outside the standard library. But I'm sure it was added with the hope that developers would flock to Python 3. Same goes with type hints. It seams completely out of character for Guido to support this. I claim its out of desperation that these changes are being added to Python. Just like ending support for Python 2.7. Sure they will do security fixes for 2.7 until 2020 but that's it. What project, in there right mind would drop support for the version of the project that is used by the majority of there users. One that is both desperate and in denial that just maybe Python 3 has failed. Then there is the latest. Lets change python at the shell to run Python 3 as having to type python3 instead of python must be holding back the adoption. I can see it now the countless number of times people are going to get aggravated over this change and just how often something that was working perfectly fine will now break. For those already sold on Python it wont be a big deal to type python2 instead of python or to fix the shebang line but the bad taste it will leave in others will be nothing but bad news for the health of the Python. &lt;/End_of_rant&gt;
Thank you! New project to start just as school lets out!
&gt; python should be used in the shebang line only for scripts that are source compatible with both Python 2 and 3. in preparation for an eventual change in the default version of Python, Python 2 only scripts should either be updated to be source compatible with Python 3 or else to use python2 in the shebang line. End of story imho.
*Why know how to program?* If you can program a little bit, you can start automating the small and boring tasks like data cleanup, you can also do good data analysis (although Excel can be descent at that too). And if you're good enough you won't need to hire a programmer to try few ideas. Plus it's fun. *Why Python?* Python is one of the most versatile, simple, with rich libraries around. If you have one language to learn, it's probably it. * *simple*: it has become the intro to programming language in many universities, because it abstracts away a lot of the complexities in other languages (memory management, object oriented right off the bat, ...), and its syntax is generally very clean. * *versatile*: you can do professional-level data analysis and scientific programming with Python. But you can also write a website easily, create small utilities to help your day-to-day work. * *rich libraries*: there is a great number of top qualities libraries to help you do basically everything and anything. From scipy/numpy, to networking libs, to web frameworks, and the list goes on and on. * *python is bad for*: the only thing Python isn't a great fit for is probably what's called 'system programming', that is the lower-level code that is behind databases, network layers. But that's far from anything you need to write. So yeah, definitely worth exploring and see if you're liking it. Good luck.
% formatting was brought back into Python 3. You are entirely correct that {} allows finer control and additional features but sometimes it's cumbersome to type when you just want to print one thing.
This is mainly a recomendation for new scripts btw. There is tons of old source code that still expects ``/usr/bin/python`` to be Python 2. Anyway, there is other problems too: Debian 6 does not ship with ``/usr/bin/python2``, but it's still used everywhere (and the fact that this is a LTS does not help too). Another commonly used distro that does not have ``/usr/bin/python2`` is CentOS &lt;= 6. I am sure there is other distros everywhere that still does not ship with ``/usr/bin/python2`` and are still used today. I would love to live in a world where every common distro had ``/usr/bin/python2`` but this is not what happens in reality. In the mean time everytime I need to write scripts compatible with Python 2 that runs both on Arch Linux and every other distro, I end up using the following script: #!/bin/bash PYTHON2="/usr/bin/python2" if [ ! -e "${PYTHON2}" ]; then PYTHON2="/usr/bin/python" fi "${PYTHON2}" script.py Which makes me very sad because I hate writing ugly bash scripts with my beautiful Python code.
The `six` compatibility library supports versions all the way back to 2.4 so making a version that supports 2.4-2.7 and 3.X with that is feasible, but may require some significant patches and rewriting. It sounds like the core maintainers have no interest in large changes though, so maybe you need to fork it? Sorry... I would argue that a library/application that doesn't have plans for supporting 3 at this point is basically unmaintained though.
You asked the key question. "Am I wrong to think a port is important for the project?" I would say most likely yes, as it doesn't seam like there is a compelling reason to make the change which would likely require a fork of the project. Your fears of the project not being maintained in the future is a bit premature at this time considering Python 3 has such a low adoption rate at this time. If you not convinced that Python 3 has a low adoption rate see [A Year of PyPI Downloads](https://caremad.io/2015/04/a-year-of-pypi-downloads/) blog post. The relevant information is towards the end of the post.
 Wow, there's a terrific amount of work here. Hopefully it's up on Awesome Python.
I'll check it out. Thanks for the recommend.
I'm a newb to Python and this is great stuff... Can anyone else in this sub point me to some similar type tutorials? Start to finish projects? I think those are much more educational. I've learned the basics but want to do something practical.
Did you post it on here?
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
How isn't it the present? Most of anything works on 3 now, and python 3 users rise while python 2 users go down. Might be slowly but when every linux distro comes with python 2 and most python programmers use linux, it isn't hard to see why python 2 has most of the userbase. Which again, Ubuntu is going to ship with Python 3 which will no doubt cause other distros to do the same. It is the future and it's the present once you let it be the present. Either way Python 2 is legacy. Supposedly Python 3.5 is going to have some major additions too. 
/r/freebiesuk might enjoy this.
 &gt; Your fears of the project not being maintained in the future is a bit premature at this time considering Python 3 has such a low adoption rate at this time. Don't get me wrong. I know there isn't a problem right now. It's just I know it's going to take a lot of time to port. 
This is kinda amazing. 
Yeah, thought about posting there but I want to see real Tkinter apps, not beginner ones, I've found plenty of those already. I don't need a fancy UI, mostly just text fields, labels and file pickers. For my use case, the simplicity (and near ubiquity) of Tkinter is desirable.
If you're still interested in working with Django, the tango with django tutorials are really great. Especially for beginners!
As you're dealing with a number of users who are using 2.4 - you might have to tread carefully on this one, but it's not impossible to deal with. I'd suggest that you'd need to decide on a particular release to become your long term support branch - might be slightly tricky as it's not your project. Promise bugfixes for a certain number of years, but no new features at all for this version - it'll be stuck at this forever. This way if someone is on RHEL 5, you've got an officially supported version which they can use without any problems. Then I'd suggest you modernise the codebase and focus on 2.7 and 3.3 compatibility. Use six to help with code which can run easily on multiple versions of Python. It might be time consuming - but I strongly suggest that you keep 2.7 support around for a while longer. Use the full power of any Python 2.7 features, don't even consider 2.6. You might want to provide some documentation on recommended ways of installing Python 2.7 on machines which don't support it. I believe some distributions offer this, although it's obviously less supported. Then those users who really want the latest version of the app but refuse to upgrade their base operating system can install a few additional packages to run a Python 2.7 app. Hopefully you can maintain the 2.7/3.3 code for a few years, and encourage people to start running on Python 3 **now**. Don't encourage 2.7 if you can avoid it! 
How about this: https://automatetheboringstuff.com/
Yeah, if it's really necessary, it is possible to support 2.4 and 3.x from a single codebase, either using `six` or by running 2to3 in setup.py. `six` will make the code somewhat uglier, but it's easier to see what it's doing, whereas 2to3 is more implicit. But neither is ideal, and if the core developers aren't sold on Python 3, they're probably not going to be terribly keen on this. I'd suggest politely trying to establish what the timeframe is for dropping support for old Python versions - it's unlikely that the project wants to support Python 2.4 for ever. Most of the scientific Python ecosystem has already dropped support for 2.4, so users who are still stuck on that should by now be used to installing old versions of packages. When the minimum supported Python is 2.6, it will be easier to do a Python 3 port. I think I know the project you're referring to, however, and if I'm right, the core developers are notable Python 3 detractors, so there's probably not much that will convince them at the moment. I'd leave it until major Linux distros are shipping without Python 2 in the default install - that might provide a bit of incentive. And, to be blunt, the project's major (non-Python) competitor is slowly killing it anyway.
 $ grep 'print(' myscript.py ;)
We could timeit. I believe their index access is fast, but attribute name access is noticably slower than the index access. I can't remember the exact relation to class attribute access though.
I'd try and see if the developers will accept patches / pull requests using tools like [six](http://pythonhosted.org//six/). If not, consider if you have the time and capability to fork it? Otherwise you are at the mercy of upstream. 
If the core devs don't want something to happen with a project or aren't really interested, then it's *extremely* hard for it to happen. That also makes it impossible to encourage others to help. The *process* of being able to help has to be easy, welcoming, and encouraged; not difficult. Or people will try once and leave. Pull Requests get ignored, or not reviewed, the status quo is always preferred to refactoring "because we know it works in the current state", etc. If you want to make change easy, make tests easy, fast and plentiful first. Get stuff unit tested; if it can't be, often that means it is ripe for refactoring. It gives people a lot of confidence to allow changes to go through when a hell of a lot of green lights stay green. Moving a codebase to &gt;=2.6 makes it easy to port to 3 because single-source compatibility becomes so much easier. Exception syntax comes to mind. Huh, guessing this project is Mercurial. Yeah, they're really stabbing themselves in the back. At the moment they're just falling by the wayside and losing to Git; being modern and easy to contribute would be a nice advantage to have in the fight for popularity, pity they're not taking it. http://mercurial.selenic.com/wiki/SupportedPythonVersions#Python_3.x_support 
Thanks I am glad to hear that as I was worried I was stealing your nice idea! :) 
Are you sure there is no alternative project? There's not alot of projects that don't have Python 3 alternatives one way or another.
I have a useful GUI application that will be released in a few weeks. I will let you know when it is released. Good luck with everything.
I am... I just want help in understanding? Try going to MIT.
If your school isn't preparing you for your assignments, get your money back. Otherwise the point of your being there isn't to do the work, it's to learn how to figure out how to do the work yourself.
Yes it can and it will help you a lot. The reason why many people love python is simply because it allows you to do tons of work with very little code. But I don't think that this is what you should be interested in and this shouldn't be your driving force. Specifically for finance and economics, python could be a gem. e-commerce systems won't be a problem for it, in fact there are tons of solutions already. Mobile apps are not python's strong side. You basically have two options - there was a qt library for mobile apps(can't remember the name) and kivy. I've tried kivy a few times and while it is still limited when it comes to interface customization, it does a lot of things really well. As for finance and economics, this is where python could shine: Extensive libraries and picture perfect documentation: numpy will likely end up being your best friend for analyzing datasets efficiently and perform mathematical operations on big vectors without any effort. As supplements - matplotlib and pandas. Theano - another gem. Generally it is a machine learning framework but it could help you a lot. It is a symbolic framework which basically means that you will give it a symbolic equation such as z = x^2 + y^2, then theano will compile your instructions to C and you'll be able to throw any data at it(including vectors) and it will perform the operations for you. And to make your life even easier, it allows you to use you GPU for the heavy lifting. There is a catch however - it uses CUDA, so you will need to have a specific [nvidia graphics card](http://en.wikipedia.org/wiki/CUDA#Supported_GPUs). The only obvious limitation with this approach is that you are limited to 32 bit float numbers so extreme precision is not a strong side for now. Afaik, nvidia is working on a 64 bit gpu for that purpose(project Denver if I'm not mistaking). tl;dr - go for it.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 4. [**Supported GPUs**](https://en.wikipedia.org/wiki/CUDA#Supported_GPUs) of article [**CUDA**](https://en.wikipedia.org/wiki/CUDA): [](#sfw) --- &gt; &gt;Compute capability table (version of CUDA supported) by GPU and card. Also available directly from [Nvidia](http://developer.nvidia.com/cuda-gpus): &gt;'*' - OEM-only products &gt;A table of devices officially supporting CUDA: &gt; --- ^Interesting: [^Plymouth ^Barracuda](https://en.wikipedia.org/wiki/Plymouth_Barracuda) ^| [^Milan ^Čuda](https://en.wikipedia.org/wiki/Milan_%C4%8Cuda) ^| [^NVIDIA ^CUDA ^Compiler](https://en.wikipedia.org/wiki/NVIDIA_CUDA_Compiler) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cr4wgeh) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cr4wgeh)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I built and launched my first website using TwD! Highly recommend this and Two Scoops of Django.
Thank you for letting me know. I have python-tk installed. I noticed there is no python-tk-dev in the apt-cache search. A little more searching and I found tk8.6 and tk8.6-dev. I got those installed and ran make again and it did not throw a warning for _tkinter. I will ignore the other four items and make install with this now. Thanks again for your help.
From the terms and conditions, &gt; 7. One voucher per person using an email address or mobile telephone number unique to the promotion. If more than one request is received from the same email address or phone number, or from a different email address or phone number by the same person, those requests will become void. If it becomes apparent that a participant is using a computer(s) to circumvent this condition by, for example, the use of ‘script’, brute force’ or any other automated means, those requests will also become void.
Yeah it does a really good job of walking you through how everything connects with MVC. I had a lot of fun with it! :)
Yes you can. Syntactically, it's denoted with the keyword `pass`. 
&gt; Heavily uses strings as binary data containers. Run far the fuck away.
Kind of a dick response, but just use SQLAlchemy and it'll solve your problems.
http://www.pylonsproject.org/ can run a small to large projects. Can use different ORMs (SQL/NoSQL), forms etc. ps: runs this site too :)
Any help is welcome :)
I don't follow. Let's say you have a variable, x. In Pascal you'd write Case x of 1..3 : WriteLn('Low'); 4..6 : WriteLn('Medium'); 7..9: WriteLn('High') Else WriteLn('Undefined'); End; What's all this about common types and methods? Why would I want to fill a list or a dict, especially if the case is using ranges of values? What does inheritance have to do with any of this? It sounds like a way to make something simple into something much more complex. 
Figured it out, I had it linked to the incorrect Python reference for homebrew connection!
I just use the Python 3 doc search page as a custom search engine, with the "py" keyword. So if I type "py regex" into my address bar, I go straight to [this](https://docs.python.org/3.4/search.html?q=regex&amp;check_keywords=yes&amp;area=default).
Are you sure you get that result? I get `['he']` from running your code which makes sense because you are collecting the first part of the two "he"s in a group. I can't imagine how `['hehe','hehehe']` could even result from that.
Sry, Forgot to add a comma in the text (I copied another code): print re.findall(r'(he){2,}',s) 
And yet, it *can* be the only language in the toolkit, which is part of what makes it such an amazing language.
I now use the PyYAML lib ( if the user has it ). This is what it looks like. - onEVENT: repeat: 0 delay: seconds: 1 when: - procexists: params: - banshee result: True do: - action: - notify-send - Banshee open - Lowering your volume so you don't get blasted with sound! - action: - amixer - set - Master - 60% alternative: - action: - notify-send - Banshee closed - Raising volume back to 100% - action: - amixer - set - Master - 100%
`re.findall(r'((?:he){2,})',s)` does what you want it to, I'm not sure if there is a better way to do it, I'm not that great at regex. I'm not sure how well I can explain regular expressions and why your code is wrong, but here goes: The old code only matches the "he" because that's all you put in the group. You need to put the `{2,}` in the group as well. However, `(he{2,})` will match hee, heee, etc. You need the non-capturing group `(?:...)` to group together but not match "he".
Thanks it worked.
I'm not trying to be patronising, so I apologise if that's how I come across, but: Do you know *why* it worked?
I like it. I've never thought about doing this with the Python docs, though I've done something similar with another site (Reditr -&gt; Reddit). The google links bother me too because I mostly use 3.4 nowadays. I think I'll use this, thanks.
I agree. Which is why I've added it to the place where we list only the best tutorials: http://twoscoopspress.com/pages/django-tutorials. 
I'm starting this now and it looks like it'll be great, my only complaint is the lack of windows directions at the start. Does no one program Python on windows?
Are you continuing with the project9 after discovering mailshake ( or whatever its called) that seems to serve the same purpose? Are there things you want to do differently? Nm, read your comment on githib. I
It would be way cooler to have something that only saves to requirements.txt libraries that are imported by your project
looking good!
Do you know if DataNitro run on Yosemite
Actually, there are others like mailshare. Fluentmail is working and maybe some people are using, but I want to design a good email api. Not sure if fluentmail design is good, but if is, there's nothing to change. I have some ideas to add a better attachment way and include some django-like template to reuse emails. 
and coke zero for that matter. I don't know, maybe it could be helpful if you're trying to cut back on soda :)
Honestly, if you're supporting Python 2.4, Python 3 is going to be a pain. When supporting both branches, you really don't want to be supporting anything older than 2.7.
Merci Mimi ! (and Sam) (and Max)
...which, from a syntax point of view, is a statement. A no-op, but still a statement.
For common things like print you can use the standard library \_\_future\_\_ module. Add this as the first line of your script and you can use the Python 3 print function in you're Python 2 code. from \_\_future\_\_ import print_function Also in addition to the six module you can look at the future module. It is nicer than six in some ways and the documentation has a nice cheatsheet for writing code that works on more than one version http://python-future.org/compatible_idioms.html 
It is a simple code to clone all github repositories https://jibinjacob13.wordpress.com/2015/01/02/clone-github-repositories-using-python/
Thanks a bunch, I'll take a look! Good luck with your thesis! 
There is zero risk that Python 3 will be considered a failure. Adoption is coming, it's just taking time, and it *is* better. Honestly, I don't get the resistance people have towards it.
Nice, thanks. I know a few people who will love that.
2,342,21244,218 pastes øbinned? wtf? That's a lot
Interesting, I did not know one could do this. I will have to remember this for next time. Thank you.
Note that `zip` has become lazy in Python 3.
thanks mate
Quick note about new-style classes in Python 2 for the newer users here. The article makes it sound like you'd need to do, say, `class Foo(int, object)` - but most classes already inherit from `object`. Inheriting from `object` should only be done when not inheriting from anything else. Personally I'm not a fan of "[never] use mutable default arguments". The rule **should** be "never mutate input arguments where a default makes sense". If you need to do this transformation, chances are the callers to your function are getting unexpected mutations. 
It took me way longer than it should've to decipher that.
What is that library and what is holding it from being 2to3-compatible?
Thanks for pointing out the new style classes misconception. I meant to say that your base class should always inherit from object. I've edited the blog post to reflect this.
Interesting article. I did not know about the one default arguments. It never occur to me that the list assign to the c arg would always be the same in different calls.
In my own defence I do make a reference to `itertools`, the point is to take people out of using `range(len(thing))` kinds of expressions to cleaner alternatives. Using `zip` in python 2 is not a pitfall since it behaves as you'd expect it to. Also in Python 3, everything that returns an iterable is a generator (at least all the ones in itertools and the builtins).
&gt; The GIL (Global Interpreter Lock) means that only one thread in a Python program can be running at any one time. That's not quite true. Only one thread can be *executing Python code* at any one time. Complex C libraries will generally release the GIL while doing their thing, and their thread will keep running (also obviously a thread waiting on IO will do its thing without holding the GIL) &gt; Never use mutable default arguments, instead use the following: Never say never. There are precious few situations where mutable default arguments are useful, but they do exist (just as there are use case for `static` local variables in C).
Could you give me a good example where a mutable argument would be useful? I've looked but haven't found a situation where I could use an alternative (such as a decorator) to get the job gone.
That's a joke, it's a hard coded number. The thousand separator being stupidly wrong is kinda a clue :)
Ehhh... I would argue debugging in dynamically typed languages can actually be much harder for large projects. A lot of errors that static languages will catch at compile time need to actually get executed before showing up in a dynamic language.
Thanks zach, we use a ton of ivona at work. This should ease things a bit.
I think an empty list/dict is pretty useful as a default argument, as long as you don't actually mutate it in the function. I also occasionally use classes as default arguments, and they are technically mutable.
Haven't played with OS X for a while... but have you tried using the [Anaconda Python distribution] (http://continuum.io/downloads)? It comes with PyQT rolled in and may solve your install issues...
Hence the "pythonic pitfall"! 
&gt; I think an empty list/dict is pretty useful as a default argument, as long as you don't actually mutate it in the function Then why would you do it?
There are a few stylistic and functional problems with your code which I think it is important to fix before anybody uses this in a production environment. I'll do my best to explain and justify my comments, but please let me know if I haven't been clear on anything. ## Functional problems # Calls to 'exit' You have a few conditions in your code where you call `exit` if some dependency cannot be met. The problem here is that if somebody else starts using your code in their production environment, your code could be terminating people's Python applications. You are using `print` statements to explain why you are terminating the code, but those can be easily missed - so there is the opportunity to make a lot of people very confused and angry with this approach. What you should use instead are [exceptions](https://docs.python.org/2/tutorial/errors.html). Exceptions give users of your library a programmatic way to handle the errors, if they arise. For example, if somebody is using Pyvona to enhance their app, but it is not critically important that pyvona works, they might call: try: voice.speak("Pygame is not installed!") except PyvonaException as e: pass your speak method in this case would look like: class PyvonaException(Exception): pass ... def speak(self, textToSpeak): ... if not pygame_available: raise PyvonaException("Pygame is not intalled, cannot speak.") ... # Avoidable dependencies You are using `requests` in your library. Requests is a super useful tool, and I absolutely adore it, but for your library it is not required. You can easily replace your use of it with `urllib`, and in doing so you won't be forcing users of your library to install something they don't actually need. ## Stylistic problems Nothing I'm going to mention here is super important, so I'm not going to go into a lot of detail, but if you want to advance your Python skills it's probably worth bearing these points in mind. Currently your code goes against the "Python" way of doing things, which might make it look a little out of place when being used, and a little tough to understand quickly for other developers (whether using it or contributing to it). [PEP-8](https://www.python.org/dev/peps/pep-0008/) is the generally accepted coding guidelines for Python, though it's not critical you follow it to the letter. I also recommend Raymond Hettinger's talk at Pycon this year, [Beyond PEP 8 -- Best practices for beautiful intelligible code](https://www.youtube.com/watch?v=wf-BqAjZb8M). Again, all of this is stylistic - it's probably not worth bending over backwards to make your code "beautiful". # Old-style classes Your voice function is defined as an 'old style class'. In Python 3 that doesn't matter, but in Python 2 it will be treated as an 'old style class'. To define a 'new style class' you simply define a class using 'object' as the parent class `class Voice(object): ...`. This arguably could be classed as a functionality problem, but I think in this case it's not important. I haven't explained what a 'new style class is', I'll summarise by saying the 'new style classes' fixed a bunch of inherent problems that 'old style classes' suffered from, and that in this case those differences probably aren't important at all. Here's a quick explanation of the differences on StackOverflow: http://stackoverflow.com/a/54873/1930516 # Using 'setters' In Python there really isn't any reason to have 'setters' in your code. Instead of your users using `voice.setVoiceName('bob')` they could instead use `voice.voice_name = 'bob'` - it makes no difference. Stylistically, in Python, instance variables that are not prefixed with an underscore are considered "public", and thus open for anybody to use. If you want private variables you should prefix them with an underscore. In cases in which your setter needs to do multiple things, for example your `setRegion` method, Python has a getter/setter concept to handle that: class Voice: ... # Set region vars, with an underscore to note only your class should modify these (this doesn't stop users of your library actually changing them, but they're not good Python programmers if they do!) _region = None _host = None @property def region(self): """ the 'getter' """ return self._region @region.setter def region(self, region_name): """ the 'setter' """ self._region = self.region_options.get(region_name, 'us-east-1') self._host = 'tts.{}.ivonacloud.com'.format(self._region) -------------- # When somebody wants to pass data to this region setter: voice.region = 'us-east-1' # Print statements Your library should generally not be printing anything to the console, for example `voice.listVoices` should just return the voices to the caller, not print them (it actually does both right now). The other uses of print you have should be replaced with exceptions. # Your '_generatePayload' function is constructing JSON manually You're doing things really weird here. You should just use dicts and encode them to JSON: import json payload = { 'Input': { 'Data': 'Please speak me' }, 'OutputFormat': { 'Codec': 'OGG' } } payload_as_a_string = json.dumps(payload) ---- There are a few other oddities that have caught my eye, but I really must get back to working instead of explaining further :D I hope this is helpful.
In the UK, if a retailer misprices an item and honors the sale, it's binding. The T&amp;C cannot override law. The only way it isn't is that when a court decides the error is so obvious that it's clear to the customer that there was no intent to sell (so they know it's wrong), such as selling a big item like a car for zero (which is situational, and might not work if there's a win a car competition in the store, or something: it's quite credible if it's a TV set or ipad) or when it's proved that someone's done something dirty like swap price tags. In both cases, contract law and criminal law will override the T&amp;C. The only thing the T&amp;C does is allow them to cancel a coupon before it is presented, and communicates their intent that you're only supposed to take 1. However, no-one reads the T&amp;C so that second issue is mostly moot. In any case, if you get a few by 'accidentally' mistyping your address, it's going to be fine.
I think in Python 2, set literals actually are printed (via `repr` and `str`) as `set([1, 2])`
I sense a Raymond Hettinger fan... But in all seriousness, spot on with the bit about setters, that's exactly what properties are for
&gt; I sense a Raymond Hettinger fan What tipped you off? The link to the Raymond Hettinger talk?
If I'm not mistaken, you missed a pretty big one: **Edit:** I was mistaken. Can't type a lot more right now, but the possible bug I brought up would not actually happen. These variables should still be instance vars, though. # Class vs. instance variables The code stores connection details in variables bound to a class, as such: class Voice: """An object that contains all the required methods for interacting with the IVONA text-to-speech system """ region = '' ~~instead of setting these variables on an instance (in your `__init__` method). When I call `setRegion('us-west')`, it changes the value of the variable in the class itself, which means that the change will affect all instances of that class. Here's a quick demonstration of how this can break things:~~ main_server = Voice(access_key, secret_key) main_server.setRegion('us-west') backup_server = Voice(access_key, secret_key) backup_server.setRegion('us-east') main_server.speak('Pyvona reporting in from the shores of San Francisco') backup_server.speak('DC in the house, ready for action if SF fails') # Actually both of these came from US East since backup_server.setRegion updated the entire class to use us-east ^^\(Note: ^^I ^^know ^^those ^^are ^^not ^^where ^^Amazon ^^servers ^^are ^^located. ^^These ^^two ^^seemed ^^more ^^colorful ^^than ^^reality.)
Done! Thanks for spotting that for us!
As accumulator, ESP with recursive functions. But that came up once in a million and I think/hope I rewrote it to be less tricky.
I don't know that there is a standard for embedding icons into a ZIP file, but I'd be interested in knowing. Freedesktop just says install them into a theme folder which is a problem for a standalone file that doesn't get installed: http://standards.freedesktop.org/icon-theme-spec/latest/ar01s07.html
You should put this on pypi so I can install it with just "pip install". If you have a setup.py already written, its just a matter of running "python setup.py sdist upload" to put it on pypi. Also, I don't think its a dab idea to use requests in a library. I think if it was any ther trivial library, you should try to implement it yourself using just the stdlib, but these days what project doesn't already use requests? As long as you include it in your setup.py's `install_requires` list.
 In [2]: set([1,2]) Out[2]: {1, 2} Evidently not
Might be an ipython thing. Using Python 2.7.9: Python 2.7.9 (default, Jan 15 2015, 16:01:32) [GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; s = {1,2} &gt;&gt;&gt; s set([1, 2])
damn, no python3?
Are you using ipython, though? (That looks like ipython output.)
That's iPython, using a normal shell I get the above.
Yes, I am using ipython
I kinda disagree with this line: &gt; If you're trying to do something a little more complex that simply adding an item to a list or set with a condition then you're probably making a mistake. A list comprehension or generator expression in a single line can be clear and expressive if it represents a combination of a `map` and `filter` that are not too complex, i.e. breakfast = [egg.scramble() for egg in tray if egg.sell_by() &gt; last_week] I think that this is a very near approximation of how complex tasks are expressed in a natural language in a single sentence. "Hand me all the all the red legos in that bin after you have detached them." becomes: [lego.detach() for lego in bin if lego.color() == 'red'] and even better one can translate "hand me red legos *one at a time* from that bin as you detach them." to (lego.detach() for lego in bin if lego.color() == 'red') To me the best criterion for a one liner is, "can I express this in a reasonably short sentence?" or "can I express this as a brief mathematical formula on one line on a napkin?". If that is the case, then it is a challenge to the language you are using (or your proficiency with the language) to write this "natural" line as a line of code in a readable and maintainable manner. Even though they are essentially just `map` and `filter` combinations, I find that list comprehensions or generator expressions can make a very wide array of tasks both short and readable.
I've heard good things about `from future import __braces__` but can't get it to work. ;)
I think certain methods in Django let you specify a database. Where the default is whatever you specify in the settings, so if you mutate that db by running a query all future calls to that method will use the mutated db.
Yes, thanks for pointing this out. I made a mistake in the video and described pre 3.3 behavior. For what it's worth, I would argue that using return in a generator and then pull the value out of the exception is a bit of an odd pattern. What I mean is just that it seems cleaner to me to use the generator as an iterator and let the StopIteration end the iteration and nothing more. Of course there are weird corners sometimes where you might need something like this though. Again, thanks for pointing this out.
Didn't catch that one when I skimmed over the code before submitting. Thanks for that one! This was my first run in with Python and I definitely was not aware of those relations. I'll fix and post the updated code within a day.
Yes: &gt; The "from module import *" wild-card style leads to namespace pollution. You'll get things in your local namespace that you didn't expect to get. You may see imported names obscuring module-defined local names. You won't be able to figure out where certain names come from. Although a convenient shortcut, this should not be in production code. &gt; &gt; Moral: don't use wild-card imports! (From [Code Like a Pythonista: Idiomatic Python](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#importing)) In your case, I'd do one of the following: * Use "import cards" and then reference "cards.a" etc. * If that's too much typing, "import cards as c" then "c.a" etc. would work. * If there are only 4 names to import (as in your example, "from cards import a, b, c, d"), explicitly importing them by name is fine. Especially if you're importing one-letter names, don't do a wildcard import, because any use of one-letter names in your code will clobber the imported names. 
Well a work in progress suggests that progress has been made and it is actively being worked on. I'm not going to refund it because I am looking forward to the finished product I was just expect at least some content when I purchased it.
Something something waiting on version 4 
There's pretty much no "compile time" (or no guaranteed compile time); the "evaluation time" means the time the interpreter goes over the function / class definition, which can be, for example, on import (and the initial module execution), or, as another example, when a function that defines another function within its code is called (even if it is just a lambda to be passed somewhere).
&gt;How would you implement that in python? ;-) I think part of why there is no case statement in Python is that no one's ever come up with a good syntax yet. :-) But in a sense Python's "in" and "range" types can model the behavior seen here. &gt;I have given enough links that explain why the "common" switch...case seldom &gt;something you wanna use. And I don't follow them since the example I posted is one of the simplest and most common types of use for "Case", and doing it another way seems like overkill. Nothing I saw in the video (which isn't in Python or even a dynamically typed language with duck typing and makes use of things Python does not typically, such as "abstract superclasses") applies to a simple example like this.
I think I need to sleep for like 3 days before reading this, damn.
No new major features but it will be supported through at least 2020.
Ah! That makes sense. We have just upgraded to 2.7.7 (we are "cautious") and was wondering if we were missing anything significant!
You're fine. 2.7 is just fine, 3.x changes are mostly for language purists. The more necessary something is in 3.x the more likely it gets backported.
Yup, pretty darn simple with homebrew. Just follow the instructions on PySide wiki (or PyQt, but I am not sure what is their documentation about that) 
You don't mutate the db value; you use the db connector to access and mutate the database.
I have used QT on OS X Yosemite - No homebrew install. I can't remember the exact order but there was a critical few steps where you had to install the packages in just the right order otherwise it would fail. I use the Anaconda python so I started with that installed. I followed the general outline described at the top of this page http://www.noktec.be/python/how-to-install-pyqt4-on-osx I got it to work eventually but I'm sorry I don't remember exactly what I did. IIRC I had to adjust a few of the flags/parameters during the make/build phase. Whenever you do a 'python configure.py ... ' there's a flag to point to your python installation - I had to make sure that was correctly pointing to my anaconda distribution I believe. 
Thanks mike_gainor! Apart from exception chaining and concurrent maps, nothing else is compelling us to move to 3.x. Although, it shouldnt be hard to port these! 
SQLAlchemy is awesome, Django's ORM is nice if you're doing web development (it is *not*, however, particularly fast).
SQL Alchemy looks promising. Thanks for the help!
Pipelining is indeed an important technique in data processing. I think pipelining goes further than breaking up function composition into multiple lines. A nicer way to pipe is to use infix pipes. R's magrittr pipes are particularly elegant (I believe Haskell, F# and other functional languages also support a similar style of pipe). For instance, instead of: f1(a, f2(f3(f4(f5(data))))) One can write this in R: (%&gt;% is the pipe operator) data %&gt;% f5 %&gt;% f4 %&gt;% f3 %&gt;% f2 %&gt;% f1(a, .) This assumes that the first argument of each function f_n accepts the data object. If the data argument is any other position, it is represented with a ".", as seen in f(a, .). Turns out you can extend Python to do similar things: (with less flexibility than the R approach above). https://mtomassoli.wordpress.com/2012/03/29/pipelining-in-python/ data &gt;&gt; f5 &gt;&gt; f4 &gt;&gt; f3 &gt;&gt; f2 &gt;&gt; f1 http://dev-tricks.net/pipe-infix-syntax-for-python data | f5 | f4 | f3 | f2 | f1 However, note that the Python implementations aren't able to handle arguments in the second position ie. f(a, x). I'm not sure if there are any general implementation of pipes in Python that are similar to R's magrittr. 
Awesome
Or, if you just want the [ipython notebook](http://sowingseasons.com/mediafiles/ipython_notebook/data_mining_with_requests.ipynb) with most of the code. Thanks!
SQLAlchemy is the cleanest and most powerful, peewee is the best ratio power/size, django ORM is has the best integration in a web framework and web2py DAL can work out of the box with some exotic DB and nosql systems. All of them can be used stand alone or inside a framework.
&gt; There's pretty much no "compile time" Compile time in Python (well, CPython) is the Python → AST → bytecode transformation. This includes things like scope resolution and constant folding.
That's not always something you can define, but when I can I prefer [Square's Cash](https://cash.me), because the fee is nil, whereas PayPal (iirc) takes a fee. More often than not, I still get physical checks from small shops.
How many times should you add the original weight? And how many times are you?
We have an arbitrary measurement for weight, and we have 7 days for a week. What is, and how is rate being expressed?
Paypal definitely does take a fee. Thanks for this. Looks perfect for what I want.
For someone who doesn't really know web scraping yet, I found this to be an interesting read. Thanks.
Negative with homebrew, I just tried their Mac package and got no where...
Hi! I just bought the PDF of Automate the Boring Stuff. It's been very helpful! I really like your way of explaining concepts.
 $ python &gt;&gt;&gt; import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! Second line would have me to believe that this from a import a1, a2 is better than this from a import * As others said, when you see a1 in the code you know where it came from.
This adds a HUGE amount of ugly syntax without really adding any new capability. All just to look more like C#? Ugh.
`statistics` being part of the standard library is also very handy. Not having to install `numpy` when all you need is to calculate the average or standard deviation of something is nice.
It ugly and is restricted to local variables , disallowing other variables and expressions.
Depending if you're in the US or not, you have alternatives to Paypal, like Skrill or Neteller, which is my favourite online payment service. Neteller also has the advantage of not changing any fees for transfers and you can access the money on your accornd theough a credit card directly. You can propose several options to your clients. Good luck Thierry
The main thing that has made me stick with PyCharm over Vim is code navigation and autocompletion. They both work perfectly, whereas in Vim, tags might work 3/4 times, and autocomplete seems to just take text from anywhere in the directory and throw it into a list. And I've tried all the completion plugins. Autocomplete in PyCharm is context aware rather than just alphabetical, and is almost always correct. Also, with the plugins I'd need to have Vim useable in a large project, it takes about the same amount of time as PyCharm to launch. I often hear people say 'Vim is not meant to be an IDE, don't try to turn it into one'. In which case, why would I want to use it for a project of any real size? I see no reason to forego the useful features that an IDE provides. PyCharm has key-map with every single function, and with the help of IdeaVim, I don't have to use my mouse at all. On top of that, if something's missing from IdeaVim, you can always fork the plugin and write it yourself. I used someone's fork to get surround-with and *-in-tag working. Though I still use Vim for everything but medium to large projects, where having fewer plugins isn't a problem.
Yep, read that one too. Really great post.
Check out Mochi. It's a really interesting new language that is implemented in Python 3. It has a pipeline operator: add = -&gt; $1 + $2 2 |&gt; add(10) |&gt; add(12) # =&gt; 24 None |&gt;? add(10) |&gt;? add(12) # =&gt; None https://github.com/i2y/mochi
In some cities (Austin, i know for sure) there's a meetup just dedicated to Learning Python. May find someone there that's local. I would also recommend the typical user groups, people are usually very welcoming at them and the groups will usually migrate to a venue and hang out and chat over beers. That's usually a great place to gleam info and get your questions answered one on one.
I recommend libgdx / Flixel-GDX to people. From what I vaguely remember of the last time I tried pygame, it couldn't do parallax scrolling without all kinds of ridiculous ugly hacks. Has that changed?
There will never be a Python 2.8 is what they said. 
 def main(): # create a list of grades starting with F at index 0, F at index 1, ..., and A at index 5. gradebook = ["F", "F", "D", "C", "B", "A"] # get the score score = input("Enter the quiz score (0-5): ") # lookup the letter grade using the index of the gradebook lettergrade = gradebook[int(score)] print("The associated letter grade for the quiz score of " + score + " is " + str(lettergrade) + ".") main() Reread section 5.3 in that book. It looks like a good book. Is this for some high school class?
I found Django's ORM (like Django itself) to be a bit too inflexible, because unlike SQLAlchemy, it's not based on a query builder. So if you wanted any advanced SQL features you'd probably have a very hard time
With this, and the continuing PyPy-STM work, PyPy is really making incredible progress. 
Great list. To add something: In Python 3, variables can't leak out of comprehensions anymore. &gt;&gt;&gt; list_ = [n for n in range(5)] In Python 2 printing `n` results in 4 and in Python 3 it's a NameError. Or try: for x in [1, 3, 5]: squared = [x**2 for x in (1, 2, 3, 4)] print(x) Prints `1 3 5` in Python 3 and `4 4 4` in Python 2. As for new features, /u/ubernostrum has posted a [similar list](https://news.ycombinator.com/item?id=9518391) a few days ago and I also found this [post](http://www.reddit.com/r/Python/comments/26y26u/10_awesome_features_of_python_that_you_cant_use/). Then there's [extended iterable unpacking](https://www.python.org/dev/peps/pep-3132/), the [nonlocal](http://stackoverflow.com/questions/1261875/python-nonlocal-statement) statement and in Python 3.5 [additional unpacking generalizations](http://www.reddit.com/r/Python/comments/2x8d64/pep_448_additional_unpacking_generalizations/).
This is interesting. I am not sure how much await/async will help us. In all fairness GIL makes any kind of aync useless. We find better performance with one thread than many. Ofcourse, I understand that I/O limitations and executing external program in threads are useful, but this feature doesnt buy any more than the libraries we use. The other stuff mentioned here are nice, no questions about that, but I am not yet convinced that 3.x is a good thing, esp when half my libraries wont work with this. As an experiment we ported close to 50 libraries that we use (numpy/scipy etc...) and the result was an unstable, slow code. Not something I would like to qualify as production code :) edit: word(s)
The fact that Redhat6 shipped with 2.6, 9 months after 2.7 was released, and will be supported until 2020 is the bane of my existence.
Could be worse. I know someone who is still running 2.4 because of Solaris related reasons. :-( I gave a slightly politer version of "Ha ha, no" when asked to support 2.4.
... I've re-checked and apparently most implementations of Python use some sort of bytecode, although I'm not sure it's always the same as cpython's bytecode.
First of all, you are aware that for secondString you're starting off with your original file content and not from firstString's content, right? If the two replacements don't overlap I would do secondString = firstString.replace('" ||',"") instead. Secondly, while I'm not that familiar with regexes and thus can't precisely analyze yours, it might just be that it doesn't match with the file's content and thus nothing is changed. When you say "only the first one works", do you mean you don't see the effect of the second write, or the second .replace? (The first one should leave you with proxy.vcl with only half of it's intended content, whereas in in the other case you should have a copy of the original content after firstString in proxy.vcl). Sorry for the meandering, I have class soon and don't have time to rewrite this clearly.
Yeah I know, the firstString is at the beginning of the line whilst secondString is at the end. What I mean is, if I comment either one of the .write's out then the other applies just fine and replaces the string specified.
Not sure what you mean by &gt; at the beginning of the line whilst secondString is at the end but I think you should change your code like so, and see what happens: f = open('proxy.vcl','r') filedata = f.read() print("Reading file...") f.close() firstString = filedata.replace('req.url ~ "(?i)^',"") secondString = firstString.replace('" ||',"") f = open('proxy.vcl','w') f.write(secondString) f.close()
Thanks for the feedback, I appreciate it. I certainly don't want the post to come off as an advertisement. I do my best to release (free) quality tutorials each week. If you have any suggestions to improve the site and make it seem less like an advertisement, that would be super helpful.
I dont care what they call it. As long as I have 2.7.14, I am good :)
I would recommend SQL Alchemy, but I only have experience with the core, not the ORM. The core is quite awesome. I've made a small wrapper (here called `db`) that allows me to do this: table = db.tables.users query = table.select().where(table.c.group_id == group_id) with db.execute(query) as res: for row in res: yield User().set_data(dict(row)) And inserts: with db.execute(db.tables.users.insert(), data) as res: pass EDIT: added another example
Blaze looks really promising. Though I dont use anything other than SQL Alchemy for DB Querying, the project has potential!
&gt; There's enough important stuff missing Like? &gt; Py3 *still* defaults to ASCII for IO What do you mean? It defaults to the system encoding. &gt; It wouldn't be a big deal, but there's no way to tell Py3 which encoding to use except via environmental variables and closing &amp; reopening IO with the correct encoding is a PITA. Can you give an example of something you're having trouble with? &gt; As things stand in 3.4, it's trading in one set of string-handling issues for a different set of issues that aren't any easier to work around. I strongly disagree. If you want to handle encoded characters on Python 2, it is extremely difficult to do correctly. For example, how do you do caseless comparisons on Python 2? The cases Python 2 is good at - basically anything where you don't want to parse the text - Python 3 is equally good at by just passing byte strings around. Further, Python 2's handling of encoded text is dangerous because of all the implicit casting. Removing this implicitness has fixed very real bugs. And Python 2's text mode vs binary mode seems to have caught more people out than surrogate escaped strings. The silence of certain functions returning surrogate-escaped strings certainly irritating, but it's more manageable than the equivalent problem on Python 2.
Been there, done that. I find [pyrun](https://www.egenix.com/company/news/eGenix-PyRun-1.0.0.html) an excellent solution for people who are stuck with RedHat6 and other ancient distros. It's a single, self-contained 13M python binary you can use as an interpreter. You can combine it with [pex](https://github.com/pantsbuild/pex) or [platter](http://platter.pocoo.org/dev/) for extra independence from os packages.
Hey are you there? I was looking for that stuff for now. Where is the tutorial, LazinCajun? BTW, the tutorial here which zionsrogue mentioned is sooo cool. I am gonna try it. :D
UPDATE: Pyvona version 0.2 is out. I used your suggestions, cleaned up the code, and added the module to PyPi. Let me know if there are any other features you guys want!
Done!
Where did you get stuck? I'm happy to update my post if it lacks some explanation!
This is not about encoding, this is about automatic handling of different line-ending styles (eg. DOS vs. UNIX) in text files. If you just want to be sure to get the same unaltered binary contents in your files, use binary files instead of text files. EDIT: I've just noted you do use the 'b' for binary when writing the file, but not when reading it. Why not? Also, if you actually want to write specific byte values to the file, instead of text in a specific encoding, why use the 'encode' method at all?
That is a fantastic idea!
I have used pyscripter, and the closest to it in linux is definitely [Spyder](https://github.com/spyder-ide/spyder)
What was the error? Did you install it with sudo?
Have you tried to build one before? I am following the tutorial above. Let's see.
oh, man! how could my rubber duck let me down so far? thank you! i dont know how i missed that. f = open("ascii.txt", "rb").read()
I've been using PyScripter for quite some time now, but I've never perceived autocompletion as one of its strongest features. In fact since doesn't do any kind of type inferring and hasn't got type hinting, autocompletion is not very useful inside of methods (meaning it can't show you an objects attributes). What makes me stay with PyScripter is that every script is run as if the `-i` flag was set, so you can inspect your programs variables interactively after running the programm. The difference to other IDEs is that you can do this in the buil-in Interpreter, which has syntax highlighting and code completion. That's something I haven't found in any other IDE.
Could you link to the discussion? It sounds very interesting!
The problem is the lack of brackets around the sub expression make it hard to work out what is happening. I am also not sure if they should also always produce the same result, the placement of the x%2 == 0 in the second expression worries me.
Thats certainly why some of my work is stuck on 2.6. My web services stuff I run using docker which gets me w/e I want. Only possible because RHEL6.6 has docker 1.4. I do provide some tools for other people to run though- those need to work with 2.6 if I actually want anyone to use them.
it’s ongoing, but [here you go](https://mail.python.org/pipermail/python-ideas/2015-May/thread.html#33282)
Yes, &gt;&gt;&gt; g = ((x,y) for x in (g1() if x%2 == 0) for y in (g2() if y%3 == 0)) would make it clearer, but doesn't seem to be valid.
Python 2.6 and 2.7 may be the most compatible versions in the language history. It's been some time since I migrated apps from 2.6 to 2.7, but I remember it was all very smooth and simple. However, it's likely that there's much more than Python apps installed on machines: for example C code that must be linked to an older version of some library, closed source binaries, bash/perl scripts which rely on output from old tools and other software with often unexpected dependencies. A single tool is sometimes enough to stop the whole migration, even if it's easy to upgrade Python code base. There's also of course corporate politics and inertia. Many managers live by the rule: if it's not necessary to change, it's necessary not to change. It may sound silly, but they are the people who made promises to customers, have SLAs and penalty clauses in contracts, so their line of thinking is often understandable. That's how many typical big corporations end stuck with RHEL6, even if upgrade to RHEL7 is free of any charges from redhat. Once you're married to RHEL6, it's now the question if your company policy allows third party package sources like epel or ius. The reason why people pay money for RHEL is redhat's support, which is in my experience top-notch. It's comforting to know that if anything doesn't work as advertised, redhat will step in pretty quickly and help you. Managers like it a lot and are eager to ban third party packages, as they are obviously not covered by redhat support. The third party ban is the worst thing that can happen to you - I don't know how often it happens, because at places where I worked every time it was proposed, we managed to convince higher ups not to go this way. I'm pretty sure not everyone is that lucky though.
This is supposed to be an intermediate level Tkinter tutorial : http://pythonprogramming.net/tkinter-depth-tutorial-making-actual-program/
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
&gt;I used to be a programmer, but now I'm a novelist. \#lifegoals
I dunno why you say, "just", but yeah. But don't fall into the trap of "I once wrote a script to tweet whenever my doorbell rang, I can work on a 10-person team building/maintaining a 50k loc project." Python scripting and python development are *entirely* different beasts.
Probably, but to be perfectly frank, I wouldn't hire someone who betrays this intent. It screams "I'd rather be comfortable than competant". In 10 years, Python might not be the "best" language anymore, and you'll be clueless.
What other skills would you require to hire a Python Engineer?
Indeed! Also, profiling with remote interpreters will mean you can profile what's going on on a production-like setup from your work station IDE. That could be a killer feature for anyone doing Python back-end development.
I don't know what is a "Python related problem". It's like if you said a "motorbike related problem". It can be fixing the bike, delivering something with the bike, selling the bike, teaching how to use the bike, etc. But here, you are espacially talking about a certain bike brand. This is not how the market work. People have a technical problem, and you solve it. If you can solve it in Python, good for you. But they don't pay you to code in Python, they pay you to solve their problem. Now, yes, there are loads of problems you can solve with Python, and that the industry solves with Python, and hire people like you for it. But I never did any job where I used only Python. Bash, Javascript, Html, CSS, a bit of sysadmin, ergonomic evalutations, testing, setuping envs, tech support, client interractions, etc. Plenty of stuff can come with the job, so no, you won't be doing "just" python related problems.
Tldr; only programmers and engineers use python. R remains of and for the science master race.
Is supporting 2.6 really that difficult? Once I have a setup for multi-version support (e.g. automatically running tests on multiple versions of Python), I find that supporting 2.6 in addition to 2.7 is usually quite simple. I can see that this would be more difficult if you have dependencies which don't support 2.6 (or won't continue to), or if you heavily use something introduced in 2.7 which doesn't have a backport or isn't supported in 2.6 via `__future__`. Or maybe your project is mind-bogglingly huge...
It's not that difficult. The hardest thing for me is giving up dict comprehensions.
&gt; However, 2.7 includes a LOT of new libraries and features not found in 2.6, so back-porting code which assumes 2.7 to work on 2.6 can require a lot of work. Such as...? They're not that different. Dict comprehensions, argparse, what else?
Please don't oversimplify what I'm saying. My point is that it's better to have a genuine interest in your day job; the kinds of questions your asking make me think you might not. I say this, again, with the utmost respect. I'm not making accusations, you don't need to defend yourself and I'm sure you're an intelligent guy. It's just that in the context of recruitment, your general demeanor raises red flags. It's totally fine to look for python-specific jobs, but I think that saying "I want to learn one and only one language" is pretty toxic.
Minecraft spotted
A [steep learning curve](http://en.wikipedia.org/wiki/Learning_curve) means something is easy to learn.
When a subject doth make an intrusion, Knowledge can clear the illusion. To know more on a thought... Just call wikibot! He can lift the air of confusion! ---------------------------------- ^^I ^^am ^^a ^^bot! ^^Do ^^you ^^want ^^your ^^own ^^limerick? ^^Click ^^[HERE](http://www.reddit.com/r/dogemarket/comments/353yd1/ss_selling_personal_reddit_limerick_bot_details/) ^^to ^^get ^^your ^^own!
He didn't come here looking to be psychoanalyzed, he just wanted to know if people have careers doing only Python shit. He's not looking to be hired by your "fledgling startup". Get a grip guy.
I've had this problem too. The problem is that Scrapy uses TLSv1 by default and the server may use something else for the SSL handshake. A solution that worked for me can be found at [http://stackoverflow.com/a/19601182/54872](http://stackoverflow.com/a/19601182/54872). 
Mehhh, this is kind-of misleading. Using a http request from your local CLI is more like "Is it accessible from my local PC", not "this website is down" which is implying it's down for everyone. Think VPN's, Bad Internet Connection, or overall network based ACL's restricting access. All would give false negatives.
SQLAlchemy - beautiful documentation. Big supportive community. excellent product.
I've found it worked great. See the example in the op above where I create "canvas", an image object. Just typing "canvas." shows all functions and parameters associated.
My project isn't mind-bogglingly huge (about 15 kloc), but it's large enough and hard enough that three people including me have attempted to make it Python 2.6 compatible and said fuck that after a few hours of poking at it. Off the top of my head the following are the things I ran into last time I looked: * Lack of some convenience functions like functools.total_ordering * No set literals * No set or dict comprehensions * A variety of parsing routines (float and Decimal IIRC) don't accept as wide a range of strings * You can't convert a float directly to a Decimal but have to go via str. And these are the things that more or less stop it from even having a chance of working without modification. I would strongly expect to find all sorts of interesting subtle issues once these are fixed. To some degree this is a simple matter of code. There's nothing fundamental that blocks 2.6 support that I'm aware of, but there are enough small things and enough code that I would have to be fairly motivated to do this. Instead I'm 100% not motivated to do this simply so that Red Hat can continue to charge for supporting Python 2.6.
Well yes, you can totally share a database between the two projects, and have an inscription on the website count as an inscription for the in-game chat. 
Fuck I hate programming these days. You made a command line app that queries a web service that makes a http request to another website to check if it is down. Or you could use curl.
Thanks for this, I'm checking out the source code now. It'll be fun for me to see how other people come to the same solution that I did. Will update this post later.
R is a mind-meltingly bad programming language that, through pure stubbornness, has become a powerful tool. It reminds me of PHP in that way.
I don't have the option: http://i.imgur.com/NE31jhk.png Do I need to turn it on somewhere? I am using #PC-141.1075. It says it was built on March 11, 2015 so I think I'm on the right RC build.
Will the community edition have the profiler? Profiler is going to be a killer feature for me (personally) because I use Python for things I probably shouldn't.
Some of it is enterprise bullsh ... policy. The sort of place where you have to fill out a form to request permission to login each morning isn't going to like people installing anything.
I'm currently doing some now, and starting a graduate degree in robotics this fall. ROS isn't new by any means, but is amazing at integrating different systems/sensors together, and is overwhelmingly what people use to build complicated robotic platforms that they want to be compatible and future-proof. You can get started with most of the SBC out there (RPi et al)
My guess is R. Project Jupyter (the successor to IPython notebook) will have R kernel support and rpy2 allows you to interface with R objects from Python. Also you may be interested in Two Sigma's Beaker Notebook which provides Python and R support like Jupyter, and is a little bit better for polyglot workflows (especially passing data between two language kernels) at the moment.
Yeah, I thought about a pay for a version that supports 2.6 at all model, but honestly it sounded too annoying to be worth it because it means either using a non-OSI approved license for the main software or maintaining a private fork. (I also consider 2.7 support non-optional for Hypothesis, but completely support other libraries taking a different stance)
Whats your workflow like with both of them? Do you use rpy2? 
I think the reason why it checks the isitdown service instead of making an http request itself is the same reason why services like isitdown exist in the first place. You could just check to see if the page works in your browser or curl, but it may be that there is something wrong on your end. I do agree that some programs needlessly rely on some web service, but this is a little less stupid than it sounds.
I promise you it's not used both ways, by anyone who uses English correctly. This isn't a flammable/inflammable situation. It's not even a literally/could care less situation. Steep learning curve means it's difficult to start learning. End of.
Django? Inflexible? Where did you get that idea?
Before matplotlib et al were fully formed I tried, really tried, to use R. I just couldn't get a good handle on it. It was so different from what I was used to (Matlab from my PhD days) that in the end I just gave up and waited - basically, I did without for ten years. Fortunately that patience was rewarded with the excellence that all the scipy packages became. Now, I wouldn't even have considered r. I'm not trying to dis r, but I think unless you're from an S background, then python is where you will naturally gravitate.
It's linked to in the first sentence.
Not an empty statement; the *absence* of a statement. Block delimiters with nothing between them represent a block with nothing in it. But in Python, we don't have block delimiters, so we can't have a block with nothing in it; we can only have a block with a dummy statement in it.
Hmm, this is about Python for data analysis, not generally.
Why would one click on a link to learn about the authors of the kardashian marriage webservice if one didn't know who the kardashians were?
It would be more helpful to the authors if you posted the whole compilation log. This is just a final statement that something went wrong.
Problem, no. Nuisance, yes. It's just one of the things that makes Python less useful for me, which is a pity, is all.
And array support... finally.
The trick for remembering how these unpack is that all you have to do to convert it to a set of loops is to add newlines colons and indentation without changing the sequence. Then stick the result, with a yield at the bottom def genexp1(): for x in g1(): if x%2 == 0: for y in g2(): if y%3 == 0: yield (x,y) def genexp2(): for x in g1(): for y in g2(): if x%2 == 0: if y%3 == 0: yield (x,y) but i had no idea you could stack the if's like that (on number 2), apparently regardless of the number of for's.
&gt; A variety of parsing routines (float and Decimal IIRC) don't accept as wide a range of strings That's funny. When I upgraded to Python 2.7, I found that `float('1.0234D5')` doesn't work anymore
If you're interested in pipelining in Python, you should really check out David Beazley's presentation on generators http://www.dabeaz.com/generators/ I promise it will be one of the most valuable tutorials you've ever read. 
I can't wait untill julia matures... we will get the best of both worlds with Julia's macros, sane design and a bonus of speed!
Or the fact the comment is located on /r/Python. If you're not a RaymondH fangirl, you don't belong here.
I found it more entertaining this way, not so dry
I use R and Python at work, and while I don't exactly disagree with anything said in the infographic, to say it is unhelpful is an understatement.
R is the language of the R environment, it shouldn't stand on its own. It reminds me of a better, non-shitty and open source Matlab (sorry Octave).
Mobile is tricky. I really would like an "Android for Kids" book, but Java is bazonkers complicated and so is the Android SDK. Kivy doesn't support Python 3 yet, and only builds on Linux. But making this would be great. Kids use phones, and they could then show off their programs to others as a "real" app. It's great motivation for them.
Indeed, it was in the sidebar.
not found...
I dunno pal. You seemed mad that the post didn't describe the project up front. I'm telling you if you click the link in the first sentence you can learn all about it. Have a nice day! 
What is the benefit of array over manytomany ? Limiting joins?
Just thought I'd share a program that I created for myself to learn about web-scraping. When run, the program will check what comics have already been downloaded, which at first will be 0. It will then continue to download all xKCD comics up to the most recent one. After this, whenever the program is run, it will check if any new xKCD comics have been uploaded and will then download them and launch the image in your default image-opening program. I've only been able to test this program on my Windows PC but I've *tried* to make sure that it will function properly on other systems. All feedback is welcome :)
How is python going to get better?
To be fair, my relatives don't make infographics comparing spoons and forks.
The AI seems to be rather simplistic. It makes very sub-optimal moves. This is even only looking one move ahead.
Looks pretty good, similarly when I was learning Python I made a subreddit image scraper to test my skills :D. Some feedback just because you asked for it: You should check out Pythons list comprehensions to clean up some simple for loops [here](https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions) These two things can be shortened: for filename in allfiles: filename = str(filename) numo = re.findall('\d+', filename) allfiles1 += numo for numoo in allfiles1: numoo = int(numoo) allfiles2.append(numoo) into something like: nums = [int(re.findall('\d+', str(filename))) for filename in allfiles] And also, a very important convention is to put the code you have under your 'Main' comment into a conditional block like so: if __name__ == '__main__': mostRecentComicDownloaded = findHighestComic()+1 downloadComics( mostRecentComicDownloaded ) #rest of stuff here... The purpose of this is so that *only* when you run this program directly like 'python myprogram.py' (which causes \_\_name__ to be set to '\_\_main__'), this 'main' block will execute. Currently, if you wanted to use this code as both a library and a standalone program, the stuff under your 'Main' comment would be executed even if this file was imported (which is bad). [Here is an explanation on stackoverflow that is probably much better.](http://stackoverflow.com/questions/419163/what-does-if-name-main-do) Lastly, if you plan to do a bunch more Python programming in the future definitely check out [PEP-8](https://www.python.org/dev/peps/pep-0008/) for a ton of code style standards (very helpful if you're new to programming or have a background in a different language, because many Python programmers have a very specific preferred style).
Thanks for the feedback :) I had no idea about the optimisation of the for loops, that's incredibly helpful. I usually use main() functions but I got really sloppy with this since I wasn't quite sure what I was doing with the web scraping. Thanks again for the help! 
It's a plugin? I don't see it in the plugin list as an option to download.
Similar in use to hstore with good Postgres support. You can also put them together in views or assemble them with subqueries. They don't come up often but there's certain times it improves performance or saves on code. 
Soon to be seen on /r/dataisugly
I'm writing lidar code to do primitive terrain mapping for ground obstacle avoidance with ROS and I've just finished my sophomore year of college. ROS has a bit of a learning curve, but the documentation on it seems pretty solid. It's really quite fun once you get the hang of it. 
Nice work, at first glance I see nothing beyond what the other gentle person commented on. Now that you've done the web scrape way, you could also do the API way, see the [json interface for xkcd](https://xkcd.com/json.html) to give that a shot!
Experience + Code Samples speak a lot, so in many cases I see I simply like to see a clear readme with some relevant documentation points and then code samples (also documented, if and when appropriate). Though I do mostly server work and cli apps, for anything front end a few screenshots would be enough for me to be happy (but I'm not your target with those).
I ported it to 3.x for use on my current project. If you want I can link you to the files. Edit: [Here is the download link](https://www.dropbox.com/s/c2s3wbw78kvlnqr/pyvona-0.2%20-%20Python%203.X.zip?dl=0). I PM'ed OP to ask him if he wants this version to upload on pypi so it's easier for people with 3.X to use. I'm waiting for his reply.
&gt; I use Python for things I probably shouldn't. Hah, I am so making a talk about this. Great topic!
The community edition is rather lack luster. Sublime / Atom are a better free option if we are comparing community stuff. Point still remains, the price just isn't there right now.
For a high school senior you got a pretty good career going. :)
Maybe as a webdev it is, but for scientific purposes, there are few things it lacks that would be nice to have.
You still want if __name__ == "__main__": main() Your current implementation still executes main() if imported.
Thankyou! 
thanks...great advice..
Did you read the description? Pretty sure he was going for "play like a human" not "minimax at the 15th ply"
It's web/http auth of some kind right? Can you reverse engineer it? (with a browser's dev tools or wireshark or something) I can't find any docs documenting the protocol.
HTTPretty might work since it works on the socket level, but it's synchronous, so you'd be mixing async with sync i/o. (and httpretty doesn't support cassettes, it's more like manual stubbing) Realistically you should write your own, the asyncio stuff isn't quite mature yet. (aiohttp itself is a little rough around the edges).
Not sure if anyone else does embedded development in addition to Python, but I was very impressed with the author's [explanation of how he built the system](https://youtu.be/cItKVmoeJsw). Not sure how the esp stacks up vs the original micropython ARM board, but I think combining Python and embedded systems is an ideal setting to get people interested in physical computing
I've been writing python code for almost 15 years now and this is the first time I read about PEP-8. I guess you never really stop being a noob.
Yes, I read the description. It seemed to not play as well as a semi skilled person. 
[Here's ](http://www.pythonforbeginners.com/basics/list-comprehensions-in-python) a quick tutorial on list comprehension, the optimisation /u/ninjalemon told you about.
Seconded! I love pycharm for scientific computing. I wish it were a bit more responsive sometimes, but it is very feature rich!
Pretty neat! Since you're asking for feedback, I have one: You need comments that explain bigger concepts. Not more comments like: #Creates a 'soup' object from the page soup = BeautifulSoup(page) which is fairly obvious and not particularly useful *to me*. (By all means, include comments like that if you find them useful.) &gt; When run, the program will check what comics have already been downloaded, which at first will be 0. It will then continue to download all xKCD comics up to the most recent one. &gt; &gt; After this, whenever the program is run, it will check if any new xKCD comics have been uploaded and will then download them and launch the image in your default image-opening program. This. This is good. Stick this at the top of the file as a comment. When you come back to it a year later you have some idea of what the script is without having to figure it out. -- I'd probably sort the imports at the top alphabetically, but it's not important. In findHighestComic, you do: try: return(max(allfiles2)); except: return(0) It's safer to check for the specific exception you're expecting by doing: except ValueError: instead because max([]) raises a ValueError exception because of the empty list. In downloadComics, there's: while comicNo != -1: The way your code is currently written, it's never fires, so it's the same as writing while True: Also, theres: comicNo = -1 return comicNo break which you can just shorten it to return -1 Moreover, since you're not using the result of downloadComics, you can shorten it even further and just put: return You might look at the docopt module if you decide to add some command line args, but seeing as how you're on windows, that might not be important. You might look at adding win32api calls so you can chose a different directory, or jump to a different starting number (eg skip the first 1000 comics). Cool little program though :)
There's also [pyRserve](https://pythonhosted.org/pyRserve/)
awesome i ordered one and was looking for something like that :) 
No tool is worth the price if you don't need it. $100 for an IDE is not expensive, have you seen what Visual Studio costs?
&gt; Stick this at the top of the file as a comment. Even better, make it the module docstring.
If you are planning to share the code with other people / open source it, it is a good idea to conform to some code-style. For Python there is [PEP8](https://www.python.org/dev/peps/pep-0008/). There are tools which check it for you, like [flake8](https://pypi.python.org/pypi/flake8). Some editors do too. It's generally a good idea to try to conform to at least the basics (4 spaces for indentation instead of tabs f.ex.). Especially because indentation matters in Python. If you never share the code, then by all means, write it how you want :)
This issue of macros has been discussed to death over the last decade and a half on the python mailing list. The general consensus seems to be that it's not "pythonic". Go ahead, implement it and have fun. It could be great for certain use cases. But don't expect anyone to consider adding it to the core language. &gt;&gt;&gt; import this
yes please
Could you provide some references to the discussions?
I have tried that too but still give me errors... could them changed the website to Self-signed_certificate??
out of politeness you should sleep between requests.
http://groups.google.com/forum/#!searchin/comp.lang.python/macros http://groups.google.com/forum/#!searchin/comp.lang.python/hygienic$20macros 
Thanks.
Umm, http://wesmckinney.com/blog/high-performance-database-joins-with-pandas-dataframe-more-benchmarks/
Red Hat 7 shipped with PHP 5.4, almost a year after PHP 5.5 was released.
Looks pretty good. I wrote a similar downloader for my favourite web-comic, Achewood. Not a code critique as such, but I couldn't see any rate-limiting in your code. Am I right to think that it just downloads as fast as it can? I think that's considered to be a bit of a dick move when you're web-scraping, just adding something like `time.sleep(0.5)` in between each comic might be better.
Luke I AM YOUR FATHER!
My first web-scraping program was also an XKCD scraper. It was also the first time I programmed something outside of class for a personal motive. I had just heard about XKCD a few days earlier and I had a long airline flight in the evening. I believe this was before in air wifi (or I at least before I heard of it), so I thought I was out of luck to read XKCD through the flight. I had seen some examples of web-scraping in Python, so I through together a janky script to download the comics. I learned the hard way that there no XKCD #404...
&gt; Here's the newer version if anyone's interested: You may wish to get a github account. Swapping links is kinda 1990s. This would also give you a bug tracker and let people modify your code (you don't have to accept the modifications, of course). Stylistically, if you want to download and share code, it helps to comply with PEP8 which uses 4 spaces instead of 1 tab. Your editor can be set to insert 4 spaces each time you press tab.
Right. I meant not a plugin that needs to be downloaded separately.
There's an XKCD api fyi - https://xkcd.com/json.html
Learning a new programming language is not one of those times.
&gt; ~~Luke~~ **No** I AM YOUR FATHER! FTFY
Oh nice I had no idea there was a json interface for XKCD! When I was interested in learning Python, I built a wallpaper downloader for 4chan using their read-only JSON API. That was really interesting and way easier than parsing XML for a noob :P
If you develop OSS you can get the full edition here: https://www.jetbrains.com/buy/opensource/?product=pycharm If you develop products professionally... then either your company should be able to pay for your time or you should pay for your own tool. Almost everywhere in the Western world, one year's pycharm license is just a few hours' of work. To me it's absolute worth compared to screwing around with emacs which I've used for 10 years. 
The main issue I have with atom is how slow it feels using it, my guess is that is due to the fact that it runs in chromium. It may be better since I played with it now, but that was a huge turn off for me verses a native application. Nice to have other options though, and there are definite perks of it being OS and expandable.
Definitely, slap on Vim Jedi and it's fantastic. I've tried the ideavim plugin, which works for most normal editing tasks, but it's really buggy on macros which I use pretty regularly.
Looks great. Seems to be as simple as argh, but quite more powerful (based on my five min browsing of documentation). Would you please also add a mention to argh in your documentation?
FWIW, there's a complete and fairly simple Scheme VM implementation in Python [here](https://github.com/eliben/bobscheme). It's functional enough to run most code needed for SICP as well as implement cool things like [the Y combinator](https://github.com/eliben/bobscheme/blob/master/tests_full/testcases/ycombinator2.scm)
http://blog.datacamp.com/r-or-python-for-data-analysis/
I always think that if you've found yourself at a YouTube video, you've made a wrong turn in your search. Direct documentation from a library is probably best.
Interesting. So SQLite (with no indices, mind you) is very slightly edged out by Pandas. However, most of the SQL in my team is done on a distributed database system (Greenplum, to be specific).
Nicely done! I couldn't find support for continuations, but looking at the VM I guess that should be quite easy to add. Also couldn't see if it reuses the current stack frame for tail calls, but that should also be easy to add from looking at the VM code. I also made [one for R7RS](https://github.com/cslarsen/mickey-scheme) (code's pretty horrible, though), but it doesn't use a VM, doesn't have a collector and has quite a few bugs.
The value is being returned from MySQL using... latestTemp = cursor.fetchone() print(latestTemp) -&gt; (Decimal('23.500'),) print(type(latestTemp)) -&gt; &lt;type 'tuple'&gt;
Still playing... print(float(latestTemp[0])) seems to work okay, but why is the database returning not just the simple value?
Wow, I thought I was the only one dealing with this awkward configuration. Our windows guys have a working Powershell script to get the Auth token, and I'm thinking at this point of just running a small keyed API from a windows system as a sort of midtier to access the Wap Server to get the token and return it to our system. Seems a bit of overkill, but so far I haven't been able to connect via python directly to get the Auth token. Now I just need to figure out how to have a webserver running and have the powershell script execute as part of the API. If you figure something out to connect and authenticate directly please let me know, if my midtier solution works, I'll post the results and configuration.
Ignore that, it's a webserver for XKCD -- it doesn't give a shit about your piddly hundreds/thousand or so of requests.
Agree, would be nice. You still can use Hy, the pythonic lisp http://docs.hylang.org/en/latest/ And I got interested by Elixir, which resembles more Ruby, with macros and other functional stuff.
So even when you only select a single column, it will return a blank, dummy second one just because?
problem solved :)
No, there is no "blank, dummy second one". As per [the documentation](https://docs.python.org/3.4/tutorial/datastructures.html#tuples-and-sequences): &gt; A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. Trailing commas also work for tuples of any length. For example: In [1]: a = 1, In [2]: a Out[2]: (1,) In [3]: len(a) Out[3]: 1 In [4]: b = ("a", "b",) In [5]: b Out[5]: ('a', 'b') In [6]: len(b) Out[6]: 2
I think I follow, Python is not my first (or even second) language so I am still getting to grips with it's foibles. The main problem being because I am accomplished in another language I am trying to write complex code in this one without the background knowledge of simple programming. I'll get there. Thanks.
It's awesome you're starting off with Python! This isn't really the right place for this though. From the sidebar &gt; If you are about to ask a question, please consider /r/learnpython. 
Crap... I honestly read the sidebar. I'll delete it and post there, thanks.
I'm sorry thanks!
Other people have already directed you to /r/learnpython, which is the correct place. But I'll help you anyway, hopefully enough for you to find the answer yourself. Your error is in this line: if u_choice == "Xbox" or "PS" or "Wii": The "or" does not work the way you think it does there. `or` goes between distinct conditional statements to tie them together. `u_choice == "Xbox"` is a conditional statement which evaluates to `True` if those two items are equal. `"PS"` is a conditional statement which evaluates to `True` if the string `"PS"` is not empty. That means `"PS"` always evaluates to `True`. With that in mind, consider the following code, which is completely equivalent to your original code: if (u_choice == "Xbox") or ("PS") or ("Wii"): This `if` statement is **always true**.
This code definitely gets the job done! Curious - why did you choose to increment "b" for every letter in the text instead of measuring the length of text using len(text) like you did with len(free)?
Hi gargantuan, I just saw this message. Thanks for the good comments. In particular, I'm alarmed that part 1 can come across as dissing the Python core devs. That's completely opposite of how I view and feel about Guido and the rest. I'll look at the wording.
That guy is a legend there.
Not sure if this is what the exercise was, but list comprehension is fun anyway: &gt;&gt;&gt; s = "This is a list of words" &gt;&gt;&gt; ls = s.split(' ') # ['This', 'is', etc] &gt;&gt;&gt; li = [len(x) for x in ls] # List of lengths &gt;&gt;&gt; li [4, 2, 1, 4, 2, 5] &gt;&gt;&gt; li = map(lambda x: len(x), ls) &gt;&gt;&gt; li [4, 2, 1, 4, 2, 5]
Thanks for the hint, it was disabled because I had UML support enabled.
Which other language?
Can you explain more? I am unable to find the plugin in the plugin search or the repository.
Consider posting things like this to /r/learnpython instead. While it's certainly a nice project, and I'm sure you learned a shitload of stuff, and you have every right to be proud of what you did. But after all, it's "just" a learning project, it's really not that useful and has been done by countless other beginners before you. Also, pastie.org is not a good place to host something like this, use GitHub, GitLab, or BitBucket instead, or at least GitHub's [Gist](https://gist.github.com/) which lets you have versioning as well.
A script that monitors the data useage on my Internet connection and shuts it down when the cap is reached.
definitely this! Not only will this facilitate your code completion but also allows you to dynamically follow methods,variables,classes,imports etc to their sources and it is fully compatible with virtual environments, custom paths etc. Eclipse has plugins for all the popular forms of DVCS' providing tree level indicators of the VC status of your files. It also maintains a local revision history during all saves. PyDev has a remote debugging server and set of libraries that can be included in your application. Pydev also does code analysis of unloaded files and can be used to identify errors and warnings in your source at the tree level These are just some of my favorite reasons for using the Eclipse platform not only for PyDev but several other languages I work in as well.
Learning Kivi .Now i quit it and started Pyside.
`map(len, ls)`?
Neat. Weird, but neat. Why anybody would write new material covering Python 2 is beyond me... Oh well. It's not like more documentation is a bad thing.
Playing with https://pypi.python.org/pypi/launchpadlib/
AI nice an easy starting project would be script/command line tool which sorts wallpapers(like remove all non HD) by resolution. It is rather simple but you get to use the os module maybe shutil add some logging etc. Also a cool tutorial/book: https://automatetheboringstuff.com
&gt; For convenience, the standard streams are wrapped. You don't have to use the wrapper if you're accepting arbitrary bytes. You're missing the point. It's not that wrapped streams are bad, it's that, in practice, Py3 wraps them using the wrong encoding in extremely common scenarios, and it doesn't give you an easy way to prevent/undo that. If I could use `#!python3 -u` or `#!python3u` or `#pyioencoding: utf-8` to tell Py3 to default to UTF-8 instead of ASCII, it wouldn't be an issue. &gt; That's a strange question - why would you be doing that at all? For the same reason you want to do it with bytestrings, I guess. &gt; I don't know why the devs have refused to offer argv_bytes, but it's simple to make your own: I know. Again, you're missing the point. Py3 idioms to make it behave like Py2 are pointless when I can just use Py2 to begin with. I currently have to spend as much time dicking around with encodings in Py3 as in Py2. That needn't be the case, and it shouldn't be the case. There are still some very obviously missing features, like a solution to the ASCII-by-default problem and this: &gt; the main problem with `surrogateescapes` are that they're not given their own type. To be clear, I'm not saying that Py3 is fundamentally broken nor that Py2 is absolutely better (although it *is* better at certain tasks). What I'm saying is that in its current state, Py3 doesn't so much solve the issues (I have) with Py2 as replace them with a different set of problems (largely because it still lacks important features for dealing with its own sharp edges). Combined with the fact that Py3 doesn't (yet) offer any must-have new features vs Py2, I just don't see it as a compelling proposition in any way. The only strong argument Py3 really has going for it (IMO) is that Py2 development is winding down. 
[It's already there in the program](http://i.imgur.com/U2FY5cj.jpg), it was just disabled.
A build system for managing my browser extensions.
I find that Doug Hellmann's *Python Module of the Week* series is a great introduction to most of Python's standard libraries: [PyMOTW: Regular Expressions](http://pymotw.com/2/re/) Also, may want to try [r/learnpython](http://www.reddit.com/r/learnpython)
Using *deque* instead of an array for _values would be better for performance, no? 
No apologies are necessary and I want to be very clear that this isn't a reprimand or anything. Just a gentle guide to a place that you'll get a better answer. :) Good luck!
"The Enthusiastically Functional" one might call it.
Python regular expressions are basically Perl Regex. There are a bunch of good O'Reilly books on Regex. http://www.amazon.com/Mastering-Regular-Expressions-Jeffrey-Friedl/dp/0596528124/ref=sr_1_1?ie=UTF8&amp;qid=1431546281&amp;sr=8-1&amp;keywords=regular+expressions
#####&amp;#009; ######&amp;#009; ######&amp;#009; ####&amp;#009; **Mastering Regular Expressions** Current $34.56 High $35.01 Low $27.00 [Price History Chart and Sales Rank](http://i.imgur.com/B11Ww0u.png) | [GIF](http://i.imgur.com/6gXPgnF.gif) | [FAQ](http://www.reddit.com/r/PriceZombie/wiki/index) 
I'd be interested in seeing this on github or somewhere else if/when you get this finished and want to share :)
Out of curiosity, what is the benefit of making the downloads slower? For my purposes, I wanted the comics to download as fast as possible
It's not about whether it actually does any harm but rather about general best practices.
It's not best practice to put thread level waits in your code.
That's a totally different argument than what you said before and you're already discussing an implementation detail.
Once I get past the issues with Python and Visual Studio (VC++10 issue), I'm going to try out data analysis with ipython that everyone seems to be raging about.. 
Maybe people write tutorials for Python 2 because that's where most of the jobs are?
I hope you don't mind me nitpicking all of the code --- I had some additional code-review things here, in reply to /u/bs4h: http://www.reddit.com/r/Python/comments/35tg6b/making_a_simple_vm_interpreter_in_python/cr843nq?context=3 --- I would do constant folding like this: def constant_fold(code): """Constant-folds simple expressions like 2 3 + to 5.""" # Loop until we haven't done any optimizations. E.g., "2 3 + 5 *" will be # optimized to "5 5 *" and in the next iteration to 25. while True: # Find two consecutive numbes and an arithmetic operator for i, ops in enumerate(zip(code, code[1:], code[2:])): a, b, op = ops if isinstance(a, int) and isinstance(b, int) and op in {"+", "-", "*", "/"}: m = Machine(ops) m.run() code[i:i+3] = m.top(), print("Optimizer: Constant-folded %d%s%d to %d" % (a,op,b,result)) break else: break return code --- I would keep `dispatch_map` static, placing it in the class definition itself, and replacing each line from `"%": self.mod,` to `"%": mod,` --- In dispatch, the third indentation level is unnecessary: if op in dispatch_map: dispatch_map[op]() elif isinstance(op, int): self.push(op) # push numbers on stack elif isinstance(op, str) and op[0] == op[-1] == '"': self.push(op[1:-1]) # push quoted strings on stack else: raise RuntimeError("Unknown opcode: '%s'" % op) --- `dup` is simpler as `self.push(self.top())`. --- `println` flushes twice. I would either choose duplicating one of the lines from `print_`, or factoring that line out to a third method. --- I would personally make `parse` a generator and then just call `list(parse(source))`. --- I would wrap the stuff in `repl` inside the loop with a `try: ... except KeyboardInterrupt: pass`, that way you don't quit the REPL on Ctrl+C, but instead cancel the line you were typing, like in the python REPL.
Maybe most of the jobs are with Python 2 because not enough people really know Python 3? I don't see the value in yet another tutorial series for Python 2. There are already a bunch of really good ones. The author is just writing new material that is already out of date.
Currently working on data analytics project in python :) I would recommend spyder, but if you are comfortable with vc, that works too. Also try ipython notebook. It's a decent ide and with bokeh, it brings life to your charts. If you prefer a web based ide where you can learn and share ideas, wakari.io is great. All in all, data analysis in python is fun ;)
Whoa, by complete coincidence, [an XKCD downloader is feature in my free Python book](http://automatetheboringstuff.com/chapter11/#calibre_link-2971). (I'm glad I came up with an example that others would think is useful to do.) The book is aimed at complete beginners who don't necessary want to be software engineers but want to write code that does practical cool stuff (like the XKCD downloader). You can extend this to several other comics. I had a script that would run daily, check which comics of a list had updated, and would automatically post them to r/comics.
www.talkigy.com chat bot
Actually it is, Version 3 and ignore the pop up.
Are you saying you didn't just suggest someone put thread level waits in their code?
https://developers.google.com/edu/python/regular-expressions
Yeah, good catch. Jumps are incompatible with constant folding in this case. And because absolute instruction pointers are used at the source level, it's next to impossible to avoid. The best solution would be to keep track of the number of deleted instructions for every code address or something, but that's really hackish. Of course, jumping to absolute addresses is a bit iffy anyway.
I apologize for breaking the rules!
Coding challenge: Design and build a website where I can deliver coding challenges.
Your biggest problem will be codec support. Ogg vorbis + theora will be probably the easiest to implement. You might also be able to link to a library such as ffmpeg to get access to a vast variety of codecs. That might require a little bit of C/C++ as well. **Edit:** for a novice programmer: don't do this! Run in through a terminal/commandline instead. If you've got plenty of C/C++ experience, the above will still be tricky and some effort. *I gave it as an original answer as I was expecting OP to be looking for a fun exercise, and OP to have plenty of experience.*
Teach both. They aren't that different. Teaching 2 only makes you part of the problem.
Traceback, line 1, in &lt;module&gt; import requests ImportError: No module named requests. I've got Python 2.7.9.
“sophisticated parsing” is NOT best served by regex, it's just the most immediately available solution without abysmal performance. You did not mention any details, but pyparsing and several available PEG implementations are most probably a better fit.
This is a short write-up I did on all the alternatives to install the Python interpreter and Python applications using current tooling. The motivation is to not have to repeat the same information over and over in every project, but just give a quick installation intro and then refer to that page for details.
Thanks for good suggestions, will update later, when I get jekyll working again. Actually didn't know you could mutate slices, so that's cool. 
The requirements you've mentioned (including batch processing) are probably quicker and easier to achieve by just using ffmpeg on the command line, no Python required. ffmpeg is fairly complex and might be intimidating at first, but there's plenty of tutorials for it out there that should cover exactly what you want to do.
Thanks a ton! Will check it out. 
Author here. Good point - thank you. I'll update to address this.
There's GitHub – and no, I'm not joking. Work on one of the projects with a proven track record, proper tooling, and a sane code base, and see how your PRs *fare*. Which also gives you much more realistic feedback and learning opportunities than all those lab / ivory tower setups.
I've written several stack-based virtual machines, and the approach I tend to take is using absolute or relative jumps, but since those VMs operate on the bytecode compiled from higher level languages that isn't a problem. In your VM, you could do something with labels, which means a small change to the parsing code, and inserting a call to a function that converts labels to absolute addresses after constant folding, [like this](https://github.com/gvx/isle/blob/master/visitor.py#L7-L22), and you're done.
&gt; You're the one that brought up caseless comparison of bytestrings as a problem with Py2. [...] After all, if you want to do string comparison, you would use Unicode in Py2 &amp; 3 Well, that would be valid if: * Python 2's unicode support was actually complete * People didn't use `str` as the primary text container Neither of those are true. This means that when receiving arbitrary text, you can't decode it (because you don't know how - or even *if* - it's encoded) and even if you could you need better library support than what Python gives you anyway. &gt; you still have to normalise the strings to get a valid comparison in both Py2 &amp; Py3, which is another silly Py3 wart What, you'd want Python to automatically normalize all your text for you? &gt; Your solution—to decode them using a miraculously-known correct encoding Well, preferably you'd use the encoding defined by the protocol. &gt; I couldn't possible comment, as I don't know C++ in the slightest. Is the situation honestly comparable to Py2 vs Py3? Well, C++ is (nearly) backwards-compatible, so it's not in that sense. But the point is that needing to have new features and wanting to have new features are very different. &gt; But such is reality, and such is the shit I have to deal with in most of my code. But, as I've said, you're dealing with it in a pointlessly difficult way. Why can't you just write bytes to byte streams? 
I didn't know you were a novice programmer. In that case I don't recommend to start binding c libraries to python. Instead, you should definitely do like the others said: run ffmpeg on commandline. You can even give commandline/terminal commands in python.
I think running search-and-replace on code non-interactively is really dangerous honestly. I'd rather search and manually deal with each instance. There's a significant functional difference between this: if arbitary_expression: pass and this: pass
I actually looked into spyder briefly. It was packaged with Anaconda I believe, But it was for python 2.7. :( I actually quite like visual studio.. But the fact that it kinda ruins like an enclosed system often causes issues. I've been using it mostly for non-python programming (SQL server reporting, querying, etc). I might try uninstalling Visual Studio and try out the ipython suite (matplotlib/bokeh(so pretty),numpy). And then, for sql purposes : sqlalchemy (still need to learn). Thank you for your suggestions!! :D
I've always heard it pronounced Mat Plot Lib(rary). I looked at the documentation and couldn't find any definitive answer to this question either.
Yeah, I'll add a FAQ entry listing other argument parsers tonight.
There's no benefit to you, it's about not putting too much strain on the server you're scraping.
I say it as liberty. Maybe because is sounds like madlib.
It's short for library but pronounced as lib in liberty. In computing library gets shortened to lib all the time, like the /usr/lib/ directory in Linux/Unix and tons of libraries called libXXX; I've never heard anyone pronounce it *libe*, always libb.
Being able to use something without paying for it is not the same as free. Per the link I pasted: *Sublime Text may be downloaded and evaluated for free, however a license must be purchased for continued use*
How do you set this on pycharm, I'd like to do that. Edit: saving for later
It was a joke, I was suggesting that the first coding challenge could ironically be building a website to issue/manage coding challenges.
Or 14 upvotes and 14 downvotes
I know how to pronounce it! Sick-shin mah-hi-yay, I think.
For the psychologist? Another guy commented with name :). For the friend's stuff? I can check with him. He might be willing to put it on his website and or github (they had a c++ implementation of a game that adapted to your skill level to prolong playtime)
So the psych guy thinks of flow as the state where things aren't too hard to be unmotivating but aren't too easy to be stimulating. Check out his work, I think you'd dig it.
I had meant the friend's stuff, if possible. No need to spend lots of effort or anything on it. I don't have time to implement anything, I was just wondering if there was a theory paper or a proof of concept to read for fun and enrichment. Cheers!
Yes, I just used the term without realizing it was a thing. Glad I didn't use that in my docs.
is there a way we can recognise only thumb drives ? 
I had a similar problem with pandas. I use Anaconda, which I think is the best distribution for novices like myself, so I just updated it. That undid some of my package updates, but everything works fine now. Python 3.4. http://continuum.io/downloads
A script that downloads torrents from an RSS feed and manages them through SQLAlchemy and qBittorrent. At the moment I'm making a wrapper for the qBittorent web API (I was surprised it didn't already exist) to make the torrent handling easier, which will only take an hour or two. 
Is there some major new development in the recent past? The post is identical to an year-old post. The landscape has changed a little bit too with some reasonable improvements (Bokeh [server side], glumpy [high performance viz], spyre [R-Shiny like dashboards], and quite a few others). Here is the post by jakevdp a year ago: http://www.reddit.com/r/Python/comments/1xiqst/mpld3_bringing_matplotlib_to_the_browser/
and that is a damn shame. I sure hope it isn't true.
Liberty Wax Lips The Alamo Band-aids Las Vegas Christmas Immigrants Popeyes Democrats Republicans Sportsmanship Books
One less character: # coding=utf-8 https://www.python.org/dev/peps/pep-0263/
According to this, I should be setup correctly: http://stackoverflow.com/questions/16048237/pass-variable-between-python-scripts
This should probably be posted under /r/learnpython, but the problem is that you aren't setting api.make_call to anything (so the return value is getting lost). You want to do something like: response = api.make_call(endpoint) print response
You need to post your error. Was it "json_response not defined"? You need to catch the return value: endpoint = '/api/vehicle/v2/' + make + '/' + model + '/' + year + '/styles' response = api.make_call(endpoint) print response 
That worked, thank you. Noted on /r/learnpython. Thanks!
Do you know how this compares to bokeh?
is it still in a pastie somewhere? I think I missed the boat in getting to take a look at your code!