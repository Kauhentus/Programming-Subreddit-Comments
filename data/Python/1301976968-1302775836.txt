[pip](http://www.pip-installer.org/en/latest/installing.html) is what most people use these days to install packages. Once you install pip you can install packages from [pypi](http://pypi.python.org/pypi) with the install command and it should manage the downloads/paths/dependencies: pip install yourpackage As far as web scraping goes [BeautifulSoup](http://www.crummy.com/software/BeautifulSoup/) is pretty nice if you're scraping from HTML. For working with CSV check out the [CSV module](http://docs.python.org/library/csv.html) in the standard library. If you're looking to use R directly, [rpy2](http://rpy.sourceforge.net/rpy2.html) is a really nice wrapper for directly interacting with the R interpreter.
I'm quite new to python as well and enjoy tinkering around with it. But when I ran your code I got this error: Traceback (most recent call last): File "C:\Users\ulyssespt2\Desktop\ONO SENDAI DECK\general hax\search.py", line 42, in -toplevel- intro() File "C:\Users\ulyssespt2\Desktop\ONO SENDAI DECK\general hax\search.py", line 20, in intro print(os.name()) TypeError: 'str' object is not callable Is it a problem with *import os* or something? For the record I am running 32bit Windows 7
Thanks for the quick response! I decided to take my self post down and move it over to r/LearnPython instead of the official Python subreddit (my problems definitely aren't news). I'll look into pip - just saw they have a new version. Thanks again.
you can't run it on a windows system at the moment. i've not set it up to recognize it for windows commands. works on mac though! 
That's what I figured. Going over the [python *os* docs](http://docs.python.org/library/os.html#files-and-directories), it doesn't look too difficult to configure the processes for a windows machine. I'll give it a whirl in the AM.
lol so pip and virtualenv suddenly replace all the missing third party tools that are essential to getting cool things done quickly in python. Awesome.
Using pip for numpy causes numerous issues, and since numpy has no python dependencies, I don't really get the point of using pip in the first place in that case.
Requirement files.
will lxml work if the webpages aren't well-formed? I might be mixing it up with another module, but I vaguely recall trying to use it but failing because the html wasn't well-formed.
sometimes it isn't thaaat important but faster is always better.
Caveat: i used pip to install the new version: pip install --upgrade pip But it broke ('upgrade' uninstalls the previous version, after the uninstall, it is unable to install the new version) The trick is to use easy_install: easy_install pip Kind of ironic...
You will also need to change: &gt; os.system('ls -l') You need to use something like "os.listdir(os.getcwd())" and then format it. You can also just change that 'ls -l' to 'dir' and keep it non portable and ugly but working on windows.
I'd been hoping that something like Akka existed for Python, but my Google-fu had failed me! I shall be following the Pykka project with interest.
Maybe now it's going to be able to install matplotlib without failing all the time.
That's annoying. I'd finally settled on NetBeans as my Python IDE after almost 10 years of coding in Python. Komodo Edit has just always felt too sluggish to me so there was no way I'd be shelling out the full price for the IDE. Maybe it's time to give PyCharm a go.
Such as?
I think you're doing fine considering that you're new to Python (not to programming in general I assume). Btw, there's another nifty helper called `pylint`. Have a look at http://www.markus-gattol.name/ws/python.html#organize_modules
As a web developer I care about speed too. The apps I write have to handle many transactions per second. More efficiently or faster I can do that, the better. Caching can help in some cases but not all the time. As a web developer I use Python for QA and performance testing. Just recently I've simulated 40K simultaneous comet sessions with a Python script Python's speed determines how fancy I can get in those tests. The author of that article lacks imagination.
Made it work on Windows http://pastebin.com/AZ6vvmg9
Strange, I've `pip install -U pip` successfully before, was your original pip installed by aptitude or something? 
Good way to practice. When you become bored, read about cmd module.
That sounds quite interesting and like it will be a good community.
Do you really want me to enumerate all of the projects that have yet to be ported? The list is huge; but just off the top of my head of the stuff that I use on a semi-daily basis; twisted, tornado, django, PIL, buildout, pymongo, pycrypto, paramiko. And these are just the tip of the iceberg in my opinion. Also, I don't think we wont really see widespread adoption until PEP 3333 is implemented. Edit: We may be talking about apples and oranges here.....I may have mistaken you comment to mean that we have no excuse not to use python 3. As far as pip and virtualenv go I use them on a daily basis and love both of them along with virtualenvwrapper.
It's unfortunate many people still feel as though it's a credible source. It's commonly cited by various people regularly.
I think you meant to write "Fabioz did a great job with PyDev".
Whoa, this post is great! I'd never considered using PyPy for writing an interpreter for another language.
Few minutes of looking at README and I still don't know what this is...
But Python is faster than C. http://morepypy.blogspot.com/2011/02/pypy-faster-than-c-on-carefully-crafted.html
PyFlakes is my main excuse.
Okay. It's basically a command line script that you can use to automatically process Calibre (the ebook management tool) recipes and then distribute them to configured Kindle email addresses. If you have a Kindle, Amazon give you an email address which you can email specifically formatted documents to, and these then get delivered to your Kindle reader. In principal, it is quite simple. It runs the "ebook-convert" command (which is part of Calibre) for each of the configured recipes which produces a MOBI formatted ebook file. These files are then sent to the configured Kindle email addresses. I'm the author and I designed it for my own needs which are to: 1) Generate a Kindle version of my local newspaper sites and a few other websites (via RSS feed) from the Calibre recipes I produced for them. 2) Email those Kindle versions to my Kindle device early every morning, so when I leave for work I have a nice collection of news/articles to read that is updated every day.
FYI, it can now be installed from PyPI: sudo easy_install kindled
Django, standing by.
Cool, thanks. Maybe it's just me, but it would be cool if tornado got more visibility. Any link to your project/company?
Is anyone using Firebird and Python in production? I've looked at Firebird a number of times and always thought it looked nice, but I was never able to decide if it was something I would want to start using in larger scale.
&gt; Do you really want me to enumerate all of the projects that have yet to be ported? No, but I was hoping you might do what you just did and name a few, at least. Most people I've talked to have said that almost all the libraries they use have been ported by now so I wondered which ones you meant. Also, it wasn't clear what you meant - normally a tool is a standalone piece of software rather than a library, so I thought you meant IDEs or something. But those are some fairly important libs, I'll admit. I currently use 2.7 and my manager is suggesting for our next project that we could use 3.2 - I might try and hold back for now.
Fr some background, there were several heated discussions about this in the mailing lists. See * [[Python-Dev] PyPI comments and ratings, *really*?](http://code.activestate.com/lists/python-dev/93253/) * [[Catalog-sig] Please turn off ratings](http://code.activestate.com/lists/python-catalog-sig/3482/) -- posted by you. ;-)
Such posts should be more usual. It would be nice if PyPy devs had some time to write official documentation showing how to use PyPy to write other interpreters including the JIT.
FWIW the next post in this series will show how to add the JIT, it was split into two parts because it was too long otherwise.
No, no, and it's meaningless.
Only to warn people away from packages they shouldn't use.
Don't use nor find useful. I don't rate anything because it never occurs to me to do so. I don't use it because for common tools I know what I want--I doubt I've ever seen the sqlalchemy or django or lxml PyPI page, I just pip install and get on with it. For more esoteric things I usually search via Google instead of browsing PyPI and install whatever looks like it has better documentation.
*There is a rating feature?*
I don't browse PyPi, except when people link me there instead of a project's docs (or worse the PyPi page *is* the docs).
Works on Linux. Windows?
Two page article with zero images of pretty plots, and it's introduced by an interstitial ad to boot. Not worth the click.
Yes. I was trying to gather some user feedback without coloring the debate with my POV.
I'll be sick if i saw my code 14 years ago. It's a great therapy see how other refactor his code.
I use the [Perl-equivalent](http://cpanratings.perl.org/) and mostly find it useful when I need to choose between 2 or more similar packages. The ratings system at the Cheeseshop seems like it could be just as useful, but it doesn't appear to me that alot of people are using it (yet?). I think a ratings system would get more use if there were a separate site for it, with separate login and everything. That way: * the site could have more ratings-specific features, such as lists of highest rated packages, most-recently rated packages, most commented-on packages this year, a pass/fail kwalitee icon for packages, etc. * any user who had an opinion could pop in and be heard, and they wouldn't need a Cheeseshop account to post (the Cheeseshop is for developers of packages, but a ratings site would be primarily for *users* of packages) * *Edit (addition):* the package's README (main Cheeseshop package page) wouldn't get clogged up with package review discussion. The way I see it: * the Cheeseshop is basically an online database of packages for pip to talk to (well, and also where you can see a package's README) * `http://packages.python.org/{package-name}` ([example](http://packages.python.org/distribute/)) is where I'd prefer to read the docs for {package-name} (rather than having them all crammed into the README on the package's main Cheeseshop page) * package ratings/review/discussion site should be separate from both of those 
nope
Do you mean you actually believed Alex Gaynor when he wrote this? &gt; It's also not possible to send any messages once your ticket has been marked as closed, meaning to dispute a decision you basically need to pray the maintainer reopens it for some reason. *Somehow* Alex Gaynor forgot to tell you about the public discussion forum http://alioth.debian.org/forum/forum.php?forum_id=999 Alex Gaynor put stuff in his blog - putting stuff in a blog doesn't make it into The Truth.
It's unfortunate many people believe whatever someone writes on a blog.
Very cool thanks!
&gt; and then suppressing further debate Obviously your opinion isn't being suppressed here. Obviously your opinion wasn't suppressed on Hacker News. And nothings been done to stop you posting in the benchmarks game discussion forum or commenting in the benchmarks game tracker. Yesterday, [on Hacker News](http://news.ycombinator.com/item?id=2407294), I asked you to show that there's some substance behind your "suppressing further debate" accusation - you aren't able to because your accusation isn't true.
Interesting, thanks. Is [BeautifulSoup](http://www.crummy.com/software/BeautifulSoup/) generally a good way to parse webpages?
I'm waiting for the day the PyPy toolchain does for languages what WSGI did for web frameworks. If the barrier of experimenting with language design gets really low, I think we'll see pretty interesting things.
I find it useful in the case that the "maintainer" has abandoned the package. Other users can leave comments stating if it does or does not still work without having to download/install it.
broken link. just cycles between .../pystack and .../#pystack
I lost interest in Tornado when I learned more about Twisted and gevent. This is mainly because Tornado seems limited to HTTP and gevent/twisted are more generic. Based on some other comments here I might be wrong about Tornado.
not sure about rotten tomatoes, but screen scraping is against IMDB's [TOS](http://www.imdb.com/help/show_article?conditions). It's unfortunate they don't provide a proper API, but that's what we have to deal with. Better to use something like [TheMovieDB](http://www.themoviedb.org/). They have a [full-featured API](http://api.themoviedb.org/2.1) that will get you whatever info you need (incl. ratings), in various formats (yaml,json or xml). **edit:** turns out Rotten Tomatoes [also has an API](http://developer.rottentomatoes.com/docs). 
With a name like CloudRoulette I expect a service that will randomly decide where to host your code and then show you a penis.
What's the result supposed to be? I haven't tried to run it. A result close to 0 is good?
I think reviews can be helpful, but ratings are generally worthless. A good tool either speaks for itself or to your niche requirement or has vocal proponents. I'm more interested in statistics about downloads and updates and seeing a list of unresolved issues/bugs.
This is super useful for Jython. I think eventually this functionality should go into pip itself
What if I'd say: "Yes, 0 is good."? ;-) My rough understanding (let's call it "guessing") of what he's doing is (based on an grey scale image): 1) Calculate the difference of the color value for each pixel. If the pixels have the same color, this is 0. Max difference is 255 for one black and one white pixel. These differences are stored in an new image. 2) Create the histogramm. Identical images would have an histogram with all pixels at 0. 100 % different images (imagine one black and one white) would have all pixels at 255 as the diff_image would be all white. 3) Then he's weighting the number of occurrences in the histogram by the square of the color scale. To me, this step is a bit arbitrary. Could he use a linear weighting as well? Don't know... 4) Then he's normalizing the data by the the numbers of total pixels and finally calulating the sqare root. So, if the images are 100 % identical, the diff_image would be black, the histogram would be "all pixels at zero" and the total result would be zero. If the images are one black and the other white (max diff), the diff_image would be all white and the result would be 255. 
I tried it with two identical images but instead of 0 I got 572.43... The histogram contains 768 elements (3 * 256 in RGB images) but three of them are non-zero. Is it normal?
I'll give a try if and only if Python releases with a PyPI GUI client and it looks like App Store
Telling us about a new visualization tool without showing any of the stuff it visualizes? Somebody need to take a marketing class or something. Or maybe just get some common sense. I'll see if I can get it to work and post a few screenshots a little later on (unless somebody else is faster than me) EDIT: [There you go.](http://imgur.com/a/Hw0Sx) Seems like a pretty vanilla plotting lib, fairly nice, but doesn't have any interactive features or such as gnuplot (not really a surprise there, though). Development seems kinda abandoned, though.
yea. [Scrapy](http://www.scrapy.org) is also cool
I didn't even know that PyPI has a rating system, and I've never found the PyPI pages useful for more than looking for a link to the projects documentation. I am eagerly awaiting the launch of Python Packages, though. I use [Django Packages](http://djangopackages.com/) all the time.
In regards to (3), he's calculating the [Root Mean Square](http://en.wikipedia.org/wiki/Root_mean_square) of the differences as it's a commonly accepted measure of error or difference. He could have used linear weighting as well, assuming he took the absolute value of the differences.
what's the algorithm of tineye.com?
Never did.
I used to write everything in assembly. now I prefer Python code like this, not tested: def rmsdiff(im1, im2): diff = ImageChops.difference(im1, im2) hist = diff.histogram() width, height = im1.size area = width * height squares = [value*(index**2) for index, value in enumerate(hist)] rms = math.sqrt(sum(squares)/area) return rms 
Let me guess: They normalize the histogram (like in this script) and via a hash-function generate a lookup-key. If you upload an image, this key gets generated and they look in their database for previously found images with the same key, done.
Well he goes by saying result of 0 is close enough. He's coming from a web image standpoint, where strict accuracy isn't all that important. I'm thinking from a technical rendering standpoint that if you want to compare two images together, saying you changed code in your rendering shaders and you want to compare the results of your test image. Having the image produce a 0 result would be a good thing, anything off that would be considered a bad result. Or, maybe some level of variation like .0135 is acceptable.
If you can’t wait for the next special issue, you can try this script to put together the complete FCM Python tutorial series: https://github.com/jabbalaci/Full-Circle-Magazine-Series .
the algorithm IS the hash function, but what's the hash function?
Making people use the form feed character is one way to ensure no one will ever use this server.
I do not participate, so no I was unaware of the forum, but that's still not rectifying the problem.
Any thoughts on the correctness of having the constructor trigger the main process? Is this a normal method?
I'm all for it. Every download, book, video, music, etc. website has ratings and people find them useful. So I don't see why it wouldn't be useful here, I certainly think it is. 
I used LPTHW and would gladly have paid a dollar or two for it. Especially if there was a teaser version with the first 5 lessons in it available for free.
I prefer to watch directly from [blip.tv](http://blip.tv/file/4878885)
I think you can separate the 'algorithm' from the 'hash function' here. Algorithm ====== Let's say you divide each pic to 9 areas and take the average color from each sector. Put the colors in to web-hex-colors 000000-FFFFFF so you now have a 6*9=54 character string which identifies this picture. Now you want to easily find pictures who match this pattern. Hash function ========= You can use a hash table for quick lookup of the 54 character string. So the hash table could use md5 for example. 
That sounds pretty neat.
As much as I like the idea of putting control characters to good use, this is true. Also, I thought this would be some kind of code generation tool, not a template framework.
Twitter is the new RSS?
I guess you can start counting the number of downloads for kinterbasdb on sourceforge http://sourceforge.net/projects/firebird/files/firebird-python/kinterbasdb%203.3/ also there is debian popcorn http://qa.debian.org/popcon.php?package=python-kinterbasdb of course there are other distros but it can give you a starting point , i use mainly django 1.3 and firebird 2.5 (there is a branch for 1.3) http://groups.google.com/group/django-firebird-dev/browse_frm/thread/4b76037db14c7928
 import re,sys for line in sys.stdin: print re.sub('\. (\w)',r'. \1',line) $ python pep8.py &lt; pep-draft.txt &gt; pep-final.txt
&gt; A feed of questions from Stack Overflow tagged Python that meet **some criteria**. Aiming for 12 tweets a day. *What* criteria?
As I understand, two spaces after a period is an artifact of typewriting. Since code uses monospaced fonts like typewriting, you still see double spaces in use sometimes. Word processors expect single space, but the good fonts know to add a little extra space in there.
I didn't read the "Zed" and thought you were talking about Shaw's the grocery store. Was really confused for a minute.
I've been going through this for a couple weeks and it's easily the best programming tutorial I've ever read.
I've been told, as you say, that monospaces fonts (which most of us use for programming) need two spaces, and that proportional fonts only need 1 space. I frequently argue with co-authors about this.
That's a string hash, I'm saying a picture hash
Yea, I wish people didn't jump to conclusions so quickly. It'd be nice if this wasn't so publicly announced in the way it was too. While I personally don't agree with all the rules (as I've mentioned on the forums in regards to using gmp), I accept they are your rules to make. I've tried to follow them the best I can.
&gt; each sentence should end in a period # It seems so # unpythonic # Why not # stick with # meaningful whitespace 
&gt; It's also not possible to send any messages once your ticket has been marked as closed, meaning to dispute a decision you basically need to pray the maintainer reopens it for some reason. Truth: you can add comments to your ticket that has been closed and that does trigger email messages, meaning to dispute a decision you basically just need to add a comment. Alex Gaynor put stuff in his blog - putting stuff in a blog doesn't make it into The Truth.
No sound here, but that gray beard really brings across authority. :)
&gt; "Oh cool, a Python tutorial that every one has been praising" &gt; "Better save it for later use" &gt; A few months later "Where did I put that Python tutorial? Oh well better download it again!" **Repeat x5**
Yes, using it everyday, and now have plenty of topical stuff to read each day on my commute to and from work. 
I think IMDB does publish their database as some sort of flat-text files. I remember grabbing copies a couple years back, and they were ugly, but usable. Ah-- [here it is](http://www.imdb.com/interfaces)
Then I concede my point.
Strunk and White? Yuck.
Proudly downloaded, would've gladly paid a few bucks for such quality material
Strunk and White prescribe one space after a sentence ending period. The linked page has the contradiction affliction.
I've never done this and I don't plan on starting. Take that, PEP-8!
Probably accounts for some of the downloads for sure. I've downloaded it 3 times now.
I do this all the time, and it really irks me when text fields on web pages erase the second space.
There's probably a clever way to do it with string formatting but this will work: import math def frexp10(x): ex = int(math.log10(x)) return x / 10**ex, ex def tolatex(n): return "$ %f \times 10^%i $" % frexp10(n) On a side note the [Decimal](http://docs.python.org/library/decimal.html) library is generally very handy for working with sig figs and formatting.
71 slides ... his talk was either 4 hours long or he probably barely made it onto slide 20 or so. It's a common mistake people make when they start doing talks, happened to me too :-) 
Q. Do you put a comma before the word unless in a sentence? A. Do NOT put a comma before subordinating conjunctions such as unless, if or because. http://wiki.answers.com/Q/Do_you_put_a_comma_before_the_word_unless_in_a_sentence
I enjoyed LPTHW -- and I was actually in your tutorial session at PyCon this year, and I thought it was pretty good, though I think it was a little slow-rolling to get to important basics like control structures during the time alloted. 
These tutorials are cool. Really nice series. A question: why does compiling the simple BF interpreter, which is less than 100 lines of code, take on the order of 8 minutes? My suspicion is that there are other chunks of PyPy being compiled (or whatever). If PyPy really aims to be a toolkit like this, wouldn't it be better to cache these reusable PyPy chunks to get compile times down?
That's a little hypocritical given the first rule listed.
Does pylint test for this?
You can pay here (and get help from Zed) http://www.udemy.com/learn-python-the-hard-way/
Thanks for the quick response! I'll give these a try and check out the Decimal library.
I'd like to see similar books that cover other programming languages. I wish for a LHTHW book, where H stands for Haskell. Since there was some tension with that Ruby clone, I hope Zed will write the Haskell book himself.
Because the whole JIT is being compiled (as well as the GC). Also those parts are nto static, they depend (at least a bit) on the input code. Also if you use PyPy (the python interpreter) for compilation it actually takes less time :)
71 pages of 2-up slides, so it's actually 142. Also, there's a bunch of _really_ cool examples in there.
Seems like [Neal Stephenson](http://www.buecher-wiki.de/uploads/BuecherWiki/stephenson_neal_peter-von-felbert.jpg) has become a fashion model.
it also recommends strunk and white, which is bloody awful. don't take it too seriously.
small change: I changed the line: ex = int(math.log10(x)) to ex = int(math.floor(math.log10(math.fabs(x)))) This fixes an issue with negative inputs throwing an exception and negative exponents returning values like '0.12 \times 10^-4' instead of '1.2 \times 10^-5' 
I don't know about 2008, but when I [saw David Beazley speak](http://pycon.blip.tv/file/4878868/) at PyCon this year, he was no amateur.
But why not use a book from 1918 as a style guideline for 21st century cutting edge dynamic programming languages? &gt; In the Boston Globe newspaper's review of The Elements of Style Illustrated (2005) edition describes the writing manual as an "aging zombie of a book . . . a hodgepodge, its now-antiquated pet peeves jostling for space with 1970s taboos and 1990s computer advice." &gt; *-Wikipedia* Oh yes, forgot about that for a moment...
Good call.
 perl -pe "s/\. (\S)/. $1/g;" &lt; pep-draft.txt &gt; pep-final.txt :-) 
Don't see how it's involved. Everything's in macports, just install each (with python_select) and away you go. python27 @2.7.1 (lang) An interpreted, object-oriented programming language py27-matplotlib @1.0.1 (python, graphics, math) matlab-like syntax for creating plots in python py27-ipython @0.10.1 (python) An enhanced Interactive Python shell It's all there, and makes it a little easier to flip between differing python versions. 
You don't need to read that answer url, unless you really want to then it's okay.
I am also interested in an answer to this. Also, does anyone have suggestions for good packages to sequence midi?
They don't, HTML however allows as much whitespace in between words as you would ever want. For example I just held down space between "for" and "example" and that whitespace doesn't show up on your screen, but it is there when you view the source.
Won't be the first PEP-8 doctrine I ignore... tabs FTW =P
If you're typesetting it professionally, a system like LaTeX will take care of that detail for you anyway, won't it? Kind of a moot point, then. Except I'm not sure if it would handle the monospace issue properly. (Or at all, really.)
Do you think he wrote a generator to access each of his slides? ;)
Get your torches and pitchforks ready - I mix [tabs](http://vim.wikia.com/wiki/Indent_with_tabs,_align_with_spaces) and [spaces](http://www.emacswiki.org/emacs/SmartTabs)!
if this works my prayers for today have been answered
Exactly. Fuck it. I'm buying a dead-tree version. Is there a happy birthday coupon code for /r/python? Just think I should ask before I click ... really, I have to join LuLu to purchase. I'm so sick of joining every place all the time. Sigh. Not your fault, I know. sorry, don't mean to complain. 
_Begone, vile demon!_
 s/^\s+//; Run your code now! &lt;insert evil laugh&gt;
&gt; Interested in learning Python? &gt; [/r/learnpython](http://www.reddit.com/r/learnpython) PS. Maybe read [one](http://www.swaroopch.com/notes/Python) of [these](http://learnpythonthehardway.org/index)? 
Python is the first language I've used where I think it really does make sense to use tab characters. I'm with you.
Unfortunately CairoPlot hasn't seen a commit to its code since [July 2008](http://bazaar.launchpad.net/~alf-rodrigo/cairoplot/trunk/files) :(
3rd interested. Also, if there isn't anything good, I'd be more than willing to contribute to something.
&gt; Don't use it on the internet, there's a whole bunch of asserts and it'll blow up FFFFFUUUUU
Uhh, David was a college professor and teaches classes and speaks professional, he didn't just start doing talks.
Huh? Why not take a look at them, see how much you know already and jump in at that point.
[Csound](http://www.csounds.com/) has python embedded. Nevertheless python is not used to define the various synthesis instruments, but you could write the score using python or any other programming language for that matter. [Supercollider](http://supercollider.sourceforge.net/) is a functional composition language for audio synthesis and composition, but to use it you have to learn a new programming language: supercollider. There are other [similar programs](http://en.wikipedia.org/wiki/Audio_programming_language) as well. 
Check the data you are sending when you hit submit. From what I can tell, you are either sending something invalid or missing some piece of data and getting the 500 error. You could compare what mechanize has in its memory right before the submit to a log captured by wireshark using your real browser.
This was for a PyCon tutorial, not a first-time talk (from a person who travels the world teaching week-long courses).
NOO!! I Fight thee back with -tt !
Sorry, there is a bug in the dependency management lookup. I will fix it asap.
I sent you a pull request thanx
Try http://seleniumhq.org/ : Runs in the browser, and therefore there won't be any javascript related problems. You can use the firefox plugin to do some tests, and then export those tests as python scripts.
Exactly. Tabs semantically mean indentation. It's what they're *for*. Some people like 3 spaces worth of indent, some like 4. Some are insane and like 8. All you have to do is set your tabstop. Plus, tab-indented code has smaller file sizes, which is super important under certain specific and very rare circumstances.
Holy shit- $250? I was hoping for a small donate button where I could give an arbitrary amount. Am I missing something?
good shit this is....
The only reason I didn't stop listening at the moment I heard him drop that little caveat was because I was in the middle of a 10 hour drive...
LaTeX sort of takes care of it for you. A period followed by space (it doesn't care how much or what type) is usually assumed to be the end of a sentence, unless the preceding character was upper-case (which LaTeX thinks is an initial). Things like "Dr." or sentences ending with "SPAM" break this, and you have to use explicit markup to correct it. It's kind of a pain in the ass. It doesn't necessarily use extra space between sentences, though (and the amount of extra space is less than double the inter-word space). It depends on settings. \frenchspacing, for example, turns off the extra space.
[Try this!](http://tinyurl.com/b4dglr)
fixed, thank you for your helpful patch
Strunk and White is fucking overrated, and people should stop treating it like gospel. There, I said it. That said, using two spaces after periods is silly. 
These are exactly the versions in the current [EPD](http://www.enthought.com/products/epd.php)
hell, even _word_ does this. If you put one space after, it can automatically turn it into a double-size space depending on taste. So the **only** reason you might ever need to actually type two spaces is in things like python comments, assuming you want them I've no idea how good word is with ambiguous arrangements like your other replier described; offhand I'd expect it to be worse than LaTeX ;)
you don't need to read that answer url unless you really want to. Then it's okay.
Thanks, I didn't know about these APIs. As I saw, you need to register to get an API key. 
You may tell me how to layout my code. But you may not tell me how to write my first language. NO H8!
I knew that it existed, but disappointed that nobody is using it. It is a very important feature for me. Fortunately, I heard that Python Packages is going to address this problem. I hope it gains acceptance.
Heh, I just did this exact thing. Turns out, in typography, the double space after a period is evil, but in plain text (sort of the source code of text) its needed to distinguish between abbreviations (like e.g.) and an actual end of sentence. If they are both single space, tools (e.g. a text editor) can't tell the difference and will screw up paragraph filling and whatnot.
Maybe buy the ebook version? https://www.lulu.com/commerce/index.php?fBuyContent=9619669
Learn python before picking up GUI knowledge. I suggest started with "learn python the hard way", its a free online book geared for python newbies. Good luck!
It's my first ever Python script. I'm still working on improving it
Nope. It was a stupid mistake on my part. Still learning python.
The best resources I've found: http://code.google.com/edu/languages/google-python-class/ http://diveintopython.org/ or http://diveintopython3.org/ depending on which way you want to go (it doesn't really matter, the difference are minor). After that the only way to really learn a language is to write something.
Not to take your joke too seriously, but... man python &gt;-t: Issue a warning when a source file mixes tabs and spaces for indentation in a way that makes it depend on the worth of a tab expressed in spaces. Issue an error when the option is given twice. "Tabs for indentation, spaces for alignment" does *not* actually suffer from this problem, and that's why I like it! =)
The best resources I've found: http://code.google.com/edu/languages/google-python-class/ http://diveintopython.org/ or http://diveintopython3.org/ depending on which way you want to go (it doesn't really matter, the difference are minor, but for what you want to do 2 might be better since it has better library support).
Wow, so much intellectually dishonest and specious argument in that thread. As just a humble user of PyPi, I don't see how anybody can say with a straight face that they can't see any usefulness at all in ratings, as if it conveys no information to me as a user to see a package that has only 5 0-star reviews or a package that has 6 reviews averaging 4-stars (out of 5). The really galling thing is that the comments are what really make a ratings system useful, and it's the same people who were most vociferous about eliminating ratings altogether who ensured that comments became disableable by package maintainers. Their arguments against ratings and reviews at the PyPI work for Amazon and Reddit as well. Surely book authors should be able to disable leaving comments in their book reviews, and surely if comments are disallowed by most authors, then ratings will be useless, and surely it follows that ratings and reviews should be scraped altogether.
The reason why Strunk and White prescribe one space after a period is because spaces in proportional-width fonts have adequate width with just one space. Python (and code in general) is typically written with a monospaced font. The rule does not apply to monospaced fonts, where you are supposed to use two spaces, like on a typewriter.
Words like dr., ms., mr. etc. are not that numerous. Latex should keep track of them.
Good examples for n00bs, but IMO it's not black magic but common Python idioms
Yes, I have used ratings and I think they do provide value. If I'm writing a quick-and-dirty script that I'll spend an hour or so on, and there are 5 packages that all seem to do the same thing, it is immensely helpful to me to be able to distinguish between the ones that have lots of good ratings and those that have no rating or mostly low ratings. I do not want to spend 2 hours downloading 5 different packages and testing them when I might never use the package again and am only spending an hour on writing the script itself, nor should I have to. Ratings with reviews are much better than ratings alone, but many package maintainers disabled comments (the ability to disable comments seems to have been very much desired by them but not by normal users like me, who would prefer that maintainers of poor quality software can't silence people who would make others aware of problems with their software).
I'm definitely planning on learning python first without GUI
I understand JIT can be produce fast code due to runtime information. In the case of Python, in which situations are speedups to be expected and in which situations not (or a slowdown)? Edit: Clarified that I mean Python.
That depends on your target language. Are you asking about brainfuck (in which case my answer is: no idea :)), or Python, or something else entirely?
http://i.imgur.com/1pIej.png
Python! Sorry for the fuzzyness. :)
Try "Hello World!" by Warren D. Sande: http://www.manning.com/sande/
I think the capitalization of the beginning of the next sentence would be a dead giveaway. You hardly, if ever, end a sentence with an abbreviation.
I have had very little luck at synthesizing audio with Python, but Supercollider is perfect for the job. I would just learn it and do your project in that. But be warned, Supercollider's big weakness is deployment.
You should probably filter out the 206 responses (partial-content). Acrobat reader does many range http requests when viewing a pdf
If you already know programming basics, you can read [Byte of Python](http://www.swaroopch.com/notes/Python), but that's only if you know what variables, functions, classes and methods (among others) are...
I think the final coffin nail has been the observation that 99% of the packages were either unrated or rated exactly once, which indicates that the feature was essentially unused. &gt; Their arguments against ratings and reviews at the PyPI work for Amazon and Reddit as well. Well, reddit ratings make no difference or even have opposite effects than intended. Often the biggest threads with the most child comments evolve on comments with a `-4` rating and below. So they are particular noteworthy, no matter what the reddit policy tells. Attention cannot be steered well this way. Amazon reviews or proper code/usability reviews are an entirely different affair. I would consider a code review as a project contribution, even though no code may be shipped, just review comments and a usability review is more than most package developers can even hope for.
One idea I saw in that thread that I *do* want is some kind of "I use this" count.
A point and a space are already much wider in monospace fonts. Why add one more space?
Downloads. Anything more would require participation from downloaders and I'm talking social icon / email confirmation requirements.
So should pypi include facebook "like" buttons?
Decorators seem similar to advising Emacs Lisp functions.
lol fair enough!
Actually it's just the opposite. A monospaced font's letters and characters each occupy the same amount of horizontal space. So a '. ' has enough reserved space on the right to make it readable without adding a second space. EDIT: [Here's an example](http://i.imgur.com/ntQRB.png) and [here are fixed and variable width with one and two spaces in word](http://i.imgur.com/BOyoa.png).
&gt; David was a college professor and teaches classes and speaks professional, I wouldn't know David Beazley from Adam, but I spend a lot of time with college professors who teach classes and speak professionally. And—well—as far as giving skillful, engaging talks, that counts for less than you'd think. ;)
I think it is misleading to call that duck typing. Python is strongly-typed so there will never be confusion concerning types. The only thing that is demonstrated is that implementing the getitem and setitem methods allows your objects to use the same syntactic sugar as dicts, other than that, it has nothing at all to do with a dictionary or with the type dict -- otherwise you'd need to explicitly inherit from UserDict and that is not duck typing.
How is this black magic? I would expect any Python developer to be familiar with constructs that are mentioned in any Python book.
That code is hard to read. The author should put some newlines in it.
Trying to deduce what the writer *actually* meant to type is what makes Word such a pain in the ass to use. Because in the end, it can't. For example, I can end a sentence with etc.
http://i.imgur.com/ntQRB.png
fuck your font.
What does 3 mean? There's your answer for the usefulness of a numerical rating.
Not just overrated; it's illogical, arbitrary, and self-contradictory. Yeah that is an oxford comma. Deal with it. 
If I used this I'm really not looking forward to patching events generated by PyGame across to supercollider...
I'm not sure this: some_list = [1,2,3,4,5] another_list = [9,8,7,6,5] added_squares = [x**2 + y**2 for x in some_list for y in another_list] print added_squares Will do what the author intended. &gt;&gt;&gt; some_list = [1,2,3,4,5] &gt;&gt;&gt; another_list = [9,8,7,6,5] &gt;&gt;&gt; added_squares1 = [x**2 + y**2 for x in some_list for y in another_list] &gt;&gt;&gt; print added_squares1 [82, 65, 50, 37, 26, 85, 68, 53, 40, 29, 90, 73, 58, 45, 34, 97, 80, 65, 52, 41, 106, 89, 74, 61, 50] &gt;&gt;&gt; added_squares2 = [x**2 + y**2 for x,y in zip(some_list, another_list)] &gt;&gt;&gt; print added_squares2 [82, 68, 58, 52, 50] Doing `for i in x for j in y` in a list comprehension is like nesting `for` loops, so the inner loop gets run in its entirety for EACH member of the outer loop. Zipping the iterables together to get 2-tuples works as expected.
I don't know what that guy was talking about, all of those things are doable in Perl. How dare he assume that his friend would not be familiar with those concepts because he uses Perl. Haters gon' hate. 
If you've been involved in the python community for any significant length of time, you should know about [David Beazley](http://www.dabeaz.com/). He wrote the [Python Essential Reference](http://www.dabeaz.com/per.html), and is generally pretty active at pycon.
Wait for the page to load completely. At least in Chrome, the code boxes are formatted then. Don't ask me why.
You'll get the wins doing the things where Python has the most overhead, basic math stuff, reading an attribute off something, calling a function, etc. You won't get big wins if you're really going all out with the dynamic stuff (think `getattr(my_obj, some_runtime_field)` in the middle of your hot loop, and you'll get slowdowns if you're actually calling `sys._getframe()` all over the place.
I think LPTHW might be too beginner for the OP. It's a good resource, but it's designed for people who are new to programming. 
yes they do. The format is not very friendly though. 
This is one of the few metrics I actually look at when choosing a library. More downloads means more people having used and tested a lib. The ratings are basically meaningless. 
Sorry about that... I (author of the post) haven't found a good way to create syntax highlighting on tumblr pages without a lot of work to coordinate the creation of github gists or something similar. As Nimbal suggests, give it a sec. Make sure you have Javascript enabled too.
I think this is incorrect. Python is strongly-typed, but it is also a dynamic language. The distinction is subtle. Here is python.org elaborating on this issue: http://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language
[mingus](http://code.google.com/p/mingus/) can sequence midi and connect to fluidSynth.
Sorry! I wasn't clear in saying that my friend had only used Perl for basic systems glue. I agree that Perl is a powerful language. Didn't mean to hate on it!
What kind of synthesis are you trying to do? If it's algorithmic sound-from-scratch type stuff supercollider is the best tool. but If just need to play back samples at various times, then PySonic might be a good choice. It's a wrapper for FMOD, a sound library commonly used in games. It also lets you play sounds at positions in 3D space. Engine noises can be made my looping a short sample and varying the speed. FMOD can do that (as well as play things backwards if you give it a negative speed)
http://www.pythonlearn.com/ is good as well.
This is a bit like the Oxford comma. It may have served a purpose at some point, but today, it's personal preference.
Good luck properly indenting a long argument list, then.
I still don't understand duck typing :-(
Because it looks weird without them. It's not the actual spacing that matters; it's that you can pick out the sentence boundaries easily. For some reason, that seems harder in typewriter font without the double space.
The duck typing example wasn't a very good one, in my opinion. All the author did was create an object that behaved like a dict, and then showed that it behaved like a dict. Duck typing essentially means that if you have code that expects a dict, it can actually use anything that acts like a dict. So if I have a function like the following, which expects a dict: def default(d): return d['default'] I can pass it any item that supports dict-like access (via `__getitem__()`). So I could have the following class, which behaves like a dict, and my function will work on it. class FortyTwo(object): def __getitem__(self, key): if key == 'default': return 42 else: return 0 and I can use my `default()` function on it. &gt;&gt;&gt; default(FortyTwo()) 42 It's so obvious it almost doesn't seem worth mentioning, but some languages would require your class to be an actual subclass of `dict` in order for that code to work.
Thank you for this explanation, it's very clear and concise. I've tried to read about duck typing before, but the explanations don't usually progress beyond "If it quacks, it's a duck".
If I were you I would submit a message to the mechanize mailing list. I've had problems before and gone that route, and gotten the head developer to respond within a day or two.
This is awesome. Would you mind posting that to my blog's comments to share the knowledge there too?
[Michael Bayer's announcement](http://groups.google.com/group/mako-discuss/browse_thread/thread/2c7885ff4958b8e4).
It's great to see the development continue on this project. I use Mako on almost a daily basis and love it's flexibility and speed.
Amazon and Reddit have a large community that oversees the ratings to make sure that small blips of noise are smoothed out by the tide of consensus. When a project having 3 ratings is 99th percentile, the SNR is just useless. PyPI is not in a position to bootstrap such a community, so there was little hope of seeing this state improve.
&gt; French law compliant Django What part of regular Django isn't French law compliant?
This is pretty amazing (and long overdue!). It's absolutely correct that the current methods are rather ugly: try: os.remove(filename) except OSError as e: if e.errno != errno.ENOENT: raise
Come up with a project, learn what you need to complete the project, repeat. Read about how to do things the "right way" after you have tried on your own for a while, that way you will appreciate why it is the right way.
I know what strongly-typed and dynamic mean, nothing in my post contradicted that. My claim is simply that Python has no duck-typing, instead of determining the type of something by its operations it uses the type it has stored for something (strongly typed) -- and indeed this type can change because Python is dynamic but that is irrelevant. At runtime the type is always known and strict.
The details are in the section you quoted.
http://en.wikipedia.org/wiki/Duck_typing#In_Python
OK, I guess why I was confused is that duck typing is something the programmer does, it's not really part of the language. The programmer can design functions and classes to do duck typing by not checking types but just hoping that certain methods will be available. So duck typing is just an amount of freedom given by the language because it doesn't check types, and exploiting this freedom to get a crude form of polymorphism. Still though, in your example you add the getitem and setitem methods, which are used by dictionaries and lists and such. That is not ducktyping (yet), because doing foo[bar] is just syntactic sugar for foo.getitem(bar). It would be ducktyping if you pass such an object to a function that expects a dictionary but you fool it with your object that looks like one.
Oh thank god. I've been maintaining a little library to "adapt" IOError/OSError subclasses into finer grained exceptions, and it's been a pain just to maintain the subset i'm mapping. Soon, there's going to be enough things in python 3.x that I *have* to move my apps to it :) I just hope they modify it to include some of the common redundant WindowsError numbers as well.
I guess my question was really more about French law than about Django. So...French law disallows common sense, then? ;) Seriously, though, French law disallows hashing of passwords? What does that mean, exactly? Are there any good blog posts (google translatable) explaining it?
Ceci n'est pas un poisson d'avril.
[BBC seems to think so.](/gkl77) [Reddit commenter with (claimed) experience in French law doesn't.](http://www.reddit.com/r/programming/comments/gkl77/hashed_passwords_outlawed_in_france/c1o883f)
Blocks, YES! Thank you!
There are some abbreviations that frequently occur at the end of a sentence: et al., a.m. and p.m., etc., etc.
You've just unleashed one of the big holy wars in typing.
A lot of Google is done with Python. (Guido van Rossum works at Google.) Pretty much all of YouTube was originally done with Python. Lots of websites use Python.
Trying to name everyone who uses Python would be impossible, but I'd start by looking at who sponsors PyCon and DjangoCon: http://us.pycon.org/2011/home/ http://djangocon.us./
python is everywhere. It's within [the top 10 most popular programming on langpop](http://langpop.com/#normalized). Some companies using python: Google, CCP Games (Eve Online), Dropbox, Disqus, Threadless, SourceForge... Some more: [Organizations using python](http://wiki.python.org/moin/OrganizationsUsingPython) 
Well.. [reddit](http://www.reddit.com/help/faq#Whatisredditwrittenin) does. 
[Abaqus](http://www.simulia.com/products/abaqus_fea.html).
A company by the name of esri (http://www.esri.com/) uses it as the primary scripting engine for their line of desktop and server products. Python has gradually edged out VBA over the past few major revisions and will be the only option by the next major release (later this year).
[Eve Online](http://www.tentonhammer.com/node/10044)
python osmosis is great and the videos are titled well, and most are fairly concise. http://www.youtube.com/user/ryanmshea
Python.org does have a [success stories section](http://www.python.org/about/success/). Edit: Also [this list](http://wiki.python.org/moin/OrganizationsUsingPython). In reality, it's all over the place.. academia, national labs (including in high performance computing) and in industry just about everywhere one can imagine. It's not as high profile or maybe as widely used as Java in industry, but it's definitely up there.
My company...
rack
Uh... a *lot* of people in finance use it. Java and C++ are still dominant there but tides are changing. It's gaining quite a lot of momentum on the scientific computation side of things.
have you actually touched pyOpenGL? if not, I would recommend [pyglet](http://www.pyglet.org/), and [gletools](http://hg.codeflow.org/gletools)[1] plus this [tutorial](http://www.arcsynthesis.org/gltut/) (sorry C(++))[2] and my [code](https://github.com/YellowOnion/opglex/blob/master/nehe-1.py)[3] [1] this has a bz2/gz file at the top that will compress latest hg, and pyglet may need the latest hg to run gletools [2] this is in C++ but is great, and it doesn't use any of the deprecated function of OpenGL which are in my opinion a waste of your time, since you'll eventually learn these anyway [3] this isnt' nehe as the name might suggest, just was too lazy to actually rename it after finding nehe was terrible to learn OpenGL 3.x/4.x plus the Twisted reactor is easy to remove if you don't want to download twisted (actually kinda embarrassed about using twisted), and it's not commented sorry
[Immunity Debugger](http://www.immunitysec.com/products-immdbg.shtml) and [IDA Pro](http://www.hex-rays.com/idapro/) immediately come to mind for me, as well as many other websites that use python.
http://www.python.org/community/jobs/ huge honking list of Python related jobs.
I second this.
http://www.livefyre.com
My company doesn't commercially release any Python code, but it's used internally every day by probably 100 people. It's also pretty heavily used within my field: trading.
Hey thanks for all this, i'll definitely go through it. I've gone (attempted) through some of nehe's tutorials and they were all so outdated it made it virtually impossible. I haven't ever touched pyopengl. 
There's quite a few big sites using it including Google, Youtube, Reddit and Disqus. http://lineofthought.com/tools/python (my site -- sorry for self promotion, but its definitely relevant :)
The NeHe website has a nice gentle introduction to OpenGL and several of the lessons have been ported to PyOpenGL http://nehe.gamedev.net/ 
My company uses Python extensively as well.
I've worked for three different companies doing Python full time. First job I built servers for flash clients in Python/Twisted. Then I built web apps in Python/Django. Now I'm working on the server for an iPhone game using Python/Django/AppEngine. I'm also applying at a web marketing agency that strictly uses Python/Django. I'm so happy that I can make a career doing Python =D
I can't remember who, but someone recently said that Python at Google is largely used for internal tools and prototyping, but that all production code is Java or C++.
Google, Youtube, Reddit, Disqus, Disney, Dropbox, Etsy, Threadless, SourceForge, SurveyMonkey, etc.
I added some extra stuff like numpy arrays I only got a wee way through the tutorial, I have no license on the Code yet, but gletools is under AGPL so I'll have to investigate what licenses I can use but if you can publish more of the tutorial that would be great
Enthought (http://www.enthought.com)
IIRC Youtube used to be PHP, and was moved to Python after they got bought.
The real question is, who is *going to* use it? Java will sink into pervasive-yet-avoided FORTRAN status soon enough. PHP is in every way inferior to Python imho...insert holy war here...
Reddit, NASA...those are two of the big ones who spring to mind.
ILM
Mako rocks.
I second this.
IMO exceptions should be tagged instead of classified
This sounds reasonable. I know Python is robust, but I have a feeling Google is one of the few sites that can't stand the performance hit of using an interpreted language on a public-facing page.
me too
Youtube is 99.999% python, according to one of its lead developers in [this talk](http://www.youtube.com/watch?v=HXevnuOOy48) (see the slide at about 7:50).
On the other hand Google owns Youtube and it was written entirely in Python. 
I work for a software company making enterprise network &amp; asset management software. The product I work on is mostly Python, with a little C++ for speed critical parts and some Java for using 3rd party Java libraries. It sells for big bucks and is used in major companies such as banks, telcos, major retail chains etc.
ebneter says YouTube was *originally* done in Python. Is it still?
We use python at yelp and we love it.
See this thread for more hidden features: http://stackoverflow.com/questions/101268/hidden-features-of-python .
I haven't heard anything about a rewrite in a different language. Although I wouldn't be surprised if they optimized hot spots by rewriting them in C, which is fairly easy to do. Honestly though for most web development, being able to write code fast and use the time you save into trying different technologies (like caching or asynchronous networking) tends to yield better performance results in my opinion for 95% of the apps I would say. Think of an average web request. It goes something like WebServer-&gt;(Thin)Python(glue code)-&gt;DatabaseQuery-&gt;(Thin)Python(glue code)-&gt;FastTemplateEngine(probably written in C)-&gt;Web Server. Most of your "heavy lifting" is done outside of the Python code anyways. And if you really have a heavy computational task you need to accomplish well you have lots of options available to you, the last resort being writing a C module. Someone actually compared Java and Python on the Google App Engine and you would be surprised by the results: http://www.distractable.net/coding/google-appengine-java-vs-python-performance-comparison/ For Google search it makes sense they went with C/C++ since Google implemented everything from scratch, including the database software and even the file system. But how many web projects require that sort of custom development really? Full disclosure: I work in a Java/Python enterprise shop, and I've written a lot of our production code in Python. And honestly the performance is great as long as you know the limitations and how to work around them. And I can tell you from first hand experience that leveraging the right programming pattern for the task will give you way more in terms of performance than would the choice of the language.
I am nothing close to an expert. Your explanation makes sense.
But Google did not originally own YouTube. They only got it around 2007 or 2008, from memory, after trying to compete for a while using Google Video.
True, however, the topic is really about the viability of Python in commercial projects. I think Python has proven itself in case of Youtube regardless of the Google situation.
Interesting, thanks!
Python is used very heavily in electronic trading and risk management in foreign exchange, commodities and interest rate trading at Barclays Capital, JP Morgan and Bank of America. Lots of hedge funds use it too. There will always be C++ for the part of the system that need flat out speed. But Java seems to be waning...
Two of the four companies I've worked at have used the Python API for [Selenium](http://seleniumhq.org/) for automated testing.
I think that's largely correct, but there are some public-facing parts of the Google that are Python-based. http://mail.google.com/support/bin/answer.py?hl=en&amp;answer=171454
http://geekswithblogs.net/gregorymalcolm/archive/2010/04/05/koans-now-available-in-python-flavor.aspx
After going to a meeting of London Financial Python Group I can tell you that JP Morgan, Gazprom at Cantor use Python :) 
[Python Osmosis](http://www.youtube.com/user/ryanmshea)
I know a lot of Rails shops /wish/ they were using Python.
Python is not just for web.
pyopengl is a straight wrapping of the OpenGL C API. It's not pretty, but that being said, any OpenGL tutorial written in C should apply. Just import the relevant functions/constants from the pyopengl module and they'll work pretty much exactly like they do in C.
They are migrating. [Slides from Pycon 2010](http://us.pycon.org/2010/conference/schedule/event/110/)
I've just uploaded a couple of tutorials that I made for a friend on github at https://github.com/skaslev/burton . There isn't much documentation since I was explaining them in person but I hope that the code is readable enough.
But $$x is just much more convenient than locals()[x] /s
Django? Pylons? Web2py? Flask? Bottle?
See, I don't know. I don't know what the best tool(s) for the job are...so I was hoping someone could direct me to some information so I could try and figure it out. Pretty much all I can do at this point is write basic python functions. This is a thing I'm doing alone, its main purpose is as a learning experience that will result in something useable. What I do know is that I'll need to have databases...I remember we had to use SQLite in the group project I did. I have a really general idea of what I need to do, but no idea of how to do it. Hence the need for me to read some possibly lengthy guidebooks. Other than that, I'd welcome any opinions as to what is best for me to use for this purpose. Edit: I will look up all of your suggestions, thanks 
&gt; But Java seems to be waning... This isn't true. I work at a *big* bank where the plans of bringing in Python for real time apps were thrown in the back seat because Java blows the hell out of Python when it comes to performance. Plus lack of static typing is a real pain when it comes to a *large* code base worked upon by team members across the globe. I really love Python but I do have to admit with a heavy heart that the application which I work on (and many others) would only amount to more pain if written in Python. Of course, YMMV.
I've been using Python commercially for the last 10 years or so, mostly for web stuff. Kudos to the people who teach your courses using Python; it's a good way to learn programming. 
&gt; Plus lack of static typing is a real pain when it comes to a large code base worked upon by team members across the globe. Type systems have nothing to do with the location of developers or the size of their project.
Of course it is used commercially - your question is like **"are there any black swans ?"** But....you get the idea (i.e. try searching for Python-specific jobs within the financial service sector) 
Unfortunately, Java (JVM) is still 100 times faster than Python, so when it comes to truly large apps where performance/scalability matter, Java will still be better choice than Python. Also, Java toolchain is way more mature (honestly best in the business) than Python, or pretty much any language out there. Yeah, it's not the most modern language, nor is it fast to develop in, nor do I like the fact that Oracle now owns it, but it's still performance king. Scala is a promising language but it depends on the JVM of course. And currently there is no viable alternative to the JVM/Java combo. I wish there were, I'd jump on it immediately, but Python/Ruby/C# etc are not replacements for Java unfortunately. 
It does, unless you are part of an ideal team. When shit happens, developers in a hurry end up fixing one part of the system and breaking another. Even simple things like violating interface contracts which can be easily caught by a statically typed language like Java are found out at a later stage with languages like Python. And sorry, if you feel that "type systems" don't have anything to do with the size of the project, I'd say you have pretty lucky all this time to not have worked with shitty teams...
See their [PyCon2011 presentation](http://blip.tv/file/4881226). I believe they are a Python shop now.
+1 for NeHe, although depending on what you're trying to learn it may not be the best. It is pretty old (dates back to '98 or '99 I think) and last I checked all the tutorials deal with OpenGL 2.x constructs. If you're looking for the "new" way to do things in OpenGL, look elsewhere.
We use it at Cisco for various projects.
[According to their presentation](http://www.youtube.com/watch?v=HXevnuOOy48&amp;feature=player_detailpage#t=519s) they use 99% Python with C extensions for the performance critical tasks.
They are already tagged. And in the "possible alternatives" section of the PEP [you can find a way for Python to use the tags](http://www.python.org/dev/peps/pep-3151/#pattern-matching). This is currently being discussed in python-ideas, you should go there if you want to participate.
Bits on the Run is written in mostly Python, as are parts of Longtail's other stuff I've worked on. Google uses a lot of Python for system management / utilities / prototypes. Tons of websites use Django. The company I currently work for does custom contract work for some very, very big name companies and defaults to Python (Turbogears, Django, App Engine, etc) unless clients specifically ask for something else. Tons of websites built on App Engine are using Python (through webapp, Django, or other frameworks). NASA uses Python. If you use Linux there's a good chance some of the desktop applications you use or come across are written in python (I've written several). Here's a list of some more info: http://www.python.org/about/success/ Python is literally huge, and every single Java, C#, and PHP developer I've met and talked with is interested in learning Python as a next step to broaden their work potential. That said, at this point it still makes more sense to be a Java or C# guy due to the sheer number of positions available for those when compared to Python. Edit: I noticed someone else mention national research labs - when I worked at one a few years back I did work there exclusively in Python and that code is still being updated and in use today.
Splunk ships with Python and the Cherrypy framework. Commercial, enterprise-grade product.
While not a tutorial, [this talk at PyCon](http://pycon.blip.tv/file/4882916/) discusses using OpenGL to programatically generate geometry. There is a [Convore discussion of the talk](https://convore.com/pycon-2011/algorithmic-generation-of-opengl-geometry/) which includes links to the code from the talk as well as other tutorials.
Django is the largest Python web framework, has support for SQLite and pretty much any other database you could want. It comes with it's own templating engine. The documentation is IMHO quite good. It doesn't take too long to set up a very usable site. Flask is a much lighter framework. You could probably read the entirety of it's code in an hour or so, it has a very small core. If you're looking to learn about what goes on behind the scenes, Flask might be a good place to start.
I learned a bit late that pylint comes with a simple GUI called pylint-gui. Next time I should do some more research...
&gt;Unfortunately, Java (JVM) is still 100 times faster than Python, Once it's up.
National Geographic, The Washington Post, The Washington Times, and NPR all use Python (specifically, Django)
Does no one listen to Last.fm? ;)
Yeah, once it's up: $ time javaw real 0m 0.10s user 0m 0.01s sys 0m 0.05s $ So, 10 milliseconds to start. Or something less trivial (but still not really a good benchmark): Java vs. C vs. Ruby vs Python Here's the (silly) code Fib.py def fib(n): if n == 0 or n == 1: return n else: return fib(n-1) + fib(n-2) for i in range(36): print "n=%d =&gt; %d" % (i, fib(i)) Fib.java public class Fib { public Fib() { } public int fib(int n) { if (n ==0 || n == 1) { return n; } else { return fib(n-1) + fib(n-2); } } public static final void main(String args[]) { Fib app = new Fib(); for (int i = 0; i &lt; 36; i++) { System.out.println("Fib("+i+") = " + app.fib(i)); } } } fib.c #include "stdio.h" int fib(int n) { if (n == 0 || n == 1) { return n; } else { return fib(n-1) + fib(n-2); } } int main(int argc, char** argv) { int i = 0; for (i = 0; i &lt; 36; ++i) { printf("fib(%d) = %d\n", i, fib(i)); } return 0; } fib.rb def fib(n) if n == 0 || n == 1 n else fib(n-1) + fib(n-2) end end 36.times do |i| puts "n=#{i} =&gt; #{fib(i)}" end $ time java Fib real 0m 0.35s user 0m 0.26s sys 0m 0.01s $ $ time python fib.py real 0m20.36s user 0m20.20s sys 0m 0.09s $ $ time ruby fib.rb real 0m10.28s user 0m10.26s sys 0m 0.01s $ $ time ./fib.exe real 0m 0.25s user 0m 0.23s sys 0m 0.00s $ So, C = 25 milliseconds, Java = 35 milliseconds, Ruby = 10.36 seconds, Python 20.36 seconds. Or, expressed in terms of C speed in this test: C = 1, Java 1.4 times slower than C, Ruby 41.12 times slower than C, Python 81.44 times slower than C. In particular, Python runs this test 58.17 times slower than Java.
&gt;Plus lack of static typing is a real pain when it comes to a large code base worked upon by team members across the globe. Define large code base. Our flagship product is several million LOC and nearly a decade old. Our team is over 140 developers in about three cites on two continents. Duck typing is not a problem for us except when we hire devs with cognitive rigidity about static typing.
Take a look at this list, and remember that this is just the Boston area: http://bostinnovation.com/2011/03/31/boston-companies-using-django/ 
A lot of the feedback I'm getting on Aspen is complaining about the use of the ASCII page break control character. To wit: http://news.ycombinator.com/item?id=2410221 http://www.reddit.com/r/Python/comments/gjswr/aspen_python_web_server_with_simplates/ Besides missing the point, this gives me a chance to do some further marketing. :)
I'm rooting for [Mirah](http://www.mirah.org/), I think it looks like a smart way to abuse the speed of the JVM without resorting to an ugly blah syntax. I hope toolchains for Haskell also improve; it's another fanboy-holy-war kind of language but the speed and elegance of Haskell really have potential.
Flask has a great [intro tutorial](http://flask.pocoo.org/docs/tutorial/#tutorial). There are some similarities among the different python web frameworks, so running through that will give you a good start. Once your comfortable, you could take a look at some of the other frameworks and decide what you like best.
[we](http://www.gamr7.com) do.
Did the FAQ just Faqoff?
Heh. It sort of looks like it. Reddit's been down all morning, and just recently came up (hence why I'm taking my normal early morning break now). So maybe the void ate the FAQ. I suggest sacrificing a goat. That might bring it back.
I think he was talking in the context of web frameworks. On my dev machine it takes minutes to compile an EAR file and another few minutes to bring up JBoss with Struts and Hibernate. Which is just ridiculous.
Most highend 3d applications support Python, including Maya and Softimage from AutoDesk, Houdini, RealFlow; and compositing applications such as Nuke. Python is the standard scripting language in the visual effects/animation industry.
I don't understand. Why drive away children from your software, now?
I've been looking through some OpenGL code and I keep running into recommendations to learn modern OpenGL. What does this mean? What is the deprecated functionality or style and what is meant by "modern"?
it is rediculous, but in the context we're talking about, still not a factor in performance
from, my noob, perspective I believe that the fixed function pipeline has been marked for removal, and shaders and VBOs are the way forward, most default settings have been removed, like for example the gl_PerpectiveMatrix function in GLSL
From what I know it still is, however almost every page is served out of cache directly.
Page isn't loading. &lt;snarky comment here&gt;.
Compilation/deployment cycle is important, but it's not the kind of runtime performance we are talking about here. Besides, java compilation is usually I/O bound and it's orders of magnitude faster than C and especially faster than C++ (as almost anything else is). I work on 3 million lines of code base, and my compiles are about 3 minutes long. Deployment cycle is about 15 seconds or so. Not bad in my opinion. Considering I rarely have to re-build the world. Also, you should not have to bring down and boot up JBoss to re-deply your code. I most certainly don't have to do that. 
Really? I would think they would need something much faster than Python. Or do they make their own C wrappers and such?
It's extremely simple even for complete newbies to pick up. I've helped several people in my classes understand Python.
I've been finding that's the real way to go 99% of the time, in the 5% case something isn't already in Numpy/Scipy for my scientific uses.
I thought trading was overwhelmingly dominated by C++?
I thought we were moving to a world where the speed of light was becoming a factor in financial computing? And now they're moving to a language which is an order of magnitude slower?
It may be blocked at your workplace.
Stupidish question: Does writing a large website in Python take a heavy hit on the servers since it (hypothetically) takes longer to process than quicker, compiled languages? Disclaimer: I have not the first idea about web programming.
Our commercially available products are mostly C++ but with a bunch of C# on the GUI side, but internally, nearly all of our testing and other apps are Python. We're around 500 people so the "internal" tools actually impact quite a few people, so it's not just dinky little utilities people are writing. I personally work on performance and load testing of a historical trade database (the product is in C++) which is almost entirely done in Python (C++ for a few extensions). We also have a C extension to the database API and have a ton of `unittest` based frameworks for testing data quality and a whole host of other stuff. There are plenty of shops that do use Python in their products, but probably not 100% Python. Usually any job posting for trading shops that *do* use Python have an equal amount of C/C++ knowledge required.
Not as much as you'd expect. The compilation process is pretty trivial in terms of CPU time, and basic bytecode is pretty fast. It's always seemed faster to me than PHP or Perl, but I've not done any scientific tests. Of course it does also depend on how smart you are with your programming. Monolithic code = bad, though generally it seems python developers are a smarter bunch (whereas too many php devs seem to be clueless 'my first program' types.) If you really want to get fancy, run it on Jython, maybe using jrockit or similar as the JVM underneath, and it'll soon compile machine optimized code for your most frequently called functions anyway. You could do your web-app in C, and gain from lots of optimizations but then changes become a lot less trivial. Given you've been using Python through your course I'm sure you've discovered how easy it is to write, tweak, prototype etc. CPU power is cheaper than developer time.. though don't take that argument too far :D
But one in which changes are extremely quick and easy to make. Reaction rates hit from two angles, code speed and speed of adapting code to new situations.
I do it for sanity purposes. Guarantees that the JVM is spotless when the app comes up, plus wipes out any resource loss from minor uncaught memory leaks or whatever quirks.
How do you guys do DSLs in python now? 
Python is used by PBS for a lot of its web stuff.
Wait, the [main attraction](http://aspen.io/simplates/) is a templating language that *uses uncommon control characters*? To *embed Python code in the templates*? Sorry dude, but the page brakes are (as many others have said) an unnecessary complication, and the embedding Python code has been done (see: [Mako](http://www.makotemplates.org/docs/syntax.html#python-blocks), [kid](http://www.kid-templating.org/language.html#embedding-code-blocks-python), and TAL). So what makes this special? **Edit**: Ok, so after doing some more reading, I think I understand: the app is just a collection of simplates (kind of like a PHP app is just a collection of PHP templates), so creating a new page is as simple as dropping a simplate in somewhere. That's kind of neat.
Youtube is written in Python. Yandex (largest Russian search engine) has ported some of their projects from PHP to Python. Russian President has a [blog](http://blog.kremlin.ru/) written in Python (Django).
Pyglet has very good tutorials.
sourceforge is turbogears thus python
can you try fib on pypy ? it IS the future of python
We use Python at my work for a lot of backend processing of customer data.
Thanks for the edit. The PHP thing where you just touch a file and voila, you're on the net ... that's actually cool. Aspen takes that, and leaves the rest of PHP right where it found it. When I was writing the [templating docs](http://aspen.io/templating/), I was thinking, "Crap, where do I test this? Oh, wait ..."
That's it exactly. Check out my comment on this [over here](http://www.reddit.com/r/Python/comments/gkihu/some_black_magic_python_for_n00bs/c1oa8eb)
I really like the design, but I think there are fundamental limitations to using a control character. I use Vim, and I'm happy to drop in form feeds for some simplates, but not all editors can handle them properly. Why not allow either the form feed *or* a literal `^L` to break pages? It's easy enough to `echo ^L | sed s/\\^L/foo/` if you want to clean it up, for example to use with emacs.
There are none. (Mis)using syntax (Ruby style) to achieve the illusion of dealing with a custom language is considered unpythonic. Syntactic macros a la Lisp are unavailable and AFAIK no one ever mixed C preprocessor directives with Python code, something which would be possible of course.
&gt; So, 10 milliseconds to start. 100 milliseconds.
"Python web server" ಠ_ಠ
Ubuntu's package manager.
What's wrong with that?
Article about a particular pattern I've started using, of unknown origin
why are you using recursion for this? 
No, it was always Python.
Kind of depends on what you mean by "production": Most of the services are written in Java or C++, but an awful lot of what makes Google run is nevertheless written in Python. (Deployment tools, etc.)
well assume my housewife mom is asking: "...what exactly is a "Python web server" ? I thought it's that "http" thing..." edit: and I will probably say "I guess its web server written in this language called "Python"...."
&gt; Needless to say, **fucking** with these is probably best not the best idea I know it's your blog but it was good until this point. Was this really needed?
I didn't know you could get .io domain names... Looks like it's time I registered a domain...
If the porn splash page &amp; adults-only joke were just removed, then you just saved yourselves from… yourselves.
In your first (previous) blog post and the first snippet, you call the function `foo(a=1,b=2,c=3)` but there is no definition of `foo` provided.
Fair enough, I hadn't really considered either way, but if it bothers you then probably wasn't needed, I'll change it around.
I work for a biotech company and most of our simulation software is written in Python. The main reasons are the quick development cycle, ability for non-programmers to pick it up relatively easily, and the availability of a wide range of scientific libraries. Performance-critical bits are written in C or C++ and then used as extension modules. 
haha yeah, I was just using it as an extremely generic example, but thanks for the careful examination. I think I will add a declaration of it just for you. edit: added it
What you need is a full-stack framework. Look at Django or Web2py. Spend one day to work with Django. Spend one day to work with Web2py. Try to build a small app on both systems. Then, you will have your answer.
Srsly. Watching porn is like eating McDonald's.
I've appreciated http://www.iwantmyname.com/
&gt; I think I will add a declaration of it just for you ...and for the many others who'll be visiting your blog in the near future. :-) &gt; However, it can at times increase the ambiguity of a function, or decrease it's security You talk about security implications but don't extrapolate on what kind of implications? (BTW, it's =&gt; it is, so you should have used "its") Also, your `healthyMerge` method can be replaced by a simple one liner: def healthyMerge(self, target): self.update(tup for tup in target.iteritems() if tup[0] not in self) 
that is a nice, pythonic solution. I'll replace my function with that and reference you. Should I reference wot-the-phuck, or some other, more suitable name?
I'm in Comp Bio and maybe it's because I'm kinda in the know, but this makes the most sense to me because of the reasons you provided.
I think mentioning 'a redittor' and linking back to this discussion should be good. ;-)
Let's floor("not all editors"). I know them to work fine in Vim, Emacs, and UltraEdit. I know that in Notepad you have to use ALT-012 or copy/paste the character in. For the editors in between, what does page break support specifically look like?
I guess I meant high performance front facing services.
The connection has timed out rofl
I see that you have changed it, much appreciated. :-)
&gt; The PHP thing where you just touch a file and voila, you're on the net Mako *can* do this too, if you build a 3 line controller that just returns templates based on PATH_INFO, the templates do recompile their underlying module when touched. But of course you might lose control of your fingers and put a &lt;% %&gt; block where you're not supposed to and anger the MVC committee, so bring on the simplates !
Development snapshots, boss. Please break it, then file a bug report: https://github.com/whit537/aspen/issues
:D
URLs are meaningless. Yes, it was clearly originally written in Python, but that doesn't mean it is right now.
&gt; At this point, it's perfectly possible for the user programmer to add in this extra call (or an "unlazy" function or something) whenever they want the evaluation, but I was looking for some way for python to know when it is needed, and to do it automatically. For experimental purposes one could define an import hook manipulating objects on loading. I would try to register the hook in `site.py` or when you restrict your attention to functions defined in some package it might suffice to register the hook in the packages `__init__`. 
Here's a list of editors showing support for custom keybindings: http://en.wikipedia.org/wiki/Comparison_of_text_editors#Key_bindings
I think the problem with this is that function objects are impossible to manipulate at anything other than the bytecode level. What I actually had planned was just a @lazily decorator, for functions you wanted to evaluate lazy stuff automatically, but an import hook would work too. I thought about a similar import hook, that would read a file, and do the manipulation at the string level, before it was actually compiled to bytecode. Only problem really was it seemed that I was going to end up re-writing the compiler if I really wanted to keep track of which objects were "lazy".
All public facing code is Java and C++, there is production Python code but it's only used internally.
The horror! And people call Lisp ugly?
Site dead?
I don't see why you're getting down voted. But as a Pythonista I really don't see how Python could be more efficient. It's a dynamic language which has been notoriously hard to optimize due to it's high level idioms. Go on the other hand is a low(er) level static language which could technically compete with C in terms of performance. Granted it is a relatively young language and an immature implementation (authors themselves state its GC could use a lot of improvements.) I think we as Pythonistas should be glad people in the PyPy project have been able to pull off these type of optimizations with Python. And the fact that Python is in the same ballpark in these benchmarks and sometimes even faster is nothing short of amazing. But in general Go should rarely ever be slower than an interpreted dynamic language like Python.
My guess on that is that he was testing on a dual core (hyper threaded, 2 real, 2 logical cores) CPU. I've definitely seen a difference between 2 Tornado and 4 Tornado processes on an actual quad core CPU.
PyPy has some experimental code for lazy variables, at the namespace level: http://codespeak.net/pypy/dist/pypy/doc/objspace-proxies.html#the-thunk-object-space
Python does give API access to its parser, compiler, and import system. I don't see this utilized much, but it is possible to implement a language and install an appropriate import hook to let Python know how to import these modules. One example is [Adder](http://www.thibault.org/adder) lisp.
Ok, Internet, how about this. I've added a page_break knob to aspen.conf so that you can override the ASCII page break default for your application. http://aspen.io/aspen.conf/ Is that acceptable?
"The Webserver for Adults" - this is pretty obnoxious.
uhhhhhhhhhhhhhhhh, your username?
Who needs lazy evaluation of functions in an imperative language that supports generators?
It's mostly a religious thing. Flask, bottle and other microframeworks are useful if you want to get started without much initial overhead (i.e. be able to write a minimal app in a single file). Django is great if you want the framework to do the heavy lifting for you. You get a lot of stuff out of the box and extensions for everything, even the CMS generates itself for you. You just have to live with the defaults. It _is_ possible to use a different ORM or template engine, but it'll cost you a lot of the magic you get with the builtins. I can't really say much about Web2Py and most of the other ones, but Pylons is a bit like Django in that it gives you a fullblown framework out of the box but emphasises loose coupling. This means you don't get any of the magic Django gives you, but you're in direct control of the implementation and can override the internals to your liking. Pylons will be replaced by Pyramid in the long run, however, so I'm not sure how viable it is to pick it up now. All that said, my favourites are Django and Flask. They are both ridiculously easy to get started with. Django does more of the work for you, but Flask makes less assumptions. Flask also requires more planning so you don't shoot yourself in the foot if you plan to grow your application beyond a certain architectural limit.
Not if you want your simplates to work in other people's servers.
This is great, thanks a ton
Delayed/lazy computation is not the same as lazy evaluation. Your post seems to be only about the first. Lazy evaluation is a specific reduction strategy in functional languages, one that is not used in ML, by the way (ML is applicative order). I find it strange that you do not talk about generators, they offer quite some support for laziness. Consider this: from itertools import count, islice def cartprod(a, b): for x in a: for y in b: yield x,y print list(islice(cartprod(count(), count()), 10)) There you have the first 10 elements of the cartesian product of the natural numbers. Unfortunately itertools.product doesn't support infinite sequences. The NLTK library has lazy corpus readers. These objects implement the sequence interfaces so you can treat them just like lists only it doesn't need to keep the whole corpus in memory. So if you focus on sequences or dictionaries you can implement laziness with objects; I think this is generally more useful and interesting than single values anyway. And if you don't need to access a sequence multiple times you can pass around generators without needing to implement laziness yourself.
I think "healthy merging" can be done with basic dicts, too, it just requires "reversing" things. For example, with your code, you would run: update_this.healthyMerge(update_from) But, you could do: new_d = copy.copy(update_from) new_d.update(update_this) update_this = new_d It's not necessarily better or worse, just a different way to think of it, which may or may not be valuable to what you're doing.
Do you mean the intended "domain specific syntax" or that AST monster which is basically displayed data?
Yeah, sorry. I'd change the title if I could. Took the page down.
Start simple. The django introduction tutorial is one of the best tutorials of any framework (in my opinion), so just follow it until you start to understand what's going on somewhat. It will obviously take years for you to understand everything that's going on under the hood, but this is a great place to start learning, and you should be able to get something workable in no time. http://docs.djangoproject.com/en/1.3/intro/tutorial01/ After you've done that, you can do as others suggested and try something else, like web2py http://web2py.com/book
Pypy 1.4: real 0m41.979s user 0m41.719s sys 0m0.056s Python 2.6.6: real 0m22.568s user 0m22.381s sys 0m0.004s Python 3.1 (might as well..): real 0m23.454s user 0m23.349s sys 0m0.008s pypy is great, but it's not the be all and end all! 
Of course that code is rather ugly and inefficient. If you're going to write code like that you're better off spending the few minutes it takes to find the low hanging fruit, fixing your base working. You can only optimize for so much bad programming, particularly in dynamic languages. fastfib.py: from math import sqrt def fib(n): return ((1+sqrt(5))**n-(1-sqrt(5))**n)/(2**n*sqrt(5)) for i in range(36): print("n=%d =&gt; %d" % (i, fib(i))) $ time python fastfib.py real 0m0.016s user 0m0.008s sys 0m0.004s That's even quicker than your algorithm using C, from barely a few minutes checking the formula for fib sequence.
Suggestion: Add file searching w/ the glob module :) 
Great news. Never wanted to go through every mag.
I've implemented caret-L as a fallback. http://aspen.io/page-break/
I've implemented caret-L as an alternative: http://aspen.io/page-break/
Cool. I think it'll help, especially since it'll make it much easier to post simplates to the web, like you said on that page. Again, great work!
3 means better than 2 and much better than 1 (better "in what way" would be nice to know, but that doesn't mean that knowing "better in some way" provides no information). I doubt very much that you really don't know the difference between books at Amazon that have tons of 5-star reviews and books that have only 3-star reviews.
&gt; uhhhhhhhhhhhhhhhh, your username? Oh, so that's the reason I've been down-voted. Just to clarify a couple of things: * You'd be surprised at how 90% of the folks can't figure out what the name means * My username here is not tied to my real world self, it's just an alias which I can use to rampage "teh" internet which is in contrast to a blog post where your real world self is represented by what you write * Python is becoming really famous among really young kids (even below 10) and I would really not want a kid who stumbles upon that blog post (by chance) to read that I know this reasoning sounds silly and my user name like a troll, but believe me, my intentions were good. :-)
Answer: a programmer that needs more than one kind of data structure. Generators only support lazy one-pass iterators (ie, iterators). Haskel lazy evaluation supports multiple passes over lists, trees, arbitrary user structs and classes, etc.
You can follow an abbreviation with a capitalized word though... e.g. Reddit
@functools.wraps(fn). Fuck this \_\_name\_\_ bullshit, update your docstrings as well.
Not too much, since website backends are typically IO bound rather than CPU bound.
I'd associate generators to continuations.
I don't know what you intend to tell here. Laziness is used as an optimization technique which allows the runtime not to evaluate expressions at all. Once they are evaluated there is no point anymore in laziness because the values can be cached and only have to queried. So one pass vs multi pass is ultimately irrelevant or an implementation detail about implicit vs explicit caching. 
I for one welcome these introspective GObjects, but how slow are they?
&gt; Since it seems that the basic dict class lacks a way of simply updating a dictionary with values that aren't already set [`dict.setdefault`](http://docs.python.org/library/stdtypes.html#dict.setdefault) is almost what you want. A neater version of your merge method: def healthyMerge(self, target): for k in target: self.setdefault(k, target[k]) 
Hmm, very interesting, but leads me to think that something is wrong with this algorithm implementation, in few of my tests i have indeed confirmed it can be 10 faster than cpython, so this is a bit of surprise to me
I think decorators are not enough, laziness isn't just a property of a function but also of the value it returns. So you should implement objects for lazy versions of each datatype. Whenever an operation is performed on the object, say the operator add is used with a lazy number, you check if the other number is lazy as well. In that case you return a new lazy object; otherwise you do the computation and you return a normal number again. This approach is completely general, the only downside is that you will have to implement it for all datatypes and add laziness checks to all of their methods.
Elaborate? Is that exclusive to laziness?
Might another way be: original = target.copy().update(original) (Untested.)
No need for insults please. I'm not retarded and the point of this code was not to be optimized for either any language, platform, architecture or algorithm since there are better ways to do any of those. The point is to just take any random, purposefully rather slow algorithm (so the running times are in seconds rather than nano-seconds). It seems you are missing the point completely. So, run the equivalent C and Java program and you will realize that it's hard to even measure runtime reliably since it's insignificant. 
It's probably what they intended: that you go to them or a number of reputable sources first. Would make sense with Google's ways of late.
Both, but the latter especially.
Prenu suggested generators were sufficient, but as you point out, they don't cache. 
does anyone know what this means for non-linux or even just non-gnome pygtk apps? Do they have a way forward, or does ths new path require te Gnome platform? (also, congrats and thanks for all the hard work!)
I think your criticism of my example is quite fair. Thank you.
Not sure if this is a good time to ask, but anyone have some favorite books or something on starting UI development in Python? Is PyGUI really as nice as it sounds?
i'm not sure he'd agree on my characterisation, but i think i work with one. he manages to produce code in it anyway and is kind of relaxing a bit, i think. also, i'm currently working on a library that extends python to add more verification of types. you wouldn't want to use it everywhere, but it might be useful for debugging. code looks like: @checked def str_len(a:str) -&gt; int: return len(a) (that's valid Python 3 code btw). and calling that with a list, say, would give you an error. http://www.acooke.org/pytyp/
Without reading about it, it sounds like it will require GObject, not the whole GNOME platform. GObject is a C-based object-oriented system that supports introspection, making automatic generation of bindings easier.
for someone who has know idea what PyGObject + gobject introspection is, what does this mean? i don't see why pygtk has to 'go away', especially since gtk can exist without gnome.
Wow, those seriously are pretty paltry porting instructions.
Quite the opposite, my boss is a java/csharp guy and he thinks anyone who programs in Python is a genius.
As in the past: today java programmers are tomorow python programmers.
I don't want to be a naysayer, but it feels like you're doin' it wrong when you start verifying types in python. If you want to make sure things are generating the right output for the right input, unit tests are great: http://docs.python.org/library/unittest.html Also, to make sure your unit test are checking everything, use figleaf: http://darcs.idyll.org/~t/projects/figleaf/doc/
The pygobject gnome live page has a downloadable windows installer, so no.
Sure, I agree. I am quite an experienced Python programmer and this is just a fun "diversion" - I'm not saying for a moment that it is the right thing to do in every, or even most situations.
Ah, sweet! I hadn't really heard about this project, so don't really know anything about it. (For the record, here's the homepage - http://live.gnome.org/PyGObject)
c# &amp; visual studio are the only ways in which I envy windows programmers 
What makes the difference between 3 and 2 besides the number 1? Why is this 3 rating not a 4? A number by itself in a rating means absolutely nothing. What's a 3 to me for X, Y, and Z reasons might actually be a 4 to you for A, B, and C reasons. Without an understanding of how the reviewer came to the numerical rating, it means almost nothing. For me to go in and rate Django a 3 means nothing -- you have no idea who I am, what I know about it, what I've done with it, how I'm using it, or what my reasons are for not rating it a 2 or a 4, or anything else. Amazon ratings sort of work because it's a number and a few paragraphs. If you give it a 1 and say "it sucks", I can just throw that out right away. If you give it a 5 and write 1000 words on it, maybe I can value the rating.
While maybe true in some cases, I am much more of a Java programmer these days than a Python programmer. And I can definitely say that this was not always the case. They're both just tools for different jobs. 
Why? 
Most Java programmers I know think Java is not a "real" programming language and only use it because it's in demand.
Why? VS isn't even that good an IDE (the builtin refactoring support is still pretty bad, though that's an up from the former "utterly dreadful" I guess).
I really like the syntax you have there.
Builds character?
I have met a lot of Java programmers who would love to dump Java for Python. I actually work with a company that rewrote their entire platform in Python recently from Java. They have all sworn never to go back.
Changelog?
The only fundamental difference between Python and Java is that the language is different...
for c# because it's the best language that's still c-similar, but that's opinion and visual studio because that's what I worked with in college with c# and found it way easier to work with than any other language + ide combo for other languages I've tended to drop back to using a regular text editor (gvim)
VS is quite nice, but the amount of bloat is gigantic.
well, thanks, but i must admit that it's not mine :o) python 3 allows type annontations (the stuff after the ":" and the "-&gt;") - they're part of the standard language. it's just no-one uses them (they're not verified, just added to the function's metadata). all i've added is the "checked" decorator that checks the types when the function is called.
I've used visual studio ocassionally and I find it clunky. Yeah, it's nice to have everything integrated but there's just too much stuff in it. Instead of configuration files now you have twenty tabs (which of course all differ in layout in various versions). Then again, I prefer a lot of simple editor windows (notepad++ or python idle) and print-statements for debugging, plus a simple makefile if I really need to (most of the stuff I write is in python or R so no compilers or makefiles needed, only for the ocassional hobby-uC-project it's back to C). Maybe not the fanciest thing on earth, but 100% reliable. c# -- no opinion, never worked with it. 
Jython brah.
Print statements are good for debugging single threaded code, but when I had a project where we used multiple threads, it was awesome being able to set a breakpoint and step through each thread independently. One thing I found Microsoft has done right is its debugging, though I often find myself using print statements in my code even if I'm using VS. I completely agree with your configuration criticisms, though.
It could certainly be useful for debugging situations, and the great thing about python is you can import what you wish to import!
Multithreaded code is only good for getting really painful headaches ;-). In interrupt handlers you also can't use print statements. On the other hand, I've noticed that print statements or traces in such environments don't help you; you see that a variable has a value which it shouldn't have, but you don't know *why* it gets that value. The problem is usually not in the code itself, but the context around it (not understanding 'volatile', something wierd with adressing, etc.). Solving such problems is tough. 
The JVM is actually a stack-based architecture.
You're clearly a smart guy, but this is just a really strange post. You've made the statement "Python and Java are pretty similar, in that they both implement a VM based on a register machine architecture", but this completely ignores the actual languages (and perhaps other Python implementations but I'm not entirely sure if IronPython or PyPy do something different wrt VM's) and judges them based upon VM implementation. "both are object orientated".. true, but you're free to do FP in Python. Not so with Java. "Really the only fundamental difference between Python and Java is that the JVM implements strict type checking on the bytecode." Really? That's the only thing that differentiates java and Python? You must have a very different background than most people ... did you write VM's or something? 
I'm relatively new to programming, and I hadn't seen PyGUI before. I'm very, very interested in this. After the three usual options for Python GUI programming, PyGUI looks like a godsend. If he put up a donate link, I think I'd click it. 
No, of course, but they don't delay computation, they save the state of the current procedure (the continuation) and return to the caller. They are basically this: (define (yield x) (shift k (cons x k))) (define (generator f) (reset (f) 'done)) (define fib-gen (generator (lambda () (let loop ((a 0) (b 1)) (yield a) (loop b (+ a b)))))) (let loop ((fibo (car fib-gen)) ; the yielded value (cont (cdr fib-gen)) ; the continuation (r '()) (i 0)) (if (&gt; i 10) ; get the first ten fibonacci numbers (reverse r) (let ((next (cont))) ; call the continuation, let the generator advance. (loop (car next) (cdr next) (cons fibo r) (+ i 1))))) ; =&gt; (0 1 1 2 3 5 8 13 21 34 55) Of course, this isn't exactly same as a Python generator, you have to make it advance by yourself, and at the end of the loop `fib-gen` still \`\`points'' to 0 (and you can traverse it again). To get them the same as Python's, they should get wrapped in a callable object, that when gets called stores the continuation in a local variable and returns the yielded value. The procedure is still evaluated eagerly.
Every day. Being a CS student with a school that uses Java for most CS classes, I use Python for everything outside of class. When I try to introduce other CS students, they seem to brandish that it's too different and they don't want to bother. They think the non-existence of types makes it more difficult. Then I have met some elitist people who strictly code in Java because they believe that Python is *slower* than Java. Forever alone (to program in Python).
how much you willing to bet on that ? ;)
OK, so what's the Python equivalent of jar file ?
egg
An executed egg?
It depends on what statistical method you want me to use.
I have to agree with him. Other than the fact that Java is statically typed, doesn't have significant whitespace, and doesn't include functional operators; they pretty much serve the same needs, but for different "ecosystems". The only reason I would choose Java over Python would be if the environment required it (which may include needing Java's speed over Python's) and vice versa. And the reason I would usually choose Python over Java, is because I prefer Python's syntax. Other than that, it's a wash.
You might want to point out that while Python has dynamic types, it still has [strong type enforcement](http://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language).
No. But I have argued a lot with a local Java guru who thinks typelessness is dangerous. After a lot of back and forth on various occasions he came up with this: "Python works well now because the people who use it are mostly well above average programmers. But most programmers are really bad. In their hands something like Python is not going to work very well. They need static compile time checks, and will abuse all the fancy tricks in Python to hang themselves." (Paraphrased, obviously.) I'm not sure if he's right, but he certainly does have a point.
They don't use it for everything, but actually higher-level languages can be just as fast as low-level ones for a lot of things. These people are generally not writing trading algorithms in bare python and then running them with the CPython interpreter. Some folks use Pysco, others use stackless, and everyone uses Numpy. With Numpy, it's possible to achieve C speeds or sometimes even faster, depending on who's writing the C. :) You certainly spend less time tracking down memory leaks. The speed of light stuff matters only for the lowest level of the stack, namely, once you've decided to execute a trade, you can push the bits onto the wire to the exchange faster than a competing firm. A lot of high-frequency trading firms now build custom ASICs or use FPGAs for this lowest level. Anything higher up the stack is usually better done with Python. And remember that high-frequency is only one portion of the financial sector. There are plenty of firms that do not care about the speed-of-light stuff, and they have lots of analytical problems that are much better solved by having an expressive, agile, easy-to-learn language that has a killer vector computation library. A quant armed with Python and Numpy is far more effective than a quant armed with a team of C++ coders that are tracking down segfaults and memory leaks all the time.
Hmmm ... interesting. I think most people consider the Python language to be precisely its syntax. How it looks on the page but you really consider that very secondary?
please change it. it is not necessary.
I honestly felt the same way about dynamic typing when I just started with Python. The thinking was, "what's the harm in letting the compiler check your work for you?" As I went along, I found that it's not as big of an issue as it seemed. Knowing ahead of time that a compiler wasn't going to hold my hand when it came to type checking, I started just naturally being more diligent. And it's nice to not have tons of ugly variable initialization lines, or to have to to switch back and forth between sections of code, going "ok, what types am I passing in here so that I can get the parameter to this method correct?" 
Really? I find the complete opposite. I pity them because of that.
As soon as I say that it's a dynamic-typed language, I think they start to not listen to anything else past that. It's also impossible to explain that for-loops aren't the same in Python to people.
I use both java and python pretty regularly. I have written most of my own toolkits in both languages and find that the python versions are much more concise (typically 1/3 the number of lines of code) and easier to use and understand. 
No, but I have run into a lot C++ programmers who thought Java is not a real language 10 years ago :D. 
Thats the idea behind the Microsoft .net Framework. C# and VB.net are ultimately the same language... they compile to the same intermediary code... Even though syntactically they're very different languages. This makes the clear point that syntax is largely secondary to the underlying functionality and libraries of your language. With the modern .net famework, it makes absolutely no real huge difference in performance and functionality whether you use VB.net or C#. I think the point here is that between java and python, they're pretty equally matched in terms of standard Libraries, and speed, and use the same Virtual Machine style runtime environment. They're the same style language at runtime basically. Syntax is just that silly stuff us monkeys need to understand it all in our puny brains. It IS largely secondary.
I think there is something to what he says, but I would argue that bad programmers are going to produce bad programs regardless of the language or the tools that they use. The only thing to do with a bad programmer once you identify them is to get them off your team as quickly as possible.
Interesting POV ... "C# and VB.net are ultimately the same language". This seems to strike some people as very strange and makes perfect sense to others. I wonder what separates the two groups. 
Python is too pleasant to work with to be a real programming language.
Um, the fact that Python lets you easily interface with legacy C and C++ libraries and turn those objects into native, first-class types is a huge feature. Also, Python's reflection and metaprogramming features are way ahead of Java; they're nice enough that it's idiomatic to use them. Python's ability to use existing C/C++ libraries means that its XML parsing, sql interfaces, and matrix algebra and large vector libraries all run at C speeds (or faster). The "Python is slower than Java" argument is dead and has been dead for a long time. If you are writing a ton of complicated, procedural logic, then throw a JIT at either and you're fine. If you have huge datasets to deal with, I'll put my money on Python any day. And this is all without considering the massive improvements in programmer productivity when they use Python; this is just talking about simple, low-level code operations.
Comparing the merits of languages based on how much damage archetypal "bad programmers" can do is like comparing airplanes based on the size of the craters they make when chimpanzees are handed the controls.
Have an upcode... heh, it does build character, or kills a co-worker in the process...
Every day. I work on test automation (Python) for an application written in Java. Very few of the Java developers know Python, but their attitude toward it is quite hostile. This could be partially related to the fact that it finds bugs in their code.
ive never seen a python '.egg' file that you just double click or run through the command line to run, but ive seen tons of jars...
[Here](http://ipython.github.com/ipython-doc/stable/html/changes.html#release-0-10-2).
I used to think that before, but w/ C and LISP (or smalltalk) ... then they went and built that thing that we call "C++". 
I've heard it, but I couldn't hear them over my sighs of relief related to not having to use Java.
Eclipse has better refactoring, but aside from that I find VS to be a much smoother more responsive experience. Eclipse feels like design-by-committee to me. VS is big too but it feels like there's a bit more vision behind it.
That's one of the reasons that Gosling really restricted Java when he defined it (as a step "forward") from C++. He really screwed the pooch (or Sun locked the pooch down too early. Or something). with some of his VM architecture/byte-code decisions. It took the industry years to build anything with decent performance. The VM used with Inferno (a register-based, orthogonal ISA VM) was very nice and easy to implement on most advanced CPUs of the time.
Yes, and I laugh and move on. Anyone that dumb isn't worth my time or yours. 
There are more bad programmers than chimpanzees.
I'm typically a python fanatic, but lately my job has me writing Silverlight apps using c# and visual studio. It's taken me some time, but I'm warming up to the idea of a strongly-typed language in non-embedded scenarios. C# is growing on me as well, although I will say that you can't be as creative as you can be in python (perhaps intentionally). I don't however have any taste for Visual Studio 2010. 1) It's quite buggy for me and everyone I talk to in the office. Random features just won't work as you would think or don't work at all, and you end up having to use plugins to plug the hole in functionality. 2) More importantly, the coding philosophy of visual studio really bugs me: that all coding should be easy enough to make a you tube video out of. They design the IDE and the framework such that you should be able to click through a wizard and it should work, without you knowing what's going on and without them bothering to document what's going on. At least, I find this to be the case with Silverlight/RIA services/Entity Framework/WCF services. If you end up having problems with some of those opaque processes, often times you are forced to rely on the knowledge of the microsoft employees on MSDN or random bloggers affiliated with the Microsoft dev teams to figure out what's going on because the inner workings of those are not likely to be documented. What bothers me the most is that so many Microsoft devotees think that this is as good as it gets. I recently overheard somebody say that programming in any language/environment outside of Visual Studio is like the stone age. Heaven forbid you have to type some commands into a terminal instead of clicking the classic 'next', 'next', 'next', 'finish'.
If he does have a point it is not a very good one. Firstly Python is not typeless, it is strongly typed but does all the type checking at runtime. This has pros and cons, but to say Python is typeless is just plain wrong. Secondly most Java programs in existence do runtime type checking some of the time. Every time you do a cast in Java it does runtime type checking - before generics were added in 1.5 this meant every time you used a container class. Also frameworks like Spring put class and method names in XML files... lots and lots of XML configuration files. To use those names it has to do a lot of runtime type checking and reflection to find the right classes and methods. Thirdly Python is an excellent language for beginners - it has even been used to teach programming to children as young as eight. One of my favourite python quotes (can't remember the source, sorry) is: &gt; Java is designed to make it hard to write bad programs. Python is designed to make it easy to write good programs. I think this summarises the design philosophies of the two languages - Java was so focused on making it hard to write bad programs, they ended up making it hard to write any programs.
&gt;because they believe that Python is *slower* than Java. It is...
&gt; Then I have met some elitist people who strictly code in Java because they believe that Python is *slower* than Java. The CPython interpreter *is* slower than the JVM in execution speed. That's not a belief, that's fact. Whether or not it matters depends on what you need to do.
That doesn't necessarily translate to your *program* being slower, though. Architectural factors tend to matter a lot more than language ones for performance, and being able to prototype quickly can often buy you the time needed to actually profile, think about, and redesign for performance.
Yea its pretty neat stuff. When you really think about everything that goes into making a language work, the syntax is really a small part of it. But at the same time, I think its great that people can just focus on the syntax and not have to think about compiler optimization, and run time environments, and all the behind the scene stuff that really goes into making a language/platform/framework work, and work well (or not well, depending on the language :P). There's a whole universe of knowledge involved in understanding and mastering a languages syntax too, so I don't mean to belittle that angle... its just one piece of a much larger puzzle though.
&gt; Firstly Python is not typeless, it is strongly typed but does all the type &gt; checking at runtime. Okay. It's weakly typed. It's dynamically typed. Happy now? &gt; Secondly most Java programs in existence do runtime type checking &gt; some of the time. Yes, thank you. I have written code, too. There's a difference between doing this every now and then, and doing it EVERY FUCKING TIME YOU ASSIGN SOMETHING. Okay? &gt; Thirdly Python is an excellent language for beginners True. Utterly irrelevant to what I was saying, but certainly true, and a useful observation. &gt; Java was so focused on making it hard to write bad programs, they &gt; ended up making it hard to write any programs. While I do appreciate the quote, I think you'll do well to remember that there are actually some advantages to compile-time checking. Yes, this makes it harder to write stuff, but the machine will remove some of your bugs. But you've completely skipped my friend's point. Yes, good programmers can do good stuff in Python. But what about the crappy ones?
Perhaps, but in a situation where most pilots are chimpanzees, what's wrong with the approach?
Does it do everything you need it to? A way to generate a "goodness metric" might be to write (automated) tests. With good testing for code you'll maintain for a while, you'll probably learn techniques to write more maintainable code. Or be very busy.
This doesn't seem too realistic to me. Have you ever tried to get rid of a bad programmer? I thought not. It's not an easy thing to do. And even if you tried, how did it go? It's more likely to fail than to succeed. Whoever saddled you with this piece of shit probably knew what they were doing, but had to put him/her somewhere. (Hmmm. This is probably one of the few cases where I can leave it as "him" without anyone accusing me of sexism.) Bad programmers are going to remain programmers. They have to write *something*. PHP might be a safe place for them to go, but Python and JavaScript are not. Java is probably the safest of the lot.
Well it does exactly what i need it to do, no more, no less. If i have a problem, i bash out a python program and it does what i need. What do you mean by automated tests though?
You sound like Monty Python. "Ok, so other than sanitation, peace, proper roads, a decent legal system, a secure food supply, ..., what have the Romans ever done for us?" Java and Python are seriously different languages. There aren't many languages that comparison would come off as being substantially different from both. The ones I can think of are C, Prolog, (Common) Lisp, Smalltalk. Yes, well, SQL and XQuery.
&gt;They compile to the same intermediary code Yes, well, ultimately all languages compile to machine code. So what? They're all Turing-equivalent, but so what? Writing Brainfuck is very different from writing SQL. &gt; java and python, they're pretty equally matched in terms of &gt; standard Libraries, and speed, and use the same Virtual Machine &gt; style runtime environment. No, no, and no. The libraries are very different. Java is way, way faster than Python. And lots and lots of dynamic languages use VMs, but that doesn't mean the Python and Java VMs are the least bit alike. If you take even a moment to study the bytecodes for each you'll they're actually very different.
If you're writing stuff that you use once, and don't ever modify again, you may not need it. If you start to develop a library of code that you (re)use often, there will be benefit to having some tools that you can use to easily check that all of it's expected behavior continue to function as you change/improve your library code. I think python has a thing called "unittest" that provides a clean interface for writing tests for your library work.
&gt; This doesn't seem too realistic to me. Have you ever tried to get rid of a bad programmer? &gt;I thought not. It's not an easy thing to do. I've been developing software since 1987. I've gotten rid of lots of bad programmers. &gt; And even if you tried, how did it go? Things immediately improved. Other programmers no longer had to waste time fighting the fires caused by the aforementioned programmer. &gt; It's more likely to fail than to succeed. You sound pretty inexperienced in software development to me. I can't imagine why anyone would think that removing bad programmers from a project is more likely to fail. &gt; Whoever saddled you with this piece of shit probably knew what they were doing, but had to put him/her somewhere. Yes, which is why you need to do the same. &gt; Bad programmers are going to remain programmers. They have to write something. They can write bad code on someone else's project. Not mine. &gt; Java is probably the safest of the lot. This is probably one of the stupidest comments I've ever heard about programming. If a programmer is poor, they produce garbage. It doesn't matter what language that garbage is in... it's still garbage. Programming language choice isn't going to somehow make garbage any better. 
So kind of like a massive list of usage scenarios it runs through to check it gets the right output?
I'm not disagreeing with you, but if I buy a book on Java or Python, 99.8% of the contents of that book will be concerned with what you consider the "really small part". Again, just an interesting POV.
&gt; ....CPython interpreter is slower than the JVM... I been wondering about this - is it because, (to a large degree) that Sun/IBM optimized the hell out of it ? that python never had the that sort of singly-dedicated resources ?
The Visual Studio 6 debugger is still the best debugger I've ever used. I haven't tried any of the more recent .NET incarnations, though.
Nevermind that the turnaround between a Python module and C extension module has never been lower thanks to [Cython](http://www.cython.org/).
Get other people to read it and offer suggestions. See if they run screaming. Alternatively, read a bunch of other people's code, and figure out how it works: pretty soon you'll have opinions on what makes good code too. Some frequent signs of bad code, in my totally immodest opinion, are: * Duplicated code with or without small changes. * Parts of the code that don't actually do anything. * Function and variable names that make no sense. * Too little documentation for something more serious than a one-off. * Too much irrelevant documentation. * Huge maze-like functions * Mazes of tiny little functions * Premature generalization * Premature optimization 
I wrote a program once which required running a simple function thousands of times, and not much else. Dog slow. I rewrote (as direct an analog as possible) in Java, and it was much faster. There is probably an explanation besides "Python is slow", but you can see how one might draw the conclusion.
I think this is symptomatic of most CS students. At my school they tend to balk at stepping outside C++.
Thanks for the list. Where would you recommend i go to read others' code? github? Sadly i don't know anyone who knows python or infact programming at all, but if i ever write anything serious ill put it on github or something and see if i can get some notice.
Personally, I'd start with the Python standard library: lots of it is written in Python. Take a module that you use all the time, and read it to figure out how it works. There's plenty of stuff on github, too: some of it good, some of it less so.
&gt; You sound pretty inexperienced in software development to me. Dear arcticfox: getting rid of bad programmers is management. Not software development. Anyway, if you *were* able to get rid of them: kudos. &gt; This is probably one of the stupidest comments I've ever heard &gt; about programming. Lucky you. Python gives the shit programmer a horrible number of ways to fuck things up. locals()[varname] = whatever. object.whoanewattribute = otherclass.method; object.whonewattribute(7); etc etc etc. There is a vast number of perversities that are possible in Python, but not in Java. I use them correctly. But then I think I'm a good programmer. I think you can trust the horrible programmers to abuse these possibilties to fuck everyone up something royal. But feel free to disagree. If you argue for *why* you think so I'd appreciate that.
Yup, I see it like this: * Dynamic languages allows shorter programs. * Shorter programs means fewer defects. * Shorter programs are easier to maintain; which means: * You're done sooner.
&gt; Dear arcticfox: getting rid of bad programmers is management. Not software development. Dear larsga: the roles you claim exist are not so well defined on real projects. I've taken on roles from strictly programming, to a mixture between management and programming to strictly management. As a programmer, you're a fool to not be on the best of terms possible with management. Bad programmers cost money and jeopardize the success of a project. Demonstrating this to management is not hard and getting them to make appropriate personnel changes is easy when you give them the necessary ammunition. &gt; There is a vast number of perversities that are possible in Python, but not in Java. I use them correctly. But then I think I'm a good programmer. I think you can trust the horrible programmers to abuse these possibilties to fuck everyone up something royal. Here's a hint. Bad programmers can royally fuck people over even when using languages like java. If you don't understand that, I can only conclude that you have not written much software in your career or you have had exposure to few programming languages. 
Absolutely. When I was younger (say, late teens through early 20s) I loved to write code and would gladly churn out as much as I could. Once I became better acquainted with higher level languages and dynamic programming, I started to genuinely understand the _less is more_ rule in programming. Your ability to do things is not based on your ability to write code, but in your ability to create better and better abstractions. With better abstractions, your code has greater applicability into a larger number of contexts with the end result being that you write a whole lot less code. As you've pointed out, less code has fewer defects and is easier to maintain. I wish more people understood this. For me, I've never really been a big fan of java. Before using java in commercial development, I had used a lot of Smalltalk, c++, and Objective-C (yay NeXT!). While I find java a lot better than c++, I don't find it nearly as useful as Objective-C or Smalltalk. I started writing python about 5 years ago and it has really helped me to enjoy programming again... mostly because it allows me to write less code.
&gt; No. But I have argued a lot with a local Java guru who thinks typelessness is dangerous. I'm going to preach to the choir here, but tolerate me for a minute. Python isn't typeless. It's strongly typed. If you try and use a string as an integer, Python will explode - as Yahweh commanded it should. However, it is dynamically typed; I don't have to specify upfront what the type is - but once I select a type it is duly enforced. My view is the dynamic typing leads to better code economy. It takes fewer statements to achieve the same objective. This leads to fewer bugs, easier maintenance and more expressive code. All this means you deliver working code earlier - much earlier - than your Java counterparts. Your local Java guru's argument is self defeating. If Java developers are on the whole worse than Python developers, then the solution is to work with Python (where the developers are better) than to use Java. I've thought about requesting LISP experience in our hiring process for precisely this reason. Anyone who knows what LISP is already ahead of everyone who does not. Anyone who has coded anything significant in LISP is much more likely to be in the top 1% of software developers than a Java guy.
I'm a huge unit test fan but I have to disagree here. Your example is about checking output. His code checks input validity. Unit tests check that your code works correctly, not that it is used correctly. In shared code, a caller can pass in anything or get the args in the wrong order. If an argument is of the wrong type, you'll get a TypeError or AttributeError or some such Pythony error. Some coders will check the traceback or, gasp, read the doc string, fix it and move along. Others will freak. Just like in C++ or, when forced, C, I assert input validity. In Python, I consider the data type or required methods (ie hasattr(...)) as part of the contract and assert those too when useful. Asserts are living documentation. A doc string can get out of date. Asserts won't (if the code is actually used). Checking for asserts in unit tests is as good as it gets for verifying interface robustness.
I was exactly the same. I used to stand back in awe at all the awesome code I created, now I would feel like a tool for writing so much. What gets me is that these languages could still work the same way, just with much less code and more readability. For example, why is their a need for private keyword, when you could instead just prepend a double underscore. Why is there a need when instantiating to declare a variables type when the compiler could clearly infer that from the class you are instantiating. And on and on an on.
Hi e, nice to see you pop up in my reddits again.
I think I would say that syntax is just that silly stuff that some poor bastard is going to have to decipher in some distant future to maintain the bytecode running the company, but that's just me...
You should have a reasonable expectation that if you told another programmer what the code did, in a single sentence that they could look at it and concur that it probably did that, or conversely if someone were to read it for a few minutes, they could definitely tell what it did.
&gt; I started writing python about 5 years ago and it has really helped me to enjoy programming again... mostly because it allows me to write less code. Exactly! What matters is the ability to express yourself! LISP is more powerful than Python, in this sense, but LISP is much less readable. I write much of my code in Python because it's very nearly LISP, in terms of power, but much easier to read. Python allows for more powerful abstractions. Consider this contrived example: def add(x, y): return x + y In C# I would need to write this function 11 times. One for each data type: * byte * sbyte * short * ushort * int * uint * long * ulong * float * double * decimal That's a lot of code for very little gain.
I've heard this argument many times, and basically what it boils down to is that they don't trust the programmers and their team/corporate structure has no accountability for dealing with sub-par coding (which normally means no unit-testing, integration testing or other "modern" programming procedures)
Hey I know this is an aside, but when you said "toolkits". I was wondering. I am pretty new to the world of career programming. I can see that having some stuff that you use often kind of stashed away as being useful. Do you have any tips, recommendations or resources you could point me towards on beginning to build a toolkit? 
It's a bit misleading to say that Java makes it harder to write bad programs. Bad programmers can write bad code in Java and they can write bad code in Python. I think the advantage in Java is that it plays into the corporate blame game more nicely: in a statically typed language you are able to define "contracts" more easily. Also, runtime exceptions aside, you even have to tell what exceptions you'll throw and if you're implementing an interface that doesn't expect certain exceptions to occur, you'll have to handle them internally rather than being able to just clutter your signatures. Depending on the culture, this can be a very good thing. It allows you to define very low-level API specifications and easily see whether they are abided by looking at the source code (or the auto-generated documentation). So, no, Java doesn't make it harder to write bad programs. But Java makes it easier to compare the program against the specification. It doesn't protect you against incompetence, but it allows you to maintain some level of quality.
Now how much faster would it've been had you rewrote that function in C?
Heh... You've actually hit on a point that has been a pet peeve of mine for a long time. I see no need for _private_ (or protected or public, for that matter). When I programmed in Smalltalk, there was a culture that was built up around respecting what other programmers had done. Because all methods were publicly visible and all variables were inherently private, programmers would simply document methods that should not be invoked from outside of the class. Other programmers would respect that. When I started doing C++ programming, I found that the culture was quite different. C++ programmers seem to feel that they know better than everyone else and they do what they damn well please. In essence, I find that things like _private_ evolved out of attempting to solve problems that C++ programmers were creating for themselves. 
Compared to the Python version, likely much faster. My point is that such a thought was not necessary when I wrote it in Java, because it was fast enough.
&gt; C# is growing on me as well, although I will say that you can't be as creative as you can be in python (perhaps intentionally). Give F# a try sometime. I'm doing a Silverlight app with F# right now and it's just fantastic. (Yeah, bundling the FSharp.Core runtime increases the .xap download size by a couple hundred kB, but it's so worth it for my purposes...)
Yeah, the HotSpot JVM is hella fast due to years of R&amp;D in JIT compilation and adaptive optimization. Also, the JVM supports real thread parallelism, whereas CPython still suffers from its [Global Interpreter Lock](http://wiki.python.org/moin/GlobalInterpreterLock), rendering it unable to take advantage of multiprocessor systems. On the other hand, CPython is more lightweight and has a faster startup time, and that can be more important for some applications than raw computational performance. Fortunately, if the performance characteristics of CPython are a problem you can always give Jython (or IronPython, or PyPy...) a try :-)
The best thing that I can suggest is that you start to look for patterns that you see in the kinds of programming that you are doing. Most of my toolkits have come from getting tired of writing the same thing over and over again. It's hard to write generalized code from scratch, but once you've written the same stuff in three different contexts, it becomes quite a bit easier. A word of warning on this. Be careful and mindful of copyright issues. If you're being paid to write code, you don't own it and are not free to slap it into your coding library. All of my stuff has been written on my own time, outside of any contracting agreements. When I sign a contract for new work I do two things: 1) ensure that there are no clauses in the contract that give the contractor rights to things that I write on my own time; and 2) add a clause to the contract that allows me to introduce code from my own library while retaining ownership of that code. In support of this, I offer a non-exclusive right to use for the client. Basically, I explain to the business people that I've already got a lot of code that is probably of use to them. I own it, but to save development time and cost, I'm willing to allow them to use it without restrictions, but I need to retain ownership because I have used the code elsewhere and have granted similar non-exclusive rights to others. 
Just out of curiosity: what level of company are we talking here? Small, large or enterprise? Software as a core business or as one factor among many?
&gt; impossible to explain that for-loops aren't the same in Python Really? I mean, Java had for-each loops (`for (Object foo : bar) { ... }`) for quite a while. I know the Java ecosystem tends to be a bit slow, but most programmers should at least have seen this structure before.
And I've seen tons of computers where double-clicking a jar file would result in an "open file" dialog or a copy of the zip tool of choice popping up.
Well, the "really small part" is what you'll spend most of the time with. Such is the benefit of using high-level abstraction.
I can understand your point, but that isn't very pythonic practice, it breaks the duck typing. I should be able to make something that behaves exactly like your desired type and have it work. Python has a focus on user responsibility rather than the more C-like behavior of trying to protect programmers from themselves.
I totally agree, it is a really neat trick! Just don't let it fall into the wrong hands ;-)
Bc there code is crap and needs all the speed it can get?
Programming for newbies: 1. Write pseudocode. 2. Realise it's valid Python.
I can't say I don't envy static typing sometimes...
Nah, there'd be significant white space. Perl's the language that happens in, but at the same time, letting your cat walk across your keyboard is valid syntax in perl..
How much less time?
For me, code is good when: * you can work out what it is doing and why just by looking at it * there are consistent naming and formatting conventions * there are as few conditionals as possible * code is not duplicated except where to share it would obfuscate it further * it uses idioms common to the language while avoiding unnecessarily uncommon syntax * it produces the correct results All of the above tend to be interrelated somewhat.
Not really adding anything to the conversation, but Mr Cooke, I gotta say, LEPL rocks! For the uninitiated: http://www.acooke.org/lepl/
thanks!
Since '87, I've consulted for a wide variety of companies in a wide variety of industries. Some of those companies have been small (&lt; 10 employees), medium sized (50 - 500 employees) and others have been large 10000s of employees. In some cases, software development has been their core business, in others, software development acts to support their business processes. The larger companies I have worked for have not had software development as their core business. They have been oil companies, telephony, electricity producers, railways and the like. Those companies that were focused on software development as their core tended to be small start-up type organizations. How you get a programmer off your project depends on the politics of where you are. If you are in a smaller company, the decisions about who stays probably lies in the hands of one or two people. You simply need to convince them that the person should be moved off the project or that they should be let go. In a larger company, dealing with poor programmers is often easier. While it may be more difficult to get them fired, there is usually something else for them to do. I've had "intermediate" and "senior" programmers writing documentation. In those cases, I dealt with the complaints by sitting down with them, taking out their code and going through it line by line showing them why their code was not of production quality. I only had one really bad case. In this particular case, I was consulting for a company that was doing java development. The company was a small start-up and brought in some angels to help fund development. As per usual, the angels installed their own people in upper management. These upper managers hired a consultant who was, quite frankly, one of the worst programmers I have ever seen in my life. We were a java shop and whenever he did anything, he wrote it in visual basic. We would throw away his code and complain to upper management. Nothing would happen. Finally, he was assigned some work that was tied to some _penalty clauses_ in a contract that the company had with another company. Of course, his stuff didn't work, which meant that we missed the deadlines set out by the contract, which triggered the penalty clauses to come in to effect. They finally got rid of him after that.
Static typing is definitely nice in many cases. But when it comes to Java it comes at a huge price of wasted productivity. Haskell's static typing has it right though. I would love it if there was a Python like language with Haskell's static typing, if that was even possible. It would be a perfect language.
Well you're just familiar with it. The same way I am familiar with Unix development and the flexibility and power it provides. 
Lol to all you OO douchebags.
This. Dear Python devs: please add type inference to Python.
On average my Java programs take more ram than Python's. regex is also faster in Python. Asynchronous network programming in Python is very lean and tends to at least be on the same level as Java. Python offers lower response times on the Google App Engine for typical web requests. My point being is Java tends to be faster for computational tasks which is only normal since it is a statically typed language and it has one of the most advanced JVM, GC and JITs around. However more often than not heavy computational task rely on an existing algorithm which have been written in form of a C module or library. Java is pretty good especially for big projects. But there are a big number of areas where I think Python is superior.
python can be written functionally language if you want
GIL is mostly an issue for native threading. For heavy IO you should be using asynchronous networking, greenlet, gevent, twisted.. If you are doing a lot of computing you should use the multiprocessing module. 
Python supports all three paradigms (procedural, OO, functional). 
Well yeah, like I was saying the GIL means you can't do multiprocessing with CPython. This is about compute-bound threads. The multprocessing module is a cheap workaround for the GIL issue, not a solution to it. If you need real multiprocessing threads you have to look at other Python implementations. Fortunately a lot of apps don't need real multiprocessing threads, but this is a legitimate problem for some folks.
Whatever, @ your co-worker, static typing has it's benefits but even though you type your fingers off to give it types it is still not a type safe language. This exception for instance: &gt; NullPointerException Is one of the most annoying things about programming in Java. And despite painfully redundant brand of static typing Java makes you do, you still can't trust it to be type safe. In Python you can (should) practice test driven development and you will still be heaps more productive than a Java developer who cuts corners by not writing any tests.
Java is the "bowling with bumper lanes" of programming languages. That's not an insult. That is an extremely accurate characterization of the design intent of Java. It is highly structured to keep everyone funneled in the same direction. It's made so that mediocre programmers on a team can't hurt themselves and the rest of the team. It reduces the ability to do something stupid by taking away options and flexibility. Of course, that also takes away the ability to do certain things that are novel and clever. It's like a highly-railed first person shooter with invisible walls everywhere to ensure you can only go in one direction. As a result, it seems a strange choice for someone to claim "real language" superiority with. Anyone doing that is probably one of the guys that the bumpers were created for. C programmers would laugh their ass off at the Java guy spouting off about "real" languages.
GIL is annoying I agree don't get me wrong. Just suggesting potential workarounds. 
Btw, your code, which uses phi, has to use doubles, which on larger n has underflow errors and loses precision. 
what does that have to do anything? i thought eggs did not serve the same purpose as JARs....
Something I miss more and more in python is haskells type classes. If I want to know something is a number it's annoying to check every possible type rather than just have a catchall 'number' type. 
How is c# similar to c?
what does that mean ?
Pro tip: Objective C. But visual studio is a one the best IDEs. It's not just it, it's also all the 3rd party plug-ins written for it. I wish Microsoft would open source it. 
Microsoft's WinDbg is easily the best debugger I have ever used on any platform. It's far better than the VS debugger and I highly encourage any Windows developers to take the time to learn how to use it. It's fantastic.
IMO python weakness is its slowness. guess that's the cost of readability
My grad work was in computational theory and languages. I programmed in a whole bunch of languages and studied even more of them. Python is - hands down -the most elegant, usable, well thought through HLL I've ever seen. Unless I have to resort to assembler, Python is my #1 lang of choice. Nothing else is even close. Not a fanboy, but a grown up professional ...
i like the analogy
Python is NOT typeless, nor is it loosely typed. It's strongly typed and dynamically typed. http://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language
Try WingIDE for python or kdevelop for pretty much anything. WingIDE does cost money beyond the basic version though.
I'm not a C# programmer, but I'm pretty sure you could just write that function once using generics. Something like: public T add&lt;T&gt;(T x, T y) { return x + y; } I don't think that's much worse than the Python one to be honest.
I do consider syntax to be a superficial detail when two languages have so much else in common, but it looks like I'm in the minority. Your opinion will vary accordingly I'm sure.
C# is a fantastic language and VisualStudio is, hands down, the best IDE available. I always felt dirty programming in it though.
I know C++ programmers who think that java isn't a really programming language now. I don't think many people take C++ programmers very seriously.
I remember there was a similar tool but for multiple languages?
I've programmed in F# and honestly I would suggest staying as far away from it as possible.
Yeah, it was really awesome he screamed and flew 20 ft across the parking lot.
One of the reasons they added the function annotation syntax was so this could be implemented outside of the core language. Get workin' ;-)
A stack-based VM essentially pushes the results of an expression onto a stack, and then pops those values off the stack to perform computations. They don't emulate the register architecture generally found in processes.
You do know you can write c# on Linux or a Mac or an iPhone, right? 
You are right, but they really have shoehorned a lot of dynamic language support into C#. So now you have none of the benefits of a strongly-typed static language, with none of the true benefits of a dynamic language. For instance, you can't do def thingy: a = 1 b = 2 return a,b in C#, and there's no return type overload.
Its also because dynamic languages are harder to optimize. Note that jython isn't nearly as fast as java although the jvm was designed mainly for java originally.
&gt; There are more bad programmers than chimpanzees flying planes. Fixed
I'm not sure that your qualification is necessary.
Someone gives you a new requirement 6 months after you originally implemented the code. Is the code modular and easy to extend? If you can extend it with a minimal amount of pain after not looking at it for 6 months then it's good code.
You need to get an understanding what clean code means before you start to write it. I found this book very helpful: Clean Code by R. Martin It's Java oriented but the principles apply universally. 
slowness is most of the time the cost of silly programming. If someone is doing silly things, every programming language is slow. 
Why? F# is great, it's basically OCaml for .NET.
Even the most trivial thing to do in C# took more lines and more time in F#. Never liked OCaml either, had to learn F#/OCaml for a class at uni, never programmed in it again. If I want a functional programming language I'll look at something like Erlang, Scheme or Arc. 
Programming for newbies: 1. Learn Python first. 2. Have a blast programming. 3. Decide to move to a compiled language. 4. Spend unholy amounts of time trying to understand why do you have to wait so much for something that used to be instant (compilation), why can't you use famous libraries because building them on Windows seams to be at a Jedi Trial level of complexity, why do you waste copious amounts of times following a step by step make procedure only to see it fail at the last step because the page is old and the libraries versions are different, the Visual Studio has moved to a new version and nobody in that library's developers team gives a flying fuck about the Windows newbies. 
Think about it, for a website, which takes longer: CPU spinning or getting that bit in and out of network stacks of the traceroute nodes over the world wide web?
YouTube, too?
The speed requirement for a scripting engine around a core engine (which is usually C for speed) is more lax. These wrapping layers often place more value and emphasis on flexibility and expressiveness, which Python is strong in.
The whole Silverlight/RIA/EF/WCF stuff should not be taken to represent Visual Studio and C#. I completely agree in that there is way too much automagic stuff happening in the background. I think this is about as bad as it gets in Visual Studio, and for the most part makes any real dev cringe. Perhaps try an MVC web application, simple yet effective and you write all the code. There are some helpers if you get stuck but they are just generating templates. Bottom line: Remember that you are leveraging Microsoft's most enterprisey frameworks that has , IMO, actually been built for people that either don't have any time or don't have a very good programming knowledge.
If you need real multiprocessing, you are more likely to shoot yourself in the foot with threads. Just because the OS presents an *illusion* of a single shared memory address space, doesn't mean the hardware will support this efficiently (it won't). If you are sharing lots of resources between CPU-bound threads, expect crap performance regardless of your language. Threads provide programming convenience, *not performance*. Python's multiprocessing module gives you the performance advantages of multi-core but requires you to think about how your processes/threads communicate. I agree this may add some design effort but ultimately it will perform better than the "just use a thread" approach. Calling the multiprocessing module a workaround glosses over this. The GIL brings more pros than cons (removing the GIL has been tried more than once and the costs outweight the benefits). With the GIL you get easy threading for IO-bound purposes, easy C-extensions and maximum single-threaded performance.
Wow I kind of thought ipython is dead...I like it much more than bpython. *happy* When did they re-pick up the development? The last time I checked the latest release was more than a year old.
All *three* paradigms? Prolog is sitting over there and would like to have a word with you.
 &gt; So now you have none of the benefits of a strongly-typed static language Templates/Generics are still strongly-typed and checked at compile time.
Make sure it follows [PEP 8](http://www.python.org/dev/peps/pep-0008/)
or get dynamic programming for free with lru_cache (need Python 3.2 ) from functools import lru_cache @lru_cache(maxsize=None) def fib(n): if n == 0 or n == 1: return n else: return fib(n-1) + fib(n-2) for i in range(36): print("n=%d =&gt; %d" % (i, fib(i))) real 0m0.085s user 0m0.083s sys 0m0.000s 
What's new?
You need to get your code out there,where people will notice and comment on it. There is always someone less knowledgable than you. Wait for a newbie question on comp.lang.python or stackoverflow, then answer it. If a better answer comes along then think about why it is better than yours. Voila! Lesson learned. 
Psh you two and your silly "interpreted languages," real programmers make sure they get to machine code ;)
Yeah, you really need to add ReSharper to VS to bring it up to snuff. Still, even without it, VS beats the refactoring in XCode 4.
Every day. We continue to produce code that amazes them it's written in Python, though, so we win ;)
Guido himself hasnt rejected adding otpional static typing sometime in the future . He has even written about it in his old artima blog. And you can also use enthought's Traits lib
I guy I work with programs mostly in Perl. He says java is "just a prototyping language". 
I program mostly in perl as well, but am branching out into Python. I pretty much despise Java programs and therefore have no desire to ever learn Java.
Yup. Don't start massive though. Start with, maybe 3, and grow it as you see useful.
very cool! It could be better if the user had the option to select which version of python they wanted to search.
Yeah but saving the state of the procedure really is equivalent to delaying a computation.. I agree that they are not _evaluated_ lazily.
ShedSkin does type inference, hopefully with Python 3 it will be able to use hints in type annotations to go faster.
Sure, I said VS "wasn't that good an IDE", Xcode is downright bad as an IDE (though Xcode 4 improves things dramatically), it's a souped-up editor.
I was referring to dynamic function calls and the like. Templates are compiled by the JIT so you wouldn't notice a bug until you tried to view the template and bang! implicit casting error.
Most programmers were not bad, java made them below average.
Do you know matlab? If so, this will be a piece of cake--many functions are even named the same way. R is slightly more different, but it should also provide enough experience. In the end, you'll need to learn syntax and function names... Try following the official python tutorial or Learn Python the hard way. I don't know any good tutorial for numpy/scipy, I usually just look up things in the reference.
No, I don't know Matlab, but I will need to know a little bit of it too, since part of my work will be to convert matlab scripts in Python/Scipy code. In those 2 weeks I have, what is in your opinion THE book I have to read?
http://pycon.tv/ also :)
Python, MATLAB, SciPy, NumPy and matplotlib all in two weeks? Try the bible.
Jesus dies at the end.
This is a very interesting read. Thanks. although it concentrates on what the code should look like, not the actual content. Still, i shall bear it in mind.
One important cost of allowing pyc-only distribution is that it causes lots of head aches for programmers. For example, I've run into problems when moving a py-file to a different directory but leaving a dangling pyc-file (helpfully ignored by git). Suddenly, any import statements in the directory where the stray pyc file is located will use the pyc file instead of the actual library, causing no end of confusion as the library is imported and seems to work, but any changes that are made to it are silently ignored. Kill the pyc, I say.
This. I didn't think this was a difficult thing until I started working with some "smart" coders. Once they left the project their code was thrown away because it would have taken longer trying to understand it than to fix it.
Haters gunna hate
I don't know. I learned python from the official python tutorial, and this was enough for me. And lots of people were recommending "Learn Python the hard way".
Yes, you can learn Python in two weeks. You better get started right away. As for SciPy, just pick it up ASAP after you got the basics of Python down.
Definitely not. I have been using linux and coding with emacs forever and it is fantastic. Recently I had to work with C# on windows and it was also fucking fantastic. The language is awesome, the IDE is almost perfect (you know, as perfect as can be without the power of customizability that emacs offers).
I feel the same way, it is too bad it isn't free.
Why wouldn't he know? The VS IDE beats it, though.
Refactoring for what language? It is flawless in C#, in my experience. Can rename anything, shit just works.
Yes, if you already know C, Pascal and R, it should be really easy. The book "scientific programming with python" might be worth looking into, it quickly introduces the python basics, and then moves on to scipy, numpy and easywiz (which is a frontend to matplotlib et al), and shows how to do various things with it, like ODE solving, linear algebra, some sound-processing and other signal processing and such. It's all pretty basic, though.
So true. I used to be a 'smart' coder and used a ton of fancy tricks and clever code (a hangover from my assembly programming days). This is not a good idea, code is for human reading as much as it is for computer parsing.
Use QA tools like [pylint](http://pypi.python.org/pypi/pylint).
Please tell me you're trying to make a funny, and you don't really believe refactoring is limited to renaming stuff.
Is it [this](http://www.amazon.com/Scientific-Programming-Computational-Science-Engineering/dp/3642024742) book you're talking about?
&gt;At this point, all IPython development resources are focused on the 0.11 series that includes a complete architectural restructuring of the project as well as many new capabilities, so this is likely to be the last release of the 0.10.x series [from the changelog](http://ipython.github.com/ipython-doc/stable/html/changes.html#release-0-10-2) I think ipython is one of those projects that a lot of other projects are built on, so development goes a little slow
Wasn't Microsoft handing out Visual Studio Express for free?
Wow, thank you for that. I had no idea [Traits](http://code.enthought.com/projects/traits/whyusetraits.php) existed, looks very interesting. I am actually going to give Traits a try on my next project.
SWT is pretty nice.
Yes, it is. If you're really short on money, perhaps I can hook you up *wink wink nudge nudge*. Most of the exercises in it aren't really that great (ambiguously or confusingly worded), and a lot of the text is just more or less copied/rehashed from the documentation from the individual projects, but it gives you a coherent, connected path to getting to know the tools.
There's no easier way to learn programming than when you have a well-defined project.
Nice thanks, I already, hum, do*cough* oaded *cough* it. I think that I will begin with "python the hard way" during 2 to 3 days and then work with this book for the rest of the time. I don't need to be an expert in Python, so I think it's feasible.
I need python to work on macroeconometric models. The project is well-defined, but now I need to learn python.
Make sure you got the newest version, then. If you start with the hard way, you can probably jump over some of the stuff in the beginning in scientific python.
If you're a student, you can get the professional version for free.
hi I have been looking into thir for months now. i was seeking something that could create a network of ladspa/vst plug-ins. and command them through midi. no real-time or intensive computation in python required. just the basic network commanded by python and controlled by midi, + maybe real-time audio input. cant find anything. reaper can be controlled by python though.
I think it's more a matter of how well you were at understanding concepts in your other programming. Once you understand those concepts, they're usually the same in other languages, but with a different edge on how it's done between languages (syntax, ease to carry out certain concepts, shortcuts to carry out a piece of logic)
Sweet docs I say
The tutorial doesn't have exercises whereas LPTHW does. Exercises are essential for learning anything, doubly so for programming. That said, I recommend that newbies first read the tutorial twice, then move on to LPTHW. I find the tutorial much more comprehensive.
Were using python, and I even get paid.
I love Django. And I also have that Design Patterns book. I need to get back into it, actually. What sort of project are you doing in Django?
Head-first-python is good but "Learn Python the Hard way" is not to be missed. The two books compliment each other nicely. http://learnpythonthehardway.org/index 
I propose : - install stuff with python(x,y). That includes Spyder. - find online Scipy/Numpy tutos about or close to what you're trying to do - paste in Spyder, evaluate the snippets (you can line evaluate as in R) and tinker with it. You'll quickly have a voodoo trivial example for your stuff, and the beginning of a feeling for the code. Going further is probably going to require some familiarity with lists, dicts, and numpy.arrays. No real dataframes there, so watch out your arrays initialization and the merging operations. Also, maybe : try pandas (dataframe like, I haven't tried it), try a scikit (time series, stats)
o_O really? F# code is usually much shorter than its imperative counterparts (granted you do need to stop frequently and think about what it is that you are coding up), unless you are using more than just a few refs/mutable types in your F# application or if you're not using any of its functional capabilities, in which case you're doing it wrong. I don't know, maybe it's just me, but in my experiences, ocaml is delightful.
A Travel-related website, more of a hobby really.
I haven't looked at Head First Python specifically but I find with any of their other books that you have to be quite the newbie to find them useful. Otherwise they're too simplistic. I would suggest Learning Python by Lutz if you really want a print book.
I'd recommend http://packages.python.org/jython-swingutils/ but it's for Swing
As far as I know, Youtube isn't written in Python anymore.
Consider [PyMOTW](http://www.doughellmann.com/PyMOTW/) for an incomplete but awesome reference/example for the standart library.
I mean free as in freedom (free software movement), not as in free beer as they like to put it.
Would you mind elaborating on why you don't like Java? I've been programming in C++ and Perl. I've just recently started looking at Python and Java. The programmer I mentioned gave some reason he doesn't like Java, but (in my not so humble opinion) he's not a good programmer. 
Also read [PEP 20 by example](http://artifex.org/~hblanks/talks/2011/pep20_by_example.html) origin [PEP 20](http://www.python.org/dev/peps/pep-0020/)
Also read [PEP 20 by example](http://artifex.org/~hblanks/talks/2011/pep20_by_example.html) origin [PEP 20](http://www.python.org/dev/peps/pep-0020/)
Well, I'm quite the newbie concerning to python :) I'm looking for a good book to get me introduced to different concepts in python.
Thanks, but for reference/example I have google... I'm really looking for a light reading to get me aware of different concepts in python that i can use/google later on.
Also read [PEP 20 by example](http://artifex.org/~hblanks/talks/2011/pep20_by_example.html) origin [PEP 20](http://www.python.org/dev/peps/pep-0020/)
You must have been reading it wrong; the first four chapters are basically one big spoilerfest...
Hey, I know this guy! Pay your respects to [Al Sweigart](http://www.reddit.com/user/AlSweigart). Very brilliant guy.
I'd love to see some benchmarks of gefr, particularly against CPython WSGI servers, particularly on a machine with lots of cores =]
nice list I'm kind of on the fence on duplicated code, I've written stuff than refactored it to be as dry as possible(lots of little functions), and then when I went back to read it months later, it took a lot longer to figure it out. So maybe there's probably a subjective balance between too dry and too much duplication 
Huh? I strongly disagree... I find F# to be much more expressive and succinct than C# and the like, particularly when you're working on more in-depth programming tasks where you can really take advantage of FP. Do you still have any examples lying around of this F# that was more verbose than C#? I'm curious... I agree with you that Scheme rocks, however :-)
And once you feel competent, [Python Essential Reference by David Beazley](http://www.dabeaz.com/per.html) is a very good *printed* reference for the language and standard libraries.
Nope, I don't have any of my F# work saved.
You could also use Python's built-in [cmd](http://docs.python.org/library/cmd.html) module, which has some other useful things already built into it.
Yes but you have a programming background already. After Head First Programming the rest can be too basic - I have Head First C# and Head First Java and found them too introductory. I imagine Design Patterns could be worthwhile since it's not focused on coding. 
Reading the Python standard library is very helpful. The Zen of Python has some good tips, which you can get to by importing this or looking up PEP 20. Actually, I opened up the this module the other day and it made me very happy. Also, using PEP 8 standards can help make your code more uniform and readable. 
[Dive into python](http://diveintopython.org/) is another good book that is freely available. It moves a bit faster than Learn Python the Hard Way and the format is closer to a traditional book. It's also a slightly dated (there's an updated version for python 3, but a lot of the scientific packages aren't quite ready for python 3). On that note: you'll have to be careful with arch linux, as they jumped the gun a little bit on python 3... so just be aware that you'll want to explicitly run and install python2. As far as IDEs: I work with a few folks from various backgrounds that are new to the scientific python programming ecosystem and most of them like Spyder. I haven't used it a whole lot, but I haven't noticed or heard of any stability problems and it does a lot of great things out of the box. You don't really have time to mess around with IDEs so just pick one and learn it.
Honestly, this is one of the greatest Python books out there. And it's free!
I don't use autocomplete for anything, so I guess I just don't have such a problem.
If you mess around with the REPL as you code, dir() and help() can give you similar functionality. PyDev for Eclipse also helps a bit. I don't believe it can guess parameter types, but it does seem to provide code completion when object types are more obvious.
Note: requires Python 3, as noted halfway down the Python installation page (Chapter 1): &gt;Important Note! Be sure to install Python 3, and not Python 2. The programs in this book use Python 3, and you'll get errors if you try to run them with Python 2. Example errors from "Chapter 15 - Reversi" include the use of an end=' ' inside of a print to denote that a space instead of a newline should cap the printout, and if you don't answer questions inside of quotes, they are treated as objects through input() in Python 2 rather than as strings. I.e. if it asks if you want to be X or O, and you type either with no quotes, it errors out on that character being undefined.
I'm one of the spyder devs and I sincerely recommend it. It has an integrated console, help and variable explorer, it's quite lightweight and very similar in concept to RStudio, another great IDE but for R. To learn scipy, I recommend you to read these notes: http://scipy-lectures.github.com/ It starts with a short introduction to python and then describes scipy, numpy and matplotlib in depth. I don't know about "Learn Python the hard way", because I think it focuses too much on syntax correctness. Python is a very easy language to learn, it's almost like pseudo-code so I don't think you'll have much problems on that front. For statistics, check this page out http://aliquote.org/memos/2011/02/07/python-for-statistical-computing Hope this helps
Not meant to discourage you, just a nice read from one of the top programmers of the world: http://www.norvig.com/21-days.html That doesn't mean you won't be able to get working code out after 2 weeks learning. But learning programming goes lightyears beyond knowing the syntax. Start as soon as possible. Let things settle in your mind.
Now this is really hard to read. Another font and text size? 
this posting really is missing the point of JIT'ing/lazy thunking; it's not remotely equivalent if you get a callable back to go access it. Someone mentioned namespace thunking (demandload, basically), but a *good* object level JIT'er is http://api.pkgcore.org/snakeoil/trunk/api/snakeoil.obj.html . Exempting when you're trying to lazy instantiate a builtin (lists/tuples) which the interpretter can vary it's behaviour on since it can see the actual class directly, that code is the best I've seen/come up with for transparent delayed instantiation of instances. Plus it's generic; you can just return a delayed instantiation and consuming code really doesn't know the difference (and the instantiation code doesn't fire till it's actually needed).
... but the intentions are good.
Also the nice thing about this book is that the author is a redditor who will answer programming questions you email him. :)
You can try apache pivot, which is another gui toolkit available for java. I think it's jython compatible.
How much did you pay for those 35, 5 start reviews on amazon? Just Kidding. Thanks for the awesome book!!!
If you've already got some background in programming, I think you'd be better off looking elsewhere than Head First Python. As you are probably aware, the Head First series is great when you want to learn a subject but have no idea where to begin. If you pick one up with a specific goal in mind, or you already have at least a foundation in some of the concepts, you'll likely end up disappointed or frustrated. Head First + an accompanying reference guide is a winning combination for new starters. 
I've used this a bit, I had forgotten about it. Great resource. Thanks!
What you are saying is "I use function argument types as documentation". Well, use documentation instead. Put a description of the function arguments into it's docstring. That's what docstrings are for (and a description of the function as well). Some of the better python IDEs (pydev, Wing, PyCharm) do decent autocomplete, prompting you with argument names and the docstring. In fact, python-3 supports function annotations, which permit you to attach arbitrary metadata on to each function argument (and also the return value). In future, I expect we'll see IDEs take advantage of this for improved autocomplete. Finally, IPython is an indispensable tool. I typically keep at least 3 IPython windows open at any one time; if I'm not sure what an object/function/metho does, I type it in the IPython terminal and get tab-completion on all attributes and type &lt;object&gt;? to get its docstring (these are, in effect, shortcuts for the built in help and dir functions).
Mostly because I've never used a single java program/app that didn't run extremely slow even on powerful hardware, or have major memory leaks or bugs. I know in a lot of cases this isn't Java's fault, but I've yet to run into ANY java program that ran efficiently or without memory leaks. I've pretty much given up on giving it any more chances.
yeah..and after that he is resurrected 
To validate the field you can duck-type the cgi.FieldStorage object by checking if ``hasattr(request.POST['my_input_field_name'], 'file')``. You can also grab the ``filename`` attribute, but it's not really a good idea to use it for anything without sanitizing it. WebOb's Request will write the uploaded file to a temporary location if it is larger than some threshold, otherwise it will be a StringIO object, either way you can loop over it and read the data in chunks, writing to the desired destination: field = request.POST.get('my_input_field_name') if not hasattr(field, 'file'): raise TypeError('not a valid file field') while True: data = field.file.read(8192) if not data: break # do something with your data out.write(data)
Thanks to his friends who went to Namek and found the Dragon Balls.
Yes, there's no reliable way around this and it sucks. There's a huge difference between having all necessary information literally at the tips of your fingers, and having to switch to documentation/repl/whatever. However most modern python IDEs (including free PyDev) use heuristics to some success. When you write '`obj = MyClass()`' you always get autocompletion after '`obj.`', then it tries its best to figure out the type of a variable or parameter based on its fields you've already accessed, and so on... The important thing about all this is that it's just an annoyance. It's very annoying, like trying to take a small object while wearing thick rubber gloves, but after you overcome the initial shock it is not actually crippling. Yes, you code a little bit slower because of that, but then you code a little bit faster because you don't need to write type annotations, and all in all it's not the most important thing about your code and coding by far. PS: And if you're into all this Stockholm syndrome stuff, you can even try to convince yourself that this stuff is useful, because it builds character, trains memory and forces everyone to make simpler interfaces =)
&gt; What you are saying is "I use function argument types as documentation". Well, use documentation instead. Put a description of the function arguments into it's docstring. That's what docstrings are for (and a description of the function as well). No, what he is saying is "In C# or Java the IDE shows me docstrings for arguments, fields and methods as I type (because it knows where to look), in Python I have to alt-tab to actual documentation".
that's what lazypy on pypi does in a way - using the pythom magic methods to trigger evaluation of lazy values.
Thanks a lot, I already installed Spyder and it looks great as do those notes. I also installed the scikit for statistics, but do you happen to know if there is something for econometrics by any chance? 
Ok, thank you for the warning, I think I won't take any chances and work with my laptop which has ubuntu on it which still has Python 2. I'll follow your advice and use Spyder it looks great.
Have you tried PyCharm? It does all of the things you said only C# and Java have in IDEs.
I see, I wanted to make sure I wasn't idiomatically "doing it wrong".
I've been noticing that once you use a method on an object in PyDev, then it remembers that method and it can auto-complete if you want to call it again (same with PyCharm). It's a shame that it doesn't infer the type from one method use, and allow you to auto-complete on all other methods contained in that same inferred type (or even all types with that method).
I am using PyDev, and while it does do all of that things, it only does them when the code is simple enough to allow it to infer type information. It works when I'm at '`x = f(_`' where `f` is a bound function name, it works when I'm at '`obj = MyClass(); obj._`', and in many other cases, but it doesn't and can't possibly work when I'm at '`def f(x): x._`'. There's a perceptible difference between a feature that works in 100% of the cases and a feature that works in half of the cases. Note that I've written a response to OP here, where I say that in my experience it's not such a big deal, it's more annoying (if you're used to having this kind of functionality) than damaging. Still, it is annoying :( Also, is PyCharm significantly better than PyDev, to justify the price? I don't remember ever seeing a good comparison of Python IDEs by someone who used them for a long time. Which is important, because I'm not interested in difficulties one experiences in the first eight hours working with an IDE, I'm interested in long-term benefits that you don't discover immediately, such as PyDev's excellent F3 (go to definition) thing that's invaluable for looking up stuff in the standard or third-party libraries, or its visual debugger which Just Works™, or the way you can report a bug and see a response from Fabio two hours later, that he pushed the fix to the nightly build &lt;3.
My son has been working his way through this book. It is a great book and is very well written. The author did a great job of introducing programming in a simple and fun way. I had been looking for a good beginner book for a while when I stumbled upon this one. I originally printed the PDF of the book and he was using that, but it is such a great book and he used it so much that I bought a copy of it for him. Worth buying. 
Thanks. That was really neat :)
Hmm, well now that my dissertation is finished I guess I should work on the next Minecraft...
Assuming windows: 1) download and unzip [web2py](http://web2py.com/examples/static/web2py_win.zip) 2) click on web2py.exe 3) choose a password, for example 'hello' 4) visit http://127.0.0.1:8000/admin and login with the password above 5) in the browser use the form on the right "create new app" and create new app called "files" 6) click on [edit] controllers/default.py 7) A edit page pops up, append this and save it: def list_all(): import os PATH = 'c:' return dict(files=BEAUTIFY(os.listdir(PATH))) 8) Done. To try it visit: http://127.0.0.1:8000/files/default/list_all.html or to have the list in json http://127.0.0.1:8000/files/default/list_all.json or to have the list in xml http://127.0.0.1:8000/files/default/list_all.xml If you have Linux/Mac you can download the [source](http://web2py.com/examples/static/web2py_src.zip) or use [pip install](http://www.youtube.com/watch?v=f6cFkK2ZDPY)
Sorry, I don't. I only know there is RPy2 if you want to interface with R. Good luck with your efforts!
The chip EDA biz is adopting Python for a couple fringe elements. Generally scripting in this field is dominated by TCL and Skill, which is a proprietary LISP like language. 
That is a kind of stupid statement he made. The asserts are there to detect internal bugs in the library. Once the library has matured and these bugs hunted down, then no external input should make ZeroMQ assert. What he really should have said is that Version XX of ZeroMQ isn't quite ready for public facing servers. I don't know of the current version.
Seems like Ned's syntax highlighter gets the division vs regex issue right too.
is there a pre-python-3 version ?
If you're a python newbie I would suggest starting out with a micro-framework such as [Flask](http://flask.pocoo.org/), or [CherryPy](http://www.cherrypy.org/) or a heavily opinionated framework such as [Django](http://www.djangoproject.com/). If you want a more customizable then I would suggest [Pyramid](http://pylonsproject.org/) which allows you to pick and choose what you want to use at your discretion. With that being said, once you learn the basics of the framework (each of them can have you up and running in a couple minutes, especially flask as it's geared towards that). You can use the same example that mdipierro provided to return the output. Example (Flask): $ pip install flask or $ easy_install flask or download Flask (http://flask.pocoo.org/). $ vim testweb.py from flask import Flask app = Flask(__name__) @app.route("/") def list_all(): import os PATH = "/" # Assuming Linux return "&lt;br&gt;".join(os.listdir(PATH)) if __name__ == "__main__": app.run() The beauty of this is you just created a stand-alone webserver with just one file that is **very** easy to customize. I would suggest starting with a micro-framework such as Flask or CherryPy and then working your way up to larger frameworks such as Pyramid, Django, Web2Py which are much more geared towards a full stack experience (authentication, sessions, etc). Good luck! 
You can learn the basics in two weeks but you need much more time to master it. [Take your time.](http://norvig.com/21-days.html)
Heh. I will admit that I think about half of those reviews come from when people emailed me saying they liked the book, so I asked them to write an Amazon review. The reviews are in their own words, but there's probably a selection bias that skews them towards the positive end since people who don't like book don't seem to review it. Then again, I think this applies to all Amazon books. (Except the controversial ones, where all the reviews seem to be 5 stars or 1 stars.) Hey NinjaYoda, mind if I ask you to write a review? :)
There isn't, but you don't have to make many changes to the source to make it work with Python 2. Appendix A has them all: http://inventwithpython.com/appendixa.html Basically, use raw_input() instead of input(), and print() is a statement and has some minor differences (like with the end keyword parameter). Other than that, I don't think the Python 2 and 3 differences matter. (e.g. in Python 3 you need list(range(10)) to get a list, but in Python 2 either range(10) or list(range(10)) works, so you don't need to change it.) The Pygame programs all work in either Python 2 or 3 without changes.
If you want the source code to more Pygame games, I started a series on the book's blog called Code Comments. There's othello, tetris, memory, and a few other games: http://inventwithpython.com/blog/category/code-comments/ There's also a couple other games' source code here: http://inventwithpython.com/blog/category/games/
for the full PyPy compilation something like 2-2.5x less.
Agreed with the two comments on the blog so far. This is a standard incantation for me during development. from pdb import set_trace as stop
Thank you for this wise advice, right now I only need to be able to do some basic stuff (and some advanced stuff, but nothing to fancy), but I do want eventually to master it. 
This was really helpful, thank you so much!!!
Being spoiled by the Matlab debugger, I have to recommend [pudb](http://pypi.python.org/pypi/pudb) as a replacement for pdb in most instances.
Anything new or particularly interesting to look at?
As much as I don't typically like them, you could always do an AMA to answer general questions about yourself and about the book.
More HOWTOs here: [http://docs.python.org/howto/](http://docs.python.org/howto/).
FYI: Requires an uninstall first.
Assign this statement to a macro in emacs (of course you're using emacs :) import pdb; pdb.set_trace() # EVIL_DEBUG There you go. Slightly easier than the one in the article. The # EVIL_DEBUG is a string you should search for in your code before you commit, lest you commit a pdb and grind your production environment to a halt.
I'm really disappointed with Microsoft dragging their feet on Python development. I know they're working on it, and I'm probably being impatient, but it feels like it's taking them forever to add one of the word's most popular languages to .NET. It's almost like too little, too late.
hi drhankpym, Note that PTVS is an add-in for VisualStudio and it isn't directly related to Python the language. It *supports* both CPython and IronPython interpreters (eg debugging). IronPython, which was msft's implementation of Python on .Net, was spun out and is a community project at http://ironpython.codeplex.com/. So we're really not 'working' on Python, but rather support for Python (any flavor) through PTVS (which is also a free/oss project).
This is kind of an odd comment. IronPython has been one of the quickest-to-compatibility interpreters out there. I don't know who reached 2.7 final first (PyPy or IronPython), but IP 2.7 had a beta release 3 months after CPython released 2.7, so I think they are moving pretty quickly. &gt; it feels like it's taking them forever to add one of the word's most popular languages to .NET IronPython has been available for 4-5 years now.
Oh, I see. That's actually pretty clever, and now I feel a bit stupid for my previous comment. I guess I'm venting from a previous bad experience trying to get IronPython to work for me. It's probably better now (or it was fine and I was just being stupid back then), but I'm glad that this supports both interpreters. 
No worries... the naming kind of implies that it includes actual language interpreters, but it doesnt. It should be PTVS (BYHTIYOI) - PTVS but you have to install your own interpreter :). Maybe someday the lawyers will allow us to ship everthing bundled together... i've heard it's healthy to daydream...
I am not sure if it's still out there, but when I was learning python, my first book was the reference manual and the quick python tutorial included with python. Dive into Python then covered everything else... But I did start around python 1.2.
I once wanted to record a broadcast, and tried many ways. I settled with the outdated and unmaintained, but working outrec. On linux. I hope this does the job too.
I once wanted to record a broadcast, and tried many ways. I settled with the outdated and unmaintained, but working outrec. On linux. I hope this does the job too.
I once wanted to record a broadcast, and tried many ways. I settled with the outdated and unmaintained, but working outrec. On linux. I hope this does the job too.
If you use [winpdb](http://winpdb.org/) you can even remotely debug your program and it's cross platform. 
&gt; The addition of the model layer and all the niceties that come with that (usually nice but sometimes just an unnecessary extra layer) Honestly, I prefer SQLAlchemy's ORM over Django's. That's not to say that I think that Django's ORM is bad - it's great for most of the cases I've encountered, but there have been times when I really, really wished plugging another ORM into Django was transparent.
I agree, SQLAlchemy lets you work in either mode (ORM or more low level) without any hassle. As far as the template language, if you liked Django's, try [Jinja2](http://jinja.pocoo.org/docs/). :D 
Thanks, I need to implement proper logging in my project!
&gt; use a webframework like flask Done! Your suggestion was taken, and made a criteria for my [0.02](http://code.google.com/p/stattr/downloads/detail?name=stattr-0.02.tar.gz&amp;can=2&amp;q=) release, corresponding to [revision 19](http://code.google.com/p/stattr/source/detail?r=19). Thanks a bunch, and feel free to rip me new ones if I screwed up something else :P
&gt; Stand on the shoulders of giants Done! Your suggestion was taken, and made a criteria for my [0.02](http://code.google.com/p/stattr/downloads/detail?name=stattr-0.02.tar.gz&amp;can=2&amp;q=) release, corresponding to [revision 19](http://code.google.com/p/stattr/source/detail?r=19). Thanks a bunch, and feel free to rip me new ones if I screwed up something else :P
Hi! I took a few of your suggestions into account in my latest release, [0.02](http://code.google.com/p/stattr/downloads/detail?name=stattr-0.02.tar.gz&amp;can=2&amp;q=), corresponding to [revision 19](http://code.google.com/p/stattr/source/detail?r=19). I'd appreciate it if you could give it another try, since I get my best suggestions from Reddit, even if it means more work for me! Thanks a lot!
&gt; should have used Flask Done! Your suggestion was taken, and made a criteria for my [0.02](http://code.google.com/p/stattr/downloads/detail?name=stattr-0.02.tar.gz&amp;can=2&amp;q=) release, corresponding to [revision 19](http://code.google.com/p/stattr/source/detail?r=19). Thanks a bunch, and feel free to rip me new ones if I screwed up something else :P
If you make a directory ./static, Flask will serve all the files there at domain.com/static/
Learn by practising. Try this website: http://pyschools.com. 
Hm, that would make it easier :/ I smell 0.02-1 0.02-1 is released, made the code slightly smaller....
How is this different from the IronPython tools? How is it better/worse?
It's based upon the same code based as the IpyTools but it includes support for normal Python as well as IronPython. That includes a new debugger (which works w/ any Python implementation), a profiler (CPython only), support for automatically deploying and running MPI applications (CPython only), built-in support for a IPython repl, and support for multiple versions of the Python language (2.5 - 3.2). In addition to the new features there's also tons of bug fixes over the IpyTools and little tweaks and improvements here and there. Meanwhile it continues to support the IronPython specific features such as WPF designer support and Silverlight debugging. 
*Why does this exist and how can we stop it?*
I would appreciate any comments on here, or on the blog. Thanks, all!
You are far too slow, April fools day was almost two weeks ago.
Haha, I had a client who needed HTML emails — which is an absolute pain to write inline CSS for. Found this package tonight, and now I can just write them like standard web pages.
Does a `&lt;style&gt;` tag in the header not work?
I mentioned Jinja2 buddy ;]
I've been told — unable to verify this, though — that older versions of Outlook use the Microsoft Word rendering engine ([here's one old article about it](http://groundwire.org/support/articles/css-and-email-newsletters)), so I've been using inline CSS. 
The algorithm is pretty standard. I'm not sure how well PyPy handles recursive functions though. I can't imagine recursive functions are that easy to optimise within a dynamic language.. but I'm not computer scientist, so might be talking out my arse.
Urgh.. my apologies, I certainly didn't mean to be insulting. Looking back at how I said what I said I can't see how on earth it could be taken elsewise :-/
Not sure if you're still reading this, but there is [an article](http://arstechnica.com/science/news/2011/04/high-performance-computing-on-gamer-pcs-part-2-the-software-choices.ars/2) about the HPU4Science cluster in France. It's run using almost entirely gaming spec machines (master machine uses a pair of Xeons, but that's only non standard thing) Relies on GPUs for the bulk of the processing, and they've chosen Python with [PyCUDA](http://mathema.tician.de/software/pycuda), along with [Sage](http://www.sagemath.org/). 
Sure, or you can do it manually for previous versions fairly easily with a dict object. def fib(n): if n == 0 or n == 1: return n if not memo_fib.has_key(n): memo_fib[n] = fib(n-1) + fib(n-2) return memo_fib[n] memo_fib = dict() for i in range(36): print("n=%d =&gt; %d" % (i, fib(i))) results in an even quicker result than your lru_cache.. though that could be machine spec difference. Also some rough testing using the time module figures that we're talking about 0.00028s for the actual math, meaning a good portion of that time is just the overhead of loading python anyway. real 0m0.017s user 0m0.012s sys 0m0.004s 
Huh, interesting. TIL.
Yes and no. Its not safe to do it that way if you are sending to multiple email clients.
I'm still wondering why this exists. Is it the email use case or what is it? Depending on the packages pyliner uses this could potentially be something that takes quite a while to write, so I hope they must have a good reason for doing it.
I do this: from pudb import set_trace; set_trace() Though 99% of the time a few print statements get me where I am going. Perhaps my job is too easy :D
Another trick, especially useful when your program hangs: import signal, pdb def int_handler(signal, frame): pdb.set_trace() signal.signal(signal.SIGINT, int_handler) #Put it at the top of your script and you can start debugging #at any point by typing Ctrl-C. Resume script execution # by typing exit at the Pdb prompt.
Reasonable, if you have a use case for it, but the name is a bit misleading. What has it got to do with Python? I clicked hoping for some fancy python byte code compilation optimizations.
Nothing new - just the result of a recent reorganisation of the existing docs into a format which is hopefully more accessible.
Doh, you're right. Sorry about that.
logging, one of the most ignored good things you can do. 
thx
Some editors parse docstrings and/or comments and use that for type hinting, e.g.: def f(x, y): """\ @param x MyClass """ # @type y OtherClass 
l is the list and n is the number of groups yoy want: &gt; `[l[i*n:(i+1)*n] for i in range(int(ceil(float(len(l))/n)))]`
Maybe it's better to call this CSSinliner, as this isn't particularly related to python or a python implementation of existing software.
This needs to be made in to a rage comic. Definitely a FFFFFUUUUUUUUU moment when you realise what's going on.
Actually, the *recent* versions of Outlook are the ones using the Word engine and while that's a tremendous pain in the ass for different reasons, they recognize the &lt;style&gt; tag in the document &lt;head&gt;. Gmail is the only major email client which ignores &lt;style&gt; tags in the &lt;head&gt;. Lotus Notes 6/7 are also affected by this, but later versions are not. So basically, if you care about Gmail (or older Lotus Notes users) you need to use inline styling. I do, so this is going to save me a lot of time if it works well. Thanks!
lesser known is pdb.post_mortem(), called inside an except: will put the debugger at the point of the exception's original cause.
1. WTF? 2. Hm, not April 1 :S 3. Ehr, mixing ``snake_case`` with ``camelCase`` *and* ``snake_camelCase``!?
I guess PyDev is okay if you like eclipse. I spent enough time with it when I was doing Java that I can say I don't. Maybe I'm more inclined to paying for my tools because I'm surrounded by designers who see nothing wrong with shelling out a few grand every other year to buy the latest copy of their Adobe stack. For reference: I started out with Komodo Edit, then decided to buy the IDE because I enjoyed it so much. I switched to PyCharm because its code intelligence is vastly superior (namely, it has automated refactorings).
Older and newer.
Django makes certain architectural choices for the user in the way it implements MVC. Others such as flask and pylons (reddit uses pylons IIRC) allow for greater flexibility precisely because they don't make those choices for the user. 
Not all environments support Django and not everyone *needs* Django. For my GAE apps, I use Bobo (built mostly from WebOb) and Genshi which make things very simple without needing to conform to Django concepts and keep my file count quota in check.
Check out ipdb.
Thank you.
Django is more monolithic. It uses a lot of its own components and is pretty uniform throughout because each of its components is a library written just for Django. Other frameworks, like Pyramid, use their preferred choice of every different library available to pull it all together. This means things are a lot more modular and switchable, and more customizable. The framework maintainers work with the library maintainers to pull it all together. They each have their advantages. edit: typo
Because they explore new ideas, which may be more appropriate for some projects. One size does not fit all when it comes to web programming. There's also a long history of new ideas from emerging frameworks being adapted back in to bigger frameworks - look at Merb and Rails 3 for example.
My current gig is an app that has three separate WSGI applications (i.e., there's at least three separate URLs) plus two background job queue processes, as well as three distinct databases. In production these apps may run on different servers, and eventually three of the five types of application may have dozens or hundreds of remote deployments, each with their own pair of databases, which communicate back to a central coordination application. The linkage of database-&gt;process is not a one-to-one relationship either, two of the five processes talk to two databases where the other three have one. All five applications share the same codebase, set of model classes (with some compartmentalization), as well as many common layout templates, includes, and static files, and even controller classes in some cases (such as login, error handling). They are all configured from a single .ini file as well that includes a separate section for each application. The "--name" flag is sent to paster server, or otherwise the appname argument to loadapp() when paster server isn't used, in order to specify which application is to be run. The applications also share a single test suite, where app-specific tests subclass a fixture that specifies which appname is being tested. The fixtures ensure that a transaction is set up for each test which is then rolled back at the end, so the tests can be run on any database without side effects, even the production DB in theory. Some of these tests run a special fixture that embeds one of the applications via webtest into a REST client that's used by the other - such as a series of tests that ensure a fully compliant OAuth 2 conversation between two of the services - a test like this runs *two* wsgi apps in one process. I do this all with Pylons and a good deal of poking around how paste loadapp() and such work in order to make it happen, but there is no monkeypatching or modification to Pylons or Paste in any way - the product supports a pattern like this out of the box. My understanding is that Pyramid is even more open ended than Pylons with regards to highly customized setups. I've never used Django, but my understanding is that multi-node configurations, even multi-database configurations for single applications, are not provided out of the box. This may not be the case today.
Exactly this. More projects means more different ideas that get at least some investigation into their usefulness. The truly useful ideas "bubble up" and get integrated into the more popular frameworks. Innovation in smaller projects in the open source arena is the key to improving the larger, slower moving projects (and if you follow Django development, you know that it can be at times quite a slow beast that regularly misses development deadlines). In summary, smaller projects can try new ideas much more easily than bigger projects. Useful ideas can then be evaluated and sometimes fit into other projects, benefiting the entire community.
It's also like having multiple species in nature (think potato famine) - your "potato" may do fine in a pool of uses, but when something unusual comes, an existing alternative may do better. Diversity is sort of the prerequisite of natural selection. So, while you compare very similar "potatoes" (django, pylons, flask) - consider those further out: nagare (still python, but depends on stackless), and some of the non-python frameworks (in particular, think of the languages that arise as a result of experiences w/ frameworks - java, historically; go-language now...) 
Exactly. It's all about how hands-on you want to be designing your architecture.
&gt; Why does the Python community spend time developing, promoting, and using web frameworks that are orders of magnitude less popular than the 800lb gorrilla, i.e., Django? Why is popularity a relevant criterion? 
There are costs to using something that's not very popular. If you develop your skills with e.g. Flask, it'll be harder to sell your skills to an employer who wants Django experience. It's also harder to find collaborators for a project if you can't count on them knowing your framework of choice. A less-popular framework probably has less documentation than a popular framework, and it's harder to find solutions to your problems online- fewer people are blogging about their experiences with less-popular frameworks, and a smaller community may not have run into your particular problem. I presume that, in exchange for putting up with these costs, developers get benefits from using less-popular frameworks that more than make up for the costs. I posted this topic to find out what benefits Python developers often see.
Put it on github/bitbucket then throw a first release on PyPI. If people find it useful, they know where to get it and can fork it and continue onward. Even if you don't end up maintaining it, it's a nifty resume piece to be able to show that you wrote it.
I use Python, not Django (or Framework/Library X).
All frameworks that you would consider valuable today were once small, less-popular projects. Just like that tired saying, "children are our future", these small pet projects might be the Django or Pylons of 2015.
* One, because it's fun and comparably easy to do. * Two, not all projects need a full stack that django provides. * Three, sometimes you need more flexibility or power than django affords.(Think SqlAlchemy vs's django's ORM) * Four, you just don't care for django's opinions. Personally, I think django is a great framework but I am glad that people continue to explore different approaches.
"Full stack" frameworks like Django (and, before it, Zope) are great because they have lots and lots of generally useful features. And each of these features is used. But full-stack frameworks often have features *you'll* never use. And it's unlikely that, even if you do use all of the features of a full-stack framework, that you'll use all of them on every job you do. It's reasonable, then, to say "OK, fine, use a full-stack framework but just don't use the features you don't need" but, in reality, it's a bit more subtle than that. The features you don't use in a full-stack framework often makes the features that you *do* use more complicated and harder to undertstand. For example, Zope embraces "untrusted, through the web" code (code entered in a web browser by a potentially semi-trusted third party), and this feature requires an enormous amount of security code that tends to get in the way when all you're trying to do is write a web application where all developers are trusted. Likewise, Django is engineered at a fairly basic level to make it easy to work with certain kinds of relational databases. If you're not using a relational database, however, the code that makes that case easy might simply get in your way. This could make it harder to write the application you want to write. Non-full-stack frameworks have a more parsimonious feature set. This often makes them harder to get started with. However, in the longer run, if your application has slightly peculiar requirements, they can actually save development time, because you're not "fighting the framework" during the implementation phase. Not fighting the framework is also usually a more satisfying development experience. In the meantime, non-full-stack frameworks often have a better extensibility story. Because their core feature set is so parsimonious, they need to provide for cleaner feature extensibility than do full-stack frameworks, which can just put something into the core itself without worrying about clean extensibility. It's often, therefore, reasonably easy to get the featureset of something like a Zope or Django by snapping together parts using the smaller frameworks' extensibility hooks. But without the parts you don't need for some particular task. Personally, one reason that I use a non-Django framework because I like writing code. After many years in the Zope/Plone world, I've realized I enjoy writing code a hell of a lot more than I enjoy carving a website out of other people's "pluggable app" code. I'd rather be lonely out on my organic farm than be a sharecropper, sold my GM seeds and told how to plow and harvest, on the big and lucrative commercial farm. Another reason is because my company tends to write CMS-style application where "declarative, inherited, row-level security" is a big deal, and this sort of security is easier to do in a system that has the concept of "traversal" and a "context". But I think your question is more a marketing one, and for that I suspect many folks will have different answers. My answer is that I think there's a very, very long row to hoe in the general web world... we're like at the one-meter mark of a hundred meter race. It's silly to think that any framework (Python or otherwise) has that race already won. We can't just stop trying and advocating for new things, or we risk loss of relevance in the long term.
Please do this. Just because there's a lot of options out there doesn't mean that people won't appreciate this. I'd love to see it.
I use Flask as the backend for an embedded Linux project needing a remote administration interface. The whole website, including SQLite database, HTML templates, jQuery and images, fits in a single megabyte. When you have strict resource limits, having a lightweight and minimalist framework is essential. Along those key features that led me to chose Flask are the very simple route API and braindead AJAX/jQuery interface.
&gt; I feel like it is at a stage where it can help folks, but there are already so many python web frameworks and micro-frameworks out there that I would dislike causing community clutter Sorry for being so blunt, but it's like saying that 'should I have my own kid when there are so many kids roaming around?'. :/ Just do it. :-)
For the same reason the open source community spent time developing the 800lb pound gorilla, Django, when the 800lb pound gorilla was - and still is - PHP. While popularity is an objective measure, various measures of quality, are not.
All of which was true of Django some years ago - the popular frameworks of today were once small, marginal projects. Another advantage of going with a young framework is that you get to contribute at a formative stage and have some influence in its direction - which would be hard to do with Django today, unless you happen to belong to a very small circle of contributors. 
I can use this on a bunch of dynamic web pages I need to convert to PDFs. The converter screws up non-embedded CSS, so this will make it a lot easier for me. 
The truth is that the development and support community behind any open source project is typically fairly small. In my experience, if project A has a hundred times the number of users that project B does, it never holds true that project A has a hundred times the number of people doing documentation, support and development. It's not like that. The relationship between project popularity and docs/development/support resources is more logarithmic (if popularity is x, support resources are more like log(x)). As an open project grows in consumption popularity, the project can expect to pick up one or two highly motivated support resources for every hundred (or, possibly thousand) users. The most extreme of these logarithmic scales relates to documentation. If a project has 100 users, there will be one guy who writes most of the docs. If the project has 100,000 users, there will still be one guy who writes most of the docs. The number of users that a project has is usually unrelated to documentation quantity and quality; either it has good docs from the beginning or it doesn't (a project rarely "grows" good docs; I have never seen it happen anyway). It's, in my experience anyway, untrue that less popular frameworks have less (or worse) "official" documentation. However, as you mentioned, a very real benefit of popularity is blog posts and other unstructured independent third-party documentation sources like tutorials given at conferences, etc.
With my tongue only slightly in my cheek... two reasons: I'm not smart enough and I don't generally trust people. When I get to choose tools, I prefer to be able to hold the mental model of that tool in my head without straining too hard. That way I can use them to do what I want, instead of trying to figure out what their developers wanted and then trying to figure out how to make their code do what I want. For example, I wanted to understand the recently approved [OAuth2](http://tools.ietf.org/html/draft-ietf-oauth-v2-15) client and server. So I grabbed [web.py](http://webpy.org/) and worked out how to integrate it by writing a little [example application](https://github.com/DaGoodBoy/webpy-example). Most of the big frameworks require that you understand their structures and paradigms before you can even start. Using a microframework like [web.py](http://webpy.org/) cuts down on how much you need to know before you can get to work doing what you really want to do. As far as not trusting people, I have no ability to read hundreds or thousands of lines of code and see logic or security problems there. If the code base is small enough, I can review the parts that concern me and have some hope of understanding if they are secure or not. I wouldn't know where to even begin on a project the size of Django without significant effort I'd rather spend writing code I actually care about. *added some clarification
I use this sitecustomize.py: import sys def excepthook(type, value, tb): if hasattr(sys, 'ps1') or not sys.stderr.isatty(): # we are in interactive mode or we don't have a tty-like # device, so we call the default hook sys.__excepthook__(type, value, tb) else: import traceback try: from ipdb import pm except ImportError: from pdb import pm # we are NOT in interactive mode, print the exception... traceback.print_exception(type, value, tb) print # PyQt4 Fix qtcore = sys.modules.get('PyQt4.QtCore') if qtcore: qtcore.pyqtRemoveInputHook() # ...then start the debugger in post-mortem mode. pm() sys.excepthook = excepthook 
Since when have you been getting periods? WHAT ELSE DON'T I KNOW?
Because each people have their own different problems, Django scratch the common news company itches like: Designer should be given easy template to work with, News reporter should be able to put their data using easy CRUD admin, and framework should not be in the developer way, while maintaining python motto of explicit is better than implicit. Let's look on another example: Rails (sorry if I'm crossing the language barrier here, but it's a good example) for example: There's should be independent stages: Test, Development, and Production Convention over configuration (common task should be done implicitly, rails use scaffold heavily) Usually popular framework didn't try to solve problems that's not their designer's interest so instead of competition, in my opinion, it creates choices, eg. if you like explicit things and crud admin, then use django, if you like customization use pylons/pyramids, if you like scaffold then use rails. 
Agreed. I love Flask. I think of it as Python's version of Sinatra, and feel it's the perfect solution for certain use cases.
If generator syntax isn't required, this is convenient: a = [1,2,3,4,5,6,7,8,9,10,11,12] n = 3 result = zip(* [a[x::n] for x in range(n)]) # result = [(1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12)] Though it, too, suffers from losing the last bit of the list if the length of a isn't evenly divisible by n.
Can someone explain what LAFS actually means? The words "least" and "authority" don't appear on the summary pages.
I believe the idea is that the filesystem can work with parts that aren't 100% reliable or free of interception (i.e. not on a "secure" network).
Nice technology for DIY offsite backup, but re-using the technology could be problematic; the code is GNU v2 licensed.
I thought Genshi didn't run on GAE?
&gt; So Py-reddit, if you were in my situation what would you do? Am I over thinking this? Over thinking? Yes. If I were you, I would clean up and document the code base and release it on github with a short README file that provides the rationale of releasing another micro web framework. 
I think the reason there are many Python frameworks is due to WSGI and its implementations such mod_wsgi. This enabling technology facilitates the making of frameworks so people can try different ideas.
&gt; it breaks the duck typing That depends. If I assert methods or attributes exist with hasattr(), the duck typing isn't broken. Duck typing isn't necessarily always a good thing. Just cuz an object has methods Foo() and Bar(), it doesn't necessarily mean that they do what my code expects.
And that's why we're hitting 7 billion people soon!
This kind of problem solving is applicable to almost every language
Pythons are already scaly, silly.
Too bad the Windows version of bpython is apparently dead :(
Have they added Python 3 support yet?
This presentation is from 2007. Many, *MANY* things have changed since then. 
Hmm. Is accessing memcache really faster than filesystem? Doesn't that mean the filesystem (at least its cache) is broken?
a gigabit network attached memcache can be a lot faster than filesystem access(for disks most mortals can afford) . 
the whole point of memcache is to *share* the cache between nodes, with the idea that one global cache of N * M bytes is better than independent caches of M bytes on each of your N nodes.
like what are you thinking of?
write some *awesome* docs for it, get it on github and unleash it on us :D Maybe include some design rationale in your documentation. bonus points for a sexy logo/website or [kickass t-shirt](http://laflamme.storenvy.com/products/66831-pyramid-not-built-by-aliens-t-shirt). The worst that could happen is that someone might actually use it and like it ;)
It still thinks that Nginx is ONLY a loadbalancer. 
I would say that the development of further frameworks is valuable for the community for two reasons. First it allows experimentation, there is no one size fits all solution for web development, and having people who are willing to try new things, and forge new frontiers increases knowledge of what works and what doesn't (even if 99% of new frameworks or crap, and I'd say that most of them have at least something to offer). Secondly, developing a framework is a great way to learn the ins and outs of python, if I use Django for all of my development and I'm a curious developer (which I am). I'm eventually going to wonder if I could create something better. I'm going to try to write my own framework making different decisions, even if I'm wrong and I create something that isn't THAT useful, I'm still going to open source it so others can learn from my mistakes, and try to understand the programming decisions that I made. Then, when I return to a more popular library I'll have a better understanding of how things are implemented and more importantly I'll understand WHY.
I would like to know how to scrape AJAX pages properly. There are pages that expand the DOM in the browser, e.g. [http://www.ncbi.nlm.nih.gov/nuccore/CP002059.1](http://www.ncbi.nlm.nih.gov/nuccore/CP002059.1). If you get this example with wget, it's about 100 KB, the source is full of AJAX calls. If you save it from the browser, it's about 5 MB and contains the necessary data. I found a solution called [Crowbar](http://simile.mit.edu/wiki/Crowbar), with this you can get the post-AJAX HTML source but Crowbar hasn't been updated since 2008. Do you know another approach? **Update** (20110415): I made a blog post about Crowbar [here](https://ubuntuincident.wordpress.com/2011/04/15/scraping-ajax-web-pages/).
As someone who has had to send out HTML e-mails in the past: congratulations on supplying the one justification in the world for such a thing. You're right, this would have helped a ton.
With Selenium, I tried to save the source with get_html_source() but it saved the original source with AJAX. Did you manage to save the post-AJAX source? If yes, I'd like to see an example.
I have that bound to f8 in my [.vimrc](https://github.com/llimllib/personal_code/blob/master/homedir/.vimrc#L120). (It's actually since changed to &lt;leader&gt;d, I need to update my backup)
&gt; And that's why we're hitting 7 billion people soon! So I assume you don't have/don't plan on having kids? :P
Actually yeah, *we* don't plan to (26 years old, so is my wife). She's afraid that eventually her hormones will go crazy and she'll crave children (like women crave chocolate on PMS) in her last years of fertility, or that not having children might have negative health consequences for her (apparently not having children may cause some problems on women's reproductive tract), but other than that we see no reason to.
Ah, nice to be young! Good luck with whatever decision you end up taking! :-)
If by "re-using" you mean making source code modifications and then distributing the changes, and if by "problematic" you mean that you would have to also redistribute the source code to your changes... if these two are true, then yes, you are correct. If you're not making changes and also distributing off-site, you do not have to share anything. I mean, it's 2011. Big corporations use, modify, and enjoy the advantages of the GPL. It doesn't hurt. It doesn't mean you don't get to do just about anything you want. All it means is that the code is free for everyone and can't get held back if one party makes **and distributes** improvements. Also, if you have some misconception or lack of understanding about the GPL, get over it: no one is forcing you to use it. If you really don't like it, write your own and use a different license. But please don't complain about someone exercising their right as an author to determine the license of their work. 
bpython seems dead on pretty any arch to me. I strongly believe ipython is underrated.
As for the docs part I strongly recommend [Read The Docs](http://readthedocs.org/), it has github integration and Sphinx (which RTD uses) most definitely satisfies the *awesome* requirement ;)
go for it, but with every feature documented, like pyramid. you got us curious. 
Python is not weakly typed. Perhaps you were thinking of JavaScript. 
Works with [pyfilesystem](http://code.google.com/p/pyfilesystem/) if you want a nice pythonic interface to it.
Could you use a [NamedTemporaryFile](http://docs.python.org/library/tempfile.html#tempfile.NamedTemporaryFile) If you are not going to do this in a tight loop it is just not worth your trouble to fight the library. Be careful to figure out if the file contains sensitive data that should not be available to other users/processes on the machine. Also, on windows this temp file might not be available to other processes. 
If the api doesn't accept a file-like object or a string containing the contents, then there isn't any way of forcing it to do so. Well, there *is* but it is probably more trouble than it's worth. My suggestion would be to hit the docs or look at the source for TidyHTMLTreeBuilder. If it doesn't accept file-like objects then you shouldn't have too much trouble hacking it in.
There's absolutely nothing sensitive about the data. I'm scraping websites for announcements about updated plugins and themes, news about upcoming specials, etc.
I was hoping for some type of pseduo file IO method that would mimic a file but could stream text as content.
"Py3k. They should have actually waited until the year 3000. At least then I wouldn't have to hear people complaining about all the features nobody wants." lol. 
Try looking in to why StringIO isn't working for you, as it is pretty much designed specifically for doing what you want in this instance.
 from elementtidy.TidyHTMLTreeBuilder import TreeBuilder from xml.etree import ElementTree tree = ElementTree.XML(text, TreeBuilder())
Depends how much data you need cached. Sometimes the system cache doesn't cut it, and you need a network system, maybe even a distributed one. But keep in mind that network access is relatively *way* slower than local memory access.
&gt;PS. I tried StringIO but it truncates the content somehow. Remember to call `mystringio.flush()` and `mystringio.seek(0)` before reading, where mystringio is your StringIO instance. Failure to flush results in the tail truncation, and failure to seek(0) results in the head truncation. Also, if you're going "write-&gt;read-&gt;write-&gt;read-&gt;...), the 0 in seek(0) can be replaced by some variable which gets updated with `mystringio.tell()` before reads (initialised to 0) - this allows you to reuse the StringIO instance. PS. If your scraper might scrape big things, or things that don't like being scraped, you should probably take `freekzindel`'s suggestion. StringIO stores in memory, and a website might do [something like this](http://www.reddit.com/r/netsec/comments/fo6zs/this_link_will_most_likely_crash_any_browser_and) to scrapers.
I agree, this is probably the problem. It's bitten me before.
Thanks! That feed is awesome!
3
well ZODB is pretty cool
Talking about great books, can you recommend any good books for network programming in Python?
"*Even BeautifulSoup vomits on this.*" It may be because you use an older version of BS. I had this problem too (the official Ubuntu repos are not very up-to-date...) but installing [BS from PyPI](http://pypi.python.org/pypi/BeautifulSoup/) solved my case.
"Metaclasses belong in C, not Python... If you're going to scare your users, do it right" :D
"That is because you are looking in the CheeseShop. You need to look in the Starship." The Starship? - everyone knows that the Vault of Parnassus is the only good collection of python libraries.
Beautiful soup is not the one to use, use lxml.
Congratulations on picking the least relevant change since 2007 :p
regardless, it's still good advice. 
from the presentation "don't think...know" so, maybe do some measurements and see what you think. :) 
I like this comment: &gt; The new multiprocessing module is a travesty. We should have just added "man fork, dumbass" to the zen of python.
&gt; If you develop your skills with e.g. Flask, it'll be harder to sell your skills to an employer who wants Django experience. Stop marketing yourself as user of &lt;some tool&gt;. And start marketing yourself as a solutions provider. 
For instance, I coded up a super basic Facebook API using algorithm and wanted to host it on AWS to show a couple friends. I didn't need the full database integration, user authentication and whatever else django comes with. I just needed something that could run some Python code and spit back results, so I chose CherryPy because it's very lightweight and brain-dead easy, even for this biophysics grad student to understand.
I have read "Scaring Python" at first glance ;)
&gt;Quit whining about the global interpreter lock - no one can really afford multiple cores, and most applications are single threaded anyway.
sphinx is great :)
&gt;Mutable default arguments are awesome because they're like handing hand grenades to monkeys. Someone is going to get hilariously hurt. As a mutilated monkey, I can confirm that this guy is uproariously funny.
I beg those who criticize this presentation for being outdated to provide an update, a .5 to 1.0 graph if you will.
&gt;Rubyist got on me about significant whitespace today told him not to get his hipster ultra tight nudie jeans in a bunch Code hipsters *sigh* Rubyists and hipsters wore ultra tight nudie jeans in the 90s? 
no trouble ... feel free to contact me
Done! Sign me up.
&gt;Oh look. How to write a JIT in PyPy (http://t.co/mmWsZ3W) fools, the lot of you! REFCOUNTING 4 LYFE. JITs are impossible/hard to maintain. This one almost made me spew water all over my laptop.
Hah, that's a coincidence, I wonder which of my colleagues posted this. For what it's worth I'm really enjoying my internship at the company :-)
Thanks! Anyways, if it ever comes to that, we would rather adopt than fork() another human! =)
I've always found iPython to be *overrated*. All I need really is syntax highlighting and auto-completion.
PyQt4 and QtWebKit maybe, take a look here: https://github.com/emyller/webkitcrawler
I found that StringIO adds formatting codes and escapes characters. For examples, instead of a newline, it puts in a "\n". Instead of a ', it puts in a "u\'", etc. I guess it disrupts the HTML enough that TidyHTMLTreeBuilder can't deal with it. If you know of a way to force StringIO to *not* put in special characters, I think my problem would be solved.
Ha, the mystery :D We're enjoying you here too. Great addition to the team.
Son of a &amp;#@*!, you're right. Ubuntu uses 3.1 and the latest version is 3.2. I didn't think a minor version could be different but apparently, I was wrong. Thank you for that.
I replied to another person with this. StringIO adds formatting codes like "\n" for newlines or "u\'" for '. I guess it mangles the text enough that the parser doesn't like it. I read hints of ways to force utf-8 but I wasn't sure how to actually implement this.
Thanks, works well! I should just figure out how to give more time for the download process. In my example, the page [CP002059.1](http://www.ncbi.nlm.nih.gov/nuccore/CP002059.1) loads in 15 seconds but this webkitcrawler doesn't wait that long thus it doesn't fetch the complete page. But it expands the AJAX calls!
Hey Grimborg, Too bad you're so far up North. I live in the South and I've been looking around for a Python job in the area. I've done a lot of classic ASP work, and currently C#, but I really dislike the strong typing of C# over the dynamic typing in Python, so at home I'm trying to pick up Python. A job programming Python would speed that up immensely. If you guys ever branch out, let me know... 
What I did is remove python-beautifulsoup with Synaptic then install the latest version with "sudo pip install beautifulsoup".
Can you explain what this is?
It's a very niche kind of joke but it's done exactly right. Any idea who's behind this?
The scrapy guys had a good blog post which talked about dealing w/ ajax. http://blog.scrapy.org/scraping-ajax-sites-with-scrapy
&gt; "True division" is the result of people thinking that we run Python on fairy dust and not on real computers. I completely agree with this one.
&gt; If you're not making changes and also distributing off-site, you do not have to share anything. I think you're thinking of LGPL, where you can link against it &amp; distribute it without disclosing your source. GPL does not allow for that - if you link against it, you're required to distribute your source. Not to mention that distribution is not too well defined - pushing it out to AWS could qualify as distribution, even if you never put the code into your customer's hands. I have no problem with someone using the GPL - it's their choice. It just limits its use for many commercial applications, which is frankly disappointing when you find that it could be useful. I was simply expressing that disappointment.
I'm waiting for him to inform us that he listened to Python on vinyl...
&gt; I think you're thinking of LGPL, where you can link against it &amp; distribute it without disclosing your source. GPL does not allow for that - if you link against it, you're required to distribute your source. Not to mention that distribution is not too well defined - pushing it out to AWS could qualify as distribution, even if you never put the code into your customer's hands. No, I'm certainly thinking of GPLv2. [Go read it for yourself](http://www.gnu.org/licenses/gpl-2.0.txt): sections 2 and 3 clearly apply only when you "copy and distribute". &gt; Not to mention that distribution is not too well defined - pushing it out to AWS could qualify as distribution, even if you never put the code into your customer's hands. Distributing it to AWS probably doesn't qualify if the nodes are part of a larger organization. The GPL FAQ [has this to say](http://www.gnu.org/licenses/gpl-faq.html#InternalDistribution): &gt; **Is making and using multiple copies within one organization or company “distribution”?** &gt; No, in that case the organization is just making the copies for itself. As a consequence, a company or other &gt; organization can develop a modified version and install that version through its own facilities, without &gt; giving the staff permission to release that modified version to outsiders. &gt; However, when the organization transfers copies to other organizations or individuals, that is distribution. &gt; In particular, providing copies to contractors for use off-site is distribution. 
I don't get the couple comments talking about Go. Where is the relation?
Damn. I clicked on this, laughed, then thought "I should submit this to /r/python!" :P
stupid twitter! downvoted just for that &gt;:(
You could just use python-tidy which will output properly formatted (X)HTML that you can then parse with anything you chose as it will be perfectly formed. An example from the documentation: &gt;&gt;&gt; import tidy &gt;&gt;&gt; options = dict(output_xhtml=1, add_xml_decl=1, indent=1, tidy_mark=0) &gt;&gt;&gt; print tidy.parseString('&lt;Html&gt;Hello Tidy!', **options) &lt;?xml version="1.0" encoding="us-ascii"?&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello Tidy! &lt;/body&gt; &lt;/html&gt; 
I have never heard of this module. Thanks for posting. 
Is it an append only file or are you re-writing it?
It is rewritten to aggregate the data that is coming in. I know it's dumb, but the file is indexed by this idx = (data point timestamp - base timestamp) / granularity in seconds You can't store data points with earlier timestamps than the base timestamp. There will be lots of holes for where there's no data points, but I get around it using 'magic' values in the binary format, as well as checksumming everything
I'd just use one of the many existing little database modules for storing data.. there is also this thing http://graphite.wikidot.com/whisper which is kinda for doing what you are doing.
Wow. Thanks! I 'll seriously look into that 
Write the file in blocks and have a checksum on each block. 
It's a web application that can track statistics for some competitive activity. That essentially means that it will take input from moderators for each event, then display the input in a pleasing format. The future will bring more helpful formats, like graphs and sortable results, as well as statistics based on users and events. Any other questions?
If you're rewriting the whole thing, and are on a non-Windows OS, then just write the new data to a temp file and use an atomic rename operation to replace the old file. Worst outcome is a stale temp file that you can simply delete.
I'm already doing that, but I would like to be able to recover the aggregated datapoint that I'm updating. In other words, I would like to be able to recover from a crash while updating a datapoint that contains 1 month's worth of aggregated data. Thrashing the datapoint in case of a failure would not be an option for some cases. Coming to think of it, I guess I just need to read the data, update it in memory, save to a log file. Whenever I fsync, I should truncate the log file. Does this sound reasonable?
Unfortunately is not the whole thing, but that sounds reasonable for small data files
I think this is a perfect use case for SQLite. SQLite is an embedded database that will provide atomic, consistent, durable writes. [sqlite3](http://docs.python.org/library/sqlite3.html) is included in the Python standard library as of 2.5. 
I already know HTML/CSS/Javascript. I'd be willing to mentor you through Python 3k if interested. Shoot me a message.
You don't have to know what the difference is between 3 and 2. You don't have to know why somebody thinks django is a 3. It would be nice to know, and it provides more information, but it's just false that the number alone provides "absolutely nothing" as you are claiming, especially when there are lots of ratings. If Amazon got rid of all the reviews and kept the ratings, I can assure you that plenty of people would still find them useful, even if less useful than currently. The number alone means something. You are just wrong on this point. Even if the number means something a little different to every person, it's true that for every person, 3 is better than 2, 4 is better than 3, and 5 is better than 4. I don't know how you can not fail to appreciate this painfully simple point. I guess you must think that on a site like http://hotornot.com/, where photographs of people are rated on a scale from 1 to 10, that there must also be no information provided by knowing that somebody got an average rating of 9.9 from 1000 people, versus an average rating of 5.0 from 1000 people. Different people find others attractive for different reasons, and we have no idea who the people are that made the ratings or what their preferences are, why they have a 7 versus an 8, etc. By your reasoning, knowing somebody got a 9.8 provides no information whatsoever, and the numeric ratings must be absolutely useless. If you'd like to find out that you are just wrong on this topic, I invite you to find 5 photographs of women on that site that have an average rating of 9.8 or higher from at least 1000 people, and 5 photographs that have an average rating of 5.0 or lower from as many people. Take the 10 photographs, and ask 5 heterosexual men to pick the 5 women that have an average rating of 9.8 or higher, and the 5 women that have an average rating of 5.0 or lower. They will have no trouble doing this. They won't tell you it's impossible because a 9.8 is meaningless without knowing why each of the 1000 people gave the rating they did. They won't tell you any of the silly objections you gave for why a number can't mean anything alone.
I don't think memcache is the place for static files. If you're looking at high-performance you need to be using a CDN.
StringIO is most likely not the problem.
Certainly put it on GitHub in the least, with a liberal license. Actually you should have done that first and linked the repository for us to evaluate. :)
I think whisper is fixed size only, not sure though. If you need fast random access or need to query by timestamp range, i'd go for an index file with entries for timestamp start &amp; stop, compressed and uncompressed size, number of messages and file offset. Store the data itself in a file consisting of concatenated zlib streams. Keep a buffer of n messages in the server and write each one to disk as temp files when they come in. After either an arbitrary amount of time or n messages, flush the buffer into the zlib stream file and append an entry to the index file.
vanity vanity