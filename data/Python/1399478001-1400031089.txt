That makes sense. I also work in IT and have a interest in programming. I'm starting to wonder if DevOps might be something I could do. I've played around with Python in the past, built a simple Reddit bot with it. It was fun and easy for me to pick up. However I lack in the education department. I have not completed any college and I've been out of it for a while. 
Making the jump from QA to dev isn't easy, and often times requires leaving for another workplace to do it. The mentality from bosses might be, "well, there's probably a reason why you're in QA to begin with" - that you're not good enough to be a dev. Then there's also logistics and pay structure at issue. I can't speak for all workplaces, but QA was often last on people's minds. Being in QA does teach you a thing or two, and can make you a better full time developer, but you'll find you'll have the least resistance elsewhere. Much like going from completely unpopular to prom Queen after a move during your senior year to a new high school. It'll take some work, and there may be less things working against you. - I was QA guy from 2012-2013
Rewriting code to Cython is *not* enjoyable. Are you having any specific performance issues? I'm pretty sure the running time of your scripts is dominated by querying the remote server and writing the file. If it's a large JSON file, you might get some speedup from using something like [ujson](https://pypi.python.org/pypi/ujson) instead of standard `json`.
Python?
You'd better to profile your code to see if there are any bottleneck in python. Also you may use some external libraries such as simplejson with C extension if json files are huge.
You are confusing information (art is not information, I'm not talking about information... art doesn't have to be powerful or even useful, it's art), knowledge, creation, facts and putting all of these in the same bag... Did I say that math solutions should be patented ? NO. I said IP protected, that's not the same thing. You are confusing patent, copyright, intellectuel property and ownership, and putting all of these in the same bag as well. "Sure you can. Because the EU patent office allows it in violation of EU laws. But that's another matter..." No you can't, France is not EU and EU is not France. France is breaking some EU laws, EU is not a country... Plus, I don't understand why you are talking about tax money. Artists are paid by selling art or doing performances. Do you think concerts should be free ? Movies ? Do you think you can make spiderman with no money just because it's fun ? There are artists, and but also a lot of people involved in creation ! Do you want them not to have a job anymore, because they're doing it for fun ? So fun should be free ? Do you think that every artist should work at mac donald's and make CDs and movies on their spare time just because it's fun ? "because people already like doing it!" Money is not here to make people like or bare doing things, it's here to make people make a living out of it.
http://www.brython.info/ This looks really interesting, can't believe I didn't come across it in my searches. I will definitely fiddle with it and report back if I meet some success. Thank you very much for bringing it to my attention.
Hey, I know Python and machine learning and can learn things quickly (and am about to get a PhD), want to hire me???
Same with analysts and engineers. Good "technical" people are still somewhat rare.
Meow!
This is good advice. Is creating a GUI in Python comparable to writing one in Java?
The test env is unfortunately at the moment on a shared hosting package running Cent OS 5 so I had to compile Python 2.7 and PyPy from source code for my user. When running locally or directly on the server (without CRON), then the resulting file can be around 300 kb without indentation and 600 kb with indentation. I'm just worried about the CRON job timing out and I cannot get the CRON results as the main /var/log/cron file is locked down by the root so I cannot open or copy.
&gt; I'm just worried about the CRON job timing out Why, is there a time limit? How close are you to it? How much time is spent doing network and file I/O? If you time out because the network is slow, no amount of hand-tuned assembly will save you.
Yeah, QA can basically be a straight up dirty word, you see people create whole new job descriptions to avoid it, like "Test Engineer"
Generators. Almost every loop can be expressed more clearly with a custom generator than with a C-style `for i in range(...)`. Doubly so for nested loops or lots of processing in the loop body. 
33%*
Yes. And even if you do migrate out of QA officially, you rarely leave it behind. Oh, you are a QA person who moved to business analyst? Here, don't worry about those pesky requirements docs, test the app. Your the new dev promotion from QA? Make this minor change, and then regression test the whole app for everyone else's changes also.
Congrats on taking the reins! 
I was a software dev team lead for 9 years, and know *exactly* what OP means. But OP, it is not like that in all companies.
&gt;Python and **machine learning** and can **learn things** quickly I see what you did there :P 
&gt; he then joked "what are we running here? a kindergarten?" Some people don't put any stock in being inter-disciplinary, as that would suggest that their one-and-only skill set would place them behind the curve. Edit: honestly, having devs with support experience, qa folks with coding chops, and all the other possibilities sounds like the makings of an awesome workforce. Imagine if everyone understood how everyone else's job worked?
Well, there's your problem right there - you got the Windows in your system. I kiiiid, I kiiid^kind^of
[musl](http://www.musl-libc.org/) libc. I built Python using musl on a modern 3.11 kernel linux and I can run it on older versions of the kernel, even an eleven year old 2.4 kernel machine. Although I'm told it's a patched Red Hat 2.4 that is almost a 2.6 kernel. It feels like time travel is real when I send a modern 2.7.6 Python back to myself on a decade old machine. We have thousands of customers running old linux with no hope of upgrading. Building Python with musl is a pain. Python's build system seems to try to override the musl gcc scripts and inject standard libc. I wrote custom scripts to delete any arguments that begin with "/usr". Once Python is built then I can use pip to build modules with musl and add them in. One exception is cx_Oracle because it relies on prebuilt Oracle client libs. So... I've quit using cx_Oracle directly. When forced to use Oracle, I now publish an Oracle interface class using XML/RPC and a conventional Python build. Good reason to replace Oracle everywhere with Postgres. I built Postgres with musl too.
Unfortunately I don't live in Minnesota. What kind of qualifications are you looking for out of your candidates? Interested to see how I stack up. 
I timed the connection to the remote server with ujson and it is about 15-20 seconds until completion and saving of file. Of course most of that is probably contacting the remote server and getting the info. I do like how i simply change my json import to just "import ujson as json" and barely have to touch any of my code. Most tests say that ujson is the fastest encoder/decoder. Some sites also said that ujson isn't running on PyPy, but if it is, would I get much of a performance boost if the script is only run once a night?
Remember, there are QA developers who actually write the unit tests other QA anaylsts use, and they most certainly aren't QA forever. Source: I am a Test Developer in a QA department, soon to be software engineer in another.
Since I corrected his mistake, I knew how to calculate the raise, ergo it is obvious I was rounding it. However, your answer seems to look for precision, but is still grossly approximated. This makes my answer acceptable, and yours, not.
I haven't added in the part that makes them iambic pentameter yet. So yeah, it is.
I think it's possible using the CMU phoneme dictionary. Still not sure exactly how, but I plan to figure it out.
I can't seem to find much information about updating the graph and how many points you can set it to keep in memory on the browser.
I PM'ed you the details
Thanks!
They say you own your data and sharing [https://plot.ly/tou](in their plans) and compare it to "a GitHub for plots." 
I know this doesn't answer your question but I'll share it anyway. Maybe someone will find it useful. [Free programming books](https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md)
and this "simple automation language" shown on the home page is...Python ?
Just use regular cpython and see how it goes before being wrapped up in optimizing the speed. Nothing you are describing (hitting a remote server w/ queries and saving JSON) screams out for pypy or Cython. 
as someone that has been toying with the idea of migrating out of QA in the future, thats a little scary
Im also new to Python, and the virtualenv is still somewhat confusing. I understand the "why" and the "how" but the implementation feels odd/messy. Let me explain; I have a Python project in a folder, and create a new virtualenv and run the activate command. The result is alot of "stuff" in my project folder i dont want to see, or have in this folder. I know i can have a list of gitignore entries, but i like to keep stuff very clean and organized. Maybe its just me, but the result feels very messy. I could go with a hidden folder that could keep all the virtualenv stuff. Maybe something like .env/ But is there a reason why python devs dont use Vagrant? I feel this way you always have totally clean dev environments, and you have total controll of the OS as well.
I would honestly recommend to set up a hackintosh, I did this recently without almost any driver or any other issues, and now I forgot about the pain that windows cmd is. Also multitasking on mac is GREAT, the ability to have several virtual desktops is awesome especially if used with two screens. No more windows for development for me, I still keep it in case I want to play games :P
Here's to psych/soc majors looking to get into tech fields. Because who needs a useful bachelor's! 
We're going to try to do this once a month. Anyone is welcome to join in, to ask us about recent changes, future plans, or how to do things. Contact me for an invite to the Google Hangout, or join our [development chat room](http://www.hipchat.com/ghtNzvmfC) at that time.
Necessary is a bit of a loaded word :-) The point I would bring up, is why not isolate the software you are writing from your system as much as possible? This helps you avoid a number of OS/package manager related issues.
Also - you can install pylint, pyflakes, and pep8 on your system or in a venv to get excellent analysis and compliance checks without an IDE. (Not that there is anything wrong with an IDE for this). I've setup emacs to run this pychecker every time I save my code and it has been very helpful. Reinout van Rees has a very helpful blog article on doing exactly this: http://reinout.vanrees.org/weblog/2010/05/11/pep8-pyflakes-emacs.html Also, note that the pychecker.sh script he has written, can be used with anything. It just needs to have a file or directory as its target.
This is what I needed.
Thank you. I know that python didn't actually do the work, but the barrier to entry for python was so low that it really enabled me in a way that other languages I had tried didn't.
It's often extremely hard for people who learn Java, Python, or any other higher-level language to go into C, because they are never forced to confront the realities of resource management. Someone who learns how to consistently bounds-check things to avoid problems in C code ends up writing much more secure and fault-tolerant code in higher-level languages, is my experience.
I think that's why learning puppet wasn't too hard. After going back to look at ruby though, and how unpythonic it appears to me, I still have no desire to learn it :)
No, it's not a full programming language. It's basically a data format, expressed in YAML, that allows you to specify the configuration of a machine. It is quite simple, defining just a few different components like hosts, tasks, and handlers. You can learn the majority of it in an hour or so. Ansible interprets these specifications (using a Python program), executes them by sending Python scripts to the specified remote machines for execution, and reports on the results. If you need custom functionality that doesn't exist in the standard system, you can implement a module in Python and invoke it from a configuration spec. This enforces a separation between the specification of a configuration, and its implementation. It also allows modules to be written in languages other than Python. One advantage of this approach is that the specification of configurations is standardized. A problem with using a full programming language for this purpose is that using programming functionality at the level of the specification tends to obscure the specification itself. 
I use **virtualenvwrapper** and keep all my virtual environments in *~/virtual_environments*. Keeping all those files in your git repository indeed seems messy - give **virtualenvwrapper** a shot. I quite like the writings of Jeff Knupp, perhaps [Starting a Django 1.6 project the right way](http://www.jeffknupp.com/blog/2013/12/18/starting-a-django-16-project-the-right-way/) could be of some inspiration to you if you need some more elaborate instructions. A disclaimer - I believe Python 3.4 added **venv** but I haven't tried it out yet so I don't know how what I have written so far holds up to that version - I'm still on 3.3.
The most helpful things I ever did were to try to write programs that solved problems I had. That worked better than any book I read. However I love the "python cookbook" because it has tons of examples of great, concise, and practical functions. Hang out in /r/python and /r/learnpython and just try to write a program every day.
I used so many tools by Mark Hammond in my Windows days. Thankfully though, those days are behind me, phew!
How painful is it to maintain after install?
You will!
I would love to, but unfortunately the machine learning is for my own personal progress. Not related to the business... yet. If I have questions about python machine learning though, are you up for some advice?
Yes, that's a good point, but it also depends upon your needs/goals. I'd argue that your typical sysadmin doesn't really need to know C to write useful day-to-day code. I'm a software tester myself and sure, if I were testing embedded systems, it might make sense to know C (and even assembly) well, but I'm typically writing lots of glue code and utility scripts. I would never say that starting with C as a first language is bad, just not entirely appropriate for every beginner's needs. As I mentioned though, it's WAY better than C++ as a first language. Also, this is a generalization, but for some people such as myself, it's easier to start off with a "gentler" more forgiving syntax and environment. Yes, it leads to some sloppiness and bad habits, but I've had a much easier time going back to C AFTER learning Python reasonably well. I'm at the point in my career/aptitude that I'm no longer afraid of languages/tools. I know that I can learn anything, it's just a matter of time and effort. When I first started with C++, I felt like a complete idiot. C++ has its strengths and is useful in many domains, but it's also fairly complex. For example, I was tripped up for the longest time over the difference between pointers and references. Ultimately however, I agree with the conventional wisdom that you should be flexible and try out different tools. I don't like to say that you should use the "right tool for the job" because there's almost never one "right tool" for the job, but instead many "good enough" tools. :)
I'll check it out for sure. I was aware of salt and ansible, but not this one.
Well, I can tell you from my wife's experience, she migrated from senior QA Analyst to Business Analyst 8 months ago, and she has written 3 times as many Test Specification documents than Application Specification documents. She also has done deployment testing for every deployment she has participated in as a Business Analyst.
Check out this post by a guy I met at a DevOps meet up (which are way fun btw,) with some deviation this is pretty typical I'd say. http://redd.it/20vp2q 
thanks
Yep, potentially! Most of the machine learning stuff I've done has been outside of python, but I'm slowly getting familiar with scikit-learn, so maybe we can help each other out.
I'm a huge fan of education, the more the better. That said, I don't think that education must mean college only. There are so many free/cheap resources out there now to do trade learning (like programming) that can give you the skills you need to go out and make something. I'm glad I went to some college, and I felt like I learned enough for what I wanted to do. But even in college, for my math classes for example, most of my learning happened on [kahn academy](https://www.khanacademy.org) anyway. 
I believe it already has 3.x support, look at the Requirements section here: https://github.com/paramiko/paramiko 
I understand your sentiment, but for me, Python would have been a better first language. I'd still argue that C is better than C++ (again as a first language) since it's the precursor to C++ and is "closer to the machine" i.e. there's less overhead with C than C++. We could easily get into flame war territory here. . . :) 
%;33.333333333333repeated
That's so great to hear! Congrats! I have a very similar story and the common denominator between us is not programming specifically but instead: DevOps. I started out a few years ago as a Technical Support Analyst, slowly moved into some Sysadmin stuff and then luckily got the chance to learn Chef/Ruby and work with the Lead Operations Engineer. Now, less than a year later, I just accepted a position as DevOps Engineer in San Francisco and doubled my previous salary :D DevOps is HUGE right now. Automation is the next big thing. There are literally teams of recruiters specifically looking for people like us. Best part is I love Chef, I'm excited to learn more Ruby and I feel like I'm quickly moving towards the life I want. The technology is exciting and there are really fun companies looking for the flexibility that an "Automation Engineer" provides. We will have no issue finding work in the near future that's for sure. 
&gt;Yes, that's a good point, but it also depends upon your needs/goals. I'd argue that your typical sysadmin doesn't really need to know C to write useful day-to-day code. Yeah, C is a very inappropriate tool for devops. C++ and Java as well. There's a reason why the most popular tools for that job set are written in Python and Ruby. C is actually very fast but fragile. This actually makes it really good for programmers who want to learn to be experts; the closeness to hardware means less fluff (like bytecode compilation and running through a bunch of JVM optimizations) sits between the programmer and the results of execution. It teaches you to be careful, because C is unforgiving and doesn't have constructs like garbage collection and strong type checks to protect you from yourself. That pain is your later gain, of course; you then get empowered by high level languages, but I think you avoid bad habits. It's definitely not about the language. I did a tiny stint in BASIC as a kid and then Pascal for a semester and then did a bunch of C code before branching off into Perl, PHP, Python, Scala, Javascript, with deviations into LUA and a bunch of other niche oddities. But I wrote an e-commerce engine in PHP that went a decade without a security breach or performance-crippling issues, and given what I've seen of most PHP code, I think it was my background in C that saved me. I was absolutely paranoid with my algorithms, sensitive to memory allocation, paranoid with user input -- all things I learned writing C code where a segfault is waiting around every corner (especially if your first computer was running the code at the equivalent of like 1Mhz). To draw a fitness programmers in /r/fitness might love, I think writing C code is like the squats of programming. It's painful, it's awkward as all hell, it isn't glamorous at all, but it builds fundamental strength that is useful for all sorts of things. But not devops. :)
What city are you in?
Not exactly what OP meant but I worked in companies that outsourced QA. If QA guys touched code people will shit themselves. There will be accusations of stealing intellectual property and other shit. 
Well I had it for only few weeks, but it is pretty effortless all OS updates install automatically so there is no problems there. IMO it takes less work to maintain than a windows. One thing is that you must be careful when upgrading the hardware. But check on forums if your hardware is compatible, if not it can be a pain in the ass to get working properly
So, basically a sysadmin but abstracted one layer up? Is that what Google calls a Site Reliability Engineer?
&gt; After going back to look at ruby though, and how unpythonic it appears to me I started out with Python and moved to Ruby because there were more Ruby jobs where I am. They're both pretty great tools to have in your belt. Every design decision has tradeoffs, and in my opinion neither wins across the board. I originally felt the same revulsion as you about Ruby's unpythonicness, but my thinking has flipped after working with Ruby for a long time. Some things like the syntax for classes, instance variables, etc is much nicer in Ruby. No weird `__magic_methods__` syntax or `self`'s littering your class definitions. And I don't expect a lot of agreement in this sub, but the pythonic ethos of "One and only one way to do something" is both a blessing and a curse for the ecosystem. It means consensus must be reached before any features can be changed, since old things must be removed, and leads to ridiculous decisions like breaking the `print` keyword syntax for purity reasons instead of just supplementing with the new `print()` function. That's a trivial example, but it exemplifies the crux of the issue nicely. In Ruby world, they add features but rarely take away complementary features that aren't broken. This leads to situations where you can have multiple, sometimes many, ways to accomplish the same thing like with Procs/lambdas/blocks. But I've never found it to be a problem. And it keeps everybody playing nicely together under one big tent, unlike the python 2 vs 3 schism. Anyway, I'm not trying to talk you out of anything. Python is a fantastic language. But try to keep an open mind.
I sometimes feel guilty about what I charge people for some of the Python solutions I have developed, however - it's really their problem, not mine!
It only counts if it makes it through say 6+ hours of solid testing.
Make sure Windows is set to create a dump file on BSOD, then analyze the dump file using something like http://www.nirsoft.net/utils/blue_screen_view.html
Initially....... I was in an political organization and wanted to automatically update dates for regular event dates with various rules (example no meetings for months x and y). Python and HTML SSI (http://en.wikipedia.org/wiki/Server_Side_Includes) allowed me to do what I wanted at the time. Prior to that I was fooling with PHP, but wasn't fond of the language syntax.
Later on, I started using it because it was faster to develop in compared to C/C++.
maybe look into how to know it better so you can actually be worthy of that 50% raise? have you gone through code designs yet?
Try Kivy.
My feeling is that every language has a Zen, whether it's actually written out or not. Since there are so many general purpose languages that are well suited to solving the same problems, it makes sense that each one evolves around some central concepts that set it apart. I think the "feel" of a language should be consistent. Yes, Python would be more explicit without properties. As with all language features that aren't straightforward, you have to consider the trade offs involved. That's exactly what we're talking about WRT the Ruby style code blocks, right? Properties and the implicit calling of a setter or function bring with them more good that bad. Multiline lambdas (or lambdas at all, IMO), don't add enough to the language to make up for the extra complexity they bring. This is my opinion. You're not going to change my mind by pointing to other features of the language that are also complex (like *yield from* or the *asyncio* library, which are not so straightforward IMO). One complex feature or implicit behavior in the language doesn't merit the addition of another! As a side note, doesn't Ruby also basically have properties? Ruby calls them assignment methods, and they're a lot cleaner than Python's *property* decorator: http://ruby-doc.org/core-2.1.1/doc/syntax/assignment_rdoc.html#label-Assignment+Methods Yep, context managers were definitely simple, useful, and awesome before they existed in Python. They also happen to *fit* neatly in the language. So what? I'm really not following the *language feature X exists in Python so therefore language feature Y should also exist* arguments.
Is this an open source app? Is it something you plan to sell commercially? Questions like these inform your choice of packaging. 
I ran the code, it runs and asks for the password and the email, but it keeps on running does not stop runs forever. I am not sure how it works on your machine. Do you use linux. I use windows.
Because I hated ruby. With Passion!
I've found [this site](http://effbot.org/tkinterbook/) useful for working with Tkinter, even though it's rather old. If you're using Python 3, you'll have to change `Tkinter` to `tkinter` in examples, but I think that's about the only change.
'Cause Eric S. Raymond likes it.
[Python Module of the Week](http://pymotw.com/) is a great one. Asking around /r/python and /r/learnpython is helpful too. Check out "Python Cookbook" on Oreilly, also. Great book.
Awesome, thanks for the links, I'm aware of the two subs and lurk them ocassionally. I'll have to actively read them now!
more people should know about set()
After migrating to Firefox, and falling in love with the idea of using free software, I wanted to pick up a hobby, where I could give back to the community. A bit of googling lead me to Python. I tried it, wrote rur-ple as my first project, and got hooked.
I'm not sure, because I have not created a GUI app in Java (I don't know Java). But I'd bet it would be fairly comparable. In both cases you would have the language itself + the widget toolkit for making the buttons, textboxes, menus, etc of the GUI itself. In Java I guess that is something like Swing or SWT. For Python, you have a number of choices: wxPython, PyQT/PySide, PyGTK, or Tkinter (which is included in the Python standard library), [among others](https://wiki.python.org/moin/GuiProgramming). I use wxPython, but I've heard good things about the others as well.
This post finally convinced me to learn python.
Definitely check out http://bokeh.pydata.org. Streaming and realtime plotting is a basic feature.
The scipy stack is notoriously difficult to install, for a variety of reasons that are too numerous to go into here. That's why most people are now turning to just using the Anaconda distribution, and its package manager conda.
Start by making something much simpler in TKinter - just learn how to create basic components like labels, buttons, and text areas. Then learn how to use the Tkinter canvas object, which will probably be the easiest way to make your snake game. You'll need a data structure to represent the game board, and another to represent the snake. You'll also need a timing mechanism, and the easiest way to do that in Tkinter is with the after() function. Here's a few lectures I did on creating apps in Tkinter: http://cs.iupui.edu/~aharris/230/python/GUI-TK/gui.html (audio and HTML5 slides with plenty of code samples) I've got a few more advanced demos with the timer and canvas here: http://cs.iupui.edu/~aharris/230/python/demos/ Games are NOT the easiest type of app to build, especially in a framework like Tk which isn't really designed for gaming. It can be done, but you've got a lot to learn. 
There are some text related tools, but it's mostly the base libraries that many of the related data processing stack depends on. The rest can be easily pip-installed on top.
I wanted to get into gamedev, from various engines that were on market, Panda3d seemed like easiest to use, but it needed Python (or C++). At that time i had almost no clue about how use C++ properly (college level problems were OK, but I was not confident to use it for game). Then I discovered Python, and fell in love, before that I knew PHP, Javascript, JAVA and some C++. Python was simply too awesome compared to PHP and JS, and so much easier to use than JAVA or C++
Congrats dude!! As others have said, it's your attitude towards self improvement that has got you where you are. Its these stories I love to see as I move into work where I hope programming can help me out too.
My commanding officer told me to learn it. So I did. Jokes on him, I earn twice as much on the outside now. 
&lt;spock&gt;Fascinating!&lt;/spock&gt; Also: Brython, really impressive.
psych BA ended up in a Systems/Data/QA/Business analyst position. It can happen, looking to move to a dev role in the near future.
I no longer remember. I wanted to learn to program, Googled around, and somehow picked Python. It very well may have been partly because of its name!
All positive notes? No complaints about GIL? Personally its itertools and collections. functools, decorators and context managers would probably get used more too when I get used to them..
Everyone else was doing it. 
My primary job is coding in Java but it took too long for an idea to go from paper to a compiled running app, so I started writing Python for new development. The other hardcore java devs on the team don't like python and frown upon it but I'm undeniably quick at getting working prototypes in front of the corporate big wigs so the bosses continue to let me code with it now.
You still haven't answered /u/anossov's question. What exactly are you afraid of? Where is the problem with a once-a-night cron job running for 15-20 seconds? Many have cron jobs in production that run for hours.
I have a similar story and I'm not even on the tech side. I started in Marketing, which really is just a lot of spreadsheets and numbers and repetitive analysis. I first wrote VBA scripts to automate and improve some of the processes but VBA sucks so I moved to Python and began learning that by myself and using it at work. Fast forward 2 years I increased my salary by almost 100% and am managing someone even though I'm only 24 years old. Boss was a fan of my Python magic so he even sent me to Montreal to attend PyCon with our tech team :) Learning Python literally changed my life. I love coding!
Commercial
Well, there is [this](http://zetcode.com/gui/tkinter/nibbles/) which shows how to make a snake game using tkinter. Though you might consider that cheating. However, that website has a very excellent tutorial on using tkinter (and other gui libraries) in python, I highly recommend it.
PERL did.
That is so awesome. Too bad [DataNitro](http://www.datanitro.com) wasn't around when you first started!
/r/softwaregore 
I had a tough time installing Perl on my windows box.
&gt; If they dig deeper, I compare it to writing formulas in Excel -- since Excel is company approved, to they need approval every time the type in =(A1 + A2)? Excellent analogy. One that I am going to nick - thanks! 
Pycharm was a close second in my 'list of things I wish I knew before'
MATLAB license server was down at my university. Now I never need it. 
Because I had a good enough handle on Java and I had wanted a crack at Python for a long time.
I had to deal with a multimegabytes 'project" written in VBScript. I just wanted a way out... The alternatives where: D, Python, JS, a bullet in my head... I just selected the one with more wide spread support at the time.
It's not that bad of a message. At least you knew the problem was with the argument. 
If you can do the math by hand, it's easy enough to translate that into any programming language. If you really need a plugin, I found [these](http://www.astropython.org/resources), but I don't know if they will work. 
Pandas, and only pandas
I've put together a standalone executable with PyInstaller, which got the job done. I think it only works for Python 2.4-2.7. The command used was python pyinstaller.py -y --icon=pathto/myapp/icons/my_icon.ico --noconsole pathto/myapp/myapp.py
Your Google search was unsuccessful? Really? OK fine I'll just tell you. Xlrd, Xlwt, xlsxwriter. Try searching Google again "python excel". 
&gt; a program (not built by me) a compiled program ? written in...? (I don't want to assume) do you have &amp; can you modify the source ?
&gt; but VBA sucks How did you use Python to do what it takes VBA to do ?
Wrote Perl for long enough that I could not longer read it.
Well I used Python to automate data gathering, putting data together, analyzing it using rules or models, scraping sites, templating. A lot of different stuff. The libraries I use often are openpyxl, pandas, requests, csv, beautifulsoup. The stuff I was doing wasn't for presentation purposes so prettiness wasn't a factor.
Thanks for the tip. I've started using emacs with autocomplete.el lately and this may help with that setup.
I found something like that in struct.pack a while back. It was caused by the function looking something like: def pack(format, data): return Struct(format).pack(*data) data was the wrong length.
Congratulations. Here is some advice / tough love: * You linked to your profile, not the program you're talking about * Your requirements.txt file looks like you remembered that you need one and then did pip freeze &gt; requirements.txt and removed all the ones you didn't care about. Do I really need simplejson==3.4.1? * Don't use reserved terms like `input` * Spaces are preferred over tabs * Why are you only grabbing one link from youtube_links? * soup.findAll(src=True) * Obey character limits per line. * If you return the same thing from both clauses, just return it instead of having the else * xmltodict looks like a horrible idea. XML can be interpretted as many types of "dict" (dict with either nested dicts or lists all way to strings or ints?). You may notice that the library interface looks insane too. Use xpath for xml searching, especially when you don't have much to do. * Close any handlers you open, regardless of whether they'll be closed by exiting your scope. * You only call `image_links` with tags=False. Remove the extra logic. * return list(i.get('src') for i in soup.findAll('img')) seems clear enough * else: pass???! * why are we replacing new lines with brs? * Obey character limits! This definition can span multiple lines! * Globals should be ALL_CAPS * Are those env variables typically defined? Do you want people to have to call your script with `NB_TOKEN=xxx python wp2nb ....` At least use [] look up so they get a key error when those aren't defined and can see that they are missing information. How do they know they have to set those environment variables? * Two of three similar api methods return a status code while the other returns a response. * Space around = when it isn't defining a named parameter. * Why splitext if you are just going to join again on the next line? * What did the first character ever do to offend you? * When did we decide that it was image/jpeg? * Does the updated time matter? Are you just passing in something to make it work? * json.loads(r.content)!?!!?!? r.json()! you already know what version of requests they are using to the point! (unless the issue is that you want a datetime back or something else that requests' sp * why append to the list in a loop then loop over the list to delete when we could just loop over the list to delete. `for i in get_posts()['results']: delete_post(i['id'])` * Where do I get this magical xml file I'm supposed to be passing in? General advice: 1. Your code is asking me to remember a lot for just 150 lines. 2. Make the \_\_main\_\_ method high level. I should be able to read it aloud for documentation 3. I think you are using dictionaries a bit much to move data around. For example, output_dict could be replaced by `return post, images`. 4. Don't create variables unless you need them. `x = computation; return x` should just be `return computation`. Comment mainly why you are doing something only comment what you are doing if it complex You don't need to say "This splits the filename from the URL." the next two lines say that quite fine (also cudos on using tuple assignment in the return). What does delete_all_posts do? Why it ''' Removes all posts '''!? Whoever would have thought! A lot of what you have done is good. You are trying out some best practices (requirements.txt, README), you have install and run instructions, and you've clearly spent time breaking this into isolated logical sections. If you're reading my comments and thinking, "Man, this guy is an idiot! NB_TOKEN is required for nation builder to run! RTFM," code with the mantra "the people reading this are idiots, I must make this code so dumb they can understand it."
exactly. It's faster than python, and it's better at concurrency - so i'd choose it over python when that matters. I'd also choose it over C in the same instance, but i wouldn't say i've 'switched' from C to go. 
&gt; code with the mantra "the people reading this are idiots, I must make this code so dumb they can understand it." Solid advice right there ( not that the rest of it is less important though )
I wanted to pick up a "safe" language that wasn't Java (because fuck Java). Most other dynamic languages do stupid crazy things if you try to do something weird instead of just erroring out like Python does.
Your wording just made everything click for me! Thank ya darkness.
Thanks for the reply, definitely useful.
Being a perlfag I was actually opposed change for a really long time, and my first forced exposure to what I deemed to be newfangled and unnecessary was to ruby through Puppet. I never liked the syntax and eventually started using python and was immediately hooked on making webapps with django and web.py. Eventually I could not believe all the years I had wasted on Perl. So in retrospect I can also just say "Perl did." and leave it at that. 
There's absolutely no reason you should need admin privileges to author and execute python code with special libraries. It's all about configuring your environment. PyGame doe not seem to offer the binaries in non-installer format. They all seem to be msi, exe, deb, rpm, ... Most of these installer packages can be extracted without the need to run the installer, but it may be a bit of leg work. Perhaps you can install them at home and grab the necessary components on a jump drive. On the other hand, Kivy offers a zip format for getting the binaries. This is perfect for your use. Get the appropriate binaries for your version of python (match both platform and architecture.) Just extract, configure and go. Kivy even comes with .sh and .bat files to help you get the environment setup correctly. It's mostly about getting the PATH and PYTHONPATH variables set correctly. For example, download the latest kivy binaries: http://kivy.org/#download 1. Open a shell. 2. Execute the kivy.bat or kivyenv.sh. 3. Run python 4. import kivy 5. have fun!
Whoopska - thanks, this is exactly the feedback I'm looking for. I'm obviously not a pro, so it's great to get some advice. I'm a political staffer by trade, so there's not many people around who can look at my code and go 'yuck, why are you doing that?!' I'll work through your list and see if I can make some improvements.
cookbook
I'd even go further and say "I'm an idiot. I must make this code so dumb that even I can understand it (in three months)." Hopefully you are always improving and refining your coding style. I often look over my old code and wonder about what I was thinking when I wrote it. I take solace in the idea that my idea of great code is ever evolving.
Just be aware that bytecode can still be decom(py)led. It's not a good way to protect your source, even if it will obfuscate it a bit. Compiling to a binary executable will be a better option, though still not bullet-proof. I've had mild success with py2exe, but that was mostly an experiment. Also I would not trust any python tool that was distributed as a binary. I may be wrong, but I feel like commercial viability is based on support and continued development. Heck, clients can even provide some useful patches. There are a lot of commercially viable open source projects out there.
There are two hard things in computer science: cache invalidation, appropriate naming, and off-by-one errors.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 4. [**Python**](https://en.wikipedia.org/wiki/Guido_van_Rossum#Python) of article [**Guido van Rossum**](https://en.wikipedia.org/wiki/Guido%20van%20Rossum): [](#sfw) --- &gt; &gt;About the origin of [Python](https://en.wikipedia.org/wiki/Python_(programming_language\)), Van Rossum wrote in 1996: &gt;&gt; &gt;Over six years ago, in December 1989, I was looking for a "hobby" programming project that would keep me occupied during the week around Christmas. My office ... would be closed, but I had a home computer, and not much else on my hands. I decided to write an interpreter for the new scripting language I had been thinking about lately: a descendant of ABC that would appeal to Unix/C hackers. I chose Python as a working title for the project, being in a slightly irreverent mood (and a big fan of [Monty Python's Flying Circus](https://en.wikipedia.org/wiki/Monty_Python%27s_Flying_Circus)). &gt; --- ^Interesting: [^Python ^\(programming ^language)](https://en.wikipedia.org/wiki/Python_\(programming_language\)) ^| [^ABC ^\(programming ^language)](https://en.wikipedia.org/wiki/ABC_\(programming_language\)) ^| [^Van ^Rossum](https://en.wikipedia.org/wiki/Van_Rossum) ^| [^Guido ^van ^Robot](https://en.wikipedia.org/wiki/Guido_van_Robot) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chcjiug) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chcjiug)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; You are confusing information (art is not information, I'm not talking about information... art doesn't have to be powerful or even useful, it's art), knowledge, creation, facts and putting all of these in the same bag... I'm using the definition of "information" from physics. I have no idea what definition you are using. &gt; Did I say that math solutions should be patented ? NO. I didn't say that either. I said "Math shouldn't be IP protected". &gt; No you can't, France is not EU and EU is not France. The EU court has jurisdiction over France though. The EU court is higher than the French supreme court. And EU directives are constitutionally required to be implemented. That's a requirement to join the EU! &gt; Artists are paid by selling art or doing performances. ...and they have the backing of police and law for IP protections. Courts and police costs money, and that money comes from taxes. Any law that is enforced by the state is a transfer of tax money into whoever benefits from that law. &gt; Do you think concerts should be free ? Movies ? Do you think you can make spiderman with no money just because it's fun ? I believe copyright should be something like 30 years from creation, which I said before. Please argue against what I said. &gt; Do you think that every artist should work at mac donald's and make CDs and movies on their spare time just because it's fun ? The majority of music is actually produced something like this already. Just a very select few earn any real money. So even if copyright was abandoned it wouldn't affect the creation of music much. But again: I'm saying it should be 30 years, not the ~140 years it is today. &gt; Money is not here to make people like or bare doing things, it's here to make people make a living out of it. Money is the tool of free markets to make sure things that must be made is made in a self regulating fashion. It isn't there to finance musicians just because they want to make a living doing it. We aren't living in a communist state!
[This video](http://www.youtube.com/watch?v=OSGv2VnC0go) helped me do that, the tricks he talks about are pretty nifty.
Dude. https://en.wikipedia.org/wiki/Information
&gt; Your requirements.txt file looks like you remembered that you need one and then did pip freeze &gt; requirements.txt and removed all the ones you didn't care about. Do I really need simplejson==3.4.1? Could you elaborate more on this? What's wrong with having simplejson==3.4.1 ?
Also, specify in the readme which version of python it requires. I can deduce you use python 2.x since you did print something but it helps if it read in the manual :)
What does this do that one can't do with "find ... -exec mv" ?
Project Euler. During my Math degree I wanted to start working through some of those problems and it seemed a lot more intuitive to do in Python than C (the only other language I knew). Plus I liked the indentation too - my code always seems to look neat (even if it is logically a mess...). 
I've been using C, C++, Java and other systems but none of them ever felt as comfortable as I used to feel with the Turbo Pascal environment. A friend suggested I try Python (1.5.2) and within a few hours it already felt like an old pair of cosy slippers.
because I never understood what my dev-friends were talking about. 
OT: How did you upgrade your RaspberryPi to Gigabit ethernet? Totally agree on what you said. I wrote some scripts in python which, just by removing frequent disk I/O, became twice as fast. 
Some people, including me, are very used to statically typed languages and like to be sure what objects they are handling. The IDE support you can get from statically typed languages are also far better than what I have seen from python. For quick small tasks python is ideal. But for anything larger and more complex I'd like the extra control static typing gives.
Pyramid Framework made me do it 
Whoopska was pretty thorough. There are certain conventions it's a good idea to adhere to generally. flake8 embodies a lot of those opinions and it's dead easy to use. $ pip install flake8 $ flake8 wp2nb.py
Dealt with a commercial search engine product that had an extensible document processing pipeline written in Python. On a work trip, bought the first edition of Lutz's "Programming Python" and was irate the entire 17 hour flight I had no laptop. Python just made sense. And every iteration, it just gets better.
Excellent analysis. Just to add a wee bit more detail: not onlly "input" is a reserved term (builtin) but also "id". You can spot them using the colour of the syntax. if `len(url) &gt; 0:` can be reduced to `if url:` 
be careful about following this type of tutorial too closely. I just gave out a bunch of zeros to folks who turned in code I found on line. While you will no doubt learn from a tutorial, the teacher will not know if you really did it yourself or just copied the code. I've seen exactly the example you're talking about turned in as a final project. Your professor probably has too. If you do this, be up front about it in your docs. give a link to the tut and explain how your code extends and improves the tutorial.
What time is the hangout?
I second this. All my requirements.txt files contain whatever pip freeze spews out.
We have a very poorly programmed 3rd party software to drive a camera in an interferometer. The scripting side of the software to allow you to automate things was a bastardized python interpreter. It forced wx gui windows but couldn't communicate back from them. So the only way to adjust options, files to run, etc was by changing the script files themselves and running them through their software. Also while it could send to the win32api, it wasn't waiting to receive a response back so I could write to excel sheets but couldn't rearrange them for example. I knew nothing of python, but I used the scripts as a base to understand the parameters needed by the project and flush out the 3rd party software routines for my own routines written in python/c to get out of their software, now I only run it to grab the images and that's on the cutting block next. I love it though, and prefer it to the other options here which are LabView or IDL. Although now my manager whom wrote a whole software suite for a different interferometer in IDL wants me to convert all my code over, grr. But god damned learning it was useful. I was sitting at home a few months ago and needed to send ~700 pictures from a trip to my parents. In 10 minutes and roughly 15 lines of code I had it shrink the resolution of the pictures to a reasonable size to email. I still use it to test the data and files being saved during the process of re-coding things in IDL. Amazing where buying a shitty software suite will take you (I had no say in the 3rd party software, that was purchased years before I got this job).
win32api has great com interop. That will let you open, manipulate and save a sheet from Python.
I think he means replacing the Pi altogether with a different unit that has gigabit. 
Have you used the PyCharm ide? Being a java dev I thought it got a good share of what java ides can do considering its not a static language. 
You can have a look at this project and see how they did it. https://github.com/riverrun/genxword/wiki/genxword-gtk But you might also consider writing the Program to display output on the console initially and later adapt it with a gui. This way you will have the logic in place and can decide on the best format. Maybe it's not a GUI you need but a visual representation of your puzzle and you can do that by converting output to html5.
This article is being down voted for the same reason any other article that makes comparisons between oranges and apples gets down voted.
I ran into a problem today when installing MySQL-python from requirements.txt. The requirements was made some time ago and when I ran "pip install -r requirements.txt" it spewed something about having to upgrade MySQL python or something like that, I don't have the output anymore. It was easily fixed by changing the requirements.txt from having == to having &gt;= in front of the version number for the module. Although I don't think /u/Whoopska was talking about problems like this.
I'm a C# coder at work, so I figured at home, I should try something different. Python seemed different enough from C#. And hey, if they can write Reddit in Python, it has to be okay, right? Why is that a silly reason? Because I've been 'promoted' at work to the point that I don't do any coding in C# at all. Now, I'm almost 100% a Python programmer (actually Python/HTML/JavaScript/CSS, but still mostly Python).
Blender ships with a python interpreter built in, and is scripted in Python, so you might be able to make the case that it is Python. However, 3D modeling is not easy to learn, and it will take you a long time to learn enough modeling to even get to the scripting part, so I don't think this is a good solution for your first rodeo. 
I build a lot of high-volume data flows for data warehouses where there may be one or two massive, usually machine-generated and simple data sets and another 10-30 small, complex ones. I see a lot of folks struggle to come up with a single framework and language to handle both cases. I prefer to address this with two languages: * The most maintainable language - for 95-100% of the feeds. It should be easy to test, easy to read, easy to produce documentation for. Python is perfect here. * A fast language - for that last 0-5%. Almost always I can get by using Python here as well, though typically I'll split my incoming data and run it through multiple python processes for course but very fast parallelism. Because going with the fastest language possible at the cost of maintainability is just premature optimization. The cost of these projects is typically 90% labor - so fast maybe sexy, but maintainability keeps the costs down.
I too was led to Python by its usage of significant whitespace, but for a different reason -- I originally looked at the language because of a few particularly whiny complaints I saw online about its use of whitespace and indentation, and was immediately impressed by the "forced" legibility of programs written in the language (not just tutorials and examples, but real tools and libraries) and the flexibility of the language itself and the standard library. Finding Django shortly after discovering Python certainly helped, too :)
if i told you, i'd probably have to kill you :(
The problem is that he has to interact with unsaved documents, which those modules don't do. (Unless I missed that part of the docs) For the first part, he's going to need something like autohotkey.
Simple way... not really, unless the program you're hoping to pull from exposes an API like stuaxo said. What you're looking for is a screen or memory scraper, which I don't believe are easy to accomplish in python. Scrapy is a great module for python web scraping which might be able to be configured to look at data on the local system (not sure) - it's worth a look anyways.
It moves files into dated folders (under .old by default), and also expires them based on arguments. I don't know how to handle that with find alone. I use this on my windows workstation primarily so bash and find were not tools easily had.
I'm going primarily the route of OS X but at the very least I would prefer that the average joe not just `Open Package Contents` and see a .py file in there.
The scope assignment thing is new to me. I often run into errors like that, but never realised that they were related to the +=.
That site is very slow for me :( Also these mistakes aren't even Python mistakes. They are more like general mistakes that can be done in python. Assigning module variables or class variables inside a function scope? Why would you ever do that when you can assign them directly from the module or class scope without using functions? If it's not supposed to be constant, then you just made other mistakes. Referencing to exceptions outside an except block? What for? If you wanted to log them or show them or something you would do it inside a catch all except block. Importing a module that's importing the current module? Python is duck typed so if you are actually doing this you might have made other, far more serious mistakes. Lambdas. The only item from this list I suppose is justifiable is using lists and other mutable objects as default values for arguments.
&gt; ? I've tried it locally and it works just as fine There is no reason to do it in this case (and there very rarely is a reason to use it), but there is a semantic difference: `a = ` will forget the old list and name the new one, whereas `a[:] =` will empty the old list and put the new elements within it. That is, `a[:] = b` is equivalent to while a: a.pop() a.extend(b) Note that the left-hand slice may use indexes (just as the RHS version), which can remove/replace part of a list. This may be useful if somebody gives you a list and you're supposed to alter it in-place, this can also be a terrible idea if somebody gives you a list and they don't expect you to alter it. Looking at the examples, the code is kinda full of crap e.g. `lambda x : bool(x % 2)` could just as well be `lambda x: x % 2`, and if you have or are defining a function you should use filter instead of a listcomp, that is [n for n in numbers if not odd(n)] should be written filter(even, numbers) with `even` being defined as `lambda x: x % 2 == 0` (and if you need both an item and its index while iterating, use `enumerate`, don't go iterating on `range(len(list))`)
For those that say that Python 3 is no improvement: If you use Python 3, mistake 3 won't ever happen. And I think by using Python 3.4, you won't have issue 10 either.
That's not an off-by-one error though, the first count is the number of required arguments and the second the number of arguments passed in. This message generally occurs because the caller passed in optional arguments but forgot some of the required ones. You can have a message telling you that you didn't pass enough arguments because you gave way too many: TypeError: &lt;lambda&gt;() takes at least 1 argument (42 given) 
While your at it, why even declare numbers = [n for n in range(...)] to begin with? Just use range(10).
&gt; scroll Scroll? What about zoom?! I tried reading that in phone browser. Had to scroll left and right, left and right... +out of breath+ I think they missed the gold nuggets to hiring a decent web guru to make their site at least remotely usable.
That one as well.
[Indeed](http://a.pomf.se/qmqasw.png)
TIL. I always thought that when you create a slice you're essentially creating a new object that has no ties to the original. I guess when you assign a value to slice (which was something I didn't know you could do ) you end up modifying the original array. &gt;&gt;&gt; a[::-1] = [1,2,3,4] &gt;&gt;&gt; a [4, 3, 2, 1] &gt;&gt;&gt; a[::2] = [99,99] &gt;&gt;&gt; a [99, 3, 99, 1] 
`global` always seems kind of hackish to me. I try to always pass in any variables I'm going to need to modify and return the modified version. Keeps code much cleaner and more decoupled.
If you can get in contact with Karen Tracey, she'd might have some good info: http://www.caktusgroup.com/about/karen-tracey/
It doesn't seem to be as flexible as Highcharts, though. I can't find anything on tooltips or similar. I am looking more for a javascript replacement. Lemme post in that subreddit.
I agree it's a hack, but that's what that code is doing: manipulating global variables, i.e. it was a hack to begin with.
Python 3 is a huge improvement and anyone that says otherwise is just a whiner that doesn't want to port their code. They've fixed high-water-mark memory issues that are present in 2, and the full import paths alone are enough to switch. Managing a Python project of any scale with a bunch of local/relative imports in 2 is just a huge pain.
There are plenty of libraries that provide a least square fitting function. The weighting could probably be accomplished with any stats package. Frankly, R has all of this stuff built in and might be a better language for this application.
Semantic restrictions lowering cognitive load. Filter says you get a proper subset of the second argument (it can be abused to lie, bit that's a kneecapping offense). Comps can do filtering, flattening, nested iteration and mapping. And of course of you already have a function using a comp is longer than calling filter. 
&gt; There are a lot of commercially viable open source projects Could you name some, particularly if they are written in Python? Thanks. 
It seems to me that `filter` is less readable than the list comp, and it is possibly also slower.
I'd use python to parse your puzzle to LaTex. LaTex makes beautiful prints. http://tex.stackexchange.com/questions/44775/how-to-create-a-crossword-puzzle-in-latex
1700 UTC ([see here](http://www.timeanddate.com/worldclock/fixedtime.html?iso=20140513T17) for what that is in your time zone).
My company was downsizing and while I think I have a good shot at being retained I thought having Python on the resume in addition to Perl/Expect and all the rest of it would not look bad. That and all the cool kids were doing it.
The \ is an escape character, so it's escaping the character that comes after it. By "escaping", I mean that it causes the .to be treated "normally", rather than as a wildcard.
The exception-tuple thing is outdated. Instead of using the comma syntax, you're supposed to say something like except (Exception1, Exception2) as e:
ah... so "Python." is what it's looking for. Dammit. That's like coding 101. I should've caught that. Thanks!
Oddly, the documentation for Cython sold me. I know that doesn't make much sense, but that was what cemented my choice.
I had just moved, was looking for a hobby, and wrote a sudoku solver. Then I rewrote it using Dancing Links. Then I used PIL to write out a digraph of each stage of the recursion. It got a little silly. http://cavernum.net/dlsudoku/
not very convincing. 
Don't you hate those ones? I still get them after 28+ years of coding.
Normally it's bad style to return things you mutate. The lack of a return is often used to indicate possible mutation.
Typo inpected directory
Get rid of the original hack then! :D
Fabric. Made my life as a PHP dev much, much easier. I'd had some exposure to Python from a Django site I inherited back in 2010, but Fabric is where I really started getting a taste for the awesomeness. The more I used it, the more I found myself wanting to use Python to solve other problems. It's a beautiful language. I haven't managed to get rid of my PHP work, and it's hard to complain about it paying the bills, but I definitely look forward to the day where I'm doing more Python work.
Fuck that; I'm lazy. If a hack fixes the problem then I don't care. It works; ship it.
So someone starting fresh/new should definitely use the latest version?
Yeah, there was a fair amount of initial resistance to 3 because it wasn't backwards compatible and the initial releases were a little rougher, but 3.3/3.4 are definitely worthwhile. At this point most major Python projects like Django support 3 as well, so there's less and less reason to stick around on 2 even for existing projects. Start fresh with 3 and enjoy feeling superior when you come across some old 2 code that looks like # Argh you stupid Python 2 try: import cPickle as pickle except ImportError: import pickle try: import cStringIO as StringIO except ImportError: import StringIO
I've been trying to learn a language that just felt right for a long time and my work requires a lot of text file manipulation (using csv modules now for that). Python just gave me the flexibility I want to do that bit more. Plus my background is a monty python image and has been for many years... Also: first post and this place gets my love, figured you guys deserve it
&gt; asyncio is a kernel for event-driven programming, with some applications starting to be developed. [...] Twisted is also a production-quality event-driven HTTP server and client including its own event-driven templating engine [...] However I wonder why Guido decided not to add asynchronous HTTP/DNS client/server libraries employing `asyncio` to the standard library. Including only a framework for asynchronous I/O in the stdlib is just like including `socket` and not including its applications (e.g. `httplib` or `urllib`).
thanks!
Good point! We updated the post accordingly. Thanks for the input. [Toptal blog editor] 
Sorry I'm not the developper of the framework.
Pure function best function
AIUI it does not use invokeDynamic, as the appropriate research has not been made for it. It is definitely on the radar, but the dev teams size is not the largest (like 3 or 4 people who regularly contribute code).
I'm I right believing that if we had to define variables (ie "let x = something") we wouldn't need "global" at all, we would get rid of some nasty name aliasing bugs? "nonlocal" would still have its use, but just that.
Great! Congrats @mdipierro and the whole web2py team.
http://i.imgur.com/rh9N8vw.jpg
Hmm, I haven't encountered that sentiment anywhere else in the Python community. I think typically the lack of return indicates a non-data operation like connecting to a socket or something. Returning a mutated value is much preferred to using global vars and the `global` keyword.
That article part isn't particularly accurate, although I suppose this is one of the more finicky areas of Python. It says &gt; Remembering that lst += [5] is really just shorthand for lst = lst + [5] I shall now explain why that is false. Let's look at how a typical local lookup works: import dis global_variable = [] def simple_local_lookup(): local_variable = [] local_variable + ["new"] dis.dis(simple_local_lookup) #&gt;&gt;&gt; 6 0 BUILD_LIST 0 #&gt;&gt;&gt; 3 STORE_FAST 0 (local_variable) #&gt;&gt;&gt; #&gt;&gt;&gt; 7 6 LOAD_FAST 0 (local_variable) #&gt;&gt;&gt; 9 LOAD_CONST 1 ('new') #&gt;&gt;&gt; 12 BUILD_LIST 1 #&gt;&gt;&gt; 15 BINARY_ADD #&gt;&gt;&gt; 16 POP_TOP #&gt;&gt;&gt; 17 LOAD_CONST 0 (None) #&gt;&gt;&gt; 20 RETURN_VALUE Going through the bytecode one step at a time, so we get it: * `BUILD_LIST 0` makes an empty list * `STORE_FAST (local_variable)` stores the list in `local_variable` * `LOAD_FAST (local_variable)` loads the list from `local_variable` * `LOAD_CONST ('new')` makes the string `"new"` * `BUILD_LIST 1` makes another list, but with one item, which is the string `"new"` * `BINARY_ADD` adds the loaded `local_variable` with the newly created list. * `POP_TOP` just removes the result from the stack * `LOAD_CONST (None)` loads `None` * `RETURN_VALUE` returns the `None` Not too hard, then. Let's look at the change in scope when using a global variable: def simple_implicit_global_lookup(): global_variable + ["new"] dis.dis(simple_implicit_global_lookup) #&gt;&gt;&gt; 35 0 LOAD_GLOBAL 0 (global_variable) #&gt;&gt;&gt; 3 LOAD_CONST 1 ('new') #&gt;&gt;&gt; 6 BUILD_LIST 1 #&gt;&gt;&gt; 9 BINARY_ADD #&gt;&gt;&gt; 10 POP_TOP #&gt;&gt;&gt; 11 LOAD_CONST 0 (None) #&gt;&gt;&gt; 14 RETURN_VALUE Now we have `LOAD_GLOBAL` which *loads* a *global* instead of `LOAD_FAST` which *loads* a *local*. The rest is the same, so that's fine. But what happens here: def stunningly_broken_global_lookup(): global_variable + ["new"] if False: global_variable = [] # Can never run! dis.dis(stunningly_broken_global_lookup) #&gt;&gt;&gt; 34 0 LOAD_FAST 0 (global_variable) #&gt;&gt;&gt; 3 LOAD_CONST 1 ('new') #&gt;&gt;&gt; 6 BUILD_LIST 1 #&gt;&gt;&gt; 9 BINARY_ADD #&gt;&gt;&gt; 10 POP_TOP #&gt;&gt;&gt; #&gt;&gt;&gt; 36 11 LOAD_CONST 0 (None) #&gt;&gt;&gt; 14 RETURN_VALUE ? Well, one might *hope* that an `if False:` codepath will get removed without affecting anything, but in reality it does have one effect. The first load is now a `LOAD_FAST` again! This will break, as `global_variable` isn't set locally by that point! So how does this relate to `+=`? Well, def what_does_iadd_do(): global_variable += ["new"] dis.dis(what_does_iadd_do) #&gt;&gt;&gt; 50 0 LOAD_FAST 0 (global_variable) #&gt;&gt;&gt; 3 LOAD_CONST 1 ('new') #&gt;&gt;&gt; 6 BUILD_LIST 1 #&gt;&gt;&gt; 9 INPLACE_ADD #&gt;&gt;&gt; 10 STORE_FAST 0 (global_variable) #&gt;&gt;&gt; 13 LOAD_CONST 0 (None) #&gt;&gt;&gt; 16 RETURN_VALUE One sees that it's very similar to `+` followed by `=`, as there *is* a `STORE_FAST` in there. But it's not quite the same, because `INPLACE_ADD` is called, not `BINARY_ADD`... So surely this would mutate and *then* assign! Let's try something scary: cannot_assign = ([],) def do_the_impossible(): global cannot_assign # Impossible to assign, can still mutate cannot_assign[0] += ["new"] dis.dis(do_the_impossible) #&gt;&gt;&gt; 6 0 LOAD_GLOBAL 0 (cannot_assign) #&gt;&gt;&gt; 3 LOAD_CONST 1 (0) #&gt;&gt;&gt; 6 DUP_TOP_TWO #&gt;&gt;&gt; 7 BINARY_SUBSCR #&gt;&gt;&gt; 8 LOAD_CONST 2 ('new') #&gt;&gt;&gt; 11 BUILD_LIST 1 #&gt;&gt;&gt; 14 INPLACE_ADD #&gt;&gt;&gt; 15 ROT_THREE #&gt;&gt;&gt; 16 STORE_SUBSCR #&gt;&gt;&gt; 17 LOAD_CONST 0 (None) #&gt;&gt;&gt; 20 RETURN_VALUE do_the_impossible() #&gt;&gt;&gt; Traceback (most recent call last): #&gt;&gt;&gt; File "", line 21, in &lt;module&gt; #&gt;&gt;&gt; File "", line 6, in do_the_impossible #&gt;&gt;&gt; TypeError: 'tuple' object does not support item assignment cannot_assign #&gt;&gt;&gt; (['new'],) Whaaat?! Well... * the bytecodes `LOAD_GLOBAL`, `LOAD_CONST`, `DUP_TOP_TWO`, `BINARY_SUBSCR`, `LOAD_CONST` all run fine. * `INPLACE_ADD` acts *directly on the list*. So that *works*. * `ROT_THREE` does boring stuff * `STORE_SUBSCR` does an assignment to an element. This will mean that we are assigning the list back to the place it already exists. *This* fails, but only *after* mutating. --- Why does it do this? Well, `INPLACE_ADD` is used for mutable things, which is good because it's faster and it's a nice-to-have. But some things don't allow mutation, so `a.__iadd__(b)` just returns `a + b`. The `a = b` is needed to *keep* this change.
Interesting, however, it seems to me that the following: [i for i in range(10) if i % 2 == 0] would be a little different (probably faster) than: even = lambda x: x % 2 == 0 filter(even, range(10)) `dis.dis` isn't super helpful here though.
That's true, but if they're going to get at the source regardless I'd rather close the gate to the garden than leave it wide open, they'll hop it either way.
I took a course at my university by started off just learning basic syntax on Code Academy. Also, think of little things you want to make like a budget or fitness calculator. I'm interested in computational linguistics so I made a little program that took suffixes off of words (like plural nouns) to get root forms. Of course people have done this before but it's good to learn first hand. And having friends who program too is a great motivation and collaboration in coding can be fun. 
This crashes Chrome on iOS, and Alien Blue :(
Why would you do either? Just mutate it. The caller *already* has the object; no need to give it to them again.
Replacing the hack is another kind of debt: time. Which one do you think the user / client / customer cares about? Time or theoretical problems in developing in the future?
I don't know whether there exists such a thing. But given the length of time Guido spent to create `asyncio`, it's a reasonable inference (?) to think that he could have written an HTTP library using `asyncio` for the stdlib with additional several weeks of work if he had wanted, isn't it?
I believe the intention of asyncio is to allow people to create the rest of the components and keep them out of core Python itself. That way the libraries built on asyncio are not burdened with having to wait for official core Python releases, and can increment and improve more quickly. I for one really like this approach. ;-)
hi massimo, i think it'd be better if you upload high quality videos to youtube or vimeo. 
I think the pandas library has a method for reading and writing excel files. Check it out. 
I'm assuming this is a port of the Node.js package? You might want to change the "tiny (~36kb)" qualification to use CLOC instead. One thing I didn't see in your examples is the auto-generated -h|--help output, which seems rather important...
A (very) quick test: &gt;~ python3 -m timeit 'odd = lambda x : bool(x % 2)' '[n for n in range(10) if not odd(n)]' &gt;100000 loops, best of 3: 3.96 usec per loop &gt;~ python3 -m timeit 'even = lambda x: x % 2 == 0' 'list(filter(even, range(10)))' &gt;100000 loops, best of 3: 3.01 usec per loop &gt;~ python3 -m timeit '[n for n in range(10) if n % 2 == 0]' &gt;1000000 loops, best of 3: 1.69 usec per loop &gt;~ python3 -m timeit '[n for n in range(10) if not n % 2]' &gt;1000000 loops, best of 3: 1.62 usec per loop I'm not sure if it's a fair test, filter return an iterator in python3, so I added list().
I hadn't heard of that one. This is more inspired by another NodeJS package, `optimist`. There's a lot left to add; automatically generated docs are one of them. But the whole point of this package is that it works with minimal, or ideally zero, configuration. Someone requiring a help string could simply just add a line `if argv.help: print __doc__` or something. That's not to say I wouldn't add it, but if you want fancy stuff, you're better off using one of the more sophisticated libraries.
Writing a library is one thing. Fixing all the bugs in it, and working out what the API should look like is another. Things in the stdlib can't evolve very fast, so I think it makes sense to do these things outside the stdlib, at least for now. Maybe they could migrate into the stdlib once they're more mature.
Bad timing. Just last week Armin Ronacher (main author of Flask) released [click](http://click.pocoo.org)
I would use either default arguments or function properties for things like that.
To be fair, their arguments aren't too great. Python 3 is a *way* better language. A lot of people who don't understand this write Python 2 code that's Python 3 compatible, and complain that it offers no real benefit. No shit. The libraries argument is also a mediocre one, as it's relatively rare to find decent libraries that are both unported and without a ported variant.
My own example that got me thinking about this is when I was trying to figure out a way of creating a scope in the middle of a function without defining it as an internal function. class TrueOnce(object): def __init__(self): self._value = True def __nonzero__(self): if self._value: self._value = False return True return False if __name__ == '__main__': t = TrueOnce() while t: print "Hello World" 
It's not that they didn't improve things, I just don't think they improved things *enough* to justify breaking compatibility.
as marky1991 pointed out, it appears these packages need the target workbook to be saved before anything can happen
Click looks awesome, but there seems to be different design goals between this and that. I don't think they're likely to inhabit the same program, but that doesn't mean one of them obviates the other. SimpleArgs doesn't make any kind of link between command-line arguments and the functions they're used in -- for better or for worse. Click doesn't do its own argument parsing, either. At the end of the day SimpleArgs is best for "quick and dirty" applications. Python newcomers, people who haven't learned any of the existing argument parsers, people who don't require anything fancy from their arguments, etc, could make good use of it. The overriding goal is to minimize cognitive load.
This seems cool but... At this point it practically seems like there have been more argument parsing libraries released in the past few years than there are actual programs that parse arguments.
Really though, you're not going to find a program that can interact with an unsaved document like that. The best you can do is use something like autohotkey to just save it and then interact with it normally. A better solution would to just modify the original code to save the files that it generates instead of just creating them and leaving them in limbo.
Then I'd just create a VBA function to do it, takes like 5 lines of VBA
Scipy implements [least-squares minimization](http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.leastsq.html#scipy.optimize.leastsq), and I think it shouldn't be too hard to write the error function to minimize so that it weighs the points according to their assumed accuracy.
The first time I gave it a go, I was intrigued. I used webbrowser to load a web page with about 3 lines of code. But the silly whitespace turned me off so badly that I dropped it for a few years... Next, I stumbled onto the Python Challenge, and tried it in my normal, "goto" language: Ada. Did it too, but it damn near cost me a week! Then I was reading about how easy some of the Python crowd found it to be, and I had to give it a try. That did it, I was hooked! Though I still hate the whitespace (It's a silly affectation, and screws up more than it fixes) but you've just gotta love a language that lets you do so much, so easily. 
You could create arrays with numpy for the general layout, then use PIL to turn them into images. Maybe pygame, too?
You seem to take it as the article attacking Python, but that's not the case at all. They aren't saying that late or early binding are bad, they're only showing how both can bite you in the ass if you don't pay attention. Some of the ones that seem obvious are still mentioned because they can be mistakes Python programmers might make, as per the point of the article, despite how obvious they may seem. They aren't trying to find solutions to all of these problems, despite mentioning possible workarounds. And they also don't make assumptions about what version of Python people use, so just because Python moved on doesn't mean that nobody would ever make an error in Python 2 again.
Ah, `True`. The main reason I decided to do this was due to the negativity in specific *comments*, not the article itself. But I agree that I confused the two.
Very hard to follow what the code is doing. Very weird OOP. So it appears to be like Python, but different. I notice in the random number generator code, there is a class RandomNumber, but what I don't get is, how do I create an instance of that class? I see randomNumber. Is randomNumber() an instance of RandomNumber? Also, where did newRandom come from? I just don't get it. When I look at tkinter code, it is very easy to follow what it's doing, but looking at the example WebBot code, it's just confusing to me. Maybe I'm missing something.
&gt; Hmm, I haven't encountered that sentiment anywhere else in the Python community. It's a pretty common idiom in the standard library. List methods that do this include sort, append, extend, insert, and remove. For sets, add, remove, and update. dict.update, too.
I was a GIS guy just getting into programming, After a few years fumbling with PHP, I found that many of the geospatial libraries both open source (GDAL, Mapserver, etc) and proprietary (ArcGIS) were adopting python as the de-facto scripting language. I dove in, started experimenting, discovered django and numpy and scipy and ... there was no turning back.
As a stylistic point, returning the original object lets you chain sequential method calls. Ruby does this, and it's not uncommon to see code like `stringlist.map!(&amp;:upcase).sort!.uniq!`. That transforms, sorts, and uniq-ifies a list, all in-place. Python's list comprehensions are a great alternative in some cases where you'd want to do this, but not always. For one example, if they were, we would probably just have a sort method on every object where it makes sense, instead of the separate `sorted()` built-in that enables a similar style.
For class methods I absolutely agree, since it's pretty obvious what's being operated on. File-level functions are much less obvious.
Python doesn't encourage this style. You'll see many cases in the standard library and on builtins where this is so; sparse few where it is not. I don't know where this rule is written, but it has been proclaimed many times, including (if I recall correctly) several occasions from Guido. Plus, Python is far more invested in duck-typing than Ruby. This leads to a function-oriented approach, rather than Ruby's method-oriented one. Personally, I dislike code like you've given because it expresses too many concepts. Splitting this on to several lines is a good thing.
indeed! Using list comprehensions like the one the original author presented it, it's just horrible style. Python already allows you to save so many lines with respect to other languages, but abusing it like that is just plain wrong.
always use the standard python.org, you will have to do more (like manually install package with setup.exe or install VS express for compiling), but it's worth for your future (assuming you're using Windows)
Or who needs to work with strings with undefined encodings, like say, UNIX/Linux filepaths.
Mistake 10 won't happen in either 2.6.5 or 2.7.6, I couldn't replicate (and didn't feel like tracking down further) [discussed over in /r/programming thread](http://www.reddit.com/r/programming/comments/251it6/top_10_mistakes_python_programmers_make_advanced/chcz428). The bug he mentions is from 2009. Mistake 6 is clearly [plagiarized from here without attribution](http://docs.python-guide.org/en/latest/writing/gotchas/#late-binding-closures). The first one is arguably a language wort (also mentioned in the previous one). The third one was a language wort, but as prum said won't happen when you use the modern `except syntax` (`except (ValueError, IndexError) as e`). Mistake 9 is hardly a common gotcha. Python3 made an improvement (clear up references to exceptions outside of their clause by secretly deleting it) and it comes up with an obscure error when you try using uncopied exceptions outside of their clause. Piss poor guide at best.
Not sure what your code has to do with "scope in the middle of a function without defining it as an internal function". Personally if I was implementing that I would write (Python 3): def true_once(): yield True yield False if __name__ == '__main__': for okay in true_once(): if not okay: break print ("Hello World") 
OK, so we start with something really simple: def false(false): return false(false) Yeah. You with me? It's just a false function that calls itself recursively, yah. Kind'a pointless, so let's replace it. OK, so we have a function, and in it is a class. Now this function gives a class which is always `False`, right, so we call it `false` and the class can be `False`. But `False` is taken, so let's use just `false`. Heck, inside its `__bool__`, we can even set `false = False` *just to make sure*... @false def false(false=False): class false: def __bool__(self): if False: nonlocal false try: return not not false finally: false = False return false() [bool(false) for _ in range(10)] #&gt;&gt;&gt; [True, False, False, False, False, False, False, False, False, False] _________ o o | | _____ | AAaahh! | / \ /_ nooo...| /_______\ \_______| 
I think this is insane. Insane but great.
The only thing that prevents me from starting fresh with Python3 is the unclear mysql situation. And no, switching to Postgresql is not an option here.
You know all of that formatting that C/C++ abhor enforcing? Yeah, Python fucking forces you to format your code so it's readable. C++: for(int i=0;i&lt;array.length();i++){std::cout&lt;&lt;array[i]&lt;&lt;std::endl;} Python: for i in array: print(i) You know how you always wanted to run a function across a list if a given condition was true, and return the result as a list? In Python, you can: modified_list = [do_something_with(x) for x in original_list if x &gt; 4] You know how you always wanted to use functions as objects? In Python you can! def get_inner_function(enclosed_variable): def inner_function(): enclosed_variable++ return enclosed_variable return inner_function You know how you wanted to give the sort() function an anonymous function to compare elements? In Python you can! lizt.sort(lambda x, y: return x &lt; y) You know how you wanted to create a function that saved its state each time it ran AND you wanted it to be thread safe (eg: no global or static variables)? In Python, you can! def get_inner_function(enclosed_variable): def inner_function(): enclosed_variable++ yield enclosed_variable return inner_function You know how you wanted to automatically create getters and setters for each variable? In Python, you can! class Thing(object): def __setitem__(self, key, item): if key == something: self.data[key] = item # The normal behavior else: do_something_else(key, item) def __getitem__(self, key): if key == another_thing: return do_one_thing() else: return self.data[key] # The normal behavior You know how you wanted to run a function each time a variable was accessed or modified, without having to force the user to run a function just to have that function `return this-&gt;thing;` or `this-&gt;thing = other_thing`? In Python, you can: class Foo(object): def get_thing(self): return self.thing def set_thing(self, thing): self.thing = thing thing = property(self.get_thing, self.set_thing) foo = Foo() foo.thing = a_different_thing # Runs foo.set_thing with a_different_thing as the argument print(foo.thing) # Runs foo.get_thing() You know how you wanted to easily print out an objects internal state? With Python, you can: print(dir(thing)) You know how class inheritance meant that you had to either use template metaprogramming or wrap objects of one framework (eg: Qt) around objects of another framework (eg: Boost) so you could properly use object polymorphism? With Python, you can: # Note: object is a built-in class that all classes inherit from, and # it does _not_ have a walk() method class Dog(object): def walk(self): self.wag_tail() def wag_tail(self): pass # Theoretically do something else class Cat(object): def walk(self): self.poop_on_your_bed() def poop_on_your_bed(self): pass # Theoretically do something else class DeadParrot(object): def is_nailed_to_its_perch(self): return True def walk_your_pet(pet): # This doesn't depend on an object hierarchy, only that pet has # a member named walk that is a "callable" object (read: a function) try: pet.walk() except AttributeError as e: print("{0} didn't have a callable walk attribute".format(self)) raise e bow_wow = Dog() meow_meow = Cat() pining_for_the_fjords = DeadParrot() walk_your_pet(bow_wow) walk_your_pet(meow_meow) walk_your_pet(pining_for_the_fjords) # Throws an exception Did you ever want to fix a private method of a parent class? In Python, you can: class Thing(object): def get_random_seed(self): self.mess_with_some_internal_state() return 4 # Chosen by fair dice roll; guaranteed to be random class OtherThing(Thing): def get_random_seed(self): super(OtherThing, self).get_random_seed() return rand() Did you ever wish there was an easy way to specify regular expression in your code? In Python, you can: import re match = re.match(r'^(.*) cheese shop', shop_name) match.group(1) # Gets the name of the cheese shop Did you ever wish you could tell the ~~compiler~~ interpreter to automatically clean up resources properly when you were done using them? With Python, you can: with file.open('huge_file.dat') as huge_file: huge_file.do_stuff() # This might throw an exception, but we want to close huge_file either way # huge_file is now closed (automatically), no matter what huge_file.do_stuff() did Did you ever want to keep your documentation within your class, and even have it accessible at run time? Iin Python, you can: class ShesGotLarge(object): """ ...tracts of land """ def show_documentation(self): print('My documentation is: {0}'.format(self.__doc__)) Did you ever want to import two functions with the same name, but you didn't want to always refer to them with their namespaces (if they even had separate namespaces)? In Python, you can: # This example is kind of dumb import i18n.translate as _ import i18n.translate_lazy as __ print(_("Yay!")) print(__("Hooray!")) Did you ever want to inject code into another function without rewriting the entire function? In Python, you can: from django.contrib.auth.decorators import login_required @login_required def homepage(request): """ This Django view (an unfortunately poorly named component - it's actually the controller of an MVC system) now required the user to be logged in, without us having to explicitly check that ourselves """ return just_the_normal_response Did you ever want your code to take some compiled code, decompile it, and use that to autonomously craft SQL to run against a databse? In Python, you can: Uh, I don't actually have an example of this, but PonyORM does exactly this: https://stackoverflow.com/a/16118756
You actually nest classes within each other. Every nested class becomes an independent controller on the page that can be refreshed independently of the others via AJAX. You don't *have* to nest classes - it's just doing that makes this connection happen automatically vs defining the sections all at one level then manually nesting them to make the same structure.
you've been downvoted but this is actually a good argument, the right solution would be to refactor all but if you can't in order to maintain backwards compatibility turning an attribute into a @property method is the way to go.
WebBot does some magic, but in this case the magic isn't that deep (and is what most web frameworks do). You define the class but the instance of the class is made for you on each request. In WebBot's case it makes this instances available as the same as the classname with the first letter lowercase - so that you can easily interact with the different controllers. AKA randomNumber is just the instance of the class RandomNumber. newRandom here should be less confusing - it's directly what is defined in the UI xml as the button right here: &lt;button id="newRandom" class="MainAction" text="Click to generate a new random number" /&gt; which is what ui exposes. 
Webbot was a really big project for me and something I really believed in. I thought, and still do to some extent think it made it way faster to build complex websites - however the project is somewhat huge and I have not been able to invest the time necessary for it to reach it's full potential. I hope to revisit it soon - and would double my efforts if I was able to get at least one other person to devote time to developing it alongside me. I used it to develop a social to-do list that I use everyday: http://www.honeydo.es/. The truth is I made a mistake making my first OpenSource project so large, there's a lot of learning I still had to do about what makes a good pythonic OpenSource project - and the amount of that that is missing over such a large code base shows. After WebBot failed to pick up steam I refocused my efforts on much smaller projects and have had significantly more success there: https://github.com/timothycrosley/isort https://github.com/timothycrosley/frosted https://github.com/timothycrosley/instantly WebBot needs a massive code cleanup, a significant amount of documentation, and some modernization to incorporate good ideas like single-source-of-truth that client-side frameworks such as Angular have since presented.
I love that map, is there a higher resolution of it? 
just pycharm it, babe. What you need is damn good autocompletion, not cheatsheet.
Does anyone think there is better shared-hosting than webfaction ? I just stopped searching when i found them.
Some things are obviously missing in C++, because its static typed and does not have reflection(yet), however, most of the things you listed are just as easy in c++ -- perhaps a bit more verbose. *C++*: for (const auto&amp; e : v) std::cout &lt;&lt; e &lt;&lt; std::endl; Use clang-format and never look back :) *Python*: for i in array: print(i) ----- *C++*: std::vector&lt;T&gt; modified; std::copy_if(original.begin(), original.end(), std::back_inserter(modified), [](const T&amp; a) { return a &gt; 4;}); std::transform(modified.begin(), modified.end(), modified.begin(), do_something_with_it()); *Python*: modified_list = [do_something_with(x) for x in original_list if x &gt; 4] --- *C++*: std::sort(v.begin, v.end(), [](int a, int b) {return a &lt; b;}); *Python*: sort(lambda x, y: return x &lt; y) --- *C++*: int inner_function() { thread_local x = 0; return x++; } or auto inner_function = [enclosed_variable]() mutable {return enclosed_variable++;}; *Python*: def get_inner_function(enclosed_variable): def inner_function(): enclosed_variable++ return enclosed_variable return inner_function --- *C++*: std::regex regex("^(.*) cheese shop") std::smatch base_match; std::regex_match(shop_name, base_match, regex) *Python*: import re match = re.match(r'^(.*) cheese shop', shop_name) match.group(1) # Gets the name of the cheese shop --- *C++*: RAII, RAII, RAII *Python*: with file.open('huge_file.dat') as huge_file: huge_file.do_stuff() # This might throw an exception, but we want to close huge_file either way # huge_file is now closed (automatically), no matter what huge_file.do_stuff() did
hope your are talking about VPS. just check at http://lowendbox.com/ , There you will find some good offers. I'm using http://www.hetzner.de/en/ almost for about 5 years at my office.
&gt;Python 3 is a huge improvement and anyone that says otherwise is just a whiner that doesn't want to port their code. It's not my code I'm primarily concerned with - it's the 23 libraries in my requirements.txt that are going to need porting.
Its a JS plugin called "jquery-masonry", works really nice and very easy to setup.
&gt; The libraries argument is also a mediocre one, as it's relatively rare to find decent libraries that are both unported and without a ported variant. I tried caniusepython3.com on my requirements.txt files and about 20% were still unported. A few of them aren't ones I care a lot about, but there are still a fair few (e.g. mechanize, twisted) which are both good, I don't want to drop and don't look to be ported (or not ported and tested). I just tried on another project and 30% are unported.
Curious, have you thought about trying out Jython? Anyways, here's a quick [tutorial](http://learnxinyminutes.com/docs/python/). There are some books available [here](http://www.it-ebooks.info) using title search at top right. EDIT: There's Django web framework, SQLAlchemy for ORM.
isn't books a little bit too much? as I already have programming experience. All I need a little bit of introduction for libraries and semantics for python.I am also looking for something I can get my hands dirty, see how different architectures are implemented through python.
Now aren't we a little impatient. ;-) I think you'll eventually have to look at API docs anyways. The official docs have a good overview in my opinion.
I can heartily recommend [CodeAcademy's](http://www.codecademy.com/tracks/python) Python track. You can breeze through the exercises in a few days and they cover all the basic stuff in the language. It's a nice interface to do the exercises in as well. I started with [Learn Python the Hard Way](http://learnpythonthehardway.org/book/) which is also a superb learning resource in my opinion but it might not be as convenient as CodeAcademy. Both are well worth the time. Aside from that, [Flask](http://flask.pocoo.org/) is a nice web framework to start out with. Their IRC channel is friendly and the docs are good. Might be too minimal but it's easy to get into and a pleasure to work with. 
as someone who does python scripting on a really regular base, it get's faster. There is even an image somewhere that depicts how many time you can spend on automating a task(http://xkcd.com/1205/). Even though it is biased, made by 1 person, and generaly a humour-based site, it is quite interesting :D
That's not a cheatsheet, that's a crutch for people who use an IDE without decent autocomplete. EDIT: what I mean to say is that this doesn't give you anything that a good IDE wouldn't give you also (i.e., this is not a useful cheatsheet).
An IDE without autocomplete is not an IDE. 
I wanted to read about the difference between range() and xrange(). Disappointed :(
Check "Add Python to PATH" in the installer, it's off by default.
XKCD is fantastic for things like that, and I regret nothing about spending that long doing it :D
first of all, i said *decent* autocomplete. Secondly, I don't think autocomplete is the one defining feature it takes to distinguish between a simple editor and a full-blown IDE.
Autocomplete is a crutch.
no concurrent.futures station in the concurrency section :(
That is awesome, without going too far OT, any resource you can point me to on that? ninja - I'll look also with what you've got. If you're inclined, otherwise no biggie. :) derp edit - I'm looking at the source code and I think I might have it. I'm still waking up. 
I think what distinguishes an IDE is that it has an interpreter/compiler, debugger, and file management all integrated together. Early IDEs didn't have autocompletion and it is hardly the most important feature. 
Thanks! Looks like Part 2 will be a breeze been developing enterprise web apps with java for more a year already. this will be easy. any blog posts about enterprise architecture with regards to python? Looking for Enterprise Java stuff in the python environment. 
Hey Thank you iblag , You gave me a fucking good sum up to python, and it's gotten me more excited then ever. I mean I never heard of these facilities... Thanks to blazbr and pkfiyahhh too and oh btw pkfiyahh I do possess the book you mentioned :) , but you know that being a programmer reading books is far lesser experience than actually programming something.But mi amigo, thanks for your help :)
and iBlag ... I actually copied that into a text file :) 
I knew metaclasses was the end of the line. ( and that's why i still haven't yet learnt them yet ).
The string string formatting is nice. What shidarin is commenting about is the shittiness of Python's number (float) formatting. 
You might want to take look on *aio-libs*: https://github.com/aio-libs Edit: **aiopg** ( asyncio connector to PostgreSQL) is very interesting, it allows you to query database using SQLAchemy's SQL dialect: join = sa.join(emails, users, users.c.id == emails.c.user_id) query = (sa.select([users.c.name]) .select_from(join) .where(emails.c.private == 0) .group_by(users.c.name) .having(sa.func.count(emails.c.private) &gt; 0)) print("Users with public emails:") ret = yield from conn.execute(query) https://github.com/aio-libs/aiopg/blob/0b7b76fbf126d0d0806fe6b22a76fe38158cbc67/examples/sa.py#L96 It is not ORM, but fancy way to write SQL queries.
I thought number objects were immutable in python and whenever the value changes you are actually creating a new variable with the same name? If this is the case it follows that decimal length can be determined whenever you assign a new value. Apologies is this is off base, I'm fairly new to Python.
Ok so I did that and it still doesn't give me the right response. How would I manually add it to the path? What folder in the python directory would I need to add? EDIT: False alarm, I just had to run cmd in admin mode. Thanks for the help.
This is awesome! Thanks!
Looks perfectly fine to me: print("Hello %10.4f" % (1/20000.0)) print("Hello %10.4e" % (1/20000.0)) print("Hello {:10.4f}".format(1/20000.0)) print("Hello {:10.4e}".format(1/20000.0)) Both with and without using the scientific notation. And there are exactly two ways of doing this. At least as far as I can see. Am I missing something?
Just google how you set the PATH variabe under Windows. Its in System/Advanced System Settings/Environment Variables. Add the directory to the PATH-variable where python.exe is. This usually is C:\Program Files (x86)\Pythonxx\ or C:\Program Files\Pythonxx (if using 64 bit Python). Just search for it with the explorer before adding it to the PATH variable. And remember to restart the command line after setting the PATH variable. You can check if its set by using "env" in the command line. Edit: Added a hint.
Not sure what you mean by solutions... you might not find pre-existing code for what you are trying to do. That being said, Python + Numpy + Scipy should be more than enough for what you are looking to do. Just install [Anaconda](https://store.continuum.io/cshop/anaconda/) and start using the Spyder IDE to write your program. If you know the math and what needs to be done, it really shouldn't be too difficult to implement. If you are familiar with Matlab, Spyder has some nice features like allowing you to split your scripts into cells and a variable explorer (only supports a subset of datatypes). 
hey, when at first you don't program fast, you probably learned something from it :D
Oh yeah I probably should have restarted my pc after the install. I never think to do that...
that's because it shouldn't be necessary
You only need to restart the command prompt.
Thanks for the share!
Congrats on another successful release!
FYI, I would intend to run the web interface as a service/daemon (always on)
That's a valid reason if the library is still actively maintained. I find most actively maintained libraries are 3 compatible, though. If it isn't maintained, ditch it and find another way.
xrange is heresy, use Python 3.
It works! perfect toy for a friday! Thanks!
Hah, thanks man, nice to see a positive response!
Nice, should zip() be added to "Set &amp; Mapping"; I can never remember exactly how it works.
I like to consider Pyramid to be between Flask and Django although some might say it's closer to Flask. Just another option.
I've read that the soap support is sub par, which is important if you need to interface with other services. But don't take my word for it. Look it up. I haven't investigated it myself.
Thanks for letting me know. I turned debug off and will check out the error. UPDATE: This is because gmail wants you to pay now if you try and use their service. An FYI for anyone planning on using them for SMTP. Switched to sendgrid. UPDATE UPDATE: email submission is back up and running for those interested. 
Once you learn python and are starting to get stumped by gotchas: http://pyvideo.org/video/2623/python-epiphanies-1 &gt;This tutorial is for developers who've been using Python for a while and would consider themselves at an intermediate level, but are looking for a deeper understanding of the language. It focuses on how Python differs from other languages in subtle but important ways that are often confusing, and it demystifies a number of language features that are sometimes misunderstood.
But then you'd have people confused why 1000000000001.0 prints like 1000000000000.0 (as I guess it would). Decimals exist as well, and work better for this sort of things.
If you're on Python 3 already, please consider [donating to py3k in PyPy](http://pypy.org/py3donate.html), they've reached almost half of their funding goal already.
Yes. We had equipment problem. We schedule the event on a Sunday and that was a bad idea.
We'll do better next time.
Thanks for this. I have been following aiohttp and [aioweb](https://bitbucket.org/jagguli/aioweb) but this is a nice portal to check the progress on other projects as well. 
It's worth noting that we're dangerous close to releasing the 3.2 version of this, and some initial work has already started on 3.3. Hopefully we're over-delivering on the money we've received!
Good GUI but I can't barely hear anything (superlow volumen)
 File "test.py", line 1, in &lt;module&gt; import Markov File "/home/kim/PyMarkovTextGenerator/Markov.py", line 29 if val[0] == value ^ SyntaxError: invalid syntax Anyways, this is pretty cool, the generated texts are pretty convincing compared to some other Markov-based generators I've seen. The generated text doesn't look very random though (big chunks appear to be copied from the source text), but this is probably due to the small size of the demo text. If you think generated texts are fun, you should look into grammar-based generators too. I've tried creating convincing texts with Markov chains, but have settled with grammars instead, as the randomness of Markov generators sometimes gives away that the text is computer generated. Here are a couple of grammar-based generators I've made: http://git-man-page-generator.lokaltog.net/ http://tumblr-argument-generator.lokaltog.net/ You could also check out the Dada Engine, which is an ancient grammar-based text generator written in C.
they used pypy embedding API. But it was not public (and used some hacks) until this release
That sounds great! I'm using PyPy 3 2.1 Beta 1 myself and it really is an amazing piece of software, so much faster than CPython. I just thought that - as Python 3 gets a lot of love in this subreddit - it might be a chance to get two or three more people to support your amazing project. ;)
&gt; If it isn't maintained, ditch it and find another way. I'm usually opposed to reinventing a wheel that works, even if it isn't being actively maintained.
~~Decimals still convert to scientific notation and still suffer from rounding errors- in the example above it actually occurs at the exact same amount of digits.~~ &gt;&gt;&gt; 10000000000000001.0 1e+16 &gt;&gt;&gt; Decimal(10000000000000001.0) Decimal('10000000000000000') Edit: **I am happy to be wrong! A whole new world of precision**
Thanks!
Better use Tornado!!! http://www.tornadoweb.org/en/stable/ Easy to start... FYI... Tornado is a Python web framework and asynchronous networking library, originally developed at FriendFeed. By using non-blocking network I/O, Tornado can scale to tens of thousands of open connections, making it ideal for long polling, WebSockets, and other applications that require a long-lived connection to each user.
Whoa, I had never heard of Anaconda before. Thank you.
I'll check out Scipy, thank you.
not as good, no - but imho still worth it.
Being able to gittip the pypy project would be great ! Why isn't it possible ?
Thanks for the comments everyone. I was hoping to work on it more before asking for feedback but I'd love to hear everyone's thoughts and suggestions. Be it product or UI design, I'm open for anything. 
/u/sushibowl explained it correctly- when working with human readable datasets that are being fed into programs that don't understand exponential notation I need `1.0` to string convert to `1.0` (not `1`) and `0.00000000001` to string convert to `0.00000000001`, not `1e-11`. Because no string formatting method supports variable decimal places (instead you would have to force `1.0` to be `1.000000` or `1` etc) and because Decimal has the same rounding problems as normal python numbers when exponential notation begins to come into play, and still will print e notation (although not as quickly as normal floats)- you end up having to make some sort of helper function. Here's one I made recently: def _de_exponent(notation): """Translates scientific notation into float strings""" notation = str(notation) if 'e' not in notation: return notation notation = notation.split('e') # Grab the exponent value digits = int(notation[-1]) # Grab the value we'll be adding 0s to value = notation[0] if value.startswith('-'): negative = '-' value = value[1:] else: negative = '' value = value.replace('.', '') if digits &lt; 0: new_value = negative + '0.0' + '0' * (abs(digits) - 2) + value else: zeros = len(value) new_value = negative + value + '0' * (abs(digits) - zeros) + '0.0' return new_value I don't like it all that much. It's inelegant and hard to follow. At the time I thought up two approaches- this approach and a similar one that simply returned how many decimal places I should specify in another string formatting. The problem with the second is that you end up with constructing a string around the returned digit count, then you actually replace the numbers. This method just lets you do `'number 1 is {number1}'.format(number1=_de_exponent(float_number))`
&gt;I seriously doubt you have 23 completely one-off, unique libraries that are all only 2 compatible. Across 3 projects... I think I might actually have more. Some are trivial, but a few are very complex and not easily replaceable (twisted, mechanize to name a couple). &gt;What are you going to do when 2 is EOL'd? You're just putting off the inevitable. Worry about that when the time comes. Maybe instead of 23 it will be 4 and those 4 I will be able to do without. 
So stoked to check this out. Thank You (besides words I also give money).
That's fair, especially since both Twisted and Mechanize are still actively developed and Python 3 versions are in the works. I'm not suggesting that you should drop 2 and migrate to 3 this afternoon, just that unless you have legit, active dependencies that require 2 (which you do), you should be targeting 3.
pretty much what /u/amstan is saying: if you convert a float to a decimal, obviously you will take the float's rounding errors with you into the decimal representation. You should have no rounding errors if you work purely with decimals and don't bother with floats at all.
For something relatively simple, as this looks to be, I'd recommend Flask. If you've got all the code you need written already, it should just be a case of defining the paths your users can access, and then hooking those paths in to the correct functions. On top of that, Flask has a number of extensions available. You probably won't need them in this case, but it should be easy to add them in as and when you need them. Alternatively there's Bottle and WebPy which, iirc, are very similar, although I haven't used them.
DDDDDDDDDDDDDDDDDJANGO! It sounds like you'd quite enjoy it.
Web frameworks and databases. If you are using those, get the paid version. If you are using, say, pygames get the free version.
I lol'd when I saw the Ad part. Seriously, for a second I thought "Whoa..Ad? Never heard of that before...oh."
Good points! Admittedly, C++ has improved quite a bit since I learned it. I like the fact that they're trying to be more relevant. I didn't know about std::regex. That sounds pretty awesome, I'll have to check that out. And for the last one, I can't believe I forgot about RAII! You are correct.
You can just stick dependencies (usually the package directory, and the .egg-info directory) into a directory and then add it to either PYTHONPATH or sys.path. This is a rather crude method but is used on a project I work on and it gets the job done.
I don't think it's possible to gittip projects right now, only individuals? Several PyPy contributors are on gittip if you want to gittip them though!
This is indeed an interesting problem. I have been trying to figure out something but could not come up with anything. The only thing I found is fixing the decimal places to some value. The other thing that I have in my mind is the question about precision, and if `Decimal` would not be a better choice as others have mentioned. I am guessing that you won't lose precision after only 4 decimal places, but that seems to be as far as Python want's to go if you don't specify a value. And, I don't know your application requirements and maybe there's a good reason you need floats. Honestly, I have to admit defeat and agree with you ;)
It is possible. Examples: * gittip itself ! https://www.gittip.com/Gittip/ * readthedocs https://www.gittip.com/readthedocs/ etc... I'd rather tip the project, since they'll know how to allocate the money better than I do.
I think you should just copy all the dependencies to a local folder an then use pip to install them. create a requirements.txt containing -e ./deps/path-to-dependency-1 -e ./deps/path-to-dependency-2 -e ./deps/path-to-dependency-3 -e ./deps/path-to-dependency-4 ans them in your installation/deploy script run pip install --no-dependencies -r requirements.txt 
The article doesn't do that though...
Here is the one I use: http://kapeli.com/dash It has awesome bindings for every text editor out there.
I thought all 3 of them had package managers. (since they added PIP to py3)
If a static method in Java doesn't access static members, it is equivalent to a `@staticmethod` in Python. If it does, it is equivalent to a `@classmethod` in Python. Python distinguishes between static and class methods because functions that are part of a class do not carry a reference to their instance object (conventionally called `self`) or their class object (conventionally called `cls`). Static methods don't need to access class variables, so they're not implicitly passed any instance or class object when called, and their signature doesn't have `cls` as first argument. Class methods access class variables, so they need to be (implicitly) passed a reference to their class object, and so their signature has `cls` as first argument. In contrast, non-static Java methods have `this` (often used implicitly), and static Java methods have static members in their scope, so there is no need for the class method / static method distinction.
&gt; but it's worth for your future What do you mean?
Checkout Docker containers. They are a great way to deploy self-contained applications. The only requirement is that the recipient has to be able to run the Docker daemon.
"I dreamed a dream of a new PyPy, // when two was given up as legacy. // I dreamed that people would now try, // to switch to new, to better systems."
great explanation! Much appreciated!
Yes very true, it would probably be better to follow everything preceding but ignore that page. I can attest though that this website got me from not knowing anything about writing GUIs to having a full working simple application for monitoring high voltage equipment in about three hours. Extremely helpful while brief.
That is only for the first 2 minutes because only talk speakers had microphones. Session chairs did not. When talks start the volume is good.
Under "Set Types", `remove()` is incorrectly shown as taking no arguments. I think I'll stick with the official docs for now.
That "Date Arab Women!" advertisement in the lower left-hand corner of my programming cheat sheet...
that's correct (kind of forgot the original title mentioned 3.x)
I'm going to be going through the code this weekend and seeing what I'd need to do to use Decimals. The attributes are already protected by setters, so I think my biggest headache might actually be adjusting the test suite. I'm pretty god damn excited.
Well technically an RHS slice can return whatever the hell it wants, it's just a call to `__getitem__` with a slice parameter. On list it returns a brand new list, but it could return a slice (sharing the underlying data with the original, I believe numpy arrays do that)
For those of us on Linux you can use [Zeal](http://zealdocs.org/). Doesn't have the number of plugins as Dash though.
On Windows I definitely recommend using Anaconda/miniconda. On Linux, I would just use pip. If you are a beginner programmer, I would consider Anaconda on Linux too. Later on when you get more experience, I would look into making isolated virtual environments using Python 3.4's pyvenv-3.4 or with Python &lt;= 3.3, use python-virtualenv.
https://praw.readthedocs.org/en/latest/pages/code_overview.html#praw.objects.Redditor That took all of 30 seconds. :) when all else fails, python is awesome at inspecting things on the fly. Fire up an interpreter and poke at the object: &gt;&gt;&gt; import praw &gt;&gt;&gt; r = praw.Reddit(user_agent='asdf') &gt;&gt;&gt; u = r.get_redditor('metalhedd') &gt;&gt;&gt; dir(u) ['__class__', '__cmp__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattr__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__unicode__', '__weakref__', '_get_json_dict', '_info_url', '_methods', '_mod_subs', '_populate', '_underscore_names', '_url', 'comment_karma', 'created', 'created_utc', 'friend', 'from_api_response', 'fullname', 'get_comments', 'get_disliked', 'get_liked', 'get_overview', 'get_submitted', 'has_fetched', 'has_verified_email', 'id', 'is_friend', 'is_gold', 'is_mod', 'json_dict', 'link_karma', 'mark_as_read', 'name', 'reddit_session', 'refresh', 'send_message', 'unfriend'] &gt;&gt;&gt; u.__dict__ {'json_dict': None, 'name': 'metalhedd', 'is_friend': False, 'reddit_session': &lt;praw.Reddit object at 0x7f609f2cc8d0&gt;, 'created': 1286545099.0, 'created_utc': 1286541499.0, 'has_fetched': True, 'link_karma': 294, '_url': 'http://www.reddit.com/user/metalhedd/', 'comment_karma': 191, '_mod_subs': None, 'is_gold': False, 'is_mod': False, '_info_url': 'http://www.reddit.com/user/metalhedd/about/', 'has_verified_email': True, 'id': u'4evhs', '_underscore_names': None} 
thanks! I'm currently working on an automatic scheduling program which is helping me solidify my knowledge about dictionaries, arrays, etc.
Does either the free or paid version support Flask? 
Here's a patch to add Schema.org Video support (adds RDFa to template) for pyvideo.org: https://github.com/willkg/richard/pull/213 For the other useful resources listed here, within http://schema.org/CreativeWork there are "More specific Types".
Thanks for your reply. I can definitely see how for a project like that (especially closed source, distributed and multiple architectures) you would prefer something like Java.
Herb Sutter has a great talk on how important contiguous memory is for true performance. Here's the link: http://channel9.msdn.com/Events/Build/2014/2-661 Important stuff starts around 30 minutes tldr: Contiguous data, when forward (or backward) iterating basically gives you infinite L2 cache due to pre-fetching. 
This is a great map. I would love to have it as a poster.
Well, interpreted, but be careful how you say it because a lot of people don't realize it's compiled to bytecode then interpreted by a VM. Java is interpreted then, but yes, statically typed. A professor of mine once told the class ruby&gt;=1.9 is faster than python because it has a VM and Python is interpreted. Nope. Still pypy has JIT. Just because it's dynamically typed doesn't mean it can't benefit from code path optimization at runtime. It looks like they do quite a few tricks to improve performance, which may improve or reduce performance depending on your code. Still, bytecode optimization with a dynamically typed language. Also, you mention using cython, swig or f2py for interfacing with compiled code. Any reason why you didn't include ctypes?
That's the thing—whenever someone says that most libraries support Python 3, they seem to forget about all the small, obscure, unpopular, or unmaintained packages (including internal, never-released packages) that *don't* support Python 3. For example, one place I used to work still uses Django 1.3. Why? Because I left before 1.5 was released, and never got around to upgrading to 1.4. Why? Because the project relies on a big Python package that's barely been updated or maintained in a few years; a big Python package that was written by another web dev company years ago, and is an internal project they use to support their clients; ZSI, a big SOAP library that's barely been touched since 2006; and a bunch of other projects that haven't been updated in over 5 years. (Unfortunately, such abandoned packages are all too common in the Python world.) Some of these packages didn't even play nicely with Django 1.4 (because they relied on internal, undocumented parts of Django)—let alone working with *Python 3*. Upgrading all of them to work with Python 3 would've been a massive effort for one person. Integrating newer projects with the same functionality that work with Python 3, or re-writing the code to replace these old packages, would've been about as much work. Would it be worth it? I don't know—Python 3 is nice, but it's not *better enough*, in my opinion, to justify the massive porting effort required for anything but the newest or most trivial projects.
There's also ZSI and suds. Both suck, but suds might suck a little less than other "solutions".
This is a pretty good overview: https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods To answer your question, I think the equivalent in java would be a static factory method that makes a new instance of a class. I can't really think of any reason you would use @classmethod besides factory methods for new objects. I see pretty frequently that people define a class method and never touch `cls` or do weird things like name it `self` and then never touch it anyway... Also, another thing i see often is if you're doing something like: class X(object): logger = logging.getLogger(__name__) @classmethod def x(cls): cls.logger.debug('whatever') You actually don't want the overridden version, so that should be static and the logger should be accessed directly through X: class X(object): logger = logging.getLogger(__name__) @staticmethod def x(): X.logger.debug('whatever') 
The paid version provides support for most/all of the major web frameworks.
I have been coding in python for 3-4 years now and can hardly remember being tripped up by any of these. One annoying issue that I have been caught by, has been the accidental trailing comma. It can effectively change the current line into a tuple of one element. Especially annoying if it occurs on a line assigning an iterable as you end up with a value that is an still an iterable! But that is why we have unit tests and code reviews....
A python method can be classified in these three types: * Instance method: bounded to an instance of a class. * Class method: bounded to an instance of class *type* representing the actual class. * Static method: bounded to no instance at all. Java has only the static and instance methods. 
http://pypy.readthedocs.org/en/latest/faq.html#couldn-t-the-jit-dump-and-reload-already-compiled-machine-code
And to actually answer your question: In Python 2, `xrange` returns a generator, while `range` returns a list. That means that `xrange` generates the numbers on-the-fly as you ask for them (in a for loop or whatever), while `range` generates all of them immediately. That means `xrange` is more memory-efficient, but you can't iterate through it more than once. In Python 3, `range` returns a generator and `xrange` doesn't exist. To get the old behavior, you need to use `list(range(whatever))`.
this is really a bad idea, you should always try less hardcore approaches first like logging off and logging back on for example (so the environment updates)
"it boils down to Python being a dynamically typed, interpreted language, where values are stored not in dense buffers but in scattered objects" and yet pypy is fast. 
this is one of the reason python lists are fast.
The best thing about an IDE like PyCharm is it requires an 8-way processor with minimum 16Gb of ram to run half-way decent, which means you have a legitimate work excuse to convince the CFO to upgrade your hardware. Then you just run Vim anyway and have all the same functionality ;) Back in the day (read 1980's-&gt;early 90's), there used be be a huge difference. A generic text editor would be good at editing text - making it great for code - but IDE's came and added syntax highlighting, debugging, SCM integration, snippets, various degrees of introspection, inline documentation, and so on making it _especially better_ for code. Since about then, your generic text editors have done all that too; so its simply down to preferences now (your own or your employers). IDE advocates will try to argue that a generic text editor needs to be configured to do this while an IDE does it out of the box, to which I say :!python % [Vim will run the current buffer through python (or any other app, for that matter) without any configuration, all the IDE's need to have the Python environment configured first before their run equivalent will work at all). Since both require after-install config of various things in order to work better or at all, the point is moot.] 
yes, IDLE is pretty good though idk if it has wraparound
aaaannnnd here we go again....
anything a computer can do ?
But you've been doing PHP for a while ?
This computes 42 factorial, recursively, using only lambdas: (lambda x, k: x if x &lt; 2 else x*k(x-1, k))(42, (lambda x, k: x if x &lt; 2 else x*k(x-1, k))) You can replace the 42 with any number you like: factorial = lambda n: (lambda x, k: x if x &lt; 2 else x*k(x-1, k))(n, (lambda x, k: x if x &lt; 2 else x*k(x-1, k))) But that's so much ugly code, and so much duplication! So to be good programmers, let's factor out a pattern here. I honestly don't know what to call it, so I'll call it bananas: bananas = lambda k: lambda x: k(x, k) We can redefine factorial in terms of bananas, and as you can see, it is much clearer and easier to maintain: factorial = bananas(lambda x, k: x if x &lt; 2 else x*k(x-1, k))
Aside from wasting an obscene amount of time restarting my laptop, how would it be a bad idea? Would it effect the install in any way?
On that note, this *is* something that C# or VB.Net can do (on Windows, at least) by using [ngen](http://msdn.microsoft.com/en-us/library/6t9t5wcf%28v=vs.110%29.aspx). Of course that only applies to JITed data on startup, it can't look further into the execution of your program.
Haha no. I really can't think of anything I miss from .Net development. 
Here is an example of having both an app indicator and a regular tray icon (which works everywhere else) in a shared file. It is fairly simple and is gpl3 too: https://github.com/pithos/pithos/blob/8b72f5c6ed1b2818a69800dec0d02a19e815009b/pithos/plugins/notification_icon.py
You absolutely should use a good IDE. Produce better code, quicker and easier. Fuck the haters. 
I think you meant to type "*faster*".
I strongly recommend the python.org distribution because things like conda introduce weird side results when installing something not packaged by it. http://software-carpentry.org/blog/2014/04/mr-biczo-was-right.html
Couldn't CPython change its allocation strategy to reduce this fragmentation?
Quickly said: too much is decided at runtime for that to happen.
Not sure the actual answer about get_comments I am not the best at praw but I started a project about a month ago which I never ended up finishing it because I got busy with uni but if you look at the code, it might help you I was doing a similar thing https://www.dropbox.com/s/5q100thrx64hquf/Reddit_Bot_Test_1.py Also this is my subreddit for the project, http://www.reddit.com/r/Knifey/ It only has 3 posts but will show you a bit of what is happening with the code.
Thanks
Javascript uses inferred types but it's fast. Its VM "learns" to expect a certain type and unrolls it into much quicker native code. Python could do that too, but it'll never happen until some huge company puts billions into it like Google did with V8. V8 is really fast. a+b in it gets close to C performance(pretty much 1:1 parity). It still has room for improvement. Like if you do a for( var i = 0; i &lt; array.length; i++ ) the VM knows to only check array.length once and store it as a variable, instead of checking it every loop. HOWEVER, if you modify the array inside the loop, it knows to check the array.length on the next loop. These sorts of things let you just write plain code, and let the VM handle the performance. Again, things Python could do. It could be just as fast as V8. But it's not, and almost certainly never will be. What's the point, though, of pointing out why it's slow instead of improving the VM ones self to make it faster? Because this isn't a language issue, it's a VM technology issue.
Yet v8 solves these problems for javascript which is also an interpreted, dynamic language. Stop making excuses and solve the problem
That doesn't make it a class method. You can't do something like Class cls = &lt;&lt;some class&gt;&gt; cls.someStaticMethod(); while a python class method can be accessed and invoked like this cls = obj.__ class __ cls.some_class_method();
This is in the sidebar already.
That's because you can't invoke methods on class objects directly. But that's unrelated to static methods. You can do this: cls.getMethod("whatever").invoke(null);
you can always use *null* when invoking a static method this way because it is not bound to any instance. You are not forced to do something like cls.getMethod("whatever").invoke(cls); but with a python classmethod, if you do something like MyClass.some_class_method(None) you'll get an Error if the *cls* parameter is actually accessed within *some_class_method* definition. A python classmethod is defined in the *metaclass* of some class. Java has very limited (if any) metaclass features. edit: Actually you can't do something like MyClass.some_class_method(None) read it as if you where calling a classmethod passing None as its first argument, instead of a *type* instance.
It doesn't take billions of dollars, PyPy already does all the things you're talking about.
No this is the reason python lists are slow. Did you not even read the article? Python lists are not contiguous and never will be because they are Heterogeneous.
We did, we named it PyPy.
No because lists are Heterogeneous.
I have basically a JAVA program that write the status of the program in a window. I want to be able to have a python script that will for example providing the PID of the process try to intercept the I/O. ( more the outputs than inputs ) edit : The JAVA program is a commercial one
That seems like a great idea. If you're looking at multiplayer(which would be a whole lot easier than trying to make a half-decent AI), check out [this](http://www.slideshare.net/mahendram/scaling-django-with-gevent) PowerPoint for some inspiration for using python-django in an event-driven application like a game. For the client, you can use pyglet or a native code framework for a desktop application, or html5 (possibly using a python-&gt;javascript compiler) for a web app.
Well, I didn't even wanted to go as far as making the game. Then I'd get into trouble over licensing and so on. I just wanted to solve the game. Do you know this game?
Anything where you're computing results over and over... this is one example of the common tradeoff between speed and memory use. Whether to use memoization on a particular problem is really dependent on your constraints for that problem.
He's just repeating something that got to first page on HN
I suppose assembly would be. 
I just read the readme. After adding an alias, why does the logic need to be duplicated for each variation? argv.add_alias('o', 'this_is_a_long_option') if argv.o: ... if argv.this_is_a_long_option:
&gt;Java is interpreted then, but yes, statically typed. Well, to be entirely accurate, it can be JIT compiled as well, not entirely interpreted.
What resources did you use? 
Sorry in advance for any difficulties understanding it, I am a bit disjointed at the moment, thanks for your understanding :)
They're not discouraged in C++ if you're working in my team.
I get confused when people say "don't overuse" as though I say "I'm going to overuse this sooo much - it's going to be great". if you're writing a book - and you say something like that - just put in one example of overusing - or 2 or 3 guidelines.
For why exceptions would be discouraged, it's probably because of the mindset that you should only "Use Exceptions only for Exceptional Conditions." For Python though, I feel it's easier to incorporate exception handling into normal use. But I could be wrong with this. It's easy to just try it out and if it doesn't work, switch to something else.
1) SSH. this would actually be through the terminal and give you exactly what you have now, but over the network. 2) Flask. You'll have to write html and define new intput() and print() functions for the flask/html interface.
The main reason is probably performance - exceptions are generally slow in most languages. The C++ community is a lot more performance orientated than the Python community. The other thing that comes to mind is Python being a dynamic language. There are more errors which you will need to check for at runtime and throw an exception, which would (in theory) be caught by the compiler in C++.
PyInstaller? www.pyinstaller.org
try except is used a lot in the internals of Python (like the iterator protocol with for loops and generators). as such there have been efforts to make them cheap. however, except can get expensive if it happens a lot more often than not.
Some people have attachment issues and try to discredit Py3k. Some people are not up to speed on big dog's compatibility with Py3k. And finally some did not get the memo. 
Agree. An implication of the similarity, though, is that it doesn't matter much which of these versions one uses. In fact, 2.7 is in some ways better simply because it's _smaller_ (i.e., less to know).
this is presumably for new programmers, creating new code. python 3 is the best choice for that by far
While there are lesser factors, the principle reason is that Python supports dynamic types and duck typing. In C++ you have static typing and the compiler is already checking that variable X is of type Y, object a has method b, etc. In Python you'd need to put lots of boilerplate code around every parameter to check for all of these conditions. It's considered much simpler, clearer and faster to use a try statement. Most of the time there will be no problem hence most of the time there will be no cost for the statement. On the other hand, all of those ifs would execute every single time. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Minimax algorithm**](https://en.wikipedia.org/wiki/Minimax%20algorithm): [](#sfw) --- &gt;__Minimax__ (sometimes __MinMax__ or __MM__ ) is a decision rule used in [decision theory](https://en.wikipedia.org/wiki/Decision_theory), [game theory](https://en.wikipedia.org/wiki/Game_theory), [statistics](https://en.wikipedia.org/wiki/Statistics) and [philosophy](https://en.wikipedia.org/wiki/Philosophy) for *mini*mizing the possible [loss](https://en.wikipedia.org/wiki/Loss_function) for a worst case (*max*imum loss) scenario. Alternatively, it can be thought of as *maxi*mizing the *min*imum gain (__maximin__ or __MaxMin__). Originally formulated for two-player [zero-sum](https://en.wikipedia.org/wiki/Zero-sum) [game theory](https://en.wikipedia.org/wiki/Game_theory), covering both the cases where players take alternate moves and those where they make simultaneous moves, it has also been extended to more complex games and to general decision making in the presence of uncertainty. &gt; --- ^Interesting: [^Minimax](https://en.wikipedia.org/wiki/Minimax) ^| [^Minimax ^approximation ^algorithm](https://en.wikipedia.org/wiki/Minimax_approximation_algorithm) ^| [^Quiescence ^search](https://en.wikipedia.org/wiki/Quiescence_search) ^| [^MTD-f](https://en.wikipedia.org/wiki/MTD-f) ^| [^Negamax](https://en.wikipedia.org/wiki/Negamax) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cheoir6) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cheoir6)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
sudo apt-get install python-software-properties; sudo add-apt-repository ppa:fkrull/deadsnakes; sudo apt-get update; sudo apt-get install python3.4; #http://askubuntu.com/a/395503/78690 
Wait, wat he didn't call it "the hitchhker's guide to python ... for HUMANS"?
Just link to twisted docs and call it good.
Then why isn't PyPy the default implementation? It doesn't even work with Python 3. Why not put all the effort into PyPy rather than CPython?
I just released version 1.0 today so I thought I'd throw it up here. Feel free to ask any questions.
OK, so if this is a bad guide because it mentions Python 2, is there an adequate resource for new Python programmers? I'm familiar with Perl, and am currently going through codecademy's course on Python (which I believe is Python 2 - because most of the stuff I try to write in my linux environment requires code that is different than in codecademy). So I'm not completely new to programming, but at first glance this seemed like it would be a great resource to delve into.
While what you say about typing is true, you failed to answer the question. Also, exceptions can be thrown for reasons other than invalid arguments and method names.
It isn't bad because it mentions Python 2 , it's bad because it recommends Python 2 as your primary version. The best guide that I have ever read is the absolute beginners guide to programming . It's a book though. Other than that the python.org official documentation is very detailed. 
Don't ask me, I am putting all my effort into PyPy :-)
And many in this case are running alternate installs of python anyhow - in order to avoid having to use python 2.4, 2.5 or 2.6. So, going to 3 really isn't any different anyway.
I'd say my most visited site was python.org for documentation. Also hung out in the python irc and asked questions anytime something confused me. Probably the most difficult thing for me was figuring out how to get the environment setup and tools like pip and virtualenv to install libraries. There's nothing like it in Java so it took a while to wrap my head around it. Otherwise I found it really easy just to jump into python and start coding. learned as I went. Its close enough to java that the other java devs I work with can read my python code without a problem.
Interesting. Note that there are 2 other projects for mocking the requests library: * https://pypi.python.org/pypi/httmock * https://pypi.python.org/pypi/requests-testadapter There's also general purpose libraries for record-replay mocking (but I think they won't work very well with complex libraries like requests): * http://texttest.sourceforge.net/index.php?page=capturemock * http://python-aspectlib.readthedocs.org/en/latest/testing.html 
"Dive into Python 3"
In C++, you can easily leak resources (like files, sockets ecT... ) and memory when using exceptions, just consider the following piece of code { auto p = new foo() if (not foo) throw .... do_something(p) } EDIT : As there is a misunderstanding with my original message, THIS IS BAD CODE. you don't write that in idiomatic C++. 
I was using Java. This was back in '99. Fortunatly I've never had to look back.
Why not? https://wiki.python.org/moin/PyQt http://www.wxpython.org 
&gt;PyQt Some prefer PySide due to it being LGPL (and maybe other reasons as well?).
And using one of them will make it so that I get a .dmg file for Mac and a .exe file for Windows?
Referenced here: http://askubuntu.com/questions/140740/should-i-use-pyqt-or-pyside-for-a-new-qt-project
Can't answer that. However for Mac, a .dmg is just a way to transport the actual executable. I could create dmgs on mac manually. As for .exe I'm not sure? I've never actually used python for gui stuff just operating system stuff and python servers. I would assume though that yes on windows you'll get an executable. 
Why not make a browser app? HTML5 on a modern browser might have what you need for an app. 
Thanks for the reply. I'm out of my element here. I just want to figure out how to build a desktop application that works on both OSes (and maybe Linux as well) without having to build the same thing twice natively (once for Mac and again for Windows). Whelp and help.
WingIDE is the best IDE. Emacs is the best editor.
Pleasing the [ladies](http://www.pyladies.com/). 
Very basic, but very nice! (Little hint: When you link to your series, you should link to the first and not the very last episode of that series.)
Thanks for the links! A couple notes: 1. VCR.py mocks at the httplib layer, so it should work with any HTTP client library. That said, I've only tested it with requests, urllib2, httplib2, and boto (which has its own weird http client built in) 2. Capturemock is really cool ([some examples](https://github.com/msabramo/capturemock_examples)), but since VCR.py is HTTP-specific, it has some features would be very difficult to implement with Capturemock. For example, version 1.0 just added support for filtering sensitive information from requests (e.g. Authorization from headers) and ignoring requests to certain hosts (test client making a request to localhost, for example).
You know, I'm not sure how I feel on this. On one side, Python is awesome and easy/fast to learn. It does a lot to help write clean code as simple as possible (sometimes is almost like writing English). So indeed it feels like a great beginner language, as it's easy yet powerful. On the other side, Python does a lot of magic to achieve it's easiness. So a beginner learning Python will not know tons of stuff that's it's automagic in Python, but it isn't in other languages (even simple stuff like iterating over an array or even types). This is fine, but what if one has to use another lower language for whatever reason? It's pretty much a relearn everything again, and I think it's easier to go hard -&gt; easy than it's to go easy -&gt; hard. I'm not saying that everyone should start with C, but at the same time I'm saying it. I just think that a (even basic) understanding of the underlying structure is something that everyone should have. Not only software, but hardware as well. Also another thing to consider is that the easiness of Python could lure into programming people that otherwise would not care at all. If I had to try to get my parents into programming, I'm sure they'd turn off the computer as soon as they saw a C hello world, but a Python hello world is much less scary. Oh well, thanks god I'm not a teacher :) P.s. since this could be misread, I'm not saying that Python is a bad language at all. In fact it's my main language and love the shit out of it.
At my university, (University of Louisiana Lafayette) python is the first language you learn in the computer science program. It is a good and a bad thing. While it is easy to pick up and get the basics, it also makes later classes harder. For example, C++ is the second class in the curriculum and it is quite hard to adjust to, especially if you have no prior programming experienece.
Maybe you can automate it using something like this http://www.sikuli.org/
Thanks for the response. I'm looking to hire a freelance developer to build it. It's going to be a commercial application so thanks for the heads up on avoiding that method. Should I use Python on the backend and Javascript on the front end and call it a day?
[online game with django, gevent and websockets](http://sontek.net/blog/detail/pycon-sprints-part-1-the-realtime-web-with-gevent-socket-io-redis-and-django)
&gt;While what you say about typing is true, you failed to answer the question. How so? In C++ static typing takes care of a range of checks that would need to be expressed in a lot of boilerplate in Python. It's much simpler and more readable to use exceptions than to write all of those checks. &gt;Also, exceptions can be thrown for reasons other than invalid arguments and &gt;method names. Yes, and those other reasons are dealt with the same way in C++ and Python. Python makes the tradeoff of some extra exception handling vs. static typing or lots of boilerplate checking of types.
Yeah, I'm mixed on this. Some people learn better from a "top down" pragmatic approach, others learn better from a bottom-up theoretical approach. Python's a good choice for the former, C would be better for the latter. And honestly, judging a programming language by how many lines it takes to do "hello world" is wrong headed.
It's not "because we said so"; EAFP avoids reams of hasattr and isinstance checks that would be necessary otherwise because of dynamic typing. http://en.wikipedia.org/wiki/EAFP#Exceptions
I have no idea what you should do. Maybe you should trust the judgement of whoever you hire to write it, rather than strangers on reddit who don't even know what you're trying to build. EDIT: I don't mean this to sound so snarky; it's just that you've seriously got a cart-before-the-horse problem here, and none of us know what you're trying to accomplish.
From the other direction, it's hard to learn about higher-level concepts when you're constantly being tripped up by low-level issues. I took a college course on data structures that used C++. We spent so much time on syntax and constructors and destructors and pointers that nobody had any brainpower left to dedicate to linked lists. 
Ha. It didn't come across as snarky at all. You made a really good point. It made me crack up when I read it. I want to post an ad to hire a developer, so I'm trying (in my no knowledge) to figure out what language skills and experience to include in the ad.
Had a drunken conversation with my wife and a friend and decided to make this. It simply returns links (supports http://i.imgur.com and http://www.imgur.com links out of the box [but no albums]), but can be fixed to "render" them or whatever. A simple PoC for me personally, figured I'd share it with the rest.
A huge reason for the popularity of Python (at least in scientific circles) is the ability to easily interface to legacy C and Fortran packages via the C-API. That is not (yet?) possible with PyPy, and until it is, PyPy will never be a serious contender to replace CPython as the default implementation.
Very well done this has helped me a fair bit bridge some of the gaps I was missing.
They probably did, I don't remember. The disconnect between the abstract concept and the concrete implementation was great enough that most of the class had a hard time seeing the connection. It wasn't until years later when I read SICP that most of the ideas behind programming really made sense to me. 
The disparity between - the copious hype about it provided on the web page and - my understanding of *what it actually does*, despite clicking through many links on that same page and watching some of a video... ...is notable.
It's a fine multi-platform outliner, that my team and I have used for years. But I never actually wrote code with it. Just organized notes, code snippets, and sets of data (much like an ipython notebook). And it did that extremely well. 
I think in that situation I wouldn't advertise for specific language skills, but rather domain-related knowledge. Leave the choice of language (within reason) to what the developer is comfortable with and feels is the best fit. We could all give passerby advice on our favorite languages, but you'd likely end up posting an ad which sounds (to a developer) like "Need someone skilled in metallurgy and injection molding to help me build a tool shed". 
Python has factorial built-in¹, with the operator "`-ⵘ`". You know, because it looks like an explosion. # Import statement ⵘ = type("",(),{"__rsub__":lambda s,n:(lambda f,n:f(f,n))(lambda f,z:round((2.5066282746310002*(z+0j+7.5)**(z+0.5)*2.718281828459045**(-z-7.5)*(0.99999999999980993+676.5203681218851/(z+1)-1259.1392167224028/(z+2)+771.32342877765313/(z+3)-176.61502916214059/(z+4)+12.507343278686905/(z+5)-0.13857109526572012/(z+6)+9.9843695780195716e-6/(z+7)+1.5056327351493116e-7/(z+8))).real)if z&gt;=0.5 else 3.141592653589793/(__import__("math").sin(3.141592653589793*z)*f(f,1-z)),n)})() assert 2-ⵘ == 2 assert 3-ⵘ == 6 assert 4-ⵘ == 24 ¹ With a teensy-tiny import statement
Saving post to watch when I have time. Thanks!
Did... did you just create a new object which, when subtracted from something, calls a really convoluted factorial function on it, and then assign it to the symbol U+2D58 TIFINAGH LETTER AYER YAGH?
I don't think that's appropriate for web apps. Is it?
Figured I'd share this because I have a few people from college who asks me about this everyone once in awhile. This should also work on other WindowsOS versions.
That's why you should use the RAII idiom. Why aren't you using a smart pointer here?
Try IPython notebook: http://ipython.org/notebook.html
I like it. Can be used in several ways. How about an ever growing 'cats' directory for example.. LOL!
This message means that an open file "/tmp/test" (the one you log to) is still open when `subprocess.Popen` calls `os.fork`, so it gets copied into the child process. LVM-related tools see that and [treat it as a potential security risk](https://bugs.launchpad.net/ubuntu/+source/lvm2/+bug/591823). Aside from simply ignoring this warning, you can try calling `Popen` with `close_fds=True` (i.e. `subprocess.Popen(cmd, stdout=..., stderr=..., close_fds=True)`).
Hey, There is a misunderstanding here , this is an example of bad code that leaks. but we can agree that this is common code that a lot of people still write , it is to illustrate a bad code that often happens, actually it's is derived from a talk that was given by Bjarn when presenting C++ 11, he says that this still happens a lot. 
Will be watching! I'm sure it'll help fill in everything from class
subscribed :)
What is it good for? How could I use it in my everyday work?
Oh lord, lol. Karma for life, man...karma for life. Its kind of why I did it anyways (was originally meant to be a scrapper, but then I figured I'd make it be a wallpaper changer). I'm constantly making changes to it though it seems. Pushed like 20 commits of changes last night.
&gt; It may be the case that I shouldn't be programming No, I hope this isn't the message you got from my post. Everyone that's even slightly interested in programming (or solving a problem with programming) should be able to program. I hope I didn't come out as an elitist "If you can't program manually flipping bits on your hard disk, then you shouldn't". I guess Python is a great first language if you're self-learning, and just want to get stuff done (Python is great for that, you can read a tutorial and have something working one hour later), but it isn't if you're in school. Maybe it's just me, but in school I did a lot of pseudocode, bnf, diagrams... before even writing a line of code. It was annoying, but the nice thing is that you learn the principle, and then applying it to different languages is just a matter of syntax. (Mind you, this was just few years ago, not in the '80).
As someone still getting to grips with Python, these were fantastic and fun to watch, subscribed. Many thanks :) (also, i'm not sure if there typo at the end of the 7th video of Warp instead of wrap was intentional, but it gave me a good giggle with the star trek references :D ) thank you and good luck with future videos, i look forward to seeing them!
I would use the `hash()` of the permalink to the comment as a key in a set. For each username, I would store one set. The whole state would be stored in a dictionary like: { 'someusername' : {13950884593, 92525229262960}, 'anotherusername' : {893603486, 2960940694, 204690294095, 30632543}} which would be saved on disk (probably as a pickle) when the program exits, and loaded before it starts. This way, I could just use `hash(permalink) in repliedcomments[username]` to test whether the comment has already been replied to. As for your other questions, I think you need to research Python more. Specifically variable scope.
Outliners are really powerful ways to organize notes: their ability to collapse &amp; expand sections, create links between sections, etc is great. Additionally, unlike a word processor - they're more dedicated to this kind of function and far easier to use &amp; faster. So, say you've got a project and you want to keep notes on the project. You could keep notes on requirements, environments, schedules, tasks, technology, testing, etc there that doesn't go anywhere else. These days a lot of that might end up on a wiki, where it's better for collaboration. But the outliner is much faster for adding info. i've kept personal notes this way, then kept the outliner file as an attachment on our wiki where anyone could get to it.
try/except does not carry as large a performance penalty vs if/else in Python as it does in C++. I believe that the cut-off point is about one third: if you expect exceptions being raised less than one-third of the time, it is more efficient to use try/except than if/else. As for the comment that another redditor wrote to the effect that *The other thing that comes to mind is Python being a dynamic language. There are more errors which you will need to check for at runtime and throw an exception, which would (in theory) be caught by the compiler in C++.* it is either a) bullshit or b) a sign that the Python programmer in question is writing poor code with no unit tests. 
Does this just listen to everything it's told, or is it triggered by something like "Hey Jarvis, &lt;COMMAND&gt;" ?
I would be nice to have requirements in requirements.txt
Oh man, sucks that Python.org just redesigned their site, huh!
Great tutorials, well done! :D Great idea to mix it up with the little skits, and the animations are really stupendous and really good for learning. Edit: My recommendation would be make a little site for your tutorials (maybe something like "laugh-into-python.org" or something), and embed all your videos next to all the code snippets, links, further reading, etc. This will help the videos get more exposure and also make it easier for folks to follow along.
I like the funky SciFi background and sounds. How did you do those?
idle.pyw , or idle.py I'm assuming the .py because I know that's just a plain python file. EDIT: Wait nevermind, I ran the .bat and I think that was the one. Thanks. 
Thanks ! Well...to be honest I am kind of ashamed of the first video that is why ;p
Thanks illicitPC.
I have just spent an hour or so experimenting with Leo, and whilst I wanted to like it, I just can't figure out how this should be used as serious code editor. For example, how do I import my existing code into the outline? I figured you I can import existing files using '@auto filename' then right clicking and pressing 'refresh from disk'. How about whole trees? Also I tried and failed to make a button that runs some of my pytest tests. The problem here is that the stdout is not captured when using CTRL+B to execute a script. In order to see output in the log window you need to go via g.es(). So whilst I wanted to like this, I will be sticking with vim and vimwiki.
How about giving JARVIS some artificial intelligence? Sort of a neural net in which it could actually 'learn' instead of giving passive responses like SIRI.I'm interning at a research institute this summer...may be then I could share some algorithms with you? 
I am glad you find it entertaining, my six months of work is now validated! Yeah!!!
`ImportError: No module named osg` How to install this module? (I'm under Ubuntu.)
Bad, bad, string handling (py3 defaults to unicode now) not to as easy to learn 
I know right, the first episode is SUCH a humiliation, I was watching it myself and I was like WTF is that Chink doing... Well I shall let it be to be a reminder of how much I actually SUCK ! ha ha ha
"I POST in your general direction! Your GET was a hamster and your HEAD smelt of elderberries! 
Oh, that's cool, what were your gaps that this video managed to fill ? It could be a common problem.
Awesome !
This is really neat! 
That's a really nice object system for handling your search terms. However, I'm not really keen on the multiple parens: self.parse().code()(s) Without changing the model, a @property decorator might make this prettier.
Perhaps use Crunchy: http://code.google.com/p/crunchy
Cool! If anybody ask who that guy is, just tell them he is just a loser living in his mum's basement. It's true...
 pip install osg # maybe? Never heard of the package before
The Curse of Green Screen Technology.... It's either that or letting the world knows I live in a dump ;p
Good idea...now if I can get off my lazy ass....
Oooo but it looks better !
Ripping off the internet ;p
Thanks
Have you tried typing in the terminal: $ python &lt;filename&gt;.py ? (the dollar sign is the prompt, don't type it)
lol... for starters, how about just grab a [bootstrap template](http://getbootstrap.com/), embed all the videos in a really simple list just like [this page](http://cocos2d.org/doc.html), put it on github (or bitbucket) at something like "laugh-into-python.github.io" as a simple static html page (they have free hosting as you might know for static pages) after that, incrementally add the snippets or links, and maybe a disqus comment section, as you incrementally get off your lazy ass ;)
If you're successfully getting Python to load,but it's complaining that your game needs PyGame, you can download and install from http://www.pygame.org/download.shtml If you're not sure what version to go for or whatever, reply with a follow-up question and I'll try to help out. BTW, as another source of Python help, I've found the #python IRC channel on Freenode to be very helpful with questions at all levels.
Install Python if not already installed. You must do this yourself on a PC. Activestate Python is what you want, versio 2.7.x not 3.x. Then install pygame.
Lecturer here: C++ is just hard to adjust to; it's not Python's fault.
Welcome !
Browsing reddit on my mobile and I ended up watching all 7 videos !!! I watched them cause I'm looking for entertainment but u reallly taught me alotttt !! Since ur using windows .. im guessing u already convert python into executables. (exe) Would be awsome if u include how we could do that in a future video Thanks alot !
mmm.. How do I clone that repo? git clone doesn't seem to work for me
Thank you. This explains a lot.
Via HN. Discussion: https://news.ycombinator.com/item?id=7729006
Random but related plug. The Scipy conference is coming up and highly recommend going to it. Its a fantastic conference.
What's the full command you're running? Http isn't supported, only git.
http://kivy.org/ also runs on Android.
It's a external program as far as I can tell. You need to install in separately. So for arch linux for example, you need to install [this package](https://www.archlinux.org/packages/community/x86_64/openscenegraph/). 
 $ git clone git://git.anzensolutions.com/reddit/wallpaper.git Cloning into 'wallpaper'... fatal: unable to connect to git.anzensolutions.com: git.anzensolutions.com[0: 162.250.233.111]: errno=No error
says it's not a valid protocol. edit: tried git://git@git ...., not working too
Interesting article but this: "For one thing, when you can do everything in the same language, you don’t have to suffer the constant cognitive switch costs of reminding yourself say, that Ruby uses blocks instead of comprehensions, or that you need to call len(array) instead of array.length to get the size of an array in Python; you can just keep solving the problem you’re trying to solve with as little cognitive overhead as possible." Is a strong argument for node.js as anenvironment for web development.
I'm currently out with my family for mothers day but I'll look into this for you tonight. I use gitolite for acl and guess I set it wrong
Why would you suggest ActiceState over regular Python (CPython)?
I could install `openscenegraph` via `apt-get` but this `osg` Python module is still a mystery.
This is a weird module.
Got any good reading recommendations? I've been interested in learning AI but I'm not sure where to start.
If you install the program it may come with python bindings that allow you to interact with it through python. And check out the requirements.txt file in the repo which lists the dependencies that are required if you haven't already.
Oh wow you’ve watched it all ?! Such Honor.... Such Embarrassed ;p Such Honor ;p I actually didn’t bother to create *.exe out of the Python scripts, it actually has never crossed my mind throughout the video to do that because double clicking the script file will auto-execute it anyway. Hmmm....too lost in the execution of the video... Again thank you for watching it all ! :D 
Agree. But I am sort of a retard myself and I have a “need” to rename things to a more relevant [relevant to me that is] term to get my brain working probably. Like Invader Zim or Cartmen says...It’s “for the children”, have a little compassion ;p
And why an old version of Python? PyGame is up to date. Daft advice. Modern python.org installs include pip, so using "pip install pygame" at the terminal might be easiest route after installing a python.org Python3.4 bundle.
I've tried Leo before and I've also switched back before. It definitely worked much better for new projects and was too much work to make it work correctly for existing projects. When you are starting a new projects you can get some value out of organizing your code in a much more granular way than files. For example, grouping functions and their tests together. If you want to get an idea of how much structure you can have, try opening the Leo source itself in Leo, it is extremely well organized. Ultimately it's a neat idea but I don't think it can work well in the real world because it doesn't work well in team projects because you cannot force your whole team to the Leo way of doing thigs.
I'm currently using Python for scientific data analysis (which I should really get back to instead of being here...), and it's just plain wonderful compared to ROOT and MATLAB.
Hi, I used SL4A with PY4A. https://code.google.com/p/android-scripting/ Although it is very functional and you can have a lot of fun with it (GPS, acceleration and bluetooth heart rate monitor), it is very much alpha software. Meaning it has bugs and to solve a bug you need to find a way to work around it. I don't think it is still maintained. I switched to Cordova (Javascript) for Android development.
I'll agree with that.
This is what CoffeeScript, LiveScript, Dart try to do. Make JavaScript more usable and maintainable. You should also note that the next version of JavaScript ES6 will make a ton of QOL improvements.
Also when you have a small amount of code. :)
There are some free online courses and some good books (see side bar over to the right). How comfortable are you with the command line or terminal? Do you know how to set environment variables? If what I just asked sounds Greek to you, then you need to get up to speed with your computer's operating system ASAP. The reason I ask this, learning how to program is more than just learning the programming language itself. You should learn how to use your computer's operating system (OS) in terms of using the terminal or DOS (in Windows). When I first learned how to program, that was my initial stumbling block. If you are comfortable with your OS, then try out the online books at the side bar on the right. [Here](https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks) are some things you can do with Python, there are some examples on scientific computing there.
This is one of those things that I'd be like 'man wouldn't this be handy?' and then start using it and then just have to end up moving to a proper class every time. 
I would make the switch if there were an equivalent IDE to RStudio. I have colleagues who are just switching from Excel in some cases, and RStudio flattens the learning curve tremendously. 
What do you want to use Python for? Whether you will find a library missing depends a lot on what libraries you will want to use... Here's a good indication of how many of the most popular Python packages are available with Python 3: http://py3readiness.org/
5 months ago, so it's ok.
Of course! Your suggestions are most welcome. just open few issues and we'll discuss there.
At least it's not *urk* MATLAB.
Which python package is that in?
Is this the game I wrote and posted to /r/amblyopia? If it is I recommend trying an android game someone else wrote called stereo blocks. Its got a lot more features than my game and you don't have to mess about getting pygame running.
Likely needs `pyosg`.
I'm sold on Anaconda+PyCharm. 1. Install [Anaconda](https://store.continuum.io/cshop/anaconda/) for the ease of installing scientific packages. Upgrade it to Python 3 by following steps [here](http://continuum.io/blog/anaconda-python-3). 2. Open up PyCharm. Point the project interpreter to your Anaconda install. Anaconda just makes getting the scipy-stack and more (most of the scientific packages you'll ever need) really easy, and then PyCharm being a Jetbrains IDE is full of [features](http://www.jetbrains.com/pycharm/features/). If you don't want PyCharm, the installation process is even simpler: install Anaconda, launch it, install whichever IDE it was that they suggested by clicking the button, and you have a fully functional scientific Python ready to go.
Will the talks be uploaded onto pyvideo as with pycon montreal? 
I would be very surprised if you, as a new Python user, needed some obscure Python 2 library that nobody had ported by now. Consider also that the language is moving forward: if you learn Python 2, you're perfectly suited for a life of maintaining and porting legacy code, and should that appeal to you I think you're better off learning FORTRAN 77. Python 2 is effectively end of life and won't receive much other than security critical updates now. If, however, you instead learn Python 3, you'll get to enjoy some new syntax conveniences and all future Python Extension Proposals that make their way into the Python language. I'd recommend going with Python 3.3 at the moment as 3.4 is relatively new and more of a pain to install certain packages for; given though that you used to program in Perl I would think that building from source wouldn't faze you much and hence 3.4 should be fine. Has the added advantage of having asyncio if network stuff is your thing, and pip the package manager being installed by default.
The most crucial one: mysql-python This leaves 80% of python web developers stuck with python 2.7
This is very wrong and reads like propaganda. End of life for Python 2.7 was moved to 2020 because 2.7 is still more widely used and the upgrade path to 3.x still isn't possible for such a big part of the community. 
Then why is R still growing rapidly. Started with Python and pandas and moved to R. There are more R people doing scientific programming then in Python or at least three is more action on R. R libraries - reshape2, ddplyr, data.tables and ggplot2 are amazing.
I'm approaching it from an academic perspective, which is the only one that I have. I know that EOL was moved to 2020, however, I see a lack of PEPs proposing significant changes to 2.7, and Guido is (at least for now) firm in saying that there will not be a 2.8. Without OP providing more information, neither of us can really be right - we don't know what he wants, or what he plans to do. For people who use Python professionally, I agree that many of you are locked to 2.7; hell, there was that distro that was still stuck on 2.5 or 2.6. However, since he's only learning it now, I assumed that he was a hobbyist/student and that he would therefore not be bitten by the issue of corporate forcing his decisions, e.g. no MySQL connector? If it's not a corporate requirement, just use Postgres or sqlite. 
Yeah they will he. But the point of conferences is not just the talks. Its the cool people.
I can specify three reasons. One is that scientists are smart people, but they have not chosen to be CS grads. So when they program they aren't programming to impress some pedantic CS prof. They are programming to get things done. So their code doesn't implement objects because they were told that python is supposed to be object oriented. They don't implement templates because that is what should go into modern code. They know their co-scientists aren't CS grads so the function should not take pointers to 3 different structs as parameters but should be simple. I think that there are languages that some CS people adopt just to impress other CS people. Scala, Node.js, F#, etc. The next reason is that Python is so simple that it doesn't try to tell you how to accomplish your goal. This means that when doing something non-routine (common in science) then you aren't stuck with a tool that doesn't work. You just make it work even if that means implementing parts of your solution in C or whatnot. For instance Python doesn't have a favorite Operating System. It doesn't have a favorite file format. A favorite comm protocol. But lastly it has all the critical bits that scientists need. This is a bit of a chicken or the egg problem that Python has hurdled. So there are all kinds of libraries and whatnot that are ready to go for all kinds of different scientists. A key one is the ease of use of Matplotlib. Others would of course be Scipy, Panda, and Numpy. These last libraries give the scientist the ability to do things from Matlab/Octave, and R without the limitations of those languages. When presenting a paper, graphs are a critical part; so being able to have a few lines of code that read in data and turn it into an acceptable graph is really cool. Being able to fiddle with that data is extra cool. And being able to reach out through a serial port and gather that data is extremely cool. 
R is a great statistical language, but scientific computing is a lot broader than that. If you doing things like analyzing molecular dynamics simulations R is pretty worthless, but python has fantastic library support. There are other likely many other examples of places where Python shines in comparison to R (finite difference, dynamic systems, symbolic math, image processing?). Personally I do everything in Python and occasionally use rpy2 when I really need R. Most of the time I don't. That said, it's not a zero sum game. Both languages can flourish independently.
OP here. I do a lot of web scraping, statistics, graphics (now by constructing html5 &amp; jason files to run in a browser - yeah, it's a kloodge, but perl has no significant graphics capability). But looking at python today made my head spin. Apparently there are big differences between versions, and many of the tutorials and forums on the web didn't make it very obvious which versions they're talking about. I'm currently writing a neural net model in perl, and I thought that maybe scikit-learn would be an easier way to go, but it took me a long time to find that it is good for "v.2.6+". Does that include v.3? No mention. It seems that the relative dead-end of v.2.7 would make life a lot simpler for me. I really don't care about Unicode. Or maybe just stick with perl. As an old C programmer, I do love my goto's and references. :-)
Flask Don't think it's a library but it's why I have not moved yet. [Here is what they say about it](http://flask.pocoo.org/docs/python3/) 
Thanks! Yes, there are quite a few parentheses. Perhaps it should be cleaned up. Thanks for the suggestion.
Yes! Unfortuntely I don't have an android device to use (or even borrow) which is why I'm trying to get this working. Thank you so much for your help though 
Been using it for a couple of years to do "knowledge base", i.e. PIM. This thing kept me from want to go to the much more powerful OneNote because I got so used to the outlines.
It's also a strong case for Julia with native matrix support and fast performance instead of numpy / cython / C modules.
According to its PyPI page, scikit-learn supports Python 3.3+: https://pypi.python.org/pypi/scikit-learn/0.14.1. But yeah their installation documentation should be fixed to make that clear. Matplotlib, SciPy, numpy and Statsmodels all support Python 3 so I think you should be fine as far as package support goes, unless you end up wanting to use something more obscure that isn't well maintained. The differences between 2.7 and 3 aren't that large but it can be confusing being a new user when tutorials don't specify which version they're written for. Most tutorials will probably assume 2.x if they don't say otherwise. If you do use Python 3 it would probably pay to learn some of the differences so you don't get tripped up by old 2.x code that doesn't work the same.
This community loves python 3.
I'm not sure if this is the official page, but it's the page I've seen come up over the years: http://python3wos.appspot.com/ At my workplace we're still using Python 2.5 and 2.6. We're just starting to move to Python 2.7. I've taken a few online classes that used Python 3 and I haven't noticed too much of a day-to-day difference when switching between the two (mainly integer division and print statement). Python 2.7 is the current standard and likely will be for awhile. Large code bases are hard to transition (as you can see from the fact my workplace is still using Python 2.5). It sucks to dig into the standard library and find bugs that were long ago fixed or features you wish you could use. I say this about using Python 2.5 and 2.6 and looking toward Python 2.7. I've also looked at some of the new Python 3 standard libraries with envy. This could all be a "grass is greener" thing.
This article is pretty old.
Sorry, this post was the first time I'd ever heard of it.
Apache-libcloud handles AWS.
Flask does support Python 3 - even the link you give confirms that. It warns that many Flask extensions don't, but a quick flick through PyPI suggests that some of them are starting to move.
The scientific computing landscape looks very different in different fields. R is big in ecology, for example, but neuroscientists are much more likely to use Python.
Sorry about that. Got it fixed now. git clone git://git.anzensolutions.com/reddit/wallpaper.git I just tested this and it works now. Forgot to install the git-daemon to make this work, heh.
10%-50% performance slow down, and it's GPLv2 only.
Cython will not help at all here. I'm too lazy right now to explain, but it basically is an (awesome) interface to CPython. But I think you can run Python on Android, although I've never tried or wanted to.
I use python 3 and 2 for several things some missing things I would like are PyBrain and OpenCV. OpenCV is making the transition but there has not been an official build for python 3 yet. You can check here for the builds http://www.lfd.uci.edu/~gohlke/pythonlibs/ Kivy for android also builds on python 2.7 if you are planning to make apps
Jython works: http://stackoverflow.com/questions/11120130/programming-android-apps-in-jython
Yeah, that's it. But this time `pyosg` terminates: Producer/InputArea.cpp:21:31: fatal error: Producer/Referenced: No such file or directory #include &lt;Producer/Referenced&gt; ^ compilation terminated. error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 I tried to install `libopenscenegraph-dev` and `libopenscenegraph80` via `apt-get` but it didn't help.
Try to import `pyosg` in an interpreter and see what kind of errors you receive. It's likely that you're missing some dependency of the library.
CPython is not regular Python. ActiveState is a well done version that is designed with Windows in mind. Python.org Python is best in a *nix environment (Mac OS X is BSD Unix).
Python.org is fine for experienced users but OP is a newbie. Activestate is not old. They are as up-to-date as anything. You must be a newbie,too, to think that 2.7.x is old while 3.4 is newer. Also, Activestate has 3.4 if you insist on it.
I can't even install pyosg via pip because of those errors thus I cannot import it.
This is god damn gold, this should be hyped as fck!
For Morons, finally...I need this!
&gt; Python 2 is effectively end of life and won't receive much other than security critical updates now. That's not a bug. That's a feature. One I am profoundly grateful for.
Also, Django - Although I think the new RC does.
Fair enough. Have you installed osg? The posted error seems to be looking for [a file in that package](http://openscenegraph.sourcearchive.com/documentation/1.2.0-4build1/InputArea_8cpp-source.html).
scipy.in is not functional :(
There's a browser implementation of python in the works called [brython](http://www.brython.info/) in the works.
Eh, I'm subscribed to several different language specific subreddits and all of them get these "our language is conquering the world" submissions regularly. I guess it makes people feel good about themselves, so they upvote.
I think most branches of science are becoming more computational anyway, so there's a good chance that there are a number of languages whose use is growing rapidly. For a lot of students, you pick up the language used in your lab, and R is very common in genetics and bioinformatics labs (the former of which has seen a rapid computerisation). The molecular neuroscience/ behaviour lab I'm going into for my PhD uses matlab, so if I want to integrate with all of the work they've done so far, that's going to have to be my vehicle (although IMO numpy is a pretty pale imitation of matlab anyway). The point is, if python can do more or less anything that those other languages can do, and the scientific community as a whole benefits from having less variance in languages used, its use should be encouraged.
Spyder is nice. No package control though, but you can use Anaconda for that. Anaconda also installs Spyder.
&gt; "Django 1.5 is the first version of Django to support Python 3" https://docs.djangoproject.com/en/1.6/topics/python3/
Start with AI a modern approach. The pseudocode is in python.. and it covers broadly all the areas 
when defining AI you need to be specific. Chatbot is an example of AI because it modifies itself to the 'mood' of the speaker and answers accordingly. Siri on the other hand is just a software which filters out keywords and gives suggestions on them. Hope I answered you. 
Okay just let me get started with this. Btw I'm a huge fan of iron man so I had this in mind to develop something like this. As of now my finals are on so I have to abstain from programming(otherwise I'll fail). As soon as I link up with your repository I'll be there in it's development 
Anyone care to comment on why they voted a certain way or offer any improvements to any of the versions?
2.7 is a compatibility/upgrade path to modern python. And, while it's being maintained now til 2020 to cater to fossils, the version number predates 3.3, nevermind 3.4. Now, I questioned your judgement, but that's not the same as shouting "n00b", so let's keep it civil.
Nope, but there are these: http://math.nist.gov/javanumerics/ I'm just searching Google to answer your questions, I've never tried writing python for android.
awwww
1 is horrible. It takes significant effort to dig through and figure out what it's doing. I went with 2 purely because I'm not very familiar with dict comprehensions, so it was much clearer to me than 3.
PyPy can also target JS and now runs faster than CPython in some benchmarks.
foo = dict() foo = dict([....]) Seriously dude... thats' just bad. It's foo = {} foo = {....} oh and please change "int(pk)" to "pk", and PLEASE don't call a list of objects "models". "Models" in django is a list of table models.
You need to know about setting the PATH and PYTHONPATH environment variables. You can do this in DOS or use Windows advanced settings GUI.
Is Python.org's version not CPython? I may be mistaken but I am not talking about Cython
I strongly disagree. At my lab we use both, and everyone I talk to strongly detests R. There was an article in the R Journal once about how there are 7 accepted coding styles within CRAN + Bioconductor + R. Heck, there are 3 different ways to programm OOP. And let's ignore the painful slowness of R or the weird scoping rules. From a pure programming POV, the language is absolute and utter crap. Now with that said, it has some nice libraries and functionalities in it, but luckily Python has strongly caught up there with pandas + scikits.statsmodels + scikit-learn.
Thanks. 
check this out: https://code.google.com/p/python-for-android/. It is use by the sl4a project(https://code.google.com/p/android-scripting/) to script android using python(among other scripting languages)
If you are using mac, ignore the advice to use ActiveState. Python.org's python is "official" python, while AS's is designed to allow you to use advanced Windows features easily. It's not required. I think AS is a good idea, but it's not critical. 
I don't know. I suspect that the cognitive switch required when you start working with a different set of APIs and with a strikingly different paradigm, is costly enough that a language switch on top of that doesn't really slow you down much. Particularly when both languages are ones that you know well. Also, let's be serious, most projects grows to have separate backend and frontend developers anyway, at which point this becomes irrelevant. I have nothing against Node, I just think that this is one of the worst arguments in favor of it.
&gt; is there a way of running python within an android app This is what [kivy](http://kivy.org/#home) does (as already linked by chchan), though by embedding the python interpreter and letting you create the entire app with python so it runs on the phone as a normal app as far as android is concerned. It includes tools for directly accessing the android api including sensors. &gt; I'd ideally like to be able to use my Python script that uses Numpy/Scipy natively on the android phone. Kivy's android bundling tools compile the entire python interpreter for android, and the app really does run as python (plus a java frontend displaying the output, but this is handled automatically). As part of this process it's possible to include arbitrary python modules, including those written with cython or even linking directly to C, but anything that requires compilation needs special treatment to properly cross compile. This is often quite easy and the build tools have pre-written [recipes](https://github.com/kivy/python-for-android/tree/master/recipes) for many of these, including numpy, but I think scipy is unlikely to work any time soon because it has a relatively complex set of dependencies on the C/fortran/whatever scientific libraries that are not easy (read, 'probably very hard') to get working on android. It's possible that SL4A would also help you, in that you could run a python script directly and use their api to access sensors etc. I don't know so much about this, and I'm not sure if they support numpy, though I think I've seen activity about that. &gt; Is this totally dumb? Is is possible? I think it's absolutely possible and reasonable, with some caveats. One is that whichever way you try, you'll need to make some changes to work with the api of the tool you choose, possibly/probably including removing your numpy/scipy dependencies.
In still fairly certain the "official" Python implementation is CPython. 
&gt; something built-in What
-1, does not look like it would could be used in someones code
R = Crap? No there is a reason why it has been around SINCE 1976! Why does Google still use it? Why does R have the best plotting? Painful slowness? From a python user :P Maybe look at the libraries I pointed to dplyr, data.table would not be slow compared to Python. Also Julia users just fell off their chairs laughing. Reason why I switched from Python to R: "Python has strongly caught up there with pandas + scikits.statsmodels + scikit-learn" why use a catchup when you can just go to the source?
Why is that? I have analyzed a lot of molecular dynamics simulations in R. Not sure how they compare head-to-head, but pandas was not as mature up until very recently.
Flask has been supporting Py3 for a long time now and gevent [is in the last stages of being ported](https://github.com/surfly/gevent/issues/38)
As a novice who only ever has personal projects using SQLite, can I ask what the problems with it are?
Python is not Java. Don't use your name as a namespace.
And that is why it is referred to as "the Zope world". There is no mitsuhiko.click or mitsuhiko.flask or kennethreitz.requests module. If someone else takes over the development of your module, should he change the namespace and break all existing usage? If you for some reason change your name, will you also change all your code? The plone. and zope. modules are grouped by organisations which at least makes some sense, even though even this can go very wrong (See Sun-&gt;Oracle as an example). 
web2py! it would really nice if it works on Python 3.x in the same way it works on python 2.x
Very nice work done on the TLS/SSL side. Note: Please consider removing the javascript code that connects to Ohloh... it slows down the page loading way too much.
Lacking evidence that OP requires 2.7,why assume so?
C is so quick not because it's compiled but because it relies on the programmer to handle things such as types. The simple fact is that a compiled Python would have to include the entire python interpreter to have feature parity. Doing that, it wouldn't be so fast. So, you should check out PyPy, part of its implementation is a compilable version of Python called RPython ( http://pypy.readthedocs.org/en/latest/coding-guide.html#id1 ) which is probably the closest in spirit to what you're suggesting. I think it boils down to the fact that interpreted languages are interpreted because it makes them more flexible for not much cost.
It's only been in the last 6 months or so that you could start to find any programs that work with 3.x. Most existing scripts tend to be for 2.7.x. Example of a prominent program written in Python: Calibre. It needs 2.7. (You don't have to install Python to use it, though. It supplies its own private version when installed.)
+1 for SUDS. I used it for a project at work. I had to do a bunch of dirty stuff to work around a lot of the .NET SOAP WS-Security functionality.
there are not many things less wonderful then ROOT.
Short talk from pycon2014 about zip bundling, Cython, and Nuitka. **Day of the EXE** http://rhodesmill.org/brandon/slides/2014-04-pycon/day-of-the-exe/ http://pyvideo.org/video/2636/the-day-of-the-exe-is-upon-us 
But the ISSUE again is R isn't awful and the Python hate pilling on R is unfortunate and untrue. "Can't we all get along?" R = lead. Python perception is that they are in the lead which is untrue. Like this badly written thesis of a blog post states.
FFTs are in numpy, and so work on android with kivy. I played with them at one point with the test app [here](https://github.com/inclement/fourierdroid) - nothing very intensive, but it worked fine.
Same here
bro there are like 8 zillion deployment frameworks. Instead of asking people what they think of this (because why should we care), why don't you tell us *why* we should care? What is the point of your project?
Stop degrading yourself! I only watched video 7 and I loved it. The fact that you didnt make amazing and riveting videos shouldn't be a humiliation at all because it allowed you to progress and make video 7, which was freakin wonderful. To put this in perspective, I just took intro to Python at an Ivy league school this semester and your videos taught me more in less time than my professors ever could. I'm not saying you need to be happy about video 1 if it sucked. Just acknoloedge it sucked and move on. You actually possess a gift when it comes to teaching, you just need to refine your craft is all!! I'll be waiting for more videos
For faster non-reading-counters (that don't return the value on increment/decrement) look at hypertable. explained here how they work https://news.ycombinator.com/item?id=7627481
Would this sort of issue go away if invalid Unicode was allowed in Unicode strings? Then stuff would only blow up when something that needed valid Unicode tried to interpret that bad Unicode. If I am not mistaken, that is how Julia deals: http://julia.readthedocs.org/en/latest/manual/strings/ 
Cool! Check this out and see if you want to pull. Tested on Windows and Linux, worked on both except for the last step (changing wallpaper), but it DOES download the images to the temp folder.. Cheers &gt;https://github.com/concacid/wallpaper &gt;https://github.com/concacid/wallpaper/commit/afd6e89bddb9f27cd5e1e7f71d0d10fe5ff4b6b0
The IPython notebook is great as a training tool, as well as an actual environment. It also gets installed with Anaconda. Seriously worth checking out!
The author of the linked post appears to be unable or unwilling to accept that the English-centric roots of Unix, Posix and Linux are unable to associate metadata with individual data streams to identify the encoding for non-binary bytes. There is no standard way to distinguish a stream of latin-1 keyboard characters from streams with latin-6 or latin-2 characters. Using a Unicode encoding such as UTF-8 requires us to distinguish between binary and text streams but allows us to represent a large percentage of Unicode code points in the text streams. This is a much simpler problem, with a more elegant solution, than the alternative where we have binary plus a multitude of differently encoded text streams. Until the OS and filesystem can store metadata about a data stream or files contents such as text/binary or text encoding, applications will be forced to guess this metadata themselves. Python3 makes it easier to simplify the required metadata to the question of test vs binary, with an implied encoding of UTF-8 for text.
Nice, thanks a lot!
&gt; The simple fact is that a compiled Python would have to include the entire python interpreter to have feature parity. I may be completely off base, but I would have thought that a Python compiler in the way the OP is asking about it would use the interpreter to decide on types and then would compile to native code, and so you would wind up with a small and fast executable, just as you would with a compiled C program. The Python interpreter would not be needed in that resulting file. (Actually *doing* this is problematic, of course).
Oh wow...I felt like I have just been hugged...eyes a little wet :( I could never go to an Ivy league school, I am from a lower middle class family and sometimes, I felt trap by my circumstance...but that is another story. However, it’s nice to know I’ve helped someone perceptively far more intellectually superior than me [You went to Ivy, I went through school of hard knocks], thanks man, really kind of you :) 
&gt; Python 3 improvements, including the ability for `pip install` to install all ported modules. Huh? I thought twisted only supported python 2?
&gt; It seems that the relative dead-end of v.2.7 would make life a lot simpler for me. I really don't care about Unicode. It will. Especially if you don't care about Unicode. 
I get that Armin runs into pain points with Py3, but on the other hand I get annoyed with the heavily English centric criticism - its easy to think Py2 was better when you're only ever dealing with ASCII text anyway. Fact is, most of the world doesn't speak English and needs accents, symbols, or completely different alphabets or characters to represent their language. If POSIX has a problem with that then yes, it is wrong. Even simple things like french or german accents can make the Py2 csv module explode, while Py3 works like a dream. And anyone who thinks they can just replace accented characters with ASCII equivalents needs to take some language lessons - the result is as borked and nonsensical as if, in some parallel universe, I had to replace every "e" with an "a" in order to load simple English text.
The point is that Python 3 oversimplifies things, making several things around text/bytes handling harder to do intelligently. 
Here is the most up to date list of ported modules : ~~https://twistedmatrix.com/trac/browser/trunk/setup3.py~~ https://twistedmatrix.com/trac/browser/trunk/twisted/python/dist3.py#L33 (thanks /u/takluyver! ) You may also have a look at https://twistedmatrix.com/trac/wiki/Plan/Python3, although the lists there are probably a bit obsolete (the rest should be relevant though.) 
They have a limited Python 3 support since 12.3.0 : https://twistedmatrix.com/trac/browser/tags/releases/twisted-12.3.0/NEWS#L23 It's still not a complete port though, see [my previous comment](http://www.reddit.com/r/Python/comments/25cs8q/twisted_1400_released/chg1ae2), but it's slowly improving after each releases...
Awesome, I'll check it out. Thanks!
Ah, I see. Great point. I haven't programmed outside of Python, so I guess in C you could never have a line akin to print input() + input() for this reason; is that right? 
mechanize :(
&gt;I think that there are languages that some CS people adopt just to impress other CS people. Scala, Node.js, F#, etc. I have no experience with Scala or F# but there's a pretty good reason that lots of people are adopting Node.js - it allows you to build up web infrastructure quickly using only Javascript. Not a bad thing to bridge the divide that typically separates front-end from back-end. I don't want to start a language crusade in the comments thread but I'd imagine there are plenty of good uses for Scala and F#. Can we just let that slide and give them the benefit of the doubt? 
For the record. I'm with you on that. I can code python 3. But 2 is just easier
Once again Nerd Rage doesn't = Helpful. R is Growing and so is Python. I can make an R script that is faster then Python (data.table) R is the open source remaking of S so it's origin is 1976. Python, while I love it, isn't really best of show for many programming projects. To learn Python and just program everything with it isn't really a selling point to me. There are better tools for almost every project that Python can do.
It's because you're going through the index of every character in the original string, but you're shortening the string in the loop (with the `string = string[lns:]` line). Ie. you start with a 19 character string, but on finding the first space, you cut out the "Arnold ", then later the "Palmer" (which only happens by chance because the lengths are the same), and try to index position 8 or on a string that is now 4 only characters long. [Edit] BTW - I take it the intent is to find the last word in the string (ie. the "90" here)? If so, you can actually do this a bit more simply with the .rindex function. This searches the string from the right (`.index` searces from the left) for a character, so you could actually write this as just: def get_section(string): return string[string.rindex(" ")+1:]
Your loop doesn't stop after you update string. The value of string_length is no longer valid for new string. It seems like you could accomplish what you want with &gt;me.split()[-1] 
TL;DR: you start the for cycle with range(string_length), which mean that I will go from 0 to 18. But you modify the string with string = string[lns:], which mean that the string is not 18 characters long anymore. Longer version: You calculate your string_length (18) and start the cycle. Everything works fine until you hit i=7, which mean that string[i] == ' '. You do a string = string[7:], which mean that string equals to 'Palmer 42 90'. You can see that 'Palmer 42 90'[7] is another space, so you increase lsn and do string = string[8:]. Now string become '2 90'. Next cicle, you try to access string[9], but len(string) is only 4 characters long now, and thus you go out of range. [By the way, a debugger could help here :)](http://81.4.126.121/i/1399915488.webm)
Pro: trivial code works. Con: Exceptions randomly thrown in a part of the application that has no relation to where the problem is. Possibly not even soon after the non-unicode was read. I prefer to fail fast. Makes it that much easier to fix.
fabfiles are already pretty simple. what is this buying us ?
I've made an effort to list several articulated points and even provided sources to back it up. That's called arguing. All you do is saying "R = almost as old as COBOL", so cool it with your insults, champ.
Large, high-dependency software maybe, but I've been using Python 3 for years and would not say it's only 6 months mature. Unless OP specifies otherwise, saying his software requires legacy support, I'm gonna lean towards the 5y/o, stable, modern branch of Python. You wouldn't tell someone to use Office '98 to open a document "just in case", so I see little reason to here. Python.org-&gt;download-&gt;3.4-&gt;add to path-&gt;terminal/command-prompt-&gt;pip install pygame. IF pip doesn't work because it needs to compile something and you're on a WinMac machine, go download a pygame installer instead and use that.
It's a very begrudging process but I'm glad to see progress. They're one of the last major libs to update.
1. I don't see any great issue with dict() vs {}. I actually agree with you and prefer {} but saying dict() 'bad' is a little extreme 2. You're mistake about dict([....]) - it is being passed a list of 2-tuples and therefore has to be the constructor rather than a literal 3. I didn't know the Django ORM would implicitly cast strings to ints. I rather wish it wouldn't 4. 'models'. Yep. I actually use 'item_models' everywhere else in the code but slipped up here.
&gt; But unlike the newcomer to Python I wanted to make sure the application is as stable and Unicode supporting as possible for both Python 2 and Python 3 and make it possible to unittest it. Well that's your first problem. If that's your goal, you should be using something like `six` or you're going to have a bad time.
I am not saying they are bad. But they aren't as general purpose as Python. They are more specific, as you mention node.js being webby. I just find that people who adopt things like Scala seem to develop a complex where they justify over and over how dumping Java and switching to Scala was one of the most brilliant things they ever did. I find that they felt conformist using Java and a rebel using Scala. The other thing that I find CS people now doing is looking at these non CS people building rather brilliant things in Python and suddenly they are trying to trash talk Python like people do PHP. "Oh that is just a scripting language. But real men use (fill in the compiled language here)." 
This is exactly what i was looking for! Can't wait to try it out! Keep it up!
Most recent one I ran into was html2pdf. Some libraries I've run into say they're supported, but you can't get them to build in 3 using pip. Some (like various mysql connectors) have python3 versions, but they're missing features or unmaintained. Some annoyingly have slightly different names in python 3 (e.g. python3-foo instead of python-foo) or worse, slightly different APIs; which means if you're trying to prepare your python2 codebase to be easily portable you've got to do a lot of version-checking and aliasing in your imports. FWIW there are things to like about Python3, and I'd like to move all my code to it if I could. I keep running into roadblocks with various libraries, though. It gets better, but I have no idea when we're actually going to see the kind of library coverage like we have in python2.
Once again this is why we can't have nice things! Listen to mom and if you dion't have nice things to say then.... Never said "R = almost as old as COBOL" Just it is from 1976 which is when S was introduced. COBOL is from "Amazing Grace" Hopper in 1959. Not one insult? You called me a chump. List one insult I made?????? R is good and you can make a living using R. R it is a good choice. Python is also a choice. Stop the Nerd Rage they are both fine for what they are made for. There is no BAD language except maybe Esoteric Programming Languages. 
Lots of R in that thread :)
Ah, interesting...I wrote my own functions for reading/writing when I was using DLPOLY. R has an interface to igraph so I also used that a bit, but I was not aware all of these tools existed. But yes, associating coordinates with atom types in data frames was very useful, though sometimes slow.
I need probably a bit more marketing to be convinced, but I'd use such a tool. Salt and Ansible are probably overkill for simple projects (specially single server ones), and developing your own scripts on top of Fabric is, IMHO, a waste of time (there is a lot of wheels and best practices to reinvent).
Personally I would never use it, but here's my feedback: Why must I have to put an ini file in every subdirectory? Why not just have an ini file in the root directory and feed in specific information through there? How extendable is this? I.e.: if I wanted to write a handler for SVN instead of Git? Other than that, I don't have much else to add as I don't use deployment systems (unless you count using git pull). It seems nice and if it fits your needs then awesome, but with the complexity of having to maintain an ini file in every directory/module, I don't think it'd find much use elsewhere.
Py2 *is* better because it doesn't suffer from the points Armin lists. Sure Py3 means developers don't have to learn how to Unicode till much later, but when something like this comes up (and dealing with UNIX filenames is hardly an edge case), Py3 puts you in a world of pain. With Py2, you have to be aware of Unicode pretty much all the time, but at least it works. Py3 makes entirely false assumptions (that all text is or can be Unicode), that are way harder to work around (as in the article). That a lot of Py2 code blows up when presented with non-ASCII is bad coding, not something inherently wrong with the language. Accents do not make the csv module explode: Unicode does. I've been using it for years with umlauts and what-not. You decode the text *after* processing it with csv. Sure, that ain't ideal, but it's a problem with the csv module, not Py2. It's certainly a smaller problem than the whole language pretending everything is Unicode when it ain't.
As the author pointed out, sometimes you just don't need to know the encoding to work with the data. Except with Py3 you do because it wants to pretend all text is Unicode.
I guess I should have been more One of my favorites is Sentry https://github.com/getsentry/. Granted, their product is actually a service, so the code is secondary. 
Thanks! Also, good to know Canonical provided some funding to scratch their own itch and get the ball rolling.
&gt;Py2 csv module explode, while Py3 works like a dream. Not for me. With py3, I've had to import codecs module to decode csv files that I opened with urllib urlopen. There is an issue ticket opened for adding a decode= parameter to urlopen (). Until it gets patched, you'll need to use the methods in the codecs module. This isn't some unusual use case. This is a common occurrence. So yeah Py3 is better, but not quite there yet. There are plenty of gotchas with using it when you deal with strings and files on a frequent basis. EDIT: Here is an [example](http://nbviewer.ipython.org/gist/pybokeh/b0beb36a08c2fa2d8a80) where I had to import codecs and use its iterdecode() method.
&gt; With Py2, you have to be aware of Unicode pretty much all the time, but at least it works That's an unusual take, because I'd describe Python 3 in exactly those terms. Python *2* lets you ignore unicode until someone uses a non-ascii character, and then it all falls apart. Python *3* forces you to use unicode from the beginning, but then it doesn't blow up the moment someone uses an é. The pain points with Python 3 are mainly when you really want to be dealing with bytes, such as raw stdin/out/err streams on Unix, and it expects you to deal with unicode. This is slowly being improved, for instance by [PEP 461](http://legacy.python.org/dev/peps/pep-0461/).
The actual list now seems to be in another file: https://twistedmatrix.com/trac/browser/trunk/twisted/python/dist3.py#L33
&gt; Python 3 forces you to use unicode from the beginning, but then it doesn't blow up the moment someone uses an é. Except it does blow up suddenly. Everything works fine, until you run your program via cron, or via SSH, or ... and everything blows up, because the locale is suddenly set to C instead of something.UTF-8. Of course, it *only* does this when someone uses an é. 
hi. i completely agree, fabfiles are simple. The problem is, once you reach a certain amount of scripts, they are hard to maintain. What i mean is that a deployment is hardly ever just pushing your code to the server. Sometimes you have to stop / start some daemons, prepare virtualenv(s), do some other stuff. My original fabfile was growing and growing in size, and it was hard to maintain. But i guess the thing which i was missing the most was keeping track of project dependencies (i have a project which consist of not only a backend in django but it also has several workers. when i was deploying the code i had to keep track of what is the current stable version and which was already deployed. Now i can specify this in the ini files and the script takes it from there ;)
Wouldn't say suds sucks, but its far from perfect. When it does work, its pretty dang easy and friendly to use.
Hey, sorry I missed this. There's no need to duplicate the logic. That's only there to demonstrate that the two are equivalent. I could be clearer on this front... EDIT: updated the README. Hope this clears things up.
my problem with one ini file is that every submodule of my project can have a little different specification, which would be hard to describe in just one file. Here's an example: i have a `main` application (written in django), several `slave` workers [by worker i mean a network daemon which has just a socket and uses an internal protocol] (some of them written in django, some of them written in pure python with sqlalchemy). each of the modules has a 'stable' and 'testing' version of the code. By using several files, it's very easy for me to describe those values. (Otherwise, i wouldn't know how to specify that for some of the modules i need to call manage.py syncdb / migrate and for others don't). Also, if the version of a module changes, i can change just one value and the script would re-deploy just the module(s) that have been affected. A handler for SVN would require to have some kind of 'version' describing. If i remember correctly, SVN uses the notion of 'revision' which are numbers, so the section would be in the form of [release:stable] revision = 1234 The code which handles git is 25 LOC. I guess SVN handler would be similar in size. git pull is not enough for me - as i have written above, in my scenario the complete deployment consists of several additional steps.
that only helps with those python dependencies. having python-pgsql in there doesn't magically install postgresql server and configure it and all that. 
It *only* does this when someone uses an é *and* does not specify an encoding explicitly. Since Python 3 attempts to implicitly guess an encoding in far less cases than 2, it's still way better. Also, this is completely unrelated to the stuff outlined in the blog post, which is about Python 3 treating things that are *not* text as text. And, well, let's be honest: the only place this *is* a problem is `sys.argv` on UNIX. Most of the stuff Python 3 code in that post consists of is there simply because it tries to implement what Python 3 tried so hard to avoid: implicitness all over the place. I mean, there are special cases for when `sys.stdin` is not a text stream or `sys.stdin.buffer` is not a binary stream! All of that based on a single assumption drawn from [a clearly incorrect piece of code from the docs](https://docs.python.org/3.4/library/sys.html#sys.stdout)! (Go on, I dare you, try running `sys.stdout = sys.stdout.detach()` in a CPython 3 REPL. It's not as cool as using ctypes to change the value of 1, but still.) And, apparently, it doesn't matter that documentation for `TextIOBase` [explicitly states](https://docs.python.org/3.4/library/io.html#io.TextIOBase.buffer) that `something.buffer` is always binary. If you remove all that nonsense, [what you're left with is this](https://gist.github.com/pyos/deb7abbe2adbc11f96e7). Doesn't look nearly as bad as Armin makes it out to be, does it?
I suspect an X-Y problem here. Do you have a C/Java/Pascal background? Iterating over chars like this isn't typical for python. Here's a snippet that is supposed to give you a hint about rewriting your code (no, after a quick glance I have no idea what exactly are you trying to do, this would be a nice addition to your question - to state the problem you are trying to solve): In [1]: me = 'Arnold Palmer 42 90' In [2]: print me.split() ['Arnold', 'Palmer', '42', '90']
i'm not trying to compete with either of those. it's just that each of them has something which feels kind of `itchy` for me. for instance, i wouldn't want to use ruby nor yaml files. The rule of thumb for me was that if our admin gave me credentials for new machine, the script would have to take it from there (i.e. setup necesary directories, create virtualenv(s), push the code, prepare supervisor scripts and so on. one other thing was that i never really liked fabric-way of passing command-line arguments. it was doable, but unreadable (i.e. fab deploy:branch=foo,restart=True,something=bar) if i were to `market` it, here it goes: - it supports dependencies - it supports 'releases' - which can help if you have components written by different developers. When time comes, the developer changes the branch / tag of latest stable / testing build and the whole project can be re-deployed - it's very easy extendable - it can pretty much `bootstrap` the whole application, i.e. if you input the necesary credentials, it will create the directory structure, setup virtualenvs if needed - it's by no means restricted to python, i.e. it's equally easy to deploy static angularjs app like to deploy django project. - it's easy to adjust the deployment procedure to what you normally do (i.e. it's not you that have to adjust to the tool, it's the other way around ;)) 
well, i was hoping for an inside view of the code itself. For instance, i was hoping if someobody pointed that.. i don't know 'dude, your signaling code looks like total piece of crap, you should have used xyz library instead' also, it's not that i created it because i discard other projects / frameworks. I have used them in the past, but didn't like them. Maybe somebody has similar issues and would find my tool nice to use :)
I don't see anything wrong with this code. You're fetching text data in an unknown encoding, surely you need to explicitly decode it before parsing? The only reason you didn't need to use `codecs` on Python 2 is because your file is in an ASCII-compatible encoding; you simply got lucky it's not UTF-16 or something: 0 # curl https://dl.dropboxusercontent.com/u/1929216/airport-codes.csv &gt;ascii.csv 2&gt;/dev/null 0 # iconv -f ascii -t utf16be ascii.csv &gt; utf16.csv 0 # python2 -c "import csv; print next(csv.reader(open('ascii.csv', 'rb'),delimiter=','))[1]" AAL 0 # python2 -c "import csv; print next(csv.reader(open('utf16.csv', 'rb'),delimiter=','))[1]" Traceback (most recent call last): File "&lt;string&gt;", line 1, in &lt;module&gt; _csv.Error: line contains NULL byte
i agree. although it would be possible to implement it, i personally wouldn't do it. I tend to trust the sysadmin better than my own scripts ;) that's why i use it for application deployment rather than server set-up.
If I sample my Twitter stream, it would tell me that me and most everyone I know, have been spending a lot of time in IPython Notebooks. Which is also my big prediction for the rest of 2014 -- someone will right an amazing IPython Notebook Cookbook/Hacks.
Has anybody actually tried to get a *cat* implementation working on Py3? I didn't think it was as hard as this article lets on. I posted this already on /r/programming, but I'm really hoping somebody here can explain why this Py2/3 solution is incomplete: import sys import shutil if sys.version_info.major &gt;= 3: sys.stdin = sys.stdin.detach() sys.stdout = sys.stdout.detach() for filename in sys.argv[1:]: if filename == "-": f = sys.stdin else: try: f = open(filename, "rb") except IOError: # this is probably a directory continue with f: shutil.copyfileobj(f, sys.stdout) Edit: /u/doug100500 [has a much better solution](http://www.reddit.com/r/Python/comments/25d0ug/everything_you_did_not_want_to_know_about_unicode/chg8b3d)
and the sysadmin, if they are any good is using chef/puppet/salt/ansible edit: and if they aren't using any of those, I wouldn't trust them.
&gt; Python 2 lets you ignore unicode until someone uses a non-ascii character, and then it all falls apart That's exactly what I meant. You don't get to ignore non-ASCII and expect things to work for very long. &gt; Python 3 forces you to use unicode from the beginning, but then it doesn't blow up the moment someone uses an é. But it assumes that all incoming text data can (and should) be converted to Unicode, which sometimes isn't the case. &gt; The pain points with Python 3 are mainly when you really want to be dealing with bytes, such as raw stdin/out/err streams on Unix. The problem is, this includes the extremely common case of UNIX filenames. The bottom line (for me) is I prefer things to blow up within my code where I can do something about it that makes sense in terms of what I'm coding, instead of having to work around Python 3's bad assumptions. Unfortunately, that means I have to constantly be aware of what's Unicode and what's an encoded string/bytes, but Python 3's decode-all-the-text! approach doesn't work when the environment (e.g. UNIX, sockets) is giving you text of indeterminate encoding. Python 3 is lovely for folks who don't have to worry about text encoding because they have a platform/framework that takes care of all that for them, but IMO the core devs screwed the pooch by removing the string APIs from `bytes`.
^ this.
Okay, so the reason Python generally needs a VM and cannot easily be compiled to native code is because it's just so dynamic. Its great power is a weakness in this respect. However, we have PyPy. Now, PyPy is a Python implementation written in Python, compiled to native binaries. Huh? How does that work? Well, I lied. PyPy isn't actually written in Python, it's written in RPython (short for Restricted Python). RPython is a subset of Python, which means every valid RPython program is also a valid Python program that does the same thing. However, there are Python programs that are not valid RPython programs, because RPython disallows certain dynamic features of Python. This means RPython _can_ be compiled to native code. It's all very cool. But yeah, a compiler for Python proper isn't going to be much use, because Python gives you so much freedom that a compiler needs to be able to handle at runtime, which means it'll have to generate bloated, slow binaries that would not be much different from a VM + chopped up bytecode, so why not just compile to bytecode and have a single VM on your computer instead of one for every program?
I'm not saying anything is wrong with the code, just pointing out that I have to import codecs and wrap around my file with a decoder. That's why there is a patch to add decode= parameter to the urlopen () method. That way it is just cleaner or more Pythonic instead of the programmer having to remember about codecs.
That depends on where you're getting your files from. Files created on the system are almost always going to use the FS encoding for their filenames. Files extracted from zip archives are a different matter. The same applies (or certainly used to) to files downloaded with BitTorrent. Note: I wasn't saying that filenames not using the system encoding are "extremely common" but that reading filenames from UNIX filesystems is "extremely common". And for better or worse, those are bytes, not text. 
WOW $200 !!!!!
If you use [requests](http://docs.python-requests.org/en/latest/), then the response object has an attribute `r.text` to get the decoded text.
No, but now that you wrote the code like this, I as the click library need to deal with the mess I wrote because `sys.stdin` is now a binary reader instead of a text reader. This is exactly the reason why this code is that convoluted.
Thanks I was aware of this. I just wish codecs was somehow "married" or integrated better with the various standard API methods that one uses to open files and not necessarily from URLs or at least a way to decode without added hackish API bloat as in my example earlier.
seriously, what even is this thing?
Hmm, I will need to check out IPython notebook and see how it handles pdb.
Yeah, I've used Rstudio a lot and Spyder is the closest equivalent in terms of layout and workflow. As others have mentioned, Ipython notebooks are great for data analysis as well.
this one looks promising : http://www.packtpub.com/ipython-interactive-computing-and-visualization-cookbook/book
heehee... scratch, itch, and ball.
The code he provided is unnecessarily complex. The following works fine: import sys for filename in sys.argv[1:]: with open(filename, mode='rb') as f: sys.stdout.buffer.write(f.read()) sys.stdout.buffer.flush() He's trying to handle the case where `buffer` doesn't exist. But that case only happens if you deliberately cause it by redirecting `sys.stdout` from within Python. Just don't do that if you don't want to have to handle it.
Good luck for your exams!
There's no need to pass a list comprehension to the `dict()` constructor -- if you're going to do that, get rid of the `[` and `]` and pass a generator expression instead. Also, using `\` as a line continuation is generally considered evil, since it depends on there not being stray invisible whitespace after the `\` for it to work. 
mysql, not sqlite. mysql-python is crucial binding if you use mysql in your project, and it's python 2.x only.
What are the arguments against making: PYTHONIOENCODING=utf-8:surrogateescape the default? Forcing Unicode output everywhere is certainly not the cleanest of solutions, but it seems a hell of a lot nicer then having scripts randomly explode just because somebody added an Umlaut into a filename.
I think the newer [io.TextIOWrapper](https://docs.python.org/3/library/io.html#io.TextIOWrapper) API is a bit nicer than `codecs` - it wraps a binary stream in another file-like object. It's what's used for text-mode file handles on Python 3. 
I recall that in the past Kivy used to support iOS and Android on 2.7 and not on 3.3, but it looks like Kivy now fully supports Python 3 according to their [FAQ](http://kivy.org/docs/faq.html#does-kivy-support-python-3-x). Forgot about opencv. Now that's one library I miss from 2.
You can get yourself ready for the eventual switch by doing from __future__ import division, print_function, unicode_literals, absolute_import Probably not on existing code, but when developing new modules. According to [Python docs](https://docs.python.org/2/library/__future__.html), everything was in future since 2.6.0a2.
Thanks, that guide looks thorough.
Thanks, that's very good advice. There is an issue with trying to make my life easier with regards to instrumental analysis. I work in a testing lab, so we have very strict protocol, and I cannot really change or add anything without having it go through everyone's approval. We get audited by our clients and they are very strict on protocol. But I think I am just getting ahead of myself. I would have to learn the basics anyway before I even get there. What exactly do you do? Do you see a lot of potential in combining these skills?
try this: c:\python27\pythonw.exe c:\python27\Lib\idlelib\idle.pyw
pyephem is a pretty useful module. My radio astronomy class has us use it to track objects.
I've lost count of the times I've typed this: import ipdb ipdb.set_trace() 
&gt;(\*) Websites are build on a Python framework called Django. Examples: Instagram, **Firefox**, Pinterest, even YouTube! Uh... no.
This is awesome, but UI needs to be cleaned up.
 import sys def set_trace(): from IPython.core.debugger import Pdb Pdb(color_scheme='Linux').set_trace(sys._getframe().f_back) def debug(f, *args, **kwds): from IPython.core.debugger import Pdb pdb = Pdb(color_scheme='Linux') return pdb.runcall(f, *args, **kwds) 
Specifically talking about websites, just replace Firefox with Mozilla &gt;Most of the code on our sites is HTML, CSS, JavaScript and Django (Python) https://wiki.mozilla.org/Webdev/GetInvolved Firefox does make use of Python as well &gt;* If you know Python, you can contribute to our web services, including Firefox Sync or Persona. &gt;* If you know Make, shell, Perl, or Python, you can contribute to our build system. https://developer.mozilla.org/en-US/docs/Introduction 
You can always make use of Alex's ctypes port of MySQL python. I wrote a CFFI version from it (performance in PyPy FTW!) at work Come to think of it, it might be better off to write a mostly pure python MySQL adapter and conditionally call into Cython if you're using CPython or CFFI if you're using PyPy. Then you can, with six, cross the divide of 2/3. I wish I had more reason to do it other than "because I can"...
In most python production stack for small-medium companies, PyPy is rarely used. "Because we can" is one thing, server melt down because dev version edge case errors during mid-night and you have to get up and fix everything is another story.
&gt; Being super pedantic about encodings can cause a lot of pointless complexity. Being lackadaisical can cause of a lot of pointless bugs.
&gt; In most python production stack for small-medium companies, PyPy is rarely used. &gt; "Because we can" is one thing, server melt down because dev version edge case errors during mid-night and you have to get up and fix everything is another story. That is why I mentioned Cython - as companies would use the CPython interpreter and you want speed. Cython is mature and well supported. I understand this is a lossy medium (Reddit) – but I would appreciate if the whole of my statements were read. I did try to take in consideration both experimental and production quality deployments.
nice ... but nothing really new. Crunchy (http://code.google.com/p/crunchy) had an web interface to the Python debugger in 2008. https://groups.google.com/forum/#!topic/crunchy-discuss/HT90YtkssFA (note that Crunchy, which has not been updated since 2009, does not support Python 2.7 - it does work with 2.4 to 2.6 and with 3.4 ... although the pdb feature may not be supported with the latest 3.x versions.)
From my understanding OpenCV is ported still. So its a matter of time but I have been interested in trying it out for several monts.
I think FP (and haskell in particular) is neat and all, but I really don't think they're beginner languages. I've gotten to the monad part of a haskell tutorial like 3 times and still don't know how to use them. I don't really see how haskell's any better at teaching recursion. Recursion looks more or less exactly the same in the two languages. (In FP you tend to use recursion more often (often because there's tail-call elimination, of course), but you can do the exact same thing in python. (Up to a certain stack depth of course) Same for modularization. In my opinion, there are likely some things that a FP programming language would be better at teaching. But these things aren't it.
&gt; but I feel like learning a functional language first Question: did you learn a functional language first?
I would push either python or Julia both are easy to understand and do not have those damn braces. 
We're always happy to have people contribute patches to port a module or two to Python 3. It's a bit tedious and boring, but it's a great way to learn the development process and get involved without learning a whole lot about the intricacies of Twisted or UNIX :).
UT Austin CS used Scheme for the first programming course. People with programming experience had much more difficulty than those who didn't. It's really hard unlearning imperative habits. Haskell is awesome for its type system, but I think something simple and forgiving like Python or Scheme is better as a first language. Introductory courses are about teaching recursion, paradigms, sorting and searching. The language shouldn't get in the way of that.
I am still sutdying, but I have seen quite a few examples where coding is handy. One of our lab engineers has to run a certain analysis from time to time for a researcher and the labreport is rather simple write. He decided to create a script to handle the mouse for the analysis program and starting the script that puts together the standardized labreport based on the results. This only works this simple because the results are either good or bad for the researcher, but the lab engineer saves a lot of time. He only has to prepare the sample and let the analysis script run. Same engineer wrote himself a little library while working for research several years ago, where the instruments would give him a .csv and it was a hassle to get the data into the precreated excel template. So again he wrote a little program reading the .csv file and calculating the results and exporting it to .csv from which he exported the data into his LaTeX report, so that he only pretty much had to write a discussion section. He made it a background task so that it tests a certain folder for new .csv files and if it detected a new .csv file the script would process it. Later the requirements changed quite a bit, but the formulas for calculation were mostly the same so he was able to reuse most of his old program and he said it took him 3 hours one afternoon and saved him probably weeks of work over the years. He did a lot of other neat little things and he is the most relaxed lab engineer at my university. Thinking of the instrumental analysis lab we have. I guess there isn't too much that could be automated except maybe little help for labreport writing if you can use LaTeX. I never tried handling .odt files in python. It heavily depends on the programs used I guess. We have some programs with an api and automation possibilities built-in and others that heavily relies on user input. All in all I think coding/programming never hurts learning. Even though I almost never can use it for my studies, it changed the view of data and how I use it. It even helped me writing better lab reports, because I learned the value of readability through programming. For example before I would create a quick'n'dirty excel sheet that I would need about an hour to get back into when I had to correct calculations. Now I already intuitively know how to align and name my columns. Another example is simulations. Sometimes I have no clue why and how some formulas interact with each other and then I write a few functions and plot it in matlab. This helped my understanding a lot in Physical Chemistry. Edit: Look into statistics and design of experiments. In germany companies love people who can handle statistics. Some bigger companies even require that you finish their in-house statistics course within three months or you're fired. Both fields can be heavily automated due to programming and it is something usually not taught at university so you have an edge over your rivals when trying to get into a new field. I am planning myself to write a simulation and use the simulation by DoE principles and put it online for my resume.
Not terribly relevant to the article, but the c++ code quoted here won't compile, as it's missing either a using namespace std; or std:: scope identifiers on cout and endl.
Why is Python so much more popular than Ruby for introductory programming courses?
I didn't actually, I learned Java first. But after learning Haskell I thought about how much better I would've written Java code had I had a FP background
I thought that was entirely relevant, because even for their example of bunch of complicated syntax they actually forgot even more complicated syntax which would have resulted in the program throwing an error!
Not OP, but I did learn a functional language first. In high school our CS1 course was taught with scheme (using How to Design Programs as the text). Then my freshman intro computer science course at University was taught in scheme as well (well, racket now) again using HtDP with SICP as an additional text. Additionally I was a TA for the course this year as we transitioned to python. I certainly am a proponent of functional programming as the way of teaching new students. For me it really helped solidify the idea of designing programs with building out of small blocks.
You can read it and understand what you wrote after more than a week.
Thank you, I use pudb, but this will come in handy.
What can you do in Perl that you can't do in C? What can you do in C that you can't do in Assembly? Functionally, Python and Perl are capable of accomplishing the same tasks. However, there are certain tasks that are easier or harder to complete in particular languages. For example, Perl has great regular expression support, but I find Python code to be a lot easier to read in many situations (and I say this having worked with both). If you're happy with Perl, then write Perl. Nobody here is trying to force you to learn Python. However, it is useful when approaching a problem to weigh your options in terms of languages and decide which language is better suited to the task.
Can or can't is never a very interesting framing; you can do anything in any language. It's all about how much effort is required to do something.
And then they will get to a data structures class and shit themselves when the find out ".sort" functions aren't going to cut it.
Just guessing here: Because it has less sigils, which might be intimidating to newcomers. 
Basically it comes down this: a different attitude is encouraged towards exception usage in each language, where in python they are encouraged to be used more than purely for exceptional circumstances. While in c++ they are there to be used purely for exceptional circumstances, errors, pretty much in c++ they are there to replace c's error code returning way of error handling. Pretty much though in both language it's a way to separate logic. Also because of what I stated above, in the context of python, py exception handling isnt that expensive, where as in c++ it is. But really, like Guido has said, from the start python never really cared about performance, it's a dynamically typed scripting language. Where as c++ is c with improvements and more abstractions built in, and c had to compete with assembler, so of course performance is important. However I think python encourages exception handling too much. Exception handling is basically a glorified, dynamic goto that strips the stack back to the catching function. Also python is awesome, but it's just a scripting language, and so many people, most who find c++ scary, seem to think python is a full on programming language, it's a scripting language. It's direct ancestor is the ABC language python got a big chunk of it's ideas from, language Guido worked on, was a language designed for people, lay people who found programming too hard and wanted it made easier for them, python comes from a legacy of dumbing down a language to pacify people who found programming too hard. My point is too many people are getting into programming, start with python, get way to comfortable, then think they are programmers. How are you a real programmer if you have no idea at all about how a cpu works, or a computer works. Why are we producing all these substandard programmers don't even have a working understanding of a computer? I find it just crazy to have a function that can take anything thing in any amount as input and can almost return anything. No this is not precision, python in guidos own words comes from an attitude of cutting corners, forgoing precision, these aren't compatible attitudes with good programming. So if you are someone who has only ever used python and you don't know what an opcode, register or pointer is. And perhaps you tried c++ one time but the compiler messages scared you away and the ease of slapping things together in python sucked you right back, then sorry to say but you likely aren't really going to ever be a really good programmer, a true programmer.
So they learn fundamentals w/Python and get to data structures and learn something else. Big fucking deal. I started with BASIC, and moved on to C++ a few years later. Data structures are NBD to me. Unless you want your intro class to be purposefully designed to weed out the "weak" (which, given that a great many jobs of the future are going to require programming in the future, is a really fucking shitty thing to do, and anti-humanity really) where "weak" is just "people who cannot into PhD-level CS."
The premise of your question is not valid. Anything is possible in any language - one should integrate all costs to compare the efficiency of both languages and ecosystems.
OpenCV. Template matching as a start.
It didn't as of 2002, when it was Java. Right now, it's still Java (looked it up). https://www.cs.utexas.edu/undergraduate-program/courses/312-introduction-programming I remember learning Java the summer before I started at UT so I'd be prepared for class (although I started with Intro to CS, not Intro to Programming). **Edit** Removed references to certain UG programs because mentioning them was kind of a douchey thing to do.
At least in engineering and science programs (which the author teaches in), Ruby is a non-starter since it has almost no support of numerical, statistical and scientific computing, whereas Python has a robust community with Numpy, Scipy, Pandas, Matplotlib, IPython and SymPy at its core with a huge ecosystem built up around those libraries. 
I'm going to go in a slightly different direction. My professional experience with programming languages basically reads like a top 10 languages for the last 30 years. But when I program in Python it makes me happy. My productivity is amazing. Basically I imagine it and poof, I have implemented it in few lines of code. When I do have to go back to C++ for various reasons I literally resent typing int, braces, semicolons, even the parenthesis around my if statements. I have realized that if I don't need to type them in one language then having to type them in another is annoying. Then there is the syntactic garbage that I end up polluting my C++ code with. While it is critical to making it compile it has little or nothing to do with what is in my head. It is like when making a beautiful knife that you then carve into the blade all the various steps involved in making it. While informative, they just take away from the beauty of the knife. 
If you're using python3, you could assume input() returns a string, right? Still, `eval(input()) + eval(input())` would break.
Why can't you teach data structures in Python? What am I missing?
[This post from 3 week ago might help.](http://www.reddit.com/r/Python/comments/23lmww/having_fun_with_python_and_opencv_finding_game/)
&gt; I open Perl scripts written by other people with dread, because there is the possibility that I will have no clue what is going on with their code. I also open up Perl scripts that I have written with dread too.
I learned how to make scripts for ~~translating~~ transcribing and manipulating swathes of data in 2 days. I learned how to plot really great looking graphs in 3 days as well. It took me a while (about a year) to *only* learn to plot the same shit on mathematica nowhere near as efficiently as i do with python. All thanks to mathematica's lack of auto-set labels, its crappy case sensitive syntax and the long and unintuitive operation marathons you have to go through in order to ignore certain parts of tables.
Which is exactly what I'm doing.
Yes, i'm a chemistry student and the raw power of python for numerical calculation and plotting is fucking amazing. What i did on mathematica in 15+ rather long and convoluted lines with lists, transpose operations, plot, listplot, show, mean, std dev, errplot + having to manually set labels and save graphs, i can do on python with 10 short and sweet lines which i can then copy and paste and make all my other beautiful graphs with no-fuss error bars, and have them automatically saved as whatever format i desire. Plus, i can run simulations and compile all the outputs into a mega output which i can analyse with any other program i want, or even python itself.
I guess you could. I've just never heard of it being taught with Python at a university. 
Oh yeah i use ipdb aswell but afaik you have to install it whereas pdb doesnt? Correct me if im wrong
Radass
&gt; sys.stdout.buffer.write(f.read()) Yeah, an indicative py3 code. It works fine for relatively small inputs. Also you use file object internals. There is a high abstract code?
Yeah, I know about the switch to Java. Haskell is no longer mandatory in the major either (CS 337). Dijkstra [formally complained about the department's switch to Java]( http://chrisdone.com/posts/dijkstra-haskell-java), but unfortunately passed away soon afterwards. Hell, the department went as far as using Java to teach OS for a few years until switching back to C after the backlash.
1. It's bad to not know your tools. But yea, it's not a big bad :P 2. "it is being passed a list of 2-tuples and therefore has to be". Eh. What? It's the other way around: it's a dict() therefore the param is passed as a 2-tuple. dict([(1, 2), (3, 4)]) should be {1: 2, 3: 4}. There is absolutely no reason to do the tuple dance in the linked code! 3. I can agree with that :P
If you don't know the encoding, you **are** working with bytes. Even if you call it a text string.
Have you seen project 'underwear'? * https://github.com/makaimc/underwear it's using ansible to deploy django project by using one file: * https://github.com/makaimc/underwear/blob/master/underwear/deploy/underwear.yml So you have all power of ansible and end users have simple one configuration file and additional fabfile.py. Roles can do anything not only nginx/postgres. You can create role for every your module and set dependencies between them. Role can fetch repository, run Makefile, copy files, run django commands, restart services like supervisord/circusd. And for end user you can provide simple file with variables, or even put variables at .ini file and add plugin to ansible reading this file. I don't know you situation, but i think it's better use and extend existing tools than recreate.
There is also [Shedskin](https://code.google.com/p/shedskin/). It compiles a subset of Python. The problem with a Python compiler is that if you want full Python parity, you don't get a fraction of the speedups that you might expect from a compiler, because almost everything has to be looked up at runtime in the general case. For example: class Foo(object): def __str__(self): return "Hello" class Bar(object): pass f = Foo() print str(f) f.__class__ = Bar print str(f) Bar.__str__ = lambda self: "Goodbye" print str(f) str = id print str(f) 4 identical lines have different output here because everything can change at runtime. For `str(f)` to work out which code to call, it has to do the `__class__` lookup, and then lookup `__str__` in the class dictionary, and its superclasses etc. And before any of that, even `str` itself has to be looked up in the current namespace, as demonstrated by the last one. This applies to everything - "a + b" has to do lookups at runtime to work out what "+" implementation should be called. Many other things about Python (e.g. `**kwargs` etc.) require much heavier *runtime* implementations of things as simple as a function call, compared to something like C, which was designed to be map onto simple and fast machine code. So, for the general case, a JIT compiler works better, because it can take advantage of the fact that *normally* you are not doing the kind of tricks I've done above, and very often some code that does thousands of additions, for example, will end up calling exactly the same "+" implementation. And this is what you have in [PyPy](http://pypy.org/).
hmm so if this guy is using ansible and fabric then he's extending, but if i'm using fabric then i'm suddenly recreating? if somebody finds ansible useful then by all means he should use it
be sane.
Wow, thank you -- 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Jaccard index**](https://en.wikipedia.org/wiki/Jaccard%20index): [](#sfw) --- &gt; &gt;The __Jaccard index__, also known as the __Jaccard similarity coefficient__ (originally coined *coefficient de communauté* by [Paul Jaccard](https://en.wikipedia.org/wiki/Paul_Jaccard)), is a [statistic](https://en.wikipedia.org/wiki/Statistic) used for comparing the [similarity](https://en.wikipedia.org/wiki/Similarity_measure) and [diversity](https://en.wikipedia.org/wiki/Diversity_index) of [sample](https://en.wikipedia.org/wiki/Sample_(statistics\)) sets. The Jaccard coefficient measures similarity between finite sample sets, and is defined as the size of the [intersection](https://en.wikipedia.org/wiki/Intersection_(set_theory\)) divided by the size of the [union](https://en.wikipedia.org/wiki/Union_(set_theory\)) of the sample sets: &gt;&gt; &gt;(If *A* and *B* are both empty, we define *J*(*A*,*B*) = 1.) Clearly, &gt; --- ^Interesting: [^MinHash](https://en.wikipedia.org/wiki/MinHash) ^| [^Paul ^Jaccard](https://en.wikipedia.org/wiki/Paul_Jaccard) ^| [^Hamming ^distance](https://en.wikipedia.org/wiki/Hamming_distance) ^| [^Most ^frequent ^k ^characters](https://en.wikipedia.org/wiki/Most_frequent_k_characters) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chgq99s) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chgq99s)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I teach Python to my first year computer science students. One of my favorite lessons is import turtle. I use it to teach the concept of functions: a function does one thing and the flow of code is from the top to the bottom. I also introduce documentations (turtle module) during this lesson. To start the lesson, I usually ask them to write the following code: import turtle turtle.forward(100) I ask them to describe what they see. Next, I ask them to add the following: turtle.left(90) Again, I ask them to describe what happened. Then, I add: turtle.forward(200) turtle.left(90) turtle.forward(200) turtle.left(90) turtle.forward(200) After everyone gets an idea on what they are doing, I insert turtle.penup() somewhere there. At the end of the lesson, I give them a challenge: draw a letter. any letter. I have seen all the letters drawn with the turtle, including O. The students who look at the documentation usually figure it out and I'll get them to write their code in front to show the importance of reading the docs.
If by point 2 you mean: "dict() constructor can be replaced with a dict comprehension" - yes - I *know* that - I used a dict comprehension in version 3. That was part of the point of the poll. Version 1 wasn't meant to be exemplary by any means (and I didn't write it :-P)
Python and Haskell also means that people actually have a distinctly different tool. A lot of "using the best tool for the job" involves having a range of different tools rather than different variations on a theme.
'Underwear' just run ansible with preconfigured files, so you can still extend same config using all ansible features and provide preconfigured fabfile which I can modify or add more different tasks. When I'm using 'porter' , porter-admin uses only their own ini file with own directives and I cannot use other fabric features. What if every module could have own fabfile.py for build/deployment and porter just read dependency config and run all specific fabfiles in proper order giving them parameters like f.i. target host/directory? Or even which tasks should be fired?
Can you point out the resources you used to learn all these things?
Read it.
I forgot you loss the articulated points when you say R as a programming language is totally worthless crap. (And I get down voted and he gets an up vote :)
15 years ago I chose computer science as my major. They taught me Scheme and I wanted to jump out the window. It was a horrible first language. The projects seemed meaningless and every exercise was a pointless chore. We also learned java, which was way better, but my teacher barely spoke English. I couldn't understand the lectures let alone the material. I switched majors. Years later I picked up Python on my own. I am still a neophyte but I can at least code a project. I can use Ipython, pandas, matplotlib, regular expressions and other basic data analysis tools. It's real. It's applicable to modern business challenges. and there is no compiling. It's beautiful. 
I compare Armin's post to someone coming from JavaScript and doing `""+3` in Python and then complaining that it throws a TypeError exception.
Not sure why you got a few down votes. I just started looking into Julia myself and it seems pretty amazing from a computational point of view. It's just as readable as Python, and approaches fortran or C in performance. 
p.s. icon from http://gnome-look.org/content/show.php?content=162145
The problem with TextIOWrapper is that it depends on the new style streams with a very complex interface. Click uses it internally for instance but it needs a fixup class to pass arbitrary streams through it: https://github.com/mitsuhiko/click/blob/master/click/_compat.py
I'm not denying that at all, thanks for making sure they do work! but not everyone is as diligent. When I say this is english centric I mean it in a more general way - a lot of code does not deliberately handle the encoding, so on py2 it breaks but py3 it works. Therefore I dispute the claim that py3 is worse because it forces unicode, because for a huge class of cases that especially impact the non-english world it makes life a lot easier.
&gt; a lot of code does not deliberately handle the encoding, so on py2 it breaks but py3 it works. Except that's not true at all. *Unless* you used an ascii incompatible encoding there is a very, very low chance that you cannot fix unicode unaware code in Python 2. Show me one example (except for the csv module and the datetime module) where it's impossible to add unicode support trivially in Python 2.
Any chance you got the idea from Karel (programming language) the Robot? I noticed the [Java programming] (http://see.stanford.edu/see/lecturelist.aspx?coll=824a47e1-135f-4508-a5aa-866adcae1111) course over at Stanford uses that to ease students into the idea programming.
I can't honestly remember. The first time I started to teach, my students had trouble understanding functions. I chalk that up to my inexperience. Then I remembered the turtle library\*. Reading the documentation, I realized that I can show how functions can change the program's state. So I started with something simple: a box. Later, I realize I need to test their understanding so I asked them to draw a letter. In my first time teaching the class, after the students have drawn a letter, I introduced how to make functions by putting each student's letter code into their own function (e.g. def A(), def B()) and then called each function to draw their names. I dropped this afterwards when I realize that the student started writing functions badly. So I try to introduce other built-in functions first before showing how they can create their own. \* I don't remember how I knew Python has the turtle library (I known about logo before this though). If I read it from Think Python, then I was inspired by it. If not, then its coincidence. P.s. Sorry for the wall of text. 
No. This is the first time I heard of Karel.
&gt; Py3 doesn't require you to know the encoding. It requires you to know the difference between text and bytes. So does Python 2 if you don't want your code to fail miserably the first time it encounters non-ASCII. However, it also lets you work easily with encoded strings (or bytes if you prefer) as strings, and doesn't do dumbass things like treating UNIX IO as Unicode when it isn't. Python 3 does exactly that and—as the article makes clear—it makes you jump through a lot of hoops to work around its incorrect assumptions. 
I've listed quite a few of my complains that make the language feel like crap in my eyes. I'm not saying that you can't produce something nice with it (you listed a few high-quality libs yourself), but that doesn't change my opinion that the language itself is crap. 
Would you accept turtle.circle(100) for O?
Yes! Now go in front and show us your code. That's when I point out the importance of reading the documentation. Most of my students who found that function would code another letter. That's how I gauge their interest.
you can't ``import this``
&gt; Being lackadaisical can cause of a lot of pointless bugs. The bottom line is, you have to know your way around Unicode and text encoding/decoding with both versions of Python because it's going to bite you sooner or later either way. At least with Python 2, there's less "magic" going on behind the scenes, so when things blow up, it's usually something you've done wrong, not something Python is doing wrong. The former is easier to fix. 
Not sure about the google trend API but I know that the google search API is very restrictive in how much data you can pull at once.... So you have to throttle the requests or your IP will get blocked for a period of time.... Either way I would read the documentation on it and see what restrictions they have.
Even as a professional software engineer, I feel that syntax shouldn't be the limiting factor for development. I've changed my career path to actually avoid (for better or for worse) languages with problematic syntax. I'm disappointed that python isn't better at parallel processing, because it's probably one of the biggest problems holding it back. The syntax is superb.
I haven't spent the time to build a nice marketing website. I've just been busy. I've received a lot of great feedback though, and I'd love to hear from more people who read it.
LOL, another candidate for a comp sci course. All languages satisfying the simple requirements of a Turing machine are equivalent. So an exact same question is: What can I do in python that I can't do in brainfork?
Much clearer. Cheers!
&gt; brainfork Brain... From Wikipedia, the free encyclopedia (Redirected from Brainfork) Dang, I thought I'd learn a new language! 
Anyone know why PyPy + CFFI was slower?
The tenor of the answers appears to be that Python restrains me from doing certain things that perl allows. So it's kind of like the difference between my own car, which can go wherever I direct it, and a bus, which will go only where someone else has decided it can go. If you're adequately disciplined, I don't see why you can't write maintainable code in any language. I'll admit, my perl code is copiously commented - not so much because of the failings of perl, but because of the failings of my aging brain.
Few Questions: - What Python experience level is recommended to comprehend this book? Novice? - What format is the book? Cookbook? Tutorials? If you need any assistance with any marketable landing page assets, shoot me a PM.
Try defining and using a 2D or 3D array. That's always entertaining in Perl. :) Here is one way to do it in Python: Matrix = [[0 for x in xrange(5)] for x in xrange(5)] Matrix[0][0] = 1 
&gt; Not sure why you got a few down votes. Here are two reasons: 1. Whining about braces is a pointless annoyance. I've never seen any trustworthy source claim that brace syntax has hampered their ability to learn a programming language. 2. Julia is indeed promising, but it's new and hasn't hit 1.0 yet. It's one thing to teach it on a more focused course for scientific computing, but it's another to use it as a language for an introductory computer science course.
nearly free ! https://www.kickstarter.com/projects/1223051718/practical-flask-book-project/posts/527464
I think one of their lead people was working on asyncio for python 3. I suspect that'll speed up the remaining porting.
Everytime you use range (len (x)) You should *probably* be using either for i in x: print (i) or if you need the index for i, c in enumerate (x): print ("index", i, "has character", c) However in THIS case you can use str.split () to split your string into a list of words and then jsut return the last word: print (str.split ("arnold palmer 50 60")[-1]) Which is what i THINK you are trying to do, but it's difficult to grok your code and you haven't provided the problem specification. BTW if you remove elements from a list while iterating over it in the forward direction, you can run into difficulties. One common way to get around that is to iterate reverse and use list.reverse(). 
Python is converted into bytecode and the bytecode is executed by the interpreter. Python doesn't "translate to C" although some operations are implemented in C rather than in more bytecode. Look at Pypy if you need to run Python faster. For Python on Android, look at Kivy. Most of Android user space is Java which is also converted to bytecode, but the more rigid nature of Java compared to Python allows it to run quicker.
IDLE does work but it's very basic. I'd recommend looking at the free version of a professional quality IDE. Pycharm and Wing have free versions for non-commerical or student use. In my personal opinion, Pycharm Community Edition is slower and more complex while Wing Student 101 edition is a bit snapper and easier to use but has fewer features. If you need to use Windows versions of 3rd party python libraries you will find them [here](http://www.lfd.uci.edu/~gohlke/pythonlibs/) or you can the free version of a commerical "everything installed for you" Python like ActiveState, which bundles windows binaries and the Windows API.
Hello Massimo, congrats a you and the whole team.
google for "market basket analysis / support / confidence"
Seems like there are plenty of books on Flask popping up. I used this tutorial to get up and running... http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world
I feel very much the same as you. However, and maybe it's just me, there is something so satisfying about compiling your code into a binary.
You can buy it or better yet, get it for free at https://github.com/rpicard/explore-flask This is how books should be done. Free for all to use!
Let me get to my computer.
I remember creating a reddit bot that scraped for image links (from most sites) in comments that contained certain tag words and opened them with either openCV or simpleCV to do some facial recognition and FTP uploading for a response. I could see if I could find the code I used and post it to my git. It had an issue at one point where sometimes it would get an image link but the filetype would end with ')' as well as the filetype so it couldn't be opened. I had to call a function to check whether the link had that and remove it before processing the link.
I find that Python 2 lets a beginner find out how to write proper unicode handling code completely by themselves and with little clues - everything looks fine initially when you're only testing English. Then a while later, you'll encounter an invalid encoding error, and try to fix it. Then a little while later, the same thing later on. And on and on. Python 3 makes this painless and upfront from the start, with no magic. You can't double encode things, you can't pretend utf8 is ascii when it happens to be english. You realize the right thing to do right *from the start*, when you find something expects a bytes or unicode type. 10x easier to get *right*, and no need to *fix*. Needing to fix it proves it's broken in the first place. I've got immense pain from fixing Python 2 "yeah well mostly works" code to be correct in Python 3, but that's not because 3 is worse, it's because 2 was horribly incorrect and unclear in the first place.
It's not that it's impossible - the language wouldn't be turing complete if that was the case. It's that it's non-trivial and unobvious. Python 3 will give you a wrong type error the first time the code path executes, not the 11054th time when some enters an umlaut into something.
Yeah, I know. Why do you think I'm arguing about the dumbness of Python 3's trying to decode filenames on UNIX?
Yes I used a tool to make a python app file. Very nice; though very big. Kivy can make iOS apps and Android apps. Very very satisfying; but again a bit big. 
&gt; Everything works fine, until you run your program via cron, or via SSH, or ... and everything blows up, because the locale is suddenly set to C instead of something.UTF-8. This is the programming language version of blaming the victim. The environment, governed by age old tools, has given a completely inappropriate system encoding, yet somehow it's Python's fault. Even though it's trying it's best to follow the system when its given no hints, somehow python is the problem in that case?
I've heard from both novices and experts who said they got something out of the book. I wrote it with people who know Python and have been through the Flask user guide, and are looking to start building real apps. The format is that each chapter covers a topic. Here's the T.O.C. for a better idea of what I mean: 1 Release notes 2 Introduction 3 Coding conventions 4 Environment 5 Organizing your project 6 Configuration 7 Advanced patterns for views and routing 8 Blueprints 9 Templates 10 Static files 11 Storing data 12 Handling forms 13 Patterns for handling users 14 Deployment 15 Conclusion
Indeed. If anyone can't afford to pay at the moment, I still don't mind giving out a copy.
Be careful though. The git repo is out-dated and a mess in general. I'm planning to do a clean-up soon (maybe next weekend).
&gt; it's because 2 was horribly incorrect and unclear in the first place Funnily enough, I find the opposite. I've always been careful to test my code with non-ASCII input because I speak German, too. It just isn't that complicated (or broken) in Python 2. Encode/decode on IO boundaries and you're (mostly) golden (see the last few paragraphs for another trap that Python 3 *hasn't* fixed). Certainly, this is something that needs to be pointed out to folks new to Python, but as long as you test with non-ASCII input, it just isn't a big deal. &gt; Python 3 makes this painless and upfront from the start, with no magic. Except there *is* magic, and that's what causes some of the problems. Python 2 works just dandy with encoded text (as long as you're careful not to mix it with Unicode), but Python 3 tries to decode data it shouldn't using a charset it's basically guessing (on UNIX). Your Python 3 program seems to work just fine, but then you start it from cron/upstart and it blows up because the locale is now C, not XXX.UTF-8 and someone used an umlaut. And because that's built right into the language, it's much harder to work around than accidentally mixing `unicode` and `str` types in Py2. What's more, Python 3 doesn't even do Unicode "properly" to the extent that you don't still have to know it and think about it. It doesn't do any Unicode normalisation when decoding text, so for example, if you create a file on OS X called "üäß.txt", do `os.listdir` and compare the returned filenames to the string "üäß.txt", you won't get a match because the NFC-normalised filename that went in was NFD-normalised by the filesystem (and Python doesn't change it when it reads it back) but your Python string is still NFC-normalised. As I wrote above, you still need to know about Unicode and text encoding whichever version you use. And when Py2 blows up, it's usually easier to fix than Py3 because it's something you did wrong, not something Python is doing wrong *by design*. 
You mean "write-only"...?
http://en.wikipedia.org/wiki/Brainfuck
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Brainfuck**](https://en.wikipedia.org/wiki/Brainfuck): [](#sfw) --- &gt; &gt;__Brainfuck__ is an [esoteric programming language](https://en.wikipedia.org/wiki/Esoteric_programming_language) noted for its extreme minimalism. The language consists of only eight simple commands and an [instruction pointer](https://en.wikipedia.org/wiki/Instruction_pointer). It is a [Turing tarpit](https://en.wikipedia.org/wiki/Turing_tarpit), designed to challenge and amuse [programmers](https://en.wikipedia.org/wiki/Programmer), and was not made to be suitable for practical use. It was created in 1993 by Urban Müller. &gt; &gt; --- ^Interesting: [^Esoteric ^programming ^language](https://en.wikipedia.org/wiki/Esoteric_programming_language) ^| [^Leet ^\(programming ^language)](https://en.wikipedia.org/wiki/Leet_\(programming_language\)) ^| [^FALSE](https://en.wikipedia.org/wiki/FALSE) ^| [^P′′](https://en.wikipedia.org/wiki/P%E2%80%B2%E2%80%B2) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chh3dca) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chh3dca)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Good writeup.
http://nbviewer.ipython.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-4-Matplotlib.ipynb http://stackoverflow.com/questions/1796597/import-array-in-python http://dml.riken.jp/~rob/#talks I have those in my favourites, but i also used the python, scipy, and numpy documentation.
To be fair, in the OP's article, the author responds directly to that argument. Python obviously has some responsibilities to work in the environments you'd expect it to, bugs be damned at time. Clearly you and him don't agree on the scale in this context, but it's something that's obviously true about the language, and programming in general. 
http://en.wikipedia.org/wiki/Auto-erotic_asphyxiation
How do you *expect* people to react when Python 2 works but 3 doesn't? If it looks like a regression, swims like a regression, and quacks like a regression… No question, it's downright daft that UNIX doesn't specify and enforce a filesystem encoding (and zip, too, for that matter), but that is, unfortunately, the way it is, with no sign of things changing anytime soon. And yet, knowing this, the Python core devs went ahead anyway—practicality be damned—and broke shit that works just fine in Py2. The Py3 docs themselves say that you should use `bytes` for filepaths when using `os.listdir` and the ilk on UNIX, yet Py3 tries to decode the same filepaths to Unicode if they're passed as command-line arguments… 
80 lines is a limit that is used by many people. I, for example, have two views of 80 characters + a file list (SublimeText) which fits exactly at my 1920px wide screen. Files that are wider than 120 pixels would be less readable for me. It depends a bit on who has to read your code later. If only you write and read your code, do whatever you like. However, if others have to review or use your code, it makes life easier for them to stick to the 80's rule. Or, you could come to a compromis with them (cake helps). Something I'd like to stress: this is not a Python limitation; it's just a community-set agreement which is older than Python. 
 could you point to some resources that were useful to you in your studies?
Thank you! :)
A marvellous aphorism. Should be added to the Zen of Python.
Braces and semicolon are not the only problem, languages like perl are difficult to read and braces is an additional thing to manage for beginner. This is not wining if you are teaching someone and they have to deal with these annoyances it will deter them from learning. Furthermore beginners do not have to deal with memory management in python Python can replace matlab, octave, and SPSS with easy to use libraries. &gt;but it's another to use it as a language for an introductory computer science course. Julia is perfect for teaching other than the speed you can assign variables to unicode characters if you speak arabic, chinese, or japanese, you can assign variables in your language making it easier for people to understand. And Julia is NOT only used for scientific computing I can use it for finance and text processing, it has decent enough libraries. There are also library support for HADOOP. But you are right there are a few stack overflow problems and functions are still being deprecated and decided 
If you share your code in a blog or on github it may look much better in the browser if it is 80-char (sometimes I even use 70-char). 
&gt; Braces and semicolon are not the only problem I know. I didn't say they were. Your comment only mentioned braces, which are perhaps the least significant thing in the syntax of programming languages possible. (Hence the downvotes.) &gt; languages like perl are difficult to read For reasons *completely unrelated* to braces and semicolons. &gt; This is not wining if you are teaching someone and they have to deal with these annoyances it will deter them from learning. Have you taught an intro CS course before? I have, at least, taught parts of them a few times now. Whether the language we used has braces or not is literally a non-issue. Not once in the years that I've been involved has anyone complained that braces really made the task of learning a language harder. And as I said before, in addition to that experience, I've not yet heard from *any* trustworthy source that puts forth a serious claim that braces are a hindrance to learning a programming language. Now, you may have a minor annoyance with writing braces. That's cool, it's your preference. But choosing to talk about *braces*, of all possible problems with teaching someone how to program, is quite frankly ridiculous. &gt; Furthermore beginners do not have to deal with memory management in python &gt; Python can replace matlab, octave, and SPSS with easy to use libraries. I don't know why you're saying these things. I strongly urge you to re-read my comment. But yes, everyone loves to pontificate on what a good beginner language is. I was not doing that and I make a point not to do it. Opinions on that are a dime a dozen and most of them are completely useless. &gt; And Julia is NOT only used for scientific computing I can use it for finance and text processing, it has decent enough libraries. It's almost like you're going out of your way to purposefully twist what I said. I never implied that Julia was only good for one thing. That would be ridiculous. I gave **an** example of where one might want to teach Julia given its youth. Providing an example neither means that that example is always appropriate nor does it mean that that is the *only* example. &gt; But you are right there are a few stack overflow problems and functions are still being deprecated and decided Yes. As I said, the language isn't stable yet. By that fact alone, it's not good for an **introductory CS course**.
Yup, Regex was what I used for it.
Of course I did. How silly. Especially considering how carefully I tried to proof read my post. Sometimes we have blind spots when writing. At least I do, and I like a compiler/interpreter that catches my more stupid mistakes.
I'm not overly jealous of the 80 characters limit, I try to abide to it, unless it hinders readability of a particular line (say, up to 90ish chars). Long lines go against readability. There is a reason books aren't a wide wall of text. And code is meant to be read by humans, and after that, by computers. Use your common sense while trying to achieve maximum readability. Please excuse my poor English.
If you hit the start button and start typing 'idle', it might show up, it worked for me on Windows 8. On a further note, you may want to try [Classic Shell](http://www.classicshell.net/). It's open source and after installing I kinda forgot there is a difference in Windows 7 and Windows 8, besides some funky permission stuff when dealing with files on the C drive. 
I try to stay under 80 characters, but I'm not going to kill myself if I go over that. My hard limit is 120 characters (which is also the default limit in PyCharm - I was almost sure this was the PEP8 limit until I checked). At the end, if it's code for yourself, do what you prefer. If you're committing code to someone else or working on a team, follow the guidelines.
I'm still learning, and some of the code's not as good as it can be--particularly my first attempts. I'm kind of busy, at the moment (finals and final projects, ie reports). So for now, i'll link you to my mega folders, and when i'm less busy over the summer i'll set up a github account, smooth out some bugs in my copolymerisation program, attempt to clean it up a little bit (1.8k lines thanks to not knowing about global variables in functions), and i'll post them on the sub when it's set up. I also need to translate the comments to english. [3d-polymer visualisation](https://mega.co.nz/#!4d8UURYZ!f58LGGrWPwfZTv-pNxARHr1Kwq1_P6vTrGlwrat8R6I), (polyethylene) still needs a bit of work to get it to preserve angles and dihedral angles. I already know how to preserve the dihedral angles using vector projection. You can actually simulate polymers at different solvation time scales, or in different solvents if you modify the growth angle (phi). [Short tutorial i made for some friends for their polymer chem class.](https://mega.co.nz/#!tU8WhTqB!6Yi0bHoF0hv25rUI0eBGRqzw24Nf_R3WshWa6Aj0Z3s) [Output handling tutorial/function repository i made for a friend.](https://mega.co.nz/#!JYshjTLb!S-IZXDpd3cnX5yRKTBSSEWTpgtUORUUAzefG0AtcidA) Spectra plotting (with the spectra) [1](https://mega.co.nz/#F!YQcwzaQB!fuaBeDKKUDozauKAUk2mqg) [2](https://mega.co.nz/#F!oUlmWagB!GSse-BTJ9v4GxSzzVhmTLA) [3](https://mega.co.nz/#F!oUlmWagB!GSse-BTJ9v4GxSzzVhmTLA) [4](https://mega.co.nz/#F!NNcBUAxR!HNiGlDsAgQ1Gv13san5aQw) [5](https://mega.co.nz/#F!Ud81CZTD!H_KjM2dXngsohcWZIi49Eg) [6]( https://mega.co.nz/#!QcMxxTKR!hIrFLQfoLBvq05pHe5Y_YPD5v948G5DD4RkPcoxtvvw). Home-brewed selective ion electrode calibration curve and concentration calculations [1](https://mega.co.nz/#!IMNnRa5Z!q6pIMwEtwbUbAvxqoc5uRo09rVnI6rIkUf_GfngSCNg) [2](https://mega.co.nz/#!IU8WwYjA!ZHwrSa8wi_-xyT2xAk3Jc62YIR6uFutzTFn7KmQ-Mo8) [3](https://mega.co.nz/#!ME0HSQjb!2QHpEEzgvOrPEOpjtNSeTxIA31a8c_jyBrkc57ydNFc). [Copolymerisation script a modified version of my first, very cringeworthy, python program. The original was for my polymer chem class, this is for a stat analysis class. You can give how many replicas you want and how many different inputs you want. It uses inputs generated by another script, which uses a table which comes from minitab.](https://mega.co.nz/#!8RU2jSIR!CzrLE_pDu_D312fi1OXeFIp8at_PeQ63kKK0V5Z1ERE) This script can actually tell you the maximum number of contiguous As and Bs, and their frequency. It's an improved version of the original, but prints out less info, as it's useless for the class it's for. [Output handling script, compiles all outputs into the order minitab needs.](https://mega.co.nz/#!JQ0DRAKa!UkMgSbBTM1UieBYGzrY3gVlqeQYO5m3m5EO3_flJIXs) Inputs (from a minitab table) and the script which generates the inputs required by the polymerisation program [1](https://mega.co.nz/#!8UlyUCwA!M49EQIpVNeDnyU3OA-oIYukVEL65Wlg-p4TFuUYsXoQ) [2](https://mega.co.nz/#!BVMAHCQY!8wWkyn863lNZ_u3iXte1QEcdB43H5nuIhe1tUFtkVF0). I know it could have been easier to just use the inputs directly from minitab, but i wanted to learn how to practice making short scripts, and it was faster than trying to adjust the copolymerisation program. Original copolymerisation program, three versions, direct input and output, direct input and text output, and text input text output (they have a very rare bug--about 1 in 150 runs with a specific termination--that i solved in the modified version) [1](https://mega.co.nz/#!AJ1yHJIY!spT4boecvxJROtzVjYaIv0QyLIs7erurmc307s0JkgY) [2](https://mega.co.nz/#!AdVwjCYS!v1r7KZnG1pYiiDiUOfJr10fEH1OKftudcbxmiIF_IMs) [3]( https://mega.co.nz/#!AYlBzBIS!Uqif2pCnrCCyyu9UZdP5rEIi7lbBIIBtu7R37jO1tt4), the text input order and a text input example [4](https://mega.co.nz/#!gc0HxTCD!3nlkpY5C_v7xKlx-3FiJ_BFCl-sNPTizorNPY0DLwa8) [5](https://mega.co.nz/#!QIEVVDgY!yw-a5aYWttvBQxJi7FziMankdnFqsZGXq0I8pkK1Oq8). This program can simulate different types of linear copolymerisations. You can make block copolymers, alternate copolymers, alternate copolymers with different proportions of contiguous As or Bs. It's actually super awesome, and even though it's a fucking monster, i'm really pleased with how it turned out. All you need to do is modify the reaction constants and starting proportions. 
web2py had something like this for 3 years. This looks cooler anyway.
Congratulations!
Keep your panties on buddy. Your wording or phrase isnt all very clear. Have you even tried Julia? So what if it isnt version 1.0 or 2.0? No one says anything about using it for production.
thanks for this! I've never seen turtle in python (still starting) but it's a neat little module!
Cool! https://github.com/seedifferently/the-great-web-framework-shootout/blob/master/README.rst#do-these-results-have-any-real-world-value 
MUD game is go to project, you can keep it simple and then do more complex stuff
Looks simple and decent for your first code project! Any reason why your methods return either True or False redundantly? Edit: Also your next project should involve classes and multiple objects. That'll really stretch your programming muscles.
That's a good idea, thanks man!
I hate the 80-character guideline. It's outlived its usefulness and doesn't make sense at 1920x1080 let alone HiDPi monitors. Many people counter by saying that they can fit more windows on screen. That can be true, but it depends on your monitor. For example, I primarily code on a 2560x1440 in portrait mode. In PyCharm, I can fit about 130 characters along with the IDE window. I can't put two windows horizontally. It's either use long lines (I use 120 characters) or waste a ton of space. I think that it's entirely reasonable to expect people to have horizontal resolution of at least 1360 pixels (HD or better). It's harsh to say it, but if you don't have at least that horizontal resolution, you're the one that should adjust. [Wikipedia has a list of computer monitor resolutions and rudimentary statistics about popularity](http://en.wikipedia.org/wiki/Display_resolution#Computer_monitors). At least 53.84% of web users have a horizontal resolution 1360 or better.
Except that not having to cooperate is kind of an exceptional situation, unless you're a hobbyist. Those of us who write code for a living usually work in a team, and I can tell you one thing, when you program as a team, people *do* tell each other how to write code, because if you write unreadable code on my team, it affects everyone.
Try some of the project ideas from here: https://github.com/karan/Projects That repo has a bunch of different categories that might be interest to you (i.e. DBs, networking, graphics, web, security, etc.)
* E-mail - plain-text e-mail wraps at 70-something, even; throw in a few levels of comments, and you have yourself a fine mess in a mailing list * The human brain - reading comprehension is best when line length stays within limits, and 80 characters is pretty close to ideal (at least for monospaced fonts). The limiting factor, here, IIRC, is the moment when you skip to the next line; the longer the line, the harder it is to find the correct line to continue reading. For fun, pick a random book from your book shelf - an actual book, that is, properly typeset prose, ideally a novel or something like that; and count the characters per line... * History - 80 characters was a popular width for text terminals back in the olden days, and while nobody uses these anymore, a lot of software from the time has survived in one form or another, and optimizing terminals and terminal applications for 80 characters is still kind of a common thing to do. Yes, I know, you aren't using a terminal, you have a fancy GUI text editor, it's 2014, yadda yadda - guess what, lots of people love their vims and emacsen and their terminal programs, because they're fucking fast, they've been bug-hardened for decades, they eat close to zero system resources, and they can be used over a dial-up modem connection into a 400 MHz ARM machine, with minimal usability impact. * Side-by-side viewing. 80 is not a magical number here, it just so happens that a total of 2x80 characters plus a bit of extra space for diff annotations and scrollbars and the like tends to work out fine on many common setups - for example a 1280-wide display with an 8-pixel wide monospace font can display (drum roll) exactly 160 characters. None of the above is specific to Python though, and it's fairly common to see 80-character limits recommended for any given language. Python however adds a bit of an educational flavor on top of it; there seems to be a notion that the language and the programming style standard should somehow stimulate writing "better" code, by some (arbitrary) measure - a relatively harsh line length limit is supposed to force people to split up "complex" lines, which is supposed to make the code more readable. Personally, I think the best way to make code more readable is to hire better programmers and give them the freedom and the tools they need to do their job well...
Don't you worry about it, I've had three of those moments today, over two accounts. It's one of those days.
Nice, thanks! Would be good if there were solutions, but I guess they are general problems for any language, so I'm likely to find them somewhere on the interwebs.
Depends on what is your definition of unstable. When I learned Java in college in the 90s, it wasn't 1.0 yet. Julia is pretty much a Touring complete language. You can define functions, data structures, looping, etc. I guess MIT folks are batshit &lt;any hipster word&gt; crazy then.
nice. i like the cute way of swapping the player.
&gt; guess what, lots of people love their vims and emacsen and their terminal programs, because they're fucking fast, they've been bug-hardened for decades, they eat close to zero system resources, and they can be used over a dial-up modem connection into a 400 MHz ARM machine, with minimal usability impact. I'll add that *this* programmer's motivation for learning 'vi', was attempting to fix a failing software demo on a customer site, deep inside a DMZ, with only a bare-bones production VM (and no internet connection) to work with. I limped along with 'nano' for all of that day, and swore never again to be without a decent development tool. Since 'vi' is installed by default on every linux, just about everywhere, I'm never without something powerful at my disposal. I'll echo your remark that 80 columns works out really, really nice in any editor where you can do side-by-side viewing. But I wouldn't necessarily call old school editors out on needing such a line length. Vim works great sprawled out across a 16:9 screen, just as well as an old VT-100. I would argue that old *displays* help set that standard first, and we could all probably get along with anything in the 80-100 chars range, before people start shouting "everything's starting to line-wrap, cut it out." TL;DR: 'vi' is *everywhere.*
MIT is not teaching Julia in their intro CS course. Julia is unstable ***by their own definition***. The lambda calculus is Turing complete too. Maybe we should use that to teach programming in an intro CS course.
Nice job, good project to start with! What are you going to do next?
Compilers don't magically produce executables that execute a program faster than an interpreter does. In fact an interpreter might be able to outperform code generated by a compiler, especially if you don't have a lot of information at compile time, which is the case for Python.
Now do it in C/C++. EDIT: Allow me to qualify. Python is a TERRIBLE language to learn programming. I remember a student i had while a TA in grad school. We had a test on conditionals and he bombed (it was the first test). He was trying to argue for a better grade on the basis that *if -&gt; otherwise*, was the same as *if -&gt; else*.
Congratulations! Completing a first project like this is a major accomplishment; too many people just quit after copying some code from tutorials and never trying something on their own. To me, your code looks clean and well organised. I'd like to ask you a couple of questions about it: 1. Will the line 7 `return board` ever be called? Would your program work the same without it? 2. Under what condition will line 72 raise an exception? Would your program work essentially the same without the try/except clause? One last comment: on line 2, the "normal" Python idiom would be to use if board[position] is not None: which, in your program, would probably turn out to be easier to follow.
I always find it admirable when people find the energy to start programming themselves. You've got a lot ahead of you, and I wish you all the best for your next steps. Don't give up and it's going to be great! Have fun :)
Are you a kth student per chance? ;)
There's a big blue text that says "Solutions" and links to [Solutions](http://github.com/karan/Projects-Solutions)
Hey, I'm a vi evangelist myself, no need to convince me ;) Just saying that both vi and emacs were originally designed with 80-column displays in mind. They do work fine on larger displays, but hey, they also work fine in an 80-column terminal emulator inside a tiling WM or a tiled screen/tmux session. Common scenario for me is to have four terminals open, doing things like code in one, tailing logs in another, man page in a third, and random other stuff in the fourth. And they're all 80 columns wide, because I set up my WM this way, because I know that my tools work great at this particular width.
Umm, could you specify what you mean? I've little knowledge about how/what/why certain things return certain values. If I knew what part of my methods were redundant, I wouldn't have made them that way.
PEP8 was recently revised in a number of ways: http://hg.python.org/peps/rev/fb24c80e9afb Specifically it says 99 is ok now. Not quite the 120 you wanted, but better than 80 in any case.
The IDE can do it, but it doesn't make any sense. I just checked, and my IDE (with my font settings) can display 141 characters wide in a 100% wide editor buffer. [Here's a downsized screenshot](http://i.imgur.com/HjEJPkf.png) of how I use my IDE with 120-character lines. I added a white line since the wrap indicator is difficult to see if you're not familiar. [Here's a screenshot](http://i.imgur.com/CE2ps2X.png) of windows side-by-side on the same monitor. I can adjust the bar in the middle, but I only have 132 characters to use. 
If by *k*th, you mean a student of any grade *k*, then yes, I am. elif by kth you mean some particular school that's probably more clearly called KTH (because it's obviously an acronym), then no. 
God damn my ignorance. Thank you kind sir! If only I had looked harder than just surfed the page quickly. Thanks!
1. You make a good point. I don't *think* it's ever called, so I wonder why I put it there in the first place. 2. In any case where the raw_input() returns an error instead of a value, which I'm not sure can happen. What happens when raw_input() is given no input? Is it just the string "" or an error? I'm not sure. Thank you for the feedback, btw.
Python isn't a terrible language to learn programming with. In fact, many colleges have it as their first language. I would argue that Python is an excellent first language because the student doesn't have to deal with confusing syntax/header files/compilation and can focus on the core programming concepts. Obviously they should be exposed to other languages like C/C++ to learn about memory management, types, compilation, and other advanced concepts but Python does a great job as a first language if the goal is to teach basic programming ideas like functions, objects, basic I/O, conditionals, loops, etc.
I'm not sure! My friend suggested hangman, which seems like it'd be a challenge. Do you have any good ideas I could try?
If you're feeling up to the task, try making a version where the computer can play against you!
% string replacement is deprecated, use format() instead! It helps generate code that's 100 times more readable too.
I know the arguments for python, i happen to disagree with them. Types, memory, pointers, compilation, linking, and the like are far more important and you get OOP, functions, IO, conditionals, loops, etc along with it. EDIT: OOP may be too much for the novice, which is also why i dont like python as intro. C should be taught for intro, then C++ for second semester.
[It isn't free?](http://flaskbook.com/)
My first thing in python was a tic-tac-toe too(plus GUI w/ xturtle)! Congrats!
You are looking at this from an very narrow scope by teaching you only mean ***teaching for CS*** I am looking at it at an more broad scope to Undergraduates (same as the topic). I have taught people with no programming skills who have no interest in doing programming except for speeding up some of their task or avoid doing redundant task. If you are say only for the purpose of CS then I would say Java or C are good choices. 
Quick question: Why is it deprecated? And also how is format() used?
Yeah hangman is a good idea. Is there anything you do on a daily basis that could be automated? 
&gt; He was trying to argue for a better grade on the basis that *if -&gt; otherwise*, was the same as *if -&gt; else*. Would you mind elaborating on that? I've not looked at C since high school, but I don't recall if-otherwise being a thing (I remember if-else), nor am I aware of any such construct in Python. Linguistically, the two seem to be analogues, so I can understand the argument there, but as a predominantly Python programmer, I wouldn't ever make that argument. That aside, maybe /r/Python isn't the best place to try and convince folks that Python is a bad language to learn/learn on. It's pretty widely regarded as one of the best languages for beginners to learn, due in large part to its combination of simplicity and depth/power. 
You've been coding too much for one day, friend. Just take it easy, and think how cool it would be if you were from kth. 
Probably go with Hangman, good practice. 
You remember correctly, there is no such thing as "otherwise." The kid was arguing that "else" was the same as "otherwise." But this is why i would argue python is not a good choice, to the veteran "if X in" is nice. To the learner, i feel python is too close to vernacular. It wont generalize well.
+1 for `elif`
I'm a small business owner with a ton of very repetitive tasks that are done on a daily basis. These tasks eat up my time significantly. I've been looking into ways to automate them, mostly by looking at Automator for Mac, but is very limited and basic. I've been thinking about investing some time and effort into learning Python during my down time (I'm part of a very seasonal business), but I'm not sure if I can automate the tasks that I am doing. I'm aware that Python is a powerful programming language, but I'd like to describe some tasks and see if they are doable or not. Could I describe a couple things that I wish to be automated, and see what you think? 
I can't make sense of your comments. You don't introduce programming with an unstable language. I have never, in any walk of life, seen braces in a programming language hinder one's ability to learn that language. It is such a trivial part of learning how to program that your incessant focus on it has become comical.
Modulo operator for formatting strings is not deprecated... It is a well supported and widely used legacy syntax which is generally more performant for many typical use cases. The newer str.format method is more flexible and supports a bunch of stuff that the old style doesn't, but replace the old with the new largely seems to be a code style preference if both work in the case at hand....
Supposed to have been deprecated in 3.1, but looks like the official deprecation is still in the air.
&gt; You probably know that it claims super-generic CLI names like convert and identify, but that’s just the tip of the iceberg Including one that always hits me: *import*. I keep ending up with huge screenshots of my screen in random directories named things like "sys" or "os" because I accidentally type into a shell window rather than a python prompt.
It can be very error prone and in general has less functionality than format. "Hello {name}".format(name='Dave') Hello Dave
... You know you don't have to jump into OOP with Python? It has functions, which you don't even need to use. 
If you get bored make sure you take a look at [Project Euler](https://projecteuler.net/) for some more problems to solve with python(or any language). 
What's the point of manually breaking lines into 80 characters anyway? Don't all modern editors have built-in wrap abilities?
I found a bug, On Python 2.7.5 if you play to end the game, it will go through an endless loop, allowing you to only choose "yes". This is due to the nested while loop and break only working on the current, nested, while loop. This change fixes the bug: http://pastebin.com/wS4wQjba Otherwise, great job! Continue making cool things.
Honestly? Your code looks pretty nice. I say *pretty* nice because it doesn't follow [PEP 8](http://legacy.python.org/dev/peps/pep-0008/) perfectly. Python's style guidelines are something of a religion, and they help make your code look familiar to other programmers.
It's not deprecated, just discouraged. my_string = "This is a string {0}".format('yay') instead of my_string = "This is a string %s" % "yay" You can also name and number things to be replaced, lots of things. my_string = "Hello, {name}".format(name=user_name) The documentation covers all the various options and formats. 
&gt; s = "like this" &gt; print "You use it {}".format(s) Produces &gt; You use it like this There's plenty of formatting options that you can put inside the curly braces, very similar to the formatting using %
&gt; OP here. I do a lot of web scraping, statistics, graphics (now by constructing html5 &amp; jason files to run in a browser - yeah, it's a kloodge, but perl has no significant graphics capability). In that case you should be fine with Python 3. I am doing a lot of what you just listed as a data analyst. Looking at the other people's comments, some people really don't have a clue as what is ported to Python 3 or not. It's a shame really. Just adds to the confusion. From my experience using Python3 for at least a year, I have not run into a case where I couldn't do what I needed to do for work because something wasn't ported over.
Yeah, go ahead. I am sure you would be able to find a way to incorporate python into easing that workload. 
Congrats!
Nice catch! I noticed the same retesting my code and implemented the same solution. I'm glad you let me know, though. All this feedback is awesome!
I have to agree on this point. To me, at first PEP8 read like somewhat arbitrary standards to make code pretty, and the documentation itself didn't really try to convince me otherwise when I started working for a company that adheres to it. But after writing code to PEP8 standards for some time (strictly, by having a linter yell at me when I didn't), I just like my code better for it. Smaller logical chunks, better structure, cleaner layout, I don't know. It's just better.
If you are working on an open source project then 80. But, if this is an internal project then you and your team (if there is one) need to establish a standard and stick to it. Personally, I prefer 100 and its what my team uses at work.
I thought I was replying to you, but it was someone else with an M name. The response is under marsman12019, right above you. Thanks!
In your winTest() method you return True for four cases. That might be an issue later down the road (I mean with other projects; instead of all True, maybe pick an int or other value to return to be discretional.) I guess it's pretty non-redudundant the more I look at it. It was just weird when I first saw it.
Nice! Seems similar to my Tic Tac Toe program I made recently! [Here](http://pastebin.com/fqHbGSMa)
Funny. I'm annoyed when they don't.
From the docs, raw_input() only return an EOFerror when it reads "EOF" (End of File), which I guess can only happen if someone pipe a text file into your input. Also I guess it could raise an UnicodeDecodeError if someone input non-ascii text.
Just upload it to your github repo already!
I'm a High Schooler as well, and at my school they have a website that teachers put grades on. My first Python project was making a tool that scraped my grades from the website and put them in a text file. Just choose something that you are interested in :)
My current setup is a notebook with a resolution of 1024x600 I believe, and I fit 2 windows side by side on the same screen. Needless to say I prefer 80 characters per line... Even with a big screen such as yours, I have like 3, sometimes 4 windows side to side. But I guess, not only the number of characters per line count, but also the whole setup, like don't sizes and such. It looks like (?) you are using big fonts which keeps you from having more than one window; I would consider this a waste of space :)
Yeah, definitely possible. nofunallowed98765 give a good starting point. Not much to add to that, but these are ideal tasks to automate. For handling the emails I would suggest giving pyzmail a look, might make things easier. 
Correct me if I'm wrong, but it's basically a set of functions that are more convenient/easier to use than what's beneath the wrapper. So in your example, you write Python functions that call the C functions. But the next time someone wants to use the C functions, they can address your Python code (which should be more logical/convenient if you are already working in Python). Does that make sense?
I've been using Emacs since v22, it's perfectly fine with more than 80 characters in a line. Let's not give these young folks the wrong impression.