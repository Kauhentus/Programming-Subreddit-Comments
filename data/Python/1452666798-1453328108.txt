Perl has been on 5 for ages (the odd/even bit is in the second part - 5.23 is "pre 5.24" which in turn would be a stable version) Perl 6 was just released but it's basically a completely new language.
Right, but all of that seemed like too much explanation for a simple joke. 
You're right. First I thought the solution just resembles a partial (I was mislead by desmoulinmichel's answer ... shame on us! :)), but it really adapts a container like a list or tuple, so that it can be used multiple times without calling it directly. That's actually pretty nice.
What about just sticking to python 2 or python 3 in a script, and not trying to get it to run on everything? I think most systems have python 2 and python 3 installed, so it shouldn't be a problem to expect slightly older versions to be installed.
I test this I would probably fire up python with a gui debugger and step through the code and sanity check the result of each line. But really my question is why are you manually controlling all the loops and manually doing the checks? Because your code is so verbose it is actually quite hard to read. If you cant read it easily you cant understand and reason about it easily. Here is what I would write: (apologies if code formatting doesn't work correctly on my phone, ill correct it when I get home) numbers = [] amount = 5 while len(numbers) &lt; amount: new_num = random.randint(1,69) if new_num not in numbers: numbers.append(new_num) print(numbers)
Bash
Using a list comprehension for side effects is ugly. You expect it to return something instead of mutating. And I guess that confused you when you wrote: `random.shuffle([random.shuffle(c) for c in a])`. You're shuffling the list returned by the list comprehension here, which is [None, None, None], and the order of the sublists stays the same. /u/bearsfan654, I'd recommend to use a normal for loop: random.shuffle(a) for sublist in a: random.shuffle(sublist)
Hello rharsh11 Your welcome, I'm just a user that tries to help here. Best you ask the [Gramps developers directly on the mailing list](http://sourceforge.net/p/gramps/mailman/) or follow the link I provided above to Github for them. 
&gt; sock absorbing 😆 Is the script somewhere else? What modules etc were used?
I just write my code so that it fails on Python 2
I guess I just have a load of Robust PCA type algorithms ported from Matlab to Python and it would be great to have them in a proper package I could rely on rather than my adhoc scripts!
This is good advice and also one of the more common causes of weird debugging problems in my experience. I would add that using `try` blocks should be for when the behaviour in the `except` block would be *truly* exceptional. If you expect a fair chunk of your input not to have the attribute you're looking for then I believe the `getattr` solution is more semantically correct, and will be faster.
and Emacs ! http://wikemacs.org/wiki/Python it has nothing to be ashamed of, for python at least.
Nice implementation. I have a couple questions about the differences between this implementation and the original VAE. 1.- In this new implementation, the author uses an encoder with 2 hidden layers(while in the original work they used only 1 hidden layer). I guess theoretically this is not a big deal, but I'm curious about what is the motivation to do it. 2.- In this implementation "softplus" is used as an activation function instead of "tanh". I'm also curious on the motivation for this too. I mean, activation functions at the output layer are conditioned by the output we want, but, can we change the activation function in hidden layers without hesitating at all? (assuming we are using a tool like tensorflow that calculates the gradients) If so, why not go even further and use a ReLU to speed up the calculations even more?
The title should be more specific "Never use hasattr() to check properties", for methods it is ok!
Well, i can understand why it's breaking, but please note that None can be a valid value. So in the end, only try-except is safe for every approach.
I would recommend you to watch the talk [stop writing classes](https://www.youtube.com/watch?v=o9pEzgHorH0) by Jack Diederich. A function to execute your algorithm would just do the job as well, without the boilerplate of wrapping it in a class with a pointless constructor. May I ask you if you have a java (or the like) background? Because this is exactly what happens if you try to apply patterns from languages like java into python. It works but is simply not considered pythonic. 
The only time I can see OP's solution being useful if when you pass it to a function that : expect an iterable AND is coded in such a wrong way that it expect only non generator AND your generator is not a generator expression and need to be called (or you need to wrap it) AND calling list() on your generators is too much of a performance cost. That's a lot of if.
Surely we shouldn't be using such logic in the first place? I don't think I'd like to maintain an extensive code base that has to deal with multiple python versions within a single script. That just seems like it could get very confusing -- especially if a Python 4 ever does exist! Of course, sometimes using such logic is *un*avoidable... but IMO it should be *avoided*.
He kind of let go of the reins in about 2012-13. Starting accepting ridiculous PEPs willy nilly
The equivalent in rst is """ @type input: str @type n: int """
Hm, my impression was good python code usually prefers `try` `except` as a clause instead of the alternatives... do you disagree?
Exceptional behavior is localized. Hitting the end of a list isn't exceptional, unless you're the one managing the iteration. 
I agree with the try-except: it is what I'd expect, handling only exceptional cases. The meaning of hasattr is clear enough to justify fixing that use case instead fixing the code.
and @returns: int
Or create a unique singleton.
It's a really good talk, it took me two screening to completely grasp his point but it was well worth it!
Yea ok, that's better.
Hmm.. maybe "declaring variables in too liberal scopes, i.e. global instead of inside a function, global instead of inside a class, etc" might be even better?
Still doesn't work since the method could be returned by `__getattr__` for example, which could raise arbitrarily.
The title should be "upgrade to Python 3 already"
Are you sure? The first snipped shuffles the lists, the second snipped shuffles the contents of each list, but neither does both. **Further**, even if you do both, each list will still contain the same elements as they did before being shuffled. That is, if the contents were [1,2,3],[4,5,6],[7,8,9], 8 will never end up with 5, 1 will never end up with 7, 4 will never end up with 2, etc. Is this what you want? If instead you just want to shuffle all the elements, probably the easiest way is to write a function that flattens the lists, shuffles the new list, and rebuilds the original 2D array.
I've shown non pythoners and they consistently don't get when else is called. Else being called when the main block succeeds seems odd. Not that I avoid it. It's just weirdly named. 
Learning Python well in one day??? I've learnt Python on-and-off for over 4 years and I still don't know it well!
I would support this. If the author can't get on board with python 3, going so far as to actively discourage its use, 8 years after its release, I can get behind not encouraging folks to check him out.
What's wrong in the f-strings syntax?
I ran into a similar bug in Matlab. When displaying a class, Matlab runs all getter methods, but suppresses any errors they raise. Unfortunately this class represented an RS-232 object, so the low level I/O got out of sync due to a hidden error, and the next command would fail. That was fun to debug.
I did "learn python the hard way" in python 3 and learned both 2 and 3 by doing so.
Automate boring stuff with python, as linked in the op
[Program Arcade Games With Python And Pygame](http://programarcadegames.com/) is a great book for beginners as well.
can i suggest using requests module instead of urllib? in [docs](https://docs.python.org/2/library/urllib.html) you can see See also The Requests package is recommended for a higher-level http client interface.
+1 It also teaches old things, such as distribute, nose, and web.py.
I just started moving everything I can to 3.5. My co-workers are still on 2.7. When they asked why I told them that it gives me a few more years before I have to listen to "Why the hell did he write it in 3.5". And for people that are new to programming, that day is coming. Python 3, Perl 5, PHP, Fortran, COBAL, C, C++ eventually what you're using will be old.
Flask works fine on Python 3. I'm the newest maintainer on the project, and use 3 exclusively. At least in the Flask ecosystem there is no reason not to at this point.
Python9000
What's the alternative to nose?
The teaching method it uses is outdated and is widely discouraged. No point in using it unless you're a masochist. 
&gt; it's still one of the best python books ever written It's decent, maybe, but one of the best?
Strangely enough, `hasattr` is slower on python 3.5 ([test code](https://gist.github.com/ionelmc/553372b9322a3edcccfe)): -------------------------------------------------- Name (time in ns) Min -------------------------------------------------- test_tryexcept[withattr-cls] 159.9998 (1.0) test_tryexcept[withattr-obj] 173.0760 (1.08) test_hasattr[withattr-cls] 214.9987 (1.34) test_hasattr[withattr-obj] 219.0465 (1.37) test_getattr[withattr-cls] 231.5776 (1.45) test_getattr[withattr-obj] 234.9989 (1.47) test_hasattr[without-cls] 562.4970 (3.52) test_getattr[without-cls] 575.0007 (3.59) test_getattr[without-obj] 642.8537 (4.02) test_tryexcept[without-cls] 657.1437 (4.11) test_tryexcept[without-obj] 733.3292 (4.58) test_hasattr[without-obj] 1,399.9816 (8.75) -------------------------------------------------- Can anyone explain?
The web server is sending the response with gzip compression: &gt;&gt;&gt; response.info().get('Content-Encoding') 'gzip' The standard library doesn't handle decoding this automatically. Normally that's not a problem, because a server is only supposed to use compression if the client specifies that it can handle it via the presence of a request header like `Accept-Encoding: gzip`, which `urllib2` does not add. But this server is misconfigured and is violating the HTTP standard. You can decompress it yourself easily enough: import zlib import urllib2 url = 'http://dados.coperve.ufsc.br/vestibular2016/resultado/vestcac03_LinkCursos.html' response = urllib2.urlopen(url) content = response.read() if response.info().get('Content-Encoding') == 'gzip': content = zlib.decompress(content, 16 + zlib.MAX_WBITS) Note that `content` will be a byte string, but you really want to be working with a character string, so you should decode it. The encoding to use should either be present in the response headers, or in a HTTP meta header. In this case the page is encoded with ISO-8859-1, so you'd then want to do something like: decoded_content = content.decode('iso-8859-1') That will result in a unicode string, i.e. a string with character semantics, as opposed to byte semantics. That's what you should be working with whenever dealing with text, not a byte-string. You could also consider using a third party library like `urllib3`, which is the basis for the `requests` library. Both the gzip decompression and the character encoding will be handled automatically, so that you can write just: decoded_content = requests.get(url).text 
Related, here's a list of the tutorials we (sopython) do recommend: http://sopython.com/wiki/What_tutorial_should_I_read%3F. This and the other page were inspired by the multitude of users who would join chat to ask a weird question sparked by LPTHW.
You shouldn't have to defy the teacher to get a decent education. The book should go.
&gt; It's widely regarded as using old and tedious teaching methods. [citation needed] You've said this twice without backing it up. The L_tHW method has been the most helpful for me in learning new languages, although LPtHW's content is certainly outdated.
distribute, web.py, nose... And on top of that archaic python 2 syntax. Even if it is the best, you are still learning bunch of things that are useless. Other people are saying that they are working on updating it. I say put it back once it is updated, currently it is just confusing.
Yes. Python 3 has compelling features not present in Python 2 and increasing support for concurrency and type/interface checking.
Author's attitude and misnomers are funny yet sad.
Before you think that it's too much of a corner-case, consider how you would implement Python 3's `range` in pure Python. You'd almost certainly end up with a design similar to the OP's pattern. &gt; is coded in such a wrong way that it expect only non generator It isn't necessarily wrong to write a function which assumes its input is a collection of numbers, as opposed to an iterator or generator. See: [here](http://www.effectivepython.com/2015/01/03/be-defensive-when-iterating-over-arguments/) or below for some examples.
*self. This isn't r/javascript, get it together! 
I prefer nose2.
I second 2achary's comment about stepping through the code in a debugger, but if you want to stick to the console (ie you are debugging remotely) I highly recomment pudb (console based graphical debugger - https://pypi.python.org/pypi/pudb)
&gt; LPTHW is being updated for Python 3. ... and when it is, it can be added back. It's one thing if an author tells an impressionable learner: &gt; At the time of this writing, Python 2 is a better choice because [reasons] It's another to present learners -- who have no sense of the context in which it was written -- with unqualified invective like the example in the OP. The sell-by date on that advice has long passed.
Yes. Personally I don't like how it teaches, it didn't work for me, but I'd be happy to see it return when it's updated or at the very least the py3 vitriol removed. If you're going to make strident claims, it's on you to keep them up to date (he was right at the time).
Sure. It is done. Edit: I'll put the LPTHW link back up when Zed finishes the Python 3 update. Remember that his Python 3 admonishment is really out of date, because that's a very old resource! Also just a general reminder that when you're learning things, you should also be critically evaluating the resources that you are using to learn with; just because it says something in a textbook, that doesn't make it true.
I have him set as a friend on Reddit and it's amazing how often I see him pop in. He also seems to answer just about any decent question on /r/inventwithpython .
good point! I pushed an update and its a function only now. I was thinking that at some point, I would be adding multiple methods that potentially shared the same input phrase. As in different password algorithms and such. But you're right, at this point, there is no need. Great video BTW.
There is use in learning by rote for some things but programming is not one.
[py.test](http://pytest.org/)
The [r/learnpython](https://www.reddit.com/r/learnpython) subreddit might be more helpful.
[I guess](https://matt.sh/howto-c)
Learning through repetition is only part of it. The author also encourages you to get an actual environment up and running. There are other good resources for sure but a while back it seemed like the other options were things like code academy where you are walled off in their little web interface garden. 
What is the use case for else vs just having additional commands after the potential exception but within the try? try: # open a file # process the file except: # the file doesn't exist, populate default data else: # process the file again?! I don't get it. finally: # clean up What would prevent you from taking any try/except/else and moving the else block to the end of the try, and then removing `else:` The only situation that wouldn't work is if else could end up throwing the same error that the initial try did, and where you DO NOT want to handle the second instance of the exception. In which case the outer code has to handle it, which means the outer code is ready for it, so why am I handling the first instance at all? def divide(a,b): try: result = a/b except DivideByZero: print("you tried to divide by zero, but don't worry I caught it") result = None else: # You may think I just handled DivideByZero, but I didn't cause I'm an a-hole: a/0 finally: print("fooled you") return result
Read the list of complaints. He genuinely suggests that people should memorize boolean tables, instead of learning about boolean logic. That's a terrible teaching method. The book jumps into stuff like making your own hash map implementation all of a sudden, despite the reader not being anywhere near that level yet. 
&gt; you should also be critically evaluating the resources that you are using to learn with; just because it says something in a textbook, that doesn't make it true. This is excruciatingly true, I know this is a python subreddit, but take this advice everywhere with you in tech. There are books on my shelf that are obsolete on chapter 2 because 18 months after publication standards changed etc. (ed: my point being you can't really tell sometimes as you read! This is particularly hard because you're probably reading a book because you're uneducated on the topic, which makes it difficult to know when you're being spoon fed something incorrect, outdated, inaccurate....... ;)
But the author of LPTHW has a point. Many project I'm interested in use python2 and don't support python3 :-P Examples: idapython, angr, pydbg, vivisect.
&gt; Is this what you want? Ah, I should've asked that, too. I assumed OP wanted to shuffle the sublists separately like iamaziz did. /u/bearsfan654, if that's what you want, do you need help with flattening and rebuilding the list?
Yes, I actually tried to search for your post, but couldn't find it anymore. :)
I first learned to program with lpthw :( I found its method extremely helpful coming from a place where I had no programming experience and was very intimidated by syntax.
The only complaint I needed to not use it when I was first getting into python is that it reads like its written by an angry, condescending manchild. Edit: teach me to not click through, that's #2 on the list.
Actually I was referring to a file on my local HD, but I've probably ranted publicly before as well, yeah.
IMHO - that is a very biased viewpoint. Outside of the purview of enthusiasts, Python 2 does not look to be going away. One of the biggest important pieces of Python software released - Tensorflow by Google - is Python 2. Flask is going to be Python 2 for a while. Django recommends Python 2 unless you're sure all your extensions are Python 3. I fail to see why Zed is wrong. At this point, I think it should be acknowledged that Python 2 is NOT going away. Not in 2020 - unless you want Anaconda or someone to create a fork. 
But if you're learning you're also lacking in resources to make those decisions. 
&gt; In math and science, rote methods are often used, for example to memorize formulas. There is greater understanding if students commit a formula to memory through exercises that use the formula rather than through rote repetition of the formula. Newer standards often recommend that students derive formulas themselves to achieve the best understanding.[2] Nothing is faster than rote learning if a formula must be learned quickly for an imminent test and rote methods can be helpful for committing an understood fact to memory. However, students who learn with understanding are able to transfer their knowledge to tasks requiring problem-solving with greater success than those who learn only by rote.[3] This paragraph from [wikipedia](https://en.wikipedia.org/wiki/Rote_learning) sums it up well. To his credit he tries to do problem based learning, he just doesn't do it very well.
Same as you, for sure. I am not arguing agains super per se, I just have an impression that the whole approach of overloading (instead of defining) some methods is less usable than it could seem. Especially, if we are talking about super, it's killer-feature is diamond problem resolution. It is way cooler than what we have in C++, but, let me confess: I never used it for anything good. The last phrase was unsuccessful pun to (Python's super considered super)[https://rhettinger.wordpress.com/2011/05/26/super-considered-super], probably most well known article on super().
Your best bet is probably using cron to run a script at certain times a day. Well, at least on Mac or Linux systems. Not sure what the Windows equivalent is... Can you explain what system you're on and what you're automating?
&gt; I learned to use nouns and verbs before I knew what they were called. But you didn't have a teacher giving you *other* names for them. &gt;connotations of things like x and y-axes and Euclidian space If you think of Euclidean spaces in response to the word "function", I have to wonder how you were taught math :) x and y axes are a perfectly fine thing to have in mind; the "x axis" corresponds to input, and the "y axis" to output.
Thanks! That's awesome to hear because that's pretty much my plan 
I learned from it too, but in hindsight, I realize that there were many better choices and I can't really give LPTHW credit for where I am now. 
pyglet seems more bare metal than I would like. I would rather have simiple structure over the rendering system to decrease complexity. I'm used to using MonoGame so I'm trying to find a suitable python type of replacement. I'm in a python class this week so I figured playing around making games would be a fun exercise but it seems python doesn't really target much of that at all.
Generally that just means you have to compare different resources while considering their age and reliability.
One thing I didn't see on the list was that it's just not very effective heuristically. The book constantly prescribes things like memorizing lists of terms and reading things backwards, neither of which I found particularly effective. Also, from I remember, the conceptual/theoretical stuff was either non existant or poorly explained. If a tutorial/beginner/intro book isn't great it's not a huge deal, but this one actually held me back by proporting that the "hard way" was the one and only way to learn. Ironically, I wound up learning much more effectively with C, and than coming back to Python.
As a musician, that seems kind of ridiculous. We practice things over and over again *until* we get them right. Because we can't do them the first time. There is no skill in typing code from a web page into a text editor and running it -- you can do that right the first time no problem. It's a completely different method of learning, I don't know why he would think those are equivalent. 
You want Python to end up a dead end language that never updates, refuse to use anything that isn't python2. Otherwise, use Python 3, and bitch whenever some library *still* hasn't been migrated. It's been too fucking long. It's time to change.
I think it's pretty useless because you don't explain what you're doing. There is a total lack of docstrings. You're using os.system and import *. You're also hardcoding the client ID. You have globals everywhere. It's also not Python 2/3 compatible.
Is it perl6 yet? No. They're a good example of how to do it wrong. We need to do better, and adopt the new standards.
What problem are you solving with Jupyter? And I am not sure, but what is Scheme? The programming language? How are Jupyter and Scheme related ... are you using a scheme kernel in Jupyter? Edit: Why the downvote?
&gt; I'll put the LPTHW link back up when Zed finishes the Python 3 update Thank you. It is one of the best resources for the beginner who is not looking for spoon feeding.
That's who it was written by
LPTHW is for a pretty specific audience - people completely new to programming - one most people that would be subbed to /r/Python do not fall into. But everything has to be perfect for everyone I guess.
Can be summed up in one complaint: 1. LPTHW is out of date.
[Why.](https://github.com/search?l=python&amp;q=def+__init__%28this&amp;ref=searchresults&amp;type=Code&amp;utf8=%E2%9C%93)
I think if you are going into a Udemy course looking for a certificate level class, you are the one messing up - Udemy is pretty good for getting entry level intro into stuff. Coursera and general assembly are much better for certifications
I disagree, in that I think it's for people with a specific learning style. "Direct instruction" is a well documented teaching style with a lot of well documented criticisms. And it was never intended to be a student-to-book system. Having a teacher go through the exercises with you is a huge part of how direct instruction is supposed to work. There is a subset of people who work well with LPTHW's style, but they certainly aren't a majority on this subreddit.
Sure. Nouns were "thing words". Verbs were "doing words". I'm a teacher. One of the worst things you can do is start with a bunch of "jargon". Basically, you're just showing off how clever you are while confusing (and possibly alienating) your students. It *is* important to know and use the right terms for things (to avoid confusion), but there's a time and place for that, and it ain't chapter one. With the vast majority of learners, it's better to start with something concrete and work towards the abstract (like the proper names of things). Similarly, starting with files before control structures is a solid idea: you can do real, useful things with files. If statements don't achieve a whole lot in isolation. 
His method is *okay* (Seriously, he does a lot of things bass ackward), but his tone is a huge problem, *especially* for beginners. I'm not saying we should treat new developers like special snowflakes and spoon feed them everything. But seriously, how many *good* teachers are actually condescending douchebags to their students?
I think "Learn Python the Hard Way" still has value - it's one of the only resources out there that actually starts from a total beginner's level. A lot of resources claim to, but actually start from a programmer's idea of what a beginner is. 
I started with a need to process spreadsheets. Reading 3-5 documents and producing another 2. Next up was a gantt chart drawing program that output its results into PowerPoint slides. These days I'm calling APIs to pull reports for my department. My team has specific needs that the current reporting system can't deliver. Finally, I'm playing around with a Raspberry pi. I want to be told the time, weather, and how long until my bus as my alarm clock.
I agree that Zed's tone is a huge problem for some people. Personally I don't mind, but I'm kind of used to it and have a thick skin (for this kind of stuff anyway). He can be a challenging person though. I don't see a reason to outright _remove_ it from the sidebar links though. It will be a good text for some people, and not good for others. Its certainly not the only text we link here though. I would fully support adding new texts that might be preferred by some people, for whatever reason (style, tone, content, pedagogical approach, etc.), but we should not remove texts that are in many ways useful and have a reasonably good track record.
I don't agree with some of those complaints. &gt; First teaches the concept of command line and command line arguments and then (much later) proceeds to explain functions as some kind of miniscripts that take arguments akin to argv. &gt;Calls functions commands until teaching the word function. Likewise modules are features until they are called modules. &gt; Really backwards teaching order, files taught before any control structures. Sounds like he's focusing on writing shell scripts. I think that's a good idea, because it lets you do something useful right away. It may take some time for control structures to sink in to a beginning programmer's mind, but shell scripts can be useful without these things. Some of the other complaints are just that he doesn't explain enough. That's ok. When you're just beginning, you don't need to waste time reading the theory. It's often better to learn by experiment and feel your way around. You can learn the theory later once you're comfortable with doing things.
Everyone has their own learning method. I can see it's not for you, but it worked really well for me.
&gt; Is it perl6 yet? No. What are you trying to ask? If Perl 6 is available? Sure it is: https://perl6.org/
Less clout, sure, but he does have clout. He wrote the original Mongrel server that a bunch of startups used as part of their stack during the Ruby on Rails boom.
That list was driven by our long term observation of the types of questions (often [XY problems](http://meta.stackexchange.com/q/66377/253829)) that LPTHW was generating on SO and chat. The list isn't meant to be comprehensive, or to say that users can't learn with it, but it does start to explain why we think it leads to the questions that we observed. The problem with not explaining enough is that there are multiple places where users are then encouraged to try something, and don't have the necessary tools for the job, leading to them asking how to do things that *can* be done, but are just bad practice. If you'd like a book that starts from the absolute beginning, check out the [Invent With Python](http://inventwithpython.com/) series. Those books range from absolute beginner to advanced as well, but seem to avoid the issues that LPTHW has.
&gt; One of the biggest important pieces of Python software released - Tensorflow by Google - is Python 2. [From the TensorFlow website](https://www.tensorflow.org/versions/master/get_started/os_setup.html), highlight by me: &gt; The TensorFlow Python API currently supports Python 2.7 **and Python 3.3+** from source. 
As the author, I totally agree. It also is in multiple languages and has been constantly refined over the last seven years. I'd love to have it on the sidebar. 
I feel like I push your material more than you do. I should get royalties or something ;)
Here ya go: https://github.com/rtphokie/TheMartianLaunchDate
Questioning authority is part of education. It just shouldn't be a losing battle. 
Oh, yeah, don't get me wrong: He's a great developer. He's just. . .a dick. I don't like dicks. :(
Lacks a Readme file. Hardly any comments and doc strings as mentioned. I got bored after seeing the imports because I don't know what the project is about
Fair enough, lol.
Dang, a couple weeks late! I just purchased a Raspberry Pi and decided I should learn Python, so after some quick redditting and googling I came across your website, just started reading the online copy of your book. Seems like it's going to be super helpful! When I can afford the course I'll consider signing up! Thanks again!
This was the resource I used when I first tried to get into programming 7 years ago. I thought python was cool, but the book wasn't very engaging and I didn't stick with it. Now I'm a ruby dev.
No way!
Yeah, try, except, else, finally is pretty confusing. If I remember correctly, `else` executes in cases that `finally` doesn't.
Just an FYI, this should be your scrape target: http://www.powerball.com/powerball/winnums-text.txt
Contact the author, see if you can get them to do it, if not find a new project or do it yourself. EDIT: also it was last updated in October https://github.com/zakird/pyad/graphs/contributors
Thank you!
Thank you! i think i am getting somewhere!
It was a strange time, to be sure. For those of us with somewhat less talent (read: basically just me), we were in college, practicing etudes that might be given to a child. I can't say I never made mistakes, it's just that mistakes were not part of the pedagogy. There's a saying that "the master has made 10,000 mistakes" or something, but I think their idea was that "the master knows *exactly* what his body should and will do before doing it". We spent hours studying the anatomy and mechanics of our body before even (officially) attempting a technique. Analogously in code, I would called these "assumption mistakes". You assume a thing will work (whether a library or algorithm) without knowing that it will. So, the equivalent methodology is to first begin by proving your algorithm and underlying software behaves as you believe it does.
What instrument do you play? I play clarinet and saxophone and there are plenty of things that just require building up a lot of muscle memory, but there are also a lot of things that I don't think you could really understand until you tried them. 
 Draw Date WB1 WB2 WB3 WB4 WB5 PB PP 01/09/2016 32 16 19 57 34 13 3 01/06/2016 47 02 63 62 11 17 3 01/02/2016 42 15 06 05 29 10 2 12/30/2015 12 61 54 38 36 22 3 12/26/2015 65 40 44 59 27 20 2 12/23/2015 67 16 63 38 55 25 4 12/19/2015 30 68 59 41 28 10 2 This is the format of the data.
In my experience there is always an alternative. If there is an exclusive 2 module that hasn't been updated I've always found a 3 module that can replace he functionality.
fake
I play guitar. I guess the exposed nature of the hands makes it much easier to prevent problems. If I come off as hostile, it's just reddit. There are always mitigating factors (in this case, the sheer time it took to begin a new technique or piece). This style also only works for students with some degree of patience for it. However, that studio has produced some of the best guitarists in the world, so it's worth considering- [Silviu Ciulei](https://www.youtube.com/watch?v=qyjZKVBy-l8) [Lily Afshar](https://www.youtube.com/watch?v=6BEA-a-79K0) [Francois Fowler](https://www.youtube.com/watch?v=LX1WJBLtSMw) 
That is because it is "the hard way" !!! So it goes as advertised!
This is a very good reply. However, I'm just working on lists and while loops now. Please recommend more basic stuff.
Thanks for confirming the importance of memory management on this case. 
Where did Zed say he would update LPTHW to Python 3?
Is there a good summary of the differences between pep8, pylint, pyflakes, (any others?)
At the most basic level you just need to follow a course/book to learn what is possible to do. Evolve that into scripts that can do things and then small programs. If you wanted to build a journal then break it down further 1. Ask a user on the command line for input and then Print it back 2. How can you save that to a file? 3. How could you add it as a new line in a file Etc Each step involves learning how to do something small for the first time. You shouldn't drop following a course as you want to be exposed to what's possible in the language, just don't let it get boring. If you learn something new then think how you could use it in your project.
good one, thnx for sharing 
Yes, it is possible.
Great to know! Now would it be difficult for a beginner to do or is it fairly simple? Also where would be the best place to start looking for a template of code I could build off?
What happens when it crashes? Do you see any kind of an error message? Does it just hang? If it hangs, make sure that you've run `%matplotlib inline` - it might be opening up a window in the background and waiting for you to close it.
that's not accurate - https://github.com/tensorflow/tensorflow/issues/1 Google did not use Tensorflow in Python 3. And we are talking about Google here.
Yeah, but this isn't about excelling in academia. It's about learning a new and **useful** skill. You start by teaching someone how to do something useful, like ordering a beer or filtering a list of files by date. Adjectival declension and PEP8 will always be irrelevant until the learner decides they *want to get good*. 
It just says "It appears that the kernel has died."
It looks like there were a couple of optimisations for size which might have affected it. In particular, [this section of the PEP](https://www.python.org/dev/peps/pep-3154/#better-string-encoding) says that it can save 3 bytes storing every string less than 256 bytes long, by using a 1-byte field to store their length. It sounds like you're storing filenames, which are probably short, so that could be significant.
Incorrect. https://github.com/tensorflow/tensorflow/issues/1#issuecomment-162710214 and thats the latest tagged version.
Nope; just says the the kernel has died and restarted. 
I'm still waiting on maya upgrading. Goddamn autodesk you've bags of money, it's not like they're trying to bug fix what's already done ha. 
&gt;What Python version should I use with Django?¶ &gt;As of Django 1.6, Python 3 support is considered stable and you can safely use it in production. See also Porting to Python 3. However, the community is still in the process of migrating third-party packages and applications to Python 3. &gt;If you’re starting a new project, and the dependencies you plan to use work on Python 3, you should use Python 3. If they don’t, consider contributing to the porting efforts, or stick to Python 2. I urge you to double check.
I think looking it up is one of the biggest skills he tries to drive home in the tutorials. 
Many more options for learning Python out there now compared to that older doc. Py3 is coming into the mainstream and especially for beginner coders, they need to work in 3 instead of 2. You can always put checks in that will run 2 or 3 based code depending on the version installed on the host.
I was told "*Perfect* practice makes perfect," as in, if you aren't practicing it the right way, you won't lean it properly. 
Tomorrow we're doing SQlite, so I'm not sure it's necessary...let's just hope SQlite works. 
&gt; un the script without any syntax error showing up? I can't help you without your code if that wasn't the issue. I'm just testing with a simple hello world soo theres no sintax errors I've tried using the code you gave me but it had no effect. The thing is I cant save a file as a python project everything is fine until I try to save then everything goes into text mode but stillb running on the IDLE
It doesn't really "teach" anything anyway. Just a few lines of text with some examples. Something like Dive Into Python 3 is much more friendly. 
I've never understood the appeal of LPTHW.
I started it over five years ago, got a few chapters in, got discouraged, and dropped Python thinking it was too difficult for me. I lost a lot of time thinking Zed's attitude was representative of the Python community.
This is cool, but just FYI, the Project Euler folks ask you not to post solutions online. Obviously they can't stop you, but just a heads-up.
Please don't put it back up. It's been taken down for a good reason here, but beyond that I found it really irritating when I looked over it. There are loads of other good learn python resources, this book needs to earn it's place again and shouldn't get an easy pass. 
Both Tensorflow and Flask have supported 3+ for ages... Wtf are you talking about. 
&gt;and can be trusted not to randomly rant on newbies, unlike the other ... Could you provide a source for that? I'm interested in seeing that. Edit: Gets 104 upvotes and provides no source for his comment. Good stuff.
I'm not familiar with him outside of the book. I'm just saying that we shouldn't auto-include resources just because they have existed for a long time, and that this would be a good opportunity to re-evaluate whether it deserves it's place on the side bar. Although I'm not intimately familiar with the book, I probably wouldn't vote for it, having cast my eyes over a couple of chapters. Just because some colleagues you know have had some success with it doesn't mean that they wouldn't have had more success with another resource. There are plenty of other good resources.
Awesome, thanks!
Great! Thank you! 
I will let the Wtf slide. https://github.com/tensorflow/tensorflow/issues/1#issuecomment-162710214 it has beem 9 years since Python 3 has been public... and they released Tensorflow as Python 2 first. The release was on Nov 9 and Python 3 compatibility was released on Dec 10.
'then' maybe?
I'm actually about to start learning Python this month, self-teaching. Can you recommend any Python 3-centric resources that are the "correct way" (not what LPTHW uses)??? I'd like to use a free resource, if possible. I do have some coding experience from survey classes in grad school.
Lots, from Dive Into Python 3 to Head First Programming/Head First Python depending on whether this would be your first programming language or not.
Good point. Overall I just never use else in a for loop or try block except for the very rare times that an alternative is just really bad code. I suspect this is rarely used anyway. How often do you need that kind of flow control in well-structured code? Maybe in a nice complicated state machine, where it will only complicated it further?
Additionally, about flask, here's what the author says about python2. https://news.ycombinator.com/item?id=7799917 That info is a year old, but even the official doc right now does say that low level libraries may be buggy on python 3. https://github.com/mitsuhiko/flask/blob/master/docs/python3.rst
I don't get it, isn't this literally what list comprehensions are for - what are we doing here?
Well it's nearly 2 years old. Actually I don't really know what to think about the creator's attitude to flask.. He's definitely created something great but has distanced himself from it a fair amount. I suppose it's a good thing that flask by itself doesn't actually do much. All I know is I've produced several production ready websites with flask and python 3 with no issues. I think we can say that it is python 3 compatible. 
There are loads of advantages of Python 3! You do have to learn the new features and idioms, but they all seem to me to be so much cleaner in 3; they have been nicely redesigned. If nothing else, being able to use range instead of silly xrange everywhere is enough of a reason to switch. Here's the top google result that has some nice P3 examples https://asmeurer.github.io/python3-presentation/slides.html There's really no reason not to switch, except for being grumpily stuck in the past. 
That's cool and clearly your input would be invaluable when the book is updated and we make a new thread to discuss it's merits to see whether it should be put back on the sidebar. At that point I will be sure to give it another look. My point was not that it should not be put back up when it is updated, just that it should not automatically be put back up, and we should have that thread to discuss it. I look forward to seeing the update!
Yeah, I thought I had it wrong. I've never really needed to use `try`, `except`, `finally` in my code that often, so I never really `try`ed to figure out a good use for `else` in a `try`, `else` block.
I'm on it! Thanks. 
i dont think using c is a good example because almost all c projects are written to ansi c, not c99 and c11.
&gt; but I ask for a good reason to use python 3. Sane Unicode support.
Do you mean you want to append something to every line? There's no way to do that without rewriting the whole file, something like: from __future__ import print_function import shutil filename = 'file.txt' new_filename = filename + '.new' with open(filename, 'r') as infile, open(new_filename, 'w') as outfile: for line in infile: print(line.rstrip(), '12345', sep='', file=outfile) shutil.move(new_filename, filename)
Well, not the same thing to every line, i just want to know how to add something to each line in general
Amazing, thank you for referencing my post =)
what about pluralsight.com???
Sublime is a full blown text editor for editing code while Jupyter notebooks serve as a middle ground for showing off examples in a readable format. If you want to code full blown applications or full blown packages use Sublime. If you want to code one off scripts for show then use a Jupyter notebook. Sublime = Text Editor Jupyter = a way to show what your scripts do
Why exactly should one use Sublime? I can only see the benefits for "full stack" work. Why not just use Jupyter, vim/emacs, and XCode? It feels like Java-users missing Eclipse...
On the other hand, it got me started with python.
If you want to have different behavior if a user passes in None, a string or a file object or a StringIO object, you need to handle it. You can't just randomly call `.read()` or `.write()` on a `file` object. Ever make a dynamic class? You need your `hasattr` method. `hasattr` is very useful.
Ha, gotcha. I think we're probably on the same page. I will definitely read through it and hopefully get someone with little experience to read through it as well, and hopefully even be able to write a program at the end. It likely won't be an automatic "the second this is up, it's back on the list" sort of thing - I'm not that on the ball anyways - but more like a "once it's ready I expect this to be a reasonable resource to include after verification".
sorry for the late reply but would the software I'd be getting into be selenium?
emacs https://media.giphy.com/media/q540XuK9hMxY4/giphy.gif
So I just ran futurize on the package and, again, it seems to work perfectly. I guess I should just ask the author if he'll add this to the official release? I'm wondering why this hasn't been done before since it seems so easy.
How do you have time to mod a python subreddit when you're supposed to be in your Garrison getting pumped for Legion
Jupyter is in no way like vim emacs or xcode. They are all text editors just like sublime. 
pyqt5 can't be installed with pip, so you can't track it with requirements.txt. You need to install it with your package manager. For example, if you're in Ubuntu you need to use this command: sudo apt-get install python3-pyqt5
I have a family and a business too. I don't sleep much.
God speed you golden stallion 
Aren't the differences pretty negligible anyway?
Of course!!
I've looked through it pretty extensively, and it seems I would have to extend the FastLED library myself, which is a bit more work than I have time/patience for. Thank you for the link, I am surprised I never found this in my many hours of googling.
Seems like O'Reilly is the standard programming book company.
New libraries should really drop python2 support, imo.
Yes, that's why I'd really like to see a source for that remark. 
I'm definitely a fan.
Me neither. I'm gonna check it tonight now that I'm starting to feel a little better. I love those kinds of low traffic mostly easygoing reddits. They're the majority of my subs.
Here's a tweet from him about a related thread... https://twitter.com/zedshaw/status/686995069535035392
I have a python QT 2.6 desktop app running on Korean Windows 2000. Been there, done that. Unicode problems affect a minor subset of people. They are important (I should know.. I work in Asia), but I can write my code to be somewhat Unicode compliant in 2.7 What I can't do however is rewrite Flask-Socketio
I love it. As a newbie to Python (but someone with other language knowledge), this is a great example of Python's strengths at certain things.
www.automatetheboringstuff.com
Right, I think Go is actually a pretty boring language, but it's the kind of boring that also instills trust in the language. That said, I'll probably return to python every now and then for automation of one off tasks and the like, primarily because the third party library selection is still far larger.
If you are controlling the browser yourself, yes. If there's a good API, you might be able to stream it some other way, which might actually be better. If you are working on youtube, for instance, there's [pafy](https://github.com/mps-youtube/pafy), which talks to youtube, and vlc.py which talks to vlc. There's also livestreamer, which works with many providers, but is a separate program you can use the `subprocess` module for. Also, check out www.automatetheboringstuff.com. If you can't find some elements (say, the play button, because the video player is written in flash), use what's in Chapter 18 of the book to help you. The author recommends pyautogui, which can move the mouse around and find objects on the screen for you. Maybe combine it with selenium or requests or beautifulsoup to get the title. The possibilities are endless.
The quote is verbatim from the [website](http://learnpythonthehardway.org/book/ex0.html).
LPTHW was my first ever foray into programming, and it sucked. I was constantly annoyed that he refused to explain anything, and justified it by saying things like 'well you need to get used to reading the official docs if you want to be a programmer' and 'if you find this difficult or unpleasant then you're probably not cut out to be a programmer'. It was really fucking annoying. Ditched it after the first few lessons and went to Udacity CS101 and never looked back (note that, at least at the time, the Udacity course was Python 2 as well, which is a shame). Having gotten the basics down from Udacity I cut my teeth on functions and classes with programarcadegames.com (which is an *incredibly* well laid out and user friendly resource, can't recommend highly enough). I would say that insofar as a learning resource can be objectively and comparatively critiqued, LPTHW *is* a bad resource. Whether you're an experienced programmer or not, there are plenty of much better free resources available today, and that's even setting aside his absurd and explicit recommending against Python 3.
Automate the Boring Stuff is great, as the other commenter recommends. As the title suggests it quickly streams you towards loads of practical uses for Python at work and home, but the trade off is it stops short of teaching about classes, which is probably the last step in having a solid working knowledge of Python basics. But I have dabbled with a shitload of beginner Python resources, and programarcadegames.com is the best by far in my opinion. The course is well structured, well written, and all lessons are available in both text and video formats, so you can pick whichever medium you learn from best, or chop and change as you see fit. Assessment and practice work is plentiful and varied, from simple MCQ quizzes to projects. On top of that, you get to make pictures/animations/games as you learn, which is fantastic for keeping you excited and motivated. But make no mistake, you will come out of it with a good working knowledge of broadly applicable Python basics. The games oriented aspect is just a bonus. The only caveat I would offer is that if you hate or can't handle a little high school level trig and geometry, or just hate video games (and hence life and fun) it might not be much fun. If you already have programming experience, I hear that Dive Into Python 3 is a good one, but can't comment from personal experience. Oh, and make sure you subscribe to r/learnpython. It is extremely active and you will very quickly get help on any questions or problems you encounter.
"Python 2 Considered Harmful"
That's not the upstream, by the by. [FriendCode](https://github.com/FriendCode/gittle) is the upstream.
Real programmers use 'cat' and get it right the first time.
&gt; LPTHW is for a pretty specific audience - people completely new to programming People constantly trot that out as an excuse for the shoddy structure and insulting tone of LPTHW, and it *doesn't make any sense!* Surely if anything a resource aimed at absolute beginners should be more friendly and clear in it's style and content. For what it's worth I was a complete beginner when I started with lpthw, and I hated it. Fortunately I didn't take to heart his stupid assertion that if I didn't like his style I wasn't cut out for programming. I ditched it, and the very next resource I tried (Udacity CS101) was *much* better. Seriously, there are loads of free Python resources around that are aimed at programming beginners which are way better than lpthw. Have you looked into any of them? Do you have any reason to think lpthw is not worse than all of them, for compete beginners or otherwise?
Different people, different things. I got through it in a few weeks and found it amazing. To me it showed how accessible python is. Looking stuff up is something he drives home and without being handheld I figured out I could do anything in python with a little reading. Before as a beginner and on these handheld courses I was scared of APIs
There it is: &gt;**I learned so much solving problem XXX so is it okay to publish my solution elsewhere?** &gt;It appears that you have answered your own question. There is nothing quite like that "Aha!" moment when you finally beat a problem which you have been working on for some time. It is often through the best of intentions in wishing to share our insights so that others can enjoy that moment too. Sadly, however, that will not be the case for your readers. Real learning is an active process and seeing how it is done is a long way from experiencing that epiphany of discovery. Please do not deny others what you have so richly valued yourself.
Problem I always find with these things is people start blindly passing self without understanding why, they just seem to know the "rule" and use it. Dunno, just always see that with beginners and when told they are the same they go about learning the difference in params faster in their learning path. May be observation bias but I always see this
Those are [annotations](https://www.python.org/dev/peps/pep-3107/). They allow you to specify the type of the parameter (or a description or whatever) for documentation purposes.
&gt; Those are basically descriptions. You need to start somewhere. Language is a formal system, and has its axioms, you can't infinitely simplify, nor you can pull stuff out of thin air.
I have made some suggestions elsewhere in this thread, check them out for more details. programarcadegames.com is the best by a country mile in my opinion, and not because it is game/graphics oriented (that's just a bonus). I found the start I got on Udacity CS101 (after very quickly getting fed up with lpthw's nonsense) extremely helpful as a compete programming noob; the extra time they spend explaining the fundamentals like expressions, operators, types, assignment etc etc were fantastic for my slow learning style. Unfortunately it's tricky to get to their content for free now, and they do (or did) use Python 2 - bummer. And of course I agree with everyone else recommending Automate the Boring Stuff. Bear in mind though, when you start off with a free resource you aren't locked into any obligations, and if you aren't happy with their content or the way they present it you won't lose any ground by switching to something else. It just means you'll have to spend a minute skimming through the new resource to find where you're up to. The basics are pretty much universal. And subscribe to r/learnpython. Great sub :)
Suggested addition: quote (a sentence from) the parent comment and below add 'ftfy'. Don't change anything in the quoted text.
Thanks. &gt; Python-Version: 3.0 Seems there is a reason why I haven't seen this before :)
Even calculus or geometry textbooks??
It may be that the author didn't know about these tools, or just hasn't used Python 3, so didn't feel any need to support it.
If you're new to Github, start by [opening an issue](https://github.com/zakird/pyad/issues/new) to ask about Python 3 support. Mention that you've had a go at it and what you've got seems to work. This isn't strictly necessary, but it lets the maintainer know what you're doing, and gives him a chance to suggest other approaches. Github has a help site that explains how to make a pull request: https://help.github.com/articles/using-pull-requests/
 &gt;&gt;&gt; class C(object): ... def __getattr__(self, name): ... if name == "y": ... return 42 ... &gt;&gt;&gt; i = C() &gt;&gt;&gt; "y" in dir(i) False &gt;&gt;&gt; hasattr(i, "y") True &gt;&gt;&gt; getattr(i, "y") 42 &gt;&gt;&gt; i.y 42
You'll probably need to post an example of your code. You'll also probably get a quicker and more helpful answer from /r/learnpython :). 
That's… not exactly recent insight. Java's "Collections Framework" (J2SE 1.2, 1998) uses views for e.g. map "iterators" are `Set` (keys and entries) or `Collection` (values) views. And considering Java isn't exactly the most innovative language out there I'm reasonably certain the idea of collection views predates it.
The only practical difference that needs mentioning is that a method is automatically passed `self` as the first argument. That will confuse a newbie if they don't know it. If you're going to introduce classes at all you probably need to mention this behaviour. It's pedantry to correct your terminology every time you open your mouth, but it's not pedantry to point out when first teaching you that there is this particular difference in behaviour, because you actually need to know. I tend to agree with /u/davidism, the whole paragraph could be replaced by something of equal length that instead explained this point and that it's the only difference from normal functions that you need care about right now.
My thoughts exactly. I am not familiar with six library, but I am not sure it is a good idea to introduce the PY3 variable in the first place.
&gt; compression algorithms work very well on text Your assumption is inaccurate: compression algorithms work well with data having the characteristics of text (little variability among the byte values). You can easily find binary data more compressable than text. Apart from that, did you check the size of the uncompressed data? Could be, in your case, that protocol 4 yields less data than all the others? 
I wouldn't say that any of the features highlighted in the link are really hidden or even less known. I've only been programming with Python a little over a year now and I was familiar with and have utilized all them in production code.
Right, that's not what the devils advocate above was defending though. Command is just different jargon for function, it's not any more useful to someone who has no idea of the concept. 
Those are not the hidden features you are looking for. 
This is the stuff that is listed in the first few chapters of every Python Beginner tutorial/resource...
Ok thanks!
Nice job. Thanks for sharing it. 
The new logos are the horrible. Every Jetbrains product now has awful logos. I hate them so much I changed them back to the old ones. Yes. They are _that_ bad.
&gt; Command is just different jargon for function, it's not any more useful to someone who has no idea of the concept. What? "Command" isn't jargon. Are you seriously arguing that "command" is a niche word that is not widely understood? 
I found that learning Python with LPTHW and attempting the exercises with Python3 (I've never used Python2) was a rewarding exercise and required a little extra critical thinking, enhancing the learning factor.
I Lead dev team and still recommend it because of the value it teaches (figure it out yourself) is more important than the language itself. Software is constantly evolving so you have to be able to figure shit out constantly. The people who need hand holding don't last very long.
Thanks.
It also makes coding in an IDE a little faster and easier to use. PyCharm does a really good job of finding what objects methods and properties are when you use this. BTW I'm using [Type Hints](https://www.python.org/dev/peps/pep-0484/)
Oh please don't use this as a good example of what to do. I just threw this together in my spare time. It's not the most pythonic and the documentation is horrendous or really lacking. I'll try to update it when I can to make it a little cleaner. 
When you so add it back can you put it lower down the list, the other resources are much better than LPTHW. LPTHW is written in a condescending tone and is in my opinion not an optimal way to learn and is not as friendly for newbies
and that's how you teach programming youngsters Too bad it didn't go out earlier, it could surf the minecraft wave a little bit more 
 import concurrent.furutes with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor: a = executor.submit(ask_amazon_for_data, upc) b = executor.submit(ask_walmart_for_data, upc) process_replies(a.result(), w.result())
What are some good books for learning data science using python 3?
You're missing the point entirely. It's not a case of taking the concept of a function and rebadging it a command. We're talking about introducing the unfamiliar programming concept of functions via the widely understood metaphor of commands.
Zed is right. Every function lives in a namespace. That namespace can happen to be global, module, class level, instance level, or whatever. Those particulars are just different kinds of namespaces that sometimes confer different kinds of syntax options for calling them. So what are "methods" then? Just functions that so happens to exist in a particular kind of namespace called a "class".
If I may be so bold, it sounds like you recommend it to people with the assumption that if they learn Python they are going to become programmers, and you might have to work with them, and it makes your life miserable to work with dipshits who are flakey about researching and solving problems on their own. My position is that programming should not be reserved for such people, and a book like lpthw is discouraging for people who otherwise might just find it a really enjoyable and useful hobby. It's elitist in that sense. Maybe there is some bit in lpthw where he states that it is designed not only for people who have never programmed before, but *who also are already dedicated to becoming a professional developer*. But that seems like a pretty weird target to shoot for. More likely it's written largely with the intent to vent Zed's frustrations about having to work with the aforementioned dipshits, rather than to simply expand the total pool of knowledge of Python in the world in general. Which is ok it itself really, but people should know what they're getting into with that book.
Another alternative is leveraging asyncio with the requests like library [aiohttp](http://aiohttp.readthedocs.org/en/stable/). You pretty much just need to get an event loop and add the tasks. But it's probably overkill for your need and the thread pool works perfectly and is in both py2 and 3 Edit: sorry for no example, on mobile and I can't recall off the top of my head Edit2: An Example, if you have &lt;3.5 you can replace `async/await` with `@asyncio.coroutine/yield from` #!/usr/bin/env python import asyncio import aiohttp async def callit(url): async with aiohttp.get(url) as r: print(await r.json()) if __name__ == '__main__': loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait([ callit('http://ip.jsontest.com'), callit('http://headers.jsontest.com')]))
yea i def used 2to3, now im mainly just continuing the learning process. Do you perosnally have any gripes w/using QT instead of TK? The Qt designer app just makes things WAY easier than using TK
Comment of the year
I use QT and QTdesigner, it is the simplest however the licence of QT is GPL (or similar) so you may not be able to use it in proprietary software. If you are making proprietary software you can convert the PyQT code to PySide using a tool but I can't vouch for how effective it is.
It's beautiful, yet evil. I like this idea...
I think we need to do a bot war, anytime my bot sees any of your four responses it'll reply with "fake".
woosh
Bot wars are fun, unless you are a mod.
To be fair, if someone is Googling the answers this isn't really a problem.
just using it for work utilities for non techy people to be able to do some ssh stuf for us. Coming from someone who is extremely noobile I absoultely LOVE QT. it's like I was on crutches with TK and now I'm on a four wheeler with QT
This criticism makes more sense to me than any of the long list answers. Shaw did lots of things well in that course, and no doubt it took a lot of hard work. My gripe is that 'a lot' is not in this case equal to 'enough'. Abstract explanations that his alleged target audience cannot possibly understand, and presenting concepts without necessary foundation, these are things you can get away with in a live course (good thing, since all instructors do it to one degree or another) but fatally sabotage a self-learning tool. I think parts of the book could be used effectively by an instructor looking for some partially built wheels to insert into a course. As a standalone, imho it never deserved the credit it got. One other thing. Shaw explains what he means by 'the hard way', and without looking up the exact language, the explanation is basically that just typing lots of code and using memorization will have an almost magical effect in resulting in understanding. I'd say he is right up to a point, but that his book goes very far beyond that point and lazily relies far too much on these inadequate devices. -offered with some reluctance, but sincerely. As I said, a lot of good work obviously went into the book. Just not enough.
Thanks for the great reply. What college did you go to to get a degree in Computer Science? Any other tips?
Great writeup! I still have no idea what's going on :)
Best explanation I ever heard regarding the FFT/DFT: simple squigglies add up to make complex squiggles. 
You might want to look into [gevent](http://www.gevent.org/), it's made for exactly this purpose.
Might be fun to check this out, I didn't realize Minecraft had a Python interface.
They classified what microtransactions were allowed and not allowed in an effort to make the game kid friendly and cut down on predatory microtransactions aimed at younger kids. Mojang was getting the heat from the parents while the server hosts were keeping the money.
&gt;I tend to agree with /u/davidism, the whole paragraph could be replaced by something of equal length that instead explained this point and that it's the only difference from normal functions that you need care about right now. The thing is, I'd agree if the person wasn't completely new to programming, which is the audience it's targeting. When you're completely new, having it repeated that methods are essentially functions with a *slight* difference is extremely helpful because you're not grappling with having to learn an entirely new concept. Edit: Downvotes, really? Please explain what was so controversial about this statement. 
I learned a lot by messing with Lua in that feedthebeast mod. Having my code move something in a world I was already familiar with was extremely helpful. 
Forgive my ignorance, but what is the best place now for this stuff? Is Bukkit still around?
Oh gawd!
Flask works fine with Python 3. The flask docs for the older version (and maybe even the current version) discourage it, but it works fine.
?
If you're wondering what FT does, watch [this](https://youtu.be/QVuU2YCwHjw).
That depends on whether you want to generate random number**s** or just a single random number. And you don't need to use `os.urandom`, `random.seed()` does that automatically when it can, and I am pretty sure it does so automatically when it is started, so you don't need to manually set the seed unless you want a specific seed. So really you can just use `random.randint` directly without creating a wrapper like this. If you want more than one random value, `numpy.random` is a better choice.
Why not? Won't reseeding it every time ensure better entropy?
I suppose I'm just paranoid about random.seed() defaulting to using the system time instead of throwing an exception like os.urandom would when a system doesn't support it. Also, what advantage does numpy.random have over random.randint? From what little I know of it, numpy.random uses the Mersenne twister pesudoRNG just like random.randint. Thanks!
It's more based on Forge. Take a look a r/feedthebeast and go from there.
Found this: [https://stackoverflow.com/questions/9490058/why-substring-slicing-index-out-of-range-works-in-python](https://stackoverflow.com/questions/9490058/why-substring-slicing-index-out-of-range-works-in-python)
what are you writing that uses ansible?
The grequests library is a great abstraction of this. Stupidly simple to use, and has the same awesome API as python-requests. 
Sure, but at our place we're not dogmatic about these things. The purpose is adequacy now and maintainability in the future. Line length is just an indicator.
or simply print("Well done {}, you have scored {} points!".format(name, score))
Didn't realize the random module had this class. Thanks!
I'd recommend using Neovim with the deoplete.nvim, jedi-vim and ropevim add-ons. There are other add-ons that are very useful for general (Neo)vim usage, but those are the ones that will help the most for Python development. These are the ones I use, if you're interested: https://github.com/mixedCase/dotfiles/blob/master/.config/nvim/plugins.vim
Here's another tidbit to blow your mind...you can pass [slices as an object](https://docs.python.org/2/library/functions.html#slice). def pass_a_slice(a, s): return a[s] x = list(range(5)) print pass_a_slice(x, slice(0, 2)) print x[0:2] print pass_a_slice(x, slice(1)) print x[0:1] --- output [0, 1] [0, 1] [0] [0] 
'pip wheel' can do that already. The PEP is primarily about updating the defacto specification for markers to handle Python 2.7.10.
Just don't pass '-U' to pip, and it will only upgrade on demand.
Only if -U was passed, or another earlier package in the dependency set required a newer numpy.
&gt; when you're learning things, you should also be critically evaluating the resources that you are using to learn with; just because it says something in a textbook, that doesn't make it true Very good point. When I learned to code it was all from 80's 'learn basic for the Commodore 64' books and I was a 5+ year old. I had an Amiga 2000, a Toshiba laptop with a green screen (only ran DOS), an Apple II and Mac plus that all used various incarnations of Basic. Not saying I'm amazing, but as a 5 year old I was able to read my books critically and decide what syntax worked best for each computer. Each version had different syntax, so I couldn't just transport my code over seamlessly... so that was a consideration. For example: - In Amiga Basic I loved typing *SAY TRANSLATE$ ("HELLO WORLD")* because the computer would speak. My other computers saw this as being a syntax error. - Goto... was goto good practice? Lots of reputable coders who I learned from used goto in a big way (and it wasn't confusing, it was quite neat/organised). What do you do when an 80's book made by a famous coder says 'use a goto here'... and then Basic gives you a warning, suggesting that you should never use goto? At the time, my only access to the internet was at my mother's work, and it was mostly bulletin boards...etc. Computers were slow, and things weren't as well organised. As a kid, bulletin boards looked pretty random and I didn't know a lot of the lingo/nuances. However, I was able to see how people were coding things, and pick up the gist of why things were different between versions and systems. At this stage I also discovered different languages for different jobs. If a 5 y/o can can think critically about resources, then most people should be able to IMO. It's a really important skill when coding because every nerd's gonna have their own way of doing shit and many are really loud, condescending and not very advanced in terms of social skills. As a result, you'll likely get berated by a bunch of nerds even if you're doing what (might) actually be the best thing for YOUR situation. IMO everybody needs to get to a stage where they listen to others, but also know enough to be able to say 'that's a bullshit indoctrinated opinion that reflects x,y and z... I'm doing this my own way, thanks for your input!' You can't just expect all the 'right' info for your situation to be sitting there ready for the taking... 
Haha. That's basically what Fourier's paper on the heat equation said and even given this radically powerful idea (that really plays a huge role in the modern world) he still had to submit the paper like 3 or 4 times for a lack of rigor. (So it's arguable that people in his own period didn't get it) Another way to say the idea is that complex signals can be modeled to some level of precision given simple sin waves. This is done by adjusting their period, choosing a scaling factor, and summing some number of such functions. Don't ask me how you find those functions -- that's voodoo which is how FFT algorithms are born.
Do you have any real requirement to use Python 3? It may not be worth the trouble if Python 2 works for you.
Wow, this is the first time I've felt like I really understood the basics of how FFT actually works.
Nice write-up. . Nostalgias of college days. . Should have studied well. .:(
1) I disagree, it is a valid way and easy to use 1a) But yes, sure it is easy to read... if the try except blocks are done properly. There's a reason `else` exists 1b) True never ever do a `except:` "pokemon block" (gotta catch em all) 
That's not true. Test it.
After prolonged reflection, I think a better strategy is to go the browser route, and release a new major version each week. Python is twice as old as Firefox at this point, so we should be up to at least version 85 or so. &lt;/s&gt;
I just finished a class in college last semester where we used that book in the course. 3 days into the course the teacher removed it from the curriculum because it was so out of date and confusing.
You are very good at asserting that you are right, that's for sure. ai suppose it can be an asset. 
That's what I'm wondering; if this is the right book for an 11 yr old who just *cannot* shut up about that game.
Just saw that! Looks awesome. Will give it a spin ! Thanks for pointing me to this 1
&gt; in his own period Pun intended? :P
code is already in python3 and everythign was working until i brought qt into the mix. it runs fine until i try to convert to an exe
&gt; he still had to submit the paper like 3 or 4 times for a lack of rigor. I didn't know this, but it isn't surprising. The base theory is really simple once you get your head around it. Even with years and years of proofs and use I still couldn't bring myself to believe it was really that simple and actually worked. &gt;people in his own period I see what you did there...
My understanding from the docs: http://mypy.readthedocs.org/en/latest/basics.html is that mypy will only check a thing (module, function, whatever) if it's industry to it that it should check it (by importing typing at module level or by annotating a function. So 1 is checked because it's in a function which is typed, 2 is checked as the import typing indicates that your module is typed and it's at module scope but 3 is in the scope of an untyped function so it's ignored.
Sounds pretty cool. I should get back to my somewhat related project but real life got on top of me (pretty sure its one of the "several projects" mentioned)
Exceptions *are* flow control for *exceptional* conditions, with the cavaet that the definition of exceptional is local. When you're iterating a list or a file, hitting the end of those isn't exceptional to your high level code. But it is exceptional to the code doing the actual iteration. 
Nope
I'm fairly certain we've agreed to disagree then. 
I use Skyfield as well. Brandon and I have traded some email as well on the best way to solve various problems I'd been looking at. I particularly like how nicely Skyfield works with NumPy. Last used it to find perihelion and aphelion (point where Earth is closest and furtherst from the sun). Skyfield can very accurately find these +/- 5 mintues.
Thanks for your valuable input.
Other tips which I think apply at any of the big software shops (Microsoft, Amazon, Google, Facebook, and so on): * Get a broad set of both CS and programming skills. It's as important to understand why you would use a binary tree as how to implement one in your favorite language. Also try to go deep in some area: UX, machine learning, databases, compilers, esoteric languages, whatever interests you. Having both breadth and depth will help. * Literally everything we do is in teams. Being able to work with other people is probably more important to day-to-day success than being a rockstar single programmer. * Being excited and passionate about a project or product you've built will naturally help you sell yourself on a resume, in an interview, etc. * Stay in touch with friends in the industry even if they're at different companies or in different parts of the world. Never know when you'll want a job there or want to partner on something. That's the gist of it, at least the things I've tried to follow so far. Good luck with your programming! 
No, let's say I have two requirements for my project, Django and django-braces, and I want to upgrade django-braces but not Django itself. `pip install --upgrade django-braces` will upgrade both because Django is a dependency for django-braces. There is a workaround—specify a version number for django-braces—but it still sucks. 
I bought minecraft and the book, and I've fallen in love. So far so good, except now whenever I try to download the api it throws this error: "The directory '/Users/&lt;username&gt;/Library/Caches/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag." "The directory '/Users/&lt;username&gt;/Library/Caches/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag." could someone help me with this!!! 
I cannot remember the original source for where I heard 3 or 4 times but the general idea was he had to kind of beat the idea in with rigor to convince other mathematicians that he had a good model for expressing the heat equation. In particular Lagrange is one of the main hold outs and I think a lot of it revolves around how coveted a solution to the heat equation was (but I am unsure on that last bit). Either way, it seems Fourier has to try a good few times to convince his peers that he has some cool math tricks with respect to the Fourier series and modeling a complex signal as a super-position of simpler signals (the heat equation during the day). It's not something that is original seen as the powerful tool that it has in our modern context. I think what's really fascinating about it, is the abstract power of the idea and the kind of revolutions it can lead to. Fourier transform ion cyclotron resonance (FT-ICR) is a form of mass spectrometry that provides great accuracy by avoiding collisions (which is a more traditional way of measuring mass). Instead, the mass of an analyte can be measured based on the Lorrentz force and using the FT to takes the frequency of the analytes revolution and gives us it's mass. In this way, the FT transform allows us to "derive" information from a system in a rather unique way. Aside from that, we have to give props to the simple fact that modern telephones work because of these general ideas (that a signal can be decomposed in the analog space and effectively modeled in the digital space such that it can be reconstructed in analog form for a receiving party -- it's just straight mathemagic) .
Just use task scheduler... Seriously. One trick to a more zen existence is to just use the correct tool for the job instead of trying to constantly drive nails with a screwdriver. Even if you wrote your python launcher script, you would still have to schedule execution. Why needlessly add another layer of abstraction to such a simple task? If you still want to learn python, then go follow one of the thousands of tutorials out there, program the towers of hanoi, game of life, or whatever other hello-world type application excites you. You'll learn way more, and you won't be jamming up your company with needless shitware.
That's not what ad hominem is. But I imagine you will assert so anyway. 
This a thousand times over. People have this false idea that Django is the god of all frameworks for Python. When in fact Flask is used more and doesn't require a massive community since the devs that use flask don't need to bother with asking people for assistance. Sure Django has it's place as the wordpress of frameworks, but I've seen more flask based systems in place in both financial and industrial applications in the past 2 years than Django.
That's not an error that's a warning I think, can you post the full output from your terminal on pastebin and put the link here?
That's what I mean, app key/secret pairs are a very particular type of authentication offered by sites to developers. If you don't know what it is then you don't have one. Maybe I missed something on the page you linked, but it looks to me like what you are trying to do is more akin to scraping or monitoring the site. 
as I said, else exists for a reason try: foo() except FatalError: recover() else: bar() baz() getOn() How is that hard to read? Simple example . lets assume we want to symlink a file but also need to support windows where it isn't available so we fall back to copying the file. Sure you could test for the Platform... or you just try and recover gracefully if it fails (easier to ask for forgiveness than permission) try: os.symlink(path, link) except (AttributeError, OSError): shutil.copy(path, fileDest) getOn() instead of (pseudocode) if Platform == Windows: copy() else: symlink() but what if windows suddenly shows reason and implements it properly in Windows 11 (for a user with non admin rights for example) ? now you have to check for version code. if Platform == Windows and windows.version != 11: copy() else: symlink() What if NyanCatOS comes out with the same issue? if Platform == Windows and windows.version != 11 or Platform == NyanCatOS: copy() else: symlink() However the code with try, except still works with no modification as before. By now which is more readable? Edit: Added more examples
It's not valid, AFAICS. This is why: random.seed = os.urandom(seed_bytes) You are not setting the random seed. You are setting the 'seed' attribute of the 'random' module to the value of `os.urandom(seed_bytes)`. All that does is make it difficult for you to actually set the seed, without actually affecting the RNG state at all. Setting the seed is done by **calling** `random.seed(seedvalue)` So what you were aiming to do was probably random.seed(os.urandom(seed_bytes)) (I presume you are already aware that when the stored entropy data is exhausted, /dev/urandom will return PRNG-generated results instead.)
tl;dr mojang hired bukkit devs, one of the bukkit contributors kicked up a fuss as he is legally allowed to, whether it was relevant is another question, but it basically meant that bukkit couldn't be distributed by mojang or used in mojang code, unless they re-wrote all that person's code without looking at that person's code 
Beginners, please understand that if you start with Python 2 then you immediately incur a learning debt, don't learn the out of date technology, learn the current technology and save yourself time and cognitive load.
Because multiprocessing.pool is a horrible pile of shit
Help me understand why.
I am the author of the post. Thanks for your comments. I agree that I have not explained the details of the FFT algorithm, which would reduce the complexity to O(nlogn) from O(n^2). I'll make the correction whenever next I get a chance. However, I'd be more interested in why you considered the explanation to be poor. More importantly, what in your opinion would have made it better :)
Fourier Transforms are used extensively in signal analysis and processing. Signal filters often do nothing more than include/exlude a range of frequencies (e.g. low-pass filters remove high frequenies, high-pass filters remove low frequencies from a signal). Perhaps surprisingly, an image can also be considered a signal, though it will be a two-dimensional signal. Noise or interference in an image can be considered a high frequency component that can be removed by first obtaining the Fourier transform of the image, then removing the high frequency components causing the noise, and then transforming the processed Fourier signal back to an image ([example](http://www.mathworks.com/matlabcentral/answers/uploaded_files/3932/FT.jpg))
Even the popularity of this thread won't convince the Python 2 diehards that anyone uses Python 3.
Why don't you just do it yourself?
Yes. Then they'll have two things to not shut up about 😊 
That's what they said at StackOverflow....
Any better idea?
A basic use might be to measure the rate of contrast in an image. You could use that data to decide if the image is blurred.
You could avoid bias against LinkedIn or anyother "social" network by instead using accounts that are more value-neutral, such as Python wiki, or PyPI accounts. As far as a bias against polls, you're SOL but at least one bias is less pernicious than two, because the risk of overlap isn't there. What's the desired outcome here? Why do we need another poll? It's pretty clear that the last big roadblockers to widespread upgrade are now moving, such as Twisted and Kivy, and nobody has forked a credible "Python 2 forevar!". Python 3 is no longer the future of Python, it's the present. What do you want your poll to discover? Not being snarky here, but if you don't know the answers you want to find, you'll founder with strategising the question.
Many thanks! All excellent points! I also thought that showing that energy of the time series signal is the same as the energy of the transform would be useful. It would provide more intuition into what the Y-axis on the FT plots mean. I, for one, had a hard time understanding this and had to dig up a lot of stuff on DSP stack exchange! Aside: Would you know any text that would be useful for DFT?
MRI is a cool application! MRI makes use of these transforms by collecting spatially encoded frequency data and performing an inverse FFT. KSpace (frequency) data collected from the machine looks a lot like the image (b) in the filtering example
what would the point of this poll be?
Everyone I know just uses them as synonyms 
The 'few resources online' are correct. Arguments are the actual values, parameters are the placeholders that take arguments as their value. The terms are often used interchangeably because it's obvious what is meant from the context. Don't stress over the difference.
1 You could have Wikipedia-ed this. The arg is the data you send. The parameter is the var inside the func that holds the arg. 2 No-one cares if get the two mixed up. No-one even knows the difference (apart from Wikipedia) anyway. Really no-one cares and this is why the words are used inconsistently. 3 You guys should cooperate on making an awesome app and stop worrying about this. 
has anyone looked at he book yet and able to comment on quality?
In general, *parameter* refers to the function definition and *argument* refers to the instances passed when calling the function. [Wikipedia calls them *formal* and *actual* parameters.](https://en.wikipedia.org/wiki/Parameter#Computer_programming) However, the names of things varies by language and this is no different. [The Python docs clearly use this language](https://docs.python.org/3/reference/compound_stmts.html#function): &gt; When one or more parameters have the form `parameter = expression`, the function is said to have “default parameter values.” For a parameter with a default value, the corresponding *argument* may be omitted from a call, in which case the parameter’s default value is substituted. So *parameter* in Python refers to the function definition, and argument refers to the corresponding part of the actual call to the function. 
Arguments are used by the Klingon to conquer random software.
You're right, protocol 4 does yield less data than all others, this plays a smaller role when comparing protocol 4(binary) with protocol 0(text) but it's still significant.
A parameter represents a requirement. An argument represents an attempt to satisfy the requirement. Try visualizing it outside the context of programming. * I want a pizza with 3 toppings or less - Parameter. * Here's a pizza with pepperoni, sausage, and onion - Argument When you define a function, its definition may have parameters. When you call a function, you supply arguments according to the parameters in the definition.
Albatross!
well that is what is weird to me I have C:\Qt\Qt5.5.1 but still reference QT4 :| everything works great until i compile down to exe w/pyinstaller. Is there a better way to compile?
Your example does serve the need, but I think this would be more realistic: * I can serve a pizza with 3 toppings or less. - Parameter * Serve me a pizza with pepperoni, sausage and onion - Argument Made me chuckle though :)
ILuvAnal
Great module! It's more pythonic then the redis-py. Will test it soon and give feedback. why Walrus ? :)
Not sure about requests. Have you looked at using httplib2 ? Here are some examples, https://code.google.com/p/httplib2/wiki/Examples
Yes! Thank you for catching that. This is why I need a coffee drip IV.
No, no... You're think of /r/ships. Here, arguments are what you have with your friends when you disagree. Parameters are the set of physical properties of the atmosphere, like temperature, pressure, and density.
&gt; compiled Python Objection, your honor! Misleading. That which is compiled is not Python, but always a subset of Python and usually a superset of a subset. Python is no more and no less than whatever CPython accepts as input and does with it. You can thank the BDFL for that, because his lazy ass did not define the language with a formal, sufficient and exhaustive specification. 
You are reading the entire contents of `self.x` into memory at one time. How big are these files? What happens if you instead stream the contents in a block at a time? http://stackoverflow.com/a/3431838/3140 def create_checksum(self, x): hash = hashlib.md5() with open(fname, "rb") as f: for chunk in iter(lambda: f.read(4096), b""): hash.update(chunk) self.x = hash.hexdigest() --- From a code review standpoint, it confuses me when you use `self.x` to temporarily store the filename and then the resulting hash. Rename the argument from `x` to `filename`, and rename `self.x` to something more descriptive.
Sorry, that was a typo. Fixed it.
I wanted to answer the same way, but you beat me to it. But for comparison, my results were: $ time md5sum foo 2dd26c4d4799ebd29fa31e48d49e8e53 foo real 0m24.804s user 0m20.528s sys 0m4.048s $ time python3 test.py foo 2dd26c4d4799ebd29fa31e48d49e8e53 foo real 0m23.204s user 0m18.076s sys 0m4.636s So, pretty much no difference. The python version was even slightly faster (even if I retry).
Is `test.py` the block-at-a-time version or OP's `.read()` version? Also, does the performance differ in python2 vs python3?
No, it's block-at-a-time. Loading a 10GB file into my memory would probably kill my PC anyway :-) **Edit:** And no, no significant difference between python2 and 3.
The solution isn't to use a database...that's a cop out. Especially if your data isn't tabular or structured. You use generators and asynchronous IO development patterns. Using a pre-defined [`mmap`](https://docs.python.org/2/library/mmap.html) could have also helped your query performance. Your post is also disingenuous to the language, since you've neglected to use modules such as [`csv`](https://docs.python.org/2/library/csv.html), [`json`](https://docs.python.org/2/library/json.html) or [`collections.namedtuple`](https://docs.python.org/2/library/collections.html#collections.namedtuple). I'd rework the entire article and try again.
It's only a cop out given the context...I think databases, and SQLite in general, is usually a great solution. Just not when the premise of your article is about "How to open a 5 GB file in Python." Even changing the title, "Using SQLite to open a 5 GB CSV file in Python" would have been 10x better. 
I'm not exactly sure why the Python version is 2x slower ~ but, if you're doing a lot of MD5 on bigger files, it might be better to execute the command via a sub-shell and just pipe the stdout back into your program.
Why do I hear so little about Julia? It's a competitor for both Python, and Rust/Go, thus by extension also C, and IMO, looks by far the best of all up-and-coming languages. Meanwhile, everyone keeps raging about Rust and Go. Why?
This assumes that your data is essentially a CSV representation of data, in many cases large files aren't. So anyone reading this article as "this is the way you have to read a large file" don't take it that way as the OP is presuming you not only need to read the large file but query stuff from it in a structured way. Even if this is the only way, you can make it way nicer to work with instead of counting your indexes (the second I see `my_list[22]` I am thinking there is definitely a better way.... and there is.) If the actual problem is "open a 5gb file in python" then the real answer is to iterate the lines (rather than read it all into memory, which is accurately pointed out as a problem, but after they went over how you need sql knowledge, etc.). You can also just use an iterator to go through the lines and process as you need, here as if it's the OPs csv: # get a file reference with open('data.csv') as f: # drop the iterable into the csv module reader = csv.reader(f) headers = next(csv) # Presuming you have headers for row in reader: # No way in the world I want to count indexes, make these into dicts to work with content = dict(zip(header, row)) # Now do with the row you want, including inserting it into the DB print(content['Other Provider Identifier Issuer_16']) The few un-obvious side benefits is you're no longer manually splitting rows, unquoting strings, etc - as most of that is done automagically.
Julia isn't really finished yet. It's still being very actively devoloped. Like there isn't a good web framework yet, and a lot of the more niche features are still being decided, like some metaprogramming and syntax candy. Although its super elegant and beats python in a lot of ways, so I'm pretty sure it's going to become huge. 
I agree with the premise being fundamentally flawed, that's also what is irking me about it. The author does go into the iterating lines piece but that is after providing a ton of unnecessary background on SQL and whatever else, and the iteration is simply a side comment. Also, I commented about a better way to navigate the lines because seeing indexes of `22` or `23` was killing me to read when you know the headers.
Ah, good point, not sure *why* I missed that. Kinda makes me wish I was in more of a condition to pitch in into some of that development.
Slice assignments can be useful if you have a list referenced in some other container. &gt;&gt;&gt; list_a = [1, 2, 3] &gt;&gt;&gt; list_b = [list_a, [4, 5, 6]] &gt;&gt;&gt; list_a[:] = [7, 8, 9] &gt;&gt;&gt; list_b [[7, 8, 9], [4, 5, 6]] If you only assign `list_a = [7, 8, 9]`, list_b would be `[[1, 2, 3], [4, 5, 6]]` because the original list is still referenced.
Thanks. Do you have a link in mind? I'm specifically talking about functional programming within Python
My mistake, I overlooked the functional part of your post. The Python docs have some info and there is an O'Reilly book you can look at but I don't have much experience with it so I don't know if either would help. 
The DB dumps are all over the place. They start out at ~100MB and go up to 10GB. We have one DB, which in rare circumstances can be 20GB, but this is very rare.
Google led me to [this](http://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming) and [this](http://www.ibm.com/developerworks/library/l-prog/) post. Which seems to explain the extent of functional concepts you have in python. Are you looking for an article explaining a specific aspect of functional programming in python? Also, Are you trying to learn functional programmming? If you are I would suggest a language like Haskell to understand the functional paradigm rather than python. 
i learned a lot from reading through Learn Python the Hard Way. though some of the tactics in it (like don't ever use py3) are obsolete now. 
Personally, I have found that if celery gets floppy from being old, you can cut the end off and put it in cold water and it comes back to life. Good as new
Okay thanks for the information.
&gt; One way to speed Julia is to take into account the fortran ordering it uses. It's kind of unfair not to have done that in the first place don't you think? Also is there any particular reason you disable GC in Python but not Julia?
If you notice at the top of the file, there is a line: `#!/usr/bin/env python3` which indicates that this script is designed to run in Python 3. You are using Python 2. The `configparser` module was renamed between these versions (see [the docs](https://docs.python.org/2/library/configparser.html)). Pastie is down for me, but is your error an interpolation error? If so, then I suspect that your username or password contains a percent sign. ConfigParser tries to be a bit smarter than it perhaps should be, and will interpret the percent sign as the start of a string to be interpreted. I have [filed an issue about this](https://bugs.python.org/issue24086), but the behavior is unlikely to change. You can use a [`RawConfigParser`](https://docs.python.org/2/library/configparser.html#ConfigParser.RawConfigParser) as a workaround.
Exactly. Learn Haskell or Scheme first. You could write Python in an FP paradigm, but it's not really a FP language. I'm just curious for more resources to see what the kool kidz are doing nowadays. 
Test
I favored Julia code as It does not allocate memory in the timing loop. This shows in the output of @time. If gc time is over 0.1% it would have been indicated. I will change the code to include the allocation and I will disable the gc to be on par. I didn't think of writing a column major julia code in the first place indeed as I am not familiar with julia. It is when I looked again at the C code that I did it. Edited for typo and some possibly negative statement.
will get right on that, Gov'
Thanks for the pointer. I include Julia as I always get the question if I don't. 
i don't think the problem is the library i am using. it's that i don't even what type of authentication to use.
Thanks a ton for clarifying this.
Haha, thanks. My colleague and I did have a look through quite a few resources, but I decided that a consensus would put our minds as ease. Thanks again :)
Already did this, was just hoping for a consensus. Thanks for taking the time to post though.
Thanks for your input, the analogies helped :)
 PyStAl or Pystal (pronounced like pistol) IsMyPyHotOrNot (throwback to amihotornot from days gone by) 
I know you said you are looking to go open source very soon, but do you have an ETA? I am new to working on open source projects, but I would really enjoy working on this for some experience. 
This should be part of Celery Documentation. 
That's just front end though, right? I want like django in Julia. 
Start by reviewing the source of existing web frameworks. Perhaps launch a debugger and initiate some requests to get a good map of how they handle the request/response process.
Oh, OK. Why move to Python then? Interesting enough, I came across ErlPort a week or two ago. Not the same thing, but you might like it for some projects.
I did that. But I find that inconvenient as I can't properly handle different errors and so.
http://www.oreilly.com/programming/free/functional-programming-python.csp
A circular list is, but that's besides the point. What I meant is it's exceptional to `for`, consider if we had to implement it ourselves: list_iter = iter(target) while True: try: yield next(list_iter) except StopIteration: break But it's not exceptional to the code *using* for. Similarly, contacting a remote API and you get a 4xx or 5xx back. This is exceptional to the code managing the call but it might not be to the code using that call. Like I said, exceptional has a localized definition. 
Rust is for lower-level system code. Go and Rust are both supposed to be what C would look like if you were designing it today. In reality, Go seems more suited for application-level programming and Rust for lower-level system programming. Julia, meanwhile, is squarely aimed at mathematical computing. As such, they're aimed at very different markets and it would be strange to find a group talking about Rust and Go bring up Julia. 
Julia's compiler is fairly straightforward actually. LLVM does most of the optimization, there aren't that many high level transformations going on. You can introspect on the various stages of Julia's compilation very easily: `@code_lowered` and `@code_typed` to get abstract syntax trees, `@code_llvm` to get LLVM IR, `@code_native` to get the assembly. For high level optimizations and clever compilers, there's the sort-of-Numba-esque https://github.com/IntelLabs/ParallelAccelerator.jl
but of course it is flow control! "does this work? no... hm ok do something different " this is a change in the procedure and therefore a flow change. of course that's the recommended way to do stuff as it is easy to use and read and quite stable (at least more so than testing each and every single edge case that might happen) 
Just on the off chance you haven't checked: have you tried [IdeaVim](https://plugins.jetbrains.com/plugin/164) with PyCharm? It gives you the world of Vim, still keeping the Intellij based magic. Also there is a way to reduce latency for typing in Intellij IDE based IDEs ([link](http://blog.jetbrains.com/idea/2015/08/experimental-zero-latency-typing-in-intellij-idea-15-eap/)). [This comparison](https://pavelfatin.com/typing-with-pleasure/), while very detailed and long, does say that experience gets is very Vim-like.
aaaaand it's gone
fantastic! that worked great. thanks for the help. 
Fortran excluded because it would blow away everything else?
I am not sure how you're calculating the score, but I would imagine it would be something like a count that you add to the number to know how many they got right. count = 0 Then update it after every right question. count += 1 Then add that to the print statement when completed. print("Well done " + name + ", you have scored '%s' points!" % count print("Oh dear " + name + ", you only scored '%s' poInts, meaning you failed." % count 
Every other language has done the right thing
I think you would need to recompile vim to work with Python 3?
Well, I'm not talking about English grammar, but yes, it is a grammar issue. For example, in this text: &lt;some random text you want &lt; other random text&lt;&lt;&lt; &gt;&gt;&gt;&gt;&gt; depending on what you meant by "search and delete everything between and including a '&lt;' and '&gt;'" this could mean you get no text, or it could mean you get a bunch of "&lt;" and "&gt;". This is not HTML--do you still want to delete it? Or no?
Have you tried Rope? It's used by klen's python-mode which I find rather complete.
There's a discussion on [Hacker News](https://news.ycombinator.com/item?id=10911913). Here's the relevant quote: &gt;Author here. Please be aware that the project has no releases, it's not on PyPI and it's little more than a proof of concept. &gt;I have no intention to mislead any user into running it so I'll remove the repository for the time being. 
Yeah, installing Numba manually can be tough. Anaconda packaging has it ready to go though.
Searching a list. Break if you find the element, use the else to handle when nothing is found. Think of it like the equivalent of using a Boolean flag that you check after the loop. 
YCM uses Jedi for Python completions. It should work. What is not working? What is working? Is it not detecting the filetype? Do you have it configured appropriately? Manual completions working?
http://ruslanspivak.com/lsbaws-part1/ ...seems like it might be interesting to you.
Maybe this could help: http://stackoverflow.com/questions/7378398/how-to-make-web-framework-based-on-python-like-django
Is there a predefined LU factorzation in Julia?
The Python 3 stuff in python-mode doesn't work unless Vim is compiled with +python3. Even syntax checking doesn't work.
What kind of extra stuff did you get?
If your default-else case has side effects, you might not want to do it if you don't have to.
Albatross as in the bird, right? Looks cute. Any other reason this guy popped into your mind? :)
&gt; Constrict So the software gets people constipated? :D
I agree? The example given didn't fit that though. A similar example which has several variables initialized before the loop, and the else: clause sets only some of them, might be a better fitting case.
ahhh hahahah hahahhaah hahahaha hahahaha hahaha ha
try: /r/cheatatmathhomework 
BTW, thanks for asking the question. I'm working on a batch processing script and had the exact problem I described above, now it's solved :D I had totally forgotten about the else clause. 
Yeah!
Python snakes are constrictors (they kill prey by crushing it), a static analyzer constricts (limits) the programming language, and it has 'strict' in it.
 var = 'whatever' if any( somefunc(v) for k,v in d.iteritems() ) else 'not found default' But of course you'd use the *for break* version for complex iterations...
The else case is called when the iterator runs to exhaustion (there's nothing more to iterate). Basically it's called after looping through all the elements.
Which it always does in this case. So you could just put the code unindented under the loop, without using else.
Why are you scratching your head? They are like metaclasses, when you need it, you'll know it, when you don't need it, don't use it.
Thanks for mentioning. I have the IdeaVim plugin installed and it's meant to be pretty full featured - I haven't given it a thorough testing yet. Thanks for that brilliant link, very detailed. I tested the lag free mode in pycharm a few months ago and it didn't seem stable enough yet, but those are amazing results. IntelliJ should be very pleased they have managed to get and IDE faster than any other editor out there. I haven't read through the whole link yet but curious to see if the vim he tested was fully loaded with comparable features to pycharm or just raw vim (which would be a bit of an unfair test)
sure. I don't have rust installed though, I'll install it ASAP.
In this case I needed to use sudo -H ...etc Without the -H tag even sudo failed. New one for me. 
Are you telling him to not to learn unless he has to?
This... 
I can't think of any off the top of my head, sorry. Generally, though, the bottleneck for the web-framework stuff is going to be the network, not the processor. Any processor-intensive stuff that you'd want to write in Cython should probably be put in a separate module which will then be imported into your webapp.
That is a fair point
Thanks!
It happens on the fly, it doesn't touch the disk.
Actually, the else is a counterpart of `break`, so remember the combo as "break-else" or "for-break-else", not "for-else", that way you can remember what exactly it does without confusion.
 def get_static_path(subdirs=[], base_dir='static'): data_directory = None for x in sys.path: # And try to add 'static' to it static_path = os.path.join(x, base_dir) if os.path.exists(static_path) and os.path.isdir(static_path): data_directory = static_path for d in subdirs: data_directory = os.path.join(data_directory, d) if not os.path.exists(data_directory): break else: # If we got here, subdirs exhausted sucessfully return data_directory 
the other comments, actually explaining what it’s used for, are better though.
What if you need to call one or another function, instead of assigning a value to a variable?
Every other language simply didn't challenge the status quo. 0-based indexing was never done because it was "right", it was done because of times when optimizing the performance cost away wasn't possible. All arguments for it were thought up after the fact.
And also disappears from the other half. Such as `array[length - i - 1]` becoming `array[length - i]`, bounds checking becomes a neat `1 &lt;= i &lt;= length`, instead of a confusing and easier to mess up `0 &lt;= i &lt; length`. Face it, there's simply no real argument for 0-based indexing being superior, you're just trading one discomfort for another, while simultaneously losing the intuitiveness of the familiar 1-based system. I've been writing Python, C++, other languages for years, and still kept messing up periodically. In contrast it took me half a week to get used to 1-based indexing in Lua to a higher degree than I've ever gotten used to 0-based. Sure, there's still some `+1` or `-1`, but at the very least it's intuitive. 0-based is like double-negatives. All great and clean on paper, but when it comes to it, it's just confusing as shit, and the only way to power through it is to memorize every common case. There are use cases when 0-based makes more sense, but they're no longer anywhere near common in modern programming where abstraction is as prevalent as raw pointer manipulation was back in the C days. Because in the end index is an index, and not a pointer offset, and it makes no sense for the first element to be numbered zero. EDIT: And specifically concerning Python, addressing lists from the back, via negative numbers, also makes *way* more sense with 1-based indexing, than otherwise, since then `1` becomes `-1`, not `-2`.
Why do people think I don't understand that? It's just a total non-sequitur. &gt; "How does that differ functionally from.." ... &gt; "If your default-else case has side effects, you might not want to do it if you don't have to." The whole point of my reply was to point out that that **wasn't** the case for the code in question, so /u/hylje 's reply didn't actually appear to connect with my comment -- ie. it didn't answer the question at all.
.. Then you probably should use the else clause. That's exactly why I said &gt; Procedural things are probably closer to the mark, analogously to try: .. finally:. For example, logging a warning when a result isn't found. The 'variable' case just deserves a little special attention, because there are simple existing idioms for 'get X value if possible, otherwise Y value', so the added complexity of an 'else' clause is unjustified (as in /u/moepsenstreusel 's example)
Self
It has 1 indexing. This alone dooms widespread adoption.
Or called out to through celery or the like.
I don't mind this, but I definitely prefer self, so much more mentally intuitive 
They were just elaborating in ways that at least I found helpful. I didn't read the comments as saying you were wrong.
 for something in some_things: if one_thing: continue if another_thing: that = 5 break if last_chance: that = 10 break break else: that = 15 In this loop, I really only want it to run through once and not hit any of the if conditions. If it passes, I stop the loop and move on. If a break gets hit at any stage, either a condition that requires stopping happened or it passed successfully. If a continue happens, something went wrong in a controlled way, and I want to try it again. This is useful when you have an operation such as calling on an API from the web and the result might just require you to retry the request. 
That's like saying that bicycles are about as fast or faster than motorcycles because some guy in a recumbent did [139.45 Km/h](http://www.recumbents.com/wisil/whpsc2015/results.htm) while my 50cc scooter is limited to 50 Km/h.
My poorly-written example is a dumbed-down version of [this](https://www.reddit.com/r/learnpython/comments/410v5x/help_understanding_use_cases_for_decorators/cyzclop) (a comment I made recently about the usefulness of decorators). The loop is there to re-run a complex process (an API request) in the case that a specific issue occurs (throttling). In most cases, the loop runs once, the request finishes without error, and it exits out. In those small cases where I need the same request to run again, I `continue` the loop. The unconditional break assumes that none of my error conditions occurred, so I can break the loop and return the results of my request. If the same error that caused `continue` to fire occurs every time, then the `else` triggers, at which point I know that the request was throttled too many times. That's when I return different results. Finally, there is no default variable to be set here: my `else` should happen rarely, and when it does, the value it sets is one of my error conditions.
The string assignments were essentially nothing more than comments saying "This is the section where you would write code for this case." It isn't a direct example so much as a template of examples. This is an extremely common pattern when people write example answers to questions like this on e.g. StackOverflow, although replacing those lines with comments to that effect is clearer. So, the reason people were responding the way they were is because, unconsciously aware of all this, your question seemed odd. They thought you you were saying, "How is that *template*" different from this *template*".
I mostly agree - Guido himself has [stated](https://mail.python.org/pipermail/python-ideas/2009-October/006157.html): &gt; I would not have the feature at all if I had to do it over. I don't think I've ever used this feature myself.
Just use Python and run s profiler to find hotspots and if it makes sense write those parts in cython 
Because people don't know the language is a horrible reason. Following that rul, we'd all still be writing Python like C or Java and never use a new feature, or anything that wasn't immediately obvious to novice programmer. Fight ignorance with education not by dumbing down everyone else to the ignorant's level.
If I might be so bold I would like to suggest this web and its starting tutorial series. http://fsharpforfunandprofit.com/series/thinking-functionally.html I am aware of fact it is not about Python but from my experience you cannot find better pages to learn functional philosophy. It is good to start here because Fsharp is functional first and contains concepts which are pretty bizarre or uknown in Python context (e.g. TCO, patter matching, function composition, operators like |&gt;, discrimination union etc). Once you get better understanding of FP you can judge by yourself what is viable in your Python. By the way, Fsharp is using really nice syntax similar to Python in that sense that there is indentation instead of bracket and a lot of similar features. But be aware it is completely different beast :) The book mentioned below http://www.oreilly.com/programming/free/functional-programming-python.csp is pretty cool as well. I can recommend. 
Banned already? Last activity was 15 hours ago. Nice job though 
According to Guido: &gt; To anyone who prefers 1-based indexing: you are the same people who screwed up the calendar, starting at year 1 and calling the 1900s the 20th century (and arguing that the year 2001 ought to be the start of the next millennium). Haven't you done enough damage? 0-based indexing is to make the indexing and slicing beautiful.
I wouldn't insist on writing auto self = this; In C++, so I'm not sure why anyone would use "this" over "self" in Python...
Why!? That sounds like a silly idea. Pypy is not suited for everything, but django and flask are the poster children for it.
I suppose it would allow for early termination of the processing. 
It could more easily interoperate with fortran and matlab? That's like the entire language stack of my coworkers!
Is this answer helpful? http://stackoverflow.com/questions/15624070/why-does-scipy-optimize-curve-fit-not-fit-to-the-data
It can be difficult to decide if something is "worth" learning especially in the domain of GUI tools. Very nice write-up. I have played with Tkinter a little in the last few days, and I gave Kivy a spin about year ago. It looks like I need to try again...
Also you could probably do a fully compiled runtime dispatch system for python or a Python like language and it probably wouldn't have much difference in speed.
I have tried to get completion working in vim, NeoVIM, and spacemacs with anaconda. It has not been pain free... in fact, I've been down this rabbit hole so many times that I gave up and just used Pycharm. There are a tons of env plugins for vim and emacs. Some work, some don't... I am done tinkering with my editor. I just want to build stuff. I love anaconda and want to use it on everything. I love vim modes, so I use ideavim in pycharm and it has been great for me. Its not vim, but it is close enough. 
This is exactly what comments are for.
 for t in things: if t == target: found = t break else: print("Not found") raise WhateverException(target) print("Found: ", found) ... do stuff with found ... Old people who used to have to implement their loops as GOTOs will remember this pattern. So it's not really fair to say "no other language does this" as they likely all do it if you look at the generated code. You've probably actually done it with a while loop but didn't recognise you were doing so because the loop was named while and not for. But, what's the difference between while with index boilerplate, and for?
Github.
They have a blog? I went to Kivy -&gt; home page -&gt; gallery -&gt; kivy on android -&gt; site broke. Looking *again* I see the blog. But seriously, the "show piece gallery" is broken.
I miss the days when programming seemed like magic.
I won't repeat what others have said, so: 1) It's called Dropbox. You can configure what you sync and download on each machine. I'm surprised onedrive doesn't offer that? Or maybe I'm not. Microsoft is a bit behind with cloud. For 2) the *easiest* way as a non-programmer would be to get a wordpress blog and get a plugin for file access. You could also use google drive or dropbox to share the file with their own authentication, but they are not really designed for this. Do you actually *need* authentication? is a non-public URL good enough? 
It looks like it's a GUI based application that allows you to search for tracks on Soundcloud, then stream them using VLC.
I do this by making use of `any` / `all`, or with `next` (which you can apply to a generator expression and get the first match; wrap in try/except to handle the not-found case).
I legitimately think /u/antasi's way is easier to understand. It operates at a higher level; the name `any` is meaningful, and attention is focused on the logic ("give me `'whatever'` if `any` of the dict items meets the criteria, and `'not found default'` otherwise") rather than the process of explicit looping and breaking out on a match.
No, from what I gather it was basically a filesystem which transparently applies public key cryptography to its files. It essentially encrypts all the files with a particular public key. The only person who can then read the files is the person who has the private key.
Let me see if I got that right. It encrypts files so that only one *unknown* (to the user) key can decrypt them? I wonder if, we gave everyone in an org a different key, we could implement "secret crypto santa".
Your answer is more Pythonic, but I was trying to write it in the old style to show that it wasn't a new pattern and that Python wasn't "weird" for having it.
I'm out of town and it shut down. I'll have to look into it. I think I'm going to reduce the amount of random comments. Maybe to one a day or even one every couple of days. 
The problem is not with novice programmers. I know programmers whose code I loved but didn't know about for/else until I explained it to them. Code is made to be read, not written. For/else is a misfeature. Don't use it.
Haven't fully tested it, but it seems to work fine. That being said, as a fun exercise, I would suggest rewriting this to avoid the copy-and-paste. Here are some suggestions: Only need to import time once at the top of the program: import time Then make a list of questions and answers: questions = \ [ "What is the alter-ego of The Flash? A: Joe West B: Hunter Zolomon C: Barry Allen D: Eobard Thawne", ''Matt Lescher plays what Speedster? A: Reverse Flash B: The Flash (Barry Allen) C: Zoom D: The Flash (Jay Garrick)", ] answers = ["C", "A"] Then, loop through them like this: for index, question in enumerate(questions): time.sleep(1) print("Question {}: {}".format(index + 1, question)) answer = input("What is your answer " + name + "?: ") if answer.upper() == answers[index]: score = score + 1 print("Well done!") Note that it would be technically better to use a list where you store questions and answers together. I did it with separate lists because I think it is more intuitive for new programmers.
Yes, at least the decryption key is potentially unknown to the user. For example, secret agent Alice in the field could automatically encrypt all of her notes such that she herself cannot decrypt them, only her handler Bob can.
Isn't it backwards compatible? Try to download pywin32 through pip using the following command: pip install pywin32 
Thanks, will give it a go. 
I was interested in this in the past but after writing a few Android apps using Xamarin (C#), I've decided my next mobile project will be using the language native to the platform I'm writing for. There are too many intricacies about using a non-native language that it makes the whole project much more difficult, IMO. I love Python, but at least for me I can say I don't know C# or Python well enough to justify writing an app in either rather than learning Java or Swift as I go along. Trying to figure out how an API works in some language when all I have is Java documentation is a good way to go insane, at least for a hobby-coder such as myself. 
You only need itervalues()
This is the worst Python quiz I've ever seen. And I've seen quite a few bad ones. This is simply quizzing how well you've memorized boxing. And how well you can read badly formatted code. I am honestly a dumber person after reading these questions. 
True, that would be more elegant!
That was the first thing I tried, sadly it prints: "Could not find a version that satisfies the requirement pywin32 (from versions: ) No matching distribution found for pywin32" :/
On pypi, I believe it's listed as `pypiwin32` for whatever reason.
Thanks. Removed client id...im gonna put a user input to do this but could you explain a bit more why is % bettet than +
&gt; Because people don't know the language is a horrible reason This is correct answer to everything has been written here (imho). I used for/while/try-else thounsands of times without falling once in any of the problems mentioned here. Every other people reading my code learned something when they have encountered it, and they liked it. Its logic is fu**ing clear and so easy to understand. Where's the problem?
THANK, YOU! It worked! And I thought all I would get is "learn to google" from posting here.
Cool, thanks.
Mostly to keep your code looking tidy, but it is also reliably faster. But based on some benchmarks I've seen in the past, the fastest string concatenation method is `''.join(iterable of str)` Also, you can quickly format strings with the mod operator on strings.
Why use `__getitem__` when you could use `__getattr__' or `__getattribute__`? If the value is a dict, you can either set it to your proxy type on assignment, or upon retrieval. You would want to do proxy types for lists as well. It would be fairly simple to do.
This is correct, but I've found that factoring the for statement out into its own function is usually the cleanest thing to do.
Whoosh 
If 99.99% of people should leave a file alone, it shouldn't exist. Set them as internal defaults :)
Because I didn't want to touch the underlying data, I wanted to make just a "view" for the data. Also it would be harder to create values if getattr would be used. 
You wouldn't have to touch the data, just a container for that data.
I was asking because YCM already includes Jedi by default, so I found it interesting that you'd get extra features by installing it using pip.
You mean why does pip install globally? There's probably a good reason but I don't know it. Check out virtualenv to help with that a bit.
this is less explicit than using else
Fair enough. I've certainly seen this pattern plenty. It was just the usage of a single variable assignment with default that seemed against the spirit of providing a somewhat valid for/else example.
Pip shouldn't be global. You're supposed to use virtualenv so that you have your own local copy of the interpreter for each project. Pip will then install locally into that venv.
Lol I found the reverse true, the fact that you have to do `npm install -g` to install globally, and it'll just create a directory called `node_modules` without some init step bothered me when I started using `npm` But I got used to it.
Learn for a reason. Have a target in mind; a problem to solve. As every step brings you closer to that goal you'll naturally want to do then next one. You learn carpentry to know how to build a set if shelves, or a table. You don't learn it just to learn it. If you're learning python just because you think it's a good idea to know python, you'll lose interest pretty quickly. 
I could only see it being useful for a library that you want to be compatible with both 2 and 3. For project specific code, no, don't use six. 
so I realized this was because comcast is doing man in the middle attacks on my network. Assholes.
Sure you can do that. What I've done is getting value like in template engines (django). 
:-) I know it can be done different ways. My approach fitted into my project and I thought it could help someone.
the code above the loop isn't explicitly a fallback. You have to read the loop to understand that the code above the loop is in some sense "not executed" - even though it IS executed - given something that happens after it. there is no indication in var = "foo" for thing in things: do a bunch of stuff that var is meant to be set in the event of loop exhaustion without you knowing what "do a bunch of stuff is" while for thing in things: do a bunch of stuff else: var = "foo" indisputably does just that - regardless of what "do a bunch of stuff" is. 
I am learning Python because I think it's a good idea for me to learn Python and my interest is growing.
Well first i wanna learn the basics of python then move on to web development, game development, and GUIs. After learning python i would move on to learning Swift but learning swift is for different reasons --- Also wondering what should i use to learn python pythongrogramming.net or code academy :P 
This. I learned in my own by programming a game. Pick up a favorite board game and turn it into code. The fun part for me was writing the AI that plays against you. 
Well simple web programming is not too hard for beginners, they just full of concepts, I suggest you to just hop on to web programming tutorials, such as Django Girls or Tango with Django. When you start building things, you will get motivated easily,
It has a limit of one request per second, my script can run far faster than that.
Multithreading isn't really applicable here, as this is really a sequential algorithm except for the innermost loop.
Okay, good... and why do you want to learn web development, for example? Is it to get a job? (And if so, why do you want to get that kind of job?) Is it because you find the subject interesting or fascinating? Or some other reason? If you have several reasons, great, but it helps to know which is the most important to you. That most important reason, whatever it is, determines the best way to motivate and discipline yourself. 
it's truly unfortunate how dogshit slow any and all are.
[My learning order plan] --- * Web development (Python) * Game development (Python) * IOS Game development (IOS) This is for pure interest and i just wanna make a website that publishes the games I have made :) Should i dive straight into web development or should i start learning 'Basics' of python 
There is a great overlap between what Python provides either through the standard library or through popular packages and what Qt provides. I've been there as well. For instance, [QNetworkAccessManager](https://doc.qt.io/qt-5/qnetworkaccessmanager.html) provides a way to do network requests and we already have the great [Requests package](http://docs.python-requests.org/en/latest/) with Python that does pretty much the same thing. In [my recent project](https://github.com/remyroy/CDDA-Game-Launcher), I've decided to go for QNetworkAccessManager instead of Requests because it provides an easy way to get back in the UI loop to update the UI with download progress information. I've tried to stay as close as possible to PEP 8 for code style but it's a hard task with the mixed code styling from PyQt. Even if I have to pick a fight with Qt once in a while, I feel the use of Python is pretty good in this *glue the parts together* usage. I would evaluate the components provided by Qt for each usage and figure out the pros and cons of using them compared to what is available in the Python world on a case by case basis. If what Python provides works better for your case, go for it. If not, use what Qt provides.
Looping in python is generally quite slow.
Well, you can use mkvirtualenv foo --system-site-packages to use your system installed packages in your virtualenv. I think that's the best possible solution using pip/virtualenv. Another solution is using conda and conda environments, that really let you install and work with PyQt5 in an isolated environment. If you're interested, you can install pyqt5 using this command: conda install -c spyder-ide pyqt5 after installing Anaconda or Miniconda, and creating and environment with conda.
~~That's an if-else inside a for loop, not a for-else~~ I am a doofus 
Because CPython installs packages globally and globally is the easiest to get started quickly with for new users. It's generally going to bite you in the ass in the long run, but this Python practice dayes back to 1998 or so, so it's pretty deeply ingrained in package land.
The proper solution is for the QImage constructor to support the [Python buffer interface](https://docs.python.org/2/c-api/buffer.html) (now called memory views). In PIL for example, an Image object can be created from any object that supports the buffer interface, like a NumPy array, with [the `frombuffer` method](http://pillow.readthedocs.org/en/3.0.x/reference/Image.html#PIL.Image.frombuffer) without having to copy memory. I don't use Qt, but looking at the documentation, it seems QImage might support buffers: &gt; `QImage.__init__ (self, str data, int width, int height, Format format)` &gt; &gt; Constructs an image with the given width, height and format, that uses an existing memory buffer, data. The width and height must be specified in pixels, data must be 32-bit aligned, and each scanline of data in the image must also be 32-bit aligned. So you could just use NumPy arrays internally in your application, PIL to read and save files, and QImage to display them, all without copying. Try something like this: from PIL import Image img = Image.open("foo.jpg") import numpy as np array = np.array(img) height, width = img.shape[:2] from PyQt4 import QtGui format = QtGui.QImage.Format_RGB32 qimg = QtGui.QImage(array, width, height, format) ... Hope that helps.
Look up the wordnet database. One of the main things it does is group words into groups of synonyms: So pretty much exactly what you are looking for.
Yeah, OneDrive on Windows 10 doesn't allow individual file syncing so you have to sync a whole folder which is not ideal. (For example, I download daily files from an FTP into one folder, I only care about syncing files from like the last couple of months, not the whole folder).
I might look into that service, thanks. 
I am using pandas - any point in looking at bokeh? I use matplotlib sometimes, but honestly I mainly output files and hook them up to Tableau for visualization. 
I have written yards of both Python and C++ using the Qt framework. This has been going on for about 4 versions of Qt (C++ going way back). Yet that entire time I have sought to get away from Qt. wxWidgets etc. So far nothing. I have even tried OpenGL and Kivy as solutions. In C++ there is Poco to take care of much of the non-GUI that Qt does but for a good general purpose liberally licensed multi platform (and maybe multi language) library I can only dream. Even after all these years of using Qt, I still can't really put my finger on why I want to get away. The only thing I can really say is that I don't like the direction it has been going from pretty much Nokia on.
I need to incorporate this into some of the code I have that does merges between files to prevent accidental cartesian products. 
Thanks for asking this. I also only use jupyter. I only work with data and files though. Kind of replaced excel and Minitab with python. Never tried a text editor 
How about Pycharm? I also only use jupyter and it has served me well but I wouldn't mind branching out 
No. 
just use itervalues instead
Watch out for Lambda cold starts, they can be pretty jarring when first hitting a Lambda function. 
 That was really well written. Thanks for posting it! I can think of some great uses for this. 
The indentation issue is fixed now after disabling the caching for the quiz.
Wow amazing contribution!. I didn't know about poco, but is i need for several projects. Thank you very much.
I haven't done PyQt stuff in a while, but if I remember correctly, QT classes are more desktop-aware than standard Python modules. The network stuff in particular should be able to pick up desktop-wide proxy settings, whereas Python relies on environment variables that are usually missing. I agree that it's mostly a matter of choosing what works best for the individual case, there is no general rule. Yes, Qt bindings often force you to code in unpythonic ways; but when they offer more functionality than you can get with vanilla Python, it makes sense to use them. 
&gt; Say you want to add a web or command-line interface. Why could you not develop a web or CLI that uses Qt? QApplication does not require X and it's quite inexpensive to instantiate. CLIs in particular will work perfectly fine with Qt components. For web there are further considerations, but usually that domain maps poorly to desktop or CLI models anyway, so a refactoring/redesign would likely be required anyway. I mean, I agree on the overall concept of separating concerns; I'm just saying that Qt is not necessarily tied to the display interface.
Exactly - that is why I prefer PyGObject. It feels more pythonic and you are encouraged to use stdlib constructs and not Gtk ones.
cool description of your project bro
Wrong neighborhood, dude
Confirmed broken, in Chrome and Safari on OS X Yosemite, though from the Javascript 'undefined' error I'm guessing it's broken in all browsers.
How about working on a basic game? Always a great place to start project wise
Hi, Here is a version of your benchmark code archive with the Rust code in it: https://drive.google.com/file/d/0Bxqq0wByV0DsU202dV90bmlZeEU/view?usp=sharing To build it, use the command `cargo build --release`. Its work in progress though; I built it on a Mac with the Rust nightly (bleeding edge version). It was blazing fast but generated incorrect results, suggesting that the Rust compiler was optimising away things that it shouldn't have. I tried building it on a Windows machine with the Rust 1.5 beta, but Python crashed upon import. Maybe you will have a little more luck?
Not my fault idiots don't want to hear that their favorite language isn't good for everything. I use python for web development and love it, never would I use it for applications.
I tried the target='parallel' argument now supported in Numba 0.23.0. It rocks, parallelism is effective here.
The application is part designed as a part of a larger toolkit, all Python based.
Fixed, thanks for info!
First of all, it's interesting how the top two comments half a day after posting this appear to blatantly contradict each other. I take it as a sign my problem is not as straightforward indeed. For now my approach will be separating Qt and Python logic more or less, providing matching interfaces between the two as class methods.
Awesome ! That was missing. I know I'll use it.
On that note, I will take your comments into account and alter it if it becomes a necessary feature or an issue. Hopefully I'll find a more elegant way of writing it. Thank you for your input!
PyCharm will convert from a for loop to a comprehension for you, but not the other way around.
The description of wordnet looks good. Unfortunately I would need something like that for german ;(
I'm not forced to have a database to store the stuff. I create the database on my own, so I could create a different data structure for that purpose. What would be a better structure for searching?
For python 2.7 they have a specially packaged version of the older VS that you can download. https://www.microsoft.com/en-gb/download/details.aspx?id=44266 I haven't done any python 3.x dev on Windows so not sure the way to get MS compilers for free there (though it is probably involves downloading the Windows SDK)
It's really just about the design philosophy and has nothing to do with Qt. You could replace Qt with any other GUI library (or replace Python with any language) and this comment would be relevant. 
I'm not sure what you mean by "the possibilities of refactoring are quite limited in Python", care to elaborate?
Your right, my brain farted out on me last night. I feel like a goofus now.
I'm interested; where could I find that option? It's not obvious to me in PyCharm how to do that refactoring.
Care to elaborate on the "manual refactoring"?
I agree and I have bought a Xamarin license for this reason. There's also RubyMotion which has a free version (includes a splash screen). I've said before I think Kivy really needs a professional version for the cash injection this would bring as it lags behind the other cross platform solutions by some way imho (I would add the disclaimer to this statement that this is not a criticism of the platform and certainly not the guys working on it who do a great job).
http://upwork.com
It is free actually. The community (free) edition allows installation of extensions including PTVS (Python Tools for Visual Studio). The pro version has extras for enterprise like testing suites and profiling tools.
there is a project called jitpy that does exactly what you described for pypy (so you can submerse cpython inside of pypy).
Meetup.com, google, look for incubators and contact their companies
Instead of running some command in your editor: :'&lt;,'&gt; refactor You do the refactor yourself. def find_the_stuff(things): arr = [] for t in things: if selector(t): arr.append(t) return arr You transform that, by hand, to: the_right_stuff = filter(selector, things) A trivial example, but [there's thing that we can do by hand that an automated tool *can't* do](http://justanr.github.io/exploring-code-architecture). We can recognize complex patterns, things that an automated tool would just bugger all up into an incoherent mess. Iunno, maybe I've become a curmudgeonly beardo, but I've gotten by 13+ years without using an IDE* or automated refactor tools so maybe I just don't see the point. *: I'll own up to having some plugins for vim like autocomplete and stuff that'll show a signature and documentation so I fill in the right things.
I think that the way to make money off of open source is to give it away in exchange for people's resumes, and then place them, working as a recruiter. blogory.org PrivaCv.com
This is pretty neat!
Here's a _giant_ list of project ideas. https://github.com/karan/Projects They range in difficulty, but there are quite a few that would certainly take well over 20 hours. 
The problem is in pywin32 on windiws 10. Uninstall this package and spyder will work. However u will still be unable to use any packages that depend on pywin32. There is a new release of pywin32 version 220 which may solve but I CD not get it to install. Or use py2.7
There is no need to struggle with QString and QVariant in PyQt4 either. Using Python strings, datetime, etc instead is a simple matter of setting sip.api to 2. Converting all the code may take some time, but it will ensure compatibility with PySide and PyQt5 (just note that sip.api must be set at the very beginning of the code that is run) http://pyqt.sourceforge.net/Docs/PyQt4/incompatible_apis.html
Make up a few python/flask or python/django sites with various desirable functions, a good admin control panel with multiple users, and good templating. Offer screenshots or a live demo of the sites. Find places that would benefit from your work and offer them a free quote to meet with their it/management. It works better if you know people, but cold calling does work sometimes. One project I already had the code for and just had to dress up a bit was a employee anonymous complaint form. I already had a public note board all I had to do was change it so that only the admins could see the notes and add some email alerts.
Completely unintelligible. It's like your very own http://www.ioccc.org/ in python. 
Have you tried contacting any infosec people for their advice? Maybe somebody on the Security Weekly (http://securityweekly.com) or TrustedSec (http://trustedsec.com) podcasts?
A fresh install of Win10 with just VS2015+Python tools is NOT enough to avoid build errors
I've recently had good luck with a script called kernprof.py which requires line_profiler.py for it's functions. You preface each routine in your code that you want profiled with a "@profile" declaration and then call your program using kernprof like this: kernprof.py -l -v your_program.py After completion or crash it will display your line by line stats for each profiled function. Edit: Here's an example output... Total time: 8.37195 s File: palprimestd3-splitarray.py Function: is_prime at line 69 Line # Hits Time Per Hit % Time Line Contents ============================================================== 69 @profile 70 def is_prime(num): 71 231 143 0.6 0.0 if num % 2 == 0: 72 return False 73 231 201846 873.8 2.4 elif min(num % primes5) == 0: 74 205 118 0.6 0.0 return False 75 26 160608 6177.2 1.9 elif min(num % primes6) == 0: 76 5 4 0.8 0.0 return False 77 21 1104608 52600.4 13.2 elif min(num % primes7) == 0: 78 6 14 2.3 0.0 return False 79 15 6904562 460304.1 82.5 elif min(num % primes8) == 0: 80 return False 81 14 44 3.1 0.0 return True Total time: 0.000882 s File: palprimestd3-splitarray.py Function: next_pal at line 83 Line # Hits Time Per Hit % Time Line Contents ============================================================== 83 @profile 84 def next_pal(seedL): 85 231 172 0.7 19.5 strL = str(seedL) 86 231 115 0.5 13.0 strR = strL[:-1] 87 231 199 0.9 22.6 strR = strR[::-1] 88 231 312 1.4 35.4 pal = int(strL + strR) 89 231 84 0.4 9.5 return pal Total time: 8.37634 s File: palprimestd3-splitarray.py Function: is_Pprime at line 91 Line # Hits Time Per Hit % Time Line Contents ============================================================== 91 @profile 92 def is_Pprime(n): 93 1 3 3.0 0.0 digits = 15 94 1 2 2.0 0.0 seedpwr = (digits / 2) 95 1 2 2.0 0.0 seedL = (n * 10 ** seedpwr) + 1 96 1 1 1.0 0.0 range2 = (n + 1) * 10 ** (digits - 1) 97 98 1 7 7.0 0.0 outfile = 'PalPrimes-profile' + str(digits) + '-' + str(n) + '.dat' 99 1 92 92.0 0.0 datout = open(outfile, 'w') 100 101 1 20 20.0 0.0 thisPal = next_pal(seedL) 102 231 140 0.6 0.0 while thisPal &lt; range2: 103 231 8373232 36247.8 100.0 if is_prime(thisPal): 104 14 514 36.7 0.0 print str(thisPal) 105 14 69 4.9 0.0 datout.write(str(thisPal) + '\n') 106 230 169 0.7 0.0 seedL += 1 107 230 2088 9.1 0.0 thisPal = next_pal(seedL) 108 return 
the http debugging proxy helped alot. thanks
Or, static languages are becoming a fossil of times before type inference could offer dynamic types that were as good as static types for optimization and verification. Type inferred code approaches dynamic typed code as the theory and implementation advances.
I think you kind of missed the part where type inference exists to apply static typing without explicit type declaration. Type-inferred code without any type declarations whatsoever, is still statically typed. Besides, type inference can't do everything, there's still situations where you want to declare types, e.g. you probably **really** don't want a compiler to infer Dynamic/Union/etc. instead of throwing an error, and thus potentially introducing an error that will only come up at runtime. It also doesn't give you method signatures, usually can't be done across modules unless you sacrifice performance, and can sometimes be otherwise untraceable in complex code. Additionally, it's extremely difficult and often outright impossible to reach the performance level of code generators(templates, proper macros, compile-time reflection) with just building code via eval/exec/compile/etc, especially if you rely on generics(even lightweight ones) for dynamic dispatch. Ultimately, type inference in static languages is orders of magnitude simpler than the complex optimizations you need to do on dynamic languages for them to begin reaching the same levels of performance as languages like C++.
If I have code that uses type inference to deduce static types with no annotations, it looks like Python and not Java (or other vanilla static language). The final victory of static languages sure looks like Python. It's just Python with more static types under the hood. I can even code it further as if it were dynamic. The more advanced the inference, the more dynamic-esque things I can get away with before the compiler barfs or calls into the interpreter. Either can be perfectly fine behavior. Even if corner cases, interfaces and other explicit behavior are annotated, most code still looks like Python. 
I'm stuck in the same area and was wondering the same thing. I work in a restaurant and I'm 27 years old. I don't hold any degrees and actually didn't even finish High School. Around 6 months I started learning Python. Now I know all the basics, plus some extra. I'm okay at the following: All the basics * Working with API and geting data * Webscraping * Flask * NLTK * working with files and csv * Used a little bit of pandas, matplotlib, and other data analysis/science tools(not much) Scripts I wrote: A sentiment analyser and grapher * A webscraper that scrapes craigslist, then texts me if there are new results * A little social network website with Flask(didn't finish it, kind of shitty, but just made the basic functions of a social network app to learn Flask) * A "summarizer" (scrapes news articles and gives a summary.... I hooked it up with PRAW and now it takes every reddit news post on "r/San Francisco", "r/BayArea", and a few others, then goes to each url that links to an article scrapes the article and summarizes it for me.) But now what? I don't have any experience or hold anything. I get paid literally nothing for my current job and it becoming impossible to even survive (especially in the Bay Area). Would it even be possible for me to get a job. Even better could I even freelance or do something with my skills for some side income? How could I get job on Upwork.com when I don't have any reviews. Plus I don't want to be in over my head. P.S. - Didn't mean to hijack the thread, just trying to get the same answers without starting a new one. 
That's simple data analysis, too many people jump on the data science bandwaggon for my liking, thinking that it sounds impressive.
&gt; Why could you not develop a web or CLI that uses Qt? You certainly could. You can use Qt components as much as you'd like to build you application -- in the interface, in the domain model, wherever -- but the use of Qt is an implementation detail and thus shouldn't show up in your architecture *unless* you understand and accept how tightly coupled this makes your system. Such a tight coupling might make sense for small, one-off projects, but as the size of the application grows the more dangerous the coupling becomes. In other words, the interface is one module of your application, and the domain model is another module, and they should communicate via the language of your domain, not Qt types, even if both modules use Qt internally to get stuff done.
I haven't done C++ in 10 years. I recently started looking at C++14 and was stoked to see things like *auto*. Python is still a lot more fun/easy to program in but C++ is a great compromise between C and languages with higher level constructs.
The best answer I read regarding this was on *Stack Overflow Open Source*. http://opensource.stackexchange.com/a/210/1053 Quoting: &gt; You offer the software as free, open source software free of charge for every one who obeys the rules of the license. Companies who don't want to follow those rules, can still use the software, provided that they buy the software under another, commercial license. This model is called dual licensing. The weaker the copyleft of the license, the harder it will be to sell your product.
Btw, from what I understand SQL is also considered a special case of logic programming, since SQL queries state *what* you want from a database but not how to retrieve it.
No, But query languages like SQL and logic programming languages like Datalog are both [declarative languages](https://en.wikipedia.org/wiki/Declarative_programming)
Type inference saves on the finger-typing, but doesn't offer the power. What if I want a parameter to be either, say, a file name string or a file object? Or I have a callback function for XML processing - a dynamic language can simply have the function return any type it wishes to cast the passed element to. You can't do that with type inference either. Ceylon can have dictionaries with multiple value types, but little else can. D can add properties to existing objects, but again, most statically typed languages can't construct objects on the fly. So statically typed languages are still far away on the functionality of dynamically typed languages.
When I read that I thought if I was sleeping and this was a dream... What the fuck? 
I'm on windows 7.
Create a tracker of some sort. I love beer and wanted to track servings and ratings of all the beers I was trying. I built a Django site and have been adding features for over 3 years now. Now it tracks the brewers, styles, and servings for each beer; servings including amount and cost; optional ratings; a location API for marking where I had each beer; a responsive desktop and mobile site; charts showing amounts and costs for the past 7 days and 12 weeks; probably more I'm forgetting. People often ask why I don't just use Untappd. I use it as well, but my tracker is so much more detailed and I own the data.
Thanks for the correction!
Honestly, you don't need a degree. I personally dropped out of college and never studied computer science or any related field. The trick is to find a company that doesn't have hard and fast rules about education qualifications. Stay away from the larger corporations. They tend to be pickier about the arbitrary qualifications. Apply directly to start ups if you can find ones that are looking for junior devs. Furthermore, don't push that you're qualified technically. Show them how you've learned so much without taking a classical approach. This is actually more in line with how you'll learn on the job. Any company worth their salt will realize that if you are capable of learning on your own you'll be a much more valuable resource down the road. Honestly, hiring Junior Dev's in general is more about teachability than current ability.
time to increase my job security 10 fold
1. No one uses Python to write GUI applications, so the deployment problem doesn't really matter. 2. Speed is relative to other concerns. For scientific computing, all the calculating happens in a loop, so Python isn't slow. For webapps, the database is the bottleneck, so Python doesn't matter. 3. If you are a good programmer, you will learn many languages in your lifetime. It's not a big deal if one language is not perfect for all situations. No language is. Use it where it's good, and not where it's not.
I dont know what you are asking? do you want your concerns addressed or something? All I can say is if you take a career in programming, you will use many languages. So it doesn't matter what language they teach you with in school. 
 #1 is [flat](https://en.wikipedia.org/wiki/Deluge_\(software\)) [out](https://github.com/spyder-ide/spyder) [wrong](http://bittorrent.com). Hundreds of examples [here](https://wiki.python.org/moin/Applications), many of which are GUI applications. #2 is right but for the wrong reason (I don't know where you got the "all the calculating happens in a loop" thing). Packages such as Numpy, Pandas, Numba, PyCUDA, and others do the heavy-lifting with C/C++, but you're still programming in Python, so "Python" becomes fast. Yes, you're going to be limited by your slowest item (disk I/O, network, database, interpreter, etc). #3 is correct.
Ugh, arrays of list objects of arrays... this may be the worst abuse of numpy I've seen in an article in this sub.
Interesting. What is this virtual environment thingy? 
you are nuts if you think finance isn't extremely automated, with extremely talented programmers. you may be mixing up basic accounting and finance though.
This looks cool, but I can't try the site (500 error).
Yeah, and honestly, I'm very happy with pycharm, and I see no reason to switch.
What specifically do you mean? Scrapy is pretty good for that, but for sites that are very dynamic and use javascript, it can be hard since the page doesn't look the same until a lot of js has run, which may not happen in a headless browser. For that you may need to use something like selenium, which does use a browser.
I've been using selenium but it's really slow. I was wondering if there was a way go browserless,speeding up the whole process.
In addition to the others, find a local group that handles this. My state has a dedicated tech sector meetup group, any local startups will be a part.
If you're limiting yourself to like a 10 mile radius, maybe. Otherwise? Yeah, absolute bullshit. Show me.
Unless it uses lots of js to render, you should be able to use mechanize or scrapy with no issues.
I think it's hard to say in general whether multiple classes or a single class per file is more readable. A single module should be a modular unit that has some meaning when decoupled from other modules. Often, this is a single class, although it doesn't have to be. Additionally, a module should have some sort of unifying logical purpose. For example, the collections module makes sense the way it is: it's a collection of classes that define containers outside the builtin ones. If you need a container, either that module has it or you need to build it yourself. It's easier to keep track of because instead of from bag import Bag and from ordereddict import OrderedDict you have a module that clearly organizes and provides a logical hierarchy: each class is important on their own, but they all share an essential purpose.
I just split a side reading the features section. What a great new language!
I lost it at failing silently.
"Selenium" is not a browser. It's a library that talks to browsers. You need to profile your code before you start optimizing it. Otherwise, you have no idea if your changes are improving performance. They may very well degrade it.
Yes I wind up writing a lot of compresensions that look like your examples. But I often look at my code that looks like this and it feels wrong. I mean, it's practically a bracketed function. When comprehensions look like this, is there a better way? I know comprehensions are more optimized than, say, appending elements to a list within a for loop, so I'm not sure how to refactor them efficiently.
Thanks.
Is there a tool I could use to do this?
Thanks.
Amazing.
You're welcome!
https://github.com/samshadwell/TrumpScript/blob/master/test/test_files/fizz_buzz.txt Make Python Great Again!
&gt;You do get that it's a parody right? right? Low energy comment!
Holy Christ this is terrifyingly great.
Beyond strings to const, a huge problem with DT is type instability. This is something that I've seen leads to runtime errors time and time again. Not in a "oops I don't know why i multiplied "the" by 3", but in a "my demo just crashed in front of my customer" way. Particularly for languages that are meant to be used interactively, there's a tradeoff. It's also a problem on large, multi-person projects. Allowing both cases as the previous example did, you now have to be sure that the function is type stable for both inputs. Multiply this by composition across the system. Unless of course, one isn't building systems to be composable (often the case in python because of the poor guarantees), which is also unproductive. If one's experience is primarily Turbo Pascal / Java and seeing "bits" of D, I'm not surprised that DT seems worlds better. DT _is_ more productive than those languages, but in the long run, that's not a very high bar and DT of the python kind is a poor man's band aid. You say simple static typing, "not in the haskell style", but that's exactly what i'm referring to. Haskell won't be the language of the future, but the principle it has shown that good language design means you aren't trading safety for flexibility is the future.
&gt;The worlsheet you've linked isn't any more basic than countless other resources. Zed Shaw distinctly did not explain the difference between variables and vegetables in his book. I checked. Variables got essentially a one-sentence explanation, like most topics he covers. &gt; It's just aimed at a much younger age It wasn't specifically aimed at a young age; it was aimed at people who didn't know anything about programming computers. &gt;LPtHW is written for adults, but still assumes almost no knowledge on the reader's &gt;part. There's too little teaching material for something aimed at those with no knowledge. 
Back in 2012 at his PyCon keynote he talked about the very, very narrow window under which he'd support changing the syntax, even if PyPy needed it for performance improvements. Now he's changed syntax just to give us yet another way to format strings? And complaining on the mailing list about people quoting the Zen Of Python against adding another method? When a valid criticism used to be "this would be just one more thing people have to learn"? I fear Guido has been kidnapped and Python is being run by Larry Wall in a Guido mask!
woosh
I thought so but he does appear to legitimately support Trump.
As with all things, this can be overused. As you say if the actual type become to difficult to know by looking at the code, in many ways it's very similar to duck-typed code that works...it works, but you can't tell by looking at it. Haskell programmers (with very good type inference) have dealt with this for a while and their solution afaik is to be explicit with the types whenever the clarity of being explicit beats the cleanliness of leaving it out...ymmv.
...But Trump doesn't follow a script.
The primary objective of the article was educational to conceptually understand KNN. Welcome alternative implementations as feedback 
glad if it helps
Found the Hillary supporter.
That is why the script follows Trump! 
Wow. And I thought I was excited when I found out about ArnoldC
Isn't packages in Java the analogue of modules in Python?
&gt;There are no import statements allowed. All code has to be home-grown and Amerian made. Lol
Why is it not ideal? 
AFAIK Java packages only contain classes, they can't contain data or functions, that's only available at the class level (as statics). A Java package is just a name, a Python module is a full-fledged object. So no, packages are not the java analogue to Python modules.
A better place for this would be in: www.reddit.com/r/learnpython www.reddit.com/r/learnprogramming Also in cases like this (homework-like) it would be great to show what you tried and did not work. 
I would prefer to go for option 2. In other words, should I code and place a check_transactional_emails() function that is run at every relevant action? I've already (very lightly) used django signals in my project. Would this be a good time to reuse them? Oh, and thanks for the answer!
Maybe a different problem then. But maybe it same so worth a try to remove pywin32 and it may help.
Ok, NP 
The UI of dropbox is written in Python.
As a general rule of thumb I say comprehensions should be kept short and to the point. You should never nest them like in the ones above, instead split them out into multiple generator comprehensions. If you can't, use normal loops. There are exceptions to every rule, though. I once wrote some code to iterate over values in the windows registry to detect what arduino devices are currently connected to which ports. If I left it as loops and if statements I ended up with a block of code indented 11 times, but converting it to a comprehension meant basically just removing the colons, putting it all at the same indentation level, and moving the inner expression to the first line. The was no nesting, but I feel that it greatly improved readability while still being about 10 lines long. This is a rare case, though, and I definitely did it for readability, not performance. Unless you know you're working with tens of thousands of values don't even worry about performance. Even if you are, use a profiler to determine the best code. 
&gt; * Instead of "True" and "False," we have "fact" and "lie" I'm gonna be typedefing that
Is this enterprise ready?
Or you can do it [in javascript](http://play.elevatorsaga.com/) with instant feedback.
[Automate the boring stuff with Python](https://automatetheboringstuff.com/) is a good place to start, its in the side bar with some other useful sites. Just fyi /r/learnpython is a better place for this kind of post in future. 
C+= !
Thanks alot for the link, also was not aware the subreddit existed, sorry about the post. 
&gt;The language is completely ~~case~~ insensitive FTFY
Isnt mine. Just wanted to share it cos it's awesome :)
Wait, it can't capture him perfectly because it doesn't completely destroy the system whenever it's installed.
Java does need to be installed. It's just that it is much more common to have the the JRE installed than python. Also, distributing a C++ app is also not as straight forward as you make it look. You need to make sure the user has the required libraries. I will concede that it is much easier to deal with than python, since it is a fairly common task and there are a lot more resources available to deal with it. If you want alternatives to py2exe you can look at [pyinstaller](http://www.pyinstaller.org/) which is cross platform. [py2app](https://pythonhosted.org/py2app/) is the mac equivalent to py2exe. As for linux (besides pyinstaller), most distros have python 3 available on their repositories, so if you make a package you can make it depend on python 3. Otherwise, have some instructions on what is required on the documentation. Also [nuitka](http://nuitka.net/) will try to translate your project as is to c++ and compile it, which may give you a performance boost (may not work with all code yet, so you have to test it). [cython](http://cython.org/) will do something similar, but you may need to do some code changes to optimize it.
That would be vanilla Python, right? Everyone has equality and freedom to do as they want with it since it's open source!
Breaking too much code is become unreadable. Reading source code written by other Java programmers is very hard because they break their code into multiple files, make it harder to follow the flow of the program and understanding what this piece of file do and what is this file connection to other classes. In Python we put the multiple classes in single module make it easy to read and follow the flow of the program. We only put the classes in multiple files if code become very big and need to put the critical parts of the code into multiple files, to make it easily accessible by other team programmers.
Doesn't work for me, no clue why. Also, I don't see the equivalent of something like that in the menu bar?
Seriously, though, how can you go wrong with something called "imperial"? Those weaklings oversees hide behind all their "metrics" and "standards" -- that's not what America stands for! /s
[removed]
Its very clever, but political propaganda should not be allowed in /r/Python, this is only going to encourage more of these types of posts that have nothing to do with Python.
&gt; What if I want a parameter to be either, say, a file name string or a file object? Use a sum type.
It's written in Python
This script language is doing a tremendous job. Absolutely tremendous. All of the competing scripts are disgusting.
There is a lot of talk about readability and such, but the reality is that Python would completely break if you only allowed one declaration per module. This question actually cuts to the very core of how Python has been designed. Since everything in Python is first class, there is no real way to distinguish between allowing only one class per file or one of anything else. For example: myClass = functionThatReturnsClass() myClass = namedTuple(...) So enforcing this within the current system would require awful hacks and could probably be circumvented regardless. If you were to change import to only import the first member of a module into the current namespace you really haven't achieved much. Anything that was a module just gets wrapped in a class and the class itself gets treated as a module. Remember that in Python a class can contain any number of declarations, including those for other classes. Syntactically it would even look the same to the user of a module. The easiest way of thinking about this is that Python already only allows one *thing* to be imported per file, and that thing is a module.
you have db.insert_one(mongodoc) you want collection.insert_one(mongodoc) It'll help you a ton to ~~get rid of~~ fix that try/finally and actually let it produce an exception. ;)
That isn't how learning works. Based on your name and racist posts, I'm guessing you probably don't learn at a regular pace.
Creeping me much? I am actually anti racist you moron
You don't need the lambda in that case and just pass the function directly, though. Or am I missing something? :)
C Plus Equality: Highly offensive and oppressive Trumpscript: HILARIOUS!
Trump, despite his many failed companies, has never lost his personal wealth. So any number assigned to trump should never be decremented.
Oh god. Which ones?
Look man, I'm not exactly a Trump fan, but the guy does nothing but win. (Before someone says something about how he's declared bankruptcy, thinking of bankruptcy as losing is something the wealthy have convinced everyone else to do. Bankruptcy is neither winning nor losing; it's another tool to allocate capital, and the risk that you might declare it is baked into every decision any entity makes when it deals with you, so you can't even consider it failing to keep your promises.)
Thanks for the detailed response!
What is the error you're getting? It's hard to debug your code without knowing what's stored in your lists/dicts.
This may be internet lore (so please correct me if I am wrong), But I seem to recall the game [SimTower](https://en.wikipedia.org/wiki/SimTower) came out of an elevator simulation game. In the end, that was often the key between a successful tower and a failure (though, the game would play fine without user input so you could get a small but positive bank flow and then leave it over night...)
Well, `__getitem__` gets called when you access your data through ['MAXSTATES']. It seems that your class DataSet is not designed for that kind of access. If you implemented that class yourself, you can provide a `__getitem__` function, otherwise you will have to access that data differently. edit: formatting.
I am newish to python so this may not be right, but I think, at least from the little you told us, that your program is just begging for some object oriented approaches. It would likely make your life a lot easier! And you can also include `__ne__`,`__lt__`,`__gt__`, etc methods (see [this article](http://www.rafekettler.com/magicmethods.html))
I feel your sentiment. It is damn hard to choose a language to really learn. I also agree that the distribution story for Python is, frankly, pathetic given the rich and diverse ecosystem. I have been thinking about this quite a bit for the last few days and I don't have a good answer. I would like to be able to distribute my app in different ways... something other than Django, Flask or the command line. Hell, even the command line is problematic for lay users that are NOT developers. It would be nice if the community embraced this post: https://glyph.twistedmatrix.com/2015/09/software-you-can-use.html
Thank you. What are your thoughts on codecademy.com?
Thanks
Editting the code for the class would actually make things more complicated in this case. Would using the itemgetter() function work at all?
I want to see a firewall implemented using this.
No, since itemgetter() will AFAIK always call `__getitem__`, as well. Your class must have some mechanism to access the data, - just use that. ;)
Wait, is this for real? I FUCKING LOVE THIS!!
Look at the examples you posted from the wiki. I didn't look at all of them, but in a 5 minute click-about, I found: many of them are dead-dead. Many of them are built for one platform. A lot of them are using Python &lt; 2.5. The reason Python isn't used to create more GUI apps is due to the fact that distribution of Python is HORRIBLE for anyone other than programmers. Don't take that from me, read this: https://glyph.twistedmatrix.com/2015/09/software-you-can-use.html
At the risk of contradicting the Imperial golden hairpiece, the US has never used Imperial units. It uses [US Customary units](https://en.wikipedia.org/wiki/United_States_customary_units), which are based on English units before the British Imperial system was introduced in 1824. A number of the Imperial units are different from US units. Also, US customary units have been defined in terms of metric units since at least 1893. 
&gt; This will be Yooj! FTFY
Trump is a leech who got city handouts in his real estate deals. Is that "winning"?
It's a pun on "Politically Correct" which is a Trump talking point.
&gt; political propaganda should not be allowed in /r/Python Unless it's done by people pushing Python 3 as a replacement for Python 2, right? /s
I can't tell if you're serious.
Solved it. See edited OP. My attempt at a solution, in the above comments, was trying to access an element that didn't exist which is why it wasn't working. Sorts the list properly now. Spent all day on this, only had to delete 3 characters. Oh the joys of writing code. Cheers for the help.
That bankruptcy shit is a perfect example of the kind of world we get with people like Trump and Clinton, and I'm thinking of Biden specifically who they paid to make sure student loans weren't dismissible. Bankruptcies are horrible experiences for people and they've done nothing but make it more difficult to get them and these conflict of interest traitors who provide "advice" as part of the deal. It's a scam and it's time to fight back.
You know what I say... Ghandi is dandy, but liquor is quicker! Ha ha... quicker.
Fiorina Biden Fiorina Fiorina Biden Fiorina FiorinaBiden
I have been summoned! So what'll it be, master?
Codecadamy is a good start, it will cover all the basics and you'll pick up the general idea of progamming. I did all the courses for Python in a week, week and a half, just POUNDING them out. I loved it, I'd suggest Codecadamy as a start. 
Well, he was a Democrat for a long time. 
&gt; All numbers must be strictly greater than 1 million &gt; Nothing is 1000000 minus 1000000. 1000000 is not &gt; 1000000, does the spec match the implementation?
Well it's not ideal in the context of comparing it to pythons modules. Everything has to be explicitly stated it's part of the package and what not but I guess that's javas nature 
Seems to be fine for me: http://i.imgur.com/TBpdmnN.png Have you actually tried to read [this](https://support.google.com/mail/answer/78754)?
Python can set arbitrary properties on objects, and many libraries/frameworks rely on that. How would you write an orm for julia? How would you attach arbitrary properties to request object in middlewares? It might be that I am used to python way of doing things, and different solutions are available in julia, but indeed I don't see people who intensively used python dynamic switch to julia. Some of them use go now. How in your opinion julia does in web department? I've found one web framework for it, and every other language has plenty (whether it makes sense or no to have so many)
That was done with Python? What a waste of resources! All it needed was one html tag! &lt;Trump&gt;Yes!&lt;/Trump&gt;
"Hmmm, who is this? Ahh, a submission asking someone to identify tea." I have you now.
Bluebream is listed but not real tools in use by real people? This list is pointless. Things like Lektor and Cookiecutter should be there.
Yes, post your code to something like pastebin.com and then give us the link so we can look at it-- the advice/criticism you get may benefit somebody else down the road!
Top. Men. 
No, america is Great.
https://github.com/TheFeministSoftwareFoundation/C-plus-Equality
I've talked to some of the best enterprise programmers, some of the very best people in enterprise programming, and they tell me this will be ready to run everything on day one. They tell me that on day one, this software will be doing all of the big things it needs to do to that hasn't been done yet. 
Why don't you have a car?
Relax man, the whole thing is just a goof
I didn't accuse you of being a robot.
Oh god, posting anything even close to pro-trump in /r/python? Be ready for those reflex downvotes.
Of course you can set arbitrary properties in Julia:http://docs.julialang.org/en/release-0.4/manual/types/#man-parametric-types Escher looks amazing: https://github.com/shashi/Escher.jl When Julia can compile to wasm, we can write our front end, backend and scientific code in Julia. For middleware check out mux: https://github.com/JuliaWeb/Mux.jl I don't know if Julia will take off for web stuff, but why shouldn't it? It is almost as dynamic as python, atleast as fast as go, has coroutines, channels and multithreading is coming in the next release. I think its just a matter of its lack of recognition as a general purpose programming language...but It will only take that one or two person team build the super fast and scalable multithreaded Django like MVC that can render front code written in pure julia to make it big for web. 
You never stay on subject to begin with so why bother.
You know what, I think I have you figured out. Your bold-faced lies, your accusations and subsequent denial thereof, your passive aggressive way of turning this argument around on me. You're just like my ex.
Well too bad because honesty is the best policy.
There's a documentary about it on Netflix but I just saw this article while I was searching for the name of it for you: http://philadelphia.cbslocal.com/2016/01/11/ray-didinger-donald-trump-destroyed-a-football-league/
There is no objective measure of hours to experience. Your proficiency has less to do with the number of hours you work than it does the challenges you solve. What /u/ScM_5argan is saying is that you need to work on real-world problems (either those you make up for yourself or work-related) in order to actually gain proficiency.
I just spent two hours pounding it out. I am wondering how far I can get with codecademy. What do you think is sufficient time devoted to reach more or less average level.
You always have to have the last word, don't you?
&gt;Of course you can set arbitrary properties in Julia I am not sure if I get it. I meant this in python: class Request: pass req = request() req.country = 'US' # most middlewares do something like that escher: looks like absolutely great tool for very narrow set of usecases. I write mostly business logic that usually feels good in neatly separated modules, namespaces and classes. From my point of view this is not pretty. I realize that for a scientist it may be fantastic, but I am not sold. &gt; I don't know if Julia will take off for web stuff, but why shouldn't it? Because it solves problem most webdevelopers don't have. Really, speed is great, and many people want it, but still majority of web projects never becomes next facebook. Speed of development beats all else, except relatively few cases and then what you want is exactly what you have, just faster. Python gathered domain knowledge (for web, science may be different) Julia doesn't have, while some other languages (like dart or go) do, and for most people this is preferred path. It may be a matter of time and marketing. Its good to have a choice of interesting languages. Btw that one more thing Julia suffers from - for a developer there is no point in learning something that is just slightly better. The same time could be invested in learning something radically different and more beneficial. 
Thanks for the suggestions, all sound promising, I'll give webassets a try it seems very dynamic.
Keep in mind that Python / C++ / &lt;language du jour&gt; is just a means to an end: giving a computer a set of instructions to follow. There's more to a programming job than giving a computer instructions. You'll need to learn how to organize your data (ADTs), how to organize your program (possibly using OOP, at least using complexity analysis), what algorithms to apply to your data, and possibly some domain-specific skills. Think of Python as a tool, like a screwdriver. Of very limited use on its own, but very powerful when used in conjunction with a wider set of tools and skills. This is all to say, don't become so focused on learning Python that you lose sight of your larger goal: to become a proficient coder. You might poke around the online courses you're considering and find other topics to study. As I said above, ADTs and algorithms may be worth your time.
I'm not sure how the code can even run: ``` db = conn.RXMMongoDB ``` I don't see conn instantiated anywhere nor is it a string.
TrumpScript in action from the [github test scripts](https://github.com/samshadwell/TrumpScript/tree/master/test/test_files): &gt; Make Hillary cry by getting 100000000 votes. If, Hillary is 1000000000 years old; We should let her know: say "lol you're so old and unsuccessful"! Or else: say "lol you're so unsuccessful"! America is great
Oh, I see. I misread your comment. 
This clearly triggers undefined behavior. In this case we end up invading Iran.
Trivial, and unidiomatic Python. Hint: nobody writes `if dinner == True:` or `dinner == False:`. It is not the case that `if not dinner` is the same as "if dinner is False", depending on what the meaning "is" is (it doesn't mean `is`, which hasn't been defined).
Questions like this are better in /r/learnpython than here (sometimes people ask about reddit bots there) but a more specific sub for your question would be /r/redditdev
I almost add an asterisk on "in a loop" for pedants. Thanks for making me glad I didn't. 
[`vmprof`](https://vmprof.readthedocs.org/en/latest/) claims to be a lightweight statistical profiler. Maybe it will have less overhead for you.
I'll make sure to post there from now on, apologies and thanks. Embarrassingly enough, I did name the file semantics3. After changing the name and running though, now I get this: ImportError: No module named products 
ehhhh.... not really. he supports universal ACCESS, which is a WHOLE nother beastie altogether. he wants to do away with the way it's a huge plethora of providers and plans and wants one national market. 
&gt; To use to check for equality, do the same but append a ? I think that's my favorite feature.
Ah my bad, I edited it now. Still, I can't see it working. 
Even as a scientist I like some of the American units for daily tasks better. The only annoying this is the conversion factors
Ah, that's neat. All the transpiler just needs to produce syntactically and semantically sound C++ and then the actual C++ compiler will handle optimizations -- which makes complete sense. To be clear, the Github example produced code would be optimized into a TCO form?
Build something, as someone else said. Codecademy is only good for teaching you the basics. It won't put you past the absolute basic "beginner" level. I'd say the only real way to go from "beginner" to "novice" is building something. Get an idea, break it down into smaller parts, and find out how to accomplish the smaller parts one at a time. In between these, maybe the first thing you do in the morning every day, is do code katas on a site like codewars.com. This will help you learn how to push your knowledge on how to accomplish specific tasks and expand your Python "vocabulary."
check the learn python subreddit - someone they may have encoutnered this issue before /r/learnpython if you can't find any solution you can open an issue at the pyinstaller github https://github.com/pyinstaller/pyinstaller make sure to provide as much info as possible with respect to your build environment: What OS are you using?, What version of python?, how is your python distribution installed? (Anaconda, Homebrew, ActivePython, installed/built straight form source from python.org, etc...) This doc will help with that: https://github.com/pyinstaller/pyinstaller/wiki/How-to-Report-Bugs#information-we-need 
&gt; make oracle pay for it ftfy
So you're the guy everybody avoids a the party...
Thanks, this is a great post. Here are a few more sites for those interested in learning more as I am: http://www.analyticsvidhya.com/blog/2014/06/books-data-scientists-or-aspiring-ones/ Best.
I was in your position about a year ago and I can say that it's certainly doable. However, it takes some real discipline. I think I spent about 2 hours every weekday and about 4-5 both weekend days learning over the course of 10 months. My track for Python for data analysis was as follows (in order) with a few books and interactive education sites mixed in (on mobile so forgive formatting and typos): **online courses** * [codecademy](http://www.codecademy.com/en/tracks/python) * [Python for beginners](https://www.udemy.com/python-for-beginners) * [MIT OCW 6.00 Spring 2011](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00sc-introduction-to-computer-science-and-programming-spring-2011/index.htm) * [Python for data analysis](https://www.udemy.com/learning-python-for-data-analysis-and-visualization/#/) * [Harvard Data Science](http://cs109.github.io/2014/index.html) **Books and interactive tutorials** * Python for Data Analysis: Data Wrangling with Pandas, NumPy, and IPython * Data Science from Scratch: First Principles with Python * Automate the Boring Stuff **Practice** (probably the most important part of my learning experience) * Codewars * Project Eular I'm not saying this is the best approach, just what I did. Note I also read some statistics books as well as an SQL book. Take a look at /r/learnpython as well. Hope this helps and good luck!
Thanks a lot. 
pretty neat, wish there was one of these for all CTCI design problems
Its indeed "too entrerprisey" - mainly due to the fact that all apps are different, and not all of them need those parts - or have them big and significant enough to worry about them at the architecture level. Starting to think from "how generic architecture should look like" point of view is not particularly useful for anyone, since no project is generic. Most of your code is structured around http staff. What you should do instead is start with defining data models and data flows, and design architecture to support those in most natural and invisible way possible. The more tech details you will *hide*, the better.
why do you want them all in one file?
And I was just ready with my awesome answer. :0)
I try to catch all of his talks, along with Raymond Hettinger and Ned Batchelder
Needs more jQuery.
Well, he hasn't actually gotten even 1 vote yet. Either way, he'll probably get them nomination, unless a bunch of other candidates drop off before Super Tuesday, then someone else may get it. But for me the scariest part is that 31% of Republicans(~45-50% of the population) wants him to be presentient... There's no way he'll win the general, I'm pretty sure you could put him against a dog, and he'd still lose. But that's still a scary number.
He's got plenty of polls under his belt, though, and while they don't count, they do continue the positive picture he's been giving so far.
Much more importantly, pints of beer are different sizes in the two countries. An American pint is 16 US fluid ounces which are about 29.6 ml each, giving 473 ml. An Imperial pint is 20 Imperial fluid ounces of about 28.4 ml each, giving 568 ml. Basically Americans are lightweights when it comes to beer. :P
I'm really happy to see a thread like this in /r/python, because it *is* a topic that seems to be underrepresented in our community. Many of the resources on high-level software design and architecture seem to be written for Java and, to a lesser extent, Ruby. *Clean Code* and *Growing Object-Oriented Software* use Java examples, and Uncle Bob gives talks at conferences on Rails. The core ideas of these resources aren't language-specific, but I feel that it's crucial to have good, concrete examples in a language one is comfortable with to really understand why architecture matters and what good design looks like. In any case, thanks for the post, and I intend to study your gist when I have a bit more free time.
By the end of it I forgot it was weird at the beginning, hehe.
I like to keep JS and django very decoupled and have written [django-webpack-loader](http://github.com/owais/django-webpack-loader) to do so.
The true hallmark of a rice kid
Oh neat. Would you (or anyone else) happen to know what the main difference is between the two libraries? They both look like they were started around the same time: [vcrpy 0.1](https://github.com/kevin1024/vcrpy/releases/tag/v0.1.0), [betamax 0.1](https://github.com/sigmavirus24/betamax/releases/tag/v0.1)
Honestly, I'm not a big fan of simple coercion wrappers. If I can replace it with a lambda, there's a good chance I don't actually need it: def use_exponent_df(creator): ... And passing `exponent_df` vs `lambda n: Dataframe(exponent(n))`, or even just giving it the actual dataframe instead of a callable (though, I do see a benefit with lazily computing a dataframe if I *might* not need it). Iunno, there's pros and cons to each approach. Your decorator is neat, and while I don't see a need for it, if it fixes your problem use it. :)
Indeed, a very good lesson. While I was already familiar with the concept from my foray into Haskell, and an attempt to make my Python code more functional, seeing it outlined like this does make it a fair bit easier to think about.
I use https://pypi.python.org/pypi/relatorio
Thats cool and all, but man, spoiler alert?
Why not: def fetch_ddg(word): # fetch from ddg return requests.get(...) def pluck_dgg(response): return response.json()['Definition'] def find_definition(word, plucker=pluck_ddg, fetcher=fetch_ddg): return plucker(fetcher(word)) Now you can supply dummy pluckers and fetchers to find_definition and thus test find_definition itself without having to resort to patching libraries in your tests. This makes the tests more functional and thus more understandable as well. EDIT: As a side-benefit, the functions are now function-scoped which makes the name lookups faster. So if you have to call this in a tight inner loop it will be faster than on lookup needing to traverse to the outer scope. But this should not be the only reason why you would want do it. EDIT2: Especially in a function doing I/O this sort of scope optimization is silly. tl;dr; If you want to split this stuff, make it composable! Don't fall into the trap of writing Java in Python.
Using PRAW and Oauth2util will make things much simpler. I suggest going to the v1.0 branch on my repo, it has a karma counting script in it.
ok thanks!
Standard measures (a shot) in the UK are usually only 35ml (unless you're in the shittier bits of England where they are 25ml for some weird reason) The US's are apparently ~44ml. So there's that.
I use nuitka but the code it produces is still python (cpython constructs). This project doesn't require libpython, thus can work on arduino or such systems. 
They were likely both inspired by [Ruby's VCR lib](https://github.com/vcr/vcr) mentioned in the vcr.py readme -- hence the VCR theme.
Dependency injection is simply providing some objects or functions rather than having the method/constructor create them by itself. I used to be confused about this too and assumed that you need some complicated framework for it like Spring in Java, but yeah, it's actually not that complicated.
awesome, thanks!
virtualenv+pip. I am not familiar with Hadoop, but I assume you can make it use python from your virtualenv.
If your team considers this trick an idiom then it's ok. Otherwise ternary operator is more readable. If you are debugging and need to change some behaviour you can call the boo "debug" and make it true or alse the line before. "Workarounded" version is on par wwith ternary operator in functionality (although there might be some other quirks) but even less readable than ternary operator.
To some degree, this sort of architecture is just an ossified version of basic software principles, and I tend to think that something similar should just emerge from your code, rather than being made explicit. But then, I work in small teams where that's practical, and I appreciate that if you have a bunch of junior programmers, they won't always appreciate why making SQL queries and generating a string of HTML from that inside a web view is not a perfect separation of concerns. I like what you've done with the Gist but what I find from all approaches like this is that they only look clean when you've got the minimal working example. Once it becomes a proper app, reality starts getting in the way with questions like: * if FrobRepository is created at import time, how do I parameterise or test that? * if FrobRepository is global, what happens if I'm running in a threaded or forking server? * If I'm running Flask, what do I do about these HTTPViews - which do I override and which do I replace? And what happens when I'm not running Flask? * I need to return 1MB of search results, and stream them to the user - but View assumes it's going to get called just once, rather than multiple times (eg. like Flask returning an iterable) - do I need a separate parallel interface for that? And which part of the pipeline handles getting that to the HTTP server (or servers)? * How do I return something more informative to the user than 'InvalidFrobInput'? 'adjust input and try again' is not a great user experience. But maybe that should depend on who is requesting the method? But should such information leak into FrobService.create_frob?
It's pretty unreadable to be honest. If you need comparison for more than two items then just make a function that uses `*args`.
For the first point, it's basically DI by hand. Using Flask as the example, it could be created in `make_app`. You'd test/parametrize it like anything else. On the second, you wouldn't be using a dictionary in a real application (for the data store), instead you'd wrap your SQLAlchemy models with the repository. Which sounds really crazy until you try it. In a basic Flask app, view would simply call `render_template` or `jsonify`. Similarly, it could return an instance of StreamedResponse. "adjust input and try again" isn't great from a ux perspective, but it could be changed at any point you're comfortable with. The second argument is used for anything extra the domain wants to communicate out. They don't necessarily need to be headers or supplemental information.
thanks!
Because applications tend to be more complicated than conference talk examples. Also, I'm not sure how my pieces aren't composable. Or how taking inspiration from another language is bad.
scraped from distrowatch https://www.reddit.com/r/Python/comments/41kn28/looking_for_a_table_of_python_versions_shipped_by/cz3tyh7
A few relevant lines from [The Zen of Python](https://www.python.org/dev/peps/pep-0020/): &gt; Explicit is better than implicit. &gt; Simple is better than complex. &gt; Sparse is better than dense. &gt; Readability counts. &gt; If the implementation is hard to explain, it's a bad idea.
Yeah, this is what people who didn't care about readability did before the `g = a if boo else b` construct entered the language. If you do that _today_, your code isn't going to pass code review.
Maybe I wasn't clear, but my point wasn't so much "how would I do these things?" but more "this stuff starts changing a lot when it hits the real world". Lots of things look clean in sample code but start to get messy in bigger code bases (including Flask itself, incidentally). &gt; Using Flask as the example, it could be created in `make_app` What `make_app`? Most Flask examples expect you to dump an app global variable somewhere (which is one of the awful things about Flask, but I digress). But assuming you've wrapped this in a nice function, now you have the problem of getting access to your CreateFrobAction etc from whatever Flask views you have. Push them all into `app`? Perhaps. &gt; you wouldn't be using a dictionary in a real application (for the data store), instead you'd wrap your SQLAlchemy models with the repository That's a leaky abstraction, since the repository is depending on a certain implementation of the back-end to be safe. &gt; In a basic Flask app, view would simply call render_template or jsonify. Similarly, it could return an instance of StreamedResponse. Same - if my abstract views need to know about Flask, why would I bother having them, and not just code it straight into the route-handling function? It feels like layers for layering's sake and doesn't seem to add value in that case. The service and repository still add value, but this is why I prefer to let my project structure emerge, otherwise it's easy to create abstractions up-front that turn out to only get in the way of the concrete objects we're using. 
I disagree with his thoughts about the clean architecture. I don't think he's interpretated it wrongly, more I'm not a fan of his (and Gary Bernhardt's) interpertations - mostly because there seems to be some odd, mind bendy things you need to do for something as simple as database filtering. Rather, I prefer to define my things that want to do IO as abstract base classes (closest thing to that interface keyword as we're got) and then create implementations at the highest level and dependency inject them in. My core then doesn't know if data is coming from the database or Ms. Cleo. Rather than only passing simple data structures, I also allow for interfaces defined in the core to be passed in. Database filtering is still a little odd but easily overcome with something like the criteria pattern. Edit: We've actually reduced the dependencies from *at least* five to two, which is fundamentally better. Originally we were dependent on web, file and db because our collaborateors were *as well* as Foo and Bar. Nevermind anything else either of those two were also dependent on. Now we're only dependent things that look and act like instances of Foo and Bar. 
Armin has specifically advocated for using an application factory and the most of the flask community uses them. The only place app needs to be global is in a WSGI file. Your app factory handles building everything up for you. All abstractions are leaky. It's just a matter of *how* leaky. And it's only *some* implementations of the app depend on certain implementations of repository to be safe. Your abstract view doesn't know about Flask. All it knows is "Someone will implement render". Your Flask app knows about Flask *and* the view interface, so it implements a Flask specific subclass of View. 
Some people say that if it is called a trick it might not be sensible code. And I have to say they have a point.
EDIT: some stats from data below, and release date. Py3 distros: 18%. Most popular Py3 release: 3.5.1 - 66%. Most popular Py2 release: 2.7.9 - 39 % Top 50 for the last 12 months on Distrowatch, latest release: {'Antergos': {'release': '2015-12-29', 'version': '3.5.1'}, 'Arch': {'release': '2016-01-19', 'version': '3.5.1'}, 'ArchBang': {'release': '2015-12-03', 'version': '3.3.3'}, 'Black Lab': {'release': '2015-12-24', 'version': '2.7.5'}, 'Bodhi': {'release': '2015-11-17', 'version': '2.7.5'}, 'CentOS': {'release': '2015-12-14', 'version': '2.7.5'}, 'ClearOS': {'release': '2015-11-11', 'version': '2.7.5'}, 'Cub': {'release': '2015-07-18', 'version': '2.7.5'}, 'Debian': {'release': '2016-01-19', 'version': '2.7.11'}, 'Fedora': {'release': '2016-01-19', 'version': '2.7.11'}, 'FreeBSD': {'release': '2016-01-19', 'version': '3.5.1'}, 'Gentoo': {'release': '2016-01-19', 'version': '3.5.1'}, 'KNOPPIX': {'release': '2015-11-22', 'version': '2.7.9'}, 'KaOS': {'release': '2016-01-15', 'version': '3.5.1'}, 'Kali': {'release': '2015-08-11', 'version': '2.7.3'}, 'Korora': {'release': '2015-11-08', 'version': '2.7.10'}, 'Kubuntu': {'release': '2015-10-22', 'version': '2.7.9'}, 'LXLE': {'release': '2015-08-31', 'version': '2.7.5'}, 'Lite': {'release': '2015-09-01', 'version': '2.7.5'}, 'Lubuntu': {'release': '2015-10-22', 'version': '2.7.9'}, 'Mageia': {'release': '2016-01-18', 'version': '2.7.11'}, 'MakuluLinux': {'release': '2015-11-29', 'version': '2.7.5'}, 'Manjaro': {'release': '2016-01-18', 'version': '3.5.1'}, 'Mint': {'release': '2015-12-04', 'version': '2.7.6'}, 'Netrunner': {'release': '2015-11-23', 'version': '2.7.9'}, 'PC-BSD': {'release': '2014-11-17', 'version': '2.7.8'}, 'PCLinuxOS': {'release': '2015-08-14', 'version': '2.7.9'}, 'Peppermint': {'release': '2015-09-06', 'version': '2.7.5'}, 'Puppy': {'release': '2014-10-28', 'version': '2.7.5'}, 'Q4OS': {'release': '2015-08-05', 'version': '2.7.9'}, 'Red Hat': {'release': '2015-11-19', 'version': '2.7.5'}, 'Robolinux': {'release': '2015-12-04', 'version': '2.7.9'}, 'Sabayon': {'release': '2015-12-28', 'version': '3.4.3'}, 'Simplicity': {'release': '2015-07-30', 'version': '2.6.4'}, 'Slackware': {'release': '2016-01-18', 'version': '2.7.11'}, 'Solus': {'release': '2015-12-27', 'version': '2.7.9'}, 'SparkyLinux': {'release': '2015-12-20', 'version': '2.7.11'}, 'SteamOS': {'release': '2015-06-26', 'version': '2.7.9'}, 'Tails': {'release': '2016-01-12', 'version': '2.7.9'}, 'Ubuntu': {'release': '2016-01-18', 'version': '2.7.11'}, 'Ubuntu GNOME': {'release': '2015-10-22', 'version': '2.7.9'}, 'Ubuntu MATE': {'release': '2015-10-22', 'version': '2.7.9'}, 'Ultimate': {'release': '2015-12-20', 'version': '2.7.9'}, 'Vector': {'release': '2015-06-27', 'version': '2.7.8'}, 'Xubuntu': {'release': '2015-10-22', 'version': '2.7.9'}, 'Zorin': {'release': '2016-01-19', 'version': '2.7.9'}, 'antiX': {'release': '2015-06-30', 'version': '2.7.9'}, 'deepin': {'release': '2015-12-31', 'version': '2.7.11'}, 'elementary': {'release': '2015-12-09', 'version': '3.4.3'}, 'openSUSE': {'release': '2016-01-18', 'version': '2.7.10'}}
You are giving no context at all. What is course1_assessments? Apparently an object, possibly something GUI related. But without knowledge what you are doing here there really is no way to answer that.
Nice job!
My last company used sqlalchemy, which I liked very much. Just make sure to use the core for production: http://docs.sqlalchemy.org/en/latest/core/. sqlalchemy ORM is good for writing mock ups, because it's easy to write, but it is not meant to be high performance.
Also I would suggest trying out alembic: https://alembic.readthedocs.org/en/latest/. It's a handy tool for database versioning. You can upgrade and downgrade your database schema easily using version numbers.
&gt; In C++ there is a construction: g = boo ? a : b which assigns a to g if boo is true, and b if it is false. This called "the ternary operator". Technically it's *a* ternary operator but in the context of most languages, it's *the* ternary. Python's ternary is `A if X else B` You wouldn't pass code review with `g = boo and a or b`. Please don't do it. If you have to explain your Python syntax to experienced Python developers, you're probably doing something wrong. They don't know it, or forgot it, for a reason. *EDIT I am in no way saying not to experiment and learn more. I am happy you have discovered this and written up a post. However please treat it as an academic discovery to further understanding of python and not as a programming technique*
I do use it however some people frown upon it as they believe that True and False should not be 1 or 0 and should be separate things. I don't think that as this is good for use in list comprehension. However them being 1 and 0 can be used to make code that is confusing. e.g. &gt; False ** False and True True
Those frameworks ruined the DI brand. :(
&gt; The benefit is that you can fit different components together more easily, and the downside is that you have to tell each component the specifics of how to do its job. You're explicitly *not* telling the component how to do it's job. Without DI, you tell the component to open a file and use that as its data source. With DI you just pass in a file-like object and the component doesn't need to know if it's a file or a BytesIO or a network socket, etc.
No
I'm not a trained developer, and am just starting my journey - I want to make sure I'm taking the correct information away from this talk. I enjoyed the discussion but am a little curious about where the end conclusion can be followed; throughout the talk he kept taking the larger functions into smaller and smaller functions, to be collected at the top by procedural processes (using his terminology, coupling the various functions - data or IO). Is this meant to suggest that our programs should be a collection of many many many smaller functions? And, if so, should this be taken into other languages, including scripting-based languages (PowerShell, Bash, etc.)? To what end should this be taken, how narrow should we get our functions down to? 
Are you reusing the same base PDF over and over, or are you looking to fill out many different kinds of PDFs? If you're reusing a PDF, I would flatten it (to get rid of the fields), use fpdf to create a separate PDF containing the information you want to print on your PDF, then use PyPDF2 to overlay and merge your "cover" PDF onto your base PDF. PDF is a weak point in Python's available libraries based on my experience so far (in a job that involves working with several million PDF files). 
1. Belongs in /r/learnpython 2. Without the specific errors there is 0 chance for us to know what happened.
I understand, and agree that there was information pertaining to the comparison left out. I think, though, that was intentional - the comparison wasn't brought up to perform a review of Word Count problem, but to show how the smaller 6 line solution was much easier to read and visualize than the 10 page pascal program. Performing a quick search pulls up a lot of commentary on the Word Count problem - here is one such article that even includes a python-based solution: * [http://blog.peterdonis.com/opinions/still-another-nerd-interlude.html](http://blog.peterdonis.com/opinions/still-another-nerd-interlude.html) * [ https://github.com/pdonis/wordcount](https://github.com/pdonis/wordcount)
I think you missed a part of his post, He's asking about mysql client libs, not about which ORM he should use... he could already be using sqlalchemy :)
This is a tremendous. Thank you for the example... I think I'm going to use examples like Gucci Mane for everything from now on. 
I have a few gripes, at a glance, but all around, it's the one language among everything upcoming that I'm excited for the most - both Rust and Go have been way too zealous with their respective design goals, while Julia is simply a sane attempt at creating something good to fill a specific niche. I do wish that they focused on general-purpose applications a bit more, but perhaps not doing that is just what needed to be done. I think it's promising.
I don't do this, but a great place to post python related questions is r/learnpython
&gt; PDF I'll be re-using the same base PDF over and over. That is, I have a base PDF template and want to insert into the form fields of this base template, values from various CSV or Excel files. Is this what you mean by merging?
What do you think is missing from general purpose capabilities? 
From http://matplotlib.org/1.5.0/style_changes.html &gt; In the second week of August, Michael Droettboom and Thomas Caswell will decide on the new default styles, with the release of 2.0 by the beginning of September 2015. So *four* months ago...
More than just "part of the optimization," but people would get seriously pissed off if their elevator decided to make a detour and drop somebody off out of sequence. &gt; I've been riding this elevator up from the 1st floor, and then this jack-ass gets on MY up elevator at the 20th floor and makes it go DOWN to the 19th. TAKE THE STAIRS BUDDY!!! LOSE SOME WEIGHT!!! Its a really interesting problem in human computer interactions, as well as being a fairly challenging stochastic optimization problem.
Good point. The US 44 ml shot (1.5 US fl oz) is used when you order a full drink. However, when people are "doing shots", bartenders will typically use a smaller shot size like 1 oz (a.k.a. short shot or "pony"), which is ~30 ml. 
&gt; And, now, anybody that uses thing now needs to also know, understand, and create these Foo and Bar objects to use a thing. Less Great! My approach to this is to offer both a high-level and low-level interface. The low-level interface is the `Thing` class which accepts in its constructor all of its dependencies. The high-level interface consists of module-level functions or class methods which serve as factories for instances of `Thing`. They create and inject `Thing`'s dependencies so that the user doesn't have to. A good example of this, I think, is Python's own built-in `open` function. `open('foo.txt', 'w')` creates an instance of [`io.TextIOWrapper`](https://docs.python.org/3.5/library/io.html#io.TextIOWrapper) with all of its dependencies and returns this object to the user. The user doesn't need to know about `BufferedIOBase` streams or any of that low-level detail, but if one wanted to, he/she could dig into the details and customize how they operated by substituting in different dependencies.
Exactly. I just wrote this up real quick as an example of how to take a PDF template and write some text on it: import fpdf from PyPDF2 import PdfFileWriter, PdfFileReader overlay_pdf_file_name = 'overlay_PDF.pdf' pdf_template_file_name = 'base_PDF_template.pdf' result_pdf_file_name = 'final_PDF.pdf' # This section creates a PDF containing the information you want to enter in the fields # on your base PDF. pdf = fpdf.FPDF(format='letter', unit='pt') pdf.add_page() pdf_style = 'B' pdf.set_font("Arial", style=pdf_style, size=10) pdf.set_xy(100, 100) pdf.cell(0, 10, txt='THIS IS THE TEXT THAT IS GOING IN YOUR FIELD', ln=0) pdf.output(overlay_pdf_file_name) pdf.close() # Take the PDF you created above and overlay it on your template PDF # Open your template PDF pdf_template = PdfFileReader(file(pdf_template_file_name, 'rb')) # Get the first page from the template template_page = pdf_template.getPage(0) # Open your overlay PDF that was created earlier overlay_pdf = PdfFileReader(file(overlay_pdf_file_name, 'rb')) # Merge the overlay page onto the template page template_page.mergePage(overlay_pdf.getPage(0)) # Write the result to a new PDF file output_pdf = PdfFileWriter() output_pdf.addPage(template_page) output_pdf.write(file(result_pdf_file_name, "wb"))
In my opinion, your thing should only create objects or use objects, not both. As for the blocking thing, you should account for that when designing your object. Or provide a convenience wrapper that does. Or an alternative implementation that's async aware. There's dozens of ways to solve this problem. 
I'm using both. I use pip for simple libraries that don't need further (C) compiling tasks. Libraries like pillow /PIL are such a pain to install via pip whereas Python-PIL is just a RPM with a few dependencies. 
They're good and bad. The good is your able to manage a complex object graph easily inside your program. The bad is there's often a really nasty config file no one wants to touch.
Actually the GitHub page has their milestone for February 1st of 2016. https://github.com/matplotlib/matplotlib/milestones 
Have you tried running command prompt as an administrator? [Related StackOverflow question](http://stackoverflow.com/questions/32167418/python-pip-install-trouble-shooting-permissionerror-winerror-5-access-is)
Granted, but that nastiness needs to live somewhere, and I'd rather it be in a single location (either a complex DI config file or a program entry point) whose sole purpose is to describe that nastiness than interspersed in every class, and often repeated in multiple classes due to the unprincipled nature of this approach to handling requirements. Also worth noting that the "nastiness" you're describing isn't caused by dependency injection, it's caused by a system with complex requirements. There's no way of escaping this level of complexity except to simplify the requirements. The tradeoffs we can make are fewer components with more responsibilities (simple object graph but complex components, typically with responsibilities duplicated across them) or more components with fewer responsibilities (more complex object graph, but simple building blocks). The latter is more true to the single responsibility principle, but the interesting property that emerges is that you manage your system requirements by composing your object graph, rather than assigning responsibilities (often arbitrarily) to components.
I can't speak to scripting languages, and I'm also no expert. But I'll parrot some generally accepted advice. Yes, your code should be made of many small functions and methods. There are two categories of reasons. The things that are impossible if you don't, and the things that are encourage (though not forced!) if you do. If you don't break your code into smaller subroutines it is impossible to: write tests for small parts of code, reuse small parts of code, and run most of the code while modifying small parts of its behavior without rewriting it. It encourages (though doesn't force!): loose coupling, code reuse, documenting smaller components, and automated testing. How small should you make it? A very, very loose guide (and I'd say at the large size) is that no single function should be longer than fits on your screen. There is also a tautological benefit in having all the code fit on the screen in that you can see it all at the same time! You can read through a whole function repeatedly without scrolling. In practice, writing Python, I'm happiest when my functions and methods are under 8 lines each. It's a very concise language. If I'm writing more, I'm probably doing too much.
Could the same separation of concerns not be achieved with inheritance? 
Wouldn't that be created when packaging the app?
&gt; The website is supposedly closing down ... I didn't see the message yesterday. It's a bit sad, because not every video is available on Youtube, e.g. "Names, Objects, and Plummeting From The Cliff".
 {x for x in foo if x not in bar} more readable version: set(foo) - set(bar)
Seriously. I run an open source project. It's 4 months behind schedule and hopefully only will be 5 months behind. Things take longer than anticipated and then things kind of need to sit in production for a while before you iron out all the kinks.
Again there's no correct answer, but I feel this would be a poor use of inheritance. As a rule of thumb, I would only use inheritance for clear "is-a" cases. Dog is an Animal. For "has-a" cases, like "elevator has a motor" then aggregation or composition might be more appropriate. It's a rule of thumb, because of things like: if square inherits from rectangle, what happens if you set my_square.x != my_square.y? Would you implement a car by multiply inheriting from wheels, engine and seat? Or would you implement a car by inheriting from vehicle and having the car contain instances of wheels, engine and seat? The second option will be in the general case less troublesome.
I would do the second one, but I wouldn't hide those classes within the definition of the vehicle class. I'd define them elsewhere and then create an instance of that class in vehicle's __init__.
First one is to use `len` explicitly. As we're creating a list anyway, *something* needs to be its elements, but it does not matter what it will be, so I just picked self-explanatory stuff. Using x's makes sense too because then it's literally elements of data that are processed. Yeah, that makes more sense. &gt; assuming you didn't want to use `sum` Well, `len` is more suitable in counting task than `sum`. I'm not saying `len` is to be used for this case in general but it's better than `sum`. &gt; Isn't that idiomatic use of Counter as per the docs? I don't know really. Looks like a bit of an overkill. `len([x for x in data if x.is_processed()])` is better IMO. So, I think there is more idiomatic alternative to the case where you have to rely on True == 1.
As someone who has only used jupyter to do data analysis and work on files, is Pycharm or sublime worth using?
I use it exclusively. I normally make a lot of cells and run my code in blocks to check for accuracy. Similar to the brandon Rhodes pandas video. I only mess with files, sometimes ftp servers, and a little selenium to download data. 
&gt; Less-performant? You're not seriously suggesting that a conditional is going to have an effect on an I/O bound operation are you? No, I was speaking generally to the convention of a function keying off of the type and properties of its arguments in order to divine the Right Thing To Do. &gt; And I can't agree with the 'more complex' aspect. Factoring out an algorithm so that it works as a template method/strategy pattern is going to be more work than just having 1 algorithm with some inline conditionals, and will hide the flow of control quite considerably too. I'm not suggesting that. I'm suggesting passing in the right thing for your application. If my application says that we're only going to decode files, then the application wires up the object graph such that the Decoder is only given a file. If it only takes a socket handle, then wire up the object graph such that the Decoder is only given the socket handle. If we need to take a URI from the user and divine what type of file-like object to create based on the scheme prefix, then create said factory unit and pass its output to the Decoder. I don't see any case for embedding that same factory logic into the Decoder. &gt; But a lot of DI fans don't accept that it comes at a cost. I don't think there is a cost. We're talking about whether it's better to sprinkle little arbitrary bits of the object-graph-building responsibility across all of your components or to put that responsibility all in one place (your main method, the application class, etc). This sort of pollution comes at the cost of unit-testability (though in Python, there are hacky ways to ease the pain of validating a poorly designed component). I see lots of reasons not to couple components, but I see no case against it.
I wish it just wasn't so huge. The amount of time it takes to compile this thing is insane. The sheer quantity of code means you need a small army to build any development momentum at all. It does not encourage contributions.
[PyCharm](https://www.jetbrains.com/pycharm/) is free and [great at that](https://www.jetbrains.com/pycharm/help/creating-and-editing-file-templates.html). Super easy to do and by far and away the best Python IDE I have found. Sublime and Atom are nice if you are looking for lighter editors. But if you want a full IDE go PyCharm. 
I have been using [hostmonster](https://www.hostmonster.com/) for years and have loved their service. Price is super cheap at $5 a month. They do allow [python](https://my.hostmonster.com/cgi/help/48) scripts on their default linux systems and there are [tutorials](http://fgimian.github.io/blog/2014/02/14/serving-a-python-flask-website-on-hostmonster/) to help you get set up. Disclaimer: I personally have not used any python scripts with them, but I love their service and they do offer it. 
py.test + coverage packages also coveralls.io
Are you using Jupyter without using "shift+enter" to run cells? or with .py files instead of pynb files? or without a running and connected kernel to execute? Your comment surprises me. I use Jupyter as my scratch pad for when I want to work with code more interactively. I use an "actual" IDE (pycharm) for a lot of my work, but when I want to do scratch work (like you would do in python shell mode) I use Jupyter. Just create a new cell for each new line and now you have python shell that is more powerful and you can make changes easier and copy/paste easier and such. You can also debug in Jupyter notebooks, try: %pdb on The only thing jupyter lacks are the rich features of more complete IDEs and the ability to interact seamlessly with .py files. You can use .py files, but its an extra step needing things like %load and %%writefile. I haven't touched a python shell (apart from troubleshooting a particular python executable environment) since I discovered Jupyter.
Install and manage everything means super complex? DO looks like a very good option, but I want to make sure that it will be quickly to set up, so that I can focus on the usability of the app
I'll take a look, thanks!
Thanks! I'm having a lot of trouble understanding the process for running a python program from the command line though. Do I need to put it in my C:\Python34\Scripts file? What command do I use to run a .py from command? All the files I've run from command have been .exe
I recently used opeshift, and it was very nice, specially since it is free.
This is unfortunate, but understandable. Thank you for providing this service to the community.
[This other StackOverflow Answer should help with that](http://stackoverflow.com/questions/4621255/how-do-i-run-a-python-program-in-the-command-prompt-in-windows-7)
&gt; I want to run something, debug, and maybe play with it interactively. All of these you can't really do in the notebook I do all this in the Notebook. It almost sounds maybe like you don't realise that you can hit Shift+Enter on a cell more than once, and it overwrites the output? I can't see why else you'd debug something in another notebook… Like others have said, I do also end up creating a bunch of scratch cells for testing small things separate from the main body, and then deleting them (or clearing their contents and replacing it) later on.
So edit the title.
where are all the videos that have no origin listed, like all of those from [PyGotham 11](http://pyvideo.org/category/10/pygotham-2011), going to be posted, or does someone have to quick download all these videos and post them to youtube before the site is taken down? 
&gt; `ipython console --existing` This seems promising but it threw a ton of errors my way. I will play more later. Thanks! 
Nice! I'm not OP but I really appreciate the breakdown. Was looking into something similar &amp; this is useful.
The decision to use Firebird is insane. FB is 8 years behind releasing version 3.0, has almost no developers left, few users outside former Soviet Bloc nations, a lack of quality testing, a lack of modern features, a lack of modern books and learning materials, etc. The embedded version of Firebird only works on Windows, so it would have to full Firebird to work with crossplatform LibreOffice. Why not simply use SQLite? Popular, ubiquitous, well-documented, simple, etc. 
Hi, your question might be recieved better over in /r/learnpython. It sounds like http://selenium-python.readthedocs.org might be useful for what you want to do, but I've never used it. Best of luck!
It probably doesn't work on Windows, you have to do it after you open the notebook. Open iPython notebook server from terminal/command line : $ ipython notebook Open a notebook, then a new terminal window, do $ ipython console --existing
Can you be a more specific about what you need? The Gaussian distribution is a continuous distribution and doesn't really work for choosing between three discrete values. 
vimtutor is the best option to learn vim from scratch. Why did you decide to give up PyCharm btw?
I'll put this question here, because it seems as natural a place as any... Do you find yourself writing a lot of classes which could be replaced with higher-order functions? In other words, following the desire to build a composable object graph through injecting dependencies, I often find myself with classes with a constructor and a single method (i.e., a "functor"): class DoSomething(object): def __init__(self, foo, bar): self._foo = foo self._bar = bar def __call__(self, x, y, z): # do something with self._foo and self._bar This can of course be replaced with a closure: def do_something_maker(foo, bar): def do_something(x, y, z): # do something with foo and bar return do_something Though the class is perhaps more verbose, I feel that it has benefits over the higher-order function. For one, it's easier to document, since, as far as I'm aware, Sphinx and other automatic documentation generators don't have great support for documenting a higher-order function AND the function that it returns. An alternative to these two is to define a function: def do_something(foo, bar, x, y, z): # do something with foo and bar and then to use `functools.partial` to bind the first two arguments. I see this as being superior to the higher-order function. Choosing between these is larger a matter of style, but I'm curious if you have any preference?
i like splinter. a bit easier to use than straight up selenium. its probably better to learn selenium in the long run, but this should work for now. https://splinter.readthedocs.org/en/latest/
That is super disappointing. Pyvideo was my goto place to aggregate new talks rather than tracking multiple conferences. Just kept it loaded in my RSS reader and every once in a while I would be blessed with new learning opportunities.
I mean it loosely in the sense that you have a function that picks randomly from three discreet values but is weighted towards certain values. so if i have [1, 2, 3], it would pick 2 most of the time, and 1 and 3 occasionally.
I dunno u.u I just said that n.n I'm not really following programming world stuff superclosely because of various personal issues :(
`random.gauss` returns a value- a *continuous value* from a Gaussian distribution where you can control the mu and the sigma of the distribution. So, something like: def gauss_choice(l): idx = int(random.gauss(2, len(l)/6) + len(l)/2) return l[idx] You may have to play with how you size your standard deviation some, and you may want some rounding instead of truncing, but this is basically the neighborhood of what you want to do.
Even reading the post and understanding the why, I'm still bummed out. This is the first place I send people looking for new Python information. Thank you for making a wonderful site, I'm glad I got to experience it while it was around. 
Yes. It highlights the option i want it to select, but doesn't click it.
sorry thats what I meant, you can't give boundaries to a gaussian distribution function. i have a check in place, which is sort of why i asked the question, because that seemed a bit dirty.
That's math, for you!
wasn't that removed from selenium.
http://selenium-python.readthedocs.org/api.html#module-selenium.webdriver.support.select
Just get a VPS. http://ramnode.com/vps.php $15 a year, install debian on it (option when buying) and you are good to go. 
I often enjoy data projects and it's a very marketable skill if you get good at it. Find a topic that interests you and then find some data about the topic. Build a program that not only acquires the data, but does something interesting with it. Given your user name... An example might be a program that downloads data about the migratory patterns of Atlantic lobsters and then plots their seasonal migrations on Google maps. Don't jump into something like Pandas yet. Try to stick with the standard library and maybe a couple small libs like Requests. A hint: Using data that is not Twitter would be a bonus. Unless you are interested in Twitter.
Thanks I'll check it out. I've heard very good things about VIM. It seems very customizable and extensible so I figured I'd give it a shot. 
The site is just an index. It's not hosting them.
Thank you based ccb621.
python is an amazing language once you have completely learnt the basics. Many libraries out there will help you discover the full power of python like creating back end processes for websites, creating androids apps with kivy etc. For now since you are a beginner i would concentrate on getting the basics down create small games like rock paper scissors, Hangman, oh and the reddit api (Oh i messed ALOT with that..its so fun!!). Cheers,
I am on a Mac and that's what I *think* I tried. I'll play more when I'm back at work
They thought of everything.
Where have you been all my life?!?
Such a compilation of information. Thank you for sharing.
This is the official driver and goes through Oracle's support. I've reported different bugs and they're fairly good at fixing them
https://github.com/pypa/pip/issues/3384
That sucks... 
... Markov chains and Moby Dick?
It's always worked fine on Windows for me. Just make sure that the Ipython kernel in the notebook has started already when you run it.
I think better looking styles will become default. Though right now you can use pyplot.style.use("ggplot") (ggplot is an example, there are others) to get prettier plots.
It's kind of a limited comparison, but this might help: http://www.web2py.com/examples/static/web2py_vs_others.pdf
Bit fields and masks are pretty fun!
My notebooks are always really messy, which I think negates a lot of the benefits. Coming from a PyCharm background, I like being able to write stuff in different files and importing it. Maybe it would be better if you could minimize cells.
&gt; It does not encourage contributions. A while ago TDF hired a dedicated mentor for new developers. This wiki page (and its parent) is his work among other improvements to onboarding. I agree with your note on compiling time. I recently tried it on Windows with a 2012 Thinkpad: it took 24 hours without even running tests.
Assuming it's possible (since it is), how would you solve the problem? I ask you because, if I give you the answer, you won't learn anything.
They have great tutorials. Its just a virtual instance like anything else: you start with a base linux install (the distribution of your choosing). Don't be afraid. In the time you spent fretting you could have had nginx and gnunicorn serving python already.
I wonder what are the exact resources the site is using / needs to run?
It depends on what you think is fun. If you like computer games you could go through some tutorials for pygame.
A good start would be the Django tutorial --- where they create a polling web app.
This is how i do it: from selenium.webdriver.support.ui import Select driver = webdriver.Firefox() driver.get('http://yoursite') Select(driver.find_element_by_xpath("//select[@id='size']")).select_by_visible_text("..") For the last part you can use any method ccb621 pointed at.
Will Kahn-Greene and Sheila Miguez, a lot of thanks for these five years of awesome pyvideo.
Thanks
&gt; minimize cells. I like that idea... especially if it minimized to only show the first line, so you could have a comment line explaining what the minimized cell does.
You should also be able to simply run a cell in your notebook with %qtconsole And open a connected qtconsole. I think I prefer the console in terminal, but QT console can do inline plotting :)
* Vim is not an IDE, it's a simple, but very extendable editor. * Vim is not new. It's older than most players in the editor/IDE market these days. * You won't find the PyCharm level of comfort with Vim unless you used Vim for at least five years and it's wired into your brain. It's your call whether to spend that time on getting into Vim or enjoying modern user friendly IDEs, but it comes down to your level of nerdiness, not to Vim being better than PyCharm or Sublime. Me myself I want to be a Vim guy, but I'd be too slow the first year or so and I'd miss all the integrated features of PyCharm.
The integration of peep functionality is nice: https://pip.pypa.io/en/stable/user_guide/#hash-checking-mode I wonder why there is no option for `pip freeze` to generate the hashes though? It seems like peep itself can be used to do this with `peep port`, but would be useful to have this directly in pip.
Holy shit the new color defaults are *sooooooooo sexy*
I'd like to thank you for your patience. I didn't understand the problem at first. Thanks for bringing this up! Issue fixed.
The command is called "convert list comprehension to for loop". See if you can find it in the global lookup-thingie you get if you double tap shift.
Most of all, I would say it is important to learn computer science, algorithms, data structures, that is really valuable knowledge that is independent of the language you use.
Diving deep into any ecosystem/language is good, because it makes it easier to jump into another ecosystem. So instead of jumping to C# or something, it's probably best to go deeper into python for now. That way when/if you DO jump to another because you get a job in it, you'll be able to go "oh, X in C# is like Y in python" and figure out things fast. At work we don't really care much if you've worked in python before when we hire people. If they're good in another language they'll transition super fast anyway. That being said, a little bit of functional language is probably good, I'd recommend Clojure over Haskell because the learning curve is MUCH shallower.
I see. I was not sure what would be a mess, but I guess you're saying that the Javascript pages would be a mess because they would not be maintained? What do they actually do with Javascript? Does that mean Django/Flask/etc are kind of useless now? &gt; once you get the javascript working, it's probably obsolete and you will have to re-write everything in the new fashion Would it stop working? Or would the businesses want to use the latest language etc? I've never done web-related things, but I've been meaning to play around with it once I have time in a few months. What do you recommend to start with?
SimpleCV is basically abandoned
Maybe this is because you use numba pro when I use numba 0.23.0 . 
Go use /r/learnpython , that's what it's there for! That said, it's obvious to me that you don't yet understand what functions are for or how to pass data around (that makes me suspect you need /r/domyhomework). #!/Python27/python # look up python future python-future.org # you'll save yourself a lot of pain with # this makes print and divide behave the same in python2 as it does in python3 from __future__ import print_function, division import mysql.connector # Name your functions so it's obvious what they do # variables and function names should be lowercase_with_underscores # CamelCase is usually for classes def search_phone_by_model(model): conn = mysql.connector.connect(user='root', \ host='127.0.0.1', database ='phone') cur = conn.cursor() query = "SELECT phone.Model, phone.Make, tariff.Duration, price.PriceUpfront, price.PriceperMonth FROM phone, tariff, price \ WHERE phone.Phone_ID = price.Phone_ID AND tariff.Tariff_ID = price.Tariff_ID \ AND phone.Model LIKE '%" + model + "%'" cur.execute(query) # you're reusing a variable name from the function definition for a different purpose # this can be very confusing and cause you heartache model = "device" # it also means this print statement will always say "This device has the following tariffs:" print ("This " + model + " has the following tariffs:") for (Model, Make, Duration, PriceUpfront, PriceperMonth) in cur.fetchall(): # now you use model again # and your variable names are all capitalised # also look up how to use format strings, they'll make this less messy print ((Make + " ") + model + " (Duration of the Contract: " + Duration + ")" + " (Price Upfront: " + PriceUpfront + ")" + " (Price per Month: " + PriceperMonth + ")") print ("") cur.close() conn.close() def search_phone_by_make(make): conn = mysql.connector.connect(user='root', \ host='127.0.0.1', database ='phone') cur = conn.cursor() query = "SELECT phone.Model, phone.Make, tariff.Duration, price.PriceUpfront, price.PriceperMonth FROM phone, tariff, price \ WHERE phone.Phone_ID = price.Phone_ID AND tariff.Tariff_ID = price.Tariff_ID \ AND phone.Make LIKE '%" + model + "%'" cur.execute(query) model = "device" print ("This " + model + " has the following tariffs:") for (Model, Make, Duration, PriceUpfront, PriceperMonth) in cur.fetchall(): print ((Make + " ") + model + " (Duration of the Contract: " + Duration + ")" + " (Price Upfront: " + PriceUpfront + ")" + " (Price per Month: " + PriceperMonth + ")") print ("") cur.close() conn.close() search_phone_by_model('iPhone 6 plus') search_phone_by_make('Apple') Notice though how much stuff is the same in both functions? Wouldn't it be nice to get rid of a lot of that? #!/Python27/python # look up python future python-future.org # you'll save yourself a lot of pain with # this makes print and divide behave the same in python2 as it does in python3 from __future__ import print_function, division # let's get a context manager for mysql from contextlib import closing import mysql.connector # Name your functions so it's obvious what they do # variables and function names should be lowercase_with_underscores # CamelCase is usually for classes def search_phone_by_model(model, cursor): # we no longer need to make the connection here, the cursor is passed in for us to query query = "SELECT phone.Model, phone.Make, tariff.Duration, price.PriceUpfront, price.PriceperMonth FROM phone, tariff, price \ WHERE phone.Phone_ID = price.Phone_ID AND tariff.Tariff_ID = price.Tariff_ID \ AND phone.Model LIKE '%" + model + "%'" cursor.execute(query) # you're reusing a variable name from the function definition for a different purpose # this can be very confusing and cause you heartache model = "device" # it also means this print statement will always say "This device has the following tariffs:" print ("This " + model + " has the following tariffs:") for (Model, Make, Duration, PriceUpfront, PriceperMonth) in cursor.fetchall(): # now you use model again # and your variable names are all capitalised # also look up how to use format strings, they'll make this less messy print ((Make + " ") + model + " (Duration of the Contract: " + Duration + ")" + " (Price Upfront: " + PriceUpfront + ")" + " (Price per Month: " + PriceperMonth + ")") print ("") def search_phone_by_make(make, cursor): query = "SELECT phone.Model, phone.Make, tariff.Duration, price.PriceUpfront, price.PriceperMonth FROM phone, tariff, price \ WHERE phone.Phone_ID = price.Phone_ID AND tariff.Tariff_ID = price.Tariff_ID \ AND phone.Make LIKE '%" + model + "%'" cursor.execute(query) model = "device" print ("This " + model + " has the following tariffs:") for (Model, Make, Duration, PriceUpfront, PriceperMonth) in cursor.fetchall(): print ((Make + " ") + model + " (Duration of the Contract: " + Duration + ")" + " (Price Upfront: " + PriceUpfront + ")" + " (Price per Month: " + PriceperMonth + ")") print ("") # go read http://stackoverflow.com/questions/8067690/context-manager-for-pythons-mysqldb/22840557#22840557 # http://eigenhombre.com/2013/04/20/introduction-to-context-managers/ # ensure that the connection is closed with closing(mysql.connector.connect(user='root', host='127.0.0.1', database ='phone')) as conn: with closing(conn.cursor()) as cur: search_phone_by_model(model='iPhone 6 plus', cursor=cur) search_phone_by_make(make='Apple', cursor=cur) Still a lot of common code though, let's try to reduce that a bit by putting the reporting in its own function #!/Python27/python # look up python future python-future.org # you'll save yourself a lot of pain with # this makes print and divide behave the same in python2 as it does in python3 from __future__ import print_function, division # let's get a context manager for mysql from contextlib import closing import mysql.connector # Name your functions so it's obvious what they do # variables and function names should be lowercase_with_underscores # CamelCase is usually for classes def search_phone_by_model(model, cursor): # we no longer need to make the connection here, the cursor is passed in for us to query query = "SELECT phone.Model, phone.Make, tariff.Duration, price.PriceUpfront, price.PriceperMonth FROM phone, tariff, price \ WHERE phone.Phone_ID = price.Phone_ID AND tariff.Tariff_ID = price.Tariff_ID \ AND phone.Model LIKE '%" + model + "%'" return cursor.execute(query) def search_phone_by_make(make, cursor): query = "SELECT phone.Model, phone.Make, tariff.Duration, price.PriceUpfront, price.PriceperMonth FROM phone, tariff, price \ WHERE phone.Phone_ID = price.Phone_ID AND tariff.Tariff_ID = price.Tariff_ID \ AND phone.Make LIKE '%" + model + "%'" # now we wll just return the result return cursor.execute(query) def report_result(phone_info): model = "device" print ("This " + model + " has the following tariffs:") for (Model, Make, Duration, PriceUpfront, PriceperMonth) in phone_info: print ((Make + " ") + model + " (Duration of the Contract: " + Duration + ")" + " (Price Upfront: " + PriceUpfront + ")" + " (Price per Month: " + PriceperMonth + ")") print ("") # go read http://stackoverflow.com/questions/8067690/context-manager-for-pythons-mysqldb/22840557#22840557 # http://eigenhombre.com/2013/04/20/introduction-to-context-managers/ # ensure that the connection is closed with closing(mysql.connector.connect(user='root', host='127.0.0.1', database ='phone')) as conn: with closing(conn.cursor()) as cur: phone = search_phone_by_model(model='iPhone 6 plus', cursor=cur) report_result(phone) phone = search_phone_by_make(make='Apple', cursor=cur) report_result(phone) Of course there's a lot further to go, but that's an exercise for you to learn. These videos helped me understand a lot of things: https://www.youtube.com/watch?v=DJtef410XaM https://www.youtube.com/watch?v=EiOglTERPEo 
http://interactivepython.org/runestone/static/pythonds/index.html
I do enjoy the way he writes/speaks. Nice and clear, and no bullshit fluff. 
What usually happens in the front end? Looking at some tutorials, it's basically an HTML page with text? What do people do with Javascript etc?
What if they're both there by default? I don't think it's particularly interesting which one the `python`command starts - and I can provide a mostly complete list of that in one sentence: it's Python 2.7 on every recent distro apart from Arch. What I'm interested to know is: - How long before 3.5 is available in the repositories for most Linux users? - When is it reasonable to drop support for 3.3? - Which distros and releases have a Python 3 interpreter in the default installation? The Distrowatch data doesn't help much with any of those questions.
Check codeacademy
Thanks for the input. I didn't realize it was that tough to get used to. May be better for me to just stick with Pycharm for now 
Using VIM at first can seem unintuitive. But once you learn the basics, you can quickly learn to do most things with just a couple keys. Vim also offers you the ability to create custom macros and remap its keybindings, so if you find yourself doing something over and over, you can quickly adapt. A major advantage to VIM is that it is available on nearly all UNIX systems, so you won't be faced with the issue of installing new software if you want to work on machines other than your own. If you still want to learn vim, I recommend doing vimtutor every day until it becomes natural. Then, google for articles like "useful beginner vim tips" and you'll get way more than you need. In my experience, you'll remember the super useful ones and forget the rest. It took me months of casuallly using VIM before the basics were wired in comfortably enough to do many advanced things, but once I got there, I found that it became much more powerful than it seemed when I was getting started. There's a large, rich community and plugins for just about everything an IDE can do (once you know you can't simply do it with VIM built-ins). 
This isn't getting enough attention. Don't upgrade unless you are magically not impacted by this.
I changed the query, but it returned a syntax error. Basically this block here: print "This " + Model + " has the following tariffs:" for (Model, Make, Duration, PriceUpfront, PriceperMonth) in cur.fetchall(): print (Make + " ") + Model + " (Duration of the Contract: " + Duration + ")" + " (Price Upfront: " + PriceUpfront + ")" + " (Price per Month: " + PriceperMonth + ")" print "" Specifically: for (Model, Make, Duration, PriceUpfront, PriceperMonth) in cur.fetchall(): The `Make` was highlighted. I think you're right about splitting the Model variable, but how do I even begin?
Seconded. Fantastic library.
&gt; With SQLAlchemy to bypass SQLite checking limitations and create a simple wrapper. Err, the database in question is not for unit tests (which are being rewritten in Python) but for LibreOffice itself (LibreOffice Base), which cannot make use of SQLAlchemy as far as I know.
any meaningful difference between the last two forks?
Hey, the author of the post here! Feel free to ask any questions and share your thoughts.
http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf 
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. Cheers &amp; best of luck with Python!
What's the big difference between LXML/BS4 and Scrapy?
Damn, what are they using in that usage gif in the first link? Is that emacs?
Fourthed, it's beautifully simple to use: from tqdm import tqdm for element in tqdm(iterator): code_with(element) produces a progress bar with an estimate time till finish that you can watch while the code runs
Learning Haskell is great, it has even affected the way I wrote code in imperative languages. It's also a lot of fun so I would definitely recommend looking at it sometime. Another free book (available online) I would recommend is 'Structure and Interpretation of Computer Programs.' It teaches you some basic computer science in addition to paying attention to how to write modular code. It has lots of good exercises as well.
I think they want to see this one: https://raw.githubusercontent.com/tqdm/tqdm/master/tqdm.gif
It's the other way around. noamraph is the original developer, they [stopped updating pypi](https://github.com/noamraph/tqdm/issues/8) and ultimately [stopped working on tqdm](https://github.com/noamraph/tqdm/issues/18), [@hadim](https://github.com/hadim) ultimately [forked the project to a tqdm org](https://github.com/noamraph/tqdm/issues/18#issuecomment-108432589) and proceeded to [ask for the pypi project](http://sourceforge.net/p/pypi/support-requests/507/) so they could push updates. That last step [took a little while](http://sourceforge.net/p/pypi/support-requests/507/#37c6).
Just for a little A little clarification, the GIL tracks references to every object and it will not allow a specific object to be accessed by multiple threads simultaneously This is very different than allowing multiple threads to run concurrently. The common case where you see multiple threads running at once is on network bound software, for example an HTTP server
Thank you so much :)
You do not find it "interesting" that CPython is not complying with the language specification?
Not really.
███ 40% *___*
I don't see how this isn't "complying" with the language specification?
Full disclosure: I work at Scrapinghub, the lead maintainers of Scrapy. They have different goals. LXML and BS4 are XML/HTML parsing libraries and that's it. Scrapy, on the other hand, is a full-featured Python web crawling framework to create web crawlers and scrapers in an almost declarative way. It actually uses LXML behind the scenes to implement its parser. Scrapy handles a lot of complicated issues for developers, so you only have to worry about defining which information should be extracted and how to extract it using XPath or CSS selectors. You can plug components to handle post-processing activities like storing the data in a particular database or storage provider, cleansing and validating the data extracted, resizing images, etc. It handles all the complicated networking stuff, like redirections, retrying failed requests, throttling to avoid getting banned (which is quite common if you don't pay enough attention to politeness), it can automatically read and follow robots.txt policies, among a lot of other features. So, if you want to scrape only one webpage, you could go with BS4/LXML + Requests. But, if you need to scale your solution a bit, it would be much easier if you had started with Scrapy. With BS4/LXML + Requests, you'd need to implement all the crawling stuff (browsing automatically from one page to another) by yourself. And it is not that trivial. I'd suggest you to take a look at the Scrapy at a Glance tutorial: http://doc.scrapy.org/en/1.0/intro/overview.html
In what way is it not complying with the specification? The program executes as expected (the next line is like any normal line), the only "problem" is that you are given an ellipsis instead of a prompt. Is this intentional? Probably not. Is it a bug (in the CPython REPL)? Yeah, I think so. Is it against the specification? Not as far as I can tell from the quote in the article.
I don't think that this is a bug. In fact I think it's intentional. Similar to how comments are skipped in source files, so too should comments be "skipped" in the interpreter. It's waiting for an actual command. 
Both the Django and Flask tutorials.
Thank you for the informative response, I'll take a look at the link! I was thinking of maybe using Scrapy, because I've heard so many good things about it, but I wasn't quite sure what its use case was. 
I am programming C++ with Qt at work and i learned a bit of C and Java in my first semesters at university. I think learning something different taught me more than reading into the "dark arts" of meta-programming in C++ so i am sceptically about diving deeper into Python. All that's left is working through the standard library and reading up on the "more wizardy things in python" (with "wizardy" i mean meta classes, abc's, advanced decorators, binding to C libraries, and the like). How is the learning curve with Clojure shallower than with Haskell? I have never had contanct with any of them, but i am interested in functional programming.
**EDIT**: nevermind lol, they just fixed it within literal minutes, amazing. Gotta love good developers. - - - ~~Unfortunately I managed to have a bad experience with tqdm recently.~~ ~~usecase was, seeing the progress on a sale (it was limited stock): People were canceling orders which is what made it the most interesting.~~ ~~tqdm.update(n) will [ALWAYS increase the current value by 1](https://github.com/tqdm/tqdm/pull/110) if `n&lt;=0`, which is just... unexpected. if you `.update(0)`, you expect the statistics to update with the iteration number not changing, it doesn't do this. if you do `.update(-1)` you expect the iteration number to decrease, not increase.~~
Python is all about indentation and newlines. You don't write semicolons at the end of a line to specify that you have finished writing the command, python just sort-of interprets the newline as the semicolon. In OPs case, he found an instance where newlines were not being obeyed in the same way between different compilers. I think that's pretty interesting, and I am curious if there is a reason for it or if it was for some reason purposeful by the developers.
There is support for things like typing :imap jk &lt;Esc&gt; in the notebook itself. It seems that it would be possible to write such commands in a ~/.ivimrc file and load them into the custom.js javascript to be loaded by the browser. I hacked this together pretty quickly mostly because I liked the backend options, but found it rather complicated to set up such that would be difficult to do consistently across my servers. So at this point, the tool is just simply sharing what I'm using. But I may add something fancy as you suggest.
honestly, don't involve yourself with people who write these kind of blogs. People need a way to stroke their ego and some of them do it through bashing others. Its literally a 'high school effect' where people elevate their position by potentially demeaning others. Just love python for what it is and not for what people say it ought to be and what it isn't
Probably. You need to be able to get at the output and then look at the output. That's about it. 
Shouldn't we be making a distinction between the REPL and the CPython interpreter? That is, the shell you get by running Python interactively at the command line is *not*, strictly-speaking, CPython; It's just an interface to it. So there's no real contradiction here. I wouldn't be surprised if this behavior was introduced *by design*; If I want to comment on something I'm doing in the shell, it makes sense to keep the comment together with the expression I'm documenting.
Parsing isn't what sets Scrapy apart. It's the networking code. Scrapy is *nice* for parsing stuff but *absolutely fucking amazing* at **fetching** all the stuff you want to parse (and this is where all the alternatives let you down). Like, ridiculously so. I recently wrote a feed aggregator, so nothing to do with scraping, really, but I based it on Scrapy because it's *fucking amazing* at fetching stuff for you. And I don't just mean "fast". I can do that myself with a sprinkling of Twisted or asyncio. It comes with standards-compliant HTTP caching, which makes development super easy—you can tell the cache to just hold onto everything till the code is finished—and real-world performance far, far better. It also comes with excellent throttling capabilities, so you can limit the total number of concurrent connections *and* the per-host number. Regardless of whether you're actually parsing any HTML, Scrapy is an awesome choice if you just need to fetch a load of things from the web at maximum speed (without battering the servers). The conveniences Scrapy provides for parsing are easy enough to implement yourself. The *networking* code is not. And it's a masterpiece. 
That's not a language specification as far as I know. That's an implementation detail.
Heh. https://github.com/scrapy/w3lib/blob/master/w3lib/url.py#L126-L130
That is exactly what I tried but it gave me tons of errors. Oh well. I am not too worried about it
Ok, so let's start with the basic: Electron is an embedded browser with some facilities to access the underlying system instead of being sandboxed like a normal browser. For any Electron app, you still define your interface with HTML and CSS and define the behaviour in JavaScript. The part where Python would 'get in' would be the JavaScript part, so all you need to do is rip off the whole JavaScript engine and put Python there. ... which is no easy task, specially since the Electron runtime is V8 -- or, in other words, the very basic engine inside Electron is a JavaScript engine. ... which is the same what the Python interpreter does. The same "tooling", in this case, would probably be a system agnostic library that could be installed in any operating system, and a package generator for it. My bet is that you can do this using Kivy for the interface and the default python packaging system (and py2exe or something like that to generate the Windows installer).
Progress bars are meaningless.
This is the Cloud9 reddit account, let us know if you have any questions or ideas on how to improve Python support even further :)
We need a progress bar that shows our progress on making progress bar libraries.
Which is the master branch you are referring to? https://github.com/tqdm/tqdm has activity over the past few months, with commits as recently as of 2 hrs. https://github.com/noamraph/tqdm looks dead as of 2 years ago. pypi is also using the tqdm/tqdm repo.
This looks awesome, thanks for sharing!
Is there just a way to allow the program to send mouse events? File "C:\Python34\lib\site-packages\pyautogui-0.9.33-py3.4.egg\pyautogui\_pyautogui_win.py", line 480, in _sendMouseEvent raise ctypes.WinError() PermissionError: [WinError 5] Access is denied. Shouldn't there be a way to just allow access?
It's bpython, not DreamPie.
I know it sounds like that, but I promise it isn't 
I've always used fish. https://pypi.python.org/pypi/fish