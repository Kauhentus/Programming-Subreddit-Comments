It looks like telegraph is just for stats rather than log aggregation in general. I have run into some issues with logstash with regards to scale, and an alternative does have some appeal (i'm actually looking at some influxdb stuff for other purposes already), but I don't see this as a viable replacement. I'll admit I haven't looked at the roadmap, but considering influxdb is made for metrics rather than things like log entries I can't see it as a "true" replacement. I'm more than willing to be wrong...
Is there anything like Java's maven/gradle for C++ or requirements.txt for python? Though I'd say that maven has more feature than doing pip/virtualenv.
Last I checked it has a pretty hefty dependency on Cython. That could be a pretty big roadblock. I'm not a hefty kivy user though so I defer to those with more experience.
Doubtful. Copyright agreements, mostly.
I'm afraid I can't, but the idea is simple. First, `pip install &lt;package&gt;` or `python -m pip install &lt;package&gt;` installs a package with modules and stuff in the python's directory. The problem is that although it does install it, it installs it globally, and projects are known to depend on certain specific versions of things and not just on whatever is installed at the time. So there comes virtualenv. ([user guide](https://virtualenv.pypa.io/en/latest/userguide.html)) What virtualenv does is create a directory with a custom python executable and the same directory structure python needs to run where you can install packages for the project and do project-related configuration. So you execute `virtualenv &lt;my-directory&gt;` or `python -m virtualenv &lt;my-directory&gt;` and it creates that structure there. So say you call `virtualenv ./venv`, it makes a `venv` directory with all you need for a project-specific setup, like a project-specific python installation. Then you need to activate it so that when you run pip or python it uses the `venv` directory instead of the global directory. Normally this means running `venv/scripts/activate` or `venv/scripts/activate.bat` in the console/terminal. my-project/ my-project/my-cool-code.py my-project/venv/ my-project/venv/scripts/ my-project/venv/lib/ etc Once you do that, when you call `pip install &lt;package&gt;` it will install the package inside the `./venv` directory instead of where you installed python in your system. That also means when you run your project while virtualenv is activate'd, if a package is installed globally but not in the venv directory it's just like it's not installed at all so you might see import errors until you re-install all dependencies your project needs to run in your project-specific python install. Once you do that, you'll have a situation where all the packages you need to run are in that project-specific python install. Then comes `pip freeze`. What it does is print out all installed packages. Normally it would mean all globally installed packages, including stuff your project doesn't need, but since you are running from the project-specific venv directory, it will only print packages you installed in there. So running `pip freeze` while virtualenv is activate'd will give you something like: flask 1.0.0 jinja2 2.2.2 whatever-flask-needs-to-run-idk-werkzeug? 0.9.9 So you can just save that to a file, using `pip freeze &gt; requirements.txt` or whatever, and then, when you need to install those requirements, you can do `pip install -r requirements.txt` and pip will install everything it had listed before. Of course if you plan to move your project to a different computer or directory, you will want to create and activate virtualenv again before you execute `pip install -r requirements.txt` so the packages are installed in the project-specific `venv` directory again instead of globally.
&gt; I guess one would have to be faster than the other, but it never occurred to me that Javascript would be faster than Python. JS (actually V8) is very fast compared Python (actually CPython). They're different beasts altogether, V8 being a JIT compiler and CPython being a relatively simple interpreter. PyPy is a JIT compiler for Python which is much faster than the CPython interpreter, but it does not support all the latest features and it still doesn't appear to be as fast as V8—although benchmarking this accurately is hard.
I just use anaconda and it works fine 
There are a number of things that can be improved on the Elastic Search side; using _bulk is definitely one of them, better index mappings is another. I will work on them as the necessity for us comes up, but let me know if you definitely need it, and I will try to find some time.
Supporting a different backend should not be a difficult problem. Is there something specific you have in mind?
I use it with pandas a lot. Np.where is very similar to an if statement in excel for me 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Didn't know about this one, thanks for pointing it out. As /u/AeroAD pointed out, this looks to be more of a time series stats aggregation program, instead of log parsing; it appears to replace e.g. [Prometheus](https://prometheus.io/). I'll keep it on my radar, though.
&gt; I've heard great things about Apache Spark Yup. [Netflix is using Spark](http://techblog.netflix.com/search/label/spark) as part of their analytics platform... they're moving hundreds of GB a day through it.
&gt;&gt;make &amp;&amp; ./run &gt; &gt;does not take that much more time than &gt; &gt;&gt;python main.py As a professional C++ dev, this is highly dependent on what you're building. Some builds you kick off and just go home :P
&gt;The other day I did a fairly boring command line program which reached out onto the net, grabbed some data in a protocol buffer format, fiddled with the data a little bit and then smushed it into a database Of course there wasn't much speed difference here as it's mostly I/O bound. All languages wait at the same speed :P
Yeah, I know about timsort. Maybe I was dreaming the results, because I just found the code and here are my results, so yeah timsort is quite a bit faster. Time is in seconds: pypy partition1 time= 0.0677268505096 timsort time= 0.000385999679565 python: partition1 time= 1.39662981033 timsort time= 0.00105500221252 
What kind of input data set? If the data is purely random, I'd expect quicksort and timsort to be... about the same speed, but for anything less than pure random (so... basically any real data at all in the real world) for timsort to be much much faster.
Yep, if it works then it has value! You may look into a framework like luigi, however, because they help organize and standardize your pipelines. Even Pentaho might be a great option for this, especially because it has the GUI (makes it possible, although not 100% easy, to train non-programmers).
You need to loop through the paragraphs and do the sub on every paragraph not on the list/generator. 
/r/learnpython
'Opening a file' means being able to read it's audio data. The 'waveform' is that very audio data. Compression and lossiness only refer to the way the audio data is stored within the file. The data you read is the same as if the file was not compressed.
what if there was python JIT compiler that neither required you to enforce static type nor lose interpreter startup speed, and gain respectable performance?
My point exactly. For many things that I do the speed difference would either be imperceptible, or irrelevant; such as a nightly routine that might take 3 minutes in Python and 3 seconds in C++. The massive savings in development time is where the win is to be found. Sometimes though, I am pushing right out against the limits of the hardware such as an embedded processor that enables a robot to do something very reactive such as balancing, or avoiding. In this case the debate could even end up being C vs C++ for that closer to the metal speed. Even throwing greater processing power in this example isn't an answer as battery usage is a significant consideration. 
My main issue with Rust is its (ugly) syntax. Where a semi-modern language like Python basically looks like Pseudo code and is very easy to read, Rust more looks like a bash script vomited on a piece of C code. I'm sure the features make up for it, but the syntax is not helping its wider adoption. Maybe I'm just too used to high-level languages. 
I still get "TypeError: expected string or buffer". I tried some variants on the following: for paragraph in paragraphs: paragraph = re.sub(r'\&lt;.*?\&gt;', '', paragraph)
There's relatively new tool that can track memory usage of your program: https://github.com/nvdv/vprof
Duck typing is just a relaxed form of dealing with interfaces. Take this function: def add_all(iterable): iterable = iter(iterable) result = next(iterable) for x in iterable: result += x return result This works with any iterable. A list, a generator, a stream of byte, a file... Basically anything either defining `__iter__` or `__len__` + `__getitem__`. And it also is important to note that the iterable can contain anything, as long as it can be added. So anything defining `__add__`. It means with this function, you can do any of those: &gt;&gt;&gt; add_all(range(5)) 10 &gt;&gt;&gt; add_all(['a', 'b', 'c']) 'abc' &gt;&gt;&gt; add_all(([1, 2, 3], [4, 5, 6])) [1, 2, 3, 4, 5, 6] &gt;&gt;&gt; add_all(open('/etc/fstab'))[:100] "# /etc/fstab: static file system information.\n#\n# Use 'blkid' to print the universally unique identi" By focusing, not what interface object you implements, but on what programming interface the you expose, duck typing allow you to make very generic and flexible functions with little code. It also helps a lot with refactoring, and let you change your mind later, or make mistake with your API design that can be easily fixed latter (`__call__`, `@property`...) 
Falcon web framework is actually awesome, I've used it for a few things.
For handling large data, you can check h5py.
I mean stricter data types can be a good thing for ease of development. Gets rid of a lot of potential errors. Honestly I kind of wish Python was statically typed but just with Haskell level inferred typing.
I don't think this a good example, because you can do the same thing (better) with interfaces in a static typed language. Define the interface for a file (open, write, read, seek, close, etc). Concrete implementation of file class may be a file on disk, or from a string, or over the network, or whatever you want. I say it's better because the interface is then a known API, and anyone can easily implement a new class that conforms to the interface and can be used like a file. For stringio and file, they happen to implement the same interface, but there is no gaurantee and that interface is murky. Such is the nature of duck typing though.
It's hard to find a single good benchmark—usually benchmarks focus on specific, small things, rather than running a comprehensive suite. And even if they do, there's still caveats. They also become irrelevant after some time has passed. But you should be able to get a good idea just by Googling for it.
i assume you are on osx, see the troubleshooting section of that page
Yeah this guy is making me feel like a wizard for doing all my development as a student in vim and on a command line. I do it to avoid all the dumb issues he brought up though
nim is pretty nice for a statically compiled to c language, maybe it's something worth taking a look at?
Thanks! Having the project named "falcon" doesn't really help when there is another python package of the same name... 
Odd how he writes it. Somtimes it's 25% faster (so 0.25) and sometimes it's 2.5x faster, so 150%? I am confused.
Here is some nice way of doing it as a `decorator` http://kukuruku.co/hub/algorithms/automatic-algorithms-optimization-via-fast-matrix-exponentiation 
As well as the dependency on cython which would be a major technical problem in the standard library (as taddeimania said), this just isn't a good development direction. People sometimes say 'the standard library is where modules go to die' - the problem is, once something is in the standard library, its release schedule is tied up with that of the rest of python and it's much harder to make significant changes and improvements because many programs will come to rely on its existing functionality, which the standard library is reluctant to ever change.
The paper was from 2013, so it's reasonable to say they were working on falcon when 2 had wider use.
wow, that cuts deep.
Using regular expressions to parse html is not recommended. Html does not require closing `&lt;/p&gt;` tags, for instance. Even if you are absolutely sure there's no such edge cases, it's usually easier to use a html/xml parser. If your input falls within a very small and strict subset of valid html, using regular expressions can be quite straightforward. import re html = """ &lt;p&gt;Paragraph one&lt;/p&gt; &lt;p&gt;Paragraph two&lt;/p&gt; &lt;p&gt;Paragraph three&lt;/p&gt; """ re.findall(r'&lt;p&gt;(.*?)&lt;/p&gt;', html) output: ['Paragraph one', 'Paragraph two', 'Paragraph three'] As you can see, the output of `re.findall()` is a `list`. Which is why your `re.sub()` raises an exception. You're passing in an incorrect type. If you want suggestions for a better way to do this, you must tell us what input you have and what output you expect. It's also unclear why you need to use regular expressions for this, especially since you seem to be very unfamiliar with the the basics of the python `re` module.
COBOL or Opinion-C
Should stashpy even handle index mappings? Seems like you would want to have elasticsearch create them off of a stored template and use the curator plugin to create and rotate new indexes when necessary. I wonder if that will even ultimately make life easier. The _bulk feature would be a big win for me personally - our logging throughput is to high to rely on single messages. The tough part would be working around the single message per listen part and the async reqeusts; I imagine we'd probably want to throw some small queue in there to group grab message and continue to use the async requests. Then again, I also haven't finished my coffee so I might be talking crazy. 
Does that mean I could to AJAX-like stuff using Python?
But the thing is, pypy breaks a lot of existing libraries that are written in C, such as numpy and scipy, so they end up having to re-implement them all over again, which means pypy's libraries often lags behind CPython's.
Managing dependencies in C/C++ is a real nightmare. In Python you have pip. In C/C++ you have ??? There really isn't a de facto package manager for C/C++. The system package manager (apt, pacman, yum, etc) doesn't count because it's almost always filled with old packages, requires root, and rarely has all the packages you need. The build system is also an annoyance. There are so many build systems for C and C++ and no-one really agrees on which and they are all terrible to use. In other compiled languages like Go, Haskell, Rust, etc you have one de facto build system that everyone uses.
Fun fact: Rust used to have an ML/OCaml-ish syntax but they changed it to appeal to the C++ crowd :P
I don't pick out a new ide every time i start a new c++ project, just like I don't randomly decide to learn a new editor when I do python. Also if you are starting a new a C++ project in this day and age there is absolutely no reason not to use cmake. 
Combine that with a Falcon computer. I just found these through Google though, so don't take what I just said as actual advice. http://www.falconcomputers.co.uk/catalogue/search?q=falcon
try doing print type(paragraph) to see what it is. Or better yet: use a debugger like the one in PyCharm.
Something that doesn't automatically stem and tokenize without me asking it to. This is the biggest deal. Also, something that doesn't require Lucene search and complex XML abortions to be posted to it to interact. Maybe MongoDB? Even Postgres would be better than elasticsearch for me, but sharding and reliability is definitely desirable.
When I said interact, I didn't mean query. I meant things like setting config options (that should be in a damn config file). I went and looked at the docs just now (I discarded ElasticSearch a couple years ago), and it looks like currently you have to post JSON/YAML to it via HTTP in order to interact. (I don't know if I mis-remembered or it has changed.) My problem with elasticsearch is that it stems and tokenizes data based on its idea of natural language. That may work great for certain problems, but it does not work great for log data. I was trying to use (I spent significant effort over the course of a couple of weeks) logstash to ingest and transform my log data (firewall logs, DNS server query logs, etc) and feed it into elasticsearch to view with kibana. I got everything "set up" and "working"... sort of. Most of my DNS queries are apparently for... "com". (And no, I don't mean lookups of the com zone at the GTLD servers level.) As in "www.something.com" tokenized. Which also made www pretty popular, along with net, etc. root and servers (rather than root-servers) also pretty popular. Dammit, that's useless. Equally useless is the fact that 192 tops the list of firewall entries as a source IP entry. Gah! So how do I fix this? Oh, post a complex document to it via HTTP, instead of editing a config file. Oh wait, that fails, because that doesn't match the schema of all the log data it has already mangled. Fuck. Okay, so, basically, drop the entire cluster, go tell logstash to forget all the logs it has ever seen and reanalyze all of them... Rinse and repeat until logstash quits fucking with my data in unpredictable and unwanted ways. Now, when you talk about "use cases" for data in a data store, you mentioned Kibana for ElasticSearch. That's a front-end, and it's definitely a way to use ES if your queries are simple in nature. (Otherwise, you have to write your queries using Lucene syntax, format them into a complex document and POST them to ES). However, I'm a programmer. If the data is in a datastore that I can interact with readily, I can generate my own searches and reports as needed. I just don't want anything making guesses about the meaning of my data.
Not a bug. Using `yield` anywhere in a function turns it into a generator function. Calling a generator function does not execute any of the function, it just returns a generator that's ready to iterate. Your question can be boiled down to this: def foo(): print('hello, world!') yield 3.14 foo() If you run that, nothing is printed. 
No. The method includes a `yield` statement so when called it creates a generator instead of executing. When the thread is started it will call `run()` but that call will return immediately creating a new `generator` object but the generator object will not be run by the thread.
Even after the return when the code is unreachable?
I saw flask 1.0.0 and I thought that it was finally released :P
In addition to what /u/odraencoded said, if you are on Python 3.3 or above, you can use the version of virtualenv that is bundled with the standard runtime. You run it with `python -m venv &lt;my-dir&gt;` or `pyvenv &lt;my-dir&gt;`, no need to install anything.
Use numpy arrays, it will safe a lot of memory and garbage collection problems. I had this issues when I was trying to use random strings, honestly it is just better suited for that. Worst case, it might be easier to use the Levenshtein in C 
Badass, thank you!!!
Falcon uses a shitload of well known opts in the bytecode. CPython is usually looking for simplicity in the coderead, even if that means sacrificing performance, as someone else mentioned here. And yeah, pypy is a speed demon.
the new post is ready :D Python for Object Based Image Analysis (OBIA) Satellite image segmentation and classification in Python http://www.machinalis.com/blog/obia/
Why is it in JSON?
Thanks for the write-up. I've got a busy day, but I'm going to try to carve out some time this evening to recommend a few tips that might be applicable to your application.
Lesser known for a reason. Oddly i have tried every single one of these...all are complete rubbish.
Also sometimes you have to write the makefile first...
I don't know any of them, so this is a genuine question : can you elaborate why they are rubbish ? Is it the lack of functionality, are they clunky to use, or anything specific ?
I guess I should try for myself, but for instance `natsort` looks quite clean in terms of documentation. It is clearly specific and if I have to use one of the features twice a year, that would be an absolute maximum, but after all, I guess that perfectly fits in the OOP paradigm to write super specific functions and then just compose them… Anyway, I rarely use something else than the Scipy/Numpy/Matplotlib/Pandas…
I guess that's because your window manager screws up the (interactive) size of the figure. There are several way of circumventing this, but what I would do is the following : * drop the pylab import in favour of a `import matplotlib.pyplot as plt`, which is in general similar, but with much less edge cases * use a non-interactive backend such as `cairo` (or really any other one) * do not use the `plt.show()` command, because that *does* create the window * just save the figure as pdf Hope this helps. By the way, this kind of question would probably be more suited for /r/learnpython 
Don't listen to the haters.
All were new to me. PrettyTable looked interesting, but i soon found another library for that purpose that is infinitely better: [tabulate](https://bitbucket.org/astanin/python-tabulate) It has a huge number of ways to output the table, like orgmode, rst, jira, mediawiki, latex, ... Now you don't just have nice CLI output, but actually useful formats. 
I think a better question is why should Tk be replaced with Kivy? If that doesn't have a simple uniform (by this I mean not just your opinion) answer then there is really no reason for the change to happen. There are valid reasons to not like Tk and/or to not use Tk. However, that's not really equivalent to saying Tk shouldn't be the Standard Library GUI. I think someone new to python and learning to use Kivy may be a bit confused about the Property system in Kivy given that it differs from that of standard python. If Kivy was part of the Standard Lib I could see someone being confused that the Kivy Property system is not the way all python classes are defined. Granted their documentation does do some effort to explain the difference. I don't disagree with how Kivy handles properties - it greatly simplifies a lot of code but its very specific to that package.
Programming in Python has given me the time to study archaic English conjugations. ;-)
I think the company still owns the stuff you do outside of office. Disclamer: I'm not a lawyer. Maybe if he were an hourly worker that might hold-up, but if he's salaried, I think the company owns everything. If he's working on an existing open-source project, I think that would be a different story since he started with something that had a pre-existing license.
TkInter isn't the official GUI framework. Python doesn't have an official GUI framework. Kivy is pretty good for animated games, or skeuomorphic interfaces. It isn't great for larger desktop software. For that, actually, I would recommend PyQt over anything else. It's relatively modern, powerful, fast, and gives you a native look and feel on every platform.
nice, requested invite! and why not use slack invite system written in Python? like [Slackipy](https://github.com/avinassh/slackipy) may be full disclosure: I wrote Slackipy
I think you do wrong advertising. By taking the choice of saying "consolidation interface" or "sits on top of PIllow, Wand and OpenCV", we don't see the value of it. It makes senses only after further reading: "Willow currently has basic resize and crop operations, face and feature detection and animated GIF support." IMO, whatever the dependencies are, this is where you should focus your market, even if your library have restricted feature depending the dependencies installed / used. But now i can see why Willow is interesting: whatever how the image is loaded, you can use the feature from one dependencies with another one, as they are all sit on the same abstraction. Right? My 2 cents :)
quamash library
I felt this way when I figured out list comprehensions. List comprehensions are the coolest way handling of mapping/filtering in any language I've seen yet. 
Im also a Python/C++ guy. Have you used Cython at all? Cython is a huge pain in the ass to learn, but once you do it makes the C++/Python interface awesome. BTW, i just want to add that C is not C++. They are entirely different languages.
&gt; It's a shame that universities and other educational systems are so slow to embrace Python as well: from database administrators to a former executive of Sun Microsystems (Bill Raduchel), businesses want people that know Python. However, after my brief experience, call me a convert because this is awesome. Right... I've been using Matlab as it was taught my freshman year, but I had to switch to python because mpmath variable precision was necessary to avoid cancellation issues in a sum of very small numbers and Matlab variable precision sucks. I wish we just learned Python freshman year. Easier, faster, and way more applicable to other programming problems besides just numerical/HW-like stuff.
Sorry, I didn't think of that, GitHub's automatic render of Jupyter notebooks doesn't work on mobile. [Here's a link to an nbviewer render, which does](http://nbviewer.jupyter.org/gist/Prooffreader/5407b018d7f11b30747f88b8fae228e8)
TESTIFY! Python is my first language, and working with bits of Javascript and JSON for service management is just so painful and terrible after the pure beauty of Python. I'm probably going to have to learn a blend of Javascript, CSS, and HTML to move forward in my career, and I am not looking forward to it, at all.
My college switched from Scheme to Python for their main 101 class about 10 years ago. There are definitely places out there that see the light, but they tend to not be focused on churning out enterprise coders.
Agreed! As a former ASP/PHP developer throughout many years (10+), I also had "witnessed the glory" :) List comprehensions, decorators, metaclasses, iterators and descriptors: for me, those are the "building blocks of awesomeness" when you talk about Python. And agreeing with you on the shame about universities and other educational systems: In my university (IFRS/Brazil) we have a "academic week", where teachers and alumni expose technical works and speeches. This year, I'm gonna be the one teaching Python on a workshop that's gonna last an entire day :)
Yes python is great. You should definitely read up on the GIL though before you get too exited. It has been significantly mitigated in python 3, but its existence is still a solid mark against the language.
Thank you for this great post &amp; example. This really helps me get a feel for the topic :).
[Image](http://imgs.xkcd.com/comics/python.png) [Mobile](https://m.xkcd.com/353/) **Title:** Python **Title-text:** I wrote 20 short programs in Python yesterday\. It was wonderful\. Perl, I'm leaving you\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/353#Explanation) **Stats:** This comic has been referenced 246 times, representing 0.2283% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d28zvn2)
Care to give a bit more detail as to why you feel this way?
I find C#'s LINQ and javascript's functional functions (map, filter and lodash) quite comparable.
Wow. This is a great example and your comparison of explicitly typed interfaces vs implicit duck typed interfaces using iter brought me over the top. I think I got the point, but I´ll probably have to read your post a couple of times to fully grasp everything. Thank you very much :).
We've started a cookiecutter-data-science project designed for Python data scientists that might be of interest to you, check it out here: https://github.com/drivendata/cookiecutter-data-science Structure is outlined here: https://github.com/drivendata/cookiecutter-data-science/tree/master/%7B%7B%20cookiecutter.repo_name%20%7D%7D Would love feedback if you have it! Feel free to respond here, open PRs or file issues. 
I now get what you mean and I like the comparison. Thanks for that input.
Thanks @voytek9 I am leaning toward building my own pipeline
&gt;Until you run it on hardware. Then it's everything but. as if there's any other option
Thanks for the mention, it's an interesting read. I had considered that there might be issues due to it being an interpreted language. My assumption was that they would be minor especially due to the current status of hardware performance, and it looks like I was more or less correct. I typically compare Java to Python as they are both interpreted languages (and I am most familiar with Java), and it doesn't appear that the GIL impacts the performance significantly in Python 3. It also appears that you can avoid it with design decisions or even different variations of Python as well. I'm actually going to try and push this for my university because holy hell, disregarding my personal feelings for Python, the industry WANTS Python as a skill. Thanks for letting me know, I can make sure to include that consideration. 
You can't avoid wasting RAM and CPU cycles unless you replace Python with a more efficient language/implementation. That's why the usual advice for performance bottlenecks in Python is to rewrite them in C/C++ and limit Python's use to a glue language (much like shell scripting).
How is moving from Scheme to Python seeing the light?
C#'s (really .NET, it's not limited to C#) LiNQ is a thing of beauty and the strong typing combined with intellisense makes it VERY smooth to work with. 
You do realize that that is second person, right?
My college's 101 class teaches Python!
We are thinking at some point in the near future to better organize the community into interesting channels, like: computer-science, django, web-development, etc. Of course we are totally open for suggestions. As the name says, it's a community.
Java is actually my primary language. I haven't done any individual projects that are extremely large and I wouldn't call myself particularly skilled at Java, but so far from learning Python I see many situations in which code would be convoluted. For example, to make a collection with words and numbers in Java, you'd have three options: -Import ArrayList or similar function, then define it using ArrayList&lt;String, Integer&gt; list = new ArrayList&lt;String&gt;(); and populate it with list.add("one", 1); list.add("two", 2); etc -Import ArrayList similar to above but have all entries as String so that you can use numbers or letters for keys, but would have to convert them later -Create custom function Whereas in Python, you can simply do x = [1,"banana","orange you glad",2] Granted, there aren't many situations in which you would need a less structured list, and my example isn't the most efficient, but the many features of Python that you can utilize to create programs, especially when a small quick program is needed just blows my mind. You can rename IMPORTS, so you don't need to write long, convoluted references that make code less readable and longer. I don't know about the future, but my current impression is that after learning how Python handles syntax, I don't really want to go back to Java unless Python isn't an option at all. 
Agreed, most popular languages have their strengths. Python has a very wide area of usefulness but it is by no means better at everything. I get a similar feeling whenever I boot up the Java IDE and immediately understand how to use a third party library entirely via auto-complete. Moving to a functional/apl-like language that can accomplish 20+ lines of python in thirty characters is fun as well.
holy, effing crap. you are correct sir. 
Yeah, I guess I have just been bitten too many times with the python solution not being good enough. You define (open, write) and then you pass it to some library that will treat it like a file, it runs fine. Then 2 weeks later in production the library suddenly calls read(), and you didn't implement that, so it crashes with an exception. I've used Python extensively in a professional capacity for the last 5 or 6 years, so at this point I don't think my opinion is going to change. There are a lot of things I love about python, but duck typing and lack of real interfaces is not one of them. edit: to be fair, one can use abstract base classes to mimic most of what you would get from a traditional interface, and there are third party interface libraries that exist for python, such as from zope and in twisted.
Still relatively new to Python. What does: brings everything together that you want to do in one place. Scripting, prototyping, analysis, visualization, applications, etc. It doesn't do any of these things optimally compared to other languages, but it's definitely a catch-all. I still have a hard time abandoning Perl when I need to parse lots of text files rapidly, or not using Fortran (modern) to do heavy duty numerical analysis. or to abandon Matlab to do quick and dirty plotting. Yes Python can do all of these things, and with practice I feel like I could abandon Perl and Matlab completely. Fortran is here to stay (for my profession). 
I imagine the length check is unreliable in the presence of `EXTENDED_ARG`, especially if the new fixed-width bytecode lands.
Where can I learn more about this?
`import antigravity`
Hahahaha that's fantastic! 
World's most unnecessary bot
&gt; As a former ASP/PHP developer I literally came when I used Django for the first time ever, after using PHP for two years. I moved to Rust from Python now though. Python doesn't have good enough performance for some of the stuff I want to make.
The convenient thing about comprehensions is that you can have an arbitrary expression in your map, instead of just a named function. But then you need to duplicate the code if you have an expression or anonymous function there.
Came here for the Python, left with the Syntax!!!
Using lambda functions inside list comprehensions does get kinda clunky, true. At some point you just strain what can be done in one line while maintaining readability.
At my university Java is the first taught language, but in recent they are planning on teaching the first intro class being half python at the start and basic java in the end. There are 2 courses that just focus around java so a lot of the Java 1 course will be consolidated in the 2nd Java course
Haskell's type system is just about powerful enough for the first two. You would simply have to have it so that using 'foo.bar' asserts that foo must be an instance of special typeclass 'hasBar'. And then when creating a new object, if it sets 'bar' then it is automatically a part of 'hasBar'. Ad hoc interfaces would more or less fit under the same umbrella. I think you could extend Haskell's type system to include implicit union (explicit ones already exist) types, but it wouldn't be as trivial.
It's true: list comprehensions are so cool because they are even much more readable than "seemingly" nice `filter`, `reduce` and `map`.
Almost like it is still in German 'Ich habe, du hast, er/sie/es hat, wir haben, ihr habt, sie haben.'
Peer review filters out the bullshit. This is bullshit.
&gt; I know Java, C, C++ ... Doubtful.
So numpy will be waay faster for memory allocation and some default functions. Using numpy, you can rewrite line 8 as import numpy as np d = np.zeros((n, m)) Lines 10 and 11 can be rewritten as d[:, 0] = range(n) d[0, :] = range(m) Then you can rewrite the rest using the same type of syntax. Some notes: * Numpy will *just* allocate the necessary memory for the array. Built in python arrays do dynamic memory allocation which is super slow ([here's an article on dynamic memory allocation](http://www.evanjones.ca/memoryallocator/)) * Element access should be a lot faster (not 100% on this, should at the least be faster for larger arrays) * Edit: [read this](http://stackoverflow.com/a/29311751/1419668) That's a decent start, but for another speedup, definitely implement that algorithm you linked.
But I don't have 2.7 installed, how could I use it as my interpreter?
You need to move to coffeescript. It's the Python-for-Javascripters that you wish you had learned earlier. Don't complain about compilation. Just accept it. You will be happy you did!
Gevent is a great scaling solution if it isn't already in your project. I took a site with by a Java programmer from 12 minutes load time to 4 seconds thanks to gevent. You read that right, 12 minutes.
I guess I would take a bit of a different approach on this, and outline some background of the problem that duck typing solves, as well as some other approaches and the pros and cons to duck typing. * duck typing is a form of *polymorphism*. if you don't know what polymorphism means, you may want to read up a bit. briefly, poly=many, morph=forms... basically, in this context it means the ability to perform the same operation on objects of different type. or, to say one object may have many forms but still be treated the same way. * duck typing provides polymorphism by capability. that is, there is no type checking involved, but if the object can do the thing then it will. otherwise, it will throw an exception. * there is an classic division in computer science between the "Look Before You Leap" approach and the "Easier to Ask Forgiveness than Permission". LBYL advocates checking to make sure a thing would work, before trying it. EAFP advocates just doing the thing, and then handling the consequences. duck typing is very much EAFP, and this is common in python. * as covered by some answers already, other languages commonly provide a similar capability for polymorphism via interfaces or templates. you write an interface that defines the API, you write a class (or many different classes) that implement that API, and then any instance of any of these classes can be used for something that requires an object which conforms to the API. * the primary benefit is that duck typing requires less code, and less "bureaucracy". you don't have to specify an interface, you just write the method that will be used, and it gets called if it exists. it's just simpler for so many things, both when writing code and in the interpreter. * this is especially true as you build up more classes with complex functionality. look up something like "java generics hell" to see what a mess you can into when the type of everything must be specified ahead of time. * it can be easier to understand. especially for new programmers that are not familiar with all the terms i have used here and long words like polymorphism which can be intimidating. * another is that it's easier to modify on the fly, or dynamically. if you are doing some metaprogramming or live editing in a debugger or other fancy stuff, you don't have to jump through any hoops to conform to an interface, and can more easily modify core behavior or build up your own type system. * it's can also be faster. if the interpreter doesn't have to check whether an object conforms to a particular interface before calling a method on it, that is some amount of saved CPU cycles. the savings however is minimal, and most static typed languages are faster than python for other reasons, so this isn't a great argument. * one downside is that when you start treating different objects interchangeably in a function that expects them to have implemented some common API, you are essentially conforming to an interface. unfortunately, it is an interface that is not well specified. if the programmer of the library/function was a nice guy, they have included some comments or documentation about what behavior is expected from objects that get passed in. for example "must be able to bark(), run() and wag_tail()". if not, you have have to look through the code yourself to find out what methods get called. for instance, what methods define a file-like object in python? are read(), write(), and close() enough? what about len(), readline(), readlines(), writelines(), seek(), tell(), truncate(), flush() and isatty()? what are those methods supposed to return? how many of these are necessary to implement for an object to be able to fulfill all capabilities of a file? * this leads us to the fact there is no easy way to check if you got it right. with an interface, you can write some code to check it for you. this is what python does with abstract base classes. compiled languages will check if the interface requirements have been met at compile time. with duck typing, you have to write a lot of unit tests, and hope you caught everything in a test. or maybe you don't care, and it just blows up at runtime in unexpected ways. * since there is no official interface, developers feel no qualms about changing behavior. let's say you were passing a file-like thing to some library. everything was working great. now you pull down a new version of the library from pip, and suddenly the author is calling some other function on the object that you don't support! or, vice-versa: you are using a third-party library that offers a thing that happens to work like a file. you write code that treats it like a file. new version, they make it not work like a file. now you have to rewrite a bunch of code. you email the developer to complain, and they say "i didn't know anyone was going to use it like a file!". it just happened to work... until it didn't. 
I don't think it's that simple; that would require all `bar`s to be from the same typeclass and thus of the same type. I don't think Haskell is able to infer typeclasses globally either.
oh...I guess I wasn't sure if the audio data was encoded somehow that would result in a nonlinear translation into the waveform. Despite my best efforts, I'm pretty ignorant about a lot of things.
Not really polymorphism in Python though, is it? It's duck typing. 
150% _faster_ is 2.5x 150% _as fast_ is 1.5x English is weird...
I'm taking an EdX class from MIT on Analytics and we're using "R". Having done some work in iPython notebook with Pandas, etc..., "R" is a total disaster. 
That would actually make a cute ad series: "Programming in Python is so fast &amp; easy, I now have time to &lt;insert bizarre hobby here&gt;."
Speed is a focus for Python 3.6 because of renewal of requests about it. Many projects are also raising (pydgin, pyston, etc) to create JIT for Python. While Python doesn't need the extra speed to be a big player, having would make some people happy it seems.
I am not sure if we can release transcript in together with episodes as even summary is time consuming. I am working on transcript for latest episode and will post it to our site once ready. 
"...I now have time to LEARN HASKELL" (you wanted something bizarre, right?)
I'm in the middle of trying to write my data containers in structured numpy arrays, this will get rid of most of the nestled dictionary I was using. I'm just going to use one dictionary with two fields, 'upstream' and 'downstream', both of those will then have structured arrays that contain everything else. I have this mostly done, it just doesn't meet my criteria for "readability" yet. Which honestly, readability might be a waste of time. I've pushed these changes to github
Except that he uses the print function of python 2, but it's an older comic, he shall be forgiven!
What do you think Cython does behind the scenes? It takes a subset of Python with some extra markings and generates C which it then compiles and links into a module. It's just like I said: the solution to Python's waste of resources is always to replace it with a more effective language.
I personally really like ruby's methods as well!
I take the phrase "union types" from the formalisms you find in Crystal and Ceylon, but these are really just statically checked versions of how dynamic languages like Python are used. Effectively this is an expanded form of flow typing. When you have two possible assignments to a value, like if test(): x = foo else: x = bar `x` takes the type `type(foo) | type(bar)`. A common example is the nillable type, which Python programs typically represent as `T | NoneType`. Now, nillable types are a bit unimpressive, and unchecked nillable types from a dynamic language if anything are a disadvantage. But ad-hoc unions are a lot more flexible. If, say, you have a list of instructions instructions = [Add(...), Mul(...), Load(...), Store(...)] this will have type `list[Instruction]`. You might avoid making an `Instruction` supertype (depending on context, either option is preferable), in which case the type is `list[Add | Mul | Load | Store]`. Now, let's say you want to find the length of these, but decide you need to pad the instructions to certain alignments. You could then have instructions = [Add(...), Padding(4), Mul(...), Padding(2), Load(...), Padding(2), Store(...), Padding(4)] Then the type is `list[Padding | ...]`. If you call `byte_length` on the values and all of the inputs have a `byte_length` method of type `Self -&gt; int`, the resulting iterable would be of the abstract type `Iterator[int]`. Note that if `Mul`s gave, say, a `float` the type would be `Iterator[int | float]`... which is really cool, but not relevant to this example. Then if you want to run a method on only instructions, you can do something like instructions = (i for i in instructions if not isinstance(i, Padding)) This gives an iterable of abstract type `Iterator[Add | Mul | ...]`. Then if all of *those* types support some method `to_bytecode` of type `Self -&gt; bytes`, you can call it on each element of the iterator. Statically checked versions can do this too, FWIW. Note that no interfaces were needed; interfaces are extensible whereas these refer to the behaviour of a fixed set of types. Doing this in a Haskell-like language would normally require * An `Instruction` ADT (= `Mul(Mul) | Add(Add) | Load(Load) | ...`), * An `InstructionOrPadding` ADT, * `byte_length` implemented for `InstructionOrPadding` that dispatches to its contents *and* for `Instruction`, which dispatches to *its* contents, * `to_bytecode` implemented for `Instruction`, which dispatches to its contents. This is reasonable overhead in many cases in Haskell, but Python isn't as concise as Haskell and the ability to just "slot" in a `Padding` instruction and then filter it out without reorganizing your types or creating explicit interfaces is part of what makes Python so quick to prototype in. 
After thinking about this for a bit, the point is kind of moot. The logstash template will be used as a base, and additional mappings can be added on the elasticsearch side. The original concern I had was with the addition of log fields, but it looks like that's handled via json that elasticsearch will dynamically create the mapping for. 
plus, when you want to include modules, just pip install them, no maven or gradle pains or woes, no npm node versioning problems, no indecipherable compiling or linking problems, it just fucking works
The circlejerk is to strong here and there are a lot of [baby duck syndrome](https://en.wikipedia.org/wiki/Sexual_imprinting) cases around here.
The first time I wrote: reduce(filter(map(... and it was 100% obvious to me what I was doing, I was so happy. It's like leveling up in abstraction. Can't forget `chain.from_iterable` either.
Python is a great language no doubt but in my estimation it is a terrible language to teach computer science. Most universities have computer science programs and aren't in the business of teaching "programming" per say. If the goal is to simply teach someone to program then yeah Python is pretty good. Just realize that there are two different goods here. 
It's not. x is a tuple whose first member is a lambda that returns True and whose second member is 0.
Have you checked out decorators? You gotta check out decorators.
I've been using Python solidly for a decade and a half now. I don't think I've *ever* run into a problem caused by the GIL.
Will do
thanks, that's what I feared. was hoping for a more transparent way more compatible with my usual work flow (display figures and then saving at the end with a single line). I will probably add a little function to my utility script. Thanks for the suggestion about the learnpython subreddit. didn't know about it. I am a reddit beginner ;) m
if i'm going to write the silly x for x in ... then i can do filter(filter_func, map(lambda item: mapping expression, items)) right away
Yes. And then there's Java.
I am waiting for the day, calculating the fibonacci series is actual needed in real code ;) BTW I added a fib_generator and changed your recursive function, two pull requests are waiting for you. I have at least two more different methods in my mind ;)
That tattoo is beautiful and better than ugly. 
Python, yes, most definitely, but never heard of haskell
Of course my one-liner only works on that first case. The issue I have with `natsort` as a library, is that generally, when sorting strings, I want a very specific method to their ordering. For example, a use case that `natsort` will not work on is a = ['5r34a', ...] Let's say I want to sort by the release candidate number (for some reason) instead of the version number. Yes, `natsort` can use a custom key for sorting, but at that point why bother? Why not just use the default functionality? My point is, is that when it comes to string sorting, there are a couple really basic cases where a library like this comes in handy, but in general, there are far more cases where it breaks down. I would prefer defining a function that I *know* orders an array of strings in the exact way I want it, rather than hoping that the default behavior of some exotic library has my use case in mind. Don't get me wrong, it can be absolutely essential if your string arrays are all of the same sort of format that `natsort` can deal with, and if you don't know the exact type of formatting that a given string array might have, then it could be a lifesaver. That being said, it's not at all a replacement for the default sorting `key` argument.
David Beazley used it in a demo talk as an easy way to represent cpu intensive tasks that could be made to be very rapid or much more long running. 
coffeescript is a dead project, I would strongly recommend against learning it.
Beazley also often jokes about the fact that the fibonacci series is a overused example for recursion with no real use case. Also the naive recursion is slow as hell. Nobody calculates fibs and also factorials in a recursive manner, except haskel guys.
I acknowledge that, However, For me personally, I have never found it to be a problem. I either use a makefile or a script with a clang or GCC command, which works just the same everywhere, although you might have to format it for Windows, you could still copy paste it into your terminal, and make files can be very universal. I would posit that the package system depends on your system and that is really, in this context, how it sort of has to be because of the OS companies, etc. Regardless, You could always include the okay?ries, Or do a static compilation. Really, You can always manage, And it never is hard, You can just include the instructions in your README or maybe even make a script to automatically download and install them for every OS. This is just how it works, It's not a big deal in my experience and it's part of why C/C++ is faster. Also, The root question for apt is just a basic security feature, present on even iOS devices for their app store. You know your own password and it's not hard to type it in, If you don't know the password, then it's probably not your computer and you should either ask or not do that thing. If I may ask, What is your language of preference/which languages do you know? I understand if you primarily use and first learned interpreted languages and consider compiled languages to be strange. *almost everyone* thinks that about different languages than they first learned. Lots of C people dislike C++/think OOP is lame, Or interpreted langauges or web languages, etc. That's where most of us start out, We choose one dynamic for whatever reason, And we develop a sports esque loyalty to that dynamic, But that isn't really logical. Different languages do different things for different reasons and that's fine. We are (maybe?) All adults here and we shouldn't bash each other's preferences. I started with C++, Then I went to C and lua, I still primarily use C, But I've been expanding myself to Python and some web languages like HTML5, They all do what they do for a reason and there isn't anything wrong with that. Let's just accept each other, okay?
If you like JS functional, you'll love Ruby.
I've heard a lot of negative things about coffeescript lately, and basically everyone has moved on to typescript or just pure JS with ES2015
In this instance he joked that he'd finally found a mildy useful application for a fibonacci number generator - just to churn on the CPU. 
There's a neat package for doing Levenshteiny things called FuzzyWuzzy... https://github.com/seatgeek/fuzzywuzzy
AntennaPod has two separate search facilities, one for iTunes and one for gPodder.net. In the iTunes search you're the first hit when searching for `code podcast`, it links to the SoundCloud feed and works perfectly. The gPodder.net search on AntennaPod times out at the moment (gPodder.net is often slow), but on the web it [doesn't really seem to find it](https://gpodder.net/search/?q=code+podcast). It's listed [in the directory](https://gpodder.net/podcast/code-podcast) (with [this RSS feed](http://codepodcast.com/feeds/all.rss.xml)), but gPodder's search function just sucks :/ edit: looks like the SoundCloud feed is in gPodder's directory as well, [here](https://gpodder.net/podcast/47a7cf4c068011e690bdaa0000139656).
&gt; Java is actually my primary language. This explains your excitement with Python :) . (I say this in an absolutely not condescending manner. It's really that big a difference; Java feels like filling handwritten forms in triplicate when compared to Python.) &gt; Whereas in Python, you can simply do x = [1,"banana","orange you glad",2] This is a property of most if not all dynamic typing languages. It's the same in JavaScript (which is nothing like Java besides the syntax looking similar and sharing some OOP properties), Ruby, Perl, PHP, Lisp, Clojure, etc. I do not enjoy programming in languages where this is not possible. &gt; Granted, there aren't many situations in which you would need a less structured list There are many though — ad hoc data structures. Why do everything with lists and dictionaries when you could be using classes? Because you already have a hundred well designed, well documented, well tested, well implemented functions for lists and dictionaries which you know from memory, and zero boilerplate and paperwork to do. And for the same amount of work, you can do far more thing with 5 classes with 20 methods each, than you can do with 20 classes with 5 methods each. Of course, there's a downside to this, which is documentation and ease of understanding in large projects in large teams (large doesn't mean 7 people). I wouldn't write aircraft firmware like this. I would write something like Reddit like this. Another downside to this and dynamic typing in general — type errors happen in real time, not compile time. PHP and JavaScript make this worse by converting numbers to strings and sometimes worse on your back, which means when there's a bug or unchecked bad input something will glitch and you'll have a harder time to find why, but Python is a lot better at this as it kills it with fire on the spot. **However**, this is a problem that can be mostly fixed without resorting to boilerplate type definitions as you have in Java, just popular languages aren't smart enough to. Check out type inference. For example: char *a = "hello"; int f(int i) { return i + 2; } Well, no shit Sherlock, even without types you can tell a is string (or char * in C), i is int and f has to return int. The fucking compiler should be smart enough to tell. (In the case of Python, all that could be said is that a is str and i must have \_\_add\_\_ with int, though.) &gt; You can rename IMPORTS, so you don't need to write long, convoluted references that make code less readable and longer. You're also used to the Java standard library, which is the paramount example of an overengineered, overdone, overeverything, bloated lump of crap with multiple layers of inheritance that makes documentation spaghetti and programming very difficult without a huge, smart IDE. BTW, you can also reload Python modules to have a program reload and update its functionality in real time. &gt; my current impression is that after learning how Python handles syntax, I don't really want to go back to Java unless Python isn't an option at all Same here. Both as a development director and as a developer if I'm to do development, I would never prefer Java over Python in particular; if I *had* to use the JVM I'd try to use Jython (or Clojure, or maybe Scala), and if Python wouldn't be acceptable for whatever reason, I would explore whatever high-level alternatives I have, from JavaScript to Clojure.
Well, it WAS a great language. Then the fanboyz started clamoring to make everything "pythonic" (A nonsense word which they say has great meaning, but mysteriously avoid defining), which included (Apparently) the need to whine about anything and everything that didn't follow the rulez of the Mighty PEP. Remember that freedom you felt at first, because pretty soon somebody will whine at you for using 3 spaces instead of 4. (And don't you DARE to mention that using tabs instead of spaces would have allowed everybody to see the code the way they wanted to see it. BLASPHEMY!!!) And when the Bondage Dick For Life makes stupid changes, well you'd just better suck it up, kiddo. The fanboyz will tolerate no logic!
On flexibility, I want to be able to do anything anywhere. For example, and most importantly, it annoys me to no end that Python has statements which cannot go anywhere, which causes the following warts that hurt the language; for example: - def vs. lambda (lambda shouldn't even exist!) - lambda sucks because it can't have if, while, etc. - def sucks because it can't go anywhere, e.g. an argument list - So programs are plagued with def _ shit - Because of this we have the awful wart of decorators, when all that was needed was to do something like decorator(def x: ...) - "a or sys.exit(0)" is ok, but "a or raise SystemExit" is not just because - if statement vs if expression, and the if expression was evilly crafted to impair nesting just because fuck you, and I still haven't heard a single reason why a = if x: y; else z; is not possible. - print statement in Python 2 vs print function in Python 3, yet sys.write is always an expression; it's so arbitrary and ridiculous - You can do a = b = c but not a += b = c or f(a += b) - for inside list comprehension goes anywhere but not outside - And I can go on and on... All of this makes functional programming, i.e. the highest level, least error-prone paradigm, very cumbersome in Python. One reason behind this is that Guido van Rossum doesn't like functional programming (and he said so); simple as that. &gt; I like some of the FP-related choices Python has made I suppose you meant dislike, as there are no downsides to tail call elimination other than Guido hating recursion. &gt; I have trouble seeing FP in Python as "Fucked up", and compared to JS, I think Python does it slightly better. What are your opinions on it? JavaScript got a lot of things very wrong, but at least there are decent λ-expressions (function as expression, and you can even give it a name which is nice for stack traces), and with the right libraries and discipline, it feels slightly better to me, even if it still has statements and crappy syntax. Decorator syntax is simply a stupid, unidiomatic, warty and ill-conceived workaround introduced by Guido to allow a particular case of higher order function not to suck in Python, making the language bigger and uglier, instead of fixing def. Instead of doing: @magic def x(stuff): things you sould be able to do x = magic(def x(stuff): things ) And don't get me started on the shitty way @magic(x) is handled and the decorator you need to properly define decorators with arguments, as opposed to the simplicity that: x = magic(arg1, arg2, def x(stuff): things ) would have been. All that is perfectly possible in JavaScript, in fact JavaScript doesn't have a language feature for "decorators", just like nobody has a language feature for "function that returns function" or for whatever other particular application of functional programming you'd like to have. BTW, before you ask about magic receiving arg1 and arg2 after the function, or receiving more than one function, it's really simple; just keep in mind that Python replaced the usual braces of C-like languages with INDENT and DEDENT, so you would do something like: x = magic(def x(stuff): things , arg1, arg2) Whether this looks better or worse with INDENT/DEDENT, braces or parens is a matter of aesthetics.
Just because readability and maintainability are prioritized above performance doesn't necessarily exclude all optimizations bar none. The above micro-optimizations are merely readable and maintainable (as opposed to, say, a full blown just in time compiler versus straight interpretation).
TIL German.
Which `HasBar`? There are potentially multiple.
Well, you are basically transpiling using Babel for ES2015, plus you have to do all the bracket crap and let/var stuff. I'm not moving to it yet until all browsers support it directly. But I'm glad you've heard about Coffee. I love it, and never want to write old JS again. 
I would suggest doing show notes instead of transcripts. No one does transcripts in the hobbyist podcast world.
It seems I misunderstood what you meant by "You could have multiple `HasBar` typeclasses be generated". I'm not so pro at Haskell, but isn't using `h a` a bit suspicious? Doesn't this only work for parameterized types? How would you implement this for `bool`?
Python 2 has the same functions as javascript (Python 3 has them if you `import functools` - it's preferred to use list comprehensions instead).
But ruby is not async
I write threaded code all the time. Single-threaded.
Rather than starting a new one and further fragmenting the community, you should join an existing one with &gt;850 members! (Vs the 26 you guys have ATM) python-community.slack.com [Join Link](http://pythoncommunity.herokuapp.com/) 
If someone were posting those threads every day, or even every few days, then you might have a valid complaint.
Hi there, this post being removed as it is not directly related to the Python programming language. It might be more topical on /r/programming, /r/coding, or /r/technology. Cheers, /r/Python mods
I write in Java for a living, whenever I switch to writing something in python I feel like I'm getting away with something, like it shouldn't be that easy. When I learned Python it was my first language and the book I was reading kept reiterating that Python is polymorphic, and I was like "so, who cares?" And then I got to Java and was like "oh, that's why"
[Image](http://imgs.xkcd.com/comics/python.png) [Mobile](https://m.xkcd.com/353/) **Title:** Python **Title-text:** I wrote 20 short programs in Python yesterday\. It was wonderful\. Perl, I'm leaving you\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/353#Explanation) **Stats:** This comic has been referenced 247 times, representing 0.2291% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d29qmln)
Py3 only moved `reduce` from builtin to the `functools` module; `map` and `filter` are still there. Comprehensions (list, set, generator, dictionary..) are often more elegant though, as you get the exact datatype you want.
Yeah, but the more important question is: So what? You end up writing python and getting performance out of it, it shouldn't concern you at all that it is translated into C before being compiled.
Isn't the whole point of Computer Science 101 to teach computer science concepts? If a "niche" language can do that better, why wouldn't they use it? A "more practical" language that's worse at teaching concepts sounds like it's *more* suited to "churning out enterprise coders", not less.
Haha yeah I should look at it that way. 10 hours here and I thought maybe something different but the disappointment continues. What also gets me is they're putting other languages down like C++ doesn't have its place. 
How's about I write you a tutorial on web scraping? ;D
i think you meant to say definitely!
&gt; The first time I wrote: &gt; &gt; reduce(filter(map(... &gt; &gt; and it was 100% obvious to me what I was doing, I was so happy. It's like leveling up in abstraction. After the tenth time, I was feeling more lispy than pythonic - all those parens! Then I discovered some of the crazy stuff Python lets you do with functions - the things people usually associate with Haskell (but nice, I promise). You can write a function which composes functions: def compose(*funcs): return reduce(lambda f, g: lambda x: f(g(x)), funcs, lambda x: x) assert reduce(filter(map(x))) == compose(reduce, filter, map)(x) Now you can chain together long sequences of functions *without* nesting parentheses, including chaining chains to whatever depth. Contrived example: myfunc = compose( functools.partial(open, encoding='cp437'), iter, functools.partial(filter, lambda line: line.strip), tuple, ) lines = myfunc(file.txt) # tuple of non-empty lines from file with odd encoding This can be surprisingly useful, especially if you're already passing functions as arguments or chaining functions together!
&gt; tools that seem to be missing from functools like a compose function def compose(*funcs): # assert reduce(filter(map(x))) == compose(map, filter, reduce)(x) return reduce(lambda f, g: lambda x: g(f(x)), funcs, lambda x: x) Should be part of the stdlib, but at least it's a oneliner if you need it.
I know. My point is python does implement optimizations that are outside of simply what's obvious; the GIL for example.
They don't intend to add new features, adopt es6 features or even compile to es6 (compiling to es6 can hint the JIT better).
Thanks, that makes a lot more sense. I disagree with you that decorators are an ugly syntax-bloating workaround though. Yes they are needed due to the fact that you can't define functions as expressions (and I agree that it should be possible to do that), but I think that @magic def x(stuff): things looks way better than x = magic(def x(stuff): things ) and if you add more decorators, like @decorator2 @decorator1 def something(): pass the alternative starts to look even worse. `@called_decorator()`s are a bit of an exception given that the decorators themselves are ugly and somewhat confusing to write, although you can always write a decorator that transforms saner functions into decorators. &gt; JavaScript doesn't have a language feature for "decorators" Interestingly enough, I've seen some somewhat serious proposals to add decorators to JavaScript. The only thing I can find right now is [this](https://github.com/wycats/javascript-decorators) which I don't believe is an official thing, but I'm pretty sure I've heard more about it. Speaking of JavaScript and decorators, I once wrote a JavaScript function that allows you to do var something = decorate( [decorator2, decorator1], function() { } ); although I suppose that goes to show that JavaScript is more syntactically flexible than Python and doesn't actually look very pretty, I did it because I liked Python's decorators and wanted to emulate them in JavaScript.
&gt; Isn't the whole point of Computer Science 101 to teach computer science concepts? If a "niche" language can do that better, why wouldn't they use it? Because there are a lot more pain points using Scheme, and 99% of people that took the class will never use it again. ((((Don't get)) me wrong, (I took the Scheme version of the course and loved it, (((but the language itself is a pain in the ass and) I could have gotten most of the same functional programming) knowledge out of it by using python.)))) (did I get my parentheses count right?) &gt; A "more practical" language that's worse at teaching concepts sounds like it's more suited to "churning out enterprise coders", not less. Was more trying to point out that schools that teach Java/.net/whatever as their 101 language are probably not going to switch to Python, while schools that are using a LISP language for intro programming might be more willing to entertain Python, as their goal probably isn't to prepare students to go work for an enterprise code shop if they're teaching them Scheme.
I mean you need to use `MultiParamTypeClasses` but extensions are a core part of Haskell at this point. {-# LANGUAGE MultiParamTypeClasses #-} class HasBar a b where bar :: b -&gt; a data Foo = Foo { barBool :: Bool } deriving (Show) instance HasBar Bool Foo where bar = barBool data Bazz = Bazz { barInt :: Int } deriving (Show) instance HasBar Int Bazz where bar = barInt I phrased the multiple TypeClasses thing poorly, I meant one use of `class` but you end up with multiple pseudo-typeclasses through different values of the first parameter. I also messed up the type of `bar`, it is actually `HasBar a b =&gt; b -&gt; a`. Pretty much all my previous commenting was on phone, now that I am on my computer I can be more accurate. And `h a` isn't particularly suspicious. I mean the type of `pure` is pretty close: `Applicative f =&gt; a -&gt; f a`. Just the inverted version of it.
Yeah, I have something very similar that I copy-paste into my programs now and then, but it ***really*** should be in the stdlib. On a similar note, why aren't all (or at least several of) those recipes in the itertools docs part of itertools? I mean the stdlib can't do everything, but it could provide a few more functions for common problems in itertools and functools IMO.
Damn I can't believe I haven't heard of it. Looks useful, I'll have to check it out.
Lose the preachy tone dude. Python is awesome in many things, and I love it. But in many other aspects it sucks. For instance, I find C to be as awesome as python in its simplicity. Yes, C is VERY simple. Many those "universities and other educational systems" are not "slow to embrace Python", there are things that python is not suitable to teach.
List comprehension is borrowed from Haskell. But in Haskell I would prefer map f ls instead of [f(x) for x in ls] 
I think you misspelled that! definetly*
Also it looks like there is this: http://www.well-typed.com/blog/84/ Which is almost certainly better than what I am talking about.
Hey! that's not nice!
Haha fuck eh
Hey! that's not nice! you shouldnt swear! (This is a test)
This is a problem with how Reddit works in general, not this sub specifically. My recommendation: just downvote &amp; hide the post, and move on. There are some interesting posts that never get many upvotes, so you could try browsing /r/python/new -- that also helps moderating since we can downvote bad quality posts before they gain enough steam to get "hot". 
Haha I'm agreeing with you. pretty sure that mess of the jankiest code on planet earth proves your point fairly well. 
fuck
It was my first language (taught in a college intro to program development course, actually) and I really enjoyed it at the time. I'm currently learning Java, and for all of Java's shortcomings I really, really do not miss how Python cares about white space.
Well you would deduce the type for spam first. And then use that deduced type. So once you know spam is type `Int` you do: instance HasBar Int Foo where bar = spam Or something like that. Also look at my other comment, that looks much more useful than the magic stuff I am talking about.
Thanks for the link. That seems more constrained than what Python would need, though, as the return types from record accesses are always annotated.
What do you mean? It doesn't look like they are from that link?
Warning: hathlib has been deprecated since the 18th century
Same. But not all shops are this way though. This is especially the case with older code. It took me the better part of 5 years to clean out our codebase of shitty, ineffectual multithreaded code. The original developers were Java folks who did not seem to believe in actually testing whether or not the kludge-y mess they'd written actually performed under python like it would under Java.
Do you have an example?
Yea I do that too. It'd pretty nice.
&gt; Python is being rapidly developed and changes in the language are happening faster than in other languages like C++, Java, C# Interesting way to describe a single set of changes that happened across the very long period of 1 version bump also for comparison .NET https://msdn.microsoft.com/en-US/library/dn458358(v=vs.110).aspx python https://docs.python.org/3/whatsnew/3.0.html java http://www.oracle.com/technetwork/java/javase/8-compatibility-guide-2156366.html cbf to find a good resource for C++
That has nothing to do with gevent and everything to do with you probably being a significantly better programmer.
No, Haskell compilers require you to annotate your datatypes.
You might be right about this. I skimmed too quickly the first time.
What do you mean? isPrime n | n &lt; 2 = False isPrime n = all ((/= 0) . mod n) (takeWhile ((&lt;= n) . (^ 2)) primes) toPrime n | isPrime n = n | otherwise = toPrime (n + 1) primes = 2 : map (toPrime . (+ 1)) primes Has zero annotations and works exactly as expected. (Generating a stream of primes). I do a large amount of Haskell programming and can tell you type annotations are rarely required. They are however good practice as they essentially work as a very informative and compiler-verified comment. Are you talking about something else?
My school uses Python for the intro CS course and it definitely makes it way easier to get started. You get to skip learning so much with python you can focus on the concepts and techniques, then in later courses you pick up the other important things that don't really come up with python, e.g. pointers. Glad you've seen the light! Its not without negatives but its a really fantastic language. 
This is what you get with democracy. *shrug*
I had the same feeling recently. Going from years of working on backend C/Python/Java to doing some frontend work and realizing that a lot of stuff I thought was super cool and cutting edge from those web dev hipsters is actually garbage. I can understand the lack systems knowledge, but lack of respect for project maintainability, documentation, best management practices, qualification, etc is just baffling. I suspect 90% of that code will be in a dumpster in 5 years, while I use Linux tools today that were probably written before I was born and still feel well crafted.
I've been maintaining a Node app written by someone who was figuring it out as he went along. I'm so very glad that Python disallows defining a large function as a parameter. 4000 lines later, oh, there's the second param! (Not kidding or exaggerating.)
It's just a bot that does that btw. I did a "dude, really?" for about 2 seconds before realizing that.
Have you tried some of the performance stuff? (cython/pypy)
&gt; disliking requiring root My point was that C needs a *per-user* package manager that does not require root. &gt; I dunno what you mean about customising flags All but the most basic compiler flags are unportable (and still, on Windows you have to turn the hyphens into slashes.) The same flags do not work on every compiler. This week, I find myself dealing with a proprietary unix compiler that doesn't understand `-Wall`. Even on popular systems, there are differences: consider the commands needed to build a shared library on Linux vs OS X. And then you have libraries: you have to find out where that library and its associated headers are (might be in a non-standard location). In some cases the libraries might be even named slightly differently. Or maybe the version is incompatible and you should warn the user. On some systems you need a `-lm` to use math stuff, but on others you don't. And so and so forth.
Can you give me an example of something you don't think Haskell would handle (cleanly, I mean technically you can handle everything, it just might be gross and verbose) that you can do in Python. I think examples probably do exist, but can't think of a practical one at the moment.
?
There's a reason there's not a lot of development into ideas like this. If you've worked on any decent sized code base and a github repository with a few contributors, you'll know what I'm talking about. 
It's a small project. We are not that advanced. 
Oh. Ok 
Sorry I should have been more clear, I knew what union types were but I didn't understand what they had to do with python. I see what you mean now though. Thanks! 
C is simple in that it's low level, Python is simple in that it's mathematically simple. In python, using integers, a + b &gt;= max(a, b) is always true when a and b &gt; 0.
https://lodash.com/docs
Many thousand thanks... were I live it's too damn difficult finding a decent Python book :D
How many Romans?
If you separated it out on to different lines, commented it and replaced some of those x'es / self / magic numbers with sensible variable names (and refactored the object its in) it would probably look fine. I'd still prefer to see that line in my code than an imperative equivalent.
&gt; For example, to make a collection with words and numbers in Java, you'd have three options: &gt; -Import ArrayList or similar function, then define it using ArrayList&lt;String, Integer&gt; list = new ArrayList&lt;String&gt;(); and populate it with list.add("one", 1); list.add("two", 2); etc &gt; -Import ArrayList similar to above but have all entries as String so that you can use numbers or letters for keys, but would have to convert them later &gt; -Create custom function Not sure what you mean by all that. In Java you could very easily just store them in an array of Objects, or if you want a growable array, use arraylist. ArrayList&lt;Object&gt; strAndNum = new ArrayList&lt;&gt;(); strAndNum.add(1); strAndNum.add("bob"); System.out.println(strAndNum.get(0)); System.out.println(strAndNum.get(1)); &gt;&gt;&gt; 1 &gt;&gt;&gt; bob When you wanna imitate dynamic typing in a static typed language, there usually is a way. interface in go, Any in Rust, Object in Java, void* in c, cpp is adding std::any, but you could easily make your own or just use boost variant (really there is a myriad of ways you could do it each with their own pros and cons). In summary, what you were saying was easy to do in python (have a list with both numbers and strings) is a repercussion of python being dynamically typed, and lists allow any type in them. Statically typed languages can do the same thing as well, but usually its frowned on since it removes a big benefit from using a statically typed language, the benefit that I know that if I make a list of strings, the compiler will stop me from adding a number to it 
The PyPy C-Ext layer is much improved. It's beginning to feel more like FUD when I hear "PyPy breaks C extensions". Yeah, rather complex and bizarre ones break. Not all C extensions are complex or strange enough to break under PyPy. In fact, most C extensions are rather simple. It's more common though that if you're going to target PyPy support, you're going to go the extra mile and make it worth it (use CFFI, make a wrapper). Probably because enthusiasts feel they'd rather get 10x instead of 7.5x despite the difference in effort.
python is as good as imperative gets. i can fully understand why more functional languages either use ML-like syntax (Haskell) or braces (Rust). a multiline indentation-based lambda passed to a function can only end bad.
Your *datatypes*, aka. what you use `data` for.
this is reddit, don't get surprised
Maybe I missed it on mobile, but is Fluent Python on here? I think it's an excellent intermediate/advanced resource. 
Not yet. Still, pypy won't be as fast as a compiled language, probably. I use Rust mainly because it prevents a lot of stupid mistakes, even ones that would go unnoticed until they broke something in Python.
I suspect you can do the necessary stuff via a simple script that can be built with kivy-ios even without kivy being present or used. I'm not sure though - it would be fine on Android but I don't know if iOS locks these things down more.
And that's why you don't want def _, the shitty if..else expression, the decorator hack, and a lot of things Guido has been adding. with is another of such hacks by the way. He's special casing as opposed to making the language flexible enough not to need more bloat.
Not in South Carolina :\ C#/.NET is the name of the game here. plus i don't have a CS degree + experience working in 'software development teams'. So that's a big barrier to landing the few that are out there; "Python" tends to be part of a longer list of languages they want for a "Senior Software Engineer", as opposed to a role that relies primarily on python.
 [f(x) for x in y if filter(x)] No need for lambdas
This is really interesting, gonna bookmark his blog. Now I have two interesting blogs to read, this and jesterscourt.cc 
&gt; basically, Python What Cython needs, in order for the transpilation to C to work, is a superset of a subset of Python. Details matter.
Looks good! I'll definitely be coming back for specific topics, because it seems like you have plenty of those.
Elixir wants to shine in all areas it seems. Enough guys! It seems similar to SQLAlchemy in the Python world.
I was surprised to see that it's not there. That book took me to a whole different level. 
Hey, just an unsolicited feedback since it seems like you're running a pretty interesting curation thing. As far as listing goes, I don't think bigger number is better. A well-curated list is where the value lies. In fact, I would say when the list has &gt; 50 books, its pretty much worthless. When you have that big of a list, it just seemed like you're throwing every material with the word "python" in it to the list. I could easily get better result by typing "python" into the amazon search bar. 
In the same way that Java is interpreted. They both compile to an intermediate bytecode form that isn't any form of native code, but is easier to run.
Many of us do use other languages constantly, but I'd say that a language-specific sub is the wrong place to prostelesize your language even if it could be a better choice for a problem at hand. Think about it. A lot of numerics code written in Python could easily be done in C++ or C# with better performance characterisics---even if we use numpy. Yet if someone comes with the question of how to do X numerics job in Python, we give the best adivce on how to do it in Python because we presume (a) they want to stay within the language they know / don't want to split their codebase or (b) have other things written in Python that need interop with this code. The same is pretty much true in other subs. For instance in /r/Javascript there's a question about how to make Express HTTP/2 compliant so it 'has a future on the modern web'. To me, the answer is simple: a javascript webserver should alwasy be behind NGinx/Apache so it being HTTP/2 compliant is as useful as Gunicorn/Django Runserver being HTTP2 compliant.
I *have* Thou hast He hath
I'm not complaining about it, but I must point out it's a bot, written by someone human and not kicked and forbidden by any human Op there. Python takes legibility pretty darned seriously.
The idea came up my mind 2 days ago.Then, I immediately created this project so I know it needs more general purpose snippets.Next days, we'll add more snippets.
You can start a new pull request for fluent python. thx cc yes_or_gnome
Python Cookbook? Look `Grammar` -&gt; `References`
Also look at doing the plots first in an IPython jupyter notebook with in line plots. Just edit the plot cell to your hearts content. 
My mistake, didn't see it there. Incidentally, there's an earlier edition of the Python Cookbook which covers Python 2.x Edit: generalise version
&gt; why? **I had some spare time** and made a minimalist 1KB CMS [OC] Didn't know strapdownjs.. very cool
ok I'll be more explicit: why did you post your shitty waste of time code to this subreddit.
I like your lovely personality. 
A dictionary.
Actually, universities are very much jumping on the Python bandwagon. I teach Python in my CS1 course, because I really don't care about languages; I care about algorithms and problem solving. I want students to have some early success to go along with the constant failure that comes with programming. Python is overtaking Java as the most popular language for beginning CS courses. (Java is awesome, but you can't teach it without asking people to ignore some ugly details for a while. public static void main(String[] args), I'm talking to you.) If Python is the ONLY language you learn, you're missing out, because it does a little too much for you. After you learn how programming works with Python, you should definitely learn a lower language like C, a stricter object-oriented language like Java, and maybe a functional language like Haskel. But those can wait. 
&gt; news about the dynamic, interpreted, interactive, object-oriented, extensible programming language Python do you think your turd is newsworthy?
I mean that is because it is mathematically impossible to do with ambiguity. But that is ok because sub typing is bad.
That's because you aren't really using the latest version (GHC head). If you were then you would have that extension.
OMG! OMG you're right! How could I be so blind? Thank you, sir, you made me open my eyes! I'm so sorry..
Why not just use a screensharing technology like https://www.mikogo.com/ or https://www.teamviewer.com/
@kihino Thanks. I will look into it and fix it. 
Clearly not a very successful one based on the amount of time you spend bullying undergraduate students on the Internet instead of contributing to your field by, you know, actually teaching someone some science 
http://4.bp.blogspot.com/-d3lsRTT_vv4/U12ESuXZZlI/AAAAAAAABVA/v9CDI3hoWMQ/s1600/iyam.gif
looks like bpython: http://www.bpython-interpreter.org/
Python Machine Learning by Raschka is hands down the best Python book I've read to date, just came out last year. Fluent Python is very good too. 
Absolutely. You can do anything as you do with «classic» functions (change labels, add data, connecting signals/slots, …). Though you can't connect qt event and coroutine. add: You can fire task by signal with loop.create_task or «unfreeze» some future. Also queues are great.
I'm not familiar with Node really, but after skimming through the article it seems like he's just using it because there is already an API implemented in this particular library. Why do you say it's unnecessary? Is the only alternative not to re implement that library in python?
Hey! that's not nice! you shouldnt swear! (This is a test)
Cool, thanks a lot! :)
I mean your original comment criticized python saying you have to replace it with another language if you want speed. When in reality the programmer is still typing python, which is what matters, so your comment was a bit disingenuous. Most languages have at least one implementation of compiler/interpreter which compiles/translates down to another language. You could criticize most languages with that line of reasoning.
That's true, but my experience has been that it's still much harder for beginners to understand than python.
Yes.
It's a very intentional optimization for single threaded applications. Python may not be optimized for what you want it to be, but yes, it is an optimization.
It is clear. It is python plus additional functions. You can say that is not python, but I believe it still is.
See for yourself: https://docs.python.org/3/whatsnew/3.5.html 
You may be able to define the rolling interval to be based on the right endpoint (later in time) instead of the left endpoint so the six month gap shifts to the beginning of the series instead of the end. 
Those *are* type annotations; they're just generic ones. If `Car` was such that `mode` was a specific enumeration, `b` could not then be generic.
No they aren't. There just isn't syntactic sugar that makes them implicit (yet) (I don't think). You could have cars that use that enumeration (and another not if you wanted) and still not have any type annotations. Such as data Models = Tesla | Ferrari car = Car Tesla "Model S"
Well that's clearly not true because the universe doesn't not exist. A quite simple solution to the conundrum is that Crystal sometimes asks for type annotations.
&gt; I never knew I needed Syntax Highlighting in the code examples in a book until I read this book. How is this one different in that regard?
Thanks for sharing your hard work. 
That's not the same thing. In other languages it's common to write classes such that their instance variable's types are part of the class contract. Yours make it part of the method's contracts.
Oh, I forgot to mention: sum types aren't just explicit union types. Sum types are such that an `X` subtypes an `X | Y` and static ones are amiable to a kind of "type algebra". A cool example of this is in Ceylon where the type of an empty iterable is `Iterable&lt;Value, Absent&gt;` where `Absent == Null` if the iterable can be empty and `Absent == Nothing` (the bottom type) if it cannot. This allows Ceylon to reason about whether iterables are known empty, maybe empty or known nonempty. Subtyping "just works" on this, in that a known empty iterable is a maybe empty iterable and a known nonempty iterable is a maybe empty iterable but a known empty iterable is most certainly not a known nonempty iterable. This allows you to decide some nice return types, like with `reduce`; knownEmpty.reduce(...) // Nil maybeEmpty.reduce(...) // T | Nil knownNonEmpty.reduce(...) // T and of course, if it arises through generics, knownEmptyAndKnownNonEmpty.reduce(...) // Nothing 
Congratulations are in order, then. You know better than the Cython developers.
Better than questions.
So your original point of Crystal's type system being powerful enough is basically false. As both Haskell and Crystal SOMETIMES need type annotations, and both can get away with not having them quite frequently.
&gt; Python is overtaking Java as the most popular language for beginning CS courses. (Java is awesome, but you can't teach it without asking people to ignore some ugly details for a while. public static void main(String[] args), I'm talking to you.) Yeah I know what you mean about Java; I waste SO MUCH TIME just setting up the damn thing even if it's something small. That's interesting though, what you said about it overtaking Java as the most popular beginner CS language. Honestly, the biggest problem Python has is it's lack of popularity; sometimes it can be incredibly difficult to find proper documentation whereas if you're searching for a solution to a Java issue, there's a sea of info out there. For example, I wanted to test a SQL package in Python. I eventually decided on MySQLdb, which, for whatever reason actually had a filename of pymysql. As a result, I spent AGES trying to find a download despite it supposedly being the most popular MySQL package. Even when I found it, my IDE for whatever reason couldn't auto install, so I had to stumble about manually installing for quite some time. However, once I got it installed, it worked beautifully and I can't wait to mess with it some more later today. I've been really looking for an elegant method of giving a program netcode functionality especially SQL and Python has been much easier and simpler to use for that. 
I was assuming my method was probably inefficient, though it still stands that Python's implementation of that is a lot quicker; especially for printing to console. While there are IDEs that support shortcuts for typing out a println in Java, it's not only easier but more readable in Python. I don't hate Java; there's a reason why it's my primary language. However, Python is built to be easy to type and understand whereas a lot of the "shortcuts" in Java aren't emphasized for various reasons. Java's also quite a bit more universal than Python as a result of those commands. While only time will tell if Python will actually become my favored language, I haven't had this good of an experience with a programming language since...C, and that was mostly because I already knew C++ lol. 
Oh, don't worry, I understand Python isn't suitable for everything; for example Java dominates mobile whereas Python is unsuited for, if not completely inadequate for mobile. The documentation tends to be a lot worse as well, which makes me very sad. I wouldn't say C is that simple though; it's better than Java (imo) but it still has some odd redundancies and weird references. Also, it's worth mentioning that many universities have implemented Python in their programs around the world. I'm sure the reasoning differs from place to place, but I always hear businesses looking for people who know Python, since it is undeniably the best programming language for making quick, situational based solutions for problems. In the time it takes to set up a small program in Java, I can complete it in Python despite literally learning Python just days ago, and knowing Java for a good 5 years. 
Yeah, I feel that it's much stronger than it looks for teaching programming language. Not only are classes AND module declarations optional but some sections of it are pretty much 1:1 mirrors of pseudocode because of the degree that redundancy is stripped from it. 
I get what you're saying; generally Java is the most adaptable even if it's not as intuitive as Python is. However, I feel the best benefit of Python is that the removal of redundant functions and making stuff such as classes and modules optional rather than required allows Python to be taught almost as pseudo-code rather than having to focus on the different intricacies or formats specific to that programming language. I do think that teaching Python first might spoil people though; I'm glad I know Java so well, but I'm not sure if I would have learned as much as I did if I had the option to use Python instead for messing around.
Oh... well then yeah sure... but why even suggest Crystal if it shares the issues that Haskell has. And I am honestly still not convinced there exists a concrete Python example that Haskell cannot replicate without type annotations. I would love an example.
Git in Dropbox is fine. I'm writing my honours thesis with this combo! 
Well that's the same kind of problem right? Questions should go to /r/learnpython and posts about how Python is so great we should all make each other feel good about using it should go to /r/pythoncirclejerk
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
That example's not subtyping, though. `subtype.bar` isn't the same as `supertype(subtype).bar`. (Of course that example is easily done with typeclasses, but true subtyping involves mixing types and type preservation.)
Ack, it seems I'd forgotten what I was arguing down the bottom of this thread. So remember I'm talking about class Foo: def spam(self): ... # could be anything def bar(self): return self.spam() and you want to generate typeclass instance instance HasBar Foo.spam Foo where bar = spam The problem is that Haskell doesn't support that. You want to do some kind of global type inference, which I claim is challenging. Your argument that this can already be done for structs, like data Foo a = Foo { bar :: a } doesn't help here as no type is inferred for `Foo`, only local instantiations of it. Only if `Foo`'s attribute types could be inferred globally would it evidence the ability for this kind of global inference. The problem is that the equivalent parameterized typeclass would look like instance HasBar (forall a. a) Foo where bar = spam which is obviously wrong.
Lists like this really bother me. I have time to read a handful of programming books a year, and I like to ensure the ones I pick are the best ones available. This list is merely a compilation of all the python books the author could find on google sorted by category… He hasn't read them all and likely knows nothing about most of them and thus is hardly an authority to comment on their awesomeness. I'm sorry if this sounds cynical, but in my opinion posts like this are at best of little value and at worst misleading. 
But that kind of subtyping isn't type safe... (Or at least not in the general case) such as Cow -&gt; Animal -&gt; Dog.
That's why they're checked. For instance instructions = (i for i in instructions if not isinstance(i, Padding)) from one of my other posts.
Here are two that I use frequently. def main(): ${1:pass} if __name__ == '__main__': main() ---- print('$1 = {}'.format($1))
 instance HasBar Foo.spam Foo where bar = spam You actually can do that, just not in that specific way. First you find the type of `spam` (doable as Haskell can derive the type of any function), then you do: instance HasBar Bool Foo where bar = spam (Assuming spam is a Bool) This can lead to ambiguity issues when only using `MultiParamTypeClasses` as you can't guarantee you don't ALSO have. instance HasBar Int Foo where bar = spam2 BUT, there are ways around this. To avoid re-explaining everything I will link you to the stackoverflow post I made to actually find out myself how to get around the ambiguity issues: http://stackoverflow.com/questions/36736976/how-to-make-this-example-of-pseudo-ducktyping-type-unambiguously-without-annotat?noredirect=1#comment61057519_36736976 Which works unambiguously and actually quite nicely.
Doesn't that prevent type erasure? Also that seems like evidence of poor design rather than an elegant way to solve a problem. I have never needed a heterogenous, arbitrary length / ordering, collection of objects.
I haven't had need for it myself, so I actually don't know 100%, it just sounded like it was available from that one link. Maybe [this]( https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields) will give more information?
Related: [How to get along with ASP](https://blog.scraperwiki.com/2011/11/how-to-get-along-with-an-asp-webpage/) (with mechanize).
That makes sense. One thing I did realize though is that in some cases it may lead to some fairly complex Haskell code, even if it is always doable, due to the lack of native support for union types. Like if a Python method accepted either an integer pk or the object that pk represents, you would have to have a union-like type representing one or the other. Now you could do this with `Either`, which shouldn't be too terrible. You could then also make a version of `Either` for more than two options / types. But overall this would probably be very much non-trivial.
&gt; [map_fn(val) for val in values if filter_fn(map_fn(val))] You code does calculate it twice. This does it once &gt; [x for x in (map_fn(val) for val in values) if filter_fn(x)] If might look like 2 nested for loops... but its 2 loops in series, and using generators, we avoid the space overhead from the result of the inner loop. 
Yeah. I mean students struggle with a function that takes a value, or value-returning functions at first, but quickly get the hang of them. Now we're doing OOP and classes and that's been a challenge. Half the class gets it, the other half is lost and just copies code :(
&gt; Doesn't that prevent type erasure? Well yes, but Python without reflection doesn't really make sense. &gt; I have never needed a heterogenous, arbitrary length / ordering, collection of objects. You've never had a `[SomeADT]` before? 'Cause in statically typed languages with union types that's basically what I gave, except that you don't have to reshuffle your ADT into a tree structure (and hope that you never want overlapping subtrees). In Python I'd never actually do this because `isinstance` is antithesis to duck typing and thus very unPythonic, but I would do the similar thing instructions = (i for i in instructions if i.serializable()) where `i.serializable()` implies the `isinstance` check. It's entirely fair to say you'd write it a different way, but that's a totally fair byproduct of thinking in a language. I've never felt the need for a typeclass in Python yet I really appreciate them in Rust, just as I've never felt the need for first class types in Rust yet I really appreciate then in Python.
functools.partial does work with keyword arguments... &gt;functools.partial(func, *args, **keywords) &gt;Return a new partial object which when called will behave like func called with the positional arguments args and keyword arguments keywords. If more arguments are supplied to the call, they are appended to args. **If additional keyword arguments are supplied, they extend and override keywords.** (emphasis mine) That compose is a work of art though. I can use that at work tomorrow for teeing a mapping and passing into a filter/filterfalse pair, because it was really ugly as it was. p.s. keep being a bro with your work on df
 **Python Machine Learning** |||| --:|:--|:-- Current|$40.49|Amazon (New) High|$44.99|Amazon (New) Low|$39.62|Amazon (New) |Average|$41.39|30 Day [Price History Chart and Sales Rank](http://i.imgur.com/KPZoOVk.png) | [FAQ](http://www.reddit.com/r/PriceZombie/wiki/index) 
Very interesting! Thanks. Have an upvote. :)
This sub gets over 20 submissions a day and is one of the more active programming-language specific subreddits. I'm not seeing this deprivation of which you speak.
One of the reasons I switched from using Scrapy/Mechanize for most things to Selenium for most things is how you have to bend over backwards like this to accommodate AJAX and site-by-site exceptions. imo, the engineering hours required here are enormous in comparison to having PhantomJS click and type things into a page simulating a graphical web browser. Of course, that comes with the tradeoff of a significantly larger resource overhead. Author did a great job, though, and now the world has library code to copypaste!
 :D 
Look nice. Thx :D
It seems some dude didn't appreciate the time you took to make this so ill just say this is pretty cool. I was messing around with Flask a week ago doing something similar to list directory structure and make a simple FTP browser client. I never thought about making a simple CMS using a markup engine and this together. Ive forked your repo and going to extend it to make it a fully fledge micro CMS and keep to the minimal nature.
Hi, so maybe you or the OP could help me with a question - what are you doing with your API. I had a similar project I used Django for - and I've since been slowly working on a framework for APIs and was wondering what you did/ the need for building one in Django. Did it fit what you wanted, or was it just the best available?
Who are we fooling? Most of these submissions are questions. This sub is glorified Python tech support. 
The python cookbook has syntax highlighting. Most others don't. 
https://github.com/karan/Projects
Falcon api framework, Google it.
Seems really cool, any reason you personally like Falcon?
/r/learnpython /r/learnprogramming [recursion](https://www.google.com/search?q=recursion)
Black Hat Python brought me many epiphanies about network programming in general. It was my first real introduction to scapy. I highly recommend it for intermediate level programmers. 
Find the correct sub
Recursion! You need to loop through each level of the list and see the length of each. Here is a quick example to show you. I created a recursion function that is called at each level and if it doesn't find a string, if performs the function on itself until it finds a string. list = ['apple', ['banana', ['cherry', ['damson']]]] upper_output = [] def recursion(obj): if type(obj) is str: upper_output.append(obj.upper()) else: for x in range(0,len(obj)): recursion(obj[x]) for i in range(0,len(list)): recursion(list[i]) &gt;&gt;&gt; upper_output ['APPLE', 'BANANA', 'CHERRY', 'DAMSON'] 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Tornado is an excellent choice if you don't need your hand held as much as Django/Flask will.
After learning Python a few years ago, I rarely look back except for occasional WordPress sites. If you can find a host that supports Python (some do it through Passenger or other WSGI servers), go for it. If it's a viable option, Heroku supports it. Each dyno can support many threads and connections, so you could probably get away with a low traffic site for free. Flask is relatively easy to use. A good boilerplate will help you starting out so you can get the feel of a Flask application. Good luck!! 
For my personal projects I use PHP and have used Laravel 5, Lumen, and a frameworkless collection of packages that amount to a PSR-7 based backend but at work I use Python with Flask. Based on that, here's my thoughts: In terms of language, I prefer PHP to Python. I find it easier to work with and its documentation to be better. I don't buy the arguments made in "PHP is a fractal of bad design" because many are either corrected in later versions or are minor (needle and haystack parameter order in string vs. array functions, for example). This may be a function of me having more experience with the language and having not worked professionally with it since 2008, but I would choose PHP over Python if the language was all that mattered. In terms of frameworks, Flask is better documented than Laravel/Lumen and is easier to work with. In terms of backend style, I find the functional philosophy behind PSR-7 to be easier to reason over than how our Flask app is structured. That said, Python and Flask aren't bad by any stretch. Both are easy to work with, I just prefer PHP and PSR-7. One of the reasons I'm on this sub is to learn more about Python to learn about the corners I haven't explored that make Python Python. Maybe those will sway me. You may wish to use Python because some important library is on PyPi or your code base is otherwise entrenched in Python and so the cost of maintaining code in another language isn't worth it. For hosting, it seems like most places that support PHP also support Python. Finding hosting shouldn't be too bad: Heroku and Dreamhost, are two examples that I've worked with.
Loop like a native is how I started. Generators make python so readable. Well, that and the whitespace.
I really struck a nerve with some people on that suggestion. For a bunch of people that appreciate what makes Python great, they sure are afraid of using it to parse data. 
Also +1 for this book. It also becomes great reference material after you're done with it. A lot of the code can be used as a foundation to build some good tooling off of. Oh! I also recommend picking up some windows stack exploitation and fuzzing books to pair with it. It makes a big difference when tinkering with windows exploit development. 
I can't help you with the Kivy aspect of this, I'm afraid, but I can probably point you in the right direction for some of the other aspects of it, if you haven't got there already. In order to calculate the positions of things like the Moon you'll need something lie pyephem, which calculates the position of planets in their orbits, and then performs the mathematical transformation to a sky position. In order to represent this data on a map you'll need to think about cartographic transformations, which allow you to draw the surface of a sphere on a flat surface, like a screen. I can probably give you more information about this stuff if its helpful: I wrote a program to do almost exactly this a while back for the control system of a radio telescope, so its definitely workable (and in only a few dozen lines of code).
Well-written Python doesn't leave a ton of room for personalization. With people who know the language well, and have been using it for a while, I'm sure it's possible to distinguish authors by little stylistic quirks, but I think this is an expected result of having people program in Python. If you need a way to ensure everyone's doing their own work, pick problems where there's more than one obvious algorithm or design pattern for something, to increase the chance different students will choose different approaches.
Don't feed the troll, dude. Your micro cms is cute and great presentation of what "minimalist" means. If you will stay at this project and develop it further I will always be glad to take it for a spin. Just add some documentation aimed at the common user and I'm a fan. Stay positive.
/r/learnpython
Python lets you architect applications and build websites. PHP lets you build websites.
mostly bandwagon jumping
honestly, if you have to ask, it doesn't matter.
&gt;I'm more fond of a solution that has a larger community since its easier to get help. Django then.
Thank you! That is a good idea and, actually, I started myself doing something like that (a sort of ssams+), very slowly though, cause I don't have that much time right now. It would be interesting to discuss the topic. Maybe pm me
Attacking your knowledge? Please, I was being sarcastic but it's not my fault you took offense. Get over yourself, you aren't that important. *edit: I was implying there are a bunch of posts on web scraping all the time, and you made it about you. Slow your roll, champ. 
Forced alignment is a speech recognition technique where the system is fed both the audio file and a transcript files, so the system only has to locate the location of words and phones--and not also determine what words were said. Several such tools exist for python. Two of these depend on the HTK speech recognition tool: University of Pennsylvania - **P2FA** (dead link last I checked) * http://www.ling.upenn.edu/phonetics/p2fa/ **Forked version of P2FA** * https://github.com/ucbvislab/p2fa-vislab University of McGill **Prosodylab-Aligner** * https://github.com/prosodylab/Prosodylab-Aligner This next one uses the Julius speech recognition system. It also includes a GUI frontend. Laboratoire Parole et Langage - **SPPAS** (Disclaimer, this is made where I work, but I am not affiliated with this project) * http://www.sppas.org/index.html
This doesn't address your concern about hitboxes but you should really look into classes when approaching a larger project like making a game. I see a lot of variables with the same name in functions and outside them. Also, preferably refrain from using 'global', it's usually an indication of something that should be done differently. In this case I would say structuring your code into classes will fix that. *About hitboxes, the general reasoning is 'when an object A is within an area defined by the hitbox of B, do something'. Your code structure should reduce this part to a conditional statement checking whether A's coordinates overlap with the hitbox of B.
Yes, Python is meant to be consistent and obvious.
DRF has a few opinions about how your API should be set up. I think they're all very sensible, though you can sidestep them if you want. In my opinion the design opinions are as useful as the project itself. +1 to DRF from me.
I'm not /u/njharman, but we actually use it in production. Main reason is speed, lightweightiness, and good quality source code (when something screws up you don't want to look at dragons). If you like the DIY approach then Falcon is surely worth checking. 
/r/learnpython
Honestly, at the time of this post, this thread has been very tame. This sub has been pretty friendly and so far it seems well reflected here.
Moreover, ImportD is a lightweight Django: http://importd.readthedocs.org/en/latest/ to consider in the war Flask VS Django. ImportD can be as minimalistic as Flask, but can be extended to pure Django.
paging /u/fijal: the download links for ppc64 and ppc64le contain some extraneous `+` characters.
Does anyone use PyPy in production? I've tried a number of times and had to revert to CPython due to memory leaks or segfaults.
What is this and why would I use it instead of regular Python?
hehe, little frustrated boy
Scraping is `cat' for websites. At least for the average Joe programmer that I am. cat http://somewebsite/foobar/* | grep baz | uniq Once you know handy tools to do it, the web is just another source for data. Some examples: I wrote 2 scrappers recently, First one scrapped HackerNews "who's hiring" posts to give me trends on techs and help me search offers with certain combinations of keywords. That's how I found my current backend eng. position at ScrapingHub. Second one scrapped some old-school mailing list webpages to help me search very precise combinations of keywords (again) to solve issues on a specific tech. I analyzed these websites just as I'd analyze a bunch of log files.
When I wrote my reply your post was at -7 and it wasn't the first one I've seen downvoted into oblivion. But I guess there are people with a more balanced opinion around, which is cool. :)
Yes, and I'm very happy with it. But I've only run it for 1 hour at a time, so perhaps the leaks hadn't enough time to accumulate.
I've been running it for about a year now continuously 24x7 on multiple large servers for transforming sensor data. The speed we get from it has saved us quite a lot of money by cutting down the amount of hardware we need by about 60%. 
Due to how tracing JITs work you'll see memory growth over time as more and more loops become hot, are traced and compiled to machine code. At some point this will plateau but depending on the number of different code paths this can take quite some time. This can also require quite a bit of memory and in some cases look like a memory leak. 
Cool thanks. If it runs on raspberry pi it may speech up some speech recognition I'm doing..
About the only platform it doesn't support is powerpc
Have you read this? http://www.alandmoore.com/blog/2013/02/02/from-php-to-python-things-i-wish-id-known/
I know Python for 12 years now, and R only for maybe 3-4. I am comparing Python+multiprocessing+scipy+numpy+pandas+matplotlib vs. R+parallel+caret+dplyr+magrittr+ggplot+other modern packages in the tasks I usually do (machine learning in a somewhat classical data analyst/statistician position). The following is my personal opinion: R is much much better for standard statistical methods, its data transformation facilities are a better fit for ML, the implementations of classical algorithms like trees or SVM are more complete. The workflow feels much more natural. The ggplot API for plots is just wonderful (and no, Python's attempt at reimplementing it is only in early stages and not really fit for duty yet). Parallel processing is also easier to use, at least on Linux. Also, certain language features help a lot in making nice APIs, which are difficult to do in Python: lazy evaluation, access to parse trees, custom operators… Python is better in integrating with the world: more libraries for contacting databases, easier parsing of weird file formats, etc. It also has deep learning libraries, something R is almost completely missing (I actually use Python in ML mostly because of [keras](http://keras.io/)).
sexist shitlord
That's good data point.
Actually Python has some of the best built-in SQL support. Practically all versions of python come with sqlite support built - in: http://cs.iupui.edu/~aharris/230/python/data/SQLiteDemo3.py sqlite is not quite as sophisticated as mySQL, but it is more than enough for most purposes, and it's just easy to work with. I'm a huge fan of pythonAnywhere, because they have practically every non-graphical library you can think of already installed in the free version and you can work from anywhere. You can also host one web app for free, which is a really great deal, and all the major frameworks are supported with one-click install. I love that.... Although there is a ton of Java support out there, the language is 20 years old, and so is (some of) the documentation. I have hundreds of applet files sitting out there that nobody uses now because Applets are irrelevant today, for example. Finding good documentation that's up-to-date and relevant is difficult for any programming language. 
it's literally flask for dummies 101: listing a fucking directory.
Why do you need casting? I personally love the freedom that no casting gives me. I can have my functions take and return whatever I want and have my code adapt to it on the fly. Think about it the other way, why would you cast it?
so its not python being good or bad using naming instead java is bad because using vars over naming? but why did they do that there have to be pros and cons using each over the other
In my opinion, casting is a crutch. It helps you debug some things sometimes, but if you don't mess up, why would you need it? Shouldn't be too hard to see that you need an int instead of a string.
I've used PyPy for a bunch of home stuff and never once seen a SEGV. Did you try isolating and reporting a minimal test case? They're very prompt at fixing pretty much any bugs
This was older versions to be fair. Last time I tried was mid 2015. I tried it just now on a personal project. I had an install of 5.0.1 on my Mac. I'm rendering a page in a web app, and render time went from around 45ms to ~40ms. That was after a few thousand requests. I have seen PyPy speed up code by many orders of magnitude, but for some reason my code is confounding it. Is there anything that PyPy doesn't optimize so well? The page I tested was almost entirely cpu bound.
&gt; Flask documentation doesn't seem to be straightforward (at least for a me) I don't think it is about Flask per se. It is about changing the approach. Don't think about website as a bunch of pages with some code embedded in the html. With pretty much every other language except php you build a web application and register it with some sort of an application server. And get the Miguel Gringberg's [Book](http://flaskbook.com/). It complements perfectly the Flask docs. &gt; and i know i still have to learn a templating engine (jinja). Even if you stick with php, sooner or later you will have to learn some templating engine like Smarty or Twig. And Twig is actually inspired by Jinja/Django templates, so it is more or less the same thing as Jinja. &gt; I'm also thinking about the hosting services available in my country as it seems most of them is dedicated for php. Hosting company does not have to be in your country, often you can get better deals elsewhere. Just find a provider that lets you to install your programs and allows long running processes. There are plenty of VPS offers on the market. And finally, there are valid reasons to use php, and there are valid reasons to use python. Just do what you enjoy doing :)
What are you looking for? More announcements that someone has made X in Python?
Both Java and Python use variables the difference is that Python is classed as 'dynamically typed' which means you don't have to declare the type (string, int etc) when you write the code. Java is 'statically typed' as you declare the type of your variables upfront for the compiler to validate. In Python this validation is done at runtime. Do a "type(i)" to see what type your variable is at runtime. 
are you trying to implement a jpeg encoder or trying to shrink existing jpeg files smaller? 
&gt; First you find the type of `spam` You can't just *first* find the type of `spam` because the type of `spam` might depend on the type of `bar`. The whole problem with global type inference is that there are loops in it.
I explored Falcon while we were determining how to port some of our APIs, and I have mixed feelings. It is very fast, and there's power in its simplicity -- however, it was a little "too" raw for my taste, and took some pretty bold liberties with how the code should be structured. I would recommend it if you're starting from scratch.
Meaningless if I can't use all the usual scientific python libraries (numpy etc) on top of it? 
I mean I guess. I just think heterogeneous lists of varying length and ordering are unnecessary. I mean the closest I get to that is something like a list with one type but multiple constructors for that type.
Use: class ExpectedFailureTestCase(unittest.TestCase): @unittest.expectedFailure def test_fail(self): self.assertEqual(1, 0, "broken") 
or else you're using numpy wrong, which I see a fair bit of.
Oh. I see. Yeah, that's kind of weird.
which would be in the C side of things (no amount of speeding-up-python is going to help incorrect numpy usage), hence, the code isn't python-bound
I don't think you read the question. I was curious how to selectively add test methods to a suite based on a test method parameter.
&gt; pathological Eh?
But why does Java want's to have their variables static, they could aswell just validate them runtime so noone would need to use casting and other methods to change their variable types, in Python you can just change around the types the names are referencing to, why doesn't Java do that then? What are the benefits of forcing the programmer to set the type instead of letting the compiler chose the right type?
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Type safety? It also just doesn't really work with type classes, as it is impossible to know every possible concrete instance of a typeclass, as more can be added arbitrarily anywhere in the code base and suddenly your instanceof type stuff isn't exhaustive.
The Rust I showed and Crystal I mentioned are entirely type safe. Python code isn't statically type-safe by design.
What are you taking about? You do realize Haskell's type system can decisively type anything that can have a type? Like I really don't get your point, you can't come up with any example of something Haskell cannot type. Because it CAN (like 100% definitively) type your example.
Haskell now does not infer types for typeclass instances. It just doesn't.
But it cannot possible work with Typeclasses, as they are arbitrarily extendable. So you have to limit yourself to concrete unions of a limited number of types.
This is more akin to an ADT than a typeclass, yes, but you're not entirely right. When, for instance, I have the type `list[Padding | Add | Mul | ...]` you might be able to treat it as `list[Padding | Instruction]` where `Instruction` is a typeclass. That gives half of the arbitrary extension aspect, and that's as much as I'd normally want. If I use the Python-style filtering, `i.is_serializable`, I only need to make sure any new `Padding`-style type is not serializable and any new `Instruction`-style type is serializable to add extensibility to `Padding` too. In a Crystal-like language, if I want `Padding` to be extensible too I can use inheritance. Alternatively I can use a more complex `is_instance` check, although that route is less nice. Heck, if this was ever a major problem you could always introduce constant methods and do the Python version in Crystal.
I really don't get what you mean. Open up ghci, type in: `:t (\x -&gt; x + x)` and tell me what you get.
Well if you use typeclasses then you can never get back the concrete value again, hence why you probably want a finite union of concrete types, as its type information was erased leaving only the typeclass. Which I guess works? Because you can't use `isinstance` exhaustively as there can be an infinite number of instances of a typeclasses added at any point in the program.
Oh, you mean like this? Prelude&gt; :set -XMonomorphismRestriction Prelude&gt; let plus = (+) Prelude&gt; :t plus plus :: Integer -&gt; Integer -&gt; Integer But seriously, no, that's not what I'm talking about. I'm saying Haskell doesn't infer types for typeclass `instance`s: instance Typeclass _ _ where ... which is what you're requiring.
You can't just enable a shitty god damn extension to make a point, `MonomorphismRestriction` should not be used. That is what you are talking about? Well I mean yeah, inferring typeclasses doesn't really make sense. The stuff I am talking about is about the generation of necessary typeclasses, not about just magically inferring instances.
With JPEG, the biggest thing is the quantization tables. To make a smaller image, you usually just need a lower quality Quantization table than was used in the original image. If you can be slow, something to try out multiple variations on the table will be helpful in minimizing size for the best quality.
&gt; But why does Java want's to have their variables static &gt; "why did they do that there have to be pros and cons using each over the other" I see that you have asked the above 2 questions without getting an answer. Here is my view on this matter... Python does dynamic typing because of convenience. There is great ease of use associated with dynamic typing of variables. However, this greatness is only without side effects while the programs are small. As soon as one gets to large complicated programs (1000s of source files and interfaces being used in 100s of places), we start seeing the cracks. Here is one hypothetical scenario where dynamic typing leads to problems... If you change the interface of a method... ( add / remove required arguments, or change argument types, or change return type), you have to make the corresponding change in all the places where that method is used. In Python, the task of finding out where that method is used is not trivial. There is the problem of methods in different classes with the same name. Sometimes, methods can be accessed dynamically - object.getattr(var1, lambda *a, **kw: None) (*args). (we have code like this in our codebase). Such code will most probably lead to runtime errors in the program (it has for us), unless you have tests that cover such scenarios. The way to avoid such errors in large programs is to have near 100% test coverage - not just code, but use case coverage as well. Java will catch such places at compile time... It is often stated that statically typed languages need less test code coverage for the same amount of developer confidence, as compared to dynamic languages. Having said that... Python is unbeatable for writing small independent programs - and I usually have to write many more small programs than big ones.
In the case of `chain`, the advantage is that it works with arbitrary _iterables_ and returns an _iterator_. For lists, you can just add them together, but then you've created a new list in memory, and if you are dealing with big amounts of data, that might be a bad idea. `chain` returns an iterator over all of those lists which will take up a constant (I think) amount of memory. If you deal with some arbitrary iterable that isn't a list (for example a generator), you wouldn't even be able to add them using `+` anyway. `repeat` is sometimes useful as a component of a more complicated iterable. The [docs](https://docs.python.org/3/library/itertools.html#itertools.repeat) give this example (which isn't too useful, but maybe gives you a sense of what you can do with it) &gt;&gt;&gt; list(map(pow, range(10), repeat(2))) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
If it's simple assignments, I'd expect everybody's version of "use a for loop to print the numbers 1 though 100" to be pretty much identical with a few variations. If possible, make assignments more interesting and complex, and people will have to come up with more interesting solutions. You can potentially give assignments that demand some marginal creativity like "Imagine you are running your dream business. Imagine ten products that you sell, and write a python script that tracks your inventory in a text file with $(assignment parameters)." Then if everybody runs a bakery with the same selection of cupcakes, you know it's not right. Or of there is a car parts shop that sells "grandma maisie's lemon cupcake" for a 1994 Toyota it was probably a rushed retooling of somebody else's code that missed a spot. You can still do automated verification of the output if it is well specified, even if everybody's answer is different. (Do the right fields exist? Does the price field have a dollar sign? Is the inventory count an integer? Is the name text? If you buy the first product, does the count go down?)
wow that looks great. I'll look into this especially as my dropbox storage becomes a problem. 
Yea I was going to do this as well with my thesis, but I really REALLY don't want a corrupted repo from some syncing issue with dropbox. Some folks on SO think that this is a problem, but I'm guessing many more do it without a problem and without checking to see what might happen. 
I mean but everyone immediately turns it off as soon as it actually does anything.
I'm in a similar position, rather gone off PHP and I'm looking at Web2py. There's only one thing that puts me off it, it's only Python 2.7, but otherwise, I'm really really impressed with the documentation; there's a free pdf e-book for it. Being developed by a Comp. Sci Professor does it no harm at all, quite the opposite.
I hate the type classes that they have. It makes the code unreadable 
What do you mean by it working out of the box?
Trying to read this gave me a headache
I see that you guys always test Django in your performance benchmarks, so I assume it and it's ecosystem are supported pretty well. I was wondering about Flask and its ecosystem of libraries (flask-bcrypt and flask-sqlalchemy as examples), some of which rely on compilation of C modules at install time (sqlalchemy can build without them though). Would those not be supported under PyPy yet? If so, how do you guys plan on supporting libraries that require C module compilation?
Meaning you can install it and run your existing Python code with it without having to change any of your code. 
Hm, I use Python 2.7 a lot... It's all currently in virtual environments. I'm wondering how cumbersome it would be for me to upgrade.
You can just apt-get install it. Python3 isn't linked to 'python', just 'python3'. Only difference is Python2.7 isn't there by default.
Assuming `flask-bcrypt` uses `bcrypt` from PyPI (and not `py-bcrypt`), it'll work great on PyPy.
Maybe one thing you will need to know is Kivy. As C# developer you will feel strange for the different approch to GUI programming. Kivy is one of the best choice. https://kivy.org/
If you mean python points to python 2 then that's correct, that is not changing until that one pep related to it changes status. The default just means that a default installation won't have python 2 installed but it will install as soon as any package you install depends on it or if you install it directly.
With virtualenvs it's easy to switch between Python 2 and 3. The switch to Python 3 on Ubuntu means that if you use the default python, it will be Python3 and if you want to access Ubuntu functionality using Python, using Python 3 will be easier than using python 2. In conclusion, this means that the general incentive to use python 3 over Python 2 has increased quite a bit. I think this change is more important for Python 3 than for Ubuntu:-)
Bit of a cop-out then. Yeah yeah I know this is the official line from PEPs etc, but it's the same thing -- it was a cop-out before and it's a cop-out today.
ITT: * `python`points to version 2.7 * `python3` points to version 3.5 The 2.7 version gets installed automatically as soon as any other package you install depends on it... so pretty fast. The situation hasn't changed that much from before.
I think it does. However I'm pretty sure it still requires an additional C module compile step when installing. I know I had to go hunt for a pre-compiled `bcrypt .whl` file to get it working properly on Windows last year because my VS setup wasn't adequate for it to use the C compiler it provides (got that sorted out now though). Anyways, if something depends on C modules compiled at install, will PyPy support it? That's the root of my question, I suppose. 
So you're telling me nobody works on anything cool involving Python, people in this sub should just ask Python support questions? Furthermore, keeping post standards low is just something we should accept? 
And I think it's not a bad situation either.
Or you can just say "this script is supported everywhere except ArchLinux" and let the downstreams take care of porting.
One thing I puzzled over recently; in Python there's no function to determine the length of an iterable. You can do `len(tuple(anIterable))` or the like (there are more efficient ways), but there's no simple length function. I had hoped to find something like that in itertools, but I imagine it was left out because depending on the iterable it may destroy the data, and/or it may never terminate.
&gt; I think the company still owns the stuff you do outside of office. This isn't automatically true, but is probably true in this case.
I'm telling you that people who work on "cool" things aren't going to stop working and post on them every day.
Nothing real ground breaking here. Literally every library/framework I've used in the past 6 months is all on 3.x not 2.7. Times change and you either progress with the language or you don't.
So all the people on this sub don't work on anything cool they like to share? Or maybe this sub is such a circle jerk that they wouldn't see the point? 
Unless the user overrides this one, it's a pretty safe bet to be true. And any seasoned python developer knows not to override this (for fear of certain death, or other complications).
Isn't Python 2.x EOL before 16.04 LTS EOL?
Yeah, of course, that's the right attitude. Because why would you want to use something that works everywhere when you can piss off your users and slowdown the migration to python 3?
Not a cop-out, but a pragmatic decision. Tonnes of software expects 'python' to refer to Python 2, so changing what it refers to would unnecessarily break a lot of software. Ideally, when Python 2.0 came out, python would've been a symlink to 'python2' or something similar, and people would've depended on the latter, but unfortunately that was never the case. Edit: spelling.
- You have backups, right? Git makes it trivial to set up another remote, and push to that too occasionally. - Git is very, very robust against file corruption. That's the point of hashing the history. So it'll detect any problems, then you restore from backup. - Store the *headless remote* in dropbox, and your actually working dir should be elsewhere.
I'm just not sure the link exists on all systems. Particularly OSX that hasn't updated Python in ages and probably goes back to befoure Python3 existing. But I don't Mac so...
API is the entry point ... but it depends what you want to do - the most bang for the buck is pyramid - http://www.pylonsproject.org/ - can scale from a small to a big project with a sound structure. 
What is the length of `itertools.count()`? What's the length of this: import random def rand_iter(): while True: x = random.randint(100) if x == 5: break yield x Some iterators do implement a `__length_hint__()` method, when they do know the length. It's used by `list()` or other similar methods to generate the list directly at that size, so less resizes have to take place. You can access the method via `operator.length_hint()` instead of `len()`. The difference is that the value might be wildly inaccurate, whereas `len()` should be always accurate. 
The C module for `bcrypt` comes from `cffi`, which works great on PyPy.
Yeah, but in Gentoo there is a clear line of "it's the admin's fault if they opt in to something unsupported (like multislot gcc)."
Try pythonnet to call your previous c# code from CPython or to call CPython from c#.
Can anyone explain the status of PyPy3? The [PyPy download page](http://pypy.org/download.html) still has PyPy3 2.4.0. There has been no blog post specifically on PyPy3 since the [2.4.0 release announcement](http://morepypy.blogspot.com/2014/10/pypy3-240-released.html) on October 21, 2014. This post says, "Update rpython functions with ones needed for py3k", which is encouraging, but I still get the sense that PyPy3 is languishing. Is it?
Im running some python on a surface pro 4
And of course you can use the `bytes` type, if you want an immutable version.
Ah... So is the only real "feature" of bytearray that it's mutable? Otherwise bytes serves the same purpose?
Any laptop will be fine for starting out, but maybe ask over at /r/SuggestALaptop for whatever the best deals are right now. They're a bit of sticklers for their rules, so be sure to read the stickies or the sidebar before posting.
You'll get a lot better help over at /r/learnpython. If you're just starting out and need a simple setup python.org has the right steps, but you might want to check out anaconda since you're on Windows. 
Praise the lord. Python 3.5 is a far superior language to any version of Python 2.x. And how long has Python 3 been out? Almost 10 years? It's about time we (as a community) start embracing Python 3.x
Arch doesn't use `/bin`. In fact, `/bin` is just a symlink to `/usr/bin` on my machine. $ cat /etc/os-release NAME="Arch Linux" ID=arch PRETTY_NAME="Arch Linux" ANSI_COLOR="0;36" HOME_URL="https://www.archlinux.org/" SUPPORT_URL="https://bbs.archlinux.org/" BUG_REPORT_URL="https://bugs.archlinux.org/" $ which python /usr/bin/python $ python --version Python 3.5.1
What are the language-specific formats in Visual Basic you are referring to?
Well, since this is a python subreddit, try playing with the NetworkX library. 
It's generally better to use `#!/usr/bin/env python{2|3|}` so it picks up a different python environment e.g in the case of virtualenv.
PRAISE BE UBUNTU, PRAISE BE
Usign something like Selenium is a pretty bad idea though: - Significantly slower - having a couple of requests vs 20 something requests your normal browser makes + all of the javascript execution is like night and day comparison. - Stress on the website - since you are imitating full load the source website gets more stuff to do thus making you throttle your crawling if you don't want to get banned/cause harm to the website. In my opinion it's still worth digging through the source and reverse engineer some of those forms because the difference is just so huge. Otherwise there's an alternative to selenium and phantomJS developed by the scrapy guys called [Splash](https://github.com/scrapinghub/splash) which I think is already miles ahead of those two.
They should do it the other way: python = python 3.5, python2 = python 2.7. Or have python2 and python3 for consistency.
You're not supposed to use `#!/bin` on arch either. Arch just makes it so `/bin` and `/usr/bin` both work, but you're supposed to use `#!/usr/bin`.
If I say `#!/usr/bin/python2` is that going to fuck me on some systems?
That would break a lot of programs,I guess they will do it eventually like for 20.04
RHEL 7 links /bin and /usr/bin too.
Python 3 has two types of built-in byte sequences: `bytes` (immutable) and `bytearray` (mutable). Analogous to types `frozenset` and `set` or `tuple` and `list`.
Yes, but mutability is a big deal. In place operations are much faster and take less memory. E.G: you can actually swap easily 10000 bytes in a blink using slicing, because slices support assignations.
any alternative ideas?
We're like Lelouch and Suzaku right now yo.
It doesn't bloody matter
Using python3 for python 3.5 (or later) is recommended by the Python core developers: https://www.python.org/dev/peps/pep-0394/ """ This PEP provides a convention to ensure that Python scripts can continue to be portable across *nix systems, regardless of the default version of the Python interpreter (i.e. the version invoked by the python command). - python2 will refer to some version of Python 2.x. - python3 will refer to some version of Python 3.x. - for the time being, all distributions should ensure that python refers to the same target as python2 . however, end users should be aware that python refers to python3 on at least Arch Linux (that change is what prompted the creation of this PEP), so python should be used in the shebang line only for scripts that are source compatible with both Python 2 and 3. in preparation for an eventual change in the default version of Python, Python 2 only scripts should either be updated to be source compatible with Python 3 or else to use python2 in the shebang line. """
https://xkcd.com/1172/ Can you guess which one it is? You should be able to.
Stuff in VBS like "IF ... END IF" not to mention many many many other cases in which it has unconventional and redundant formatting. 
This is in no way an Arch-ism. `/bin/` has existed way before Arch was even born. Distros deciding to move everything to `/usr/bin/` is a relatively recent convention, mostly in order to group everything under one folder, i.e `/usr/`. At the same time `sbin` was gotten rid of.
`#!/usr/bin/python2` won't. On 16.04 people will need to have `python` distro package installed beforehand (it is now not there by default).
Ah, shebangs. That makes sense...
Regarding "older, more mature languages". First appearance (as per Wikipedia): * c++: 1983 * python: 1991 * java: 1995 * c#: 2000
The developer is a naturally lazy animal, sometimes you have to prod him with a stick to make him go forward. All this stuff "breaking" could be fixed by changing literally one line (the first!) per file, and it would send a powerful signal that it's time to move on. As it is, the py2 community can just go about its business like nothing happened -- which they are doing. We have to drag them kicking and screaming in the new decade. I could see the rationale for being conservative 5 years ago, when py3 was a bit "experimental", but now it's time to be bold.
&gt; if ubuntu does it, it will be a glorious breakfest, but maybe people will learn to use #!/usr/bin/env python2 and #!/usr/bin/env python3 Except historically Python 2 was `python` and there was no `python2`. Still isn't on OSX AFAIK, there's only `/usr/bin/python`, which is 2.7.10.
I'm not referring to programmers here. Break things for us as much as you want. It's end-users and sysadmins this can't break for.
If you are going to do scientific computing with numpy, pandas, scipy, sklearn... choose always more RAM. this is way more important than raw cpu power and the main limiting factor of the things you can do easily. 
&gt; Python 2.x EOL I imagine there will be lots of hissing and clawing when that time comes. Python 2 user: "Pry it from my cold, dead hands!!!" Python 3 user: "Gladly!"
well, people still use `#!/usr/bin/env python` when writing new stuff for linux, so that’s the people i’m meaning. and i didn’t know that OSX fucks this up as well. they [should get their shit together](https://www.python.org/dev/peps/pep-0394/#recommendation) (first bullet point)
You know every distro is eventually going to replace `python` by python3, right?
I certainly wasn't suggesting that the *existence* of `/bin/` was an Arch-ism, it's been around since before *Linux* existed. It's '/bin being a symlink pointing at /usr/bin rather than a distinct location' that I was talking about. My understanding is that it's still the case that /bin is usually a different directory from /usr/bin/ (and that the latter directory is where Python will normally be installed) 
Yes, I'm aware of that (but prefer to say 'that will break' rather than making prescriptive comments)
Thanks.
&gt; It's '/bin being a symlink pointing at /usr/bin rather than a distinct location' In that case, that's Arch following a suggested standardization by Fedora/RHEL https://fedoraproject.org/wiki/Features/UsrMove
Full disclosure, I am the creator of [beekeeper](https://github.com/haikuginger/beekeeper). I'd love to answer any questions you have or help you turn any REST API you've been struggling with into a beekeeper hive file for easier use.
there will be again. “12 years is not nearly enough time to port my shit, pls support moar” i really hope they won’t budge this time.
Thanks for the clarification. Is there a semi-definitive list of which other distros conform to that? Right now, I have only Arch on that list, and Gentoo on the "doesn't conform" list.
You make a fair point! And if each REST API actually took advantage of the full set of RESTful principles and patterns available, then I'd probably agree with you; "let REST be REST". But, the fact is that there are thousands of APIs out there, each doing REST in their own particular way. And that means that knowledge and work you do on one isn't really transferrable to another. Is beekeeper about making working with REST APIs easier? Yes, yes, yes, a million times yes. But it's also about saving developers from writing tedious, time-consuming, platform-specific code.
no. Ubuntu’s own shell
The issue is that people release new software on Python 2.7 all the time. Tensorflow, for example, was originally released for Python 2.7 only and it took them quite awhile to get it to work for 3.4. And 3.5 is still unsupported. If people from Google don't bother, then how can you expect anybody else?
as always, [relevant xkcd](https://imgs.xkcd.com/comics/standards.png) just curious, have you seen [swagger](https://github.com/OAI/OpenAPI-Specification)?
I have! Like a whole variety of REST-related systems out there, it's great at doing what it does, which is to comprehensively describe HTTP endpoints and the variables they use. What it's doesn't do (what it doesn't really try to do at all), and what beekeeper does, is contain an object mapping that makes it possible to create dynamic client libraries that use object-oriented language-native idioms, rather than HTTP-native idioms.
&gt; RESTful requests are made over HTTP; we know that. That's not the case; REST is communication protocol-neutral. [As Fielding puts it](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven): &gt; &gt; A REST API should not be dependent on any single communication protocol, though its successful mapping to a given protocol may be dependent on the availability of metadata, choice of methods, etc. In general, any protocol element that uses a URI for identification must allow any URI scheme to be used for the sake of that identification. *[Failure here implies that identification is not separated from interaction.]* While most REST APIs are deployed over HTTP, that's just an implementation detail of those particular deployments, it's not part of REST. &gt; By consuming JSON files that describe the endpoints of an API This sounds like Beekeeper isn't designed for REST APIs, it sounds like it's designed for those annoying APIs that call themselves "REST" but aren't. A REST API doesn't define endpoints, it defines media types and relationships. A REST API already has the equivalent of the "hive" resource baked in. If it doesn't, it's probably not a REST API. 
I have switched to Python from C#, so I will write down what has changed: I have: 1/ started to use help function, 2/ read Python documentation, which is great, 3/ stop cursing Python batteries because .NET library is named more consistently, but batteries are fine, 4/ started to use interactive command line instead of debugger, 5/ started to understand what is delegate in C# (function or method are objects in Python), 6/ started using comprehension and stop to (over)use them in favour of yield statement, which is IMHO clearer to read, 7/ started understand concept of mutabiliy and immutability, 8/ stop using heavy-weight IDE, 9/ stop using generally OOP and got more functional but it happened mainly thanks to fsharpforfunandprofit.com 
This is an old one and for Java, but most of the recommandations are probably extant and C# isn't that different from Java: http://dirtsimple.org/2004/12/python-is-not-java.html Especially the conclusion: &gt; stop writing so much code. &gt; To do this, become more demanding of Python. Pretend that Python is a magic wand that will miraculously do whatever you want without you needing to lifting a finger. Ask, "how does Python already solve my problem?" and "What Python language feature most resembles my problem?" You will be absolutely astonished at how often it happens that thing you need is already there in some form.
Just use something like `&lt;meta charset='utf-8' /&gt;` in your header. http://www.w3schools.com/tags/att_meta_charset.asp
I've updated our page with podcast button which links to SC feed at the footer. Now everyone has an ability to add the show to app of choice. gPodder returns 500 with "server overloaded" message at the time but I will definitely spend some time to look into it. 
&gt;I imagine it was left out because depending on the iterable it may destroy the data, and/or it may never terminate. This is exactly it
As others have already mentioned, there are many iterators that can go on infinitely. Itertools supports 3 different iterators that are designed specifically to create an infinite iterator, for example.
Scrapy handles all the networking stuff for you such as: retries, redirections (both HTTP and HTML meta), smart auto-throttle mechanism (if you want so), sessions/cookies are kept automatically, http auth, robots.txt, etc. Basically, if your crawling requirements are more complex than just scraping a few pages, at some moment you will find yourself implementing your own version of Scrapy based on requests and BS4. :)
Thanks for the tips ya'll
I use #!venv/bin/python All of my projects use virtual environments (pyvenv-3.4), so using the above allows me to run script.py from the terminal without having to remember to activate the virtual environment every time. 
I'm not really familiar with the standard unittest module, but if i remember correctly, it will execute any method that starts with 'test' in your class, right? If so, you could add/remove these methods at runtime, doing crazy/stupid things like these : SWITCH = True class Foo(): def bar(self): print('bar') if SWITCH: def baz(self): print('baz') def outside_method(self): print('let me in!') if __name__ == '__main__': f = Foo() print([n for n in dir(f) if not n.startswith('__')]) tmp = Foo.bar del Foo.bar print([n for n in dir(f) if not n.startswith('__')]) Foo.bar = tmp print([n for n in dir(f) if not n.startswith('__')]) Foo.inside_method = outside_method print([n for n in dir(f) if not n.startswith('__')]) 
My number 1 tip would be: write unit tests. Because Python is interpreted some errors that in compiled languages would be caught by the compiler you would find out at run time. Unit tests help to detect these and of course are just immensely useful in general.
As a casual programmer who didn't do any web stuff since 2004, I have a real problem with understanding why **practical** REST is communication-protocol neutral. It seems like there are two distinct meanings to REST: one theoretical, as you mentioned, and another which is practical and what people usually mean by REST in any practical conversation, and which is essentially "hey, HTTP verbs correspond to typical data I/O operations you should map your remote calls to them." I would be so happy if anybody could explain a bit of background about REST, why is it special and mentioned by everyone and my dog and what was background to such popularity. I am currently implementing some sort of REST in my project but I don't really see anything in it that deserves a particular name and all the hype around it. I just have this strong feeling that the advice "Use REST" heavily implies "Use REST instead of RPC" and the definition should be negative, in the sense of "avoid doing this stuff" instead of "do this stuff".
This is horrible. It is way, ways *way* too early to even think about leaving 2.7. A good chunk of my code (including all of OpenCV) depends on 2.7. This is just ridiculous. 
To assign a complex type to a convenience variable, you just do a normal assignment like plot_solitons_RT = Tuple(List[np.ndarray], Dict[str, np.ndarray], Dict[str, np.ndarray]) `TypeVar` creates a *type variable*, which is something completely different. 
OS X.
This seems to just contribute to the existing problem of poorly designed APIs. &gt; Of course, right now, to get the benefit of this, you typically have to write the JSON “hive” file to describe the API yourself. But, with a bit of help, and a bit of luck, that won’t always be the case. The long-term goal is for beekeeper to become so popular that API providers will write their own hive files and host them on their own websites. These people have already poorly built their "RESTful" APIs. It seems unlikely they're going to implement something that describes their poorly built API. OPTIONS should be used to describe the individual resources in a RESTful API. I don't see the point to encouraging people to not use the tools built into REST. I feel like if you're trying to build a *RESTful* client OPTIONS is what you should be using; not this side-protocol you've created. I think beekeeper is an interesting idea for describing shitty APIs in general but this should not be the long-term recommendation for people building a truly RESTful API.
Oh dang you're completely right. I forgot for a sec how that worked. Woops... 
meh and then it works for nobody else. better use venvs correctly when you use them.
Which is a stupid idea that will just cause the same breakage if Py4 ever becomes a thing.
then install it
Wow, this reads like Straw Man City. For example, one of the First Principles is: &gt; Another key principle written by Fielding in his paper was the concept of “Hypermedia as the Engine of Application State”, or HATEOAS. The idea was that a client application could automatically “discover” all of the resources that an API provided, as well as the methods and variables exposed to work with those resources. Sounds neat! But then a few paragraphs later you imply that Wikipedia's API is a "REST API", but complain that: &gt; To access any resources on the API, the developer has to delve into the (often-lacking) API documentation and figure out exactly what parameters are needed for which resources. Huh. It sounds like you're complaining that it's missing one of the core principles of a REST API. Whatever happened to the hypertext that would allow my program to automatically discover useful endpoints? The problem here isn't with REST APIs, but *non-REST* APIs. In fact, Wikipedia doesn't even claim that this API is REST. (They do have an experimental "[REST content API](https://en.wikipedia.org/api/rest_v1/?doc)", but sadly it's also lacking some of the core REST principles.) There is a problem with modern APIs in general, and the biggest one I see is that they usually don't obey the REST principles, even when they claim to. Maybe "beekeeper" is a good solution for clients who can't fix these servers. But it feels like you're throwing REST under the bus here. From skimming the rest of the documentation, it looks like "beekeeper" provides two key features: 1. Describe an HTTP-based API with a JSON configuration file 2. Wrap HTTP API requests/responses with Python classes/methods \#1 essentially sounds like "make this non-REST API act more like they had used HATEOAS". #2 is neat and useful even for REST APIs. If there were a way I could split these parts, or have it default to reading hypertext links for #1, so I didn't have to write a JSON config file for actual REST APIs, then this would be a very cool library to use. There's certainly room for improving the API client experience, and experiments like this are great. I just don't want to make it sound like this is an inherent consequence of REST. It's a consequence of an API designer who didn't understand REST.
wrong. the question is about systems that *when python 2 is installed* don’t have `/usr/bin/python2`. obviously, because why would you expect something to work if a vital dependency is not installed. the right way to get a python 2 script running on ubuntu is either 1. package it. the package will depend on `python2` and pull it in. not fucked. 2. or just put the script for download and mention that the user needs python 2 installed. not more than the usual amount of fucked, because that’s how informal dependencies always work
The comment asked about `/bin/python2` when I answered.
idk, i think debian made it pretty clear that they won’t, ever. but fuck /u/infecthead for his attitude. why not try to make things as easy and future proof as possible?
Lambda!
Then remove it completely or just keep it pointing at 2. Changing it would help nobody at all.
well, if i recall correctly, they also needed many complaining people two releases (remember: debian) until they managed to ship that `python2` symlink. initially they [removed it!](https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=634967)
ah, so i wasted my time :D
Are you deliberately misunderstanding my point that fun stuff can't happen continuously?
Can you point to a REST Api that's not deployed over HTTP? 
You might be interested in this. [HTTP isn't a transport protocol](http://www.restpatterns.org/Articles/Why_HTTP_Isn't_A_Transport_Protocol). It really helped me in digging deeply into the HTTP spec, and finding out that pretty much anything you want to specify with regards to transferring data or calling actions on a foreign server, are specified in HTTP. The HTTP verbs, header fields, request/response definitions, and the like make it for a very useful the base of an API layer---much better than I'd have defined myself. -- I tend to write RPC over HTTP due to the context of my problems (we have way more actions that can be taken within the API than would map cleanly to single resources). HTTP is *restful* if used in that manner, but it can be so much more. 
Yeah. Well me too. have a nice day!
I don't agree with your point when there are so many people subbed here. Your other posts kind of miss the point too, but I appreciate your hard headed passion. 
This reads more like a manifesto for an idea rather than an implementation. You should summarize your mission statement and project goals earlier before the tl;dr and maybe provide a summary example.
Did I go back in time or something?
Why should Python 2 be the "Python" one? "Python" refers to the latest version of the Python language, the only reason why it's still refering to an old version in some distros is to avoid scripts breaking.
Now that winning at Go has been solved, I'll just wait for Google to create a public API for their GOBOT. Then I can just write a Python wrapper for it and be done. This ^is^how^I^solve^all^my^problems
is apt-get install python2 a real big concern? 
Well if you don't agree with it; that's okay. Just don't bring up other tangents.
You don't need a fancy editor for the behavior you describe. Instead of running it from the terminal like `python myscript.py`, run it like `python -i myscript.py`
Dude... you hit it out of the park. Python doesn't irritate me often, but you seem to have captured almost all the places where it does. Couple more things... 1. Its very difficult to build a gui. 2. Ship an executable / installer. 
The issue I have with stub files, is that the big reason I like to include the type hints is that it's a good reminder when I'm going back to old code what the function takes as input/output, etc. A stub file works, but it adds another file that I have to keep open for reference.
Well, even if they changed the default image from CD to DVD, there is still a concern to making the image not too big.
So it's kind of like WSDL for REST...just not as rigorously defined? ;-) Maybe SOAP wasn't such a bad idea after all...
IPython 5.0 will be using this.
https://www.python.org/dev/peps/pep-0394/ &gt; #Abstract &gt; This PEP provides a convention to ensure that Python scripts can continue to be portable across *nix systems, regardless of the default version of the Python interpreter (i.e. the version invoked by the python command). &gt; &gt; * python2 will refer to some version of Python 2.x. &gt; * python3 will refer to some version of Python 3.x. &gt; * for the time being, all distributions should ensure that python refers to the same target as python2 . &gt; * however, end users should be aware that python refers to python3 on at least Arch Linux (that change is what prompted the creation of this PEP), **so python should be used in the shebang line only for scripts that are source compatible with both Python 2 and 3.** &gt; * in preparation for an eventual change in the default version of Python, Python 2 only scripts should either be updated to be source compatible with Python 3 or else to use python2 in the shebang line. 
I mostly use matplotlib as well, but for time series and such, I would suggest to have a look at seaborn, and at the pandas package. While not a *plotting* package, pandas does have a lot of stuff to handle time series, including primitives to get nicer plots.
&gt; never #!/usr/bin/env python. you never know what you’ll get. Unless your script can work in either version.
Are Unity the engine and Unity the GUI remotely related aside from their logos?
They are not related
Makes me curious as to the logo usage then.
I am using plots and these visualization tools at various points throughout my workflow. Common things like frequency distributions, histogram, scatter plots, and others. For time series I am visualizing goodness of fits, cost fn convergence plots. Really, and i guess this question could have been phrased better- is there anything new and exciting in the plotting space? I think think the answer is yes- Bokeh seems pretty good. really easy to get up and running and a welcome change from what I have had to configure in a plot using matplotlib. That said when plotting 100K plus points the plot generation seems a little slow. 
I don't see the logo similarity
Fantastic post... there is a pydata seattle talk by Joel Grus last year that highlighted some really awesome things you can do w/ itertools and functools video: https://www.youtube.com/watch?v=ThS4juptJjQ github: https://github.com/joelgrus/stupid-itertools-tricks-pydata 
"Randomly"? Your script just assumes that the current /usr/bin/python is going to stay compatible with your code forever. **Your script** is doing it wrong. Every language has backward incompatible changes, there's nothing wrong about it. If you're not willing to update your code regularly for these changes, then just put the version in the shebang.
&gt;Break-fest This is going to my vocabulary.
You can use either raw sockets or scapy in python to sniff the local network for specific traffic. You can find some neat examples at http://www.binarytides.com/python-packet-sniffer-code-linux. You can also read more about the ARP protocol at https://tools.ietf.org/html/rfc826
As a note, in PyDev you can use Ctrl+Alt+Enter to run the current editor in a shell which you can later interact with too (as in IDLE) -- or you can use F2 to send individual lines to the console too. http://www.pydev.org/manual_adv_interactive_console.html has more information. 
just use Atom and install a python linter package + autocomplete python. It works great and is fairly fast. 
+2 Ipython and jupyter are incrediblely well made machines. Open up on of those ipynb files and you'll discover such a wonderful looking json file that you could cry.
Thank you, this actually helps a lot.
I'm sorry, but as much as the python3 community wants to believe that be the case, it simply isn't true. I can't think of a single other instance where a widely-used language introduced backwards incompatible semantic changes (which is really the problem here, if python3 were just python2 with added features and some standard libraries removed, porting would be trivial and we never would have had these issues). The only thing that even comes close would be perl6, however the perl community isn't in denial, and admits that perl5 and 6 are completely different languages.
Theres already a [post] (https://www.reddit.com/r/Python/comments/4fs6pn/pypy_51_released/) on the frontpage of this sub.
I use Sublime and it's pretty kick ass. EDIT: Don't shit on me for using Sublime; love is what I got. 
How did you get the price history chart?
http://python.readthedocs.org/en/latest/library/unittest.html#organizing-test-code def suite(): suite = unittest.TestSuite() suite.addTest(WidgetTestCase('test_default_size')) suite.addTest(WidgetTestCase('test_resize')) return suite ***See Also:*** http://python.readthedocs.org/en/latest/library/unittest.html#skipping-tests-and-expected-failures Oh btw, there is little point to adding these to a loop, simply explicitly declare your deps 
Awesome, I use `ipython` all the time, and known about prompt_toolkit for a while, thinking it was awesome but it needed an implementation somewhere.
Since we seem to have hit a metaphorical wall, let me just explain what would convince me. To show that Haskell's type inference is sufficient, you should give a reduction to real Haskell. If you need to do this in stages, that's fine, but each stage can't involve any things that aren't actually Haskell code (such as typeclass `instance`s without the types declared), since I disagree with you over whether those can be simply inferred.
Everything you brought up was a tangent. I'm not willing to back and forth with you further. 
***I*** didn't have internet at home. I had to download software at school, and then install it when I got home. And it always pissed me off when I had to deal with the software actually needing to download something else to work.
Could you even really use a lambda inside a list comp? Personally, I've just become a lot more used to functions written in the same scope, e.g. def whatever(): def something_else(thing): return thing*42 return [something_else(_) for _ in range(20)] 
I've been using [bokeh](http://bokeh.pydata.org/en/latest/), and found it far less frustrating to use than matplotlib.
That's a pretty neat combo, covers two of the main programming approaches. Do they do a LISP at any stage?
I'm sincerely curious if there's a reason to serve content using Python like this as opposed to running a web framework. Does anyone know any?
I'm pretty sure most IDEs can do what OP wants. I use PTVS(whatever, I like it) myself and can just highlight sections of code or send entire scripts to the interpreter. Although PTVS is very easy learn for what OP wants, I think Ipython/Jupyter notebook is the best answer for OP because what he describes seems to be using python for some kind of data analysis. OP: these notebooks run in your browser with cells of code and cells of markdown for comments and presenting your data. If you run a script in one cell then its variables will be available globally to manipulate in other cells. Add on the bonus of auto completion to see what methods or sub-data is available in returned objects. It can even do slides and display external data in iframes or JS like node and D3 for visualizations. If you are doing data analysis then once you play with Ipython you'll probably never want to look back.
&gt; So it's kind of like WSDL for REST...just not as rigorously defined? ;-) That's what I took away from it! &gt; Maybe SOAP wasn't such a bad idea after all... You shut your whore mouth. &lt;3
Relevant talk: [Brandon Rhodes - Oh, Come On Who Needs Bytearrays](https://www.youtube.com/watch?v=z9Hmys8ojno)
I use vim with python-mode for the feature you described you could just map a key to execute it with *ipython -i* map &lt;F6&gt; :!ipython -i %:p&lt;cr&gt; vim has steep learning curve though... but it's worth it :) 
PyCharm!
I use pycharm and love it! Still learning how to fully use it too! It's awesome 
It'd be wonderful if it wasn't so damn slow.
Yea Visual Studio is pretty god tier secretly
Emacs
Vim
I just use atom or if I'm server side nano. Not doing anything too complicated at the moment to warrant an ide.
THIS. Damn fine editor indeed.
If you've not already, then give Atom a go. It really feels like Sublime 4 and is much more actively maintained.
You mean like a Python to Haskell transpired? Or just purely typing Python. Cuz the former is very hard.
Probably had autocompete mess with his shit
Vim, tmux, and a shell.
oh jesus christ this question again.
I just wish it was easy to use in emacs.
Oh god, this changes everything 
The latter; I'm interested in applying Haskell's type system to Python the way we've been discussing. To make things easier, you can assume classes and functions are immutable (though of course objects need not be) and there are no metaclasses or `eval`s. To be clear, I'm not asking for an actual formal implementation or any kind of completeness. Just answers to the specific questions raised, like how you're going to compile duck-typed attribute accesses.
WingIDE
Ok I see! Thanks for answering my question!
&gt; A REST API doesn't define endpoints, it defines media types and relationships. Well said. This is the key point that took me forever to truly figure out, due to the fact that the term "REST" means something completely different in industry. Since getting a job involving "RESTful Web Services" I've seen that in industry the polar opposites of RPC versus REST have nothing to do with what the acronyms originally meant. Industry RPC means that you just use HTTP/HTTPS as a convenience layer for a simple application of the form of I give you a bag (xml/json/whatevs) of text (ascii/utf-8/whatevs), and then you think about it and give me a bag of text back indicating how things went. Everything is POSTed to the same endpoint, and everything returns 200 OK no matter what happened. To get any meaningful information I have to understand whatever is in that bag of text the server sent back. Maybe some headers are used for authentication, but the headers likely proprietary to the API. Industry REST just seems to mean that you bothered to read some of RFC-2616 and actually use HTTP as an application protocol extending it with whatever specifics are needed for your application. This is nice because it means that there is less that I need to learn about your specific API. I know that your server is broken if you send me 503. I know that I'm not authorized if you send me 403. I don't need to learn your particular list of error codes. Endpoints tend to correspond to actual resources. HTTP verbs are used in an appropriate manner. Its easier to learn and interact with this API because it is closer to familiar standards. You might even say its a form of uniformity in software architecture that Fieldman praises in his thesis. Of course, with "Industry REST" I still have to read API documentation and understand it, but I would argue that with actual REST I need to read and understand the domain-specific media type and then devise a more complex client that can navigate the REST API through multiple requests to locate the appropriate resource and perform the desired action. While I think there must be niche applications where this tradeoff is beneficial, for the bulk of day-to-day needs I think good use of http and a reasonably defined set of endpoints is pretty much what is needed. "Industy REST" services should really be called "HTTPful services"
If you're a Pythonista mucking about with D3, take a look at [Bokeh](http://bokeh.pydata.org)! :-)
I have the IPython shell enabled just fine. I mean I can't get notebooks to work in it.
Echoing what some folks have said, if you are doing web development, then most machines should work. However, if you are going to do data analysis work with Python, you should get a machine with as much RAM as possible: at least 8gb, and 16gb if possible. Some beefier machines offer 32gb but that's hard to find. And, of course, if you are going to do data analysis or scientific computing with Python, I'd recommend you download [Anaconda](http://continuum.io/downloads) as a great way to get all the libraries, pre-built and tested.
&gt; I have struggled to get and hover over features working. with seaborn though. For that, you need to use javascript-based plotting libraries like [plotly](https://plot.ly/ipython-notebooks/cufflinks/) or [bokeh](http://bokeh.pydata.org/en/0.11.0/docs/user_guide/tools.html#hovertool).
The debugger is really great, method extractions and suggestions from a drop list are my favorite features. Still working with data it's often easier using iPython first testing snippets and then export to Pycharm. I know you can open up iPython notebooks in Pycharm, but I just don't like the interface.
+1 for Bokeh. I have been using it to develop server apps extensively for fun, but mostly at my company for various interactive dashboard apps. I really hope it overtakes D3. I think with further time and effort, and a little bit more user freedom we will get there. Also Bokeh is by far the best run and maintained Open Source project I've interacted with. the group of people handling issues and PRs on github are phenomenal.
Yeah, I am using Android app.
I've used atom with a linter and a few addons, it's great as an all-around editor. I use it for everything else, but pycharm had become a part of my work flow, much like eclipse has for someone working at Oracle or visual Studio for someone at Microsoft. You probably could achieve the same functionality of demand from pycharm with atom extensions, but I'm already set in my ways. 
In PyCharm you can enable/disable whatever bits you want also although I've got all of the standard plugins and a few more enabled and see no performance issues at all (desktop with i5 2500K, 16GB RAM, SSD). I really don't get this "IDEs are bloated, slow etc." line of thinking as even Eclipse is pretty snappy on my machine which is years old. A professional programmer should have decent hardware as it's the tool of their trade. If you are assigned machines by your work, it should be simple enough to show them the value proposition of your wasted time vs. the cost of a decent machine.
This is *awesome*! I'd love to see this integrated with Swagger JSON definitions, and a method for automatic creation of the JSON definitions from a set of models (think Django + DRF). Great work, hope to see this gain some traction!
Definitely different beasts. I wish the notebooks interface in pycharm was good enough to keep me from ipython when I'm working on a presentation but that simply isn't the case. 
Any autocomplete? I use YouCompleteMe https://github.com/Valloric/YouCompleteMe
I'm surprised anyone used the system python long enough to find the bug.
Well, maybe. /u/zedshaw would have the analytics and a much more informed answer. (Also, zed, thanks for the book. It was the first extra book that I bought for college.) I don't know when the first edition actually came out, or when it started getting popular. However, 4 years ago, he had one of the first results for "learn python" on Google (I know this from experience). Combine the SEO with introductory CS courses moving to python and away from java, his success makes sense. 
Yes, and he even forgot to ask about Python 2 or 3
YCM does code completion, syntastic checks for syntax / linting errors.
Kdevelop has a Python plugin with amazing code completion / documentation / navigation support. Can't write Python without those features anymore without feeling like I'm writing ansi C.
I agree with you. I didn't WANT an IDE, I thought it would slow me down, after experiences with netbeans, eclipse and it's derivatives. PyCharm made me fall in love with IDEs. Jetbrains did, and still are doing a great job with this and the other IntelliJ based editors.
One advantage of having a RESTful service is that the service becomes easier to scale by just adding more physical or virtual machines. Since it doesn't matter in theory which server handles the requests all you need is a load balancer and then just deploy additional servers as needed. This is the so called Y-axis scaling. X-axis scaling is when you scale servers among specialization. Say you add more servers that handles user login or db management. Obviously there are pros and cons to each scenario.
I'm pretty sure Visual Studio is widely respected.
I thought they had fixed that, but I've continued running with `-s` out of habit. Actually, it still doesn't work with `ipdb`, now that I think about it. You get errors. This is on a pretty recent version.
thanks! i'll try to read it!
thanks! helps me alot! i'm considering php now! this is a really huge project.
thanks for this reply man! helped alot! :)
Yeah it really seems quite difficult. A large part of the issue is that people doing really "evil" things can make things very difficult. Something such as having a method on an object clobber all its existing methods and then graft on a whole bunch of totally unrelated ones. Also I would probably have to use a ton of union types. And by that I mean `data UnionNumber4234234 = A Int | B String | C Char ...`, which actually works quite well as a union, but it is a huge pain to generate a ton of really big ones. Whilst I still think it should be just about possible to use Haskell's type system, I think any attempt to type Python without any changes to Python itself would probably end up being horrific to implement. So really the best way to end up with a statically typed Python is to change Python itself in the process, which many won't consider worth it. But yeah I also took a lot from this debate, and it was very interesting! Thanks!
can you share the book title? :)
I'm into frameworks as i also like code igniter on php. thanks for those links, i'll read through it!
heh. my emacs python configuration consists of: (setq auto-mode-alist (append '(("\\.py$" . python-mode)) auto-mode-alist))
I use VIM, Gedit or Liclipse depending on where I am and what project I'm working on.
Pygame, Kivy or Pyramid, are probably good/fun places to start depending on what motivates you. * http://pygame.org * http://kivy.org * https://trypyramid.com/
It worries me that I don't see spyder on here. Am I using something shitty while you all know better? 
Ah fantastic, thanks very much!
I can't speak for the original commenter, but I believe he just meant most people `brew install` the latest python version and use that or use `virtualenv`, etc. From a SysAdmin perspective, it is nice to know that if you're on X version of OSX, that you have a decent scripting language at your disposal.
FWIW, I use / really like spyder, but I suck.
A whole bunch of people have downvoted this which I find pretty funny.
I would say there question here is, how you use that module. Let's say you have an app that saves its data to a plain file by default, but lets the users choose to save to a database. Then it would make sense not to import the database module right away but wait until the user chooses the database option. In general I would put the imports at the top, as this is just easier to read. 
&gt; Currently all systems try to be real time systems, or at &gt; &gt; least soft-real-time systems. Wot?
Just take your time and learn pdb module https://docs.python.org/3/library/pdb.html
I love bokeh! This is the best plotting library I've ever used for real time plots in python. Matplotlib is too slow on refresh and everything else doesn't have real-time functionality.
I found it about as funny as having four different ways to do string formatting.
The only time I ever put an import NOT at the top of the file is when I'm using a single function from the module, once. I will put the import above the function call, so that people don't have to scroll to the top to see where it is imported from (or scroll to the function call when they see the import at the top). Of course, you can probably avoid this by not using the 'from x import' syntax
There's also [PyQtGraph](http://pyqtgraph.org/). I haven't used it myself but it is better suited for real time plotting than MATPLOTLIB.
Not very zenlike
It says "CC-BY" as a license. Does that mean I could use it in the slides for a python course given in an academic context (post-graduate course) ?
I'm pretty sure only OSX and some really obscure an/or outdated distros are left. OSX should have provided the link long ago and you can just create it as a workaround, whereas in arch, python can't be made to point to python2.7 So the most compatible thing would be to create /use/local/bin/pytgon2 if there is no python2. Or just use python 3, you know?
you mean a clown with a light saber fighting children in the forest doesn't convey "complex is better than complicated?"
You can do whatever you want, but it's not required, as his post somewhat implied.
Maybe it was [funnier in Portuguese](http://hacktoon.com/log/2015/programming-comics-3/)
Check my FAQ link above :)
I used that before I switched to sublime. It's okay but is missing many useful features (even with plugins).
Ycm is only completion. Syntastic does all the syntax checking
I used screen for 20 years but switched to tmux for the last few. It's better.
What do you mean by malfunctioning?
Somehow, this managed to fill two screens without saying anything.
That's the expected response to "whereis python3".
And saying non-sense as well. I do like Python a lot, but *come on*, it is not "super efficient". Not slow for common tasks, and `numpy` does help a lot for (light) computing, but coming from a HPC point of view, *python is slow and memory-expensive*. Still very good for most analysis, but this article is not only useless : it is also wrong.
Ok obviously the real answer here is that it depends on the actual function that is in play or in discussion. If your import statement within the f() improves performance, this might be helpful for certain applications in which the module is very specific to a certain task. So the person who said 'how do you use the module' is spot on. The general rule of thumb, imo, is to put the imports at the top because they are typically regarded as more backbone based ideas and easier to review/read when you're actually looking at the script. again, rules are made to be broken. if readability is sacrificed for performance or visa versa, well depending on the application, that could be beneficial! have fun
I have. I tend to prefer Jedi (CTRL-. is one of my favorites) but I'm the kind of guy who's been using the same config for long enough that I don't even remember what everything does. I would never do this in Python programs, but I'm okay with it in emacs-land. I also use autopep8, which is interesting because it trains you to write consistent code. I'll try to post my config. I have been experimenting with using other people's to see what else is out there. Recently, I discovered desktop-mode, which remembers what you last had open.
When you say `from os import *` now all those functions are siting in the same namespace as your other functions. You will have masking, and if you import many packages like that, total chaos. Unable to know which function was coming from which package. When you say `import os` all those function are siting in their own namespace, under `os.something`. Many languages only have the ability to `import *`
Sadly, I agree. Unfortunately most of the ideas just don't translate into any context other than code.
it makes you wonder why they decided to do it 
I think if you get to the point that you're designing for the need to only open only if you want to do one option, you should create a modular application and put that import at the top of a new module.
Neovim with plugins. 
/r/Python is for news and releases. /r/learnpython is for questions.
Yes. Nobody knows when, but it will happen, just like every other man-made thing.
Upgrading to SSD might help?
Yea I sometimes use autocomplete and I think it's YouCompleteMe. For me though, it's all about syntax highlighting, PEO8 warnings, and setting a colored bar at text width 80
Let me quote the Snopes article you just linked: &gt; When the astronauts began to fly, like the Russians, they used pencils, but the leads sometimes broke and became a hazard by floating in the [capsule's] atmosphere where there was no gravity. They could float into an eye or nose or cause a short in an electrical device. In addition, both the lead and the wood of the pencil could burn rapidly in the pure oxygen atmosphere. Paul Fisher realized the astronauts needed a safer and more dependable writing instrument, so in July 1965 he developed the pressurized ball pen, with its ink enclosed in a sealed, pressurized ink cartridge. In other words pretty much what I said, and the cartoon perpetuates the mistaken assumption that the Pencil was the better choice, WHICH IS WHAT THIS ARTICLE DEBUNKS. 
Not ever.
 if a is True: return True else: return False
There's nothing un-pythonic about modifying globals from a function *when it's warranted*. If I ever found myself in your situation, I might do it like this: def init_imports(): import hugelibrary1 import hugelibrary2 ... globals().update(locals()) 
And non-man-made things, because of natural selection.
Well, it's normal that you haven't heard of it before. It's one week old. The good news is that it's receiving lots of love so far.
https://realpython.com/blog/python/setting-up-sublime-text-3-for-full-stack-python-development/
Jupyter is integrated into Spyder
As of El Capitan it's impossible (without jumping through some highly technical hoops) to upgrade any system components, including Python.
Maybe because it isn't version 3. If you're targeting 2.7, though, it's actually fairly recent.
I would be surprised if one (or several) large organisations that rely on it didn't fork and continue to support it over py3k at that point. I know I have no intention of switching.
Could actually be a good money maker, providing corporate support for it. I believe the [license](https://github.com/python/cpython/blob/3.4/LICENSE) supports it: &gt; All Python licenses, unlike the GPL, let you distribute a modified version without making your changes open source. 
And? I had a look at the FAQ and the sidebar. I can't see anything where i'm breaking any rules or anything to help me. (although you might be hinting at [this](https://www.reddit.com/r/learnpython/wiki/faq#wiki_what_are_classes_and_how_do_i_use_them.3F)). Are you saying that I should post this Q in the sticky instead? (If you are, then I'll just wait til next monday for the fresh one)
I was thinking more along the lines of the universe reaching either a cold death or a collapse, or even just the sun blowing up. Evolution doesn't really guarantee extinction per se.
hasn't quite worked out for me just yet, though I'm not sure exactly why. keeps throwing "OSError: [Errno 2] No such file or directory" I've tried using full or partial directories with and without ./ but to no avail yet. Maybe it's related to the fact that I'm running this in a jupyter notebook? edit: nevermind, I'm an idiot. I guess my manual compiling of ffmpeg didnt work right. so i just did a sudo apt-get and now the function is working properly. Thanks again for the tip
"Would it be for a racing car driver job?" It hurts. 
[This is my favorite](http://i.imgur.com/UaTTwdR.png) 
There is a 3.3 branch, it just hasn't been released :(
I have this code where I have this quiz for students and each student's score is then input into a csv file. I want to then output the average score of each students last three results when requested. For example if John scored 3, 5 and 7 I want to output into python: John: 5. This is what I have so far, but it isn't working: def average_score(filename): averages = {} with open(filename) as fd: reader = c.reader(fd, delimiter=",") for row in reader: user, *scores = row #If user has no score if len(scores) == 0: continue averages[name] = sum([int(score) for score in scores]) / len(scores) Sorted_averages = sorted(averages.items(), key = o.itemgetter(1), reverse = False) #This outputs to the user for item in Sorted_averages: print("{}: {}".format(item[0], item[1])) Can you please let me know if you can help, thanks.
The server code is going to be published when it's out of beta. Then you can test your bot in it. Until then, you can test your bot in the KGS. 
Please never use global names.
What do you think an import at the top of the module does? It creates a global name. 
Unless I'm mistaken, global names also propagate up into any modules that import yours. Imports are still restricted to the scope of your program. For example, if I import random in a module I'm writing, I still have to import random in any modules that import random. If I import random in a function, random is restricted to the scope of that function.
No matter how much window dressing in the form of `await` and `async` you throw at it, you can't protect against accidental forgetting of putting `yield from` or `await` in front of a generator-like construct. Mainly because you can't disambiguate easily if it's a mistake or passing around suspended state to a caller or subroutine. Still, aiohttp looks rather fun.
If you have to develop Python on Windows anyway the [Python Tools for Visual Studio](https://www.visualstudio.com/en-us/features/python-vs.aspx) are actually pretty amazing.
It is true that you can forget an await, that's why you need write tests.
I don't understand what you mean by "have to import random in any modules that import random". There is no difference between import foo and def f(): global foo import foo f() In both cases, whatever code imports * from this thing will end up with `foo` in its namespace (unless we define `__all__` at the source and exclude `foo`). 
Everyone of us will be obsolete before python 4. 
The system python has gone to shit in recent OS X. I sincerely hope no-one uses it. They have beta versions of pypi packages installed in it by default, for no apparent reason, that are unremoveable.
Right, but the article implies it's some sort of mystical, unexplained crash.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
I also noticed hangs on autocomplete suggestions and slow menu opening. Never worried about the initial indexing. Are the autocomplete and menu opening the deal breakers. 
Look. Anything you define at the module level *is* a global. In Python, the global scope *is* the module scope. Variables don't magically leak from module to another just because someone uses the `global` keyword. I only mentioned importing * because that's the only way you'll end up with `foo` in the importer's namespace. `global` has nothing to do with it. 
http://google-engtools.blogspot.com.ar/2011/07/are-ssds-silver-bullet-to-improve.html
There is currently nothing pointing in that direction. It has existed for quite a long time and it is the favourite high level language for many programmers, so there is really no reason for it to go away.
I doubt it has any more of an impact outside these changes being merged to the pypy3 branch.
My favorite comprehensions tutorial: https://gist.github.com/bearfrieze/a746c6f12d8bada03589 I especially love the end of the Set Comprehensions section - you'll appreciate it too I'm sure. :)
I love Emacs, especially how well REPLs can be done with it. Though it is a hassle to set up as beginner. I tried to accommodate by providing EMacs Python (https://github.com/kootenpv/emp). Mostly bundled around `elpy`.
The thing is: if a bot plays against a bot it should always deny that it is losing, as it does not suffer any consequences for saying so. It might actually still have a chance to win (e.g. other bot errors). For human play it is better not to deny losing forever, though the pressure is only of a social kind. It would be interesting though to add a multiplier effect if a bot says it can win and another denies it. The denying bot could be punished. Though this actually makes it a different game.
Python 3 is the future. Python 2 is not. As for transitioning, you can always use the 2to3 tool (however as a beginner, you should just write Python 3).
Tough question. I learned 3 first, because I thought it was the future of the language, but I always find myself using 2 more, now that I learned it. Master three first, then learn 2. 
Re: "you can always use 2to3", no, you can't. The results are not sufficient for large projects, I've had at least a few people tell me, privately or on IRC, that they'll be stuck on 2.7 because they have millions of lines of code.
Most 'frameworks' are concerned with lower-level activities - things like making a website, displaying animations. It's unlikely that any one framework will give you all the higher level business functionality you desire. 
The question is too broad to answer, and you sound like you're way out of your depth. Try to be more specific next time!
Copying my /r/programming comment: Yes, for applications which look [like this](https://bitbucket.org/pypy/benchmarks/src/59290b59a24e54057d4c694fa4f47e7879a347a0/warmup/function_call2.py?at=default&amp;fileviewer=file-view-default): def k(a, b, c): pass def g(a, b, c): k(a, b + 1, c + 2) k(a, b + 1, c + 2) k(a, b + 1, c + 2) k(a, b + 1, c + 2) k(a, b + 1, c + 2) def f(i): g(i, i + 1, i + 2) g(i, i + 1, i + 2) g(i, i + 1, i + 2) g(i, i + 1, i + 2) g(i, i + 1, i + 2) g(i, i + 1, i + 2) for i in range(2000): f(i) The actual report they misquote says &gt; the overall **warmup** benchmarks got up to 90% faster They also got a wrong link to the release announcement.
I knew of one from long ago so [I googled Python Business Application Framework](https://www.google.com/search?q=python+business+application+development&amp;oq=python+business+application+d&amp;aqs=chrome.1.69i57j0l2.8017j0j7&amp;sourceid=chrome&amp;ie=UTF-8#q=python+business+application+development&amp;start=10) and up came: * The one I know about from long ago, [DABO](http://dabodev.com/) * [this new one](http://www.python-camelot.com/)
One Atom package I love for Python is **multi-wrap-guide**. I set two guides one at 72 characters (for comment width) and the other at 79 (for code width). Sublime Text probably has a similar plugin but Atom is where I first encountered this functionality.
Yup, same. Pretty fantastic so far; lots of features with most pretty intuitively designed for access. I really enjoy the IDE a lot, and it has only a few problems I've encountered with it, although most of them are minor annoyances.
fast navigation is pretty useful. I used to dismiss it when IDE users would rave about it, but quickly jumping to the definition of a function from a usage elsewhere in the code is pretty nice.
Can you not find a company that will let you work remote and continue with your ML/data science skils.... Leaving that field to run web-dev makes me sad.
Isnt len constant time?
Machine learning is a great skill to have and it sounds like you are on your way. The problem with ML, from my experience when this kind of thing comes up, is the company wants the person doing the work in-house because there is a near paranoia in management about "what can happen if this gets out". Everyone using ML is doing so to have some kind of business advantage or to have security tightened and management tends to get nervous about that happening away from the core business even though it really isn't. It sure is fun though.
Last remote gig was programming/devops with OpenStack. I've seen a few similar opportunities floating around.
Thanks! That was exactly what I was going for - skip the beginner level stuff!
lol, I thought only PyCharm gets any love around here. Nobody would ever call it light weight but VS works well and has a very pretty dark theme with nice fonts. If you're on windows with a solid machine, I think it's a solid choice.
From what I've heard, data scientists have to often be at the office and aren't allowed the same remote opportunities as web developers because they are needed to explain things to management and nontechnical people. Thats because the ML algorithms are alot more complex and harder to explain to people I would be willing to work as a data engineer if there are remote opportunities, but I'm not sure if there are that many
&gt; It's generally better to use #!/usr/bin/env python{2|3|} so it picks up a different python environment e.g in the case of virtualenv. I just tried this on Arch, it doesn't work. /usr/bin/env: ‘python{2|3|}’: No such file or directory Guess env doesn't work with globs ☹.
It's 2016, we have video conferencing. I work 1300 km and 1 timezone away from the Head office. Between 150mbps broadband and video conferencing, the only thing I miss from being in the office is the social stuff. I'm constantly in meetings with management, product teams, customers, professional services, name it. A big difference might be that my company (not a huge one) has 5 main offices in 3 timezones and 2 continents so there's a culture of video conferencing and remote participants in meetings.
To become a consultant, you only need to be 2 pages ahead of the clients; that and have some comfort in project management and billing people largish sums of money.
In no particular order- [Qt designer](https://doc.qt.io/qt-5/qtdesigner-manual.html) for creating GUIs with Qt [Glade](https://glade.gnome.org/) for GUIs with GTK+ [Builder](https://wiki.gnome.org/Apps/Builder/Features) is a newer toolkit for GTK+ 3 only. [WxCrafter](http://wxcrafter.codelite.org/) for WxWidgets, could likely be used with [WxPython](http://www.wxpython.org/) [Pygubu](https://github.com/alejandroautalan/pygubu) for a visual designer of Tk/Tcl (the toolkit python comes with) [Kivy](https://kivy.org/), high level, python-focused
Yeah, skip 2 ones for now. With time and experience, you'll eventually be able to translate easily between the two.
YCM has Jedi python completion built in! (unless that's what you were implying by linking to YCM)
Disputes like this are covered in the rules of the game, though the specifics vary quite a bit by rule set. In AGA rules it's very simple: continue playing until it's settled. Yes, a player can claim that a group with a hundred eyes is dead, but then it's up to that player to prove it. It's annoying, yeah, but those are the rules of the game. The fact is that Go does not have an objective end condition, and that's one of the reasons it's been historically hard (and interesting) to program. It's trivial to do basic eye detection, and that should be enough to eventually reach an agreement.
It doesn't require any experience to be a consultant. A lot of companies don't have anyone that knows data science, so you can provide a lot of valuable services for them even as a beginner data scientist. My first data science job was as a consultant. I often explain stuff to my clients over gotomeeting or google hangout or the phone rather than in person. I have several clients that I've never met in person.
&gt; NetworkX Thanks for the tip, there seems to be a few tutorials out there. Looking at the graphical plotting in the demos, this looks a valuable tool. http://www.python-course.eu/networkx.php https://www.udacity.com/wiki/creating-network-graphs-with-python
So gevent? Personally I prefer having context switches explicit.
Thank you! I'm also very not familiar with GTK+. What is it exactly?
Yes, you are right. My bad. http://stackoverflow.com/questions/1115313/cost-of-len-function Thank you for correction and info. I would not expect that. But even so, generally is not good idea to call the same function over same object twice time. :) Frankly speaking I really doubt the code in question. This is exactly the reason why is Python said to be slow. But the culprit is not code. &gt;&gt;&gt; I have a fitting algorithm I wrote that takes in about 300,000 (30,000 x 10) points and uses this &gt;&gt;&gt; data to determine x, y, z, yaw, pitch, and roll needed to align my physical system. I step towards &gt;&gt;&gt; these results and then iterate via a "while" loop over this to find the next step. If I got this lines correct, tuple of such range is about 120 MB of memory. (To save some memory you can use *array from array*). Using lazy evaluation correctly should not cause such memory problem considering "while loop". You can have your basic data and pipe them through generators without drastic increasing of memory usage. Here is everything stored within one object for some reason. Of course, I might be wrong :) I didnt analyze that code really deep. PS: I know you are not the author of this post but I am generally surprised of speaking about numpy or so, when the main problem might be in code itself. I would expect from community a little more. 
Operating systems and networks are mystical to many developers...
IDLE :l
Is beekeeper similar to bravado (https://github.com/Yelp/bravado), a fork of swagger-py (https://github.com/digium/swagger-py/) ? If so (or not so), what would be the key differences ? 
Don't believe what you've been told. I'm currently looking for a remote job too and have noticed few remote data scientist positions during this time. Be patient — new positions are constanly openning, just wait for the right one. If it helps somehow, here's my list of the best places where to look for a remote jobs: stackoverflow.com/jobs remoteok.io (reposts from stackoverflow mostly) workingnomads.co (reposts from stackoverflow mostly) weworkremotely.com angel.co/jobs
I've used both and don't understand the hype. Besides being trendy right now, what makes Slack any better than Hipchat?
Here an editor to build webinterfaces, in case you would like to control your raspberrypi remotely without remote desktop solution https://github.com/dddomodossola/remi/tree/master/editor
Me too, very much so
I think the seeming lack of opportunities for remote data scientists is less attributed to: &gt;they are needed to explain things to management and nontechnical people Instead, the bottleneck may be more attributed to some variant of the "Drake equation": opportunities_available = ( engineering_jobs * percent_remote * percent_needing_data_engineers * percent_hiring_now * percent_one_knows_about * percent_one_qualifies_for * competition_from_peers ) I'm sure there could be many more variables - but you get the idea. It doesn't make it _easier_ but it might influence your job searching algorithm.
if the "working remote" is what is hindering you from getting a foot in the door .. i would suggest you get your foot in *without* this requirement. once you are hired, and during your first year, you can explore possibilities of transitioning to working away from the office. it's an easier road to take to get to your goal.
[The debug mode of asyncio warns you when that happens](https://docs.python.org/3/library/asyncio-dev.html#asyncio-coroutine-not-scheduled) I have been working with aiohttp daily for the last four month, it is a wonderful piece of software.
I do web dev for a startup and work from home. Reporting to the office once a week for a meeting and whenever necessary - which is not very often. All my work is done on a computer and we use the internet for communication anyway.
In short: yes, these skills are transferable and it's probably that you'd be able to make money off of them. It's hard to say anything more without knowing more about your background, seeing your code or asking you what area you'd like to go into (Python is widely used in scientific computing, web development, system administration, and more). I think you'll have much more luck if you hit up other subreddits like r/ITCareerQuestions, r/freelance, r/cscareerquestions. I'd first get a feel for each. The first one focuses on general IT stuff, the second is super freelance oriented (lots of business stuff, little about coding), and the last is really focused on the coding aspect of comp-sci related careers. I hope this helps, and good luck!
Well it is not exactly a secret that there are large python code bases, but eventually they will become obsolete. So forever is probably a strong word.
I would suggest trying to move into GIS type stuff, that is always in pretty stable demand.
if you are indeed being inundated with consulting offers, and if you don't have time for them all, maybe it is a good idea to talk with the clients to have their job ad's up in a WORK section of your website. since you teach, your students could surely benefit...
&gt; The problem here isn't with REST APIs, but non-REST APIs. Pretty much this. The author brings the Wikipedia API as an example of a problematic REST API, but it is actually not RESTful at all. It violates HATEOAS as the API is not self documenting and it relies on out-of-band information. So the problem today, in my opinion, isn't REST, but rather implementations claiming to be what they are not.
It's just like directories but for objects instead of files. You can see `os.path.exists` just as `os/path/exists`
There's more to an IDE than theme and fonts yo... &gt;_&gt;
We've posted a couple of neat tricks on pytest at http://hackebrot.github.io/pytest-tricks/. And many more to come! 
In a few places I've seen that ScrapingHub is hiring. 
I find the built-in Path lib (os.path) to be annoying to work with. For example: conf_path = os.path.join(os.path.join(os.path.abspath(os.getcwd()), "mydir"), "..", "options.cfg") The backported pathlib that /u/Imperal suggested looks a lot more readable and concise.
It looks like at the end of the day, the goals are the same: make HTTP API requests in Python less horrible. I see a lot of convenience features in beekeeper that definitely wouldn't be possible based on the information in Swagger. One key bit of that is namespacing; bravado definitely makes really good use of the information available by trying to automatically pull resource name information from URLs, but that can't always work. Plus, since bravado uses the Swagger `operationId`, you can get duplicate namespacing - for example, `client.pets.getPetById(petId=123)`. In beekeeper, because namespaces are declared explicitly, there's no ambiguity or duplication: `client.Pets.get(123)`. The above actually uses another feature of beekeeper, although not one that couldn't be implemented in bravado; if there's only one remaining required argument after `**kwargs` has been used, beekeeper can put it where it needs to go without having a keyword for it. Beekeeper also supports the `APIObjectInstance` feature. Because beekeeper can be made aware of a particular API object's ID variable, you can subscript on that variable: `client.pets[123]`, assign the resulting `APIObjectInstance` to its own variable (if you want: `frank = client.pets[123]`), and immediately have access to all the methods that are relevant to that particular instance; e.g., `frank.get()` or `frank.update(name='Joe')`. beekeeper is also much more adaptable. Swagger defines a set of basic variable types, and doesn't allow any others, which is 100% understandable in the context of "give me a complete and accurate universal definition of this API". In comparison, beekeeper will allow you to extend the available types relatively easily by decorating a method that can handle them with `beekeeper.VariableHandler`. beekeeper also lets you extend the data MIME types that it can handle automatically, just by inheriting a handler class from `beekeeper.DataHandler`. This is especially handy when transmitting more complicated data structures. For example, to update a Hubspot contact in that API requires a JSON object to be sent in the following format: { "properties": [ { "property": "fax", "value": "555-123-4567" }, { "property": "nickname", "value": "Flamin' Fox" } ] } In beekeeper, all you need to do is set the default variable type to a custom "hs_contact", define a handler, and any additional `**kwargs` you pass will be automatically processed into the appropriate type. In bravado, because there's no way to hook into the logic, it's only possible to pass the entire JSON object at once, which, even if you build a custom handler to do it, means another call that has to be made. Essentially, what I see in bravado is a project that's doing a really fantastic job with what the Swagger spec gives it - which unfortunately isn't quite enough to make an API that really feels like it belongs in Python.
I like the third party integrations better and I like Slack's UI better. Also, it's useful for sharing code, if you need it for that. Edit: Found this interesting link. http://slackvshipchat.com/ One of the things they say is that the notifications are better. That's a huge reason for why we switched.
I think you're kinda missing the point there. If it's a REST API, chances are it *can* be deployed over HTTP. What I'm saying is that a REST API's design is independent of the communication protocol. It might help to consider the World-Wide Web. It's a pretty common misconception, but the WWW isn't "HTML over HTTP". It's an abstract information space with discrete, addressable resources. None of that requires HTML or HTTP, and in fact, the WWW gets along fine without either. Consider podcasts, which are Atom/RSS/MP3, or consider `&lt;a href="ftp://…"&gt;`, which works just fine without breaking the web. If a successor to HTTP or HTML came alone, the architecture of the WWW would continue to work unchanged because it's not dependent upon HTTP at all. 
Consider contributing to the [Orange Data Mining](http://orange.biolab.si) and [OpenML](http://openml.org) projects.
The notifications in Slack are the biggest reason I despise it. The HipChat notifications allowed me to turn off system notifications (which break my focus) for everything except named mentions and direct messages. There is no combinations of Slack notification settings that allows this.
Linux is my IDE :-) http://blog.sanctum.geek.nz/series/unix-as-ide/ My IDE is to have a couple of applications open: * Firefox for searching the internet, or getting distracted. * A programmer's editor, preferably with a tabbed interface. I prefer GUI editors rather than vim or emacs. I like the KDE 3 version of Kate, but not KDE 4, or geany. A tabbed editor. I prefer kate (KDE 3 version, not KDE 4), but geany is also good. gedit will do for quick edits, but I wouldn't want to rely on it for big jobs. * An xterm or console app, again with a tabbed interface. I like KDE 3's konsole, but any modern, configurable, tabbed console will do. Support for Unicode is a must. In the console, I have at least three tabs open (and usually many more): * At least one tab running the Python interactive interpreter, for testing code snippets, using interactive help(), etc. * At least one tab for running my code or unit tests. * Another tab for version control (hg or git) and other file management. 
&gt; I'm curious to see what a REST API looks like when it isn't over HTTP But as I said, a REST API is independent of the communication protocol, so its design looks the same whether it's deployed over HTTP or over another communication protocol. Hence the WWW as an example – you can load HTML pages over FTP and link to other pages accessed via the local filesystem, and it continues to work as it would if those pages were loaded over HTTP or any other communication protocol. Granted, it's not perfect – there are some layering violations where HTML assumes use of HTTP, but it's a good example of how the API design is the same regardless of communication protocol. &gt; I've implemented a RESTful API over HTTP but now want to deploy a similar API over a message queue system and its not working out well Could you give examples of the problems you are facing? &gt; Can you think of any more examples, please? Off the top of my head, only non-public ones. Generally speaking, HTTP is drastically over-represented in public APIs for a bunch of reasons, e.g. it goes through firewalls with ease, and it's easy to find developers familiar with it. 
Wow........just....wow.
If we take it at face value, no. `conf_path = "options.cfg"`. Paths are relative to cwd, so there's no need to get the cwd, get a directory in it, get the parent (still the cwd), then get the file. If we look at it conceptually, still no. There isn't really a reason you'd keep a reference to the configuration file around after reading it, so it should just be `conf = open("options.cfg").read()`, and if you're changing the cwd (which again, there's no reason to), you could just `os.path.abspath("options.cfg")`. Maybe you chose a poor example, but even so; I've never had a problem with `os.path.join`. I wouldn't mind if if the whole `os` module was more object oriented, but whatever, that's fine.
You can drop the abspath altogether: conf_path = os.path.join(os.getcwd(), "mydir", "..", "options.cfg")
It's 100% on usability for me. I've never had a better experience with code completion than VS's IntelliSense. The only things I've been able to trip it up with is weird imports. Custom importers and evals, that sort of thing. It's also really good about refactoring and reformatting, and finding references is basically instant and infallible. Also also, before I was forced to use PyCharm, I never realised how good VS's tabs and panes are.
&gt; Could you give examples of the problems you are facing? Basically the request/response cycle was taken care of via HTTP. With a message queue, you lose that. So one idea has been to delivery responses over the queue as well; with a reference code to which request generated them.
I really like PTVS, and VS in general, but mostly I find the differences don't impact me and I could use either. I certainly like both.
 print a +os.sep+ b +os.sep+ c
What things are you into besides prgoramming? Do you have any passsions?
You can opt for a VPS (you can find some at $5/mo) or a PaaS such as PythonAnywhere.
Is it a big hunk of code or just a few lines that need to read something somewhere? Python can run on a lot of devices. Like Raspberry pi or you mobile phone.
A fifty second slide show of JPEGs hardly constitutes a tutorial, let alone a complete one.
Why on earth are you adding mydir to the path, only to drop back to its parent? That's awful. "How do I get to the Post Office from here?" "Well, you drive to High Street, turn left, then follow the road for ten miles. Then turn around and drive back nine miles. There's the Post Office." Either of these will do: conf_path = os.path.join(os.getcwd(), "options.cfg") conf_path = os.path.abspath("options.cfg") 
Make an open shift app. Add a Cron gear. Flask for serving up a monitoring page / downloading the files without SCPing in.
I have done a lot of thinking on that exact topic, actually. I usually get at least 1 career offer a week and multiple contracting opportunities. I am trying to decide how to best organize it, but I would indeed like to play matchmaker. I have a decent amount of data based on user interests on site and completed tutorials to start with. I am planning to add a few more metrics (since you wouldn't do tutorials on a topic you were already an expert in), but I would like to give the ability both for employers to search for students, and students to search for employers on site. If you have any suggestions on how to make that work, I am all ears. In order for it to be successful past the initial stage, the metrics and whole thing needs to actually work. Employers need to actually find worthy candidates, not just worthless leads, and students need to find worthy employers, not just time wasters. For anyone currently in the job market, especially if they are on linkedin, recruiters are maybe the #1 complaint due to major amounts of time wasted based on lies...etc. 
You might want to look up using AWS Lambda: http://docs.aws.amazon.com/lambda/latest/dg/lambda-python-how-to-create-deployment-package.html Python is now a first class supported language there. Maybe save your data in an S3 bucket.
Oh i didnt know this exist. Thanks man :)
It's in the sidebar and the sticky. It's also above the text boxes when making a new post.
If it's for scraping, there's [morph.io](https://morph.io/).
No problem, but these kind of questions fit better to /r/learnpython 
What about a basic pong-like soccer game? Or get into Django and try out some web stuff. 
Python is a tool. It's a tool you can use to do almost anything. (Automate the boring stuff). The trick is to find jobs where you can use your tool sets remotely. I automate [dSpace benches](https://www.dspace.com/en/inc/home.cfm) and [Vector CANape](http://vector.com/vi_canape_en.html) with Python. The end goal isn't making something with python, it's making python do something that gets me my end result.
Cron job or I've seen a python lib called "schedule" used for this kind of thing as well.
ha, appreciated this: if first[0] == second[0] and second[0] == third[0]: (...) print "Surely, this is more improbable than the Big Bang (Theory's merciful cancellation.)"
If you're using pathlib in conjunction with os.walk check out [scandir](https://pypi.python.org/pypi/scandir). It was incorporated into the python 3.5 standard library and it's blistering fast compared to os.walk in 3.4 or 2.7, especially when running the script in a windows environment. 
Certifications are pretty irrelevant these days, just start automating things away in your normal life or build a web service or contribute to open source.
Everywhere I've worked looks at code that's shared on github (or bitbucket). It speaks much more highly to show the continued work and improvement with open source than it does to have some "qualification". The best qualifications are usually experience and ability to learn, nothing more. Edit: I'm in the US, and that's been across a few locations: Midwest and Western US, I doubt the east is much different.
Certs have no value for most Python dev jobs that I have seen. As somebody else mentioned, contributing to Free &amp; Open Source Projects can look good on the resume.
AWS EC2 has a free tier that is perfect for this. I have a ton of scripts running from a server that has no open ports but SSH from a specific IP. Super secure, and free. Can't beat it!
All good; keep it in mind for future.
I'm still kind of a novice. Can you explain what's bad about idle?
I can recommend AWS Lambda: [Using AWS Lambda with Scheduled Events](http://docs.aws.amazon.com/lambda/latest/dg/with-scheduled-events.html)
It's a bit old and clunky and doesn't look very nice. The user interface is a bit unfamiliar to many people, and some of the error messages when it doesn't work are hard to understand. But it actually is a decent, if old-fashioned looking, basic IDE.
Heroku actually has this feature. Once you have deployed the actual script on your command line type:: Heroku addons:create scheduler Then go to your heroku dashboard and click on the app you created(where you deployed your script). You should see the option for scheduler and then just specify when.
Came here for this. Used task scheduler for a job last year 
Yea, so most of the packages are free for a year only. But EC2 is free as long as you stay under 31.5 days a month. Which essentially means, if you have one microInstance server running 24/7 you will be fine! This stays free forever :) EDIT: Misread terms. Only Lambda stays free forever. Sorry!
You're a god. So I knew enough to already have pip's path set to the pip.exe in my Anaconda2 folder, BUT this was the issue: &gt;They probably each have their own pip, **and which one you're using will depend on which location is first on PATH.** I had like 3 different Pythons listed in my PATH and the Anaconda one was the last... So I was running pip.exe from Anaconda, but it was installing packages into my C:/Python. I just got fixed my Path to have Anaconda be first and now it works great. Things are installing into my Anaconda folder now and pip list brings up all the packages inside Anaconda. Pretty nice! Totally fixed. Thanks so much. 
[cron](https://en.wikipedia.org/wiki/Cron).
so would you say its very rare for python developers to work remotely for periods of at least a few months? By working remotely, I don't want to just work from home. I was hoping I could live abroad for periods of at least a few months And by web dev, you mean django is necessary to know for python developers?
That is crazy what are the downsides to this?
so would you say its very rare for python developers to work remotely for periods of at least a few months? By working remotely, I don't want to just work from home. I was hoping I could live abroad for periods of at least a few months
AWS offers a free EC2 micro instance free for a year to get you hooked into their platform. After that year you're going to have to pay $14 per month, if you plan on keeping the server running 24/7 [1]. I'd recommend looking into [DigitalOcean](https://www.digitalocean.com/), they have a $5/mo option which seems like a great option for what the OP is describing. Here's a guide [DigitalOcean vs. AWS](https://www.upguard.com/articles/digitalocean-vs-aws) Lastly, if you do decide you want to get going with DigitalOcean, here's a free $10 voucher (disclaimer: affiliate link): [https://m.do.co/c/80be98d229c2](https://m.do.co/c/80be98d229c2) [1] [http://calculator.s3.amazonaws.com/index.html](http://calculator.s3.amazonaws.com/index.html)
I got a foot in the door for a company that deals with analytics and big data. I just recently heard that data scientists get far less remote opportunities that web and mobile app developers. Thats why I'm now considering learning web app with python. By working remotely, I don't want to just work from home. I was hoping I could live abroad for periods of at least a few months
Working while travelling abroad is a more complicated situation. Timezones start being an issue. In addition, without a Visa in the country you're traveling to, it might well be illegal.
Get off my lawn
Lambda is certainly the most popular answer here, but I think it is worth also mentioning Google App Engine which also supports Cron and now has an option for Python 3, which lambda does not.
That job could similarly be a foot in the door for python dev
Well at my company, we're using Py3 from here on out because they're adding a lot of nice-to-have features. That said, our old code is in Py2 and when it came time to decide if we're going to transition, it pretty much came down to "Python 3 seems like a whole new language, that just happens to share a lot of syntax overlap with Python 2". If that's the case, then arguments can be made to just rewrite pieces (not the whole thing) in other languages---Go, Elixir, etc.
I was curious to what exactly are automating regarding those two websites?
I am not OP but I am also looking for an ICP library. I needed it for point cloud alignment which is what I think most people would need it for.
Ah... when you pass a python object to igraph it adds a ['name'] default dictionary where you can access the methods of the python object! GREAT. So, that makes igraph also pythonic. 
Thanks, this one's been good
Site looks really good for a second attempt at a website.The site definitely has a lot of potential and another community website is needed.
Sounds like you've indeed given it a lot of thought. I agree with ur logic that experts are not necessarily there doing tutorials. In this case the 'burden of quality' should first rest on job hunters I think. If u could encourage students to bring their best foot forward via straight up git profiles, that might be something employers could rely on. Then it's a matter of facilitating communication between the two by keeping it as simple as possible. Just a thought from my side too, though. I think you have a potential platform in your hands as long as the platform stays out of the way and just connects the two parties. You might have different ideas for it though. Thank you for replying.
Buy a raspberry pi and start playing around with it :)
I actually have 3 of those (1 of each gen) and a youtube channel with some tutorials lol. But, I get what you mean...I should do something fun with them. 
A $5 a month VPS on Digital Ocean is the way to go. It's much cheaper than Heroku and since you're not setting up any complicated scaling infrastructure you won't need the extras that come with Heroku, AWS Lambda and other PaaS (Platform as a Service) providers. I've got a referral link here - https://m.do.co/c/0b5b884cd05a - giving you $10 free on sign up (and some credit for me if you ever put credit into your account) or just go for the non-referral link: https://www.digitalocean.com (I don't think there's any free sign-up credit there just now but I may be wrong). Honestly, unless you need the scalability of AWS Lambda or Heroku (automatically scaling up or down to handle thousands of concurrent requests), steer clear of PaaS. For most purposes, it's very overpriced. Other VPS providers you could consider are: - [Google Compute Engine](https://cloud.google.com/compute/) - [Microsoft Azure](https://azure.microsoft.com/en-gb/) There are plenty of them our there. Just keep your code and data backed up and you can experiment to find the right provider for your needs.
AWS Lambda does support cron via [CloudWatch Events](https://aws.amazon.com/blogs/aws/new-cloudwatch-events-track-and-respond-to-changes-to-your-aws-resources/). Granted Python 3 is a second-class language right now, but you can subprocess or exec it from any of the other languages (Node.js 43, Java 8, or Python 2).
For a simple scheduled script, I disagree going VPS or any server/OS that you have to manage. That's the great thing about the serverless infrastructure of AWS Lamba or the equivalent Google or Microsoft offerings. With a VPS, you are responsible for patching, managing storage, logs, etc. I mentioned it above, but a script set to execute every 5 minutes has a total cost of less than $0.50. And if that's all your doing, it's under the free tier which *does not* expire after a year like other AWS free tier services. Plenty of good reasons for VPS instances, but for a small set of fire-and-forget scripts, serverless is what I recommend.
Just get yourself a minimal linux VPS and run your python script from the cron. AWS, Google Compute, Microsoft Azure etc have steep learning curves and are definitely an overkill for something as simple as what you want to do. There are many 15 dollars per year (seriously, per year) offers on low-end VPSes like [here](http://buyvm.net/openvz-vps/) and [here](http://serverhub.com/vps/ssd-cached).
What's with the random hashtags. Also, what is your question even. #hashtags #random #seriously #though #why
&gt; now has an option for Python 3 OH SHIT WHAT!!!!!!
I've done this exact same thing in the past, running off of my phone. Free, always on and when I would run it at night it always had wifi.
This will only work if the web scraping job takes less than 5 minutes, the current maximum lambda existence time. Another option is to set up an Elastic Beanstalk worker-tier environment with a crontab file that will hit various endpoints accordingly. This is more expensive, but depending on the use-case will have more configurability. 
I believe you want to unescape html returned by a program. Check [this example](http://stackoverflow.com/a/2360639).
Don't post screenshots of your code. Put the code on pastebin or put it in your post (prefix with four spaces to activate code formatting) Do post the actual error you are getting. The whole thing with line numbers and anything else python is telling you.
It may be quick for you but it means we can't easily test your code and find out, for example, that the parentheses on the constant input line don't match.
/r/learnpython is more appropriate. Also [stackoverflow](http://www.stackoverflow.com).
seems rare imo, definitely something the most desirable companies should do!
Posted it on there too, thanks :)
&gt; The free account is limited to 1 daily task hmm \*writes single script that invokes other scripts\* \*is a lawyer programmer\*
Rad, thanks!
I honestly haven't looked into Amazon Lambda, but if it's as cheap as you say, then that definitely sounds like a better solution. Let someone else handle the uptime and hardware.
[citation required] (I've googled this several different ways, and the only security exploit that anyone mentions at all is social engineering in a multiuser environment (getting someone to set their PATH to a malicious value) -- which they label as a minor concern.) After researching, the only reason I see to specify direct paths is if you KNOW what systems the script will be running on (and where their python binaries are). Even so, if those paths to the python binaries happen to differ between systems, you still can't get away with hardcoding the path. (virtualenvs probably also are relevant here, but as I stated, I don't know enough to comment what the correct thing to do for virtualenvs is) A more substantial reason to not use `env` is if you need to pass arguments to the command (isn't possible with env **in a shbang**).. Fortunately, for Python this is not usually needed.
look at openshift, they give free gears that are really handy. this small script of yours could be the perfect case where I would use it.
Although do not rely on Windows 10, I used to have a script run on my desktop but after a week or so Windows 10 would just turn off to install an update without my permission :(
Right, but if OP has only one script then that benefit doesn't exist. I have no idea how much Amazon would cost as I have a BBB that runs my local scripts and a Digital Ocean account that runs my remote scripts. :)
All the boring things. Software checkout with hardware in the loop integration. 
Used PyScriptor for a long time but then switched to sublime text 2, then upgraded to 3, for the past month or two I've been using PyCharm and am loving it. 
Grabbed the very first 360 spherical image today. Created a spherical panorama using PTGUI https://github.com/Open360cam/360CamHardware/wiki/Field-Testing
Just use a VPS and set up a cronjob. A micro-instance on AWS is free-tier. Just be careful you don't start experimenting with other services or launching new ones or stopping terminating and starting a new one - just get that micro up and leave it up.
Alright thanks
Thanks for taking a look at it! I appreciate it.
It's still rare for developers in general to work completely remotely. It takes a certain caliber level to be able to get projects and spec-work done without communicating with your boss and/or client directly. Still entirely possible for some people though. I know some people from college that travel all the time but still make a living doing work online. Just look for offers that accept remote work. You have to know your stuff though. Otherwise you'll be freelancing.
I agree, get a 2 way encryption going first, then $cp your modules to the default py folder on the host. Then start an interactive Python shell for parrots.
I'm currently using Idle, but the lack of a refractor and debugger has been killing me on the inside, and since a lot of people say that pycharm is good (and through research of all the options suggested) I think I'll be using pycharm (if I like it).
`plugins.load_plugins` is called each second. Is *that* the hot swap?
Yeah, hipchat is amazing compared to non-group chat things. But I would like to try slack; I'm no atlassian fan (though we use a ton of their stuff). It's good, useful, necessary... but always feels a little unfinished or weird.
Must go lookup Amazon lambda ASAP!
crontab
fabric, maybe?
Is it? Typing 'python' in 16.04 still gives me 2.7. Both are installed. I don't know how that makes 3 'default' or under what circumstances you're running a python script without it calling out a specific version anyway...
Only "on the server, cloud and the touch images" (out of, what, 12+ different images?). [Previous discussion](https://www.reddit.com/r/Python/comments/4fuywi/ubuntu_1604_lts_released_with_python_35_as/).
Took them only 8 years.
It looks like Pybind is a newer one to look out for. https://www.reddit.com/r/cpp/comments/4g73u7/pybind11_seamless_operability_between_c11_and/
Instead of `list of names, list of grades`, you probably want `list of (name, grade)`. E.g.: students = [ ('Turner', 94), ('Philips', 82), ... ] Note that I'm using tuples here to represent student/grade pairs, at some point you probably want to introduce a `StudentRecord` class to use instead. Anyway, written like that, any list operations on the whole list - sorting, slicing, reversing, filtering... - will always keep student names and grades together.
If you just wanted to run some scripts with lambda it would be near free(I think it's like .001 cents/minute). Additionally they have a small sever(close to pi in specs) for 3.50ish a month. As for your concern about getting blind sided by costs you can set up alarms in your billing for when it goes above a certain amount. Just in case you ever wanted to try it out.
&gt; Its telling me Nothing else Yes, it is telling you more. Notice how it highlighted part of the text? That's the point in the code at which the syntax error was detected.
Perhaps [Tryton](http://www.tryton.org/) (ERP) with [Flask](http://flask.pocoo.org/) (lightweight framework) via [flask_tryton](https://pypi.python.org/pypi/flask_tryton)?
Yes. Same happened for Cobol. Doesn't mean Cobol is not obsolete. Everybody wants to kill it. Something similar will happen to Python 2. This week, I gave a training in Python 2.7. The first one in months. It was painful. I had to explain the difference between xrange and range, iteritems/item/iterviews, why non ascci characters were crashing the VM unless you put some crypting comment at the top, the whole str is not str but bytes shenanigans, truediv, print doesn't work in lambda, avoiding relative imports pitfalls, yes you have to type super(AllTheNameOfYouClass, self), inheriting from objects, no you can't unpack there, sorry this var leaks out of the scope, arf, pip is not installed (what do you mean you don't have admin rights on your machine and you can't install it ?), oh nooo, don't compare strings to int it willl... work... ish..., os.path.walk is not the same as os.walk, from codecs import open, itertools istuff vs regular stuff... All that is gone with Python 3. It just works. 
https://beezwax.net/products/bbox is a plugin that will allow you to use Python from in FileMaker I'd suggest trying to use a solution out of FileMaker as I have had issues with plugins et. Having MySQL as the db and fm as the presentation layer is always my favoured approach as there are connections to MySQL from pretty much everything.
 import datetime import smtplib from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.header import Header from email import Charset Charset.add_charset('utf-8', Charset.QP, Charset.QP, 'utf-8') maillist = [] def send_email(messages_list, smtpUser=None, smtpPass=None, tls=False): failed = [] try: s = smtplib.SMTP('smtp.gmail.com',587) s.ehlo() if tls: s.starttls() s.ehlo() if smtpUser and smtpPass: s.login(smtpUser, smtpPass) except: print "ehlo failed" failed = [x[0] for x in messages_list] else: for to_address,from_address,subject,encoding,mesg in messages_list: try: if len(mesg) == 2: msg = MIMEMultipart('alternative') else: msg = MIMEText(mesg[0],'plain','utf-8') msg['Subject'] = "%s" % Header(subject, 'utf-8') if len(from_address) == 2: msg['From'] = "\"%s\" &lt;%s&gt;" % (Header(from_address[0], 'utf-8'), from_address[-1]) else: msg['From'] = from_address[-1] if len(to_address) == 2: msg['From'] = "\"%s\" &lt;%s&gt;" % (Header(to_address[0], 'utf-8'), to_address[-1]) else: msg['To'] = to_address[-1] msg.set_charset("utf-8") if len(mesg) == 2: part1 = MIMEText(mesg[0], 'plain','utf-8') part2 = MIMEText(mesg[1], 'html','utf-8') msg.attach(part1) msg.attach(part2) s.sendmail(from_address[-1], to_address[-1], msg.as_string()) except: traceback.print_exc() failed.append(to_address[-1]) try: s.quit() except: pass return failed maillist.append(( ['someone@gmail.com'],["Me","noreply@example.com"],'Subject','utf-8',['text_message','html but you can delete this list element'] )) for k in send_email(maillist, smtpUser='you@gmail.com', smtpPass='pwd', tls=True): print k, 'not delivered' Just use this function if you don't want to use a module. I always post this one.
Almost every Slack bot is a while True loop that stays running. Even the example has a 1 second sleep in a loop: https://github.com/slackhq/python-slackclient plugins.load_plugins checks to see if there is a new, changed or deleted plugin and calls the appropriate function. If nothing has changed on disk compared to what's loaded into memory then nothing happens. Currently for a new plugin it does the equivalent of a module `__import__` on the file. This isn't perfect as it would be better to be able to specify a folder outside of slactorbot for the plugins that doesn't need a `__init__.py`. There's functionality in ThespianPy to hot reload code via a zip file so I'm going to see how that works and maybe switch over.
Looks good, function names should be lower_with_under() though ;-)
This has been posted 3 days ago already with a decent amount of comments. https://www.reddit.com/r/Python/comments/4fuywi/ubuntu_1604_lts_released_with_python_35_as/
oh I see. i want to follow the conventions, because unreadable code is horrible, but I am a bit green with some things :)
Python is also strongly typed. I take it that you actually meant statically typed?
Sorry, but mentioning no sql, sql, and sqlite like you did makes it clear you don't really understand those technologies (the last of which is an actual product ). I'd read up more about them, along with key value stores. Otherwise, your best bet is probably sqlalchemy, which allows 3 or 4 different sql servers, including sqlite. 
Give Sublime Text a try. There are a few plugins you can install that add stuff like autocomplete. It's a great editor once you've installed a few plugins.
unit tests lacking in both cases :( edit: 14 people love bugs!
Do some research on Database Abstraction Layers (DAL) or Object Relational Mappers (ORM). As mentioned SQLAlchemy is a popular ORM.
What the license for this code?
Hi, a good list here: https://github.com/vinta/awesome-python
the link to fabric mentionned: http://docs.fabfile.org/en/latest/index.html which uses Paramiko
I grant MIT
PyCharm seems pretty popular https://www.jetbrains.com/pycharm/ That said, unlike languages like C++ or Java, Python isn't that dependent on a powerful IDE. Anything with syntax highlighting and smart indentation will do the trick. There aren't really any "industry standard"-IDEs that you have to master.
[halfway down the page, 2 days ago](https://www.reddit.com/r/Python/comments/4g0vp6/what_ide_do_you_guys_use_for_python/)
This question every bloody week.
Thank you bobspadger 
OK thanks alot, did some research and it seems as if that is indeed what I'm looking for. Is there a way to find out if this is indeed the piece of code that is being.. well... escaped? 
Oh. So exactly like before.
[pyInvoke](http://www.pyinvoke.org/) is the replacement for [~~fabric~~](http://www.fabfile.org/)
Do you know of anything that doesn't require this?
Django's ORM and SQLAlchemy both provide some of what you're speaking of (a standard interface to various SQL Servers), they both support at least Postgres, MySQL and SQLite. They do not, however, do NoSQL (there is a Django extension for Mongo, I believe).
"for the time being, all distributions should ensure that python refers to the same target as python2" I think that was what I was referring too. I only use Raspbian so what happens to pip? Do you have a pip3 also? On Raspian I tried updating the systems version of pip-3.2 but it broke and when reinstalling pip I overwrote the Python 2 version of pip. How do you install Python under a different name easily?
Your comment said: &gt; I think Arch Linux did it so [...] even though it said in one of the PEPs that you should not do that. What I tried to say was that the PEP didn't exist at the time Arch Linux changed the meaning of `python`. And yes, I have pip2 and pip3 side by side. 
I use digital ocean for a similar project.
I'm not sure I get it – the non-parallelized NumPy version of EM took 26.227670908s, whereas the best parallelized version (using openMP) of EM took 36.5230062008s. Isn't the whole point of this to show that we can do things faster with parallelization? I get that this was only parallelizing the log-likelihood calculation and that other calculations should be parallelized as well to show the full speedup, but I really don't get the sense that parallelization is practically effective in these examples.
Definitely networkx. It's super easy to use, has a ton of algorithms built in, and it can handle thousands of nodes. 
Yes, add code and try it.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Oh yeah, I agree. But also remember most people should be valuing their time but tend not to do it. It dramatically changes the calculus when you start thinking about all the crap you're going to have to deal with yourself. For example, buying a pre-built NAS that also runs VMs and a media server was waayyyy easier and cheaper than building one myself when you factor in the time to order parts, put it all together, install software, etc. And then there's the part where when the OS acted funny I got a free replacement device within a few days versus having to debug it all myself.
There is also [python-emails](https://github.com/lavr/python-emails).
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
I was trying to automate something crazy small a while ago and figured I'd do it the "right" way. After hours and hours of struggling through OAUTH bullshit for a command line app I just gave up and changed my account to allowed "less secure" access. 
Would you be interested in gisting it and refactoring a little so it's easier to plug'n'play? Changing magic strings to constants at the top etc.
What's actually the problem with this? I think it's very clear what's happening. Accidentally attaching a file when you want a lone file name seems pretty unlikely. Using Path would be an improvement, but I don't think the current method is so bad.
If this was a github repo, maybe. He posted his code as a reddit comment so I don't know why you feel the need to bother him futher
Public APIs list, good luck. https://github.com/toddmotto/public-apis
I wrote a testing framework that supports multiple backends for logging the results, and this is something you have to do yourself. Basically, you create a class `BaseBackend` and inherit from it for your different targets. As long as they all have the same methods, it doesn't matter which one you call because the custom class handles the specifics. class ResultsBackendBase(object): def __init__(self): self.name = self.__class__.__name__ def log_success(self, details): raise NotImplementedError def log_failure(self, details): raise NotImplementedError def log_exception(self, exc_info): raise NotImplementedError @property def connected(self): raise NotImplementedError
I'm genuinely curious as to why one shouldn't write an app as customizable as possible. Is it because of possible scope creep later on / maintenance of a larger code base? What if strategic customization options provides you with an advantage over other similar apps?
&gt; I wonder if part (if not all) of the reason for that is because Python has great support for easily sorting your data types when needed. There is a pretty big difference between having an already sorted object like a B-tree, and having to call `sorted` anytime you want to walk the tree. The B-tree has potentially slower operations in general, but guarantees that you can always walk the tree in sorted order at no additional cost. If you want to just call `sorted` on a dict you will pay the cost of sorting every time. The bigger issue here seems to be the fact that things like dict/list/set have C implementations instead of pure-python implementations which makes implementing a composable containers interface harder, and that in turn has discouraged the creation and use of the variety of containers used in other languages.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
In general, try and only have one python installed at a time, wipe the others. Removes the possibility for a whole class of confusion when installing things.
Dunno man, seems like your ogg file is borked. Ffmpeg converts whatever amount of audio data is in your source file. What does ffmpeg -i yourfile.ogg print? What if you convert it manually (ffmpeg -i yourfile.ogg result.wav), is the result what you expected? Maybe the ogg file has a large silence encoded at the end?
I like to keep code simple for my server-side scripts when I need to send nice email to admins. I'd love if someone would expand on the function and write a full module, but my work is needed elsewhere :). https://gist.github.com/andrew-azarov/dc17c1ad5d4f24f035bd0f9e63ca7563 EDIT: Updated GIST a bit more, feel free to use.
Read this: https://docs.python.org/2/library/signal.html 
Yep. I didn't provide example of trying to sort a set, but SortedSet is one of the classes provided by this package, apparently. "sorted set" is a quote from that site, not from me.
&gt; sudo pip install hogwatch never sudo pip install
&gt; "some text brand1.png logo2.png" Why is that a text, and not a filename?
There's also the `joinpath` method for those of us who aren't a fan of `/`.
Even cheaper than a Raspberry Pi, for $10 you can get a [Pogoplug v4, and with an old SD card and about an hour of your time, you can load Debian on there](http://blog.qnology.com/2014/07/hacking-pogoplug-v4-series-4-and-mobile.html); while the Kirkwood processor isn't super powerful, if you're doing work that's simple and I/O bound, it's an excellent, expandable, cheap choice. Just use a cronjob with whatever system you pick, and you'll have something that's dead simple and works well.
thanks. I'll look into it.
&gt; that's the wrong approach. you lst.sort() after every bulk of insertions. That only works for lists. Often, I want to iterate through a dict or set in sorted order. Plus, having to remember to manually sort the list regularly is clearly more error-prone; you might forget to do it on the last iteration, for example, and then later on, walk through the list expecting it to be sorted.
No unit / integration tests?
If you want to use Paramiko I have some classes that can serve as a solid advanced example - including capturing exit status, standard error, standard, out, etc... https://sourceforge.net/p/coils/coils-code/ci/master/tree/coils/logic/workflow/actions/ssh/ 
http://datastore.readthedocs.org/en/latest/ It only has a few operations, since more advanced operations work very differently in different datastores.
The dialect support in SQLAlchemy is amazingly broad; I construct complex queries and use advanced features, it hasn't been a problem yet. And if you want to break out to a native connection - where you implement support for different databases 'by hand' for some feature - that is easy to do do.
So? Nobody is saying you can't implement basic data structures in python. It is rather that they are not included by default. And part of the reason they aren't included by default is that you would have to wrap things like dict/list (depending on what kind of structure you want to end up with) which is hard to do correctly because those structure don't expose their entire implementation to python since they aren't pure python. Alternatively you could write a pure-python version of these structures using the other structures as private members... and performance will go to shit... which defeats the purpose of implementing these data structures in the first place.
it can kinda be done. tkinter is a little under-engined for what you might want to be doing. you can use the filedialog part of ttk to pick out and open a file, then use raw python to read that file and display it to a text window within the tkinter master. your GUI will grow unless you set it to be a fixed size, as the text widget will want to display the document in its entirety. 
If I want a list, sure. But if I want a map... I can't lookup by key, I can only lookup by position. So sure I could write a binary search tree with a list as the underlying storage method, and use `.sort()` to handle inserts, and it wouldn't take all that much code to write... but then the performance of the lookups relative to the `dict` class is probably going to suck because of the pure-python implementation of the binary search.
Or just inherit from `UserList`, `UserDict`, etc as needed. I have a sorted deque implementation that is 17 lines long, for example. It's really not as much work as you're making it out to be. 
Okay, good to know. I took your advice and uninstalled the ones I wasn't using. Wasn't using the others anyways! 
Do I have to have the Spotify app installed in order for it to work? I installed in my OSX, where I don't have the spotify app installed and it did not play any songs. The error I get is: &gt; 22:32: syntax error: A identifier can’t go after this identifier. (-2740) What am I doing wrong here?
Did I say it would take a lot of lines of code to do this? I'm saying the performance is problematic. `UserDict` is ~5-6x slower than the c implementation of `dict`. So before I subclass `UserDict` in order to replace a bunch of instances of `for k in sorted(dict_obj):` with `for k in dict_obj:` I have to ask if paying the 6x penalty on insertions and basic access will be made up by the gains in not having to sort when walking the full tree. The people who really care about having things like proper Red Black trees are those who cannot afford to call: `for k in sorted(dict_type):` every time they need to walk the tree, but they also cannot afford to wrap every single insert into a UserDict to ensure that the data is sorted. So basically they cannot use python, which means that python doesn't get these structures in its standard library because anytime they come up they get implemented in some special c library and exposed in limited ways to the interpreter. In [1]: import timeit In [2]: import collections In [3]: def ins(num, d): ...: for i in range(num): ...: d[i] = i ...: In [4]: timeit.timeit("ins(100, {})", globals=globals()) Out[4]: 11.100580295780674 In [5]: timeit.timeit("ins(100, collections.UserDict())", globals=globals()) Out[5]: 57.22800435498357 
According the docs http://www.grantjenks.com/docs/sortedcontainers/implementation.html The structure performs well up to 10,000 * 10,000 elements = 100M. That is not so large structure - if it contained unique numbers I think that would mean 100M * (8 per pointer in array + 16 per python int instance) = 2.4 GB RAM. Is that something which prevents to scale the structure for larger volumes?
If you care a lot about time complexity that is insufficient. `sortedcontainers.SortedList` has `O(log n)` insert, but your method has `O(n)`. Because `O((n log k)/k)` where `k` is the size of each bulk of insertions ends up being `O(n)` for all `k`.
Though this may be a good source on list indexing and slicing, I'm disturbed by the use of a list to store key-value pairs...
they could use an `OrderedDict` (the ordering of which is implemented using two deques) or a similar implementation that uses bisction to insert the keys in sorted order instead of insertion order. Your example is not a good one because the premise is based on the idea that people who are interested in performance are also going to rely on naive solutions. I don't buy it. Most of them are probably not going to be best served by a self-written implementation, either. They're more likely to turn to SciPy's KDTree or some other performance-oriented implementation. Not everything needs to be in the standard library to be useful. It's important to remember that once something is *in* the standard library, it's more or less stuck as-is until the next release cycle, which may not be great if the implementation isn't sufficiently mature.
Have a look at aubio: - https://github.com/aubio/aubio - https://twitter.com/aubio/status/724644954891538435 - https://aubio.org 
Having a very dry sense of humour I've so enjoyed reading the comments here. I can only assume that some people have never bothered to read the testimonials to sortedcontainers. Further I doubt that those people would understand the prestige within the Python community of the people making those testimonials. What do you want on it for a freebie, blood?
I used pydub, it has a pretty simple API.
I'm a bit late, but if you're on Windows, Task Scheduler is a breeze to work with! I do virtually this same thing!
The bisect module has a C implementation of binary search, actually.
I think the [Python Database API Specification v2.0](https://www.python.org/dev/peps/pep-0249) should be your starting point. If you want a lightweight ORM just to get you going try [peewee](http://docs.peewee-orm.com/en/latest/index.html) or [ponyORM](https://ponyorm.com)
Thanks! 
In what language is Kdtree written?
Attendance at PyCon is capped to keep it small and relatively intimate--it's a generally feel-good community focused event. And it's almost entirely run by volunteers who work their asses off. I love PyCon and I don't want to shut out people and pretend like it's some super exclusive club that only the cool kids get to go to. But I would fly into a rage if PyCon started having trouble because of a [free rider problem](https://en.wikipedia.org/wiki/Free_rider_problem). **Please, respect the volunteers that work so hard to hold this event--don't look to actively exploit their efforts.** All of the PyCon sessions will be posted online as they have been for years. In fact, the first videos usually appear online before the conference is even finished. Watch the videos online and make sure to register for PyCon 2017--as an avid PyCon attendee I'd be happy to welcome you next year. /edit a word
Registration is now closed, so the only options are not attending or or attending unofficially. I'm not seeking to exploit anyone. I've organized several conferences myself and am sensitive to the issues.
It's because you are passing `button_calc()` as an argument to the `Button` constructor. `command=button_calc()` executes the function and assigns the result to command. You want to just pass the function as an argument, ie `command=button_calc`
Damn computers are pedantic. But thank you thank you thank you! I just tested it and it worked. Thank you!!!
nums.readline() only reads the first line of the file. You should iterate over 'nums' itself, instead of 'file_string', as that will iterate through the lines in the file.
Yeah... that's not going to be terribly helpful... That's like someone asking if it's possible for one man to move Mt Everest 1,000 km away with a shovel and wheelbarrow, and you point out a trick that lets him use two wheelbarrows... The attack you linked to means that rather than having to guess from 2^256 possible options, he "only" has to guess from 2^231 possible options (assuming ideal conditions for the attack). A modern computer could, in round numbers, make maybe a billion guesses per second. That means it would take 10^53 years to exhaustively search the whole keyspace. Seeing as the universe itself is a little over 10^10 years old, that's still probably longer than the OP wants to wait.
If you find a practical known-plaintext attack on AES, forget your friend's files, you'll be rich and famous.
solved actually, thanks though. I created a list of each line and then iterated through the list of lists haha still have a lot to learn!
http://stackoverflow.com/questions/5953205/sorted-container-in-python
blist has the logarithmic guarantees you want.
Python is telling me you really want 8 + 32 bytes (or just 8 + 24 for Python 2). That means 4 GB of memory use, not 2.4. But this isn't entirely complete either. Most containers have overhead. SortedContainer's overhead is rather slight; I think it's about 4 bytes per value. But an actual tree, like most of the C implementations, would have a lot more. The case of storing 4 GB of sorted, garbage collected Python integers is niche. If you're using PyPy you'd *probably* be fine, but why service a use-case only PyPy users will ever care for? Though, if you really need, scaling beyond this probably just requires adding another layer to the "tree".
IPython
After consistently outperforming the Java teams with half the manpower and a high-profile explosion with a few teams trying to move to Scala, Python has practically sold itself at my work. ¯\\\_(ツ)\_/¯
sortedcontainers does outperform blist on some access patterns, but sortedcontainers is definitely *asymptotically worse*. blist is implemented as an actual B tree, which guarantees that searches, sequential access, insertions, and deletions are done in logarithmic time. sortedcontainers cannot do insertions and deletions in logarithmic time.
One use-case that I've hit a lot is when I need to find the *nearest* actual key on either side of the requested key.
BECUZ AWS IS LOVE AWS IS LIFE
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
I pretty regularly use variations of this in my code, so I figured I would generalize it and share it. Just set up a Mailgun account and you're good to go. No need for an SMTP server on your machine, and no overkill libraries either. It does require `requests`, so it isn't pure Python, but whatever. 
Have you checked out RPyC? You can remotely call procedures on a middle box, wrapped in an SSH connection &amp; have the middle box use paramiko to get to the final destination.
You won't notice the `O(sqrt n)` aspect because of the *really good* constant factors. Strictly speaking, with a static load factor the insertion cost is `O(n)`, but the recommendation is to increase that as the size increases: &gt; By default this factor is 1000 which seems to work well for lengths up to ten million. Lengths above that are recommended a load factor that is the square root of the average length `SortedList` is a depth-2 tree. The bottom-most nodes are sized by the "load" factor and are stored in another list of lists. Consider a length-10k `SortedList`. Since the load factor is 1000 by default, the list-of-lists is tiny (10 long). This gives a running time dominated by the cost of the insertion into lists of length 500 to 1000. When you move up to a length-10M list, the load factor is *still* 1000. You also only need to do a linear insertion into the list-of-lists (10k long) once every ~500 insertions. This means the cost there is still pretty small relative to the main insertion. When moving to arbitrary-length lists, say `k`, if the load factor is left unchanged the insertion is still into a length ~1000 list, but every ~500 insertions you'll need to do an insertion into the length `k / 1000` list. This has a cost `O(k / 1000 / 500) = O(k)`. That's partially why the recommendation is to increase the load as you get to obscene list sizes - if you use `sqrt k` as the load factor the insertions are `O(sqrt k)` and `O(k / sqrt k / (sqrt k / 2)) = O(1)`, roughly. On doing the numbers I just wrote above, I realize that if you were to use `cbrt k` instead your time complexities would be instead `O(cbrt k)` and `O(k / cbrt k / (cbrt k / 2)) = O(cbrt k)`. I'm not sure why that's not recommended instead. And, indeed, my own testing shows this to be the optimal solution for a variety of sizes. See http://www.grantjenks.com/docs/sortedcontainers/implementation.html for reference.
This article doesn't tell the whole truth. It definitely corrects the myths, but makes up a lot of spin to put Python in a more positive light than it deserves. Here's my deconstruction With #1, Python is an old language, sure, but it hasn't become a quality language until version 3.0 (2008) and even then, the community was fractured between 2 and 3 for many years and only recently has version 3.5 had proper type-hinting support. (a hugely important feature with a dynamically typed language.) And only recently are people coming around to the fact that v3 is a far superior language than v2. With #2, yes and no. Sure it's compiled somewhat, but a lot of it is (typically) still interpreted at runtime. In contrast, C# (because it is a statically-typed languages) can be optimized further than Python and runs faster as a consequence. With #3, Agreed. Generally. Although the fact that there are no private and protected in OOPython still bothers me. With #4, semantics. I'm not touching this one with a 10 foot pole. With #5, True, but this topic is a classic misunderstanding: Weak vs Strong, Static vs Dynamic. Two different, yet loosely related concepts. Of course, the author glosses over everything and says "oh, look Python is Strong and Dynamically typed!" (as if weak and static is lame or impotent. But they're not. They're just adjectives that don't mean what they sound like.) As mentioned before, because Python is Dynamically typed it prevents the compiler from making smart optimizations. Also, you find out about all your typing errors at run-time. I honestly consider this a weakness of the language. Especially when you're trying to write Enterprise class code. It also requires you to write far more unit tests that Statically typed languages don't have to cover because the compiler will catch them for you. The trade off is you get a certain amount of extra flexibility. Whether you need that extra flexibility is up to you. Most programmers don't, although they think they do. With #6, Interpreted Python IS slow compared to other byte code languages, like C#/.NET -- That said, Python's performance is good enough for most tasks. And as the author pointed out, you can compile it and optimize it further with things like Cython. Can't really speak to #7. With #8, a co-worker of mine tells me that they've finally fixed the multi-threading issue of Python. About time. EDIT: Another reader tells me it's still broken. Not sure which is correct, but true multi-core/processor multi-threading has been broken for awhile. With #9, no Python programmers are not scarce. Good Python programmers ARE scarce. In fact, good programmers are just plain scarce. Python has, indeed, become a popular language. With #10, I can't say, but the numbers of the quote don't add up. Bank of America claims to have 10mil lines of code and 5000 Python programmers. That's 2000 lines of code per programmer. I wrote 2000 lines of Python code in the last month alone. This is a terrible quote And the quote that takes the cake: "Our most common success story starts with a Java or C++ project slated to take a team of 3-5 developers somewhere between 2-6 months, and ends with a single motivated developer completing the project in 2-6 weeks (or hours, for that matter)." Hahahahaha. Riiiiiiiight. That's just awful. Now I definitely don't believe this article. Projects fail for a variety of reasons. Chances are it wasn't the language. Java, C++, and Python are all capable languages. It wasn't the language. So in conclusion, yes, the author corrected some important myths, but simultaneously put some fancy "rah rah go Python!" fan-boi spin on it while fixing the myths. Read this article with a grain of salt. 
OP, could you just please listen to everyone who is trying to tell you implicit attachments are a really really bad idea? You keep insisting on doing it inline, but it's WRONG. Consider: "Hello {name}".format(name=name) If 'name' is something user-submitted (like it almost always is), you HAVE to check if that file exists. Or you should make sure you're executing in an empty cwd. But how's that simple? Not only that, but you waste 2N system calls (with N number of pieces), because first my code has to check if the files exist, and then the library has to do the same. It's just bad practice. Don't do it.