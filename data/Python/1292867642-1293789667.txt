This is interesting, I get 'Google' with a[:2] + a[8:9] + a[10:13] With or without the period.
return "" if len(s) &lt; 2 else s[:2] + s[-2:] (didn't submit as formatted text since the &lt; kept being replaced)
Ack, that was dumb of me. I didn't see that you did it by just grabbing the "o" and then "gle"; sorry, it's early. Your solution is indeed perfectly valid and now I've made an ass of myself... Omelet sounds good right about now.
Sure. It starts off fine, but then you get here: class BinaryTree: ... def get_root(self): return self.root which is unnecessary and not idiomatic in Python. Just access the attribute ".root" from the instance ala "mytree.root". Then there is the "insert()" method. It makes more sense and would be cleaner and simpler to have the body of the "bt_insert()" helper function just be part of the "insert()" method. Even though it is being called recursively, that's no problem for methods. The point is, there's no need for helper functions that are only being called with certain objects as arguments: just make them methods and have access to "self" and the object's attributes via it.
what is this google python examples? I want to actually start doing stuff in python over the break (already know two languages)
&gt; [...] which could be avoided by writing my on queries by hand? I use SQLAlchemy a lot also for "hand-written" queries. It's so much nicer to programmatically modify the query-objects using `sqlalchemy.sql` than dealing with strings. SQLAlchemy rarely gets in your way, though. It's designed to make it easy to roll your own SQL.
What are these examples?
I am about a third or so done, for a plugin are you thinking like a "latest bookmarks for me" widget? Otherwise I was going to gpl3 the code
I get your first point regarding get_root. bt_insert is defined outside the class so it can be used by passing the root of any tree. You can do: tree.insert(1) or bt_insert(root, 1) root being the root node of any tree. Thanks for your feedback. I will update a new version soon which should be less confusing as it is a tutorial after all.
Not sure what you mean?
Would CherryPy 3 be a good compromise over plain WSGI?
no, you've been very helpful. your exercise was good morning thinkin'.
Do you find this easier to read? I don't, really.
Okay. Just wanted to point out that s[0] == s[:1] is not correct.
I will buy every original SQLAlchemy 0.1 user who's stayed on and upgraded all the way to 0.6 a beer at Pycon this year, for those who are coming.
Op is more understandable, not everything has to be a one liner.
modded up 4 free beer
that is what the problem asks for
*raises hand* I even have the SA 0.1 docs printed still on my shelf. Although, I won't be at Pycon. :( When people ask me "What is good software design, Pythonic or otherwise?", I send them to the sources of SA and CherryPy. I think we owe you a beer.
You're about to be the complete opposite of clucked. SA is built out of a few interdependant modules: **db interface layer** - nice abstraction on top of the python dbapi * can use it to do raw sql queries * or can use one of the higher level modules **schema definition layer** - rich set of objects to represent your sever schema(s) * can use it to define your server schema * or can just have it "reflect" the existing schema (no work for you) * don't have to use it (except if you use the higher-level modules below) **expression language** - python OO framework for building sql queries * don't have to use it * if you do, requires the schema definition layer * frequently much nicer than hand-coding sql **object-relational mapper** - the heart of SA, binding objects to classes * uses all of the above modules * doesn't have to be used The nice thing about SQLAlchemy is that you don't have to commit to making one of the above choices on a per-program basis. You can make one choice, and then 5 lines later, use a completely different choice, and the code will basically work together. This is also just a vague overview of the architecture, there's actually a lot of gray areas and hybrid methods which let you do things even more efficiently than one above modules alone. edit: The [SQLAlchemy Overview](http://www.sqlalchemy.org/docs/intro.html#overview) paints the above component picture pretty well. I also should mention [Elixir](http://elixir.ematia.de/trac/wiki), a nice declarative layer on top of SQL Alchemy, takes care of a lot of schema &amp; orm setup for you (haven't used it myself, but I've used similar layers before, and liked them). edit: maybe "clucked" instead of "fustered" will stop me from being downvoted :)
what a nice old lady.
Unlike ruby, ints and floats in python aren't full fledged objects with functions. Thus, there's no such thing as 1.is_odd() or 4.5.round(), however strings are (think "string".upper() or .join() etc). My point isn't that this simplifies the grammar, it's that it makes things more consistent. I apologize if my comment implied this was the only reason. I don't think consistency was the only factor in this decision. There are other things to .format() that other commenters have already pointed out (additional functionality being a big one).
You have to understand that the operators are basically shortcuts for functions in the operator module. `1 + 1` is equivalent to `operator.add(1, 1)`. You can create your own class of custom numbers and you can add them together (with `myobj1 + myobj2` or `operator.add(myobj1, myobj2)` ) so long as you define an `.__add__(self, other)` method. Strings happen to have an `__add__` method internally that does concatenation, so there's no reason why + for strings is bad. Now, you could argue "why not just get rid of all operators and use the operator module". I would respond that 1) your code now becomes more verbose, 2) people aren't used to that, 3) you have no added benefit/functionality. (edit: darn you markdown!)
aha! you're right, I've seen that before, but don't use it often enough so I forgot about it. In this case the way you posted may be more handy if you're dealing with a dict of values to substitute, whereas if you have a list the other way is more convenient... of course you could always do .format( yourdict.values() ) edit: nvm that would get hairy and buggy
I've been on since .3 I think and I'll buy you a beer. Or some elaborate beer cost offsetting scheme.
I suggested it after the OP of the thread questioned the need for two returns. I personally find the style easier to read, and the it gives the OP an alternative.
Given that the OP of the whole post didn't understand it, it was worth presenting an alternative.
&gt; After I installed 2.7 I switched to .format cold-turkey. good for you! i am still working with 2.6 (not my decision) and not pydev (my decision) ... thanks for ther {}-tip, though.
&gt; I wouldn't use join if the number of items is a small constant like i said, i would not either. this is an example to show what can be done.
i can assure you, i did not *guess* which one is faster. thanks for documenting a way to easily benchmark and not just pointing fingers. what python version and platform did you use in the test? EDIT: example modified to avoid int-&gt;string conversation, because a lot of time is actually lost there (i know %s does that too, just showing the difference without it): $ python -m timeit -s 'a = 10' '" ".join(["Donuts:", str(a)])' 1000000 loops, best of 3: 0.517 usec per loop $ python -m timeit -s 'a = "10"' '" ".join(["Donuts:", a])' 1000000 loops, best of 3: 0.246 usec per loop EDIT2: removed tests with growing lists. where supposed to show that longer lists are faster with join than with %s, but results of the %s varied a lot. 0.4-1.2 ... so I just let it go.... :) EDIT3: %s is not a typo... it is the plural of % :)
SQLAlchemy is designed to replace clusterfucks, not to create them. SQLAlchemy is pretty much the best thing since sliced bread. I finally got sick of dealing with multiple databases myself (and switching between them, which is a nightmare). I just started to learn SQLAlchemy somewhat recently, but I have already used it from start to finish on one project, and it really takes almost all the pain out of the database layer once you get it set up and running. The only complaint I would offer is that sometimes there are too many ways to do the same thing, and the tutorial documentation does not always seem to use a consistent approach, instead opting to show you the many different ways you can come at the same problem. That's nice to learn the different ways so you can pick which one you prefer. But in a tutorial I'm really looking for a lot of hand holding, and I would prefer it to say "this is the way you should do it right now" so you can end up with a nice, consistent, pythonic structure and leave the other alternatives for some other time. But that's a fairly minor quibble compared to the amount of utility that SQLAlchemy provides. Highly recommended. It will not bite you in the ass, it loves you, and you will love it.
What version of python are you using? If you downloaded python3, print became a function, not a statement. Try: print("hello")
you are using python3 then, try print("hello") or use python 2.x
http://stackoverflow.com/questions/442352/python-2-vs-python-3-and-tutorial/442397#442397
That is great! Just last night I installed 2.7 on my Win7 box. It's my first time diving into anything beyond html, css, and some basic javascript. Seeing things work have been a big motivation to keep going for me. I never thought I would enjoy something like a Python more than something like markup. Especially coming from a desktop publishing back ground. Keep at it! If you're having as much fun as I am being completely clueless, it's something to keep at and not pass by...if that makes any sense?
This post made me register. I'm interested. I have limited time, little experience in web dev but the idea sounds like a cool project. You could also contact the author of blueslug.com.
Thanks for the breakdown of SA. Looks like I'll definitely be investigating this further tonight.
I'm pretty sure I owe you a beer.. or 24 justin@oldbox ~ % find ... | 'other unix stuffs here' SQLAlchemy-0.91alpha-py2.3.egg SQLAlchemy-0.1.0-py2.4.egg SQLAlchemy-0.1.2-py2.4.egg SQLAlchemy-0.1.4-py2.4.egg SQLAlchemy-0.1.7-py2.4.egg SQLAlchemy-0.3.4dev_r2321-py2.4.egg SQLAlchemy-0.3.4-py2.4.egg SQLAlchemy-0.3.7-py2.4.egg SQLAlchemy-0.4.0beta6-py2.4.egg SQLAlchemy-0.4.0-py2.4.egg SQLAlchemy-0.5.3-py2.5.egg SQLAlchemy-0.5.5-py2.5.egg SQLAlchemy-0.6.1-py2.5.egg 
I love using the google challenges! I'm learning python myself right now and finished this one a week or two ago :) great job
But that's two manta ledders to spelt out ( iPhone auto-correct died a little inside Its logic core to tap this out )
print('hello') works great! Thanks!
Works! Thanks.
This tutorial has been updated with only the class Node to simplify the methods arguments list: ie: no need to pass the root node.
You could use the [official Python SDK](https://github.com/facebook/python-sdk), which uses the new Graph API. It does not have the exact functions that you want (it has a more future-safe style, and so uses *get_object* instead of *get_status*), but you should still be able to do what you want.
http://code.google.com/edu/languages/google-python-class/
http://code.google.com/edu/languages/google-python-class/
I personally prefer it baked with a cajun rub.
One good library is [Python Twitter Tools (PTT)](http://mike.verdone.ca/twitter/). It does OAuth. It includes a handy command line client, which also serves as example code for how to use the library. 
I've been using the [GAE data store](http://code.google.com/appengine/docs/python/datastore/entitiesandmodels.html) lately and come to like its API: #lookup: app1 = Application.get(however_you_look_up_things) #update, but don't store it yet: app1.name = 'hello' #instantiate a new one, but don't store it yet: app2 = Application(name='world', foo=1) #store: app1.put() app2.put() #remove: app1.delete()
Yes.
I think it's a fine starting language. The syntax is about as understandable as it gets and you can model most, if not all of the classic data structures that you'd find in a more advanced course (for learning I mean). C can be pretty daunting to a beginner. C was one of my first languages but I really wish I could have learned through python. If nothing else it gives a great perspective on the big picture of development. 
don't you think that a firm understanding of memory management is what makes c/c++ such a powerful starting language for real computer scientists/programmers? just because something's "hard", doesn't mean it's bad. ps. i love python btw.
I'm not exactly sure what you mean by "external resource". But, I think what you might be looking for is similar to an ORM (Object Relational Mapper). Except you probably aren't mapping something "Relational". Take a look at the documentation for Django Models, or SQLAlchemy, to see sample API's.
How is that going to help with Facebook?
You can have Twitter automatically update your Facebook status, so PTT could update them both...
Can you point out a python book that isn't bullshit? Serious question here since I'm on lesson 4 of Learn Python the hard way and I do not wish to waste my time.
If it makes you feel better, I upvoted you for trying to help. Also I never know enough about Python, so thanks.
It runs OK for me, but then I was only using a single core laptop. I read the docs and assume that it will be auto-paralleled on a multi-core machine. If this works then it is even more reason for my next laptop to have multiple cores. (preferably eight ;-) - Paddy (original poster).
My advice would be to not reinvent the wheel. Tim Golden has already [wrapped a lot of the Windows stuff](http://tgolden.sc.sabren.com/python/). Combined with that and win32xxx, you shouldn't have to wrap much Windows stuff yourself.
This is a typical model used by ORMs [in Python]. Maybe `save()` instead of `put()`, but whatever makes sense..
 def donuts(count): num_donuts = str(count) if count &lt; 10 else "many" return "Number of donuts :" + num_donuts 
Try replacing for text, timeStamp in textList: secs = int(timeStamp)/1000 a.write ' %s %s % (time.strftime("%a %d %b %y %H:%M", time.gmtime(secs)), text) a.write with for text, timeStamp in textList: secs = int(timeStamp)/1000 a.write '%s %s' % (time.strftime("%a %d %b %y %H:%M", time.gmtime(secs)), text) 
I'm not saying you should delete it, I'm just saying it's preferable to use the first version.
LOL no 
Why should I switch from Eclipse to this?
Because Eclipse is wank.
Nope.
Cool. I'm hoping HTML5 will be the Flash killer. Javascript is getting ridiculously fast, but its WebGL that I'm most excited about! How far along is your engine? Anything I can look it?
Ints and floats _are_ proper objects with methods, as can be demonstrated by the fact that you can do `(4.2).__add__(3)`. What you meant to say was that numerical types are conventionally acted upon by operators and and that strings are acted upon by methods and that `%` was depreciated in order to strengthen this convention. I understand your point and I don't disagree with the new practice of `string.format()`. I was just pointing out that what you said (as opposed to what you _meant_) was incorrect.
I am aware of all this. If you can argue that `'string' + 'string'` is acceptable because it is done via a `'string'.__add__('string')` method call, then why can't you argue that `'%s' % 'string'` is okay? Because that too uses a method call: `'%s'.__mod__('string')`. Again: I'm not advocating any particular usage (In fact, I agree with you that `format` is the better option). I'm just pointing out that the argument being put forward is flawed.
And thank Gods for that. As useful as the logging module can get, the documentation has been abysmal so far. Good to see the standardized format and proper tutorials.
&gt; a.write ' %s %s % (time.strftime("%a %d %b %y %H:%M",^here. Hmm? a.write(' %s %s' % (time.strftime("%a %d %b %y %H:%M", time.gmtime(secs)), text)) 
Anybody using this ? i am still thinking of getting some good IDE for Python but Eclipse seems very heavy weight for me (ie. probably good for big projects, not ideal for quick hacks)
Pycharm is good. 
Sound fun, I might try it out. My current editor is Editra, and aside from that, Vim. Eclipse seemed to bloated and Geany seemed annoying to me. I've also tried dr. python, which was alright, but it didn't stick to me. I'll wait until PyCharm is officially released, but it seems worthwhile!
In my experience it is slower than Pydev on the same system. But it has Git integration which is a big plus for me. I'm still not using it.
I like PyCharm a lot. It's my new IDE. http://www.protocolostomy.com/2010/11/26/pycharm-is-my-new-python-ide/ If you're a happy Eclipse user, use Eclipse I guess. I'm not sure there's anything PyCharm can do that Eclipse can't, but I never liked Eclipse for any language. I like that when you install PyCharm and launch it, it's ready to code Python *right now*. I like that there aren't a bunch of different views, perspectives, or whatever. I like that there are lots of very high quality plugins available that can easily be autoinstalled. The vim emulation mode is top notch, its understanding of and support for Python language semantics is excellent, and the ongoing code 'inspections' have really made a difference in the number of stupid bugs that get checked into the DVCS. Oh, and I really like the autoimport feature, which lets me code away, prompts me to import a module based on what I'm coding, and hitting cmd-enter adds the import line to the top. I'll generally go back later and clean that up so things are broken up by built-in/third-party/internal modules, and alphabetized within that grouping, but when I'm coding like mad, I add imports the same way PyCharm does, so I'd have to go clean that up anyway :) I will also note that I don't really utilize code completion in any IDE, though I use it more in PyCharm than any other IDE I've used. I really don't feel it's the job of the IDE to know the language and code for me, and typically I type faster than code completion works. Maybe there are options to make it kick in faster, but I haven't looked. Here's a rundown of my past frustrations with trying to find a good Python IDE, written during the PyCharm EAP period: http://www.protocolostomy.com/2010/05/13/python-ide-frustration/ And here's an older piece (Ubuntu 8.04) regarding Linux Python editors: http://www.protocolostomy.com/2008/04/28/ubuntu-804-and-python-editors/ Although PyCharm does load kind of slowly, it doesn't load nearly as slowly as Eclipse, and doesn't show any signs of being lethargic once running. It also doesn't appear to get bogged down when you use a few plugins, which was my experience with Eclipse as well. 
Dude. DUDE. Does it work correctly when printing to stdout? Then do this: $ python phonedump.py &gt; file.txt Thats the correct way to do it.
shit, i think there's plenty of people going to pycon that owe you beers. 
This. However, I'm not entirely sure of how to authenticate yourself using this method.
This is a huge improvement.
Thanks, looks useful.
I have made a library that downloads data from the Bureau of Economic Analysis and the Bureau of Labor Statistics and compiles them into a coherent database for every county in the US. Well, it isn't quite done yet. It downloads them and imports to a database, but I'm still implementing the data estimation procedures. It's my first python project so...
I've written a website for a charity that runs on python, django and the app engine. It's nothing spectacular, but at least it's a project to be working on while I'm trying to get a job.
to become a terminal ninja with the default osx setup you will probably want to visit this link frequently: [Advanced Bash Scripting Guide](http://tldp.org/LDP/abs/html/)
the real problem with the default Terminal.app is the lack of 256 color support, iTerm fixes this and adds some nice shine. imo, xterm works just fine but it does lack support for transparency and does not use the Cocoa font rendering system.
I have a sort of strange friend who likes to take words with 'po' in them and say them with 'poo' instead (this man is an adult). Examples: pooetry, poolite, anthropoology. I built a script that pulled all words matching %po% from my computers dictionary for him to have fun with.
Unless I'm mistaken, can't this be done without python and simply with `grep`? **Editing to expand:** Something like grep -n "http://" *.html should find absolute links in your files (assuming they all start with http://) and give you the filename and line number. You can filter the results through `sed` or something similar to pare down the results if you like, but that might be all you need. **ETA** Also, stop being an entitled dick. You came here for help.
I wrote a filesystem
How about you get started on your own and then post your code when you run into a roadblock and we can help you from that point on.
Built a [distributed storage system](https://launchpad.net/swift).
Ported everything at work to 3.1, used multiprocessing to blast the shit out of our server, wrote a simple continuous integration server, blah blah work stuff, etc. Added a bunch of features and fixed a bunch of bugs in CPython 2.7 and 3.2, wrote a two guides for PSF Sprints, persuaded my company to donate to PSF Sprints, tried to get people involved in sprinting, presented a few times to my local group about contributing and sprinting, submitted a PyCon talk, and got involved in the PyCon review committee. Summary: spent pretty much every day working with, on, or for Python.
&gt;brand spankin' new to Python &gt;for work See MrDerk's comment, that is a great reason why posting this before I spent too much time on it was a great idea. I see your point though. 
I'd check, but Debian 5/lenny (what I've got handy) only has Python 3.1 available.
I'm using this, like it a lot.
I tried it on mine and it ran so far I couldn't work out if it was fast or slow so I altered it a bit, the "normal" version ran in 8 seconds and the "multi-core" version ran in 2 which is about right considering I have a quad core. Here's the code I used for anybody else that wants to try it, uncomment the correct line at the bottom to run the part of the code you want. from concurrent import futures import time NUMBERS = [ 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, 3000000, ] def count_me(n): j = 1 for i in range(n): j += 1 return j def main_concurrent(): with futures.ProcessPoolExecutor() as executor: a = executor.map(count_me, NUMBERS) # Forces it to complete for i in a: print(i) print('') def main_non_concurrent(): a = map(count_me, NUMBERS) # Forces it to complete for i in a: print(i) print('') if __name__ == '__main__': start_time = time.time() main_concurrent()# 2 seconds on my computer # main_non_concurrent()# 8 seconds on my computer print(int(time.time() - start_time))
I don't know why someone would downvote you. Personally, I think this is the correct answer. I'm kind of sick of all the "help me" problems that barely provide any description. Not to mention that this guy's asking for help for a *work* project and offering "love" in return. Fuck that bullshit. Also, it would take maybe two seconds to search for a code example--certainly less time than it took to write this post. *Also*, MrDerk's suggestion doesn't work in the general case (depending on what exactly the OP is trying to do--where the input data's from, etc--and we don't have a clue what that is).
http://www.reddit.com/r/Python/comments/epcxr/can_somebody_help_me_make_a_script_to_search/c19v72g
Helping would have been faster than bitching. You mad, brah?
more gae, moving to pyramid, getting somewhat involved in some of my favorite projects. pycon 2011. 
Bottle is the definitively the best micro framework! It is also a great tool for teaching. I love that everything is in one single file.
i wrote a lot of wsgi stuff for http diagnostics for a big dumb j2ee application. proved empirically why shit is so slow. quit that job and got a job working on gae stuff and python full time(in ohio no less). learned django, whipped out one site with it for a friend of a friend, stuck with bfg for most other things. got really comfy with emacs. 
Would you suggest panda3d over pyglet for a 2D game? 
i had a solution written, then you said brah is only 5 lines too
Relearning that which I forgot while at a Ruby on Rails job, learning Generators and Decorators, finishing my game, and hopefully migrating to a python web framework for a few projects.
Learn it. We're slowly starting to transition our codebase from perl to python. 
I'm switching our CS I course from Java to Python in the Spring semester. I'm excited, but a bit nervous. So far it looks like it will go well, but I still have a few colleagues that aren't convinced. The real test is in the Fall, when I transition those Python students to C++ and Java in the second course. I'll also be porting a game engine I wrote in Python /pyGame to HTML5 / JS (I know, technically that's not in Python) I'm hoping to keep some of the same ease-of-use.
You might be interested in [this presentation](http://us.pycon.org/2009/conference/schedule/event/8/) from PyCon '09. It's about two Michigan State University professors who changed their CS1 class from C++ to Python while their CS2 class remained as C++.
I monitored a remote Windows server running a service that was leaking memory, and after it started using too much memory, I restarted it and annoyed the people who wrote it with a flurry of emails. The annoyance caused those developers (a third party) to fix their software. Today, that leak is no more.
Yes, he offered no helpful information and his username has the word troll in it... I prefer not to feed the trolls, that's all! Honestly though what is your point here? To tell me "I know it, but I'm not going to tell you!" I'm just glad there are people like Mr.Derk who actually help, or mcdoh who at least makes a valid point when bitching in a thread. 
I built a couple of scripts that take names and passwords and then create .csv files for uploading to Google Groups for account creation. And then I learned that everyone else was doing the same thing with a few clicks in Excel. Oh well. I learned quite a bit in the process and personally prefer my method. :)
The one thing SQLAlchemy really needs is a decent migration tool, at least ALTER TABLE support (for databases that support this). I've found SQLAlchemy-Migrate to be quite buggy and lacking compared to similar tools such as South for the Django ORM or Rails migrations. Migrations really are a lifesaver in large / long-term projects. Other than that it's a fantastic tool, best ORM/data-mapper in any language.
If you want to pick off web pages, I expect it's a bit more complicated. grep works on local filesystems, so I should think a curl or wget + a pipe of some sort would be indicated
I read it and believe most of the posters here are right. You are * dabbling in python for work * applying it to the wrong problem * looking for a free solution mr. derk has the right approach imo, just presumably you want to store the output also so I'd convert it to grep -n "src='http://" *.html &gt;results.txt or for subdirectories, locate .html | xargs grep "src='http://" &gt;results.txt and use regex if your pattern varies, like some people using double quotes inside the a tag
I competed in Startup Weekend with Python. I also made [Readerous](http://www.readerous.com). Readerous still needs lots of work from a UI perspective and I need to figure out how to position it against things like goodreads.
I hope to write a turn-based strategy game framework using python 3.1 and pygame. It's going to be a dangerous balancing act between sexy abstraction and whore-level super-abstraction o' doom. Should be fun. It will be open source. It'd also be nice to find a free windows-based IDE for python that has VIM keyboard shortcuts, doesn't suck, and isn't as bloated and painful as eclipse.
See? Much better than your OP this actually offers a lot to the discussion. I don't really see how if this is for work, school, or personal enjoyment should really even be an issue. I did not ask anyone to write this for me I simply asked for something similar that had documentation so I can learn from the example. For a "Free" solution? Do you expect me to offer a reward to anyone who helps me? I'm sorry if a stranger's gratitude is not enough, but it's the internet after all... I don't really understand your applying it to the wrong problem point, care to elaborate? Edit: Also thank you for the additional help with the grep command. 
I think so. you need to understand the camera stuff (to have the proper projection for 2d) but beyond that you get all the power of panda3D : task, physics, shaders, etc. Another interesting choice would be cocos2d which wraps pyglet in a nice way.
&gt; It'd also be nice to find a free windows-based IDE for python that has VIM keyboard shortcuts, doesn't suck, and isn't as bloated and painful as eclipse. [Komodo Edit](http://www.activestate.com/komodo-edit) isn't a full fledged IDE, but it's a free text editor with Vim keybindings. It's a subset of the Komodo IDE (not free), which I've used for almost 5 years and I've loved it since day 1. It might be worth a look.
I can code it myself. I put a lot of open source scripts out there for others to use. Just wondering if someone already has pieces of this done that they wouldn't mind sharing. 
I'm new to python and programming in general. What would a full blown IDE get you over just using vim? I took time to learn vim and python at the same time doing python the hard way and now I can't stand using any other editor.
The way I understand it, he wants to search local html files and find absolute links. No curl necessary. I could be wrong. There's not a lot to go on from the OP.
Pycharm 1.0 has already been officially released ([PyCharm](http://www.jetbrains.com/pycharm/)). 
I wrote a library &amp; app to randomly generate maps for an online gaming site (wargear.net). I am currently working on adding documentation using sphinx to this library. 
I have some weird issues with python plug-ins for vim. The main problem is that vim refuses to auto-indent correctly in a non-hacky way for me when I'm writing python code. I have modifying the python.vim file according to a few suggestions but it has never worked reliably and well. I also like code completion in non-trivial cases. I would love a python IDE that infers types beyond the stupid simple ones (the simple ones are where you explicitly set the variable to a value with a clear type before you try to use code completion on that variable name).
Sigh. No need to be rude. I write a lot of python. The problem is EFFICIENCY. When you have 30+ gzip'd log files that are 1GB+ and 2000 search terms, how do you efficiently search them? Using python's gzip module allows me to search line by line ... this is how I'm currently doing it and it takes forever. Unfortunately, the log files are so large that I can't load the entire file into memory on my server as to speed up the process. I've considered ungzip'ing one file at a time, then searching the uncompressed file, then deleting that file and moving on (which is probably what I'll try tonight). In any case, the request was friendly and for someone to share some love. Whyyoumadbro?
Sorry for not putting more information up, I didn't want people to think I wanted them to write it for me (Which is ironic based on the rest of the replies). You are correct I will be performing this locally. &gt;Also, stop being an entitled dick. You came here for help. If you noticed I agreed mcdoh had a valid point. I did not take too kindly to troll or sedaak's first post because neither of them added to the discussion IMO. You're right I did come here for help and I am actually appreciative, but I don't know why you expect me to appreciate "I have the answer, but I'm not going to tell you". 
I'm writing a wx/SQLite/SQLalchemy based Printed Circuit Board tracker for work. It keeps a database of broken ones generating barcodes(and printing them) and using a barcode scanner to find which board goes with which entry etc. First python based app and it's turning out fairly well thus far. Really, really making me love python.
I used this quite a few times. It's a great framework. Don't forget to check out http://www.reddit.com/r/bottlepy
Learn it! 
Actually I was having issues with indenting until I put "setlocal smarttab" and "set nosmartindent" into my python.vim. Here's my whole file if you're interested: setlocal tabstop=4 setlocal softtabstop=4 setlocal shiftwidth=4 setlocal textwidth=80 setlocal smarttab setlocal expandtab set nosmartindent set number set textwidth=0 set wrapmargin=0 Also the latest python [syntax file](http://www.vim.org/scripts/script.php?script_id=790). I would like to get good autocompletion, but I haven't taken time to figure out how to do that yet.
Among other things, I wrote an utility that interrogates Oracle database dependencies. It's used by release managers who want to release a Java (or other 4GL) app. The utility inspects manifest.xml created by app developer and determines if target Oracle site is ready for the application release.
What did you do for the remaining 1439 minutes of the day?
Thanks for your work on Python for Windows Brian (and all your other work too). Appreciated.
I started the year working for a German firm writing web applications with Django on the server and Silverlight on the front end. The front end application (about 20 000 lines) was written entirely in IronPython and running in the browser. Communication with django was almost exclusively sending and receiving json. In September I started working for Canonical, working on web services associated with Ubuntu Pay, the new software centre and the single sign on services for canonical websites. This is mostly working with django. unittest in the Python standard library has continued to evolve, which I've been heavily involved with along with a few other standard library tweaks (my favourites being contextlib.ContextDecorator and inspect.getattr_static plus backporting weakref.WeakSet to Python 2.7). Python 2.7 was released in 2010 as well as the first alphas and betas of 3.2. The changes to unittest are available in a backport to earlier versions of Python called unittest2 which has gained a surprisingly large number of users and will be incorporated in the next version of django. My 'other' testing project is mock, which is approaching a 0.7.0 release with a lot of new features. The blocker on getting the final version out of the door is a thorough review of the documentation. Hopefully I will find time for this over the christmas break. The beta seems to be getting a nice level of uptake though and no new bug reports since the last release... ConfigObj is still reasonably popular but I'm not using it a great deal myself these days, so I haven't worked much on it this year. A couple of folk ported it to Python 3 though, which is fantastic. In 2010 I attended PyCon US, EuroPython and PyCon Italia. All were fantastic and at EuroPython this year we had our first language summit and PSF members meeting. I've helped out a bit with talk selection for PyCon US 2011 and am organising the language and vm summits we will have there. We intend to repeat the language summits and PSF members meeting at EuroPython 2011. The EuroPython 2011 location is fantastic, so hopefully see some of you there! 
I envy you but you seem to ignore your blog ;)
Mainly tools that help with the job of writing Objective-C apps, both internal and external. One largish code generator for a lot of the boilerplate Objective-C requires, a tool that generates a diagram from a protocol state machine, [a small hg extension](https://bitbucket.org/juri/hg-status-sections/) and [xibgraph](https://bitbucket.org/juri/xibgraph). I seem to end up writing a lot of half-assed Objective-C parsers and should really look into writing a libclang wrapper so I could use its AST. 
can I have the script/module ? I may have use for it. thanks
Worked for Eldarion, where I get to do nothing but Python and Django! Became a core developer on Django (and eradicated doctests), contributed to PyPy in a few different ways. Wrote and open sourced random libraries.
* NOSQL talk at pycon'11 (if accepted ;o)) * Develop OpenStack data services layer [https://blueprints.launchpad.net/swift/+spec/swift-cdmi] * Contribute to py projects towards 3.1 migration (any suggestions?) * Add py 3.1 algorithmics for BioInformatics
Good job. Any benchmarks?
Continue my contributions to Django and PyPy including possibly championing a transition to Python 3. Finish writing my ORM, write a networking library, write a branching regex dispatcher that efficiently compiles to a single DFA.
I've tried cocos2d, but I've found it hard to figure out. I think I will gowith Panda3d simply ecause I can do more with it in the long wrong. 
Well it's been a while, but a little over a year ago I did a data mining project analyzing large gzip'd text files. I'll take a look around, but from what I remember python comes with a pretty easy to use gzip library. In terms of efficiency, I think one of the best things you can do is try to get some parallel processing going; there don't appear to be any logical dependencies between files, so the only thing you've got to worry about is output. I don't have any experience with this, but if you make a component script which accepts one gzip file as a command line argument, I think you could use a controller script to call it (os module) on each matching file, and then perhaps find a neat way to collate the output. I'd start with a simple algorithm, and make it smarter if it's too slow. You can easily iterate over the lines of a gzipped file and compare each term to a dictionary of search terms. This won't be blazing fast, but it's easy to implement so I'd start there. I'll see if I can find some code, but I'm not sure where it is, and in any case I'm no expert. 
Dude. Just use grep. Put your list of search terms in a file (plain strings, not regular expressions) named "tofind" or something, then do this on the shell: for filename in $files_to_search; do zcat $filename | grep -Ff tofind --label=$filename; done This is not a job for Python.
I wrote a wrapper to the World Bank API. I created a website with django that allowed students at my school to enter their schedules during orientation to see which other students will be in their classes. I created a Facebook app (never launched, just for fun) that would perform graph math on networks of friends and determine centrality, path lengths, etc. This was done in django on GAE and I did all of the graph math with my own code. I created a framework that could direct objects to one of a group of functions based on regular expressions (first real experience with regular expressions). This is based on the django url patterns combined with the Flask decorator syntax. Still haven't taken the time to figure out if/how to make it reversable. I wrote a blog engine for myself with Flask, and then neglected to post on it.
find a job writing python code :/
Stop using it.
I want to write a blog engine using [CherryPy](http://www.cherrypy.org).
Made a [job hunting agent](http://scattered-thoughts.net/one/1274/311469/330868), because scrolling through job sites is tedious. Wrote an [email chatbot](http://scattered-thoughts.net/one/1274/311469/329424) that baits 419 scammers. Various one-off scripts, tests and benchmarks for [texsearch](http://scattered-thoughts.net/one/1274/311469/312218). Patched some of the [smarkets](http://smarkets.com) middleware to match my changes to the backend. Came 78th in the ICFP contest with a python spambot. More than I expected actually, given that it isn't the main language for any of my paid work. Python is like sand, it gets in everywhere.
I really haven't had the need for 256 colors. 16 colors are enough for the quick vim editing that I do on terminal. Anything more that require fancy colors and stuff, I just use MacVim. Can you tell me where 256 colors would be useful? If there is one, it might push me over to iTerm.
A script that compiles virtual user log files from my performance tests and calculates statistics such as average response times, std dev, 90%, etc. Then it outputs different results to csv files and creates graphs on the fly using matplotlib. A video plugin for XBMC to watch Academic Earth videos. And many more...
I'm actually looking for interesting python projects to work on... so if anyone has any, feel free to let me know...
See [Facebook's authentication documentation](http://developers.facebook.com/docs/authentication). For fully programmatic access, I think it would be easy to create a single web page to request the [permissions](http://developers.facebook.com/docs/authentication/permissions) that your script would use (including the *offline_access* permission), and then save the OAuth access token provided for later use.
Just for kicks a few months ago I wrote a Facebook/Twitter bot creation website that runs on Python/Django. I added a scripting language so you can auto-post random statements. So far there's a Tourette's bot talking random mindless trash, a Hellen Keller simulator, and a guy making statements about current Twitter trends. Anyways, the Python Facebook library I used was webappfb. It does the basics fine and it still works. Once you do the authentication stuff it's good to go and you can post anything.
Looks interesting. Does it run in Python 3.1 or is it version 2 only?
Then you should take a close look at this: [MIT Open Courseware](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/) 
At work so I can't look. Is Komodo IDE expensive?
It's $245 right now, and I guess it would depend on your definition. I think it's a great product so I don't consider it expensive.
&gt; The down side is that bottle requires Python 2.5 or newer. Not a huge requirement, but one of my first applications I built up and then realized the machine I was deploying it on was CentOS 5.5, which has Python 2.4. Hey, if it's older it's more stable right? Can't beat a six year old version.
They not pricey for a Company, or a Freelancer, but for an casual programmer it is. 
&gt; Can you tell me where 256 colors would be useful? well for me it's useful because i prefer terminal based vim to macvim, also i spend about 75% of time in vim :)
I wrote a psych experiment in python involving a maze and decent AI, a poor-man's batch processing library, a scheduler to keep track of the hours I spend working on whose projects, a ton of CLI wrappers and tools, and a few little GUI wrappers for said tools.
flask is also good... python microframeworks are wonderful
Which language are you going to transition to? 
I graduated as an IT major and took 3 different programming courses that revolved around Java. I would have loved for one of these to have been python. Which brings me to what I want to do this year: learn python. 
I see. Makes sense. Thanks for sharing.
Hmm... Right now all our benchmarks are sort of behind the firewall of our product based on the open source project. Hopefully soon we'll get a reference hardware config and we can do stuff like that better.
Wrote a script to snarf all the flv's from a pr0n site.
Not as interesting as what others did: I created a word cloud generator for Wikileaks cables using Python and BASH: http://code.ebrahim.ir/wikileaks/src/tip/cables/
It's not really a "transition". I don't forget Python just because my work is in another language. I'd like to be writing more in Go. I'd like to be writing more in C++. I'd really like to be writing more in a language of my own invention, but that's awhile down the road, I think.
Continued working on my [checkers game](http://code.google.com/p/raven-checkers/). A new feature to annotate games is very close to complete; hope to complete it before 2011.
Wrote a process that interfaces with RHEL Satellite server to setup a patch repository that our other product uses to actually perform the patches (Redundant yes, but I just do what I am told....). Interfaced a ticketing system with a vulnerability scanner so that when the vulnerability scanner finds a ticket, it opens up the ticket, within the ticketing system. Wrote a python-script that will transfer files, and execute a command strip on any number of *nix servers. Will even handle sudo for me. Wrote a Squid-Cache helper that checks to see if a system is supposed to have internet access. Basically, I work very hard with python, to make my life easier!
I was happily using bottle for a while until I discovered [flask](http://flask.pocoo.org) . I found flask to have better documentation and better support for important middleware features, such as csrf protection and session-support. Flask also uses decorators for routing / templates. I do like bottle for its cgi support, however. 
Yeah... I was hoping to avoid this because of the big overhead, both in terms of code and learning curve. Seems like a lot of reinvention just for "log in, get list of messages, and set status to [TEXT]", you know? Seems overkill. The lack of sample code for things like that also scares me. But I guess I will have the bite the bullet if nobody has a shortcut idea. I am kind of shocked there are not 3000 scripts for this. Doesn't anyone else want them? 
It's not for anything from a website, just cron jobs from my own computer, so no web interface or login needed or wanted. That said, I guess curl or something could do the login and save the info. Again, I'm a bit stunned this hasn't been done by so many people already... I expected the code to be floating around all over.
Yeah, but that won't help with anything other than status, sadly.
Nice. Thank you.
Hey razzmataz, If you live in US and want to write Python at work, Send me a message with your resume. I'm looking for SEs/SDEs with Python experience, if You (the general You) have similar goals for next year as razzamataz, send me a message with your resume!
Just do this. Even if you wanted to use python it is faster to use zcat instead of gzip.open. Once you do that, it is still faster to use grep than have python do it. However, there is another way to speed things up. You can turn your search terms into a set: search_set = set(terms) and then do something like for line in os.popen("zcat afile.gz"): if search_set.intersection(line.split()): #line matches if your search terms aren't words you can still split everything into n-grams (4 works well enough) and do the intersection on that. def make_4grams(s): return zip(s, s[1:], s[2:], s[3:]) then you just need to build a search_set of ngrams and do instead: for line in os.popen("zcat afile.gz"): if search_set.intersection(make_4grams(line)): #line probably matches 
Huge thanks for doing unittest2, and of course thanks for all of your other work as well. I used to manually copy over the py3k unittest to all of my 3.1 installations in order to get skipping, discovery, and custom `TestResult`s.
Finally pickup on robotics with python "brains".
Thanks
There is no reason why Flask shouldn't work with CGI :) from wsgiref.handlers import CGIHandler CGIHandler().run(app)
Make pyQxt Bindings (alongside pyQt) - need to learn SIP http://libqxt.org/
I want to build a Django-driven (so, obviously, web-based) multi-user password manager tool that uses GnuPG for encryption (either it can generate keys itself per-user, or you can feed it your keys if you trust it) of actual password data. By encrypting each protected token (i.e. password) with the public key of every user allowed to see it, the password is recoverable with valid credentials, and a screwup in the app's permission systems won't expose passwords to unauthorized people. I've looked around for a web-based password manager written in Python and haven't found one, so I'm going to scratch the itch myself. Even if something already exists, I expect it will be a very good learning/refresher exercise.
Get beyond my novice level to something I feel comfortable putting on a CV. My thesis involves playing around with AES, so I've been asked by my supervisor to try write my own program that implements it by the time the semester starts at the end of January. Actually looking forward to it.
Numpy and Scipy. Definitely learn Rpy2 to compliment my daily work with R. python is really more of a hobby, so no huge projects planned. 
1. Refactoring some in-house tools to improve the user-interface and allow for batch processing. 2. Developing some new in-house tools to process CFD results that will require some significant computational geometry calculations. Need learn more about the pros/cons of various libraries (scipy.spatial, CGAL, and VTK) and more general background on computational geometry. 3. Need to learn the right way to distribute code (most all with some combination of wx, numpy, scipy, matplotlib). Confused by all the options though: py2exe, pyinstaller, pip, distutils, distribute? Any advice? Happy New Year
I've been working on a [DAG](http://en.wikipedia.org/wiki/Directed_acyclic_graph) framework to allow me to quickly interconnect abilities in the program I use for work for rapidly building myself work-doers, report generators, and boss impressers. In the same app I've been toying heavily with building a UI generator to let me rapidly build UIs with the crappy UI system in the app that takes me forever, even with years of experience, to make anything work nicely. I've built the beginnings of some nice animation rigging systems. I'm going for Lego-like interconnectability using a pass-base system that builds layers of rigging in passes, and counters race conditions in the logic by waiting for things to become available (i.e. created in other passes) before moving on. I've been learning to separate out the logic from my code from the display, so I can code on machines that don't have the app I'm writing for, then later easily hook it into the display end, UIs, etc. This includes a lot of work in the 'failing gracefully' end of things. I wrote this little recursive string permutator: def reorder (m): if len(m) == 1: return [m] w = [] for i in range(len(m)): for j in reorder('%s%s' % (m[:i], m[i+1:])): w.append('%s%s' % (m[i], j)) return w It does return duplicate entries if the string has any duplicate characters in it, because it's giving every possible reordering, not every possible unique word, but it was a fun little challenge. I love puzzles like this.
I'm sure you know, but to make it explicit, grep -F uses the [Aho-Corasick](http://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm) algorithm, which means it's still going to be much faster than your alternative algorithm in Python. Python's a tool. It's not the right tool for this job.
I learned Python and now use it every day for my graduate studies in Biology. Python is great for bioinformatics!
I've been using this as well, and I like how you can use it with Google Apps.
Yeah, it is faster, but not by all that much... for one of my data sets of 200,000 words and 2.45 million lines fgrep takes 2.4 seconds and python takes 2.7 I've only used python for this type of thing when the program needed to do other things. The last time I used this was for realtime matching of domains in dns lookups, where the list to be watched for was constantly changing. If it wasn't changing then just feeding the list to fgrep would have worked too.
Not sure if this will help you, but check out [Chapter 16 - AI Simulation](http://inventwithpython.com/chapters/).
Nothing stopping you from using virtualenv either. I have to use CentOS on some of our work servers and I ignore their ancient system python completely.
I learned python and wrote some simple stuff to facilitate all the Google Calendar posts my work requires. This venture began initially with me copy/pasting a script that was ~90% Google's example code for programmatic login and QuickAdd and then turned into something much more grand with default values, a log file and obfuscated login information. I hope to finish work on my next project which will automate my work order entry through our dated website. This should be done over Christmas break, so it still qualifies--right?
Learn MORE! I just started a month ago and I've built some useful scripts, but I have much more grand ideas. :) I've got a webapp I want to build and ZERO idea where to start. If anyone wants a pet project to work on while teaching a newb, feel free to chime in. I ran into something that I needed today and couldn't find an easy solution, so I want to build it. In case anyone is interested, I'm a "free beer" kind of guy, so my dreams for this app is that it generates enough revenue to pay for its server/bandwidth/domain fees and that is all--so a few adds at the most. Really, it's for me. If no one else uses it, it's their loss. :) Oh, the details. :) Basically, I want a website that takes a huge image, and breaks it into smaller images for printing. A tool for printing posters on letter sized paper. 
See my post: http://www.reddit.com/r/Python/comments/epdzf/what_do_you_want_to_do_with_python_next_year/c19x45y
Finish this: http://whice.dev.archadesign.com Basically a recommendation-driven reddit-style site.
I find your numbers extremely hard to believe. Are you able/allowed to provide more details so I run similar tests? 
http://google.com/search?q=rasterbator -- don't let that stop you from making a better version!
wait, i was gonna mention grep too. that's 4 grep mentions on the page...
to think that i was looking for something to read tonight. thanks OP!
take a look at David Beazley's generators [tutorial](http://www.dabeaz.com/generators/)
I want to play a lot more with PyGame, and eventually transition to the Blender Game Engine.
I want to expand the no-frills pygtk desktop environment I'm calling [Ogden](http://code.google.com/p/ogden/), including a port to pygobject-introspection as soon as that's advisable and thence to python3. In particular, I'd like to improve the image viewer, write a panel, and maybe a file manager and imap client if I get really ambitious. I'd also love to create a gui tool for xdg-mime.
Joke: Damn flask people injecting in every bottle thread! A quick check reveals (only core *.py files). - Bottle: 1938 (lines of code, 1 file only) - Flask (including dependencies Jinja2, Werkzeug, not including tests, debug, apps, contrib): 24179 (lines of code) - web2py (not including tests, apps, contrib, database abstraction layer but including templates, html helpers, form generation and processing libraries, and syntax highligther and all handlers) 23469 (lines of code) For people who want a *MICRO* framework. I think Bottle wins by one order of magnitude. EDIT: Before touchy people jump up and down: I added web2py as a reference point. I am not comparing it with Bottle and Flask. I am not saying it is a micro framework. If I had Django or Pylons installed I would have added them as reference points too (I would not know how to separate the ORM). Perhaps other redditors can contribute numbers and verify mine.
The difference is that he was responding to someone else who brought up Flask, yet you independently brought up web2py.
Seems to me you'll be manually updating your names with every new dll update. See this: http://stackoverflow.com/questions/1615813/how-to-use-c-classes-with-ctypes If you worry about manually updating your code, then try to wrap the C++ dll as a friendly adaptor dll in C: http://wolfprojects.altervista.org/articles/dll-in-c-for-python/ Now you'll only have to recompile for your new C++ dll with the new version (which could be automated though)
What are you talking about? First of all I made a Joke. Second, who is "he" in your post? Third, both Siraf and bobx11 brought up Flask in this thread without "responding to someone else". Since you are here, you could contribute with some useful information: how big is Django without orm, apps, and contrib?
or was it 2.45 million words and 200,000 lines?
My intent for next year is to better understand Python, and write my own code to print out a paper slide rule. PyNomo (don't go there unless you have several hours) does the work, but the plan is to do it myself. My knowledge of Python is still quite limited, but if it is possible, an interactive HTML slide rule project might also be attempted. Best of wishes for a prosperous 2011!
What windows DLL are you using? Names in common dll's (kernel32,shell32,user32, etc) are not mangled
It's a third party DLL.
I'm still not sure why this isn't something ctypes can just deal with transparently. There are tools that let you view DLL exports with the option of demangling function names.
Thanks for the link! That gives me some ideas, but yeah, I'd like to clean it up a bunch. Hopefully I can figure it out!
2.x only
I built my first website using Django / Python this year: http://www.lookingforcoupons.com (it's a retailmenot clone). I plan to build another website, I have several ideas but nothing clear yet. 
Try the [Python code](https://code.google.com/p/aima-python/) provided for the Artificial Intelligence book by Russell and Norvig. It is what I used for the minimax code in [Raven Checkers](https://code.google.com/p/raven-checkers).
I tried that. It gave me: Traceback (most recent call last): File "c:\users\me\documents\me.py", line 78, in &lt;module&gt; direction, errorCode, text) UnicodeEncodeError: 'ascii' codec can't encode characters in position 142-147: o rdinal not in range(128)
I don't think mdipierro was referring to mitsuhiko's response but to the two top-level unsolicited comments promoting Flask.
As far as I understand - correct me if I am wrong - Flask stores sessions in digitally signed cookies. Bottle does the same. They are both based on WSGI and can use WSGI middleware. One thing that Bottle does not do and should be easy to add is handling RANGE requests (partial content). It is useful for http streaming. Not sure if Flask does that but I assume it does.
We found that the zgrep that is with freebsd to be the quickest way to parse gigs of logs. Most linux versions of zgrep are basically zcat piping into grep. Another solution for long term would be to use splunk... Thats what we went with(we were doing ~200 gigs of logs per day). Highly recommend splunk, we were able to search through terabytes of data in a minute or two with the proper search string and architecture. You can also look at mapreduce on something like hadoop.
Actually, I didn't consider the dependencies. Good call. Flask is definitely somewhere between django and bottle in terms of dependencies. I typically have a flask installation up and running in 10 minutes thanks to pip, gunicorn, and virtualenv.
Wow! Great tip. I've been trying to do this for a while now — nearlyfreespeech can only handle CGI. Perhaps I'll do a writeup and benchmark the two over the holidays.
wow, just downloaded Komodo edit and set it to Vi mode and it's exactly what I wanted. So thank you for introducing me to it :D
python3 Django would be excellent!
Translation: "Hey, I've got this reputation for being a guy who bursts into threads about other frameworks to talk about my own. So I'm going to snipe this dude by making a 'joke' about him doing the same thing, and then use it as an excuse to cover yet another case of me bursting into threads about other frameworks to talk about my own!"
* finish any of my projects
I'm using Tornado now. I'd look at Bottle or Flask but I'm using the SSL support in tornado. 
I've made a radio automation system for the campus radio station I worked at called [KRAP](http://krap.sourceforge.net/) I made a few small scripts for things [recreole](http://www.danomagnum.com/wiki/recreole), [asciigraph](http://www.danomagnum.com/wiki/asciigraph), a dinnerbell gui (my first gui), a script to pull a bunch of data about bad company2 from the bfbcs.com api, and numerous others. I launched a minecraft website called minetrade built on django I also learned how to set up a django app to run locally with py2exe.
I'd like to work on python again... Used to work on it all the time, spent a long time in many python shops. Then I wound up in a shop that is a bit crazy (quite a bit crazy) and decided to replace a C# application with... wait for it... C/C++ (not for speed, mind you, just because 10 years ago the rest of the staff learned C/C++ in college and no one wanted to "learn python"- Even though *no* one has worked with C/C++ since their college years, they still thought writing a SOAP app in C/C++ was going to be easier than writing it in Python....) Yeah... I'm not terribly happy where I am..
You probably know most of this already. Maybe someone doesn't and could learn something. Sure, you can do it. It will take some hackery. First, C++ symbols are not random or magic. C++ has polymorphism, which means a function can be called the same thing but have different definitions based on the different parameter types. Instead of doing something magical with method lookups at function-call time, the definition names are mutated to include the types of parameters and all the lookups are effectively done at link-time. So, function *foo* might have three int parameters, so the symbol table would instead be *foo$IntIntInt* or some other more compact representation. *foo* could take two ints or a int and ten strings, et c, each with a new name starting "foo" and then some encoding of the parameters. C has no polymorphism, so there can be only one *foo* function, with no parameter types encoded. If you can figure out the parameter encoding scheme, you can catch the call, look at the types of the calling parameters and try to match the nearest encoded symbol name, and call it. For Python, you could make a function that takes the function name and then a list of parameters. def dll_call(func_name, *parameters): encoded_params = "".join(type_to_string(param) for param in parameters) dll_lookup = func_name + "@@" + encoded_params return ctypesblahblah[dll_lookup](*parameters) Or something like that. 
I persuaded my girlfriend to learn python, if that counts.
Since Ericflo is not answering my question, when you are done with the personal attacks, could you tell us how many lines of code is Django without orm, apps, tests and contrib (but including comments in code)? I would not know how to measure it precisely and I am interested in the number. I think people are interested in numbers. For the record: the joke was on myself. I do not think Siraf or bobx11 did anything wrong. Do you think they did something wrong? Or are you using a different metric to judge my posts? I personally judge posts and posters by a simple criteria: is it about a technical issue? Did it tell something I did not know? or is it just a personal issue? By my own standard this post of mine scores very low.
I've never really had problems with vim auto-indent for my python code, and I've been using it for years. set nocompatible set ts=4 set ai set sw=4 set expandtab set smartindent set softtabstop=4 set backspace=indent,eol,start set wrap lbr set formatoptions+=l 
EDIT: I apologize for the previous joke. It was not on you. It was on me. I am not sure where Django stands in terms of size if you take out the ORM (Flask does not include one), contrib and tests (I did not include them in my Flask measurement) and the apps (Django has admin and the scaffolding app for example). Probably Flask and Django score pretty close... like Flask and web2py do. Which was the point I tried to make. Once you include SQLALchemy in Flask or Bottle things change dramatically. In terms of lines of code SQLALchemy is 40,000+ lines of code, bigger than the entire web2py+dal. I would not be surprised if Flask+SQLAlchemy is larger than Django. I would like to see the people involved publish some numbers. Ideally I would like to see numbers broken by category (core, dal/orm, contrib, apps, tests) not counting blank lines and comments in code. The web2py dal is a single file and 4949 lines. I think it would make a good pair with bottle. We just changed the license to LGPL3 so it would not affect apps built with it.
1. [For the lazy](http://plnnr.com/) 2. What IDE's did you use for the code? Was the graphics done in-house, or outsourced? 3. What specifically was Python used for, and what other languages did you use and how? 4. Looks awesome!
I'm going nuts... I type, nay, copied in this code exactly, and it still just says got: None. It seems like my return statement isn't working at all.
You may want to checkout pymysql. It is pure python and has ssl support via the built-in python ssl module. web2py switched from mysqldb to pymysql and this did not break any user app. pymysql is also faster! 
I've just been playing with this on a micro EC2 instance, and it's pretty fun. The only weird thing is the wildly inconsistent response times. Wish I knew how to tell it to keep everything in memory, or whatever.
[Try here](http://www.lfd.uci.edu/~gohlke/pythonlibs/)
Note, mdipierro was not "sniping" the commenter -- he has no problem with Flask folks posting in threads about Bottle or with anyone posting in threads about web2py (see [here](http://www.reddit.com/r/Python/comments/ej0p1/new_standalone_web2py_database_abstraction_layer/c18g0va)). His joke was pointing out the double standard often applied to him and web2py (people regularly post about other frameworks in web2py related threads). If anything, he was "sniping" at folks like you who "burst" into threads solely to make unfounded personal attacks instead of contributing to the discussion.
use Linux? sorry I cant actually be helpful.
I'm just starting in programming in general. Picked Python to start. I can't wait until I can start developing my own ideas. Hoping to get into a web dev project to get some actual project experience down the road when I have any kind of a clue in what I'm doing.
reddit: The only place where recruiters are cool.
I'm planning on getting to grips with a web framework like Django next year. Nothing too fancy, write my own blog and so on.
From memory it's about 60k lines of code, no idea if that includes tests, but it doesn't include docs.
gjango project
Finish off my work report (for my co-op) about code clarity and the benefits of Python. Gonna be the easiest work report I've ever written.
If you are unable to compile mysqldb from source (which is moderately complicated on Windows) you will have to use one of installers that you can download from the internet - like this one: http://www.codegood.com/archives/129 pymysql, as mentioned in another comment, is also a good (if not even better) option but it may not be possible to use it (sqlalchemy, for example, started supporting it in trunk but there has been no stable release yet with support included).
Thank you. That confirms my suspicion that Flask+SQLA is bigger than Django. bottle.py+dal.py adds up to 7000 lines (including doctests) and provide very similar features to Flask+SQLA in 10% of the size. The more I look into the bottle source the more I like it. It is really clean and well designed and contains a lot of gems.
I think this misses the point about what a "microframework" does. It doesn't really matter from the development point of view how big, in terms of lines of code/modules/dependencies, the framework is. What matters is scope/complexity vs features. For example, Django provides more out of the box functionality - ORM, admin, auth etc - over Bottle. But Bottle provides (arguably) less conceptual overhead and more flexibility, with the bare minimum to get started with a simple WSGI app. You don't have an ORM, you add one yourself (SQLAlchemy, PyMongo, whatever) or do without one if you wish. Either framework may be a good choice, it depends on requirements and preferences. I couldn't care less how many lines of code each are written in however. Function call overhead is a concern - how efficiently the code runs - but lines of code != number of function calls. For example, even if SQLAlchemy has 40,000 lines of code, much of that is support for different SQL dialects, extensions etc that will only be executed if you are running a certain extension or dialect.
I seriously doubt the web2py DAL provides similar features to SQLAlchemy.
The web2py DAL does not handle very well legacy databases. Apart for that I am not aware of any feature of SQLA that DAL does not provide. If you know please tell me so I can add them. The DAL is faster and supports more backends. 
oursql
&gt; EDIT: I apologize for the previous joke. It was not on you. It was on me. No worries, mate! I appreciate the humour. I actually don't know why you're being downvoted, you made a really good point about defining a *micro* framework.
For my ORM, I definitely side-stepped the SQLAlchemy issue by jumping on the NoSQL boat. I use mongoDB. I'm more of a fan of [MongoEngine](http://mongoengine.org/) than mongokit for the vain reason I find the syntax to be more pleasing. You're definitely right about using lines of code as a metric.
I agree. But allow me to be surprised that Flask (without SQLA) is 10x bottle and people here both present them as if they were equivalent. Since Flask has been brought up on this thread, not by me, I would like somebody to explain to me why 10x so much code. I am sure there are extra functionality that bottle does not have. What is it? I agree with you that bottle is more flexible that other frameworks and it is really well designed.
`zgrep`
It's expensive compared to Eclipse or Notepad++, but it's worth it if you're a professional. Sadly its git support is lacking (can't push to remotes, occasionally get obscure SCC messages on start up) but I found a good workflow using Komodo and git in a Bash shell side by side. Also, the "publish" feature is mostly worthless. It doesn't always register when files have changed (with no way to "publish" unchanged files) and it's a two-way sync, which makes it more of a dumb SCC. It found it easier to write a hook for the git remote to automatically deploy to a testing server (coupled with a fabric file for auto-setup). It's certainly not as feature rich as Eclipse with all its extensions, but that isn't necessarily a bad thing. It's cross-platform, fits on a flash drive and has a relatively short start time (also, its look &amp; feel is very smooth compared to the sluggishness of some other Python IDEs I tried).
A virtualbox is good as this will be the first hurdle of many if you want to develop python on windows. You will hit walls with Virtual-Env and PIL because truth be told even though Python is marketed as a cross platform language (and to be fair the core is), extensions are only supported "well" on linux.
If you're enthusiastic about vim, I suggest sticking with it for now. Vim is quite different from other editors and IDEs because of its modality. I prefer working with a GUI, but using keyboard shortcuts or commands for everything is definitely faster. There's not much you can do with other tools that vim can't do or be made to do with plugins. It's more of a question of faith than benefits.
I'd like to wrap my mind around topic modeling by implementing my own gibbs sampler and latent dirichlet allocation in python (and numpy/scipy if needed).
Bottle works with the tornado web server. It contains an adapter.
&gt; extensions are only supported "well" on linux. And OS X 
Finish my django website.
The SDK is trivial to use. You pass it a dictionary with the appropriate fields set for your request. (The field names and values you can look up on FB's SDK docs page.) That's all. (The SDK is just a wrapper for HTTP POST/GET) The auth is trivial too. It's just OAuth 2.0. /edit: seems the Python SDK is even easier to use: graph.put_object("me", "feed", message="I am writing on my wall!")
Compiled PIL on OSX?
1. Thanks 2. I like Komodo edit, with IPython on the side. 3. All the backend is written in Python, which includes: * webserver code (over turbogears) * trip planning algorithm * content harvesting and processing * other tasks I also used the regular stack, css, javascript, xhtml, so on. I'm thinking of using [sass](http://sass-lang.com/) though. 4. Thanks!
* Build an astronomy website with Django. * Solve as many project Euler problems as I can. * Re-learn numerical methods and learn some advanced algorithms using python. * Learn Sage.
To contribute to a PSF sprint .. 
I used python to make sense of the results of my data analysis program (written in C for speed) to figure out the periodicity of a pulsar.
The comparison is a little bit unfair. Werkzeug and Jinja2 provide a lot of features which are not used by Flask and Flask as well as it's dependencies provide a lot of features Bottle doesn't even have. Jinja2 for example provides a sandbox. Werkzeug provides various tools for session management, caching, hashing functions for passwords and a lot of powerful datastructures MultiDict, ordered dicts, immutable dicts, if you look at how Werkzeug handles headers you will see that it parses them and makes them accessible with a nice API, not to mention the middlewares to handle server bugs, atom feed generation etc. If you remove all those features I doubt there is a big difference in LOC to be found, unless you count documentation as well.
May Mahakali bless your soul for all the good work you've done.
Learnt and hosted a site using google appengine, also really improved my django-fu (reading source code almost as much as I read documentation), loads of useful fun/work scripts
sure... [http://pdb.finkproject.org/pdb/browse.php?summary=PIL](http://pdb.finkproject.org/pdb/browse.php?summary=PIL) among many other places, as a rule of thumb if you can get it working on Linux you can get it on OS X. 
To be totally honest I don't use OSX, however I do remember seeing many complaints regarding PIL as it had to be compiled before being installed, the compiler and certain C libraries had to be obtained seperately. PIL does have an installer for windows but it's useless if you want PIL in a VirtualEnv. Needless to say PIL isn't a niche library that is hardly used, it should have better integration on all three major platforms.
i've build a chatterbot in python/django for my university degree. i kind of forget about it but i'm planning to revive it now that i have a website to play with.... which is another project in python/django: http://theipo.org/t/random. i want to open source bought of them... any help?
I think it's because name mangling schemes are not standardised - they're [compiler-dependent](http://en.wikipedia.org/wiki/Name_mangling#How_different_compilers_mangle_the_same_functions). So to support this transparently would be a lot of work!
if you live in Germany and want to write Python for money, send me a message with your resume. It would be very helpfull if you know about SQL. 
i've build a chatterbot in python/django for my university degree. i kind of forget about it but i'm planning to revive it now that i have a website to play with.... which is another project in python/django: http://theipo.org/t/random/ i want to open source bought of them... any help?
I wan to run PyPy with Numpy.
I salute your decision to change to LGPL3 and I wish you guys all the best.
Is this a good framework to start with? Was looking at web.py, but this looks more complex yet not as django does.
&gt; The comparison is a little bit unfair. Werkzeug and Jinja2 provide a lot of features which are not used by Flask. That's the point. Would you call a wrapper on top of Django a "micro framework" just because it hides most of the features and provides a simplified API? Is Elixir a "micro ORM" just because its API is more simple than SQLAlchemy, even it depends on SQLAlchemy to work? Flask is a nice layer on top of a bunch of huge and mighty libraries. Nothing wrong with that, but I would not call it "micro". The term "mirco framework" is controversial, I know. But as I see it, "micro" is more than just a nice API. It's a philosophy for small, clean, dense and useful code. It does what it does and it does it well. Every line has a purpose. That is what I try to do with bottle. "Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away." - Antoine de Saint-Exupéry &gt; and Flask as well as it's dependencies provide a lot of features Bottle doesn't even have. That is true. The thing is, if you miss a feature in Bottle that is provided by werkzeug (or any other library), then you can just include werkzeug and you have it. That is what a library is for: Use it when you need it. Bottle does not prevent you from adding dependencies if you really need them. But if you don't use a feature that is provided by Flask, can you easily remove the werkzeug or jinja2 dependency? Bottle supports 4 template engines (including jinja2 and the built-in one) and 15 WSGI server libraries out of the box. The decorator or middleware that adds werkzeug to the mix is less than 10 LOC. Want a debugger? Include it, apply as middleware and you have it. I don't see the need for a hard dependency.
This. I was used to working with a Linux desktop which doubled as my local testing server. It took me a while to realize there was no easy way to make my Windows 7 machine play that role without virtualisation. My new plan is to set up a virtual Linux installation that perfectly mimicks my remote test server's environment. I just need to find out how to talk to my virtual Linux box from my webbrowser.
Awesome! It seems like PyPy is moving fast. Once it supports Python 2.7 I think many people are going to migrate to it or at least try it out :)
One of those vars is perhaps a `unicode` object containing signs outside ascii?
You can actually just use grep on top of hadoop streaming.. you have to use a wrapper script that always exits with 0, but otherwise it works as you would expect. 
Love web2py. Thanks Massimo and friends !
Can't say I've found that to be my experience. Sure, if you want to get the latest and greatest Python version, then yes, Python's awful C API and lack of backwards compatibility means that you're screwed without a C compiler on your system. But if you stay with a slightly older version, which is typically still getting security patches, almost every extension you need can be found in precompiled form.
I believe you are confusing framework and application here a bit. It is totally irrelevant how the code of your framework looks, the interesting part is how an application looks. request.accept_languages.best is how I get the preferred language from the Client using Werkzeug and/or Flask. In order to get the same result with bottle I would have to parse the header myself and handle edge cases depending on the Browser used. That results in neither small, clean, dense or particular useful code and I still have to test it, for every web application I write. Again this is a little bit unfair, who needs to know which language is preferred by the client anyway but that is kind of the point of Flask. It is as micro as you want it to be and if you don't want it to be micro at all that's fine as well.
You get downvoted because you are needlessly aggressive with your promotion of web2py. Stop it, you do contribute really good stuff. Here, an upvote. PS: Flask does compare to Bottle in simplicity. For most tasks, complexity that's completely under the hood is alright. For instance, having Apache with mod-wsgi installed wouldn't justify adding the whole Apache codebase in the comparison. Bottle wins hands down in lack of dependencies.
Works with buildout of the box too now, very cool. 
1.0 was created as a teaching tool.
LOL
The Jinja2 and Werkzeug dependencies must be included to compare apples to apples because bottles too includes a template language, digitally signed cookies for sessions, a web server, and multiple server adapters. P.S. Actually, on this thread I am promoting Bottle!
Dammit I can't wait for NumPy/SciPy support!
Thanks for the clarification. Seems interesting and I will look more into it.
web2py has an impressive set of capabilities, but I wouldn't call it complex. It's actually quite easy to learn. The [book](http://web2py.com/book) is excellent, and if you have any questions, they will be answered very quickly by the friendly and helpful [web2py community](https://groups.google.com/forum/?fromgroups#!forum/web2py). Not only is web2py easy to learn, but it's really simple to set up and get running -- it comes with everything you need, has no dependencies, and requires no installation or configuration. It even comes with Python and has its own web-based IDE.
&gt; Would you call a wrapper on top of Django a "micro framework" just because it hides most of the features and provides a simplified API? Yes.
I personally use sqlite, and haven't had any issues w/ platforms or versions.
Amazing! Congratulations to all the contributors. It's also worth mentioning web2py's [plugin_wiki](http://web2py.com/book/default/chapter/13#plugin_wiki) and the [components](http://web2py.com/book/default/chapter/13#Components)/[plugins](http://web2py.com/book/default/chapter/13#Plugins) system. Makes life even easier. :)
It wasn't clear to me from zgrep's manpage how it worked with additional args (e.g., -fF &lt;filename&gt;), so I put something I knew worked.
I can't wait for Python3 support!
1. Download and install [ActivePython](http://www.activestate.com/activepython/downloads) 2. Open command prompt and type ``pypm install mysql-python`` ([details](http://code.activestate.com/pypm/mysql-python/)) 
I don't plan on removing features, lowering the quality of code or removing documentation to win an argument. So if a microframework does not depend on anything else to be called a microframework the mother of all microframeworks (camping) and the most popular Ruby one (sinatra) are not microframeworks.
Web2py is much easier to learn than Django and offers much more productivity than web.py.
congrats on the release massimo! do more screencasts! :)
It should also be noted that while it is crazy simple to get up and running with the Web2py bundle (&lt; 5 minutes), it is also very easy to deploy in a production environment on various server environments (Windows, *nix) with different web servers (Apache, Nginx, Cherokee, etc.) and using different databases (MySQL, Postgres, etc), including Google App Engine.
I need NumPy support to move onto PyPy too. A lot of the code I work with, though, is pure Python, so PyPy will certainly speed things up.
I do not think there is an argument to win. I do not think you have to take anything off. I said and I repeat: I like Flask, although I do not think it is a micro-framework, at least not in the sense Bottle is. Yet it is pointless to argue on definitions. What is important is what it does and what it does not. DasIch helped clarify things for me. Can you tell us more about the sandbox or point us to the docs?
It's got everything you need to get started, and it's zero-setup on all platforms. Plus you have a book that will be valid across releases, since web2py maintains backwards-compatibility carefully.
My some required libraries: PIL (satisfied), psycopg2, PyCrypto.
I wonder if a pure Python/RPython version of NumPy would be usable?
Stuff's a happening here. NumPy, in parternership with MS, have been modulerizing NumPy so someone (in their case IronPython) can just implement `numpy.core` natively and then have all of NumPy fall into place. Once that lands, in theory, we can just do that in RPython and have numpy goodness.
I would choose bottle.py over web.py. Both minimalist but the former is much more modern (for example has a tornado adapter, and digitally signed cookies).
Awesome! What's that project called?
I typically use pymysql on windows. It's just easier to get it working and I don't use windows enough to faff around with mysqldb.
I don't recall it being a problem at all.
I will be all over PyPy when it moves to Python 2.7 compatibility. I have a hard requirement for the multiprocessing library, so that is the only thing keeping me from switching to it immediately.
It's called... `numpy`! http://lists.ironpython.com/pipermail/users-ironpython.com/2010-December/014059.html
Keep up the good work
&gt; web2py maintains backwards-compatibility carefully But beware that this can't never be 100% perfect! If you rely on bugs and think they are features, it could go wrong. But I've only encountered it once. In a template, dynamically generating JavaScript code. Faulty escaping was fixed and my old code relied on the wrong one. 
* Documentation? *Check* * Community? *Check* * Examples? *Check* * Screencasts? *Check* Even if you are sitting at a naked Windows PC without any IDE, you can just download the version for Windows, start it, enter an admin password and startthe server. Now you are in your browser, log in and you can access the code of all supplied applications. There's an example app, Welcome app, etc. Creating a new app is easy. You can even use a wizard for the first setup (DB, layout, etc.) but you don't need to. After that: There's a code editor in web2py and you could theoretically hack away everything without any external editor/tools. I've tried it once and came very far with only the internal web2py editor. But in the long run I prefer an external editor. And it's no problem to use one. Everything is in the filesystem. So no silly storing of templates in the database, as some CMSs do it.
&gt; at least not in the sense Bottle is Again: if that is what you think, no language besides Python has micro frameworks. &gt; Can you tell us more about the sandbox or point us to the docs? [jinja2 sandbox](http://lmgtfy.com/?q=jinja2+sandbox)
No doubt, great support, mdipierro himself replies to emails.
this looks like the rexec module that was removed because broken. I think something like this (and digitally signed cookies) should be part of the standard python libraries. How about a PEP to include your code. I would support it. 
That won't work. Python cannot be sandboxed, Jinja2 can. The techniques I use to sandbox Jinja2 do not work on arbitrary Python expressions.
Brew install jpeg pip install pil is pretty much the way of installing pil on snow leopard nowadays.
I misunderstood. Thanks for the clarification.
A new tag in git, there is still much work left but I think it's coming along well.
Worked with the Xbox Kinect using Libfreenect's Python wrappers.
hey, why are there no flames?
Cool, that helped a lot!
I agree w/ the project Euler problems. So much fun.
CherryPy is great. I get attacked from China all the time and my CherryPy site has never crashed. I use parallel python, CherryPy and 8 computers to manage documents.
Threads are great for a single computer. I use [parallel python](http://www.parallelpython.com/) and 8 machines with a total of 14 processors. It is really easy to use and the speed up is amazing. I get the computers cheap from pawn shops. You can't beat the prices. Get the ones that won't boot windows anymore. Install linux and go. 
My experience with Python isn't huge as I am a PHP programmer by default. I used my first python GUI (PyGame) to try and make a python version of Settlers. The long term goal was to learn sockets so I could play Settlers via the internet with friends. I managed to get as far as creating the hexagon board that is random on start up. I didn't get farther because I got side tracked with IRL projects.
I would like to learn a python web framework. I am leaning towards Pylon at the moment. I am not sure what I will make but that's what I would like to do. 
damsel?
damsel?
Tackling Project Euler with Sage is a lot of fun.
I thought multiprocessing is part of 2.6? As for me, I'd switch if it supported more than SQLite.
It's pretty easy. If you're using VMWare, you can set it up to share your NAT. In which case it'll appear as another private IP that you can connect to (or alias with HOSTS) from your host OS. I've been doing this for a while as my set-up, and its great since the dev environment perfectly mimics the production environment. Testing and staging is as easy as switching a database connection.
`multiprocessing` was introduced in 2.6, however since we currently support 2.5 only we've decided to jump directly to 2.7, so the fast-forward branch currently contains that work (including most, if not all, of the multiprocessing module).
I showed that to my colleagues when they wondered if I was watering down the curriculum. It was great to say 'yup. Just like they're doing at MIT.' We'll be doing C++ and Java for the second course (as we are now) I think that will work well, really.
Just out of curiosity, why do you do this to yourself?
Well, I'm currently working on Haiku OS, which is based off of the Be operating system. It has Python on it (2.6), so I'd like to start getting some PyGame working on there as well as other python-projects. Also, I'd like to see about getting python working on my ds via the acekard 2i a little better, as it can't import modules and making a while loop in the interpreter simply doesn't work (no ellipses, so I have to use semi-colons or lambdas for my code).
I realized NAT was the answer after trying everything else. As I'm running VB on a Windows desktop and have neither an SSH nor HTTP Service running natively, I just NAT'ed the relevant ports to the VM. I expected there to be an easy way to make the host see the guest as a hostname on the network, but apparently there's no sane way to do that without emulating a full network (including a virtual Internet gateway).
Mostly, because I'm still a total n00b and I didn't realize it would be hard. I need to use Windows because that's what we have at work - and I don't think think they'll let me get anything else.
I created a program that solves sudoku puzzles. Easily one of my proudest programming accomplishments. Its really fast and will find all possible solutions. Give it a blank starting board and it will (theoretically) solve every possible sudoku puzzle ever. I know this has prob been done before, but I'm still really happy with it. I can post my code if there is any interest.
&gt; daml as a haml Ah, yes...the daml...as a haml...
this is so true. OAuth can be a bit of a pain to handle (need to listen for request), but its a relatively simple with the SDK to update a status.
An adaptation of a popular templating style from Ruby (haml).
Oh, I'm sorry I guess I should try to be more helpful... I suggest showing them how much faster Windows in, and factor that into the time you lose because of your inefficient operating system. With spreadsheets and all. Depending on your bosses I guess. They might also let you install a second OS though I suspect they have a centralized Windows thing. Still, it's economically smart to at least be *able* to use Linux for certain things. In any case, this is far from my area of expertise, so I'll just wish you good luck.
Don't know where you are in skill level, but if you are only slightly familiar with it, I would recommend knocking out the first 20 or so programs in Project Euler. Really easy but they'll require you to use loops, lists, conditionals, and even recursion. I know a few people that use those problems to get a feel for any new language they are learning, since they're short enough to not be a hassle and distract you from the language.
Try reading Programming Collective Intelligence.. It's a good book with lots of examples and exercises to practice on..
This actually helped me learn a lot of the basics when I was starting out with Python: http://www.pythonchallenge.com/
I found it to be too directionless, but that might be because my python was ahead of the target skill group so I spent longer figuring out what the puzzle was than I spent solving it.
I am an ex-zope2-er and ran away from it because of its complexity and difficult debugging process. I was glad to discover pylons because it was simpler to build applications with. I grabbed the basics of pylons, sqlalchemy, elixir and formalchemy in about a month or so and wrote my first pylons web app in that period of time. I only hope that pyramid, while borrowing funny stuff from zope like url traversal, is not that complex. 
Do the models of Pyramid compare to the persisted objects in zope (when you create a zope product) ?
Is the next generation of pylons or the next generation of reopze ?
Along with python challenge and project euler already mentioned, there are: [codingbat.com](http://codingbat.com) and [python koans](https://bitbucket.org/gregmalcolm/python_koans/)
Something that's neat about jetbrains tools is their strong support for hotkeys. It's possible you'd like that. I still struggle outside of bash/vim though, so each to their own.
Yes. Yes, you are.
Not implicitly, I suppose, but both constructors and methods take parameters, so what's wrong with passing it in explicitly?
The Zen of Python clearly recommends to ignore guidelines when they're more trouble than they're worth. One of the benefits of sticking with 80 chars per line is that it allows you to fit more code on the screen. This is very useful if you work with multiple windows open at a time, e.g. shells.
That's why I prefer the LISPy style of putting the closing bracket on the same line: blah = moo( whatever, "some string", oh_hey) It also avoids the unnecessary extra comma. It's not as easy to juggle the argument order around afterwards, but that kind of thing is bug-prone anyway.
What we do in this situation is have the nested "self" called self2 - highly original but works a treat. Remember, self is not magical, it's just convention.
&gt; In java the outer self is reachable by using A.this, which is only possible due to the magical nature of "this". Which always seemed like an incredibly ugly hack in Java's otherwise fairly clean OO model. Yeah, it makes the anonymous-classes-everywhere idiom possible. But it's implicitly creating a knows-a relationship, which is a bit strange. My general rule of thumb for "inner" classes in Python: don't. Python isn't Java. But sure, if you must, just rename the inner self. Make up your own convention, use "me" or "this" for such classes. Hopefully you don't have multiple levels of nesting.
You could create another reference to the outer self. Not sure if you would consider that to be renaming it. class A: def f(self): print(self) outer_self = self class B: def g(self): print(self) print(outer_self) # Is it possible to reach the outer "self" # without renaming it to a_self and/or b_self? B().g() A().f()
It especially makes sense if you consider that functions are variables, too (except they remember their name).
I think sockets have a huge amazement potential because they give you a low-level perspective for things that are otherwise hidden underneath high-level application logic. The first time I "talked" to a mail server with a telnet client certainly made _me_ feel like a hacker.
Everything is a good alternative to [Java](http://harmful.cat-v.org/software/java), even Perl.
And here is (as a xmas present) the solution for this using Tim Goldens WMI module (this makes it so easy): import wmi c = wmi.WMI('&lt;remote server&gt;', user='user', password='password') remotetime = c.Win32_OperatingSystem()[0] print remotetime.LocalDateTime exampledate = '20101223104640.000000+060' remotetime.SetDateTime(exampledate) 
I can recommend [SPOJ](http://www.spoj.pl/) as well as the already mentioned sites. To find out more sites that have programming excersies you can look at good recommendation at [Stackoverflow](http://stackoverflow.com), for example: * http://stackoverflow.com/questions/24692/where-can-you-find-fun-educational-programming-challenges * http://stackoverflow.com/questions/325653/what-are-some-good-websites-for-programming-puzzles
I read that as "Python.... Peter North" was for a moment thought I had stumbled back into /r/nsfw
this. self is just a parameter, just name the inner ones differently and you can get at the outer ones.
Whoa Whoa Whoa, Let's not say things we can't take back. I hate Java (otherwise known as new COBOL) as much as the next guy, but we don't need to drag Perl into this.
http://projecteuler.net/
I have yet to come across a use case in which nested classes provides any real benefit in any language. I've never seen this approach pay off in terms of code clarity/readability, conciseness, ease, or anything else, and it seems like it will pretty much kill reusability of the class. Is there a particular use case that maybe I've just never come across that really screams "nested class"? Keep in mind that I've read source code that uses it in plenty of apps I didn't write, so I know it's used and don't need examples of where it's used. What I want are concrete use cases where this kind of thing would be considered a 'best practice'. 
In java you almost have no choice. If you want to define a callback function, you can't, you can only pass classes around, not functions/methods. So if you want your class to get GPS location updates on android, you make a nested class and override the methods which are the callbacks. In python I'd say nested classes are perfect for a factory of types. For example [named tuples](http://docs.python.org/library/collections.html#collections.namedtuple).
Thanks for the work on PyPy. I'm sure all the developers are being pulled in several different directions at once, but keeping up with the language changes will be a big help. :)
I always do something I really care about otherwise I lose motivation quickly. Now that is probably not the answer you wanted to hear, there is no link, no instructions but if you stop for a moment you will probably be able to think of a couple of things that always bugged you, now you will not be able to fix all of these things but there is probably at least one thing you can fix, now go on and fix it.
Do elaborate...
Nice!! Great framework!!
Technically you could, via introspection. Eg. import inspect class A(object): .... def g(self): print(inspect.currentframe(1).f_locals["self"]) However, this is intensely ugly (and unportable), so you're much better off just renaming self. 
Compared to Java, Perl and Python are more alike than they are different. Well-written Python code reads very much like well-written Perl code, just with different syntax.
I like your solution because: 1. It's obvious the "renamed" variable is related to the nested class. They're physically close to each other. 2. If anyone ever removes the nested class, no harm was done to the method signature.
I tend to use nested classes for custom exception types that are thrown by the parent class, mainly for the namespacing aspect: class A(object): . . class CustomExceptionThrownByA(Exception): . . etc. 
the only thing adapted is the use of #id and .class tag hashes and being indention base. Beyond that, they are two pretty different things. daml is also part of a larger project where the goal is to completely abstract out templating code from all your controllers, so no more tacking on related or semi-related views to a particular controller
I was dissapointed when the article failed to explain *why* python might be a viable alternative. Essence of the article: "there was this one time that I wrote a program with less lines in Python than in Java or Lisp."
i dont like the name daml and plan to change it soon, and hey who knows, the logo might just be repunzel in a tower with OSI climbing her hair to save Views from the MVC-implementation-hell Tower
...on the back of a camel that has, for whence, brought us here...
How about giving B an __init__ method and assigning the parent? .... class B: def __init__(self, a): # now B has a reference to A self.parent = a ... B(self).g() Now you can un-nest the B class and everything will continue to work Also, is there a reason you don't just define method g inside A? Does the B class serve any purpose beyond being a container for the g method?
I'm the co-founder of [Djangy.com](https://www.djangy.com) -- heroku for django. If you decided to go down the path of learning Django and doing some web apps (I think you should!) then let me know and I can get you into the private beta ;-)
No love for flask?
By itself, daml is for outlining html with dynamic content. Features inline python and a sandbox you can update with custom functions (so they are in memory, versus writing the function in the template). As part of a bigger project, daml is playing a part in completely removing the "view" from controller code and will feature an extension for requesting data via IPC from your controllers (or anywhere else for that matter if you want to wait). Overall I'm finding this significantly reduces the complexity of developing each portion of code following MVC, eliminates funky quirks that have always bothered me (stretching between idealism and realism), and its a pet project for learning and developing my own ideas related to programming.
On a rare occasion I use nested classes I name it "selfself". It's ugly, but rather descriptive.
An alternative is http://spoj.pl
requires Cython?
yes currently it does. There are a few utility functions that are written in cython b/c of the speed difference and it also depends on lxml (written in cython) and makes use of that during the final document build which is done in cython as well. Down the road, after I get all of the specifics worked out for the syntax, cython and lxml will be optional (and necessary if you want it to be as fast as possible), but theres absolutely no reason for there to not be a pure python module. It's really not that complex. --edit: I should note the "speed difference" was part of my initial profiling when I first started writing the code and finding what worked well and what doesn't. The speed of it now, visually, doesn't appear any slower but I know it's not up to par like it was before right on the heels of mako
That's like saying a horse and a unicorn are much alike ... yea, FIND me some well-written Perl code!
self is not a keyword in python like this is in c++/java, exactly to do what you ask. You can use a different name for it in the inner class to disambiguate: class A: def f(self): class B: def g(inner_self): print(self) print(inner_self) B().g() A().f() 
woah calm down reddit, it's just an announcement. why downvote it?
Even C++?
it varies, Dasa App Markup Language, da Markup Language, Dinosaurs Are Mauled 4 Life. Just depends on how I'm feeling when I wake up. Oh but this damsel bit, da Markup 4 Savvy &amp; Eloquent Ladies (and gentlemen), yes yes, that might just be a game changer
I agree an upvoted it before going off and grabbing it now that 1.1 is complete and not a RC.
Knock the price down to $50 and I'll buy it. As it stands, I don't do enough python coding to shell out twice that price. I don't see it offering that many features that I feel so attached to that I'd drop $100 on it.
Are you really that much of a language bigot? Bad code can be written in any language. My only problem in getting an example of well-written Perl is the choice itself, because there's so much of it out there. But here's one: [Class::Multimethods](http://cpansearch.perl.org/src/DCONWAY/Class-Multimethods-1.70/lib/Class/Multimethods.pm), written by [Damian Conway](http://en.wikipedia.org/wiki/Damian_Conway), 
I think PyCharm is amazing value for money, it's almost too cheap. Maybe they should release a cheaper "lite" version. 
[Tough call](http://harmful.cat-v.org/software/c++/), but at least C++ has a minimally sane subset... C.
Can't second this enough. A great way to learn the subtleties and standards of any programming language.
I second that. I grabbed a beta coupon, before they released 1.0, and got it by $50.
Write a search functionality for a wiki.
Isn't that what modules are for? If I saw something like this, I would be strongly inclined to rewrite it.
Interesting question, but why wouldn't `B` just be a top-level class that's initialized with an instance of `A`? Your trivial example is confusing enough; I wouldn't want to have to try to figure out what it's doing when there's actual business logic in there.
This doesn't solve OP's initial question but this is probably the best way to do it. Don't use the inner class to begin with, just pass self as an argument to another totally seperate class. Classes are nice. Closures (def's inside def's) are also okay for a lot of things. Classes inside classes that are also closures, while still completely possible, are sort of an OMGWTF anti-pattern.
Yeah I agree that that looks the best. I guess I don't do that because of the ease-of-reordering reason. But I guess that's not always relevant. Maybe I'll start doing that.
I agree that it isn't clearly explained why. My take was that the article simply meant to show that Python was effective (it could be correctly done in a short period of time) and expressive (the resulting code was easy to understand). That may be my own bias showing through though because my biggest arguments here at work in favor of Python are: it's effective, expressive and consistent. (Anybody who thinks C++ is consistent - I am trying to get some Python to use a DLL via ctypes and all the Googling in the world doesn't seem to turn up a single authoritative source explaining how to demangle overloaded functions. For some reason C++ decided not to standardize that and as a result it seems compiler writers decided to make inconsistent implementations of it.)
It would be extremely nice to have some sort of trigger-script capability inside eggs. However, there seems to be [great resistance](http://bugs.python.org/setuptools/issue41) to the idea, so there's no easy pre/post install hooks. In particular, it would be really nice if eggs adopted a trigger framework like the [dpkg maintainer scripts](http://www.debian.org/doc/debian-policy/ch-maintainerscripts.html), which have As it stands now, I don't think there is an easy way to run a pre-install script to check if non-egg dependancies are satisfied, and reject app installation. You could try to hijack the extension building framework triggers (designed to compile c extensions locally), bundling the code which extends disutils as another package, and then have that package listed as a setup-requires entry. Then have some custom extension builder (say a weird file extension) trigger your custom distutils command that then checks for wget, and aborts the install if it can't find it, just like a c-extension aborts the install when it fails to build. (just an outline of an idea, and of a rather hacked way to do things). The only other option I can think of is to create a python interface to wget, providing an alternative when native wget isn't present (there may be something in the stdlib already), and then distribute *that* egg as a dependancy for your app. This doesn't solve the general pre-install hook problem, but it might solve your specific need. edit: added some details
more detail? I've been wondering how to scale cherrypy in the future and how it would hold up to ddos, etc. what's your experience with that been?
all IT people should be required to learn python. it's by far the most useful tool ever. 
Sweet, multimethods! I discovered these when a friend of mine told me about the [expression problem](http://en.wikipedia.org/wiki/Expression_Problem), and now I wish I had these at the language level as an alternative to classic OOP.
That's one of my favorite parts about PyPy, we can have people working on the GC, JIT, and 2.7 support independently.
Turtles all the way down.
Hmmm, having had to write a lot of COBOL a very long time ago I can tell you that COBOL is much better than Java for a few reasons: * COBOL is just a language, not a platform * COBOL is far less verbose than Java * COBOL doesn't require an IDE * COBOL programs written in 1968 still work fine today without recompiles * COBOL is actually portable * COBOL can run on machines with just 512K of memory Note that I'm not saying that COBOL doesn't suck. Just that it sucks less than Java. Ah, just remembered another story about COBOL &amp; Java I had to share. Nine years ago when I worked at a Java consulting shop with about 300 people I performed an analysis on our productivity - and found that in 2001 when building e-comm sites using Java, JSP, EJBs, Oracle we were almost exactly as (non)productive as shops I worked at in 1985 building stateless applications using COBOL, CICS and DB2. This was based on the number of hours to develop each page.
Just try a "which wget" and fail if it doesn't return a path. But you could try and support curl too, between those you should be covered.
I'd like to see a review of the latest PyCharm vs. Eclipse vs. Komodo. I've used all 3 but can't make up my mind. For the last few years, I've been using [ulipad](http://code.google.com/p/ulipad/) which is free &amp; open source python but it's missing many bells and whistles. My casual survey suggests most pythoners use TextMate, Vim &amp; Emacs. None of them have deep integration beyond basic text editing. It would be nice to have a definitive Django IDE - is this it?
Most of the downvotes are from reddit's anti spam system itself. They are there so you can't really tell how many downvotes it 'exactly' has.
I'm hesitant as I'm fairly comfortable using geany and emacs and don't do any django development, plus it's a closed source pay-ware product. Is this really worth trying out? Does this have any advantage for non-django development over something like PyDev for eclipse?
Used urllib to download satellite info, then produced an OpenGL simulation showing where those ~6000 satellites are in their orbit around a textured earth globe. Fun stuff!
I am going to try to use the phrase "whore-level super-abstraction o'doom" at least once in daily conversation. Oh wait, its supposed to relate to python...
I would like an invite! :D
Hmm, Good points. I'll have to stop bashing COBOL by comparing it with Java. 
* COBOL's fate does not rest in the hands of Larry Ellison. (You forgot one)
This is it. The problem is it's not needed. A text editor is all we need to do Python. As long as you have a reasonably featured one, you don't need anything else and some features end up getting in the way of productivity. I find the only Django specific features that are used by most developers is Django/Jinja template syntax and code completion that will allow you to scan the Django package. 
Everybody, I respect the want for a Django specific editor, but we are not programming in the Django programming language. Further, when building a Django site, most users tend to use 10% of Django and 90% of other packages when building. You're not looking for a Django IDE, you are looking for a good code completion interpretter and text editor.
If all you want is download something, use Python's own urllib2, rather than an external program.
I wonder what's that which lets you speak on behalf of all Python developers. If a text editor is all you personally need to do Python, that's certainly fine, but I doubt you're really aware of the needs of all Python developers in the world.
Agreed. And a lot of what you learn isn't practical for everyday Python. Sure the web stuff has wide appeal, but how many people need to use PIL?
What is this referencing?
PyCharm isn't a Django-specific IDE, it's a Python IDE with Django support.
I don't understand why a Python program would need to rely on wget. 
Looks like you're missing a file: when installing (python setup.py build): gcc: http-parser/http_parser.c: No such file or directory 
I'm not sure what you mean by "should clear completely, but it doesn't". Anyways, here is a more elegant version: self.txtOutput.Clear() self.txtOutput.AppendText('\n' * 10) self.txtOutput.Clear() time.sleep(1) 
Depends on your needs. All of them can do a lot of things well (pylint, auto completion, definition lookup). Komodo seems to be the lightest, easiest to configure, comes with dark themes, and the autocompletion/jump to definition works really well.
Sorry, I'll try to be more clear. The textbox will clear one or two lines, and thereafter the lines will only be refreshed when appending new data to the textctrl.
Am I really that much of a language bigot? Yes. PERL has a well deserved reputation as being a write-only language ... so much that it's one of only 5 languages mentioned in the Wikipedia entry on WOL and I haven't hear of the other 4. Is it possible to write PERL that doesn't make your eyes cross? Sure, but it's rare, and even "well-written" PERL varies widely ... TMTOWTDI is the blessing and curse of PERL. If you can't admit that then you really don't know or love PERL. It's a mess ... and you can't just pretend otherwise or chalk it's line-noise reputation up to novice users. Line-noise is fostered by PERL ... it's a @!#$ing feature at this point. Unfortunately, if you ask 20 PERL programmers what "well-written" PERL looks like, you're going to get about 20 different answers. If you ask 20 Python programmers, you'd probably get about 5. They're different my friend .... http://en.wikipedia.org/wiki/Write-only_language
One of my few complaints with wxPython is that it doesn't repaint itself enough. You might need to repaint after Clear. Try Update or Repaint or Refresh for the control or its parent control or its frame. (I can't remember what the correct one is. Maybe start with self.txtOutput.Update())
how well does this scale? i.e., dozens of front-end servers, millions of requests a day?
try to call wx.Yield() right after self.txtOutput.Clear(), seems like it doesn't redraw itself properly.
Definitely not Refresh :-)
self.txtOutput.Update() does it! Thank you!
you have to clone the http-parser project linked on the github page into the same directory. even after i do this, however, there is another dependency which is not found on my computer; the header file ev.h. does anyone have an idea which package or project provides ev.h ?
libev-dev
``namedtuple`` is a function, though. That's the standard idiom for type factories in Python.
Is there a way to get this to run on not a port but a file socket? How does it rate in comparison to gevent?
Wrote a [computer search engine](http://www.shodanhq.com) that scans the entire internet for services/ devices and lets people search for them.
thanks a lot!
I would love an invite for this as well, if you have one to spare!
More than 1ms for Hello World? I'll stick with uwsgi
I wouldn't base your opinions on a project on a single random posting... 
That's a good idea. You should check for yourself. 
It's no different then everyone else here taking the developer's word for it.
Bloat is such a strawman attack. Who cares if uwsgi has extra features when it adds sub millisecond overhead to your WSGI app
The tricky thing about *needs* is that you don't know what you are missing until it's crunch time. If you learned all these "time saving techniques" in the IDE, that could come in handy. I don't think anyone is seriously arguing a true IDE vs. a text editor. Just because you *can* get by w/just a plain text editor, doesn't mean that's the best choice for all (or even most) situations. I'd like to save time but also don't want to "work for an IDE" (i.e. spend gobs of time learning/tweaking it). I also don't want to go camping w/the kitchen sink (i.e. bloatware w/many features I never use). At the end of the day, if you can compile the same code w/fewer keystrokes/clicks, isn't that worth something? Don't tell me I have to write this review myself; surely someone is already warming up their favorite blog editor...
Keep in mind that extending a list is not necessarily a cheap operation.
Curl for some reason is failing to successfully download the files I need to download, but wget works, so I open wget in a subprocess and it gets the job done.
Yeah, I know how to test for wget, but I'm trying to figure out how to make the installation fail. As mentioned curl hasn't been working.
Shame there's no support for triggers, good ideas for hacks though, thanks, I'll look into them
Dive Into Python 3, Learn to Think Like a Computer Scientist, the Python tutorial… There's lots of good stuff out there. Heck, if you've made it part way through Hard Way, you may as well finish it. Just don't let it be the last book on Python you ever check out. 
I think you can easily pull in http-parser using `git submodules update`.
Yeah, I wouldn't generally consider a structure based on resizing an array efficient. Something like a linked list would be much better here. 
Well the authors' argument against other projects is "bloat"--not specifically inflexibility, or over complexity, or anything that can actually be deciphered and challenged--simply "bloat". So whereas I would usually say opining about a project based on a single random posting is foppish, now I say *this is the level of discussion that the author has reduced us to*.
and TIL: that [The ‘sh’ profile is different from the now-obsolete (and unavailable) ‘pysh’ profile](http://ipython.scipy.org/doc/manual/html/interactive/shell.html)
Have been wanting to use this as my main shell for a long time now, but the startup lag is too much. I want my shell to be ready _instantly_, and not take 200ms every time I open a term.
I would think you'd easily buy back that in increased productivity unless you're opening and closing terminals an awful lot.
I think GGLucas is expressing frustration over the delay as a psychological factor. There is research on how delays can hamper creativity even if we would reap benefits from increased productivity from the syntax itself. I could probably dig it up but I am on my phone which hampers my ability to type.
You could write a script to always keep open at least one instance in a detached `screen` session at all times. That way when you go to use it, there is always one ready to go. I did this for a while for some software that took a few seconds to fire up and the only drawback was my unfamiliarity with screen.
If you want a term ready instantly, then have it running constantly, and just show it with a keypress. There are quite a few to choose from that are designed to do this, like tilda and yakuake. I use tilda with tmux at the moment. 
I would LOVE to use this as my shell, but I can't live without !!, !!:$, !-2:$:t edit: typo -&gt; !-2:t should have been !-2:$:t
Threads are hard - lets do more async servers !
&gt; take 200ms every time I open a term 1/5 of a second? For a system you will be using all day? Seriously? If anyone on reddit deserved this, it's you: "You talk like a fag and your shit's all retarded." 
Way to go - bashing your "competition" in your readme with unsubstatiated claims. 
I open many many terms every day over the course of my work. So I'm not sure why you think it's a one-off cost.
I would, but I open like 12 of them at boot, and 3-4 more every time I go and do something else. One term won't do.
Yeah, it's true. It's probably a psychological factor more than an actual one. It just ticks me off.
That sounds nice. I won't use screen since I use an immense amount of terms, but I suppose making it so that opening a term attaches and then creates a new cached session in the background could work. I'll probably use dtach or something. Investigating. Will report back.
Editor is broken on Chrome 10 dev, but it executes fine, nice work Emscripten! In any case, I am glad to see people are working on replacing JavaScript with Python.
&gt; In any case, I am glad to see people are working on replacing JavaScript with Python. Pyjamas &amp; Skulpt have been around for some time, and emscripten is a pretty interesting concept. Rather than Python replacing JS, I'd rather some generic VM to replace JS, and let the compilers flow. 
It is also getting Google App Engine support as well. I like it, I was a beta tester and got it for 1/2 price. I have reported bugs and asked for features and they devs have been very responsive. I hesitated a bit because I use Vim but I like the completion and it is Christmas so it's a present to myself. :-)
omg whatever
you could write a script to put the necessary files into a ramdisk on machine startup and wawoooo!!
ok what's !!:$ and !-2:t?
! is an event designator, and the second ! is short hand for -1. So !! == !-1. !-2 will repeat the second to last command, etc. I often end up finding myself only wanting to use part of the previous command, generally, the last word from it. A colon : lets bash know you want to use a modifier, and $ takes just the last word from the command referenced. :t takes the "tail" of the last reference (this assumes it's a filepath, so if you're referencing /var/www/site/index.php, !!:$:t gives you index.php, and !!:$:h gives /var/www/site/). cheers! read more [here](http://www.gnu.org/software/bash/manual/bashref.html#Event-Designators)
Sweet thanks!
Sounds like it's not a python problem, but a problem within pyopenCV. It can be difficult (if not impossible) to work around this sort of error. I suggest you go ask the pyopenCV people; be sure to include more code. 
!$ is also handy shorthand for last whitespace delimited word of last command. 
Like a lot of us here, I don't do enough Python coding to justify dropping the cash for an IDE like this. Might I recommend a community edition that perhaps collects stats to help make the program better? I always try to submit feedback when using community edition programs. Anyway, food for thought. 
I feel like throwing this into an HTML5 app and finally having a python shell on my iPhone without ssh or jailbreaking.
Awesome!
This is awesome.
Looks like Tornado in the end, no?
So add it perhaps? Isnt that the whole point of using a python shell in the first place, to extend/script it? Should be pretty trivial
http://ipython.scipy.org/doc/stable/html/interactive/shell.html
[Paste Deploy](http://pythonpaste.org/deploy/) anyone?
I agree with you. Nonetheless, it has happened once or twice that I had to use that technic in an environment I had control over, I knew it wasn't clean but couldn't make a better way without having to patch external libs I was using. The lesson to me was that it's not because you're using a dynamic language that introspection is A-OK. However when it's a necessity, dynamic languages make it really easy to do so.
an interpreter inside an interpreter will never ever be viable replacement for anything other than trypython.org You'd be much better off compiling python code itself into javascript, rather than the entire CPython interpreter.
Is pycharm any better than komodo ide?
Actually thanks WSGI.
I have only ever used Komodo Edit and not Komodo IDE so to be fair I can't say with 100% certainty that it is. For me personally I've enjoyed PyCharm more than Komodo Edit. PyCharm is a Java based application which will annoy some but I've been fine with that because it is faster than Eclipse and Netbeans. The latest version definitely seems faster than the initial 1.0 release. It does everything I need and so far it's had the best Django and App engine integration that I've found. Here's the features set http://www.jetbrains.com/pycharm/features/index.html I'm sure Komodo IDE does most everything PyCharm does and includes support for languages like Perl but it's cheaper and despite being relatively new does its job very well. During the beta it didn't support some libraries like wxpython because they're not pure Python. The turn around on the fix for that was pretty good. I'd say Jetbrain's support is most excellent. That is something again I have no experience of with Komodo IDE as I assume, like any other company, paid customers get better support. I would definitely recommend trying it. If you're a hardcore Komodo IDE person maybe you won't like it as much but if you're not willing to pay for Komodo IDE and only use Komodo Edit I would say without a doubt PyCharm is better but it will still cost something to keep it more than 30 days legally.
Fair enough. Sorry about the tone/phrase. It still seems cheap compared to (say) a Firefox tab, but hey: I grew up programming on the PDP-11, and everything today seems quite snappy to me. EDIT: I do have one question though ... I tend to have a lot of shells and editors open at the same time; but I don't re-open them. When I am done with one task set, I stick the icon up in the 'pool'. Do you find it easier just to kill it and restart? If so, why? 
Here's hoping for a bytecode standard.
The [code](http://syntensity.com/static/python.js).
Extending the [NaCL](http://en.wikipedia.org/wiki/Native_Client) project to compile untrusted LLVM, perhaps?
i'm much more interested in the editor, skywriter :) i hope someone will build an IDE with project management and file saving on the cloud so we can finally be independent from the desktop :)
I won't even bother looking at such a pretentious project.
Thanks, that seems to be what I could gather as well. I'd use other wrappers, but this has been the only one that has worked/worked well.
I can't see anything going wrong... * Microsoft won't implement `tailcall` correctly; it will instead implement `jumptoFunctionHeader`, which will work 95% like `tailcall`, but won't correctly setup the stack &amp; env frames, so you will have to have a VM shim to help on IE11. * Mozilla &amp; Google will trade blows back &amp; forth about who has the best VM implementation. * Opera will have a complete VM implementation right after the spec is finalized, but no one will care, because it's Opera, who uses that? * Safari will implement the VM 99%, the other 1% wasn't useful on Mac OS X anyway. 
That would be a good start, but as Poromenos says, we'd need a bytecode standard, and some standard way of transmitting patches (since who wants to retransmit the same 100k when only 5k changed?). NaCL has most of this, but who else will implement it?
It's a bit sad that this is just an interpreter. A Python to JavaScript converter would be nice. CoffeeScript is great, but I'd probably switch in an instant if someone created a working replacement.
The _minified_ code, to be specific.
(Uh, LLVM *is* a bytecode standard.)
It's not platform independent though, iirc, which isn't the end of the world, but that would mean you'd need to at least have x86, x86\_64 &amp; ARM laying around (If I'm correct; if not, you're just fine :D)
I will look into the trial version of pycharm, thanks for the info.
I may be missing something but in http://pythonpaste.org/deploy/#paste-server-factory... that missing part, left to the user, is what this script provides. 
You are devastatingly accurate, but at least this will be the compiler implementor's job to get right, and will save all of us a lot of headaches.
NaCL only supports x86, x64, and ARM because those were the platforms targeted first. A good portion of NaCL's security relies on denying target programs the ability to make syscalls, without relying on the OS to ignore or distrust them. So, it does things like disassemble the target binary and other things which are CPU-specific. For example, on x86, it mandates 16-byte aligned jumps (for reliable disassembly) and uses the segment registers to restrict what untrusted code can do - %cs is limited to disassembled code, %ds is limited to only memory that should be written, %ss is moved around to keep the OS from recognizing it as valid, etc. (And yes, it also uses OS sandboxing features where available to deprivilege itself.) A NaCL-LLVM port would be conceptually simpler - there are less unsafe features in LLVM than most CPU architectures and it's easier to do static verification to check if a particular LLVM program is going to use them. And you'd get every architecture LLVM supports, which I believe is much larger than the amount of architectures NaCL supports today. 
It would also mean that we could start to see *standard* implementations of Python on the browser, rather than a gaggle of different systems with different restrictions. It could lead to a good deal of exploratory programming (no longer would you need to setup a dev env, just download the standard Python VM to your current browser, on any machine), and with a decent security model (W7 or some other capability system) we could actually get a nice system. Plus, if you do it right, you could see Python apps leveraging Ruby code written for the same VM. I think it would be awesome (esp. when you quickly hack something together that pulls down code &amp; displays to the canvas siting right in front of you). It would be awesome.
&gt; NaCL only supports x86, x64, and ARM because those were the platforms targeted first. A good portion of NaCL's security relies on denying target programs the ability to make syscalls, without relying on the OS to ignore or distrust them. So, it does things like disassemble the target binary and other things which are CPU-specific. For example, on x86, it mandates 16-byte aligned jumps (for reliable disassembly) and uses the segment registers to restrict what untrusted code can do - %cs is limited to disassembled code, %ds is limited to only memory that should be written, %ss is moved around to keep the OS from recognizing it as valid, etc. Yes, I saw this during that bug finding contest they had some time ago (write an app that broke out of the NaCL sandbox, win $, or whatever it was). It's an interesting concept, but I agree with you, a bytecode VM based on a system that is already working would be conceptually simpler, and you could avoid things like timing attacks, or other yet-known side channel attacks on NaCL. I'm not familiar enough with LLVM's internals to say if it is a good system, but I think it certainly would be better than simply pushing the required CPU binaries (which would be a burden on small companies as well as lazy ones). 
Go figure why I get downvoted... the fact one can swap servers is due to WSGI's protocol.
I used to hope this would happen but Javascript is actually a fine language and there are some great projects going on in that language. Why dismiss all of that ecosystem?
I did not downvote you but: The script that starts the thread teaches a reader how to use WSGI to connect to the various servers (what module to import, how to pass the wsgi app to them). Your post does not teaches much and gives the impression you imply the script is useless and un-necessary (which it is if you already know the syntax for any of the listed servers). I know that you not what you meant by the way. ;-)
Indeed that wasn't what I meant, I was merely echoing to your "(thanks bottle)" in your title. 
+1 indeed
if it had the args in the right order you would be right. FWIW, PasteDeploy is more powerful in other areas. http://pythonpaste.org/deploy/#composite-applications for your more than trivial sites is where PasteDeploy shines in my opinion.
I used flup, gunicorn and cherrypy and all include a server factory.
thanks bottle and wsgi indeed! :-)
I don't understand what you mean. Python would be the compiler, compiling for the browser's VM. You wouldn't need Python to *run* the code, that would be the browser's job.
Have you tried Pyjamas?
By "Python VM" I meant the *environment*, sorry about that; any standard libs or what not, for the developer. If you were deploying to an actual application, you would, of course, not need any of this; no one would need to know that you used Python or anything really. This is what I get for typing comments in between Christ's mass events :D
Man, it would be awesome if you could use any of the standard library's libraries in the browser (most are C now, so they couldn't be compiled). Think of the rich apps we could build...
Yes, exactly, especially if things like numpy &amp; the like were ported (such as the `numpy.core` work for PyPy &amp; the like). If you exposed the full gamut of the web to the VM's core, plus had the power of decent libraries, you could have a real "web os". I've often thought about creating something similar, "HyperApps", supported by HTTP-based infrastructure: a JSON schema for apps, JSONML for documents (and documents alone), JSONRPC for network-centric computing (grids, remote docs, whatever), and a simple VM for code to be executed, using E/W7-style capabilities for security (the browser/OS could be locked down with RBAC for corps too). Still, it would serve only as an example of what could be; lower-level OS changes would be nice too. It's one of the things I've experimented with in my Scheme dialect (which has native W7 support), secure, multi-site apps. It's interesting, to say the least.
That's the best way to go.
Hrm, did the break-out-of-sandbox competition have any winners? Also, I haven't mucked around with LLVM but I can say there are a few things that need to be checked before compiling and executing untrusted LLVM code: * LLVM pointer types can be manipulated either with getelementptr (mostly safe) or casts (decidedly UNSAFE). * LLVM supports inline assembly, which is target specific and would have to be either verified by the NaCL sandboxer or rejected * LLVM can, as far as I know, hunt the dynamic symbol table for missing function declarations, which if not detected statically could be used to get at sensitive libc or syscall functions (breaking the inner sandbox) * Sign extention is done with the SEXT instruction, taking age-old jokes about dirty instruction names to the texting age.
cool, thanks!
&gt; Hrm, did the break-out-of-sandbox competition have any winners? Depends on what you mean by "win"; quite a few issues [were raised](http://code.google.com/contests/nativeclient-security/) and fixed. I do recall that certain types of issues (such as side channel attacks) were off limits, although people did release papers about it. Maybe a stripped-down LLVM with added security could work? I mean, there is quite a bit of engineering time &amp; money already in LLVM, so I presume there should be a decent system underneath that could be leveraged for such a project (although, being interested in such things, I am, of course, tempted to throw it all out &amp; start over :D).
I do mostly to save space in my task bar, I regularly have three browser windows open (each with between 10-20 tabs) for different purposes, I could cut one of those windows down if I avoided reddit..., my mail client, multiple IM windows, 2-5 terminals depending on what I'm doing, spreadsheets, reference documentation, an IDE and a network status window. I have terminals hotkey'd so all I have to do to get a new one is press Alt-F3. Everyone has their own workflow though so too each their own :)
pyinotify is the best way. You're lucky you're doing this on Linux - the way to do this in Windows is... ugly.
cool, thanks! I will be looking in to how to do this in Windows at a later date, but my current need is only for Linux since what I need it for is only stable and regularly updated for Linux.
"win" = defeat the NaCL sandbox in such a way that untrusted code can interface with the operating system. It looks like some vulns were found which could have had that effect, and it's a good thing NaCL is getting researcher attention.
also LLVM doesn't need to be remade, you just need to write a verifier which ensures an incoming LLVM program doesn't have unsafe instructions that could break the inner sandbox. Perhaps LLVM could have some security options added to it like "--noptrcasts --noinlineasm --nodlsyms" ?
&gt; also LLVM doesn't need to be remade, you just need to write a verifier which ensures an incoming LLVM program doesn't have unsafe instructions that could break the inner sandbox. Perhaps LLVM could have some security options added to it like "--noptrcasts --noinlineasm --nodlsyms" ? Of course, that's all true, but where is the fun of challenge in that? :D
Hm, okay maybe I was too dismissive. I'll look into the SDK a bit more, thanks.
&gt; "win" = defeat the NaCL sandbox in such a way that untrusted code can interface with the operating system. It looks like some vulns were found which could have had that effect, and it's a good thing NaCL is getting researcher attention. I meant that the issue I had with "wins" is that certain restrictions were placed to begin with. Yes, they were able to breach the sand box, and there were some very neat tricks to get past the verifier. 
Very cool, I've been looking for something to use with a game updater for PNG files and the like. But there's no license. GNU rsync is of course GPL'd, but presumably this could be non-copyleft if you wrote it based on only the paper. EDIT: Ah, I see on the right-hand column that it's MIT. Cheers!
Yeah, normally I label all of my code public domain if there's an option to. If not, it's a BSD or MIT license, so consider the code public domain unless you are required to have a license.
The creative commons cc0 license is the most legally robust way to do this nowadays.
Awesome - thanks for making this available. 
`win32file.ReadDirectoryChangesW` doesn't seem excessively ugly.
I'd love to see a comparison to other implementations. Also, would it be difficult to fully implement the daemon?
It is _a lot_ slower than the rsync algorithm used in the actual rsync program, but that is to be expected since rsync is writen in C. While I have no plans of re-writing rsyncd in Python, my motivation for this module is my next project: a pure-python version of [Unision](http://www.cis.upenn.edu/~bcpierce/unison/). I actually finished a Python Unison-like application, but it did not handle network latency well making it useless on anything other than a LAN. I scrapped it and will be rewriting it before too long using my rsync module.
try stackoverflow
Cython?
you should most likely look at [`os.walk`](http://docs.python.org/library/os.html#os.walk) rather than `glob`. `os.walk` will walk down the directory tree, and give you files to work with. You would then need to filter the file list it returns for jpegs &amp; move only those.
I'd probably just poll with os.path.getmtime if it's something simple
I think I'm going to play with your code and see if I can do a file snapshot viewer - something clumsier than filesystem snapshots, without the grace of apple's time machine.
Maybe you can try to run it in pypy and see if that boosts performance?
Broke it: import sys import random print 'Hello world! This is Python {} on {}'.format(sys.version, sys.platform) print 'Here are some numbers:', [2*x for x in range(5)][:4] for i in range(10): print i, random.random() prints out: JS crash: |ReferenceError: _dlopen is not defined|. Please let us know about this problem!
It is perhaps interesting to note that rsync uses the rolling checksum for speed: it is much faster to update a checksum by one byte than compute a new checksum from scratch from 4 KiB of data for every byte. However, Python's not really fast with number crunching, so it may be faster to replace the rolling checksum with, for example, the Adler 32 bit CRC (zlib.adler32). That is not an exact implementation of rsync, but it keeps the spirit.
 from fs.opener import opendir from fs.utils import copyfile from fs.path import basename src = opendir('C:\Users\Jack\Pictures') dst = opendir('C:\Users\Jack\Desktop\Pictures') for path in src.walkfiles(wildcard="'*.jpg"): copyfile(src, path, dst, basename(path)) Requires PyFilesystem (http://code.google.com/p/pyfilesystem/)
One solution to the file system issues is to use PyFilesystem (http://code.google.com/p/pyfilesystem/), which lets you restrict all operations to a root directory. Paths with backrefs outside the root will throw an error.
&gt;Wrote a Squid-Cache helper that checks to see if a system is supposed to have internet access. Care to share the code?
cool, thanks!
cool, thanks!
It's the exact same checksum they use in the paper minus the modulus because it isn't necessary in Python. And you're right, it's not an exact implementation of rsync it's the rsync _algorithm_. EDIT: Also, I experimented with Adler in a past revisions -- doing a full checksum each time even using zlib is a lot slower.
Microness is about API design, not weight of code. Many high-quality lines are easier to read and follow than a few low-quality ones. Does your measurements include docstrings and comments?
SSL is mostly irrelevant to a WSGI framework - it's about the server. Flask can be [deployed on Tornado](http://flask.pocoo.org/docs/deploying/others/#tornado).
Stupid question, but a few years back I had to get fairly familiar with the trade-offs between GPL, LGPL, BSD and MIT. Is there an idiot's guide to CC0 and Apache that you happen to know of? [Google just turned up the actual license(s), and I have been known to miss things when reading legal documents]. Thanks!!
Because it's an idea inspired by bottle: wraps some wsgi server's interface and provides a normalized run-with-xxx interface.
I love these small servers, however, it seems that there is no significant differences between bjoern and fapws3, both based on libev. Anyway, I love this small server. 
&gt; a normalized run-with-xxx interface That interface is provided by WSGI. Bottle merely makes it a clean function of it. I'm not denying the usefulness of that module but it would probably wouldn't even exist without WSGI.
Interesting. When I did a (toy) implementation of rsync in Python, the zlib.adler32 checksum was much faster than the rolling one in Python. (See http://blog.liw.fi/posts/rsync-in-python/ for the code; I have not touched it since, though.)
inotify is the most scalable way. Your program won't use any CPU while waiting for the file to appear. Just polling with os functions is the simplest way.
cool, thanks!
the macport problem is on the Numpy which require atlas. You could compile your own numpy or add +no_atlas on your macport while installing numpy. sudo port install numpy +no_atlas sudo port install pygame
exist http://librsync.sourceforge.net, used by rdiff-backup util
That's not Python.
Yeah, I think starting with "actually" implies a correction (i.e., "Actualy, thanks WSGI, not Bottle"). Perhaps you meant, "Also, thanks WSGI".
There are some improvements you could have made: - `block_data = block_data[1:] + f.read(1)` ; Slicing is a bit slow. Collections.deque combined with popleft and append is faster. I tested this on one of my machines, and while I don't have access to the code right now, slicing and appending was a huge perf hit. Deque is stored as a linked list so popping edge items runs in O(1). - Despite Python's fast hashing, using list.index for the signature lookup table is actually faster for smaller lists. - When you find a matching block, you can usually skip over the next "blocksize" bytes of data. ~~You did make me realize that there is no reason I should not be generating the target's signatures using zlib even if I don't use it in the delta generation.~~ Forgot, It's not the same checksum as Adler-32 so zlib won't help. I have to wonder if your rolling checksums were not implemented efficiently enough because I found they made a huge difference.
It looks a bit childish, but I think its rock solid, fast, easy and fun... ̣http://inventwithpython.com/
Too pedantic for Christmas :)
Maybe you will find [this](https://github.com/skorokithakis/omnisync) useful?
Shedskin?
Cool. Thanks!! Bookmarked, gonna use it to show my nephew who is showing interest in gaming and development. But I am looking for a specific one. It was a few page long tutorial that showed simple syntax etc...
_Actually_, Christmas was yesterday. Or is that too pedantic too? :)
An [average Python developer in the UK](http://www.itjobswatch.co.uk/jobs/uk/python%20developer.do) earns about €56000 *gross* or €41000 *net* at the end of 2010. Assuming this person is working 250 eight hour days a year which is 2000 hours, they are earning €20/hour *net*. It's going to take one morning of work to earn enough to pay for an €88 PyCharm license with their own money. Based on my own use of PyCharm over the last few months I reckon it's already paid for itself several times over.
* [The Python Profilers](http://docs.python.org/library/profile.html) * [Guppy memory profiler](http://guppy-pe.sourceforge.net/) * [Line profiler and kernprof](http://packages.python.org/line_profiler/) 
7
Why use Mac Ports at all? It is easy enough to just use virtualenv + easy_install or pip. Just download all the SDL frameworks from the SDL website and install all the library requirements which means that you don't fill your drive up with a bunch of crap from Mac Ports.
It's entirely possibly that my rolling checksums were implemented inefficiently. I did the adler32 checksum early on and did not spend a whole lot of time on the rolling ones.
Another really good place for newbee questions is the python tutor list. The tutors are awesome and explain things very well! http://mail.python.org/mailman/listinfo/tutor
Ctrl-F 7, upvote.
&gt;However, if I am loading a webpage, then sending that data to the user, could that result in making my router slower? How does this compare to me just surfing the web on my home network on, say, my laptop? If it's a problem, what's a more efficient way to do this? Why would your router gets slower? All the bandwidth your laptop is using is not available anymore to your server of course. The most efficient way is to buy webspace on a dedicated server.
Please stop, poorly made web crawlers are basically the bane of every sysadmin on the planet. Unless you intend to support robots.txt and the sitemap protocols, and build in things like rate limiting and loop protection from day one, you are going to make a lot of people very sad.
It's just for me. Not making it for actual use.
Are you using it against anything other than your own servers?
Not quite sure what you mean, sorry
Are you using it to a mirror a site that isn't your own? If so, the way you're trying to get all their data on their website is probably wasting their bandwidth allowance, as well as potentially accessing areas of the website they don't want you to. EDIT: Apparently this was downvote worthy. Jesus christ.
I've always used Python from python.org and the Pygame installer without any problems.
[How to think like a computer scientist](http://greenteapress.com/thinkpython/)
I [submitted](http://www.reddit.com/r/Python/comments/ergxw/rsync_algorithm_in_python_now_runs_at_a_usable/) this code to reddit shortly after I submitted it to Active State.
(upvoted for relevance)
The title of the post says Snow Leopard, but the blog post is about Leopard. I had no problems using base python 2.6 from python.org and latest pygame using Snow Leopard.
PyPy?
[Learn Python the Easy Way](http://learnpythonthehardway.org/index)
There are dozens of ways an inexpertly built crawler can bring a site to its knees. I don't mean to discourage people from learning Python (and indeed, this has nothing to do with Python), but building a crawler isn't a task to be taken lightly. If you think that a mirror of a specific site would help that community, talk to whoever runs the site and you can probably work out a more efficient way to mirror it. If you have a legitimate academic reason to need large numbers of web pages as some kind of corpus, talk to the folks at archive.org and/or Alexa and you can probably work something out. This is *not* a project to undertake as a learning exercise unless you will take exceptional care to never run it against a server you do not control.
 for a in range(100): print a / 10, a % 10, (a / 10) + (a / 10) % 2 Edit: I think the nicest way to write this would be: for a in range(10): for b in range(10): print a, b, a + a % 2 I don't know if math.ceil supports rounding to arbitrary numbers, but I would maybe use that instead of the a + a % 2, which is sightly hacky for my tastes. 
Mainly my question was asking how to make it one line. For instance, putting the for loops in square brackets and such. But I like this trick a lot!
Also take a look at this: http://www.2style4you.com/
Python 3: print("\n".join(["{0} {1} {2}".format(int(a/10), a%10, int(2*round(a/20+0.5))) for a in range(100)])) Edit: `briancurtin`
If the above is correct, one line would be: [print (a, b, a + a % 2) for b in range(10) for a in range(10)] Or are you thinking of the non-simplified version's logic in one line?
This is not your blog.
Astute observation
Why not? wolfbaden6: tell us more.
What's the point of this post? Lonely? Felt other r/pyhton's readers' screens weren't cluttered enough already? No one is forcing you to do this. If you want to learn programming, there's a reddit for that r/leanrprogramming (gee, we sure did hide that one, didn't we?). 
The point of the post was to introduce myself in this subreddit. I am not lonely, just friendly and I like to share. How the hell am I supposed to know how cluttered your screen is? I'm well aware nobody is forcing me to do this. Thank you for the suggestion, it seems to be the only nice thing that has been said to me in here so far, but the sarcasm was entirely unnecessary. Glad to know r/python is such a welcoming community.
Good luck. Python is a great programming language. More so as a first programming language. Grab the official tutorial (python.org) or Learn Python the Hard Way. And when in doubt - head over to stackoverflow.com or /r/python and ask away. 
&gt; Putting the for loops in square brackets We like to call them 'list comprehensions'. 
This guy has a .. oh wait. wrong sub-reddit. Carry on.
oh com'on. Please dont troll. Troll, if you must, choose the right /r/
Here's another one, but I found it to be a fabulous video-tutorial. I think It's a good watch, and shouldn't take too long: [Learn Python](http://goo.gl/rBuun)
The information on coping with filesystem paths is dangerously wrong: the sequence "../" can appear at any level of the path, e.g. `safe-subdir/../../../../etc/passwd` (give or take a few "../"'s depending on how deep you assume the app to be nested). I only had to use the filesystem once in a small local app and I used `os.path.abspath` with a "/" prefixed path variable before removing the prefix again and passing it to `os.path.join`. This would fail disastrously outside POSIX-y filesystems, but it did the trick for Linux (it still suffers from all the other attack vectors mentioned in the article, tho).
The reason you are being downvoted is that the OP explicitly mentioned they have been using that tutorial so far.
I use rsync for most of my backups and updates to keep computers synchronised. I have always been frustrated by the inability of rsync to give you any information on the overall progress: you can get a progress bar per file, but not on the global backup progress. Any plan on adding this kind of feature to your python implementation?
And in case anyone else is confused the guy's project name do clash with this one http://pypi.python.org/pypi/pyquery (jquery like queries on XML DOM). 
How does this solve anything that isn't already solved with list comprehensions?
you can combine the two loops with zip like so: for (a,b) in zip(xrange(10), xrange(10)):
Because here, the votes decide. And apparently they have decided that this is not the OP's blog.
I am not working on a re-implementation of rsync in Python, but it will be used for [this](http://www.reddit.com/r/Python/comments/ergxw/rsync_algorithm_in_python_now_runs_at_a_usable/c1aca3g). Everything is computed beforehand, and some form of progress meter would more than likely be included; I had the same frustration with that, and I once considered doing an rsync dry run just so I could get the total amount of data that would be transferred to make my own progress bar.
From the [documentation](https://github.com/timtadh/pyquery#readme) &gt; The motivation for this work occured while working on a software system with a unified namespace to address heterogenous data models. Some of the models were relational, some were XML, and increasingly some were simply native python objects. To unify this namespace I am working on this language. However, I expect that since PyQuery works on any Python object collection it may be generally useful to the Python community I am not the author and have not evaluated his claims :-)
No `print` statement.
Finally. The lack of a proper installer was the main reason I never played with PyGTK.
Exactly. PyCharm is really cheap. 
lean towards pyramid, though pylons will be supported for a while, the new development is happening in pyramid now. http://docs.pylonshq.com/pyramid/dev/index.html
I have actually ended up writing a css-selector like functionality for python in one of my projects sounds like this could be a neat stand-in. But it's to much bloat for my taste when the purpose is to do xpath queries.
You're a Software Development minor and haven't learned a single programming language? Python is a good choice at least. You'll want to look through some of these: http://www.sthurlow.com/python/ http://zetcode.com/tutorials/pythontutorial/ http://inventwithpython.com/chapters/ http://www.dickbaldwin.com/tocpyth.htm http://www.pythonchallenge.com/ http://www.youtube.com/watch?v=tKTZoB2Vjuk http://learnpythonthehardway.org/index 
Can we use list Comprehension? Something like the following: [[a, b, a + a % 2 for a in range(10)] for b in range(10)] I can't check it right now. EDIT: I can see that someone has already done this, and better.
Isn't cherrypy and rocket redundant? Or am i missing something?
very, very welcome. would love to see support for python 2.5 as well, since it's even more difficult to get set up.
I've only taken one course for the minor so far and that was Discrete Mathematics I. I'll be taking more classes for it this coming semester though.
I don't understand, I installed the pygame libraries and dependencies in less than 20 minutes just a few days ago on Snow Leopard with fink like any normal application. 
Yeah, this crashes too: print float('inf') with |ReferenceError: _copysign is not defined| I'm not really sure which "us" we'd be letting know about the problems. 
Perfectly legit to ask how concisely this can be expressed. But the one-line expressions in this thread are all pretty far beyond the bounds of what I'd consider "pythonic". I think the reason [this comment](http://www.reddit.com/r/Python/comments/erumz/how_short_can_i_make_this_snippet_of_code/c1afacd) breaks the thing out into two nested for loops and three total lines is that it's really really easy to see what's actually going on in the code. I'd argue the readability of that example is much more in the Python zen.
Okay, given: from itertools import product def output(tup): print " ".join(str(x) for x in tup) One could do (some stolen from klohkwherk): map(output, ((a, b, a + a % 2) for a, b in product(range(10), range(10))) Edit, actually without itertools.product, you can do this: map(output, ((a, b, a + a % 2) for b in range(10) for a in range(10)))
os.system("title %s" % a) Note: depending on where you are getting the value of "a" from, this is not the most secure method of doing this.
I must have misread your question because it reads to me like this would be the solution: os.system(a)
The biggest thing you'll notice coming from Java to Python is the huge syntax differences and some changes to the rules. Instead of "else if", we have "elif", when we define functions, we don't declare what they return, and when we define variables, we don't declare what type they are. I love Python because it's short and simple, and requires less typing to do more. Classes, functions, loops, all become a lot easier with Python. The idea behind fixed-size arrays goes out the window and evolves into lists, dictionaries, tuples and iterators. The best thing about Python is, I can have an idea, small or large, open up the Python IDLE, and code what's in my head with Python. Compared to Perl, you might notice some similarities. You won't need the dollar sign or other fancy symbols to create variables/arrays. In fact, there's no such thing as a "for" loop in Python like there is in Java/Perl, there is a "foreach". There's also no 'variable++' or 'variable--' like Java/Perl. I did use Eclipse + PyDev for a while, except I really dislike IDEs. Being a linux user I like doing most of my code with regular text editors (Gedit for instance) and run the code via terminal. My friend however uses Aptana and says he likes that better than Eclipse for Python. You shouldn't have any problems installing Python on Fedora whatsoever. In fact I'm not sure if it's already installed or not on Fedora. People would recommend 2.x series over the 3.x series because of some very tiny differences in the versions. I've only encountered very small issues mostly related to package name changes, certain method removals from certain classes, and a change in bytes and string. The biggest thing I couldn't get used to was the change in the "print" function, where it went from 'print "something"' to strictly 'print("something")'. For the beginning route, you should use 2.x because I think it's easier to learn with, and most tutorials teach using 2.x. I've been using Python for a few years now and safe to say, I still love it! If you take the time to learn Python, I'm sure you will too.
That did the trick! Thanks!
With this I get an error saying, that the value of "a" is not recognized as a command or some such.. "a" is just a string afaik.. The program is not made by me, I'm just trying to "enhance" it =) Thanks anyways!
Ahh, I see what I did wrong after reading jjheiselman's post.
- Understand how Python is strongly but dynamicly typed. Everthing is an object of a certain type. Variables are names/labels to objects in memory. - A consequence of this is the concept of ducktyping. Python doesn't care about types of names (they have no type, they point to objects of certain types). Therefore, if two objects of different type have the same method names, you can call them in your client code with no need being concerned about the type. That makes it extremly easy to extend your code without modifying. You're basically coding against an interface by default. There's hardly need for abstract classes and inheritence based polymorphism (just create another class with the same method name and signature). - Be careful about mutable and immutable types. Every good resource for beginner will give you more info on it. - You don't need to make a class for everything. Often, functions are the best choice. - Functions are first-class objects. You can pass them around to other functions. This can make certain patterns extremly easy to implement. Generally, Python makes a lot of things much easier to achieve. Don't try to translate "famous" design patterns 1:1 to Python. Check out Alex Martelli's talks about Patterns in Python (google ...) - Python is much more readable then Perl. There should be only one obvious way to do things. Google for Zen of Python for more info. - Eclipse and PyDev are perfectly OK. I prefer Wing, but IDEs are a very personal choice. - I'm not aware of issues with Python x64 - If you're not planing to start a web app project in the near future, I would go with Python 3.x. There're plenty of discussions about this topic here. You can search for more opinions. EDIT: Check out this!!! http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html
Not to code everything in OOP.
The biggest language quirk is the multithreading crap. Well, I guess this is more of a CPython quirk, but chances are that you'll be using it. Anyway, multithreading is fake in Python due to the Global Interpreter Lock; everything is single threaded. Sucks. The most important difference between Python and many other languages is the emphasis on elegance and simplicity. Keep that in mind when programming and you're golden.
* Do not approach Python from a "Java perspective". Instead, approach it as a complete beginner. The two languages differ **greatly** in philosophy and design. Static vs. dynamic typing, inheritance-based vs duck polymorphism, and the general distaste for GoF-ish design patterns among Pythonistas are the most significant ones. Python 2.X's quirks are mainly limited to the string/unicode division, IMO. Python 3.X resolves this issue by making all strings unicode. Learning Python as a newbie has the added benefit of making it easier to resist one-dimensional comparisons with other languages (like Java). Neither is "better". They're just different, and have their particular uses. * Python is also quite different from Perl. It's designed to be consistent, readable and mathematically elegant (see list comprehensions). Python's general sentiment of "explicit is better than implicit" captures many of the differences in design. * Eclipse + PyDev works well enough for my purposes. PyDev doesn't work with virtualenv, but it's otherwise solid. It has code completion, Django-specific commands, integrated REPL, etc. * I haven't encountered any issues with Python x64 (both 2.X and 3.X) on POSIX-like systems. Windows COM modules used to have issues with x64 at least a year ago, although I don't know what the situation is now. * There is much more production code out there in Python 2.X than there is in 3.X (by orders of magnitude). Many 3rd party libraries haven't been ported to 3.X, Django being a famous example. I'd recommend learning both languages. 3.X is cleaner and has fewer quirks. *Learning Python* by O'Reilly publications takes one of the best approaches to teaching both variants simultaneously. They really aren't that different. EDIT: If you're starting new projects with Python, and if you don't require 2.X-only libraries, please stick to 3.X. This is a snake/egg issue for the Python community, so we need all newly hatched eggs to contribute to a better future for the programmers. ;-)
You're welcome.
Python should come standard on any redhat derived os. A lot of the plumbing is done in python.
dont think this works
One thing to be very careful of is that you can write Java in any language. Do not do so! A big initial clue is you start writing getters and setters. (I was guilty of that in my first Python program.) Read lots of existing Python code. This will teach you what is normal. (eg you'll note a lack of getters and setters.) [This article](http://dirtsimple.org/2004/12/python-is-not-java.html) about [Chandler](http://chandlerproject.org) although it doesn't explicitly say so is a very good starting point. Coming from Java you are probably used to Javadoc. That is by far one of the best things about Java in my opinion. Python has gone through a few alternatives over the years so you'll see varying guidance of varying ages giving different advice. Current best practise is to use [Sphinx](http://sphinx.pocoo.org/). You'll also find the community very warm and inviting. Write some code to solve whatever problem interests you (eg Suduko), keep trying to improve it which in Python usually results in making the program shorter **and** more readable and then post to a forum asking for advice on improvements you may have missed.
However if the OP decides to use jython to tie in with his java skills, he should note that jython has no GIL.
Thank you all for the feedback so far. Since posting this post, I have installed Python on my Windows box and updated to the 3.x for Fedora. Eclipse took a few minutes to set up and all is set for the fun to begin. Did Hello World as always. Anyways, my plan is to follow the MIT OpenCourseWare assignments for Python: http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2010/assignments/ I've used MIT OCW before for C++ and it kept me on track. 
Good to know there are no fixed arrays. I hate that in Java. I always tried to use ArrayList instead of an array if possible. 
Regarding the "web service cluster" architecture -- does anybody have experience with this? I haven't seen any tutorials or books on creating web applications that use components via a common protocol, but I've heard some major sites use this to prevent single points of failure (e.g. in e-commerce if the suggestions engine is unresponsive, you can isolate that problem by providing generic suggestions as a fallback). It seems like this would incur quite a bit of overhead (for handling the protocol rather than being called natively) but in many cases could be worth the effort. Are there any introductions to this from a pragmatic perspective (i.e. not a Comp Sci book on distributed systems)?
http://www.pythonchallenge.com/
Who the fuck is Brad Feld? :)
Sounds to me like you need to start yourself a project. Why did you want to learn python in the first place? Are there any interesting programs you use that you know are written in python? Maybe searching github for the Python language could help you out: https://github.com/languages/Python
It was installed indeed. Just updated to the 3.x. 
I don't think that's a problem right now. I doubt I'll be doing multithreading in Python any time soon. 
Yup. I learned about Javadoc early on and have been using it ever since. I will look in to Sphinx. Anyways, my plan is to follow the MIT OpenCourseWare assignments for Python: http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2010/assignments/ I've used MIT OCW before for C++ and it kept me on track. Trying to find a random problem to work on early on doesn't work with me unfortunately, as I find that I try to solve something very complex with little understanding of the language. &gt;keep trying to improve it which in Python usually results in making the program shorter and more readable and then post to a forum asking for advice on improvements you may have missed. Apart from this subreddit, would you recommend some specific Forums? 
More specifically, you are exposing yourself to [shell injection](http://en.wikipedia.org/wiki/Code_injection#Shell_injection).
I think the better question is, who ISN'T Brad Field. If we narrow it down by eliminating everyone else, we can quickly learn who this guy is. 
Solve Sudoko then. You'll have to learn how to do program invocation, file input, iteration, recursion and passing a data structure around. Start with a brute force solution that just tries all possibilities. As a data point I did that a while back out of curiousity and the file is 60 lines long. It is so fast that I didn't bother trying any more [elegant algorithms](http://norvig.com/sudoku.html). It usually solves in under a second. [The most complex Sudoku](http://zonkedyak.blogspot.com/2006/11/worlds-hardest-sudoku-puzzle-al.html) took 90 seconds. This also underlies another Python principle. In general we don't care about runtime performance that much. One reason is that you can always improve runtime (profiling, algorithms, parallelism, calling C code etc). But the other is that it is a lot quicker to write a Python program. For example if it takes 15 minutes to write the solver and then it runs in 90 seconds then that is preferable to something that takes 3 hours to write and runs in 9 seconds. 
Prototype one of these as quickly as you can: http://ycombinator.com/ideas.html
&gt; Do not approach Python from a "Java perspective". Instead, approach it as a complete beginner. You can replace "Java" in this sentence by a lot of languages. How many times I stumbled upon C++ code disguised in Python… Don't ever write this.
Well, why did you learn it in the first place? What did you see yourself doing with it? Provided you don't have any work in that vein, I always recommend Project Euler. The early ones are simple but the later ones will make you think about how to represent the problem with different data structures and will force you to thoroughly consider what algorithm you want to use. A few deal with number theory but others only require good thinking.
He's fairly well known. Follow the link and read his bio if your question is sincere.
Try this: http://projecteuler.net/
Do not ignore the Python interpreter. Spend some time interacting with it rather than writing .py files. A lot of questions are answered a lot faster by starting the interpreter and trying something (or reading a __doc__ string) than by looking it up. 
It's one of the better things about Python. Lists are nice, but sometimes fixed arrays are faster. NumPy's arrays make that difference.
top notch info man. especially about design patterns and their role in python. it took some of us a while to let those go, but it's totally worth it. :) 
Thanks for the info m8. Going with Python 3.x as I have 0 Python stuff right now. 
If you really need to, you can always use multiprocessing instead. Threads are overrated anyway.
I am not Brad Feld. Who else here isn't Brad Feld?
It's funny you mention Sudoku. That was one of the first projects I had to do for AP CompSci in Java last year :)
&gt;Do not ignore the Python interpreter. What do you mean exactly? Are you talking about the Python shell?
Ok, just a quick update: I just finished the first set of assignments in MIT OCW (see: http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2010/assignments/ ) and I gotta say, it's a shit ton of less writing compared to Java in some cases. And not having to specifically state if a variable is a string,int,double,etc is pretty cool :) So far I know: * Get user input (input,raw_input) * Math ops * Basic string manipulation (ie. print string + number in the same line) Two question: WHY isn't there block commenting ( I know I can use the triple quotes to get around this)? And why use # instead of // for comments, seriously, every other language uses // for single line comment ?!?!?
Not from me, nope. I've got nothing against flask (well, I don't like that it uses stacked object proxies) but a) it isn't directly related to the Pylons / TG / Pyramid lineage that was specifically being asked about and b) it's not what I would use.
&gt; And why use # instead of // for comments, seriously, every other language uses // for single line comment ?!?!? Any language that plays nicely with a unix console uses # instead of // (e.g. shell scripts, Python, Perl, Ruby). See [shebang](http://en.wikipedia.org/wiki/Shebang_%28Unix%29) for the reason why. Only post-C++ C-like languages use // for comments. SQL uses --, Smalltalk uses quotes, Scheme uses semicolons, Fortran uses exclamation points and Pascal uses curly braces. But more to the point... philosophically multi-line comments should be fairly rare. You may have a big header at the top of the code for housekeeping, but otherwise, what are you putting into your comments that should not go into a doc string?
&gt; WHY isn't there block commenting ( I know I can use the triple quotes to get around this)? better question: why doesn't your editor have a "comment this region" command? ;) Also, don't use triple-quoted strings for comments, they are for string literals and docstrings. &gt; And why use # instead of // for comments, seriously, every other language uses // for single line comment ?!?!? no, lots of languages related to C do. python descends from a language called ABC.
it's not really a shell, but I assume themissinglint meant the python interactive interpreter aka repl.
&gt;From a few posts here on Reddit and a few other places people seems to recommend using Python 2.x.x over Python 3.x.x. Why is this? because 3.x is a different, incompatible language to 2.x, and 2.x has much better documentation and library support. as to some tips: * don't write pointless getters and setters * no, really * use a (single) leading _ for attributes you consider 'internal' * at some point someone will tell you that two leading underscores in an attribute name makes it 'private' - ignore them, it is a trap (all it does is enable name mangling which is rarely useful) * all classes in python 2.x should inherit from 'object' rather than nothing * don't try to type check things * don't use try/except: (ie catching all exceptions) unless you re-raise the exception in the except block
Yeah, I know the triple quotes are for docstrings, but this is the only work around that I found. Eclipse, AFAIK, doesn't have a comment command.
Ah. That makes sense. &gt;But more to the point... philosophically multi-line comments should be fairly rare. In final code, yes. However, when I just want to take out a method temporarily in Java for testing, I use a multi-line comments. 
On a related note, has anyone written or seen a really good Java for Python programmers tutorial?
&gt; Eclipse, AFAIK, doesn't have a comment command. It's Ctrl + / on Windows and probably Cmd + / on OS X. Select as many lines as you want and hit the key combination.
http://www.ibm.com/developerworks/opensource/library/os-ecant/#N100B7 seems to say it does. but really, don't use triple quotes for comments, even if your editor makes it hard. comments inline with python code are fairly rare - usually just for explaining things that are not immediately obvious and can't be put into a docstring'd function for some reason.
I've never been able to get macports to work properly for me. But I don't remember having any problems installing PyGame. Look: http://i.imgur.com/1edhV.png
Any such tutorial will be woefully inadequate in teaching you to produce good Java code. There are certain core concepts in Java - such as generics and anonymous classes - that have no equivalent in Python. These concepts don't necessarily make Java more powerful, but their reasons for existence are very Java-specific. Better to learn the language from scratch.
I use Freemind as a central database of everything. On the backburner, I started a parser for it to eventually make a web interface to browse it. I'm gonna use PyQuery for that probably.
I had no clue about that command... Thanks. I feel quite silly now. EDIT: To be fair "man" is more natural and a couple of keystrokes shorter :P
The author (very poorly) was trying to describe web services, not scalable web architecture, but...very briefly: Database servers are normally the only servers that are clustered. The servers containing the actual application are generally treated as individually disposable. There might be a entire rack or more of identical 1U app servers. Requests are can be load-balanced across the servers using a number of different methods, from switches at the network level, to proxies at the application level, or using poor man's load balancing via round-robin DNS. When needed, performance can be improved at various layers of the system using different types of caching. Solr and memcached for the DB, and Squid or maybe Varnish on the app side of things.
TIL
Ah, right, you'll need to: from __future__ import print_function And get rid of the space: [print(a, b, a + a % 2) for b in range(10) for a in range(10)] :-P Does that count?
I find that IDEs and editors like WingIDE, Komodo IDE / Komodo Edit and so on are better suited for Python development workflows. Going away from Eclipse may also help you make the mental disconnect between Python and Java. You should definitely experiment with IDEs and editors for Python a bit. For the initial coding (and possibly forever) a good old text editor with syntax highlighting should do the trick, though. The great thing about Python in comparison to Java is that you normally don't have as much file hierarchy to worry about and don't need to compile your files directly. It's also a very good idea to get used to working with the Python interpreter (you can just run `python` directly, btw). It serves doubly as a testing ground and as a universal reference: you can experiment with syntax or new libraries, and you can easily look their documentation up from within the shell. It also makes a great calculator.
Does that work with PyDev too or just in Java?
A few things to try and learn: * [List comprehension](http://www.python.org/dev/peps/pep-0202/) - Process lists concisely * [Object customization](http://docs.python.org/reference/datamodel.html#basic-customization) - Make your Python objects behave in a manner consistent with that of other objects. * [First Class Functions](http://en.wikipedia.org/wiki/First-class_function) - Unlike in Java, functions are objects. This is useful. * [PEP 8 Style Guide](http://www.python.org/dev/peps/pep-0008/) - The style conventions exist for a variety of reasons, and even if you don't understand them yet it's a good habit to get into. * [The Zen of Python](http://www.python.org/dev/peps/pep-0020/) - It's not always easy to apply, but it's good to have in the back of your mind.
Finally, there was a lot of fighting over the second-place framework and it's good to see that the duplication in efforts will decrease.
Well, the great thing about .bashrc (and linux in general) is that any reason is a good enough reason because you can do any damned fool thing you like and the rest of us are none the worse for it. Pydoc's worth taking a look at on it's own, though, just because it has search (maybe wrap apropos as well?) and can generate html. In fact, I generally use the -g switch and fire the thing up in a browser, because you can follow links and it's fairly natural.
It works with PyDev. You can verify the shortcut in the gigantic "Edit" menu (but then every menu is gigantic in Eclipse).
I am currently learning python as well, and would like to move beyond developing simple programs without much purpose for my own use. Could I be involved as well?
Do you recommend Pyramid even to those without zope background?
An engineer turned VC and fairly interesting blogger. Certainly not making him into some sort of idol but though the article was worthwhile.
According to his bio, some guy who made a lot of money with venture capital and is somehow involved with Zynga, among other things. Apart from being economically successful and investing in start-ups, there doesn't seem anything particularly noteworthy about him. Apparently he has more credit as an investor than as a programmer.
The Turbogears developers better get cracking on improving the documentation if the average quality of documentation in Pylons/Pyramid is to be maintained at its current excellent level through this merger. Documentation quality is the main reason I moved away from Turbogears (poor documentation) to Pyramid (excellent documentation). It may be important that Pylons gets a full stack framework from Turbogears; it's much more important that Turbogears gets its documentation ethos from Pyramid.
&gt; iterators Emphasis on iterators/iterables. Many languages have iterators, but with Python they're pervasive. This is one of my favorite expressions, where f is an already opened file: all(regexp.match(line) for line in f) It goes through the file and checks that every line matches *regexp*. At no point does it have to keep the entire contents of the file in memory. If a line doesn't match then the file doesn't have to be entirely read into memory. To break that down: * Files are iterable (line by line, with the line ending still on the end) * Generator expressions process one iterable and create a new iterable. They're a lazy version of a list comprehension. * The builtin function all() takes any iterator and returns true if the iterator never spits out a False value. You can also use functools.imap, which is an iterator-base version of the builtin map(). This does the exact same thing: all(functools.imap(regexp.match, f))
Documentation quality isn't just good for it's own sake - it's an indicator of the quality of the product as a whole. Poor, out of date documentation in a project often goes hand in hand with poor, buggy and unmaintained code. 
Nice, clear post. Thanks!
For viewing the profile module's output, [Gprof2dot](http://code.google.com/p/jrfonseca/wiki/Gprof2Dot) and [RunSnakeRun](http://www.vrplumber.com/programming/runsnakerun/)
Hmmm, that looks great, one of my favorite features of bpython but it doesn't appear to work on Snow Leopard.
Sounds like good advice. On that same vein, any good tutorials on generics and anonymous classes?
Wonder what this will do to the Django userbase. I debated long and hard over Python frameworks a year or two ago. Pylons was very interesting to me but ultimately I chose Django for community, documentation and several essential batteries that were not included with Pylons. Perhaps in the future I will be using Pyramid.
zope/bluebream (or whatever they are calling it) isn't/wont be built on pyramid as far as I know. not sure if that was your intent. 
Just in case anyone's trying to use these who's just getting started, you're gonna need three lines at the top of the file as well: import os import sys import pprint plus anything else that needs importing in case I missed another module. Optionally you can add del os del sys del pprint at the bottom if you'd rather not see these modules afterwards without importing them into your session.
Just looking to do RSA-based encryption &amp; signing. I would have said pycrypto, but have read some comments suggesting it's not very secure (leaves too much up to users). Multiplatform ease of installation is a consideration.
Thanks, sorry I missed those in my snippets when I was breaking out my configuration for the post. I'll add them in :) You can see my whole configuration on github to get all the imports you need.
Yeah, I did see them there, just figured I'd make it a tad more obvious. Great post though, thanks.
What doesn't? bpython? Sure it does, works fine here. What issues have you had?
also: from code import InteractiveConsole from tempfile import mkstemp 
Sweet. Works.
[Discussion](http://www.reddit.com/r/programming/comments/esktq/we_just_opensourced_our_internal_python/) in proggit
awesome abstract python logo!
talk to your teacher. talk to your TA. don't be afraid to ask questions to them or to your peers on the internet (aka. reddit). 
It sounds to me like you need to spend more time on your work and not wait until the last minute. In general, programming isn't something you want to rush through.
* Many programmers (myself included) did not get a CS degree. Many of the best coders I know (or have read of) are actually from the Arts (music, philosophy, art). However, they all had to overcome the same hurdles you are dealing w/now. * You are posting in /python and not /askreddit, but the answer would be the same, "Just Do It!" * Having taught beginning programmers many times (or played the role myself while learning in a new framework or language), I can tell you the best way is to start simple. Getting overwhelmed is common. The cool thing about programming is that you can always break things down into their most basic parts. * Get help. Scrambling around at the very last minute is no fun and easily preventable by doing a little planning. There is no shame in getting tutoring and you'll be a much stronger student because of it. Good Luck!
I Google it and read as many different explanations as possible. If necessary, I ask other programmers on online forums, but usually if I find it difficult someone else already has and I can find existing threads. I ask my teacher to explain it a different way. I ask a programmer friend about it. Whatever. I just get as many different perspectives and explanations of it as possible. I also find as many book resources as possible - that's one reason I love Safari (online access to hundreds of books) and a wide array of books. Actually I find programming rather easy; it's the theory I have to work through.
I've found the ["official" tutorials](http://download.oracle.com/javase/tutorial/java/generics/index.html) to be decent. O'Reilly books, such as [this one](http://www.amazon.com/Head-First-Java-Kathy-Sierra/dp/0596009208/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1293563942&amp;sr=1-2), are very good if you have a couple of weekends to spare.
CompSci is about a lot more than programming. In fact, the best programmers don't necessarily have a CS degree, and a lot of good computer scientists aren't the best programmers around. Computer Science is about computers and programming in the same way that astronomy is about telescopes. They're just tools for doing science...
I recently used watchdog in a project on Windows, it's cross-platform and will use inotify on Linux: https://github.com/gorakhargosh/watchdog#readme
The only real thing that can be said about this sort of situation is that some people can just 'get' programming and others can't. For some people, it just clicks right away; it is a level of abstraction that makes sense to them. Computer science is not the only field where this applicable. Students in physics and higher maths are often in a similar situation. What is an extremely easy problem for someone can stump another for ages.
We need another web framework.
Thanks for the links. 
do all of the sample problems given in your reading. if you don't get the concept, find more sample problems to toy around with before you move on. The only way you're going to learn this stuff is by using it. Full disclosure: no, I don't have a CS degree and never claimed to. Also, I don't see what your issues in class have to do with anyone else having a degree or not. Good luck!
leave the "{}" crap at the door
never done OOP until Python (recently). what exactly is "design pattern" mean here ?
I'd be interested if you could elaborate, because I've been thinking much the same thing about overbloated frameworks for web development...
Very well, thank you.
Absolutely. Pyramid's stole some good ideas from Zope, and even uses a small number of zope.* packages deep down in the innards, but it is a standalone framework that should be considered on its own merits. You don't need to know anything about Zope to build Pyramid apps.
on any Linux flavor
thanks for the tip!
&gt; Going away from Eclipse may also help you make the mental disconnect between Python and Java. agree. drop Java tool(s)
so just don't do "__" at all ? that what you're saying ? &gt; don't try to type check things I've been told that repeatedly on #python, so just error-handle it ?
&gt; how did you get through all those hard time when you simply don't understand what you are supposed to do? Probably going to make me sound like a jackass, but I always understood exactly what I was supposed to do.
A great writeup about Java to Python transition: http://dirtsimple.org/2004/12/python-is-not-java.html Also google for 'Pythonic' to get random blogs and opinions about idiomatic Python. For e.g. http://cafepy.com/article/be_pythonic/
That table is a little bit outdated already. If you are going to do anything serious, check out cryptlib first. If it does not suit your needs, then M2Crypto is pretty much your only choice.
&gt; so just don't do "__" at all ? that what you're saying ? right - __* is very very rarely useful. &gt; I've been told that repeatedly on #python, so just error-handle it ? well, it depends, usually you just want to let your program crash so you can fix the bug in your code.
This looks pretty nice, although once you try [iPython](http://ipython.scipy.org/moin/) you won't need any of that.
It really depends on how sensitive your information is and whom are you protecting it from, not on how small subset of algorithms are you going to use. If it's another bookmarking service, pycrypto is probably fine. Just ask yourself how much attackers would pay for your information and act accordingly. 
My mistake, my post wasn't very clear ... bpython works fine, I meant the tips provided in the OP link don't seem to work in a vanilla Snow Leopard install. Trying the following in a python shell still doesn't activate tab completion: import rlcompleter import readline readline.parse_and_bind("tab:complete") EDIT: The help file indicates the latest extension to the readline module must be installed, I wonder if a new version needs to be compiled? 
For PyChef I just used ctypes to wrap the 4-ish functions from openssl I needed. Makes installation much easier (except on Windows, but it isn't any harder there).
Yeah, seriously. ipython has a bunch of other, very useful functionality and it's easier to install than it is to do all this.
TurboGears has come a long way in the last few months on documentation, and we'll be working to improve more. But, we're very very committed to growing Pyramid and their docs, and we are all very engaged with the need to provide world class documentation as part of everything new we build. 
YAAAAAWN
[iTerm2](https://sites.google.com/site/iterm2home) is the OSX terminal for real ultimate power. Check out the [comparison to Terminal.app](https://sites.google.com/site/iterm2home/iterm2-vs-terminal-app).
Grab python from macports/fink to get a real python. The OSX default python is a cut down pile of crap :}
&gt; To be honest, I'm having hard time believing that ya'll have C.S. degree I have an MS actually, so yah... it's doable. &gt; I'm having extremely hard time getting though programming class When it comes to CS, the programming are (were for me) the easiest of all the classes. &gt; but when the time comes for new concepts or so, I just go... blank I propose that if new programming concepts do not interest you, then you don't really like programming. &gt; how did you get through all those hard time when you simply don't understand what you are supposed to do? Those happened to me, but not with the programming classes. For the others, you talk to your professors and peers ahead of the deadlines.
arrows means inherited from.
cool, thanks!
Done. It really didn't take that long to drop the habit of those.
Thanks for the first link. I'll keep those points in mind.
I'm not sure what it is you're trying to do, but here are a few tips for your existing code. First off, you don't need to get the current working directory before opening a file in the current working directory -- you can just use the filename without a path. If you are going to construct a path, you should use os.path.join instead of manually adding path separators. Second, 'read' will return a list of bytes. You're then enclosing this list of bytes within a tuple. So, you have a one-element tuple; that single element is your list of bytes. Just do "data = f.read()". Third, you should encase your "main()" function call within a "if \_\_name\_\_ == '\_\_main\_\_':" block. It's not strictly necessary, but it's how you're supposed to do it. So, you're code can look like this: def main(): fname = 'important_file.bin' f = open(fname, 'rb') data = f.read() print data if __name__ == '__main__': main() As for what you're trying to do: reading a file as done above will give you the "hex bytes" for the binary data. Just do whatever it is you want with it. For converting multi-byte binary data into primitive types (turn four bytes into an integer, for example), you can use the 'struct' module (specifically, the pack() and unpack() methods). 
I did use Komodo for Perl a while back and I didn't like it. I will try Wing. 
&gt; Second, 'read' will return a list of bytes. You're then enclosing this list of bytes within a tuple. So, you have a one-element tuple; that single element is your list of bytes. Just do "data = f.read()". Actually, your version and his are basically identical. A parenthesis alone will not create a tuple. `t = (1)` is equivalent to `t = 1`. `t = (1,)` would create a tuple however.
Ah, you're right, good catch.
If you are trying to get to EOF, why not just: f = open(fname, 'rb') f.seek(0, 2) #whatever else you want to do **edit:** Oops, Syntax. 
Are you kidding? Programming was fun in college. The requirements were clear, there was no legacy code, and most projects could be done in one night. The real world is so much harder. Someone drops a gigantic pile of buggy undocumented code on your head and tells you to fix it.
I like bpython myself.
Wouldn't that seek function have to be like this: f.seek(0, -2) In order to not read the last two bytes in the file? Sorry on my phone and can't test it.
If you wanted to seek until 2 bytes before the end of the file, it would be `f.seek(-2, 2)` which means, seek to the position -2 spaces away from the end of the file. the second 2 tells seek that the first integer is relative to the end. Alternatively, for readability you could use `f.seek(-2, os.SEEK_END)`
In versions prior to Python 3.0, Python makes no distinction between a string of printable ASCII (what you normally consider a string) and a string of bytes. You can manipulate a string of bytes exactly as you would any standard string. You can slice it like so print bytes[2:5] Each binary byte is still only a single character in the string. You can encode bytes manually into a string with backslash notation as follows bytes = '\x00\x1f\x61' which despite looking long is a string containing exactly 3 characters: ASCII NUL, Escape, and finally a lowercase printable 'a'. Also note that due to a quirk of the way Python handles all strings as immutable objects, using + to concatenate strings is PERFORMANCE-DEVASTATING on large strings like the kind you may get from reading a file. Do not do it. Ever. Two acceptable ways to concatenate strings are using string formatting: mystr = '%s%s%s' % ('str1', 'str2', 'str3') or using list joining: mystr = ''.join(['str1', 'str2', 'str3']) 
When did people stop referring to them as BSc and MSc? It took me a while to realize most people weren't talking about bullshit and multiple sclerosis. 
Stick with a particular version of Python. They are different.
Different, and different for a very, very good reason.
http://dreampie.sourceforge.net/
There're some general, high-level goals in programming. Sometimes called design principles. Examples are the Single Responsibility Principle or Open/Closed Principle. They all aim to easy maintainable and extendable software. For example, you should try to minimize the need for modifying exisiting code if you need to add functionality. That's why in static typed languages everyone tells you how important it is to code against an interface and not against an implementation. Now, Design-Patterns are some commonly used patterns in static typed languages to achieve the higher level goals. Most famous book for this topic is written by the "Gang of Four" (GoF), see http://en.wikipedia.org/wiki/Design_Patterns. The point with dynamic typed languages like Python is that you often don't need these tricky Design Patterns to achieve the higher level goals (Single Resp., Open/Close, etc.). Duck Typing is the magic ingredience. There are even talks about "the lack of design patterns in Python". Here're some (first two are direct links to pdfs): http://assets.en.oreilly.com/1/event/12/_The%20Lack%20of_%20Design%20Patterns%20in%20Python%20Presentation.pdf http://www.aleax.it/gdd_pydp.pdf http://www.python.org/workshops/1997-10/proceedings/savikko.html You can also check out Stack Overflow, e.g.: http://stackoverflow.com/questions/606448/python-design-patterns
Use 2to3
I need the application to run on a range of versions. I don't really consider excluding one from 2.5 to 3.1 an option.
If you need to cater to an older version then do so. Specify the version required in the shebang line and newer python installations should know the difference. If you want to cater to those who might have a python installation that only understands one particular version you might have to write separate modules and load them based on the version in the environment.
I'll post the same thing I posted on the programming post: What does this framework have that the other frameworks (CherryPy, Django, Pylons, Web2Py) don't have? Why not choose project which has had it's time to mature in the community and help make it better? Not trying to knock you guys at all, the framework seems really cool but I'm just a firm believer in the Python community coming together and making 2 or 3 awesome frameworks as opposed to a ton of frameworks that each have their little advantage. Thanks and keep up the good work!
you can need that all you want, but 2 and 3 are incompatible languages. kingkilr's suggestion of 2to3 is excellent advice and is your best bet, particularly if you have good test coverage. if you insist, http://eli.thegreenplace.net/2010/05/19/making-code-compatible-with-python-2-and-3/ has the solution to your immediate problem and http://packages.python.org/six/ might help with other ones.
Here is a method of doing this. It takes 3 scripts: a loader script like the example below that determines the python version: import sys if sys.version_info &gt; (3, ): import module3 else: import module2 and then module2.py and module3.py which is all of the version specific stuff. **Edit:** random print that I had in there when I tested it.
Uh, if you want to write code that's the same in Python 2 and 3, you should use at least 2.6 if not 2.7. 
Definitely this. 2to3 easily converts the Exception, e syntax to Exception as e. Nothing fancy necessary.
You can still use "except ExceptionType:" but to get the actual exception instance you need to get it via sys.exc_info()[1].
Working on it... 
And I'll reply [the same thing](http://www.reddit.com/r/programming/comments/esktq/we_just_opensourced_our_internal_python/c1aoudk) :)
Making 2.5 compatible with 3.x isn't easy, as you noticed. 2.6 and 2.7 are much simpler for that - writing single code that runs on 2.6 and 3.x isn't hard. Ask yourself why you need the code to run on both 2.5 and 3.2. Is your code a library? In that case, the user shouldn't have a problem installing the relevant version of the code. Is your code an application? Then consider removing the version headache altogether by either packaging your script into an executable, or using virtualenv. ---- P.S. if you really insist, use something like: except ExceptionType: ex_type, ex_value, ex_traceback = sys.exc_info() # ... use the three values above for profit 
&gt; 2.x has much better documentation No it doesn't.
&gt; There are certain core concepts in Java - such […] anonymous classes - that have no equivalent in Python [type](http://docs.python.org/library/functions.html#type). Though it's rarely used for what anonymous classes do in Java as that's kinda useless (functions generally being a better fit)
in python 2: d.write('\x4f\x4b\x4f') in python 3: d.write(b'\x4f\x4b\x4f') 
My numbers, no code changes except for Timer: Python 2.6: 72.1 s PyPy 1.4: 12.8 s import random,math def gibbs(N=20000,thin=500): x=0 y=0 samples = [] for i in range(N): for j in range(thin): x=random.gammavariate(3,1.0/(y*y+4)) y=random.gauss(1.0/(x+1),1.0/math.sqrt(x+1)) samples.append((x,y)) return samples from timeit import Timer t = Timer("gibbs()","from __main__ import gibbs") print(t.timeit(1))
If you switch that to `xrange` (both of 'em) PyPy gets faster still (if anyone's curious I can explain).
hm, I'd disagree. the vast majority of documentation and tutorials and videos and whatnot on the web are for 2, as are basically all python books.
I programmed for a hobby before I went to uni and studied Computer Engineering (Similar enough to C.S. for this question) and I was constantly getting distracted from the course material in favour of my own projects. Ultimately discipline is one of the things I learnt at university, the next thing I learnt was that programming is only marginally about putting code to text-file, it's more about being able to grasp your idea and explain it clearly.
The official documentation covers the differences between 2.x and 3.x, and apart from that most of the 2.x documentation is easy to apply to 3.x
If you're having trouble with _programming_ in C.S., you seriously need to reevaluate what and why you are doing what you are doing. It only gets harder. Industry is then _even harder_ because you have a pretty long leash and are basically treated as a professional that can acquire new skills and perform your billeted tasks on your own accord. You can be a great programmer without a C.S. degree and a terrible programmer with one, but if you are struggling with the types of undergrad programs you may simply not be cut out for code writing and will be miserable now and later. Worse, you'll make those that have to work with you miserable. This is a field the favors those who are passionate about what they do perhaps more so than others. Do some introspection and find out what you are passionate about; if you can make a career out of it do it. And if it's not Computer Science, look on the bright side, you're young and have time to adapt. Also, work on your attitude. Yes, some of us have C.S. degrees (4 months away from mine). Yes, it's possible. No, it wasn't easy. Sure, some of it wasn't relevant to the trade of professional programming (I have decent experience there), but I'm still very happy I pursued it and don't appreciate somebody's baseless claim that I didn't.
Looks like a job for [Readability](http://lab.arc90.com/experiments/readability/).
I am! I always write xrange() because I at some point read i would be faster, but I can't remember why, or why its not just renamed to range for that matter :)
&gt; Why not choose project which has had it's time to mature in the community and help make it better? Because the world is not black and white.
It may seem like a lot of work maintaining two versions, but down the line when `python2` has all but dried up, you'll wish your code wasn't full of kludges.
Yes. I would like to know too. I read something about range() creating an entire list and iterating through it, that's what slows it down. But I would love a better reasoning.
I've written modules compatible with Python 2.4 - 3.2 in a single codebase, so ignore the naysayers it is well possible. I would only advise it for relatively small codebases though. The mock module now weighs in at around 1000 lines of code (plus around 1500 lines or so of tests) and is compatible with (and tested with) 2.4 - 3.2. I wrote about some of the techniques I used here (including exception handling): http://www.voidspace.org.uk/python/articles/porting-mock-to-python-3.shtml
Thanks, this is what I need. The codebase is fairly small, and only a few portions need to be coded any differently between 2.5 and 3.x. As of late, I have made several modules I wrote 2.5 through 3.x compatible (e.g. [cron expressions](https://github.com/jameseric/cronex) and the [rsync algorithm](http://code.activestate.com/recipes/577518-rsync-algorithm/)), but I had not run into exceptions yet. I forgot about sys.exc_info. Thanks for the read and _useful_ advice.
No idea, never heard that before.
Does anyone these use encryption functions built into linux kernel? Does OpenSSL use kernel builtins if available and hence I would choose M2Crypto?
No, it is near the same for PyPy and a litlle slower for Python 2.6: 74 s. Edit: Maybe it is a little faster for PyPy: 12.2 s 
Maybe it's a British/American thing. I'm pretty certain I only heard them being referred to with the extra "c" when I was looking through British sources.
range creates the entire list and then iterates through it. xrange returns a generator that returns new elements on demand. So you save the cost of creating the list and allocating space for it.
That's really interesting. I also wonder how long the equivalent code in R would take.
That's good to hear. The narrative documentation supplied with Pyramid is invaluable to newcomers. The style of writing is clear, the content is comprehensive and there appropriate links both between the different parts of the narrative and between the narrative and the reference documentation.
Originally found here http://www.reddit.com/r/Python/comments/esya8/what_is_the_best_way_to_capture_exceptions_in/c1apacy
In addition, [this guide](http://docs.pythonsprints.com/python3_porting/py-porting.html) also lists compatibility notes as much as possible (although I wouldn't say the doc is 100% complete).
Not tied to logging, I've found [colorama](http://pypi.python.org/pypi/colorama) quite useful in Windows.
Others have given the notation to embed binary data in strings directly (ie '\x4f\x4B\x4f'), though in this case that's equivalent to just 'OKO'. However, if you've an arbitrary list of integers in such a format and you want to write them, you just need to convert them into a bytestring first. In Python2.x, this is done with chr() &gt;&gt;&gt; chr(0x4f), chr(0x4B), chr(0x4f) ( 'O', 'K', 'O' ) So given a set of bytes to write, such as : prepend_bytes = [0x4f, 0x48, 0x4f] change your commented line to: d.write(''.join(chr(x) for x in prepend_bytes)) In python3, you can create a bytestring directly from the list, so this would just be: d.write(bytes(prepend_bytes))
In Python 3 it is, range and xrange are the same thing.
Having done similar things, I can verify the insane speedups. See [my post](http://www.korokithakis.net/node/117) with links to other posts. This was in a class of people writing the exact same thing in various languages, and, from what I remember, Python+Cython/Shedskin was the fastest, comparable to Java/Haskell/others.
I've just run the adatron.py file from the shedskin examples with PyPy 1.4. It finished in 31 s on 2 Ghz Intel processor. There is no compilation phase and no code changes other than adding the Timer. 
On CPython you would be completely correct, `range()` returns a list, it's the equivalent of `list(xrange(*args))`, however 95% of the time people use it the same way as `xrange`, just iterate and forget (as in this code). So PyPy has a pretty cool optimization: basically we return an object that looks like a list, at Python-level it's completely indistiguishable `type(range(2)) is list`, however in the internals it's represented differently, the same as an `xrange`, except that if you try to call mutating `list` methods on it (such as append) it will "force" itself, evaluating the entire list and storing it internally. This means that every operation needs to do a check like `if self.forced`, the results in a few extra instructions every time you touch an xrange in the JIT'd ASM. It's still more efficient than just returning a big 'ol list of numbers, but not as efficient as `xrange`.
entirely possible.
I am the author of a C extension and have 99.6% test coverage. Keeping both C level and Python level compatibility between Python 2 and 3 is pretty easy as the article shows although I am a far bigger glutton for punishment supporting back to Python 2.3 (predates lots of new Python 2 syntax). By far the hardest bit was not regular code but rather boundary and invalid conditions in the test suites such as Python 2 strings that cannot be converted to Unicode (impossible in Python 3), integers that are too large, [tri-valued booleans ](http://docs.python.org/c-api/object.html#PyObject_IsTrue), API inconsistencies (what exactly do file reads return?), different syntax for exec etc.
Thanks for the pointer to shedskin. I could only find one example of using it with numpy, and the compiled function was invoked as f(a.tolist()). It seems like this could be a bottleneck or not scale well to larger matrices. Do you think it's reasonable to use numpy with shedskin? 
I doubt that python is going to go away just because someone is proposing a variant. Even if it does it is just as likely to be something like python4k that actually catches on. People are going to have to maintain multiple/cross versions for a long time...
Python, I love you just a little bit more.
Thanks for linking to that. I've got an internally-developed equivalent that I've been getting tired of maintaining for my company. Now I just need to rework it's cursor positioning support so I can contribute it to colorama :)
i cant help you besides giving you an upvote because i would love to learn of this too!
You could probably hack it using a python automated testing framework. The automated testing tools should allow to find the window and push buttons, etc...
I did this a long, long while ago, I've since moved off to boring linux lands where you just script [xdotool](http://www.semicomplete.com/projects/xdotool/) and call it a day. I recall using [SendKeys](http://www.rutherfurd.net/python/sendkeys/), which is a very handy module, but it only does keyboard input. [SendInput](http://msdn.microsoft.com/en-us/library/ms646310%28v=vs.85%29.aspx) (and the related mouse_event/keybd_event) are the lowest level of keyboard/mouse control, and will be a major pain to call from python. Instead, get [PyWin32/PythonWin](http://sourceforge.net/projects/pywin32/) and use win32api.SetCursorPos and ... shit, I guess there isn't a click event that doesn't use the SendInput family. [Here's a StackOverflow question](http://stackoverflow.com/questions/3720968/win32-simulate-a-click-without-simulating-mouse-movement) with some helpful code. mouse_event is easier to call than I expected. 
Are you referring to Selenium or there are others?
I believe [AutoPy](https://github.com/msanders/autopy) can be of value for this. Edit: A brief description: "AutoPy is a simple toolkit for automating and scripting repetitive tasks, especially those involving a GUI, with Python. It includes functions for controlling the mouse and keyboard, finding colors and bitmaps on-screen, as well as displaying cross-platform alerts."
Check out autohotkey http://www.autohotkey.com/ I do all my windows scripting using this language and the learning curve will be minimal considering you already know some programming languages.
[pywinauto](http://pywinauto.sourceforge.net/) looks interesting. Not sure how applicable to games it would be though...
Cygwin python: /usr/bin/python: No module named e Similar trouble on Windows Py 2.6 2.7 3.1
Nevermind. This is not a standard module...
Autohotkey is an amazing tool! I USED to write all my windows automation stuff in Win32/C/VB.NET but now it's pretty much all AHK!
I'm not sure shedskin even supports numpy (I don't know what Mark has done since I last used it). My usage of numpy was just storing data and simple calculations, which are much better off in pure python and optimised by shedskin. If you use numpy extensively, I would definitely go with Cython. I got almost the same speedup with just an extra bit of work. The advantage of shedskin is that, a lot of the time, it's absolutely zero work.
Heh, adatron.py is the file I'm referring to above, which I wrote and submitted it to the examples list. I have high hopes for PyPy, although shedskin takes something like 5 seconds, if I remember correctly? Can you tell me how long it takes on yours? I'd be very interested to know how long CPython, PyPy and shedskin took. EDIT: On mine: Implementation | Time (seconds) :--------|---------: CPython | 92.77 PyPy | 13.57 shedskin | 1.66
oh, and what? python librsync binding u can find in rdiff-backup/duplicity sources
[Prey](http://preyproject.com) may help you flesh out some ideas.
I just did a quick search for "python automated testing" and saw there there were a couple promising results. Edit: Selenium is a web based automated testing framework. I don't think that would work out. 
I have no real clue how to go about doing this but if I really had to do it, I would try my best to send out as much information as possible without any interaction at all and I would definitely try to do this in any and all modes (safe, recovery, live, etc). ASAP. The trick from a software perspective in my opinion is reporting as much information immediately e.g., as soon as the notebook is booting. That's just an idea otherwise a hardware solution would probably be the best of all bets. Good luck!
For people having [issues](https://github.com/msanders/autopy/issues#issue/10) with the bitmap module while importing the autopy module: try commenting out the relevant import statement in "Lib\site-packages\autopy\\_\_init__.py". Of course you won't be able to access its [functionality](http://msanders.github.com/autopy/documentation/api-reference/bitmap.html) then but you can atleast work with the rest.
w means write, r means read
Stop arguing over semantics. You are both right.
The second item you pass through in the open statement is the mode. This tells Python you want to either read/write/append to a file. Keep in mind that some of the modes can be combined (rb = read binary, wb = write binary, rU = read with universal line support). You should check [this](http://docs.python.org/library/functions.html) out, head down to the open() function. 
If windows only, try [pywinauto](https://code.google.com/p/pywinauto/).
Simply check this: http://docs.python.org/py3k/library/functions.html#open
That's one regexp from hell
it would likely be a little easier on the eyes if raw strings were used.
You should probably use http://stackoverflow.com/ to ask these sorts of questions.
I especially love the "(trust me)" in the comment
Go?
Can someone explain the regex?
&gt; - from types import StringType &gt; + StringType = type('') Y U NO USE `str`?
It's actually surprisingly readable if you reformat it (using `re.X` when compiling it) and use rawstrings (and repetitors instead of those 6-quotes runs): should yield something along the lines of (not tested, but should be roughly this): re_foo = r''' ( (?:''(?!') |""(?!") |'{6} |"{6} |'(?:[^\\']|\\.)+?' |"(?:[^\\"]|\\.)+?" |'{3}(?:[^\\]|\\.|\n)+?'{3} |"{3}(?:[^\\]|\\.|\n)+?"{3} ) |#.* ) '''
all I can say is ... uh oh, I see this ending very badly for my free time.
maybe because bottle try to keep compatible on both python2 and python3?
sauce or it did not happen.
these notes... are they a github feature or something you can do with git in general?
[github's](https://github.com/blog/622-inline-commit-notes)
`pip install e`
Not in this case. Actually it is impossible to write this pattern as a raw string. Try it. With raw strings, all backslashes are left in the string. This includes backslashes that are used to escape quotes. Edit: I did not consider repetitors ('{6}). Thanks for the hint.
Yes and no. I am so used to work around 2to3 that I do strange things sometimes. In this case it was just stupid.
The repetitors are a good idea. Thanks
I won't call database "access_point"
&gt; maybe because bottle try to keep compatible on both python2 and python3? A good reason to not use `types.StringType` (it was removed in Python 3, along with any other type available as a builtin), but irrelevant for `type('')` vs `str`: Python 3.1.2 (r312:79147, Jul 12 2010, 20:39:16) [GCC 4.2.1 (Apple Inc. build 5664)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; type('') is str True Python 2.6.1 (r261:67515, Jun 24 2010, 21:47:49) [GCC 4.2.1 (Apple Inc. build 5646)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; type('') is str True 
See `VERBOSE`d version above, "correct" formatting makes the regex much easier to read (basically, it captures comments — line chunks starting with `#` — except when those chunks are within strings — by matching but not capturing the content of strings (a pretty smart technique).
Now that I think about it, wouldn't it be possible to use back references to halve the number of lines in the non-capturing pattern? (might not yield a simpler regex though)
How is this? https://github.com/defnull/bottle/commit/b14b9afa3fbffee1eda63bc0d7dde1009b433d4f :)
The way these options work sounds wrong. What if I define an option titled "me". What takes precedence? Python shouldn't allow this. Is it optparse/argparse default behavior?
Some numbers on load-time improvement: marc@nava:~/bottle$ git checkout master~5 marc@nava:~/bottle$ python imptest.py bottle Time spent in bottle: 0.01269 (total: 0.10501) marc@nava:~/bottle$ git checkout master marc@nava:~/bottle$ python imptest.py bottle Time spent in bottle: 0.00551 (total: 0.06554) Most of the time saved in 'total' is from removing the 'tokenize' dependency. Bottle itself is faster because the error template is now parsed on demand only. Good news for GAE or CGI developers.
Neat. While I've never found switching to command that much of a problem, I applaud your efforts.
I want to subscribe to your newsletter.
What about pyinotify? Or something along those lines? But still, even like this, is seems like a good idea :) But personally, I would reduce the wait-time to something like 0.5. Alt+Tab, Up-Arrow, Enter is much faster than 2 seconds :)
`-m` is a flag for the Python executable, and it executes the `e` module. Define all the `me` options you want -- the options you specify for your script are for your script only. Think of `-h` help options. The Python executable has one and many scripts often have one as well. Neither of them interfere with the other.
I usually run with 1 sec, that could be a variable i suppose ;) but yeah… i find it also helps if the terminal window remains in sight while the code is being changed. Flick eyes left, output changes, back to code. I find my trains of thought to be more continuous this way 
yo bro... so like never link though a frame bar wrapper like stumbleupon... it's tooootally uncool dude.. original link: http://www.staringispolite.com/likepython/
I second the question about pyinotify - did you try using it? The solution you have at the moment seems buggy - adding the size and timestamp to one big total makes me wonder if I were to shrink the size of the files by the exact number of milliseconds between saves that a change wouldn't be noticed?
TL;DR: Don't import tokenize (directly or indirectly through import of inspect)
Let me rephrase the question: If I define an option "-m" in optparse, will the command line: myscript.py -me cause the "m" flag to receive "e" as it's value? If so, this sounds wrong. If this isn't the case in optparse or argparse, I don't think the python executable should behave any differently.
yes. it would break :-). Im running on odds here, guess you could just use time? 
Your `m` option would receive `e` as its value unless it was truly considered a "flag", e.g., True if present, False if not. `-me` is no different than `-m e`, which is the case for any option parser I've encountered.
Nice job, writing small utilities to improve your workflow is always fun. Not sure how much use I would get out of it personally because I compulsively save...like in the middle of typing words and whatnot. For me it's easier to just have emacs open with shell-mode in another frame, run my editor in one tiled window and my terminal in another or just using screen. 
Ok, I just tested optparse and it does behave like you say. Does this seem reasonable in your eyes?
pyinotify is excellent, if probably Linux-only. It'll also do nice things like start watching files and directories that get added after the scanner is started. Here's a 50-line "recompile" script that automatically runs a command on all files within a directory tree with a certain suffix: http://nullege.com/codes/show/src%40p%40y%40pyinotify-HEAD%40python2%40examples%40autocompile.py/18/pyinotify/python
I tend to put a space between my arguments and values, but I don't think it's unreasonable not to do so. Anyways, changing this would definitely break behavior that people have been using for years across many languages and parsers.
In vim, I set up execute keybindings: let mapleader = "," nmap &lt;leader&gt;r :w&lt;CR&gt;:!./%&lt;CR&gt; nmap &lt;leader&gt;x :w&lt;CR&gt;!!./%&lt;CR&gt; nmap &lt;leader&gt;e :w&lt;CR&gt;:!./% nmap &lt;leader&gt;z :w&lt;CR&gt;!!./% ",r" will save, execute, and display the output. ",x" does the same, but puts the output in the buffer you're working on. ",e" and ",z" let you provide command-line arguments first. This all assumes your file is +x and has a #! line, of course. 
awesome, thanks :)
Good idea! I'd implement it something like this though. (Tested on Windows, seems to work.) #!/usr/bin/env python import os import stat import sys import time tomon = [path.rstrip() for path in sys.stdin.readlines()] command = " ".join(sys.argv[1:]) if not command: raise Exception("No command given") stats = {} def update_file_stat(path): last = stats.get(path) stats[path] = current = os.stat(path) if last and (current.st_mtime != last.st_mtime or current.st_size != last.st_size): print &gt;&gt; sys.stderr, "* %s has changed." % path return True # Changed! return False # No change! while True: if any(update_file_stat(path) for path in tomon): os.system(command) time.sleep(1)
Perhaps I don't understand how you work, but if you are using BASH/KSH etc, you can setup vi editing mode (`set -o vi`) and if you set your `EDITOR=vi` environment variable, you can actually edit a long complex command line in actual vi/vim. So, my workflow looks like this: type command, hit enter. There's a problem? Hit `ESC kv` this uses shell built in `fc` command to launch your editor of choice (vim in my case) to edit your command line. Fix whatever you need to fix and "save" your changes which re-executes the command line. This is automatic, fast, works everywhere (no python required) and I always thought this is how most UNIX/shell people work anyway.
[Pyeval](https://bitbucket.org/nejucomo/pyeval/wiki/Home) is even better.
Wow, you even added explanatory comments for each line, awesome.
Don't import `tokenize` *when your module is frequently reloaded from scratch* (which is the issue with GAE or CGI, in `fcgi` or `mod_*`-type situations, the module is loaded once and the process is reused over and over again, so the overall cost of importing `tokenize` is low)
I've been using autonose for this purpose: https://github.com/gfxmonk/autonose
You are correct. It states right on their site: &gt;Pyinotify is a Python module for monitoring filesystems changes. Pyinotify relies on a Linux Kernel feature (merged in kernel 2.6.13) called inotify. inotify is an event-driven notifier, its notifications are exported from kernel space to user space through three system calls. pyinotify binds these system calls and provides an implementation on top of them offering a generic and abstract way to manipulate those functionalities.
Good idea, although I always though that it should be possible to set a trigger to a particular inode in linux and run some code whenever that inode is changed, in that case you don't even need to have a while loop. But, in order to implement this thing you need to use kernel API, and I'm not sure if it's available in python.
$ iwatch -r -e modify |while read event; do ....
The second argument to the open function is the mode - when you open a file with `w`, you can only write (thus the IOError). It also creates the file if it does not exist yet. [Try the `r` mode.](http://docs.python.org/library/functions.html#open)
I would expect `-me` (single hypen) to be equivalent to using both `-m` and `-e`, as with many unix'y tools (e.g `rsync -rav` == `rsync -r -a -v`): &gt;&gt;&gt; p = optparse.OptionParser() &gt;&gt;&gt; p.add_option("-m", action = "store_true") &gt;&gt;&gt; p.add_option("-e", action = "store_true") &gt;&gt;&gt; p.parse_args(["-me"]) (&lt;Values at 0x100560cb0: {'e': True, 'm': True}&gt;, []) &gt;&gt;&gt; p.parse_args(["-m", "-e"]) (&lt;Values at 0x100560cb0: {'e': True, 'm': True}&gt;, []) `python` doesn't use such parsing, and it treats `['-me']` as `['-m', 'e']`
Honestly, this looks to me like you want to put those commands in a Makefile...
True. Maybe that could be implemented as an optional feature when creating OptionParser/ArgumentParser? Something like a "multiflag" argument. I tend to use `tar` in the same way as your `rsync` example, so applications which might have a bunch of flag options could specify that they want that behavior instead of `-rav` meaning `-r av`. However, I suspect most applications don't work that way so I'd argue against that being the default, plus the obvious backwards incompatibility I previously mentioned. 
If you don't use "store_true" as your action, the parser behaves as the Python one would. Basically it's the difference between using "m:" and "m" in getopt, which implements the POSIX standard for command-line options.
err wait, I should have paid closer attention to your example and/or tried it out :/ Nevermind, what I just said.
Pssh, that's not even bad: https://github.com/brosner/everyblock_code/blob/master/ebdata/ebdata/nlp/addresses.py
I use Buildout, so I just use the collective.recipe.omelette to automatically create symlinks to to flatten the library load path into one directory view. Then I just open a library with: mate ./parts/omelette/numpy Or just: mate ./parts/omelette/ Which will open an entire working set of libraries ... except Python's Standard Library because the stupid thing is unpackaged :( 
Oh, good point: &gt;&gt;&gt; p = optparse.OptionParser() &gt;&gt;&gt; p.add_option("-m") &gt;&gt;&gt; p.parse_args(['-me']) (&lt;Values at 0x100560b00: {'m': 'e'}&gt;, []) So `-me` is the same as `-m -e` only if `-m` doesn't take an argument
The w mode will delete the file if it exists and then create an empty file.
&gt; using + to concatenate strings is PERFORMANCE-DEVASTATING on large strings like the kind you may get from reading a file [citation needed] In [1]: a=open("/dev/urandom").read(1024*1024) In [2]: b=open("/dev/urandom").read(1024*1024) In [3]: c=open("/dev/urandom").read(1024*1024) In [4]: %timeit z=a+b+c 1000 loops, best of 3: 1.31 ms per loop In [5]: %timeit z="%s%s%s" % (a,b,c) 100 loops, best of 3: 2.02 ms per loop In [6]: %timeit z="".join([a,b,c]) 1000 loops, best of 3: 1.31 ms per loop 
[PyZen](http://pypi.python.org/pypi/PyZen/) is a test runner that does this natively and has direct support for Django, Flask, and distutils for test discovery. It also works on Windows, OS X, and Linux and supports a number of notification frontends for test results.
[Original thread](http://news.ycombinator.com/item?id=1043491) It has some code examples.
Interesting. Perhaps they optimized it in more recent versions. I know I attended a talk (with Guido in attendance) several years ago which analyzed that specific issue. I believe the current Python version at the time was 2.2 or 2.3, so it likely has been fixed since then. Thanks for the correction.
You've got it. I think `man 3 getopt` gives a pretty good description of the behaviour. Most option parsers including Python's getopt and optparse modules behave in accordance, though usually contain additional extensions.
Hey thanks, I'll take a look at Buildout, and see if I can leverage that. Qwandry already works well for the Standard Library, ie: `qw string` or `qw num`.
This is cool. Where has the code to be inserted? .vimrc? Thanks a lot.
this looks cool though when i try ESC jv vim opens a temp file in /var/folders not the command i previously executed, do i need to load the file into vim manually? 
I like it, it's pretty hard. A suggestion: make the colors change as you get farther. green-yellow-orange-red. Looking at the code, why are there three different versions? Just scrap 1.01 and 1.02. Git keeps the revisions for you! Also, you seem to be using a lot of global variables. I could be wrong but I don't think this is very good practice. Why don't you use a class to keep everything neatly packaged?
Thanks for looking over it! The colors idea is pretty good, I'll try to implement something like that. Also, I definitely agree on the globals comment. For some reason, the variables are outside of the pyglet/rabbyt functions.
oh, so it's inherent to pyglet and rabbyt that you have to use globals? 
&gt; I use Freemind as a central database of everything. Everything ... as in, for [note taking](http://www.evernote.com/) and [task management](http://culturedcode.com/things/) as well?
I'd rather not put all my notes online. Notes include all minor project planning, categorizing of things. I'm a little crazy like that actually. And I've switched around a whole lot, I can't seem to find a to do list/note taker scheme that quite works for me. I gave in and put my to do list on Remember The Milk though, at least for now, that one seems to be pretty good. Maybe I'll make my little program use Freemind as a task manager as well eventually.
No you don't. Just edit the file and save it and quit (e.g. `ZZ` or `:wq`). At that time the newly edited command line will be executed. If you have EDITOR environment variable set to a valid executable file in your .profile, it will be executed when you press v in normal mode and the current command line passed to it. You don't have to use vim necessarily. `fc` built in does indeed create a temp file (for me it is `/private/var/folders/IU/IUHt5-AzHcCq9P8erXvuok+++TI/-Tmp-/bash-fc-1293756865` ), but it also opens it in the editor if you have one set.
Polling instead of inotify? You *must* be punished! EDIT: The OP also polls, you will both be punished.
I wrote a tool just like that called `onchanged`. Usage is onchanged &lt;filename&gt; &lt;command&gt; I use it all the time for LaTeX, to recompile my document on changes, because evince automatically updates when the pdf changes, so it ends up working like a live-update IDE.
There is probably a FileSystemWatcher based one for Windows.
A class is a great way to encapsulate a bunch of variables. You don't even need to write the class itself. Just do something like this in global scope: class Container(object): pass game = Container() game.level = 1 game.speed = 999 You can instantly access everything globally through attributes on the `game` instance (unless the name game is masked by a local scope). The instance uses a dictionary (`__dict__`) to store attributes, so what you're really doing is closer to: game.__dict__['speed'] = 999 Which means you could also do something like this using just a dictionary: game = {'level': 1} game['speed'] = 999 But none of this matters! You're writing a fun sub-200-line game, so you can do whatever you like! 
Do note the bit where I said I tested it on Windows. Last time I checked, inotify didn't exist on Windows. That said... [FindFirstChangeNotification](http://msdn.microsoft.com/en-us/library/aa364417\(v=vs.85\).aspx) does exist...
More importantly, w means write _and truncate_.
Python seems to work best for me when I use one file to read from, then another to write the processed data into. I open in 'r' read format with one file. Then open in 'w' another file and move the processed file object through my code and into new file. Both are retained. Supposedly in 2.6 you can put in 'r+' to both read and write. But I cant seem to get it to work right. Besides it is often good to retain multiple copies of files and dispose of those you dont need. Unless you have a big project. Remember to f.close() to save the data. You can then open right back up and read if needed. 
Isn't that what PyCon financial aid is for? +1 for creativity, at the very least. =)
This is the right-er solution: it uses events instead of polling, so you're not stat-ing all the files every N seconds. it's called inotifywatch in my inotify-tools package (on debian) If you only want to rebuild on certain file modifications rather than *any* file modification, you can do something like this inotifywatch -e modify --fromfile &lt;(find . -name \*.py) | while read event; do time *rebuild-command*; date; done (I like to throw in the 'time' and 'date' to give myself a bit more context) I used this pattern with latex and xdvi to rebuild + notify xdvi that the .dvi file it was looking at was updated, so that every time I saved in my editor I could see the results in usually less than half a second (if I broke the document up into chapters as appropriate). I would have looked up the exact xdvi invocation except that it doesn't seem to be in apt on this machine, wtf.
I'll give you my hard earned money and you'll have fun at the PyCon? I don't think so! Why shouldn't I buy a box of beer instead and drink it while watching the original talks on blib.tv (or whereever)? Or why shouldn't I give some money to people who really need it. Or to the WWF? I don't know what to think: Is this guy naive? Does he lack the basic understanding of what a deal is? Or is he just cheeky? EDIT: He's cheeky! He doesn't want to share a room. Now I see this guy as a lazy spoiled mummy-boy. This guy should write a web-app to raise money to the homeless people freezing to death these days! 
I think you need to be willing to share a hotel room for the PyCon financial aid. This guy wants his own room ... ;-)
Source code as promised, nice one! :-)
He is a freeloader. I am in a 3rd world country. Donate the money to me. 1300$ can feed 100 children here for a month. For donation go to www.cry.org 
I am a Python midnight.
Try F1 in IDLE and go to Tutorial, as well as a Byte of Python. http://www.swaroopch.com/notes/Python Make sure you use the correct version of a Byte of Python for whichever version of Python you decide to learn.
lol, I meant noob, was typing on my phone
This is what you need: [http://diveintopython.org/](http://diveintopython.org/)
cheers :D I was introduced to Tornado only a short while ago and I've been looking for something like this to play around with. 
Thank you I primarily use linux and Mac and I am trying to expand my repertoire.
um, thats noob, damn phone keyboards... too effing smart for their own good...