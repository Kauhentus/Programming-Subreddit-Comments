I code between Java and Python all day, so I use Eclipse + Pydev.
I worked on a largish python project for a few years and I swear it was never a problem for me. Now I have to flit between java and other langs, I absolutely have to use eclipse to get anything done in java - and I can kind of feel the mental muscles atrophying. I really think if I had to stick java out for too long, I'd have the same problem you're describing.
The life of Brian and the holy grail....
Don't call your file "turtle.py". When you do "import turtle" you import your turtle.py rather than the turtle module in the standard library.
That's what the "save" feature is for (or the bookmark feature in your browser). Reddit would look like shit if everyone publicly posted their bookmarking just because it's convenient for them. Try to be a little more considerate.
I really like [this Google Talk](http://www.youtube.com/watch?v=wEhu57pih5w) by Mi≈°ko Hevery. Also, [Fast Test, Slow Test](http://www.youtube.com/watch?v=RAxiiRPHS9k) by Gary Bernhardt.
Could you elaborate on your emacs config? I have always used emacs, but I do often find myself wanting some IDE features, especially when someone is standing over my shoulder and I am flicking through buffers trying to find the right thing...
Modernize, try tmux! :)
My workplace uses PyCharm for the most part.
Pycharm with an open source license thanks to my project https://github.com/Itxaka/pyapi-gitlab The full version is awesome, with django integration, database connection and more.
WingIDE locally. Emacs with [this](http://gabrielelanaro.github.io/emacs-for-python/) slightly customized, when working remotely/through shell.
Seeing as he uses vim he already have splits and windows. Unless you want to do more fancy stuff screen is just fine. 
Sadly this is a downside of duck typing, that you'll never have auto completion as good as for java.
Screen as a project is officially abandoned. Whilst true, it's not going anywhere, it's sometimes fun to learn something new and "keep up" so to speak.
Do you have experience with modern IDEs to make a comparison?
I LOVE PyCharm. It handles multiple virtualenvs well, introspects code well, and formatting works well. I've used the paid one for a few years but just switched to the community edition because I usually run my programs in a shell outside the IDE. 
Could be seen as premature optimization, screen isn't going anywhere so there's no negative cost to keep using it until there's some concrete benefit in tmux for said user.
vim usually, im secure shelling to machines all the time. I like having the same editor everywhere. 
if you are interested, here's my [emacs config](https://github.com/twillis/my-emacs-config) Jedi seems to do a decent job at the autocomplete thing. I have to do some per project things to get debugging and ipython in emacs working right but it's pretty much a matter of setting up some paths. (setq tw-test-project-dir (file-truename "")) (setq bin-dir (concat tw-test-project-dir "/bin")) (setq tw-test-flags "--failfast") (setq tw-test-runner (concat bin-dir "/" "manage_dev.py test ysn")) (setq tw-project-dir (concat tw-test-project-dir "/src/ysn" )) (setq tw-ext-dir (concat tw-test-project-dir "/ext")) (defun tw-run-test() "this is handy for when you are looking at a unit test file, this function will launch py.test with your flags and run the tests contained within the file you are looking at" (interactive) (progn (setq test-file buffer-file-name) (setq compile-command (format "cd %s ; %s %s" tw-project-dir tw-test-runner tw-test-flags)) (compile compile-command))) (defun tw-debug-test() "run file for current buffer in pdb" (interactive) (progn (setq test-file buffer-file-name) (setq source-buffer (current-buffer)) (setq gud-pdb-command-name (format "pdb %s %s" tw-test-runner tw-test-flags)) (setq gdb-show-main nil) (pdb gud-pdb-command-name) (setq gdb-buffer (current-buffer)) (switch-to-buffer-other-window source-buffer) (switch-to-buffer-other-window gdb-buffer))) ;; jedi setup (defun check-jedi-python () "Update the path to python for jedi-mode if we switch to a Buildout project." (progn (jedi:setup) (set (make-local-variable 'jedi:server-command) (list (concat bin-dir "/python") jedi:server-script)) (set (make-local-variable 'jedi:server-args) (list "--sys-path" tw-ext-dir)))) (add-hook 'python-mode-hook 'check-jedi-python) ;; ipython integration (setq python-shell-interpreter (concat bin-dir "/manage_dev.py") python-shell-interpreter-args "shell" python-shell-prompt-regexp "In \\[[0-9]+\\]: " python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: " python-shell-completion-setup-code "from IPython.core.completerlib import module_completion" python-shell-completion-module-string-code "';'.join(module_completion('''%s'''))\n" python-shell-completion-string-code "';'.join(get_ipython().Completer.all_completions('''%s'''))\n") As far as I'm concerned the only thing I'm missing that an ide would provide is the ability to attach/debug a running process. But I usually write unittests to get to where I want to debug. And if I did more front end dev, I'd probably like a better html mode that handles multimode better. it exists for emacs, but I haven't had the motivation to set it up. 
I have never had trouble with any of the things you've mentioned. Did you happen to report those problems to the PyCharm team? They are very responsive and I'm sure they'd be interested. It **is** a Java application, so depending on your platform it may not run well. I know that I've heard it runs poorly on OpenJDK (as do pretty much all complex GUI applications). The auto-complete is quite a bit more sophisticated than a typical text editor plugin like the ones people tend to use with VIM, so I'm not sure what you mean that it's awful. My experience with auto-completion in VIM is that it just does some basic symbol matching, and it can only symbol match in the currently open buffers. I.E. If there is a class definition in a file that isn't in an open buffer, instances of that class won't be getting auto-complete. PyCharm on the other hand completes a static analysis of your entire project and it's dependencies (if you have a requirements.txt file) when your project loads and keeps on analyzing as you go. If it's possible to infer the type you're working with at the given moment you will see the members of the class (or module) available for for auto-completion before all others and when it doesn't it uses symbol matching. But even in that case it will match to symbols of other methods it knows have been used with that instance before.
My team mostly uses [Komodo IDE](http://www.activestate.com/komodo-ide) or the free [Komodo Edit](http://www.activestate.com/komodo-edit). The python autocompletion isn't as hot as some more python-centric ides, but it makes up for it with a good set of general editor features, and highlighting support for every language under the sun ... that last bit being a killer feature when your application isn't python, but python, C, javascript, html, rst, and js &amp; html templates. 
Big project and Emacs here. While my emacs setup provides all useful IDE features, I find complexity management the biggest benefit of using a text editor instead of an IDE. A good IDE allows you to spawn much more complex design than your brain is able to cope with. The popularity of IDEs in Java world (combined with their nasty support for generating boilerplate code) may be the main reason, why much of Java code is so needlessly complex. If all you have is a simple text editor, you are forced to produce simpler, less verbose and more modularized code. My project is fairly large (in terms of both lines of code and participating programmers), but it's surprisingly easy to start hacking it, when you join the team. The popularity of vim and emacs in our teams may be a big contributing factor, in my opinion. 
Oh I see. So this isn't actually Python *per se* but shell commands you're executing. It sounds like there is already a file called "temp" in the directory you're working in, maybe from a previous run? Run the command "dir" from within your cmd shell and see what files/folders are already there. If you want to get rid of the existing "temp" file you can delete it using: * "rmdir temp" if it's a directory or * "del temp" if it's a file 
Thanks! Bought the bundle, vol 2 of Treading on Python is very informative and just what I need to help me take my Python to the next level.
I am all about Eclipse+PyDev.
I wonder why this is getting downvoted ? :/
Thank's for mentioning th TagBar plugin, hadn't heard of it before and it's great!
ido-mode, pyflakes, jedi-mode (maybe, currently turned off). This is really pretty much it. I used to have a lot of custom keys, but I seem not to use them a lot any more (alt-1 to the last visited buffer, alt-2 to the previous one etc.)
He could have ipython and vim side by side with tmux.
&gt; I've heard it runs poorly on OpenJDK Interesting.. maybe that's my problem. I tried out PyCharm on my laptop and it ran slow enough for me to just give up on it and go back to vim. I'll try installing oracle's jre and give it another go. I don't have any problems with vim, but people have spoken so highly of PyCharm and JetBrains' other products that I feel l should at least give it a try. &gt; My experience with auto-completion in VIM is that it just does some basic symbol matching, and it can only symbol match in the currently open buffers. I.E. If there is a class definition in a file that isn't in an open buffer, instances of that class won't be getting auto-complete. That's true by default, but you can try out plugins like https://github.com/Valloric/YouCompleteMe (or just https://github.com/davidhalter/jedi-vim if you only care about python).
Agree. I also use idea when programing in other languages and the IDE is just so rich but gets out of your way. Got my boss to try it an now he is liking it over visual studio!
Are you using Oracle jdk or openjdk? Openjdk is unsupported an has personally caused me a lot of issues with intellij products.
On windows I use notepad++, because I just want syntax highlighting, line numbers, and auto indent. Thinking about switching over to sublime, but I'll see how it is
Have you tried intellij? I cant even try to use eclipse any more with out getting pissed at how much shit is thrown in to the UI and it's slowness.
I'm using Oracle's JVM on a Macbook Pro Mid 2010 (2,4 GHz). PyCharm runs fine in Power Safe Mode; but then it's only a bad editor.
This is probably my favourite: [Militarizing Your Backyard with Python: Computer Vision and the Squirrel Hordes](http://www.youtube.com/watch?v=QPgqfnKG_T4)
pycharm, vim, web2py or nothing
I've also never had a problem with it. I find it pretty surprising to hear it doesn't work well.
&gt; PyCharm on the other hand completes a static analysis of your entire project and it's dependencies Yes, it does static analysis to some degree. But when the application gets more advanced than a basic hello_world.py, it sometimes just fails to "analyze" at all. Most of my `werkzeug` functions are underlined because of superflous arguments... that's simply not true, but PyCharm does not evaluate slightly advanced `getattr` calls which dispatch functions. &gt; when your project loads and keeps on analyzing as you go. Always have fun with it. Especially when I run `tox` and PyCharm re-indexes *all* testing environments while `tox` is running. I now use PyCharm for JavaScript now (not PyCharm CE) and there it really shines. It can analyze all my require.js stuff.
I think every IDE I've tried has code folding. I know both Wing and PyCharm have it.
I tend to use a text editor + drop-down terminal (running iPython). The end result is IDE-ish.
If you write a lot of medium-sized scripts that then turn out to be useable libraries, it can be bloody useful. For example, I wrote a script to manage itunes podcasts. Turns out that with a bit of refactoring, it's also a handy library for iTunes music and videos, too. You could argue that I should move the common functions to a separate module, but then I've got non-scripts in ~/bin or I have to install the library on PYTHONPATH. Not worth packaging such a thing, and moving it *will* cause problems (I'll forget about it when installing a new OS, or it won't work from, say, Hazel because it doesn't use my PYTHONPATH).
+1 for the "Class Development Toolkit" video. I thought I knew how to write Python classes, but after watching that video my code got better by a factor of 10. Things like `classmethod` *actually make sense now*. Really, though, anything by Raymond Hettinger is a must-watch. I'd probably watch a 30 minute video of him eating fruit loops if it were posted to pyvideo.
Any McDonalds job ad.
On my phone now so can't get to the config itself, but from memory: Jedi, flycheck, YASnippets, emacs ipython notebook, python-mode, cython-mode, rope, whitespace-mode (highlight only trailing whitespace and long lines), then a whole load of packages for file management, frame organization (winner mode), appearance and navigation. Also Tramp is invaluable for editing remote files in my nice GUI emacs. Basically everything ends up in a single emacs instance... Python, ipython notebooks, remote shells, directory navigation, etc. Learning emacs properly was probably the best time investment I ever made at work
I used to use mostly Vim + plugins for everything, but my current employer tends towards eclipse for most of our stuff, since we do Ruby and Java, and they like/tolerate the GUI front end. I also poke around in Rubymine and textmate, for doing my Chef configs and setups.. I like to keep those out of eclipse. They also do Vagrant configs rather well.
IMO they lost popularity years ago. 
Yeah, I was curious what it needs. Screen has been my goto terminal multiplexer for a couple decades. I don't notice any bugs in my day-to-day use and I'm not sure what I'd want to add to it.
Newer to Python so I don't think my opinion is worth a whole lot, yet I do love Intellij, and I write Go, JS, PHP, and now Python in it. Diddled with some Ruby, yet I went back to Python. Also use JetBrains AppCode for Objective-C, so I like having a similar IDE feel between languages. Keeps it nice and consistent.
Although the other answers are shorter and probably faster I thought I should specifically point out when you do "f.readlines()" you are creating a list with every line from the file in memory. You can use the file object as an iterator and save a lot of memory by doing "for line in f:" which will only read one line at a time from the file.
&gt; There are a few plugins that do auto-complete and linting for Python -- and they work incredibly well. Could you give the name of those plugins ? I usually use sublime text too when I code in python ; but I'm pretty much a beginner so I won't mind a little coding setup enhancing. 
IntelliJ is far, far better for Java IMO. I used to be an Eclipse guy too. I work with our Android team a lot, but also do some plug-ins for our Hadoop front-end, and I use it for both. I haven't actually tried out their Python product yet, i.e. PyCharm. I keep meaning to but most of the Python projects I work on are data analysis type things, and I've found Spyder works best for that (for me). I'm only writing maybe 100 lines in Python at a time though.
Text editor + shell is always enough. You just need a better workflow. Look into Jedi for Vim, learn how to tmux/screen, and keep ipython open at all times.
It's all about jedi-vim
What Sublime plugins do you use?
there are just too many (for me) of various quality, in both content and audio/video, that's why I throw out the question
I'm in the process of learning pygame, and I thought I would see how quickly I could build a simple implementation of a simple known design concept. I think it turned out alright, there are a few bugs with regards to collisions between things and sound, but for the amount (read: lack) of time, effort and preparation I put into it, I think it shows some of the strengths of python for game development.
For the lazy: /r/pygame --- I provide direct links to lesser known subs mentioned in the title if one isn't already provided. Let me know if I need to try harder: /r/LazyLinkerBot
Thank you, this worked perfectly!
do you want to resolve this as a hitscan weapon (the moment the bullet is fired, you check the line, and if something gets hit, it bleeds) or should your bullet have limited velocity? the first case is easier, as you don't have to keep the bullet around and move it independently. for the collision detection itself, are you sure you want to work with enemy squares? with appropriate transformations, you can have hit scanning on circles quite easily. (you'd transform the coordinates of the centers of the enemies into coordinates relative to the pointed weapon, and see if they are off from the shooting line by less than their radius). as for which part of mathematics, i suggest you not only look into vector calculations, but particularly have a look at projective geometry (works in 2d as well as in 3d), which really spares you much special casing.
vim + YouCompleteMe (with its JEDI integration) makes coding Python brilliantly easy.
Some time ago I started working on a mid-size Python project. Right from the beginning I was using SublimeText + some plugins and really liked it. After some thousand lines of code I switched to Pycharm and found my productivity even higher than with SublimeText. I prefer using PyCharm because it doesn't feel like a allround text editor/IDE with some mediocre Python plugins but rather like a IDE that was made by Python developers and for Python developers. I can only recommend to [give it a shot](http://www.jetbrains.com/pycharm/download/index.html).
we use aptana for python
nice one. Bookmark this page and come back in a couple of years for the LOLZ
I like PyCharm, but it actually has caused me to BSOD more than once (on Windows 7!).
in which way isn't this blatant advertising of a book?
&gt;A good IDE allows you to spawn much more complex design than your brain is able to cope with. This is a brilliant insight. When you can press buttons and have pages of code just appear by magic, it's easy to get lost. 
Thanks! Pretty much the same setup as I have here, though I use rope for parsing; I really should look into tramp. Haven't used it much, but I'm just about fed up with the whole save - scp - test - edit thing. 
I have some good reads/tutorials/videos at pycrumbs(https://github.com/kirang89/pycrumbs). Hope that helps.
First great idea I will have to give it a try. I see that you are using Selenium does StackOverflow not have an API ? Were you forced to use selenium instead of something like curl or urllib? 
Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm Pycharm http://www.jetbrains.com/pycharm/ 
Yeah thats cmd shift f12 on mac
Anyone interested in starting a new project with either socket.io of sockjs should read this: https://groups.google.com/forum/#!topic/sockjs/lgzxVnlth54 In general, sockjs seems to be the better choice, although I don't think it has a supported gevent library. You can use either in tornado though.
OpenJDK unfortunately never worked for me properly with any java ide, be it Eclipse, PyCharm (Phpstorm , etc.) or even jEdit.
If you are on windows python tools for visual studio is really slick now. PyDev in Eclipse has made improvements too. When i started with python almost two years ago, PyCharm was not free. Im not even sure what has been stripped out for the "community edition." But, free was really important.
Ew, that kid has something going for him but his is ass is lofted by the hype that is documentaries.
Anaconda is one. :)
PyCharm is famous for eating system resources like no other text editor... It has nothing to do with using an underpowered system (well, technically, but when you can run everything except pycharm...)
If i use the API i will need to send a request every XX seconds or something. So i decided not to use the API. I used selenium for two reasons: 1) SO is using a websocket to update new questions. with urllib i would still have to send 1 request every XX secodns. 2) I just thought you can have an isolated browser having so only, So when there's a popup of something you would answer you can just atl+tab If you want i can also implement one sending requests but i think its not a right way to implement it. 
Iphthon + sublime ftw. Unless Im on my laptop, then its ipython notebook.
Vim only if you use autocomplete. Fuck people that use two letter variable names.
At first I concluded that you had to be one of my co-workers, given that you exactly described my company. But based on your comment history, you can't be. It makes sense that this is a common hardware/software setup for Python companies, though. I personally keep flip-flopping between vi and Sublime.
The comments are overly verbose because it was requested by my CS teacher, so he can see that I understand what's going on.
We are all individuals. What do you mean?
It ends on December 2, Midnight PST.
This looks absolutely awesome. I'll be sure to test it out and have a look through the code.
The Python Indie Bundle site is up until December 2, Midnight PST. Apologies if I came across thin skinned, but this touched a nerve for a number of reasons. It's hard to explain them without coming across badly. For what it's worth, I'm not giving up. Not until I'm dead. ;-)
ipython &gt; %history &gt; sublime. That's my exploratory coding flow.
If all authors are individuals, isn't labelling the sale the "Indie Bundle Sale" rather painfully obvious?
Agreed. However if OP's CS professor is anything like the ones I had, be careful about racing ahead. If the professor hasn't introduced functions and dicts yet, they might not want you using them to solve this particular problem. I would add comments to the code to show that you realise that you are repeating code and that collecting the questions and answers into a data structure and iterating through it would be a neater solution, possibly with an example.
I think if you can use "patterns" properly in your project with an editor and good naming, structure and some decent docs, then you are ~~good to go~~ as good as an IDE. The thing is that a lot of Java IDE's produce all the repeat / regulation code at the press of a button - making programmers lazy and / or productive (depends on the programmer). Just curious ... does your project use a lot of the official "patterns"?
Yes, for large projects I definitely will open up an IDE. Currently I use PyCharm, although I used to use PyDev for Eclipse and it was good too.
It's going to be a windows-specific thing. Does it run as a service? I presume not since the logoff event matters. Maybe pywin32 has something you can use?
Hey, Thank you for apologizing. I did kind of lose it, which is out of character. What you said touched a nerve since I do contribute more than what makes any sort of financial sense. I you want to delete this thread, go ahead. In any case, I really do appreciate the apology. If I see your name on positive themed statements I'll make certain to up vote you. :-)
[I'm gonna "quote" myself here, sorry. :P](http://www.reddit.com/r/Python/comments/18czyy/start_writing_more_classes/c8e2vw1) 
&gt; being killed by the user using task manager &gt; manually killing the process from my IDE I'm about 90% sure that these methods perform the equivalent of [SIGKILL](http://en.wikipedia.org/wiki/Unix_signal#POSIX_signals) on Linux and are thus un-catchable.
&gt; * "stop writing classes" by jack diederich @ pycon '12: http://www.youtube.com/watch?v=o9pEzgHorH0 I watched this one a couple of times already, the dude is hilarious :D
We are three indie authors. We decided to run a bundle sale of our stuff. How does this not make sense? Unless, we're arguing semantics. In which case, Happy Cyber Monday. ;-)
Hey guys, I just want to point out Matt Harrison's blog [here](http://hairysun.com/blog/2013/08/13/how-i-spent-three-years-writing-a-book/). He is offering some special offers. If you own the physical copy, he is willing to give you a digital copy for free as well. As many others, I still prefer a dead tree copy over a digital version. The digital version comes in handy, but I also like to flip through pages of a book to a random page and just start reading. Personally, I'd like to know which purchase method puts the most money in the author's pocket though before I make the purchase.
Yeah I guess I should say I have never taken a cs class so I don't know anything about answering questions for a class. 
&gt; does your project use a lot of the official "patterns"? Yes, we try to follow common idioms and keep the code base pythonic, if that's what you mean. If you ask if we use "design patterns" in classic sense, then of course as Python programmers we love patterns like [iterator](http://en.wikipedia.org/wiki/Iterator_pattern) or [decorator](http://en.wikipedia.org/wiki/Decorator_pattern). ;)
I just picked up the bundle. Thanks for putting this together. 
I know it takes way too much processing power, but it'd be awesome for Valve to put this into L4D3 to make it even more terrifying.
You can do that with screen just fine. I continue to use screen because I don't like how panes work in tmux compared to windows in screen.
DOOOO IITTT! Seriously, I used to use N++. I was like, meh, its good enough. Then I started using Sublime for little things. Then the plugins came, sweet baby Jesus. Comparing N++ vs sublime is like comparing IE vs Firefox (except it uses about the same amount of memory as N++, with like 5x the flexibility. I use it for everything from notes written in Markdown, to light code editing. Honestly, I've become very fond of Jetbrains products (PyCharm, IdeaJ) as of late. I used to use PyDev, but it's just not up to snuff. Eclipse is fine though, but on a small screen I prefer the Jetbrains stuff. As a side note, my friend that works as a PHP / web dev turned me on to it.
Great idea, it'd be interesting to see MongoAlchemy and MongoKit added to the list.
pycharm or gedit or vim or ipython or ipython web notebook. depends if I am making a small fix, developing a new feature, doing exploratory data analysis, etc. I'm privileged to have multiple code bases over many projects to work on. 
I work on a very large Python framework at my job, and we used WingIDE for a new years. The auto-completion, code re-factoring and debugging features are nice. But I've switched to using Sublime text with a few select plugins for most of what I do now.
Screen doesn't have support for horizontal splits in the maintained package. There is a patch that adds it, but it is very inefficient. There are no plans to fix it, or to really accept it upstream into screen. 
Dude this is Raymond Hettinger we're talking about. He makes love to his wife pythonically.
I use Pycharm, Notepad++, and Sublime. Sublime and Notepad++ can both be 'upgraded' to do syntax highlighting, code completion, and so on, but bigger projects need different tools- I end up missing the feedback from the dev console in pycharm, the more-intuitive navigation among files, etc. That said, I'm a novice-level dev and don't do much except grok open source projects code and my own personal projects.
I can't say I've played with the alternatives very much in the last year or so (got my workflow situated), but I'm curious what the other IDEs are up to that I'm missing out on. Besides the autocomplete issues, what other features do PyCharm etc have which Komodo is lacking?
This looks pretty thorough - what's the advantage over something like [tox](http://tox.readthedocs.org/en/latest/)?
I believe you can use the `signal` module to change how the program responds to `SIGTERM`/`SIGINT`, specifically by passing a different method in for handling `SIGTERM`. You might also be able to use `__exit__` and `with` if things are mostly handled by a class.
My goal with that script was the automate the functional testing while using nosetests and virtualenv. TBH, I wasn't aware of tox. I think a single script could be far more useful than using yet another tool that I have to learn. A script can be tweaked easily, and is (probably) simpler. Additionally, I started to use logging in Bash, which I haven't done before. So, that was interesting. 
Why wouldn't you use iPython for web scrapping?
Good stuff! I was looking for a SQLAlchemy example.
I am glad that Wing no longer needs X11. That was a showstopper for me on OSX. I don't want to install the X11 crap.
What about it was a big mess exactly? Try to separate things into files that make more sense if possible. It's hard to give more advice on the subject without knowing more about the project/code. As far as git or any other vcs, it is just good practice to pull others changes before pushing your own. In the case of git (compared to some other version control) it is super easy to make branches to test out new features before annoying other people with your frequent commits. I suggest creating branches if you add features that may span more than one commit. Merges (or rebases) are just the way version control goes and are a good thing in the long run. If things became a mess because people weren't pulling in others' changes before pushing their own then that's their fault.
These are some nice examples! I recently started a new project and went with Peewee, and looking at these, I'm glad I did. Of course, it's mostly just personal preference, but it's nice to be able to compare them.
/r/python has become /r/java? 
For completeness. This SQLA: recent_items = Item.query.filter(Item.checked_out &amp; (Item.updated &gt; hour_ago)).order_by(Item.updated.desc()).all() Using the web2py DAL would be: recent_items = db((Item.checked_out==True)&amp;(Item.updated &gt; hour_ago)).select(Item.ALL, orderby=~Item.updated) The web2py DAL consists of a single file without dependences, it would be easy to include it as one more example.
As a bash newbie, this actually cleared up a lot for me - nice and clean, easy to follow. The logging function is really clean, I might use that for some of my setup scripts, the `echo "Starting..."` stuff everywhere is ugly :)
Eclim is alright.
Yeah, but most of it can be inferred with a thorough enough completion engine.. It's definitely much easier to analyze static typed languages tho.
Less than 20% of the time. Example when working "Naturally Speaking" used Microsoft's Visual C IDE. Almost all other work was done on UNIX where the cli integration with the vi &amp; emacs is so powerful that little else is needed (also see "gid" for symbolic lookups etc. ) 
if you run it in terminal it will give you a warning that you use openjdk and its recommended not to if i am right. auto-complete seems to be working fine for me.
I'm so flattered you chose to include peewee! Thanks for this project, really neat idea.
&gt; multiple cursor What is multiple cursors and why is lack of that feature a dealbreaker for you?
In windows you can't catch any kills from the task manager. Same thing goes when you stop a schedule tasks. What exactly are you trying to do ? Instead of doing stuff at the end, you may prefer 'checking' stuff at the launch of your soft then. For example, at start, create a .lock file somewhere, which indicates your soft is running. If is exits abnormally, at restart, you see that your .lock is still here, and you make your 'cleaning' (or whatever you are trying to do during this atexit() call. Also, windows has a 'Job' api which is pretty nice and can help you. But it all depends on whatyou are trying tondo. Tell us and we will be able to help, I'm sure!
If git seems too hard for you, maybe give mercurial a try? It is easier, and is well supported! Switch to git if you want, after your folks got a glimpse of how dvcs works.
Sublime Text 3 and SublimePythonIDE plugin work well
That sounds...wrong. Git should not allow you to overwrite commits unless you force them (via the -f flag). I'm also pretty sure that the default when you pull and a conflict exists is to merge or at least complain. It sounds like one or more people got impatient with warning messages and used some flags they weren't supposed to without knowing the consequences. 
nice project but running a browser just for that seems a little bit too much for me.
I read your github intro text and I have no idea what this thing does. 
It's totally unnecessary to have multiple files if the groupings are clear and the files are manageable. That's a choice the developers have to make. It's like saying each function should be in it's own file. It's totally unnecessary. Files are logical groupings of methods/classes.
Try git-workflow
If things are small, related, and not going to cause merge conflicts, I agree. I really should have asked why he's defining all of his classes in one file. In general, my experience is that Python developers tend to err on the side of over-inclusion though, lumping logically unrelated code together which can then become a nightmare to maintain, especially when different people are working on different parts of the project and are thus not in constant communicative. Probably the best rule of thumb is to ask if you're likely to touch A while working on B. If the answer is no, split them up. I also try to have a guideline of some sort about file length. Nothing set in stone, but somewhere around 500-1000 lines, I make sure we take a step back and consider "should this all be together or did it just kind of grow? At what point will it be correct to split this up? And, if it shouldn't be like this, why was this not planned before coding starting (nothing wastes time like a mid-project refactor)?"
I use sourcetree and shell for git because I often am between editors
I haven't used it but that doesn't mean it isn't there. They do however have a source outliner.
Hmmmm guess Ill make the switch and see how it goes. Thanks
Can you speak about the remote shells in emacs? I thought Tramp was a way to avoid that. I've never been able to run a remote shell in emacs successfully (using term, ansi-term, multi-term...).
multiple cursors allows you to click multiple places on the screen and then edit text at all of those places at once. It's useful instead of find/replace in some situations.
Add [PonyORM](http://ponyorm.com/) and [PINQ](https://github.com/lihaoyi/macropy#pinq-to-sqlalchemy) please :D
&gt; PonyORM $49 just for a 'hello world' seems a bit steep. :P
Sounds like something useful in very specific circumstances but not enough for me to not consider an editor with the feature.
&gt; But when the application gets more advanced than a basic hello_world.py, it sometimes just fails to "analyze" at all. I use it with several projects with over 200 source files representing ~30k LOC, and it has no problem, not to mention that it's also handling completion for all of the modules installed in my virtualenv.
Thanks for the tip. You're the second person to mention jedi-vim. I'll be giving that a shot. Does it support analyzing modules in the current virtualenv only? And what does it do if I change virtualenvs?
jedi-vim looks really good. I'm going to give it a try. Does it support analysis of modules in the current virtualenv (do I have to start VIM from within the virtualenv or something or is it virtualenv aware?)
It's free as GPL or for non-commercial use. See here http://ponyorm.com/license-and-pricing.html Author is on reddit http://www.reddit.com/user/kozlovsky
Oh. Thats all we use in class. What so you suggest
I would just open the Terminal/Command Prompt and type "python" (no quotes). 
If you're interested in GUI development using the Qt framework, feel free to check out my (albeit a bit dated) videos - http://www.youtube.com/playlist?list=PLA955A8F9A95378CE . Additionally, I offer a somewhat updated version of the same course on Udemy, but for a small fee. That's here https://www.udemy.com/python-gui-programming/
Which OS? If Linux which distribution? And how did you download/install?
vim, with [sontek's](http://sontek.net/blog/detail/turning-vim-into-a-modern-python-ide) vimrc. It's a very good IDE indeed.
IDEL is horrific. When you have a large file and are moving blocks of code, you'll find duplicate blocks show up occasionally. Textpad is better (and free), but seriously use a real IDE like WingIDE or PyCharm.
II just got textpad but now how do I run this 
I just realized that it does create and or delete the temp folder when i type mkdir and rmdir but nothing shows up on terminal saying it created or deleted it. When I hit return it just goes to the next line for me to type something else. That kinda makes it hard to follow this book, I have no clue if i'm doing things right or wrong.
Exponential backoff is the first one I wrote for myself.
&gt; Does it support analyzing modules in the current virtualenv only? And what does it do if I change virtualenvs? I don't change virtualenvs from within vim, but my understanding is that whatever environment you start vim from will be what it uses until you close it. I'm sure there are plugins or workarounds that exist for changing virtualenvs from within vim though. As for pycharm, switching to oracle's jre was a huge improvement. So, thanks for that.
It's an amazing text editor that lets you copy/insert columns of letters and join rows with insertion characters. You don't run the code with it. You type "python script.py"
The main problem sounds like either you or your friend is writing code and are add/committing before pulling. The problem then arises that you have divergent histories that then need to be reconciled. My general workflow to avoid merging issues is * git fetch * if there are no changes, do the normal add/commit/push * otherwise, git stash * git pull * git stash apply * resolve any conflicts (normally, git auto resolves) * goto 1 and restart the process. The benefit of this workflow is that it's incredibly forgiving. A bit cumbersome, but it's incredibly difficult to outright lose or trash anyone's work. At any point during the merge process if things have gone awry, you can trash your working tree and start over since your original work is stored in the stash. An outright git pull w/o stash would trigger a merge, which can be difficult to recover since there would be no clean copy of your work. After the push, don't forget to drop any of your old stashes. As to code organization, a module is just a collection of definitions and statements, and a package is a collection of modules. A basic approach is to subdivide and group your definitions into logically similar or cooperative sets of functionality. My guess is that all of your logic/controls resides in game.py, and that your objects/entities are defined in the classes module. The game module probably has... math, ai, audio, physics, user input, file i/o, etc... You might start by breaking apart your game code into respective modules and organizing them into a game package.
[jedi-vim](https://github.com/davidhalter/jedi-vim).
Yes, design patterns is what I meant. The thing i wanted to get from your post was that with a good editor (+ plugins), educated developers, and organised code, one can write "enterprise" code, without IDEs. 
Mind adding just straight SQL queries? 
windows: gvim, conemu, total commander python with ipdb debugging
Heh &gt; Windows &gt; The only way i know of installing PyQt on windows is to click next all the time...
The ycm configuration file for clang is a nightmare.
Upvote for slop!
I have worked on a number of medium to large projects, and I use the following editors on a monthly basis: - Chocolat - SublimeText - IntelliJ - Vim - LightTable I use all of these alongside a terminal with tmux. Sometimes I mess around in Haskell, Go, Clojure or some other language - but I mostly stick to C++, Python, and JavaScript for producing real projects. I'm not going to tell you which one is better, because the sad truth is that they all have major problems. Most of them do one thing very well, and everything else poorly. - I only use LightTable, because I am hopeful (but without high expectations) that it will finally do the job well when it's more stable. It's pretty much bad at everything at this point, although it's inline results are a bit interesting. That is, if you can get them working properly. - IntelliJ is great at refactoring, but it's a terrible excuse for a text editor. - Vim is a great text editor, but it's a terrible excuse for anything more than small projects - even with [the huge list of plugins](https://github.com/monokrome/vim-configuration/blob/legacy/vimrc) I use regularly. - Emacs is an interesting mix between the two, but it isn't good at solving either problem. Some people just happen to deal with it because it at least tries to solve both problems. - SublimeText sounds great from a theoretical standpoint. You can write plugins in Python, instead of some obscure languages like VimScript; but it has an extremely limited plugin system with an extremely poor API that exposes half of everything in the least useful way possible. The other half of everything, of course, isn't exposed at all. - Chocolat solves the UI problem well (for the most part) but then it has the problem that it crashes all the time for no reason. Still, it's UI has some weirdness - like it's confusing splits support by holding command/alt when selecting files depending on split direction. Text editors and IDEs haven't evolved in any revolutionary way in a long time, and I feel like it's one of the biggest problems in computer science that isn't going to be solved any time soon. Programming efficiently requires that - for every task you perform - you have to choose the right tool for the job. So, I find myself in a position where I have to use all of these at different times depending on the task at hand. The state of text editors is a shame, really. TL;DR Quite frankly, text editors suck.
One reason I still use pydev is the eclipse git plugin. I dislike the pycharm one. Where is the stage? How van I edit it?
On (arch)linux pycharm bugs for me. Sometime my keyboard stop working. To solve that I stop/start pycharm.
POSIX signals don't work on Windows, at least not the same way they do on UNIX. If a process is killed on windows it's just killed, it isn't given a signal to cleanup.
That will trigger when the window is closed, but probably not if the process is killed. Sounds like OP is trying to make a background service and not a GUI program anyway.
Most mates in my team use vim only. I use it for little jobs or if it's over ssh. For larger project I prefer use eclipse+pydev+egit+... Using an IDE improve productivity. That's it. I use pycharm on my laptop because eclipse requires a bigger resolution.
I'm really happy with Eclipse+PyDev. If you're already familiar with Eclipse, I see no reason to switch to something else, though I haven't actually tried anything else. :)
well the idea is that you would normaly have a browser with SO and spent your time there now you can do something else and when there's something interesting you can answer it.
pyqt4 wont install with pip. cx_freeze gave me problems with selenium. so you have to manually do it and that's the windows way ;] 
Exactly. On the other hand, `classes.py` doesn't sound like it‚Äôs a logical grouping of classes.
Someone downvoted this, I just upvoted it:) I think there is a real kernel of truth in the comment. Every so often I try out an IDE, and I always end up back in a text editor (in my case one I wrote over two decades ago, but it could just as well be vim or emacs), and its always the same two reasons. The trivial one is I'm used to a certain set of keybindings. The important one is, I end up jumping off into a shell to do stuff (ie., I use the unix tool chain) so often, the IDE is just getting in the way (and having a shell inside the IDE doesn't count, once I'm in a built-in shell I'm effectively out of the IDE so I may as well do it properly). I have a sneaking suspicion that there is something fundamental here, analagous to the difference between regexps on the one hand and (say) python on the other: both are languages but only the latter is Turing-complete. IDEs are sort-of like regexps, a text editor plus the Unix command line is sort-of like a turing-complete language. LT;DR (to misquote a post above) Quite frankly, IDEs suck :) 
i assume it would be the same as what I need to do for emacs. so in your virtualenv ... pip install jedi epc and then a bit of local config like this.... ;; jedi setup (defun check-jedi-python () "Update the path to python for jedi-mode if we switch to a Buildout project." (progn (jedi:setup) (set (make-local-variable 'jedi:server-command) (list (concat bin-dir "/python") jedi:server-script)) (set (make-local-variable 'jedi:server-args) (list "--sys-path" tw-ext-dir)))) (add-hook 'python-mode-hook 'check-jedi-python) that should be enough to get completion on members and function params. 
I use vim with some tweaks on this site: http://yoursachet.com/ Though, you'll not really appreciate the power of vim unless you learn the following: Regex, Visual mode + Linux Commands (grep, awk, sed) ( ggVG!grep "blah blah" | awk .. | sed.. ) Ctrl + z Window I tried using IDE but the vim plugins is so limited since it can't execute unix commands. 
It gives you ability to transform large amount of data : cvs to dict, refactor code, make list of ids for one-time query. It is really handy in many situations!
I much prefer MongoKit to the other ODMs as it feels more like you're working with Python datatypes rather than messing about in OO hell. It's also nice having Pymongo accessible just "under the hood" when you need raw speed. Thanks for the great work with this!
That's actually not too far off from the kind of research this technology was meant to support. Though my experience has been that galvanic skin response (gsr) is probably a better choice for that kind of application. If Valve developed a mouse or controller with GSR contact points, I think it might actually be pretty effective for emotional state/alertness detection (better than heart rate variability alone, anyway).
Only point GSR requires new hardware where as many computers already have a webcam available.
 The one thing that I'm particularly leery of is the `add_camera` method and then using `get_cameras()[0]` to reference a specific camera. That sounds dangerous. What if two scripts run on the same object at the same time so the camera you want is really the second camera and not the first? Is it always just two cameras, or are there sometimes fewer or more cameras? I ask because if it is a fixed number of cameras, using an array to store the cameras doesn't seem like a good idea. If it is exactly two cameras, maybe thinking about the nature of each camera would be better. Otherwise, I would consider using a dictionary instead In general, I just feel nervous about directly accessing the indexes of a list. Just in general, this code really isn't acting like code that is creating classes, especially since you are directly accessing them via the galaxy rather than treating them as objects. For one thing, using accessor, getter, and setter functions isn't very pythonic. It's generally considered better to just access the values directly. Maybe something like this (and here I'm using dictionaries rather than indexes) would work better: gal1 = Galaxy(name=gal_name) primaryCamera = Camera(name='SDSS', zp) gal1.cameras['primary'] = primaryCamera axisProfile = Profile('axis1', I,R,W,info_dict) # definitely think about refactoring this!! primaryCamera.profiles['main'] = axisProfile axisProfile.fit() It would definitely help to see more details about each class. 
Mine is pretty simple
Sounds like for this functionality classes might not be necessary. If you do go with classes: since the number of cameras and profiles is fixed I'd make them an attributes rather than members of a list (ie. `galaxy.firstCamera` rather than `galaxy.cameras[0]`).
I had the same thought. I've been using grepedit (https://pypi.python.org/pypi/grepedit) for years to change multiple files simultaniously. It is simple and works really well. Especially when you want to change some occurances of a string and not others.
Notepad++ with a few plugins. I work with XML a lot and XMLTools is godly. In my experience, IDEs get in the way more than they help. "No, I don't need a goddamn dropdown with a full help description of the function I am halfway through typing, why are you drawing over the 3 lines below it that I need to read right now..."
My knowledge of trig stretches to the fact that it has triangles in it. I guess I could use a shortened down version of the triangle where the point is the coordinate I'm testing, shortening down the hypotenuse and either of the other lines depending on if I'm testing x or y. The only problem is a: I'm not really sure *how* to do this b: there is a constant dread of time.. if I cram 20 billion equations in for every enemy, the game will be slow and unplayable.
I'm not exactly sure how to "wrap" the rect into vectors, I have tried using pygame.Rect, but I don't really understand that either, and could find no suitable tutorial. Could you please show me an example of how to do this?
Do you mean creating an instance for every enemy created? I'm not sure how fast this would go at runtime, added to the fact that my bullet is actually a straight line from point A to point B, not a projectile where I could check if the end point of the bullet is inside the rect.
I could have a clause that checks if the line is undefined, with seperate, fixed calculations to see if any enemies are on the line.
The bullet line will be checked for any collisions at the click, if that is what you mean, the fired bullet will not move at all, simply fade out into the background. I am fine with squares, though I am not sure how to achieve the idea using radii to check collision, how will I choose what point/coordinate I will want to check the distance of from the centre of the circle? (excuse me if this is just misunderstanding what you meant by &gt; "transform the coordinates of the centers of the enemies into coordinates relative to the pointed weapon" ) As I have told LeFloatingGhost I've never really worked with vector calculations, and have no idea how to "wrap" something up in vectors, could I have an example to help me understand how you would do this please?
Try this: http://www.raywenderlich.com/35866/trigonometry-for-game-programming-part-1
You're not going to miss out on much. Most libraries support Python 3 (and Python 3 has some really nice features, like unicode support and the yield from construct). Go with Python 3 until you find something that needs Python 2. It'll take you an hour, tops, to figure out the differences.
Thank you for introducing me to /r/pystats!
i prefer ansible or web2py on pythonanywhere
Ebooks are nice, too bad I'll never ever buy one since I can always find a free pdf version in the internet... Search Python Cookbook, 3rd Edition filetype:pdf to find [this](http://dl.e-book-free.com/2013/07/python_cookbook_3rd_edition.pdf). Before anyone claims that I should support them for writing these awesome books, I often buy the 'real' versions...
So do you keep the ones you don't buy?
There are several hosting companies out there that can do this for you. Personally, I only have experience with Webfaction. I have been overjoyed with their service. $9.50 per month They always answer help tickets immediately. Installing Flask or Django is a BREEZE! It's simply done through their GUI, which is pleasant to use. You get full control to install libs and stuff with pip and easy_install. Full SSH access. I really love Webfaction, they have been amazing for my Python work. Check them out [Webfaction](http://webfaction.com) Also here is my affiliate link (I will get a small credit each month if you use this link to sign up) [Webfaction](http://www.webfaction.com/services/hosting?affiliate=ghc)
using elpy-mode can help, it can use jedi or rope and has other cool features. 
sure
Full disclaimer: I work for Rackspace. With that out of the way, Rackspace has a [developer discount](http://developer.rackspace.com/devtrial/) that gives you $50/month for 6 months. You can run one of the performance instances all month and have plenty of wiggle room for other services (cloudfiles, CDN, cloudqueues, etc.) Beyond that, Amazon's [free tier](http://aws.amazon.com/free/) (750 hours of a micro instance) lasts for one year after signup. Additionally, DigitalOcean's lowest server is $5/mo. They *all* give you full SSH access so you can install whatever you want. On a side note, link your project here so we can check it out.
PyCharm won't analyze your code if it has syntax errors. My open source project is 100k lines of code with some really screwy stuff in it. PyCharm does just fine if I didn't mess up.
I use the Tiny plan from http://www.asmallorange.com. I don't need more than 150MB disk so the $35/yr plan fits my needs. Beyond that, they completely blow me away with their customer service. It has full support for pip+virtualenv, but they don't give you full reign to e.g. compile numpy/nltk. Whenever I need something like that, they've either granted me (temporary) full shell access or performed the install steps for me. I've contacted their customer service a few times over the years and they've always responded within minutes (and usually resolved my issue within hours).
I'm currently writing an IRC client/bot library with asyncio.
please elaborate.
I fell in love with PyCharm but my current code environment is HUGE and PyCharm could not cope. So I returned to my editor of more than 20 years Emacs. Also, we do some odd things mixing virtual file systems with version control that would take a bit of tinkering with the PyCharm run-profiles thing to get working. And we run a custom version control system which is a front-end to a commercial VCS and an in-house VCS (again because the commercial one could not cut it). So I wrote a bunch of emacs commands to navigate this gigantic sea of custom unique functionality and left both WingIDE and PyCharm by the wayside. WingIDE did better and trying to assimilate the codebase though. 
With O'Reilly you can often get the print+ebook for the $4.99 more than the cost of the print. They are the only publisher I know that is doing this, so I tend to buy a lot of print+ebook combos from them. If you want other publishers to follow suite, I suggest you vote with your wallet and but O'Reilly ebooks as well. Also O'Reilly gives all of their books DRM free, which I love. Stiffing the good guy of their money will only lead them to behave like the rest of the asshole publishers out there. 
I like [prgmr](http://prgmr.com/). They give you a (virtual) server with debian, ubuntu, fedora or centos and a console. You do the rest. Their motto is "We don't assume you are stupid."
I second both the Amazon EC2 Free Tier recommendation, and the DigitalOcean one.
Wish it was for hard copies too...
Another nice thing is the ebooks are drm free.
 face detection lock = True Traceback (most recent call last): File "get_pulse.py", line 212, in &lt;module&gt; App.main_loop() File "get_pulse.py", line 180, in main_loop self.processor.run(self.selected_cam) File "/home/oramirez/tmp/webcam-pulse-detector/lib/processors_noopenmdao.py", line 208, in run idx2 = np.argmax(pruned) File "/usr/lib/python2.7/dist-packages/numpy/core/fromnumeric.py", line 737, in argmax return argmax(axis) ValueError: attempt to get argmax/argmin of an empty sequence 
They made some changes to the GIL for Python 3, so I'm not sure the information in this article is valid for anything in Python 3. Does anyone with more knowledge know how much of this article is valid in terms of Python 3?
Hm, what platform are you on? I have an idea of what the problem could be. Does your webcam otherwise work correctly? Do you know what the framerate of it usually is?
If it were for hard copies, I'd order a few, but I refuse to pay for technical ebooks. I only use them as reference guides, and I can use misc. googling just as well. If I have a hard copy, I tend to read through the entire thing.
I don't know if it's possible to set up for people outside of Germany, but Uberspace supports Python (and a whole lot more) for 1‚Ç¨ minimum (that's right, name your own price). They only accept regular bank transfer as a payment method and without some knowledge of German their tutorials and documentation won't be of much use, but other than that I can wholeheartedly recommend them. Shoot them a mail, they usually respond very quickly, maybe it's possible! 
Y u no space!
Don't bother with WebFaction. For several dollars cheaper you can get a *full* VPS with root access. Check out lowendbox.com.
You might want to try posting in /r/learnpython - I think you'll find it more appropriate than here. It looks really neat though! Here's a few thoughts for improvements: 1) What if they type "Pistol" (or anything else that you're not expecting)? Can you think of a way to handle that and maybe ask them again? (Hint: You'll need loops and an IF statement) It's also easier to read code if you post it to pastebin.com first, and then just post the link here. Great job though!
Here's an idea if you want to try and challenge yourself: Make an engine that can handle arbitrary games of this form, by reading questions, correct answers, and responses from a text file in a format you design.
If you buy an eBook from O'Reilly, they will give you 40+% off of the hard book. If you wait for a sale on hard books, it will stack/compound with that sale. 
I'd definitely second the PythonAnywhere suggestion. I've been using PythonAnywhere for over a year. Very friendly, reliable, and 100% focused on Python. Access through SSH or web console. Plus, "batteries are included" -- just about every python library known to man is already set up. I have yet to do my first easy_install (it's available, of course). I joined because of the low price, but I am staying for the support and reliability.
I am learning Web2Py at the moment. I come from a Codeigniter background. Web2py seems quite neat and well ordered after an initial learning hump. The owner of web2py Massimo, often pops onto reddit, stack overflow and google groups to answer questions.
Thanks for the suggestion, I will definitely check it out!
you kno what dickwad? this is why there arent that many ebooks for python. because people like you take money from authors and publishers. if you buy the print copies why dont you take a photo of yourself and the books and put your real name on it. i bet you arent going to do that because you suck.
+1 for webfaction. Unless you are absolutely sure that you need a vps, this is a great choice. Just make sure you do your db backups, they say they do daily snapshots but that turned out to be bs. Otherwise their support is great - fast and helpful.
Maybe add four spaces before the stuff, like so: def whatever(): print "Do something or rather" 
Use http://ramnode.com and do the deployment. Edit: if you want to help me out, use the affiliate id 302 when you sign up. Also, there are some coupons out, some being IRC33 and BLACK42 IIRC.
Check out http://cloudatcost.com/ , $35 one time fee for a small instance, I have the $70 instance and it's been pretty solid for the last month. They could get acquired or go out of business at any time, but if they last a year it's a worthwhile investment. 
General rule of thumb when you think you've found a bug in well used and well tested code bases: It's not a bug, there's something wrong with your code. I'm not trying to be pain, I've just seen this mistake made many times over and many hours wasted waiting for someone else to fix the problem.
Manning Press will give you a free e-book version, DRM-free, if you buy a print book. This is the main reason I buy their books. But they also have a lot of good books. I have especially appreciated their C# programming books.
Wow, that is great. Unfortunately, after looking over their catalog, they just do not have much that really interests me right now. Edit: for those interested: http://www.manning.com/catalog/by/subject/
Have an upvote for nuclear physics.
I'm running it under Ubuntu. The camera worked fine, and the face tracker was able to lock on my face and find my forehead. No idea on the camera framerate. How could I check?
Are there any must have books I should buy now?
I was excited by this offer, because I've got my eye on _Python for Data Analysis_. Price on Oreilly's site: $31.99. At half price, that's $16. Kindle price: $17.17; Nook price: $17.99. ‡≤†_‡≤† 
[Python for Data Analysis](http://it-ebooks.info/book/1041/) . why does anyone buy ebooks..? google --&gt; filetype:pdf " NAme of book here "
So true. Interdependencies also matter; for example, people on Windows almost always demand an IDE because there's really only one way to create programs on that platform; the Visual Studio IDE. So when all you have is a hammer, ... Also, if your Python component is part of a wider application that's not necessarily in Python, for example something with an embedded Python interpreter for whatever reason, you may find it easier to work in the team using the same toolset as everyone else. For example a large project I had was mostly in Java and the team was using Eclipse so it became stupidly easy for me to plug in PyDev and be able to interact with the same code repository in the same tool, everyone is on level footing. Personal preference: Vim. REPL languages don't need an IDE, and frankly their shoe-horning always feels wrong. There's also no substitute for the simple yet powerful editing capabilities of Vi, especially when all existing IDE's are essentially glorified Windows Notepad (hammer keys repeatedly because there's no concept of motion and repetition, poor (if it even exists) and complex external tool integration, constantly have to refer back to the mouse to do simple stuff, ...) 
It doesn't seem to return anything.
A blank screen pops up and then immediately closes. 
Python would suit perfectly since its a common task in python.
Has anyone used a python to javascript translator for any large production project? I would be interested in hearing the pitfalls. I've definitely considered this approach before, as there are [a ton](https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS#python) of ways to do so, but I keep deciding against it, b/c the community and widespread adoption doesn't seem to be there. When I'm deciding on a technology to write a long-running project in, it's hard to compromise on the lowest level. Or is it not a compromise at all?
Are you sure you need a programmer for that? Maybe [LinkChecker](http://wummel.github.io/linkchecker/) can help. Otherwise [Scrapy](http://scrapy.org/) is up for the job, so you can't go wrong with a python programmer.
This is a minimalist one I wrote as an example in class: https://gist.github.com/mdipierro/6624cb39851ca750bb2b It can be improved but works fine.
i thought BDFL himself asked to desist from converting python to javascript in his slashdot interview or due to some reasons? edit: spelling
Because they want to support the author rather than stealing their work?
Isn't R focused on statistics? I only have a passing familiarity with it, but it's one of the last languages I would consider for web scraping. Python is a great tool for this job. I work on web scrapers as part of my job, and all of ours are written in Python. This is not a difficult task from the sound of it, if you don't need to deal with Javascript or Java it could be done in an hour, with some overhead to test things and add the code for reporting things and whatever else you need.
This looks interesting. I seem to remember there is a python interpreter for browsers where you can directly link py files in the script tag. It was pretty cool. But I guess it would not be as fast as the compiling-to-JS approach. I wonder how would one do multi-line anonymous functions elegantly in python?
Most people have different definitions of 'must have' though.
Thanks! [Building Machine Learning Systems with Python](http://shop.oreilly.com/product/9781782161400.do) looks like a good read. Does anyone know of other introductory books on this subject (in a web context), based on Python or other languages? 
Flask is designed to be small and not overly featureful, if that's what you're looking for. Pyramid is also great if you want something "well rounded" but not as massive as django.
I thought it was much, much funnier as "BDSM" and maybe a personal opinion on Guido's function in regards to the core developers. :-)
[Skulpt?](http://www.skulpt.org/) Python was (is?) also available through Windows Script Host. And there's [Brython](http://www.brython.info/), too, which implements Python 3. Though I don't know how active it is. I didn't bother to check.
I have previously used WebFaction but now I have moved to digitalocean. It's cheaper and you get all the good stuffs of a VPS.
You should exit the loop in some point, one of the possible solutions could be: while True: print menu answer = input("blah, blah: ") if answer.lower() == "p": ... if answer.lower() == "x": # assuming 'x' means exit print "bye" break Break will exit the neverending while loop.
I'd take a look at Billy - https://github.com/balanced/billy
https://groups.google.com/forum/#!topic/skulpt/WeFe9inRO3Q some progress in merging
I hear good things about this book: http://shop.oreilly.com/product/0636920029533.do Although it's still in 'beta' so I'm waiting for full release.
Brython ? http://www.brython.info/
Its a good deal to be sure, but O'Reilly has these deals quite often - sometimes just for a certain subset of the books and quite often the same 50%. Follow their twitter https://twitter.com/OReillyMedia and you'll catch them. In addition, when you login you'll notice that they actually have a buy one get one for free thing going on all the time. (basically 50% off if you need two books). 
there is also some PaaS https://medium.com/p/ac909b5c2423
I'm very interested in the topic but I hate reading through slide decks without video of the actual presentation so I'm going to let this one... slide.
/r/learnpython is that way ---&gt;
You're welcome! Spread the word!
I was on this presentation. The language of presentation was russian. As usual video will be available [here](http://www.youtube.com/user/pythonMinsk) in 3 weeks.
I don't have the reference handy, but I suspect it was more along the lines of "please stop calling it python if it doesn't implement python" more than "please stop making python-like languages". *Edit: &gt; Guido: I gave up on it in 1995, so yes. And please don't try to compile Python to JavaScript. The semantics are so different that you end up writing most of a Python runtime in JavaScript, which slows things down too much. (CoffeScript's strength is that it is designed to map cleanly to JavaScript, and the two are now co-evolving to make the mapping even cleaner.) From which I infer that a translator that doesn't actually match the semantics should not be called python.
How are they continuing to compete now that Digital Ocean is out there?
If $20 a month isn't too much for you I couldn't recommend Linode any higher. An amazing company. Full disclaimer: I don't work for Linode :) 
Better tooling, for once. It's easier to make code completion with static typing. Tools could make better analysis of your code if you have type annotations... But then again. It's the performance gain what matters the most. Mypy looks certainly cool. It reuses the type annotations available in python3.
Pretty excited about this project, it's pretty obvious the creator has done a lot of research and has been persistent about trying and looking over all implementation possibilities. IMHO this will be the first really useful and production capable Python to JavaScript compiler.
&gt; Isn't R focused on statistics? I only have a passing familiarity with it, but it's one of the last languages I would consider for web scraping. surely you mean to say it's NOT one of the best you'd consider for web scraping
It's a structure and correctness. Having static types means that errors can be found earlier- when you go to compile. It makes unexpected behavior apparent sooner, which makes it easier to fix.
*"Having static types means that errors can be found earlier- when you go to compile"* Only *some* errors, specifically type errors, which in almost all code that I write (perhaps I'm an exception), are the trivial errors that take 2 seconds to fix (and find), compared to logic bugs that are much more difficult to find and resolve. (And no compiler can find these)
I didn't know them. It looks interesting. And I hope the owner of prgmr review his prices. His service is good, but he should keep up with the competition
Already mentioned, but I will repeat anyway, [Digital Ocean] (http://Digitalocean.com) . Nobody beats $5 box including SSD. Beautiful UI I'm using the 4GB RAM 2CPU $40/month machine for Pythonhackers.com+PythonArticles.com and couple of more websites.
nicely written explanation
to those more familiar with this library, how is this better or worse the differeds using twisted ?
Just thinking.. Sure, you get more control, but maybe that's not always a good thing. It requires more know-how and IT admin/Unix knowledge. And time. Myself, I'd pick Webfaction or something similar instead, just to avoid the hassle of admin stuff.
I am looking for the Python equivalent to the book "The Ruby Programming Language". Short, compact, and where the reader is suppose to be familiar with programming concepts. I write python from time to time, but it is just not very Pythonic yet. Where should I go looking? 
My unproven opinion is that Haskell types make code rock-solid. Java types are cumbersome. Again, this is unproven. I could not code my way out of a paper bag in either of those languages.
Why are you (still) using hard copy tech books ? I'm really curious. 
In PyPy benchmark repo we have a raytracer that runs +- 100x the speed of CPython.
This gets skimmed in this presentation, but performance is very much a non-issue. If you write programs statically-typed-like, PyPy's JIT can make tons of optimizations based on that. You don't have to actually **write** those types.
the Cheese Shop is my goto fix
there's just too many so I started this thread
Right. I am not trying to be argumentative, but the idea is that static typing potentially eliminates this class of error. In a not so big project this seems like not such a big deal. You can pop into the source code, update the offending source, write a new test case and, update production. But, for large code bases (I am working on a 1million + loc python project) these type errors can be maddening and expensive. The time invested in making these corrections could be better spent on other things. 
For me, it comes in handy big time with a webapp, or really any time you're trusting user input to be something other than a string. The number of functions I have that start with multiple lines of type checking is a bit absurd.
Your comment reminded me about Darcs. This shit was slow AND buggy as hell. It was few years ago when I last used it and I bet the project improved a lot since then. Yet somehow Haskell didn't save Darcs from its sorry state back then.
Does Morepath do something new in combining Flask-like app-based decorators with a general system for doing extensions and overrides? I suspect so, at least in the Python world, but I'd like to hear of other examples. Pyramid is close, of course, but doesn't have the app concept. 
I know this thread is in the Python sub, but for a C# programmer, Manning has arguably the best collection of advanced programming books of any publisher. Anchored by Jon Skeet's excellent *C# in Depth*, then there's *Metaprogramming in .Net*, *Dependency Injection in .Net*, *The Art of Unit Testing*, *Aspect-Oriented Programming in .Net*, and *Functional Programming in .Net with F# and C#*. That's a solid collection. I find that I prefer reading my technical books on my Android tablet, but I prefer *having* my books on my bookshelf.
WHY?
Refactoring, mostly. Dynamically typed languages suck hard at doing rapid prototyping/exploratory programming at the scale of more than a hundred lines of code (in a hilarious counter to common wisdom). Basically, you finally realise that so and so function should take an extra parameter, or a list of items instead of single item, or be called differently, or whatever, and where you'd press F9 or ctrl-shift-B or whatever compile button in your favourite IDE or Vim and go through all call sites (or even use the refactoring tool), with Python you experience a pretty annoying phantom limb sensation. Tests would help somewhat, but are incompatible with rapid prototyping/exploratory programming, you really don't want to write 5x the amount of code that you're probably going to refactor into something completely different or just throw away. Vastly improved intellisense is another thing that causes phantom limb sensations and bitter resentment for years after you stop using a language where it really worked. Heterogeneous collections on the other hand are useful not all that often and are trivially implemented when they are.
- Why is it called "twosheds"? - scsh (Scheme Shell) and TCL (Tool Command Language) come to mind as prior work in other languages. Not to mention eshell for Emacs.
Ajmarks, have you tried approaching repo maintainer on github about package's architecture and other issues you have found?
* Not having to learn bash or (worse) Windows Batch Language to do any kind of advanced thing in the shell * Easily customizing parts of the shell (e.g. prompt, tab completion etc.) 
Fore more than one year, I have a code for 50% off when buying two books or more.
I haven't yet. I hope to get time later this afternoon. The only reason I came across this was I was trying figure out this error (written to stderr, so no stack trace!): findItemsAdvanced: Domain: CoreRuntime, Severity: Error, errorId: 2030, Internal error: java.lang.IllegalArgumentException The cause was a bad API key. Because that makes perfect sense.
- No good reason. "twosheds" is a reference to [a Monty Python skit](http://www.youtube.com/watch?v=HLjS3gzHetA). It's early enough that I'm open to changing it if there's reason. - Neat. Will need to check them out (especially scsh since that might reasonably be even more powerful). I actually have not heard of those.
Unfortunately my program was using blender (www.blender.org), so I don't have the freedom to change my python implementation at will. I ought to reimplement it as a standalone python program. It'd be a fun excuse to figure out how to install pypy. (On the other hand, I could still write the raytracer as an extension module in cpython. But python is of course more fun than c)
Just to follow up to /u/gschizas, I wanted to make a shell I could hack on. I've tried bash, fish, and zsh, and while especially with the latter two I like a lot of their features, I've tried extending them on several occasions and could not figure it out. twosheds is just Python-- if you know how to write Python (or are willing to learn) it's trivial to move on to advanced things like extending the interpreter or customizing tab-completion. I also think the scripting languages are terrible. For instance, simple things like setting the PATH requires elaborate constructions: # Set search path for executables unset PATH for _this in \ ~/local/bin \ ~/bin \ /usr/local/bin \ /usr/bin \ /usr/sbin \ /usr/X11R6/bin \ /bin \ /sbin do test -d $_this &amp;&amp; { test -n "$PATH" &amp;&amp; PATH="$PATH:$_this" || PATH="$_this" } done export PATH versus: PATH = ["/Users/ceasarbautista/local/bin", "/Users/ceasarbautista/bin", "/usr/local/bin", "/usr/bin", "/usr/sbin", "/bin", "/sbin", ] os.environ['PATH'] = ":".join(PATH) With any luck, I will never have to write a bash script again (at the very least, for personal use). I've written some examples in the [advanced](http://twosheds.readthedocs.org/en/latest/user/advanced.html) page, namely: - adding a git branch to the prompt - automatically running `ls` whenever the contents of the working directory change, and - automatically running `git status` whenever the git status changes. For an example of a more complete customization, I wrote my own personal shell (which is now my default) just as a proof of concept, [ceash](https://github.com/Ceasar/ceash/blob/master/ceash). Perhaps more importantly though, I just want to have a platform where a wider audience can contribute extensions (similar to Flask). If the barrier to entry can be reduced, I think we can reasonably expect a lot of creative work in the future.
I've never really been a fan of IDEs. I prefer things to be very fast and 100% keyboard controlled. Also I move between machines a lot, so like I said, not depending on software on the host machine is key. So no, I haven't used sublime or pycharm thoroughly enough to form a comparison, but I'm not particularly compelled to either. Also I'm one of those people that has a hard time trying new stuff, I'm very stuck in my ways lol.
I'm at half a million and I'm not having any issues with these type errors. But different code bases are different, I guess. That aside, the question of course becomes whether giving up dynamicism is worth the benefits. I personally have a hard time even seeing that the benefits exist, so I of course don't think it's worth it. (Which is why I prefer a dynamically-typed language to a statically-typed one, all other things staying the same.)
YAY, lets all make fun of other peoples codes. Cuz that's not hostile but using gender specific pronouns in docs is. 
This is interesting. What does one time fee means? Is it for one year? or like forever (which I suppose, couldn't be)
thanks every one for the responses! It seems like python might be the winner (I don't know anything about NodeJS &amp; jQuery but I'll ask around about that too). More specifically -- and maybe I should move this to /r/Python -- the end result of what I'm looking to have built would be a program that would do the following steps: 1)read a text file that I supply as a parameter upon execution. This text file will have one "keyword" per line 2) for each keyword, scrape the top 10 results of Google for that keyword based on a "footprint" of settings that I would also supply on execution (ex. "site: *.edu -2013 -2012 -2011" which would only scrape sites with a .edu extension and only sites that existed before 2011 ... If anyone is familiar with Scrapebox, I'm basically automating what that program does so far). 3) take that list of URLs and run a "link check" on them. This will crawl every link on those URLs and report back a status code for each. Basically, what Xenu Link Sleuth would do, but, again, automated. For each url that returns a certain status code, write that URL to a text file. 4) I would now have a new text file with a list of URLs that returned the status code I'm looking for. Sorry for the long winded post. Just trying to get an idea of how long something like this would take a programmer to do and how much a reasonable price would be to pay someone to do it. That said, anyone interested in taking this on... let me know :-) Thanks again everyone!
I would say python hands down. I would use: gevent http://www.crummy.com/software/BeautifulSoup/ flask gunicorn 
Tramp is a way of avoiding having to open up a remote shell just to do an 'emacs -nw'. I find it's also useful to open a terminal on the remote machine to execute scripts and the like. The way I set things up is to use Tramp to open up any files that I want to edit on the remote server and then split the frame and use "M-x eshell" to get a command line window inside of emacs. SSH into the remote server from that command line, then I can also be executing python scripts, moving files, etc. All from within one GUI Emacs frame that is running on my laptop.
And what is up `_version.py` and `get_version()`? It's a python file but it parses it with a regex. WTF.
Awesome, + it seems to work in virtualenv, which most python audio libraries don't. 
It's a great name!
It's forever, until the company ceases to exist (or they change owners/policies or whatever). I assume they probably won't stay in business for too long with this business model, but who knows. 
I'm not commenting on the specific package mentioned by OP, but I don't see what's wrong with having a decent amount of code in \_\_init\_\_.py. It doesn't seem especially better to put stuff in e.g. `core.py` and then in \_\_init\_\_.py do `from .core import ...` etc. I'm not saying that you *have* to put substantive code in \_\_init\_\_.py, just that it doesn't (in and of itself) seem wrong. 
Are they translating python incorrectly, or just translating a subset? The projects that accelerate python by compiling to a lower-level language (numba, parakeet, cython) only support a subset of python.
What this guy said. I have used the "value, error" paradigm only a handful of times ever, and only because it made a lot of sense to do it at the time (I can't think of an example right now). Typically, you want to raise exceptions. I think one case you can argue returning an error makes sense is if your function has a lot of expected errors, and the error doesn't mean the function's processing should halt.
Right. Avoid using Exceptions for flow control. If an error is not exceptional, then keep it inline.
All the cloud servers let you bring up new boxes with new OSes anytime you want. Provisioning time keeps getting lower and lower too -- down to less than a minute. So if you want to, switch OSes every couple minutes. Easy to tear down and bring up especially if you script/automate your provisioning and deployment. I have a slight bias towards which you should use, even though I use all the ones listed above. If you use Rackspace, I'll be around to help you out with our services/infrastructure. Just let me know!
 Thanks for your thoughts - you can ssh into the remote server with eshell?? I thought it wasn't powerful enough...(I mean you *can*, but I thought using shell or eshell for remote access was advised against.) I do use Tramp sometimes but I hate how it pauses when I C-x C-s out of habit...but I do like that you can use dired in the remote server with Tramp also, if I recall correctly. 
That can be just as bad. There's just no logical organization of code.
This is not some guy's random homebrew project. This is eBay's official Python SDK, and it's awful from beginning to end.
There is a reference to [this](http://www.youtube.com/watch?v=6RexQLrcqwc) sketch in there in case that part about train spotting sounded weirdly familiar to anyone. 
did you write that program IN the shed?
have you read this? http://www.jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/
Why are you type checking so often? Could you provide a good example?
I think that's kind of the point of the project. Better example might be: PATH = ["/Users/ceasarbautista/local/bin", "/Users/ceasarbautista/bin", "/usr/local/bin", "/usr/bin", "/usr/sbin", "/bin", "/sbin", ] PATH = [f for f in PATH if os.exists(f)] Which is much easier to read and write, regardless of your prior knowledge. Bravo, I really like this project, and will start messing with it immediately.
who gives a shit? and why does it warrant front page on r/python? I mean there's fuckin cat pics yet to be scraped from imgur with my favorite web framework. and we are all wasting time with EBAY? Why not AOL or Myspace? 
Can I see it? Maybe I've been over complicating these... The documentation is rather poor.
Yeah the docs suck. Here's one from a project of mine: https://github.com/zfogg/libbin/blob/master/.ycm_extra_conf.py
OpenShift (from Red Hat) has a free plan for Python hosting, IIRC. http://openshift.com https://www.openshift.com/products/online 
If its early enough, maybe you can incorporate the concept of a pipeline of objects, like in power shell. That really is a brilliant concept that I miss when I move to my Linux boxes. (get-items).fullname is so much better than ls-l | cut or whatever. And that's a simple example. There are better ones.
The simplest example I can think of is imagine I have a function that handles a request to /multiply?x=2&amp;y=4. In this request handler I try to convert x and y to int, and if they can't be, I set them to 1. This handler calls multiply(x, y). Now if I screw up something in my request handler with that conversion process, I don't know until I go to that page and see an error page returned. So now maybe I do some type checking in multiply() so I can react more gracefully than just throwing an error immediately (as sort of a backup precaution to messing up the type conversion). On top of that, now I have to write a bunch of unittests to ensure that bad input is handled properly. Having static typing removes the need for all of that. Some will say those errors are the easiest to find/fix, and they're mostly right, but it's just a hassle to have to be concerned with that type of thing so frequently. I don't see how adding optional static typing could hurt.
By worse you mean the basically all-around awesome object-oriented scripting language that is Powershell?
love these post, keep up the good work :)
Will look into it. Also totally feel free to make a pull-request yourself. :)
Interestingly here's another one: https://github.com/marianoguerra/rst2html5 From what I can see so far they appear to be unrelated codebases. I've been using this version to generate presentation slides, as it also has support for things like reveal.js. 
&gt; it's one of the last languages I would consider. Means they wouldn't. This is a common English idiom.
Why would you use type checking there? Why not just use EAFP like normal and just do try: x = int(x) except ValueError: x = 1 #repeat for y In your example, if you control all callings of `multiply`, why not just ensure that you don't pass in non reals? (Integers, in this particular case) If you had unknown third parties calling your code, I could see a justification for the type checks here, but if you're the one calling your own code with bad data, well, don't do that silly. Otherwise (to be consistent) you'd have to pepper all of your code with type checks everywhere and at that point, why are you even coding in a dynamic language if all of your types are known (at write-time) and verified at runtime anyway? I don't really see how static vs. dynamic typing has anything to do with this at all. As far as I can tell, this is just user input validation, which is the exact same whether you've got static or dynamic types.
This is a neat way of collecting and presenting info, but wouldn't it make more sense to publish this as an RSS feed than submitting it to reddit?
Yeah, it is a pain, but YCM is so useful that I do it anyway. Besides, how often do you really edit a Makefile during the lifetime a project? The source will be edited so much more, and that's where you'll need the `.ycm_extra.py`.
At the cost of your shell scripts only working on your own machine? That's a pretty high price.
I built it originally to save the effort that some folks put in to make daily posts when there are big sales, and I kinda like seeing the reports mixed in with my regular feed every day. I've thought about building a nice little site front end where you could see what's on sale, maybe look at price fluctuations over time, that kinda thing but with the sites like steamdb and steamcharts already existing I'm not sure if there's much want for something like that. I'm probably going to take the data that I normally dump into my dropbox as JSON blobs and start pushing it into a DB and I'll probably make a public API for that.
Have you tried Long Path Tool? I think this tool will be helpful for such issues!
This reminded me that I was still using the old distribute 0.6, and that I should upgrade back to the reinvigorated setuptools, which strangely requires manually deleting things from `site-packages`.
I'm confused, are there multiple"for app in app_list:" for loops, or are you just adding to them the more you explain it?
Oh wow, thanks man!
I edit them a lot :(
Hello Bkkrocks. I am interested in helping you with the development if you choose to start from scratch. I already have a similar project in mind. Its kind of minimalist, just tickets with a few classification behaviour. But I think we can figure out a common project and work together.
No, I meant the mess that is .bat files, run by cmd.exe. I like the idea of PowerShell, but I could never get past the initial steep learning curve...
That would be great. I'll send you a PM.
What do you mean? If it's a regular python script, it's fairly portable. If it's specific to twosheds, it's just a shell, and nothing serious would be lost. (If I'm really missing something, it would be good to get it out the way now.)
I do apologize, I am by no means a web developer. If you'd like to make a change to the style sheets or basic templates my site uses feel free to submit a pull request [here](https://github.com/chipolux/site_source). It's just a simple static site generated using Mynt.
A lot of interesting tutorials and material [here adafruit](http://learn.adafruit.com/category/learn-raspberry-pi)
http://www.reddit.com/r/Python/comments/1qnbq3/webscraping_selenium_vs_conventional_tools/cdeq2t7
http://www.reddit.com/r/Python/comments/1ozd0a/how_does_tulipasyncio_relate_to_go_and_clojures/ccxlmbk
doesn't blender let you use pypy these days?
Using SSE is a nice alternative though, but sockjs/socket.io allows for (sort of) easier multi-directional communication. If you just need to push updates from the server to the client then SSE is perfect, the only problem I've had is lingering connections when shutting down the server, it needs to kill all connections before trying to quit.
Thinking the same as we already have this: http://eleks.github.io/js2js/
Version 1.0.0 raises TypeError as you suggested. Thanks!
So... did he get the job?
Looking through all the suggestions, this is definitely the best way to go about it - checking whether any cleanup is necessary on startup, and performing it then - rather than trying to intercept kill signals and doing it before shutdown. I've now implemented the .lock file and everything seems to work well - thanks for your help! :D
Jesus. No idea how I read 'last' as 'best'.. Just did it again now. Something's up with me eyes!
&gt; I do apologize. You shouldn't apologise to undeserved rudeness.
It really is unreadable on a phone.
[Google is your friend](http://lmgtfy.com/?q=python+read+write+midi) Edit: in case you knew all that already, and were wondering "how do I edit a file?", the answer is that you don't. Just create a new file, and while parsing through the old one, write to the new one.
Is there a library that you'd recommend or a process by which to parse a midi file that you'd recommend? I'm not the most advanced at python, but I just need more of a tip in the right direction to get started more than anything. Also I worded the original post badly, and I know that the original file won't be edited.
Immensely popular massive online games :World of Tanks , World of Warplanes and EVE Online! Those huge online games uses python in both Server Side and Client side , Bigworld engine Powers WOT and it is almost all python on serverside and except engine , most of client side are in Python too . EVE too. You can read a lot about EVE and Stackless Python.
You are assigning the result of the callback functions as a callback for the buttons instead than the function itself. pro-tip: you made an obvious mistake.
There are two different python midi libraries in the top 5 google results. look over their documentation for a few minutes each and then just dive in to whichever seems the best documented. It's a very simple thing you want to do and I'm sure both provide a fine interface for doing it. Just dive in!
Arguments are evaluated at definition time. Where you say (e.g.) self.button = Button(..., command=self.openFile(...)) You're giving command the return value of 'self.openFile(...)', not telling it to call that. 
Thanks, I appreciate the help despite the initial sass haha
Maybe you should look into getting a book if CodeAcademy doesn't explain returning and printing.
Return *returns* data from a function to where the function was called. Print just displays some data on the console. 
Print and return are very different. Print takes what you give it and puts it on the screen for you to see, that is all it does. Return basically says, here is the result of my work, give it to whatever requested it. It seems to be the same when you work in the interpreter, because everything that is returned and not otherwise used gets printed out for you to see. If you just want to see the answer on your screen, use print. If you want to use the answer for anything else, use return.
Checking now. Thanks!
What libraries might those be? 
Whole Scientific python set. (numpy , scipy , matplotlib , scikit-learn) , Web2py , Many other libs that no longer updates..
Except for web2py, every single module you listed supports Python 3. 
Scipy, numpy, matplotlib, scikit-learn all support Python 3.x. 
And if you're interrested more in-depth (why not) .. print sends the object (string/anything) directly to stdout (basically commandline) but return is at the end of a function/program and is passed on to the caller when you call a function that has print .. it just prints the contents of the object you're printing to the console (stdout - you can pipe it to somewhere else or do unix magic with it) but when a function has return in it, it returns the object to the place where it was called and you can use it there for another piece of code
Happy cakeday, Python 3! And **it is** getting more and more mature as new libraries are ported... :)
...and it was called Python 3000 back then. Brave move and still, state of Python 3 it better than state of Perl 6 :-)
*you* need to move (a bit)
Glad to be helpful ! Have fun with python :) 
I like that analogy, especially as it would lead out to the primary danger of async ( if you get too wrapped up in a task that cannot be stopped, other stuff might burn/time out ).
It'd be a lot easier to use the time library for this versus the datetime library. import time cur = time.time() #do whatever duration = time.time() - cur
thanks
Guido has said the transition is right on track and that he gives it another 5 years. It'll probably be a bit after Python 2.7 is deprecated that the leftover people start actually upgrading. I know my company won't upgrade till then. I do wish I could do... from __past__ import print
OpenCV
Looks interesting, but I can't use it since it's GPL. Apache v2, Python, or MIT would be much friendlier.
and I'm still using python 2
WMI
scapy.
Thanks for the feedback. What is the exact problem with GPL? I can consider changing the license if there are good reasons.
GPL means every project that uses the library also has to be GPL-licensed (or GPL-compatible). Typically you want people to publish changes to your library, but not necessarily whatever they build using your code.
..me too. I tried using python three exclusively a few years ago but the library support just wasn't there at the time. The landscape seems to be different now. Perhaps it is time to give it another shot. 
Yeah, the damn print function, I still forget the parens each time.
The reverse is happening to me, but I'm importing print_function from __future__ in my code, so I never use the version without parenthesis unless I forget that import. I do similar thing with unicode and division, in hopes that porting to 3.x will be much easier.
Ubuntu now ships both Python 2 and 3 by default, and is moving towards dropping Python 2 from the default installation. Fedora is also [aiming for Python 3 to be the default](https://fedoraproject.org/wiki/Changes/Python_3_as_Default) by F22. And of course Arch has been a fan of Python 3 for some time. It was always going to take a long time to build up the momentum for this, but things are moving towards it now.
Twisted
I feel that things are progressing quite nicely lately. I think with python 3.5 many people will make the switch. The event loop will be stable then, the performance will likely be fully on par with python 2.7 and library support acceptable.
Not a very good idea unless you want to lock out OS X users.
Your "pro-tip" is inaccurate, you simply have not yet reached the necessary level of understanding. Look here for some help: [TkDocs - Tk Tutorial](http://www.tkdocs.com/tutorial/index.html) To provide parameters, you need to use a lambda function: self.button = Button(..., command=lambda: self.OpenFile('filename'))
There are newer languages than python 3 if that is your criteria.
There's no need for Sage for this. It's doable in straight Python. You're looking for something like this, I believe: import random spellPower = 569 fireball_min = 596 fireball_max = 761 fireballCastTime = 3.0 averageFireball = ( ((fireball_min + fireball_max)/2.0 + spellPower) * fireballCastTime / 3.5) def castResult(crit, hit): "Compute the result of a fireball cast with the given crit and hit chance" actualCrit = crit / 100. actualHit = 84 + hit hitRoll = random.randint(1, 100) if hitRoll &lt;= actualHit: # The original code says that it returns an integer. # I don't know if it truncates or rounds. I truncate. return int(averageFireball + actualCrit*averageFireball*0.9) else: return 0 def averageCastResult(crit, hit, iterations): "Compute the average result of a fireball cast with the given crit and hit, \ after casting the specified number of times" total = sum(castResult(crit, hit) for i in xrange(iterations)) # The original code says that it returns an integer. # I don't know if it truncates or rounds. I truncate. return total // iterations 
Well, then you can use `/usr/bin/env python2`, I think. But if you're writing a library module, not meant to run by itself, the shebang's precise format is not as important as the `python` vs `python2` distinction. There are some operating systems now which symlink `python` to `python3`, and there will be more in the future, so you *can't* just assume `python` is `python2`.
* automagical [playlist for videos in this post](http://radd.it/r/Python/comments/1s3odr?only=video) *^Downvote ^if ^unwanted. ^Comment ^will ^be ^removed ^if ^score ^is ^0.* [^Message ^/u/radd_it](/message/compose/?to=radd_it&amp;subject=Please Blacklist&amp;message=Good sir, I appreciate your efforts but do not require automagical playlists. Please add me to your bots blacklist.) ^to ^never ^receive ^comments ^from ^this ^bot.
So they claim. Both times I tried to set it up I was unsuccessful, although I only ever tried the prepackaged msi. 
Here, I made it a class for you. Who knows, maybe you'll find it useful. class StringGetter(object): def __init__(self): self.started = False self.string = "" def go(self,prompt="Write a long word to get it's length",ask="INPUT WORD &gt;"): print(prompt) self.string = raw_input(ask) self.started = True return self def __len__(self): return len(self.string) print len(StringGetter().go())
&gt; There are newer languages than python 3 if that is your criteria. newer and as good ?
Note that the python2 symlink was only added in 2.7.3, so if you support older version of Python you cannot rely on it.
You should almost always use `/usr/bin/env python2`, and never a hardcoded path.
&gt; /usr/bin/env That looks like a hardcoded path to me. (source: Python programmer, using it on both Haiku and Windows) Edit: not that I mind being downvoted, but that IS a hardcoded path to "env". I did undertood /u/gsnedders was referring to a hardcoded path to Python. I was just pointing out that "/usr/bin/env" is not something you can rely for truly multiplatform python scripts. Whatever :-)
I didn't really get in to Python until a couple years ago when the general consensus seemed to be that 2.7 was the "safe" version to use until 3 gained more traction. How is support for 3 nowadays?
What are you trying to do with argparse?
Well, then you're fucked. Unless you seriously plan to write code that runs on both 2 and 3, you'll need to create a different distribution just for the Mac (or at least put in instructions to modify the shebang).
env is on /usr/bin/env both on Linux and Mac OS X.
What is the advantage of the print statement besides looking ugly when you want to print to stderr?
How do you print to stderr? I use: sys.stderr.write('asdf') I rarely print to stderr, but I don't really understand your question...
This response is more than I deserve, thank you very much for your help. However, if you're willing to give me one more moment I've encountered a problem since I don't understand python very well. The only question I have stems from my lack of understanding of how to execute "functions." From my understanding of the formula (Though the tests I just did may have proved this wrong), you are supposed to get different outcomes for "averageFireball" when you change the "crit" and "hit" values within the functions under it. For example, when you make crit = 38 and hit = 0, the end result should be 1207.481235 When you make crit = 30 and hit = 8, the outcome should be 1248.850396. When I evaluate "averageFireball" it goes by the default 1069.28571428571. In order to get varied outcomes, which defined command (such as "total" or "sum" or "averageCastResult") should I execute? Thank you again for your help so far.
Thanks Massimo. I will work through these. 
As someone who writes a whole lot of tiny scripts and uses the print as the main debug tool, I'm definitely not moving to Python 3 anytime soon...
I'm a server admin, working with Debian stable python 2.7 is the default package. Also have projects with more than 4 years in Django, and is not easy to modify them for use with python 3. http://packages.debian.org/en/wheezy/python
let me guess... you're an Arch Linux user.
*Edit: I misread "advantage" as "disadvantage", and my comment should be read that way* You cannot redefine it if you want to do something else instead. In Python 3, you *could* do print = myLoggingFunction 
Where's the joke about the GIL? 
Nope, Arch is too much of a PITA for me.
Awesome bot :O. 
Arch made the change to python 3 a while ago IIRC.
Your list comprehension example is faulty: 1. Your output doesn't match the function's output, because you're using append() instead of extend(). 2. It would have been much simpler to write: return [x * x for x in items] Also: - Why are you putting a space between a function name and its colon? - Why are you calling gen.next() instead of next(gen)? - Your examples seem to suffer from a serious lack of PEP8. 
I'll start with a bit of terminology. In Python, the term "execute" the function can mean two things. It usually means that the function was evaluated for the first time. That is, the Python run-time executes the code that "def"ines a new function, named "averageCastResult." I think you're using the less common meaning, which is to execute the function using specific parameters. Most people use the term "call" for this, as in "call the function averageCastResult." The details of how to define a function and then call it are covered in any number of Python tutorials. For example, http://docs.python.org/2/tutorial/ and more specifically http://docs.python.org/2/tutorial/controlflow.html#defining-functions . There are also sites like http://www.learnpython.org/ , and likely videos as well. To get you started though, add the following to what I sent before: print averageCastResult(30, 8, 10000) This will print a number like 1248 or 1249, which is the integer approximation to 1248.850396. The actual number is based on random numbers, so will vary a bit. I thought the original code returned integers, so I explicitly did that in my translation. Here's the version with floats: import random spellPower = 569 fireball_min = 596 fireball_max = 761 fireballCastTime = 3.0 averageFireball = ( ((fireball_min + fireball_max)/2.0 + spellPower) * fireballCastTime / 3.5) def castResult(crit, hit): "Compute the result of a fireball cast with the given crit and hit chance" actualCrit = crit / 100. actualHit = 84 + hit hitRoll = random.randint(1, 100) if hitRoll &lt;= actualHit: return averageFireball + actualCrit*averageFireball*0.9 else: return 0.0 def averageCastResult(crit, hit, iterations): "Compute the average result of a fireball cast with the given crit and hit, \ after casting the specified number of times" total = sum(castResult(crit, hit) for i in xrange(iterations)) return total / iterations print averageCastResult(30, 8, 10000) If you run this, it prints values like, 1250.57562214, 1250.032425, and 1247.45223857 . 
get something like $ command subcommand --global-param=?? --cmd-specific-param= The catch is subcommands would be discovered via setutools entry points. I think I got it working to my satisfaction for the moment, but it feels like a bit more boiler plate than what I come to expect from python. This is just my initial reaction. I'm sure as I play with it more I'll come to understand it and feel differently about it. 
Let's see... * No moderately-to-extremely interesting string manipulation, because `unicode`. In particular, no string literals except with the `b"..."` syntax which forces everything to be 8-bit and terrible. * Iterating over dictionaries is fucked (`items` vs `iteritems`). * Iterating over ranges of numbers is fucked (`range` vs `xrange`). Nope, I definitely do *not* want to write in the above language. (Yes, you can use `from __future__ import`... statements to fix some of these, but sufficiently old versions of Python may fail to support that as well).
2to3 can handle those
also `open`. you have to do `from io import open` at the top to unify behavior in this respect.
Clojure and Rust. The first is about as old as Python 3 and the second is only a few years old. Netflix already uses Clojure code in production, and Rust hasn't even hit 1.0 yet but it's very promising. Rust's being developed by Mozilla. They're both VERY different to Python though, Clojure is a functional LISP-dialect that runs on the JVM and Rust is suppose to be a modern highly-concurrent systems-level language.
also virtualenvs.
and the py.exe launcher on windows can parse that shebang line and does the right thing.
[looks pretty good](http://twistedmatrix.com/trac/wiki/Plan/Python3). only 5 missing things left!
Thank you for having so much patience with me. This formula will help many people. I hope that I can become less dependent in the future, I just wish I could return the favor. 
especially this great paragraph: &gt; The biggest problem in practice is actually a semantic one: Python 3 doesn't let you play fast and loose with text encodings the way Python 2 does. This is both its greatest benefit over Python 2, but also the greatest barrier to porting: you have to *fix* your Unicode handling issues to get a port to work correctly (whereas in 2.x, a lot of that code silently produced incorrect data with non-ASCII inputs, giving the impression of working, especially in environments where non-ASCII data is uncommon). this is true. in python 2 i used to monkey until the UnicodeErrors went away, in python 3, i‚Äôve yet to see one of those. python 3 code (that doesn‚Äôt use python 3-exclusive modules) is ported to python 2 *fast*. i think python 3.4‚Äôs tulip (async IO) will become its ‚Äúkiller app‚Äù.
And the source: https://github.com/python-imaging/Pillow/blob/master/Scripts/viewer.py
&gt; No moderately-to-extremely interesting string manipulation, because unicode. Heaven forbid your python 2 code actually has to deal with unicode correctly now, rather than just looks-like-correctly because I don't have any foreign language in my database yet. &gt; but sufficiently old versions of Python may fail to support that as well). That's *directly* why I only mentioned the versions of python that I did. Python 2.5 is over 7 years old by now, and has been EOL for ages, its pretty much a security vulnerability if you're still using it. `from __future__` and the six library will help you with practically all of that.
Learning clojure helped me to appreciate `itertools`. 
fan boy..
I've done that several times. It's very useful. By the way he was asking what the advantage of the print *statement* was over the print function. (And the answer is "You save one character")
Support is pretty good: https://python3wos.appspot.com/ Adoption among developers still isn't as high as 2.7. I'm still using 2.7 due to a few packages that haven't made the switch (OpenCV, Enthought traits, etc).
Sure. As you get more comfortable with python you'll realize these solutions are all just at your finger tips. There isn't anything special (usually) about what you are trying to do and someone has probably made at least a rough project that does what you want. As you need, you really can fix a few lines of code or add functionality to existing code. You'll get the hang of it. Good luck!
Really? I'd have thought you'd want to use `io`. I've never even heard of `codecs`... isn't it the module responsible for managing Unicode encodings?
The current struggle is figuring out how to install libraries... 
well you sure schooled me
They've been using this image for a long time now. [Here's another article from a few months ago using the same image](http://www.theverge.com/2013/9/4/4694638/nsa-review-panel-reportedly-meeting-with-privacy-groups-tech-companies).
python.org just needs to remove all the 2.7 downloads and documentation, and give a good guide on how to move off recalcitrant modules like Twisted to frameworks that are actually supported in Python from this decade. There's been more than enough time given to folks to get their act together, anyone who hasn't done it by now is either neglecting the software (its not really supported, so needs to die off like all unsupported software) or the design and/or implementation is so poor, its simply taking 5 years to fix inherent flaws in the current version (like shoddy Unicode handling - playing "fast and loose" as Nick Coghlan put it) - in which case you're probably better off using something not as nasty. 
Just wondering: what was the reason you chose to build on top of `readline` versus using [`cmd`](http://docs.python.org/2/library/cmd.html), or some similar existing library?
If you're talking deadlinks within your own website, Google does this for you. Sign up for webmaster tools and you'll be notified whenever it finds them. 
my thoughts exactly
I haven't used python3 or perl6 in any production app. But I can at least run python3. 
really people? downvoting someone expressing something real? oh wait this is reddit, plz carry on with the group think. 
What's a good alternative to Twisted that runs on Python 3?
This looks awesome, but it's a shame there are so many projects covering this problem! What makes this project special? I'd love to keep the reference around in case I ever needed it.
did you actually write the article ?
No installation required. Copy and paste that folder into your working directory and you're good. Unless there is complied c code involved, "installation" is really just moving the scripts to a common directory and adding that to your python path. But your current working directory is always in the path. 
[Go](http://golang.org/) has been adopted mainly by ex-Python programmers. But "new" really is a completely meaningless attribute for a programming language. Haskell is over 20 years old, and hailed by many as an extremely modern, advanced language, for example, and Clojure, which [borscht mentioned](http://www.reddit.com/r/Python/comments/1s31ah/python_300_was_released_5_years_ago/cdtq7tf), is a Lisp dialect. Lisp is as old as computer science.
AutoHotKey (or AutoIt?). It's not a beautiful language, but for this space it's basically the only feasible tool.
He wasn't really rude imho, he made a good point and OP responded well, I see no problems! 
Very cool! Thanks for sharing Massimo! Go DePaul! :)
Depends what you're using it for in particular, that thing is massive.
Everything takes twice as long as planned.
I used Python, pywin32 and AutoIt's COM API. Wrapping the AutoIt calls in python functions resulted in fairly decent looking code. This stackoverflow article may point you in the right direction: http://stackoverflow.com/questions/8844279/getting-python-and-autoit-to-work-together-using-win32com-whats-up-with-those
don't you also need a newline, which print adds?
This is one of the worst ideas I have ever heard.
Exactly. I'll move when I can do some real concurrency without firing up a whole second/third/90th python instance, or using ugly hacks. This is the killer feature for me, and till then 2.7 makes me very happy. Ideally I'd like some sexy built in openCL magic. 
))))))
You are right, I didn't consider derived work. Thanks, I think I can add a less restrictive license, I'll update asap.
I just tried it and it worked perfectly fine with Python 3.3. I installed from PyPI with pip as it's a pure Python module. 
Well that's cool. I wonder what the deal is with the MSI then. There's a point where it searches the registry for python installations, and it only ever finds python 2 installs for me. I figured it just didn't support python 3.
yeah, sorry. `io.open` it is
If he was an Arch user he would have started with "As an Arch user". It's astonishing but this has a 95% success rating at stopping them.
Scientific programming is also stuck on python 2. Mind you the way van Rossum seems to try and kill all functional parts of the language every release I'm not sure if this is a good or bad thing.
I thought NumPy and SciPy are already on Python 3. But yeah, I agree that Guido van Rossum is a bonehead when it comes to functional programming.
They are, but sagemath isn't and most of what I use is symbolic. 
Breaking backwards compatibility: not even once
Since the beginning of Python 3, I've always read people saying I should switch to python 3, but nobody explained me **why** I should switch (beside the handling of unicode). I really think that breaking the compatibility without solving much of the things that people were complaining about (the concurrency, the speed) was not the best idea.
I think that has more to do with limitations of the MSI installer format than the actual code. As far as I know, binary installers need to be built separately for each Python version (cf [Christoph Gohlke's site](http://www.lfd.uci.edu/~gohlke/pythonlibs/)) so whoever is publishing that installer should be urged to offer that.
We still have some systems that are on Python 2.4 (SL5), though we will retire them soon(ish) and then we'll be at 2.6.x for the next 3-4 years in SL6. So yeah, Python3 is far away for us :)
And yet most of the modules we use in class are only Python 2 compatible, that's a little depressing. Now I feel motivated to update modules to Python 3.
Unicode literals in Python 2? Now that's just confusing. Check out python-modernize, it upgrades your Python 2 code into Python 2 code.
&gt; In particular, no string literals except with the b"..." syntax Why do you say this? Wouldn't it make much more sense to only use string literals with the u'' syntax, and actually support unicode? Indeed, using the b'' syntax would pretty much break lots of stuff because a python3 bytestring behaves very differently from a python2 str. &gt;Iterating over dictionaries is fucked (items vs iteritems). Iterating over keys hasn't changed, and in general the difference in items vs iteritems isn't going to matter unless you've huge dictionaries. The same for range - standard practice is to use range() most of the time in python2 *anyway* (or better, replace with enumerate) unless you're dealing with large number ranges but don't need a real list - which is uncommon: iterating over them is the prime use case for this. &gt;but sufficiently old versions of Python may fail to support that as well He did say just 2.6/2.7. Supporting older is probably impractical, since the more recent versions have added stuff to make things more in line with python3. 
What I immediately liked is the straightforward configuration. I find this is a pain with Grunt for example.
Very nice setup. Going to start using some of those myself now. It is always nice to see what other people are using especially when they are using things you haven't heard of / used before. TBH I prefer to use Samba and edit things using my Windows desktop and notepad++. But something I have been meaning to try is using Pycharm 3 on Linux.
While we use 2.7.4 in our school... :/
It upgrades your Python 2 code into Python 2 code that is more likely to work in Python 3 by using the `six` library.
I see. That makes significantly more sense.
Doesn't `print` flush? Edit: it does not do `sys.stdout.flush` ‚Ä¶ seeAlso `python -u` / `PYTHONUNBUFFERED` (http://stackoverflow.com/questions/230751/how-to-flush-output-of-python-print/230780#230780)
http://www.structlog.org/en/latest/ is pretty cool.
Yup, liking URLObject a lot.
You've clearly not heard very many ideas then. 
Yeah, libraries are only a fraction of the problem. Eventually enough libraries will have moved, but that still will leave a daunting task for those with significant application codebases written in Python 2. Especially since application codebases tend to have worse test coverage compared to libraries. You need a reason to justify the economics of porting application code to Python 3, compared to maintaining it in Python 2 forever. 
I don't see any ridicule at all, actually, just a small number of downvotes (presumably from the 9 fanbois on the #twisted irc channel or whatever...) by people who don't comprehend simple concepts like reddiquette, let alone more complex ones like a software development lifecycle. If getting rid of unwanted, deprecated cruft is such a ridiculously bad idea, you probably need to star in the next episode of Hoarders. It's easy to make statements like the above, what's more difficult is backing them up with any substantial evidence. How many serious people run Linux 1 on their servers today? None, because they're running 2 or 3. Same with Python. A new major version came around 5 years ago. Just like Linux has not shuffled off this mortal coil, run down the curtain and joined the choir invisible because Linus dared to release a new major version, neither has nor will Python. Any statement to the contrary is quite absurd. 
Is there any doubt ? :/
Consider what you're stating - that a majority of Python developers are seriously contemplating abandoning all the work they put into Python 3 over the course of what... 7.5 years (PEP3000) to roll back to Python 2 forever because... you though it. Riiiiiight. 
Consider what *you're* stating. In any case we're only about halfway through the time the process was expected to take when python 3 was started (10 years).
I'm not sure how long you can use it for free but I've found that [Automa](http://www.getautoma.com/download) is excellent for Windows automation.
That's because its tied to RHEL, so it doesn't count (its like picking on the kids who ride the special bus). I doubt it would make Maya 2014, but for subsequent releases third parties like Autodesk now (since Sep 2013) have the option of RHSCL on their legacy platform which would give their product current developer tools not tied to the usual "things grandpa ran" problem with previous RHEL releases (its currently got both Python 2.7 and 3.3). So things are looking up in your niche world! Edit: Maya 2014 was released in September 2013 and contains Python 2.7.3.
I know that Pyramid has Kotti, but I've never used it. http://kotti.pylonsproject.org/
&gt; But I can at least understand python3.
Well someone wished for living in interesting times, and [PEP3156](http://www.python.org/dev/peps/pep-3156/) changes the game. asyncoro has been around for a while, there's also pulsar which is tracking PEP 3156 as well now; there's no possible way to answer "good" though because what's good for me isn't necessarily good for... anyone else. 
you're never likely to see (((( although you will see many closing brackets together. Fortunately, it's no problem since any decent editor highlights bracket partnership.
I doubt many Python developers are happy about the stagnation and all the hacks in existing code that have resulted from trying to support both versions. I doubt many think the confusion that new users experience when wanting to know which version to use has no clear answer (for the past 5 years). I doubt many are happy with the fact that most Python 3 code is automatically generated by 2to3 which makes trivial source code transformations which the compiler could have practically handled like so: try: code = compile(txt) except SyntaxError: code = compile(run2to3(txt)) I doubt many are happy that vast amounts of code and projects were put into a state of obsolescence for no other reason than to make a few minor improvements (most of which are trivial syntax changes).
I guess there are quite a few frameworks already. Most of them seem to require people to write a fair amount of code in order to get a simple site up and running. My intention is to build a higher level CMS that can be used with very little knowledge of Python. If people want to do some coding, a Python API is available, but it's not compulsory to use it. I also want it to be quite self contained, so that people don't have to learn how to use a bunch of different packages.
We all struggle when we start. As you improve, help others who need it.
They are, but it's hard enough as it is to get scientists to adopt something new. I wouldn't expect anyone in the scientific community transitioning to Python 3 for years to come still.
Quokka CMS - Flask + Mongo www.quokkaproject.org 
Have a look at [Sikuli](http://www.sikuli.org/). It's basically python programming with screenshots; so you call e.g. a function like `click(**)` where `**` is not text, but an image of the element you want to click (image as in *yes, really an image*).
None of whom have a Sun box, since they forgot to include SILO on the install ISO so you cannot boot the system after spending 23 hours compiling it all. 
That's interesting, I hadn't seen that. Seems quite nice.
Welcome to the real world. Where deadlines are met and products have to ship. Does it work 90% of the time? Yes? Ship it.
In web2py, if you clone the scaffolding application and, in controllers/default.py, edit the index function as follows: def index(): return auth.wiki(manage_permissions=True) You get a minimalist CMS. Every user can create wiki pages, give permissions to them (groups that can read/edit), attach media files (which inherit page permissions), and embed custom controls via Ajax. It works differently from what you may be used to, but it is customizable. 
Same here. Actually developing right now in squeeze and running into no issues whatsoever.
Yes, it certainly is! We're using it at AppNexus for a project I'm on involving a legacy database.
About the same as 2.7 or about the same as it was a few years ago?
Same as a few years ago. 
Sikuli is awesome for this. Python for easy and simple tasks (or even more complex ones) and it has an Java API if you want to incorporate it to a bigger program. Sikuli also work with texts (with decent precision).
Aww :(
&gt; shift print trickery uuh, that‚Äôs just special syntax mirroring `echo nextline &gt;&gt;somefile.txt` in the shell, no shift operator.
Nice, I am making a little demo of it on my workplace tomorrow.
(s)he‚Äôs downvoted for the false claim that the scientific stack isn‚Äôt ported [here](http://www.reddit.com/r/Python/comments/1s31ah/python_300_was_released_5_years_ago/cdtemml).
most even? which might that be? i can only name twisted and pypy from the top of my head.
Wow, conratulations. It seems a lot of work is in this package. I will try it !
I did it. I use matplotlib, pyQt, numpy-scipy, several scikits, ipython, pandas,... I would said that scientist are the fastest adopting something new. At least in the more competitive and dynamic areas. Otherwise you are dead. 
What install ISO? I bootstrapped my last install from a Debian netboot.
Well, thanks for your honesty. That's the first time anyone's said that to me. I'd be interested to see if other people agree/disagree...I guess it's a subjective thing. 
Is there any Muslim in Pakistan ?
&gt;Maya 2014 was released in September 2013 and contains Python 2.7.3. Oh yeah, I forgot. I would enjoy some of the additional `unittest` assertions, though I've made do pretty well with the handful back in 2.6.5. We're still on 2012. I do feel like I need to update my knowledge to 3.x, but I find it a little confusing that on one hand it seems to just be some semantics changes (e.g. `print()`), and some reversals (`xrange`-&gt;`range`, unicode), yet it's taking years for packages to make the switch, which makes it seem that it's actually a lot more involved than some basic, non-destructive things like that. Is it a massive rewrite?
This means very little. It would be a better exercise to analyze what cyclomatic complexity really means in practice. A software that does more thing should have higher cyclomatic complexity; but that doesn't mean it's bad. But, if you look at higher complexity and conclude that it's "excessive", then you are abusing this notion of complexity. If you have the same team, building two versions of the exact system, with exact goals, and one version has higher cyclomatic complexity than the other, then you can relatively safely conclude that the one with higher complexity has unnecessary/excessive logic in it. Using cyclomatic complexity to compare 2 different systems (which might try to achieve the same tasks) means very little. The one with higher complexity might be worse (because it has unnecessary logic) or it might be better if the logic contributes to the quality of the software.
so you know for a fact that their libs that they wrote over possibly decades have been ported to python3? way to play the politically correct gender angle, still a -1 for you. 
I agree. I've misread the question as "what's the *dis*advantage ... Besides looking ugly" (Btw: you save tw characters ;)
Indeed... =) Thank you, feedback highly welcome!
no, i said it‚Äôs *special* syntax. as in ‚Äúpart of the print statement‚Äù. the `&gt;&gt;` you see is completely unrelated to the shift operator elsewhere in python.
sorry, but i don‚Äôt even know that one :/
It was an exaggeration. Support has improved. That being said, most of the above referenced code is still written in Python 2 that is either 2to3'd or uses a compatible subset of the two versions. 
It's a simple module for drawing stuff on the screen. Basically lets you make a window and draw objects on it (balls, boxes, cylinders, that kind of thing).
aah, ok. interesting. [here‚Äôs the bug](https://github.com/vpython/visual/issues/6), maybe you can do something about it.
Nice, I'll take a look. Thanks for the help.
[Autohotkey](http://www.autohotkey.com/) is brilliant at this kind of task, especially since it's been around for so long that the forum is full of recipes for specific apps. 
Perhaps I spoke too generally. From my experience (background in experimental physics), a lot of people are more concerned with getting things done quickly. If their old code for analyzing data works, why rewrite it to be with a fancier, new programming language? All that does is force you to spend your time on that instead of taking data or upgrading your experiment. Keep in mind that a lot of stuff in Numpy/Scipy still relies on FORTRAN code written decades ago! If it works, it works. Anyway, what I meant to say is that for many scientists, especially those whose programming tasks are relatively simple, using the latest and greatest is not usually on the top of their priority list. For that reason, many will continue to use what they know and what works until they have a compelling enough reason to change. A great example is Python itself. Until recently, almost everything in my field was other done with LabView (mostly for experimental control and automation) or Matlab (for running experiments and analyzing results), along with a smattering of a few other things here and there. But in the last several years, Python libraries useful to scientists have matured to the point where those who were reluctant before to invest the time in a new language found that there were a lot of advantages. I don't really see quite the same thing in the transition from Python 2 to Python 3.
[whoooosh](http://pastortimfowler.files.wordpress.com/2011/03/dont-get-it.jpg)
IMO, not confusing at all... In all of my code I use unicode by default, and bytes() whenever I need to make sure input is ASCII (for example when using dnspython)
Eh, I figure the site is proof of concept of your project, I wouldn't sweat it. As long as its easy to drop in some 3rd party CSS, you're good to go.
But it's also much easier for many scientific programmers to migrate. In my experience they rarely deal with unicode issues or any of the other backwards-incompatible things. Most of the scipy stack is ported now and 2to3 handles their code very well. Honestly, for a lot of scientific programming the only changes you have to make are fixing all the print functions.
Okay, this is a real question and hopefully won't attract the wild Reddit Flame Moths: is anyone using plone/zope anymore for anything but larger legacy stuff? I used to develop in plone/zope but have been away from that end of the community for a while. I just know I never see anyone talking about it these days and I no longer work in it for various reasons.
Well, you could do print"blah" you could also do print"print""""print""""""print""" I think I won't miss that functionality, however ;)
As far as I can tell it's basically a matter of how much effort you're willing to put into memorizing commands and shortcuts. I'm really lazy so I just use pycharm.
You clearly don't know what the fuck you're talking about. &gt; 99% of the world it's not worth the extra effort The effort is the initial learning curve to set it up. If I give someone (and I've done it) an already installed archlinux all they need to do is update regularly (but not before serious work, just in case - which also goes for windows or any linux distro) and, be moderately aware of the news in case something really big is up (which is extremely unusual). I never recommended arch for 99 % of the world. But it's not that hard to setup or maintain and you certainly don't waste work time maintaining it (that was your initial idiotic fallacy). The first times you set it up, it's certainly daunting (unless you feel comfortable using the command line) &gt; trying to prove how 7331 your linux skills are. Yep, you're a moron. I have very mild linux skills and have nothing to prove. Archlinux is just absolutely handy, light (depending on what you do) and customizable. It's rolling release, bleeding edge, has an awesome package manager that takes care of everything, a great community, etc. &gt; but hey, i was cool once and could compile X, and Firefox etc... but the time spent doing so was better spent on other things. There's no "time spent" because it's just sudo pacman -S firefox and that's that. When you update with something like: sudo pacman -Syu it will be upgraded. It's similar to apt-get install and apt-get update / upgrade in debian based systems (yes, I'm an Ubuntu user as well and know the pros/cons of each distro). So, you're not disagreeing. You're not right. You're just spouting ignorant crap without knowledge for whatever reason (You probably heard some criticisms about gentoo and applied them to archlinux). 
I don't hear about zope as often as I used to.
I second this, this is definitely the best way I've used, much better than sikuli.
Oh, so now you're "just trolling", right? &gt;_&gt; Nice cop out. 
I also recommend line-height:1.4em; on .main. The sidebar looks cluttered when all &lt;li&gt; has separate background color. Go easy on border-radius. Keep youre eyes open when surfing and "steal" a sites color scheme when you like it and see what happens.
I'm not lazy and I use Pycharm too. I can't productively do proper TDD without refactoring and renaming tools. 
&gt; Wouldn't it make much more sense to only use string literals with the u'' syntax, and actually support unicode? ~~The u"" syntax is illegal in Python 3, since you're supposed to just use bare quotes.~~ Actually, it works. [This document](http://docs.python.org/3.3/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit) lied to me. &gt; Indeed, using the b'' syntax would pretty much break lots of stuff because a python3 bytestring behaves very differently from a python2 str. Really? Care to specify?
it wasn't obvious before? 
vim includes "Refactoring" and "renaming" support, it's just built into the editor itself and doesn't have a name. I guarantee I can rename a variable faster in vim than anyone can in an IDE. Note, I do use gVim, the GUI version of vim, but the functionality is identical. The fundamental issue with editors like Sublime is that text editing is limited to a character keys, a few keyboard combinations, and the mouse. In vim I can do almost any kind of editing without lifting my fingers from the keyboard or hitting 4+ keys at once. It does take a while (I've been using vim over a decade), but once you get to a certain point, not having those keybindings would *seriously* hamper your editing speed. If you've ever seen someone *really* good at using vim (or emacs) editing code, and you can't even keep up with what they're doing, you know what I mean.
VIM is a TUI (Text User Interface), making it kinda like the old edit.exe we had on DOS. However, Vim's strength is actually that it's a Modal editor. It's normally run in the Command mode, where each key on the keyboard is a command. Most of the commands logically follow what you'll be doing, so __c__hange, __p__aste, __i__nsert. Also, each command can be prefixed, so if you need to move three words ahead, it's __3w__ords or __3e__nds. The mode where you type like normal is the insert or replace modes. The phrase "text surgery" is frequently used to refer to what Vim users are doing. Once you get the muscle memory for it, and learn to speak vim, then everything you do starts getting really fast.
I'm trippin ballz here wut da green bar for
An orangered... who could it be?
What?! How hideous! I didn't know the whitespace wasn't required. (On second thought, I guess it makes sense that it's allowed since it isn't ambiguous in this particular case.)
&gt;This document lied to me. It's probably just out of date - I think the original release of python 3 didn't allow this, but it was added in in one of the point releases. &gt;Really? Care to specify? Well, for a start: # Python2 Python 3 &gt;&gt;&gt; print(b'hello') &gt;&gt;&gt; print(b'hello') hello b'hello' &gt;&gt;&gt; b'hello'[0] &gt;&gt;&gt; b'hello'[0] 'h' 104 Bytes in python3 is basically designed around being treated as raw binary data, rather than conceptually being a string, as the python2 `str` object is. Eg. it no longer has an encode method, just decode (while strings are the opposite - python2 they had both), and is missing a few string methods like format.
As I said again. It's a cop out. If I made and persisted with a series of inaccurate (albeit popular in certain circles) statements attacking python/emacs or whatever tool you use frequently and after a back and forth I just went: lolz, jk. I'd still be acting like a jerk. Whether I thought myself funny or not. 
Right, and that's kind of my point. If it takes *any* effort at all, and it doesn't clearly lead to enhanced productivity, then most people who do the kind of scientific programming I'm talking about aren't going to bother so long as Python 2 continues to be maintained.
Thanks Massimo.
I have used music21 a little and it was fine http://web.mit.edu/music21/ Not 100% sure if you can place an event in terms of milliseconds with this library though, but you should give it a look.
Plone is alive and kicking, just launched the main Brazilian government site in Plone: http://www.brasil.gov.br
Does not cover decorators with arguments, aka function returning a decorator. 
attacking is a strong word though. and honestly i wouldn't give a fuck if you were "attacking" my favorite tools. nor do I give a fuck that a redditor is accusing me of being a jerk or claiming that i'm copping out. nobody cares that you have infinite amounts of time to read the endless reams of docs on how to setup your favorite linux distro manually except for maybe 10 other people. So, just accept it and finish up that system config and then go do something amazing with it like write another great cat pic internet scraping app. Then I'll "attack" that too. :)
How do you rename a "public" function/method? I've seen a couple of approaches, but don't have one that really clicks for me.
Im loving PyCharm right now. They have a free version now. Its really fantastic. 
Thing is, actually writing code is a pretty small portion of my day. I spend most of my time reading code, logs, and docs.
So you censored the first fuck but not the second?
you asked ‚Äúdownvoting someone expressing something real?‚Äù i answered ‚Äúbut in [this comment](http://www.reddit.com/r/Python/comments/1s31ah/python_300_was_released_5_years_ago/cdtemml), (s)he said the modules (s)he means are numpy and so on, all of which are ported. that‚Äôs why people downvoted.‚Äù everything clear now?
ummm the getting started guide is the start, then it's setting up your preffered desktop environment, graphics card(oh you have nvidia on your laptop prepare for pain start with the bios), sound(you want alsa? pulse?) etc... and that is the time sink I'm talking about. I'm not saying that's bad exactly as you now know, I am comfy maintaining a constantly tweaked emacs config etc.. the LIE as I see it is arch users jumping in and claiming that it's easy as in ubuntu easy. it is not. it's better than slackware IMO, and better than gentoo in terms of ease, but it's not easy. And I reckon that the only reason someone talking shit about arch hurts your feelings is because you have to step back and acknowledge you wasted a weekend for little upside. 
I amazed at attitudes of Python Redditors too, Guess they never worked in large projects that span more than 2 years. (When our project started , it was python 2.5)
Clearly not all , web2py is main component for our UI. I admit i haven''t update scientific stack for long as especially we have modified scikit-learn and they didn't accept that patch , we do not have time to patch every subsequent version either, so it was left at 0.12. There are still many of our own code needed to port to python3 , that can be managed in 2 weeks to a month , but many , un-maintained small libs we use , we won't see them ported anytime soon. Some examples are PIL , OleFileIO_PL,Sphinxsearch driever , and Gevent. Still alot more.. flying-sheep : "all of which are ported" &gt;&gt; Are you sure about that? Please lookup web2py.
all that you listed in that post except web2py. and PIL is ported as Pillow (PIL is dead) why so aggressive? i didn‚Äôt even attack you! i did nothing more than explaining why people downvoted you.
I'm not sure that it's as clear-cut as you think though. I could easily make the counterargument that (in my experience) people that do scientific computing, especially in Python, like to be on the cutting edge of their tools and would be interested in any advancements if it didn't take much effort. I mean, the people who are using Python for scientific stuff are a fairly self-selected group and often enjoy programming and python instead of just viewing them as just tools, otherwise they would probably be using MATLAB or maybe R.
https://wiki.archlinux.org/index.php/Installation_Guide That one. It's short and sweet and expands to meet the user's needs. Of course, if you're a beginner, you have the more detailed and hand held version that covers everything in detail so that you don't screw up and provides links for anything you might be interested in: https://wiki.archlinux.org/index.php/Beginners%27_Guide &gt; the LIE as I see it is arch users jumping in and claiming that it's easy as in ubuntu easy That WOULD be a lie since you HAVE to set things up but you can meet that lie when it actually happens. Not have that moronic knee jerk reaction at the sole mention of arch having a feature. This all started when one guy named what Ubuntu had done and another guy named what arch had done. You didn't attack the ubuntu user for namedropping ubuntu so why the fuck did the arch user get flak. &gt; but it's not easy. Oh, but, except the initial setup... It is. Even further, for someone who likes customization it might be even easier than Debian based systems where you can tweak packages as easily. If you use default everything then surely, it's not. Since it barely has defaults. &gt; And I reckon that the only reason someone talking shit about arch hurts your feelings Stop being a prick. It doesn't hurt my feelings. I just call shit when I see it. The same will happen when someone takes a piss at python/c++/java emacs/vim firefox/chrome whatever simply for the sake of it and showing a clear lack of understanding. You're like a windows user using the words free-tard and neckbeard. *you can't afford stuff, loser*, *who has time* and shit like that. &gt; is because you have to step back and acknowledge you wasted a weekend for little upside. everything you learn has a cost. Be it linux, archlinux, ubuntu, vim or whatever. You might think that the cost is not worth the upside but, asserting that it's not worth it for others is being purposely ignorant for no purpose. Considering my usage of archlinux and the ease of use to change the system to fit my needs (despite an extensive knowledge of linux) I'd say it's very well worth it in my case (try switing DE's and removing them and dealing with dependency hell in ubuntu). Its current popularity would suggest that many others feel the same. What you need to understand is that even though it might not work for you it HAS worked for others. It has worked fantastically (hence, why you might see some over-hype). You don't need to make up reasons like time wasting or unpopularity to feel better about not using it. Specially since you're not curing cancer right now nor even programming that cat app you mentioned, you're answering one guy on reddit.
I don't think you really need to switch. I can't think of a killer feature in Python 3 that would be an incentive. However, one day, you'll just be using Python 3 because the Python 2.x line will cease. And I really doubt you will have any big issue that day because as far as I can see, the whole ecosystem is moving to py3. Slower than some expected, but it's surely getting there.
Meh. I've used vim for a decade. I recently switched to PyCharm, then IntelliJ IDEA Ultimate. I am so much more productive now it's insane. Most of the people I've seen that use Vim think they're more productive because their hands fly rapidly over the keyboard like a tazmanian devil, hitting 10K WPM in a beautiful whirlwind of clacking without ever leaving the home row. I did this, I thought I was productive. Then I was working on a codebase of ~30K lines across a whole bunch of files. About 30 dependencies. I discovered that my actual productivity / keys clicked wasn't very high, and I was jumping around a hell of a lot more than I needed to. When I started using IntellJ, I had the same opinion - I could never be as productive as I was with Vim. But then I got used to it, and realized I could click a tenth of the keys and get the same amount done. Good auto complete (never got it to work in Vim), integrated testing (had it working in vim, never liked it much), class trees, and a whole slew of other tools just worked without requiring an investment of my time. Jamming hard on your keyboard is a young mans game.
Things usually work well in Simple applications. Real life ain't.
&gt; https://wiki.archlinux.org/index.php/Installation_Guide yep short and sweet. OH WAIT!!!! what's a boot loader https://wiki.archlinux.org/index.php/Installation_Guide#Install_and_configure_a_boot_loader choose one of 7ish as far as I can tell. https://wiki.archlinux.org/index.php/Boot_Loaders oh well I heard about grub... https://wiki.archlinux.org/index.php/GRUB man that's a lot of words. and everything was like that. it's docs all the way down. So it seems my friend that you are being dishonest about the short and sweet setup guide. I will say that it's pretty impressive that 10 people managed to write all those docs though. 
so you can test models and then you need a web browser to test everything else. test coverage for the win!!!!
Anything but "learning python the hard way", really. The official tutorial (http://docs.python.org/3/tutorial/) is totally fine, or maybe you want to try "a byte of python".
You'd be surprised how easy it starts to feel after the 1st decade.
must be extremely annoying when someone gets the courage to give a presentation like this and then share it on reddit only to have people bitch about the style. I don't think any of your points detracted from the message at all as far as I can tell. 
Is it just me or is the volume in the first video a bit too low? Anyway good work! Also sorry for hijacking, but is there any plan to add OrientDB support to the web2py DAL? 
I actually think that is a valid analogy. I don't drive often, therefore I drive an automatic even though a manual would give me better performance and control.
I know some basic vim commands, but I prefer to dedicate most of my brain space to stuff that feels more important. To each his own, though. I don't think there's a right or wrong answer to this.
Yes unit testing for models and functional testing for rest.
&gt;This module is like violence: if it doesn't work, you just need more of it.
brilliant. about to surround all my code with fuckit from now on.
Thank you. Until I found out about FuckIt.py I was having a highly suboptimal day. Now all is right in the world.
Just FYI, it cannot be a pure-Python package, because PyGTK relies on the Gtk library, which is written in C.
I always wondered why python can not try: some_code except Exception: # modify something here retry It will save tons of time. Edit: you need to patch something before retry.
Because that will almost never work. It's a very small class of errors where immediately trying again is actually going to work - if the server was down 2ms ago, it's still down.
sure it can do that: while True: try: some_code except: pass # maybe log the error or something? else: break but you probably don't want to do that. (maybe if it's a network error or something, but catch that specific error then)
Last week I wrote this code: def crawl_server(): try: return do_request() except Exception: time.sleep(5) return crawl_server() Not my proudest code, but it was a one-off script and I was hurrying to meet a deadline.
I would just like to draw attention to the beautiful [tests module](https://github.com/ajalt/fuckitpy/blob/master/tests.py).
For normal gevent usage there would effectively be only one true thread as well. So can't see much difference in that respect.
Can someone explain what's going on at line 112 of https://github.com/ajalt/fuckitpy/blob/master/fuckit.py ? It took me a second to figure out what bizarre operator &lt;- was (I thought it was some hideous compare_then_decrement operator that I had somehow missed over the years). (Then I just realized we were comparing to negative True.) There's a comment, namely source &lt;- True # Dereference assignment to fix truthiness , but I have no idea what it's supposed to mean. Is it really just a pointless (and nonsensical) comparison? Unless some wierd magic is going on, I don't see how the code could do anything. But if that's the case, why is it there? Hmm.... Thanks!
Since you're on Windows, you could check out [pyrobot](https://github.com/chriskiehl/pyrobot). It allows python to interact with the screen as well as mimic mouse and keyboard actions.
It basically boils down to explicit vs implicit. Gevent monkey-patches the standard library and with AsyncIO coroutines, tasks, and call-backs as well as the event loop is called explicitly.
"The test suite actually found a bug, holy shit" Perfect commit message. Immediately had to look at your tests "suite", and I was not disappointed! 
In other news, the JS module this is based on just might have the [best license agreement ever](https://github.com/mattdiamond/fuckitjs).
&gt; assert 'false' # Good thing this isn't PHP mwahahahahahahahahahahaha!
Fuck it! Yes! That's your answer. That's your answer for everything! Tattoo it on your forehead! 
Dude, I NEVER had to read that and I don't know that much about the inner workings of bootloaders. I just followed the step by step here: https://wiki.archlinux.org/index.php/Beginners%27_Guide#Install_and_configure_a_bootloader Of course, you ignored the frigging BEGINNERS guide I offered. &gt; I will say that it's pretty impressive that 10 people managed to write all those docs though. I know you think you're funny and half telling the truth and half trolling but ... sigh... You're sucking at both.
I've done this more times than I'm proud... Always the other guys crappy code that's the problem. Or the network. Yea. The network. 
-&gt; is a c operator, which is what the comment is referencing. Less than negative True just means less than -1. True and False are just special versions of 1 and 0, and can be treated as such in python (nice way of counting elements in a list that fulfill some condition is using `sum()` with a boolean generator expression, eg `sum(i &lt; 5 for i in lst)` is the number of elements in lst less than 5). 
I know all of that (even interpreting it as a C-related joke or something still doesn't make sense to me), but that still doesn't explain what the heck the code is doing. 
I like how the link for the code coverage badge goes to [here](https://coveralls.io/r/ajalt/fuckitpy?branch=master), which shows 72% code coverage for the 'fuckitpy' project, but the image is from the [coveralls-python](https://coveralls.io/repos/coagulant/coveralls-python/badge.png?branch=master) package's code coverage testing.
According to [this](http://php.net/manual/en/language.types.boolean.php), "false" is true but "0" is false in php.
Oh. It's not doing anything. Just a naked boolean. It looks like it's just there as a joke.
last function's comment is golden: &gt;Returning True prevents the error from propagating. Don't silence KeyboardInterrupt or SystemExit. We aren't monsters.
I consider myself a pretty good Python programmer, but this is a work of art.
That only raises an exception in python 3. As far as I can tell, the modules themselves are valid code. : )
[comtypes](https://pypi.python.org/pypi/comtypes) is lightweight COM automation, allows to define, call, and implement custom and dispatch-based COM interfaces in pure Python. Unfortunately, it does not work in python 3.3 and above.
Great thing about IntelliJ / JetBrains products...is the ability to drill down to methods, etc.. to find the original code. No more searching for anything.
&gt; assert 'P' != 'NP' # proof is left as an excercise for the reader lol
afaik, python3.2 support in pypy is *very* recent and is still in beta and it's already a version behind cpython... So it's coming but not quite there yet ;-) 
It gets worse. http://www.php.net/manual/en/types.comparisons.php
Python supports Haskell's binding. ^Trust ^^me ^^^I'm ^^^^an ^^^^^expert.
I don't see the analogy. Transition from Linux 2 to Linux 3 was smooth because most of your code just worked. Transition from python 2 to python3 would take a lot offort for any nontrivial code base... To make things worse: - python3 had major performance/quality issues until 3.2 I think (e.g. see http://programmers.stackexchange.com/questions/63859/why-do-people-hesitate-to-use-python-3) - not everyone thinks that some of major python3 features (e.g. unicode handling/print function) are an improvement... (yes it fixes some issues but it creates quite a few new ones) - until about python3.3 there was a non-trivial chance that python3 will turn out to be another perl6-like fiasco... - all of which means that many library projects were also taking wait-and-see position which further aggravated the situation.. Doing anything drastic (like removing 2.7 info from python.org) will upset everyone who sits on any kind of non-trivial codebase (meaning old python users) and would be very bad for python ecosystem.
I'm working on something called Agentum -- a toolkit for agent based modeling. Not quite a purpose-built library for population dynamics -- but you could build one on top of Agentum in 20 lines of code or so
This is fucking amazing.
E.g ?
It's taken years for *some* packages to make the switch, because their original code was wrong. The biggest issue is that, particularly for networking (or other i/o) libraries, authors got away with shoddy code that blindly assumed all data is 8-bit ASCII as Python 2 let bytes and str be used equivalently. When Python 3 changed the implicit string representation to Unicode, that assumption is no longer true, hence the library breaks. Especially in large codebases, this can require a massive rewrite particularly if their application was also designed wrong and shoehorning in encoding/decoding steps can slow the application to a crawl due to unnecessary calls. Correctly written applications that encoded and decoded data at the right places had no problems. Also, some packages had dependencies on shoddy libraries so while those packages were ready, their dependencies were not. There's also a bunch of minor stuff that may or may not affect porting efforts for your code, depending on what it is. http://python3porting.com/problems.html The porting effort depends entirely upon what your code is doing - if its not affected at all, there's no effort. There's a 2to3 tool included to get over the boring changes (like print statement to print() function) so almost no effort there either. Ideally 'print' is not really used (if you're after debug logs, use the logging module; if you're writing to a file, use its .write() method) With Maya, I'd watch out for the change to the division operator as I expect you're using that in calculations ( '//' is always floor division, but '/' can change meaning depending on the specific type of the dividend and divisor ). There's numerous good examples lying around of code that works with both Python 2 and 3, e.g. [bottle.py](http://bottlepy.org) and also helper packages like the [six](https://pypi.python.org/pypi/six) library for the impatient. 
I found a great library for python 3.x at http://www.pjb.com.au/midi/free/MIDI.py, but I still really appreciate the suggestion. Thanks!
For some I had to do some command prompt stuff, like: C:\Users\bilzzardfire&gt; python setup.py install in order for a certain package to work. But regardless, I found one that does everything I need at http://www.pjb.com.au/midi/free/MIDI.py. Thank you for all of your input!
The two most dangerous words in the English language.
Nobody makes books like that anymore. I wish they did. 
and for full credit, you could add some randomness to the sleep or do a geometric retry (like 5,10,30)
`with fuckit` is brilliant.
http://docs.python.org/2/
long-time vim user here, and I lol'd
I built http://scrape.ly, which is a url based API for web scraping. If you want some credits to test it out, message me. I also created a reddit to teach people and discuss how to use it at http://www.reddit.com/r/Scrapely/
What car I drive would 100% be affected by how often I drive. If I only drive 15 minutes per day, I'd rather have a cheap, easy to maintain car. If it occupies more like 4 hours per day, then I'd want something better.
Yeah, a difference of 4.999 seconds.
&gt; Of course, you ignored the frigging BEGINNERS guide I offered. like thats any better?? Are you fucking serious? we have 2 potential branches(2 places to fuck up) right away bios motherboards or uefi motherboards whatever those are that's just the start for bios you can choose(fuck up) with syslinux or grub or for uefi gummiboot or grub but configured differently Yep totally easy for world population - the 10 people that use Arch. quit lying asshat.
Well its great, definitely would make a article in that, testing regex, mocking views, form validation. Thanks for pointing out this.
I recently gave up on PHP as well. I'm even thinking about giving up on Python as well.
You'd probably want something like a condition system for that. You know, like LISP has had for many years... ^ducks
Turn your Python into PHP with FuckIt! Now, you can be a bad programmer and LIVE HAPPILY!
wat
This comment cracked me up.
I find demonstrations of these things in simple applications worthless as indicator how they'd work in a real world implementation.
This is so over the top to be useless. Yes, virtualenv helps with isolation, but it's not perfect. There's a leaky abstraction in python package management with development libraries and other dependencies. It's not an *anti-pattern*, it helps construct the necessary environment for a deployed application. Sure, other virtualization options like hyper visors and LXC might mitigate some of the benefits of virtualenvs, but don't discount the entire pip/virtualenv/requirements chain. A big problem with containers and other modularization approaches is how you build one from scratch. A recipe like requirements.txt is an important component along with devops tools like chef or puppet.
When I started out with python, which was fairly recent, I went with http://learnpythonthehardway.org/ - This a great start for any one who wants to learn to code with python or wants to learn to code in general. I am developer and have been for a long time, and this was the easiest guide there is to get to know python. I hope this helps.
And heading to...?
Would be way more useful to show how you would actually use LXC instead of just subjectively bashing virtualenv and pip ...
ALGOL 68.
Social sciences.
Use a task queuing system such as Celery, gearman or Redis Queue. Don't do it in the web application process.
Looks like something Zed Shaw could have made.
very nice write up!
After about 80 minutes, yeah.
Underwater basket weaving
Fuck it, just link straight to another packages image.
I am already using LXC, but managing my own dependencies via PYTHONPATH looks like reimplementing half of pip by myself. I'd rather have a requirements.txt in there and let it do its thing. I fully agree that pip lacking binary packages and always compiling everything from source is horrible. I also hate it when a `pip install somelib` fails because I forgot to do an `apt-get install libsomelib-dev` beforehand. And that's the root of the problem really -- we have two packaging systems: the linux distro one and the python one. Those two don't like each other very much and it shows. I'll probably be focusing on researching ways to package python apps and packages as deb archives that will let me use just the system packager.
maybe http://cx-freeze.sourceforge.net/
 "php" == 0 0 == false "php" == true true == 1 Are you fucking kidding me?
What is a "book" ?
This does not give any answer to my question.
I was going to, but, well...
PEP666: include fuckit.py into the standard library.
Take the coursera course from Rice on creating space invaders. It is head and shoulders above the rest. Most important of all, it is fun. That will engender an enjoyment of programming that is essential. These new online courses have so many advantages over traditional learning.
I agree with most of your points, but so what. I am on Windows, don't have drive space for the virtual machine option. WHAT DO YOU PROPOSE AS AN ALTERNATIVE? This type of post with a clear alternative is constructive. Without it, it's just whining. 
Disk space is cheap, get a bigger HD
 &gt; # proof is left as an excercise for the reader I seriously burst out laughing, as someone who studies math this literally made me laugh out loud, doesn't happen often
I worked for a while on a system where the target servers where running Debian, and the devs were developing on Macs. Virtualenv seemed to be used to make the Python environment on the servers look like that on the Macs. This really gave me the willies. Sure, use virtualenv to make your development environment look like the target servers, but not the other way round (though, for anything other than a toy system I'd want the development and the target environments to be the same). I've heard the arguments like "virtualenv protects you when the sysadmins decide to upgrade". Bollox. If the sysadmins are upgrading without the developers knowing about it, then your organisation is seriously fsck'd. And "virtualenv saves you when the system doesn't have the package you need and you can't install it". Again, bollox. If you need such a package, the sysadmins should install it. Two packaging systems is a lurking nasty that can bite you in subtle ways.
Python is strongly typed. You probably mean that you like Go being statically typed (where python is dynamic.)
There's no strict equivalent, but I always recommend the *Python Cookbook* in these situations. It's not a overview of the language in the same way K&amp;R is, but it was the book that took me up quite a few levels very quickly after starting with the language and thus serves the same purpose.
Could I control a program like Photoshop or uTorrent with this?
This is, *by far,* the best Python module ever written. 
You should definitely check this talk, by Raymond Hettinger, "Transforming Code into Beautiful, Idiomatic Python" (https://www.youtube.com/watch?v=OSGv2VnC0go)
Resources are abundant on google so I'll just tell you what I think you should study to write better, more concise, more pythonic code, BTW you should really upgrade to 2.7. - python built-ins, know them. - List comprehensions, dictionary comprehensions, set comprehensions - generators - the itertools module - decorators - context managers - properties/descriptors - the collections module These are what I consider to be the most important, but, of course, there's always lots more to study. [edit] added the collections module, it was stupid not to have it there.
See also the q module on PyPI for no-nonsense debugging.
&gt;These things I never learned in Uni and now that I have no mentor to ask I am not sure which resource I should use learn more advanced methods of coding with Python. Uh. Ask the new recruit? Is it a matter of pride? Get rid of it.
Not really a fan of his opinion on pip. I really wish Python had a much more standardized package manager. It's such an amazing language but it has the crappiest command line tools.
I do ask the new recruit, no doubt about that. But some third-party resources could be good for greater understanding (not always easy to understand when you are told through IM)
Just watched the whole thing. That is exactly what I was looking for! Great stuff, thank you! Do you know anything with the same method of teaching/speaking? I am currecntly watching some of the other talks that he've had.
I would just settle for a `return` statement in the `except` block that continues the try block as if the exception raising statement returned the value actually returned in the `except` block.
The section about --no-site-packages says taht this option is stupid because, due to system libs, you don't have perfect isolation anyway. In the case of pure Python libraries however, I do, and --no-site-packages helps at least in this instance.
[Tip of the iceberg.](https://wiki.theory.org/YourLanguageSucks#PHP_sucks_because:)
Fuck it saved the world!!! It bypass some code trying to destroy the Universe [broke.py line 11](https://github.com/ajalt/fuckitpy/blob/master/broke.py#L11).
Note that pip supports wheels, which are a better binary package format. http://www.pip-installer.org/en/latest/cookbook.html#building-and-installing-wheels
This is gold! I love it! 
here is a chart of truthy equals http://i.imgur.com/pyDTn2i.png
You can use gevent without monkey patching.
Take levels in monk and Skill Focus(Craft[Basketweaving]) to be extra good.
Lovely! Thanks for sharing your work!
http://docs.python.org/3/
I post my weekly class material at http://codebytheneedle.com I would recommend the standard codecademy first followed by the API usage one
Please don't! If you use this license agreement, I wont be able to use your project with fuckitjs since the licenses are mutually exclusive. I can either save you XOR save mattdiamond. I also suspect that the tounge-in-cheek clause renders it a non-free license, similar to the [do-no-evil clause in json](http://tanguy.ortolo.eu/blog/article46/json-license).
My problem with code academy and python is that it's just so broken. Unless they've done some *major* fixes when I went through it too many times code I **KNEW** was correct would fail their tests, or it would take incorrect code as being correct, or it just wouldn't work. I love the idea, code academy has a ton of potential, the examples and lessons in the python section were great, but implementing it was terrible.
What's the 1 sentence description of context managers and properties/descriptors? I don't think I've used those.
Just to correct the misunderstanding, gevent (like asyncio) still only uses one system thread. It uses software defined threads via greenlets and an libev event loop to manage them.
That's because passing integers as a string are always evaluated, however text is not. 0 is always interpreted as false, strings and anything greater than 0 is always interpreted as true. Therefore, since the word "false" in quotes is a string it will always be interpreted as true.
Yeah I know, but I figured "fuck it", if the stack overflows with a 5 second interval between stack frames then the server's not coming back alive soon.
Is this a... What day is this?
neither did your answer to my question
Too many "high light" colors...nothing is neutral. 
&gt; for k, v in list(module.__dict__.items()): Someone used `2to3` without checking the results...
Depending on how you're serving your application you could start a separate thread and feed it jobs using the standard library queue.
Looks like you forgot to **app_list.reverse()** before slicing **top_twenty**. You could also use **sorted(..., reverse=True)** instead.
What about this one? http://www.amazon.com/Learning-Python-Edition-Mark-Lutz/dp/1449355730
Packaging is a huge reason why I avoid using Python on Windows. I mainly program on Linux, because it is much easier to install the needed python packages. It would be awesome if python package installing would be easier on Windows. Some of my friends, who wanted to learn Python, even installed a VM for programming since hassling with the Windows installation process was a pain for them. 
I think you can just use PIP with the anaconda distro to get the bleeding edge of what you want. Conda uses their own repo because they try to coordinate releases properly - so the stack doesn't break. For example, ipython 0.13 was quite different from 1.0, and a blind upgrade would break dependencies and annoy the average user.
I agree with Python being a pain on Windows, but this [site]( http://www.lfd.uci.edu/~gohlke/pythonlibs/) helps a lot.
I use the editor I wrote. I would not suggest either writing your own editor, or even using mine. Most people I know end up using Vim with some plugins. One of my former coworkers wrote a plugin to get Eclipse features in Vim: http://eclim.org/ .
I use Emacs. Got it configured with Jedi completion, flymake, and a few other addons, and with the exception of refactoring it does most of what you say you're missing. Since I code for the web, I need to edit JS, HTML, Jinja templates, legacy PHP stuff, BASH scripts, SQL, etc.etc. as well as Python. From that perspective, using a "python IDE" makes no sense. 
Context managers are used with the `with` statement. They are often used to ensure resources (like files) are cleaned up after use. More generally, they can be used to wrap a block of code with your own custom setup/teardown code. http://docs.python.org/2/library/contextlib.html Properties are a nice alternative to the (private attribute + getter + setter) pattern. You can use `obj.attr = foo` or `x = obj.attr` syntax and underneath a setter or a getter method is executed. Descriptors are used to implement properties, and are a way of modifying attribute access. http://docs.python.org/2/library/functions.html#property 
The mentioned pydata meetup with guido is quite disappointing. Guido seems so uninterested in the scientific stack, even this is now probably one of the most important user groups of python.
My recollection of that meeting was: it wasn't that Guido was uninterested, rather, he felt that the scientific Python ecosystem's needs were broader and more complex than what Python core dev could really concern itself with at that point in time, so he encouraged the scientific folks to do their own thing and solve their own problem.
And yes - conda gives you the ability to create multiple envs, on the same system - in fact those environments don't even have to have the same python version. You can clone them and re-create them on other machines, in other places easily as well with conda. It's quite like virtualenv, except the act of freezing, and re-creating doesn't require building packages.
Nice one - we'd talked about something very much like this a few days ago, so it's amazing to see it implemented and working so soon.
Someone asked this very questions 2 weeks ago: http://www.reddit.com/r/Python/comments/1qy829/what_can_be_considered_to_be_the_python/ There's a nifty search box in the top right of the page.
I don't see what is so hard. On linux/mac, I have python2.7 and python3 running side by side, with modules compiled for both. It is easy to add/remove stuff just by downloading the source and putting it together or deleting files. Why do I need to use some manager when I can just do it myself. The only hard part is the setup, which just consists of putting the appropriate lines in my bashrc. Then I can switch back and forth like a rockstar. Edit: Jeeze... so much hate..
PyCharm system requirements page (http://www.jetbrains.com/pycharm/download/) says: Oracle JRE 1.6+ (OpenJDK is not supported) Very happy PyCharm user here, BTW. Came from VIM to Wing IDE and now am using PyCharm only.
Good point. Now if we could just make every single grad student, researcher, and data scientist trying to use Python as talented as you, we'd be all set. :-)
I think it's because the dict is being modified in the loop that a copy has to be made of the dict's items.
Wasn't trying to be snarky, or maybe only a little. But I really don't see the point. The average person *who is writing python code* doesn't understand how the modules are installed or where the go? I find that amazing.
I doubt there is a visual tool like LabView. There are some [bindings](https://pyvisa.readthedocs.org/en/latest/) for VISA though.
I doubt it too, but I figured I would ask around after I didn't turn up anything on google or github. I actually just finished rewriting some of my experimental procedures using pyvisa. It's so much better than LabView that I want to keep using it, but I need to make sure others in my lab can use my work (they aren't capable/willing to use a text based language), and I need some realtime graph feedback. 
I agree with you. I am a relatively new Python programmer, but I did some research and thinking and configuring, and I basically approach it as you do. Fact is, this is the second decade of the 21st century, and if you're going to be using this stuff, you need to know how to *use it*.
a good book to recommend is Think Python. it covers a lot of the basics and offers example code and exercises plus it's free. It's based on Python 2 but like you said, a lot of the skills are transferable. http://www.greenteapress.com/thinkpython/thinkpython.pdf
I find myself using namedtuples more and more
&gt; We could not wait for the packaging solution we needed to evolve from the lengthy discussions that are on-going which also have to untangle the history of distutils, setuptools, easy_install, and distribute. What we could do is solve our problem and then look for interoperability and influence opportunities once we had something that worked for our needs. [conda](http://docs.continuum.io/conda/) and http://binstar.org rock. *fixing pip* * "pip should not execute arbitrary code from the Internet" https://github.com/pypa/pip/issues/425 * "Implement "hook" support for package signature verification." https://github.com/pypa/pip/issues/1035 ... http://www.reddit.com/r/sysadmin/comments/1s4ec4/please_stop_piping_curl1_to_sh1/cdu41kh?context=3
http://www.reddit.com/r/sysadmin/comments/1r8exx/automated_workflow_software/
everything program-ee is a pain in the ass on windows. it's not a problem unique to python. some of your friends did the right thing. When you are trying to learn how to program, it's probably best to make sure something like windows stays out of your way. 
Does pip / running a setup.py script not work well on Windows? Most of those scientific oriented python distributions come with mingw compilers. 
The ability to read and understand someone else's code. The ability to clearly and concisely document your own code.
could you provide any guidelines to do this? Pleasy?
Have you ever written in .NET? Windows programming (and deploying said programs) is a breeze, and Visual Studio (plus some add-ons) is one of the best IDEs in the business. I think .NET as a whole is amazing for Windows development, and with Mono it's even pretty decent cross-platform.
I agree. Care to clarify what your arguments are? 
Common development practices, agile is hot right now. Also look into subsets of it like Test Driven Development. Documentation tools, for both code (i.e. API) and program level (i.e. user guide). Sphinx is the default for code documentation. For guides people will use anything from LaTeX to Markdown (git friendly) to Sharepoint and word documents. The best thing to learn is how to describe your code on different levels to different people, enabling easier buy-in from co-workers / higher-ups. 
I'm sure he didn't mean .NET considering that it comes from the makers of Windows.
 start &lt;= n &lt; end and not n % skip
I don't see anyone using the output function in that scenario. Then you might as well just leave the same old print statement. Python 3's premise is to make people move on.
I only saw the video, so your recollection is probably the right view. But regrading the dot operator, his proposition the implement just a dsl is just ewww. (maybe i am remembering it wrong, it is a year since i watched the video.) 
Got a link? this sounds interesting. 
You are a winner!
I didn't run 2to3 at all, I wanted to make sure it ran without modification from Python 2.4 all the way to Python 3.3. Because iteritems() doesn't exist in 3.x, and because I'm modifying the contents of the dictionary during iteration, I need a list.
 conda create -n environment_name python=2.7 And then something crazy like installing nodejs into it: conda install -n environment_name --channel https://conda.binstar.org/quasiben nodejs Quasiben only has node packaged for linux and osx, but you can see how much more powerful it is than virtualenv, when you realize the binaries (any kind of binary) and libraries are all isolated into envs. note: that nodejs package is from binstar and a 3rd party channel, but I am just illustrating the power of conda's envs.
You've obviously never had to write production code running python 2.5 because the Operations team wasn't going to touch the ancient version of python on the long term support OS (RHEL, centos, etc). OS package managers run using the system python so anything that might possibly break the whole system are avoided. Having an easy way to push out isolated versions of python and libraries is a god send in large enterprise production environments. 
Its almost exciting to find a question like this.
i did dev on windows from 98 till 2007, and every 1.5 years they would completely change the stack or introduce something that forced everyone to upgrade and make all your previous work broken and you were forced to upgrade. whether it be going from the vb runtime 16 bit to the 32 bit runtime.... activex(ugh) to the various .net runtimes treadmill. the various ui frameworks that they would introduce and then deprecate a couple years later. the straw that broke the camels back for me was when windows 2007 was introduced and they dropped ole automation that made many of my customers happy and productive. At one point I needed 3 different virtual machines with 1000's of dollars of software to maintain those various projects. So yes, to answer your question I have done .net programming. But not for the last 7 years. And the above is my reasons for that. Every time I have to get on a windows machine for various reasons I'm reminded of how much of a waste of time it was to put so much effort into a stack that could change at any point and break all my shit and force me to upgrade my tools, or force my clients to upgrade their software. The .net as tech is pretty solid I'll admit. But it's expensive and forces you to develop based on MS's whims, not your clients needs.
As the author alludes to in this blog, the numpy stack are about the worst packages you can try and install with pip. e.g they don't even use setuptools (or distutils) at all. They use their own code... which somehow has to be there before you install it. That's why its next to impossible to install them without something like an external system package manager or a specialised python distribution.
forgot to mention the complete lack of an orm. But was promised for at least 3 years. Strongly typed recordsets that depended on lots of boiler plate code generated by your ide, and of course the next version would generate it in a different and incompatible way. So new guy gets new version of vs because licenses are no longer available for the previous version. He/She opens the project and is prompted to upgrade it before they do anything, so they do, and all of a sudden the rest of the team has to upgrade. Does installing vs.net still require a day or so of watching an install screen? And your browser gets upgraded too, it's required, OH, well you need to support the previous browser version, but you now can't run the previous browser on your machine, so you have to get a windows license for a virtual machine and ask IT to get you a very specific version that has the version of the browser that you are required to support. More $$ for MS, more wasted time for you. This version of vs only supports that version of TFS, the next version of TFS requires sharepoint new version. Can't install new version of sharepoint without a windows 7 PDC, can't upgrade the PDC because there's no room in the budget to upgrade exchange or your database servers. This is the kind of pain in the ass i'm talking about. 
the downvotes are from idiots who dont know any better. see my reasons above. 
 solve problems breakdown complexity 
It also demonstrates two big problems at the moment: 1. the use of installers means that you can't do isolated python development (everything has to be installed in the system package site), meaning it becomes harder to work on multiple disparate or similar projects at the same time (some people never have this problem because they are distant end users of things like ipythonnotebook). 2. The binaries these install are pretty much incompatible with anything else. If you got numpy's official binaries for windows, and then used these to install extensions like scikit-learn, you'd jump into a pile of errors not least because Holke's packages use a licensed intel fast math library. Now both of these problems are not easy ones that should be already solved, indeed the second, binary comptibility, has been a pain for programmers and users since the dawn of time.
*Windows* programming using *tools from Microsoft* is easy. Try *anything* else.
&gt; The average person who is writing python code doesn't understand how the modules are installed or where the go? Hell yes. Lots of people are approaching much more complex problems then just writing one bit of python code with a package. They need to get x, y and z done, with these set of graphs to show their boss at the end, and it involves all sorts of packages which provide the functionality needed for them to get a result quickly and easily. And their boss wanted this done yesterday, not in a week when they've had time to figure out how the packaging ecosystem works. There are *plenty* of those types of people around, as well as heaps who say "please just let me run a command and then write to this API in your docs" and many others even for whom programming might not be a primary skill of theirs but need the packaging system to work anyway, and not fiddle about with extracting and compiling source files in order to get things to work.
hmm.. how would i install a list of packages and versions? just keep adding name=version?
In fact, both of these problems *are* actually solved by conda, and are some of the primary, motivating reasons why we created it in the first place.
&gt; The average person who is writing python code doesn't understand how the modules are installed or where the go? I don't know what "average" means when applied to the hugely diverse Python user community. I know there are plenty of non-programmers who are starting to use Python to replace Excel, Matlab, and R. They are brilliant scientists, statisticians, econometricians, financial quants, geneticists, etc. But they don't know what "IDE" stands for and can barely operate a command line. They're comfortable with IPython notebook or writing scripts and hitting a Run button. But most don't know what "grep" does nor what a compiler is. Now, we can either require that they read up on ELF, .so library linkage, the Apple ADC docs on Darwin Mach-O and dyld, etc. before they can run a logistic regression.... or, we can build a stack that just works, and usher one more user into the rapidly-growing Python community. 
OK... almost everything you write in Python can be run on Windows just as easily as *nix. Install your libraries and Python and you're good to go. Same thing with Java, node, whatever. You can run vim/emacs on Windows if you want to use a text editor instead of an IDE (or Sublime Text or Notepad++), and a linux-like environment with Cygwin if you feel like you need the tools. If you want to stick straight Windows, Powershell is amazingly powerful. I don't really see your point here.
&gt; I'm not aware of anyone (at least in recent memory) that's ever said "Yeah distutils (or even setuptools) is perfectly fine for installing any python package you could ever want" but somehow you're constructing a strawman who does think that's the case. OK, not *any*, but LOTS. If you read the recent distutils-sig thread about conda and installing binary package, you can find people who declare that the current situation on Windows Works Just Fine, Actually. It's amazing to me, after I've walked into multiple Fortune 100 companies and seen just how f-ed they are by the Windows Python packaging situation. &gt; If you're using your own code to do the installation, then its not portable, even if you are making use of functionality of setuptools somewhere in the backend. What do you mean by "not portable"? Using numpy.distutils, I was able to build Fortran and C++ extensions on Windows, Linux, Mac PPC, and Mac Intel. &gt; I am a little dissapointed that the author has talked about setuptools in the same breath as distutils The reason is because setuptools inherits the same architectural flaws as distutils, namely: 1. An imperative script instead of a declarative one, for specifying build 2. Conflating the problems/needs of build-time, install-time, and run-time. 3. Bundling said conflation into a single imperative *python* file, which frequently has imports before it can even be properly imported to introspect &gt; It's come about the same distance for general python packaging in the last year or two as conda Well it must be a year, because conda is only about a year old. :-) I think it speaks volumes that when we wiped the slate clean, asked what the real, fundamental, root problems were, and didn't back away from solving problems at the C level, we could build a robust "portable homebrew" and successfully use it to ship hundreds of thousands of copies of software, including things as complex as Boost, Qt, and LLVM. I've been tracking the Python packaging space since about 2005, and while I don't have as much hands-on "cutting my face" experience as Travis, I have certainly been intimately familiar with the painful journey that the community has taken from distutils -&gt; setuptools -&gt; distribute -&gt; pip -&gt; setuptools2 -&gt; distutils2. I've seen many people that jump in with the best of intentions and attempt to fix things while not appreciating the deepness of the problem, *and* they try to maintain compatibility with legacy brokenness, and then that brokenness infects the new stuff. Maybe this is too broad of a brush, but for a long time the folks in the "PyPA" did not appreciate that their problem is a common one shared by R, Perl, Ruby, etc. And none of those other languages really solved the problem either. It's ultimately rooted in the OS ABIs, and how C and FORTRAN compilers generate code - the problem is really that deep. In the Python world, we actually had an opportunity to really show how to do this right, because we had a sub-community that had the right mix of complex extension modules AND programming know-how. And time after time, the core Python packaging conversation would treat the scientific ecosystem folks as just wrong or as crackpots (c.f. how some of David Cornapeau's comments were regarded during the initial evolution of distribute out of setuptools). 
Not that I find Windows flawless in any way but... this is the first time I use the tag feature, just to mark /u/twillis1973 as a known troll. My first time since I'm a redditor.
Have YOU had to deal with multiple versions of a package YOU wrote, in a multi project environment, using just a default Python install you have no real control of? No? Well, back off then and come back when you know what it feels. Packaging on Python sucks, no matter what platform. Source: 7+ years earning my food by programming in Python for several platforms.
Good to see somebody that understand the issues at hand. I get tired of these hipsters claiming that we are just dumb for not using X or doing Y, while all they write are one-off scripts. Fuck, I despise those clueless bastards.
I would personally like to see the ability to understand/edit existing code and at the same time be aware that your changes might break existing code. Next would be the skill to put thoughts in terms of classes/functions (not UML diagrams but sketches). This is really a big one because there are a lot of guys out there that can write Python but once given a non-trivial problem to solve (which involves a few classes, deciding flow), they get flabbergasted.
"Agile is hot right now" - that turn of phrase makes you sound like a recruiter describing a word they have seen lots of people using, but have no idea what it means :)
And he's already said "Yes I will solve these problems" about fixing asynchronous I/O (that's tulip/asyncio/[PEP 3156](http://www.python.org/dev/peps/pep-3156/)), so he's already got a massive problem.
Communication skills are vital. Software is a social exercise as well as a solitary one. That means written language, spoken language and learning empathy. Learn to listen. Understand what your other team members are good at and learn from them. Trust is very important, but be on the lookout for people who are not as good as they think they are, or people whose lives are getting in the way of the quality of their work. You will contribute in parts to analysis. Learn the terms that allow you to express your thoughts, even if they are not well formed. Understand the jargon, but only use it when necessary for precision - it should help but not hinder. You will contribute in parts to design. Learn how to step back and plan what you will do, and review those plans with others. You will save a lot of time and grief. Finally, remember that this is an engineering discipline, not a contest of opinions or politics. Sometimes you will be flat out wrong and someone will teach you a lesson. Do not become emotionally attached to your opinions or your code. Be willing to change your mind. Be humble and learning will come much faster.
Yep, lxml with virtualenv on Windows == pain
Python packaging has been something to work on for a lot longer than Guido has looked at async io; but I'd also say even though they're both areas that are hard to "get right" packaging is even bigger and harder.
test
If you're comfortable using VIM, why not SSH into a box running Linux? 
I like to think that my code is commented well, and I appreciate it when others take the time to explain their thought process. But as I am still fairly new to the art of programming, I was wondering if there was an example of beautifully commented code you could show me? Something concise but beautiful that for you would be the gold standard.
But if you don't use the monkey patching and a greenlet blocks, nothing else will run. The monkey patching allows control to be yielded to another greenlet so it can run. So don't use the monkey patching and you throw away and semblance of concurrency that it gives you.
You can deploy python (modern one) in production and in a large enterprise (I'll add also with compliance requirements): just need to understand the operation team has probably the duty to not break things, verifing step by step what is installed. And this is where you'd avoid setuptools/pip/easy_install/eggs/wheels/conda/blah-blah-what-next "enterprise packaging" solution: they are not suitable in a enterprise environment no matter what they claim. They simply don't fit in the environment, they trying to "reinvent" a new packaging system. 
I meant that. It I like that Go can detect a lot of errors at compile time. Go also allows dynamic typing and reflection btw.
Installing python packages is only a a pain with packages that need to be compiled for speed reasons. About 80-90% of all packages can be installed with a simple 'python setup.py install'. But yes, for those packages (which are not the least -- pyodbc, cjson) it is a major PITA. 
Anaconda supports environments directly, so you have no reason to install virtualenv. See the [example here](http://docs.continuum.io/conda/index.html). I haven't used this yet, since I only heard of Anaconda this morning and spent the next 25 minutes getting our project to run in it using the root environment. Before, this took days of working out, using a combination of ubuntu packages with as much as possible installed in virtualenv. It ended up being horribly dependent on the exact ubuntu version and a constant source of anxiety to maintain. 
That's pretty cool. Python [wheels](http://pythonwheels.com/) can also be generated from win installers, which can be natively installed from pip.
Personally I would put Mono in the same category like Wine: It is nice to have, if it works, but I have to admit that Wine runs much more stable for me in recent years than Mono. I will list my own experiences with programming under Windows: It starts with the terminal: No auto-completion for commands, the lack of tools, no color support, you change folders with cd but partitions by just typing the drive letter and :, no fullscreen, no tabs. I know that the powershell was developed, but I was reading into it and I thought that it is quite an overkill for what you want to do with a terminal typically. Also you would have to drop serious money, because the powershell isn't included in the cheaper Windows versions. It has been a while since I tried cygwin though. Setting up the environment is also one of its main drawbacks. If you know what you want, you will have your environment running in linux in a couple of minutes. In Windows your first friend is google and hunting down librariers, compilers or whatever you need. Package managers are so convenient and great. I don't know why Microsoft hasn't make one themselves. I think this point is more unique to me. I like programming in a tiling window manager, because my hands do not have to leave my keyboard to look at documentation or whatever information I have in other windows. No real fullscreen for programs. I just can't do C-f and have my editor in fullscreen. Every DE or WM I know under linux can do that. This point can be nullified by having autohotkey run in the background, which is able to do just that, although it doesn't work well with every programm. Another point that is more unique to me, but would apply to everyone with a weaker machine: I program on a little netbook and Windows would take most of my resources. Filesystem: This isn't directly tied to programming, but the filesystem structure of a linux system is very transparent and you will know where to find things. Also as a beginner a nice and easy task is to write a backup system, which is relatively easy under Linux. I think under Windows it would be a lot more problematic to write one. (with recovery of the system of course.) Of course it isn't impossible to program on Windows and I do it from time to time, but these are the little things that annoy me quite a bit. 
&gt; Since /u/twillis1973 doesn't care to explain why he thinks so, I will list my own experiences. I think I gave plenty of reasons why I think so. Though I didn't mention the terminal support. 
sweet. can you guess how much I care?
Sorry, somehow I overlooked your post! I will edit my post.
did you even read this before you accused me of not providing concrete reasons? http://www.reddit.com/r/Python/comments/1s97j4/python_packaging_thoughts_from_the_author_of_numpy/cdvl7g7 it was posted 2 hours before you posted this asshatery according to reddit. and I blindly downvoted you before reading your other comment. what are you going to do about it? 
I don't know why the parent thinks that pip is hard to get running - I agree with you that *literally* installing it is pretty simple in many cases. However, it is true that many Windows boxes are locked down to varying degrees, so that the user does not have "local admin" privileges and can only write to certain directories. This does make actually using pip for many packages to be really difficult. It's also possible the parent poster means that getting pip to successfully build most packages is an ordeal, because you need to have installed the exact version of Visual Studio that was used to build Python.exe.
This is very interesting. I was unaware of sencha and seems very interesting. Also found this - http://www.sencha.com/forum/showthread.php?130149-Samples-Examples-for-ExtJS-4.0-and-Django 
this seems like it would be pretty cool for getting "line of business" apps rapidly prototyped and done. Also, [this earworm](http://youtu.be/8s8l75Oxf1U?t=58s) was going through my head as I was browsing the docs. It will likely be stuck in my head the rest of the day now. 
Well I stand corrected then.
im using the command line on a daily basis (for basic tasks only but still) and my path is correctly set and nothing that confuses me. but i still remember spending 60+ minutes looking for solutions to the problems i was having and then i just said fuck it. but this isnt about me anyway, just look at stackoverflow and the forums, they are full with people having trouble getting pip to run and it shouldnt be like this. now its an old discussion but i think that answer to this is not requiring everyone to suck it up, learn new skill x and go through frustrating troubleshooting, the answer should be to make the process easier and less error prone so that as many people as possible get the chance to use pip and try out python in a comfortable way
My whole point was that if you have enough skill to write meaningful code. Then you should have enough skill to know how the modules are setup, and where they are located on your system. I'm not talking some deep understanding of the actual code compilation. But, being a scientist myself, there are no black boxes. All of those people you listed need to know both how the code they use works and what it does. Sure, my experience is limited as some people have pointed out. So I am sure that there are cases when you need package managers and things like that. I don't.
looks like the playlist doesn't exist
Oh, snap!
Have they implemented 'Reddit Coal' yet?
&gt;I get tired of these hipsters claiming that we are just dumb for not using X or doing Y, while all they write are one-off scripts. So anyone who disagrees with you is a script monkey eh? rox0r has a point though, getting it running on your dev machine is one thing, running on servers in prod that are not under your control is an entirely different matter. 
try doing it in other languages, and it still sucks not just python. source: 15+ years enterprise development, business basic, visual basic, delphi, vb.net, C#, java, php, python, appengine, javascript, ruby, rails, windows, netware, sco unix, linux
I got OP's list to come up for a while, then after I refreshed the page it said it didn't exist. It looked like he may have made a new playlist out of the MIT 6.00 lectures, which already has an [official playlist](https://www.youtube.com/playlist?list=PLB2BE3D6CA77BB8F7)..
The online course version of these lectures was just this semester put on edx.com as a joint venture with Harvard. It takes some of the best parts of MOOC's like the interstitial quizzes in udacity and pairs them with very high quality lectures that don't skimp on theory. https://www.edx.org/course/mitx/mitx-6-00-1x-introduction-computer-1122
&gt; having to deal with the nightmare of Linux GUI inconsistence i thought we were arguing about why just python packaging sucks and that windows is perfect. I'm not defending shit as gay as how a GUI makes you feel and whether thats cool or not. 
Sorry for late reply, [here's a zipfile I just created](https://launchpad.net/mergou/trunk/alpha1/+download/tarball.zip). Launch code_browser.py with python files as argument or any directory containing python files. 
If you can't view the playlist take the code from PL onwards, in this case: PL5F90ACB29A774A5F and search for it in youtube, should work then?
I'm wrapping this course up, and the Big O-notation part was really nice. Mr Grimson is a great lecturer!
Eric (Prof Grimson) is just a great person all around. :)
Sure thing. He and John (Guttag) are both pretty busy. But one thing that I've always admired about them is they really were focused on student success in class. He'll appreciate the feedback.
If I can recommend a follow-up, /u/spez (Reddit co-founder Steve Huffman) did a great practicum type course that gets into web-app development and the google app engine platform via python. There may be some overlap with what you just did, but hang on through the first unit or two for exposure to some neat cloud computing concepts and "how to think like a programmer" type problem solving. https://www.udacity.com/course/cs253 
I'm so very new to the world of programming. Can you explain what a test in Python means? Don't you test your code when you run it?
https://github.com/rg3/youtube-dl https://www.youtube.com/playlist?list=PLB2BE3D6CA77BB8F7 Combine for win. 
Is it this guy? http://people.csail.mit.edu/welg/contact.html 
The depth of the framework is impressive. I wish a more modern (less GWT / enterprisey) UI was available.
Yes it is very "enterprisey" which is why I'm sticking with my own development line right now :) I do, however, like the integration with ExtJS which seems promising so I may explore that further however I'm not big on the whole licensing scheme behind ExtJS concerning development for resale.
This playlist works on desktop: [MIT 6.00SC Introduction to Computer Science and Programming](https://www.youtube.com/playlist?list=PLB2BE3D6CA77BB8F7)
In fact, 6.00.1x has a follow up course 6.00.2x. And, then there are *five* more after that in an [XSeries on the Foundations of Computer Science](https://www.edx.org/xseries) that stretches out to the end of 2015! The MIT course is very much centered around computational thinking. I think that the coal is for students to use programming in other fields like science or business as much as it is to develop software engineers. The Udacity course sounds like it has a greater emphasis on practicality and maybe the state of the art.
When programmers talk about testing, they are referring to automated tests that they can run every time they add or change some part of their code to ensure that they didn't break anything. For example, say you build a shopping cart. You might want to test that when you put an item worth $1 in the cart, the total cost is $1. Then you increase the quantity to 2. Total should be $2. Now apply a discount code for 10%. Total should be $1.80. You could write this out and do this test manually, clicking buttons on the screen, but once you have more than a few tests, it would get tedious; so we write code that automates this testing. We can then run those tests every time we make a change to the software to ensure that we didn't break anything. A large project might have thousands of tests that take anything from a few minutes to a day to run. We run these automatically whenever someone checks some code into source control and if something goes wrong, the person that made the change is alerted and can investigate.
Not exactly the same size as K&amp;R. Although this book is really, really good.
Mac install issues are a huge pain, especially with xcode and linking against the right library. Sometimes the best solution is to create a link from where the installer expects something to be to where your version is actually installed. You may be having [this guy's](http://stackoverflow.com/questions/11833838/gcc-4-2-error-on-mac-osx-mountain-lion-unable-to-install-mysql-python) problem. If you type `gcc` in the terminal, what does it say? It should be something like i686-apple-darwin11-llvm-gcc-4.2: no input files Try `ls /usr/bin/gcc*` and check for gcc-4.2 . If it's missing, symlink it to gcc.
Alright, I'll say it -- the transforming code into beautiful, idiomatic python talk (pycon 2013) is immensely useful. A lot of obvious information and a lot of non-obvious useful tricks. Also fantastic delivery. *what happens if you don't release a lock. Do puppy dies? ...pause... every time.*
That was very helpful - many thanks. Doing this seemed to pacify the install and it says it was successful: sudo ln -s /usr/bin/gcc /usr/bin/gcc-4.2 However, help('modules') doesn't reveal that it has been installed. I am pretty sure that it installed, but maybe to the wrong directory. Any ideas on how to repair that? 
Here's some proof-of-concept code that adds element-operators ("._*" and "._**") to the matrix type. (The numpy.ndarray type doesn't play well with setattr.) import numpy as np class _elt_op(object): def __init__(self, m): self.m = m def __mul__(self, other): if isinstance(other,(np.ndarray, list, tuple)): return np.multiply(self.m, np.asmatrix(other)) if isscalar(other) or not hasattr(other, '__rmul__'): return np.multiply(self.m, other) return NotImplemented def __rmul__(self, other): return np.multiply(other, self.m) def __pow__(self, other): return np.power(self.m, other) def __rpow__(self, other): return NotImplemented setattr(np.matrix, '_', property(lambda self: _elt_op(self))) m = np.matrix([[1,3], [5,7]]) print(m) print(m * m) # Matrix Multiplication print(m ._* m) # Element Multiplication print(m ._** m) # Element Power 
To be more [precise](http://pyvideo.org/video/1780/transforming-code-into-beautiful-idiomatic-pytho)
&gt; The MIT course is very much centered around computational thinking. I think that the coal is for students to use programming in other fields like science or business as much as it is to develop software engineers. That's actually exactly correct. The 6.00 course is explicitly for non-CS majors to become familiar with computational methods. Source: I was a TA for it.
homebrew is the answer #1: brew install python #2: brew install postgresql #3: /usr/local/bin/pip install psycopg2 #4: there is no step 4 
When I import I get: /usr/local/bin/python2.7-32 /Users/username/Desktop/pytest/testing/testing.py Traceback (most recent call last): File "/Users/username/Desktop/pytest/testing/testing.py", line 2, in &lt;module&gt; import psycopg2 File "/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/psycopg2/__init__.py", line 50, in &lt;module&gt; from psycopg2._psycopg import BINARY, NUMBER, STRING, DATETIME, ROWID ImportError: dlopen(/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/psycopg2/_psycopg.so, 2): Symbol not found: _PQbackendPID Referenced from: /Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/psycopg2/_psycopg.so Expected in: flat namespace in /Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/psycopg2/_psycopg.so
I'd like to cast my vote for the class development toolkit video.
I've been teaching python to kids from 12-18 years old for a couple of years now, and an hour is not nearly enough time to be productive. Usually, in my first one hour class we can cover: * what is programming * what is python * starting idle * what is the REPL * opening a new file and saving it with a .py extension * what is a variable * string vs. int * getting text from a raw_input * printing text to the window If everything has gone *extremely* well, you might be able to introduce them to an **if** statement. Of course, then you have to explain the colon and indentation of blocks. If you're only going to teach to the kids in the computer club, then disregard what I've said. Otherwise, I can't recommend the CSEDWeek tutorials highly enough. I'm going to be running it at my kids school (which is K-8) using the blockly powered demo for them all. It is super easy and will teach the kids a lot! They'll learn IF, ELSE, WHILE, UNTIL statements while having fun. Either way, good luck with your hour of code and please let us know how it went!
'That was a pretty sick burn.' Hahaha
Thanks! We're ready to go for Wednesday and I'm very excited about introducing people to coding! 
that changelog looks extremely bland for a major version change.
SQLAlchemy is probably the most popular way to talk to postgres.
Maybe not what you need exactly, but Postgres does allow for Python code incorporated directly. Also, you can try this. https://github.com/kennethreitz/osx-gcc-installer/
I wonder why he never wrote a book
"dunder" is just a portmanteau of "double-underscore".
I want more packages to drop support for Python below 2.7. The only reason I'm developing a Python 2.4 based program is the Air Force is still installing 2.4 on some of their computers because their programs use Python 2.4, despite 2.7 being the current required standard. Trying to find and build PyQt3 is a pain. My open source Python project requires Python 2.7+ and relatively recent versions of numpy, scipy, pandas, and matplotlib. Don't like it? Don't use it. I know how to support Python 2.6, but I choose not to as it would make Python 3.2+ support much harder (I skip 3.0 and 3.1 like anyone who is sane).
Knowing where the modules are located is not sufficient to install, say, Numba, which relies on Numpy and LLVM, from scratch. Yes, people need to have some understanding of what their system is doing, but there are vastly more useful ways for people to spend their time than figuring out Python packaging.
Exactly: conda create -n my_env python=2.6 numpy=1.7
Watched lectures 1 - 4 today. Thanks for posting!
(2.6, 2.7, 3.3) is also a good conservative choice for compatibility that's sane to maintain. 3.3's unicode literal strings makes that little bit easier than 3.2
Seems like it's to mainly to indicate CPython version compatibility. 
Asyncio is defines a runtime-replaceable event-loop interface, which has a default implementation it provides, but can also be replaced. Gevent will always use its own libev event loop. Greenlet runs on top of greenlet green threads to cooperatively multitask, asyncio uses `yield from` to achieve the same effect. Asyncio is &gt;=3.3 only, Gevent is &lt;=2.7 only. Both are designed to run in only a single OS thread. Gevent is more battle and field tested, asyncio is newer and more flexible with implementations. 
Thanks.
Absolutely. With the 2x course not being available until the Spring however, the Udacity class may be a good filler. =)
If it was me I would rabbit mq the msg then pick it up with a separate console app. For extra points use mass transit.
Can't see it on my phone
Ah, no, don't bother. Stopped working after a while; I probably had it cached. But there was a link to the real playlist in these comments. 
Software Development * https://en.wikipedia.org/wiki/User_story * https://en.wikipedia.org/wiki/Pair_programming * https://en.wikipedia.org/wiki/Distributed_revision_control [1] * https://en.wikipedia.org/wiki/Test_automation [2] * https://en.wikipedia.org/wiki/Test-driven_development#Test-driven_development_cycle * https://en.wikipedia.org/wiki/Continuous_integration#Principles * https://en.wikipedia.org/wiki/Code_review * https://en.wikipedia.org/wiki/Release_management * https://en.wikipedia.org/wiki/Build_automation * https://en.wikipedia.org/wiki/Continuous_deployment Communication: Documentation * https://en.wikipedia.org/wiki/Technical_communication * https://en.wikipedia.org/wiki/Software_documentation * https://en.wikipedia.org/wiki/Specification_(technical_standard)#Information_technology * http://docs.python.org/devguide/documenting.html * http://write-the-docs.readthedocs.org/en/latest/ Open Source Teams * https://en.wikipedia.org/wiki/Open-source_software [3] * https://en.wikipedia.org/wiki/Open-source_software_security * https://en.wikipedia.org/wiki/Business_models_for_open-source_software * https://en.wikipedia.org/wiki/Comparison_of_free_software_licenses * https://github.com/blog/1530-choosing-an-open-source-license * https://github.com/pydata/pandas/blob/master/CONTRIBUTING.md [1] Revision Control (CVS, SVN) and Distributed Revision Control (Git, Hg, Bzr) * http://documentup.com/skwp/git-workflows-book * http://book.git-scm.com/index.html * http://hgbook.red-bean.com/ [2] Automated Testing * http://www.reddit.com/r/Python/comments/1drv59/getting_started_with_automated_testing/c9tfxgd [3] The Art of Unix Programming: Best Practices for Working with Open-Source Developers * http://www.catb.org/esr/writings/taoup/html/ch19s02.html 
Teams * https://en.wikipedia.org/wiki/Team * https://en.wikipedia.org/wiki/Team_building * https://en.wikipedia.org/wiki/Tuckman%27s_stages_of_group_development * https://en.wikipedia.org/wiki/The_Five_Dysfunctions_of_a_Team * https://en.wikipedia.org/wiki/Collaboration#Technology * https://en.wikipedia.org/wiki/List_of_collaborative_software
I was fortunate to have him as my instructor for a series of Python classes I took earlier this year... very no-nonsense, and one of the best instructors I've ever had for a class (including college).
You know you can save threads right
&gt; Programming is problem solving. For most programming jobs, this almost always mean solving a business problem. i.e. writing code to enable client(s) to: - sell more stuff, or - sell NEW products/services, or - update existing code/system to comply with changing market (e.g. changes in legislation/business landscape etc) 
&gt; Shorter, much more concise Usually a good thing. &gt;more complicated methods of achieving his goals than I do. Not necessarily a good thing. Rule of thumb is: the better code is one that is easier to maintain (i.e. easier to extend/modify in the FUTURE!)
Saving
What does 2.6 make harder for 3.2 and above?
I think several issues are conflated here: the main added value in distributions systems like anaconda, epd/canopy or activestate python is the curated set of pre-built packages. That's what makes them easier to use on windows, nothing fundamental about how conda works -- once wheels become more popular, we will be able to do the same thing (we are working on it in numpy, scipy, at which point others should be able to quickly join the bandwagon). 
Awesome now I have no more excuses left
Supporting (2.7, 3.2, 3.3, ...) is easier than supporting (2.6, 2.7, 3.2, 3.3, ...), due to the __futures__ added in 2.7. 
I stand corrected. There are a few changes, but they don't seem too major indeed: http://www.python.org/download/releases/2.7/
http://i.imgur.com/ZNYHtU1.jpg
Are these accessible to someone just starting out in programming?
Yeah - he addresses this somewhere deep in the article: Anaconda utilizes conda, but conda is a stand-alone distribution manager with no dependence on the Anaconda distribution. (i.e. you can simply pip install conda)
You never did ;) But go get 'em tiger! 
There is some great **typo** mistake while posting the article. i dint notice that. If you feel something is wrong or code can be changed you need to say it softly and should explain why it is wrong ? I have changed the code, i accept your point that you need to have r' ' in every line, i literally forgot to migrate that into article when i wrote it and now say How will you escape the whitespaces between each set of numbers? (Dare you if you use \s anymore now). Mistakes are ought to happen and you cannot shout as you wish. There is a way to tell things. Learn how to behave in public rather than shouting. I appreciate you that you pointed out my stupidity but don't forget you are no genius or some fucking world coder. Mistakes are ought to happen. 
I probably wouldn't use it as-is, but look at it for inspiration. So yeah, publish it!
Do they have the next course in this sequence posted?
Man, after watching the "transforming code" video I felt so ashamed. I am one of those guys who writes Python code like a Java developer and I really need to get deeper into the language and its Zen. But hey, after watching the video I opened PyCharm and rewrote several sections of my recent project. Now they look so much better! The more I use Python the more I love it.
Nesting a class inside another isn't really doing anything exotic, it's just defining the inner class in such a way that it's only visible to methods of that class, in the same way that the definition of a local variable defined in a function is only available there. Maybe it's some internal type used for bookkeeping and there's no reason for it to be exposed anywhere outside of that class. Perhaps you're writing a class that manages a series of dates and internally you want to store all the data in some custom date representation. I don't know. A compelling example isn't springing to mind. The point is, if one class is only ever going to be used within another class, and for some reason you don't want to expose it to the rest of the program, then you can define it as a nested class. 
In python it's just about namespaces and there's no real reason to do it. In Java there's a distinction between static and non-static inner classes. The former work like in python, while the latter have access to a specific instance of the outer class, i.e. they know its `self` variable. To get the Java behavior in python you have to define the class locally like a closure.
I understand what you are saying, i know what i did wrong with code, i already changed it. You are a flamer who flames with jealously and ego. As i already said i knew each string should be used raw, when i pasted i messed up with pattern nd dint notice until you pointed out but that doesnt mean i m fake, imposter. I know my code and how it functions, you can see other posts if you want and then speak. I m very much offended by your words. How can you say i am fake. You dont have any rights to say about me. 
Just starting, I think the MIT course is great, just don't confuse learning computer science with learning Python programming.
I'm leaving the ruby world, and converting completely to Python. Something I don't understand is why there's such a discrepancy between the two languages. Is it simply due to history? In ruby, there are multiple working options for side-by-side language versions (rvm and rbenv). And gems+bundler handles packaging. Could a 'pvm' (python version manager) modeled directly after rvm be a way to go?
Commit [47c91a2](https://github.com/gkbrk/RandomDilbert/commit/9b8042deb276ef11b6800001b4e3f0a17c80fcad): Added \_\_main\_\_ block.
Probably the only (corner) case would be if instances of the nested class do not "leak" outside the containing class. I have a first hand experience in C++ (not in python where this design errors are less common) and I can tell you is really bad idea: the biggest problem is the code becomes quickly un-testable as the container class grows. 
You can define the inner class based on parameters given to the outer class.
&gt; I don't know, maybe I'm wrong to be this harsh, but you are really doing a very harmful thing with your attitude. You are not wrong. I agree with you. The problem with blog posts like this is not that they are telling bullshit. It's that the authors make it seem like they know what they are talking about. I'm honestly fed up with this shit. Another example why this post should be deleted ASAP: he implicitly suggests to parse HTML with regular expressions ...
That'd be interesting. I still can't really think of an example of where I would use that, but this is pretty much the only legitimate use for this that I can think of. Maybe with some cool metaclasses we could make some *really* black magic. Hmm...
My automation library [PyRobot](https://github.com/chriskiehl/pyrobot), of course! ;p For heavy automation stuff, though, (like driving multiple programs as you mention in your post), I'd definitely second /u/donaldxv 's suggestion of Sikuli. It's very mature, and its template matching makes things as about as straight forward as they could possibly be.
What do you have so far? Also you should probably post this in /r/learnpython instead
I mean write the inner class with data passed in at run-time. Take a look at the code for collections.namedtuple for an example of run-time class definition. They don't use a nested class; they use eval + a dynamically-built string, but the end result is similar. A class is written based on data passed in at run-time. I DO NOT recommend using this kind of trickery unless you really need it and unless you're willing to test thoroughly. This fancy shit is difficult to explain to rookies and often has unexpected side effects. But it's a free country, and it's good to learn stuff the hard way too :)
I love experimenting with weird stuff like that in throw-away code. Sometimes I'll figure out something really helpful. But wow, it is hellish to debug really dynamic stuff during a production emergency.
&gt; As I tried to explain, there's bullshit and there's real bullshit. I totally understand that mistakes happen, misunderstandings happen, god knows I've made a lot of those. But here the entire whole attitude is wrong, the dude just isn't a programmer right now, he doesn't possess the necessary frame of mind. And he sort of normalizes this copy-paste caricature web programmer approach and being a programming educational blogger for the sake of getting views. &gt; Why would you even try to make a post about regex tricks if you don't know what \s* does? Fuck ALL about that. I'm totally with you. And I'm equally frustrated. When I see stuff like this (mostly here on reddit) I can not help but give them a piece of my mind. And then I get downvoted for the tone that I'm using. But what can I do? I've seen too much :/
You motivated me :D
That was helpful. Thank you :-)
I'm sad that I only get to report posts, but you get to denunciate them.
Download Related Course Materials: http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00sc-introduction-to-computer-science-and-programming-spring-2011/download-course-materials/
There s one section called dont reinvent the wheel at last, did you even tried to read that.
I don't know what you mean. This page seems to be broken. Clear your cache and reload it. The last heading I can see says ***Non-c*** after section ***Conditional (If-Then-Else) Patterns***. [Screenshot](http://imagebin.org/281251) ^(EDIT fixed image link)
and then run `conda init`
what "desktop version" ?
I was speaking about the Hettinger/Martelli videos on pyvideo. Ive seen some lectures where the language is just too far over my head and I realize that I could probably use the time a bit more wisely, in regards to learning.
The article was mentioned two days ago by pwang99 using this link: http://technicaldiscovery.blogspot.ca/2013/12/why-i-promote-conda.html Reddit link: http://www.reddit.com/r/Python/comments/1s97j4/python_packaging_thoughts_from_the_author_of_numpy/?sort=confidence
This is worth 70 points of your final grade. More than likely you've had more than enough time to complete this. Do your own homework. Personally I think you deserve to fail. 
If you've had 100% in the class up to this point then you should already have the knowledge foundation to complete the assignment. 
Fixed the cache, sorry.
 import this print(''.join([this.d.get(i, i) for i in this.s]))
Hey guys, you may also want to check out http://coursera.org for some courses taught by other university professors. The courses that are ongoing right now will also have exams and quizzes and will offer (some form of) credit if you pass, but you can watch the lectures by themselves if you want, too.
'this.s' looks like a rot13 version of the output from 'import this'. If you do 'this.s.decode("rot13")' you'll get exactly what you're looking for. A more generic way to do this however would be something like this: &gt; import sys &gt; import cStringIO &gt; stdout_backup = sys.stdout &gt; sys.stdout = cStringIO.StringIO() &gt; import this &gt; this_string = sys.stdout.getvalue() &gt; sys.stdout.close() &gt; sys.stdout = stdout_backup &gt; print this_string This makes stdout stop printing to the terminal and instead put it into StringIO buffer.
&gt; A more **generic** way to do this however would be something like this: I would never call replacing sys.stdout generic haha.
why not just this? print this.s.encode("rot-13")
Heh, I agree that it's certainly a very *bad* way to do it. But if you've got some other module that prints stuff on import and doesn't have an equivalent to this.s, then replacing sys.stdout should work, hence generic.
Because I use python 3 and that doesn't work there.
Is this code GPL?
&gt; print this.s.encode("rot-13") print this.s.decode("rot-13") FTFY
Because you've written a class that is far too monolythic and sprawling so much so that it needs it's own internal class object model. Really, it's a thing you should almost never do, but if you really want to you can. As a disclaimer though, this is coming from a python programmer, and these days I'm trying to use OOP as infrequently as possible. An "only when I need it" philosophy.
I wonder what this guy's take on zc.buildout is...
Django uses it for ModelForms. There's a class called "Meta" inside each ModelForm where you can define its model and the fields that should appear in a form. I guess it's so that the fields namespace is not polluted or something.
sys module already backups stdout for you: import sys sys.stdout = ... .... sys.stdout = sys.__stdout__ 
Not sure why you got downvoted, this is what I came to post after doing dir(this). Seems to be more of what the module authors intended. You can skip the [] though, omitting them makes the join over a generator comprehension, so it doesn't build an intermediate list.
Unless someone else has already fiddled with it and would like their settings restored. Of course to be robust we'd do it with a finally block, or even better, wrap the whole logic up in a context manager that does that for you.
What he wrote is actually the code as present in `this.py`, source code of the module.
That's great thanks. I'll try to give mergou a go tomorrow. Thanks for making the tarball - I appreciate it.
The English alphabet has 26 characters and 13 is right in the middle. So it doesn't matter whether you encode or decode it, you get the same result. this.s.encode("rot13").encode("rot13").encode("rot13")
Wow, you just blew my mind there. All those hours wasted compiling Numpy, Scipy and Matplotlib could be finally over! 
The thing with pip is that to install *any* package with extension modules needs a compiler. It's getting a compiler working on Windows which really sucks. For Py2.x, it will *only* work with MS Visual C++ 9 / MSVS2008 (anything newer breaks ABI compatibility), or MinGW (32-bit only). Having just spent a quality 2 days getting a build-environment working in a new VM, I can attest its not a fun experience. Why o why can't I just "yum install Development-Tools" and have it work...
I actually had this problem before with similar code I wrote, there is a better way to do ARP scanning which I will dig up from my old laptop and submit him a pull later...
It does on Python 3. Bytestrings can't be encoded, they have to be decoded, and Unicode strings can't be decoded they have to be encoded. 
I do it from time to time, if I need some code that is best implemented as a class, that is needed inside a single method in a class (so the nested class is in the method of the outer class) class Outer: def mymethod(self): class Helper: .... h = Helper() .... It feels to me better having the nested class close to where it is used, rather then someplace possibly many lines of code further away. I guess with Python 3's *nonlocal* I might use a nested function rather than a nested class some of the time.
Hello, I wrote impala, a PEP302 implementation, and would like to offer it here for exposure and criticism. EDIT: i appreciate both upvotes and downvotes, however, the downvotes especially are not very useful without comments. downvote away, but please state your reason!
If the aim is to make it easier to test code that is in a 'src' directory, which would be installed under a different name, then use tox to drive your tests. Using tox is much better anyway, because it will sdist your package and install it into a fresh virtual environment and the tests will then be run against that. Thus you are testing against the same package that a user would have installed from your package and you have less risk of missing something when the package is bundled because the tests will fail if there is. Using tox also allows you to test for multiple Python versions or other variants.
I think the main application of this would be making some bundled package available globally. Not sure who still does this on a large scale - Django did it with simplejson but they are deprecating that ... Also, why indent at 2 spaces ?
Are there any good books out there with this kind of information? Easy to understand examples of how to efficiently use the Python language the Python way?
Would love to hear how you structure your code without OOP. functional style?
On python 3 you can't use either encode or decode with rot-13 because rot-13 is a string to string translation.
Because somebody else had already given that answer.
I'm installing a fresh Anaconda on Windows 7 64-bit and issue a `conda update conda` first thing, to which I immediately receive "Unsatisfiable package specifications" and "python2.7* has a conflict". Any idea what I'm doing wrong? 
hey hey. I recommend we build a new sane IPC system that is distributed. * We need distributed locks with a sane algorithm for concurrency (like a DHCP server that leases resources instead of IP); * We need wires to propagate signals (probably a messaging system that supports crypto); * We need a sane distributed framework that handles process control other more than one computer; * we may need a distributed clock or a validation signal.... or a sets of small schedulers on every computers. We quite need to reinvent the same abstraction as an OS for process (with IPC) but instead of being on an OS it should be on a set of computers. It probably requires tools like gaffer or circus, zmq, and a lot of asynchronuous tools. We might have serious issues with time (clock drifiting, monotonic clocks, at some point relativity, ntp ....), so a clockless logic should be cool. I pretty much picture that like an electronic design where we wire process across more than one computer (with messaging), and a state machine to emulate stuff like "on rising edge") Not sure, of what I can deliver :) 
Hettinger and Martelli assume you have programming experience. They would be quite confusing if you jumped right in without first going through something like the MIT course or a Python tutorial. But once you get there, Hettinger and Martelli will teach you idiomatic Python and give you insight into the language design, making it a much more powerful tool than you'd expect given the MIT material.
Why not just this? import this print(this.s.encode('ascii').translate(bytes.maketrans( b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', b'nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM')))
Ah, a fellow two spacer! :) I picked up the two space habit after working with a bunch of Scala code. 4 spaces just feels like too much wasted space to me now. Last night, I was experimenting with... three spaces as a happy compromise D: But I figured that would cause the hard core PEP 8 guys to faint. 
This is a very nice ebook on just this topic: http://www.jeffknupp.com/writing-idiomatic-python-ebook/
Cause it's kinda gross looking ;D And from `import this`: &gt;Beautiful is better than ugly
`this` is the joke.
i picked up indenting with two spaces, along with "comma belongs to the beginning of the line", from some Boost (C++) code. it took some time to think it through between the sight and the application in my own code. Python really does not like the comma thing, but i use 2 spaces for indentation everywhere i have that option. (i prefer to have leading tabs in Makefile rules rendered to the width of 8 columns though ;).
The easiest solution is to render the LaTeX as images and display those in the Tk widgets. There are python libraries that interface to LaTeX interpreters and Ghostscript to generate images. However, a LaTeX environment is a very heavy dependence that is unlikely to be installed by the users. Matplotlib has a simple pure python LaTeX interpreter that uses system fonts to render the output. But it is far from supporting all of the LaTeX constructs and depends on the availability of glyphs in the chosen font. I'm not aware of any other python solution.
Yes, that was the joke. 
i mean stuff like this: return regex_replace( fmt , regex("%[DP]\\&gt;") , cref(expand_sink(prefix, d)) ); 
Django also uses a [Meta class on models](https://docs.djangoproject.com/en/1.5/ref/models/options/). ModelForm's Meta is probably only a side effect of model.Meta.
I would suggest installing the anaconda meta-package if you are interested in they scientific libraries, as it will make sure numpy and everything is using compatible versions. conda create -n environment_name python=2.7 anaconda One confusing thing is that when using a meta-package like anaconda, the versions are explicit. If you happen to upgrade individual libraries and then update anaconda, you'll notice the version being put back to the anaconda defined version. It seems backwards, but it's because each anaconda version is an explicit release of known-good packages. 
I'm not sure why you think conda doesn't fit into an enterprise environment. Using puppet I have no problem managing conda environments and packages. Binstar is a start to solving any reliance on pypi. The next step is an internal enterprise binstar to move the resource in-house. I've used RedHat's pulp project to mirror RPM repos for internal deployment. Binstar appears to be moving the same direction: clone, freeze, upgrade repos/channels. Pulp makes it possibly to show auditors what packages have changed, and those some features would make it possible using a local binstar. This is definitely a place for a paid product, because enterprises have money and the problem mostly exists in enterprises and not out in the OSS world. 
I just double checked and it's [4 spaces](http://google-styleguide.googlecode.com/svn/trunk/pyguide.html#Indentation), not 2. However, this might not have always been the case. If you look at the old `wx` code for App Engine you'll see that it's all 2 spaced (This may come down to developer autonomy though). 
Unless you define the inner class in the `__init__()` method itself (which makes it inner to `__init__()` actually) then no, you can't.
&gt; The question then is, how do I import pyoneer in the test files (&lt;workdir&gt;/tests/...) and have it load &lt;workdir&gt;/src/__init__.py? The default import mechanism requires packages to live in eponymous directories. There's no such logic in the default import mechanism - "import" just looks in sys.path for where to find things. sys.path happens to include "." by default. There's no "mechanism" here. If you aren't using setuptools to import the library locally just set your PYTHONPATH accordingly. Or just run your tests with a runner that inserts "./src" into sys.path. SQLAlchemy has exactly this layout, with `lib/sqlalchemy/` and `tests/` (which I would not have done today, but this was eight years ago), but no special importer hacks are needed to work with this configuration.
You return the class out
?
&gt;omitting them makes the join over a generator comprehension, so it doesn't build an intermediate list In this case it doesn't prevent that because `''.join` makes the list anyhow. Not that it matters; removing the brackets looks nicer.
nose is "odd" as other people have voiced to me. This is not 100% authoritive but a quick difference between the unit test frameworks and nose. With unit-test, you need to build your test suites as a class that inherits from a test harness and then individual methods will use these inherited methods to perform qualifications. So for unitTest's class TesTfoo(unittest.TestCase): def setUp(self): self.myInstance = MyClass() def tearDown(self): del self.myInstance def test_succeeded(self): returnVal = self.myInstance.DoSomething() self.assertTrue(returnVal) With nose - def make_object(): return MyClass() def test_succeeded(): x = make_object() retuvnVal = x.DoSomething() assert retuvnVal == True * nose provides similar setUp/tearDown methodology but I don't use it often. Semi-real/production world examples is a pet project to make a CherryPy like web framework that handles asynchronous/comet connections is txWeb. One part of the system overrides the default GET/POST arguments behavior to be slightly faster/conveniant using a sub-classed dict(ionary) type. The sub class definition is here - https://github.com/devdave/txWeb/blob/refactor/txweb/util/param_dict.py and the basic block &amp; tackle unit-tests are here https://github.com/devdave/txWeb/blob/refactor/txweb/util/tests/test_param_dict.py On opinion side, I like using nose because it's much simpler and requires less memorize ( actual unit tests are just assert statements, if they fail the test fails ). Additionally nose has a plugin/adapter to the coverage system so you can build a html overview of your project to see where unit-test gaps exist at the file,class,method,if/else block levels. *Note I tried uploading a picture of what coverage looks like but imgur has the flu at the moment and rejected my uploads, ask me again in a little bit and I will try uploading them again.
Depends on if join is smart enough not to re-wrap it in a new list. Since it's a standard library function, it's probably optimized as such but you should probably assume the worst in general.
From the first link. &gt; nose wraps or replaces everything in unittest. nose2 does a bit less: it does not wrap TestCases, and does not wrap the test result class with a result proxy. nose2 does subclass TestProgram, and install its own loader, runner and result classes. It does this unconditionally, rather than allowing arguments to TestProgram.__init__() to specify the test loader and runner. See Internals for more information.
also the link to the page i found the code is http://docs.python.org/2/library/socket.html 
You probably don't actually need to use sockets directly. If you're in control of both ends, use a messaging library like zeromq or redis pubsub. It will handle the connection setup, polling, and error handling transparently. Seriously, don't write your own socket code without an extremely good reason. However, you should check that you can actually reach that machine on that port and aren't getting blocked by a firewall. The telnet sytem command will connect to an arbitrary port and confirm that you can get there from here. You can also obviously test with client and server on the same machine.
&gt; it gives me errors. Are they secret?
what is uber?
Nice! - Is from .client import UberClient, UberException, UberLocationNotFound the same as.. from uber.client import UberClient, UberException, UberLocationNotFound Why use a relative import here? - How do you like the 'client-side encryption' Braintree is offering? I like the 'know nothing' technique for handling payment. - Any reason you prefer classes to simple dicts or lists for the models? Good work! :D
Well, the code you copied there has a hostname hard coded in the client: HOST = 'daring.cwi.nl' # The remote host You want to change that to the IP or hostname of your server.
I recommend checking out the raspberry-strogonanoff project -https://github.com/dmcg/raspberry-strogonanoff It achieves virtually the same but uses a 433mhz RF transmitter and does not involve tearing apart the remote. Only downside here is that if you don't get the switcher detailed in the description, you may struggle to find the correct codes. flaskofsoup is also worth a mention here, it uses the code from raspberry-strogonanoff but puts a Flask app on top of it - https://github.com/mastersplinter/flaskofsoup
You also want to change the server side to bind to the correct interface. Use the external IP of the server. 
As per the python manual: the empty string represents INADDR_ANY. So technically, the server sample code above binds to all IPv4 addresses on that host.