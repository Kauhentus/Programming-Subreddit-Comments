Where are you located? Are you in a city where it is very difficult to find a tech job or was that a very appealing option for many different reasons?
Just a quick update for those following this. I have updated the source on Github and refactored it a lot, so it's ready for implementing the OS X and Windows support. There's still a few things that need to be ironed out, but I'm much happier with the layout and structure now. I've also added it to the Cheeseshop (PyPi) so you can install it via `pip` now, although some dependencies will need to be installed manually. See the docs for more info. And a thank you to the people who already submitted pull requests and tickets.
No video? For shame.
I learned python over a decade ago using the official documentation (and Dive Into Python) and didn't find it bad at all. Python's documentation reminds me of a textbook, which makes sense given python's education background. Since it reads like a textbook, it works best when you read the docs section by section, because there is a logical progression to everything. It's not meant to be used with a series of "how to X in python" google searches. Compare: * http://docs.python.org/3/tutorial/index.html (very thorough) * http://php.net/manual/en/tutorial.php (very brief) And: * http://docs.python.org/3/library/re.html#re.findall (very brief, no example code) * http://www.php.net/manual/en/function.preg-match-all.php (very thorough, lots of example code) They're just written in different styles. I wouldn't say that PHP's or Python's documentation is bad, they're just different. If I wanted in depth coverage of a certain module with lots of example code I would look at [MOTW](http://pymotw.com/2/contents.html) instead of the official docs. Similarly, if I wanted to point someone at a good thorough tutorial on PHP I probably wouldn't look at that official tutorial I linked to, I would need to go to some other site.
We're working on it :-) If all goes well, there'll be a video up by tomorrow.
Yay!
Would the raspberry pi be fast enough to do this? It would be cool to make a standalone "sentinel." Even cooler would be to have a way to deactivate it through a password voice command or something like that so that you can have it effectively guarding an area from unauthorized personel. 
1. duplication of effort 2. hard to maintain 3. singular point of view 4. impossible to read linearly (like a manual) SO is like blogs on the internet except it's all on one site. It would be much better to have wiki-style documentation (hopefully with some nice enhancements to both encourage contribution and improve the workflow) with clear guidelines and focus efforts there
That sounds like an amazing idea, and could potentially be feasible. I'd like to see someone who has both a Raspberry Pi and a USB missile launcher try this out. I have half a mind to get a Raspberry Pi myself just for this ... Voice commands are also an interesting idea, though I'm not sure how good open-source voice recognition libraries are at the moment.
Except that Apple now sells music too !
I am familiar with those trademarks. I don't know if there is somekind of "first in first served" rule when it comes to trademarks...
I think you have solved it for the case where you have only made one guess. I considered that a computer could make 1 Billion guesses. Therefore, there is another exponent term. The probability of guessing *at least one right* is therefore one minus the probability of all your guesses being wrong. Therefore, for at least one correct, the probability should be: 1-((36^15 -1e7)/36 ^15 ) ^1e9 So the precision issue comes in to play with this much larger exponential term. 
The deployment workflow they use is very similar to something I do for a *PHP* project. Don't worry, my deployment stuff is in Python. I should migrate to Fabric, seems like a better stack for these kinds of tasks.
That Python docs are not very good at having all necessary information in one place. Compare [this](http://docs.python.org/2/library/urllib2.html#urllib2.urlopen) to [this](http://msdn.microsoft.com/en-us/library/fhd1f0sw.aspx). Python version is a more or less free-form explanation what the stuff does and what you can do with it and stuff. It's maybe better suited to getting an overview of a library, like, when you sit down and read the entire page from start to end, but it sucks as a reference manual, because you _have_ to read a significant part of the page to figure out some little detail that you are actually interested in. In MSDN all pages follow one and the same fixed structure that, when you get accustomed to it, allows you to instantly find whatever interests you at the moment, be that the type of one of the arguments, the list of possible exceptions, or a code example. It's much worse if you're trying to read it through because of all the duplication and structure, but that duplication is exactly what you want from a library reference. It's like RDB denormalization, sort of.
Blender already has python 3 built in, and it should be able to export to the formats supported by cgkit. I think that the maya/python interface is an independent part of the project. Additionally I think cgkit started well in the bad ol days that were Pre-2.5 blender GUI - not exactly the most pleasant experience for those trying to use blender.
Nothing glamorous, but here ya go: http://www.youtube.com/watch?feature=player_detailpage&amp;v=L2It-kK0yfM The tracking's usually quite a bit faster at homing in on the target, but our computers were bogged down and this is the video we've got.
Haven't tried the Pi but if it runs a version of Linux with USB support it should be possible. I imagine the frame rate would suffer a bit like it did in the video but with some code optimization it might be able to run ok.
Civil discussion with who? An IRC chat? That sounds like an amazing idea. Did you try the documentation mailing list docs@python.org?
Well, there's already tutorials for using OpenCV on Raspberry Pi (http://mitchtech.net/raspberry-pi-opencv), and the Python demos seem to run quickly enough. At the moment, the time taken by OpenCV to process images is not the limiting factor for us (capturing the images is), so this might still be workable with the Raspberry Pi's CPU. If not, the image size can always be reduced, which increases speed at the expense of accuracy. At any rate, it certainly seems worth a try.
A wiki is not good for official documentation as it allows for non-experts to possibly poison (accidentally or not) documentation. You can contribute to the documentation via the mailing list docs@python.org. See [About the Documenation](http://docs.python.org/2/about.html) and [Reporting Bugs](http://docs.python.org/2/bugs.html#reporting-bugs)
It exposed a great deal of the game engine. By default it was used for server-side game logic such as round time, ticket calculation and team notifications. The SirCommunity managed to create a mod called "Sandbox Mod" which provided ways to use object spawners, simple game physique, customized in-game menues and more, but I don't remember. Generally Battlefield 2 was great for modding because almost all resources (models, textures, script code) of the default mod where exposed in the "mods" directory.
yes and no. Yes, I agree a plain wiki is not ideal. But, for example, a wiki with approved users who act as shepards and watchers of specific pages would work well in my opinion. This makes it easier to contribute.
Cool idea, I actually did this a little while back but never posted the code. I'm one of the core SimpleCV developers. We are speaking at pycon and I was thinking of actually demoing something like this. In fact I built my own that mimicked the portal turret and demo'd it at the Bay Area Makerfaire (https://www.youtube.com/watch?v=vwzRMAslkbw). Someone had already written a library for the motion control of the rocket (https://code.google.com/p/pyrocket/), it's even in the Ubuntu repos. I just ported it to SimpleCV to use way less code. Because HaarCascades are computationally intensive you can use it to detect the fact then use things like blob tracking to speed things up. I recommend not mounting the camera on the rocket as webcams use crappy CMOS sensors and you get a lot of motion blurring when moving, they should have about 120 degree viewing angle and catch anything that moves in front of it either way, and would probably help with accuracy.
Even if approved users are shepherds and watchers if the any section of the documentation becomes out of sync with reality for any length of time it is a Bad Thing^TM . Making it easier to submit edits would be great, but a wiki is not a good idea for documentation outside of a small internal group (ie company projects).
Cute! Does it still fire through the eye holes? Yeah we snapped our pictures in between movement to avoid the motion blur. It would be interesting to see to what extent you could use other techniques to better track a fast target.
&gt; is my_init needed in your NotifyHandler? Yes, that's a standard usage for that module: [docs](http://seb-m.github.com/pyinotify/pyinotify.ProcessEvent-class.html)
It seems like the python community can't really make up its mind that it wants to commit to python 3. I constantly see python newbies being told to not bother with python 3 yet because the package support isn't there, and on top of that a lot of enterprise linux distros have barely caught up with support for 2.6 let alone 3.
That is pretty nifty. Never heard of it before.
Good points, i moved my imports to the top, changed the config statement to be the single statement, and updated my shitty variable names and yeah, my_init is called at the end of the normal __init__ passing **args and **kwargs iirc.
thats a good thought, this is going to be used in a secure environment (theres only a small handful of people with the IP, and two with the ftp username, and password) but i'm still going to update that subprocess command
i changed that name to input_file, good point
im probably going to make it use an external config file, just because im not the only person who would be adminning this server, and i'd like to be able to add a link from init.d
It has a hard time being both at the same time, though. Postgres doesn't.
I would not blindly trust a benchmark by the creator of the winning framework. For example, how it it possible that wheezy.web is slightly faster than a raw WSGI application (py2.7 uwsgi)? I am sure that some frameworks (including bottle) could perform better with some minor changes (e.g. doing a warm-up request). And that the benchmark results are not reproducible (he used timeit instead of timeit.repeat) But I am still satisfied with bottles results :)
It feels a little like you're asking me to do your homework here, and so I'm not going to just do it for you. 36 ^ 15 is around 2.2e23, easily representable in a 64 bit float. I don't know why you have that number twice in your equation, perhaps that's part of your trouble?
Really? More and more projects are moving or providing Python3 versions. Things take time. I am okay with that.
&gt; Yeah, it's about cost versus benefit. And by benefit I mean quantifiable, demonstrable benefit. And my assertion is, new guy on day 1 is not qualified to even suggest something as risky as scrapping/rewriting. It's impossible for them to prove any quantifiable benefit because they just got there. Maybe a year from now, but not on the first day of the job. I have not been in dev mgmt(thank goodness), but this scenario plays out all the time when I need to get new people up to speed on the project so that they can start contributing quickly. Me: "this is how stuff works..." new guy: "Why are you doing it this way? Framework X is so much better..." Me: "Yeah that may be, but this is what we have right now, and we have deadlines so...." new guy: "We just need to re-write everything in framework X" So now, apparently it is my job to justify every technical decision that has ever been made to new guy in hopes that we can't move past this and focus on what needs to be achieved right now. This is BS, because I have my stuff to do, new guy was hired to contribute, not slow me down. And if new guy ends up spending the majority of his time wasting mine and reinventing wheels, sooner or later, I'm going to be telling my boss to get rid of him because he's not helping. And we're not in the business of subsidizing someones technical experiments, we're in the business of delivering features that customers pay for. 
It looks like you're still off by a decimal place. I get 4.52e-8, not 4.52e-7 as you reported: &gt;&gt;&gt; from decimal import * &gt;&gt;&gt; getcontext().prec = 100 &gt;&gt;&gt; x = Decimal(1e7) / Decimal(36) ** Decimal(15) &gt;&gt;&gt; N = Decimal(1e9) &gt;&gt;&gt; 1-(1-x)**N Decimal('4.52337380477244100828349978740219658983132372909327646762029243111941054809705876964310942795E-8') Did you notice that this number is almost exactly the same (to ~6 decimal places) as simply x times a billion? &gt;&gt;&gt; x * N Decimal('4.523373907076996879564824202074273670504041287997110026731804714541379157473246609398964699786085931E-8') That's because: p = 1-(1-x)^N (1-x)^N = 1-p ln((1-x)^N) = ln(1-p) Nln(1-x) = ln(1-p) N = ln(1-p) / ln(1-x) # Maclaurin series expansion of ln(1-x) = -sum{n=1..Inf, x^n / n} N = (p + p^2/2 + p^3/3 + ...) / (x + x^2/2 + x^3/3 + ...) # since x and p are both very close to zero, drop higher order terms as they are extremely small N ≈ p / x p ≈ x * N So you can skip all of this arbitrary precision decimal module stuff: &gt;&gt;&gt; 1e7/36**15*1e9 4.523373907076997e-08 It's not exact, but it's pretty close. 
Interesting, thanks for sharing! My value was different than yours by a factor of ten because I used the 100M estimation of cards in circulation according to this: &gt;Changing assumption #2 from 10 Million to 100 Million provided an estimate of 0.00000044
I like that all of their apps are opensource. That's awesome.
No, but python. The sourcecode was leaked a while ago.
It doesn't matter if you divide through. You get `1-(1 - 1e7/36**15)**1e9` instead. That is still not computable with standard floating point types as they lack the necessary dynamic range to accurately represent the value `1 - 1e7/36**15` which is along the lines of `1 - 4.52e-17`, or `0.999999999999999954766...`. 64 bit IEEE floats can only represent about 16 decimal digits of precision, but at least 17 or 18 are required to even approximate this number. In other words, it's too close to 1.0 to be representable, and the result will be rounded to 1: &gt;&gt;&gt; 1 - 4.52e-17 1.0 If you continue with the exponentiation you get 1, a nonsense answer. The precision is lost and is irretrievable. Subtraction is always very dangerous when using floating point types. If the two operands have wildly different exponents, the result can be utterly meaningless as all the significant digits have been lost. 
Newbies should be told: "Need a specific lib only compatible in 2..use 2. Otherwise, use 3." Easy.
The problem with that is: you start a project, it doesn't seem like there are any libs you need that are only 2, so you use 3. Then some time in the future, maybe later that day or a year later, you need a lib that's only compatible in 2. Fuck.
Maybe look at [Kivy](http://kivy.org/). It is very easy to install on various Linux distros (e.g. PPA for Ubuntu and so on).
Very True. Blender has truly evolved in leaps and bounds since then. Well it accepts most file formats anyway so there is nothing hindering using it with Blender.
So the idea here is that they're creating static file deployments of microsites and dropping them into S3 buckets? 
Hey Brian, great writeup, thanks, I could not potentially say it any better. I find myself in a similar position to this guy when trying to learn another language, which does not support &lt;feature X&gt;. A good example of WTF was learning that ruby does not have a builtin debugger that is as good as pdb or gdb. This guy comes from the PHP side of things, where the docs have a very specific format. Note that in PHP, nothing makes sense, but there is a function for everything. So obviously if you want to do something you look it up on google, where you'll be pointed to function-oriented documentation, that's pretty good, including examples. In Python it does not work that way, for a variety of reasons, but mostly because there are very few things that require constant look for documentation (with a few stdlib modules that are notable offenders, like os.path or tempfile, but it's all in-progress or in-discussion to get fixed already). Instead a combination of guessing/help builtin/docstrings and tab completion can get you very very far. Now maybe something constructive would be to have a sort of wiki-style for python docs, where you have a link on each function that leads to a URL (that helps googleability) where people can add comments/examples how to use it? I'm just guessing here, but it's definitely worth discussing, even if noone would immediately jump to implement it. Cheers, fijal
I've had some good experiences with Jinja, HTML template using Python. And if you are looking to turn this into a bigger project you could look at Django.(Although the latter if for running web apps instead of just template) http://jinja.pocoo.org/docs/ https://www.djangoproject.com/
I can see CPU graphs being say 2hz. Otherwise, every graph I can think of displaying would be live but slow on updates.
I use Flask for my work projects. It's great and fast. 
it does :)
Jinja is a good start
Realistically, if there's functionality that you don't know you need until a year in, it's probably not so critical that you can't use a slightly suboptimal solution.
I find [this](https://python3wos.appspot.com/) to be a more accurate representation of the state of python 3 compatability. Even if all the super-popular things are ported, it only takes one single mission-critical package to make it unusable. Some key ones for me are: Twisted, PIL/Pillow, python-ldap, and reportlab.
How do you know there's always going to be a "slightly suboptimal solution"? In most cases, I would say the solution is very suboptimal, if there is a solution at all. I don't think your scenario is particularly realistic, it certainly seems rather incongruous with the Python development realities I've experienced in my career so far. For example, say a new requirement has come up that the application must be able to read user data from an LDAP directory. If your application is built on Python 3, then [here are some suggested solutions](http://stackoverflow.com/questions/1982442/does-python-3-have-ldap-module) and I consider those a little bit more than "slightly" suboptimal. In my case, the offered solutions would be to rewrite the entire application for Python 2, or drop cross-platform compatibility and maintain my own LDAP-ADO wrapper, or try and port a library myself. Great options.
My friend wrote a 'tweetboard' in kivy for a party he hosted. When people tweeted a certain hashtag, it would get added to a queue and then displayed on the screen (he had a HD projector and it looked niiice). Suffice to say it was a hit! Oh and he was able to hack it together in like a week.
That thread is over three years old. Isn't [this](http://permalink.gmane.org/gmane.comp.python.ldap/847) from two years ago a version of python LDAP that works on python 3 on Linux?
An unreviewed patch for an outdated version of python-ldap that is two years old and still hasn't been merged [or even seriously discussed](http://thread.gmane.org/gmane.comp.python.ldap/949/focus=950), and [which the author says is only for testing purposes](http://article.gmane.org/gmane.comp.python.ldap/1025/match=)? Yeah I think I'll pass on installing that into production software, thanks.
I understand your points, however I appreciate the happy accident of MCEdit and Python. I only picked it up to learn Python and am now enjoying using it a great deal.
Very cool, and it's just like NPR to make all of their code open-source :)
Use logs, and especially use log1p(x) := log(1+x), which is appropriate when x is small. ((36**15 -1e7)/36**15 ) ** 1e9 = (1- 1e7/36**15) ** 1e9 = exp(log((1- 1e7/36**15) ** 1e9)) = exp(1e9 * log1p(-1e7/36**15)) &gt;&gt;&gt; from math import log1p, exp &gt;&gt;&gt; exp(1e9 * log1p(-1e7/36**15)) 0.9999999547662619 &gt;&gt;&gt; 1-exp(1e9 * log1p(-1e7/36**15)) 4.523373808851261e-08 Compare this to the Decimal solution of: &gt;&gt;&gt; (1 - Decimal("10000000")/Decimal(36**15)) ** Decimal("1000000000") Decimal('0.9999999547662619522755899171650021259') &gt;&gt;&gt; 1-(1 - Decimal("10000000")/Decimal(36**15)) ** Decimal("1000000000") Decimal('4.5233738047724410082834997874021965898E-8') The key computation, giving 0.9999999547662619, matches exactly. You can see that the biggest error using floats come from computing the final 1-x where x is very close to 1.0. Of course, as Rhomboid points out, you could use the observation that (1-x) * * p is very close to 1-p *x when x * p is small (as is the case here) and approximate the answer as &gt;&gt;&gt; 1-1e9*1e7/36**15 0.9999999547662609 &gt;&gt;&gt; 1-(1-1e9*1e7/36**15) 4.523373908771333e-08 &gt;&gt;&gt; 1e9*1e7/36**15 4.5233739070769966e-08 The key line is again the 0.999...609 part, which agrees up until the 2nd-to-last digit with the other two approaches. And again, it's only the 1-x calculation which gives floats a problem across 16 powers of 10. 
that actually pretty cool! is there a video of this somewhere? What I wanted was a general display with clock, some graphs showing some statistics of the particualr machine itself, some stats gathered from other servers and applications (eg, I am working on a reddit mining mission, I'd like to see in near real time, how fast each of the tasks are going), and perhaps the output of a log file or two. But, I want it to look SLICK, as if a square rimmed glasses wearing guy made this. I figure this is a good, small, simple project, to gain some graphic-related skills and experience.
The original poster never saw Perl documentation if he thinks the Python documentation sucks (joking aside because CPAN is an awesome module-website with almost always very good documentation) but I do agree on the fact that sometimes in Python you just want to have a function, you do not want to learn about the different types, twenty other functions that are also included in the package sys before you reach the function you need. When I was a beginner in Python I frequently asked myself what the author of a module meant with his sentences (they were not always that clear). As soon as I read somewhere that you could use the command pydoc I would just receive lists of methods and the guessing about which function was correct could start. PHP is also one of the best documentated languages (in my opinion). The template handling a function is really short and brief but also provides all the information needed. But as every community, even PHP dev's are hostile, you just encounter them less because you got a very good documentation website.
Are the Google rankings of pages on docs.python.org directly under control of the Python communities cited by the original source? If they change their structure, is that going to change what comes up in the top-5 results, or would it still be up to linking pages to "vote" on what was useful?
And you wouldn't know this, being a newbie. I think in many ways it's ok to make it a problem for future you. The absolute worst case scenario is that you have to learn enough Python 2 to use the unported library.
Full disclosure, I don't know who Brian Curtin is. I agree with this post almost entirely, but he made a few attacks on the rant rather than what he was saying, which didn't really help his credibility. Borderline passive aggressive there, not really convincing me of the objective nature of the post. For almost every point OP makes, he mentions either that the ranter wasn't respectful enough, hasn't spent enough time with the language, was just talking for the sake of it. 
I suppose if they didn't they have "taxpayers" complaining about not doing it. It's a bit of a catch 22.
The range was [-5, 100] at one point and that one may have been arbitrarily chosen. But when the `bytes` object was introduced, [the range was expanded](http://bugs.python.org/issue1436243) to all possible byte values.
Another possibility is to make it a website with [Flask and Server Sent Events](http://peter-hoffmann.com/stackoverflow/12236019.html). For graphs there are some really nice JS libs too.
Even if that's true in this particular case, the overall point still stands.
Be very careful with this email regex provided: emails = re.findall(r'[\w\.-]+@[\w\.-]+', str) This won't match emails with underscores or pluses, both of which are legitimate. The problem is a lot more complex than it seems on the surface. http://stackoverflow.com/a/201378/183948
I had thought about that, I felt limited. for example, I think it would be neat to have some lighting effects. The cPU graph could start to glow rather than just get redder you know?
Came here to say this.
The type of person who would make that complaint doesn't know what source code is.
I always thought [this](http://rationalwiki.org/wiki/Lenski_affair) was the best example of taxpayer access to public works.
As others have said, if you have really fast data this may not be the best solution, but I've use PyQt4 for stuff like this. For my job I created a PyQt4 GUI that displayed data at ~0.5 second intervals with up to 15 plots showing at once. I used matplotlib to make the Qt Widgets and used their blitting functions to speed things up a little. I also made it so it updated the line every new tick (data point), but only updated the y-min/max every 10 or so ticks. It works really well.
Ideally that will motivate said person to port the library you Python 3. That is exactly what we need to make the transition.
* http://docs.python.org/2/py-modindex.html * http://docs.python.org/2/library/itertools.html * http://docs.python.org/2/library/itertools.html#itertools.product * http://docs.python.org/2/library/&lt;modname&gt;.html ... * http://sphinx-doc.org/latest/ext/viewcode.html 
If I figure something out in python - besides stack overflow where I post a question and answer it. Is the place to submit an idea for an example to add in the python docs is as a bug?
Came here to say this, striking similarity.
This is just silly.
&gt; where you'll be pointed to function-oriented documentation, that's pretty good, including examples. Sure PHP may have it's drawbacks - but this is the key sentence right here. Sure, some of the comments are old or out of date, but usually they point out something to watch out for or a quick tip. The earlier can save you hours of hair pulling of trying to figure out why X won't work only to stumble upon a buried mailing list post saying "that's how it's supposed to work - but here is a way around it". jQuery is a perfect example of this. On their ajax page they list out all the options and what they do - and they have a couple of blurbs on cross-domain AJAX but they never tell you how all the pieces go together. After several hours of combining mailing list posts - I can tell you it is very much possible to do cross-domain AJAX requests using any dataType you want.
I asked in /r/learnpython earlier but got a little impatient, thanks for the tip on stackoverflow
Thanks for the reply! I will try this and report on the results Could you elaborate about set_radius? 
Or bottle.py
Actually, this is quite as funny [django-annoying](https://bitbucket.org/offline/django-annoying)
But the great weakness of flask is that if the project grows large, it will need to be rewritten from scratch in Django. This looks like it could allow a flask-like project to be quickly created, but then organically grow into a full production Django application.
Hey, I am the author of the project, and I have heard about flask, and bottle etc. I do love them, but the thing is I have good knowledge about django, which I will give up if I switch to flask etc, knowing two frameworks inside out is a wastage, and django is indeed "harder" compared to simplicity offered by flask/bottle. So I created importd to retain all my django knowledge, and yet build simple one/two page apps or API servers with a single file.
Actually a `.` in a character class is a literal `'.'` character. So for example `re.findall('[.]+', 'hey... man....')` will return `['...', '....']`.
 #!/usr/bin/env python import time import sendMessage #main (This is the start of your program) print sendMessage.show_Full_Time() #This is just for personal reference, so you can look at the prompt while the program is still running and see about how long it's been. start_time = sendMessage.get_Time() #Do something, body of code time.sleep(300) #code is complete: time to send alert print sendMessage.show_Full_Time() sendMessage.doneTextSend(start_time, sendMessage.get_Time(), "Demo Process") And that's about how I'd use the program. I only imported the time function into this .py file because I wanted it to wait a period of time. In reality that portion of my code is actually useful, but we're ignoring the boring parts of reality here. Hope this helps!
&gt;But the great weakness of flask is that if the project grows large, it will need to be rewritten from scratch in Django. That is definitely not true. Flask projects can truly be of any size and still be maintainable, especially with Blueprints and other useful features and third party plugins. Now, as for whether a big project is easier/better to write in Django vs. Flask, that's a different debate.
Is the textual interface local or over the network?
It works! Here is the updated code: import numpy as np import matplotlib.pyplot as plt from matplotlib.widgets import RadioButtons t = np.arange(0.0, 2.0, 0.01) s0 = np.sin(2*np.pi*t) s1 = np.sin(4*np.pi*t) s2 = np.sin(8*np.pi*t) ax = plt.subplot(111) l, = ax.plot(t, s0, lw=2, color='red') plt.subplots_adjust(left=0.35) axcolor = 'lightgoldenrodyellow' rax = plt.axes([0.025, 0.1, 0.25, 0.75], axisbg=axcolor) radio = RadioButtons(rax, ('2 Hz', '4 Hz', '8 Hz', '12 Hz', '14 Hz', '16 Hz', '18 Hz', '20 hz', '22 Hz')) def resize_buttons(r, f): "Resize all radio buttons in `r` collection by fractions `f`" [c.set_radius(c.get_radius()*f) for c in r.circles] resize_buttons(radio, .25) # shrink your buttons by some factor def hzfunc(label): hzdict = {'2 Hz':s0, '4 Hz':s1, '8 Hz':s2} ydata = hzdict[label] l.set_ydata(ydata) plt.draw() radio.on_clicked(hzfunc) plt.show() Unfortunately it is still more like an oval than a circle
I feel like I missed the joke, reading through it there's some nice convenience functions. Edit: I'm tired and I read 'eliminate' as emulate. Hence my confusion.
Honestly, I'd say it's mostly about aesthetics. Some people think Mako's syntax is less consistent than jinja, whereas I find the Mako syntax more concise and intuitive. FWIW I really like the way Mako's template inheritance works.
Sure, start creating a CMS, then in 4 years time there'll be a post to /r/php about the shitty CMSes that we have in Python from the guy who replaces you. Get a real CMS and configure it, whatever you do don't write your own ball of string CMS.
I have no idea why you have been down voted so much for this. 
This is awesome. Thank you for bringing the only thing I love about bottle over to my favorite framework. 
8 years? I'm not getting something here: if the call for 1.0 was 8 years ago, how did stuff like the notebooks and the qt console get added?
"It's not that bad, look at the guy over there, it's even worse!" is never a good argument.
Are you looking for something like this: http://www.wanware.com/tsgdocs/snack.html ?
There are [PyBrain][] and [NeuroLab][]. [PyBrain]: http://pybrain.org/ [NeuroLab]: http://pythonhosted.org/neurolab/
Sorry, I did forget to mention that. It is accessed via telnet.
knowing two things inside out is surely better than knowing just one thing inside out!
I agree with you in the long run, but time constraints are a real thing.
ah, so i misinterpreted “The Big Cleanup” as being some sort of code freeze, while in reality it only meant a new branch where the underpinnings were seriously reconfigured, while new features were introduced in both 0.x and 1.x branches? if that’s the case, it must be really a lot of effort to keep that in sync. or assumed i wrong again and it was totally different?
You may want to have a look at another implementation of logic programming, which I wrote: [pyDatalog](https://sites.google.com/site/pydatalog/). 
&gt; #!/usr/bin/env pytHEIGHTon ???
I guess the idea at the time was that there would be some kind of code freeze, but it didn't happen - or at least the release didn't end up being called 1.0. There was another discussion about making a 1.0 shortly before 0.11 or 0.12 (I forget which), but we didn't go for it. This 1.0 will be a bit like Linux 3.0 - it doesn't mark some massive architectural shift (that came in 0.11). But the current minor release numbering is starting to get a bit silly.
That depends what it is - an example for e.g. `len(x)` would probably be rejected, because the structure of the docs makes having dozens of examples awkward. But for more complex cases, clear examples are encouraged. E.g. [examples for the re library](http://docs.python.org/2/library/re#examples).
Have you tried [telnetlib](http://docs.python.org/2/library/telnetlib.html)?
Is there a way to have auto-reload? EDIT: see https://github.com/amitu/importd/issues/3
I really wish someone at the IPython team would do a release of [pyreadline](http://ipython.org/pyreadline.html) that supports Python 3. I use IPython from the console under Windows and it works great with 2.x, but without readline support using 3.x is painful. From what I can tell the work has mostly already been done, but there's been no release. 
oops, an incorrect find-and-replace
at least there will be `IPython.kernel.inprocess`. but in the 0.1.3 branch, `import kernel` says it’s now in `parallel`… there’s so much i don’t understand about the exact part of the ipython api i want to use :D
I will say that's one thing I loved about PHP docs, was the comments. Usually the comments had a couple really good examples of how to use the function in a block of code. Or they might contain information on how to install/setup the needed lib to gain the functions. I even remember a few times were comments would point out gotchas, like "make sure to tweak this setting in the php.ini".
Any way we can still get into this for free? I am very interested, but am a college student myself. Hoping to use Python in my honours thesis though.
nobody got a vid, but we took some photos of it in action, I'll dig them up. and as far as looking slick, kivy is pretty flexible, take a look at their demo page for some examples. it would prolly take you more than a couple weeks, but then once you learn kivy you could also write a cross-platform app and make a little extra pocket money
&gt; but mostly because there are very few things that require constant look for documentation "Python documentation sucks because we don't need documentation" is a novel argument, respec bro. Compare [this](http://docs.python.org/2/library/urllib2.html#urllib2.urlopen) to [this](http://msdn.microsoft.com/en-us/library/fhd1f0sw.aspx). Python documentation is a free-form explanation of what stuff does. That's good when you're getting acquainted with the module and read the stuff from top to bottom. But that sucks as a reference documentation, for when you want to find out the types of the arguments or the return value, or which exceptions the function throws, or code examples, or supported library versions, or whatever. MSDN shows how reference documentation is done properly: you have a fixed structure that _all_ help pages follow, and when you're accustomed to it, you can immediately jump to the section that contains the information that you want. Sure, there's a lot of extra structure, and a lot of duplicated information between functions, but that's _exactly_ what you want from a library reference, it's like a denormalized database, if you will.
I actually know the guy who wrote the original rant, and he actually do a few languages. So yeah, you are wrong on that one.
I miss occur_check, indexation, cut, meta_programming, etc. I find all these pseudo-implementations of logic programming that do not build on the Warren Abstract Machine and all the already existing knowledge on implementing LP to be nothing but toys. Sorry.
thanks tastycat, your comment is very helpfull
Tanks all ! "tastycat" comment was most helpful. 
PyReadline is really Jörgen Stenarson's project - the other IPython developers don't even have commit rights on it, as far as I know. Most of us don't use Windows day to day. I think Jörgen's quite busy, but if you get in touch with him and offer to help sort out a new release, I'm sure he'd be interested.
OP wants a tool to drive a text-based interface. Looks like Snack creates them.
That's so much more eloquent than my planned reference to the episode of Married With Children where Kelly studies too much and forgets her dad's football record because she ran out of room in her brain.
They approved it but then they decided it was too expensive to keep me around. Sadly this job was shortlived.
Is there an implementation of logic programming in Python which includes the features you listed? If not, where can I learn more about them?
From time to time, there's an announcement "Firebird available for &lt;put-name-here&gt;". Can someone using firebird share why use this database instead of any other?
&gt; Rite of Passage FTFY
FWFM?
I am not sure what that means. :(
Heres a good reddit post about firebird. http://www.reddit.com/r/programming/comments/8fq27/why_so_few_developers_are_using_firebird_sql/
I found this after quick googling: http://stackoverflow.com/questions/1635273/postgres-vs-firebird. Rather discouraging…
That is an old article here are my answers point by point http://www.firebirdnews.org/?p=5548
I'd try this first
&gt;Unfortunately, the IRC channel isn't always known as one of the most friendly places to find help. Understatement.
Here is the direct link to the django firebird download: https://pypi.python.org/pypi/django-firebird Here is the tweet that announced the release: maxirobaina &gt; django-firebird (fdb driver) now available for install from pypi. Just run: pip install django-firebird #django https://twitter.com/maxirobaina/status/304636118069018624
Yuck. I do not like this idea at all. Every time you access the dictionary -- even if you know the key you're looking for -- you have to search through all the keys, turning a nice O(1) data structure into a O(n) slug. Exact lookup and substring searching should be separate operations, not mashed together as one. Besides, you don't need a whole class for that -- it's very simple to achieve the same thing with a simple list comprehension: &gt;&gt;&gt; d = {'foo1': 10, 'foo2': 20, 'bar1': 100, 'bar2': 200} &gt;&gt;&gt; [d[k] for k in d if 'foo' in k] [20, 10] Or perhaps slightly more efficiently: &gt;&gt;&gt; [v for k, v in d.items() if 'foo' in k] # use iteritems() for 2.x [20, 10] If you find yourself needing to do that in more than a couple places, put that line in a function; don't take over all dict lookup operations. 
This is pretty friggen cool :)
You should write it yourself. Anything you get off the shelf will be slightly different from how you would want to use it, and the exercise of writing the pager will help you become a better coder. It should be pretty simple, just a couple of hundred lines.
Would I be too obtuse to ask for the source, or should I try a different angle?
It's a case of horses for courses. Django is easier if you're going to stick with their models, views and templates. When you start needing more/different components, then it's a lot easier to cherry-pick the ones you want using flask.
Is there any reason other than having a decent programming exercise not to just use your normal pager? e.g. cat &gt; ~/bin/tips.sh &lt;&lt;EOF #!/bin/bash find -type f ~/tips/ | egrep -i "${1}Tips.txt" | xargs less EOF
It's just reading a file and doing an API call. What's the big deal?
Is it? How so?
I didn't expect paragraphs. At the very least, I expected complete sentences. 
I don't think the theme of this game is going over well with people. Seems like blaxploitation.
Great job ! I've long thinking of something like this. How do you get away with problem that django [require models.py][1] to exists ? [1]:http://www.reddit.com/r/django/comments/rgvmy/more_usable_django_in_single_file_than_commonly/c45pku0
I did't see any good arguments to use it over any other db
I thought people would be more respectable to a game written in Python albeit with a gay theme. 
It's not exactly 'some kind of software,' but part of the normal Python distribution. If you don't have Python installed, I'm puzzled at why you need easier access to its docs. Opening a browser and doing a search for modulename is not fewer steps than 'pydoc modulename'.
But Python doesn't have that many issues where I need an old comment to save me from pulling my hair for hours, because it's more or less rational and the docs already contain most warnings that apply to the stdlib. I don't see how this is helping anything unless we are going to get into a volume of specific proposed changes to docs for specific modules. Python doesn't need to have PHP-style docs because it's not PHP.
There are an increasing number of libraries which only support Python 3, and are bound to be more as time goes on, so the argument can also be made in the other direction. Unless you are talking about specific libraries, which are the only good reason to commit to Python 2 only for brand new projects. But that implies you already know what you will need. I don't believe this is a really common or likely scenario, that you will be absolutely clueless of a hard requirement for some library in one year.
Which Python frameworks aren't fast?
Or you could watch this video and learn from Ian Bicking. http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2011-javascript-for-people-who-know-python-4900851
this isn't, by any chance, publicly available is it?
Yeah, that's why games with busty women (not just adventure games mind you,shooters, beat'em'up, RPG, strategy...) never go over well with people, because it's expolitation of women.
Thanks ! :) I needed something like that.
urllib2 in this code is only used for including headers, which I think if does a lot better than requests. Also, I didn't know someone makes this every week, but does it really matter? I thought it would be a fun project, so I made it.
This is giving me horrible flashbacks to my time in GIS working with MapBasic. Ick. Good work though!
I wouldn't want to have a close minded friend like you either. 
What can be interesting to us as python programmers on this site? I didn't find anything tech related, just a product website.
Wow, never thought I'd hear something like that from a python dev.
You should check out Charles Karney's fast-and-accurate [GeographicLib](http://geographiclib.sourceforge.net/html/index.html); it has C/C++/Javascript/Python/MATLAB bindings. 
I personally use CoffeeScript which is very similar to Python in syntax.
Anybody calling themselves 'a Python programmer' who requires a foot into another language (especially one so completely similar as JavaScript, i.e. interpreted, loosely typed, etc) custom made for their 'native' language is a terrible, terrible programmer, and should not be allowed near any codebase of more than trivial importance. Programming is never about how many languages you know, it is about the fundamentals all or some languages have in common. A selection sort works the same whether you are implementing it in C, Python, JavaScript or even Basic. Sure, there are quirks you need to learn, but at the end of the day any competent programmer should be able to code in xyz unknown language in a couple of weeks max, and be considered fully accomplished within a couple of months.
A blog post explaining the technology used to build the game (i.e. Pygame? How are the binaries packaged? Other libraries?) and so on would be very interesting. As it stands now, I agree with other comments that there's nothing really Python (or programming) specific here - just commercial promotion.
That page needs an update , in fact i edited some of the missing links and old info For what i think about Firebird vs Posgtresql i exposed into this blog post http://mapopa.blogspot.ro/2010/10/where-firebird-is-better-than.html This can be only a starting point a better view is doing benchmarks , tunning so i invite you to test it on your own data and workload For what customers think i guess you can get some help from google https://www.google.com/search?q=why+firebird For a customer quote Norbert Saint Georges wrote :"Thanks to Firebird, the memory and processing space has been reduced with two thirds when migrated from MSSQL to FirebirdSQL ." http://www.firebirdnews.org/?p=8296 Why don’t everybody switch over to Firebird? :-) https://plus.google.com/u/0/b/111558763769231855886/117974351240450919837/posts/2igbrrrkddk
In a randomized order. Try making sense of it when you have no good idea of the context each text block belongs to.
This is very helpful for someone who is new to TDD- does anyone else have some particularly good Python testing tutorials/examples?
Yeah it's pretty amazing what you can do with the aid of a decent JS debugger.
I'll definitely have a look; the Python package says it's a translation of the C++ code though, not a binding?
I don't think there's any disrespect, there's just not a lot of value in this link for tech-people.
That's a good question, you may be right. I have only used the MATLAB version, which is MEX-wrapped around the C++. 
I don't know, I just learned python and wanted to try making something. I guess it's pretty useless.
I used to have it set for full sentences, but most of the sentences in that book are too long to tweet, so I relaxed that constraint. After reading this comment I added it back again. 
this is not what I said, you're not arguing with me. for what is worth I find MSDN absolutely horrible to use - it's impossible to find what you're looking for and it contains tons of useless boilerplate. This is just an example interpretation - it's really a very subjective topic.
For me, it's very Windows friendly. When I first looked around for a good OSS DB a few years ago, PostgreSQL wasn't available on Windows, MySQL was a bit shoddy in it's data integrity and sqlite was weak on it's processing (i.e. no complex scripting, fair enough, not it's target). Firebird had a long history (via Interbase) and a simple install. The FbEmbed version also means it can scale well from simple stand-alone setups to fairly heavy dedicated server systems. It's not perfect (I'd like per-database user accounts for example (coming in FB3 I think)), but it is simple and clean. The support mailing list is pretty good too.
Sorry, but I feel like talking to a car seller who doesn't listen to me. The top two answers on the page I linked doesn't mention speed or features, but drawbacks and glaring omissions in the basic design of the database. Could you comment on at least the things mentioned in the top-voted answer?
Or just use PyPy. It's even faster than the C version due to lack of conversion between args. Why do people do that to themselves.
No, nothing does this at all. Always write your own code; other coders generally write only trash and their crap is full of bugs.
Brace for requestards.
Nice. There's a reason people prefer Requests. If you need the power of urllib2, then Requests isn't the right tool. For 95%+ of use cases, Requests is vastly faster to write and has a tiny fraction of the learning curve.
Requests is awesome, and I wrote about it in a previous post ( http://bit.ly/YLHDey ). However, urllib2 is still widely used. 
Well, at least you're honest. I've got a pretty thick skin, but I guess I just don't see the point in alienating a segment of the Python community whose only sin seems to be trying to use and write libraries that are more intuitive than what we have today. If you disagree, that's fine. For those of you that agree, I urge you to help support the authors of these types of projects on [Gittip](http://www.gittip.com). [Here's the Gittip for Kenneth Reitz, the primary author of Requests](https://www.gittip.com/kennethreitz/).
Because people don't donate enough to the py3k project at http://pypy.org/py3donate.html (and I don't have $50k to spare). I don't see a reason to stick around in an obsolete language if I don't have to, and even a simple FFI implemenation in C gives enough speed that it will not matter for another couple of years, at least. PyPy is amazing, and when I _really_ need speed I've used it, but for general purpose programming, I'll wait for 3.2 compatibility.
Thanks =) Not so many years ago most geodata came in ancient and proprietary database formats, and every imaginable projection. At least these days there seems to be a larger movement towards homogenization of data.
The thing is, how can we possibly appreciate what you have achieved if you give us neither your code nor any information about your skill level?
Oh god I lol'd.
Installing it isn't the problem! There are a myriad of ways to install python modules. It's the management of the modules, the lack of support, the possibility of needing to create a fork and *then* manage that. It's not just about installing a module.
I couldn't disagree more. One of Python's greatest strengths is its ability to draw upon the work of others through abstraction. `import antigravity` anyone? Given a choice between including a mature library and writing functionality myself, I'll choose the library *every time*.
I am clearly missing something important. How is any of this meaningfully different from what can be done with standard data structures? membero seems like an awkward wrapper around set intersection. Why re-invent the wheel? Facts is a bi-directional dict? That's kinda cool I guess. Can someone point me towards something to read that puts this library in context? I'm lost, here. 
Nothing at all to do with what I was saying.
This is the right way to do it. In my experience, the best way to get things done in the face of a corporate bureaucracy is to start with something tiny, prove its value, then grow it. Move that PHP crap to Git. Use Sphinx to document the existing code, and set up commit hooks that automatically build the docs with each commit and expose them via gunicorn or similar lightweight webserver. Then use the easy deployment of the documentation to show how easy and reliable deployment can be when compared to the existing process fo the actual application. So on and so forth...
Yup. Did you read the others? All of them start with "I am making the world better by..."; while it is slightly pretentious, it is unlikely that Kenneth chose it himself.
What's with the grandstanding? Are you saying this tutorial should not exist? What is wrong with having a guide that relates the two languages? Who is saying they "require" this tutorial in order to learn Javascript? It just sounds like you're using this as an excuse to rant about something completely unrelated.
The beta might be ready by pycon. Also, seriously, if the porting to python 3 is as easy as advertised, having small stuff running on python 2 shouldn't be a problem should it?
It wouldn't, except for the added complexity of having extra venvs for the code that runs python 2, extra mirrors for python 2 packages, and generally more complex production environment that is not really acceptable for small gains. Also, I timed it. Even running PyPy, the C version is consistently faster, although by just 40-50% $ pypy -m tests.test_distance Time elapsed for 100000 calculations in Python: 188.62 C: 129.09 Factor: 1.46 $ python2.7 -m tests.test_distance Time elapsed for 100000 calculations in Python: 1908.58 C: 297.00 Factor: 6.43 $ python3.3 -m tests.test_distance Time elapsed for 100000 calculations in Python: 1862.03 C: 305.62 Factor: 6.09
In that case may I suggest complete sentences who's length are less than or equal to MAX_TWEET_LENGTH? 
you should run newer pypy, someone was reporting 2x faster than you. what are you using?
My biggest peeve with the Python documentation is that it doesn't tell you all the exceptions a function may throw. It is documented very inconsistently... I complained a long time ago about it here: http://stackoverflow.com/questions/6283757/python-and-exceptions
Good for you for making it. But curl ftw when it comes to this stuff
Apparently you have no idea what REST means. **UPDATE** Look at [curlish](http://pythonhosted.org/curlish/) and [httpie](https://github.com/jkbr/httpie/blob/master/README.rst). These are tools that *actually* provide features to support working with *RESTful* APIs.
but then I have realized http://www.pythonforbeginners.com/python-on-the-web/using-requests-in-python/
&gt;Python or Ruby would be poor choices for an interpreted language on the browser, since they are general-purpose languages Why does the browser diverse a domain specific languages while other things dont? 
How has your experience been interacting with native JS? I've convinced myself that I need to learn proper JS before moving on to the candy.
Hmmm, if image capture is an issue, then look at their new cameras coming out. They have a decent camera that connects directly to the GPIO, which should be quick.
When writing CoffeeScript, I still have to debug the JavaScript code in the browser (unless you use source maps, which I haven't tried), so that helped me a lot in understanding it. Also, sometimes I would need to write some JavaScript in the HTML file itself, so you're constantly exposed to it as you go, forcing you to learn it while using CoffeeScript for the bulk of the work. If you're like me, you're probably going to end up translating snippets of JavaScript from the web to incorporate them into your code and this manual translation will keep you aware of the type of code the compiler generates. I would definitely suggest starting with CoffeeScript since it's much faster to develop with if you want to get something done while learning JavaScript as you progress. However, if you're interested in learning JavaScript for the sake of the language, then you should go for that.
You never get specific on what Python should do, other than be more like PHP. For example, you just said Python's language reference isn't proper (how?) and it's not usable as a reference (why? What does this even mean?) Since you are not offering any specific or constructive suggestions, this leaves everyone to guess at what they might be, if you even had any. The docs PHP puts out front are task-oriented narrative with piles of examples and comments - more like recipes or tutorials than language reference. This is hand-holding through individual tasks. And there is an important role for that kind of documentation. But Python doesn't do it in the core language docs, and this is a defensible decision. PHP puts it in the core language docs, but that doesn't mean Python has to. Again, I don't think it is necessarily the responsibility of a core language reference to hand-hold you through individual tasks with loads of little example snippets and comments. If that is good for PHP and for you, fine, but that doesn't mean Python is terrible for not doing exactly the same thing. Because Python has abundant good material of these kinds outside the core language docs, in pydoc and on various websites. The only reason you excluded these from the scope of your discussion is that they kill your thesis that Python is inadequately documented. Python's reference docs are perfectly proper and usable as a reference. 
I may be confused but I think this is what you want: Open the settings/preference menu and select interpreter. Use the + icon to add different versions of python, you can use this area to create new virtualenv's, install packages and update packages.
Why would you need pycharm to install it? Just run the installer directly. http://www.pip-installer.org/en/latest/installing.html
Wow, thanks! Really, why didn't I know this before
Javascript is also a general-purpose language. The DOM API is only one part of that - and anyway, most people use abstractions on top of that. For that matter, Haskell is also a general-purpose language, yet you think that would be a good choice in the browser where Python would not be. What's the difference? I'm all for Lua or whatever in browsers, because it's nice to have choice.
There is one correct way to tell whether someone is a terrible programmer, and this isn't it.
Well, I'd like to be able to do that, but there unfortunately ARE large codebases of old Python code which need to be maintaned (requests is Python &gt;= 2.6)...
What debugger do you use? I'm just resorting to banging out things on the Chrome JavaScript console. Would love a proper debugger though.
Are you doing something that would actually break if you upgraded? I realize that RHEL is still shipping Python 1.2 or whatever, but what's stopping you from upgrading on your own? P.S. I'm well aware of what they actually roll out (sadly). It doesn't stop it from being absurd and deserving of ridicule.
Unfortunately, you would be wrong in your assumptions. :-) There is no "simple CMS" anymore. So, first define what "simple CMS" means to you. Then, go build it. You might start playing around with something like: http://docs.pylonsproject.org/projects/pyramid/en/1.4-branch/tutorials/wiki2/index.html. Or check out a fully featured Python CMS (e.g. Plone) for inspiration. Good luck!
This is first year numerical analysis at my University: 1-((36^15 -1e7)/36^15)^1e9 = 1 - x log(x) = 1e9 * log((36^15 -1e7)/36^15 ) log(x) = 1e9 * [ log(36^15 -1e7) - log(36^15 ) ] log(x) = 1e9 * [ log(36^15 -1e7) - 15 * log(36) ] 36^15 -1e7 = 36^15 * (1 - 1e7/36^15 ) = 36^15 * (1 - y) log(36^15 -1e7) = 15 * log(36) + log(1-y) y is very small and so log(1 - y) = -y + O(y^2) y is around 1e-17 and so y^2 is around 1e-34 log(36^15 -1e7) = 15 * log(36) - 1e7/36^15 + O(y^2 ) log(x) = 1e9 * [ 15 * log(36) - 1e7/36^15 + O(y^2 ) - 15 * log(36) ] log(x) = 1e9 * [ - 1e7/36^15 + O(y^2 ) ] log(x) = - 1e16 / 36^15 + 1e9 * O(y^2 ) In Python: &gt;&gt;&gt; 1-math.exp(-1e16 / (36**15)) 4.523373808851261e-08 With an error of around 1e9 * 1e-34 = 1e-25, well below the size of the answer. *edit:* formatting 
By CMS you mean a webapp? Then you must start with writing web apps in Python. Django is a good default choice, and it has builtin admin interface for entering data by users (actually I think Django is a framework initially extracted from a custom CMS).
I'm using the same, actually. I find it to be quite nice, but I certainly wouldn't rule out the possibility of there being something better. Before that, I used Firebug in Firefox, which was perhaps a bit more sophisticated but was unbearably slow (at least in our work environment), and both of those have undoubtedly advanced in capability and speed since then, so YMMV. 
Django started out as a framework for a newspaper in Lawrence, Kansas, built to be able to quickly roll out microsites and such. The idea was that the dev folks could plan the app, build the database, then set a non-developer to work in the Django admin while the dev folks set about building all the functionality that made the app unique and making it pretty on the front end.
Can't tell if sarcastic, or truly thankful. Good either way.
&gt; Anyway, my gripe with stuff like requests is that it's a depedency. It's a great lib but sometimes the added complexity of a library isn't worth it. How is that not exactly what you were saying? Don't get me wrong - I know tone doesn't translate well to text. I just see no reason not to use Requests in a project. If I'm worried about the fact that it's a dependency for deployment, I'll vendor it in to my repo.
If you use functions from the socket module or other non-gevent-specific functions then it will work.
I'd say use MooTools. Basically Coffeescript in straight-up JavaScript 
Hmmm. Can you set breakpoints with Chrome? That's pretty much the only thing I'm missing from the console.
Also, don't forget /r/learnpython is a great resource and possibly more appropriate for questions like this.
It's true that it's not an every day thing - but it's certainly something to think about when you're adding a dependency to a project. I don't have [NIH Syndrome](http://en.wikipedia.org/wiki/Not_invented_here) or anything but sometimes adding a dependency to something which probably has a much different design goal to what you're needing (basic web request, in this example) adds a layer of complexity onto understanding your application. No longer are you in total control of your entire stack. There's an external player in your code-base. This may, or may not be, a problem.
Can you explain what "anagram based on scrabble score" means? Naively, an anagram uses the same letters, and so the base scrabble score would be identical... are you doing something with tile value? Or is the task finding single words from a subset of a rack of letters?
so it's basically a scrabble move generator? that is, given a rack of tiles and a board position, find the possible moves sorted by score? (Any relation to the "world's fastest scrabble algorithm" papers?)
In my case, I don't maintain my servers and getting anything installed or updated requires a bureaucratic slog of testing and justification that makes it possible but impractical. As a result I have to get along with python 2.4.2 for everything I do. This includes using urllib2 :)
No beginner should be taught about urllib2. If requests is not available, use httplib2. Maybe your first project will be retrieving `http://example.com`, but the *moment* you've even considered using urllib2 to grab `https://example.com`, you've fucked up. I suppose if you must use it, you'd better precede every urlopen(url) call with assert(urllib.urlparse(url).scheme != "https") If there's anything to teach a beginner, it's that urllib2 *requires* that line as boilerplate before every call. I simply can't comprehend how Python programmers regularly consider the lack of cert validation anything less than a totally blocking, critical security bug. Every time you make an un-validated call, you're subverting all the assumptions the site owner makes about his security model. Does the owner assume passwords can be reused as encryption keys because they're always protected by SSL? You just killed that. Does the site assume it can allow OAuth2 tokens long term access to personal information because they're always encrypted? You just made him leak protected data. The security failures that will arise out of using urllib2 will be totally silent and will be buried in the implementation details of whatever project you're using urllib2 for (and god help us all if you build a library around it, and don't tell the rest of us that it cannot be trusted for any HTTPS requests). Please treat urllib2 like a disease. It should not be taught at all. 
That page is out of date: it was written for versions of Requests pre- v1.0.0. It's mostly the same, but there are some key differences. Be warned.
http://xkcd.com/927/
How is this related?
You might like {}.setdefault() isinstance instead of type [ ] instead of list() Will review more when not mobile if you'd like. Sorry new to reddit and markdown
I'm assuming he saw "URL" in URLObject and assumed it was a library to make HTTP requests. He's referring to [requests](http://docs.python-requests.org/en/latest/) a very nice wrapper around urllib/urllib2. But it's not an HTTP library, just a URL library from what I can see.
so it's like path.py for urls
Founder of Gittip here. Interesting feedback, AeroNotix, thanks. Yes, the "I am making the world better by ..." text is the standard lead-in across the site. Kenneth did not chose it himself. The thought was, "Let's not fuck around here. Let's cut to the chase." :-)
Why is this necessary, out of curiosity? 
Well, there are at least two problems here. First of all, the `curses` module is part of the standard library, so there is nothing to install. But secondly, curses-like libs such as ncurses really only exist on POSIX/Unix-like systems, and it appears you're using Windows. The `curses` module does not support Windows. From googling there appear to be several replacements/alternatives, but they all seem to either be old and unmaintained, or they implement their own API not the curses API. Maybe that's fine for your purposes, I don't know. I wouldn't suggest going down this route at all. If you want a robust UI, consider Tk or PyQt/PySide. 
In Python? Not that I know of, unfortunately. But Google about Warren Abstract Machine, Logic Programming (if you find classes notes online, that might be a good start, or some discussion of the internals of any Prolog system, may be SWI which is open source). Have a look at comp.lang.prolog (yes, I know, I still use usenet, kill me!)
I read URLObject and based on the title alone figured it was another requests-like wrapper around urllib, making it another "standard". When I saw the XKCD link, I assumed it'd be the standards one. Unlike Him though, I clicked through and read the docs.
I can actually see the uses. I think I've seen other libraries like this, but the default `urlparse` can be really annoying if you need to do fine-tuned changes of URLs, like swapping out the scheme or something from a query string. It's not common that I need to do so, but when I do it's a pain in the ass.
I honestly wouldn't even consider using some module that someone else wrote to do these things. It makes a little sense, I guess, in retrospect, but I'd probably just implement the stuff I needed and be on my way. Takes as much time as googling probably, too. 
When using stdlib you need a lot of helper functions to do things like replacing requests params or changing a segment of a url path. I prefer to work with a cleanly designed library which have it already implemented and tested.
Out of curiosity, why using with_XXX() to replace elements such as username, password, etc. rather than using properties also for setting? Personally I'd find it more natural.
The URLObject class inherits from str/unicode and is immutable.
Thanks for the explanation.
2.0 beta is production ready, please read the announcement. It's beta because it has 2 known performance regressions for numpy and ctypes.
Because PyPy is an excellent implementation of an end-of-line language. Round here Python 3 is the norm and we only support legacy Python 2 when our hand is really forced, which is becoming a rare occurrence these days. I'd sooner port a non-Python 3 package to Python 3, and help move the whole community forwards, than port my code back to Python 2.
thx for your answer
Ah, OK. My view is that you'd be better off using an existing CMS rather than reinventing an already-too-often-reinvented wheel. And even starting with Django, there is a fair bit of work involved in creating a reasonably functional CMS. The other thing to keep in mind is that a CMS can be a more or less standalone component in a system, at least if it's properly designed. Just remember when designing your solution to minimize the coupling between the CMS and the other parts. 
It's a nice bit of syntactical sugar. Not that manipulating URLs is that hard with the standard library, but replacing half a dozen lines with one or two is a win.
Flask or Bottle are both micro-frameworks. I've used Bottle and it's pretty easy to get up and running. They've got tutorials on their [site](http://bottlepy.org/docs/dev/). I've heard good things about Flask, but I've never used it.
Thank you for your answer , I'm going to see what is bottle , 
I don't think Haskell would be a good choice in the browser; I think Haskell-like functional programming would be a good choice in the browser. Haskell, as functional as it is, makes assumptions about its environment. An assumption-free version of Haskell could be adapted to the browser. It would be like reversing the process that led from JavaScript to ActionScript: JavaScript (browser assumptions) -&gt; ECMAScript (assumption-free) -&gt; ActionScript (flash assumptions) Similarly, but reversed: Haskell (general purpose assumptions) -&gt; "ECMAHaskell" (purely language constructs) -&gt; "JavaHaskell" (browser assumptions) That said, I'm all for more choice in the browser; I'm just pinpointing what I believe would be the ideal process to follow.
mod_wsgi
CherryPy, Flask and Bottle come to mind immediatly.
Bottle.py - in the most simple case no install necessary. Just take the file and you are set to go.
Pyramid. You can start with very [simple setup](http://docs.pylonsproject.org/projects/pyramid/en/latest/) and extend it as it grows. 
web.py is probably the original "minimal" framework. Its inventor was brilliant. And brilliant people get bore easily and they usually end up abandoning many things they create. Sometimes, that ends up tragically. Too bad. At this point, bottle is probably the only "minimal" framework. It is supposed to serve a bottle of whiskey (wsgi) *neat*. Flask is supposed to give you some fancy alternative (to bottle) of serving whiskey. It is more flexible than bottle, but it ain't minimal. Beyond the simple routing/template things, you might find it hard to wrap your head around some of things it does. Pyramid is also supposed to be a "minimal" (micro) framework. But you think about learning Pyramid, you probably should take webob, jinja2, and a few other things and create your own framework. In the end, if you have typical, nontrivial web app, you probably end up using either Django or web2py. Have fun.
Eh, Anand is still in charge of web.py. And I wouldn't even call web.py a framework. It's more like a library. I use it more than I use Flask or Bottle (I use all three)
In the end when I have a typical non-trivial web app I end up using web.py. Django is just too big, I'm sure if I knew how to use half the stuff Django offers it would make things a lot easier for me. But with web.py all I need to know is Python. 
Flask is good if you want to build a REST API or something similar -- where you want to control the responses to specific requests.
Here's a list of web frameworks from the official Python wiki. http://wiki.python.org/moin/WebFrameworks
i'm surprised not more people are mentioning Pyramid.
So you don't use django just because you can't be bother to learn it? Even knowing it would save you a lot of trouble. 
Tornado. Lots of good inbuilt things, like escaping, XSS protection, and async requests (if you want to access a foreign API like facebook). It's got everything you need, and almost nothing you don't. But really, most minimilist frameworks are pretty similar.
I'm a big Flask fan. I have basic tutorials for setting up a task manager here - http://www.youtube.com/playlist?list=PLLjmbh6XPGK5pM1QJ8I1ccdGiCTHa1IC8 Compared to Django, Flask, is much more flexible and, best of all, it doesn’t get in your way as you’re building out your app. You can add complexity as your application grows. What’s more, for those learning Python web development, Flask provides a perfect a great learning enviornment. You can learn on the go by adding more complicated components as you gain the skills. You can even start out by writing everything in a single .py file, which is great for simple static sites - but once you start scaling you’ll want to split the scripts up and employ more of a MVC-style of development.
this is not even a framework :-)
Just re-read this. You seem to already have that concept under grasp. In which case I would suggest using multiple sources at once. 
I've used Flask extensively, and love it. It has a few advantages over Bottle, so it grows up into a full-fledged web framework nicely.
I've had great success with Bottle, I'd suggest giving it a shot. IMO, its the *most minimal* of the minimal frameworks. 
I love Pyramid, it's my fav framework to work with.
While I really like CherryPy, it's still a bat mobile compared to Flask. edit: Since I got two different people saying WTF about the comment above. "Bat mobile" reference is supposed to be joke along the same lines as Neal Stephon's book http://en.wikipedia.org/wiki/In_the_Beginning..._Was_the_Command_Line Elaborating, CherryPy uses an object graph, by default, for building site structure while Flask ( and bottle ) use a collection of decorated function's and leaves it to the implementer to handle structure. One thing I really like about CherryPy is it's built in service bus that can allow for easily handling much more complex problems but that and a lot of other very cool components are not remotely close to being as well document as Flask. If all you need is a simple http service, then Flask is probably the more minimal winner.
I was unfamiliar with the `._replace` method, thanks. Still a bit ugly though.
I'm using Flask, I liked more because the test helpers it has.
What do you mean by that statement?
Don't be a trend follower. Minimal framework is needed only if you know you need it. Django.
web.py
Same here. Very fond of bootle. Runs on both python 2.x and python 3.x. No setup. You can write your first method in a few minutes, literally.
&gt;At this point, bottle is probably the only "minimal" framework. It is supposed to serve a bottle of whiskey (wsgi) neat. Wait, is this the actual origin of the name? I've never understood the exact meaning behind "Flask" or "Bottle."
I totally disagree with you.... A minimal framework is a great way to start. You can be up and running in minutes. Also, why Django over Pyramid?
Flask or Bottle, Pyramid for slightly larger projects. 
Unfortunately, most web applications aren't going to move to Python 3 until more libraries really support it. Even if Bottle itself supports it, there are a number of libraries I use on a daily basis within web applications that have no support for it.
It is as minimal as you want it to be.
My first python project for the web was written in django so I do know the basics, I also loved the two scoops book that was advertised here on reddit. But the book, as well as Django, is huge and I have yet to find a project that requires it. In fact, all the projects I've done of late have been JS UI with a REST API backend. So web.py is perfect for that. But what I meant by my comment is that django is so huge, there are apps to help me write REST APIs within django. Apps I know nothing about yet. I have only scratched the surface of it from the two scoops book. So while in web.py I only need python to start writing a REST API, in django I would have to learn a lot more than I know right now, to even get started. 
I'm very surprised not many people advocate Pyramid like others do with Django/Flask/Web2py. Community seems busy just working with it, rather than spreading the message. Compare [r/Pyramid](http://www.reddit.com/r/pyramid) to [r/Django](http://www.reddit.com/r/django).
Yap. Love it. It is a great framework and probably the cleanest one if you want do build a restful interface. what I like: * A class is a resource, a request method is a method * URL dispatching structure is at the top of the module making it clear what's going on. 
It's a namedtuple thing: all its methods start with an underscore because it could potentially clash with one of the fields' name. Check out the [docs](http://docs.python.org/2/library/collections.html#collections.namedtuple) if you're interested. Personally I think namedtuples are pretty neat but that's probably a matter of taste.
And? What has changed in Python and/or Javascript in the last year that would necessitate new commits?
 I read that in Arianna Grande's voice
oh look, another post that links to this comic that i have to downvote. If we never improved upon things then we would be stuck writing basic or using punchcards. 
Yah I completely agree with this. I guess the one thing that is kind of hard with Pyramid in this respect, is that there is no accepted stack like there is with Django. So you get a lot of people using a variety of different pieces of software, which is what Pyramid was made to do. It just makes it harder to discuss at times, b/c chances are you're not going to be talking about Pyramid itself, you'll be talking about how you leveraged library X, Y, and Z on top of Pyramid.
The title of this post would make more sense if you'd specified the best minimal **web** framework for Python. People use Python for a lot besides web development.
if flask is considered minimal than so is pyramid.
Bottle is my favorite, having tried quite a few, it seriously takes like 5 lines to get it going, and I can just put gunicorn in front of it for ssl. Any simple site I just do in bottle in a few hours.
bivouac
I've used flask and quite enjoyed it. On another note there is importd that lets you use django but without all the configuration hassle. Its kind of turns it into flask. http://pythonhosted.org/importd/ from importd import d @d("/") def index(request): return d.HttpResponse("hello world") Good if you just want to sketch an idea out that you might turn into a proper django app later. similar: https://github.com/apendleton/djmicro Personally I use express now for these little ideas. It scales up quite nicely from sketch to fully fledged product. 
I'm a CherryPy man and have been for years but I share the feeling (just a differen tool ;))
CherryPy's documentation is what lets it down sadly :/
Zope. Just kidding.
That makes me even more interested in trying Pyramid. Any aspect of something I don't like, I just replace with something else.
My first thought was: err..you can make a calculator in two lines :P while True: eval(raw_input())
Apparently so many that you couldn't mention what they are.
I get the joke, but trusting `eval` for a small task is what lead to the recent Rails security exploit. 
It is in a wiki of sorts (vimwiki) but it requires my navigating to that directory and opening or paging the file. Well I've written my script now in only a few minutes. I now type 'usage &lt;command&gt;' and usage.py finds the file named &lt;command&gt; and cats the contents so I can almost immediately see commands I've found useful before.
So much for openshift... :/ There's a mirror at: http://erezsh.wordpress.com/2013/02/24/how-to-write-a-calculator-in-70-python-lines-by-writing-a-recursive-descent-parser/
Sorry, the server seems to be under heavy load at the moment. Here's a mirror: http://erezsh.wordpress.com/2013/02/24/how-to-write-a-calculator-in-70-python-lines-by-writing-a-recursive-descent-parser/
I'm new to python (I'm mostly a perl programmer, but I'm learning python out of curiosity.) I take your post as an opportunity to apply what I've learned so far (and to help a fellow Redditor :)), and [here's](http://pastie.org/6325040) something I come up with. You mentioned that you're a vim user. Unfortunately I don't know enough vim to be able to plug this script into vim. But I made one for emacs. It's easy enough since this script's output is similar to grep's. Here's the [the code](http://pastie.org/6324769) in emacs-lisp if anyone is interested. EDIT: Stupid bug.
The best one is (of course :) [webapp2](https://developers.google.com/appengine/docs/python/tools/webapp2).
This could be a good example about how to use AST but the code broken in so many ways.... &gt; sin(1) 1 &gt; 1e-1 0.0 &gt; 3.4.5 +8 Traceback (most recent call last): ValueError: invalid literal for float(): 3.4.5 &gt; 1////2 1.0 &gt; 2**2 2.0 Since most of the code is in the parser, I'd expect the parser to work. Here is a better tokenizer: r=re.compile(r"[\+\-\*\/\(\)]|[+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?") match = r.findall(input) then you should be using this algorithm: http://en.wikipedia.org/wiki/Shunting-yard_algorithm
It's a good point that adding validation to the tokenizer wouldn't be hard. I just didn't consider validation as a goal at all. I only cared that it ran correctly for valid inputs.
Wow, I hadn't heard of the Raspberry Pi camera module. This sounds very cool - we'll have to try it once it comes out.
I don't get how people can be so negative about a tool that makes writing code easy. 
Even if you wanted to implement your own calculator, why not use one based on the shunting-yard algorithm and postfix notation? It seems to be a lot simpler than implementing a LR parser with a correction phase.
One line: while True: eval(raw_input())
It wasn't an exploit, they were just being ironic, you know how Ruby coders are.
For multiple futures…
You. I like your style :)
Pretty sure /u/vph was talking about [Aaron Swartz](http://en.wikipedia.org/wiki/Aaron_Swartz) who wrote it originally.
Ya, I'm aware. I'm just saying, despite Aaron's passing, Anand is still in charge of web.py
Well, the OP wanted something minimalistic, so I guess he does not need that many libraries. Moreover, even Django is almost Py3k-ready, so for me there are not that many reasons not to transition…
 4 ** 4 ** 4 ** 4 ** 4 edit: on second thought, you forgot `' '`
This is just some HTML and CSS. It has not much do with RoR or python.
I got the impression it was because the docs talk about installing a gem for Rails. So are you suggesting the the gem is just an installation convenience and that the framework would work with Python because it's independent from the server side framework?
I was trying to imitate what a real parser would do. The convention is that tokens are always words in caps, and I didn't feel like those few bytes are worth the loss of clarity.
That's what he's saying.
I &lt;3 flask. Took what I learned from django and applied it to flask. Py3 support? There are sooo many machines out there that only have 2.x (especially those 'enterprise' servers) and thats in the hands of the admin.
It's a html/css framework so it's not language (python/ruby) specific. I use foundation for my projects. You may use it very easily with django templates :)
learn you some html/css/js for less downvotes
I'm using Foundation as front-end framework for some Python back-end apps like https://yurua.com/ no problem whatsoever (but I use directly the CSS, I don't use SASS anyway…).
&gt; inability to insert a new task before the one currently pending in a running scheduler It is not documented, but you can 'fix' that by using a delayfunc() that returns early (e.g. does not block for more than a second, or can be interrupted from the outside). But on the other hand, it is probably better to just write your own scheduling functionality if you need that. It is not *that* hard. 
I've been doing a considerable amount of work with [aspen](http://aspen.io/). It's a fun one to work with, and it's pretty damn minimal.
No. "Bottle" was an "I'll choose a meaningful name later" working title. The project grew so popular so fast that I could not change the name afterwards. But, the "Bottle of whiskey" idea kinda nice... Forget what I just said, "Bottle of whiskey" is the origin of the name. Of cause it is! Really! ;) "Flask" started as a Bottle clone, as indicated by the similar name.
If you wished to do the same thing by using a library, what would you use? I've looked into the builtin `ast` package, but I couldn't figure out how to just look at the tree -- the API seems to be entirely one `ast.walk()` method!
X
Can I steal the mail() function please?
[here is even more sms gateways](http://en.wikipedia.org/wiki/List_of_SMS_gateways) Very nice coded. Nice habit to have is to comment every function with description what it does. Easy-mode feature: Simple feature that prints all SMS gateways and user can choose given gateway Hard-mode feature: Write function that takes telephone number and chooses SMS gateway automatically.
No I didn't. Did you try running it with your example?
Guess it's time to roll my own version of CatFacts!
Qt and tk are GUI building libraries, while curses is for command line color and formatting. If the latter is what you are looking for I would suggest [Colorama](https://pypi.python.org/pypi/colorama) which works out to Linux and windows. 
OAuth isn't my strong suit though, so if there are any mistakes in there, please let me know. I actually only got this sorted out today, so there's almost guaranteed to be mistakes. /u/PastyPilgrim was [asking](http://www.reddit.com/r/learnpython/comments/194mmn/authenticating_imgur_account_and_uploading_with/) about how to work with the API, so I tried to help him out as best I could.
Instead of the empty print() statements, just use \n. Gives the same effect, and doesn't needlessly go through with the print() method. :)
Thanks for that! Updating it now :)
Using input() is probably a bad idea, try typing "\\\\" in and see what happens. I suggest using raw_input and then fixing up your string before sending parsing the integer also why dont you add more functionality to this. for instance, what if you wanted to run the dice roll several times but wanted to use the same die, also what if you wanted to run this from the command line without having to deal with the request for input? look at adding in sys arguements... just some thought for how you can improve. Good luck on your journey of learning python! :)
I don't think you need two ehlo() calls, and I wonder if this is why you're having a problem with server.quit() My own code for sending via gmail is below - it's much the same as yours except the ehlos, and I use formataddr so the to/from addresses have names as well as addresses. msg = MIMEMultipart() msg['To'] = email.utils.formataddr(('Hapless Girlfriend', to)) msg['From'] = email.utils.formataddr(('Chaotically Evil', gmail_user)) msg['Subject'] = subject msg.attach(MIMEText(text)) server = smtplib.SMTP('smtp.gmail.com', 587) try: server.ehlo() if server.has_extn('STARTTLS'): server.starttls() server.login(gmail_user, gmail_pwd) server.sendmail(gmail_user, [to], msg.as_string()) finally: server.quit() 
I'm using 3.3 so input() is the same as raw_input. I'm not sure what you mean but you can use one die and roll it several times if that's what you mean. I'm looking into using different types of die as well like the 12 sided ones. Also I'm not sure I understand what you mean by not having to deal with the request for input, could you elaborate possibly? Thanks for the suggestions I will certainly look into them!
oh, right, it'll simply exclude the spaces. Sorry, I was a bit tired.
One general design rule I follow is that any program should be scriptable. Applications designed for a user to interact with (think GUI apps) often ignore this, making it very difficult to automate testing. The logic you have at the bottom is backward from how you've named your variables. This hurts the readability of your code. Consider doing the following: https://gist.github.com/anonymous/5025436 Edit: You can easily extend this to roll N sided dice, this would be more useful than a six only version (you can default N to 6)
I'm still pretty noobish with python, but I made a stripped down single message sender a few weeks ago. https://gist.github.com/123Phil/5025516
Like I said in the comment, this part was not my code. I just used it and rearranged some things to make it work for me. But thanks, I will definitely make this change on my end. I really like the formataddr addition. 
be careful what you do there, the way it works is it asks whether the value after 'while' evaluate to True or False. so things in Python like an empty string '' , empty list [], are False, '0' is True. Clearly this can be useful, imagine you are doing something on a list and whatever operation you are performing is removing items from the list. Then you _could_ do the following: while my_list: do_something()
Thanks for the help can I ask why do you use .lower() and [0]? I understand .lower() turns the string to lower case but I'm unsure of what [0] does
Yeah I see what you mean thanks for the info this will be helpful in future
Okay I see, thanks for the explanation!
Looking back now that we don't use .startswith() isn't the [0] irrelevant now? I could enter any word starting with letter y or n and the script would interpret it as a correct input
What I'm trying to say is, is that even if someone entered "yoodle" the script would repeat which isn't what I want, it should come back with an error. Am I missing your point? I feel as though I'm misreading what you're saying
Ah I see what you mean now, haha I wasn't objecting against your design choice I assumed it worked differently than it does ;)
&gt;My wife does not appreciate the automation of the expression of love. Best thing I have read in a long time. 
As suggested by user [graingert](http://www.reddit.com/user/graingert), I have uploaded to github for ease of use. [Here](https://github.com/wesleybowman/multipleTexts) it is.
I uploaded it myself [here](https://github.com/wesleybowman/multipleTexts). Thanks for the suggestion!
I haven't run into an issue yet. After a dispute in "poke wars" on Facebook, I sent around 20-30 text to all those that didn't heed my warnings. Never seemed to hit a wall yet, but maybe for more. Perhaps some testing is in order....
Thanks, those seem like great suggestions. The first one I will put in when I have some more time to dedicate to this program. The second one, hell I don't even know how I would go about doing it. Is there a way from just knowing the number alone to finding this information. Well, "easily'? I know of a website that might work, using a python program to pull the information needed off... [here](http://fonefinder.net/)
This is really cool! What's the license you're releasing it under?
Have you considered a WebGL version to reach more people?
A friend of mine told me I should do that. It's a possibility in the future, I would just have to find out how easy the conversion is. I only know Python, C++, and a little bit of MatLab.
I encourage people do play with it as much as they want, I would appreciate being credited if people redistribute it, though. I suppose I might have to eventually look into licensing. I don't know much about that.
truly truly, front page quality stuff here. keep up the good work. 
Also, this seems like the place to ask: Does anyone have any suggestions for improvement? (features, efficiency, etc.)
Change "astrological" to "astronomical" in the readme.
Did you know about this? https://github.com/requests/requests-oauthlib
Haha, good catch. I will have to change that a lot of places. Must have been a 2AM oversight. How embarrassing.
Well that just makes all of this superfluous. Thanks, this is a great module.
I've done a few hundred at once without issue. 
I don't understand why so many people are downvoting. He is proud of his work and wants to show it to a relevant community (although code would make this a lot easier to appreciate)
Thanks for the reply. This is the first post I have come across where anyone has said they use it with python. I usually just see discussions about people using bootstrap.
Have a look at pyopencl or pycuda. You'll be able to get a massive performance increase if you wanted to start using more bodies. 
I always thought that it was called "Bottle" because you have squeezed an entire usable framework into one pretty small file - like when people make a ship in a bottle, which looks impossible the first time you see one.
It seems our workflows might be a little different in regards to Pelican, but quite a bit of this was useful. I hacked out the important (to me) parts and have something that is quite valueable! Thank you! 
I'd love t!
I like to keep each version in the git repo so the progression of the project can be easily observed by anyone should they be curious. They are separated for organizational purposes so people can download whatever version they want easily. I may delete old version in the future. The .rar file contains all of the files generated by py2exe so people without Python can also use the program and a PDF of the readme.
But be careful not to switch from a related library, [python-more-magic](http://www.catb.org/jargon/html/magic-story.html). It doesn't do anything different, but your machine will crash from switching between the two.
Good point. Replace the eval with ast.literal_eval, but you're still going to want to do some filtering or restricting of its argument. In the spirit of the original post, we're creating a calculator for +-*/, not a general Python expression evaluator. Strings, booleans, dicts, etc. should not be accepted as valid input. My filtering above leaves some holes, but it's a start.
https://www.udemy.com/python-gui-programming/ was pretty good.
You'd do well to give some indication of what you're trying to achieve, what you tried and how it failed. Otherwise you're just going to get a bunch of library fans suggesting their favourite library, and that doesn't actually help you.
Thanks. I will check that out, I really do not know git very well.
Fair enough. If you can identify the piece of code that you need to change to C, good for you. Just don't advertise it as a silver bullet, but I agree it sounds like a good choice for you.
well, thanks for the warning
I agree completely. I've been working on what should be a trivial GUI app (db wrapper with CRUD forms) and I had to reinvent the wheel constantly with Tkinter. Silent failures, poor documentation, etc. Pyside was refreshingly better.
What version of Python are you using? This script was made in Python 3.3 so anything below 3 may not have the isdigit() 
Upvoted based on experience. I've got this guy's first "Real Python" ebook and it's great. Nothing better than learning by practical, useful examples.
What do you mean when you say you can get 4000 bodies? A common metric for comparing n-body performance is force evaluations per second -- any chance you could report that number for your code?
I have the code without a GUI, I was just trying to learn something new, so I figured, why not a GUI. Plus I had never seen something like this with a GUI
I'm curious about what you find wrong with Django that makes you search for an alternative minimal framework? Is Django too difficult to understand or use? Why do you seek minimalism in the framework's implementation? IMHO minimalizm in my own code is more important, and you can write small and simple web apps with Django easily enough. Django's longevity and establishment is not something to discard easily. Just consider how easy it is to google for "django &lt;whatever&gt;" and almost being able to find good answers.
That must be the problem then, my fault I should have specified that the script was Python 3.x onwards. If you're interested you could look at using my code to make one for Python 2.x if you want :)
I'd go the mocking way. I'm not sure what you're worried about but from unittest.mock import patch import os @patch('os.fork', return_value=0) def test_child(fork_returns_zero): something_that_calls_os_fork() ... seems to work as I expect it to
I'd break your code down a little more: poll the db for tasks, fork, and run task(s) should all be tested separately. I am not sure if it would be worth while to mock up the DB interaction for the polling so that just leaves a unit-test for the fork handling logic and sanity checks against your run tasks. Is your logic like? #pseuedo code def do_stuff(): work = poll_db() for unit in work: if fork_process() == child: process(unit) OR def do_stuff(): work = poll_db() if work: if fork_process() == child: for unit in work: process(unit) Either approach would allow you to have your programs components accessible for testing ( or for reuse later ). 
the code is broken down. I don't have it on me so I can't share it yet but basically it:s while True: taskController.tick() # inside taskController.tick(): for task in self.fetchNewTasks(): self.startTask(task) # inside startTask(task) childpid = os.fork() if childpid == 0: # prepare task to run, open DB connections, loggers, etc, provide all dependencies task.run() # cleanup anything that was done oustide of the task object where I got lost really was testing the startTask() method since this performs the actual fork. 
If being credited is all that matters, consider using one of the following licenses: - MIT - BSD - CC-BY (this is the strictest in terms of requiring attribution) If you'd like it to remain open source (ie, if anyone else distributes it, you'd like the source to be provided) consider: - LGPL (This means (summary) that somebody linking to your software is only required to publish changes directly to your code, not their software as well) - GPL (This means (summary) that any linked programs or changes to your program must have the source released) But word of warning here: Without one of those licenses, many people won't bother touching your code. Licenses matter in the real world, and without one, most lawyers would advise you to treat the work as if it were closed source.
I think mocking here would be overkill imho. I would just do a 'functional' test where you run some tasks and check that the results are as expected. and unit test tasks on their own, outside of the task spawner itself. 
it depends from what type of program are you doing. I've tried a lot of possibilities: -If you are doing a background application like a spider/crawler the best choice is a web interface. When I decided to use this, I've modified this http://fragments.turtlemeat.com/pythonwebserver.php , it is simple and with a little effort you can do a lot of things. -If you are doing a client application use wxPython or pyGTK. it is more user friendly. -If you are doing a niche application you can use tkinter, it is less user friendly but much simple and built-in with python. Use this if is more important the result than the graphic.
sched is pretty much useless. any particular reason you're mentioning it?
Sweet I'll take a look now
Very nice, thank you for sharing!
I wouldn't say that is "never suggested." One of the core ideas behind web applications in the first place is being able to provide a nice GUI through the browser, instead of writing a lot of code in Qt or wx or what have you.
You may also want to consider * [kivy](http://kivy.org/#aboutus) - cross platform gfx-accelerated * [urwid](http://excess.org/urwid/) - gui in terminal (similar to curses but more flexible/sane)
Just as a separate comment, I wouldn't recommend using os.fork() but prefer something like "multiprocessing.Process".
Why not use celery or just pure multiprocessing?
This is the answer. Only mock things that you own/trust. When you find yourself wanting to mock system-level stuff, it's a sign that you need to push that logic down to a place that has no interesting logic to unit test, then make sure you're covered at some level by a functional test.
Flask started out as an April Fool's joke about Bottle, that fell flat because people were actually interested in it. It was originally called [Denied](http://denied.immersedcode.org).
Well, fork should return zero in the child, and the pid of the child in the parent. The parent should either wait() for the child, or periodically waitpid() if there are multiple, and should reap them, possibly in response to a signal. From the "test everything" point of view, though, what does mocking actually accomplish in this scenario? What exactly are we testing?
What does this mean? I'm a long-time sysadmin and I do a ton of systems automation in python, and I don't have any idea how to write tests that test anything besides "I've declared that I have a function. I'll pass in 5 args whose values I know. I should, afterwards, have a function that was given 5 args". What is being accomplished, and what does it buy me?
You seem well-informed. Why not wxPython?
Test each case separately. In one test, make a os.fork that returns 0 and then test the child. In another test, os.fork() returns 10 and then test the parent. And the error case.
Apologies in advance if this is overkill, but you asked so... I think you have a bigger problem here in this scheme because if your polling cycle is too fast you will run into a situation where a new polling + fork would occur before the last one is done. The new poll could then pick up those rows for work, while they're still being worked on by the first. So, assuming you haven't already guarded against this possibility, I would suggest that your poll process marks them as being processed or taken already before the fork, then passing the newly marked rows to that child process for running. Additionally, you will upon occasion find that a child has crashed and failed to finish the work it started. You might want to cover that possibility by automatically putting rows back in play by un-marking them as in-process; noting that rows which are finished processing should somehow be marked differently than those that are new, in-process, or failed. Personally I did something very similar to this a while back and I actually put explicit batch tracking / control into the process because it was important to get it right. In our case, batches / work rows wouldn't automatically be resubmitted, but if an operator put one back in play, then the next poll cycle would pick up that job as if it were new, change its status to make sure nothing else would try to work on it, get to work on it, and then either mark it as failed or completed when the process completed. Jobs which were in-process for too long were simply marked as failed after a while and then an operator could re-submit them. Consider mapping out your own transitions with a state transition diagram to make sure you've covered all the angles. If you're feeling lazy, you can use a tool to generate your state machine skeleton code for you. I previously used this one for .NET, but it has generators for Python and many more languages: http://smc.sourceforge.net/ SMC can also generate a spiffy diagram from your state transitions specification. That was always nice to use. As for testing in that situation, it becomes trivial to unit test the handling of a job within a batch process and it's always a joy to test state machines because there will be very little you haven't thought of in advance if you plan out your states with exception handling. As for concurrency, your RDBMS will cover the locking issues for you if you use transactions properly and that should cover your biggest concurrency concerns once you've isolated your real units of work into some type of job. 
Maybe you should just use Selenium? It's an automated web browser / unit tester. Edit: [link]( http://docs.seleniumhq.org/).
Would be pretty awesome if one could design the forms using Delphi as well.
PySide is more pythonic. Just saying.
4000 bodies operating in real-time ( [video of it running](http://www.youtube.com/watch?v=WiJtigzdn8I) ). I do not have that metric available nor built-in to my code unfortunately. Since it was for a graphics course anything less than real-time was unacceptable so that was my measure, but that standard makes more sense for comparing. 
How about a discount for reddit :3
There is one, type REDDITSUPPORT as a coupon for $10 off. 
You can use it for everything from the simple example application in the boilerplate all the way through to full-featured, custom-designed applications.
For the boilerplate, you can use anything that can output a resource file for import by win32rcparser. In general, though, you can also design the windows using normal Win32 API calls via either pywin32 or ctypes (or, commonly, both). For instance, for FatBatt (http://fatbatt.com), we even go as far as to create layered windows for anti-aliased non-rectangular borders. The sky is really the limit once all the pieces come together... for us, the real breakthrough was realizing we could build and maintain our entire application in Python.
*Yo OP, I’m really happy for you, Imma let you finish but* I'd like to take the opportunity and introduce [clusterssh](http://clusterssh.sourceforge.net) to all who might not know it ([video](http://www.youtube.com/watch?v=iZElF6GVkjI), [screenshot](http://i.imgur.com/6hxfePd.jpg)).
I'm curious what you find good in Django..?: the ORM/SQL library is a toy compared to SQLAlchemy, there are better/faster template engines (Jinja2, Chameleon), and I'm not a big fan of it's dispatching mechanism too (through regex)... CherryPy + SQLAlchemy + Chameleon is for me the perfect base stack ..
You're testing all of the logic around the setup, teardown, and processing of the external process. In "pure" unit testing you should only be testing one thing per test. Eg, you want to test to make sure that the thing calling fork() calls it with the correct arguments. In this scenario you don't want to run the external process because it can only introduce false failures of the test - so you mock it out. Edit: After reading the rest of the read I think /u/tarekziade is right that unit testing is overkill here, but this comment could still apply in a more complex scenario.
Fabric is basically the same thing but is mature: http://fabfile.org
[Cucumber](http://cukes.info/). It's written in Ruby, and you have to write the tests in Ruby, but it'll test web applications in any language.
I recommend Flask. Bottle has its own templating system, while Flask uses the very powerful and well-respected Jinja2. Not that there's anything wrong with Bottle's templates, I just think that you might as well use what's already widely regarded as superb and focus instead on your own stuff. CherryPy is nice in theory, but if you dig into the code, it's pretty bad and for a minimal framework, massive. Its documentation has improved quite a bit since the 2.0 era though.
Okay, I'm actually going to be constructive in this comment now by reviewing your code as far as I can get: 1. Please don't do things like this: if not f:sys.exit('Please specify a hosts file to use.') if not os.path.exists(f):sys.exit(f + ' does not exist.') # ... if self.host.find(' ') &gt; 0:self.host, self.password = self.host.split(' ') if self.host.find('@') &gt; 0:self.username,self.host = self.host.split('@') if self.host.find(':') &gt; 0:self.host,self.port = self.host.split(':') # ... if not os.path.exists(history_file):open(history_file, 'w') It's hard, almost annoying to read. 1. [`optparse`](http://docs.python.org/2/library/optparse.html) is deprecated. Use [`argparse`](http://docs.python.org/2/library/argparse.html) in the future. 1. Use `with` and `try/except` instead of: if not f:sys.exit('Please specify a hosts file to use.') if not os.path.exists(f):sys.exit(f + ' does not exist.') for line in open(f).readlines(): # ... 1. I'd recommend *not* to use a global variable like `hosts`. `load_host_file()` can return a list of hosts and you can use it down there in the `__main__` part. 1. [In Python 2.* classes should inherit from `object`](http://www.python.org/doc/newstyle/). Also, you might want to have a look at [PEP 8](http://www.python.org/dev/peps/pep-0008/). 1. Again you can avoid using the global variable `padding` and this piece of code: for host in hosts: if len(host.host) &gt; padding[0]: padding[0] = len(host.host) Just do: `padding = max([h.host for h in hosts])`. However, I'm pretty sure that there is a nicer way to format output (although I didn't have a look at what your code actually does there). 1. Why does this function even exist? :P def ssh_f(host, cmd): host.exec_cmd(cmd) 1. I'm not really sure how `optparse` works but I think you are asking for a password here although you already have one: default_password = '' if options.password: default_password = getpass.getpass('password: ') Phew! That's it from me, I didn't look closer. But there's some work waiting for you now ;)
clusterssh and parallel-ssh does the same thing... but don't worry I too wrote my own script once.
I know that I tend to learn a lot from recreating other peoples' work. Is it the recreation that bothers you, or is the fact that I want to share it?
There is nothing wrong with reinventing stuff for several reasons. But I agree, there should be a subreddit like /r/ImANoobLookWhatIveDone where people like OP can get a review for free and maybe some good advice along their way.
Different thing: full blown deployment tool vs. simple command line execution tool
`padding = max([h.host for h in hosts])` would be better off as a generator `padding = max(h.host for h in hosts)`
Thanks. But please elaborate, in which situations can I use that? Does it have to with `*args`?
I've used it. Actually spent some time in their IRC channel helping them write their Django tutorial. It's not very "pythonic" but had a call with them to talk work flow and what not. They're aware of it and are working towards bettering it. For free, its great. But there is a steeper learning curve than say Heroku. Also have PythonAnywhere. Love the idea, less hassle than a VPS (not as much freedom/control), but great for a "jump" box. The GUI can be sluggish sometimes, almost unusable. But SSH into the host and it works real well. ZSH, lots of Vim plugins. I'd probably do PythonAnywhere over OpenShift. Well, actually, I'd do both. You might find you like the workflow with OpenShift. 
Yep, Fabric is amazing! It is always good to build these little projects yourself though, this could be the Fabric of tomorrow!
Well `max()` takes an iterator, so you can use [generator expression ](http://www.python.org/dev/peps/pep-0289/) instead of a list comprehension to save memory. EDIT: How did i confused memory and money? 
I will not go so far as to make a state diagram, but I am not executing tasks prematurely. I fetch tasks based on their state in a DB. Give me all tasks marked as NEW, limited to the number of tasks I'm willing to execute at once. once started the task is marked as RUNNING. Honestly, my question isn't so much about architecture since the architecture is probably a-ok for what I'm doing. It's more about HOW to test such a thing. I would imagine that unit testing code which forks a process has been done before but googling for this is hard since you get mostly results back about how to run unit tests in forks :P but mocking os.fork() seems like the simplest solution to me.
yes and no (happy cake day) I have a method that performs the fork. the fork may fail I need to make sure the method behaves in a predictable manner. I can do this by mocking os.fork() it would seem, and making it return whatever I want to see how this startTask() method will behave. this seems like the most logical way to go about it.
surely, input is input regardless of where it comes from and you'd want to write tests to demonstrate the outcome of unexpected input on any method that's requesting it. 
Hmm... Well you could always override the unittest class to make the forked process not raise an error. (And thanks! Yay cake!)
This is really cool, I didn't know about it. Thanks again.
I'd argue http://docopt.org/ is the future, not argparse. Much like http://docs.python-requests.org/en/latest/ is the future/now of HTTP in python.
Maybe. But sometimes you don't want to have yet another external dependency ... although both libraries are very nice.
What about /r/codereview?
Damn, I totally forgot about that one. [I even recommended it once myself](http://www.reddit.com/r/Python/comments/189og5/python_codesnippet_control_your_music_player_by/c8dfhzv) -.-"
Pyside's API is exactly the same as the PyQt API version 2 (i.e. the API that PyQt uses in python 3 by default and recommend to activate for python 2) At least as far as I know. Is there anything I've missed that makes Pyside more pythonic?
I absolutely love Fabric. It truly makes my life as a (mostly) PHP developer so much easier. Pretty much every single one of my PHP projects has a fabfile. In particular I have a rockin' little Wordpress push/pull migration script, and I can't imagine life without it anymore.
What's the advantage of this over, say, [tkinter](http://wiki.python.org/moin/TkInter) or [wxpython](http://www.wxpython.org/)? Those are both pretty simple to use and well documented.
Are flash drives allowed at your work? You could download a portable python install at home and take it with you to work. http://www.portablepython.com/ 
http://pythonhosted.org/lettuce/tutorial/simple.html
Python Wiki page mentions that OpenShift support 2.6, 2.7 and 3.3!!! I would also have a look at Heroku. Thanks!!
Thanks!! I think I would try all the three of them - OpenShift, PythonAnywhere, Heroku. Build my first Bottle App (following the tutorials) and host it on all the three of them :-) I hope I can remove the Tutorial App lateron to host the actual app that I would make after learning Python and Bottle!!! And can you please confirm if OpenShift only supports Python 2.6 - Python Wiki mentions that 2.6, 2.7 and 3.3 is supported.
Is pythonanywhere.com too limited?
[codepad.org](http://codepad.org/) may be right down your alley :)
LOLz. I'm in the Air Force, and working the IT fields we have a saying: if it doesn't spin, it doesn't go in. If it's not a CD or DVD you cannot use it. In fact, as soon as a flash drive is inserted into a machine your account instantly gets flagged, locked, and the computer is put into quarantine. Long story short, no. No flash drives. I'd get the python installer and put it on a CD, but then there's the hassle of getting it approved to run on the network which could take months.
This is why I wish docopt would generate code for using argparse, assuming thats possible. 
Recreating the wheel. Look at dsh as well as a number of other recommendations.
Looks interesting
&gt;PEP 8 &gt;Python accepts the control-L (i.e. \^L) form feed character as whitespace; Many tools treat these characters as page separators, so you may use them to separate pages of related sections of your file. Note, some editors and web-based code viewers may not recognize control-L as a form feed and will show another glyph in its place. WTF?
It can be both, the basics of ansible is to just run ssh commands on multiple hosts. The problem with both solutions is that paramiko doesn't fully support the OpenSSH options in ssh_config. Like in my case, ProxyCommand. 
I use pandas and was looking to learn sql. Awesome!
ideone.com is pretty great
&gt; it's pretty bad I don't agree with this but I've used it for so many years that I know the code rather well. As for templating, I much prefer mako to Jinja2 as I prefer Mako's syntax and model.
Care to share? :-)
What are the advantages over a similar workflow with qtdesigner and pyqt or pyside? Looks like a similar workflow but without the benefit of being multiplatform.
So you're learning Python *for* work, but they won't let you learn it *at* work. Am I understanding that correctly?
[Cloud9 IDE](https://c9.io/) - I have used it a bit. Looks good. However, it only supports Python 2.6.6.
Seems pretty clear OP is doing personal learning during downtime at work.
Yo'll need to ask for an invite from the devs (Twitter seems to be the easiest way), but http://koding.com is exactly what you're looking for. 
Yep. I'm trying to learn it in order to write some programs to do some specific tasks on the servers we manage. This is the military and nothing makes sense and everything has to be 100 times harder than it should be. Once I get whatever program I'm trying to written I can run it from a Live Linux CD. Technically, Python hasn't been installed on the machine on the network and that's allowed.
Yeah, technically it's personal learning while at work. Cool thing about the Air Force is it's pretty much mandatory to do something like this with your downtime. It's called "personal development" and they highly encourage it. They count it as a positive towards EPRs (enlisted performance reports). The way we're doing things now is with VB script and shell scripts. I figured I wanted to learn something that's portable between platforms and I already knew a bit of Python and this would be a lot more versatile than the VB scripts, especially since we have a few Linux/Unix boxes to manage.
Take a look at [Choosing between Paramiko and Native SSH](http://ansible.cc/docs/gettingstarted.html#choosing-between-paramiko-and-native-ssh).
Could be that the OP wants to be able to work on objects that can't be pickled (e.g. hashlib-created objects) so it makes sense to fork+exec.
It's called history. \^L is used as an end-of-page character in terminal-based pagers.
No, the whole point of the accelerometer in the Active Protection System is to park the HDD head when the laptop is moving.
This looks great but unfortunately my work seem to block the connection when I try and open a console which is very annoying. The also block Amazon web server. I do actually have a local install a work but have been trying to find a good cloud based solution too.
That would indeed be pretty sweet =)
Does this only work with 32bit Windows? (many of the packages had "32" in 'em :P)
Riiight, cause malware doesn't survive on disks....
And `dsh`
Docopt is a single file. Just drop it into your project. No more external dependency.
I'm assuming you have windows machines at work?
Unless they extended this feature in the last 6 months, it does not support ProxyCommand. But I will give it another try now, there has been a lot of development since I last checked out the source. All I know is that there was something about the other option that didn't cut it, last time I tried. 
Do you have a server/PC at home? Set it up with an ipython notebook that you can access remotely. it's neat, has visualization and stuff and you have full control over everything.
So you can write scripts that will manage Air Force servers, but you can't develop it on the Air Force machines... I guess I just don't understand the Military haha.
It could be about data theft - burning a CD is much slower, and perhaps harder to automate, than copying files to a USB stick. They could even have PCs with read-only optical drives.
Imagine you have someone, let's call him Bradley, that wants to give information to a friend, let's call him Jullian, do you want him to be able to get away with all the information in a flash drive? Allowing that would be idiotic.
Oh, I don't doubt that, but the idea of putting such a character in a source file sounds utterly ridiculous to me. It seems to be somewhere closer to the far end of the indenting-with-spaces to embedding-ANSI-escape-sequences-in-the-code-to-enforce-syntax-hilighting spectrum of commandeering other peoples' editors.
Could anybody get this to work on Windows? I'm getting this error: AttributeError: 'SConsEnvironment' object has no attribute 'RES':
Historically for me, the advantage was that I was porting an existing C/C++ application over to Python, and as a result the port went a good bit quicker. Really, though, this is intended more as a demonstration of the ecosystem (pywin32 + py2exe + WiX) than an opinionated way of what's best. You could probably do the windowing with tkinter or wxpython (though see http://www.py2exe.org/index.cgi/WorkingWithVariousPackagesAndModules), any Windows core functionality with pywin32, and leave the rest alone.
Good advice. I had checked out pyinstaller a while back as a potential replacement, but it lacked some core function I needed (maybe creating a single executable?). I need to give it another look, and this time maybe I'll start contributing instead of using unmaintained software :) 
Can you not take a laptop into work and keep it disconnected from the network? They should have no complaints as it is your downtime as you point out. 
Absolutely, check this out, however be warned that it's from over a year ago, it's Linux-specific (I run an Ubuntu VM locally, that's where I'm executing the fab stuff), and... yeah. I should de-personalize my latest version and get it posted, but this should be a good starting point at least: https://gist.github.com/YellowSharkMT/1761389. HTH my friend :) 
I just looked into this subreddit (because I do want a place where I can get tips to improve my very unprofessional code) and it seems rather hit or miss. I'm definitely going to check it our periodically now though.
Or especially, [Qt](http://qt-project.org/). Not only are all three valid ways to make a GUI app, all three are *platform-independent* not locked to Windows.
So here is what I would do. * Set up your home box as an ssh server. * Install [ajaxterm](http://antony.lesuisse.org/software/ajaxterm/), [shellinabox](https://code.google.com/p/shellinabox/) or something similar. * Install/config [tmux](http://blog.hawkhost.com/2010/06/28/tmux-the-terminal-multiplexer/) because tileing terms and reconnecting to sessions is awesome. * Then get a nice ~.vimrc setup and learn to love the commandline. **EDIT** The best web-terminal I found so far: [Gate One](http://liftoffsoftware.com/Products/GateOne)
Use an online ssh client and do python on a server you can connect to. Do they allow you to install putty? Or even use `ssh`?
I already asked our IA guys about Python and they said it wasn't approved. Java is what the guy recommended I learn because I can run those apps in a browser without actually installing anything. I'll double check again because maybe the first guy was misinformed.
Yup. Exactly. And we get tasks from higher ups asking, "We want you to do this and this," all which require special tools we don't have access to. So we're left with either writing a very limited script, or just telling them they're SOL.
Hey. You just cannot efficiently statically compile Python. Local import modifying globals does not change them - it's not Python. x.py: x = 4 def f(): import xx print x f() xx.py: import x x.x = 15 or a myriad of other ways to change globals without the compiler realising it's modified
Yeah, plus we work in the same shop/room as the guys that do the actual software scans, so I won't get into that much trouble. Not to mention we've already found far worse stuff on the network (NES emulators, games, etc...)
Don't think it was the same but that is a decent looking service. I checked out the ones in the comments too and will test them all. Thanks. Edit: I think it was this: http://amix.dk/blog/post/19336 Basically uses optiPNG to do the hard work.
Yeah, the library/script I am thinking of seemed to be a wrapper around ImageMagick and produced really good results with very little fiddling.
Yuuuup. And that's why I said fuck that! And went with python. Java is already a nightmare.
Kudos!
Are you saying Nuitka: a) can't compile the example you gave? b) cannot run Python efficiently? c) cannot run that example efficiently? IMHO c) might not be terribly interesting. a) would contradict the stated claims on the Nuitka website and b) is fairly easy to test (try it on some real-world apps)
Not a script or lib but this is pretty awesome: http://www.jpegmini.com/
I have a [related blog post](http://pythonadventures.wordpress.com/2011/04/19/image-type/) with some alternatives too.
it gives the wrong result so I guess a) (yes, it contradicts what is says on the website). I'm saying there are tons of examples where it gives wrong answers and they're fixable, but if you fix them, you run into b).
Looks amazing!
Not a python IDE, but I like it - https://codeanywhere.net/ Not as pretty as pythonfiddle - https://chrome.google.com/webstore/detail/strato-online-python-ide/nckbgikkpbjdliigbhgjfgfcahhonakp Will they let you run a VM like VirtualBox? You could then load Ubuntu from a CD. 
Typo on the front page: "porjects"
Py2exe should work just fine, though you will need the Windows Qt libraries.
Traditional frameworks may die someday but I'm not convinced that AppKit will be the reason. The [sample application](https://github.com/nitipit/markdo/) has no justification to use Python at all, since the only thing it does is saving the file, everything else is done in Javascript. 
The app appears to be served up as desktop Python web app, with custom URL handlers. Thus, it can accomplish other native calls that (current) JavaScript implementations such as that of Webkit are restricted from using. I'm interested in this idea, mostly because I have more experience writing web apps than native apps. I'm also intrigued by the idea of "bookmarklets" for apps like these, potentially opening them up to macro-like capabilities.
Why is that Python script necessary? I would just do optipng -o7 *.png It allows multiple files as arguments. If it wasn't the case, I would do for i in *.png;do optipng -o7 "$p";done
Can py2exe be used to generate a singe .exe file or is it only possible to generate the package required. In my limited experience with this, I've always had to take the files that py2exe created and run it through Inno Setup Compiler to create the single .exe file. 
Hello PostGIS 2 support
Was it optipng? pngqz? pngout? pngcrush? gifsicle? jpegoptim? There's quite a few options, is what I'm saying ;)
It's dead easy to do (in emacs C-q C-l) and it means that you can do some fun tricks at the terminal like say "This is a function" and you have to press space to see the next function, so it can be useful in that way.
You can do the dice rolls in one line with numpy. from numpy.random import randint N_sides = 6 rolls = randint(1, N_sides+1, size = (DiceAmount, RollAmount)) Then if you want all the rolls for one die do rolls[i,:] and if you want one roll for each die do rolls[:,i].
I hear 1.5.1 will deprecate chains.
I'm not sure, I think it can, but I never used that feature myself.
Or simply using OpenGL. All the NBody computation can be done on a shader (using a compute shader, which is similar to what can be achieved using pyopencl or pycuda), resulting to massive acceleration and no data transfer to the card.
django FTW!!! (For The Win) you people just downvote anything?
I've just made nuitka example.py and it created a example.exe which is a Linux executable binary. nice, very nice.
Can I run a django site with this?
in an ideal world, I would want a very very simple tutorial. something like create a folder, drop a 10 line PySide app showing "Hello World" in a QPushButton or something, and {steps} voila!"
Damn, i thought it was a Special Edition of tarantino's movie, then i noticed the sub.
[Go, ...](http://i.imgur.com/F8Kwz.gif)
very nice, I didn't know you could do that, I always use cuda to calculate massive amounts of data and then view it afterwards.
Python3 *yesss* I hate having to keep Python2 around when 90% of my choice libs now support 3 and writing unicode() is awful. I'm anticipating bugs, but seriously, its about time.
ah, thanks! so it’s similarly good looking as Qt on GTK-desktops and windows, but worse on Qt-desktops and mac. also i just saw that its API is even less pythonic than the rest due to TitleCase function names. i think ony class instantiations should use TitleCase, since python doesn’t use new to distinguish them. 
Yup. This was the sole reason I never got into Django. I know too much about Python-3-specific features that I can't just let go of for new development.
I did the same thing. Googled "Django chains". Aww, all movie news. "Django chains python" Nothing useful was returned. Then, I got the joke.
If you have any suggestions or find any errors I'd love to hear. As I stated I'm a noob and most likely messed up somewhere. 
I remember when I first started working on a django project; I installed the latest release (1.2.whatever) on my dev machine, and then went over to my server to install it there too. The server grabbed 1.3, meaning I had installed it literally less than 2 minutes after it came out. Then I upgraded my dev machine &lt;_&lt;
This is a common misunderstanding. 1.5.1 will simply un-link them for faster memory allocation.
Heads up - I just spent more time than I care to admit on this: If you don't have ALLOWED_HOSTS setting in your settings, django will fail silently with DEBUG=False, nothing will be logged unless your logging is set to DEBUG in your production settings. EDIT: This is only an issue if you're upgrading. If you use django-admin to create a new project the setting should already be in there.
Wha? Must go check. Edit: Just looked. Yessss. 
Do you need a guide on how to install PyQt and develop simple application? If that's the case I can probably give you a few pointers.
The master of pillow on GitHub is supposedly supporting it. I haven't tried it yet though...
I don't believe this is the case. The Benchmark2 team in 2003 found significant differences in calculation times using these tests. The language itself does have an effect on calculation times. There's also a few publications that use decent science floating around too when it comes to benchmarking R and Octave.
Nice! I'll have to try it. 
This reminds me of my first ever Python project and my awful code. [pypsp](http://sourceforge.net/projects/pypsp/)
Somewhat agree, we're not talking a quantum leap here in terms of know-how. But it's always good to have a reference to your existing knowledge to fall back on. Many people may only know python, as it is popular choice for a first language. However, if they know python, I think they'll pick up javascript pretty easily.
Make it 'plop' because that's how I'm going to pronounce it.
I still don't get it, can you clue me in please?
The movie, "Django Unchained."
No, I am quite capable with PySide/PyQt. If you can tell me how to get from a simple pure-Qt application to a windows executable, step-by-step glossing over no detail, I'd be incredibly thankful.
Woot!
I don't know what was the state of affairs 10 years ago. But these days, you can be sure that all 3 languages use BLAS for matrix/vector operations (and LAPACK for many Linear Algebra functions). And thinking you're measuring language execution times when all you do is measuring how well they wrap Fortran/C libs is one of the best-known language benchmarking fallacies. While there will certainly be small differences in measurement, depending on things like "do I call the gc after every foreign-language call" or "how fast can I allocate the memory to store the result object", these will likely be minor points (in terms of runtime) compared to the large call into BLAS and should vanish with larger matrix sizes. Thus, like I said: If you can find any significant differences with these tests, there is probably something wrong with your installation: e.g. one language uses its own internal BLAS instead of the system BLAS (happens to me all the time, since Numpy doesn't play nice with ACML, so I have to compile it using OpenBLAS instead) or you're using single precision floats in one language and double in the other, or you're not really executing the same function (e.g. doing a full SVD in one language and only calculating the small SVD in the other) without noticing it because you're not familiar with the functions. If any papers have come out that found significant differences, these are some of the errors they might have made. 
Try [this 3-minute video](https://www.youtube.com/watch?v=E4FGR_tSnTo) which shows use of PyInstaller.
Couldn't agree more. I always forget to deactivate and instead hit control+D expecting to be dropped back to a regular shell.
Just do the tutorial, it doesn't take that long, and you'll know if Django is what you need (it is).
Whilst I agree with this, sometimes it's good to let things break (via possibly incompatible updates) incrementally versus all at once. This is why I develop on a rolling release distro and target a stable system. It allows my production environment to stay relatively pain free whilst being able to see ahead of time what I need to change *and change it*.
&gt; Better coding standards where testing and thinking about security is almost a must. These are a must no matter what language you're using.
Take a look at this http://glowingpython.blogspot.com
Yup, i know this now. :)
Mezzanine has a blog and Cartridge can be nicely integrated. Also I like the fabric integration. It is not multi language atm though. Django Cms is multi language. You have to integrate a blog on your own though. Both are good, but not perfect. Use whatever you want really.
True, but I have worked with Wordpress and you'll not find many plugins that have test. That's very different with Django.
Does it support the creation of virtual environments ? If not, you may want to see how [pip-Win](https://sites.google.com/site/pydatalog/python/pip-win) is doing it.
Thanks! This was exactly the sort of thing I was looking for. Judging by your username and posting history, is this your blog by any chance?
I don't use the activation script at all. There's an inherent problem with running commands in an activated shell - they are stateful - you can't use the shell history without activating the right env first. If you're working on a single project then whatever but with multiple environments/projects it's a horrible mess. And you have the shell history right ? You can run "ve/bin/python" all the time without typing too much.
Take a look at web2py. A lot less daunting for beginners and powerful for more advanced programmers. Full stack like django and then some. Fantastic documentation, simple to get started. 
How do you set up an instance? I tried following the free tier but it seems like it still requires a credit card? 
I truly feel sorry for anyone working on a django project. What a pile of abhorrent shit, everything about it makes me want to vomit. Bring on the downvotes! Go on, do your worst.
Yes, It's my blog :)
How is 've/bin/python' stateless? It depends on the working dir. You still can't blindly run it from shell history.
In other words, they're going to remove the chains in the version of Django, thereby unchaining it, like the movie. 
**At least** give **one** reason why.
banana
An article that just not lists a problem but goes and solves it. 
&gt; It's not strictly one command and GO. I generally find I need to do about 10 things out of the box to get to the 'coding' part for any new project. Check out [importd](http://amitu.com/importd/)- new release will support models and coverting to a django app, too.
I couldn't give a shit about that, *at all*. If I wanted that, I'd use Flask or Bottle or whatever the cool new mini-framework is.
lol !
Almost all useful features in 3 can be gained with __future__ imports in 2.7. The only notable one missing is nonlocal.
The discussion on the mailing list about pros and cons is very good reading: https://groups.google.com/forum/#!topic/python-virtualenv/XzI8GStvKDw/discussion
Just had a look at the blog. For indentation you use 1 space - any reasoning behind it?
On a first glance I would say it will not work with nested loops. you need to keep track of newly opening brackets while looking for a closing one. This one will work: http://pastebin.com/0nDEuqPp
Be careful with deleting indexes via South that were created before upgrading to 1.5: http://south.aeracode.org/ticket/1222 Also, index_together is not yet supported by South (which makes me horribly sad, but you can just put them in the migration by hand): http://south.aeracode.org/ticket/1217
Beginner: scared by a question like this Intermediate: eager to answer a question like this well Advanced: irritated by a question like this 
I do this as well but with exit instead so I end up closing my terminal, or my ssh session. It is really annoying.
Well I didn't say it is :) But still, I think you would agree that it is less state.
Do keep in mind that deploying a Django web application is probably not going to be as straight forward as what you are used to with a PHP based solution. I also personally prefer smaller and more lightweight frameworks. I have developed my own lightweight frameworks for both PHP and Python. If I were you I'd also take a look at web2py and one of my favourites, web.py. 
I second this. I have looked into Django &amp; have avoided it so far. I like the simplicity of the micro frameworks like flask and bottle, but I also like web2py for a nicely packaged solution to a problem. 
The _other_ pattern they could be using instead is to _print_ the desired environment variables, to be `eval`d in your shell: this is what dircolors and resize do, for example. This also allows a program designed to change your current shell's environment to be written in a language other than shell.
thanks, I didn't know about web2py. I will give it a look.
What is special about deploying a django app?
That's actually interesting. So my next issues are: 1. Are there system OS differences when languages access BLAS/LAPACK? 2. How can you be sure with different languages that these are not using internal BLAS? 3. Are there some languages that don't use system BLAS? Which ones do/don't by default and how can you change it? Are there stability issues by doing this?
But if you're writing something that is compatible with 2.5 and 2.6 then we can't use argparse based on your external dependency argument and therefore must use optparse. But the "deprecated" optparse works up to (at least) python 3.2 and 3.3 if I remember correctly. 
[Here's a quick guide on deploying PyQt apps for windows](http://arstechnica.com/information-technology/2009/03/how-to-deploying-pyqt-applications-on-windows-and-mac-os-x/). Unfortunately, you need a copy of Windows to use this method. Hope this helps. 
I am new to virtualenv / flask / github and I am still confused by virtualenv... what it /exactly/ does and do I need to include my virtualenv stuff in my .git and other files when I push to github? My structure is at the moment... /project /bin /app .git randomFlaskFiles.py /include /lib 
This may have a bit more breadth than language syntax, but: * Development Methodology (TDD): http://www.reddit.com/r/Python/comments/197kay/how_do_you_test_python_generated_web_pages/c8ltozd * Programming: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html * Algorithms: http://www.reddit.com/r/compsci/comments/18pq99/open_question_im_an_undergrad_math_student_with/ * Architectural Patterns: http://en.wikipedia.org/wiki/Architectural_pattern_%28computer_science%29 * Architectural Patterns: http://martinfowler.com/eaaCatalog/
You use it so each of your projects can have separate package environments, they don't all have to use the global environment. So each project only has the libraries installed that it needs. You don't need to include anything in a git repository directly related to virtualenv. But it is handy to include a requirements.txt that's generated by pip freeze &gt; requirements.txt So that others who clone it can simply make a new virtualenv, and then run pip install -r requirements.txt And all libraries they need get installed. Note also that pyvenv exists as is preferable if you're using python 3.
I Hope this **inve** command be included in the upcoming official Virtuaenv releases.
Posted part 2, but it seems to have been buried.. http://www.reddit.com/r/Python/comments/199j5l/generators_in_depth_iterables_iterators_and/
Your right wow I totally forgot to consider that. When I get back to my computer this afternoon I'll have to see about adding that functionality 
I believe this is addressed in Python 3.3 with "yield from"
I'll experiment with it a little. Maybe if it turns light yellow instead of light gray it won't reduce the contrast as much. Thank you for the feedback.
It depends on the host that you are using. If you are using virtual servers (cloud or non-cloud based) with root access such as Linode, Amazon, etc. then it isn't a problem. Apart from those hosting solutions not everyone supports Python in their web hosting environment (although there are a number of companies providing Django hosting specifically as a service these days, look at Heruko: https://devcenter.heroku.com/articles/django). As far as I know, most Django guys also prefer PostgreSQL over MySQL and many straight forward web hosting companies hosts MySQL servers only, which is another thing to consider. A smooth running Django site requires a good amount of server admin knowledge, Django knowledge and supporting system knowledge. Hosting a standard PHP/HTML site running on a standard LAMP service requires very little knowledge comparatively. Usually you upload your site via FTP, change one or two configuration settings and away you go. 
It's not beware keyword arguments. It's "Don't have mutable datastructures as a default value". 
For what it's worth, I tried making a few apps for work with Web2Py and it went slowly due to lack of documentation and examples. Switched to Django, and had a working app within a work week. Your Mileage May Vary, of course. But I went with Django due to the larger community and larger base of documentation/examples.
wow. that's kind of daunting for what I want to do. I currently use Dreamhost. I believe they support django, but I'll have to check.
I dont use EC2 atm but use S3 storage which is also free up to a limit for the first year. Amazon did ask for credit card but they never bill me for anything so far. I think they check your CC by charging like 1$. My understanding is that they need your CC in case you step over free limits and to check you identity. There are some restrictions on Free Micro instance. For example you can only deploy some particular Linux distribs, Ubuntu and Amazon ones are among them. If you never used AWS (for example S3) then you should not be charged for micro instance. If you cautious you can start and stop it when you need it and see if you will be charged at the end of the month.
I'm using this hack. I kind of miss the PS1 mess. But, Hey! beside that, i'll use **inve** instead of activate hereafter.
no, this post explains what's happening: http://effbot.org/zone/default-values.htm
That behaviour is mentioned in [the tutorial](http://docs.python.org/2/tutorial/controlflow.html#default-argument-values) after **Important warning:**.
Cool! It's a pretty interesting blog, please continue posting more and more new snippets.
I second the recommendation for Mezzanine. With Mezzanine, you can simply do a virtualenv, install mezzanine, do python ./manage.py syncdb, and then run the site, and you will have a fully functional skeleton, complete with blog, gallery, and page structure. With DjangoCMS, you have to do more work - namely, you have to create your own templates, which is not straightforward. Mezzanine is like buying a model plane where everything is included, you snap it together and go. DjangoCMS is like buying a kit with the airframe, motors, and propellors, where you have to create yourself and add the final touches. At least that's what it was like last time I checked.
Not that it in any way addresses the author's concerns, but it seems like not everyone in the thread knows about [virtualenvwrapper](https://bitbucket.org/dhellmann/virtualenvwrapper) or its [Windows equivalent](https://github.com/davidmarble/virtualenvwrapper-win), which let you say "workon *envname*" from anywhere (with some configuration).
They actually do, which will probably make things a lot easier for you.
well that's good to hear. :-) I think I'm going to go for it. I need a new hobby project/challenge.
Ad 1). There's probably differences between OS. under windows, you're likely to run into a DLL hell. But I've never seen people do serious number crunching under Windows anyways, so I'd say that's a corner case. But more than likely, I'd assume that most packages fall back on their own ad-hoc implementation on windows. Under Linux, most distro's these days use ATLAS as their BLAS library. On a run of the mill Ubuntu installation, R, Numpy and Octave all have a dependency on libatlas3gf and liblapack3gf. Thus, they will by default use the ATLAS BLAS library. ATLAS can potentially by very fast, but only if you compile it on your own machine (because tuning of ATLAS happens at compile time). But the fastest BLAS libraries are those provided by the CPU vendors themselves. Intel provides the MKL, while AMD provides the ACML. If you're doing a lot of number crunching, it can pay off A LOT to substitute ATLAS with the BLAS of your CPU vendor. For example on an older machine I had a 12x speedup on a matrix-heavy program when switching from ATLAS to ACML! Lately I found that OpenBLAS has become really fast on both Intel and AMD cpus, so on newer machines, I will usually simply use OpenBLAS. I have no idea what the situation under Mac OS is like. Ad 2) there's a few ways. under Numpy, you can simply try `import numpy.core._dotblas`. If that import fails with an ImportError, the internal (slow) BLAS will be used. I don't think something similar exists for R, and I don't know Octave to well. What I always do is start the interpreter in question, find out it's PID and then do a `lsof -p &lt;PID&gt; | grep bla`. This shows me all the files whose name contains "bla" that the process indicated by &lt;PID&gt; is accessing. This doesn't work if the process is using ACML or MKL, but that's only the case if you've compiled it so yourself. For example on my laptop this gives: $ lsof -p 12298 | grep mkl python 12298 BeatLeJuce mem REG 8,5 4466670 141977 /opt/intel/composer_xe_2013.2.146/mkl/lib/intel64 $ lsof -p `pidof octave` | grep bla octave 12349 BeatLeJuce mem REG 8,5 6643528 410969 /usr/lib/atlas-base/atlas/libblas.so.3.0 octave 12349 BeatLeJuce mem REG 8,5 10280928 414156 /usr/lib/lapack/liblapack.so.3.0 $ lsof -p `pidof R` | grep bla R 12400 BeatLeJuce mem REG 8,5 10280928 414156 /usr/lib/lapack/liblapack.so.3.0 R 12400 BeatLeJuce mem REG 8,5 6643528 410969 /usr/lib/atlas-base/atlas/libblas.so.3.0 Showing that R and octave both use the same BLAS/LAPACK library (systemwide ATLAS install) while Python/NumPy uses the MKL -- to be honest this surpised me, I thought I had recompiled R to use MKL as well.... oh well, good to know I guess :D Ad 3) BLAS is the most widely accepted standard for matrix/linear algebra operations, thus most number-crunching libraries/applications use it. NumPy, Octave and R are three good examples, but by far not the only ones. Fun fact: the first versions of Matlab were nothing more than thin wrappers around BLAS. As for "which ones do/don't by default", it really depends on who compiled your programs for you. Like I mentioned above, under Linux you're most likely using ATLAS. If you're going to recompile everything by yourself, both R and NumPy provide you with extensive documentation about how you can use a different BLAS library. It's usually fairly easy. For example, on my desktop machine I followed (this guide)[http://osdf.github.com/blog/numpyscipy-with-openblas-for-ubuntu-1204-second-try.html] to switch out ATLAS with OpenBLAS for my NumPy machine, which wasn't too hard. If you don't want to go that route, you can usually simply switch out the underlying BLAS library. this happens by e.g. replacing /usr/lib/atlas-base/atlas/libblas.so.3.0 with a symlink to your own version of that library. However, the last time I tried this, it didn't work on my desktop, so I had to revert it. There are no stability issues by doing this. It either works flawlessly, or it won't compile/startup. You'll notice it instantly :) Another fun fact: when I stumbled upon your post yesterday, I wanted to show you that all 3 programs (R, NumPy, Octave) have exactly the same performance for BLAS/LAPACK tasks on my desktop. That's when I discovered that they used different BLAS libraries, because I installed R to use ACML (my desktop is an AMD), Numpy uses OpenBLAS (because I couldn't get NumPy to compile with ACML) and Octave uses ATLAS (because I don't care about Octave and never optimized it). TL;DR: it's actually not that easy, which is part of the reason why large number crunchers need good system administrators. If you're running a default Linux install, all of your systems will probably use ATLAS. If you are going to use one specific system to do a lot of linear-algebra stuff, definitely look into recompiling it yourself using a good BLAS library, it pays off and is not that hard! 
And virtualenvwrapper (as well as similar projects) would be a lot more simple/verifiably correct/portable thanks to inve.
pip is good. Then we added conda. Please, god, stop the proliferation of new package managers all demanding the attention of confused newbies, and making everyone think that Python packaging is impossible because you cannot just use anything
Maybe Python should not allow imports to change existing global variables. It seems like a generally insane thing to want.
I have always stayed clear of activate, virtualenvwrapper, etc and just used explicit paths to the virtualenv's bin/python. I would rather get rid of all this shell hackery, it is a major point of contention as shown by this post and it has IMO zero benefit (except "less typing", which is not worth it). It works on all platforms (including Windows), it works in all situations (e.g. when running outside of a shell session, like in crontab), it requires no shell scripting, it's not implicit state that can be changed or lost via side effects. It's the dumbest, simplest thing that works.
I just wrote [a post](http://journal.stuffwithstuff.com/2013/02/24/iteration-inside-and-out-part-2/) that actually talks about `yield from`. It doesn't make much of a difference as I understand it. Each level of the callstack still must explicitly yield.
I must have missed Flask's feature, where is can be converted to a django app and work with existing django apps, my bad.
How can Stallion confuse a newbie and how it can make everyone think that Python packaging is impossible ? Actually Stallion is complement to pip, not a replacement. I really think that Stallion is offering a visual complement to help newbies, not to confuse them, and as the main developer, you're the first one that I see that is complaining about it.
I am generally confused and lost with virtualenv. So i learned to set up OpenVZ and love it. It is much more logical to work on a virtual computer than a virtual environment for me (even though OpenVZ works more like virtualenv than say XEN). I see that this may not be the best setup for large projects, but for me its perfect!
I'd start off with doing the Django tutorial - the poll. It will give you context of how Django works. From the knowledge gained from the poll app, start on your family site. You should be good to go. I found Django enjoyable to work with, mainly because of Python. I realize there are many other Python web frameworks out there. I played with most of them. I picked Django because I knew it was going to be challenging. Plus the fact that it's named after Django Reinhardt AND I get to use that cool pink "Powered by Ponies" icon leaned the scales for me as well- http://djangopony.com/ I also use Mezzanine on a few sites. It's great and if I had to pick an ecommerce framework to contribute to, it would be Cartridge all the way.
Does Mezzanine's blog support embedded youtube videos?
My very simple equivalent (doesn't take an argument, because I use `workon` for that): alias activate='source bin/activate'
I was looking for a way to resize movies for my Android phone, so thanks for the ffmpeg tip. I made a command-line version of this, [available here](https://github.com/jabbalaci/movie2android).
Excellent idea, can't wait to try this out!
But what is the different between a S3 and EC2?
I agree, I started with some Python knowledge but no knowledge whatsoever about frameworks or web development and picked up with Django quickly enough. Yes, there's a learning curve but the documentation is so excellent and the community is so widespread that it more than made up for it.
EC2 let you run your OS on virtual machine on one of amazon servers, S3 is amazon's cloud storage solution, some other cloud storage providers host their stuff on S3, for example Dropbox. All this and much more is part or amazon web services (AWS), when you login to AWS console you can see quite a lot of them. EC2 and S3 are the only useful for an average guy, rest are mostly for running big web applications. Look through their official guide if you have not yet http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html PS: if we are talking about credit card, amazon issues just one bill for everything you use on AWS.
Ok, thank you for explaining!
The virtualenvwrapper creator is part of the discussion [here](https://groups.google.com/forum/#!topic/python-virtualenv/XzI8GStvKDw/discussion).
Another quibble with bin/activate is that it's in the bin directory. activate is not an executable script, it needs to be source'd, making it's place in a bin directory questionable. It arguably contains configuration information as much as executable information. I use Buildout, so when I want to manage shell settings for a Python project, I'll generate a file in the root of the project named 'profile'. I find the command 'source profile' much more intuitive than 'source bin/activate'. 
maybe. but this discussion does not belong to an implementation of an interpreter/compiler, it belongs to python language design.
&gt; Javascript is in many ways a functional language, as it borrows a lot from Scheme. No, it is not. &gt; If you want to do something heavier than what is possible in js, then you probably want to jump into Java with javax, which allows you to do more sophisticated things behind the scenes. You just said it: there is no middle point between Javascript and jumping into the bloated applet-based beast that is Java (or Flash or Silverlight, for what it's worth). Complex web applications are a pain in the ass to make, because Javascript is not enough. Google has already realized that there's a need for a more structured language in the browser, and while I think Dart is not going to succeed, that feels like the way web programming should go.
It would definitely be have a better ratio if it was a well thought out criticism with the proper tone, but yes people will always down vote for these types of things. Though given that the criticism that they came up with was "banana" I'm going to assume they're just a crappy troll so it doesnt really matter.
That's kind of a low bar, don't you think? Using `super()` in Python is equivalent to saying "understands inheritance". Decorators, OTOH, aren't truly *necessary*, though they are quite handy.
This is a great idea, and they seem to know what they're talking about - but I really can't justify $9 / month on something with only 3 videos in their catalog, and no trial period. Their testimonials are great, though. I bet it will be a good thing. It's a shame there is no trial.
I wrote this to circle around the costs of services like Twilio for micro apps. My wife needed this functionality for her job, and we both thought that paying Twilio for it wasn't a good option. So I wrote this, and it gives you the same basic functionality. It works, and she is happy. It works by using the option mobile carriers give you to send text messages through an email address. Questions are welcomed. By the way, I'm available for Python contracts. :)
Why is it that people ask for the best minimal framework ? What about maximal frameworks ? :)
Cool, you can come and teach me when you find out how to use it.
Happy cakeday. I'll teach you... or at least tell you what resources to pursue (if you need some guidance).
Reminds me of Destroy All Software. a lot. not necessarily a bad thing. However the demo video is useless; snippets smash cut together such that you wont know what to expect from a "normal" episode. It would be better if the demo were two short, but complete, mini-lessons: one simple, one complex.
When I interview people, I use tricky questions -- they sound like conversation, but what they really do is tell me your skill level without ever asking you directly. For example, I won't ever quiz someone on something like "how do you find the number of members in a tuple?" or "what method in itertools can I use to iterate over multiple collections?" because that's all academic. Any fool can memorize definitions, formulas, or syntax. Instead, I'll ask things like "In your opinion, what is the most compelling reason to start using Python 3? And under what circumstances should I *not* upgrade?" "What is a feature that you think they got wrong in Django?" If you can give me a reasonable answer to that type of question, it will demonstrate to me that you have knowledge of the tools -- enough knowledge to form opinions. It also demonstrates at least *some* measure of critical thinking and (hopefully) business-oriented decision making. My point is... I'm not ever going to welcome someone in based on some project they had on their resume. There are plenty of idiots in this world who have the good fortune to work with bright people on interesting projects. It's better to weed them out and find the ones who actually understand those projects.
Once there are more videos I will be releasing the beginner screencasts for free soon. The demo is supposed to give you a feel for the content and quality of the videos. The more intermediate and advanced talks will always be paid. hit me up admin at neckbeardrepublic.com lets see if we can get you in.
I was trying to give a feel for types of talks I would be giving, demo videos like this are tough and hard to please all the crowds beginners and more advanced python developers. I think it does highlight the quality of the videos and polish we put into them. 
Isn't *method_missing* roughly the analog of __getattr__? Ruby distinguishes between methods and attributes of course, but you can always just return a callable from __getattr__ if you want to have on-the-fly methods. I was more surprised that list comprehensions and generators weren't covered. But all in all it was a pretty good overview. [Edit: Sigh. I give up on formatting getattr in markdown.]
`tsocks`uses sub shells as well
Well no, not really cssh from what I can see seems to be gui based. Mine is terminal based.
Check out my blog too! http://fulmicoton.com/ I don't know if I'll stick to python, nor if I'll stick to math / algorithm stuff, but that's the case for the 3 first posts. 
I wrote this to be used on Red Hat 6.2 originally which was 2.6.
Fabric isn't interactive, my script keeps multiple ssh sessions open and accecpting input.
Thanks for your comments, just want to say that ssh_f function exists to be called by a thread. There may be a better way to do it...
Javascript has first class functions. See: http://www.ibm.com/developerworks/library/wa-javascript/index.html For reference. I'm not saying Java plugin in the browser, I'm saying use Java to generate the javascript, this is what Rhino does (I got the name wrong before - not javax...)
I also disagree with this: &gt;`tuples should be homogenous` socket.socket expects a tuple containing a string (IP) and an int (port). In fact, if anything, lists tend to be homogenous more often than tuples are. But of course it doesn't really mean much either way.
I would just open 2 shells. (each inside a screen, tmux, or tab).
Hi there! Thanks for your input. I realize there is definitely a need for provoiding those not a part of Office Scripts a more immediate access to the scripts we have. However, for right now and for the near future, on the [Office Scripts page](http://alouis93.github.com/Office-Scripts/) we have a Script List that will constantly be updated that links to the each individual project. Each project will be hosted on their indivudal gits, each of which will be (and are as of right now) documented extensively. A solution for this problem in that will be implemented in the very near future will be to add a page to a dedicated Office Scripts website that constantly updates and adds on as we work on new projects. If you (or anyone else reading this for that matter) has any ideas about increasing access and/or availablility of the scripts, do send us a message!
&gt; "Fast, agile performant websites" Isn't *performant* just a pretentious way of saying *fast*?
Is there a way for your virtualenv to use your system environment so you can install a package once and every project can use it without having to update each manually?
Give the version you are doing that, i'm assuming its 2.6 or 2.7.
The solution doesn't imply to break a workflow. virtualenv could have both activate and inve in the bin directory. The user could choose what to use.
this is true
2.7
Of course, within the bounds of engineering constraints. It's not perfect and there is latency in that whole system of sampling accelerometer values -&gt; value above threshold -&gt; send park command -&gt; hard drive parks the head. Rely on it if you want but most of the notes in the README of hdaps or other drivers for disk parking utilities have a "test this by bumping your laptop while tailing log file X. Obviously you don't want to do this too much". Parking is a last resort from what I gather. Not a free pass to shake your hard drives around all the time. I could be wrong though, it's not my expertise.
I didn't know about list comprehension for a long time, which is really silly since the documentation goes over it quite well. Being able to do stuff like any([x for x in myList if x &lt; 1]) is really nice. Apart from that I'd say that understanding generators and the nature of iterators is quite useful. Being able to use the "next()" function on an iterator object has come in super handy with files, for instance.
Or, and I know this is crazy talk, perhaps a solution that allows both could be found? I know, it is simple to have the 2 side-by-side, but what always happens then, is you end up with one ecosystem for option A, which has a bunch of cool stuff, and an ecosystem for option B, with a bunch of cool stuff. The intersection of the two ecosystems will not be the union of the ecosystems, at which point it always really sucks when you want or need stuff from both. Maybe I'm just stupid and missing how this time it will really be different from every other bit of useful software that's gone through this ever, and we won't end up in this situation. So explain it please.
`\_\_getattr__`: \_\_getattr__
Yes, I'd also avoid activate and just put the virtualenv at the root of the project dir and just use `.env/bin/python`. It's more explicit and much easier to explain.
Our deploy script take care of correcting the shebang path in each script to point to the correct virtualenv. It just a line of sed and I think it worth it.
a = b if c else d
I guess that eventually everyone who sticks with python learns all about iterators since they're so ubiquitous in the language. You can barely write a line of python code without using an iterator, even if you have no idea you're doing so! The for loop is a perfect example of this. For at least a year after I learned python I had no idea that the for construct was actually creating an iterator and calling its next() function in order to loop through the sequence I was giving it. I always wondered how exactly it knew to terminate the loop, and then I realized it was receiving a "Stopiteration" exception when calling the iterator's next() method when there were no more values in the list (or tuple or whatever). I guess it's basic, even obvious, but it still sorta blew my mind.
It's pretty crazy, especially considering that it relies on using an exception to stop iteration. It says something about the design of Python and how you should go about using exception and iterators in your own code. There can probably be entire books written on how the for loop works in Python, and what its implications are.
Truth. Just for demo purposes, though. ;)
Control-R in the interactive interpreter prompt. It's not actually python, though. It's libreadline.
Yoink! — *the sound of me stealing that*
I like this one too. Reminds me of the ternary operator in C, but more readable.
The solution that I'm aiming for will enable both workflows. Where I wrote "[re-enabling environment modification](https://gist.github.com/datagrok/2199506#re-enabling-current-environment-modification)" I describe partially how it would works. I wouldn't consider this proposal "done" and ready for inclusion in virtualenv proper unless I successfully avoid breaking [almost anyone's](http://xkcd.com/1172/) workflow.
I expect that when I'm done, the folks who work this way (overwriting their environment variables upon switching environments) will be able to continue to do so, while the folks who `deactivate` before changing environments, or have a separate terminal window / screen / tmux session going per-environment will have a much cleaner and easier way of managing them. The main thing that spawned this gist was my inability to hit my window manager's "run" button and say "launch gnu screen activated in that virtualenv over there, so that each new window is already activated."
I mention this in that gist, under "[re-enabling environment modification](https://gist.github.com/datagrok/2199506#re-enabling-current-environment-modification)."
I think my favorite trick with IPython is simply dropping into IPython any time I want by importing embed: &gt;from IPython import embed then dropping embed() anywhere in my code that I want. Quick and dirty way to do a little variable inspection.
Few things I wished I learned about sooner than I did - 1. @decorators - http://stackoverflow.com/q/739654/225903 2. pdb - http://docs.python.org/3.3/library/pdb.html 3. List comprehensions - http://docs.python.org/2/tutorial/datastructures.html#list-comprehensions 4. IPython - http://ipython.org 
I mentioned at the bottom of the gist under "[Don't mess with my prompt](https://gist.github.com/datagrok/2199506#dont-mess-with-my-prompt)" how I re-enable the PS1 damage. It's kindof a minefield because, at least in Ubuntu and Debian distros, by default there's some PS1-setting stuff in the system-level shell init scripts in /etc. This means you can't assume your PS1 customizations will carry through into a subshell! (Unless you edit those root-owned system level RC files, which is inelegant to me.) Most folks end up just setting PS1 in their user-level shell rc files. I describe in the gist a way that you can sock a "context" placeholder in there, and interact with that when you're using virtualenv or git or whatever else.
I really like one line sorts. Coming from java this was a blessing. users.sort(attrgetter("username")) dict's setdefault is actually quite awesome too. Instead of doing something like: if key in some_dict: some_dict[key].append(foo) else: some_dict[key] = [foo] You can just do: some_dict.setdefault("key", []).append(foo) It's not as readable but for simple things it's quite neat. I'm aware that there's also defaultdict but this makes it more explicit.
Granted, this didn't come out until the version after the one we were using, but it cleans up so much code: with open('file.txt') as inf: inf.read() and with mutex: do something The automated cleanup, even in exceptional conditions, saves you so much boilerplate code.
 &gt;&gt;&gt; (1) == 1 True &gt;&gt;&gt; (1,) == 1 False
things like : a = b if c else d previous,current = current,list[x] if you want to keep track of the current and previous elements in a list, for example
I'm still learning but the stuff I learned lately that I really enjoyed were list comperhensions, selective imports into local namespace, print &gt;&gt; syntax. 
I am currently reading/fixing beginner Python code. And there are two things I wish the author knew: * You don't need parentheses in `if` conditions. So Instead of writing `if (a==1): ...` write `if a==1:` * Many things are consideres `False` in a boolean context: `0`, `[]`, `()`, `""`, ... (See [Truth value testing][1]). So instead of writing: `if mystring != "":` you can simply write: ~~if not mystring:~~ `if mystring:` As a side-effect, this will automatically take care of `None` as well, so you are much safer as in Java regarding the pesky `NullPointerException`. [1]: http://docs.python.org/2/library/stdtypes.html#truth-value-testing
List Comprehensions (because they didn't exist yet when I learned Python (v 2.0))
Reverse a list: mylist[::-1]
To expand on this, run any buggy program with 'python -i foo.py'. Then when it fails it'll drop you in the interpreter, and you can type 'import pdb; pdb.pm()' to be dropped in the debugger where the program failed. Can be super helpful sometimes.
Lambda syntax is a bit awkward in Python (in opposition of functional languages, where you can usually use partial application). I think it's easier to read generator expressions or list comprehensions in Python.
You can just call mylist.reverse() 
I literally just got a rush of dopamine from this. pdb is one of the most useful things you can learn as a python dev, other then using ipython.
Good point to raise! Parentheses do NOT signal Python to create a tuple. It's the commas that actually denote a tuple. Edit: To clarify: &gt;&gt;&gt; a = 1, &gt;&gt;&gt; b = (1) &gt;&gt;&gt; c = (1,) &gt;&gt;&gt; repr(a) '(1,)' &gt;&gt;&gt; repr(b) '1' &gt;&gt;&gt; repr(c) '(1,)' a and c are tuples. The comma separated list of names creates a tuple. The parentheses has nothing to do with it.
Another one I wish I knew earlier: using dir() for object introspection, and the general power of introspection within the Python interpreter. With an argument, dir will return all attributes (this includes methods) of the object. &gt;&gt;&gt; foo = [1, 2, 3, 4] &gt;&gt;&gt; dir(foo) ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', ...
This and the combined try/except/finally helped clean up so much ugly code.
How to empty/reset a list. many failed attempts rebinding a local name to a new empty list or writing nasty while l: l.remove ... Loops When you can just write l[:] = [1,2,3]
I like this easter egg: from __future__ import braces 
mylist[::-1] returns a new reversed list; mylist.reverse() reverses mylist in place. Both useful for different things.
Related to this, you can copy a list (as opposed to make an alias for it) with y = x[:]
Dictionary comprehension. Instead of dict((k, v) for k, v in some list)
That 2nd point is excellent, for ints, strings, and lists. You have to be careful, because the boolean value of more complex objects may not be straightforward. For example, the `time` representation of midnight evaluates to `False` for some reason: &gt;&gt;&gt; from datetime import time &gt;&gt;&gt; x = time(0,0,0) &gt;&gt;&gt; bool(x) False &gt;&gt;&gt; y = time(0,0,1) &gt;&gt;&gt; bool(y) True 
There's also the [reversed](http://docs.python.org/2/library/functions.html?highlight=reversed#reversed) builtin wich returns an iterator.
Magic methods! Once you know how to implement custom operators and comparisons using `__add__`, `__le__`, `__gt__` etc, a lot of classes can be drastically simplified. Read this for more info: [http://www.rafekettler.com/magicmethods.html](http://www.rafekettler.com/magicmethods.html)
And then a bit of both: `ipdb`.
It's not accidental. Guido van Rossum is explicitly trying to *avoid* functional programming styles in Python. Informative StackOverflow link: [http://stackoverflow.com/questions/1017621/why-isnt-python-very-good-for-functional-programming](http://stackoverflow.com/questions/1017621/why-isnt-python-very-good-for-functional-programming)
Generator isn't _necessarily_ faster though. In [1]: myList = [5, 3, 2, 5, 6, 1, 6, 2, 5] In [8]: %timeit any(x for x in myList if x &lt; 3) 1000000 loops, best of 3: 437 ns per loop In [9]: %timeit any([x for x in myList if x &lt; 3]) 1000000 loops, best of 3: 341 ns per loop of course, the difference is somewhat minor. It's when you work with gigabytes-sized numpy arrays it becomes a bit more important.
&gt; a pain when using the debugger, as pdb wants to hit that line for each element There's a command `unt` for that (and useful for any loop at all, not just the comprehensions).
Thanks all. I am the author of the course. Let me know if you have any questions. Cheers!
&gt; dict's setdefault is actually quite awesome Not to mention the `collections.defaultdict`. Especially like that: `defaultdict(lambda: defaultdict(list))`.
&gt; may not be straightforward In python 2.x the special method name for it is `__nonzero__()` (C-style a bit); that explains quite a bit of the nonstraightforwardness. 
Another tip: When working with HTTP, instead of mucking about with the `urllib2` library, use the excellent [Requests](http://docs.python-requests.org/en/latest/) library instead.
http://cx-freeze.sourceforge.net/ (.exe) and http://svn.pythonmac.org/py2app/py2app/trunk/doc/index.html (.dmg) are also good options
... available in a more convenient form as autocompletion in `ipython`, `bpython` and such. Also, its results can be redefined with `__dir__`, which is useful, for example, in RPC implementations; although you have to be a bit careful and explicit about including network calls in such normally-trivial methods.
And `import IPython; IPython.embed(banner1='...')`
This may not be for the beginner learning Python, but still a good tool to know about: dis module. import dis dis.dis(some_function) This will print out the (disassembled) Python bytecode for the function *some_function*. If you are doing profiling, looking for differences in performance of two different chunks of code that do the same thing, or are simply curious about how the interpreter sees your code, this is very useful. More details here: http://docs.python.org/2/library/dis.html Side note: as I have learned from dis, making a dictionary with dict() and {} actually have a difference, with {} being quicker. Take a look at the disassembled bytecode to see the difference!
Even that explanation doesn't quite cover it though: `()` I suppose here it is the absence of commas within a parents group which does it? But this gotcha is why I always, *always* wrap tuples in parentheses, for consistency.
You know pudb?
Any interesting presentation/tutorial of the opposite? Ruby for Python Programmers. 
could you please elaborate on print &gt;&gt; syntax?
I like minimal frameworks and distros (arch) because I can know all of the things in that thing and I know How does it work :)
In your example `if mystring != ""` actually translates as `if mystring:`.
How is it different from `l = [1,2,3]`? The reference `l` now points to this new list and the garbage collector will take care of the old list where `l` referenced before.
 import sys print &gt;&gt;sys.stderr, "Warning! Reactor breach. Leave the facility immediately!" with open("out.txt", "w") as f: print &gt;&gt;f, "first line"
Why not y = list(x) ?
Instead of i = 0 for item in iterable: print i, item i += 1 Do for i, item in enumerate(iterable): print i, item A fun easter-egg import antigravity 2.7's dict/set comprehensions my_dict = {i: i * i for i in xrange(100)} my_set = {i * 15 for i in xrange(100)} Force float division from __future__ import division print 1/2, 1//2 Need to quickly serve files from a directory? $ python -m SimpleHTTPServer Use pip instead of easy install. $ easy_install pip Safely evaluate python expressions... expr = "[1, 2, 3]" # instead of my_list = eval(expr) # do import ast my_list = ast.literal_eval(expr) Easily profile a script... $ python -m cProfile my_script.py
+1 for pprint also using pprint for defaultdicts `pprint(dict(d))`, where d is the defaultdict.
If you don't have a good reason not to, I'd recommend importing print_function from __future__, since that will be the default in Python 3. With the print function you can just specify the destination file as one of the function arguments.
Dear FSM, yes! I just found this library a couple months ago; my first thought was, "Why didn't I know about this three years ago?"
I have made more use of this than I should be proud to admit. Great way to handle some of the "less-than-adequately" documented modules/objects.
Pandas
Agreed. Elements in lists usually have the same type (but we are not enforced). However, in tuples we usually store elements of different types. Imagine a tuple as a record, or like the record of a database table. Imagine a movie table where you get movies as tuples: movie = ("Star Wars", 1977, 8.8) # last data is imdb rating
 l = [i for i in range(10)] Seriously, list/dict/generator comprehension syntax is underused and under-appreciated. Once I learned how to do that, `map` and `reduce` took on a whole new dimension of awesome. **EDIT:** advanced string formatting is also *really* cool. You can make a string with variables that can be filled by positional or keyword arguments. For example, `"Hello, {0}!".format('world')` returns `"Hello, world!"`. For a keyword example, `"My name is {n.first} {n.last} and I live in {n.country}!".format(n=name)` returns `"My name is Omg Internets and I live in the internet!"`, assuming that the `name` variable contains an object with `first`, `last` and `country` attributes.
&gt; and does a buttload of other handy stuff. Seriously, for science work, the marriage of IPython and Matplotlib is the best thing since sliced bread.
ipython: %edit -p
I thought that was the whole point as well, is that you don't overuse them, and you only use them when you truly are warranted 
quite easy to use and has that rails feeling with all the beauty of python
Does that create a 2D dict of lists? So you can do d[4][5].append ?
L[:] is also a function call...
I would have to test it, but you could have some difference like this: http://doughellmann.com/2012/11/the-performance-impact-of-using-dict-instead-of-in-cpython-2-7-2.html
if...elif...else... can be simplified and could be mentioned. Instead of ... elif n==1 or n==9 or n==4: ... You could write: ... elif n in [1, 9, 4]: ...
Mail server for debugging (prints mails to stdout). Example for port 1025: python -m smtpd -n -c DebuggingServer localhost:1025
In some cases, they make the code extremely readable. for instance, this is bottle.py from bottle import route, run @route('/') def index(): return 'Hello!' run(host='localhost', port=8080) Here, the route decorator maps a route, in this case, the root URL to a GET request processed by the index function, thus sparing us the boilerplate for the mapping. I find this a nice and readable structure. Other scenarios, in web-dev include checking if a view is to be served only to authenticated users etc. They contribute tremendously to readability when used appropriately and, ofcourse like most features, hurt when used without proper discretion.
Yeah. You can also use constant values, so creating an array of size 10 where each element is initialized to 0 is as easy as: li = [0 for _ in range(10)] (If you don't use the loop variable, you can write `_` instead. It means: "I don't need its value.").
Yes, exactly.
Since the brackets are a literal, the interpreter doesn't have to start by checking if `list` has be redefined. Slightly faster, in theory. 
All you need for that is the functional.js library
'enumerate' takes a second parameter that set the start of the index. So if you need to index from 1, you can do enumerate(sequence, 1). 'sum' is useful for counting items in a sequence that pass a condition. Just sum the value of 1. ripe_count = sum(1 for fruit in fruits if fruit.is_ripe()) 'iter' returns the iterator object used by for loops which may be used independently. It has a 'next' method that returns the next value in the sequence or raises a StopIteration exception. &gt;&gt;&gt; fruit = ['apples', 'orange', 'pears'] &gt;&gt;&gt; iter_fruit = iter(fruit) &gt;&gt;&gt; iter_fruit.next() 'apples' &gt;&gt;&gt; iter_fruit.next() 'orange' The iterator protocol is one of Python's most powerful features. Well worth learning early on.
The double bracket syntax is an ugly hack. They fixed it in Python 3 by making `print` a function. Just use Python 3 and try to forget that awful double bracket thing was ever necessary. ;-)
You can also use it to quickly reverse a string, e.g.: `'aibohphobia'[::-1]` returns `'aibohphobia'`
As far as I know cx_Freeze is the only one that works with Python 3, but I may be wrong on that. It does work like a charm though, even with more complicated stuff like PyQt.
&gt;It means: "I don't need its value." Don't ask me for details, because I don't actually know the details, but I believe that the `_` operator actually means "most recent output" or something similar. If you do `[_ for i in range(10)]`, you get `['', '', '', '', '', '', '', '', '', '']` -- a list of 10 empty strings. If you run that same line *again*, however, you get a list of ten elements, each of which is the original list of ten empty strings. If some python guru could weigh in with additional details, that would be cool!
The sign `_` in the *shell* means "most recent output", yes. Example: &gt;&gt;&gt; 20+5 25 &gt;&gt;&gt; _*2 50 &gt;&gt;&gt; _+20 70 But when you write a script, you usually use it as a loop variable when you don't need its values.
What does this do?
&gt;in the *shell* Noted! I can't really see where it would be used as anything other than a placeholder for an unneeded value, but I figured it was still kind of cool!
It's very handy if you use the shell as a calculator.
How do you enable that?
I thought we were discussing of development env not deploy env
Because it didn't exist back then? The oldest release is from two years ago, and it took a while to mature.
Or from __future__ import print_function If you can't make the switch to 3 but still want that print() goodness. E: just noticed someone below already suggested this. Ho-hum.
now this is helpful! I use shell for quick math!
Install ipython
Good point, I guess it's exactly equivalent to Matlab's `ans`. My python shell calculatronizations are going to get a whole lot more awesome.
You already pointed out the difference. My local reference points the new list and only my local reference. The problem is when I care about the other references to the list and actually want to change the content.
Another quick question. Is this somehow more efficient that doing `[0] * 10`?
I've now seen so many IPython comments, and I have to ask, what makes IPython so much better than say PyDev for Eclipse or the like?
+1 for list and dictionary comprehensions
It seems simple, but swapping variables around thus: foo,bar = bar,foo
Not exactly a _trick_ or a _snippet_, but: metaclasses. They really changed the way I see the language. There is an excellent [introduction](http://stackoverflow.com/a/6581949) on stackoverflow that does a great job at explaining them to beginners.
A yes of course, that's true
enumerate() - http://docs.python.org/2/library/functions.html#enumerate sounds like a small thing, but I've actually discovered it very late, and it's so useful.. 
My two cents. If you want to promote those scripts in the community into some kind of unified project, I suggest doing the following: - reunite everything in a single repo. having one script per repo is not a good idea. we're lost - package them. add a setup.py and make them console scripts, structure your project in a python package - make sure all the features can also be called as libraries functions/classes/methods - run flake8 (or pep8+pyflakes) - add a sphinx documentation HTH
Different use cases. I would use pydev to write a program, but IPython is very good for interactive sessions. Examples of where IPython is useful: * Any time you run a script using %run(), all the variables and methods of that script get dumped into the local namespace. * You can reference output and input by line. For instance you can edit the last five lines of input in an editor. * Tab completion and very simple access to all local variables. * History across sessions. * IPython notebook is also cool probably, but I don't use it.
I find this to be infinitely more attractive than using slicing.
cx_Freeze can also do .dmg packages, if you run it on a mac. I use it to package an application for Windows &amp; Mac. It doesn't have a 'single file' mode yet, though.
I agree. Sometimes, I even want to use `reversed(range(x, y))` instead of `range(x, y, -1)`.
I don't go that far since I think that the `range` function is pretty simple and complete as is, but I can see where you're coming from.
If you don't/can't always use ipython, you can use this trick too: http://pymotw.com/2/rlcompleter/index.html
What do you mean by automated cleanup? Does this close the file after the with block ends?
Hint: That doesn't work reliably in some markets. E.g. in Germany the receiver pays for receiving messages from the e-mail to SMS gateway. But because paying for receiving messages or calls is unsual in Germany, this functionality is disabled by default. The receiver would need to enable it first, but most customers don't even know about it.
No. Even if it had existed for the past five years, I wasn't aware of it until about two months ago. Mostly just the frustration of learning of an easier path after you've walked a hard one. C'est la vie.
Yes. See the end of section [7.2.1](http://docs.python.org/3.2/tutorial/inputoutput.html#methods-of-file-objects).
Sorry to hear that, did you start with their free book? I found the documentation to be at least on par with django and better than Grails in many (but not all) cases and had a work app up in significantly less time in web2py due to the inclusion of a front end framework and sane defaults. What kind of app did you build just out of curiosity? 
That's clever! Never thought of using them that way!
Also, if 3 &lt;= x &lt;= 9: does exactly what you think it does.
This will probably anger some but the scripts should all be runnable on Python 3.3 or better. In fact that should be a requirement for anything listed in your collection. As somebody else mentioned finding the scripts needs to be easy. I'm not sure what is the best way to go about that but it will rapidly become a requirement if this little repository takes off. Another requirement should be that the scripts are operating system agnostic. If not it should be clearly explained why they aren't. Obviously not everybody has the hardware to test on every OS so we also would need a way for third parties to verify use on alternate OS's. The ideal goal would be that every script runs every where and if not it is clearly indicated why it does not. 
Which part? The ipython part launches [IPython](http://ipython.org/). The %edit part says to open your text editor so you can use it instead of the interactive shell to input your code. When you close the editor IPython will run the code. And -p says to open the editor with whatever was in it the last time you used the edit command in this session. So you do %edit -p, put in some code, save and close the file and then it runs. Then you do %edit -p again and the same code comes back up for you to edit/run again.
Each has its own use case. If I need a reversed copy of a list that I can in turn slice, I need a real list, not an iterator. 
the zip function especially this : zip(*[('a', 2), ('z', 4), ('e', 6), ('r', 8)]) -&gt; [('a', 'z', 'e', 'r'), (2, 4, 6, 8)]
Thanks, I didn't know that :) So far I've used `*` with strings, like `separator = '-' * 78`.
I'm not sure this is a performance boost: you're rebuilding the set every time, so it has to check for the presence of 1, 4, 5, and 6 to build it; it's O(n) anyway. This might be worth benchmarking. edit: Here's the worst-case (not found) benchmark for small inline creation. In this case, the list performs significantly better: $ python -m timeit 'if 9 in [1, 4, 5, 6]: pass' 10000000 loops, best of 3: 0.0808 usec per loop $ python -m timeit 'if 9 in set([1, 4, 5, 6]): pass' 1000000 loops, best of 3: 0.351 usec per loop If we set up the numbers in advance, though, the performance boosts are already apparent, even for such a small set: python -m timeit -s 'nums = [1, 4, 5, 6]' 'if 9 in nums: pass' 10000000 loops, best of 3: 0.066 usec per loop $ python -m timeit -s 'nums = set([1, 4, 5, 6])' 'if 9 in nums: pass' 10000000 loops, best of 3: 0.0331 usec per loop It's even more obvious for larger sets of numbers: $ python -m timeit -s 'nums = range(0, 1000, 7)' 'if 9 in nums: pass' 1000000 loops, best of 3: 1.52 usec per loop $ python -m timeit -s 'nums = set(range(0, 1000, 7))' 'if 9 in nums: pass' 10000000 loops, best of 3: 0.0315 usec per loop
OK, I see. I thought you wanted to point on a new list. Here is an example of what you described: &gt;&gt;&gt; l = [1,2,3] &gt;&gt;&gt; g = l # g refers to the same list as l &gt;&gt;&gt; g [1, 2, 3] &gt;&gt;&gt; l[:] = [5,6,7] &gt;&gt;&gt; g [5, 6, 7]
Thanks for the pep-8 link :)
What's the advantage of pdb over just opening an interpreter? `import code; code.interact(local=locals())`
This is the only place I've seen decorators used, as routing agents in bottle.py and Flask.
I actually thinks it's less readable than C's syntax for the ternary operator. To me the condition should be first and not the result. condition ? result : alternative; looks better than result if condition else alternative but maybe that's just because I've written a ton of javascript.
The example was pretty contrived; if you're going to do this for performance reasons, it would be best to store it somewhere it won't be re-created every time.
enumerate
As selementar suggested above, `collections.defaultdict` can be even easier. from collections import defaultdict t = defaultdict(list) t["answer"].append(42) It does the same as the `dict.setdefault`, but assumes a default value for every item. In this case, `list()` is called whenever something not in the dictionary is asked for.
I'm debugging using ipdb - see the line where I set trace, that's where I can execute the line I pasted. Then I type "cont" and when it gets two lines down to the exact same line I had just successfully executed, it breaks
Your way works fine if your initial values are immutable. List comprehension is safer - [see here](http://en.wikibooks.org/wiki/Python_Programming/Lists#List_creation_shortcuts) for why.
And where do you define your default text editor?
They also show up in Django, for example: @login_required def my_view(request): #Do something that requires the user to be logged in
I pronounce it both ways in my head, and I can't figure out the pattern my brain is using.
Would that not just shift the complexity over to the initial construction of the set?
And god help you if you replace b and d with functions that you don't want to run unless necessary: a = (lambda: b(e), lambda: d(f))[int(c)]()
I started with the Web2Py Application Development Cookbook and the online documentation, but I found the cookbook's examples were somewhat limited in scope, and if your project doesn't mimic or mirror its example projects, it was a little difficult to determine how to proceed. In Django, if I had trouble figuring something out, I could just Google "Django &lt;thing I'm trying to do&gt;" and I'd recieve several Stackoverflow results. I could get this kind of result occasionally with Web2Py but not as often. I'd chalk that up to the size of the userbase for each stack. My first app was an inventory tracking system for our fixed assets. And for what it's worth, I'm a beginner in Python as well. So to be fair, it could be more of a programmer deficiency than a Web2Py deficiency :-)
I don't know how to do this explicitly as part of calling the DataFrame. When I've run into this problem, I casted after the fact with either of the following: Passing a type to each column: self.sample['x'].astype(int) But since you're passing functions, you will probably need to use the following: self.sample['x'].map(_pos_cnvrt) self.sample['msg'].map(lambda s: s.strip()) Also, pandas has some baked in vectorized string methods to help: self.sample['msg'].str.strip() 
`with` is pretty nice. But what didn't know a long time, it doesn't create a new scope. So this works: &gt;&gt;&gt; with open("/tmp/foobar") as f: ... content = f.read() ... &gt;&gt;&gt; print content lorem ipsum 
Install bpython
For the lazy: &gt;&gt;&gt; from __future__ import braces File "&lt;stdin&gt;", line 1 SyntaxError: not a chance &gt;&gt;&gt;
People who think programming is cold and unfeeling don't understand. Programming, like any human endeavor, is an emotional roller coaster. Though this post was tongue-in-cheek, it reminds me of the feelings I've had of complete frustration and desperation, followed (sometimes) by total elation after solving a difficult problem.
It's a very utopian depiction of a typical programming environment for people who are young, super smart, and live in the right neighborhood. Very few programmers qualify on all 3 fronts. You are more likely to have a grey standard cubicle than an individualized office or desk. You aren't going to have a foosball table. You won't be playing basketball or having spontaneous jam band sessions. Playing video games openly at work is also generally frowned upon apart from the odd Flash game now and again. Break activities are going to be basically walking, talking, and poking at your smart phone. Optionally, you'll also be going out to some restaurant somewhere with your colleagues. In some places, you might get free food. (my company does for people in and out of I.T.) Depending on the company, you might get employee discounts at some retail stores. Sorry to be the downer here but that's just the way it is in most places.
Wow, thanks.. I didn't know that was possible.
My actual software? Not technically. I made it pretty generic, but not enough that someone else could use it. It was built specifically for an weather instrument built by the University of Wisconsin - Madison, Space Science and Engineering Center (who I work for). The only copy of the code is on our local subversion repositories, sorry. Maybe some day I'll make it public and usable for others. (sorry about taking so long to reply, forgot to check reddit messages)
Yes. It ensures that the file is closed/the mutex is released, even if there's an exception while the inner code is being executed. It's a context manager, if you want to look up more details.
I'll look it up. Thanks!
"And when everyone's super... no one will be." - Syndrome
it also closes the file if an exception is thrown that is not caught within the block so you don't have to sprinkle try/finally blocks with your opens.
I like ipdb a lot more, it has tab completion plus a few other nice to haves that I forgot about since I stopped using pdb right away.
How often do you do the literal_eval? It seems like it would be easier to use json.
I have the depicted work environment ;) and i worked in an marketing company before that, where it was rather dry. Depends heavily your branch. And i know a lot of smallish companies who have it too.
defaultdicts make me moist
import antigravity doesn't work in py 2.6.6
that is pretty slick, I have to admit.
immu-tuple.
Rarely. If you can, use `json`.
A generator expression creates a new frame (which is why they don't leak the iteration variable whereas a list comprehension does) and so they are *usually* slower than a list comprehension. They're more *memory efficient* than list comprehensions though, because they're lazy rather than eager. In the case of a filter like "any" a generator expression may still be faster as it can "short circuit" if it finds a value.
http://ipython.org/ipython-doc/stable/config/editors.html
I learned about the try:/else: clause recently. Super useful in some situations. try: something except: handle the error else: #ONLY happens when try: block completes without error finally: #Still happens after else. The else clause can be really useful with mixed leap before you look styles. It allows you to do something with data (such as execute a class method that only the intended type/data will have), then do the rest of what you want to do if no errors are thrown, all before performing the cleanup in finally.
Google first. Almost everything you want to do has already been done. Best case, you will find code that you can just use as is. If not you can learn a lot by looking at other people's code. Corollary - if you find nothing on Google, you are probably doing it wrong. 
Definitely, developing cross OS scripts was an implicit requirement, I will amend it to the project's submission guidelines. I have received some excellent suggestions regarding making our scripts more accessible, and that is something we will be working on as a priority. The only thing that you mentioned that I am having a difficult time with is whether or not to make a gradual switch to Python 3.x, I will raise the discussion over at the subreddit.
That's a very interesting point. I noticed that the majority of the people interviewed and supporting code.org are from corporations (Facebook, Microsoft, Dropbox, etc.). Corporations want to increase supply in the workforce so they can make hiring easier and lower salaries and benefits. I agree that everyone who's interested in programming and solving problems with computers should learn how to program. But a bunch of corporations getting together to make a commercial saying "programmers are rockstars!" and showing off free food/money/games is transparently disingenuous and self-serving to the corporations, because all those benefits will be gone when everyone can program. I don't think they've overlooked that fact. The main goal of code.org seems to be marketing and making programmers look sexy, not to actually help people learn how to program.
zomg ipdb. never wonder about anything ever!
Ipython is my go-to source for python documentation. Tab completion for object members, and ? or ?? for function docstrings and signatures.
or you can pip install debug and use import debug and enjoy pdb with ipython
1. any/all/sum 2. iterators/generators 3. descriptors, and how central they are to Python's object model
Greetings, fellow Squeeze user?
Careful there: while pickle is useful for internal/temporary serialization, it's not suitable as a data interchange format. You can craft a pickle that executes arbitrary code when loaded.
How exactly does this work in Python? I've always wanted to do this in C/C++, but it's always been explained to me that it's impossible. How does Python handle it?
There's less with Python that's jaw droppingly *wat*, but there are small bits that are confusing or inconsistent. Traditionally, these have been called "Python warts," so try googling that. One off the top of my head: default arguments are evaluated when a function is defined, and never reevaluated. As a result, def func(item, l=[]): l.append(item) return l will use the same list object each time you call it with one argument. 
 def foo(bar=None): if bar is None: bar = [] And the same for dicts.
Nope, never used Squeeze, but it looks interesting!
As one line: from pprint import pprint as print
Language wise it's fine, but on the interpreter level ...
An interesting consequence of this was discussed in [this article](http://nedbatchelder.com/blog/201302/hunting_a_random_bug.html)
I got burned by this once when developing a recursive function. Never again. 
https://github.com/mgedmin/dotfiles/blob/master/python
You could do: def foo(bar=None): bar = bar or [] 
It's more of a performance consideration. valid_answers = set(['Y','y','N','n']) def confirm1(): answer = raw_input('Confirm [y/n]: ') if answer in valid_answers: return answer def confirm2(): answer = raw_input('Confirm [y/n]: ') if answer in ['Y','y','N','n']: return answer The difference between confirm1 and confirm2 is that you can call confirm1 a thousand times it just allocates memory to temporarily store the raw input string. If you call confirm2 a thousand times it allocate memory for the raw input string, a new list and 4 strings every time. Furthermore, if the user enters 'n' every time in confirm1 it just performs one hash lookup (is 'n' a key in the valid_answers set dict?), whereas in confirm2 it performs 4 string comparisons. I'm sure I'll be gainsaid by the premature optimization hawks, or I'm missing an optimization Python may be doing behind the scenes (like recognizing the list is constant). But this is just a healthy practice in any language. 
I have read the doc for this several times and I finally now understand it after reading this. It's like .get but for setting. Neat!!
Learning this is when I "took off" as a developer, I realized I didn't need documentation 90% of the time.
Yup - that's correct, unless there's something out there I don't know about.
I've thought about this for a while, and I'm having a hard time coming up with ones that are quite as amazing as the ones in wat. The best I've got is &gt;&gt;&gt; inspect.getargspec(sys.exit) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "C:\Python27\lib\inspect.py", line 815, in getargspec raise TypeError('{!r} is not a Python function'.format(func)) TypeError: &lt;built-in function exit&gt; is not a Python function
I should also note that mitsuhiko already did this presentation, called "[5 Years of Bad Ideas](https://ep2013.europython.eu/media/conference/slides/5-years-of-bad-ideas.pdf)" [(video)](http://www.youtube.com/watch?v=8e0l_Dt28MQ).
also: `pickle` `sys._getframe()` `locals()`
First, I'd stroll around the buildings and try to figure out what manner of repetitive labor/activity could be replaced or enhanced by a simple software. If no good ideas come around, I'd go with something flashy, maybe using OpenCV, facial recognition or maps.
also: scoping. http://lackingrhoticity.blogspot.com/2009/03/python-variable-binding-semantics.html http://lackingrhoticity.blogspot.com/2009/04/python-variable-binding-semantics-part.html http://lackingrhoticity.blogspot.com/2008/08/4-python-variable-binding-oddities.html 
I often implemented singletons in complicated ways, when really I should have just used a module. The first time a module is imported its code is ran. Any other time, it's just its namespace being made available.
You can also write a context manager to ignore particular exceptions within the context. Handy sometimes.
Thanks for the ideas, I really appreciate your input.
In Python 3, list comprehensions also create a new frame (so the variable won't leak into the current frame). `[x for x in iterator]` is equivalent to `list(x for x in iterator)` in Python 3 and `x` is not available after the list comprehension has completed.
Wat! &gt;&gt;&gt; x = (1, []) &gt;&gt;&gt; x (1, []) &gt;&gt;&gt; x[1] += "yes" Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: 'tuple' object does not support item assignment &gt;&gt;&gt; x (1, ['y', 'e', 's'])
This hasn't fallen on deaf ears. I will look into making it better. 
Another option could be some data analysis, try the library!
if they know how to download requests and then write a script to download a random image from imgur and can host that script on github and put a distribution on pypi(and then announce it in this reddit). then they know enough to ask questions here and know they wont get real answers to any serious questions.
I still have a fondness for the dictionary based example. Though, to match the ternary at the top of this subthread it would be: a = {True: b, False:d }[c] I like it because I feel it's the most explicit of the choices.
I counted 4 usages of the word "corporations" in that post none of which puts large businesses in a very flattering light. If I understand you right, the motivation is purely to move the optimal price point for programmers lower on the supply/demand curve. I don't feel that there's any cynical plot to devalue programmers going on here. As self-interest goes, Mark Zuckerberg and Bill Gates are as self-interested as I am. I think that's just human nature. As for the commercial, the worst thing I can say is that it's the career equivalent of a McDonalds commercial. IRL, the Big Mac doesn't look anything like that.
http://www.python.org/dev/peps/pep-0008 Going to throw this in here. Very useful to know before working on shared code.
Single item tuple literals are the worst. &gt; 42,
Famous and never a problem : c = 10000 print c is 10000 c=2 print c is 2 
Not a real wat, but I find that the behavior of [a:b] when b is negative can be very prone.
Sure. In my application it's for persistence of data between separate steps of a workflow. The different parts are mutually trusted, and there's no concern about persisted data needing to survive across different installations of the Python interpreter.
Learning to program is much more important than the particular language or subset of the language you use. The vast bulk of 2.X and 3.X is the same, but some of the changes are very fundamental (print is now a function requiring parentheses) so most 2.X code will need tweaking to run in the 3 versions. In my classes, we're still doing 2.7 because the library support isn't yet as complete on the 3.X series, and we really don't need the features yet. Open source languages do not have the built-in time bombs of commercial software. When a commercial language releases a new version, you can immediately expect support for the older versions to disappear, as the vendor has a vested interest in ensuring everyone upgrades. Open source languages tend to stay viable much longer, because there is no absolute imperative to upgrade. PHP 6 has been available for years, and almost nobody uses it yet. 
If 0.2 of a microsecond is that important to you, why are you using Python?
I'm sort of fond of functools.partial. Edit: brainfart, it's not applicable in this case. Just ignore me.
Haha, I did this by accident today. Didn't see it for a while, made me WTF when I saw it.
That doesn't do quite the same thing. `-m pdb` drops you in the debugger at the beginning of the program, not at the location of the exception. Edit: though if you hit 'c' to run the program it looks like it'll automatically stop in the debugger at an uncaught Exception, so yes that's another way of accomplishing the same thing.
This style looks like a question and answer, which is what helped me wrap my head around it when I learned about the ternary operator. (Is this true) ? Yes : No;
In development we always use .env/bin/python manage.py from the project root.
If you don't bother knowing the tools you use why are you programming? Using Python isn't a justification to write bad code.
So your vote is mildly for 2.7, but you don't think the version is really what I should be worried about, yes?
Well, one thing that bugged me is: why a class with only one method ?
Groovy, thanks!
Why is pickle on that list?
Java does the same thing, interning small Integers.
Whoa.
In my opinion, using tabs and spaces on consecutive lines should raise an IndentationError. Instead, python treats a tab as 8 spaces. I once had a student who couldn't figure out why a test case wouldn't run. This is what it looked like in vim: class TestStuff(unittest.TestCase): def setUp(self): # intedend 4 spaces pass # indented 8 spaces def test_stuff(): # indented one tab self.assertTrue(False) # indented two tabs But this is how python saw it: class TestStuff(unittest.TestCase): def setUp(self): # intedend 4 spaces pass # indented 8 spaces def test_stuff(): # indented one tab self.assertTrue(False) # indented two tabs
Tchew-pull. But I'm Australian.
I dislike it because it gives you a false sense of...something. It seems to imply that you can serialize objects and get them back later, when in reality it ends up being a little more complicated than that. For example, if you change the source of the class the object is based on, you probably won't get it back. It seems like a really useful tool until you realize it doesn't work for a lot of the cases you'd really like to use it for.
Why would you expect it to create a new scope? Few python constructs do.
worse! it doesn't treat a tab as 8 spaces, it uses *tab stops* of 8 spaces. :)
They're useful to add lru caching. You've probably seen @property, @skip for tests, and @deprecated. Once you start using them you find plenty of uses.
No it doesn't. None != "".
Best tool/line of code I've seen on this thread yet. Thanks!
Don't forget \_\_radd\_\_ for symmetry.
In the example above `if not mystring:` is True if (1) mystring is an empty string, or (2) mystring is None.
bool('False') gives unexpected results for those not familiar with pythons concept of Truth.
This is a great feature to remember when looping over lists of tuples, like dict items.
Which is different from the behavior of comparing to the empty string. So what did you mean when you said one translates to the other?
It's super annoying that it stops working if you reload a class in an interactive session.
Well, I didn't know this. I will get working on it! Any links to demonstrate how iPython and pdb work?
On a related note, [IPython notebook](http://ipython.org/ipython-doc/dev/interactive/htmlnotebook.html) is awesome, too. It might not seem like much, but the ability to have separate, editable snippets of code that you can run at will is quite useful.
I'm the same, I love it but I really wish it was if condition then true else false instead.
I think this is a bit of a "Wat?" &gt;&gt;&gt; def f(x): ... def g(y): ... x += y ... return x ... return g ... &gt;&gt;&gt; f(1)(2) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 3, in g UnboundLocalError: local variable 'x' referenced before assignment It makes sense…once you understand Python's scoping rules (or, as much as one can be said to *understand* Python's scoping rules, haha), but it's a bit confusing at first. (Also, sort of fixed in Python 3 via the `nonlocal` keyword.)
It's not a cynical plot at all, it makes business sense for them to do this. If they can increase the number of people going into CS/programming by a fraction of a percent long term, then the cost of producing the commercial pays off. You are right, it's about self-interest. In that case, I don't feel the need to paint them in a flattering light.
Have you heard the term "death from a thousand papercuts"? You don't lose anything by using [:] so why would you use a list()?
True. The point is that I wish I'd learnt sooner the effects of using mutable types in default arguments.
Interviewing is a lot like programming (or anything else), in that any idiot can continue doing it wrong. It's not the *number* of interviews I've done, but rather the planning I've done beforehand. I think it's too often that people recognize a need for additional help and list a job opening without ever taking the time to define what they want in the person who will fill that role. Do you really want people who can answer a bunch of bookish questions? Only if you're hiring a seminar speaker. I want people who know *programming*. I don't care if they haven't memorized APIs... that's what Google is for. But I don't want someone who doesn't know what unit tests are for... or someone who's intimidated by code reviews... or someone who has never heard of grep... so I ask questions designed to tell me this person's understanding of things like that. The only other key to my strategy is that I ask questions for which a candidate can't study. You'll learn more about a person by asking "what are some personal side-projects you're working on?" or "what new technology really gets you excited?" than you'll ever learn by quizzing him on his knowledge of libraries, or by asking him about past projects.
It really is trivial to upgrade your code, but the libraries are better for python 2.7. Use 2.7.
I really like with but when you have to open multiple contexts you end up in nesting hell! 
Eh, pickle has its uses. I use it in video games to save the state of dungeons or whatever, complicated data structures with many circular references. It's all handled by pickle no problem. I've never run into issue #2. I would agree don't use pickle when JSON will do, though.
Certain functions in the Pyramid framework take a tuple, and there is no good way to make just a single element tuple, so I have (x,) in some places and it always trips me up.
It should just refuse to run at all if some lines use tabs and others use spaces IMO.
Sorry, I was in class. Yes, that's what I think. It looks like the other posters agree, for the most part.
A while back I politely walked out of an interview when they asked me how to do fizzbuzz ( I laughed and said that was easy ) so they thought up something new on the spur of the moment and asked me how to implement a binary search function against a list. Things went downhill from there when I countered if that was something people did a lot in their company. I was so unbelievably happy that happened in the initial interview versus after accepting an offer. I don't understand why more of the industry doesn't follow an approach like yours. Sure it might partially break down if you have a Rails expert and looking to fill a position on a django project but at same time programming at a senior level is about critical thinking and problem solving and not rote memorization ( that's what books &amp; google is for ).
If you're using commandline: &gt; -t: Issue a warning when a source file mixes tabs and spaces for indentation in a way that makes it depend on the worth of a tab expressed in spaces. Issue an error when the option is given twice. - man python
IMHO, a recursive function shouldn't have optional parameters. If it is so desired, wrap the function in another function that does allow optional parameters or create two separate functions with the one that does the bulk of the work, the private one.
If you're on Linux or OS X, it's a matter of 3-5 lines that go into your .pythonrc file. Installing some other Python is kinda overkill if you don't plan to use other features.
 &gt;&gt;&gt; False = True &gt;&gt;&gt; False True
Only truest of hackers use single space indentation.
 &gt;&gt;&gt; a = dict() &gt;&gt;&gt; a.foo = 1 AttributeError: 'dict' object has no attribute 'foo' &gt;&gt;&gt; class better_dict(dict): &gt;&gt;&gt; pass &gt;&gt;&gt; &gt;&gt;&gt; a = better_dict() &gt;&gt;&gt; a.foo = 1 &gt;&gt;&gt; print a.foo 1 I know why this sometimes works and sometimes doesn't (slots) but to someone who's not familiar with it, it is strange behavior from two different classes that seem like they should be functionally identical.
This is the true definition of "wat", and essentially what I am looking for :)
How is this a wart? It did exactly what I thought it would do. What am I missing here?
I hate to say that, but no one really gets the point. The point is not to make everybody a coder. It's just that coding should taught in schools, like many other subjects. And we haven't got an oversupply of physicists or economist only because it's taught in school. But we have a lot of people who never get into coding, and never consider the branch, and it would just need someone to show them what it's about. It's about getting people interested in the topic.
A list/tuple would be cleaner IMO, although the two expressions get reversed: a = [d, b][c]
every time you use pickle, you can use something better. to pick a simple example, yaml handles circular references just fine.
well. did it succeed, or not? :)
Python didn't have list comprehension when I started learning python, but what a wonderful feature addition. Decorators are also great, but they are not nearly as universal.
Oh, now I see. Yeah, I agree it's a wtf :)
No point in hitting space 4 times while in the shell. ;)
&gt; But Python is basically designed for numpy, so it was included. That's the first time I'm hearing such a statement. Care to expand? Because I smetimes when I'm programming with NumPy i catch myself thinking "if only Python had this or that feature, NumPy could be much more awesome"...
Honesty, thank you for PyPy. I have been making sure that all my projects that I work on work with PyPy and CPython. The speed difference is very impressive once i get past the JIT warm-up phase. I had actually decided a while ago that I'll port my code to python 3 when PyPy supports it with the JIT. (seems to be almost any day now...) And the STM stuff? I am really excited to have that to play around with soon, because multi-threading is kinda hard. When I first noticed you guys talking about it I had thought that it might be impossibly impractical, but it seems you are nearing it to be usable (on 2+ core computers anyways). Love being proven wrong again and again by you guys about what is possible!
Yes, and I don't think it is a bad thing. Slightly wat, but never got any bug because of that.