This is great. Thanks. 
Would you say Tensor flow is easy to learn?? I ask this because whenever I hear "Machine learning", I instantly get intimidated.
No. There are projects out there that will compile your python though. [Nuitka](http://nuitka.net/) comes to mind.
Splitter!
I either recommend crostini or galliumOS
Working on a monitoring dashboard project. After that will move on to learn more about pandas for data cleaning. My job doesn't really need Python though so I'm struggling to get some real projects done.
Lotta industry words in the title.
Нина, от куда вы?
If you cannot use it from terminal, it's useless.
 TEST_STRING = "Gaffelbidder i tomatsovs" print("There are %s words in %s" % (TEST_STRING.count(' ') + 1, TEST_STRING))
What do you hope to gain from a "compiled" python: speed? Python is a highly dynamic language, so code generated by your desired compiler will basically consist of calls to runtime code written in C, which is what happens now with the bytecode interpreter. If you want to change python to be less dynamic and more statically typed then may see large speedups, but that's no longer python.
I was hoping to have my code run as fast as programs I write in Java.
It's been my experience that people coming from Java tend to write inefficient python and then blame python because "it's slow". Everything else being equal, python will never be as fast as Java because python is a highly dynamic language, as I said, and Java isn't, which is why it can be faster. You could try [pypy](https://www.pypy.org/) which looks promising, but has limitations.
It has literally *no* use?
There are some aspects of Python that make it inherently a bit slower than Java. Being able to arbitrarily assign properties and overwrite methods means that a compiler can't always tell if `int(x)` is using the built-in `int` function, so it needs to do a name lookup at runtime first. Usually this isn't a difference that matters.
What does it do?
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
No. Why would you want that?
best
I've been cleaning up some of my old scripts for interacting with ArcGIS desktop using ArcPy. Mainly reducing the number of scripts in favor of slightly more robust programs that have more use input options. Also trying to make the code more generic so I can share more on my public repo instead of all hidden away on private organization repos. 
nice work! something to consider for your "v2" of the app: have it compute the hash of each file from a parent directory downard and report the duplicates, then provide the option to keep a select one and remove the others OR (even sexier) replace the duplicates with a shortcut to the one chosen to keep 
This program will compare the content of two files, if the content of the duplicate file matches the original one then it will be removed. If the content of two files does not match with each other, even the name and the extension of another file matches with the original file, that file will not be removed!
If you need a scrapper then Python is way better than VBA. Plus json parsing is much faster in Python than VBA. Another thing is if you do a lot of data cleaning that consists of sort of database operations, pandas is more flexible than a bunch of lookups. For example I feel Python plus pandas is way more comfortable than Excel if I want to do some complex filtering. But it's just my perspective.
I'm looking forward to reading this! 
oh my mistake! I read through the two .py files on your github page and didn't see how either script was going into the content of each file. can you post that part of the code here for me? I'm pretty curious
The source code is too long to post here, here is the entire source code http://codingdirectional.info/2018/12/12/tell-the-user-how-many-duplicate-files-have-the-python-program-deleted/. Sorry I am not going to comment on this reddit post too much because I want to save karma but you can visit the above post and leave your comment there and I will help you to keep the software up and running :)
Cargo made me hate python. I would do everything in rust if there was the same community around it.
Are you using every package ever published to pypi?
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the r/Python discord: https://discord.gg/3Abzge7, a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
/r/learnpython
Ty
http://lmgtfy.com/?q=python+csv
I tried writing into CSV and yes I did read the documentation but it threw up errors which is why I wanted to know from here
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the r/Python discord: https://discord.gg/3Abzge7, a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Well what errors did it throw; usually they're how you solve the problem
Hi All, Apologies for the length and the humblebrag session here but my wife is tired of hearing about it / doesn't really get it and I can't tell anybody at work about this, so this is for you all. TL/DR available below. &amp;#x200B; I am a network engineer and after about 3 years of working nearly 90% travel, I took a local job at a large ISP to work in their NOC. The job was posted as support of top level route switch functions, network builds and maintenance. About 2 hours into my first day I figured it is really about 85% ticket management, 10% babysitting , and 5% networking related. Not particularly surprised, it's in line with what I was told I would be getting into from peers in the field but I didn't know it would be this hilarious. Here's the expectation of workflow: 1. An automated email from somewhere in the universe blows it's way to my inbox. "Node is down. MAC ID is 0a:1b:2c:3d:4e:5f". Ticket# is 123456. No more info. 2. I open webpage(#1) and go to our ticket Web-Based-Helper-Of-Desktops website and navigate to ticket#123456. I acknowledge and accept the ticket. 3. I read the ticket's information which contains a unique identifier for the network. Say it's called "ID-123-XYZ". I open a new webpage(#2) and go to our company intranet database. 4. I log in with username and password, then navigate to the search bar and search "ID-123-XYZ", which links me to a page built for "Jim's-Car-Dealership-Store#0001". I open notepad and copy about 20 different pieces of info like store hours, equipment &amp; circuit info (carrier, IPs, circuit IDs) usernames and passwords for their local network elements, ect. That's assuming it's #1 there &amp; #2 accurate. It usually isn't. 5. I now click a link from the intranet database that opens a new webpage(#3) to a separate sales database that is specific to this customer. It tells me what expectations (SLAs) we have to fix it, and if I need more information there's an email for the company's responsible sales person. 6. I go back to the ticket system webpage and enter the 20 bits of local contact info, the location name, the store hours, ect. Takes about 3 minutes of clicking and ctrl-pasting. 7. Hopefully sales has gotten back to me by now with the right info, so I open another new webpage(#4) and log into a portal that allows me to RDP to a server, with hourly-unique login creds that can be found with another application. I now hit the customer equipment and begin troubleshooting using the info from the company intranet page. 8. Say during troubleshooting I find the network element had motor oil spilled on it and needs to be replaced. In the intranet site, I search for the device model / type I was working on and open the vendor's webpage(#5), enter a shared login &amp; password, and fill out a request to have a new device shipped. Copy tracking info and put it in the WBHOD ticket. 9. I need to request someone to schedule a technician to go an install it when it arrives, so I open another webpage(#6) that only works in IE, which then launches a flash based application, call it "AncientWonder". I copy and paste all the same information that I already put into my WBHOD ticket to AncientWonder, as well as the type of tech I need, what equipment they need to bring, and a bunch of other details. 10. Now that they're scheduled, I need to disseminate what they should do when they get there so I open ANOTHER webpage(#7), head to a completely different sharepoint site, copy scheduling information from AncientWonder &amp; site information from WBHOD, along with my notes for what I think the tech should do when they arrive. 11. I update WBHOD with all info, then email the customer &amp; account folks on the status. Regardless of if this is within our expected response time of X hours my inbox will now have a number of emails from the customer, my supervisor, my supervisors' manager, and the sales person, wondering why this wasn't fixed already. 12. Next day: The scheduled tech is late and manager didn't (or won't) pull the notes on what to do, so the tech calls me. He doesn't know what state or city he is currently in, where to go, what he's supposed to do, who he's supposed to meet, and he's very upset that we couldn't fix it remotely. I pull the info and get him there. 13. After painstaking walking him through troubleshooting how to open a box &amp; plug something in, we manage to get an IP address on the device and I can configure / complete tshooting. The problem is solved. 14. I now have to close out 3 ticket items and update some other information: WBHOD, AncientWonder's scheduling, and the sharepoint site's scheduling. They all call for an absolutely extreme amount of additional information that is needed like hours worked, solution parameters, root cause, next steps, tracking for returns, new IPs &amp; new MACs, ect. I believe this portion actually takes the most time to complete. **TL/DR:** It takes 7 web pages, 3 applications, at LEAST 2-3 hours of time, and generally about 6 to 8 people in order to replace / repair 1 element. I've always wanted to learn to code and I realized the opportunity existed for me within the above workflow. About 2 weeks into the job I started learning by using Python3 &amp; the modules for requests, beautiful soup, Selenium/webdriver, and 2 APIs for application specific items. My initial goals were to ease the burden of closing tickets but I started realizing more and more possibilities as I went. About 3 months and 866 lines of code later I have 100% of every single busy-work task for every single network that I support completely automated from the browser(s). I keep the command line open in a small window to the side and run the appropriate function when needed. &amp;#x200B; Unfortunately it's not user friendly as it's all running within the command line/console. It requires calls to specific functions depending on where you are in the work flow. SO, this week (and probably the next few weeks to come) I will be working to finish a front end. I have a working model with tkinter right now however I've seen some information on kivy, which supports cross-platform builds into mobile devices. Tkinter has been easy enough but I'm interested to see if I can build a mobile app as well. Any thoughts or tips? &amp;#x200B; I also wanted to thank you all in the community as I literally started with 0 knowledge of programming 3 months ago. I've spent a lot of time lurking and searching the sub for questions I've had during my build. I really appreciate the knowledgebase this sub carries and reading the sub's comments often gives me an extra push to keep working when I see others have had or have similar questions. &amp;#x200B; Thanks for the read, &amp; everything else!
I am working on a simple chat program using the sockets module. It allows users to chat over a local network.
There are docs, tutorials, examples, etc here [https://www.qt.io/qt-for-python](https://www.qt.io/qt-for-python)
ShallowBot
Python is much faster to write in than Java. This may seem like a cop out but in practice it means it's plausible that you will be able to write an initial implementation, benchmark it, and write a faster implementation perhaps with a helper library that has bindings to a specialty language in python and end up with a better result than in Java. In then end it gets down to the kinds of problems you have and not a choice of language.
I’ve definitely had issues with ordered dicts in 2.7 which needed to be made explicit, and these issues disappeared in 3.6
How about some videos on deployment of python webapps
NotDeepBot RichBot (rich in features) TwiBot Streamers First NYOB (not your ordinary bot) 
Try PyPy. It has a JIT compiler. 
Yup. Actually reading the error is half of the solution. 
jusr curious, what do you do with c#? I'm kind of interested in it as I know some C++ but my job doesn't need it at all.
File a bug report if it doesn't find the right python libraries =). The only case it fails on right now that I'm aware of is when you have 2 or more python interpreters loaded up in a single process (and I'm intending to fix that when I get some time).
&gt; 94 could be the unique count of users in the git repo with contributions since a specific date. It's probably was something like that. 94 people were invited to vote with the caveat that they shouldn't vote if they planned to not contribute in the future. ~64 people actually did vote.
[removed]
Also, yes, I am aware the this website is incredibly prone to SQL injection at the moment. Just testing for now.
Code is really pumping out cool videos... any for Pycharm?
I'd say without change in API, the major version number should be kept the same. It's unreasonable to say that each non-major version supports exactly the same package or Python versions. That's what requirements files are for. If the existing public API is unchanged, it's not a major version bump. That doesn't mean you can't add new things to the public API.
&gt;Hi, I don't really know where to ask so I'll ask here. This isn't intended to be advertisement, I actually do need some opinions on this. &gt; &gt;I'm making a Twitch bot/streamer assistant that is highly customizable, open-source, modular in nature, and is aimed at users looking for a streamer assistant app that can do zzmuch any behavior can be added into it 2z2zz long22 as one knows Python and is willing to read the documentation. T2hizs highz2 level of customizability is the22 main reason why I'm making yet another Twitch bot in the first place. &gt;2222t) to the credits, if you want. Thanks a lot in advaz2nce. &gt;z2z22z2z2z2s222z &gt;P.S. The program originated fromz a streamer's frustration wit2h DeepBot, maybe its name could 2z2flect that somehow? idk2zz2zz22z222assuzz222zme 
Last year Visual Studio Code had [2.6 million monthly users](https://code.visualstudio.com/blogs/2017/11/16/connect?WT.mc_id=none-reddit-ninaz). That's a pretty funny definition of useless.
Good question. I'm from Ukraine.
As in I entered excess arguments, etc .
We recorded a 4 part series. Deployment is video #2. Check out the rest: * [One click deployments to App Service on Linux from VS Code](bit.ly/django-azdeploy) * [Continuous Integration and Continuous Delivery with Pipelines](bit.ly/django-pipelines) * [Serverless Django Functions](bit.ly/django-azdeploy) 
Sorry, I don't work for JetBrains 😂 You can reach out to [Andrey Vlasovskikh](https://twitter.com/vlasovskikh) on twitter, he's a tech lead for PyCharm.
Very cool, I figured as much with the "enko" last name - what feels like a million years ago I was an exchange student in Ukraine. Ukraine is a pretty amazing part of the world, I really enjoyed my time there, I wish there was peace there now.
First of all, the distinction is nonsensical. There isn't such thing as compiled languages or interpreted languages. Being compiled isn't a property of a language. It's a notion of a fact that for some language there exists an automated tool to translate words in that language into words in another language. So, trivially, all programming languages are compiled, because one way or another they are translated into machine code. But, usually, it's even more than that. For instance, if we are talking about Python, then it is compiled multiple times before it is actually executed. So, it is compiled first time when it is translated from Python source code to bytecode (sometimes this bytecode is kept around for future runs to skip this compilation). Then, this bytecode is translated into machine codes by means of interpreter. Some interpreters, like the one written by the original Python inventors don't do any additional translations, but PyPy translates the bytecode into yet another bytecode a.k.a. intermediate machine representation, and then this IMR is compiled once again into machine codes. The process above is very similar to what happens in, for example, Java, or C#. But this is not exactly similar to what happens in C or Rust or Ada etc. The later languages are designed in such a way that a lot of the optimization steps can be performed before the program is executed, while in Python it is difficult to use the same optimization techniques. So, when programmers talk about compiled vs interpreted it is just a wrong use of terminology, but the intuition which is the basis for this kind of distinction is that for some languages we know how to optimize the program they compile into well before it is executed, and for other languages we don't have that great a knowledge. Now, even there there are still misconceptions. For instance, a lot of people believe that having storage types tied to variables makes a huge difference, whereas in reality, it doesn't matter that much. Common Lisp compilers, for example, can produce programs that run in roughly the same time as programs written in Java and compiled using modern state-of-the-art compilers. Often times things that matter for performance is your ability to parallize work, to minimize system calls, or amount of I/O etc.
I made an [Indeed.com](https://Indeed.com) word cloud generator. So job seekers can visualize important keywords according to job title/nature and location. Source and explanation can be found from here: [https://www.codeastar.com/word-cloud-easy-python-job-seekers/](https://www.codeastar.com/word-cloud-easy-python-job-seekers/)
I'd write a support ticket. It's a paid service, and they screwed it up. No reason you should invent workarounds for their bugs.
The old saying goes: you can spend a week writing a program in C that will take a second to get you a result, or you can spend an afternoon writing the same program in Python and it will give you a result in a minute. Python is build to reduce development time, not CPU time.
That's C code dressed up in Python syntax. The point is that black will only ensure the formatting. Writing ugly code that doesn't use the proper Python idioms will never become beautiful.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
&gt; yet another Twitch bot Is this name taken? ##yatb
You need to learn the three HTML/CSS and Javascript for web development. Then you will need to learn a database language: SQL. It depends what are your goals and which projects do you want to work on!!
[removed]
Here's an example function from a personal project of mine: async def scrape_series_data(show_id: str) -&gt; List[Dict]: seasons = scrape_seasons(show_id) series_data = [] loop = asyncio.get_event_loop() futures = [ loop.run_in_executor(None, scrape_season_data, show_id, season) for season in seasons ] for season_result in await asyncio.gather(*futures): series_data.append(season_result) flatten = lambda l: [item for sublist in l for item in sublist] return flatten(series_data) The function `scrape_season_data` performs an `HTTP GET` call using [Requests](http://docs.python-requests.org/en/master/). This can take anywhere from 300ms to several seconds, and I can't always predict how long each season will take. Using `asyncio`, I can call `scrape_season_data` asynchronously on each season in the List. `asyncio.gather(*futures)` will return an ordered list of results, and is much faster than scraping for each season in series. If you're interested in seeing the whole project (work in progress), check out the [GitHub repository](https://github.com/ahoetker/legacy).
Designing my own language using RPLY parsergenerator and lexer :)
Maybe use "then" as a keyword?
If you come from Java, want to run bytecode on JVM while not wanting to commit suicide by boilerplate, try Kotlin?
Furthermore "it's much easier to optimize working code than to make optimized code work"
Interesting
What's the tab he's using between the extensions and docker tabs?
Do it the old way: "my Twitch bot" -&gt; "MTB" -&gt; `grep 'm.*t.*b.*' /usr/share/dict/words` and choose what you like the most. 
Ive found Folium to be great when you want to plot data onto maps of the earth. Uses leaflet.js and is super easy to get your head around and start plotting the data! &amp;#x200B; [https://github.com/python-visualization/folium](https://github.com/python-visualization/folium) &amp;#x200B; &amp;#x200B;
[removed]
JavaScript is pretty much a general-purpose programming language these days, but its main claim to fame is still the web, and particularly client-side scripting. Especially if you are going to pair it up with Python, the typical setup is to use Python on the server, and JavaScript on the client. Client-side web programming, however, is inevitably going to be about creating and manipulating HTML web pages; to understand those, HTML and CSS are pretty much mandatory. Fortunately, they are not full-blown programming languages, and much simpler than either Python or JavaScript. Once you have the basics down, you shouldn't hit a lot of roadblocks on that front. Now, as far as "how do I learn a programming language" goes, here's my strategy: 1. Find introductory learning material that matches your existing knowledge and preferred learning style. For most languages, especially popular ones like JavaScript, there is plenty of beginner material available. IME, it helps to start with a single monolithic book or similar work, rather than grabbing small bits and pieces scattered over the web, at least for your first few weeks of learning. 2. Find the go-to toolchain, install it, get comfortable with the basic commands you will need. For JavaScript, you can either use whatever browser you prefer, and just press F12, which gives you an interactive JavaScript / HTML / CSS environment to play in; or you can (and probably should) install node.js, which you can use both as an interpreter and as an interactive environment, much like the `python` binary. 3. Read the introductory material, work through some examples, get the basics down. Use the interactive environment to try things out, the more the merrier. 4. Once you're somewhat comfortable, start doing some real projects. Keep the scope small, but do aim to make them at least marginally useful. I find it more effective to do actual projects I come up with myself, rather than following tutorials, because it forces me to learn to think within the constraints of the new language, and explore the ecosystem. While doing this, having a reference guide handy, as well as your trusty learning materials, is super important: you use the reference guide to look up details of certain language features and APIs, while you keep the learning materials around to re-read chapters when it turns out you haven't quite understood certain concepts yet. 5. Don't let your seemingly slow progress discourage you. Learning a programming language is a gargantuan effort, especially when it's only your first or second; and the JavaScript ecosystem is huge, diverse, and confusing. You can easily spend 10 years and still know nowhere near all of it. So that's basically it. With JavaScript, and web in general, another important aspect to spend some time on is the basics of the web, and HTTP in particular. Learn about the request/response paradigm, how HTTP works, and get a clear picture of what happens where (client vs. server) - it's not complicated, but things will get confusing fast if you don't understand where the network boundary is, or, for example, what the difference is between serving a script's source and serving its output.
Same as you. But I got the basic stuff and still learning to be fluent in the language. And also developing an flask app from scratch that relates to cryptocurrency lol 
What do you mean by "compress", exactly? Are you looking for gzip compression or similar? If so, it's probably better handled at proxy level via something like nginx.
if you're on a mac check out `chrome-cli`. It's pretty useful! ``` stu@redmac ~ $ chrome-cli -h Usage: chrome-cli -h (Print help) chrome-cli --help (Print help) chrome-cli help (Print help) chrome-cli list windows (List all windows) chrome-cli list tabs (List all tabs) chrome-cli list tabs -w &lt;id&gt; (List tabs in specific window) chrome-cli list links (List all tabs' link) chrome-cli list links -w &lt;id&gt; (List tabs' link in specific window) chrome-cli info (Print info for active tab) chrome-cli info -t &lt;id&gt; (Print info for specific tab) chrome-cli open &lt;url&gt; (Open url in new tab) chrome-cli open &lt;url&gt; -n (Open url in new window) chrome-cli open &lt;url&gt; -i (Open url in new incognito window) chrome-cli open &lt;url&gt; -t &lt;id&gt; (Open url in specific tab) chrome-cli open &lt;url&gt; -w &lt;id&gt; (Open url in new tab in specific window) chrome-cli close (Close active tab) chrome-cli close -w (Close active window) chrome-cli close -t &lt;id&gt; (Close specific tab) chrome-cli close -w &lt;id&gt; (Close specific window) chrome-cli reload (Reload active tab) chrome-cli reload -t &lt;id&gt; (Reload specific tab) chrome-cli back (Navigate back in active tab) chrome-cli back -t &lt;id&gt; (Navigate back in specific tab) chrome-cli forward (Navigate forward in active tab) chrome-cli forward -t &lt;id&gt; (Navigate forward in specific tab) chrome-cli activate -t &lt;id&gt; (Activate specific tab) chrome-cli size (Print size of active window) chrome-cli size -w &lt;id&gt; (Print size of specific window) chrome-cli size &lt;width&gt; &lt;height&gt; (Set size of active window) chrome-cli size &lt;width&gt; &lt;height&gt; -w &lt;id&gt; (Set size of specific window) chrome-cli position (Print position of active window) chrome-cli position -w &lt;id&gt; (Print position of specific window) chrome-cli position &lt;x&gt; &lt;y&gt; (Set position of active window) chrome-cli position &lt;x&gt; &lt;y&gt; -w &lt;id&gt; (Set position of specific window) chrome-cli source (Print source from active tab) chrome-cli source -t &lt;id&gt; (Print source from specific tab) chrome-cli execute &lt;javascript&gt; (Execute javascript in active tab) chrome-cli execute &lt;javascript&gt; -t &lt;id&gt; (Execute javascript in specific tab) chrome-cli chrome version (Print Chrome version) chrome-cli version (Print application version) ```
I have created a ticket in support center. It's pretty clear that is a Microsoft bug. But just curious if someone else had this problem.
This is great. I recently switched to vscode for python and django development and I love it. 
Thanks for chiming in, I'll definitely keep you apprised of anything I find when I try it out!
``` import sys import os seen = set() for f in os.listdir(sys.argv[1]): if f in seen: os.remove(f) else: set.add(f) ```
Yeah like gzip compression so I am making an api which fetch data from a database but I want to compress the response code data.
python is compiled. It's compiled into bytecode for the python virtual machine. What's your problem?
Why not use threads instead ?
Pycharm is specifically dedicated for python and it’s ecosystem so it is 100% better 
What's your end goal exactly? Do you want the response itself to be a compressed file, or do you just want to compress it at HTTP level?
These types of blanket statements are so stale. No one tool is 100% better for 100% of developers and use-cases. I prefer VS Code when I want a tool that's really lightweight and has a quick startup time, as I have minimal extensions installed. It's also great when you're programming in multiple languages throughout the day, not just Python. The extension and theme ecosystem is amazing. [GitLens](https://gitlens.amod.io/#features) is one of my favorites. Visual Studio Code is also [open source](https://github.com/Microsoft/vscode). If you don't like something, you're welcome to open a pull request. 
I want the compression at http level.
Then you should probably have Nginx or Apache or whatever proxy you're using do it for you.
You can use those skills to build windows apps in Visual Studio. I use it in Unity, that’s actually where I started using c#.
the only thing i don't use vscode for python is auto completion. It just doesn't work as like as on PyCharm
Excel is ok for quick and dirty graphs on small data sets. In python, large datasets are easy with Pandas and Numpy. Plotting clean, consistent, more complex graphs is possible with Matplotlib (removing complexity, it's easy with seaborn too). It's hard to imagine a graph you couldn't make with python and a couple of packages. With excel, I find just adding error bars to be a massive pain, and certain kinds of error bars are impossible to add. Too much is done automatically, with no option to make changes. I would also say that workflow becomes much easier with Python. Say you have your data in a series of text files or csvs. You need to strip the data from those files; probably transform it in some way; do some statistically analysis and then plot it. The more steps you have from raw data to finished graph, the harder it is to keep track of what's going on with excel. With python, it's easy, and once you've done it once, you can run the same scripts with minimal changes.
Have you tried the new [AI-powered IntelliCode extension](https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode&amp;WT.mc_id=ch9-reddit-ninaz) that's in preview? The model was trained on quite a few popular open source projects. It's really good. If it gets any better, we may need to worry about our jobs. 
i will try now thanks for suggestion
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
r/learnpython
Wow, I didn't know excel had add-ons like that! So I'm gonna have to be looking at tens of thousands of rows before excel will start to run into issues then.
&gt; Then, this bytecode is translated into machine codes by means of interpreter. This is obviously what OP and literally everyone else is talking about when they refer to python being interpreted. When talking about language compilation and interpretation, it is in the context of compiling to machine code vs code that gets interpreted.
&gt; This is obviously what... Wrong. Same people would call Java a compiled language, while there is no difference between Python and Java in this respect. &gt; It is valid to call C a compiled language, Wrong again. No language is compiled or interpreted. This is just not a property of language. If you are talking about languages as being compiled, it is the same as talking about speed of triangles. Triangles are geometric object, which in some circumstances may move, and then, maybe you could talk about qualities like speed of specific triangles found in a system that has the notion of speed. But, in general, triangles don't have such a property: they do have properties like "area", or "being equilateral" etc. The same thing is with languages. They just aren't compiled or interpreted. And whoever says so simply doesn't understand that they either aren't talking about language (bug a particular process, which involves using the language) or they are even more confused about what these words coming from their mouth mean (99% of all people talking about compiled languages fall into this category).
It's Extract Transform &amp; Load. Basically moving data around and transforming it to its desired format/schema. I work as a Data Engineer and it's most of what I do from the technical side of things, ensuring data is decent for consumption into a model (duplicates testing etc) and then loading the data into an environment in the format the Data Scientist requires for the model to work efficiently. Python is very powerful for this. I'd look at Python for Data Analysis book which covers ETL; I think you can get a 2 week trial on the O'Reilly website. There are online courses on DataCamp, or Udemy. [https://www.udemy.com/learning-python-for-data-analysis-and-visualization/](https://www.udemy.com/learning-python-for-data-analysis-and-visualization/) There's a one of cost of £11.99 for that course, but it might be helpful. 
The problem with threads is that your platform limits the amount of available threads. You can't always simply create another thread - at some point, it will result in a crash. Asyncio does not suffer from this issue - you can make as many async calls as you need.
You're basic idea is OK in my book: keep functions simple and easy to read. But don't go overboard with this ;) In the case you describe I personally would not split out the squaring of a number in a separate function as it is in itself a simple one-line operation. If one the other hand `compute_single` itself would be a *complex* logic taking several lines of code, then it is worth considering splitting it out. If on top of this `compute_single` would be something you would also need to do in several other parts of your program, this is an extra reason to split it out. One last advice maybe: optimization (of both performance and structure) is **a good thing** but trying to get perfect structure from the start often leads to sub-optimization (e.g. splitting out a simple operation into a separate function that is only used once). First focus on getting the logic of your program right. Once that is done, start thinking about improving the structure through re-factoring...
new chromebooks run android apps
PyCharm is a super heavyweight IDE with a ton of features I never use that just drain my battery. VSCode is extremely lightweight and only provides exactly what I need. You sound very ignorant when you make statements like this
I use classes and methods when I find myself passing around data structures to different functions. I tolerate a little bit of that but at some point it bothers me and I create a class and let 'self' hold the structures instead. If that's not the case, I prefer functions to classes, but it's a judgement call. We all find our dividing line on that. I think your functions are fine as-is. I like that you're trying to keep it simple.
you can replace the entire second function with a simple comprehension: [item ** 2 for item in a_list if item % 100 == 2] If you replace the square brackets by braces you turn it in a generator, so you can process any iterable, even potentially infinite ones, without having to build an entire list of the results. 
I respectfully disagree with both your statements. If you want to criticize something from the open-source world, you should be able to deal with someone telling you "submit a PR" without getting ego-hurt. Because maybe all of us are aware of how open source works in the broad sense, but I think fewer than you think are of how it works in the details. You can use pandas without knowing what a PR is. "you can submit a PR" is a gentle reminder that OSS is not a product that you pay for.
Be careful not to cut yourself on that cutting edge.
which for some reason you have made a subclass of Bad.
There are a lot of features VS Code doesn't have, for me, Microsoft is very very slow on implementing new features. It might be open, it might be lightweight but I never you know what? I never liked/trusted Microsoft, maybe I'm wrong, but it's ok with me. And just a quick reply to @hendawg98, if PyCharm is too heavyweight for you, you can simply switch on the power safe mode
The problem he's solving is IO bound. The threads also have limitations and overhead. If the problem was CPU bound `multiprocessing` might be useful.
https://github.com/satwikkansal/wtfpython has some good stuff
[https://smile.amazon.com/Fluent-Python-Concise-Effective-Programming-ebook-dp-B0131L3PW4/dp/B0131L3PW4/ref=mt\_kindle?\_encoding=UTF8&amp;me=&amp;qid=](https://smile.amazon.com/Fluent-Python-Concise-Effective-Programming-ebook-dp-B0131L3PW4/dp/B0131L3PW4/ref=mt_kindle?_encoding=UTF8&amp;me=&amp;qid=)
If it's a lot of math on arrays of numbers, make sure you are considering numpy and pandas
Demo 4 reminds me of Cowboy Bebop.
I think it was definitely interesting, but more interesting would be a writeup on each to accompany the visuals. It looked like some could be re-factored into higher-level components, you could talk about being able to index colour spaces on GPU by updating a single value being able to produce 1980's graphics (it looked like you were drawing primitives with different values rather than purist pixel indexing, but talk about that). Hope the new job is going well. I switched in October. Love it but still got one foot in and one foot out.
I'm afraid I never received such warning when I'm posted. And I didn't see you had already posted it, sorry. 
What errors? In what line? What does your code look like? How do you expect any help without any of these details? Would you go to a mechanic and say "car's wrong, but you're not allowed to see it and I won't explain"?
&gt; They look very promising to me but I am yet to find a real life, production-grade systems which uses/can use this? Umm... so anything that uses twisted, gevent or eventlet since it's the same fundamental thread. The advantage of this approach are: * i. Avoid the overhead of spawning threads * ii. Avoid the complexity of dealing with locks and concurrency. ii. applies to all asynchronous and implies that this approach is effective when you have shared state outside of a database (you need concurrency) and ii. you don't need parallism "baked in" (you never have this with python - anyway). It should be noted that this comes at the cost of "preemptive scheduling" that you get when you use threads (which is sort of similar to real time constraints), i.e. if other operations are slow / don't yield control then this affects everything - though at least with this approach you see it early. Things like irc servers tends to be written *without* threads and can handle hundreds of thousands of connections. 
Thanks for your reply! The functions in OP are simplified versions of the real functions.
Well, this is the pythonic way to structure the code from the example. Real functions shouldn't be much more complex than that. That's the whole point of abstraction. 
My second attempt at approaching Python, from the eyes of a seasoned Java developer. Even if you disagree, please take my views constructively. Since this is really my second big article on Python development, your feedback is more than welcome and appreciated.
 [[source]] url = "https://pypi.python.org/simple" verify_ssl = true name = "pypi" [packages] keras = "&gt;=2.2.2" numpy = "*" pandas = "*" scikit-learn = "*" scipy = "*" sklearn = "*" tqdm = "*" jupyter = "*" tensorflow-gpu = "*" tensorflow-tensorboard = "*" matplotlib = "*" seaborn = "*" "rpy2" = "*" keras-tqdm = "*" pandas-profiling = "*" "h5py" = "*" biopython = "*" dspp-keras = "*" "beautifulsoup4" = "*" requests = "*" [requires] python_version = "3.6" 
What a load of uninformed BS.
The article should be called, "I know nothing much about Python, but I know what I don't like!" I mean, I can't take someone seriously who thinks that C's _textual_ `#include` mechanism is better than Python's `import` system! I have actually spent most of my life as a C++ programmer, and I still love it, but the big thing we're talking about these days is how to _get rid_ of `#include` and replace it with a module system much like Python's _because_ `#include` has so many issues. I started to write a rebuttal, but what's the point?
My two cents: there's no point in splitting them up if you're not going to use them separately.
&gt; I mean, I can't take someone seriously who thinks that C's textual #include mechanism is better than Python's import system! Fair point, but at least `#include` can't throw exception.
"I hate python because it's not C" What an idiotic blog post
As a newbie to Python, why did Python never adopt the {} for scope? Why is it 4 spaces? Was there a reasoning?
&gt; Fair point, but at least #include can't throw exception. My sweet summer child. 
Any sensible programmer indents code for readibility; making the braces essentially superfluous. Also; you see from 10ft away when your whitespace is off without having to count braces.
If you consider it to be no true -- come on, prove me wrong.
The simplest way is crashing the compiler by having unchecked recursion in include files. There are a multitude of other trivial simple ways. However, this is not a place for you to grandstand as the white knight for C, so go and study the language yourself.
Number 1 is a fair complaint and has been hashed over and over again over the years. Number 2: WHAT?!?! How have you gone so long in your career and not had to install multiple versions of a given runtime? I can't even... Numbers 3 &amp; 4 complain about bad things people can do with Python, not about fundamental flaws with the language design. People can do bad things with any language, full stop. Number 5: nvm I'm done with this. This article should be titled: "I spent an hour playing with Python and here are the ways that it's different from my primary language" 
Wow, what a toxic sub.
Very cool! Are you going to create more videos? Are there more parts? This is called "Part 1", I want to see the other parts too! :-D
&gt; toxic What'd you post about again
Switch VSC to dark mode or someone will call the cops.
I think its inherently not pythonic, but if you have a list of elements upon which you want to do the same operation, you probably want to call #map on it, and just pass it the simple function. I guess to be pythonic you would just do a comprehension on the list.
Some peoplr have yet to understand the concept of static vs dynamic typing... 
I'm not sure I agree with many of these points. In regards to using indents instead of brackets, so what? The indent tells you where you're at and most editors allow for indent folding as well as marker folding. And if you're nesting so many times that it's basically off screen, aren't you nesting a bit much anyway and should be breaking it up a bit more for clarity? Is that not also an annoyance in C to have indents and tons of closing brackets? I won't say I hate brackets because there are some positives (in vim, hitting % on a bracket to go from the beginning to the end is really nice, for instance) but the code is so messy and much harder to read when you see like 6 closing brackets on 6 separate lines in the code but no indication what specifically it's closing (similar issue with indents in python except more messy looking) In regards to #include and import. I can see how it would be useful to just look through a directory for the header files and such but if you're importing a module, aren't you more likely to be looking up the documentation anyway? If I'm importing something and I don't know exactly what I need to import, then there's a high chance that I'd need the documentation anyway to ensure I'm calling the functions correctly. 
So just to give readers a fair assessment since this whole thread is a Microsoft plug... &gt; lightweight Fair enough, PyCharm uses a lot of memory... But for a professional developer that should not be a concern. It's also very fast and performs well; heavy != slow. &gt; quick startup time That's unfair, the startup time for PyCharm is negligible. For a very large project you're maybe looking at 20 seconds after everything is loaded, indexing finishes, etc. How often does someone close their IDE anyways? &gt; The extension and theme ecosystem is amazing. GitLens is one of my favorites. The documentation is through and easy to follow along. There's excellent tooling for data scientists, such as importing Jupyter notebooks. PyCharm's extensions blow this out of the water. &gt; multiple languages I guess that's fair. PyCharm supports other languages, basically anything you would need for most _Python_ development. If you're switching between Java and C and whatever projects all day then sure, I guess that's a good point.
Pssh, I hate C because it IS C! See blog writer, I can write stupid stuff, too
**Lists are not arrays.** Python didn't come up with that. C# also calls them dictionaries. Probably other languages too.
I'll grant the point on backwards compatibility, but that's a topic was beaten to death a long time ago. The EOL for Python 2 is approaching and it becomes less relevant with each passing day. The rest of this is nonsense that comes across as unwillingness to accept anything remotely different from what one is used to instead of actual issues.
Then wrap it in a function and pass it to the comprehension. [super_complex_function(result) for result in results] 
I mean if you really want to get into it... https://docs.python.org/3/reference/index.html It's not for everyone, but I think anyone that wants to get serious about Python development needs to read the docs eventually.
I love Python but I see where this guy's coming from
I think the site might be down.
Never seen this, definitely learning a few things here.
&gt; making the braces essentially superfluous What about escaping newlines?
You’d use that syntax over map?
BTW `#include` recursion crashes compiler in compile time rather than your program in runtime. So it is not an apples-to-apples comparison.
Seems to work fine for me. Could you please try again?
It's wrong. The script will be just another python rocess in your host, so it doesn't matter if you have two python processes in the same or in different containers, the CPU footprint will be the same. But since we've gone this far, do you mind if I ask you if you don't agree that for two simple scripts one venv is just enough?
Hmm it looks like my university's internet is blocking your site.
It depends. I prefer functional approaches in this sort of situation, but I vaguely recall that map is considered un-pythonic. So it would depend on the larger context of who I am working with, who I am writing this for, etc. Also, I believe the list comprehension will use more memory than calling map on a list. As I think it makes a new list, where map operates on the original list. So, it depends on that a) being correct and b) mattering for the use case.
You post almost exclusively in circle jerk subs. Keep your bullshit contained in those dumpster fires. 
Java compiles the source code to byte code that is then run on the Java virtual machine. Similarly Python compiles the source code to byte code that is run on the CPython virtual machine. In this sense, the languages are similar. The main difference between these languages is not whether they are compiled or not, but how they are compiled and how the virtual machines work. During the compilation step in Java, certain operations are optimised. However, this is not the case in Python, which can generate unnecessary machine operations. Furthermore, the CPython garbage collector doesn't move any variables in memory, the JVM garbage collector might. This will also lead to speedups.
This shouldn't have made me laugh so hard but it did.
Depending on usage, I'll particularly make them a little bit more generic: def compute_single(i): return i**2 def compute_all(a_list, fn=compute_single): for i in a_list: r = fn(i) if r % 100 == 2: yield r So, I can use it in more ways, according to my needs: lst = [1, 2, 3, 4, 5, 10] # forcing results rst = list(compute_all(lst)) # using it as a generator for rst in compute_all(lst): print(rst) # using lambdas for rst in compute_all(lst, lambda x: x**3): print(rst) # with a more complex function def complex_function(x): # processing... pass for rst in compute_all(lst, complex_function): print(rst) I'm always up for refactoring according to usage. YMMV of course.
&gt; why there is an apply function in python, is that redundant? The Python developers must have thought so, because apply() does not exist in Python 3
We don't need this function. It's deprecated in Python 2.7 and removed in Python 3. Apart from providing an additional way of calling a function, it does not provide anything useful.
"We" don't need `apply`, it was deprecated back in Python 2.3 (released in 2003) and removed entirely from Python 3. And it was necessary at some point before that, because Python used to not have arguments unpacking.
Literally use their url parameters. If you need the data you can use a webscraperblike Beautiful Soup. Here is the way it is formatted: https://www.nytimes.com/search?query=Test. "query={search term}" is what you would use.
&gt;same. and the fact that you can't just call the functions you decorate like a normal function. they need to be invoked in the context of click. wait, you sure? I thought a selling point of click was that its decorators didn't modify your functions
Now, I wouldn't call CGoL computing *history* :P There's still an [active community](https://conwaylife.com/forums) exploring it and other CA
I hate to jump on the author bashing train but... God damn. Just title it "Why **I** don't like to use Python" rather than the definitive statement currently used. Things like &gt; And I pity anyone who miscounts spaces and accidentally puts in three spaces instead of four somewhere -- this can take hours to debug and track down. Just make me want to ask: What in the hell kind of tooling are you using? Every single reasonable text editor and IDE that I've touched lets you configure how many spaces per tab. And just before that &gt; Deep nesting is permitted, but lines can get so wide that they wrap lines in the text editor. Long functions and long conditional actions may make it hard to match the start to the end. This is more of a coding style problem than a language problem. &gt; For other languages, I've picked up the habit of putting debug code without any indents. This way, I can quickly browse the code and easily identify and remove debugging code when I'm done. But with Python? Anything not indented properly generates an indention error. This means debugging code must blend in to the active code. Your habits don't mean that a language sucks. &gt; Python's import permits including an entire module, part of a module, or a specific function from a module. Finding a list of what can be imported is non-intuitive. With C, you can just look in /usr/include/*.h. But with Python? It's best to use 'python -v' to list all of the places it looks, and then search every file in every directory and subdirectory from that list. I'm sorry but... USE AN IDE. &gt; In contrast, many Python modules include initialization functions that run during the import. You don't know what's running, you don't know what it does, and you might not notice. Unless there's a namespace conflict, in which case you get to spend many fun hours tracking down the cause. I've never experienced this. You're importing a poorly written module if this is the case, or am I missing something? &gt; In Python, there's no difference between single quotes and double quotes. However, if you want your string to span lines, then you need to use triple quotes """string""" or '''string''' I'm curious how long ago the author tried Python and if they spent much time researching these issues. &gt; Reason 8: Local Names So yea the author mostly has issues with being stuck in their ways. That's fine, it happens to everyone including myself, **but be cognizant of it and try to realize when that's the source of your grievances**. I had initial issues working in Python regarding indentation, lack of curly braces and semicolons etc. but I worked through that. If you're going to be 
It's really not though. I read several tech/program related subs every morning and this sub is one of the least toxic of them.
Take a look at Python bindings for Selenium
Python cookbook.
I did add rudimentary DI to a big project (asking for 'thing that implements ICurrentlyNeededService'), but we made do without for years. We focus on integration tests and just mock HTTP responses on a low level and use SQLite for faster testing, though Postgres would work too. We actually like that our tests use the real things even if they do take over a minute on 8 cores.
I cant think of a legit text editor that doesnt show you blocks on the left margin. IE you can collapse an entire function, if block, etc to see where it ends, based on the indents. Even notepad++ does this.
Hey, I'm looking for the same as well. What resources are you using? 
It can be my internet. 
Yeah I need this tutorial... I have not be able to deploy my web app on heroku or pythonanywhere .
I will always go with Django. 
As another seasoned Java developer picking up python, have you considered that dependency injection is a code smell for anything but the entry class? In your example, your business logic is responsible for looking up the data as well as processing it. You use dependency injection to give it different ways of looking up the data. As a user of the method, you know that the dependency might be used, but you don't know for sure until you run it or look at the source or comments. Also, what if you have previously looked up that same data before calling the method? Now you either perform unnecessary extra IO or need to work with some sort of cache strategy and worry about times when you don't want cached data. Personally, I find it better to not have a dependency at all and instead look up the data prior to calling the method. Then call the method of processing the data with the data as an argument.
So you mean you bind a key to spotify to place a heart on currently playing track?
What about it? What are you talking about?
Oh, another Django v. Flask article... how original.
yep, thats right
I'm currently doing one by Tim Buchalka. It's a great course. He's got loads on there for python, android, java and a few others. Quick to answer questions in the video forums too. You'll never be stuck. 
No, it's the one OP also posted a [week ago](https://www.reddit.com/r/Python/comments/a5uzmi/django_vs_flask_which_framework_is_best_in_python/). 
Too bad, I'm in asia and the only thing I have that's close to Google pod is a Chinese phone with a bunch of bloatware (maybe malware and spyware somewhere in there, but who cares about privacy nowadays). Anyway, nice post. Definitely would try to smuggle a Google pod into my country someday to try this.
The idea was that if you have a bunch of parameters in a list, you wouldn’t have to cherry-pick them into the necessary positions in a function call, you could just pass the whole list to `apply` and it would put each parameter in the list into the correct position for you. (Lisps use it all the time.) With unpacking and splat operators, this isn’t needed anymore. 
Aww too bad. What would you use? Is there an alibaba pod? 
It didnt work for me either. I want to add it to [the publications page](https://github.com/metaperl/python-oop/wiki/Publications) so for now I will just link to this reddit thread.
down for me, as well
&gt; With unpacking and splat operators, this isn’t needed anymore. What if I have a list of binary functions and I want to randomly select one and **apply** it to some data: import random func = random.choice(binary_functions_list) apply(func, two_tuple) but I guess what you are saying is the last line could be written in a DWIS fashion of: func(**two_tuple) correct? but I really think the former version is more DWIM. 
You will get good feedback on /r/learnpython for this type of question. Looks like you got some good feedback here as well :)
If a function is a pain in the ass to unit test, it’s probably doing too much.
As mentioned by others, it's not needed because you can call the function with this syntax: t = (1, 3) add(\*t) Which will unpack the variable. But, if that feature didn't exist, apply is useful for calling a function with parameters when what you have is a list. Otherwise you'd have to do something like this: t = (1, 3) # pretend this comes from somewhere else x, y = t add(x, y) It gets more awkward if t can be of variable or unknown length. Your input is variable lengths, and the function supports variable lengths, but there's no clean way to supply those variables to that function without unpacking or apply &amp;#x200B;
From theoretical perspective, it is easy to justify the existence of `apply`, it's generic and easily extensible going forward, whereas argument unpacking is a kind of a gimmick feature of the language, that suffers from all sorts of incompatibilities etc. But... Python wanted to be special. You should be happy now, because you are using a special language.
Yes. They are vectors. But I fail to see how this makes situation different. They are definitely not lists.
One of the reasons: create a kind of grammar that you cannot parse with stock compiler-compilers (like YACC). I.e. make grammar on purpose non-context-free. This allows a programmer implementing the language to prevent a lot of wannabe programmers from easily following suit and writing their own but slightly enhanced version. This, on the other hand, gives the said programmer a permit to spend time implementing their own parsers (that's why CPython parser sucks so much, but nevermind that, the important thing was for the inventor was to have fun).
&gt; but I really think the former version is more DWIM. It's not. Also that'd only be `*` since two_tuple is a tuple. `**` is for unpacking dicts. Either way `apply` was removed from Python 3 since it's redundant.
The horror.
Have you looked at this https://devcenter.heroku.com/articles/django-app-configuration? There's also a [tutorial](https://devcenter.heroku.com/articles/getting-started-with-python) with all the steps for making and deploying a Django app. Besides the Procfile you need to change settings.py and make sure your environment variables are correctly set up on Heroku. 
That's great. It sounds like work I've done in the past. Thanks for the links I'll check them out.
Thanks for your answers! :) I will look at some Powershell and Python Examples and will then device what to do first. Happy Xmas!
I know 😁. I will say that I recently [recorded a video](https://www.youtube.com/watch?v=JG9rxhA9RSs) in the studio with my laptop &amp; dark theme, and in retrospect, I think the white background is much easier to read on video. 
The example is trying to solve bad design with dependency injection. You just need to fix the bad design. Your business logic should not have to know about the API. Here, I fixed this for you. class BusinessLogic: def __init__(self, results_from_api_call): self.results = results_from_api_call def do_stuff(self): api_result = self.results print(f'the api returned a result: {api_result}') # do something with the data and return a result This is even more testable, more readable, more functional (aside from the print statement), has less code, and doesn't require any additional 3rd party library.
I’ve never heard that before, many large companies do use Python for large-scale projects.
big != large scale. scale has to do with how many processors are running the code at once. python is an interpreted language (slow) and so running slower code at larger scales is inefficient. this is one of the advantages of Go, for example, or raw C++. if you can handle the security issues yourself that have to deal with pointer math, you get much better per-process performance than with an interpreted (safer) language like python.
/u/miguel/grinberg Since you seem to have taken a pretty serious stab at this... my question for you is: do you have any tips for getting used to the relatively 'stunted' keyboard on most Chromebooks? Between the odd layout of what keys there are, and then having them re-mapped to PC/Linux equivalents (I'm on my second CB, currently running GalliumOS) it's always one of those things where it *seems* like a good idea up to a point, then my frustration level peaks and I wind up going back to my Windows laptop for a while :/
Have you looked at pyglet? Its an alternative to pygame for games and "visually rich applications" There is also pyCairo, which might be useful
They just need an excuse to tell that their favorite programming language is better. I personally find that if you put a bit of time into organizing your structure a program written in Python will be able to grow to a million or more lines. &amp;#x200B; They could also mean that Python is slow. IMHO there is an misconception that applications written in Python are slow, because Python doesn't perform that well on benchmarks. It's true that for manually writing complex algorithms Python will not be the fastest, but you are meant to use C modules for that. You can see more arguments here [https://www.paypal-engineering.com/2014/12/10/10-myths-of-enterprise-python/#python-does-not-scale](https://www.paypal-engineering.com/2014/12/10/10-myths-of-enterprise-python/#python-does-not-scale)
Thanks. I'm a data analyst so this is probably way out of my range, but could be useful skills to obtain as it's kind of painful to dev windows application with C++. I'll start the learning after I'm satisfied with Python skills.
People who don't know what they are talking about exist, especially when it comes to topics where trolls thrive (such as "what language should I use"). Maybe in some cases it might come from the fact Python is pretty bad when it comes to memory usage and performances in general making it a poor choice for computationally expensive tasks (although even this is somewhat leveraged by libraries such as numpy). This has very little to do with the scale of the project, though.
I will check these, and wow, I didn't know there is python port of Cairo.
Many people prefer static typing for large projects because it makes very large libraries easier to manage and prove things about. Many people prefer compiled languages for large projects because it means you can catch a lot of errors before they're shipped, where you can only do the same in python with extremely exhaustive unit tests. Many people prefer fast languages for large projects because if you're working through several layers of abstraction, the whole thing can grind a bit.
Why?
"So, DI is a fancy term for instantiating classes in a top-level module, and passing them as initializer arguments to one another" - this is what I've always done and the code shown right after does this without a library or any new terminology or concepts. The points raised immediately after this example do not create a necessity for additional complexity. So what is this injector library for?
Because they don't know what they are talking about. 
Explicit DI works best with mypy and ABCs imhoo
I'm interested in hearing answers to this one as well. I had a recruiter in a phone screen tell me that Python is only used for hacking and that nobody builds anything important on it. I've also had multiple people suggest I work with Node.js/JavaScript instead of Django/Python.
&gt; Many people prefer compiled languages for large projects because it means you can catch a lot of errors before they're shipped, where you can only do the same in python with extremely exhaustive unit tests. OK I think I'm missing something here. If your code works and you've done some basic bug testing, isn't that good enough to show that it doesn't have any errors?
Nice, i will give a try! If I'll find some free time, I'll look into the open issues.
I think Django would do the job. 
You should never say your code has no errors
Checking your code works can become exhaustive on a large project and can even require a separate dedicated team for that purpose. Tests are also generally easier to write in compiled languages that have things like type safety. 
Not necessarily. There could still be a few things (environment issues, strange edge case/user behaviors, issues with error handling, etc...). The big kick, we are human and, more often than we would like to admit, miss things. This is especially true of "large scale projects" where multiple people have worked on the system and you may not know the entire thing. This is the real issue with python imo: it allows you to write really bad code that may work fine...for now. I love python and write it professionally but I have come to realize how easy it is to write hot trash that is just going to hinder future developers. 
Not even a little. What if the error is in a piece of code that's only run very rarely? "basic bug testing" might not exercise that code. If you're compiling the code and have a strong type system you'll catch an additional class of errors that without even running that code, so it's just some added safety. If you're working at the scale of a large project (my day job is millions of lines of C++ code, I use Python for scripting at work and for personal projects), then there's no way to "show it doesn't have any errors" - there will be cases or code interaction you hadn't thought of. And because it's such a large project, running the test suite takes a while so it's nice to catch some of the more obvious errors without even having to run my code.
It would be more correct to say it have no known errors. In my work I happen to uncover 20 year old bugs that only surface when usage patterns change. 
A QA engineer tests bar.exe. he orders 1 beer, 2 beers, 9999999 beers, -1 beers. No errors, ship it. First customer walks in. "Where's the bathroom?" *bar explodes* I guess it depends on what "basic bug testing" entails but users will always find ways to break your programs that you didnt. 
Static typing reduces a lot of errors in big projects. In Python if there is a function which returns an int but later you changed it into a string. Your teammate who uses the function is unknown of the change and hasn't modified his code which results in an error during production. These kinds of bugs are difficult in static typed languages like java.
This is the top answer. As an anecdote, my CEO was just telling me about his experience as a 19yo in college in the industry. Company wants him to rewrite a Perl script. 40K lines. In C. The perl script runs in 4 mins. The resulting C script ran in less than a second. This thing ran so many times that he saved something like 17 years of runtime. 
Ah OK I think I get it. My job/hobbies rarely entails writing/using more than 1000 lines of python code and I'm the only developer, so I suppose in comparison to projects on the scale that most people are talking about here my projects are pretty easy to bug check.
Can you tell me what result are you getting instead? It might be the server that proxies requests load-balances my blog. Might be some sort of anti-dos protection I need to tinker with. 
&gt; Tests are also generally easier to write in compiled languages that have things like type safety. Ah, not sure I agree with this at all. Can you provide an example? I just looked at a bunch of C++ unit tests and Python unit tests I have floating around here from various sources, and to be honest, I can't say that there is any great different in difficulty either way, but at least all the Python unit tests use the same system, whereas I seem to have three different sorts of unit tests in C++ projects I've been involved with here - Google Test, Catch and "someone's hand-rolled". 
I'm sorry, Python is only used for having but they want you to develop in JavaScript?
Just because some people would be fine doing this - it doesn't mean that its necessarily a good choice for a business. Not all the devs are going to be smart about how they structure things and define boundaries to separate concerns. Probably more realistic to assume devs are mediocre rather than excellent. And if a project is around for 10 years, then things can start off nicely organized and degrade over time. One good thing about static typing is that it forces a certain level of organization - you have to define the structure of the inputs/outputs between functional components - it isn't just a 'good idea'. 
No. Look at this function: ```python def name_to_title(names): return ["Mr. " + name for name in names] name_to_title(["Smith", "Jones"]) # ["Mr. Smith", "Mr. Jones"] ``` But someone else working in some other bit in the library, or as a downstream user, may not have read all of the implementations of all of your code (which is fine; that's kind of the definition of a large-scale project), and do ```python name_to_title("Smith") # ["Mr. S", "Mr. m", "Mr. i", "Mr. t", "Mr. h"] ``` It's not common to unit test all of your functions for the wrong types being given, because there's a lot of behaviour to test there. But a dynamically-typed language does allow this kind of error to happen (and often in more subtle ways), where this would never even compile in a statically-typed language.
Just to make things clear, I am not the author.
If it's small you can get away with this mentality. As it gets larger you start realizing how wrong you were. As it gets larger still you start really panicking. Eventually you're fixing things that always worked but suddenly don't and it makes no sense at all why it ever did. And then you rewrite it in something like C++, sorting out all the types, and discover how many square pegs python was shoving into round holes for you, and how ridiculously faster it is now, and that you look older and wiser and significantly more insane. 
Flask or Django are the big players. Lots of others out there with specific features but start with Flask if you want simple and minimal or Django if you're after lots of builtin features like users. Flask also has these things but they're implemented as extensions.
Or because weak typing is a nightmare in large, critical codebases.
&gt; Many people prefer compiled languages for large projects because it means you can catch a lot of errors before they're shipped, Having worked on large projects in both Python and C++, I'm having a tough time seeing this one. It seems to me that strongly-typed languages only catch one additional type of error - the case when you pass the wrong type of item to a function (or to an operator like `+` or `-` or similar ). However, in my experience at least, this is just _never_ a major issue! Oh, I make this mistake all the time - certainly in development you sometimes e.g. swap two parameters to get the wrong types - but the issue immediately pops up the first time you run the code, and if you have even moderate test coverage, it's something that you catch in an instant. If the only reason for working in a type-safe language is to catch this one single class of problem, then it absolutely isn't worth it, for something that shouldn't even be occupying 2% of your time in a codebase with any sort of decent testing at all. There are a lot of good reasons to prefer typed languages, particularly in terms of the ability to optimize the output code for maximum performance. I'm not at all arguing against typed languages in general, just saying that this one argument for them doesn't seem to hold water.
Also - just because you *can* doesn’t mean that you *should*
You can't build dynamic websites with Django. I am asking for a frontend library, to build website without using html/css/javascript &amp;#x200B;
&gt; you've done some basic bug testing As Edsger Dijkstra put it, "Program testing can be used to show the presence of bugs, but never to show their absence!"
&gt; I had a recruiter in a phone screen tell me that Python is only used for hacking and that nobody builds anything important on it. Holy shit. Most infrastructure as code, monitoring, and other projects important to enterprise IT are built on Python. How dumb are the recruiters you talk to?
This is a much more fun solution
&gt; I had a recruiter in a phone screen tell me that Python is only used for hacking and that nobody builds anything important on it Tell that to companies like Google that build a lot of infrastructure with Python. There is a reason recruiters are recruiters instead of engineers and it isn't because they know a thing or two about technology...
\&gt; You can't build dynamic websites with Django I think you're either misunderstanding Django or are mis-using the term \`dynamic\`
The thing that I don't like with static typing is exactly that it forces you to some specified structure. That structure more often then not doesn't scale well - and I'm speaking both up and down. It might be a bad fit for a small scale project, it might be a bad fit for a big scale project. Being able to structure your project however you want lets the structure to scale infinitely, as there is no hard-defined structure. About the additional work - it's just simple hygiene to keep your project structured, and additional work upfront is less work in a long term as it's faster to write in a dynamic language.
I wonder, though, if through the rewrite some other optimizations were ran, in the same way that if someone better at perl rewrote the perl script, it might also shave a few minutes off the top. Surely C is going to be faster, but IDK about 4 mins -&gt; &lt;1sec. Is C really 240 times faster than perl in general? 
Python *is* strongly typed. It's not *statically* typed. It isn't exactly just one class of problem, though. There's a very good reason that static analysis of code is heavily used. Obviously it's possible to statically analyse python and other such dynamic languages, but the analysers are far less powerful than, for example, rust's borrow checker. There are also lots of subtle errors which can slip through some tests because of duck typing but can create awkward bugs. I have deployed a lot more buggy python than I have buggy rust, and actually find I very rarely need to debug rust, because the process of getting it to compile is so exhaustive.
Hey, I've been playing around with DI on Python too! I haven't turned it into a library yet, but, it's starting to turn out pretty sweet (at least I think haha). Currently it supports dependency injection into functions, class methods, class constructors, and via class attributes. [examples](https://flask-unchained.readthedocs.io/en/latest/how-flask-unchained-works/dependency_injection.html) Getting to this point took a pretty deep-dive into how Python metaprogramming works but it's been totally worth it. (Got 1.5hrs? Watch the first half of [this talk](http://dabeaz.com/py3meta/)) The code lives [here](https://github.com/briancappello/flask-unchained/blob/master/flask_unchained/unchained.py#L125-L323) and [here](https://github.com/briancappello/flask-unchained/blob/master/flask_unchained/di.py) if you're curious!
The only reason I will sometimes stay away from python for larger sized projects is because Python’s relative importing system is more complicated than it should be. I have run into so many errors in the past when submodules are importing each other, and they aren’t properly being imported since they are being run from an outside folder. Note: Yes, I did have the ‘__init_.py’ file within the folder.
Can Django replace javascript ? 
When the rate-limiting portion of your code is network/file/db I/O, the speed at which your code runs doesn't really matter. In those cases, it's more fun to optimize for developer productivity and happiness.
No. However, WebAssembly is a promising avenue for allowing this in the future. Currently, no garbage-collected languages work with it, but this may change. For context, I'm building a frontend framework in Rust, which does compile to WASM.
Absolutely not. In large and very large systems, it's extremely hard to write code that is completely correct, and it's hard to verify that the code you have is correct. Each individual component you have might fail on edge cases if not tested aggressively - more, even though the parts all work, the whole system might fail for one of numerous reasons. I proceed with all my testing of software as if I were going to get on a plane that would crash if there were an unrevealed bug in my code. I test all these extreme edge cases and I find problems. Often the problems would have surfaced pretty fast in the real world. I read through the code and try to come up with tests that might cause problems for the logic, or pathological data that might make it do something unreasonable. It's far less work to fix bugs before they go into the code by detecting them through exhaustive tests then have it fail later and have to fix the problem through debugging... ...but more, it means you deliver a better, more professional product that handles all sorts of users with needs or usage patterns you hadn't anticipated because you made sure it did something reasonable in all cases.
Those are more or less what I've heard, not exactly because Python is "bad" for large projects, but people have preconceived ideas of how a programming language should be, and they only like to work on large projects on languages they're familiar with. My general feeling is that if you're relying on compiler errors for Q/A, your choice of language doesn't matter -- you have *much* bigger problems than passing a string to an int parameter.
Django can serve dynamic webpages... where the dynamic parts are coded in JS (or WASM)
My implementation of Hello World has yet to have a single bug.
Generally browser can only understand javascript. There's recent work in web assembly bringing other languages to the browser but I don't think Python is one of them yet since there isn't support for garbage collection. Your only option is something to use [something that will transpile python to javascript](https://github.com/qquick/Transcrypt). I've not heard of anyone actually doing this so I suspect there won't be much support in terms of bugs and new features.
No. Django a backend framework; JS is on the frontend. They complement each other.
If you are writing a library you should always assume that the user is a total dumbass(sadly true more often than not) def name_to_title(names): if type(names)==list: return ["Mr. " + name for name in names] else: raise TypeError("I accept only a list you dumbfuck") Here,your problems solved. But wait If I can return anything and accept anything I can use this for several cases: def name_to_title(names): if type(names)==list or type(names)==tuple: return ["Mr. " + name for name in names] elif type(names)==str: return "Mr. " + names else: raise TypeError("I accept only a list you dumbfuck") &amp;#x200B;
It's not about the testing frameworks. In type save language you know you only have to test for integer values if your function returns integer values, there's no way it returns a float or a string or some crazy object you won't expect. That means you only need to test for ints, there's no way to call a function with a string if the function expects a integer value, the compiler will throw an error if somebody tries to do that. So it really just limits what you have to expect and test for. Unit test frameworks are no magic and it's really easy to hand roll your own unit test. Just call a function with a few predetermined values (like you'd do in a unit test framework) and compare it with a hard coded known result. I'd rather have small projects write a simple test program instead of adding a monster like google test to the list of dependencies just to call "multiply(x,y)" a few times with different values. 
Off topic: wow, what are all of these fast statically strongly typed language guys doing here? Shouldn't they be afraid of Python and stay away from this sub?
'frontend web app' implies a different meaning of 'dynamic' than what you're thinking of.
Okay so this is a bit complicated. In many ways cybersecurity is kind of orthogonal to python. So you learn cybersecurity and you learn a programming language, and some cybersecurity needs you to program, but it doesn't necessarily matter what programming language you use. But this is only partly true: * Your ability to do things efficiently is limited by your familiarity with tools and libraries * Sometimes one can remove the need to understand things by using tools. So you might be able to be efficient without completely understanding everythin. At the same time, once you understand a concept in one language one can quite quickly adapt this knowledge to another language and often the libraries are near identical. I can think of a few reasons why books might be written for python 2. i. security research is a niche activity, so it is not profitable to update the books, ii. because security tools are not exactly "used in production" and don't necessarily intergrate with other tools through an api interface there isn't much of a reason to upgrade tools to python 3 so a lot of the tooling for security might remain in python 2 (this has been my experience for many libraries). Another thing I would note is that changing from python 2 to python3 is in many ways a superficial change. Changing *code* from python2 to python3 is a lot of work, but going from programming python2 to python3 isn't that much work. ------- Where does this leave you? I would just learn cybersecurity with python2 and then use python3 for most of my work and become familiar with both python3 and python2 because it isn't that difficult. I would always leave tools in python2 if they are in python2 but use the version that works with python3 if possible. 
s/have/exhibit/ FTFY o7
You should mention the zope.interface in fact... And Pyramid which is a great implentation of the inversion of control. Basically, you have a registry, interfaces,andyou register an implementation for that interface. Pyramid has many interfaces you can plug tons of things yourself using its configurator. I sometime says that it is an initialization framework more tha a wsgi framework... Flask django cannot be tweaked like that.
Just laugh at those recruiters, and tell them they have no idea what they're talking about. Normally my go-to for "important" Python projects would've been Datadog, but even they're moving towards Go. Sentry is another solid entry in the Python app space. Python probably accounts for 75-80% of the AI/ML/NN space these days, via TensorFlow and related projects. Then Red Hat Linux (and its derivatives), are heavily dependent upon Python, in that Yum is fully a python ecosystem. dnf also started life as Python, but is being (or has already been) ported to C. As for Node.js/JS v. Django/Python it mostly depends on what you're trying to achieve. It certainly can't hurt to learn both. They both have ideal workloads, albeit Node targets more concurrent-style workloads the Dj/Py. In the end the *major* hold back for Python in the "large scale" demographic is, and will always be, the GIL. So when you hit a point where you say "Hey, I need to work around the GIL, so let's try Cython/Jython/IronPython", then you're already halfway to just saying, let's just write this in C/C++/Java/.NET
Have you considered character encoding and i18n? 
I think the author of Transcrypt actually do use it in production.
One thing that people haven't mentioned, is the GIL. The GIL is often a barrier to something large scale projects often need, which is concurrent operations. There are work arounds of course, but it's often easier to just use another language better suited for concurrency. But there are *many* large scale python projects out there. And Python is dominating the frontiers of AI/ML/NN projects. And also, as has been mentioned, and is worth mentioning again. Speed often matters, and compiled languages typically run faster, either via JIT, or via compiler optimized run-times.
You're totally right about static typing - I mainly work with php and abusing type hints made things much more self-documenting and easier to reason about (although a bit scary when you step into Java territory). At the end of the day, I'd say I love languages with optional static typing. If you're making a small throwaway script just hack along quick, if you're working on a big project make sure to litter it with the right checks and it'll save a ton of time by failing asap if shit fucks up.
I would for sure use list comprehension over a map. It’s more pythonic. List comprehension can be used for mapping and filtering, and a lot more. 
What happens when you order a tequila?
Not in general, no. One order of magnitude can be accounted for by the difference between an interpreted language and a compiled language pretty easily. Beyond that it's difficult to say without seeing what the script was doing. Better memory usage, better algorithms, improved data structures, and better libraries/providers could easily account for the rest. The second write of anything, even when you're moving to a new language, often includes better optimization of the overall algorithm in some way. 
[BUG] Running "Hello World" on Big Endian Systems results in "eHllW oolrd"
That's a good way of putting it
For 16 years I managed an ever-growing website codebase. We were small and started in J2EE / EJB, back in the EJB 2.0 / Java 1.4 days. We didn't like it as it took too long to spell stuff and had too many layers. And that was before EJB 3.0 left us stranded. So we moved to Python. My tenure ended with &gt; 400K lines of python in ~1900 modules, including tests but not including templates (which held their own nontrivial amount of python (Cheetah)). Somewhere along the way there was certainly a pivot point at which a static typed and distinct compilation unit pass language and ecosystem would have made parts of software engineering simpler, super especially as the team grew and we had more distinct features being developed in parallel. Having a compiler nearly immediately emit a concrete list of initial issues you've not yet addressed in a refactoring would have been a big time saver -- much faster and accurate than, ahem, grep and friends plus then waiting for a full jenkins test suite run to complete. As dev team manager, it would be irksome every time a dev would do their last check-in of the day, expecting to see happy test results in the morning, but then to be met with yet another round of stupid mechanical issues preventing a green light which needed yet another dev context switch plus then waiting for another test suite run. Had they been alerted at compilation time, then those 5 more mintues the day before would have amounted to big gains in 'time to ship' from this one engineering issue. Now, tangible measurements of all of the niceties that python gives? I can't say other than it certainly felt more expressive and so forth on a line-per-line basis. Python remains attractive at the start-up and web-shop level because of the 'time to launch' advantage. Get something online as soon as possible to beat your potential competitors to market. It certainly allows you to be able to deploy, and then to deploy new features fast. But somewhere along the way, after dozens of cycles of that rinse / wash / repeat loop, it can well make things slower due to your lines of code and complexity growing faster than the automation assists. Java, C#, etc. just has so much more constant automated checking at the price of being less flexible and more verbose. Test suites are still of paramount importance regardless of language, but having the static analysis performed by a compiler happen every time, and quickly, would remove one or two levels of 'stupid' tests needing to be written. Nowadays, sure, we've got type annotations and pep8 git commit hooks and such, but I'm willing to bet that a java, C#, or even C++ refactoring IDE would allow for way faster and less error-prone long-lived codebase operations than afforded in Python. So, we wrote more tests and got really good at code reviews. We augmented our testing infrastructure with Jenkins and a kubernetes cluster of test runners. We patched postgres to work with btrfs COW to very very quickly clone today's testing database to allow for yet another test pass. Anything to make running the test suite faster. Alas though -- the benefits of a language like java can easily be well lost when starting out, way outweighed by the, ugh, 'agileness' of a more dynamic language like python. But you can then be vicitimized by your own success and then feel like you're being somewhat hamstrung by not having been writing in a 'bondage and discipline' language all along. That said: we love python. To stay hygienic, though, you just have to be much more diligent in writing tests, early and often, and just suck up that refactorings will take longer in the future. And alas, that 'more test code' becomes its own weight in the long run.
Can you explain how python is strongly typed but not statically typed? And could you respond to this SO answer, perhaps explaining where you disagree? Because I feel like I may be missing something in your answer. [Static vs. Strong](https://stackoverflow.com/questions/2690544/what-is-the-difference-between-a-strongly-typed-language-and-a-statically-typed)
Depends completely in the operations. It could be if optimized choices are made for data structures. However, it comes at a cost. At a certain scale, the dangers make safe C come into play. Often, Python is fast enough for most code and just the tight loops or common code is what need optimized. So you then can optimize both coder time and run time.
Not by a long shot. Showing something has *no errors* takes FAR more than that. But that discussion aside, you can pass things around in python without generating an error message and still cause logic bugs that a compiler with type checking would have caught at compile time.
The only thing I know about the perl script is that he ran into new variables around line 38,000. Its possibe this was just appended as time went on, and his rewrite played a huge part in it. 
How does static typing force you into a structure? Are you writing Python where you change the object types assigned to a variable as you go along? If so, good luck figuring out what is going on. Static checking fixes bugs without needing tests for it. This is a fact. However, typing in Python 3 has added this functionality for all intents and purposes.
But then it was a nightmare anyway, and at that point you're just looking for things to toss on the nightmare bonfire. 
Spot check for bugs anyways, there are probably things you are missing or not thinking of if all you are doing is "basic bug testing". Are you exercising EVERY line of code with the basic bug testing? Are you checking for ALL inputs (expected and unexpected)? What happens if I load down some inputs with emojis? Basic bug testing and "it works" only proves that it does what you expect when you do exactly the tests you performed. This type of testing should never be used in a production system more than 50 lines long really.
&gt; and they aren’t properly being imported since they are being run from an outside folder. This sounds like it would be fixed by using virtual environments. 
This is what I have usually resorted to, but I wish it was easier to set up the project’s environment without using them.
No not really. Strongly typed / compiled languages make it easier to write precise code. This pays dividends as a codebase grows in size.
With that attitude, I don't think we are going to let you write code for airtraffic control systems :-)
Perhaps you should look into [using Poetry](https://poetry.eustace.io/), as it will handle most of that for you, as well as handling packages better. 
For larger systems you need all the help you can get. If you don't grasp that, I wonder if you have ever worked on legacy projects with millions of lines of code. Static code analysis is no substitute for QA. It's complementary. 
And doesn't even need to be class, even better!!!
Oh, this seems really interesting. Thanks for the advice!
And you have to write fewer tests too. For example a method typed as accepting values of type 'int' then you don't have to write tests on what you think should happen if you pass it a String or... whatever. Since that sort of thing is just not possible if the program type-checks.
Because they don't know how to setup a large scale Python project. A language like Java has a lot of built in safety checks in its compiler. These features exist in Python, it just does't have to have a compiler, so you need to have someone who knows it's a good idea to setup type checking and automated linting.
that being said, Python is strongly typed. It's not *statically* typed.
If that's the complexity of code you work with on a daily basis, by all means, keep doing what you're doing.
Thanks for sharing your experience, it was very eye opening to me!
Static typing: `int x` Strong typing: `"2" + 3 =&gt; Error`
Right. And be honest. Have you ever written more than a few lines of code without some sort of mistake in there? I haven't. And I've been at it for a while. So its really nice when a compiler/IDE catches some of your dumbest mistakes *while you type* without having to run all your tests. Typos in variable and method names is just one obvious and 'dumb' mistake we make all the time. Actually, thanks to static typing, you also get better content assist from the IDE (i.e when you start typing a name and the IDE finishes it for you without a typo :-). And yes, you cam have some of that for python too, but it just doesn't work as well when there's no static types the IDE can rely on to know what kind of thing you are trying to call this method on.
I don't know, my experience with the Chromebook keyboard isn't bad at all. The layout has some differences, true, but I have been using ChromeOS+Crouton for over a year and didn't really find it hard to adapt.
As someone who's been writing Python pretty much all my programming life and is working on large projects with it, I am never going to start a project without using types again. I don't even care about the type checking, usually. The biggest benefit is that well-written types are **self-updating, clear, always-correct documentation**. Compare `def parse_data(some_opaque_dict)` with `def parse_data(r: APIRequest)` where `APIRequest` is a class with specific variables (a la `attrs`). In the first case, you have to run the program and print the dict to see what it looks like, but in the second you know exactly what's available and what you can do. It's not so much about static vs dynamic typing, it's more about sane inputs and outputs to functions and contracts to same.
&gt; where you can only do the same in python with extremely exhaustive unit tests. This just isn't true. I achieve more or less the same thing with the assert statements to establish pre and postcondition invariants and a handful of tests. In fact, when I work on a large project this is one of the first things I start doing. Static typing is minimally useful as a bug catcher when you have a reasonable body of tests and invariants. Of course, having a reasonable body of tests is apparently a high bar in this industry, hence the general attitude surrounding static typing.
&gt; I work with Node.js/JavaScript instead of Django/Python. Oh boy. That made me cringe. Unless he meant 'type script' which you can use really nicely in the nodejs eco system. How is js any better? I'd say its much worse. 
&gt; I had a recruiter in a phone screen tell me that Python is only used for hacking and that nobody builds anything important on it. They don't know what they're talking about. Instagram runs on Django. &gt; I've also had multiple people suggest I work with Node.js/JavaScript instead of Django/Python. Same here, it's not like JS is better (in my opinion, it's worse). The biggest problem with Python, in my experience, has been the lack of types-as-documentation (I'm loath to say "static typing" per se because static typing by itself doesn't do much, you have to know how to use them) and the fact that it's so dynamic that it makes introspection hard. In Java, for example, you can click on a function and the tooling will tell you exactly where it's called from. In Python, you can never get every single place with certainty, but you can get very close if you aren't being too magical. That's basically it.
Just make sure to set run `poetry config settings.virtualenvs.in-project true` first so it behaves like venv does. 
You can always use Kivy or PyQt for drawing stuff on the screen.
python is strongly typed
"Strong typing" is, in general, an awful term to use because it has at least 6 different, more or less equally valid interpretations - some of which complete (one of which is actually "static"). That said, it's typically referring to a lack of implicit type conversions. E.g. Perl: '1' + 1 == 2 Javascript: '1' + 1 == 11 Python: '1' + 1 == The programmer obviously fucked up and I'm not going to try and intepret his bullshit C is a good example of a language that is both weakly and statically typed. I've seen strings like 'reg3o4' converted to 34.
I wrote a little utility function listify that takes &lt;whatever&gt; and if it's a list it just returns it. A single string, unicode object, or int gets made into a single item list and returned. End up using it all over the place and it makes my life so much easier. 
I ported the first few chapters of BlackHat Python to python3 and taught a web course. You can view the slides here: [https://github.com/tiarno/bhp3\_class/tree/master/bhp3\_class/areas\_for\_class/demo\_plus](https://github.com/tiarno/bhp3_class/tree/master/bhp3_class/areas_for_class/demo_plus) In the repo there's the actual code as well. Hope it helps.
Dynamic typing?
DI is pretty common in the Python world, but I keep not liking it. From my experience it increase readability, but decrease decoupling and ease of evolution of the project. In the OP example `BusinessLogic` need to know how `Api` works, therefore you can not change `Api` with `MoreSofisticatedApi` without having to check that `BusinessLogic` can properly handle the change. In bigger applications every single change in `Api` can lead to many regression, because `BusinessLogic` is dependent to the way `Api` it's been implemented the first time. Also, if `Api` is in a separate module, you have to stick to that even if you find/implement a better way to do what `Api` does. I like more the "primitive communication" approach (I'm sure that thing have a name, but I don't know the name), basically let classes communicate with primitive data structures as long as it's possible/efficient (just like /u/flipstables said), and add custom data structures only if more than one class in the project can gain advantage of that: class Api: def fetch_remote_data(self): return 42 class BusinessLogic: def do_stuff(self, ingredients): return ingredients * 42 data = Api().fetch_remote_data() result = BusinessLogic().do_stuff(data) In more complex designs: class BasicDataContainer: def __init__(self, number): self.data = number class Api: def fetch_remote_data(self): ret = requests.get('www.42webservices.com') return BasicDataContainer(ret) class FileSystem: def load_data(self): with open('data.txt', 'r') as f: ret = f.read() return BasicDataContainer(ret) class BusinessLogic: def do_stuff(self, ingredients): return ingredients.data * 42 With this last example BusinessLogic is agnostic about what is giving him things, as long as it's a `BasicDataContainer`.
One other thing I learned is that in a successful website/database project, the database and data is king and long-lived, while the application-level code is transient. That rewrite from java to python, co-habitating and agreeing on the shared database, was greatly assisted wherever we had tight constraints, and hindered wherever the database allowed loosey-goosey junk. Time spent writing database-level constraints, checks, and enforcing inter-field, inter-record, and inter-tabular consistencies became money in the bank in early-catching regressions in such a rewrite, and then in successive python-side refactorings, expansions, interacting new features, etc. Yes, you will need to replicate such checks to varying degrees in your application and UI code in order to make for a pleasant user experience. But the buck stops at the database, period. It is your last line of defense. When judging a rewrite / refactoring of a piece of DB-intensive application code, being able to point at a pretty "tight" schema and then say "at least the database is happy with the new code" makes all the difference. And yes, you then also need test code exercising those db-level constraints / checks! Otherwise how do you know that they themselves are written right and reject what they ought to and allow what should pass? At least those tests are just as necessary regardless of what application-level language you're using!
Really broad statements like "Language X is not good for Y" are simply piles of bullshit heaped on some poorly understood bias the person saying this really has no clue about. &amp;#x200B; For Python, people who say things like this are covering over one of two things: &amp;#x200B; 1. Python is slow 2. Python is dynamically typed. &amp;#x200B; Let's deal with these one at at time. &amp;#x200B; "Python is slow" Okay. Does it execute on benchmarks slower than compiled languages? Yes. Does that matter? It depends. For any I/O-bound application, the speed of the language *does not matter.* You can write your web app in pure assembler, and it won't execute any faster than the Python version, because the speed of language execution will not push data from your I/O pipe to the processor any faster. Javascript, Go, PHP, C# all execute much faster than Python. It makes exactly zero difference for I/O-bound applications. Perceived (wall clock time) speed of these types of application have everything to do with architecture and nothing to do with the underlying language. You can write shitty slow web and GUI apps in Golang and C# just like you can in Python. If you block the main event loop in Go with a non-yielding process, it will hang up and slow down just the same as it will in Python. &amp;#x200B; For CPU-bound applications, Python has a ton of libraries with C and FORTRAN bindings that close the execution gap so much that it's a non issue. One category of apps I'll specifically call out that Python legitimately is too slow for is High Frequency Trading. If you aren't involved in that or a few other extremely specific markets where every microsecond of execution makes a difference, Python is not too slow. &amp;#x200B; What really matters a thousand times more than language benchmarks is how productive you/your team is. Clock cycles are cheap. People are expensive. Anyone who says, "Language x is slow" or "Language y is fast" has just communicated an extremely important piece of information to you: the person you are talking to is a complete fucking moron who doesn't understand how writing software works. If the person saying this is a recruiter, that's fine. They aren't supposed to know anything at all. Recruiters are doing an A+ job if they can remember to breath every 2 minutes. If that's an actual engineer--or god forbid, a manager--walk away. &amp;#x200B; &amp;#x200B; Python is dynamically typed &amp;#x200B; Actually, the person talking about Python being bad for x usually doesn't even know enough to get this right. If you press the person on why Python is bad for large-scale projects, they will probably say the wrong thing and complain that it's not strongly typed. &amp;#x200B; The reality of this bullshit debate is that static and dynamic type systems are tools that are better and worse fits for different situations. Whether you need static types--and how strict you need that type system to be--boils down to your specific application. What is your tolerance for the class of errors that static typing guards against? Are you writing yet another startup-y garbage social media clone where basically nothing matters but getting to market before the competition so you can raise money? Great. It doesn't matter. You can write your app in brainfuck, and that's fine if that's what your team knows. Are you writing a financial application that moves money around banks, requires transaction guarantees and maybe some proof of correctness so that you can sleep at night? There are better options than Python. &amp;#x200B; Please note, that the choice about using static or dynamically typed languages has nothing to do with the "size" or "scale" of a project. That's just an ignorant buzzword. It has everything to do with your application's tolerance for a certain class of errors. All things being equal, the answer to this "gif" vs. "gif" internet squabble about type systems is basically, "all things being equal, use what your team is most productive with." &amp;#x200B; "X isn't good for Y" in general. &amp;#x200B; People who say this and won't let you write a dirty script in Python to get a job done in 5 minutes and instead want an enterprise solution in an enterprise language are the same people that will breeze right through a C# code review where you've declared all your variables as vars and use Dictionary&lt;string, dynamic&gt; instead of structs or objects. "Looks great! Ship it!" &amp;#x200B; Whether this kind of blanket generalization is a canard or a canary or a cancer really depends on your relationship with the person saying it. &amp;#x200B; Recruiter? Canard. That's really cute how you think you know things. Bless your heart, sweetie. No big deal. Your boss or coworker? Canary. Avoid. Pull out. Do not engage. Some blowhard on the internet like me? Most likely cancer. &amp;#x200B; Almost any modern language is fine for almost any project. The real success or failure of the software is going to boil down to design and architecture of your code *and* the data it interacts with. Anyone who says otherwise is most likely an idiot.
While I agree in principle with what you said, a few pedantic points: 1. You can compile both manifestly typed languages, i.e. "statically typed" languages, as well as latently typed languages, i.e. dynamic languages. A language being compiled or not had nothing to do with its typing discipline. E.g. hugs is an interpreter for Haskell, while SBCL has a very good compiler for Common Lisp. In fact, Python is also compiled to bytecode. 2. Languages don't have speeds. They have characteristics that make efficient implementations easier or harder. E.g. Python's very dynamic nature makes it hard to implement efficiently. That being said, JavaScript is also a very dynamic language, and V8 is a relatively fast implementation. And before I go: https://www.xkcd.com/386/
With a typical development team, statically typed and compiled languages won't encounter a whole host of run-time errors that one can have with python (e.g. "Operation not permitted." "Global variable not found." ). That said, if you have proper code coverage with your unit tests, you won't have that with python either. The real question is whether your development team is disciplined enough to have proper code coverage with unit tests with a larger project. 
I second this. Being able to look at a function signature and have at least an inkling of what it does from just the signature is invaluable, especially with a large project or library. Also, static typing gives much more dependable auto-completion support. A lot of the objections to static typing come from experience with languages that make static typing overly verbose (I'm looking at you Java). I've recently been working with Rust, which has a well constructed type system. While there is upfront cost to static types, I have a lot more faith that my program will Just Work if it compiles. And unlike Python where type checking was hacked on, Rust doesn't have a bunch of weird edge cases like not being able to represent JSON.
In JavaScript it's '1' + 1 == '11', not 11
Do you have another example of what you mean? Your example is basically just an example of poor naming. It should really be def parse_data(api_request): vs. def parse_data(r: APIRequest) : in which case the difference is not so clear. In addition, that exact same benefit already exists in Python in the form of types hints (although maybe that is what you mean when you say 'using types'?).
I think you'll find the [deployment video](https://www.youtube.com/watch?v=FHJvsvbD_cQ) of the series very helpful. With the [Azure App Service extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azureappservice&amp;WT.mc_id=ch9-reddit-ninaz) for VS Code, you can deploy with one click, set environment variables for your instance from the plugin, and even see logs right within your VS Code terminal. For a simple Django or flask app, all you need is a `requirements.txt` file at the root of your project. Everything else will be picked up automatically. The video is a detailed guide, or you can also check out the [step-by-step docs](https://code.visualstudio.com/docs/python/tutorial-deploy-app-service-on-linux?WT.mc_id=ch9-reddit-ninaz). If you have questions or feedback, you can send it my way. 
As someone who worked in Javascript for a long time, and still occasionally do. That "1" + 1 = "11" nonsense caused me a lot of pain.
In that space, I see a lot of Python, but even more Go. Could you be more specific about Python projects in this space? There's Salt, Ansible (and the brand spankin' new OpsMop), Docker Compose. What else? What for monitoring?
[Reahl](https://www.reahl.org) and [Nagare](http://naga.re) are Python-only full-stack frameworks. /r/RemiGUI is a Python-only library that renders js and html for you. Transcrypt, Anypylar and PyJS are also options to keep you entirely in Python instead of dealing with HTML, CSS and JS.
Python is [dynamically typed](https://pythonconquerstheuniverse.wordpress.com/2009/10/03/static-vs-dynamic-typing-of-programming-languages)
I have been wanting to create a class for a problem like this, I'm not sure quite what you mean though. Can you give an example?
You’re right, I meant dynamic. Changed.
You’re right, I meant dynamic. Changed.
It just says this site cant be reached. I'm firewalled at work, so who knows why it's happening.
So you're saying this would work if the music was playing off your phone or whatever. That's pretty awesome! 
This video is first in a four part series. You can watch the rest here: * [Part 2: One click deployments to App Service on Linux from VS Code](https://www.youtube.com/watch?v=FHJvsvbD_cQ) * [Part 3: Continuous Integration and Continuous Delivery with Pipelines](https://www.youtube.com/watch?v=OMtpVqzpJ9w) * [Part 4: Serverless Django Functions](https://www.youtube.com/watch?v=bEsgi1oi8qc)
```python def foo(response: Union[requests.Response, http.Response]): ... ```
I'm really happy to hear that. If you have feedback or comments you can send them my way and I'll pass them on to the team.
&gt; what are all of these fast statically strongly typed language guys doing here? Trying to educate the newbies.
No, that is forbidden 
Maybe if this had been rewrote with Python, its speed-up would have included the bypassing of Class Structuring by way of an overuse of Functions..? And then there's the use of C Wrappers, but don't pay any attention to me; I'm only running an analogy into this haphazardly.
Because few large-scale projects that are written in Python are such a horror-show that nobody wants to repeat it again. For instance, take MS Azure SDK. It's an unnecessarily huge project. It could've been just an HTTP client for their cloud platform, but it just got out of hand, and as of today, probably, includes half of the packages that exist in PyPA's repositories. What's so bad about it, and what is indicative of problems *any* large project would face? -- *INFRASTRUCTURE!* Python's infrastructure sucks balls. Don't listen to anyone who tells you that writing type assertions in your code will make your project scale better: that's utter nonsense. In most likelihood the result will be the reverse: more code creates more problems. But infrastructure is a whole different story. If you don't have a sane way to deploy your project, programmers on your team will have to depend on your ops team to write something for them. No ops team wants to roll out a generic solution: everyone just does enough for their needs, so everything that comes out, comes out lopsided, a little broken, with a few holes. Programmers then learn to hate the project and avoid doing any more work than absolutely necessary to maintain the appearance of work. This is why a lot of programmers who worked with Python as their second language (maybe used for the build system, maybe for tests, maybe for some other internal tools) learn to think about it as of some kind of a joke language: it's kind of OK, but you don't really want to touch it, since once it grows beyond a single script, you'll get yourself into so many troubles, that you'd rather just not go there. In the past, I had to don both hats, I've been in R&amp;D and in ops. I know how both feel about the problem: quite frankly, ops, typically, aren't the sharpest knives in the drawer, and the challenge of packaging and distributing Python code is anything but trivial. It's also invitingly simple at the first glance. So, people start by writing a few lines of prototype code that should, in principle, accomplish what they want, only to end up with a monster cluster pain after a year of trying to make it work for real. R&amp;D folks on the other hand can be easily tripped by the simplicity of `pip install whatever`. Yeah, it works the first time, but it opens a can of worms they will not know how to close. That seems like what happened to Azure SDK project: programmers installed random dependencies without any kind of control, and now it's no longer possible to really use the SDK because it's so deep down the rabbit hole of dependency conflicts, it just won't install.
where
If you've ever worked in large have projects, what happens is that you end up with lots of classes representing very similar, or even the same, thing. Naming doesn't cut it, after a certain point.
But '1' - 1 == 0, not '0' Yay, JavaScript!
I work mostly with Javascript, and now with TypeScript its a godsend! Actually makes the development really fun and also i feel ”safe” with TypeScript. I work in quite large projects and types are essential for us. That said, python with types and mypy is also a very solid toolkit for big enterprise software. Types reduce the need for tests, and is self-documenting. 
You'll find it somehow, I believe in you!
&gt; Compare def... First is an OK Python, second is a brainfart. Types in Python don't work the way you imagine, you are only confusing yourself by adding that `APIRequest`, because it's not an `APIRequest`, it's a `PyObject` with a bunch of slots in it's `PyTypeObject` slot set to a bunch of values. And that's how Python *really* deals with types. I've had to work with code written like this. It boils down to cursing the idiot who wrote every few minutes that you have to touch it. It's the same kind of people who stick `isinstance(x, y)` where it's not necessary / harmful, but they believe they accomplish some virtuous goal by adding this garbage to their code.
Ex-Googler, entirely agree. I almost exclusively used Python in my time there.
 &gt; It's an unnecessarily huge project. How is that the fault of Python itself if that project is poorly designed. 
I think you got to the cusp of weakly types languages. I’d rather get an error and fix the code by being explicit than have to memorize how every weakly typed language is going to implicitly coerce 
I think most of the people that say this haven't tried it, or got brought into a poorly thought out/poorly managed large python project. You can make a mess with most languages, even strongly typed compiled languages. The critical things to consider when picking languages for a project are how the available tools work to make development easier, more confident, and fit the requirements of the end product. How many people working in the codebase? How experienced are they in this thing? You'll likely choose different languages for a 1 person project vs a 50 person project.
Skipping over the sweary bits, this guy makes good points :-) I would add that one should push back on speed arguments when that requirement is not spec'd once adequately spec'd often algorithms can be quickly trialled in Python in less time. 
&gt; It seems to me that strongly-typed languages only catch one additional type of error - the case when you pass the wrong type of item to a function (or to an operator like + or - or similar ). It’s not about the “catching additional types of errors” at all, but rather about encoding high-level parts of the business logic into the types themselves, and then being able to rely on that. I’m all for Python, but having programmed in Rust for a while, it’s hard to return to Python sometimes. Finally, the “redundant verbosity” is quite often a myth, and in real production Python codebases you spend a lot more time and LoCs validating input types, validating conversions, and dispatching on value types etc, than a static language compiler would do for you automatically and for free. IMO, what Python is perfectly suited for and where it would be hard to beat is notebooks - that’s just brilliant and makes research and experimenting easy, efficient and accessible. But that’s exactly the case where you would just write once-off kind of code and you don’t care as much for invalid input types and other errors.
In 1976 Pet Rocks had sold 1.5 million pieces. Would you call it a non-useless object? I'm not even surprised that there are 2.6 million VSC users, you know that there are approximately 3.8 billion people with IQ lower than average. VSC users (in 2017) only cover about 0.069% of those dumbest 50% in the world.
Give this a read and reply back with any questions https://www.tutorialspoint.com/python/python_loops.htm
Probably not the best way but you could easily accomplish it with that in a "while menu not in (1,2):"
&gt; C is a good example of a language that is both weakly and statically typed. I've seen strings Are there strings in C?
menu = 0 while menu != 1 or menu != 2: Ask for input Conditionally print input or ask for valid input.
Then there's a thing called docstring to put that kind of inforamation sir! Just type is usually not enough to describe a parameter anyway.
&gt;... that suffers from all sorts of incompatibilities etc. Can you expand a bit on what you mean by that? I'd like to know a bit more about that.
Maybe just another example: you're working with a class that you don't know and you simply want to know what method this class has again. In Java the IDE always knows what type you're working on and can show/autocomplete everything for you. In Python you often don't have that, Pycharm tries to do it, but it often fails. Of course you can just look into the class you're interested in, but that takes time.
I'd love to connect this to a button and put it in my car!
&gt; But someone else working in some other bit in the library, or as a downstream user, may not have read all of the implementations of all of your code Then, in this case, it's your fault not **documenting* the function properly.
I remember trying to optimize python code recently (similar as perl right?) and managed to make code several thousand times faster with Cython. Basically doing the exact same thing. 
They said "etc", dude, what more could you want
&gt; Your teammate who uses the function is unknown of the change Yeah so commit logs are just garbage.
That's the Azure tab, it appears when you're using any of the Azure extensions: [https://code.visualstudio.com/docs/azure/extensions](https://code.visualstudio.com/docs/azure/extensions)
nah, its an array of char
There are arrays of chars, which is known as a C string.
&gt; a Perl script. 40K lines I wonder when a file got too large that it is can no longer be called *a script*
r/learnpython
OP’s not asking about front-end, not back-end frameworks
&gt; C is a good example of a language that is both weakly and statically typed. I've seen strings like 'reg3o4' converted to 34. That conversion is not a part of the language. 
Honestly, this sounds more like a general architecture problem. If the code is capsulated in nice, well defined modules, you can simply run the unit tests on your machine and it's done in 10min. You would probably see the same problems with Java, maybe not the pure type errors, but all those weird side effects when changing code in an old code base. Source: working on a 12 years old Java behemoth right now.
This is 6.0001/0002. I would recommend taking a look at the 6.009 materials instead if you have a bit of experience 
&gt; It seems to me that strongly-typed languages only catch one additional type of error - the case when you pass the wrong type of item to a function (or to an operator like + or - or similar ). Oh, hey, howsabout, say, when you refactor and change the datatype of a column in your database, and then therefore your ORM, etc. Like say the common boolean -&gt; date transformation. Or remove a column which has an unfortunately common name, like, oh, 'type.' Having the compiler be able to conclusively tell you "Here's your list of broken references" is then gold. The benefit isn't so much in the static typing, but rather the compiler's absolute knowledge of names of data members, methods, etc., and its ability to yelp very very quickly as opposed to having to run whole test suite just to be somewhat confident that you did change all of the references.
Also Python is compiled. What are you even trynna say?
I know this is a stretch, but would anyone be willing to download this before it's removed? I appreciate the link and will do my best to watch it, but sometimes I'm slow
I doubt it will be removed anytime soon, and it's mirrored on the MIT site as well.
&gt; I've seen strings like 'reg3o4' converted to 34. Hmm. Could be that you saw a function, written in C, that did this. But that is hardly the fault of the language. Other than that I can't really think of a function in the standard library that would exhibit this behavior.
Especially it's written by MS. I mean, just look at Windows. I don't think it's the fault of the language.
What kind of specified structure do you mean? I can't really think of anything being forced on you by typed languages.
And proper comments/documentation.
I actually was doing the 6.009 but I'm not super familiar with objects so I decided to start this one instead. So far, I haven't ran into anything I'm not already very familiar with yet in the first few lectures as a self-taught beginner so it's aimed at people with no experience. 
I hate docstrings for that. I see type annotations as similar to the information I would have put in docstrings a few years ago, except with automated tooling to verify that they're current every time I send a pull request to CI/CD.
I don't believe an array can be casted to a scalar, that's why I asked.
It's impossible in C, in C++ maybe since there is string type but that compiler must but exclusive.
I agree, this does not seem possible.
pip install youtube-dl
You can cast the pointer the string to an integer¹, but that's related to where in memory the string is stored. Converting the content of the string to a scalar value requires code written to do that. 1. Which is the reason weird looking hacks like `2["abcd"]` have a specified meaning in C. 
I built a small embedded tool using this one. Was not as easy as my C# version I feel.
Data driven application, database first class member. Our tests go full round trip into real database, not a mock db like SQLLite instead of postgresql. Tons of tests make dummy db data then must be sure to clean out the crap for the next test to go along. Efficiently testing through to the database is a software engineering discipline ripe for creativity and research improvement IMO. When we'd have new 'pure python' modules, just doing stuff w/o the database, good lord those were relatively fun test suites to both write as well as to keep up-to-date. Would run *so* fast comparatively.
I often mix in some cython compiled modules in my Python programs, and find that it works pretty great for the most part. Although it does take time to invest to find out the CPU bound ops then group them by complexity and do a 80/20 kinda thing to come up with a list of things that can probably help with cython compiling. If python is slow, your probably using it incorrectly or it's the wrong language you need for your implementation. I have yet to mix in Rust with Python, although rust seems harder to learn vs C. &amp;#x200B;
Oh you'd be surprised, my college posted up some knowledge base articles that were gone in a week for no apparent reason. 
idk how to use this information, but it looks important lol. Likely something I may learn in the video! 
It's been up for more than 10 years
Just because it’s compiled to byte code first doesn’t make it a compiled language. If you don’t see the difference between compiling a C program into a binary executable and running a python source file through a python interpreter, you have your head buried in the sand.
The only time MIT seems to remove theirs is when they do so with updated curriculum (I've been watching their classes for years).
Yeah it is. A lot of people in different majors take it as well as a lot of freshmen interested in CS, but with little experience. Good luck with your studies? 
&gt; and if you have even moderate test coverage Well okay, but what if you live in the real world. :) Yes everyone should have better test coverage, but often they don't. That is just the reality, and many people have to deal with larger projects that just don't have the test coverage.
Holy shit. Saved. Thank you so much!!!
https://ocw.mit.edu/index.htm
I use tqdm all the time! It's a great module!
username checks out
Reddit cliche noticed- username checks out Phrase noticed- 246 times.
Open courseware started online open source courses more than 10 years ago. https://ocw.mit.edu/index.htm It's not going anywhere.
Yep 
Just curious, what does that hack do?
I improved the execution time of Java code from minutes to seconds just by changing data structures or using some short-circuiting on more than one occasion. The one that stood out most was when I had a method that accepted a list and when I was first writing it I was like 'list is list, what could go wrong?'. Later I added a line to copy the list's content to an ArrayList if it wasn't implementing RandomAccess already. Minutes to seconds with one line of trivial code. 
The channel is MIT OpenCourseWare. It's an official channel for a program that they've had for a very long time. There's no piracy involved here. https://www.youtube.com/mitocw https://ocw.mit.edu/ 
Again, &gt; Just type is usually not enough to describe a parameter anyway. If you think just parameter name and type is always enough to describe it, I hope we won't have to work together.
[Lecture 9](https://youtu.be/C_pgH5QhIZ8?t=95) - getters and setters. I guess it's good to do without using properties... they can get into pythonic code later.
&gt; (although maybe that is what you mean when you say 'using types'?) Well, since he used type hints in his example, I think it's a pretty safe bet that's what he meant.
isn't cybersecurity best learned using C? 
Maybe I buried my head, but that's sure my personal preference. You can compile Python (py_compile), but that's often done for performance, not for syntax checking. Also, just to clarify things up a bit, a language cannot have the property of compiled or interpreted, but the implementation can. 
Are you _literally_ entering the dollar sign? It’s meant to represent the command line prompt, it’s not an actual command. So, you should enter everything without the `$`. 
good bot
Thank you, McSinyx, for voting on clichebot9000. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://botrank.pastimes.eu/). *** ^(Even if I don't reply to your comment, I'm still listening for votes. Check the webpage to see if your vote registered!)
It's equivalent to `"abcd"[2]`, which because C arrays are 0-indexed, is 'c'. When an array index notation is used, the address of the member is calculated by adding the index to the array address. The way the standard specifies this, makes the reversed form valid. Nobody use it in practice, as it makes the code messy to look at and harder to read. 
Can you post that link as well? I'm having trouble finding it in the playlists of the channel. Thanks again.
Thanks for the response. Yes that's what I'm doing, but if I remove the `$` then it just gives me [another error](https://i.gyazo.com/07b7bfe20a95d6c4ba7114d5649ce43d.png).
&gt; 6.009 Do you have a link to the 6.009 videos? I failed at youtube search.
If I were you, I wouldn’t mess with `pipenv` and just do `pip install requests` (if you’re using Python 3, you may need to run `pip3` instead of `pip`). 
Is the content relevant with Python 3 out?
If you know C, of course Rust is harder. Rust makes you think a little more. It is harder to get Rust to compile, because Rust requires you to write code that is correct and doesn't expose memory leaks and other issues. However, once it compiles, it usually does exactly what you want. Immutable by default is a good way of writing code. I find trtying to think this way in Python improves code quality.
Entering that command on its own gave me the same error. I tried entering `py` beforehand so that it knew I was dealing with Python, but that just gives me a [different](https://i.gyazo.com/70c346aff4e9c013b9e1eb1b71d12620.png) error (even if I do `pip3`).
good bot
The course content is from 2016. The channel is from 2005. The MIT OpenCourseWare program is from 2001.
&gt; If you think just parameter name and type is always enough to describe it, I don't, but a docstring is absolutely _not_ the right place to describe the type. It's not readily verifiable. &gt; I hope we won't have to work together. Seems unlikely.
No, now you’re entering this in the Python interpreter, which won’t work because the command is not Python code, it’s for your shell. Try adding `.exe` to `pip[3]`. Make sure you aren’t running any of this from the interpreter itself. 
...Your back end usually spits out what we like to call HTML, CSS, &amp; Javascript. All this, browsers handle well. There is some other stuff; but the core are HTML, CSS, &amp; JS. If you have a browser that consume other things-- then, yes, go right on ahead with those specific other things. But, for the most part, no. Stick to HTML, CSS, and JS. For bonus heads shaking, you can use your back end languages to mangle your HTML, CSS, &amp; Javascript. I recently used PHP to output a comma separated list of text into a page scope level Javascript sript. I needed an array of data-- and the PHP fills the members in. The browser never knew it was dynamic-- it just treated the injected data as if it had always been there. Because from the perspective of the browser, it had always been there. Indistinguishable from the static stuff as far as the browser knew.
Could you share a link for the 6.009 as well? I can't find it on ocw.mit.edu or their playlists on youtube. Thanks! 
Running on the W10 command line. Neither `pip.exe install requests` nor `pip3.exe install requests` return anything other than that "not recognized" error.
Time to [install `pip`](https://packaging.python.org/tutorials/installing-packages/#id13), then!
How about you stop spamming this all over reddit? Thanks.
https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/lecture-videos/
https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/lecture-videos/
I thought it came with Python 3.7 though? If I look in my Python installer it has the box for pip [checked already](https://i.gyazo.com/383f76af97d8d1e6e5cd97c9a5316084.png).
I was disappointed with 6.0002. It really morphed into a stats/probability course that used python instead of matlab.
Yeah, it should definitely come with Python 3.7! Did you _run_ the installer with this box checked? If so, you can try restarting the terminal (kill `cmd.exe` and start it again). This may not help, though.
Ha, I started that very bluntly, and I ought to have said that I completely agree and that you'd made a technical oversight. I didn't realize I was making a supporting argument.
&gt; Perl: '1' + 1 == 2 This is not inherently wrong, as Perl has no `int` type, so internally there's very little difference between `1` and `"1"`. Also - with the exception of an object which might overload `+` - operators like `+`, and `==`, etc. always do *numeric* addition and equality testing. The `+` operator is never used to concatenate strings or lists; To check string equality you use `eq`. This means more often than not, when I see `$x + $y` in Perl code, I know it's doing a numeric operation, whereas in Python, I have to know what the types are to determine what's actually happening.
Worth checking out. I did it the last time it was posted (somewhere) here. 
Another example of the advs of static types: I'm learning Cryptography using Python. When dealing with decrypting charcter message, I run into all sorts of problems with "meta" types: Eg a Python string might represent a unicode char, a unicode set of chars, a hex val with a x0 prefix, a hex val without a x0 prefix, a hex str with slashes between each char etc. The various functions and operators that work on these will expect one type, and give unhelpful error messages, or perform incorrect computations if you provide the wrong type.
Yeah, I installed it and have been running IDLE with the current settings for a little while. I have no idea why it thinks pip is not installed. Restarting the terminal doesn't seem to do anything, unfortunately.
Does running `python -m pip install requests` work?
It says that `python` is not a recognized command.
I mean that’s not bad definition of basic data science lol
WTF. How do you invoke Python? With `py` or something, right? Try running `py -m pip &lt;stuff from my previous comment&gt;` 
Yeah your definitely right, most of my errors in my earlier years revolved around pointers and memory leaks d/t either using wrong types or accidentally losing a pointer somewhere in a deeply nested set of loops. &amp;#x200B; With that said, the whole immutability by default nature of Rust is what trips me up the most lol, its such a different way of thinking.
So is 6.009 part of 6.0002? I haven't watched the videos, of course, but in the syllabus of 6.0002, it doesn't mention object oriented programming; which is what you mentioned above. 
Ahh! Yes, `py -m pip install requests` works! Thank you so much, you've been very helpful. I'll let you know if I have any other questions.
You’re welcome!
i just expected equal emphasis on computer science as well as data science, given that is an extension to computer science. 
Databases make testing more complex, yes, but why do so many of your modules directly depend on a real database? Usually you have some variant of MVC running where at least the low level DB access is hidden. That way you don't mock the DB, but you can simply create entity-objects. That doesn't eliminate integration tests, but can reduce their size (and from experience: cleaning a test environment is a recipe for disaster, there's so much that can go wrong during setup and cleanup that you spend a significant time on chasing bugs or quirks of the testbed).
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Why what.
If you'd like to take the course on edX, it starts in about a month. Here's the link: [https://www.edx.org/course/introduction-to-computer-science-and-programming-using-python-0](https://www.edx.org/course/introduction-to-computer-science-and-programming-using-python-0) &amp;#x200B; \-Josh from edX
Sure, until you inherit contractor written code. Hope you like single letter arguments! ;)
Activate your anaconda environment with the desired interpreter and run the ‘jupyter notebook’ command from your shell.
Thanks, Reahl and RemiGUI look promising. I'll have to choose one to start.
As someone who just begun his journey learning python, do you guys recommend me watching this course to get the basics? Or is it an intermediate course?
It should be pointed out that his is more geared to learning the basics of Computer Science over learning Python. In fact they state that you should already have a basic understanding of the Python language to begin the course. Don't get me wrong it's a great course, but want to give a heads up to anyone looking for something specific to learning the Python language. 
Thank you so much
You've been told by the bot before that these kinds of questions belong in /r/learnpython and it looks like you have a valid answer over there as well. 
I think if you read the first few chapters of Automate the boring stuff, you'll be solid.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, this post has been removed as it is not directly related to the Python programming language. It might be more topical on /r/programming, /r/coding, or /r/technology. Cheers, /r/Python mods
&gt; Here,your problems solved. But here you're nullifying two of python's best features - object orientation (you're checking type exactly rather than `isinstance`), and duck typing (where any iterable can be treated as an iterable - sets, iterators, dict keys).
How about the Udemy course on it?
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
I've done this on edx. I highly recommend this! CS50 is also great if you want to get started but with wider syllabus and C.
The udemy course is basically just supplemental videos. I think he goes over the basic concepts of python and programming and general, which I think is assumed that you at least know what stuff like variables are and understand the concept boolean logic and what not.
Why will it be removed lmao
So definitely start with the book instead of the videos?
Doesn't really matter, it's the same stuff. It's like a class where the teacher actually follows the textbook pretty closely, so you could do both, or one or the other and you'll cover everything. For me, ATBS was the one thing that finally got me over the hump that made me dive into actually learning programming, I farted around with codeacademy/khan and what not before and never got anywhere because it was too abstract, plus you're doing it on an abstract box in your browser, rather in an actual IDE. I hope it's the same way for you too. 
My school removed free classes and articles that were online and set then as temporary learning objectives...I didn't realize MIT wasn't a bunch of assholes like my school lol
The context of the person they replied to is ambiguous, so I'm not entirely sure. And this doesn't make much sense if that is what they meant: &gt; in the second you know exactly what's available and what you can do. Because that is entirely false. The type hint is just that, a hint. You exactly the same of what is actually available and what you can do, with or without the hint.
Heh. Fair point.
Thank you!
Type information is certainly useful for the IDE, true. That in particular has just never even been remotely enough of a factor for me to decide what language I am using for a given project.
&gt;You should mention the zope.interface in fact. YUP
I use python daily at work, but picked it up without much focusing greatly on the basics (my fault) so I have clear gaps. Looking forward to watching a few of these lectures and reviewing notes. Maybe an assignment or two if I'm feeling especially enthusiastic this holiday season.
Yeah, but have you ever been in that situation in a large Python project and honestly thought, "goddamn, if only we were using a statically-typed language we wouldn't be in this mess and everything would be fine!" I usually find using dynamic vs static typing, or vice versa, to be neither the symptom nor the cure to the situation you describe.
Reahl is complete and self-contained. I use it for my work project. A bit different but supportive authors. Remi has at least one Python framework built on it - https://mryslab.github.io/python_banyan/
Yeah I would have like to see an optimized version vs C. Who knows how poorly written the perl was. For all we know it went from single to multithreaded. 
You can't post this here man, they'll be all over you. They want you to post it to /r/learningpython. Sorry /u/StreetStatistician! :(
&gt; I vaguely recall that map is considered un-pythonic. Only by people who consider `map` to be unpythonic. The rest of us think its fine.
That sounds very valuable. I agree what prevents the infection from spreading is good and very valuable for server applications. And I'm coming into this conversation sideways. But in any case it would be a good idea to get a handle on goals. Let's look at what asynchronous I/O was originally before JavaScript: it was largely actually asyncronous I/O only. Calls to I/O could be synchronous or asyncronous. A call to wait would not affect a synchronous I/O, but wait would only affect the call to I/O meaning I could do: call IO 1 call IO 2 call IO 3 And then wait or wait 1,2,3 Or call input buffer 1 and wait call input buffer 2 but don't wait Start processing buffer 1 And voila - we have asynchronous I/O. Granted that there are other goals in life like conserving memory - like using iterables in series instead of clogging up memory huge unnecessary arrays which we get out of generator functions. Ok. Of course then having this asynchronous function or event loop idea extend generators sounds nice. But is it? Well 'No,' And 'Yes.' No is this: It was never really necessary. In the tradtional sense I/O used to be "slow" and a processor is "fast" and that's still largely true (despite language interpretation speed, and despite that a physics/math/data science applications are compute intensive). But for the general application doing I/O took up most of the time. So if you could overlap I/O it would create real savings in response time. It was only necessary to overlap IO and not processing. Now we come to: Yes: a) Today SSD is much faster than disk used to be. Networks are faster than they used to be. But b) numerous objects can be sent over the network at the same time. And while still moving data in and out main memory processors through the I/O pipe is going to be slower than processing in memory. However, c) now we've got 8 processors or 12 or 16 or 32. Or more. As we approach the Quantum computer we get more and more processors. Aside and not directly related: we have frameworks to handle these like Dask and Spark and PyWren and "serverless" functions. But the intention is similar: we clearly want to overlap processing on one processor with I/O and with processing on some other processor. In this case, the async function might hand off control to another processor. But even so, the idea of a function or callback or an event loop is a concept and a kind of primative one. It isn't an operating system or hardware or a multi-core framework. And callbacks done in a browser for one client are likely to be logically different from I/O done to a database by a server app. So JavaScript was not necessarily a model for this. "Event loop" is a maleable concept and doesn't it seem like a weak idea thing to base a huge queue of dependencies on? At least in comparison how an operating system can "move data into memory/move data out." What utility is created by it between the application and the outside world by having an asynchronous function with an event loop that doesn't even take advantage of the OS itself? In a browser, there is no OS. In browser-based JavaScript where this idea started - JavaScript is constantly running callbacks, and waiting for their completion which is why it needs an event loop. But in the rest of the world, outside a browser, applications programs run on an operating system which has its own cycles. What does "event loop aware" mean to a Web application running on Linux, or a structural engineering calculation program, for instance? If I say "start an I/O start another one, and then wait" it's pretty clear. If I say "start a function that can run asynchronously and be 'event loop aware'" what does that mean? A program running in a server generally isn't doing that. I know I'm going to have to read more and I'm coming into a conversation in the middle I need to know what the intention is? Is it to make Python run in the browser with callbacks? Or to turn server applications into something like what a browser app does. I would think if it is just to make Python be able to start asynchronous I/O, get control back, start another one, and then eventually wait - then existing "async I/O" does that kind of thing. &lt;/rant&gt; 
&gt; I use classes and methods when I find myself passing around data structures to different functions. I tolerate a little bit of that but at some point it bothers me and I create a class and let 'self' hold the structures instead. Ah, so you believe that "implicit is better than explicit"? # explicit function(something, datastructure, extra args) # implicit something.method(extra args) # Where the hell is the data structure? Nice! I'll remember that trick next time I want to make my code harder to follow. [*ha ha only serious*](http://catb.org/jargon/html/H/ha-ha-only-serious.html) [Stop writing classes](https://www.youtube.com/watch?v=o9pEzgHorH0). For an opposite view, [write moar classes](http://lucumr.pocoo.org/2013/2/13/moar-classes/). 
&gt; I use classes and methods when I find myself passing around data structures to different functions. I tolerate a little bit of that but at some point it bothers me and I create a class and let 'self' hold the structures instead. Ah, so you believe that "implicit is better than explicit"? # explicit function(something, datastructure, extra args) # implicit something.method(extra args) # Where the hell is the data structure? Nice! I'll remember that trick next time I want to make my code harder to follow. [*ha ha only serious*](http://catb.org/jargon/html/H/ha-ha-only-serious.html) [Stop writing classes](https://www.youtube.com/watch?v=o9pEzgHorH0). For an opposite view, [write moar classes](http://lucumr.pocoo.org/2013/2/13/moar-classes/). 
Trey, this is a great article. I'm a huge fan of pathlib. 
&gt; If a function is a pain in the ass to unit test, it’s probably doing too much. That's probably the single most sensible thing written in this entire thread. And documentation: if its hard to document, it is probably doing too much. 
Practically this can happen often than you think. You could be working on a different branch and merge can be done some other person. 
This [book](https://www.amazon.ca/Introduction-Computation-Programming-Using-Python/dp/0262529629/ref=sr_1_1?ie=UTF8&amp;qid=1545349951&amp;sr=8-1&amp;keywords=introduction+to+computation+and+programming+using+python) is awesome.
I prefer `TEMPLATES_DIR = BASE_DIR / 'templates'
PySimpleGUI?
MIT has been doing free videos for a long ass time. 
IDK about it
Perl: '0' / 0 = 0 
Scheme RIP
Look into requests-html or Selenium.
I'm [already doing this](https://imgur.com/a/XRNPGnf), the question is about adding PY2 kernel 
Perl will die on both of those expressions with `Illegal division by zero`.
&gt;https://www.edx.org/course/introduction-to-computer-science-and-programming-using-python-0 Josh, (genuinely asking) what would be the benefit of waiting 33 days to "take the course" on edX, versus getting started right now on [ocw.mit.edu](https://ocw.mit.edu)?
My bad everyone! Lol i was shot coming out of classes didnt mean to b mad ignorant
So long as you use [the `python_requires` metadata](https://packaging.python.org/guides/distributing-packages-using-setuptools/#python-requires), and document it in your changelog, you should be fine with a minor or even patch version bump. The paranoid could also [copy Django's manual checks](https://github.com/django/django/blob/78dc7039bc763573973475f1b9dee15afe1c470f/setup.py#L7-L33) that the Python version is OK.
I'm looking into request-html but Selenium is a program and I kind of want to make the program myself as a part of my discovery to get more into programming \^\^" But thanks :3
The objects that you cal `.pack()` have all the information they need to pack themselves since they stash away a reference to the container they are passed as an argument in their constructor, and they inherit that logic from the TK widget base class. This is a common pattern in OO frameworks.
the request-html still only parses the html from the website itself. Not the html which I would get if I would open it in chrome while being logged in on that site :/
Made yesterday when I came to conclusion I don't like live editor =) Uses bottlepy, jinja, markdown and docutils
[Cython](https://cython.org) is also fantastic! You can compile any code that runs under CPython (to C or C++ linking against the Python runtime), and also annotate critical parts so it can compile to more efficient native machine code without the Python VM.
#### TL;DR : &amp;#x200B; #### Security Summary * Support for two-factor authentication via [TOTP](https://tools.ietf.org/html/rfc6238) and [U2F/FIDO](https://fidoalliance.org/specifications/overview/). * Application specific tokens scoped to individual users/projects (this will also cover adding token based login support to twine and setuptools) * Advanced audit trail of user actions beyond the current journal (allowing publishers to track all actions taken by third party services on their behalf). #### Accessibility Summary Accessibility audit and follow-on accessibility repair work, implementing localization and internationalization features for views, creating tooling to support translators, and integrating translations into PyPI.
&gt;They just aren't compiled or interpreted. In all practical applications, they are.
Do r.html.render() to get a full version of the page.
There is [turtle graphics](https://docs.python.org/3.3/library/turtle.html?highlight=turtle) in the standard library.
It is an example of poor naming only because I didn't want to add an extra comment for the reader. The actual example is as you wrote, except in the first case `api_request` is some opaque object that can have whatever shape, whereas in the second it's a well-defined `APIRequest` class instance, which you can just look at and know exactly what's going on.
What do you mean by the horror?
The clarity comes half from the types and half from being disciplined about your data and creating structured classes that hold your data instead of passing amorphous dictionaries around, basically.
I've taken some edX courses and found them very worthwhile. Without looking at the MIT site (I will later, but I'm on mobile now), I would say a benefit would be a broader array of offerings from not just MIT, but Microsoft, Colombia Univ, etc. Microsoft had a data science cert program that was good and got you experience with Python or R, SQL Server, machine learning with Azure, data analytics using Excel, and so on. 
Really disappointed with edx making graded exercise a paid service. Someone needs to look at this policy.
I’m sorry, wasn’t sure what’s the right place for python devs who use it for web development. 
Nice article. Convinced me to finally take a look at pathlib.
Almost like that language was built in two weeks or something
I would run far away from any company that has a recruiter saying such absolute nonsense.
That's their current Edx.org 6002
A better explanation: All assignments (a=b) in Python are done by reference, and all of the labels (a, b) you write in your code are references. So in Python, all assignments work because all "types" in play are just memory references. All other operations pull the value and type data out of memory and that's where you'll get TypeErrors.
I struggled with Pip as well. I eventually found and successfully used: py -m pip install LibraryName. Perhaps give that a try. 🀄️
Many people have opinions and many people with an opinion know they're right without actually checking.
To counterbalance the discussion, virtually all projects that start in Python launch in far less time than projects that start in compiled languages, and there is an estimate that a programmer can be 5-10 times more productive in Python, which to me is sort of the reason why Python is such a force in the current ecosystem. Java, for instance, requires you to memorize a relatively long list of computer science concepts, development rules, and architecture concepts, starting with Public vs. Private. In Python, using functions, decorators, and classes, it's very difficult to make a crippling misstep that will take hours to debug. In Java it's virtually impossible to avoid these missteps without 2-5 years experience. In addition, if you want to write a function that takes a string, int, or generic object, you would have to spend some time figuring out how to handle that to avoid a compiler error in static languages. In Python, you just write the code and it works. It turns out a lot of what programmers do is moving objects and data around, mapping functions to data in an abstract way, etc. Being able to freely do that is incredibly valuable in terms of programmer time. Python's only weakness is that it tends to hide type-based errors until the value is pulled out of memory. The larger the application, the more times a variable can be passed around without any amount of checking. Imagine having to roll back your stack trace through 50 layers of functions to find the root of the error or having a value make it through a network call or into the database as a completely wrong type. It can be maddening. However, this is somewhat rare and is usually the result of poor documentation, poor compartmentalization, and a lack of test suites. Even with the added burden of having to test all the things, it's likely that Python is at least 50% faster to make relatively large apps and no worse on extremely large codebases. MyPy provides amazing functionality and will resolve most of these kinds of issues while allowing you to continue coding without typing handcuffs.
Well written I'd say. Given the number and quality of large scale Python projects I'd say those armchair language critics are now on the losing side of the argument. Some people don't know about things like Numba and Cython for speed, or Pylint for static analysis and MyPy for static type checking. Also, I wrote a dynamic type checker for DataClasses. 
Have you seen the Docs.? Take a look at https://www.pygame.org/tags/all 
He states: "Where I see DI fit best, are projects with established requirements, serving a large number of stakeholders. The challenge here is to scale and constantly improve the system, without compromising its stability" Either you have adequate requirements or not. Code to those requirements, remember YAGNI! You waste effort trying to code for that unforeseen future; You waste time turning every program into a "framework". I find requirements firm up as you deliver on some of those requirements: requirements are like battle plans - they don't survive (partial) implementation, but you need to make (and remake), them. 
So you created a Python 2.7 environment and started Jupyter from that and it still shows you a Python 3 Kernel in Jupyter?
At least a Core 2 Duo with 2gb of ram. 
If it has a screen and a keyboard and a power supply it will likely run Linux and from there you can do almost any programming language. Not sure of the Microsoft # derivations 
Late response but maybe split after the "." and read each line? put a sleep timer in between of like 0.05
Other important python skills for data science : java ruby Italian 
I use PyCharm for multi file projects. Small stuff, Spyder has been my solid go-to for a couple years now. 
I would suggest a Dell Rugged 12 or similar. As pythons, anacondas and ... well, all snakes and some lizards, gave up their legs millions of years ago, I expect the device will be subjected to significant drops, tumbles and even spills. And the oversized carry handle, touch pad, touch screen, and disabled user assistance should all prove helpful to any reptilian developers. Good luck!
They don't exist yet, is my understanding. 6.009 is a newer course and some of the instructors don't feel comfortable being recorded yet e.g.: my advisor says he's still mastering how to teach the material. Also labs are re-used so the class can't be fully turned into open courseware yet. /u/Not_Sherlock tagging because they also asked about 6.009
EdX guides you like you're almost taking the course at MIT. It provides a schedule, discussion forums, etc - the experience is pretty similar. I have taken MIT classes that run parallel EdX offerings (Visualizing Japan (1850s-1930s): Westernization, Protest, Modernity) where we followed along with the other couple hundred people taking the class online. They got the same quality of education minus the in-class discussion, and that was pretty surreal/cool. OCW is almost completely self-directed, self-motivated learning. It's for two different kinds of autodidact. EdX has a lower activation energy IMO.
whatever you are used to, i personally use vim for any and all things, people love pycharm i have noticed. At the end of the day what person X uses and why is gonna be different from what you use and why. Thats a long way to go about saying use what you are comfortable with, even if its dictation on your cell phone pushed to google docs slurped into gitlab -- as long as it works for you. 
If you inherit code written by contractors with single letter arguments, type-checking is probably the least of your problems: totally incorrect business rules, vulnerabilities like sql-injection, leaky and incorrect abstractions, etc, etc, etc.
Who will grade the exercises if you aren't paying though? I'm not saying I agree. Just confused as to how you expect them to pay people to grade the exercises.
Automate the boring stuff actually handles situations you might encounter in real life. I've found most of the edX courses to be really disappointing because they are so highly focused on mathematics. While it's important to have a good understanding of algorithms and so forth your time is much better spent learning how to use Django or some other framework and a profiler to see where you can make gains in your code.
Well yea. My point was just that naming things nicely doesn't save the day if you inherit shit code. 
Any chance you have a coupon code for the verified track? Planning on taking it!
Raspberry pi. Dirt cheap, small, and fun to tinker with. Get one with a preloaded sd card running raspbian, and python is already part of the OS software suite.
Any time there’s user interaction, speed is the most important feature, full stop. Whether it’s spec’d or not. We owe it to users to not waste their time. But that is only a small part of the application space. Huge amounts of processing can be delayed or deferred and should be. In those cases, yes, push back on speed. It’s usually some sales jerkweed or product manager jerkweed (same thing, essentially) promising the client real time streaming for big date insights and instant decision analysis or some other hogwash. And you can do the job overall much faster and better and cleaner if there’s some wiggle room there. Also, thanks for the upvote, stranger. The sweaty bits are just how I roll. I guess I’m getting salty in my old age. 
You could get the binary data. Translate that into characters.
This is better suited for r/learnpython and I think this would usually called speech recognition. 
To check that it's not in a list of extensions you can use this type of check: item.split('.')[-1] not in set(extensions_list) Membership in set is likely going to be faster than membership in a list, but the split method might end up being a bit costly
Literally anything. Right now at work I'm using an old phenom ii X2 I think it is, 8 gig of ram. Throw in a solid state drive and you'll be good to go. You may want to consider future plans, though. If our get into virtualization, big data, anything that takes lots of resources, you may want to consider this and purchase accordingly. Or, like was mentioned, a pi will get you up and running with python 
atom, spyder, vim
I have heard that a lot of people in the long run use macs, is a mac worth it for that price?
&gt;I'm only really sorting at most 5 files at a time fortunately, so this script is okay to be a bit messy haha. I've only really been experimenting with python for a few weeks now, so forgive me for asking but I tried using that and it didn't seem to do much. I'm assuming I've messed up somewhere in syntax, but no errors were given either. &gt; &gt;I'm doing this in a for loop that is checking items in a folder.
In couple of courses I've joined they were automatically graded by a software. 
I like using Sublime text with a terminal 
No. Use Linux.
Wait they're charging for automated grading now??
I'm not entirely sure that's the way I understood. However (hopefully) I might be wrong. 
You don't need to. What you do get with a mac is a machine in a nice package with a nice unix environment. But, things are obviously quite different. I'd say if you really want to spend the money, then it can be nice to have, but you'd also do well with a Linux dual boot
I flipped between this course and SoloLearn's free python course when this course got too over my head. It is more of a general computer science course that uses python to teach principles of computer science, but it was really interesting and challenging for me. 
The code assumes that the item string uses a period to separate the file extension from the rest of the string. The code doesn't do much, it's just to check if "it ends with anything other than extensions in a list", so you'll need an if statement to actually execute what you want. Here's an example from an interpreter to show what everything does. &gt;&gt;&gt; item = "filename.txt" &gt;&gt;&gt; item.split('.') ['filename', 'txt'] &gt;&gt;&gt; item.split('.')[-1] 'txt' &gt;&gt;&gt; item.split('.')[-1] not in set(['tar', 'pdf', 'log']) True &gt;&gt;&gt; if item.split('.')[-1] not in set(['tar', 'pdf', 'log']): print "do something here" do something here Good luck with the script!
Bokeh is as close as we get to D3.
Cool to see how it's done. I learned something. Having said that oh how I would hate to join a project that used this. If I assign a convoluted variable that I subsequently return it's for readability, because I've just wrapped some hideous API in a function and the API call doesn't describe what's returned. And why allow unpacking? If the assignment is bad, why not demand a slice or index to be returned. But as you said it's about individual pet peeves so what I meant to say was thanks for sharing.
6.0001/0002 = 3.00005
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Harvard's CS50 is also available for free on YouTube, with prof. David J. Malan.
No it’s a different class that students take after 6.00 (6.0001 and 6.0002) 
Yeah, the lectures are not recorded but you can find the assignments and materials here. https://6009.cat-soop.org/fall18/information I thought they would have uploaded lectures at some point through the course but no. 
The reason this is timed is because it is being hosted with the actual course being taught at MIT. 
The class is notorious for attendance issues. Uploading videos even privately might drop attendance further. Also, the actual class content has changed slightly every semester since 2015/6 when it was an experimental class. They're trying to converge on an optimal solution to two problems atm: attendance and content.
I checked BOKEH sounds promising.
&gt; started Jupyter from that if "that" means py3 env, then ans: correct sorry but what is it about my post that's not clear ? I provides paste and screenshot. 
I'm not quite sure what the problem with that is. Are you using a lot of nested functions? A good IDE will pick up a function local shadowing a name in the outer scope already.
I think the uptake of docker and k8s is a scourge, and that it creates more problems than it solves.
&gt; ~1900 modules, Jesus what is it, Youtube ?
If you use use strict.
I confirmed it dies in v5.8 without use strict... But besides, who doesn't use strict.
how ?
file NAME
I confirmed it dies in v5.8 without `use strict`... But besides, who doesn't `use strict`?
I agree! I love the \`/\` operator on \`pathlib.Path\` objects. I purposely didn't use it in that first example because I've found it sometimes scares people (and \`joinpath\` is sometimes easier for people to wrap their heads around at first).
Thanks Nina! 😊
Thanks! I'm glad you'll be giving it a look. I wished I'd given it a serious look earlier.
a Rpi 3+ is good enough
Attendance for 009 isn’t required though 
&gt; who doesn't use strict? We didn't. The code didn't run. I tried.
This is really more of a question for /r/zsh but the output from which tell you that pyenv is functions. Helpful as it is, it spit out the entire function definition.
Automation !.
Thanks for answer :) &amp;#x200B; But, I think this problem isn't related zsh, maybe **direnv**. Same symptom occurred at **rbenv**.
:) thanks!
I'm afraid that this feature is coming too late to be widely adopted. I would have loved it to be part of the language design from the beginning, and that or convenience we could create path objects with a string-prefix like `p"/usr/local/path"`. But because path objects was not part of the language design, and because path objects don't inherit from `str`, we have to accept both `str` and `Path` while creating API, and we have to ensure that function accept `Path` objects while using API... For those who don't know, there is also the [`path.py`](https://github.com/jaraco/path.py) library which existed prior to `pathlib`.
Awesome - thanks for sharing :)
&gt; Different operators that do different operations is one of the things I really appreciate in Perl. I couldn't tell you how often I forgot a $ or a @ sign in my Perl days. I was so glad to leave that behind.
I was actually playing around with spotipy yesterday, good idea man, i might even set it up so i can just click my echo-dash button and it'll add it. I REALLY wish spotipy would be updated though, but the owner seems to have disappeared, and no idea which is the best new version.
&gt; R&amp;D folks on the other hand can be easily tripped by the simplicity of pip install whatever. Yeah, it works the first time, but it opens a can of worms they will not know how to close. What can of worms? You have a list of exactly what's installed. If you're environment is messed up, just delete it and start over. That or learn how to fix it.
yes, and mechanisms to work around static typing so that the code can do what a dynamic language does with 2 lines of code make the large codebase even larger. 
In true modern MIT style, the class is breadth over depth, which is great if you want a map of the territory, but not so great if you want to know anything to a decent level of detail. The class will definitely have to be supplemented with real world projects or adjacent classes to get the most benefit out of it.
I miss the SICP MIT days. MIT's old CS101 class was magical in how great it was. Today's MIT intro to CS class in Python feels more like a road map than a thought process. It tells you to figure it out how to think, instead of teaching to you. This loses the charm and the love I once had for MIT. These modern classes do not hold a candle to what was.
r/programmerhumor
I thought os.path had an extension call? I could be wrong. Or was it pathlib with stem.
The only thing I don't like about pathlib is that it's not universally used. I still find myself casting to string when passing a path as an argument. 
Don’t spend thousands of $$$$ on a prettied Linux.
Thanks! 
please move this to /r/learnpython, /r/python is for python news, not help requests. Thanks
&gt; for something that shouldn't even be occupying 2% of your time in a codebase with any sort of decent testing at all. And how much of the codebase and time will be used to get this "decent testing"? With static typing you'll get a lot if that for a lot smaller cost.
The `endswith` method accepts either a single string suffix to check, or a tuple of them. So this is legal: ALLOWED_EXTENSIONS = ('.png', 'gif', 'jpg') if not filename.endswith(ALLOWED_EXTENSIONS): print("Wasn't a PNG, GIF or JPEG") However, if you're working with file paths you probably instead want to use [os.path.splitext](https://docs.python.org/3/library/os.path.html#os.path.splitext) to determine the extension, like so: import os.path extension = os.path.splitext(file_path)[1] if extension not in ALLOWED_EXTENSIONS: print("Not one of the allowed file extensions") 
Since you are writing a file organizer I would highly recommend you take a look at pathlib module which is in standard python. It will offer you support for all systems (posix or not) and has some very nice features. For your question if you had the path of a file, you could have: ``` &gt;&gt;&gt; print(filepath) /home/file.tgz &gt;&gt;&gt; print(filepath.name) file.tgz &gt;&gt;&gt; print(filepath.suffix) tgz &gt;&gt;&gt; filepath.suffix in set(supported_archive_extensions) True ``` 
&gt; This is not inherently wrong, This is inherently wrong because it works against user expectations. Sure, once you'll learn interpreter internals you'll change your expectations, but its not the way it should be.
Using `endswith` if the input is just the filename, or `os.path.splitext` if it's a full path, would be the idiomatic approach here. Worrying about "which is faster" over "which is more clear' is a bad idea. Though for what it's worth, `startswith` and `endswith` get to do C-level optimizations that your string-splitting approach can't use.
&gt; Compare def parse_data(some_opaque_dict) with def parse_data(r: APIRequest) Or compare parse_data(r: ApiRequest) with parse_date(r: JsonObject) Being statically typed and sane are two different things.
Create a py2 conda environment and make that primary....then fire up jupyter
Hey OP, does this teach Python too? Or does it use Python?
[Like this ](https://i.redd.it/f60emy6qq2521.jpg)
Yep, totally agree - spotipy works great until you need that one little kwarg from last two commits, meh. Last release from 2017 is quite sad to be honest - however pip install from repo url is good hack tho
&gt; Any time there’s user interaction, speed is the most important feature, full stop. The quest for absolute speed is far too simplistic. One needs to think of context: If a simulation takes three days, then waiting an extra fifteen minutes for better stats, or 1 minute can often be ignored if those stats are generated without extra user interaction from the user. Those three days for the overall task predominates. Context: if one is replacing a method that takes much longer in existing methods, then the user can take the overall value pakage if the new code takes five minutes and users feel it is genuinely useful, then they adopt it with open arms, should one then blidly try and get it speeded up to work in under a minute? a few seconds? o is ones time better expended on some other problem. One needs adequate speed, there is no absolute speed those that persue that end up stopping at some random speed anyway, and may have lost sight of the "big picture" in the process. Everyone doesn't program GPU's or FPGA's, or parallel program, for most problems. Speed has cost - weigh cost against gain.
Thats really cool idea! Probably gonna need raspberry pi for that. Whole linux board for just one button seems like an overkill but I desperately like the idea
Another option is to put a comment: # Return the blah of the blah, so that blah blah return 5*foo(x) Assigning a variable and then immediately returning it might be shoehorning a comment into a variable name.
This is just an example, if I was wanting to make a truly good function I wouldn't write it like that. I made this in 15 seconds, if I wanted to show off the best features, I would, but this code isn't meant for that.
&gt; You have a list of exactly what's installed. And how do you reproduce that now? `pip install -r requirements.txt` won't help, if your requirements are inconsistent. But it is way too easy to create inconsistent requirements by only doing `pip install whatever`. &gt; just delete it and start over Hahaha... well, you probably only worked on your own computer :) Well, this becomes a problem when your organization with dozens of programmers and thousands of users had already received the inconsistent requirements, and now you need to invent a way to roll them back somehow. &gt; That argument sounds Nah, sorry, you simply don't know what you are talking about. You just never worked on large-scale projects, which is fine in general, but not for answering to OP.
Is this language compiled or interpreted: `L = {x^2y^2 | x ≠ y ∧ x ∈ 𝛴 ∧ y ∈ 𝛴}`. 
Typically I have heard it mainly from Java developers and 100% of the time, those developers’ codes are not scalable in terms of code — they are hard to read or navigate, hard to collaborate, and take a long time to compile on a small project. Reality is that, it doesn’t matter. Just use whatever is best for your job. Python and JS are nice because they have low bar of entry and can be used in multiple platforms.
Pathlib is great. I would go as far as to say that anyone currently wanting to design a new general purpose programming language should consider making Path objects as integrated into the language and/or standard library as File objects commonly are.
The only thing I dislike about it that I often need parentheses, that I need to do (BASE_DIR / FILE_NAME).read_text() instead of being able to do BASE_DIR/FILE_NAME .read_text() but I understand why I can't have that and `joinpath` needs parentheses too so it's not like that's any better. Oh well.
Well, until quite recently, there weren't arguments that were mandatory named arguments, so, you could choose how to pass any argument: either positionally, or by name. Now, without any change to interface, some old code no longer works because... boom! some arguments cannot be positional anymore. -- This is an example of version incompatibility. Another example is having to do what happens when you provide both positional arguments and named arguments to a function, and you supply two different values for the same argument. Python, obviously, has *some* way to deal with this situation, but *should* it deal with this situation? Also, ask yourself: would you, off top of your head know what will Python do in such a situation, and how many Python programmers know what Python will do, and how many of them are even aware of this edge case? -- This would be an example of incompatibility in design itself. Another example is that some functions in standard library pretend to have certain interface, but they actually don't. `open()`, for instance, pretends to receive named arguments, but you cannot really pass them the same way you would to your own function with the same interface. -- That's an example of incompatibility due to bad implementation.
&gt; we have to accept both `str` and `Path` while creating API In that case I would just accept [`os.PathLike`](https://docs.python.org/3/library/os.html#os.PathLike).
Did you read the question in OP or my answer? Because the answer to you is already there. But, I admit, I like writing more than a single sentence answers, so it must've been hard on you. I'll try to make it shorter. I claim that one can tell why Python is a bad choice for large-scale projects by looking at large-scale projects and examining their problems. Had there been no unusual problems (compared to other big-scale projects), then you can say that there isn't any problem with Python, and that claim is false. However, that's not the case, and when we examine actual large-projects, written by companies with long record of pulling out large-scale projects, we see at least one glaring problem: abysmal quality of infrastructure where it comes to dependency management and distribution.
This is so true, I was finally redirected 2 times over to a closed issue. (Feels like they're supressing the issue). https://github.com/pypa/pip/issues/3999 And all this, when I put forward a working implementation with working plugins. I really wanted a plugin system because of the exact issues you mentioned. While poetry and pipenv exist, they bring their own suite of problems with them. I love using pip, and having a plugin system to extend its functionality would be awesome. It would also probably redirect feature requests away from pip, since a lot of functionality could be easily implemented using the plugins. I really have no clue how to push this forward, any help?
What?
#YOLK3K
Why are you suggesting that? This post is about having a plugin system, not just package upgrades!
Status update : the discussion has moved over to https://github.com/pypa/pip/issues/3999#issuecomment-447743331 I guess vouching for the feature there could help :)
Did the company you work for write an operating system, one that's been actually used and battle-tested by billions of users? Would it be even capable of doing so? I like MS no more than the next guy, but it's not for the quality of their software: it's what I'd expect from a big and successful software company. I hate them for their marketing and licensing policies, which I think must be outlawed.
&gt; Nah, sorry, you simply don't know what you are talking about. You just never worked on large-scale projects, which is fine in general, but not for answering to OP. Please show on the doll where the lack of CI touched you.
Why are you suggesting that? This post is about having a plugin system, not just package upgrades! P.S. If you want, I can make a plugin for yolk3k. https://github.com/pycampers/pip-plugin-collection
What is your code doing that's getting stuck on the case? What are you passing the inputs to and what's the goal?
The mac is typically picked by developers because it's a UNIX-type operating system with a decent GUI. Additionally some aspects of the Mac hardware, like the electromagnetic track-pad, are very good and protected by patent which means you can't get them elsewhere. You can same money and get a regular laptop running linux, but then you have to concern yourself with "ubuntu + printers = hell" and don't get things like the new mac trackpad. Up to you, really.
But then that tool would have to be reinstalled into your virtual environments everytime. The plugin implementation I put forward doesn't require you to do that, which IMO is a huge selling point. The plugins don't even have to be written with python, they can be simple bash scripts! imagine having to update the tool in all your virtual environments. The plugin system is a very good way to extend pip and actually requires little modification to the pip code base!
There are plenty of domains outside of airplanes and medicine where correctness is important. I don’t buy that Python is better for large production codebases just because you can fennagle static-ish type checking with it, but “can’t” for languages like C. Yes, you need to be specific in statically typed languages. But programs need to be specific.
thanks a lot ! 
Python virtual environments are a joke. They bring a lot more problems than those they solve. It's one of those thing things that kind of works, when it's prototyped, but when it comes to real usage, fails miserably. Few things off top of my head that virtual environment screw even more than what you had w/o them: - Python's headers location. You've installed some native extension, like SQLAlchemy or PyYAML or NumPy or a zillion of others so common in Python, and then you've upgraded the system's Python? Not the one used n virtual environment, right?... Hahaha! Nothing works in your virtual environment anymore! Because all those native extensions compiled against the headers you had in your system's Python. Python's ABI doesn't change very often, and most of those libraries come prepared to face multiple versions of Python's ABI, so, when you compiled them first time against the wrong headers, they worked anyways. Because people have already trained to eat that sheit from Python, and learned how to defend themselves... in many cases. But, eventually it will fail anyways. - Localization. The pathetic attempts on the side of Python core developers to make it seem like the world only uses UTF-8 encoding fail miserably when contacted with reality. But virtual environment don't help you protect against that. They will create your environment with whatever locale settings your system has, and let you use it with whatever other settings you want. And your Python scripts suddenly will start failing randomly when used over SSH from Macs and stuff like that. - Installing package's data files. Virtual environments screw up the locations of where things get installed. You write your code against how your development environment behaves, but come production times, your data isn't there, and you have no idea where it is, or where it could be, and whether that's your data, and whether that's the correct version of it.
Wasn't you the one who spammed the whole set of videos last week? 
They are ignorant.
This article has some good arguments as to why paths objects shouldn't inherit from str : https://snarky.ca/why-pathlib-path-doesn-t-inherit-from-str/ It's never too late to be widely adopted. We thought Python 3 would never be widely adopted, but more and more projects deprecate Python 2.x I am using Python 3.6, daily using pathlib.Path, and there's never been a need for a str cast with an external library. If there ever is one, I'll just open a GH issue and maybe do a PR.
yeah, you have no idea what you are talking about.
No , I wasn't Idk what are you talking 
There isn't a single thing that I don't like about this library, nor something that I feel could have been named better. This is really a library that shows how good OO-programming can be when it's suitable and well-done.
Just guessing but if you want them to compare to something or find it like: You have "Bitte" and you want to find it in yourdict d = {'bitte': 'please', 'danke': 'thanks'} you can use lower() function on your input: s = 'Bitte' if s.lower() in d: And I think this topic is better suited for /r/learnpython . Remember to describe your problem (or even post some code) so people can actually help you :) 
Because you found a new and fancy thing and you never bothered checking with reality? Common Lisp had path objects since... what? 20 years before Python was created? There people realized that it wasn't such a great thing and gradually learned that minimal interfaces are better than complicated structures, which, eventually fail to reflect reality, or, simply have no correct knowledge of the world around them. You want to deal with external things properly? -- link to the library which makes it its goal to do exactly that. Don't re-invent things. I've learned a painful lesson with `shutil`, and how it was a terrible idea to write that library and to incorporate it into the language. `librsync` is the library which knows how to do these things with all kinds of file-systems over all kinds of connections etc. If you want to do it right, `librsync` is the way to go, and only if you need a one-off script, then use `shutil`.
I've already written this above. No. This is a terrible idea. I've seen this done decades before Python existed. That was a mistake. But Python people seem to have a particular affinity for copying ideas from other languages very superficially understanding them, w/o any research into why those things worked (or not).
The better way to do vitualised python environments is to use conda ([https://conda.io/docs/](https://conda.io/docs/)). conda created the whole environment \*including\* python itself. No more dependency on system-python. It also lets you handle non-python libraries and binary extensions. 
The only true way to push forward is to * implement a proper API (the scanning you're doing, while robust, is a bit on the nose) * do a hard fork, follow previous license conventions * find a catchy name * promote it * create some plugins as is that the beurocracy already shut down as official features Thats all you can do really. Creating use of a hard fork where all that fork brings is a plugin system is hard. If you go further, and do things that people want *ahead of* pip implementing themitself, beurocracy's limitations will show themselves and people will switch. Hell I'd switch over for proper PEP 517/518 and Pipfile support alone (assumimg you continued to fast forward from the upstream repo). I can only hope the PyPA won't stick its roots into core development. Their beurocracy has been extremely strange for a few years now, and very on the nose in regard to gatekeeping and being politically correct (the recent "pipenv is official, wait no it isn't, wait yes it is, wait no it isn't, loop" controversy really showed that from people like Stufft, (Coghlan to a minor extent), and this one other person who I'm not going to dare even label with a pronoun nor name because I have a feeling if I get it incorrect they will see this somehow and send their twitter followers after me (oh, yeah, they really liked bringing in Twitter to brigade all the threads over Kenneth's utter BS back then. I wish you the best of luck and hope to use your fork in the (near) future. In the meantime, come up with a name and an implementation plan, iterate what you can quickly, then make a post here. 517/518 + Pipfile support would be a real gun to the head, so to speak. If you could somehow work in PGP based package verification, even if it involves adding a file to the repo and a third party for "I am who I say I am" like Keybase, that would also be a nail in the coffin. People have been asking for author-package verification for years, and the PyPA rejected it (to an extent).
You know, that's why I ask. What are the pitfalls we have to expect, even with a CI pipeline, where code cannot be pushed to test or beyond without being built from a clean environment each time? 
Is it just me, or does it seem lazy to post shit like this? No desc? No comment/opinion of your own? Not even a thumbtail? The guy inside me with the tin foil hat is yelling at me not to click the shady links already..
To sum up: [https://imgs.xkcd.com/comics/python\_environment.png](https://imgs.xkcd.com/comics/python_environment.png) &amp;#x200B;
Some bloke spammed the links to 30+ videos about Python introductions in 30+ individual posts last week. Many of the titles was similar to the ones in your playlist.
This. Conda is the answer to problems like this. 
 Is changing the name really important? I wanted to be as non obtrusive as possible. Everyone knows pip... Maybe I can name it pip-community on pypi and replace pip on the command line? I also have plans for making a proper pip command override/hooks system, which will leverage things like pyproject.toml to be integrated outside of pip-community codebase... &gt;the scanning you're doing, while robust, is a bit on the nose What changes would you like to see, in particular?
Don't bother, it's a low-effort blog post that half-assedly copies the python.org introduction to virtualenvs.
I have had to deal with the exact same issues. They don't go away completely with something like C or C++, but it is reduced in scope. The best recommendation I can give you is to do raw bytestring input. Treat anything else as an error. Don't bother checking to see if someone passed in hex in bytestring like: ``b"0xdeadbeef"``. Then provide a few conversion functions ( I use 'to_bytestring', 'from_hex', 'from_int', where a common type between the conversions is an iterable of bytes). And finally make it documented everywhere that you only accept bytestring. 
Then you have two problems.
&gt;Well, until quite recently, there weren't arguments that were mandatory named arguments, so, you could choose how to pass any argument: either positionally, or by name. Now, without any change to interface, some old code no longer works because... boom! some arguments cannot be positional anymore. -- This is an example of version incompatibility. Do you have an example of this? I have never encountered a problem with that, but of course that doesn't mean there aren't any. &gt;Another example is having to do what happens when you provide both positional arguments and named arguments to a function, and you supply two different values for the same argument. Python, obviously, has *some* way to deal with this situation, but *should* it deal with this situation? Also, ask yourself: would you, off top of your head know what will Python do in such a situation, and how many Python programmers know what Python will do, and how many of them are even aware of this edge case? -- This would be an example of incompatibility in design itself. &gt;&gt;&gt; def f(a, b): return f'a = {a}, b = {b}' &gt;&gt;&gt; f(1, a=2) Traceback (most recent call last): File "&lt;pyshell#4&gt;", line 1, in &lt;module&gt; f(1, a=2) TypeError: f() got multiple values for argument 'a' &gt;&gt;&gt; f(1, 5, a=2) Traceback (most recent call last): File "&lt;pyshell#5&gt;", line 1, in &lt;module&gt; f(1, 5, a=2) TypeError: f() got multiple values for argument 'a' Python tells me "don't do that". I don't see the problem here. &gt;Another example is that some functions in standard library pretend to have certain interface, but they actually don't. `open`, for instance, pretends to receive named arguments, but you cannot really pass them the same way you would to your own function with the same interface. -- That's an example of incompatibility due to bad implementation. &gt;&gt;&gt; open('foo', mode='r', encoding='utf-8') &lt;_io.TextIOWrapper name='foo' mode='r' encoding='utf-8'&gt; Seems to work without a problem. Again, I don't see a problem here.
I read your other comment but I don't understand. How was it a mistake? Why emphasizing the difference between strings and path objects by making them part of the language design would be a bad idea? If you have any examples of the problems that would generate, or articles about why it would not work, I'm interested.
I'm more curious about multithreading and such. Memory and pointer issues are annoying, but can be easier to reproduce than race conditions or memory issues on top of multithreading.
I guess regular lists in Java are linked lists?
&gt; Is changing the name really important? I wanted to be as non obtrusive as possible. Everyone knows pip... Mostly from a legal and not letting PyPA call you a dick standpoint. &gt; Maybe I can name it pip-community on pypi and replace pip on the command line? Replacing executables by default isn't a good idea and is generallt known as bad practice. Keep it with a different name on the command line, hell, even pipns (pip not shit), and allow the user to alias the executable if they want to (even add a sub command to alias it, but never alias by default on install). &gt; What changes would you like to see, in particular? Something more similar to the behavior of entry points. &gt; Edit - just noticed https://github.com/pypa/pip/pull/5743. Looks like it's already there in pip ! Finafuckingly. Still no Pipfiles though. Among other user wanted features.
I don't know about this specific course, but I did the Data Structures one from Coursera and yes, if I want to know if my multiple choice test answers are correct I'd have to pay the course. I wouldn't be surprised if this is becoming common practice.
spam
:-) It's a divisive issue isn't it. [https://dbader.org/blog/6-things-youre-missing-out-on-by-never-using-classes-in-your-python-code](https://dbader.org/blog/6-things-youre-missing-out-on-by-never-using-classes-in-your-python-code)
This is one of the first libraries I've released, would love any and all feedback!
There’s a lot of “if you have decent test coverage...” in your answer. And there are more projects with poor test coverage than recruiters on linkedin.
Thanks for the link, it's good to read this article again. I guess Brett Cannon is right, the best way to promote `pathlib` is to enforce its usage explicitly rather than conveniently inheriting from `str`. But I can't imagine people importing `pathlib` just to replace the convenient `open("my_file.txt")`. Libraries will never make API changes that would break compatibility with `str` paths, so people will continue to use `str` as paths. 
Ever consider building a bot on a DEX? Check out this thread: [https://www.reddit.com/r/algotrading/comments/a8a128/opportunity\_for\_bots\_on\_blocknets\_decentralized/](https://www.reddit.com/r/algotrading/comments/a8a128/opportunity_for_bots_on_blocknets_decentralized/)
That's kind of a rude response, but okay.
Yeah, but Adam literally posted a few days ago on Piazza lamenting attendance issues and my advisor Erik taught for the class and also told me about attendance issues. Attendance can be a non-requirement and the instructors can still feel shitty about lecturing to a hall or room without most of the class.
You may consider using s.casefold() Instead of s.lower()
Oh look, you're the one who has spammed links on my videos. 
You have no idea what you're talking about. 
You have your original problem in addition to having Conda fight with the rest of the systems python installation. 
Oh cool! Thank you. :)
I believe this is the same user who has been spamming links to videos on my channel as well. Recognize the thumbnail. 
no. conda handles everything including the python install. So you only have 1 problem: Conda. It abstracts everything else. Please download, learn, and try conda first. 
There are no regular lists in Java. Unlike e.g. Python or Javascript, lists aren't baked into Java. And you should prefer AralrayLists over LinkedLists 99.8% of the time. 
&gt; There are plenty of domains outside of airplanes and medicine where correctness is important The only correctness a compiler guarantees you is compile time type correctness. The point is that you replace that with run time correctness (even of type) via unit testing. That adds you the burden of doing type correctness checks (but only where you need them) and remove the burden of having to fight against the type system every time you need to create just another GoF design pattern specifically designed to deal with a type system.
Didnt know that one, thanks ;) 
I'm really happy how the mod team responded to the mini-outcry for more action against the /r/learnpython content. I still run into plenty of those posts but I report them and 99% of the time they're gone when I come back later. I think this sub benefits greatly by staying on the topic of discussing the language and surrounding happenings/tooling/resources.
This was an internal recruiter for a startup in Toronto. The conversation was frustrating to say the least.
The frustrating thing is that those recruiters are sometimes the gatekeepers for a company and can be hard to get past when they think that way.
Same as sending any other email. Problem is that many email providers use tools like DKIM to verify the origin of the message, so chances are real good your messages are destined to be blocked.
Next time I will for sure. I'm better-armed with talking points now. I'll use some of yours as well.
Considering how often people ask that question, I think it's nice you posted this. It'd be nice if there was a "OSS Bounty Board" for small and medium sized tasks that could help people get this kind of experience. Then again, it probably already exists and I just haven't heard of it.
Tell me more
Here is the thing, there are two kinds of recruiters, lets use the terms "internal" and "external". Internal recruiters work in the HR department or equivalent of the company you are trying to get a job at. These recruiters know what the company is looking for. Work with them if you are interested in getting a job at that company. They are typically very professional. External recruiters should be avoided at all costs. I would honestly rather give up on my development career and become a plumber's apprentice or something if I was forced to work with an external recruiter to get a job. They and the "jobs" the peddle are _that bad_. 
This is called spam. You shouldn't be sending emails from domains you do not own or haven't been given permission to send on the behalf of. Plus most providers are just going to block it as spam because your IP is not in that domains spf record. 
Because if you want to make it work well, you need to keep track of how various storage systems interface with you, what do they mean when they say `/x/y/z`, what's possible in those storage systems. And these are all very difficult questions to answer, and especially in the light of these systems *not supplying information in the format you want*. To make this more explicit: have you considered that not all storage systems use the same locale settings as your application, even the capabilities they have wrt locales are not the same as those of your application? Have you considered that renaming, moving, or duplicating files don't do the same thing in every storage system? What about case sensitivity? What about versioning? What about things like symbolic links, hard links, snapshots? What about special names for directories and files? What about volume labels? What about searching and matching files? What about object stores (like the one on, say, Android, where you don't even have real file-system API)? You can, in principle, interface with all of that through system calls, but the system calls don't want structured objects. They want string names. If you write your application in such a way that it operates on structured objects instead of string names, you will run into cases, where it either doesn't do what the user wants, or that it's in principle incapable of doing something the user wants.
Indeed: &gt; It's not so much about static vs dynamic typing, it's more about sane inputs and outputs to functions and contracts to same. 
&gt; &gt; Tell me more &gt; README &gt; Apprentice is a framework built for developing Google Actions via Dialogflow and Google Cloud (serverless) Functions. &gt; Includes: &gt; plug-and-play feel to get going quickly &gt; basic Dialogflow API 2.0 response handling &gt; local setup for quick iteration
Raymond Hettinger :P
Instead of re-inventing the wheel like /u/psteff does, there is a very useful [vxi11](https://pypi.org/project/python-vxi11/) library that makes this job much easier. import vxi11 pxa = vxi11.Instrument("ip.ad.dr.ess") idn = pxa.ask("*IDN?") 
I suspect that list() ±= int errors because the int isn't a list. n += [int] would.
How does Remi compare to [Reahl](https://www.reahl.org/)?
Is it timing out?
Your indentation seems screwed up at least for reddit mobile. It is different after the if in case a and the if in case b.
You can find a full walk through at https://medium.com/@andrew_32881/hey-google-talk-to-24dfd336acd
Think google will keep it alive? Their track record sucks.
Has pathlib been backported to Python 2.x?
Right, and obviously I don't believe *that exact bug* cripples a lot of production software. It was, as you say, a didactic example I came up with in 15 seconds. 
Fixed the indention. And no, the first part is correct and finds the correct answer. The given list of integers doesn't begin with zero. They're both logically the same. They iterate through the list of numbers and once the end of the file is found it starts the process over. This is suppose to happen for the problem statement.
I'm gonna test this now. I didn't realize *how slow* checking lists for values can be.
Ok, so let's corner this beast. What form is your list? One number per line? ""number""number""? By what magic does it read a whole file, as no read lines occur within the inner loop?
Instagram was the first example I thought of when I was done with the conversation. I couldn't think of it in the moment though. I've run into the same problem you mentioned above but as you say, once you aren't being too magical you can get some good introspection going.
&gt; pip install -r requirements.txt won't help, if your requirements are inconsistent. Then your requirements are wrong. &gt; Hahaha... well, you probably only worked on your own computer :) Well, this becomes a problem when your organization with dozens of programmers How so? You have an account on either Linux, Windows, or Mac, and have full control of your Python environment, right? If you don't, you should probably not be coding. &gt; and thousands of users Direct users (e.g., as in open source) or users that never touch the code? Cause if it's the latter, that's irrelevant. You should not be giving users install instructions beyond click through this menu that you've clicked through on 1000 different programs. &gt; now you need to invent a way to roll them back somehow. Meaning what? Update the requirements file. Shoot, remove the requirements file, run the code, watch it crash, and install a version of the package. If your code is so specific to version x, your code is bad. &gt; Nah, sorry, you simply don't know what you are talking about. You just never worked on large-scale projects My open source project is 150k lines of code. I'd call that large.l
alright, but what is that meaning?
Thanks for this. It was just really, really slow (had to iterate through data.txt 144 times to find the answer) and I assumed since it wasn't throwing a memory error that it wasn't finding a solution. Glad I'm not crazy.
I'll keep those tips in mind and be wary of the external recruiters. In this case the recruiter was internal for a startup. I guess there are outliers in every area.
So it turned out the second solution was just extremely slow, like 10 minutes slower. I figured since there was no memory errors that it was not searching the list correctly. Thanks though!
This is why people get sweary. You missed my point while you were climbing up on your soap box. &amp;#x200B; A 3 day simulation is not a user interaction. The user interaction involved here is that you kick of some long-running process. The speedy response is that the user is quickly told that results will be ready at a later time, and the user will get a notification when they are ready. Doesn't matter if that's 10 seconds or 3 days. &amp;#x200B; Some things do take time. Duh. But design your apps so that anything that can't be done fast is designed to be asynchronous and make the next action steps for the user fast to display and response to, and don't block the main event loop (or leave a long-polling connection on a web app) so that the user can keep working on other things.
Test Driven Development is the answer to sanity in multiprocess programming. My current main system is a 4 process system that communicates via pipes as a full system. I can start all but one of them and debug, or connect to processes with PyCharm and debug. But having full test coverage to verify operation is SO MUCH EASIER and FASTER. My pytest fixtures spawns processes from the other side of the pipe, and runs local code to verify. If done as a yield, you can setup and breakdown (just like a context manager.)
&gt; In the grand scheme of things, it's really inefficient at certain operations - but it was built for a very specific purpose and only that purpose. That's really not true. Yes, Go was built to be good for certain things, and it is, but it's also a good general programming language, and well-suited to many of the same tasks Python is. Indeed, the main reason I learnt Go was to replace Python when Py2 was EOL'ed. (I write a lot of CLI tools, and it's literally impossible to write a POSIX-compliant one in Py3.) 
Is this course still using python 2???
1. install Linux. 
"var in set" time in constant time. "set.add" is log(n) - reasonably fast. "var in list" has to walk the entire list - thus in "n" time, but I do believe that "list.append" is constant time. log(n) operations become radically faster then n operations - I'm not surprised with a 10 minute difference. 
Maintainer here, I linked directly to the list, but I briefly wrote about motivations for compilation here: http://sedimental.org/awesome_python_applications.html
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the r/Python discord: https://discord.gg/3Abzge7, a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
&gt; Python tells me "don't do that". I don't see the problem here. That requires some experience, and insight... You know, when you need to write library code, when you need to be able to deal with edge case. What you do is create an example, where the problem has simple and obvious solution. What if you were writing a library where the user was supposed to compose the arguments for your function in some complicated way? What if you were composing the code that deals with other libraries that do some meta-processing of arguments through packing / unpacking, filtering etc? I'll tell you what will happen: the number of edge cases will grow until it overwhelms you, and you just stop at some... idk, 80%, 90% of being correct, but you will lose the will and desire to make it 100% correct. And this is how all of Python code looks: it's always incorrect around the edges.
Oh, come on. First of all, you pretend to ask, implying that you know something that in reality you don't... Do you think in MS they don't do CI? Of course they do, in fact, Python releases are built in MS CI servers. But they screw it so badly regardless of whether they do CI or not. Why? I can only guess, I don't work for MS and never will. But, my guess will be that: 1. Python packaging is broken, so it doesn't matter if you package on CI server or on any other computer, it's just broken by design, and implementation is even worse, so whether you did it automatically or by hand will have no effect. 2. To do CI effectively you must cut corners, or you will end up having a very complex and very slow process, which will not serve your needs. For example, it takes minutes for `pip` to install just a dozen of pure Python packages (no compilation of native extensions etc). So, if you wanted to do CI right, you would have to throw `pip` away and write your own package manager. MS has a lot of engineers, but they are a business... they won't spend time rewriting `pip`, if they don't profit from it. So, maybe you just won't use `pip` in CI, or maybe you'll find a way to force `pip` to work faster, which would not be representative of who a regular user would use it. I don't know what exactly did they do, but I wouldn't live with such ridiculous times if I were them.
If you happen to have a purpose that isn’t to be shitty or spamming, then you can easily find this answer on google. I believe it’s as easy as adding from: or something of that nature to the message. I’ve done it before for testing purposes. 
But it doesn't solve the locale problems. It also uses the garbage format of Wheels or Eggs. I understand that it was probably not their choice to make, but it doesn't make it better. An ultimate solution to Python's packaging and distribution problems would be to throw away `distutils`, `setuptools`, `pip`, Wheel and Egg formats as well as source distribution formats and start fresh. Everything listed above has such deep seated problems that nobody can make it work well. As long as you have at least one thing from the list above in your tool-chain, you are screwed.
Why is Deluge called lightweight
Wouldn't "set.add()" be in constant time as well? If it takes O(1) to check if an item is an unordered set then that implies the item itself is the index, which would lead me to believe that "set.add(item)" inserts item at index if there is nothing there.
I stand corrected: https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt Add is O(1) after all!
Thoughts on Atom? I've been using it a lot and I really like it. It's similar to Sublime. 
Idk about that , you should check my list it's not spam I created according to the sequence wise so no one can get trouble while playing 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
[https://treyhunner.com/2018/12/why-you-should-be-using-pathlib/#comment-4251475008](https://treyhunner.com/2018/12/why-you-should-be-using-pathlib/#comment-4251475008)
To contrast: You might use Django to host a database, manage it using an ORM and admin functionality, and execute arbitrary code that does not depend on the user's system. You could also use it to serve web pages via a template system, and modify what's being displayed by a template system. Dynamic in the way the OP means building a GUI that runs in a web browser, and is responsive in a way similar to a native program. It executes code on the user's system, and probably sends requests to and from a server to load data, send data, authenticate a user etc - perhaps one running Django
You can use husky for your python project. I did that before. Alternatively, there is https://pre-commit.com which is written in python but can be used in every project as well.
&gt; But, I admit, I like writing more than a single sentence answers, so it must've been hard on you. I'll try to make it shorter. You're the cookie to work with really. Such a lovely attitude.
I think atom is officially no longer being supported. I haven’t used it, but from my brief exposure I didn’t like how busy the interface was for lightweight stuff
Oh, didn't know that, thanks. Guess I should start working more in pycharm. 
You could use Jira or something like this.
This wheel has already been invented. 
Hmm, I'd rather practice building stuff, but that's cheaper than I would have guessed. Thanks.
Is this the list that was featured in python bytes a week or two ago? I'd been meaning to look it up.
Can't comment on the quality of Docker4Python, but can you go into more detail about why you think Docker and k8s are 'scourge'? I originally thought the same way but I am so happy that I decided to open my mind up a bit.
I love my 2011 macbook pro but I would say they are not worth the money anymore. I would recommend just buying the cheapest used laptop you can find and load Ubuntu onto it. Ubuntu is easy to install and you can start learning the Linux command line while you learn python. I HIGHLY recommend using command line and a text editor when you are just starting out, it actually makes using an IDE easier when you get to that later. So to sum up my recommendations: Computer: cheapest laptop you can find on craiglist that still works properly (keyboard, trackpad, and screen all okay and it boots properly). OS: Ubuntu (load it onto a cd from a different computer and follow the instructions). Editor: Start off using vim, a text editor that runs in BASH (linux command line). Once you get the basic commands then start doing some research to figure out where you would like to go from there (maybe emacs or an IDE or just another text editor similar to notepad on windows). It's nice to know vim though because you can just quickly load up a file and make an edit. python: Newest edition of python3. I imagine you can just use sudo apt-get install python3 or something like that. Eventually you can get Anaconda or something or whatever floats your boat. Command Line: Called BASH on Linux. Use CTRL+ALT+T to bring it up (called a terminal). Learn the basic commands (cat, touch, cd, mkdir, ls, etc.). learn what a PATH is and how to edit it. &amp;#x200B; That should be enough to get you started as a hobbyist. 
Yep I have. but that was almost 20 years ago. today I would use an existing project. 
Did a wrapper for youtube-dl to add pushover notifications and a bit more control when I download playlists. Now run as a Cron job and get all the videos I add to some of my specific playlists. I guess most of my projects are for make it easier to support my hording...
I mean...there are 100% free, open source solutions to this problem.
It looks like the backport is called [pathlib2](https://pypi.org/project/pathlib2/)
&gt; The os.walk function has no pathlib equivalent either. For many use-cases you can achieve similar behavior with glob e.g. current_directory = Path.cwd() for mp3_file in current_directory.glob('**/*.mp3'): print(mp3_file) but yeah, there is no 1-1 replacement for all of walk's functionality
&gt; I recently found that you can send emails from domains that you don't own That's always been the case (i.e. you can basically put anything in the headers just like you can put anything on the outside of a physical envelope), but that doesn't mean it's going to get delivered! The article is trying to explain why this is a bad idea for e-mail (i.e. most mail servers today will either outright reject or flag that as spam based on DNS lookups)
No, I genuinely ask. What your personal experience is. That MS makes a clusterfuck out of a product isn't something new. The literature is rife with descriptions of how much hand-holding it took to build Windows NT. 
I plan for this to eventually cover the entire learning curve starting with the basics, working up to some smaller example projects, which actually "do stuff", like a simple Telegram bot or Flask site. All kinds of feedback is highly appreciated!
If you want to track bugs in software developed in-house, I'd suggest installing GitLab and use their bug tracker along with project management and Git repository. Trust me. If your tasks are not related to software development, then think about creating a ticketing system, not bug tracking. It's easier to make, operate and maintain. For you and your users. Non-technical staff does not like relatively complex systems like bug trackers and avoid using it in the end. 
I would like to open a discussion about how people view link posts without a comment. To me it appear that many of these are spammy in nature, where the poster are identical to the person who have made a very basic blog post or video on strang concatenation basics. I wonder if automoderator could be configured to hide these posts until the poster have added a comment with a short resume, so we'd at least have some idea what we're going to find. 
Python has nothing to do with it. Depending on zone configuration you either have to use owner's SMTP server to send mail or ask them to add your IP to their SPF record. Either way, you have to talk to domain owner first. 
This was exactly what I was looking for. Thank you.
I'm learning the very basics; trying to break a many-time-pad from a course on Coursera. I like your approach. Here's what I've got: ```python def pairs(text: str) -&gt; Iterator[str]: assert not len(text) % 2, "Text must have an even length" return (text[idx:idx + 2] for idx, val in enumerate(text) if idx % 2 == 0) def from_hex(text: str) -&gt; List[int]: if text.startswith("0x"): raise TypeError("Text must not have a prepended 0x") try: return [int(byte, 16) for byte in pairs(text)] except ValueError: raise TypeError("Text must be in pure hexidecimal format") def to_hex(bytes: List[int]) -&gt; str: return ''.join(f'{byte:0{2}x}' for byte in bytes) def xor(a: List[int], b: List[int]) -&gt; List[int]: # If there are extras, discard the right-most ones. if len(a) &gt; len(b): return [x ^ y for x, y in zip(a[:len(b)], b)] else: return [x ^ y for x, y in zip(a, b[:len(a)])] ```
Not to be a dick, but why? The web is full of python basics courses.
That's typically only necessary in Python 3.5 or below. Meant third party libraries have even been adding support for Path objects by using an equivalent to os.fspath to normalize them if needed. I'm curious if you're on 3.5 and/or which third party libraries you've found that don't work with pathlib yet.
Interesting. I will check it out. 
Generating tutorial content is a good means to develop your brand and credibility. In some cases, it can lead to job offers. But to your defense, just making noise to be heard can make it challenging for new programmers to find the best educational content when the internet is flooded with information.
Agreed. My point was just that type-checking doesn't save the day either in this case.
I was looking at multivariate\_linear\_regression\_demo.ipynb notebook and was wondering that you should add the summary of the model coefficients, their p-values and corresponding adjuster R squared and some other model performance measurements. Also, it would be cool to few tests like multicollinearity and heteroskedasticity and with each iteration and change in regularization\_param show how they behave.
Nice work! I've looked into storing my own resume details into a structured dataset like [jsonresume](https://jsonresume.org/), but never gave much thought to actually parsing a resume itself.
You just sold it to me. Added 1 more fan to pathlib Thanks for the awakening.
ML frameworks use Python as a frontend while leveraging more performant languages like C++ for expensive ops and compute kernels 
Just so you know it, old reddit doesn't understand the triple backtick, so for us who don't like the redesign, your code look like crap. 
What does this even mean? &gt; We include (_include... in what?_) num_string and num_int factor (_factor? what’s a “factor”? I thought these were called “symbols”, or, if you wish, “variables”_). &gt; We switched num_string from the string(greater ) into an integer(reduced ) type (_why is `int` “reduced” compared to `str`?_) utilizing int() work (_”work”? you mean “function”_) to carry out the addition. After converting num_string into some integer value Python can bring this two factor (_bring these “factors” (?) where?_).
I bet the Python3 code's even more confusing!
Questions like this are specifically not for here, try posting in /r/learnpython or discord, links are in the sidebar.
It's not the code. It's the formatting of it. Take a look at https://old.reddit.com/r/Python/comments/a7zrjn/why_do_people_say_that_python_is_not_good_for/ec9tu9a/ to see what I mean. 
Pretty sure it is! I'm still catching up, but I mentioned it on Test &amp; Code a bit ago and then Brian carried it over to Python Bytes. :)
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
A couple points on that: The `Path` object is smart with path separators so all of these have the same internal representation: ``` &gt;&gt;&gt; Path('src/.editorconfig') WindowsPath('src/.editorconfig') &gt;&gt;&gt; Path('src').joinpath('__pypackages__') WindowsPath('src/.editorconfig') &gt;&gt;&gt; (Path('src') / '__pypackages__') WindowsPath('src/.editorconfig') &gt;&gt;&gt; Path('src', '.editorconfig') WindowsPath('src/.editorconfig') ``` On Windows, those all have this string representation: ``` &gt;&gt;&gt; str(Path('src/.editorconfig')) 'src\\.editorconfig' ``` And on Linux it's like this: ``` &gt;&gt;&gt; str(Path('src/.editorconfig')) 'src/.editorconfig' ``` So I'd argue that this: ``` from pathlib import Path Path('src/__pypackages__').mkdir(parents=True, exist_ok=True) Path('.editorconfig').rename('src/.editorconfig') ``` Really is equivalent to this: ``` import os import os.path os.makedirs(os.path.join('src', '__pypackages__'), exist_ok=True) os.rename('.editorconfig', os.path.join('src', '.editorconfig')) ```
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Im so excited for deepmind getting into starcraft. It will be interesting to See how they approach a realtime game of incomplete information
Questions like this belong in r/learnpython or in the discord server, check the sidebar for more information.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the r/Python discord: https://discord.gg/3Abzge7, a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
It requires login to view the code :/
Damn - any suggestions for hosting sites? 
I disagree, mostly because I've been using `pathlib` in pretty much the same way I used path strings before and the only issues I tend to run into involve the type of what is returned. Given this function that is ignorant of pathlib: ``` import os import os.path def do_things(filepath): os.makedirs(filepath, exist_ok=True) with open(os.path.join(filepath, '.editorconfig'), mode='wt') as f: f.write('# config file') ``` This code (the old way) works: ``` import os.path do_things(os.path.join('src', 'subdir')) ``` But so does this: ``` from pathlib import Path do_things(Path('src/subdir')) ``` This is all as of Python 3.6 (as I noted in the article). Our code won't be magically changing to use pathlib everywhere overnight, but the fact that the Python standard library and built-ins all work with `Path` objects natively means the path to switching to `Path` (no pun intended) is a pretty easy one (much easier than certain other big migrations this community has undertaken in the not-so-distant past).
&gt;Same as sending any other email. Problem is that many email providers use tools like DKIM to verify the origin of the message, so chances are real good your messages are destined to be blocked. I wouldn't call that a "problem", that's what keeps my inbox sane.
Good bot
Thank you, azmanz, for voting on pythonHelperBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://botrank.pastimes.eu/). *** ^(Even if I don't reply to your comment, I'm still listening for votes. Check the webpage to see if your vote registered!)
Bad joke
Sure. OP's problem, if you will 
They said the course is meant to teach computer science concepts using python, not python itself.
You should buy a new computer to learn python. All programming on the Mac is directly tied to Excel so if you can't stand Excel on the Mac, you won't be able to learn python on it. 
/r/learnpython and read the sidebar python is fine on a macbook/air. Try a couple of IDEs like VSCode or PyCharm and see which one works for you.
Hello! I'm a bot! I see someone has already suggested going to r/learnpython, a sub geared towards questions and learning more about python. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the r/Python discord: https://discord.gg/3Abzge7, a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Expect a 3rd(?) Talk Python To Me appearance on the subject sometime? I'm purely extrapolating from historical podcast guests and your username. 
r/learnpython is best for this. I suggest you start with the newer Python3.
Haha, that would be great! I guess I have a certain output periodicity which might coincide with not exhausting Michael's audience. I hope I have some time to gather findings so I can say more than just, "yeah this exists and it has been really edifying to curate." :P
So the entire code of each of these programs is available to us to learn from?
People who bring them into project generally have your condescending, narcissistic attitude. Like they regard those not onboard with introducing their severe tooling lock-in as closed-minded.
That's right! And/or blindly copy!
I love this effort! I found a couple projects that I didn't realize we're Python, and now I wanna check out the source. Also, I was all ready to throw out a suggestion for Qtile, but then I saw it at the bottom. Nice!
Don't worry about the difference. I mean, if anything, you probably want to be on 2.7.15, which is the latest of the 2.7.x family. Or, consider learning python3, seeing as python2 is end-of-life fairly soon
Having heard your interviews I'm definitely more likely to go through the list(with the caveat that spare time is largely absent). I'd actually forgotten that you were part of the group on the python job episode, so you already have 3. Anyway, keep up the good content. 
Practically doesn't matter, especially for a beginner. If your setup works for you, then don't worry about it. Be aware that many ides/editors that work on windows or Linux will also have a Mac version, but you may find the odd ide or editor that has only a Mac version, so just be aware of this
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
You might like to use Plumbum's path objects, which we've had since before pathlib, and added a lot of pathlib compatibility after. They subclass `str`, so can be passed anywhere strings are expected. The only gotcha is that `__contains__` is overwritten to check for files in directories, not substrings. 
And [Plumbum as well](https://www.reddit.com/r/Python/comments/a82xv8/slug/eca6i1b), which inherits from `str`.
Notable that Plumbum's alternative offering does offer walk functionality. 
I would definitely recommend learning python3 as it's becoming the new standard. 
You might also check out [enaml-web](https://github.com/codelv/enaml-web).
Well that would depend on how it's used in practice. I'm not sure what is so complicated about what I'm saying? If a language is compiled is every practical use case, it is a compiled language, even though compilation isn't a characteristic of the language. I think the part that is tripping you up is that you assume people calling a language compiled/interpreted are trying to describe the language specifically, but they are not. They are usually talking about the standard practical application, and for most languages the standard practical application is compiled machine code, interpreted at runtime, or something in between.
Yeah it looks great. One of the things I'm looking forward to once I've worked through the basics of python.
Thanks for those kind words :)
Not using random.choice smh
`print(random.choice(action))`
GitHub?
There is python 3 code and there is legacy code.
Requesting changes: Missing spaces after the `,` in the list and the parameters. Missing spaces around the `-`. Fails PEP8 check.
Eh?
You’ll start feeling the limitations of your hardware when trying to do large scale ML on your machine. A MacBook Air certainly suffices
Ignore the snarky comments here; as an also wannabe woodworker, this is adorable. 
I think she wants to be a programmer her self!
Fluent Python is an amazing resource for learning intermediate to advanced skills
PEP8 wants spaces like that? Weird. I never include spaces there. 
Wow. Just wow. Python has arrays...in the array module. A list is fundamentally different in nature because it is a collection of possibly many different types of objects.
And just for completeness, `random.randrange(len(action))` , if you actually need the index value.
Honestly not sure. Flake8 would complain in this context
You should upload the code a [GitHub Gist](https://gist.github.com/).
# pylint disable=no-space-after-comma
Am I the only one who doesn’t get it?
Okay if that is the case it's absolutely ridiculous since the answer key is already known and no one has to actively look at code.
Wonderful 
I prefer `rglob` so recursion happens automatically: ```python for path in Path.cwd().rglob('*'): print(path) ```
You need content for you blog?
Lmaoooo 
It is a cutting board fam
You read my mind. Didn't you??
I agree. As Pythonic as that snark is, this is purely adorbable and I'd love one. ...May have to steal it.
Knit?
I get this all the time with subprocess. `subprocess.call([someexe, somepath])` gives you grief if somepath is a Path object and not a string.
Snakes on a plane the series: reticulated acrophobia Sam Jackson: I want these snakes off this Mother Freaking hot air balloon! Snakes: hissssss. Alright, so that's just a little taste of what's to come if I can sell this to the cw.
Certainly a feasible name. Will consider after collecting more submissions from this and other sites.
Which one, after the comma or around an operator? PEP8 suggests both but I disregard the one about operators. I do use spaces for add and subtract, but not for multiply and divide...just too far off from mathematics for me at that point.
print(random.choice([‘yes’]))
Have you checked out [https://github.com/novnc/websockify](https://github.com/novnc/websockify) ?
the real life pro tips are always in the comments
&gt;programmer her self! You know you've written a lot of Python when you split "herself" into "her self" out of habit. ;)
yep - looks like it. Been trying to get a simple example working and it's kinda painful
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the r/Python discord: https://discord.gg/3Abzge7, a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
So inefficient 
Ah, one of life's more important lessons. No matter how long your script is there will always be someone who can create a single line code that does all of that. There will be also be someone who will top him by writing a single functional haskell and say his is more efficient.
To answer your question, go to [this page](https://www.python.org/downloads/release/python-2711/) and download the installer. As you can see that specific version was released 3 years ago.
The single line pet isn't important. The "random. choices" is. It tells the reader concisely what the desired outcome is. Cramming stuff on a lime can be bad an less readable. Calling an aptly names function is great though. 
Best sister ever
I was just joking, dude. Python with it's standard library is pretty readable.
Couldn’t this be further one-lined using lambda?
Not to discourage you, but... a lot of these are really bad ideas. Most of these functions either wrap builtins with no changes, which is pointless, or hide simple, straightforward operations on builtin types behind names that obscure what's going on. You've overused boolean switches that completely change the behavior of some functions, which makes it even harder to understand what each function does.
The aim of this post was to find a new name. I have already asked for and received feedback a few months ago on r/Python.
&gt;This is why people get sweary. You missed my point while you were climbing up on your soap box. Not really; such a small example of miscommunication could be handled politely methinks.
Whatever floats your boat, but you got exactly the same advice last time: learn about the standard library, throw this out, and do something more focused (https://www.reddit.com/r/Python/comments/9zmw8e/im_creating_a_python_convenience_library_looking/).
CPython: https://github.com/python/cpython Instructions to build it are in the readme. You can modify and build whatever new features you want! Your list of things is sort of spread out everywhere, and it depends on what exactly you want to do. You may have to change the parser as well as the core logic. Good luck!
I would buy this as a gift for a colleague
Like how?
Can you elaborate?
`lambda action : random.randrange(len(action))` ( ° ͜ʖ °)
`n = random.randint(0, len(action)-1)` `print(action[n])` takes 2 lines of code, but you can just use `random.choice(action)` If I were to write the code in the picture, I would use `import random` `print(random.choice(['slice', 'chop', 'dice']))`
An unassigned anonymous function? You're fired. :)
THANK YOU
self.her
Totally agree, I thought you were talking about not using `.choice`
"so inefficient" doesn't usually apply to using an extra line of code. FWIW, the main efficiency benefit of random.choice() is that it's arguments are easier to parse than randint().
Oops, sorry
Got your back, here it is with comments. # import the random module so we can use that pseudorandom goodness from the standard library import random # cast strings slice, chop, and dice as a list to the variable called action action = [‘slice’, ‘chop’, ‘dice’] # use the random integer function from the random module to choose either slice, chop, or dice as indexed from 0 to 2 in the action variable, 2 in this case being found by counting the number of items in the action variable’s list and subtracting 1 then casting the result to a variable called n n = random.randint(0,len(action)-1) # finally we print the n’th item from the list called action resulting in a new output every time the code is executed. print(action[n]) Is it the most efficient? No. Is it cute as a button and a great gift from a loved one? You bet!
No worries; I'm just adding some sizzle. Your suggestions are perfectly fine, though it might make the cuttingboard too "sparse"... I think we all agree that the aesthetic was the most important issue as to how this particular code was written. :)
True, the board does look nicer with the current code
good python programmer is very universal, since there are python libraries for just about anything I doubt anybody at a python boot camp is anywhere near being good
Also that name should really be `actions`, plural.
 import random print(random.choice(['slice', 'chop','dice']))
I agree with this. Even though the code could be written more efficiently (if wanting to omit the use of assigning variables anyhow) it looks more tidy and readable the way she did it :)
I managed to get same stats info with django-silk and some SQL queries. Here is a blog post on that [https://avilpage.com/2018/12/django-bottleneck-performance-scaling.html](https://avilpage.com/2018/12/django-bottleneck-performance-scaling.html)
Will you explain? I'm new. I know len and random and [ brackets] for lists but that's it. It looks like it's counting the length of cut chop dice but I don't really know 
`random_randrange_len = lambda action : random.randrange(len(action))` fixed it boss
Two words. Deep learning.
The bar has been set *very* high for beginner-friendly Python tutorials, that it may be very very difficult to be noticed for new tutorials. Just a warning that you may not get the reception that you expect, even if your tutorial is very good (because there are many others that are also very good). Maybe take some specialised angle on the topic instead, in order to differentiate yourself? 
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the r/Python discord: https://discord.gg/3Abzge7, a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
+/u/compilebot Python print(random.choice([‘yes’]))
The explanation of the snarky comments is that the python code shown is not very Pythonic as its not as readable as possible. In other languages this is the normal solution to select a random item from a list but python already has this function natively.
Well if the game is text based, one can just use `print` and `input` functions as the user interface
Yes. Have a look at sets. 
The leaders will be, there was a course on pastebin deals that was originally like 1.2k or something like that it was a lot and it had been knocked down to $12 dollars so I thought what the heck it’s a bargain, and it’s very good. Covers all sorts, if it’s still up I recommend it :p the people on it defoes know what they’re doing 
/r/learnprogramming /r/learnpython
Github is preferable in most cases but pastebin is fine if it's a smaller single file program
Yeah man if you're going to be
I'm in 3.6 and I really can't recall which one
Not only are your comments excessively verbose, they are incorrect. The second line isn’t casting anything, don’t use words you don’t understand or you’re likely to use them wrong. Same for the third line, no casting.
Same! Especially with the code as is instead of using `random.choice()` so I could watch their eyes twitch between appreciation and desire to change the code
Good Job OP. May I ask you, is python your first language? because in 6 months, it is impressive.
Cool man, thanks for letting me know. What is it called then?
from random import choice
Basic economics lesson: if someone is actively working to sell you training and their argument is that their training will get you a high salary job, they have an incentive to inflate how high that salary is likely to be. Simultaneously their own salary depends on successfully increasing the number of people available to fill those high salary jobs, which means they're also incentivized to decrease the salary their training can return in the long run. Python's a great language to learn, it's widely used, extremely flexible, and -- assuming you keep at it -- will certainly pay dividends on investment, as its learning curve is relatively shallow and the number of domains in which it can be productively used is vast; very few general programming languages out there can make _both_ of those arguments simultaneously. Unfortunately none of that necessarily leads to a higher salary, which is extremely dependent on what work you do with Python and where you do that work. Take any number anyone gives you with a grain of salt.
The keywords of the language you cannot modify without [rewriting the grammar](https://devguide.python.org/grammar/), this is not a trivial task and involves about a dozen files in the C implementation alone. That won't change any of the builtin functions or classes; depending on how deep you want to go those are implemented across hundreds of different files in both C and Python. I really don't want to dissuade you, but the odds are if you're asking this question the way you've asked it you've underestimated the scope of what you want to do. Maybe explain both _what_ and _why_ you want to do it first?
kitchensink
Spent a few hours figuring out that the package I was using used both random and numpy.random so that even that even when I saved the numpy seed I couldn't reproduce my results. I now get mildly angry whenever I see random.. Anyway cool wood! 
A dice game of outcomes modulo 3 will recur forever. &amp;#x200B;
There we go; updated the link, and here's a separate one: https://github.com/nedmund13/pyPyCalc
Here we are: https://github.com/nedmund13/pyPyCalc
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the r/Python discord: https://discord.gg/3Abzge7, a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the r/Python discord: https://discord.gg/3Abzge7, a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Updated to a GitHub repository: https://github.com/nedmund13/pyPyCalc
Seems to run fine, I like your exception handling. One thing that might be nice is to remember unit of measurement choice so that when the program loops the user doesn't have to re-enter that one. Chances are slim that a given user will flip flop between the two arbitrarily. 
``` print(__import__('random').choice(['slice', 'chop', 'dice’])) ```
Vscode 
I think there's still a lot of "learnpython" spam from new users and those who don't care, so there should be an easier way to flag/move them.
This is a game i created on python while my professor asked me to make something that i liked : from random import choice play = True choices = ["rock", "scissors", "paper"] # Compares two choices, returns true if the first wins # False, if the second wins # None if the two are equal def compare(a, b): if a == b: return None elif (choices.index(a) + 1) % len(choices) == choices.index(b) or \ (choices.index(a) + 3) % len(choices) == choices.index(b): return True else: return False
A comma without a space has no place in this universe. 
`import random` `print(random.choice(['slice','chop','dice']))` 
TIL I can import modules this way. Thanks! 
Except here apparently: &gt; Yes: foo = (0,) No: bar = (0, )
Actually prefer the latter. 
I don’t use them in lists. It sounds like we write math the same. According to PEP8 I shouldn’t be using mixedCase to name everything either. Maybe this weekend is a good time to finally read through PEP8.
It's easiest to understand the number of you print it in binary. In rwxrwxrwx, each of the letters corresponds to a bit. \`print "{:9b}".format(420)\` prints "110100100" which is the same as "rw-r--r--". \`print "{:9b}".format(484)\` prints "111100100" which is the same as "rwxr--r--".
Machine learning and data science.
You need a better ice and/or pre-commit hook with linter
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Oh my bad dude. I think was right before bed and I probably should have been sleeping. There are people who "pythonize" stuff, like their list comprehension. Which is super concise but I still have a hard time reading. 
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the r/Python discord: https://discord.gg/3Abzge7, a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
I see now. Thanks very much!
How did you install before? Did you use pip? Are you using the default system python or a different version from brew, source, etc?
Check if you installed it for the correct version of python
Issa joke.
Крута штука, треба потестати!
pep-8. For variables and functions snake_case is preferred instead of camelCase ----- calculator() is huge. Carve out subtasks into separate functions. Constants probably can be put at the top. Also given fixed ratios, you could use metric as base and do math based transformation to imperial, instead of providing 2 separate const sets. ------- commas and quotes being opened and closed all over the place make it harder to build an image of what is being printed. print("The armour woud weigh ", "%.0f" % aM, " pounds, or ", "%.2f" % aMT, " tons") use string formatting, instead of using a dozen arguments. If py3.6 you can go with f-strings, other than that str.format(). print('Ther armour would weigh {:.0f} pounds or {:.2f} tons'.format(aM, aMT)) Ther armour would weigh {a:.0f} pounds or {at:.2f} tons'.format(a=aM, at=aMT)) ----- getnumber can be simplified def get_number(prompt, lower, upper) : while True: try : response = float(input(prompt)) if lower &lt;= response &lt;= upper: return response except ValueError: pass print("Please enter a valid number between {} and {}".format(lower, upper)) -------- response = str(input(prompt).lower()) str() is absolutely superfluous here. If input was not str, lower() would fail before conversion. 
You shouldn’t use the USAF target. You can’t get any robust quantitative data from it. 
Yeah coding on citrus can be really difficult. Creates some really zesty code. Really rinds my gears.
`print(__import__('random').choice(['slice','chop','dice']))` 
A degree will open many more doors than a cert will. Be able to prove you know what your talking about counts for much more than just having "experience" on a resume. If we interview someone that list Python or powershell on their resume and I ask them about what types of scripts or programs they have created and they say none then they are immediately out. I would care more about actual knowledge than paper "knowledge". 
from random import choice
this is beautifully touching
I could never take seriously a library that includes your happy birthday function. The kerning on your title font thing is hideous. You have put a lot of work into branding this thing well before that is appropriate in the lifecycle of a project. It is not a language, it is a library. That huge pile of imports probably makes the import time for your library very long. If your function is a one liner it almost certainly shouldn't be a function. There is no need for bool in your divisible function. Often, you are changing the keyword for a built in operation (e.g. enum for enumerate). In this particular case, an enum and enumeration are very different and it's twice offensive, but in general this is twisting the python language so readers of your users' code will be confused. I struggle to understand the point of your autosolve functions. Your equation function can be much better solved using the operator library in stdlib. Why on earth would you make a squareroot function for sqrt? median changing a function named average to return a median is...how do I even begin with that? Don't do that. A single \~3000 line file is a bad idea. You should replace your if elif trees with dictionaries, color_returns = { 'hsl': lambda x: x.hsl ... } or be even cleaner, dtype = dtype.lower() if dtype is 'sat': dtype = 'saturation' elif dtype is 'lum': dtype = 'luminance' elif long_hex and dtype is 'hex': dtype = 'hex_l' return getattr(c, dtype) &amp;#x200B;
Excel Vlookup in pandas..Wow..
I subconsciously knew this because comprehensions’ frames show up in debuggers, but never thought about the consequences on recursion depth. Interesting! 
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the r/Python discord: https://discord.gg/3Abzge7, a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
What OS? How was it installed? Why do you want to downgrade? Are you familiar with how to do virtual environments on your choice of OS?
Going to save this and then look for a tool to find it again. Good work! 
This is very cool, so don't take this as a criticism - but I'd love to see command line versions of the various tools too. Let me run them without the webapp so I can pipe the data into other things.
Programming languages are just tools and your toolbox is constantly getting new tools added while old tools are being removed. Python is fantastic! But employers will want to know you have the deep foundational knowledge to learn any new tool that comes up. I think you should invest your time getting a degree, even if it is an associates degree. After 16 years having a demanding job in the US military you know what it takes to be successful like time management and organizational skills. Heck most 18 year old kids can't even get to class on time. The big things I would invest my time in is cloud, security, and data analytics (all of which Python plays a big role). Consider leveraging your military experience into a military career as a civilian (either as a government employee or contractor). The DoD needs help and your operational experience would be valuable. 
&gt; Going to save this and then look for a tool to find it again. Nice! That's the spirit! I also end up saving a lot of posts and can never find anything when I need it. I wish reddit had better searching in general. &gt;Good work! Thanks
Excellent job! Im a newbie but this is very informative
Thanks! The [flask tutorial](http://flask.pocoo.org/docs/1.0/tutorial/) helped me get started. I found it pretty straight forward although I had a little bit of web dev experience when I started. And build up from there.
It displays randomly one of the three actions 
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the r/Python discord: https://discord.gg/3Abzge7, a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
This project actually came from me getting frustrated with the script I had to search saved posts. It kept breaking and it didn't do a good job of displaying posts/comments. I think the web interface is perfect for this. That being said the code that does the searching in the back end can be used for a cli with no modifications you will have to find a way to show the posts though. Search term -&gt; [search function] -&gt; list of results
My Ukrainian is very rough! What's the last part say?
Fair enough, thanks for the reply
Questions like this are best asked in /r/learnpython or on the python discord. See the sidebar for details.
No problem. The other thing, in what format would you pipe the results? Maybe send the comment/submission links? Building good cli's is definitely a work of art, I'm unfortunately not the best at it.
In terminal type pip install beautifulsoup4
Odd. `subprocess.call` seems to work with `Path` objects for me: ``` &gt;&gt;&gt; from pathlib import Path &gt;&gt;&gt; import subprocess &gt;&gt;&gt; subprocess.call(['ls', '-1', Path('.editorconfig')]) .editorconfig 0 ``` I tested that in both Python 3.6 and Python 3.7.
Did that, but when I import bs4 in pycharm it gives an error
Ha why is called the '[Quilt Programming Language](https://quilt-lang.richie-bendall.ml/)' ? It's a python package. &amp;#x200B; This looks like great recruiter fodder, but would be a real blight upon a codebase that anyone (other than you) ever has to work on. The feedback you received when asking in /r/Python was pretty gentle. &amp;#x200B; Me if you ever tried to sneak this into a PR on a project I worked on:
Just read through the article before viewing the list. I'm particularly interested in your mention of h-index/altmetric analogue. I've worked a bit with the altmetric algorithm and alternatives in the past, and I'm interested in pursuing this analysis of the python ecosystem. I was wondering if you had any more thoughts on the subject, and if you would like to discuss a possible methodology. 
It is literally astounding to me that OP and others like them wouldn't even *consider* that these things are relevant to their question.
Maybe you are on a different environment.
I think you can use Kivy from QPython, but I don't know if they ever added it to their Python 3 version (they didn't for a long time after Kivy first supported Python 3 on Android).
Nice. Thanks!
Thanks bro
I'm still unclear what is the opposite of a \`dynamic frontend web app\`; anything that is serving dynamic content needs to get that content from a server: the server is the dynamic part.
Let's forget the word dynamic. OP asked for a frontend framework. Django is a backend framework.
Upvote because of recursion. :) 
still bad practice according to pep8
Unfortunately, I've gotten \*no\* takers, and I need to push out this new version this weekend. But since rehosting the project to GitHub, the accessibility to new contributors has gone up quite a bit. But I'll post other items in the future as much as I can.
https://lxml.de/
Too lazy to type out the code, but sounds like a nested dictionary would be a good fit for this.
Better to use f strings in python now i think. The two you show. Bottom one wont work if x is ever a non string.
no no, its alright am just confused on what it wants me to do. &amp;#x200B;
Yes, lowerCamelCase is super annoying to most Python programmers, lol! Remember though, PEP 8 is suggestions. For small things like spacing, use what works for you. It is more important to be consistent. But being consistent with other projects is a nice feature, in which case following PEP 8 more strictly is likely to get you there.
List of JSON arrays? If you have to create an interoperable text file JSON or XML are the ways to go (usually)
thanks for your reply &amp;#x200B;
Am still new to python so i only know some basic methods to open a file like file.write() ect.
Check the JSON module, it can dump any structure to a file for you. Also, if you are learning, try not to bite more than you can chew, or you will get frustrated and lose motivation.
Thanks!
Was that advent of code? I had a similar idea for one of the advent of code ones.
[removed]
Prettty preeeeetttyyyyy pppppprrrreeeetttttyyyy good.
Means “I should check it”
/r/learnpython As you'll know from when you tried it, the first gives you `"a b"` and the second gives you `"ab"`. The first is much more flexible and powerful. For example: ```python xs = [1, "potato", ["things", "that", "are"]] y = "a number: {}, a string: {}, a list: {}".format(*xs) y2 = "a string: {1}, a list: {2}, a number: {0}".format(*xs) x_dict = {"number": 1, "string": "potato", "list": ["things", "that", "are"]} y3 = "a list: {list}, a number: {number}, a string: {string}".format(**x_dict) ``` For modern versions of python, you can (maybe should?) use f-strings instead, which I'll let you look up in your own time.
In the standard library, ElementTree works fine if you just want to extract data from XML. If you want to edit and save XML use LXML. The standard library implementations are incomplete and can't replicate some constructs. For example they move all namespace tags to the root node and will save XML that contains forbidden other characters. Also consider defusedxml which monkeypatches the standard library against malformed XML.
thanks for your reply that helps me so much. im bit confuse in the `.format(*xs)` &amp; `.format(**x_dict)` Ill go study for that one.
Thanks for the advice, assumed that it would hold some weight in the process. As for scripts and programs, nothing I have done to this point would I ever mention in an interview ha ha. I am just not to that level yet. &amp;#x200B; As far as degrees go are their some online programs that are known to be better, educationally, than others? (I might just turn to Google for this as well but thought I would ask.)
Dude,PLEASE use your GI Bill and get your degree. You will still get BAH and a book stipend. You will not regret it and that degree, coupled with your military experience, will open so many doors. Please, do not let your GI Bill go to waste. Source: 9 years Active Duty,USMC. BS in Comp Sci from a state school. If you have questions DM me. Too many of us do not take advantage of what we are offered and actually paid into!
These are called argument unpacking, and keyword argument unpacking. They're really handy! If you have a list of things (can also be a tuple or any other iterable), and a function which takes a number of arguments. You could index into the list, but that's lame, so you can unpack instead: ```python my_args = [1, 2, 3] def my_fn(a, b, c): return a + b + c # or whatever result1 = my_fn(my_args[0], my_args[1], my_args[2]) result2 = my_fn(*my_args) result1 == result2 # True ``` So in the format example, `.format(*xs)` is used instead of `.format(xs[0], xs[1], xs[2])`. The double star is used to unpack a `dict` (with string keys) into keyword arguments. ```python my_args = {"a": 1, "b": 2, "c": 3} result1 = my_fn(a=my_args["a"], b=my_args["b"], c=my_args["c"]) result2 = my_fn(**my_args) result1 == result2 # True ```
Hmm there is some counter argument here anlone the lines: What are the correct expectations we should assume someone has coming into a language? Seems that would depend on what languages they already know. Anyway I all know the real reason we all hate Perl: it's god damn ugly to look at! $#@perl!
If there is no problem with the installation then It’s probably a problem with pycharm 