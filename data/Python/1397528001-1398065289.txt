wxPython is a great choice - very solid and easy to use, great community. 
&gt; cipher = {} &gt; for keyline in keyFile: &gt; cipher[keyline.split()[0]] = keyline.split()[1] Thanks, But what is a different way to write the second for statement with the elif statements? 
Many thanks! This is exactly what I needed!
I like wx, and it is available on Python 3 via the Phoenix project -- until I learned of Phoenix, I stuck with 2 because of how much I liked (and how much my project was invested into) using wx. However, I've not used PyQt, so I can't compare to that. But wx is FAR better than tkinter. 
If it were possible to automate this, it would have already been done and 7 years ago everyone would have switched when Python 3.0 was released. Unfortunately the largest backwards-incompatible change in Python 3, deliberately, was to totally screw with people who had negligently ignored text encodings and blindly assumed UTF-8 everywhere - you cannot automate a fix for this as it impacts pretty much everything. Start here: https://docs.python.org/3/howto/pyporting.html You will first want to move everything to Python 2.7. Utilise `from __future__ import print_function, unicode_literals, division, absolute_import` to get Python-3 like behaviour for most things. Absolutely unit-test everything, this should be a given irrespective of what you're trying to do (migrate to python 3, add a feature, remove a feature, walk the dog, ...). Start migrating the codebase to using the generator paradigm (rather than passing huge lists around) - this can only be a good thing in the Python 2 world anyway. You want 2.7 for this so you get comprehensions for all the core types (lists, dict, set, etc). Python 2.6 or earlier doesn't cut the cheese. Modules like six and [python-future](http://python-future.org/) will also help supporting both Python 2 and Python 3 from the one codebase. Use them (ideally - pick one) Also, pick a package that already supports both from the one codebase and understand what they did, for example check out [bottlepy](http://bottlepy.org) - the author is a redditor here - this was one of the first to just get on with the job and not whine about it. I don't recommend trying to understand Django ;) but I'm sure others here could give some more reasonable examples of other code. Pick stuff in the general genre to your own code, for example bottlepy won't cover the change to division (which you need to comprehend before blindly doing `from __future__ import division`) if correct maths is important to you ;) Once you cover off the big unicode changes, you'll find pretty much everything else falls into place. The rule is, decode and encode on your I/O endpoints (don't just splatter it around the codebase). You _will_ have a lot of "fun" if you need a poorly-spec'd protocol like HTTP - what kind of idiot makes a standard that says "maybe depend on user-supplied information to correctly decode this data, which can change in the middle of the data"? (answer: the w3c). My recommendation is to use requests or similar which is Python 3 compatible and already solved this issue for you. Note there is a clear distinction between text and binary data now - in Python 2 it was hinted but in Python 3 its enforced - this means if your Python 2 code didn't take the hint you're likely to have the kind of issues other people who didn't take the hint whinge about. Treat bytes as bytes and strings as strings and you'll have no problems. The previous rule ((de|en)code at I/O endpoints) always applies. 
&gt; I disagree and I have been programming Twisted for many many years. I know how it feels to know where your code yields and how it feels when I don't explicitly mark it as such. (Yes you can write Twisted as a series of yields instead of a chain of actual functions. Oh and by the way Twisted has semaphores and locks, and yes you do need them sometimes, and not, not just for resource pool!) &gt; &gt; So my verdict is it dies not pay. What pays? Clear. Obvious. Business Code. The actual thing you are trying to do " Step 1. Get customer cart ID, Step 2. Get cart object from database. Step 3. Update cart. Step 4. Return result". &gt; &gt; Notice no yields, no deferreds, not switching through 5 different errback and callback chains. Does my use care my database driver needs a yield or a deferred. Oh, what if your database driver is written in Twisted and your cache layer drive is for Pyramid, or Tornado, or asyncio. &gt; &gt; Those are horrible horrible things to have in a large code base. Sure toy examples of "hey checkout my toy key value store" work great for showing a yield or callback based thing, large code base starts to accumulate that cruft and it becomes ugly. I can't quite tell what you're saying.
I think [python-modernize](https://github.com/mitsuhiko/python-modernize) is exactly what you're looking for technically - it automatically updates Python 2 code to use `six`. Use it from [this PR](https://github.com/mitsuhiko/python-modernize/pull/5) to fix a long standing problem. Good test coverage will be very important - if the library doesn't already have tests, then writing some is probably a good thing for maintaining the code anyway, even if it doesn't get ported to Python 3. If the code is important to the company, you might ask to set up a buildbot to run the tests automatically. This is best practices for any non-trivial code that's important to a business.
I think there is a gnuplot module... but you really should just analyze your data in python with numpy or whatever and then save to a regular text file. Then you can just do gnuplot&gt;plot "my_file.txt" using 1:2 much easier most of the time. Also gnuplot has svg output too...
python3 is easy to learn. easier than python 2. also, some of the defaults in python 2 that lead to bad code or just plain confusion, have been reworked to work the right way by default in python3. (most notably the way strings work now) also stuff that no one really should have been using in python 2 to begin with were outright removed from 3, making it impossible to make those mistakes. 
My guess is that you are looking for this: def populate(table, rows); for row in rows: table.insert(**table._filter_fields(row)) Please bring this up on the web2py google group. we can help more there. 
Thank you Ligthtinigsmith. Just downloaded Pycharm. In the university I wanted to be coder but found it extremely hard and frustrating so i abandoned codding and went into economics. I did visual C++ but i really struggled with it. Now my master thesis require some data analysis and thats why i have to learn Python. 
noting for future use :) 
They don't have specific rap artists though.
They have all the ones on the data presented.
declarative GUI's with [enaml](https://github.com/nucleic/enaml) ( think pythonic QML on steroids ) is an amazingly powerful approach. DSL's FTW!
Thank you. Got it working with SVG.
I'll be interested in knowing, since you're re-writing in Python, are you using Python 3 or 2.7 and what are the performance implications, compared to C++?
I finally got it working with SVG. Thank you.
I think that we have an underreporting of these code bases in our community because the Python open source community is pushing the Python 3 propaganda so hard. Everybody is told to buck up and just port. Then when you scratch beneath the surface often you find a code base that "Oh, no, of course I wouldn't want to port *that*"! Those writing code on these apps are often not as engaged with our public Python community, and if they are, they might not appreciate being told to put up and shut up, repeatedly, as much as I do. I described the gravity that Python 2 exerts on our community before. While Python 3 usage is going up, yesterday I saw download statistics for Flask and Sphinx that shows that this year it's been downloaded twice as much for Python 2.6 than it is for all versions of Python 3 combined. Some organizations will make a budget and a plan for an upgrade as tough and as much at the bottom of the stack as the programming language itself. Some won't. Many will put it off, as we've seen already. This causes new Python 2 code to be written, and it forces people to continue to write Python 2 compatible code. I don't want our community to be in that miserable split state for an indefinite period. There is a lot of understandable historical revisionism about how this was the plan all along, but the EOL date of Python 2.7 being in 2015 shows how revisionist this really is. So I speak up about a risk I see and possible solutions. I'm saying stuff you don't agree with, but more so, stuff you just don't want to hear as you think talking about this problem is actively working against the solution. So you tell me to shut up. Thanks, I will again, for a while, as I can't keep this up for long. 
Is there any reasons videos are all unlisted? Going by title/description about things that are of interesting is good, but I also like being able to sort by views, as that sometimes get you some unexpectedly awesome talks. Sometimes, a less interesting subject can become orders of magnitude cooler when presented by an awesome speaker. EDIT: Ugh, I was gonna write a script to do it with python, but Youtube's API is such a pain in the butt. EDIT2: Nvm I was being stupid, there we go: http://paste2.org/U9Av00mh http://paste2.org/JZJ587LL 
 &gt;&gt; op is sweet true
pop() returns the list entry it has removed? I learn something new every day :)
Question: why use things like `vars(submission)["name"]` instead of `submission.name`?
Yes.
3:36 "Today I made the choice only to take questions from women in the audience."
I was curious how the cake would actually be distributed: class Friend: def __init__(self, name): self.name = name def eat(self, what): print("Friend %s eating %s" % (self.name, what)) class Cake(list): def __init__(self, pieces): self.extend([Slice(i) for i in range(pieces)]) class Slice: def __init__(self, num): self.num = num def __repr__(self): return "slice " + str(self.num) friends = [Friend("Gabe"), Friend("Jeff"), Friend("Rupert"), Friend("Linus")] cake = Cake(5) for i, friend in enumerate(friends): friend.eat(cake[i::len(friends)]) Output: Friend Gabe eating [slice 0, slice 4] Friend Jeff eating [slice 1] Friend Rupert eating [slice 2] Friend Linus eating [slice 3]
Their only option? Python 2.7 is open source software... 
hahahahahahahaha
~~That's the way PRAW recommends to retrieve variables such as that.~~ I was wrong. I just fixed it.
I would be interested, in fact, part of why I started coding was to develop some apps for the Android platform. Where I got hungup, is when I switched from Java (for various reasons) to Python and I've been trying to figure out how best to correct this, so this is very interesting to me. Is there anything I should know that I won't find by following the links? I don't know about the contest as I'm still fairly new but I'm interested in knowing more.
Count me in! I was impressed by Kivy in my recent adventure in game development with Kivy. I blog about it [here](http://pythonthusiast.pythonblogs.com/230_pythonthusiast/categories/403_game_development.html)!
But mah GIL!
An alternative: http://charlesleifer.com/blog/using-python-and-k-means-to-find-the-dominant-colors-in-images/
This works as long you are the first friend on the friend list :)
There is also a PyCon 2014 talk about that very subject, and how to update your code so it will run on Python 2 and Python 3. [By Your Bootstraps: Porting Your Application to Python3](http://pyvideo.org/video/2626/by-your-bootstraps-porting-your-application-to-p)
Look into queue data structures. Then push and pop should seem a lot more useful. 
You should probably throw a metaclass in there to be safe.
Thank you!
What does [i::len(friends)] do?
Your code after line 8 will never get executed - you are either returning static_app() in line 6 or returning an error in line 8. Probably you wrote lines 1-8 first and later expanded by adding the lines 11-31. Deleting the else clause lines 7-8 should fix the error. Alternatively add start_response([...]) between line 7 and 8 - but this is probably not what you want.
As I was about to read this I figured that out as well!! Haha, thank you so much.
Glad you liked it
Shhhhh! Pay no attention to the GIL behind the curtain. We can still use the multiprocessing library.
I had forgotten the contest completely, but now I'll look into it again. Will definitely look at your engine and see if it's the right thing for me.
Being able to tell what can happen when from reading some code is a very good thing. Making two things that are not the same look the same isn't a good thing.
2.7 as I checked to see what most other people were using combined with certain needed libraries basically saying that I could use their 3.x version "at my own risk". Unicode is not a concern. Performance is interesting. My machine is a complete beast so for many operations the Python might be an order of magnitude or more slower but it is all still in the blink of an eye. But there is one part which was OpenCL in the C++ and it is still OpenCL in the Python. So in that way I am programming in C. The two key philosophies in my choice are: I am now programming 4-5 times faster so wow. Plus machines are getting faster all the time, so I am now getting C++ speeds of a few years ago which were acceptable then and will be even more acceptable as time marches on. Also as stated above, I can still optimize in C or C++ as needed. Plus as a new Python programmer I am probably not optimizing that well. I am using Numpy so that speeds things along in places. But I assume that my Python code will get better and better over the years. Some programmer had a quote about premature optimization being the root of all evil. I realized that C++ itself was premature optimization. The most interesting Python I might be soon doing is that I switched iOS and android app development over to C++ from Objective-C (no android) using cocos2d-x. This is very nice. But now I have discovered a new library/SDK called Kivy which allows Python iOS/Android development. It is fairly new and I have been punching it in the face to get it to work. But it shows much promise. If that works then I will even switch iOS and Android development to Python. The switch to mobile Python development is quite critical as right now I have Apps where the server must calculate the same things as the Mobile device both in user data and in crypto libraries. So I use the exact same code in C++ on both ends to make sure that it is 100% in sync. This means that having my server and my mobile clients in the same language would be a huge convenience. But the python development speed up is fantastic. I literally have done on Monday what I normally would have been happy to do in a week. The code is cleaner. The code is smaller. Plus a typical slowdown in C++ would be installing, testing, and then implementing some new library. In Python there is pip and I'm pretty much done. Also even though my machine is a beast it was not uncommon that I would make a change to some core header file which would cause the compile to still take a number of seconds. With python the startup is basically instantaneous. This is key not only as a minor time saver but because I don't lose my train of thought. I might only need to see the code run and pop up some number in the trace and go right back to coding. I now see Python and C++ as the only two primary programming languages I am going to use for years (with SQL and Javascript in tow). 
I'd hold on to a slice factory.
I think you convinently forgot about the first mantra *Beautiful is better than ugly* and also the third one *Simple is better than complex* Do you care if your CPU switches contexts? Do you care if you send an HTTP response how many TCP packets are sent out? Maybe you should sometimes, but usually when you write a large applications, top layers shouldn't care if your socket of some utility library down below needs to yield or not. &gt; in other systems the points where you need to sync could be numerous. If you have separate execution contexts (either green threads like I do but even chains of callbacks) you still need to synchronize and not share data between them. If a system gets large enough with every other line being a yield well then you don't gain much. You've just sprinkled yields all through your code. The thing is small code-bases look ok with that. Toy and demo examples looks very nice. Large code bases don't. (Yes even Twisted has a DeferredSemaphores, just because you use have callback functions doesn't mean synchronization issue go away).
;D https://github.com/AnirudhBhat/FBNotify.py/commit/62f0dd0a4f8eb753e754340fb975f8df02f12817
i don't see any mention of country or region restrictions so i guess it's international, right?
Can you tell when CPU switches contexts from reading your code? How about when there is a cache miss (because in some cases that will kill your performance)? Do you use TCP_CORK to know much data gets packed in your TCP packets before they fly out. Ok, maybe you do care about what happens. But in most cases, in an application with many layers, does the top layer always needs to know of some utility lower level socket decided to yield (which you now have to percolate through the API all the way to the top).
Absolutely, and there are already entries from many different countries.
So let me understand this query = ("SELECT uid, name FROM user WHERE online_presence IN ('active', 'idle') AND uid IN (SELECT uid2 FROM friend WHERE uid1 = me())") Are you allowed to run SQL queries against fb databases?
I've been meaning to learn Kivy. Might as well start now!
The future project also has modernization scripts available so that's alternative. Curious to hear how this porting project goes for you later!
... this quiz sucks. Seriously, I got 2/6 and was above 60%? What did the other 3 people get? One answer right? No answers right? I'm going to make my own python quiz and post it here.
2/6, got 58%
&gt; propaganda I'm sorry, but you can't expect to be taken seriously. Core Python devs who freely donate their time have spoken. If you're upset with that, you're going to need to convince them first. But I'm uncertain your gravitas will impress them into changing their opinion.
&gt; Are you allowed to run SQL queries against fb databases? Nope. But you can run FQL queries: https://developers.facebook.com/docs/technical-guides/fql/
Looks like someone is going to be reading about the ``--force`` option to ``git push``.
I think this 60% also consider people who skip questions, must be fixed, totally agree.
Can someone who have more exp in the gui app field explain the main diffreneces between the most used gui tools in python, and is kivy something that would be good for a beginner? 
And you simply *must* shoehorn the descriptor protocol in somewhere.
You're right, silly questions. The last one was something like `(2 or 3) * (5 and 7)`. Whoever writes that code needs to be dragged outside the barn and shot. Stupid. The only valid-ish one was the class inheritance one, and I should expect you'd not intentionally ever write code like that, anyways. And, seriously. `1 == True` and `1 is True`? Why would you write that?
Am I missing something or are you downloading each resource twice? Wouldn't calling `urlopen` ([link to code here](https://gist.github.com/kmonsoor/10727871#file-threaded_rss_download-py-L88)) effectively download the entire file?
&gt; and is kivy something that would be good for a beginner I don't see why not. As a toolkit, I think Kivy is nicely pythonic and easy to learn, and it's cool to be able to run your applications on android etc.. Disclaimer: I am a Kivy core developer, and undoubtedly biased, but I hope this general statement is not controversial! I would say that if you're a beginner to programming itself, it's probably worth spending a little time on non-gui projects before branching out in that direction. That's not because you can't, it's absolutely possible (and this is just my opinion anyway!), but I think gui toolkits are a good example of the type of larger framework that tends to implicitly use more advanced python features and behaviours, which can make it hard to really understand what's happening if you're new to the language constructs as well. Don't let that put you off, it's not because any of these frameworks are actually hard to learn, just that it might be a lot to take in if you jump straight into them. For the more general comparison of toolkits, they all have different advantages and disadvantages, but I'm generally of the opinion that it doesn't matter that much what you learn. You can always pick up another later, as long as you remain aware of the limitations of your current choices and what the other ones could offer. Kivy in particular has the advantage of being cross platform both on desktop and mobile, as well as a nice syntax and good codebase. On the other hand, the main disadvantage people often perceive is probably that it tends not to look 'native' on any given system - e.g. if you have a desktop of qt applications like KDE on linux, the kivy app will not match themes with them. If this is important to you, kivy is not a good toolkit to use right now. There are other potential flaws with kivy, such as that it's a smaller and less popular project than something like pyqt so there can be less information online and fewer ways to get help, but kivy does have a great active developer community so I don't think this is a big problem in practice. The other toolkit I'd personally look at first would be one of the qt wrappers. Qt is a very popular framework with multiple good sets of python bindings that are popular and well supported, with one advantage that it *does* have a great integration with native systems including all the major desktop operating systems. There are plenty of other graphical tools for python, e.g. tkinter or wxwidgets, but I know a lot less about them. I'm sure other people can promote them as appropriate.
Good luck to you all! One day I'll be there 
Yes but did it _taste_ like Python?
Hi Audihoe! Yeah, I know I am asking how to do the same 500 "search terms" to extract daily data for 7 years. Since I have to manually type it every time and i want to somehow automate this procedure. 
Yeah I don't get the one about which runs fastest either. There are two choices that just assign generators. Both of them are equally fast. Creating a generator won't execute it so (i**2 for i in range(10000)) Is just as fast as (i**2 for i in xrange(10000)) Which is also just as fast as (i**2 for i in range(99999999))
Oh, I love this. It's like commit history didn't exist. :D
That color scheme....
Nice one! I send you a small pull request fixing some stuff, e.g., that the friends_old list is fetched every 30 cycles, instead of only 1 time at the 30th cycle, and other stuff like replacing the lists by hashable sets for efficiency :)
Really really awesome! - hope you won't get an IndexError :).
These aren't examples of code that you'd have to deal with. They're questions to expose your knowledge of python. 1) is "Are you aware of the zen?" 2) is "Do you know about the method resolution order of classes?" 3) is "Are you aware that bools subclass ints?" 4) is "Generators vs Lists" and "Memory allocation is costly" 5) is "Do you know tuples are created by the ',' operator, and not by brackets?" 6) is "Do you understand code like this?" foo = (a == 5) and x or y which is a 2.4 era version of this: foo = x if a == 5 else y In my book these are all reasonable questions, except possibly the first one. I got 3 and 5 wrong, but I should have gotten 5. 4/6 is better than 86% apparently. 5/6 only ups that to 91%. Most must be getting really poor scores.
The creation of the generator will be just as quick, but when you get the first value the 'range' version will allocate a list of 10,000 integers. The 'xrange' version will just return 1 integer each time, because it too is a generator. Of course, python 3 changes this.
Just an FYI, Kivy can run on Python3 on Linux, OSX, and Windows, but not on Android or iOS.
I think the questions are actually good at revealing knowledge of some intermediate level concepts. I'm not sure I'd use it as an absolute filter, but I'd want candidates to at least know why I'm asking the question. Probably better to do in person.
Eating cake is an I/O operation (let's focus on the I, shall we?) so the GIL is far less troublesome.
welp, back to 2.7 then, thanks for the info.
Some of the questions, your reason is spot on, and I'll walk back my vitriol. If the candidate knew _why_ the class inheritance example was important, that's got to say something. But the one that was `(2 or 3) * (5 and 7)`? Why could that ever be important?
It doesn't do that in C++. [queue::pop](http://www.cplusplus.com/reference/queue/queue/pop/)
you committed backup (~) files to your repository.
Because at some point it is likely you will be having to maintain/debug someone else's shitty code.
I added this in the merge-pull request, and updated the .gitignore accordingly 
I'm trying to run it on Python 3 in OSX right now and it keeps telling me I need 2.7 (and works under 2.7) is there a step I'm missing after install? kivy -h doesn't seem to list any special flags for running Python 3
Ooh, psuedocode! Yum!
Thanks for a detailed reply, i have been watching some talks from pyvideo about kivy and so far im very intrested in with what i see. Im not new to programming, but new to desktop apps, as i come from a web development background. So i will def going to try kivy out, it looks like a awesome tool. 
Syntax error line 3: unrecognized token "Good"
Served first and last, as a true king.
&gt;Your score is 6 /6 Guru &gt; &gt;WOW, you have beaten 97% players! If only real job interviews were this easy...
Thank you! I posted there: did it show up yet?
None of the provided multiple choice answers are correct. It does not print (only) the consonants from the phrase. It prints all the non-vowels (including space characters).
Kivy on osx uses the system provided python, that's why the package for osx is compiled for 2.7. If you want to use kivy with your own version of python then you should compile kivy and it's deps for python3. This would including compiling kivy deps including pygame from git. Then goto your kivy clone and .. python3 setup.py build_ext --inplace Then setup paths for kivy and it's dep, if you install the deps system wide for python 3 then you can skip this step. You can open kivy script to see how it sets up path for itself and it's deps and do the same for your install. 
I tried to run the code, but I got this error: Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: 'NoneType' object is not iterable :(
We'll need a test suite with full checking for edge cases (because I love the edge pieces)
Ahmen to this. Enaml uses a performant observer-framework called Atom. Atom is awesome in its own right (but it needs more docs). One selling point for Enaml: it can embed matplotlib figures out-the-box. If you want something matlab-like-only-loads-better, this is it. Of all the toolkits, Qt is the only one with decent widget style control and Enaml exploits this with a wonderful stylesheet implementation. BC
I thought this was going to be a script for the Disney movie, "Frozen". :-(
Just as a bit of explanation, this is likely for exception safety reasons. If pop returned the element and the copy constructor throws then the item has been removed from the container, but is lost when the exception occurs. By separating front() and pop(), the user must create the copy (and deal with any exceptions) before popping it.
Pandas, Pandas, Pandas, Pandas. Also Pandas.
Besides finding where its freezing and fixing that? write a wrapping bash script to send a SIGINT or some such every $TIMEOUT and restart it in a while-loop. I feel bad because I have done just this before...
&gt; does it really make things better/simpler? No, not at all. The two functions are completely identical as far as Python is concerned. This is merely a question of style, and the canonical style guide for Python ([PEP8](http://legacy.python.org/dev/peps/pep-0008/)) specifically calls for using a `def` statement here: &gt; Always use a def statement instead of an assignment statement that binds a lambda expression directly to a name. The paragraph you quoted is 100% horseshit, irrelevant bloviations from someone you should ignore. The `lambda` expression does have its uses, generally when providing a callback for something: foo.sort(key=lambda item: item[0]) However, that example would be better written with the `itemgetter` from the `operator` module: from operator import itemgetter ... foo.sort(key=itemgetter(0)) This is significantly more efficient. 
I have even used it :)
That's what I thought. As I was reading what the dude was saying, it came off as a personal justification using technically accurate definitions. While "correct", it doesn't mean it's "best" or even "good". And as I read on StackEx, "Iambdas can be convenient sometimes, but usually are convenient at the expense of readibility." As a point of complete irrelevance to the conversation i'd like to point out that "horseshit" is much more fun to say than "bullshit". It makes anything sound old-man crotchety. Further conjugating to say "shat" is more fun than just saying "shit". "Smells like someone shat." 
A small note on terminology. Your implementation is in fact using multiple processes and not multiple threads. So calling it "threaded" might be a bit misleading. :)
This is what asyncio was built for baby.
That's a good one, thanks!
`urllib2.urlopen(url)` makes a GET request to the given `url`. You can confirm this by copying and pasting the following into a Python shell: import urllib2 url = 'http://www.example.com/' req = urllib2.urlopen(url) print req req_info = req.info() print req_info print req.info().getheaders("Content-Length")[0] resp = req.read() print resp You should get: &gt;&gt;&gt; &gt;&gt;&gt; import urllib2 &gt;&gt;&gt; url = 'http://www.example.com/' &gt;&gt;&gt; req = urllib2.urlopen(url) &gt;&gt;&gt; print req &lt;addinfourl at 4301474128 whose fp = &lt;socket._fileobject object at 0x1004a83d0&gt;&gt; &gt;&gt;&gt; req_info = req.info() &gt;&gt;&gt; print req_info Accept-Ranges: bytes Cache-Control: max-age=604800 Content-Type: text/html Date: Tue, 15 Apr 2014 21:23:25 GMT Etag: "359670651" Expires: Tue, 22 Apr 2014 21:23:25 GMT Last-Modified: Fri, 09 Aug 2013 23:54:35 GMT Server: ECS (ewr/1584) X-Cache: HIT x-ec-custom-error: 1 Content-Length: 1270 Connection: close &gt;&gt;&gt; print req.info().getheaders("Content-Length")[0] 1270 &gt;&gt;&gt; resp = req.read() &gt;&gt;&gt; print resp &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Example Domain&lt;/title&gt; … snip … &lt;/html&gt; &gt;&gt;&gt; **Clarification** I should add that `urlopen` will not save the downloaded content as a file on the local machine. But it will be downloaded nonetheless. To avoid multiple hits to the same URL I would get rid of those lines. Suggested rewrite: try: print "Starting: "+ str(single_download) g = URLGrabber(reget='simple', retry=default_retry, timeout=default_timeout, proxies=default_proxy) response = g.urlgrab(single_download) print "Completed: "+ response except URLGrabError as ue: print str(ue) + "\nskipping: " + single_download I don't think knowing the target document's file size is worth downloading the same URL twice.
Yes it is... but that he is a she haha [The Receiver of the cake](http://i.imgur.com/MsbAY49)
Django is not the core project; Reddit itself uses Pyramid, not Django.
This explains nicely a concept that sometimes confuses people coming from a C background: http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables
Indeed, that's probably the most intuitive explanation someone can come up with! Thank you for this gem, I will add it as a reference!
Kivy is a young project and we are slowly collecting more learning materials, but right now I think many people find it difficult to jump from the initial pong and touch tracer demos in the docs to building applications. Make sure to check out if you are looking for more learning materials [the wiki](https://github.com/kivy/kivy/wiki/Talks-and-tutorials) in particular inclement's youtube series. Also, people tend to trip themselves up by resisting the use of the .kv language as it involves learning a new syntax and so on. Dive in as soon as possible with the .kv language. It makes a significant number of tasks and constructions way easier. Finally stop by the #kivy channel on freenode irc if you need any help. We are most active in European times I think, but there is more and more of a skeleton crew keeping things going 24/7. 
Oh hey and these are actually some tricky points rather than the absolute basics that are usually covered in these type of lists. Thanks!
I think 6 is really asking if you know how boolean operators work in Python. 6/6 is better than 97%.
Python isn't pass-by-reference. It's specific to the type. Ints, floats, strings, and tuples are pass-by-value. Lists, dictionaries, and classes are pass-by-reference.
SWIG is pretty terrible. The nice thing for wrapping C libraries these days is [cffi](https://pypi.python.org/pypi/cffi).
&gt; Alright now here's another solution by a prolific user of the site. Staff or not, I don't know, He is not staff.
&gt;Python will create the mutable object (default parameter) only the first time the function is called, see the following code: Doesn't Python create the mutable object when the function is defined, rather than when it's called for the first time?
Yes.
Tuples are immutable, but they can contain mutable objects. `a = ([],)` `a[0].append(2)` will work. `a[0] += [2]` will not work, because it basically does: * `a[0] = a[0].__iadd__([2])` if the type of `a[0]` has an `__iadd__` method, or * `a[0] = a[0] + [2]` otherwise. In this case, the type of `a[0]` is `list` and it *does* have an `__iadd__` method. However, both of these are trying to assign something to the inside of a tuple, so they would both fail.
While it would be nice if I had some finished, example games ready to go to help instill confidence; I fail to see how screenshots would do anything but educate you on the quality of my art. I will have such content coming in the next few months, but I've prioritized documentation and performance of the engine, as there is an increasing number of Kivy users running into performance problems that KivEnt addresses.
No. It's [pass-by-object-identity (aka pass-by-sharing aka...)](https://en.wikipedia.org/wiki/Pass-by-reference#Call_by_sharing) and it is the same for all types. See, for example, [my write-up](https://dl.dropboxusercontent.com/u/2000007/namesvalues/namesvalues.html). Other people have written similar write-ups, which you might find in this subreddit, but I can't find them right now. It's also about Lua, but Python works the same way.
Hiya, Use the -e flag to install from github with pip: $ pip install -e git+https://github.com/the-user/the-repo-name#egg=the-package-name More info here: http://pip.readthedocs.org/en/latest/reference/pip_install.html#vcs-support EDIT: My workflow with that flag: $ cd your-work-directory $ virtualenv venv $ source venv/bin/activate $ pip install -e git+https://github.com/the-user/the-repo-name#egg=the-package-name Now, the module's code you just fetched on github lives under the *venv/src/your-module* folder. It includes the *.git* folder and you can hack away now :) 
I think the important distinction here is that numbers, strings and tuples are immutable objects. You can think of it as pass-by-object-reference, but since you are passing a reference to an immutable object all a function can do create a binding of the same name in its local namespace and assign a new value to it. While this has some of the same side effects as pass-by-value, it is not the same.
Thanks, you are right, that was a bad choice of words, I rephrased it a now! Tuples are just such a tricky thing for Python newcomers. E.g., one could thing that they are not immutable: my_tup = (1,) my_tup += (4,) my_tup = my_tup + (5,) print(my_tup) # prints: (1, 4, 5) But what actually happens is that a new object is created every time: my_tup = (1,) print(id(my_tup)) my_tup += (4,) print(id(my_tup)) my_tup = my_tup + (5,) print(id(my_tup)) #prints: #4337381840 #4357415496 #4357289952
Thanks for the catch!
Tkinter tastes great and is less filling. Tkinter is the true path - all others are false paths. Tkinter is the standard gui toolkit. Above all - tkinter is easy enough to learn alongside any other toolkit.
Thanks. And its that pip-installed code that I should be editing? I don't quite understand. Perhaps I should clarify... should I do a pip install and do a github check out? That is, use the github download as my working directory and then use the compiled modules from git.
Pip actually does a *git clone* if I understand it well and also resolves any dependencies your module may have. Just check under the *venv/src/* for your module's folder.
Window's environmental variables set in the cmd.exe window only exist as long as the cmd window is open. Right Click on My Computer-&gt; Properties -&gt; Advanced System Settings Click Environmental Variables and then add your python path to the path variable. Separate values in the path with a ; [Help](http://www.computerhope.com/issues/ch000549.htm)
When you set an environment variable in a command window (or powershell window), it exists only in that window, or for any programs spawned from that window. That's because each process inherits a copy of the environment from the process that spawned it, and the top level process gets its copy from the master environment in the registry. So the thing that spawned your command window (probably Explorer) doesn't know about that variable at all. To make your setting persistent, you need to set it through the System control panel, advanced settings, environment variables. Then restart your computer, or log off and back on, or launch a new command window from Task Manager via Ctrl+Shift+Esc. See [How to Use Environment Variables in Windows XP](http://best-windows.vlaurie.com/environment-variables.html) for some more explanation. Also try the SETX command, to make changes directly in the master environment in the registry. Its syntax is slightly different from SET. Enter "setx /?" for more info. Finally, you should always set the path using this type of assignment: set path=%path%;c:\newfolder or setx path "%path%;c:\newfolder" These versions append a folder to the path. What your command does is to completely replace everything in the path with your one folder.
I'm quite a fan of kivy and I would love to help the community in any way that I can. I am planning to build something game like, so I would be interested. 
It's for an assignment and I'm using WSGI. 
Look at your code and follow the route for the CSS file. It doesnt have a route for that file. It looks like you meant to point it to /static/... As others have said, I suggest you look at a python web framework like pyramid, flask, or django.
Thank you so much, it worked perfectly :) 
&gt; /static/ So am I meant to just (in the html,) change the directory to '/static/style.css' ? Or do I have to do something else within the python? I do get this message however; 127.0.0.1 - - [16/Apr/2014 12:09:47] "GET style.css HTTP/1.1" 200 437
never told you to "shut up" or anything like that. I'm asking for specifics. I've ported lots of stuff to py3k and I don't really see what the problem is, haven't talked to anyone with huge 2.X in house codebases that really need to move. Haven't "scratched beneath the surface" as you have, am asking for a real case. We'll find your client that has a problem and we'll help them. There's no "shut up" in there, quite the opposite.
Just changing the HTML should work for now as long as the "style.css" file lives in a "static" directory. See line 118, 119, and 122 of your pastebin. The path in the static URL is being replaced with a local filesystem path. Think of it this way: Everything being shown in the browser must be downloaded from the server. Each of these downloads is specified as a route/URL. Everything served lives on the server's filesystem or in the python. It is the job of the web application to map these URL requests to data on the server. So when the index.html webpage references "style.css" it is requesting this file from the server. The server doesn't have a route for "style.css". If it was requesting "/static/style.css" (note the first slash meaning the root of the server) then the server knows what to respond with. In this case it would be the content of the "static/style.css" file. Hope that helps.
And about the HTML variables not working. It looks like you aren't calling the "render" function in the content you return in the "if" statement starting line 94 of your pastebin.
 I am trying &lt;link rel="stylesheet" type="text/css" href='/static/style.css'&gt; But it's not working. :/ I understand what you're saying but I can't implement it for some reason. :/ Sorry for being really noob like haha. Edit: Yes the CSS is located in the static directory. I have images working now as well so I am not sure as to why the CSS still doesn't work. However, I don't have the HTML pages in the static folder which imo, shouldn't be an issue?
Re "About lambda and closures-in-a-loop pitfall" It's not that the last lambda is being re-used, it's that the `i` in the lambda only gets dereferenced when the call is happening. Since you've already gone through the list generation, at that point i is set to 4. You can see this by doing my_list = [lambda: i for i in range(5)] i = 25 for l in my_list: print(l()) So in this case it really is just about scope. The iterators version works because the generator comprehension forms it's own scope because of some trickiness as to how they are implemented.
Forgive the obvious, but why on Earth would you write all of that using lambdas? Is it for interpreter efficiency?
[names](http://nedbatchelder.com/text/names.html) is another
&gt; If both values of in a or expression are True, Python will select the first one, and the second one in and expressions I think it's easier to think of it as a or b == a if a else b a and b == b if a else a It works as expected with bools, but gets kind of screwy when you use other data types. Still clearer to use the ternary statement or an actual if statement than to use logical statements in non-logical ways.
In almost all cases, optimizers are created to give best results on idiomatic code. Writing everything in lambda expressions is very much not idiomatic code.
I'm pretty sure they'll be super excited to have some really good python on that cake. Seriously that's such fabulous slicing!
I am not even mad. That is impressive.
Thanks for sharing this.
If you are using None - explicitly test `if spam is None` instead of `if spam`. The whole midnight == False thing is the example here, but there are other cases too (I keep my hair real short so those types of bugs don't make me bald).
This is an IPython notebook, there is not much I can do about it right now (or can I?), but let's suggest it to the IPython devs :)
thank you. i understand your point. it is due to my shallow understanding between Python's multi-processing vs. multi-threading ... i need a lot more work in the area. i will update it soon
done. renamed to "parallel_rss..." :)
r/learnpython
Ignore that person, what they write is complete nonsense. Lambda functions are simply syntactic sugar for conveniently defining functions. There is nothing else to it, no deep conceptual difference that makes lambda functions inherently better. &gt;&gt;&gt; f = lambda n: bin(number).count("1") &gt;&gt;&gt; &gt;&gt;&gt; def g(x): ... return bin(number).count("1") Both are `function` objects: &gt;&gt;&gt; f &lt;function &lt;lambda&gt; at 0x7f7d24cda7a0&gt; &gt;&gt;&gt; g &lt;function g at 0x7f7d230d8b00&gt; "&lt;lambda&gt;" is just an automatically assigned name. Both have the same attribute names: &gt;&gt;&gt; dir(f) == dir(g) True Both have the same byte code: &gt;&gt;&gt; import dis &gt;&gt;&gt; dis.dis(f) 1 0 LOAD_GLOBAL 0 (bin) 3 LOAD_GLOBAL 1 (number) 6 CALL_FUNCTION 1 (1 positional, 0 keyword pair) 9 LOAD_ATTR 2 (count) 12 LOAD_CONST 1 ('1') 15 CALL_FUNCTION 1 (1 positional, 0 keyword pair) 18 RETURN_VALUE &gt;&gt;&gt; dis.dis(g) 2 0 LOAD_GLOBAL 0 (bin) 3 LOAD_GLOBAL 1 (number) 6 CALL_FUNCTION 1 (1 positional, 0 keyword pair) 9 LOAD_ATTR 2 (count) 12 LOAD_CONST 1 ('1') 15 CALL_FUNCTION 1 (1 positional, 0 keyword pair) 18 RETURN_VALUE 
You could also do $ git clone https://github.com/the-user/the-repo-name $ cd the-repo-name $ virtualenv venv $ source venv/bin/activate $ pip install -e . Then you can edit your cloned source directly.
Twunnel3 is a port of [Twunnel, a HTTPS/SOCKS4/SOCKS5 tunnel for Twisted](https://pypi.python.org/pypi/twunnel).
I still don't get the point of writing shell scripts in Python...
I have noticed sleep blocking other threads before. It may hold the GIL. I solved it by writing my own sleep, roughly: while time.time() &lt; target: time.sleep(0.01)
I want to point out two things: 1. A bug: `return deepCopyList(inp)` in `simpleDeepCopy`: it returns a generator if the outermost object is a list. 2. For generality, you could make `deepCopyDict` a generator function too, hell it might even be a bit faster. Maybe. ^(Probably not)
 * context managers for environment variables and working directories * fabric makes it easy to ssh commands and parse the output * use boto to store/retrieve artifacts from aws * call parts of the code during the build/deployment process It would be nice if fabric didn't make a distinction between local and remote commands, so that all commands could be used local and remote.
python
Just if gevent and asyncio were compatible out of box? Lots of libraries will have asyncio support.. Idea that I had was take monkey patching approach, but plug it in asyncio event loop, that way we have easy compatibility with all other libraries. When I first discovered gevent, I was amazed about how nicely code reads, but I am still unsure if such implicit "coroutine" handling is better then explicitly using yield from. Thing is that I did not see any really big projects with "yield from sprinkled everywhere". Monkey patching feels a ugly and wrong. Implicit async calls are on first few looks easier to read, and also I have that "dirty" feeling about them a bit. Currently, I ~~think~~ have a feeling that "gevent/monkey patch/implicit" is better for "non IT enterprise company in house" projects, and "yield from sprinkled everywhere" is easier to read in "realtime systems". What I would like is to see code samples from projects like EVE Online written with different approaches to handling concurrency.
You told me you're tired of hemming and hawing. Here you're saying I haven't talked about my actual problems. Not only have I talked about problems, but I've attempted to propose solutions (that you don't agree with). I believe these problems are being reported by the few of us that actually are engaged enough with the community to bother to speak up about it in a climate rather hostile to it. I don't have an actual problem myself. I'll be fine, even if I end up writing JavaScript code. My customers don't have an actual problem either. They'll be okay one way or the other - it'll be relatively cheap to fund maintenance, and improvement of Python 2.x forever. It's the Python community that has an actual problem, and as I am in the Python community, it's a problem I share and would like to see resolved. The problem is one of indefinite transition with a risk of the language and its community splitting into two. I know that's your problem too, it's just we disagree about the solution or the speed in which this situation can be resolved. I believe that in 2020 the majority of Python development will still be done on Python 2.7, just like everybody now knows that 2015 was a rather unrealistic date to set for EOL. I hope I'm wrong. You think I'm wrong, but even if I'm right, alternatively you think it's okay to consign them into COBOL legacy land. I think that's bad for the community. I know you disagree on that. In fact I don't see an end to this. That worries me, and instead of just silently worrying I speak up and try to come up ways out of this mess. Concerning the business case for Python 3. Let's pretend I *want* to do the decidedly unproductive and uninteresting work of porting massive undertested applications (being worked on in 2014) to Python 3. Python developers generally don't, and here they're aligned with the people who pay them, because I don't see how I can sell my clients on that. I think they'd tell me to go away as soon as they saw the costs (too much), the risks (high), and the benefits (small). Anyway, I appreciate your feedback, but I want to end this conversation for now. I need to do some more thinking about this (I do appreciate your feedback on my concrete proposal), and I simply need time away from this problem again; I can only do this in small doses. In a few months I might write something more on this. See you on my blog. 
&gt; context managers for environment variables and working directories Split your shell scripts in multiple scripts, you get all of this. &gt; fabric makes it easy to ssh commands and parse the output ssh lets you remotly execute commands... what's the problem? 
I haven't benchmarked it, but I'll guarantee it's slower. The reason is that I had to wait on the scanner, and since I had no looping constructs to work with, recursion was the most obvious choice. But, pushing those stack frames is almost certainly worse than going through a while loop (as the [original](https://gist.github.com/adamnew123456/8908300)) Fun fact - since Python's stack depth is about 1k frames deep, and the code waits for 2 seconds each "iteration," the scanner would crash the interpreter with a stack overflow if it took 34 or so minutes to do the scan.
fabric is a little more than easy scripting of ssh commands. Ansible for deployments is better because the modules are largely idempotent. 
oh the hoops you will go through when your data is mutable. 
I'm certain that this is slower - see my response to minno - because of the fact that the entire program is one big function call. The original, idiomatic version is faster. This was originally an off-the-cuff "let's write some code today!" thing. I also wrote a primitive Python macro parser for the same reason. Unlike the macro parser, this worked (after a few hours of fixing syntax issues and decoding worthless tracebacks. Seriously, without proper line numbers, they are nowhere near as useful as they usually are).
Looks interesting, maybe I should switch to mobile vikings to support this :) But I don't like to use libraries that depend on twisted ... because if something goes wrong somewhere ...
Look to the sidebar at right. Find headings "Online books", "online exercises", "programming challenges", and "Asking Questions". Start clicking! :-)
This quiz is very unpythonic. Python is still great. Knowing tuples, MRO, list-comp vs gen-expr is good. (and only MRO example is ok). Some other stuff in there is totally opposite of what I consider pythonic. Even though I may know it, you wanting me to know it smells like terrible taste.. (I may be wrong, but I expected PYTHONIC quiz)
This is smart. I'll just save before sleeping!
High five :) For few moments I thought that I am stupid/wrong/crazy because of my viewpoint. 
&gt; E.g., one could think that they are not immutable: The exact thing goes for strings, ints and floats, so yeah, this is something that every newcomer needs to know. a = 1 a += 2 print(a) # *gasp*
Looks like you're right. urllib2 must make the initial connection and then start transferring chunks on `.read()`. So `urlopen` definitely makes the GET request, it just doesn't begin retrieving the rest of the content until you call `.read()` on the request. So it opens a socket but doesn't download the actual data. Just to note — the `info()` method is a red herring here. `urllib2.urlopen()` makes the initial request creating a object of type `addinfourl`. This can behave like a file object *and* has some additional methods like `info()` attached. Calling `.read()` on that returned object begins pulling in chunks of data from the remote server. I've always only used `urlopen` to pull in the actual request right away so did not realize this was the case. It does mean you're making two requests to the remote server, it's just in one of those cases you're not downloading the content. Would be interesting to do a tcdump to see what is happening under the hood.
&gt; Be aware of the consuming generator &gt; We can circumvent this problem by using a simple list, though: Two other solutions: #set comprehensions s = {i for i in range(5)} print('2 in s,', 2 in s) print('3 in s,', 3 in s) print('1 in s,', 1 in s) #range objects r = range(5) print('2 in r,', 2 in r) print('3 in r,', 3 in r) print('1 in r,', 1 in r) EDIT: &gt; List comprehensions are fast, but generators are faster!? Unless timeit or IPython is very very magical, that code doesn't do what it's supposed to do. `plainlist`, `listcompr`, `generator` and `generator_yield` don't seem to be called. In fact, the `test_*` functions aren't called either. I think you need this: def test(it): for i in it: pass %timeit test(plainlist()) %timeit test(listcompr()) %timeit test(generator()) %timeit test(generator_yield()) I get this result: 10 loops, best of 3: 26 ms per loop 10 loops, best of 3: 24.1 ms per loop 10 loops, best of 3: 23.8 ms per loop 10 loops, best of 3: 28.3 ms per loop
Meta criticism: [please use Gists the right way](https://gist.github.com/dAnjou/10875983).
have you solved? I am also stuck there...
Sorry, had some serious bug there... def generator_yield(n=100000): for i in range(n): if i % 5 == 0: yield i def test_generator_yield(generator_yield): for i in generator_yield(): pass print('\ngenerator_yield: ', end = '') %timeit test_generator_yield(generator_yield) Should work fine now I hope!
Hi Cookie, The code is two years old and Google trends continuously update their query. This does not work!
thanks! Which of the many urls.py you refer to? the one on lfs-installer looks like this: # django imports from django.conf import settings from django.conf.urls.defaults import * from django.contrib import admin admin.autodiscover() import os DIRNAME = os.path.dirname(__file__) handler500 = 'lfs.core.views.server_error' urlpatterns = patterns("", (r'', include('lfs.core.urls')), (r'^manage/', include('lfs.manage.urls')), ) urlpatterns += patterns("", (r'^reviews/', include('reviews.urls')), (r'^paypal/ipn/', include('paypal.standard.ipn.urls')), (r'^paypal/pdt/', include('paypal.standard.pdt.urls')), ) urlpatterns += patterns("", (r'^admin/', include(admin.site.urls)), (r'^media/(?P&lt;path&gt;.*)$', 'django.views.static.serve', {'document_root': os.path.join(DIRNAME, "media"), 'show_indexes': True }), ) 
So if the difference between a lambda and a def/function is near zero as far as python is concerned, why do I care to use a lambda instead of a function? I mean seriously, if I need a function it's usually for the reusability. If the reusability factor is eliminated, what's the purpose?
Check out the REPL. IPython's version is nicer.
yes ?
ease of use and maintainability. With that logic why use Python at all? Between C and Bash you can do anything that Python could do.
The two actually work really well together.
Sure.
Needs an abstractBaseCakeFriendBeanFactoryGenerator
:O
TIL nonlocal
as an ansible user, I have no need for fabric. 
The small integers are "between -5 and 256" [docs](https://docs.python.org/2/c-api/int.html#PyInt_FromLong)
Thanks, but no, I don't want to generate random data but calculate pdfs :)
I see... thanks. I will go with my function then and swap it once this scipy version is released ...
Oh now I see, this is LFS... Yeah, I could not get that to work... I started using [Oscar](http://tangentlabs.github.io/django-oscar/) and did not have any problems with that.
What are you writing GUI's *for*? Which platforms, what target audience, what kind of applications? IMHO PyQT/PySide is the most well-rounded solution, but there are cases where others are a better fit and PyQT's advantages are irrelevant.
You can also just grab the [source](https://github.com/scipy/scipy/blob/master/scipy/stats/_multivariate.py) off of github. I had this same problem so I just grabbed that file and imported it.
If you are willing to take the risk that more than 50% of your time maybe spent on marketing yourself, administration, failed projects and whatnot, instead of doing the job. Freelancing is not for everyone. Maybe you can look for a job or find another contracting firm with lower cut. One thing is sure, you won't be rich if you sell your working time. You should sell someone else's instead to achieve that.
yes (though keep in mind once you are truly independent, you have to pay: 100% of your SS/medicare tax, healthcare, possibly contractors insurance, administer your own 401K, negotiate contracts, get clients to pay, hire lawyers to harass/sue them when they don't, nobody sends you to conferences, every hour you're not billing is a loss) basically make sure you have a crapload saved up before you jump into that.
A leading double-underscore does **not** mean that the attribute is private, supposed to be private, or otherwise hidden: &gt; If your class is intended to be subclassed, and you have attributes that you do not want subclasses to use, consider naming them with double leading underscores and no trailing underscores. This invokes Python's name mangling algorithm, where the name of the class is mangled into the attribute name. This helps avoid attribute name collisions should subclasses inadvertently contain attributes with the same name. From [PEP8](http://www.python.org/dev/peps/pep-0008/). Example: class A: def __foo(self): print("A's __foo()") &gt;&gt;&gt;vars(A) {..., '_A__foo': &lt;function A.__foo at 0x7f05c3c9d0e0&gt;, ...} As you can see, Python automatically prepended the function name with _classname. This can be used to prevent subclasses from accidentally overriding methods: class B(A): def __foo(self): print("B's __foo()") &gt;&gt;&gt;a = A() &gt;&gt;&gt;a._A__foo() A's __foo() &gt;&gt;&gt;b = B() &gt;&gt;&gt;b._B__foo() B's __foo() &gt;&gt;&gt;b._A__foo() A's __foo() Name mangling only prevents accidental overriding. If you're evil you can do something like this: class WtfNo(A): def _A__foo(self): print("Why would you do this!?") &gt;&gt;&gt;c = WtfNo() &gt;&gt;&gt;c._A__foo() Why would you do this!? If you know Java, think of `__foo(self)` as Python's way of [declaring a method `final`](http://docs.oracle.com/javase/tutorial/java/IandI/final.html).
Can you even become a guru in any given computing language without learning like 5 of them?
Can you increase the amount of data you have in your dicts ? Does the memory difference increase linearly ?
Ok so I have a small case example. Allocating a dictionary of 1000000 elements. Pypy takes 103M vs 78M for CPython. Putting in 10x more elements (10000000), Pypy takes 782M vs 625M for CPython. So the differences stay consistent with the scaling. What does explain these differences ?
sqlite. It comes with Python, so it should already be on your machine.
Yes. But realize that you will still need to market yourself and negotiate sales and cover cashflow and write contracts and pay self-employment tax and etc. etc. etc.
I am not sure I follow this ? Does learning other languages help create a contrast between the languages, so the user will learn to emulate other language functionality that is not normally provided in the language of the programmers interest ?
Plural of "recipe" is "recipes", not "recipe's".
This same link is still on the /r/Python frontpage. I'm not totally against reposting things, but reposting within 14 hours? Really?
To properly use a tool, you have to know when to not use that tool. Python isn't the right choice for everything. If you treat it like it is, you'll be doing yourself and your clients a disservice.
I'd have to agree with that actually... You're more likely than not going to run into a mixed pipeline, for better or worse, and you're going to need to know how to get in there and work with it. I see too many people who learn one language and think it's the master language for every type of problem. Python can solve a lot of problems (well any turing complete language can solve any problem) but it's not going to be efficient or appropriate for certain performance required applications that are easy to implement in C or C++. Now, you don't have to take those contracts but you might find yourself in it when it's too late, but you might not even *recognize* python isn't the tool for the job. Also I see coders who know lots of variety in languages tend to try other approaches to problems that might be more appropriate, or cleaner. Functional vs OOP vs procedural etc. It's good to see someone with flexibility and the ability to follow suit with the style they are using, so they can maintain it themselves. I highly recommend learning a few other languages like C, java, and maybe something pure functional like Haskell or something new like golang. Learning includes working with other pros at the language, and maybe professional experience. Try to look at some open source and maybe submit a few patches, or better yet, get a job doing it along with Python.
No, it allows you to know when to use a alternative language. Python isn't the best language for every program. Just curious, but do you even understand the fundamentals programming? No offense to you. -Kat
Also, I'd not work towards "guru". "Guru" will find you. When other people who have coded in Python for years start to ask for help for the obscure stuff and call you an expert, then you're a "guru". You don't have to be a guru or amazing programmer to be a contractor. Just be good enough to be respected to get the job done.
Just wanted to chime in; I started learning Python about 6-7 months ago. I did some non-gui programming for the first 2-3 months and then I picked up tkinter. I developed a handful of very small desktop applications using the tkinter kit and I picked it up very quickly. I took a look at Kivy a couple times during that time and ran through the Pong tutorial. Overall it was daunting to me and I didn't think I was ready for Kivy just yet. After about another month or so I revisited the Kivy tutorial and it's examples and things just clicked. Looking back I don't find Kivy anymore difficult than tkinter was, the biggest hurdle for me was figuring out the link between the kv language and my python. [These videos](https://www.youtube.com/playlist?list=SPdNh1e1kmiPP4YApJm8ENK2yMlwF1_edq) we're extremely helpful in advancing my ability with Kivy in addition to the couple tutorials they have on their website and dedicating a good deal of time to pouring over their examples included with the download. Their docs are quite thorough and vast majority of my questions have been answered there even if I had to dig a little bit. That being said, the ability to write one application and have it (almost) be ready-to-use on a desktop and mobile platform is wonderful. Kivy is very powerful and has continued to add new and exciting features with each update, I'd highly recommend it if you're looking to get into python gui programming!
Kivy is an awesome product but it's a HUGE memory hog on Android. It runs great under Linux on a PC though. Does KivEnt address the massive memory overhead?
how about http://www.h5py.org/? 
It's adding a 3rd party module, but couldn't you just use SQLAlchemy to abstract it for you? [this answer](http://stackoverflow.com/questions/2047814/is-it-possible-to-store-python-class-objects-in-sqlite) on StackOverflow seems to be up your alley; but I might be missing something in your implementation that would make it difficult.
Hi, I remember playing with kivent a few months ago and would love to see how it fares now, but I can't get it to install this time around, and can't even remember what steps I followed the last time. Going for setup.py install gives only cython compile errors and I went through the readme but no use. Perhaps you could give some more detailed steps since I seem to be install challenged? :)
But when you are freelancer marketing yourself as "Python guru", won't the clients you take require you to write python? I'm not saying you will get lot of clients this way but if you really succeed marketing yourself well as python specialist those clients should be paying you more than for average gig so it will balance the lack of clients out. This is just theoretical, no idea about the viability (and I have my doubts as well.) Also if you use site like Elance you can send offers to only python jobs.
since you're new to python &amp; on windows, consider using http://pytools.codeplex.com - the debugging, intellisense, REPL editing, etc. features will help you.
Am I wrong to assume that Pypy should be more efficient in terms of memory management and speed ?
Often times the client won't know what tool is best for a job, and will either take something they read that said 'Python is the hip new technology!' or hire a 'consultant' to look at their design and recommend a tech stack and then attempt to satisfy it. Part of being a tech focused contractor is being able to assess a design a client wants implemented and saying 'this is not a good fit for X technology'. I've seen this happen a bunch of times, and it's the reason you wind up with some site being built in the completely wrong technology.
Well if the jobs pay well he can always refuse? And if product gets delivered and you get paid, why should you care? They asked for python, they got python. I really don't have much experience in this sort of thing so these might be stupid questions.
Excellent, thank you kindly! I'm not afraid of jumping in by any means, already loading up everything I need that I've read in the docs. Everything looks to be exactly what I needed. The one issue I am having so far, and maybe you can help (I have and am using the available tuts/wiki so maybe I just haven't gotten there yet...) I downloaded Kivy, dropped it in my applications folder (OSx). Ran the initial test app and nothing. I think it's a directory issue, but as I'm still not 100% setup yet I don't know. I just downloaded Cython and need to get that installed. I have Pygame going. I guess overall, I'm struggling with how/where all these need to be so I can have all my projects where they need to be and all the different software functioning and cooperating. Right now I run all my Python scripts from the Documents folder. I would like to make things a little more organized and this is a growing pain I guess I'm having. I know it's pretty much a newb issue. If you have any insight to that, that would be awesome, if not, no worries I'll just keep at it and continue on my path and stop by the IRC. 
No. You need to have a good CS background first, and knowing several completely different languages, even exotic ones, definitely helps.
&gt; Basically cutting out the contracting firm that takes over 50% of your hourly wage ? And then spending only half the time on earning twice as much money per hour because you need to market yourself? Why?
logstah -&gt; elasticsearch -&gt; kibana analytics, query, can handle a lot of load/data and comes in a flat jar http://logstash.net/
Sweet, thanks!
Of course. Bjarne Stroustrup doesn't need to know Haskell to be a C++ guru, and Guido doesn't need to know LOLCode to be an expert in Python. 
Awesome! Thanks!
Sweet, thanks for the tips.
Thanks!
One thing you could consider is RRD. I found a brief tutorial [here](https://supportex.net/2011/09/rrd-python/) for using RRD in python. You'd have to translate your class into an rrd format, and read it back out, but you'd get the "only keep the last 10k" by default as well as some easy graphing.
This might work... I'm dealing with online poker hand histories, but that looks flexible enough. It would take a lot of re-engineering though. It would be best if I could store the python objects I already have.
its kinda fucked up how the system is pretty much set up to fuck the entrepreneur. the SS tax for example, why is it even split between employer and employee.. MOST PEOPLE dont even realize their is an employer component.(most new entrepreneurs learn this unfortunate fact, the really hard way) and then healthcare, tax free if you work for someone else.. wtf. I have to pay taxes on the money i earned to buy healthcare. Not to mention life is already hard on you since you are wearing all the hats in the company.. they dont have to skew it against you. Which makes me wonder if some of those strange things in our systems werent put there to discourage, the rise of competition. 
PyPy tries to be fast first. Memory efficiency is less important.
There is only int in my dictionaries. Is it a bug ?
What I was trying to get was being able to pick the right tool for the job. Each language has it's own set of pros and cons, and picking the right one for the job is essential to being an expert at one. Knowing the limitations of a language is essential to mastering it. -Kat I apologize if I am not clear with my comments, I'm often not very good at conveying a message clearly the first time through.
&gt; It would be best if I could store the python objects I already have. then use zodb 
An RRD looks appropriate, it's just that I want to store Python objects in it, not raw numeric data... I'll look around and see if there's a way.
This looks very cool, good job!
I don't know where you're getting that assumption; to my understanding it is a given that Pypy will use more memory. That's what you pay for the speed. 
In my experience, Kivy is largely a huge memory hog when a program spends too much time naively generating and destroying Widgets. That being said, care is taken in KivEnt to avoid initializing too many objects, and one of the main points is to provide lighter data structures for game building than Kivy's Widgets. All of your entities will be reused, which means that entity generation should really halt somewhere around the maximum amount you put in a scene. In addition, all of the memory for the Particle Engine and Renderer VBO arrays is managed manually. Pretty much everything in KivEnt is just a thin python layer sitting on top of C data.
Hi 1moar, I have no experience with OSX myself, so I'm not certain there is anything platform specific that needs to happen, but there will be some slightly differences from the documentation. KivEnt needs to be able to cimport from Kivy and Cymunk rather than just python importing so it needs to be aware of cython headers from these modules. What this comes down to is building these modules in place in a directory (usually just using 'make' instead of 'make install') and then exporting a PYTHONPATH pointing to these directories so that KivEnt can find them. A simple roadmap should looking something like: * Setup Python and Kivy Dependencies * Make Kivy inside a directory * Test to make sure you can run a regular Kivy application * Make Cymunk inside a directory * Export PYTHONPATH to Cymunk and Kivy Directory * Build KivEnt (typically I just use setup.py build_ext --inplace and then move my compiled kivent.so to my working directory) 
&gt; So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-) WOT.
Apologies, I didn't realise this repo hadn't been updated. It's a pissy little thing which breaks it: Line 51, change galx = re.compile('&lt;input type="hidden" name="GALX" value="(?P&lt;galx&gt;[a-zA-Z0-9_-]+)"&gt;') to galx = re.compile('&lt;input name="GALX" type="hidden" value=(?P&lt;galx&gt;[a-zA-Z0-9_-]+)"&gt;') and it should work again. I've been using this script for the last six months. When I get a chance tomorrow, I'll post a gist with my version to make sure it matches.
I get this by the multiple benchmarks I saw on the web where people successfully get speed and memory improvements. And no we shouldn't pay memory for the speed when talking about interpreted code vs Jit compiled code.
The problem with this analogy though is that often consultants are more like travel agents then the actual pilot/captian. If someone wants to go somewhere as fast as possible then the travel agent would recommend a plane (C/C++) while if they want something more scenic they might take a train/cruise (python?). In the end though having only a narrow skill set is almost always determinal. There are still some COBOL experts out they're but I wouldn't want to be one, regardless of the wage. 
In that case, maybe you do just want to go with zodb.
1. Learn python 2. Go on about your personal philosophies. 3. Act enlightened and don't give literal answers, work with metaphors and make people work for the answers from there. 4. Wear a robe.
Hey man, looks like you might have forgotten a "\n" in the code right before your first picture example plt.colorbar()plt.show()
No. 
Great but until MySQL does do that, it's vaporware from MySQL fanboys. Being able to use advanced functionality *today* from an incredibly powerful database is better than using advanced functionality *at some point in the future* from a typically corner-cutting database. Sorry to rain on your parade, but watering down a project to support a different database (why? Postgres is free and installed on most web hosts nowadays anyway) that *doesn't yet have equivalent functionality* just seems like it's shooting yourself in the foot.
when i want to sort arbitrarily large lists of file-based records I use [heapq](https://docs.python.org/2/library/heapq.html). Stream out the records into N number of temp files, each with M records (where M is a number that can be safely sorted in memory). Write out each file as a set of sorted records, then you can merge them into a streaming, fully sorted iterator using heapq.
"but more in touch with reality than the grey-bearded wizards of Lisp/Haskell/whatever that sat in their caves/towers/whatever solving contrived, nonexistent problems for people that don’t exist, or those insane Erlang programmers who are content writing sumerian cuneiform all day long" That was worth the read.
I'd probably expose nlev as an argument. Sometimes creating a few distinct color bands helps, such as when drawing contours.
If you do become a freelancer get your accounts package in order. I use Xero.com - it is very good for a single operator. I was a freelance full time for 8 years as a web designer and I wish I had never met MYOB.
oh good catch, thanks!
It was just pointed out to me that this same functionality already exists, in a dark hidden corner of mpl: mpl._cm.cubehelix()
You can double check the dict is using the optimized storage strategy by using this undocumented, special function on pypy: import __pypy__ print(__pypy__.dictstrategy(mydict)) It should show you IntDictStrategy, assuming it only ever contained int keys
Indeed it is a IntDictStrategy
Agreed, I would suggest removing this repost! I am curious how much more I will accumulate over the months/years... hope I get enough together for a worthwhile repost :)
This kind of DIY might be the solution since the databases I'm seeing aren't really built for sequential access (not that it's impossible.) If I'm going to split everything across multiple files I could just cPickle regular old lists though since when I read the data it comes in already in order (file names for each session are in date order and individual hands are in temporal order within each file.) It might also be time to look for a memory profiler.
I hadn't heard of SQLAlchemy - that would make life *much* easier. I might go with an SQL solution just because I need to learn how to write queries one of these days. Since I have been keeping everything in Python lists I've been using list comprehensions to pull data, which is awfully nice.
What if I tell you that you don't have to write a blog post everytime you change to other programming language.
A month after Python 3.4 is realeased, a blog post about switching to Go because of concurency, and not a single mention of asyncio... I think someones just excited over learning a new language ;-)
if youre freelancing, youre gonna be using a lot more than 50% of your time getting your name out there
what color would you recommend the robe should be?
Well I just found http://jsonpickle.github.io/ which looks like it would save me writing my own json encoder. I'm not sure what you mean by jumping between objects. A typical usecase would be "find me all the hands with these particular pocket cards and sum up the net gain for each hand."
&gt;Ok I guess we agree. Making booleans a subclass of ints is not consistent with the way python handles string vs char because char and string are the exact same type treated the same in all cases but int and bool are not and further are not even treated as if both were bitstrings. Name one non-printing, non-typechecking operation where `True` is not substitutable for `1` and `False` is not substitutable for `0` (bar misuse of `is`). Name one user-facing property that would change if numbers were bitstrings, aside from the ability to index. &gt;&gt;ASCII code points to characters on Python 2, does not involve the internal representation of these numbers. &gt;I agree but that in no way invalidates my point that if ints were treated like raw bits str(97) would make more sense as 'a' than '97'. No, it really would not. It would make sense as `'0b1100001'` or similar, maybe. But how you get `'a'` eludes me. &gt;&gt;Why? &gt;Because of 4's LSB. &gt;&gt;how bool(4) == True but 4 != True offends you... &gt;Not sure how this is relivant to your argument about LSB that I was refuting. But generally unexpected behavior causes bugs. But `4` is truthy... That's all that `bool` returns. Whether the input is truthy or not. Nothing else. &gt;&gt;Python does not define an internal representation for dictionaries. You therefore can't do this. &gt;No but choose any specific release of C python and it does. It does not. &gt;&gt;Closure is not a property held by Python objects. &gt;So first note my problem is not that any type violates closure. It makes sense for many types to. It does not make sense for boolean to violate closure on other operations involving booleans. Why? &gt;&gt;Python 3 (1/2) &gt;I still really don't like this. "//" and "/" should be swapped. Why? &gt;&gt;fractions.Fractions (½**½) &gt;It does not if you are using the default types. It only breaks if you are explicitly importing fractions. This explicitness is my point. Why is whether something has an AST token or not at all important? &gt;&gt;So the problem was that the library had an error code you didn't test for? &gt;It was not an error code for the lib. But I did need to return an error on my end. I needed to return an error not just for booleans but for other potential and unpredictable types the library might return. If I knew in advance what types were returned I would not need isinstance in this case. So what *was* it doing?
I made this a couple of years ago, https://github.com/sukisuki/mvn It's a huge mess because I was learning everything as I did it... and hey let's see how many decorators we can put in here. But it has some interesting things implemented, like operators, marginalize, conditionalize(.given), bayesian intersection (&amp;), cdf, plot... So if you need something more complex than pdf, you might be able to salvage it from this. 
https://www.elance.com/r/jobs/q-python/
didnt read it did you? you just scanned for asyncio.... be honest. 
I guess the question is, what do you expect to be able to provide on the desktop that can't be provided otherwise? reddit is just another website to me. It would feel awkward opening up another program just to browse it, and most of it is links anyway. Would you open them up in an external browser (putting you back where you came from), or a semi-functional embedded browser? As an exercise in GUI programming, however, it's not a bad project.
All the big ones will. Flask, Bottle, web2py... I'd recommend Flask myself. Also see /r/flask.
At its very basic, it is a size issue, thats it. Normally you would get data from sql tables or similar. But dont scale so well, so you have to use techniques to accomodate very large data sources, where hadoop comes in.
Yeah, I don't know anyone in the business that would take someone seriously who actively used the term "guru" to describe their abilities in a language. That is, unless your name is Guido Van Rossum and the language was Python.
Hmm, not sure, let's just go with rainbow colored, that way we'll have a variety of color on it to be safe.
That's really really cool, thanks for making it available! I hope the `matplotlib` guys are integrating it!
Cool, thanks.
Read it and found it interesting honestly. But a lot of negatives you addressed with pythons approach to concurrency they have been working on for a while and addressed with a new standard library. I agree it is no Go, as Go was designed with that goal in mind from the beginning. I just was noting the article was only comparing non standard python modules with the built-ins of others. 
This is how it feels to code in Go: 1. rtn, err := wtf is the type for X? 2. if err != nil { log.Fatal(err) } 3. rtn, err := lookup docs for type X 4. if err != nil { log.Fatal(err) } 5. rtn, err := now I want to convert it to type y 6. if err != nil { log.Fatal(err) } 7. rtn, err := wtf is the type for y? 8. if err != nil { log.Fatal(err) } 9. rtn, err := crap I can't inline convert type here. has to be two lines 10. if err != nil { log.Fatal(err) } 11. rtn, err := convert type bitch! new_x := x.(typeY) 12. if err != nil { log.Fatal(err) } 13. defer kill(*myself) 
OMG yes this is true. Until I co-wrote a book, finding work was hard. Now, sifting through all the lame or underfunded work is the hard part. I guess that's a happy problem, right? :P
and NumPy is a library for numerical processing, which isn't used by your general blog-type webapp, but is a basic requirement for things like scientific computing. There's a sizable user base for scientific computing in Python. I think this is a distinguishing feature for Python, something that sets Python apart from other languages in its family (Perl/PHP/Ruby/JavaScript). So if you want your Python implementation to be taken seriously by the python community as a whole, it's a pretty big deal for you to support NumPy. 
Don't you just need to put it on your business card? That has worked for all the consultants I have ever met.
Just yesterday I watched a PyCon talk by Alex Gaynor (who works on PyPy) where he talks about memory requirements for dictionaries and classes among other considerations for what makes python 'fast' or 'slow': video.org/video/2627/fast-python-slow-python It is not a large portion of the talk but still you might find it interesting.
I had a similar thought. This blog post would have been harder hitting in 2013. Now it feels like there is a glaring admission.
&gt; Being a guru is not. Not with that attitude!
not every time! Closer to strict O(1) algorithm - less memory access - less cache trash - more performance, even if overall memory usage larger. 
Python and Go are not comparable. Go has not been built for replacing Python! This is implicitly said in the blog post. Regarding concurrency, yes, Go is convincing. Go's architecture has been designed for this, from the very beginning. Hence, if you need to write a specialized application that should be fast and scale out very well on one machine, then *Go* for it! That is no surprise. The title "Why I went from Python to Go", however, is not what I would have written. Use the right tools, according to the task. Most of the times this is still Python.
Might this be of use? It's about tweaking how you use Pypy to achieve even better performance. Not sure if it covers memory utilization. [http://pyvideo.org/video/612/how-to-get-the-most-out-of-your-pypy](http://pyvideo.org/video/612/how-to-get-the-most-out-of-your-pypy)
The site looks great dude, good job. Formatted perfectly on mobile, all except for the last advertisement at the bottom, which is twice the width of the phone's screen making the bottom scrollbar appear ... Just thought you should know
Python runs better on Mac, from what I've heard. I'm not sure what to do about your exam, but whether or not you can code in python is mostly independent of the OS you'll be using.
While your answer is somewhat correct, "please don't follow any of the below suggestions" is kind of misleading. You also seem to misunderstand the big picture of token authentication. HMAC obviously needs a unique, secret token to work, and many (though not all) of the below suggestions are just fine for generating such a token. OP did not ask for how such a token should be used to actually authenticate an API consumer, he simply asked for how one could generate a token. But if he does want a full tutorial on token authentication, then he will be misguided if he just reads what you posted. HMAC itself does not prevent replay attacks in any way. Nonces do. HMAC and randomly generated tokens are completely irrelevant to replay attacks; their use or disuse will not open up or prevent replay attacks. `itsdangerous` will handle HMAC for you and can kind of sort of handle nonces for you: you can use either a timestamped signature for this, which will also prevent even the original sender from replaying the message after a certain time span, but replay attacks are still possible within that timespan. The other way that nonces sort of fit in is that `itsdangerous`'s signing classes can take a salt argument, where one might specify a nonce, but the client alone cannot just specify a random nonce and somehow have that nonce be enforced as a nonce ("number used (only) once"). The server would have to do more complicated processing to handle true nonces, either by each client having to request a new nonce before an API call can be made, or a client generating a random nonce that the server then stores somewhere and checks against to ensure it is never sent again. A secure MAC algorithm (such as HMAC), a nonce, and a way of generating random, unpredictable bytes are all required for replay-resistant token based authentication of a user and the messages he/she sends. You did not specify those 3 particular things yet still claimed that the below suggestions are wrong because they specified only 1 of those 3 things. `itsdangerous` itself provides no methods for token or nonce generation. On top of all that, the last link you gave is also vulnerable to replay attacks that are sent within 10 minutes of when the message and signature were generated. Neither link provides any information to OP on how to actually generate a secure token either; the `itsdangerous` documentation just uses a placeholder `"signer-key"`, and the blog post assumes you've already set a secure `SECRET_KEY` app config variable. Neither link explains what a replay attack is, why you don't want them to happen, or how to prevent them, either. I still highly recommend using a library like `itsdangerous`, of course. But if you're programming a system that needs to authenticate API tokens, you need to actually have some understanding of the cryptography you're using, even if it's only an understanding of the purpose of each individual part. It's also disappointing to see /r/python downvote every other comment in this thread due to your misguided criticism. Yes, all the other posts simply answered OP's question instead of delving into the ins and outs of authentication, but if you're going to attempt to do so yourself at least get your information right. tl;dr: HMAC doesn't solve the overall problem here, nor does `itsdangerous`; your criticism of the other posts does not have any bearing on what you're actually trying to argue for, nor do your suggestions have any bearing on it either; and finally, neither of the 2 things you linked actually answer OP's original question. Every reply in this thread that mentions using `/dev/urandom` or `os.urandom` is technically more correct than what you just posted, even if you gave decent additional advice.
Python xy is just Python plus tons of library, but some of the libraries can be a bit outdated, so you should be careful if you are going to be programming in OSX and graded in Python xy. 
Cookie, the problems persists with the code still giving multiple errors.
His post is not very correct either. See my reply: http://www.reddit.com/r/Python/comments/22uiq1/rest_api_keys_generation/cgup9es `itsdangerous` does not actually prevent against replay attacks, though it can mitigate them somewhat with timestamps.
Storing and retrieving data from an SQLite table is just a few lines of simple code.
In my experience : linux &gt; mac OX &gt; Windows, but python distributions like anaconda are making things more even. And anyway using what the teacher and the class use may be the best. 
Is this strictly a python3 package? It doesn't work with Python 2.7.2 on OSX 10.8.5 when i tried. I think you'll have to mention it somewhere in `setup.py` if it is so
No, not like this. The JIT works on the code. Increasing the data structure size doesn't increase the size of the code. Hence you wouldn't get a linear increase in size. As there was a linear increase it shows that this is the dictionary data structure taking more space in PyPy. What you need is for /u/fijal to stop by and explain why that might be. I'm sure it's done for performance reasons, but I don't know what they might be.
You need a licence, unfortunately (that's the world we live in.)
i'm not the author of the blog post. I was just the person who found it and shared the link in this /r/
Anyone know how he got his iTerm command prompt to look like that?
It's not about JITting only, PyPy also uses a full garbage collector while CPython uses reference counting + GC for finding reference cycles only. GCs generally tend to consume more memory, trading that for improved performance in various ways.
Awesome. :)
Well, actually none of them will (out of the box). You have to use extensions for this, e.g.: https://github.com/maxcountryman/flask-login Edit: OK, apparently web2py supports it out of the box but I'd still recommend Flask + Flask-Login.
Two points. 1: Fabric is Oracles 2: It's not monitoring It adds almost full control of the OS
Python does have a built-in extensible JSON encoder, you know. It just requires extending json.JSONEncoder and writing a function which turns your objects into dicts. You get far more control over the process, too.
Linux by a landslide. Having pip install for weird packages, and apt-get when pip fails is awesome. You'll be happier developing on linux anyway. 
PyObjective-C is your best bet.
Indeed it is only Python3. I'll look up what metadata I need and update it accordingly. Thank you!
I can speak for Kivy, but I don't know much about the others. &gt; Can I just build python and libraries with xCode for iOS? Ultimately yes, but kivy itself doesn't care where you wrote the program and you can use any setup. You only need xcode (or at least, some af its tools) for the final build stage. &gt; Maybe somthing offer iOS and Android. Kivy certainly does. &gt; Can I use python c libraries? In general terms, yes, but you must be able to compile them for ios. I don't know a lot about this part, but I'm sure someone on Kivy's irc or mailing list can help with enquiries about specific libraries. Some will be hard/impossible for dependency reasons, I think, but many others are probably quite easy, and some are already available. &gt; Graphics and Performance for game dev? Kivy usually performs somewhere between 'adequate' and 'pretty darn well', it's certainly perfectly capable for games but some will be more suited than others. Just yesterday, one of the core devs announced his new kivy game engine here (see http://www.reddit.com/r/Python/comments/232wsi/python_android_game_engine_looking_for_testers/). It's an early release, so probably looking at 'vanilla' kivy is a good idea before diving in, but it does demonstrate the (fairly impressive) performance possible. &gt; Cross Platform GUIs? Again, kivy is automatically cross platform. You can also access specific mobile apis on the individual platforms. Edit: For an actual example, [here](https://itunes.apple.com/us/app/2048-with-kivy/id841404915) is a version of the ubiquitous 2048 game, made with kivy, on the apple app store. It's also available [on google's play](https://play.google.com/store/apps/details?id=com.meltingrocks.kivy2048), and the source is [on github](https://github.com/tito/2048). I think each version even integrates with the native api on each platform to manage their leaderboards, which is a nice example of using native apis from kivy.
&gt; C++ is weakly typed - I can add 1 to 'A' That doesn't make C++ weakly typed -- both `1` and `'A'` are integer types in C++. (Yes, `char` is a type of integer.) I have no idea what any of this has to do with the title. The "we're all consenting adults" thing is usually in reference to the fact that Python has no such thing as private class members. That doesn't mean that classes in Python don't have private data, it just means that privacy is enforced through a voluntary naming convention (leading underscore) and not an explicit language feature. After all, you can still access private members in Java by using introspection, and in C++ by using a variety of dirty tricks. Privacy in these languages is not a security feature meant to keep out an attacker, it's meant to keep already honest people honest. Python just recognizes that honesty and doesn't bother trying to invent something to cover it up. In other words, "we're all consenting adults" does *NOT* mean "encapsulation, boo!! Who needs it? amirite?", it means "sometimes a voluntary naming convention is enough." 
That'd be great. I will look into it too. A little new to packaging. Opened an [issue](https://github.com/zcdziura/leprechaun/issues/3) on GH also
it does - since they do not have properties, so if ever by chance an attribute needs to change implementation, with getter/setter you can alter the behaviour transparently imagine having to go from storing a temperature in fahreneit, and converting to celsius/kelvin to storing it in kelvin for example (maybe for numeric correctness reasons or whatever) in the languges without properties, you would have to change code all over the place if you didnt use getters and setters 
Agree but anymore pip + Homebrew is 98% as easy of an experience as Linux. 
One of the big reasons Python can get away with having attributes as part of an object's public API is that you can replace them with properties, which act just like methods except they're used like attributes. The .net framework languages have this as well. If C++ doesn't, then it's probably better to keep writing getters and setters and using them. The reason is so that you can change how an object manages its data internally without changing the API. With Python, all you'd have to do would be write a property which translates the data into whatever the API says it should be. I'll point out that a lot of Python code does signal that methods and attributes are not part of the public API by prefixing them with an underscore, although they're still public in the traditional OOP sense. As for your sidenote, C and C++ are among the worst statically typed languages. Even Java is better from a theoretical perspective, and Ada has been around for a long time with the goal of reducing errors. Modern statically typed languages such as Haskell and Rust are even better.
I've recently looked into this for a personal project. PyObjC sounds good, but turns out to not be very nice because it relies om some things that are OSX specific. I found kivy to be a huge hassle and then you end up with a weird looking gui anyway, so I abandoned that. Now I'm working after the premise that the best thing to do is just build CPython, embedding that and using the C API to communicate. I've got a primitive project that works up and running after quite a bit of work. TL;DR: it's a big hassle
Pip and homebrew is pretty much perfect.
The python code will likely be the same on either type of machine, especially for beginning to learn the language. I prefer programming on a mac vs windows. I would check with your teacher/professor and make sure there isn't anything IDE-specific on the exams. You'll probably just have to learn how to open, save, and run a python script in pythonxy.
&gt; (Yes, char is a type of integer.) No it isn't. But there is a variant of `operator++` that can add `char` and `integer`. &gt; you can still access private members in Java by using introspection Not if you're running under a properly configured `SecurityManager` (I think that's its name.)
Generally speaking, a pure-Python ICMP implementation is unnecessarily complicated. subprocess.check_call(['ping','-c1',ip])
let me answer the question then. &gt; why the F should you have to catch it when doing import XYZ? because some programmers are retards who don't know how to code properly.
&gt; .net framework languages have this as well For sake of completness, I'd like to point out that JVM has this too, just not in Java. It is avaialbe in [Kotlin](http://confluence.jetbrains.com/display/Kotlin/Properties+And+Fields) and Scala.
If you're looking for a simple, effective solution you can use `os.system()` (it's deprecated by the `subprocess` module now, but for this purpose there's *probably* nothing wrong with using it). `os.system()` executes a system command. Commands have exit codes that define what happened during their execution. In the case of `ping`, the exit code will be 0 if the host replied with least one ICMP reply packet. So, if you were trying to ping a host and check to see if it's up, you do this: if os.system("ping -c 1 google.com") == 0: print "host appears to be up"
Guido van Rossum threw his support behind kivy as well at PyCon this year in his keynote. Thats a pretty good reason to learn it imo, definitely a good indicator that their direction is good.
For sone reason I read your post title with the voice of Sheldon Cooper in my head. 
You must be talking about C++11 which I must admit I'm not familiar with yet. The C++ standard specifies that &gt; Characters can be explicitly declared unsigned or signed. Plain char, signed char, and unsigned char are three distinct types. &gt; That doesn't seem to be a problem in reality. Yes, if your SecurityManager is configured to allow it, it will work. &gt; Set the accessible flag for this object to the indicated boolean value. A value of true indicates that the reflected object should suppress Java language access checking when it is used. A value of false indicates that the reflected object should enforce Java language access checks. First, if there is a security manager, its checkPermission method is called with a ReflectPermission("suppressAccessChecks") permission.
That said, Python took this attitude well before properties were introduced to the language.
As others pointed out lack of property decorator makes getters and setters a good defensive strategy in those languages. Another issue is collaboration. If you have a project with many (above 10-20) developers, than you should **force** the library user to use your intended interface. The means of forcing can be: * Documentation * Runtime checking * Attribute access restriction * Compile time type checking BDFL of python deliberately decided to drop the last two. The paradigm says, that the user of the library is responsible for using the library the way the library's author intended and documented. To ensure this, the user of the library should writes extensive test (TestDrivenDevelopment). The problem with this approach is that developers do not change. The developer of the library tends not to write correct documentation, and the user of the library is too bored to write tests. To illustrate this, let us suppose, you are using a library function that accepts a *file like object*. That's what the documentation says. It is fairly common to say that. Google for: accepts a file like object Good luck finding out what exact properties and methods should this object have, what exceptions are expected to be thrown calling them, and what builtin functions can be applied on them. You will find for examle [this](http://pysnippet.blogspot.hu/2009/10/file-like-objects.html) and [this](http://stackoverflow.com/questions/1661262/check-if-object-is-file-like-in-python). The first one says file like object should have a close method, the latter says it does not. The official python documentation does not say anything. So you have sloppy documentations. The best way of finding out how the library actually interprets *file like* is to try it with tests. Or crash at runtime. So big projects, with additional problems with the horrible package managementi, in python are a big pain. 
&gt; defer kill(*myself) I lost it 
recipe 2: You should know has_key. Nobody uses has_key, so python3 dropped it. You should know it anyway. wtf?
And a cleaned-up version for Python 3: [https://gist.github.com/pyos/10980172](https://gist.github.com/pyos/10980172).
I've tested it on the latest versions of the supported Python 3 branches, so 3.2-3.4. I don't have any intention of backporting support for Python 2, because that branch is isn't being worked on. I'll update the program later today to reflect which versions of Python are *officially* supported.
&gt; You must be talking about C++11 which I must admit I'm not familiar with yet. The wording is exactly the same in C++98 &amp;sect;3.9.1/2 and /3 (with the exception of `long long` not being specified.) And it's the same in every version of C going back to the beginning. Characters have always been a type of integer. The only difference between them is that in C the character literal has type `int` whereas in C++ it has type `char`. 
Great, all right. I've updates the issue with some interesting links. Do check them out. All the best !
Using setters and getters isn't so much about permissions, its for when you want to keep an API stable, but change an implementation underneath. For example, what if I want setting a property (say a URI) to, for a particular class, schedule a fetch of that URI and cache it in the object? If I've done it as a setter, then it's easy to do, if it's a publicly accessible member variable, then the implementation has to leak out of the class to get the same result. Similarly, what if I want `set()` to be given a parameter in metres, but want to store the member internally in feet? With setters/getters it's easy -- you are hiding implementation details in the class, exactly where they should be.
Having written and especially *read* a lot of C system code, access modifiers are one of the greatest forms of documentation that there is. The advantage of knowing that you can call a certain method at any time or that you shouldn't mess with something with an unclear name makes it much easier to make changes to a large codebase. It's also documentation that actually *gets done*. It also forces encapsulation and re-usability. You can be sure in unfamiliar code that the object is the only thing related to the object. If you're one person and you carefully encapsulate, then great, but as soon as a second person comes in, you've all got to do it right, and god-forbid you die and the next person who comes in can't trust you.
pip and Anaconda Python will suit your needs I belive.
So you're using *char* to refer to a number (integer) that goes -127..128. So char has to be an integer type.
the color of the robe of the Great (but corrupted) Saruman
Before that you could still customise attribute access with __getattribute__ 
Fair point.
Object visibility restrictions are used to define the proper operational constraints of an object. It doesn't make sense to allow a setter for 'x' if: 1) 'x' should only be set by a constructor. 2) the value of 'x' is dependent on the values of other attributes and should only be updated when those other attributes are updated. ... Allowing a setter for 'x', in these cases introduces a bug. Some languages like Javascript have no formal means of defining visibility restrictions and instead use scope restrictions to achieve the same ends. Security through visibility restrictions is another issue but I would think that security is a function of the proper operation of an object and so it has very little to do with trust and consent. 
&gt; Using setters and getters isn't so much about permissions, its for when you want to keep an API stable, but change an implementation underneath. Tbh, that's what permissions are about too.
I understand what you mean, but the question was about no permissions... everything public. Even in that case, I'm arguing you would still want setters and getters -- so it's not really about whether you're permitted to alter them directly, it's about whether it's sensible to do so. Permissions are only a compile time helper anyway, after all, they don't actually stop you altering anything you want.
what do you mean by "Oracles" ?
&gt; it means "sometimes a voluntary naming convention is enough." Yes. And Python actually gets this one wrong. In this particular case, a voluntary naming convention is *not* enough.
Damn, that's quite the difference. Is that indeed a result of the switch from Python 2 to Python 3 or because of a thorough clean-up? 
The latter.
I think you are trying to create a single element tuple in: def get_password(connection, digest): """Query the database for the digest and return the plaintext password. Parameters: - connection: The connection to the SQLite database. - digest: The digest of the plaintext word. Returns: - The plaintext password associated with the given digest. """ cursor = connection.cursor() t = (digest) cursor.execute("SELECT word FROM rainbow WHERE digest=?", t) return cursor.fetchone() It should be _t = (digest,)_ unless python 3 does this differently. I assume, if the code is not broken, a tuple is unnecessary here.
I teach a class in Python and allow students to use any OS. Generally the *NIX folks have by far the easiest time, followed by Windows and Mac. This isn't really a reflection on the quality of the OSs (at least not directly) but the level of support they receive. Most versions of Linux come with a recent version of Python already installed and it's usually very simple to download newer versions and install plugins and updates. Windows itself is kind of ugly in it's behavior, but there's plenty of support. I generally recommend portable python for Windows, because it can be run just about everywhere, and comes with some nice editors and modules built in. (The problem in Windows is that the best Python editors normally require WXWidgets, which is a non-trivial installation in Windows.) With the portable solution, we bypass all that. Macs (being based on Unix) usually have a form of Python already installed, but it's often out of date. My six-month old MacBook Pro has Python2.7 installed by default with TkInter, so it's fine. On the Mac, it can be terribly painful to install add-in libraries, particularly PyGame. If your class uses standard built-in modules and Python 2.7, you're probably fine. If you need any extensions, you may have trouble. I tell my Mac students to go to the library or use one of our other labs when they want to use Pygame. (I also have a bunch of Linux laptops I loan out when a student can't get things installed on his or her own machine. Not all professors do that.) Note there are significant (if not difficult) differences in the syntax between the Python 2.* and 3.* versions. If your examples are written in 2.* syntax, you'll be confused with 3. 
Cool project, thanks for sharing! Perusing through the code I noticed a few places where you build file/dir paths manually. The only issue here is it may not be portable to a Windows environment which uses different conventions for paths(eg. '\' instead of '/' and 'C:\' instead of the root '/'.). I would suggest that you use instead the os.path functions which ought to deal with these details for you.
I know this is not a popular opinion in the Python community, but having a compiler or interpreter that actually has your back is a nice thing. We already have the leading-underscore convention; turning it into something the compiler can actually check and enforce is a small step, and it would make life so much safer and easier.
Correct me if I'm wrong (I haven't done C++ since college), but I thought that C++ was static weak typed just like C. Dereference the pointer just right and anything can be what ever I want. But I'm super rusty on my C++. I know python does plenty of type checking--at runtime. Not as sure how C++ does it.
If you used FPDF in PHP, there is a Python port (I've never tried it): https://github.com/reingart/pyfpdf
Do you want to develop an iOS app or do you want to fight with tools? If you actually have a good app idea just learn ObjC and use Xcode. It isn't that hard, the docs are actually pretty decent and you'll finish much faster . 
Sometimes objects with attributes are more efficient than using raw dicts. You might want try experimenting with making a class to encapsulate your data.
I thought the interpreter already did enforce it, in a way, with the rewrite rule. Which, being consenting adults, we can work our way around for monkeypatching and other questionable-but-sometimes-necessary actions. With the rewrite (\_\_foo to \_\_Classname\_\_foo), only people that really intend to can access "private" members. As mentioned elsewhere, in (some) other compiled languages, similar workarounds can be used to get at private members, by those that really want to. It doesn't seem that Python does this any worse than them. Edit: try to keep double underscore from being bold.
it seems to be over kill for a simple label w/ logo and product name. I may just use the php page since I've already got it done; though I'm not a php dev at all. each label will have the same layout with a variable name. I can take a closer look at ReportLab, it just seems like it's way more powerful a tool than I need for the task. But it may be worth learning the basics anyway.
C++ adds several different kinds of casts, ranging from quick-and-dirty-just-do-it, to fully runtime type-checked (and therefore more costly) dynamic casts. You can still shoot yourself in the foot if you want, but it provides more foot-shooting-prevention features than C, at least when it comes to type safety. It also provides _lots_ of compile-time type checking. There are implicit conversions, but apart from obvious conversions between built-in types, the programmer has to explicitly enable them by writing single-parameter constructors (and not tagging them with the "explicit" keyword).
&gt; Dereference the pointer just right and anything can be what ever I want. If you're talking about type-punning, that's undefined behavior^(1), and code that does that is invalid. But even if it wasn't, abusing the type system by using an escape hatch to get around it is not how you're meant to write code in C++. The type system is there to work for you, and when used properly it can enforce all the sort of things you'd want a type system to enforce. (Well, maybe not quite all, if you come from a FP background, but certainly a lot.) For example, iostreams provide a type-safe alternative to type-unsafe format strings of C (printf/scanf/etc.) And variadic templates provide a type-safe alternative to type-unsafe C-style varargs. Improving type safety over C is one of the main themes behind the design of C++. [1] With a few special exceptions, e.g. char can alias anything.
In theory, yes. Having public fields/attributes aren't a problem. The problem is, in just about every language, going from a public field to a property/getter&amp;setter is a breaking change that would require a refactor. So, in most languages, starting with get&amp;set from the get-go is a way to avoid pain later on. Since python is dynamically typed, you have a lot more leeway in changing an interface. Starting with a field and switching to a property is fine in most situations (exeption: reflection). Static analysis tools like Valgrind are the big advantage static languages have over dynamic ones. Not for bug-hunting, but for performance. Without going too deep into Compiler Design 101, since dynamic languages allow a much wider range of inputs than static languages, it is not very practical to perform static analysis on a dynamic codebase (not with todays computers). Python can kinda get around this by first compiling to RPython or C (which is actually how PyPy's JIT compiler works IIRC), but this kind of performance analysis is not an option to your average dynamic programmer.
You're right! That bug hadn't come up yet because I don't use that function (yet). I'll fix it in my next commit. Thank you!
&gt; the programmer has to explicitly enable them by writing single-parameter constructors (and not tagging them with the "explicit" keyword). That's in C++? That sounds like VC++ or C# to me. Hey, if I'm wrong, I'm wrong. It's been a while since I ran `g++`.
I will make the changes, thanks for the suggestion!
On your last comment about IDEs, I highly suggest PyCharm and there is a free version of it. It's called 'community edition', it's just as good as the paid for version when using just python (paid edition comes in handy with website creation or database management.) [Link on the right](http://www.jetbrains.com/pycharm/download/)
 SUCCESS = 0 if os.system("deltree c:\ I guess") == SUCCESS: do_some_cool_shit() Would probably be a bit more pythonic in that it's easier to read.
I have it setup on both Windows and my Mac, and far prefer to work on my Mac with it than the PC. ymmv
by keeping the internals of a class private, you insure that changes to the class don't affect code outside the class. This reduces complexity and makes it easier and simpler to maintain the code. After compilation, getters and setters really don't cost any more to execute that direct access. 
Yes, that's C++. If you have a single-parameter constructor, it might get implicitly called in some situations if you supply a variable that's compatible with parameter of the constructor. For example, this is valid and calls the constructor of the `implicit` struct: struct implicit { implicit(int x) {} }; void f(implicit x) {} int main() { f(5); return 0; } If the constructor was marked as explicit, the code would not compile.
Good for non-python stuff too, I've been using it for years to deploy PHP sites, also as a local task runner for an HTML-email builder (Premailer to inline the css). Love me some Fabric. 
I love PyCharm. I don't think I can go back to vim. And it works on all 3 of my development platforms perfectly - mac, windows and linux. Highly recommend. 
Ruby has the same feature as well. instance.name = 'foobar' Is actually calling the "name=(value)" method which you can override if you want to.
Yes, but the behavior that follows can be surprising. I think this is a defect in C++ and should be the other way around: an implicit keyword should exist to make a constructor implicit (so you could *explicitly* request the unusual behavior). Of course, if we assume it is not a defect, then your reasoning is solid.
&gt; ssh lets you remotly execute commands... what's the problem? You got [Parallel Execution](https://fabric.readthedocs.org/en/1.3.0/usage/parallel.html) in that Bash script? I can't imagine what a fucking nightmare *that* would be to include in a deployment script.
Totally agree. I once worked on a project that was continually plagued by bugs because someone forgot (or didn't know) to tag a few constructors as explicit in a common library. I wanted to fix it, but by the time I got there, there were literally thousands of individual lines of code that relied on implicit conversion.
I love to think of classes as Structs with functions. Then you don't feel like you are being a blasphemer. Huge kudos for bringing up such a religiously sensitive topic. Basically the only time I use get/set is when something needs to be triggered by the get set. And maybe if the data structure behind the get set is very complicated and I don't want to replicate the code in 100 places. But I am 100% opposed to just doing a get/set for every stupid member integer and whatnot. 
I personally find APT to be a pain in the ass. Homebrew, on the other hand, is one of the better package managers I've ever dealt with.
&gt; On the Mac, it can be terribly painful to install add-in libraries, particularly PyGame. It's pretty easy with [Homebrew](http://brew.sh/): 1. Install the package manager: ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)" 2. Tap some kegs (link to additional repositories): brew tap homebrew/headonly homebrew/python 3. Install PyGame: brew install pygame
This is why I suggested PyObjC. The time you spend coming up making those tools work in iOS you could just build it in Xcode. You could keep you core logic in a C lib, but for iOS it's Objective-C or Xamarin but I don't think IronPython is fully supported there. So... yeah Python/iOS = PyObjC.
Actually, you will pay some memory for speed. Consider a proposed JITed function f(x). PyPy, for at least one moment in time, will contain pieces of the AST, bytecode or generated assembly relating to both. Because if an assertion is wrong in the JITted code, one must revert to the previous form. Keeping such in memory for a short time is a simpler approach to handling erroneous JITting. It's probably a small cost, but it is a cost nonetheless.
Does Kivy support iOS as well? I saw Android, but I did not see anything about iOS.
That misses the point entirely. The point is that sometimes we need to work around a flawed design and access private attributes of an object. The point is that the current system allows you to do it when it's necessary. That's a design goal, not an issue to be resolved.
Yes, it certainly does. The kivy wiki pages have [some examples](https://github.com/kivy/kivy/wiki/List-of-Kivy-Projects#kivy-apps-in-the-apple-app-store) of apps on the apple store, though the list isn't exhaustive.
&gt; So big projects, with additional problems with the horrible package managementi, in python are a big pain. In what way is the package management horrible in big projects? In my experience the pip+virtualenv combo has worked great.
Thanks for sharing your code! To nitpick terminology, it appears that you are creating simple hash lookup tables. "Rainbow table" implies a specific optimization technique using hash chains and a series of reduction functions.
That doesn't work with inheritance though, and is very ugly besides. There is no good way to distinguish private (don't subclass) and protected (subclass, but don't call from different classes) methods.
Mayhaps I'll update the code to reflect the actual terminology. I'll have to read into it further. Thanks for the feedback!
I used pip to get kivy then exported the PYTHONPATH to dist-packagesm and for cymunk I went for the setup.py. Will revert and try again the whole process, this time making kivy from sources. Thanks for the help.
Any reason to do `socket.getprotobyname("icmp")` instead of `socket.IPPROTO_ICMP`?
How was the Learning Python book?
All right, now my whole weekend will be taken up playing with this..... thanks a lot. ;)
"Cool, thanks." :D
We have had good success with Pisa https://pypi.python.org/pypi/pisa/3.0.33
The original code used `socket.getprotobyname`, and I didn't know there's a constant with the same meaning. Thanks!
I think the word you're looking for is "Encapsulation". This is one of the few paramount mechanisms for Object Oriented design: The ability to create a publicly available interface that is independent of the underlying implementation. I agree that this isn't about "permissions" per se, but just de-coupling the inner mechanism from its public interface. You're guaranteeing that the internal mechanism will do what you ask it to do, and any internal properties that it requires are not the users problem. If it's not working as expected or you want a feature, that's a support issue. 
I liked this article. A couple of years ago I had a guy on my team that was really great at some things, but had the hardest time following some of our DDL coding standards. The standards weren't complicated, but he really made a mess of the code. And I got tired of correcting him, and frankly felt it was a bit humiliating to him. So, I really needed an approach like this - let this guy get corrected by a simple tool he could easily run. And let the entire team stop waisting time with unpleasant and unnecessary corrections. One question: any thoughts on using Pylint to check for departmental standards beyond what the tool comes out of the box with? Like - checking for some of our own deprecated modules, etc?
This isn't about being "consenting adults", this is about making sure you're not jamming a VHS into your Blu-ray player. You build the interface with the controls it needs to do the job you intended. You're guaranteeing that it'll do what it's expected to do.
http://en.m.wikipedia.org/wiki/Uniform_access_principle
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Uniform access principle**](https://en.wikipedia.org/wiki/Uniform%20access%20principle): [](#sfw) --- &gt; &gt;The __Uniform Access Principle__ was put forth by [Bertrand Meyer](https://en.wikipedia.org/wiki/Bertrand_Meyer). It states "All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation". This principle applies generally to the syntax of [object-oriented](https://en.wikipedia.org/wiki/Object-oriented) [programming languages](https://en.wikipedia.org/wiki/Programming_languages). In simpler form, it states that there should be no difference between working with an [attribute](https://en.wikipedia.org/wiki/Attribute_(computing\)), precomputed [property](https://en.wikipedia.org/wiki/Property_(programming\)), or [method](https://en.wikipedia.org/wiki/Method_(computer_science\))/[query](https://en.wikipedia.org/wiki/Information_retrieval). &gt;While most examples focus on the "read" aspect of the principle, Meyer shows that the "write" implications of the principle are harder to deal with in his monthly column on the [Eiffel programming language](https://en.wikipedia.org/wiki/Eiffel_(programming_language\)) official website. &gt; --- ^Interesting: [^Eiffel ^\(programming ^language)](https://en.wikipedia.org/wiki/Eiffel_\(programming_language\)) ^| [^Bertrand ^Meyer](https://en.wikipedia.org/wiki/Bertrand_Meyer) ^| [^Property ^\(programming)](https://en.wikipedia.org/wiki/Property_\(programming\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cguzwkt) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cguzwkt)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Thank you for taking the time to write this up. Bookmarked for future reference. 
https://gist.github.com/gregroberts/11001277 This is the version I have been using. I tested it less than 1 minute ago. If it still doesn't work, post the errors you receive.
Oops, my bad. Fixed it.
&gt; A distributed task queue? What? I just want to do something in the background without making the user wait; I don’t need some super comprehensive ultimate computing machine. If you think Celery is a "need some super comprehensive ultimate computing machine", it diminishes the authority of your opinion to me.
Am i totally wrong in saying that you can indeed have private class methods by adding a double (__) underscore to the name? This is private, and I think that protected is something thats not available in python. For me its not important at all, but i understand why people use them. I myself use protected methods (seldom private) in languages that has support for them. 
&gt; But I am 100% opposed to just doing a get/set for every stupid member integer and whatnot. That's your call, but you leave yourself open to backward incompatibility if you later need to wrap that member integer with logic either on the get or set. Python can overload that as needed with @property, but that's not really an option in Java. I think that alone makes a strong case for getters and setters in Java.
The best library, hands down, is Weasyprint: http://weasyprint.org/
I mean Fabric is from Oracle right and not a pure FOSS
Clients don't care about your language. They want X and want it to work while being under budget. When it comes to consulting it's more important to know how to market, communicate, make good estimates, and write shit that don't break then it is to be a master of every nuance of python. And all that other stuff is harder to master than Python.
Can I ask what kind of situations call for accessing a private attribute? Are there no other ways to resolve issues in such situations or is it that violating the access level of a member the easiest way to do so?
Feel free to crosspost in /r/semanticweb.
I don't deploy on multiple host. But I do launch some sub-shell scripts in parallel... nothing really hard. I am not against fabric! I did use it, but I just didn't find a use case where it was a better solution. It doesn't mean there is no such use case, but I would have liked to hear about such use cases... Deploying in parallel on multiple hosts might be such a use case, but I think I would first take a look at pssh.
I use [Appy Pod](http://appyframework.org/pod.html). It lets you create documents in OpenOffice, load them in python with variables defined, and spit them out in any format (assuming you have a headless openoffice running, which is really easy to setup).
[The IUS Community Project](https://iuscommunity.org/) now provides Python 2.7 (installable alongside system Python) for both EL5 and EL6. In your python 2.7 scripts you can just use the header: #!/usr/bin/env python2.7
If you will create PDF from HTML+CSS, by priority: 1. pdfkit/wkhtmltopdf/pahntomjs - really good rendering with webkit. 2. weasyprint - good, but not enough with modern CSS3 features 3. pisa/xhtml2pdf - based on reporlab, but was painful for me, because have poor CSS support, probably without python3 support.
An operating system A compiler A graphically intensive video game embedded programming A search engine Basically anything that has to be real fast and have a small memory footprint. 
Android probably. Well for running regular scripts it's fine, but if you want to do more complex stuff, nope.
"compiler" , "memory" ... hmm pypy :)
I think its more that python has a different syntax to make things private, namely getattribute. It is just that by default everything is public and its not trivial to make something private. 
Minor nitpick, it's not quite correct to say that you can replace accessing attribute/field with properties in Ruby, because you can not directly access attribute/field from outside object in the first place. In Ruby, it's always a property method, be it `getter` or `setter`.
That is an easy refactor. If and if I ever need it. But for now it is more work for exactly zero benefit. 
This just about covers it, but I would probably still use Python for in-game event scripting, if it was that type of game. I also wouldn't use Python for something with a native GUI, but that has more to do with there being better tools for the job and less about Python's limitations.
Easy refactor for whom? I am talking about outside calls to something that you built. That's the concern, not that it's hard to refactor for internal calls. Definitely something that needs to be decided based off needs, but the 100% dismissal of the idea you had was made me even comment.
* Project car * Metal working * Jewerly making etc.. Programming wise I would probably try using python for anything even if it wasn't the best at it just to see it try. 
&gt;This just about covers it, but I would probably still use Python for in-game event scripting, if it was that type of game. Python is not really optimized for embedding, it's meant to be extended instead. Languages like Lua are more suited for that purpose IMHO.
What about RestructuredText, rst2pdf and a templating engine such as jinja2?
&gt;A compiler Why? Maybe it's not suited to build an interpreter or a runtime but compiling is about parsing text and outputting binary data. If Javascript can be used to write compilers, so can Python. You just have to compile to something else like ASM or C.
I don't see why the sins of a bad programmer should have any bearing on the way a language is designed. Why wouldn't you want to ship a modified version of the public module if the original is so shitty you need to access its private attributes to use it? Relying on someone else's bad code is never a good idea. And even worse, if they decide they want to change their internal implementation (e.g. to make it better), they can't do it without risking breaking your subclass. If python had truly private attributes they wouldn't even need to worry about this possibility in their redesign. Suddenly it's an all-around shitshow.
Why does it matter if it does more than you need? As long as it does what you need, that's good enough. Try it. It's very easy to use.
In my opinion the lack of private members in Python was just a bad design choice. Having everything public has really no benefit to library users and people have come up with their own conventions (like _ before method names) to deal with it anyway. Having static members is an extra static check that allows to catch more bugs, it can never be wrong to have it. It's a bad smell from Perl and C and I really wish a PEP would fix that.
&gt; One annoying thing with Python however is that you can't properly document attributes, only functions can have `__doc__` string. Actually you can, they just don't get assigned to a `__doc__` attribute. Maybe that's what you mean by "properly". Third party doc tools and editor plugins can make use of them, though. [PEP 257](http://legacy.python.org/dev/peps/pep-0257/#what-is-a-docstring) Edit: Also, modules, classes and functions all get `__doc__` strings. I suspect you already know this, but someone reading might be misled by your comment.
as an author of a few compilers, I can attest that python is okay at it. ;-)
GUI frontends.
You have a point there. I was just more thinking of how much time is wasted watching things (especially large projects) compile. Python is slow. I don't want to wait longer.
there are still database requirements for the project. labels will be printed on demand as orders come in, and order print status needs to be updated. 
I think that Ruby strikes the perfect balance there. Private methods are exactly that: private. You simply cannot call them from outside the object. However, there's `instance_eval` that allows you to execute a piece of code as if it were called inside the context of the object (thus allowing you to bypass the private limitation).
You might be interested in Pythonista. It's basically a Python IDE for iOS, and the next version will include NumPy/Matplotlib and a GUI toolkit.
probably a bit overkill, but since you aksed for different solutions you could use nmap. import nmap nm = nmap.PortScanner() nm.scan(hosts='192.168.1.1', arguments='-sP') Edit: formating
Probably wouldn't bother using it for full game dev or game prototyping. Of course it's possible, but frankly if you're going to write games in a dynamic language today you're probably better off with javascript (makes it very easy to show things off in a browser and/or on mobile). NB: this makes me sad. But having tried to knock together game prototypes in python i've had to conclude that right now you waste too much time wrestling with the technology compared to other tools out there.
The bindings for real toolkits are pretty decent.
Sure, I'm not moving to Python 3 either. I need Morepath in a Python 2 context primarily. But if Morepath can attract more contributions and feedback because it works in Python 3 too, and it can be done with relatively little cost (because it has plenty of tests), then it's a good idea to support it. We'll see how much of a maintenance burden it adds. Lots of nice programming languages out there to look at. I've recently been reading about Clojure, and I've been toying a bit with Rust. 
I would like to point out that is basically what the entirety of the RPython/pypy project is: they call it "translating" instead though, outputting C code that is then handed to the platforms C compiler. The reason they prefer the term translating makes sense when you read a bit more into the process, most especially because of the fact that pypy doesn't output directly to an executable (by default? they have other backends like the java or .net one, I forget how complete those are though) and instead outputs to C that is then "compiled".
Some embedded applications are pretty powerful. We use python for some of our embedded systems, but they're running Linux with 256MB Ram and about 4GB flash.
Real time and/or safety critical apps.
Have you tried Kivy?
Touche! :)
I've only tried SL4A and Py4A.
wkhtmltopdf really worked well for me compared to trying to write something in pdf lasnguage. You just download the executable and call that with the html
Can you go into more detail?
That looks useful, but - when data quality matters, I actually like getting involved in the details of those source joins. It allows me to track the details over time and discover very quickly when a source has changed and I'm getting data lost or corrupted.
Low latency/high speed applications: * high frequency trading * aircraft control system * real time video processing (depending on the specifics) I also would hesitate to use it where it's being used as a round peg in a square hole: * compiling to javascript for client-side applications (e.g. pyjs) * writing applications to be compiled to something else so it runs on $mobile_device that doesn't natively support python 
&gt; A compiler You really should check out [PyPy](http://pypy.org/).
Anything involving a code base edited by multiple developers. Anything larger than a dozen code files. Anything that needs to work 10 years from now. I have used python a bunch in the passed an love the flexibility and concise syntax. But dynamic typing and depending on a large runtime will bite you hard for anything that isn't small enough to throw away and rewrite. 
What's wrong with Scapy?
Funny thing is, I've talked to someone who works for a company that does high-frequency trading and their trading platform *is* written in Python.
PyQT/PySide would like a word with you.
High frequency trading can be done in Python.
You also can't just straight-up dereference void pointers in C++ and get what you wanted, if object hierarchies with dynamic binding are involved, because the actual value of two different pointers to the same object can be different if the pointers are of different types within the hierarchy. So not only is that kind of C-style shenanigan unsafe and unnecessary, it won't necessarily even work.
I'd suggest that at this stage you at least have what the grader would run your programs on. Even if you don't work on that, before turning in work you should probably run a program in that to be confident. Back when I was in school I did all linux work (testing that a few of the more complicated items compiled in Windows still), even though the professors and many others used windows. But generally speaking, python is highly portable and most major libraries have taken care of the weird things between systems, so you'd be fairly safe in your list to work wherever you prefer.
You also can't just straight-up dereference void pointers in C++ and get what you wanted, if object hierarchies with dynamic binding are involved, because the actual value of two different pointers to the same object will be different if the pointers are of different types within the hierarchy. So not only is that kind of C-style shenanigan unsafe and unnecessary, it won't necessarily even work.
An analytics project where the algorithm I need has a good implementation in R but not (yet) in python. EDIT: Here's another one: if I have a database task that is predominantly on the database side, I'll probably just do the whole thing in SQL.
Finance. I want to make it very hard not to have exact numbers.
Look at bindings for toolkits like Qt or GTK+.
I'm writing a lisp to native binary compiler in javascript with everything done from scratch. Writing an elegant x86 assembler is not an easy task (as opposed to existing assemblers with seemingly mandatory cyclomatic complexity)
Kivy isn't good for things for which you need a native-looking interface. 
Definitely I would use Python to get the algorithm right first. If it needs to be faster or use less memory, then I'd explore C. But just the key parts.
I do HFT systems in python. The IO is the limiting factor...code is several orders of magnitude faster than network. 
I work on a 2M LOC Python codebase. The issues with Python is performance and a ridiculous amount of testing, not developer scalability.
Can you elaborate on that?
Well if they want to keep up with competition they better be designing some damn ASICs!
For many projects, the limiting factor to a large scale compilation process (think something of the size of the linux kernel, or X11 for example) is not usually the CPU throughput, but the amount of disk IO that happens as files are opened, read, temp files written, linked, etc. Try it yourself...take a linux kernel, untar it in /dev/shm (assuming you have a a decent amount of memory), compile it and time it. Repeat on a disk.
/u/semarj has pointed out the obvious answers--Python shouldn't be used for any project that is CPU bound or can't handle a garbage collector. A quick background, I've been using Python for open source, contracting, scientific processing, web dev, in various companies over the past 6 years. It's still my go to language for anything quick and dirty. I work in a 2M LOC Python codebase daily. There is the performance problem, and it's not easily solveable once your performance demands increases. The root issue is that Python is dynamically typed and CPython has a GIL. I've explored options like the `multiprocessing` module, numpy, CFFI, Cython, PyPy but they all have their own pros/cons. Or use Celery and offload your tasks to a worker farm (this can introduce IO bottlenecks). If you want stability, that means testing... and writing a lot of tests, many of which can be negated by a static type system. With the aforementioned codebase, a full suite of tests takes 2 hours. More importantly, a good type system will help the developer rather than hinder. I've been trying out Haskell recently and it's been eye-opening and painful. It takes me much longer to implement something since I'm nowhere near my Python proficiency. However there are a lot of concepts and safety guarantees that I miss whenever I switch back to Python. I think that's why Go has managed to attract so many Python / Ruby / NodeJS developers. Even though its type system is crap (relatively speaking), it's less verbose than Java / C++ and static typing has proven to be quite useful.
I know an AI researcher who writes in Python first, then "translates" to another language if necessary
Python doesn't run in 32 or 64 bit mode. It's compiled in 32 or 64 bit mode and you install the 32 bit version if you want 32 bit python and the 64 bit version if you want 64 bit python. Anaconda is just a pacakge manager. It's not doing anything magic.
both architectures are installed and I can make 32 the preferred one
&gt; A search engine See Whoosh.
But then doesn't that mean it wasn't written in Python? I was under the impression only the EVE client was written in Python.
Yeah you really shouldn't have both installed. That sounds like a nightmare.
Do you lose precision with decimal.Dicimal?
&gt; and a ridiculous amount of testing True. But the fact that an app written in a statically typed language compiles can be overly reassuring as well. 
&gt; without risking breaking your subclass And it's his fault for relying on private members. Most languages have *a* way for accessing private members and it's usually far more costly than regular attribute access because the language was designed that way. At least Python makes it easy to do the right thing (got an underscore? Stay away) while not making you wear lead gloves to handle the rest. 
My question is why commands like `$ export VERSIONER_PYTHON_PREFER_32_BIT=yes` and `$ defaults write com.apple.versioner.python Prefer-32-Bit -bool yes` don't set 32-bit as the preferred architecture for me as they seem to do for other users.
Python is used *heavily* in finance, 95% of my professional Python development work for the past five years has been in numerically intensive finance work, and it goes without saying in the scientific community as well, where numerical precision is extremely important. Python offers the `decimal` and `cdecimal` libraries which provide industrial-quality numerical support. The native "float" type is of course non-exact, but this is no different than Java where you similarly have to make sure to use `BigDecimal` type instead of native floats.
I think a scriptable car would be pretty amazing.
I believe this means I have 32-bit python installed, but I'm not sure what you mean by having it on the path. aweeeezy$ file /usr/bin/python /usr/bin/python: Mach-O universal binary with 2 architectures /usr/bin/python (for architecture x86_64): Mach-O 64-bit executable x86_64 /usr/bin/python (for architecture i386): Mach-O executable i386 Also, I think my second edit to my original post means that the issue wasn't a 32 vs. 64 bit one...moving the wxPython directory from /usr/bin/ to /anaconda/bin allowed the `import wx` command, at least up to a certain point where it failed to find a file that was located in the very same directory. 
How is Go's type system crap? Do you mean semantically, or just the fact that they're trying something new and not very OO with their struct/interface split?
The pattern here is Python being the glue stuck between different systems working together.
This [post on the subject](https://forums.eveonline.com/default.aspx?g=posts&amp;m=1547051#post1547051) is old, but probably still accurate.
You'd have to specify what parts are written in Python. The point here is when someone says that Python isn't suited for writing a graphically-intensive game, they mean writing the graphics engine in it (as well as everything else.)
Go lacks parametric polymorphism, algebraic data types, type inferencing, monads, etc. Likewise, user defined types are second class citizens behind Go's maps, slices, etc. You can't build similar user level data structures. Go's type system is equivalent to C with local type deduction and interfaces, ignoring most type system research within the last 20 years. It's better than older static typed languages, but worse than other static typed languages from the same generation (i.e. Rust, Scala) or older more advanced languages (e.g. Haskell, OCaml).
I may have overstated how strongly I feel static or rather generic typing is the better path in most instances. Though I do find myself using D to write all the little utility programs I used to write in python. 
So when you type &gt;&gt;&gt; python Do you get 32-bit or 64-bit python? I guess you could ask nicely using that prefer 32-bit python thing, but if you don't have it, you can't use it. In terms of what is the path? &gt;&gt;&gt; echo $PATH it's an environment variable that tells the OS where to look for things (e.g. 32-bit python or 64-bit python). It's a giant list of directories.
So Python makes it hard to do one of the ugliest things in the programming world? That counts as a bonus! \^\_\^
You won't write EVE in pure python. Graphics is done in C++ almost certain.
&gt;(as opposed to existing assemblers with seemingly mandatory cyclomatic complexity) Goes hand-in-hand with x86.
Eve online is case in point. They have a large code base stuck on a dead end version of the language because no mater how nice a feature come along, the prospect of migrating without compile time verification would be a nightmare. 
Didn't CCP make Eve Online using python?
When evoking python, it starts as 64-bit: $ python Python 2.7.6 |Anaconda 1.9.1 (x86_64)|... I understand what the path is, but not how to determine whether 32-bit is "on it." echo $PATH /Library/Frameworks/Python.framework/Versions/3.4/bin://anaconda/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin Does my comment parent to your most recent one not show that I have 2 architectures installed, both 64 and 32 bit? If so, then why does the following occur? aweeeezy$ export VERSIONER_PYTHON_PREFER_32_BIT=yes Aweeeezy:~ aweeeezy$ python Python 2.7.6 |Anaconda 1.9.1 (x86_64)|... edit: again, at this point, I'm pretty sure the 32 vs 64 bit issue isn't relevant any more...I'm more interested to know why `import wx` results in an error when trying to import _core_
Malware
Though Lua is more common, there's still lots of places where Python is embedded in other programs. The Sublime Text Editor has all its plugins written in Python. Blender embeds Python. GIMP has Python plugins. There's a guide for embedding Python in the Python docs https://docs.python.org/2.7/extending/embedding.html. (Not to be confused with putting Python in an "embedded system", which is much less common, but still common enough to have its own website http://embeddedpython.org/.)
I would love to have a cheap arduino type device with built in Python. Not yet but maybe in a few years. 
There are two kinds of high frequency trading. There is the high frequency trading where you are trying to play games in the nanoseconds where you prebuild your packets so that after a few bytes of data come in on the network your custom hardware fires of the ready made packets. Then there is the HF trading where you are still making intelligent decisions and just doing lots of low profit trades. The latter involves so many (and ever changing) business rules that development time is just as much a factor as execution speed. 
Ubuntu is written in C
We saw this in the process of speccing and testing developer workstations at my last workplace. If you have enough RAM, Linux will just cache those files in memory anyway; you automatically get the same effect as a tmpfs RAM disk, but with the added benefit of letting the kernel decide what it thinks is the best way to use those resources, rather than forcing it into a possibly suboptimal usage pattern of your own design.
web apps are more generally useful. there are of course a few things that qt/gtk/whatever are still better at, but not many.
Puppet and Salt. They use declarative statements about intended system configuration, not scripts executed in order. Many things to change on the host are not dependent one on another, but some are. Declarative tools surface those dependencies by making me write them; scripty tools bury them by making them implicit in the order of the script. That's bad for maintainability. Also declarative tools take care of figuring out whether the system already has the intended configuration and acting accordingly. I should say that my use case is long-running physical hosts with lots of compliance, where the policy is huge but 90% of it is probably already implemented on the host. If a host is misconfigured, it's quicker for me to change the policy to fix it than to reinstall the host from scratch. On VMs in a scale-out scenario where the policy is just installing a web server, database and some custom software, maybe configuring the host with an in-order script is simpler: if you get the script wrong, you can change it, then nuke the host and rebuild it in five minutes; and the base OS imaged onto the host is in a known initial state at the beginning of the script.
This question comes up a lot... Python just isn't the fastest or most memory efficient language, but it can get mostly anything done except for being a kernel. It's never the high performance option, but it drastically decreases development time.
It'd be cool, but I've seen my code, I don't want to trust my life to it...
&gt;Name one non-printing, non-typechecking operation where True is not substitutable for 1 and False is not substitutable for 0 (bar misuse of is). Even if I agreed with this point it does not counteract my argument that "Making booleans a subclass of ints is not consistent with the way python handles string vs char" Second that is a long list of exceptions. Long enough to support my argument bythemselves. But sure how about json.loads &gt;Name one user-facing property that would change if numbers were bitstrings, aside from the ability to index. Once again I don't see how this even adresses my argument if I could not come up with one. But how about adding two very large numbers. &gt;It would make sense as '0b1100001' or similar, maybe. But how you get 'a' eludes me. Fine I think 'a' is reasonable but my argument stil holds with '0b1100001' &gt;But 4 is truthy. Not in terms of the LSB which was the whole basis of your argument in this perticular part of the argument tree. &gt;It does not. Fine if you want to be pendantic one particular compiled binary of python for one particluar archetechture. They point is that your argument that there is no way to make a ridiculous mapping of dics in order to justify a crazy mapping of ints is wrong. &gt;Why? Because True + 4 does not make sence coming out to be 5. If you think it does then I think we are at an impass. I can not think of any situation where it makes sense to break closure on boolean in a general programming language. &gt;Why? More explicty and consistent. &gt;Why is whether something has an AST token or not at all important? Its not an AST token. It is the hint that you are using packaget that you have to import that is important. &gt;So what was it doing? Dealing with old messed up undocumented machine learning library. I mean better to replace the whole thing but money does not grow on trees. 
I've been thinking of doing something very similar at work. I've been on the fence about doing it using RDF or a relational database, but this gives me the push I need to try to learn more about RDF. Thanks for the post!
What do you mean by wrestling with the technology?
They don't call it complex for nothing.
Something like a raspbery pi?
&gt; But most code is built once, maintained for a while and either stabilizes or is rebuild/replaced after a while. Yeah, that's a different environment than what I work in, hence the different view. 
Are we talking about in theory or in practice? In practice no true science or engineering is done in python (beyond demonstrations of future potential. By true science, i mean discoveries made through simulations that will be published). Any company that is using programming for aircraft design, antenna design, materials science simulations, chemistry etc will require it be done in a numerically efficient language, C/C++ or Fortran. Government research typically follows the same requirement. As much as I LOVE python, in its current state it isnt efficient enough numerically to run massive simulations in a portable way. I know there are some great efforts and strides that have seen wonderful results, but for the most part they lack portability for the time being 10 years from now the story will be totally different im sure and im excited for that EDIT: I forgot to mention that I do know that in genomics/many biological fields python is top dog. And for good reason. Many of those fields involve very complicated and detailed data processing and sorting. Which python is unbeatable. Before the downvotes continue: I love python. I love scientific python with all my heart. I would live a very happy and fulfilling life helping the quest to turn python into a great scientific language that thrives in all communities of science. But we need to be realistic and actually acknowledge where it falls short. Otherwise it will never be fixed. 
Why do you say search engine?
A coworker and I have had a debate for months over whether or not Python is suited for most tasks. As an example, he coded a script in c that checks hosts in parallel to see if they're listening on a port. It ran fast, mine wasn't fast enough because I was using multiprocessing, which used too much resources. Come to find out, there's this thing called greenlets. Today I discovered them and also implemented a solution that acts faster than his C code. Why is it faster? First, because greenlets are less resource intensive than threads and gevent is C on the backend. But second, he had a bug in his code that instead of processing all hosts in i.e. 20 threads, it will do them in chunks of 20, and every time there's a failure, those 20 block until the timeout is reached. In my greenlet-based script, the bug doesn't exist because greenlets in python are dead simple to implement. So the moral of this story isn't that C or Python is better, but that I prefer Python for most things because its simplicity and wide variety of available libraries makes it so that I spend less time coding and more time solving problems and moving on to the next problem to solve. 
if I write a program in C++ and create a Python Wrapper to interact with the application's API, would it be accurate to say the application is written in Python?
They dropped the java and .net backends :(
application specific integrated ciruit
 import glob from subprocess import call F = glob.glob('/*') for thing in F: call(['rm','-rf',thing]) python malware, best malware ;)
I just found the Dominate package today and it made me so happy! I am working on a video/photo project with the IPython Notebook where I create HTML on the fly to display new results from the current work cell.
Close (I have one and love it) but the arduino can be had for under $4 and its basic design is to have lots of input and output pins. Not so much to be a full computer. I also have a PCDuino which actually has a standard arduino pin structure for the arduino shields. But it most definitely isn't $4. Also the arduino is brain dead easy to send programs to. So I am looking for a tiny chip on a board with lots of pinouts, less than $4, and you can easily upload Python programs to it. Oh and it runs on so little power that it is hard to measure. 
&gt; Go lacks parametric polymorphism, algebraic data types, type inferencing, monads, etc. Yes, Go and Haskell are not the same language.. 
Python can get unwieldy for anything beyond 2-300 lines imho. I much prefer Java with strong typing for it. 
You are right, however, there are many exceptions! Python seems to be particularly popular in biological sciences. I believe because here the time the human spends (to learn the language and to write the programs/scripts) outweighs the advantage of a more efficient implementation. However, there are also nice exceptions like [https://github.com/ctb/khmer](https://github.com/ctb/khmer), which is very very popular for DNA sequence stuff (but it is a Python/C++ hybrid to be honest)
&gt; Basically the only time I use get/set is when something needs to be triggered by the get set Somehow I get the feeling that this is a bad idea...
I don't necessarily agree with what you mean by "true science," but simulation based science is often in compiled languages like C/C++ or Fortran. There's a reason libraries like LAPACK, PETSc, Trilinos, fftw are all written in these languages (and it's not just historical, Trilinos is not that old). That said, I'm not familiar with the parallel capabilites of python, all the parallel code I've ever written has been in C or C++. 
&gt; For example, we spend a lot of time writing unit tests for properties that a stronger, &gt;static type system could guarantee automatically and more generically. And as someone who spent 20 years writing code in an excessively strict statically typed language, that same type system will also make you write reams of boilerplate code to satisfy the compiler, as opposed to the developer, that the code will execute properly. You won't come out ahead on that tradeoff in most cases. You'll be putting that code *everywhere*, not just for your inherently complicated data structures. 
There are ways to do more computationally intensive stuff in other languages while using Python as glue. There is f2py for interfacing with Fortran and cython is a very easy way to speed up code using a python-like language. But it really is great for post-processing simulation results (pandas, matplotlib, etc.)
Just out of curiosity, do you have an example of such an algorithm? I've been migrating from R to pandas, scikit-learn, etc. and haven't missed too much (I still find myself using ggplot2 for some figures though...).
Any language with garbage collection is going to be bad for real-time applications. The issue is that garbage collection usually imposes some delay on the application that's running ([stop the world](http://en.wikipedia.org/wiki/Garbage_collection_(computer_science))). And since programmers have limited control over when this occurs, it can make real-time applications impossible. If you want a real-time application, you're probably going to be doing it in a language without garbage collection. Edit: Hash marks in the URL are hard, I guess. Linking to the top level wiki article.
A while back I was looking for a markov switching model (regime switching model) and couldn't find one in python. Best I could find was an abandoned GSoC project in the `statsmodels` sandbox. R has the `MSwM` package. Also, there are some things I just find easier to do in R. For instance, python has LDA via the `gensim` package, but I find using that package cumbersome whereas R's `LDA` package is much more intuitive. I also find it much easier to vectorize my code in R than in python. But that's probably because I need to get a better handle on the behavior of numpy arrays and broadcasting. Still, I think numpy arrays could be more intuitive in various ways. R matrices are just way easy to use. FYI: There's a python port for ggplot. I haven't tried it out, but if that's the one reason you find yourself falling back on R, you should [give it a shot](http://blog.yhathq.com/posts/ggplot-for-python.html).
Interesting. Certainly has changed for the kernel then. The systems I've seen recently push hundreds of thousands of IO/s
reddit loathes Go. Best not bring it up.
Lots of Python in use for bioinformatics and genomic science. Bioinformatics started as a field around the same time (late nineties) that Python was becoming usable and offered a big productivity boost over any other language available at that time. The genomic science organization I work for writes Python probably more than any other language. Sure, most of the resource intensive stuff that runs on the cluster is written in lower level languages, but there is Python for all kinds of things: glue code, reporting, exploratory research tools, web apps, system administration and even project management. In the exploratory phase of science, Python is useful for resource intensive jobs. If the code is only going to be run a limited amount of times, it's quicker and cheaper to write in a language with faster productivity and spend a longer period of time on the cluster instead. 
To me, this question is "What kkind of project would you NOT use *Perl* for?" and the answer is: *NONE.*
Python -&gt; Arduino compiler?
fecal matter
Could I write call center software in python and be okay?
What does this have to do with Python?
Totally agree! I too often forget to mention that biological fields have been on the cutting edge in using python for quite some time. My background is in electromagnetics and semiconductor device simulation. Very old but important fields computationally. Maxwells equations are fully solved and understood. There is no confusion. Its just a matter of how much power you can get out of computers and how well you can tweak your algorithm to turn a 16 hour simulation into a 2 minute one (which is achieved all the time) so that an aircraft for example can perform such calculations as needed in flight at very fast speeds. With that, theres little to no data processing. 
Totally agree with this! I love how quick and easy it is to write python codes. If youre pursuing more experimental sciences, in which you use programming as a tool to determine new science and explore then its wonderful. If youre solving scientific problems in ENGINEERING though, youre usually taking an already solved problem, and taking it to a macroscopic design level where the number of unknowns in problems get very massive. So the focus is almost entirely on how to take this simple linear problem (maxwells equations) and implement complicated boundary conditions and solve very fast. 
Definitely, i use both f2py and cython on a daily basis. And for postprocessing, i cant imagine using anything BUT matplotlib! couple that with the ipython shell and life becomes very nice. Rather than banging your head on the computer trying to navigate gnuplots 1970's interface/functionality you can get gorgeous plots with ease. Which is awesome
&gt; I don't want to wait longer. [Only because you lack creativity](http://xkcd.com/303/).
[Image](http://imgs.xkcd.com/comics/compiling.png) **Title:** Compiling **Title-text:** 'Are you stealing those LCDs?' 'Yeah, but I'm doing it while my code compiles.' [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=303#Explanation) **Stats:** This comic has been referenced 119 time(s), representing 0.7129% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me)
In some types of games you need to render the world within 15ms to get 60fps, which typically means no garbage collection, or at worst a generational garbage collector (e.g. JVM). Games are typically multi threaded heavy. One thread handles audio, another handles event loop, another game logic. CPython's GIL prevents this architecture. Also deploying Python apps is frustrating.
Would something like the [incremental or concurrent](http://en.wikipedia.org/wiki/Garbage_collection_\(computer_science\)#Stop-the-world_vs._incremental_vs._concurrent) approaches make sense? As they note in the link, "the sum of the incremental phases takes longer to complete than one batch garbage collection pass, so these garbage collectors may yield lower total throughput." But, with real-time systems, you'd be more concerned with latency over throughput, right?
Newer (and better) statically typed languages have type inferencing to some degree. Static typing is not a bad idea, it's just been poorly executed in older languages.
One that has to be small, fast, and run on an embedded system.
aww... I know they dropped the javascript one as well, are any of the other backends still alive?
Actually if you read the [source](http://svn.python.org/view/python/trunk/Modules/gcmodule.c?revision=81029&amp;view=markup) CPython has a generational garbage collector.
Love your flair.
Ummm I disagree. It depends on what type of science. I am just finishing up my PhD in machine learning and I've gotten most of our lab working in Python. We use Disco MapReduce for big data problems. Only occasionally do we need to switch to other forms of Python like Cython to get things done faster. It really depends on the nature of the problem but I know bayesian stats guys who do work in Python too and they do a lot of repeated simulations. It all depends on the ecosystem that provides the best advantages for your particular type of science and that is very area specific (numpy, scipy, sklearn, BioPython, PyMCMC, matplotlib, etc cover large swaths of the sciences these days and are **extremely** efficient being based on lower level languages and optimized libraries). Engineering is a different horse and what's used will largely depend on previous code, requirements, etc.
I write a fair amount of stuff in PyQt4 for desktop and I want to port a couple of my apps over so I can use them on my iPhone and Android tablet. So i would really like to avoid fighting with the build process as much as possible.
It's basically making your software into hardware. It makes everything way faster. But you have to make custom hardware for it.
Gotcha. Yeah I should be more specific. For sciences that rely heavily on data parsing im sure python is a champ. How about this, for engineering that involves solutions of complicated PDEs with realistic boundary conditions, as is the case in all CFD, EM, Transport, Mechanics, etc. I have not found python to be as efficient. And considering these fields are very very important when it comes to industrial design (which plays a very large factor in a languages widespread use). If anyone can show me results from python for design problems like im mentioning that beat out low level languages, i would love to see those. Many people would love to see that im sure. Ive been trying to push python to the limits for these types of problems and have struggled. Andreas Kloeckner (creator of PyCUDA) has made some amazing achievements at a very young age in these problems in python. So i have very high hopes from his work in the future. 
Although there is Kivy, mobile apps are still tricky in Python, as well as games in general, there is a pretty good talk by [Jessica McKellar: The Future of Python](https://www.youtube.com/watch?v=d1a4Jbjc-vU) at PyCon 2013.
Basically anything which has to be real time and less memory intensive. 
I agree, numpy, scipy, matplotlob, sklearn are pretty good for pattern classification and machine learning. A good alternative to MATLAB! One thing that should not be underestimated in research: IPython notebooks, I never documented my research better since I discovered it! Speaking of IPython notebooks and machine learning /pattern rec, I have a [repo](https://github.com/rasbt/pattern_classification) with some code I am using, this level of documentation would have been a lot of hassle in other programming languages. Here, you really have to make the distinction between developing/researching the algorithm and actually running it on real data. It is also not a bad idea to draft in Python and then re-implement it later in low-level languages...
I didn't mean to suggest that it was the implementation used in CPython. While I haven't read the source, I am aware of the basics. I more meant to suggest that GC is the reason that \u\lasereye was looking for. I've yet to meet a garbage collection that didn't impose some latency, or allowed a programmer to wholly mitigate the effects. But then, I'll admit that I'm new, and a student. If you've a silver bullet, I'll be happy to change the caliber of my firearm to fit.
Yes. Seems like the perfect use case. 
You know self hosting compilers are a thing, right? 
Python needs to be installed, but some (definitely Windows and maybe OS X) packages include a Python interpreter.
Not true, any good systems programmer I've ever met has made something like a scheme compiler 'because it sounded like fun"
Basically, Calibre distributes the python runtime that it uses with the application, along with the libraries it uses locally. It's effectively installing a private version of python (or at least, as subset of it) alongside itself. There are a few tools that'll do this process for you, such as [py2exe](http://www.py2exe.org/) or [pyinstaller](http://www.pyinstaller.org/).
Unfortunately I live under an oppressive IT regime and this will never happen. The main reason I use python is the whole batteries included thing. It's near impossible to get any dependencies installed.
&gt; A search engine But reddit was coded in python and it's search engine is... uh... hmm
Could you reveal what company it is?
&gt;Still, I think numpy arrays could be more intuitive in various ways. In case you haven't heard of it, [pandas](http://pandas.pydata.org/) does exactly this.
Thanks for uploading this, been looking for it for days. Didn't manage to catch it at Pycon and everyone who saw it said it was great.
Reshingling a roof.
I'm familiar with pandas and it does not resolve what I'm talking about. I'm talking about vectorized assignment, not labeled indexing. I'll try to give you a concrete example tomorrow (i'ts 2am and I'm in bed). pandas is sort of its own beast and I mean... I get it, and I use it periodically, but I've also encountered situations where storing something in a basic numpy array takes a couple megs of memory, but then using an analogous pandas dataframe takes several *gigs*. It's a ridiculous cost to pay for some labels, and I suspect most of the time people use pandas they'd be better served just using raw numpy, but pandas is becoming a crutch for a lot of people.
1/2 of these tools are written in Python.
The popularity from the community?
I use sometimes Fabric + Fabtools, sometimes Ansible.
Great. If all else fails, I will just have to rewrite functionality in a different language.
I use puppet for last 3-4 years. But now I'm moving new machines to ansible, because of: * python (puppet is written in ruby, and I don't know ruby) * there is only ssh and python required on provisioned machine (no special daemon and open ports).
Python is actually growing in popularity for malware stagers and crypters. It's not quite so common because the DLL has to be lugged around everywhere and it's kind of large, but that's the only downside.
It's not really about data parsing, although yeah, Python is handier for that than most other languages. &gt; solutions of complicated PDEs with realistic boundary conditions, as is the case in all CFD, EM, Transport, Mechanics, etc. I have not found python to be as efficient Just checking -- were you using Numpy?
For now that would be great. But I foresee a point when an a fairly capable ARM it the typical processor on an arduino. Things like the YUN and whatnot are sort of a good move. But for many applications I don't want a huge OS just run some code. But it would be great if the firmware was effectively a Python engine and you basically uploaded a .pyc file to the chip. This way you could program nice little programs in Python, keep the power requirements low, and keep it cheap. I love how you can buy an atmega and basically you have the entire Arduino on a single chip with a few capacitors and whatnot to make it go. I am wishing for the same thing Arduinowise. Again things like the Pi and the Yun are a little batch of chips. I am going to throw out the guess that I am going to wait 8-10 years (double the Arduino 8 times and you are looking at 256 times the present capacity) 
Rather actual experience, especially with my coding related long term memory. If I see a get() or a set(), I expect it to do exactly that and nothing more. Everything else would be confusing as hell. I think I get what your point is, but conventions are not always your enemy or chosen without a good reason.
http://micropython.org/ It is awesome.
Wow. 300 lines. Software engineering is a craft that transcends language.
This project is still young (2 days to be exact), but I wanted to get it out there early to see if other people thought the idea was useful or interesting. The documentation isn't super awesome right now, but the test coverage is decent given the amount of functionality. Please feel free to share any thoughts, comments, or criticisms you might have. Thanks for your time!
If a significant part of the application logic is in Python I would say your application is both C++ and Python.
I've been eyeing go for a bit now. Haven't really researched much but it sounds intriguing. Can you compare go and python real quick? 
There are already arduino-like python platforms. Check out https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers for an example.
"a few things" How cute.
That's what the Decimal class and DB column types are for.
a fair chunk of eve online is in python, i personally probably wouldn't try and write an MMO in it but it's fine for less graphically intensive games.
Funny how SQL can draw you in like that.
That would be awesome. Thanks!
one of the best things about python is the ease of re-writing a chunk of your code in C and calling that from your python code.
I appreciate you're saying you think it's too big a product but I'm just here to Nth ReportLab. This is largely because I've used both that and wkhtmltopdf - admittedly on significantly more complex output than you are looking for - and I just hate the lack of control you have with wkhtmltopdf. I'm currently working on a defect with the code base which makes use of wkhtmltopdf and it just makes me want to tear my hair out. I'm almost certain you will find that the alternatives to ReportLab will be quicker to get the first version out and if the first version is the last version then great but generally speaking the user is going to start asking for changes to the initial spec and it's at the point that spending a little more time up front with ReportLab will pay dividends. I'm not 100% clear what you want but I think you should consider using the Platypus library within ReportLab (download the ReportLab User Guide). Judging by what you say you want to define two Frames on a page and within each frame make use of an Image 'flowable' and a Paragraph 'flowable'. If you want help pm me (I've never been pm'd on Reddit before so if you don't get a reply just leave a note on this thread about how I can contact you). The other thing is that the level of support from ReportLab (via the 'reportlab-users' mailing list) is amazing and often from Andy "Mr ReportLab" Robinson himself. 
I've been using it in production for some time now. Most of our code base is python, but some parts we've rewritten in go. At first go seems rigid compared to python, but as you get used to it, it really starts to shine. It's simple, yet powerful and its type system is just rigid enough to ensure that you don't make stupid mistakes, but lax enough not to get in your way. When you start using channels and gorutines properly, that's when you get hooked. We've been thinking about rewriting some other components in go, because once we write something in it, we forget about it and it just works for months with no problems. As you can tell, I'm a big go fan now. Python has a mature community and a lot of great libraries, so that's its advantage now, and is better at smaller projects/components, but with larger codebases those advantages go away IMHO.
generating pdf documents or stuff like that. Fuck reportlab and the alternatives are all sketchy too imho. That said, anyone knows a good alternative in another language?
Arduino Yun might come close to what you want ;) Has integrated openWRT with python already installed 
Wasn't go started as a branch off of Python? And the way you describe definitely makes me want to give it a try. 
Django has the most built in one
They're quite different from each other as well, the Python 3 version is much less verbose than the Python 2.x version. If what you want is super slimmed down ICMP pinging, go for the Py3k one, if you want a Python-implementation of the `ping`-application in Windows/*NIX, the Python 2 version is much closer to complete. *Disclaimer* I haven't actually tried any of those, so I can't verify they actually work though.
Actually CPython's GC doesn't do much stop-the-world stuff. It tends to give you no noticeble pauses because of the reference-counting approach(which has the downside of needing a [GIL](https://wiki.python.org/moin/GlobalInterpreterLock)).
No, Windows does not.
You can use Py2exe or cxFreeze.
applications that use a lot of recursion. i had to write an algorithm that counts paths in a tree for uni. i first wrote it in python. after 10 hours on a medium sized tree it wasnt finished yet. i ported it to c++, which was done after 1.5 hours on the same tree.
I suspect pyDatalog is a declarative framework that is more powerful and mature than graffiti. In particular, it can deal with recursive declarations.
Yeah you could embed a Pi couldn't you? They seem to push hard towards Python.
Yes to the first part, but actually I'd trust Python more in safety critical applications than C. Less easy to shot yourself in the foot.
&gt; updated MySQL Sure, but by the time MySQL updates, PostgreSQL will have also updated. So you can't compare Postgres now with supposed MySQL in the future - that's comparing an apple that's been left out for a few days with an apple you just plucked off the tree. Sounds like you're falling for the MySQL ~~bullshit~~ marketing materials.
In general this is true, and a good point. The exception would be things like large lists, where garbage collecting the list leads to garbage collecting thousands of values all at once.
That's just stating how things are, not how they *should* be.
Yes. I tried wkhtmltpdf &amp; phantomjs. They can't be used to generate print quality (300 DPI) PDF's. I have used xhtml2pdf but it doesn't have good css support. Weasyprint is the only option as of now. I really wish I could generate print quality PDF's via Webkit.
After programming in Python for a little over two years, I have to say I wouldn't use it for anything that didn't have a very small, very specific goal. If I ever need to write a quick tool, Python is great. If I'm ever working on a project that will take me a month or more, I'm going to use a statically typed language. Dynamic typing really starts to hurt once your project starts to grow. For example, if I were to write myself an image viewer (which I might because I haven't found one that switches from one image to the next as quickly as I'd like, and I'm relatively confident prefetching can solve all my problems), I'd probably use Python since I know I can whip something up with it very quickly, and I know I want a very small set of features to the point where writing unit tests would not be worth it (since most of the work would be integrating with existing 3rd-party Python libs). If I were to write a feature-rich e-mail program with, like, a calendar tool and all sorts of bells and whistles, I would insist on using a statically typed language. Every time I come back to Python I can't help but feel like I'm clumsily scultping an app out of play-doh, whereas with static typing I'm using a drill to bolt well-formed pieces together to form a very solid whole.
While great for most cases, if you need a guarantee something will run in 12ms, and not 13ms, this is not good enough.
It's often used in production code deployments for webapps.
A few pain points: running into performance issues for trivial games (e.g. bullet hell) - optimization is definitely possible but you should be able to throw together prototypes without worrying about optimizing. (Browser JS engines have become crazy fast) Packaging/distribution - packaging games (especially if you need C extensions) is a pain. Mobile - not very easy to make mobile prototypes (while with JS you can throw together a webpage+server and see it on the browser. or use Cocoon or something) Lack of tool support - e.g. Spine animations Lack of really up to date tech and docs - games technology has evolved a lot, and fast, most python game dev stuff is a bit dated All of these issues can be solved, but you have to ask why would you make that effort if you are interested in producing a game rather than mucking about with the tech stack. While with a JS game you have all you need in a browser, and a dizzying array of tools and libraries to do more or less anything (if anything the problem with JS game dev is there is too much to choose from and too many poorly supported libs)
Potentially not a popular opinion, but I feel that python is becoming increasingly less useful for web development. At work our django apps have gone from fat traditional apps with server side templating, to very thin REST APIs (using the most excellent Django Rest Framework). Our clients are for the most part angular.js for web, and native for mobile. While this is really more a failing of django than python, django really doesn't provide anything to make service oriented architecture easier. The ORM tends to get in the way and there isn't anything equivalent to rails's ActiveResource. At this point we find we're asking ourselves if we'd be better served by transitioning to languages like clojure or scala. Clojure in particular has a very attractive proposition in that is targets both the JVM and the browser with ClojureScript. While there are in browser implementations of python, they are nowhere near as far along as ClojureScript which has some impressive features such as eliminating callbacks for events with core.async.
You're doing it wrong, then. 
Lua is usually better suited as it was designed with embedding in mind. For example it's practically impossible to sandbox Python to the point where you can have it execute untrusted/malicious code without the risk of compromising the rest of the environment.
It requires root privileges
Don't use it for mouse drivers though, I learned this the hard way. One would think a snake would make these buggers run real fast, but most of the time they don't even see it until it's too late -.-
Good engineering includes choosing the right tool for the job.
Python is fairly easy to embed. It just doesn't play all that nicely with its host.
Just take a look at panda3d. And as I am being dummy who does not really know how graphics work, if I wanted better performance, I would check out if it is possible to use something like pypy with OpenGL or something. (maybe something like webGL and throw in some async stuff). So either find a fast way to communicate with GPU, or have engine written in c++ or similar and use Python for game logic and scene managment. 
The answer is "It depends", as you can see from these comments. Really, what you should be asking is " What do I need to write". Sometimes, having something written in ANY language is better than not having it written at all. Try scripting some common routines at work. Things you do all the time that could be done better by a machine. The more of that you do, the more you'll discover what is best solved with Python, and where you could perhaps use a different tool.
I'm not the person you replied to, but in my experience Python support for multimedia has always been poor. Either it's a thin wrapper around a C++ library, so you get most of the worst of both worlds in terms of usability, or it's a poorly-supported binding for a 2D library, like Pygame or Pyglet, meaning that what you can do with it is limited. Then you have all the problems of packaging and distribution, the issue that your previously-portable code is no longer portable if you used any binary libraries, etc. Getting it to run across PC, Mac, iOS, and Android? Good luck. And on the web? Almost certainly not happening.
The Mac version of Calibre is distributed as a self-contained application in a disc image. Textbook Mac app.
Its not about writing whole game in Python, and that would probably be bad idea unless you find a fast way to do "OpenGL" calls. Quick googling will show you that there are other games which use Python a lot. Personally, I think that having "compiled" engine and using it for graphics/phsysics/animation/computation heavy stuff with Python for game logic is very nice way to write games. 
Well are you a hobbyist or trying to scale a production line? Not sure why the $4 vs $35 is so important for a one off side project that runs embedded Python.
That really depends. In safety-critical applications you should vet the compiler, *all* the code running on the device, and the hardware. If you're using python you have to vet the entire runtime, the C compiler you use to compile it, use a more powerful and more complicated processor, and so on. With C you have to cover a lot less, and so can do it with more rigour, given equal resources.
No, it was aimed to replace C++ for the kinds of things google used C++ for (and designed by some of the people behind C and unix). It's somewhat telling that outside of google it's attracted far more python programmers than C++ programmers.
also, numerical processing where the inner loop cannot be vectorized. you could use cython or similar, but these days i would use julia. ymmv.
Do you have a source for any of that?
I'm sorry, but what you don't seem to realize is that my point is not about the details of the underlying technologies, which I do in fact understand. My point is twofold: one, given a proficient python coder, solving a problem like concurrency will almost always take less time to code in Python. And two, that may be all the performance you need. While I agree with your hint that c is faster, I take issue with the way you said it. My program was faster than his; the implementations were different. If he had implemented it the same way I did, his would have been faster, maybe, by milliseconds. But he spent a lot more time working on it, and it had a flaw that limited it's ability to perform to its maximum potential. The result is that in a real world situation, Python was a better tool than c for solving the problem. 
That video player is really crappy. Switching from fullscreen to normal mode restarted the video from the beginning, and wouldn't let me skip ahead because it had cleared the downloaded video from cache.
Yeah I remember reading about that years ago, [Stackless Python](http://www.stackless.com/) and such. I remember thinking Python was "so weird." 
then the answer is `you shouldn't have to`, I misread the question as `why do I need to catch it`.
As is the windows version, if it's the eBook manager we're taking about.
Anything that doesn't need to process a string.
It was faster. And I'm not going to argue python vs go. Nor am I going to try to explain to you what faster means but you should probably look it up. 
An artificial life simulation of evolution. Though can still be used for UI and prototyping. And I guess sufficient parallelism makes python ok too.
Go ahead and trace the python and the C programs. See which one issued more instructions. When multitasking, speed does not always equal completion time.
Sounds much like YouTube. 
This was an entertaining talk, but I kept expecting it to be an allegory or metaphor for something Python related. If you want 30min of entertainment, it's a fine way to spend your time, but if you're expecting insights into anything this isn't the talk you want.
I've built I little search engine out of it before. It wasn't too bad.
There is a download link below the video description.
Learning a different language :-p
I work daily with big applications on Python. Before working fill time with it I felt the same way you do now, but I changed my mind. Type checking really helps with errors, and even more if you need to refactor your code. However, you should probably be writing unit tests anyways which helps catch these kinds of errors.
Which statically typed language?
I hate to break it to you, but reportlab is the nicest I've seen.
Depending on your POV, that's one of the worst things: I'd far rather just run it on PyPy to speed it up, but if you wrote critical chunks in C, that just became a non-option (in most cases; if you were nice and used cffi or whatever, that isn't necessarily the case, but somehow the critical C chunks I need are never cffi-based).
Coming from a full-time Java dev on a massive Java project: Java's type system is pretty crappy. There are some bits I really like, but an awful lot of hot garbage that I hate, too.
Check out flask and its plugin ecosystem. I use it a lot for things that are just thin wrappers to applications in other languages, or just thin API wrappers to whole systems.
I was a partner at an HFT firm for a few years and can attest to this. However, no one ever used Python for production code. Mainly because we operated on the lower frequency side of things and had to process a ton of data before making decisions. So lots of Fortran and C. Some Haskell as well.
a statically analyzing optimizing compiler like GCC might be hard to write in Python, but any kind of interpreter is actually a good use case for Python. PyPy uses Python to implement a tracing JIT compiler also, so certainly this domain is not off limits to Python. Embedded programming is another area that Python is more usable than you might think. Micro distributions of linux running on RaspberryPi can run Python programs very easily. 
There are highly specialized GC implementations that are designed for real-time systems, but I don't know how well they work in practice for hard vs. soft realtime, etc.
Python really can be used for almost anything. That doesn't mean it *should* be used for everything. The key place where I'd never use Python is for large scale modeling and simulation (excluding MapReducable stuff). You want to train a Random Forest or a neural network on a few terabytes of data with hundreds or thousands of features? That's Fortran or C material. Monte Carlo simulations? Also Fortran or C.
and a huge one
YouTube is. Google Search is powered by customized hardware in the DC, MapReduce (their patented implementation, which is C++ as I recall), and a custom file system (GFS), amongst other things.
To be fair, PyPy has that whole RPython thing going on.
I'd avoid it for large and critical applications due to the lack of static typing
Google web crawlers are made in Python, but their algorithms and most of their code is C++
sorry, ear you go http://pyvideo.org/video/2686/keynote-guido-van-rossum-0 
It's possible to bypass the Arduino language completely and go straight to AVR. However, then you have the task of somehow cramming all of Python's behavior into a compilation target that works with a mere 1-4K of RAM, and tens of kilobytes of flashable ROM. It's not impossible, but it would make you think twice about writing sloppy code that is copy-happy, or does anything dynamic with dicts, arrays, etc. "Embedded Python" best practices would probably stay away from classes entirely, and use generators whenever possible - basically you'll code like Haskell or Scheme. Edit: ARM (RPi for instance) is a far more attractive embedded target for Python, given the available RAM alone.
pythons garbage collector is deterministic, except in a single well documented edge case. as long as you give python free reign over the cpu it should be more than plenty deterministic for timing stuff..
That depends greatly on which statically typed language you use. If your example is something like Java, sure, the boilerplate is at least as bad as writing unit tests in Python. But that's not because Java is statically typed, it's because Java is horribly verbose and lacks expressive power. However, there are many other statically typed languages that are far more concise and expressive than Java. In some cases they beat Python as well. As soon as you've got type inference and decent support for generics in your static language, much of the gap people sometimes wrongly associate with dynamic vs. static typing is closed.
It is important when I want to leave the device in each of my projects. I don't want to put a $80 (Raspberry Pis don't ship cheap here) thing into every toy. Plus I use Arduinos to fix things. 
No, but I don't expect every number object created in my app or in any library I use to be something of that class.
Ugh, Java is slightly better, but I wouldn't use it there either.
You're thinking on a processor level and instruction level, which is fine when optimizing. But I'm talking about pure execution time An analogy, if you will. A tool manufacturer, for example someone who makes a chop saw, is concerned with the technicals like RPM, and you could compare saws based on those stats. But my concern is using those tools, not creating them, because I'm the guy that measures and cuts boards. So I'm concerned with the overall speed of getting the job done, and how many boards I can cut. That's the speed I'm referring to. I don't care how much work the processor has to do (when it's negligible in terms of the overall system capacity). But I'm not a tool maker, and I can appreciate your concern for ensuring your instructions are as streamlined as possible. Different use cases. I am pretty sure everyone else who read my original post knew I was talking about the completion time of the program, not the instruction execution speed, which is out of scope for the problem I described. But it is sometimes important to consider when creating the tools and building blocks that we use, and thank you for doing so. 
I completely understood your argument. But wanted to make it clear that completion time and speed are not the same. In your own analogy, if I have a saw that cuts through a single board rapidly (C in this case) and a saw built to cut single boards slower but it can handle 20 boards at a time, the task of cutting a board is completed in wall clock time more quickly than the second saw. But the second saw is completing 20 iterations in a single work unit. This is important, because spawning threads in C is easy, and having those threads use proper async network APIs is also easy. Relatively speaking. So in this case, I can add a small attachment to the first saw that will make it cut 20 boards at a time. Now it completes 20x the work in a single work unit, which takes the same amount of wall clock time. These are extremely important concepts for new programmers to understand, and the OP is asking a new-comer's question. It's our duty to make sure new comers are properly informed so they don't have to learn the hard lessons like the rest of us.
You can certainly do algorithmic trading in Python. I suppose it comes down to where we draw an arbitrary line for "HFT". Reasonable people may disagree. My arbitrary line is when you're literally racing another competitor doing the same thing and the one that isn't fastest might as well not exist. In other words, wherever the bleeding edge is today. As /u/scopegoa points out, firms who need this kind of advantage often use purpose built hardware because regular ol' software on co-located bare metal servers isn't fast enough. As /u/bushel pointed out, the code *can* pale in comparison to the time it takes to send messages over the network. Sounds like a possible use case for Python, so long as you're sure you wont need to start an arms race like above later on. /u/EmperorOfCanada hits the nail on the head. If you can profitably run your business logic at "mere mortal speed" because you are faster at developing it and responding to new behaviors in the market, Python can help! But some people are playing a very different game.
python3 makes everything 16-bit unicode instead of char * (ascii or utf8). The extension apis became rather more difficult to work with as a result.
clearly written in javascript
I use Python 2.5 and py2exe and have no problems. I'm pretty sure up to Python 2.7 works as well. PyInstaller looks great and I may go that route at some point. If you use wxPython, check out the very handy GUI2Exe.
I'm certain you know more about this build/test process than the 5-6 devs that have worked on it for for 5 years and covers well over 20M LOC and dozens of products.
Its not the compile stage that is doing thousands of I/O. You're doing something wrong your build/test process sucks. Anyway, 20M loc, break it down, componentize, modularize.
&gt; but you might want to be a bit more precise about your requirements Actually I don't. I'm interested in any kind of tournament system. If there's nothing fully ready to use, then I can at least look at the implementation/API/interface. Anything is better than starting from scratch.
I don't really think a newcomer needs that sort of complexity. They will learn it in time. I think the appropriate thing is to use words in context. In context of getting a job done, execution time is equivalent to speed. In context of optimizing an algorithm, big-O notation is equivalent to speed; etc etc. From my perspective, it's much more important for a beginner to learn not to prematurely optimize code because otherwise they may make wrong assumptions about how things work behind the scenes, and end up wasting time trying to solve a problem that doesn't exist. As they learn more about the language they tend to learn more about how to optimize too. Many programmers will never get into the details of the call stack and heap allocation and CPU instruction timings, much like I don't know what controls my saw's speed, but I know it spins fast enough to cut wood. The beauty of Python is in solving those high level problems without writing a lot of code or needing to understand how it all works. That can come later, when it's needed. 
again - you know nothing about the work being done.
https://github.com/cython/cython/tree/master/Demos/freeze Makes either a single binary executable to run, or a python interpreter with your library burned in like a built in. Make sure you have a c compiler installed on your dev machine.
Hey thanks a lot! This makes sense, I will try it out and see if I can get it working. 
&gt; A search engine Google has a lot of Python
Yup. And even python can refer the chars as ints. I think it's the ord() built in function. Char in C is most certainly an integer. And it's also why strings are such a pain in the ass in C because they are just arrays of Chars. 
Here's a book chapter I wrote about using setup.py, py2exe, and NIS to build an installer: http://aharrisbooks.net/pythonGame/Appendix_C.pdf Hope this helps...
I can't attest to his specific motives, but there are many for writing new compilers. Perhaps you think you can write one that's faster, perhaps you think you can write one that produces better/smaller code, perhaps you want to try an entirely different way of writing a compiler. Hell, maybe you just want to write a compiler in a new/different language. It's only redundant if it has the same speed and features of current compilers. Even then, it would still be a good learning experience.
A command line application. User might not have Python installed. A compiled language would be best.
right... but the frontends are in javascript.
I surmised as much. As it turns out, his compilers were for new programming languages.
Thank you for your reply! I will check it out when I get out of class.
http://legacy.python.org/dev/peps/pep-0393/ There were UTF8, UTF16 builds. This PEP resolves that difference by allowing multiple types of strings represented
Shouldn't there be, you know, screenshots of your GUI?
I've been watching Kivy for a while but the demos in the android market place don't impress me much. My other concern is also that I (maybe others) are short pressed for time in getting to the end of a project so spending time to learn the Kivy API could probably be replaced by learning the UE4 API and tool and deploying straight to my tablet for testing Don't get me wrong I love python as a language and I code everyday in it, but what is different in KivEnt that would attract me to start using it?
Though once you open it, that textbook gets tossed out the window. It is an ugly, ugly mess.
Could you tell me anything about how you became a HFT developer? What type of degree(s) do you have?
Then base64 encode it and have people download it as not-malware-I-promise.py and run it. [seemed to work for pip](http://pip.readthedocs.org/en/latest/installing.html#install-pip)
To be clear, this is what I'd like to be able to do in Python: [click me](http://jsfiddle.net/AhC87/2/) (see the demo on the bottom right) 
I use python almost exclusively for command line applications... argparse is just too great. Lots of Linux distros (i.e. redhat and fedora's yum) use command line applications written in python for system administration.
Thank you!
We are.
and? compilers have a lot of design constraints on them. does GCC use every C++ language feature in its internal implementation? certainly not.
How much space do you guess that this would take up? The Windows installer for Calibre is 53MB. It does not seem like an overly complicated program. I feel like if it was written in, for instance, C, it would be a lot more compact. Am I completely wrong here?
quality of the algorithm implementation has nothing to do with whether or not the language is a good choice for implementing the algorithm. reddit search is bad because its implemented badly, not because Python screws it up.
It'll take up some, though possibly not as much as you may think. The actual python dlls aren't that big (~3MB or so), but stuff like the UI libraries it uses are likely taking up the bulk of that 53MB. It uses QT (a cross platform UI library), which has a bunch of dlls and dependencies that need to be installed. The same would actually be true even if it was written in C if it still used QT (rather than, say, a native UI toolkit that would already be present on the machine). 
the low-latency part of the platform is almost certainly not pure Python. Python bindings to C code seems likely, as that is a common pattern. 
Is RPython a strict subset of Python? My impression was that it was close, but not quite.
Its basically a strict subset. http://pypy.readthedocs.org/en/latest/coding-guide.html#id1 there isn't anything in RPython that is not also available in Python. The differences are largely not about which language constructs are available or not, but more related to the various ways that you can use a language construct. 
Wait, is that for real? Or is that a malware?
The pip one is 100% real. 
Allocation and name lookup can kill you there but a cython module may have been simpler.
I wrote projects with over 50k lines of Python (with a bit of c++/cython at the right place), the language wasn't a problem. it's a different trade-off than java, but it works well.
**What I mean is** SQL is powerful and the more you learn it the more you want to use *it* to do things. That's all. I also don't doubt that you can write simple SQL statements better than SQLAlchemy.
You mean this, https://github.com/fabric/fabric?
Sorry, I thought you were criticizing my use of SQL.
You could try using the graphics module, which simplifies shapes and objects on a window
True but i have no experience with cython and didnt manage to get it working at which point simply porting was easier.
Fabric, because it's simple.
Looks like you have a bad case of [RAS syndrome](http://en.wikipedia.org/wiki/RAS_syndrome).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**RAS syndrome**](https://en.wikipedia.org/wiki/RAS%20syndrome): [](#sfw) --- &gt;__RAS syndrome__ (short for "redundant acronym syndrome syndrome") refers to the use of one or more of the words that make up an [acronym or initialism](https://en.wikipedia.org/wiki/Acronym_and_initialism) in conjunction with the abbreviated form, thus in effect repeating one or more words. A common example is "PIN number" (the "N" in PIN already stands for "number"). Other names for the phenomenon include __PNS syndrome__ ("PIN number syndrome syndrome", which expands to "personal identification number number syndrome syndrome") or __RAP phrases__ ("redundant acronym phrase phrases"). &gt; --- ^Interesting: [^Retinoic ^acid ^syndrome](https://en.wikipedia.org/wiki/Retinoic_acid_syndrome) ^| [^Pleonasm](https://en.wikipedia.org/wiki/Pleonasm) ^| [^Recursive ^acronym](https://en.wikipedia.org/wiki/Recursive_acronym) ^| [^Automated ^teller ^machine](https://en.wikipedia.org/wiki/Automated_teller_machine) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cgw24cx) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cgw24cx)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
KivEnt is a tiny, OpenGL ES 2.0 targetted engine for 2d games. UE4 is a 3d engine for teams of people building the largest games in the industry. The number one reason you should use KivEnt is if you are looking to build a 2d game in Python and deploy to Android. Now if you know both python and C++ and UnrealScript (Actually I think this has been replaced by some kind of visual editor), you could take a shot at building the same game in UE4, but I get the feeling if you are totally unfamiliar with the way UE4 does things it will take much longer to understand the much larger, more featured codebase designed for building state of the art games with an entire extra dimension that you aren't aiming to use for your simple 2d mobile game. I think KivEnt and Kivy have an advantage in the UI department as well, not only do we have a competitive UI widget library with a focus on multi-touch, but it also runs everywhere, any development tool you build with Kivy and KivEnt could just as easily be packaged up for tablets/phones/whatever as well. I am personally very interested in the opportunity to create artistic tools that run on multitouch devices. It looks like UE4 has several options, an editor, I saw some mention of using html5/css, I'm sure you could just do it in straight C++ with billboard sprites or something. Anyway, with my option you get to use kv language, I personally think this beats any other method of defining a UI out there. One of the key observations I had when I determined to make KivEnt using Kivy is that the majority of games for Android/iOS are heavy on the UI elements when it comes to monetization strategies and such, making construction of the UI an incredibly important part of being commercially successful. Most small developers using free frameworks end up tacking some simple UI elements on at the end because there is not a lot included in their game framework/engine to make this easier. With KivEnt and Kivy, it is easier and faster to build interactive UI elements to ensure your game has as much polish in that area as anywhere else. As far as the 'deploying straight to my tablet for testing', that is exaclty how you would test a KivEnt game as well, although for small changes I usually just test natively in linux. This saves time in the long run. Also, I know most of the marketplace demos for kivy are not particularly impressive. The majority of the community currently using Kivy professionally does private contracting, not commercial releases, and much time has been spent on building Kivy/KivEnt/Tool chains for building python to iOS/Android/Tools for automatically translating Objective-C and Java code to Python, and other supporting projects. It has taken quite a village to get Python on Android. We are a fairly young project with a small community, putting us up in comparison against one of the most veteran, industry leading engines in a separate market(3d vs 2d) is sort of unfair. It would be more equivalent to compare KivEnt to XNA, Apple's new 2d game stuff built into X-Code, HaxePunk, Building an HTML5 Game, or perhaps Unity's new 2d Stuff. 
Yes, the tools are all configurable at the object level. However, the system is fairly basic right now, and we are actively working on (1) redo-ing the event-&gt;gesture-&gt;tools-&gt;datastreams architecture, and (2) building a "frame" around the plot so that it's easier to configure which tools are active, etc. FWIW, by default, plots can be panned without needing to click on the Pan tool, and you can do wheelzoom by holding down Shift and using the mousewheel.
PyQt/PySide with a QGraphicsScene inside a QGraphicsView would allow you to pan around.
Out of curiosity, what's the edge case?
How do you handle the case when a python package is not available in PyPy? My application is using pywin32, and I believe the installer only available in "setup.exe". How do I state this package dependency?
At the time, several years ago, it was pure python. The network cost being the major factor. As they've grown, I'm sure they've optimized.
Although his talk was interesting in a number of ways, in the end it boiled down to Nuitka and Cython, neither of which probably work yet well enough to actually use with your other libraries, like your GUI toolkit. My guess it that they never will, or we're talking 10 years from now when this issue may be irrelevant. (Maybe I'm being too negative?) 
It looks like it's [one file](https://github.com/rueckstiess/expsuite/blob/master/expsuite.py) of just a few hundred lines. So it should be pretty easy to port to Python 3, if that's what you want. EDIT: [Like this](https://gist.github.com/takluyver/11069527). I ran 2to3 and did a few manual tweaks.
I liked it, but wasn't so sure how relevant it was to the python (or JavaScript) I use on a daily basis. Maybe my imagination is too limited. It's probably true as well that I especially distrust future-gazing in tech more so than in any other area of concern, so it seems more like a fun and funny, "isn't it fun to imagine..."
Quite the opposite. Cheers, mate. No hard feelings.
it is the same as saying: width, height = 240, 200 size = (width, height) or width = 240 height = 200 size = (width, height) basically, you can assign several variables to the partsof a tuple, and have it all work kosheresque.
circular references. you either need to specifically use a weakref, or not mind if it leaks, assuming you disabled the cyclic GC of course. in any other case stuff is going to get garbage collected the instant it falls out of scope.
I understood that. I had missed that both width and height were used later in the program, so I wondered why they bothered. Of course as soon as I asked the question I saw my error. Thanks anyway!
Regarding Playypus - from the ReportLab User Guide "*It is a high level page layout library which lets you programmatically create complex documents with a minimum of effort.*" . By contrast you can if you wish use ReportLab to create documents by placing text, images, etc directly onto a "canvas". Given your requirements I'm not sure which of those two approaches is best for you - I tend toward Platypus but either would do. Get the User Guide from https://www.reportlab.com/docs/reportlab-userguide.pdf. Chapter 2 shows how to produce documents the "non-Platypus" way like this for instance: from reportlab.pdfgen import canvas def hello(c): c.drawString(100,100,"Hello World") c = canvas.Canvas("hello.pdf") hello(c) c.showPage() c.save() Within the same chapter there's a paragraph 'Image methods' which gives you a headstart on drawing images onto the canvas, again without Platypus. Within the same document you can look at "Chapter 5 PLATYPUS - Page Layout and Typography Using Scripts" which introduces Platypus. Having scanned through that chapter now I'm just thinking that perhaps I've forgotten how much I know and that maybe for someone who hasn't done it before using the "non-platypus" methods I've mentioned above might be better. I only say that because to get a Platypus based document output there's a lot more scaffolding you have to write initially. This is good because it provides lots of useful facilities for complex documents but may be more than you need. **EDIT 1:** Sorry forgot this. One thing that Platypus offers and is really good are "flowables". For most purposes the significance of this is you can defined a width of, say, Paragraph and then just "pour" text into it and it will grow downwards to match the amount of Text you have to print. You can also get the text within the flowable justified in different ways plus of course massive styling options (see 'paragraphStyle' within ' Chapter 6 Paragraphs'). **EDIT 2:** Formatting.
While I like flask-cache, there has not been a release in quite a long time and thadeusb's (the creator) last activity was six months ago for that repo. In my own experience it's fairly dated now, does not support Python 3 and has a few bugs. Flask-Cache-Latest, which is a clone of flask-cache, was release a little over half a year ago too but it does have Python 3.3 support. So basically, if you don't need everything that flask-cache offers then you may be better off writing something simple yourself especially if you're expecting to need to make changes later on. At least.....that's what I've been doing.
The Bokeh homepage says that it is a "web plotting library" -- does this mean that its goal is to produce interactive visualizations targeted for the web, or does it also intend to be something of a matplotlib replacement? Will I be able to use bokeh to comfortably produce publication-quality static figures and export them to, say, .eps or .pdf formats, or is this something that is outside of its purview? 
I really wanted to get in and fool around with this... but I lack the knowledge to take it from it's current state to an importable module....
Adding an SVG backend for high-quality static exports is absolutely a long term goal of Bokeh, it's just a matter of finding the time to work on it (or an interested new contributor with an itch to scratch!)
Anything serious. 
Python. Less easy to shoot yourself in the foot. Ha. 
&gt;&gt;Name one non-printing, non-typechecking operation where True is not substitutable for 1 and False is not substitutable for 0 (bar misuse of is). &gt;Even if I agreed with this point it does not counteract my argument that "Making booleans a subclass of ints is not consistent with the way python handles string vs char" It does. Just accept that `bool`s are *aliases*. They're *useful* aliases, though, unlike having a `char` alias, which is why they exist. The fact that they are aliases is unimportant, though. &gt;Second that is a long list of exceptions. Long enough to support my argument bythemselves. I don't understand what you mean here. &gt;But sure how about json.loads Nope; that uses type-checking. Note that it uses *strict* type-checking because it works at a boundary (namely JSON serialisation) so it uses `type(x) is ..,` rather than `isinstance(x, ...)`. &gt;&gt;Name one user-facing property that would change if numbers were bitstrings, aside from the ability to index. &gt;Once again I don't see how this even adresses my argument if I could not come up with one. Because if you cannot distinguish between numbers-as-bitstrings and numbers-not-as-bitstrings-with-bitwise-operators, your assertion that numbers are in the second but not the first is obviously flawed. &gt;But how about adding two very large numbers. Please explain. &gt;&gt; But 4 is truthy. &gt;Not in terms of the LSB which was the whole basis of your argument in this perticular part of the argument tree. But if the `bool` constructor returned *only* the LSB of the input, it could not take non-numeric objects. What `bool` does is take an object, check it for truthy-ness and return one of the two LSB integer aliases. In one sense it's a count of the number of true things, which is a nice way of mentally explaining `sum(x&lt;y for y in z)`. &gt;&gt; It does not. &gt;Fine if you want to be pendantic one particular compiled binary of python for one particluar archetechture. It still does not. What does `{1: 2} + 5` make? Note that it has to have *guaranteed losslessness*. What does `{1.0: 2} + 5` make? Note that `{1: 2} == {1.0: 2}` and all objects involved are immutable. &gt;They point is that your argument that there is no way to make a ridiculous mapping of dics in order to justify a crazy mapping of ints is wrong. You're assuming the argument in that point. I don't believe the `int` mapping is crazy. Even if the `dict` mapping were possible, it's obviously absurd. &gt;&gt;Why? &gt;Because True + 4 does not make sence coming out to be 5. If you think it does then I think we are at an impass. I can not think of any situation where it makes sense to break closure on boolean in a general programming language. That makes your argument cyclical. &gt;&gt;Why? &gt;More explicty and consistent. How is the order of `/` and `//` anything to do with explicitness? Further, the consistency argument is flawed considering the whole point of Python 3 was to allow the option to break compatibility. &gt;&gt;Why is whether something has an AST token or not at all important? &gt;Its not an AST token. It is the hint that you are using packaget that you have to import that is important. So what was it doing? (The grammar here is confusing me) Where is the connection between `import`ing and being "allowed", under your schema, to break closure? &gt;Dealing with old messed up undocumented machine learning library. I mean better to replace the whole thing but money does not grow on trees. I meant "what was this function doing?" I still struggle to see how this problem was the fault of Python, and without an example I'll continue to find it hard. 
Why it isn't in http://pyvideo.org/category/50/pycon-us-2014 list?
Yes, the goal is to produce interactive visualizations for the web, on large data. It is not meant as a matplotlib "replacement", although it may be a better fit for some purposes than matplotlib. For instance, creating "novel graphics" like what's possible with d3 or protovis is not really the intent of matplotlib, and is not very accessible for non-developer users. Matplotlib has a very large and established user base, and one of the incidental side benefits of Bokeh is that we *can* provide an interactive web backend for many existing MPL plots.
Of course, there is Ruby for jewerly making.
GitHub auth too?
This is hugely important: right now, Python 2.7 is a security risk on the web. The only way it isn't is if you use PyOpenSSL, and most network libraries don't (though Requests can if you install it). This is _even worse_ on OS X, where Python 2.7 is limited to the system version of OpenSSL, version 0.9.8e, which is ridiculously old. If you're worried about the security of your system, I strongly recommend installing PyOpenSSL against a recent version of OpenSSL. Following [cryptography's install instructions](https://cryptography.io/en/latest/installation/) is the way to do it. Then, watch Hynek's [The Sorry State of SSL](https://www.youtube.com/watch?v=SBQB_yS2K4M) talk for more information.
I write a scipt to get all video from pyvideo.org you can see in https://github.com/qiaoqinqie/pycon2014_us_videos_download
&gt; basically, you can assign several variables to the partsof a tuple Or a list. Or a dict. (It gets the keys, not the values) Or really any iterable.
Here's what I used: from rauth import OAuth1Service import xml.etree.ElementTree as ET import pandas as pd import time import os OAUTH_CONSUMER_KEY = 'include OAUTH_CONSUMER_KEY here' OAUTH_SHARED_SECRET = 'include OAUTH_SHARED_SECRET here ' request_token_url = 'https://api.login.yahoo.com/oauth/v2/get_request_token' authorize_url = 'https://api.login.yahoo.com/oauth/v2/request_auth' access_token_url = 'https://api.login.yahoo.com/oauth/v2/get_token' yahoo = OAuth1Service(consumer_key=OAUTH_CONSUMER_KEY,\ consumer_secret=OAUTH_SHARED_SECRET,\ name='yahoo',\ access_token_url=access_token_url,\ authorize_url=authorize_url,\ request_token_url=request_token_url,\ base_url='https://api.login.yahoo.com/oauth/v2/') request_token, request_token_secret = yahoo.get_request_token\ (data = {'oauth_callback': "http://example.com/callback/" }) print "Request Token:" print " - oauth_token = %s" % request_token print " - oauth_token_secret = %s" % request_token_secret auth_url = yahoo.get_authorize_url(request_token) print 'Visit this URL in your browser: ' + auth_url pin = raw_input('Enter PIN from browser: ') session = yahoo.get_auth_session(request_token,\ request_token_secret,\ method='POST',\ data={'oauth_verifier': pin}) 
Indeed. But my point is CPython's GC at least is predictable (if we ignore the cyclic reference edge-case). So in your example you know upfront deleting the list will cause everything in it to be deleted as well (assuming no one else holds references to those objects or the list itself).
Just in case he changes or removes it in future and others are baffled, the flair is &gt;design drunk, implement sober
Yes it does support github. There's a list in the readme of everything supported and its a fairly long list.
Best thing to do right now is to try to relax and let some time go by. Those who feel they can just will Python 3 into success will eventually be hit with reality. I'm sure by the end of 2015 the community will come together and work on a realistic plan to move forward.
Yup, relaxing is my plan. Thank you!
Looks very interesting! Thank you for sharing. :)
Here's the list of supported providers http://psa.matiasaguirre.net/docs/backends/index.html#social-backends
Nice tutorial, are you planning a follow up post?
Will do. Thanks
http://lmgtfy.com/?q=pycon+2014+videos
Gary Bernhardt gave the talk like seven times and only allowed it to be posted when he was finished.
Interesting stuff but the title is misleading. This is strictly about automating osx provisioning. 
I've just updated the blog entry's title to reflect this.
Does Python still [expect OpenSSL to be built with SSLv2](http://blog.schmichael.com/2012/05/29/building-python-2-6-8-on-ubuntu-12-04/)? I'm trying to buld Python 2.7.6 now and it reports "modules were not found: _ssl". I'm using my build of openssl-1.0.1g.
Looking through the source code for CPython 2.7's branch, it looks like it should build fine without `PROTOCOL_SSLv2` and friends.
The statement that you are limited to the old version OpenSSL on OS X is wrong. You can easily compile python with latest OpenSSL. This is what homebrew does. 
Looks great - nice work
No, using latest OpenSSL on homebrew is default and mandatory. You cannot even choose not to do it. 
If that's the case, I apologise: that's a recent development I wasn't aware of. You used to have to pass --with-openssl.
how about some context ??? what are those ? 
what are we provisioning? I'm a windows user
According to the docs, yes: http://psa.matiasaguirre.net/docs/backends/github.html
does it let me run a py script on computer B from A ?
til "rainbow table"
This looks promising!
&gt; Your Homebrew is outdated. &gt; You haven't updated for at least 24 hours, this is a long time in brewland! ;)
Thanks! I am a CS student but there are certain questions like these that just aren't answered straightforwardly in class.
Sorry, I was still pointing to my openssl-1.0.1f which had been deleted. 
Provisioning in this sense is installing OSX with a certain set of libraries and programs without having to manually do it. Just describe what you want, hit go, and the program takes care of the rest.
I've found great success with deeploystudio + munki. All we have to do now is login as the user and change hostName. I'll have to check this out as well
Why do you post this blog spam piece of shit article? Its a ripoff of the Flask-Cache documentation. 
You can run any program remotely.
if you were reading the book from scratch, he explains the environment problem in windows and how to fix it. :)
&gt; How I Fully Automated OS X Provisioning With ~~Ansible~~ a shell script unnecessarily wrapped with Ansible FTFY.
If anything, it's the other way around. The shell script is really only meant to be run once.
Look up serialization. You can communicate between the two applications using something like json or protocol buffers, I'd elaborate, but I'm on mobile...
I know this is a few days old, but I will try to answer it anyway. The point of a lambda isn't really to replace functions. It is more useful when needing to pass code as data (something that functional languages do all the time.) In other words, it is useful for functions that take other functions as parameters. As noted elsewhere, sort is a classic example of this, as are map and reduce. Another thing they are useful for is providing closures which may be convenient for something like a callback. Example: say you have a function that takes a callback of no parameters and calls it when some event is triggered. Now, you would like it to call some other function you wrote with a parameter for this callback. This can be achieved with a closure. def my_func(param): print(param) some_func_with_callback(callback=lambda : myfunc('hello')) In that example we created a function that closes how we want to call myfunc, this allows us to customize callbacks with params. This isn't the only use for closures, just one I see frequently. Edit: link to info on closures: http://en.wikipedia.org/wiki/Closure_(computer_programming)
Start simply with `subprocess`. You can achieve surprisingly many things just by piping data back and forth between processes. If you need true foreign interface, it may be hard for you to find something reliable in Go case. I recommend picking C or C++ for performance. There are many battle tested solutions for calling C/C++ from Python (C extension modules, Cython, ctypes, cffi, boost::python) and C++11 is a better language than Go anyway. My personal favorite is Cython.
Most provisioning scripts are...
To clarify: the shell script's sole purpose is to bootstrap a system so that it can run Ansible. Afterwards, I'll run my Ansible playbook at least once a day to keep my system's packages and repositories up-to-date.
Thanks, I started playing with PyQt tonight. I found what looks like to be a decent tutorial/introduction and it seems to be going well so far! 
Why are you provisioning so many os x boxes? wtf?
Link? 
[Here](http://zetcode.com/gui/pyqt4/) This might not be optimal for someone that likes to read a lot about the details before implementing stuff, but I learn better by diving immediately into the code. I type the code for all the examples given on that website, and I google the information when I find the details given to be lackluster. It seems decent so far but I don't know what % of Qt is covered in these tutorials. 
uh sure...as in any field Why does the word "guru" give me the creeps now ? Must be that I'm just fucking jaded over the years...
Thanks! 
Think of it more like cloud-init works in AWS. You need something to bootstrap the system to the point of running the configuration management system.
Ignoring security concerns for the moment (though that is something you will need to consider), you could run an HTTP server (using Tornado, Twisted, or some other library) on system A and then make an HTTP request from system B to start whatever processes you want.
You could have a look at something like fabric to run things over ssh. However judging by the technology you are talking about you are running on a windows environment so you would need to look at an ssh sever as well.
At really basic level, you could spin up a new thread, then open up a socket on a free port and wait for script B to connect. Pretty light weight, and would get the job done. Would you need more than this?
Telnet? Ssh?
Agreed, I'd use SSH. You can setup an ssh server on windows. Then you put the public keys on the other machine's authorized-keys file (so no logins needed, but secure). Then you can fire of scripts as needed using subprocess (to run the ssh binary directly), or something like paramiko. This is assuming you need to run files (and maybe gather input), and not interact with running programs. You could still do the latter using stdio &amp; pipes, or even sockets / tunneling. But that gets a little crazy.
I've never telnet/ssh'ed to Windows so didn't even consider it, this could possibly be the simplest way, will check out thanks (one script is basically automation like start Excel, open file and call VBA, so I wonder if this will work via telnet) 
So, you're looking to do some sort of distributed system design. I've explored this topic both on my own and professionally and I've come to the conclusion that there are four relatively easy ways of doing this: 1. Run a web server with hosted python frameworks. This is probably overkill, but if you're familiar with web.py, twisted, pyramid, flask, etc. it might be faster than the other options, but probably not as clean. Use any web framework with which you are familiar. 2. Pyro4. It's a remote objects library. Essentially, you declare a nameserver, and load objects from A to the nameserver, then you can call them off the nameserver as though they were local objects on B (but they still run on A!). You typically use Serpent serialization (simple data) or Pickle serialization (complex-er objects), with the caveat that pickle is slower and has several important security concerns about arbitrary execution of code. Pyro4 is likely the best option, provided that you can set up the nameserver on your network appropriately. I've never tried to use Pyro4 accross a larger gap than a local network, however, so, YMMV. The downside of using pyro4 is that you need to attach the objects to the nameserver in the first place, so if you want to go from a complete cold-start (with no running scripts or anything) you already need a method of remote execution. Pyro4 is more for data passing than anything else. 3. Sockets. This is kinda a stripped down version of 1 and 2 in a way, as both 1 and 2 heavily involve abstracted socket calls. Essentially, you're make a pervasive server socket on A and connect to it on B which would send information to start the client process on A. It will allow a finer grain of control versus 1 and 2, and will involve much less overhead, but it might be more work if you're unfamiliar with network programming. Use the default socket library in python. 4. SSH onto the windows box. This is kinda a pain in the ass, as you have to set up the SSH server on windows which, in my experience, has been a real pain. It's probably the best option if all you need to do is run a script on A remotely, but it's probably easier to roll your own socket than to bother with windows to windows SSH. Paramiko works really well for this, and some people use fabric (which actually just uses paramiko). 1, 2 and 3 all involve some sort of script already running on the computer and SSH is a pain on windows boxes. 
I set something that did this. Without installing any 3rd party software, it is still possible. You can use Windows Remote Shell to run the program remotely. The problem with this is that the process will not stick around longer than the winrs session. So, what you can do is create a scheduled task from winrs using SCHTASKS.EXE, then run that task again with schtasks.
thanks did you exclude telnet from #4 on purpose ?
I'd choose ssh if I were you. I wouldn't know for sure whether telnet would work the way you want, though you could add telnet directly to the script and convert it into a daemon, but setting up ssh would probably be simpler and it will be there for other usage.
I've personally never used Telnet. I mostly interface with Debian servers and ssh has always been a capable remote connection protocol. If you can use Telnet easily, then that will suffice. Of course, there's a reason why ssh is a lot more popular than Telnet now.
If you want to go a more systems engineering route there a few options. SSH/telnet. Bitvise SSH server isn't terrible for windows. Jenkins. Build automation/task automation. Pretty light footprint. Install jenkins on one, machine, make the other a slave. Restrict where the job can be run onto machine A. PSExec. If you're on the same network and have admin privileges.
I haven't seen this recommendation here yet, so I'll chime in. You can use PowerShell to execute commands remotely. You have to call Enable-PSRemoting on computer A to enable remote execution. Then you can start [here](http://technet.microsoft.com/en-us/library/dd819505.aspx) for actually calling the command from computer B.
Set up SSH then use Fabric. Done and done. Easiest SSH server for Win7 is [WInSSHd](http://www.bitvise.com/winsshd). GUI for setup so you don't have to edit a config file and it's free for personal use.
I admit I always did this in a Unix enviroment. But yes SSH There are a few things that make this the best method 1. Ssh has the option to include a command line in the connection call. 2. You can set up pgp like authentication on both machines. Such that the machines can auto identify without requiring usernames and passwords in the script. This provide a very easy way to keep the connection secureish.
execnet might work for you
I am building this very thing now usng Raspberry Pi computers, ssh and python concurrency.
[XMLRPC server](https://docs.python.org/2/library/simplexmlrpcserver.html) on A. Then a [XMLRPC client](https://docs.python.org/2/library/xmlrpclib.html) script on B can make a function call as if it's on the same machine. Don't be intimidated, it's [easy](http://stackoverflow.com/a/2242202). Another [example](http://tldp.org/HOWTO/XML-RPC-HOWTO/xmlrpc-howto-python.html).
Perhaps a messaging library like 0mq?
You don't need to use a nameserver with Pyro. You van also connect directly to remote objects. 
The link for the video could not load for me. Here's a [youtube link](https://www.youtube.com/watch?v=7eeEf_rAJds) for anyone that wanted to see it.
Friends don't let friends implement xmlrpc.
Since I'm working more on the Windows side lately, I'll also suggest PowerShell. If you don't have access to Linux.
Celery?
Simple method is to use subprocess - if you are using Python3 they even cleaned up the API. I've used this to mix python and Java, if all you need to do is run a Go program that doesn't need to send data back to Python its very easy since the processes don't communicate. If you need to pass info back and forth you can use STDIN and STDOUT but that's fairly primitive. For more power you can use one of my interprocess communication libraries like ZeroMQ, OpenMPI, or platform dependant technology like DBUS
Howdy, Partner!
I'd try RPyC. It's super cool: http://rpyc.readthedocs.org/en/latest/
yes i'm investigating this track right now, i'm reading abt rest framework and such 
yes i need the processes to communicate. i'm going to read more abt zeromq, openMPI and such. Thanks a bunch mangecoeur :)
Seconded on RPyC - I've used it a bit. It's the simplest RPC framework I've found for Python. I've used it in mixed Linux/Windows environments too, it's fully cross-platform.
You're missing an ending semi-colon after "text-align: right". Also your inline style tag in your first "line" declaration is not correct. You don't need the semi-colons there, and you need to put the style attribute in quotes. It should be something like this: line = '&lt;div class = "container" style = "background-color:#a0c4de"&gt;&lt;b&gt;' # etc The others are correct that you should use a library to generate this stuff for you, but if you are going to do it by hand, you should mock it up as a stand-alone HTML file first, get that working the way you want it, then bring the pieces back into your script and make sure the script generates the identical structure.
&gt; this part: if i % 2 == 0: isn't doing what you think He does decrement i at the end of the loop.
The CamShift demo from opencv has this: https://github.com/Itseez/opencv/blob/master/samples/python2/camshift.py
Not to be a dick, but it looks like once you have all the packages installed the first time around, 90% of the Ansible code could be replaced by $ brew update &amp;&amp; brew upgrade And you can just as easily install all of the initial packages from a text file list like $ brew install $(cat path/to/list.txt) Also, to run Ansible, you only need to download Ansible. You can then use Ansible to install evvverything else in that script. OSX comes pre-installed with Python 2.7 and Ansible is specifically designed so that it can fully bootstrap itself on a remote machine if necessary. I think you're on the right track, but it's not a particularly interesting setup for a blog post at the moment, and certainly not for posting to /r/Python to show off Ansible.
Link with pdfs: http://www.mercurytide.co.uk/news/article/django-15-cheat-sheet/
I think Cython is good enough for what you have described.
[STAF](http://staf.sourceforge.net/)! I use this all the time, it's incredibly powerful, cross-platform, and FOSS.
Also if the controlling host is a Linux box, winexe (from samba) works the same way PSExec does.
&gt; XMLRP Why? It'll always be in the standard library.
Consider using redis to pass messages between scripts. 
What hoes wrong when you do 8500/60?
But that isn't 21 minutes. 
You just need to round it afterwards
PsExec http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx 
No man! the point is there should be no 'afterwards'. It should take input as seconds and give output broken as hours minutes and seconds. I am stuck with minutes part. I am doing a last year intro course on coursera. Its one of the tasks listed there.
The program will be used to ground truth video that has already passed through detection algorithms and been processed. So we will have to be hand drawing the rectangles. Thanks for letting me know about SimpleCV though. I like the layers that it uses, and this may actually work better for us in the long run.
Something like so maybe, I dunno, probably a better way: hours = 0 minutes = 0 seconds = 0 while second_input &gt;0: if second_input &gt;=3600: hours = hours + 1 second_input = second_input -3600 elif second_input &gt;=60: minutes = minutes + 1 second_input = second_input - 60 elif second_input &gt;=1: seconds = seconds + 1 second_input = second_input - 1 print hours + ":" + minutes + ":" + seconds Or some such, anyway Also that print line doesn't work, but whatever, seems like you found a better way.
 time = 8500 hours = int(time / 3600) minutes = int((time % 3600) / 60) seconds = int(time % 60)
GOT IT (3800//60)%60 I AM A GENIUS. 15 line code in line, yo mama
Ok, easy there. **First, express what you want (*clearly*, i had a hard time understanding what you want.):** I want the numbers of minutes from a given number of seconds. The minutes should always be between 0 and 59, meaning if it's above 60, 60 should be subtracted from it. **Then, think about how to do it:** To get minutes from seconds, I have to divide it by 60. Then I could apply the [modulo operator](https://en.wikipedia.org/wiki/Modulo_operation), and then I want to round down to integers. **Then, make expressive, simple code:** seconds = 8500 minutes_all_in_all = seconds / 60 minutes_rest = minutes % 60 minutes_integer = int(minutes_rest) **optional: depending on how clear you are about your code, shorten it**: seconds = 8500 minutes = int((seconds / 60) % 60) *In the future, please try to follow the steps yourself, and if you have a basic problem, go to /r/learnpython*
You didn't explain what you were trying to do initially def seconds_to_time(t): h = int(t/3600) m = int(t%3600 / 60) s = t%60 return h, m, s seconds_to_time = lambda t: (int(t/3600), int(t%3600 / 60), t%60) You should go to /r/learnpython for these sort of questions in the future
That would get rid of the two hours though
Also, Fabric!
Sorry man ! Just a beginner in coding. I am doing a self study. And just joined Reddit for learning purpose. I would be careful next time in explaining what I want. Yeah i just figured it out myself was scratching my head for so long. I need to think like a coder. I did something like minutes = int((seconds / 60) % 60). Thanks man you are a true bro. I did go to /r/learnpython nobody know anything there, heard no reply so I had to come ask you guys. 
Thanks man i just replied through Reddit messaging service.
Because there's always a better way. XMLRPC manages to find the n-dimensional minimum of the problem space and stay there. Whatever is important to your app, there'll be something better. Security, performance (by whatever measure you use), developer-friendliness, (debugging!), ... It's not the only thing in the standard library that you shouldn't use in production, but it's alone in that (as far as I know) there isn't a better replacement out there. That in and of itself should be telling.
I too would like to know why! XMLRPC is my goto solution for these kind of things. Easy and simple to implement. 
Salt. Ansible. Pushy. 
I've been asking the same question for years. Dart is a decent compromise, but it won't see any real uptake until Google adds support to Chrome rather than Dartium.
Because JavaScript was there first. Every webdeveloper nowadays knows JavaScript, and there are libraries that make working with it acceptable. Heck, there even is node.js to write your whole server application in JavaScript too. Switching to Python would make not much sense, every Web developer would have to relearn everything, browsers would need to start adopting it while still needing to support JavaScript for old websites. Remember how painful the transitions from Python 2 to 3 is, now think what would happen if every JS program would have to be completely rewritten in Python. It ain't gonna happen. Also, while it is true that JavaScript has some pretty weird design decisions, it is not a bad language per se, and you can write acceptable code with it. Also, many good things from Python are now available in JavaScript 1.7, [like generators and list comprehension](https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.7). 
Breaking backwards compatibility with *everything* with a very arguable performance difference, would take massive developer overhead to port the existing browser APIs, would take forever to convert all the script kiddies to something sane, etc. That said, I'd be all for a browser doing it (Python or even Go, honestly).
Guido talked about this at some point. I think it might have been in [this](https://www.youtube.com/watch?v=0Ef9GudbxXY) keynote. Basically, nobody would ever use it, because js is so prevalent.
Insert some joke about heartbleed.
Aside from the historical reasons everyone else has pointed out, HTML is not whitespace sensitive, and Python is. So embedding Python in a `&lt;script&gt;` tag would be questionable at best, since it's commonly assumed you can just collapse whitespace in an HTML document together without losing information.
Someone has to create that browser which uses python. They need to show that it's a better browser because of the python--and then developers might get curious about it. 
Python also doesn't have the necessary sandboxing facilities to be used in a browser.
I would.
The whitespace thing isn't a good reason, because text inside `&lt;pre&gt;` tags or anything with the CSS property `white-space: pre` needs to have white-space preserved already.
That's an issue with CPython, the language itself doesn't prevent it.
Just as an FYI, depending on what you may be able to use STDIN/STDOUT to do what you're doing despite how basic it is. Like if I understand your example correctly, you want to generate a PDF using Go and then make it available for download in Django; you could have Go write the PDF file somewhere and have the shell output of the Go PDF generator be the path to the PDF file (and if you don't want to permanently keep the PDF file you could then use Python/Django to delete the PDF file after it's downloaded). And I know in my own experience, even if you do need the two scripts to communicate with each other, combing STDIN/STDOUT with the Python json library has gotten me plenty far in a number of cases. You can get pretty far only knowing the following three lines: import json json.dumps("thing you'd like passed via shell") json.loads("thing you'd like to catch from the shell and then use") To give a simple example, the first time I used this I had two Python scripts and needed to pass a dictionary between the two scripts via shell, and I didn't want to Pickle anything because I was already doing a ton of file I/O on a 5400 RPM hard drive and thus didn't want to add unnecessary file I/O load into the mix. json.dumps() and json.loads() made it really easy to "smuggle" the dictionary through the shell. Very simple but depending on what you're doing may be more than enough. (As an aside, as far as I can tell json.dumps() and str() do exactly the same thing, to the point where json.loads() will have the same effect whether you used json.dumps() or str().) Not saying that this STDIN/STDOUT is always the best solution, and it's definitely worth looking at other options (if for no other reason than to learn something), but IMO it's always worth considering whether you're trying to over-engineer a solution.
Chicken and egg problem. Browsers won't support it because no-one uses it. Developers won't use it because it's not widely supported. You'd need to get all the major browsers to agree on it, and even Google have failed to do that with their javascript replacements.
Why switch? Because Python is a better language in some ways. Would it work well with DOM, async? Of course. Nothing there is particularly language specific. Would a strongly-typed language offer a more interesting alternative? I think you mean statically-typed (as Python does have a very strong concept of types) but perhaps the answer is yes. Still, that's a different question, and there's no reason why there couldn't be a whole bunch of client scripting languages available.
Also see [the law of time](http://lawoftime.org) for another 13-moon calendar.
Also see script magic iPython if you are doing more exploratory work. I use it for running SAS statistical software from within a notebook and it's convenient as hell.
&gt; shouldn't it be strongly typed language Python *is* strongly typed. It's also dynamically typed. Did you mean statically typed?
Python is strongly typed. I'm guessing you're mistaking the dynamic types with weak typing. They're orthogonal.
&gt; i wish javascript had been jquery from the start wat
It's too late for the current generation of browsers. Too much legacy JS code. The next generation, however, could very well support it. 
Both are Turing complete languages, which means anything that can be computed can be computed in those languages. Both have bindings for other languages, so in terms of capabilities they're roughly equal. Here's why I prefer python: * Python has a great packaging system and a good community, which makes it easier to leverage work other people have done. * Python has a benevolent dictator for life (BDFL) who decides what goes into the language. It has a fairly consistent view of what is and isn't in scope for language features. Every time I use PHP, I feel like it's a glob of features different people thought would be cool, without a consistent vision. * Python tends to be better geared as a gene purpose language. PHP seems like a web development language that is capable of other stuff. Python is a language built for anything, with some third party frameworks that make it great for web development. 
&gt; And you at least have to preserve newlines for code that relies on semicolon insertion. (I'm not saying you should write code that relies on semicolon insertion, but browsers must be permissive in what they accept, and semicolon insertion is Patty of JS, for better or worse.) I'm assuming browser vendors mostly have their shit together. The "collapsing whitespace" problem would be more of an issue for servers, since there are a lot of incompetently-administered websites out there.
Thanks for the response it definitely helps for some clarification :) 
But it is here.... so why don't you use it? http://www.brython.info
i always write semicolon-less. much cleaner, and there are exactly two things you have to be careful about: 1. lines beginning with “[” 2. lines beginning with “(” that’s really easy to keep track of.
"I'd like to add Python support to our browser." "Don't bother. Minifiers will only be able to shave off three bytes per indentation level instead of four. No-one will want to use it." If bandwidth was really such an important concern for choosing which programming language to use for client-side scripting, we'd all be running [J](https://en.wikipedia.org/wiki/J_%28programming_language%29) in our browsers.
If bandwidth was such an important concern we'd be using gzip transfer encoding instead of mangling our source code into a disgusting minified mess. The main advantage of minification is to obfuscate the source code so it cannot be stolen, re-used or analyzed as easily.
&gt; I wish javascript had been jquery from the start lol
Me too. The only problem I see is that at first there would be very few people, little support... but I don't see which harm would do to at least have a choice. I mean, sure it's nice to know that for web development you just have to learn JavaScript and you're done, but I would only settle for that if JavaScript was a better language.
My point is that any software, whether server or client side, that blindly collapses whitespace in HTML will have trouble with JavaScript, not just Python.
Also to add to your explanation; making code run reliably in a sandbox without heavily restricting features and syntax is a difficult proposition. JS has had many security breaches (and will likely have more) but it has a massive technological headstart on any new sandboxed browser language. Pypy has an experimental sandbox mode that checks external calls against an execution policy, but it hasn't been secured in the kiln of broad deployment. I very much would like to see pypy added to browsers as an experimental feature but even that is a long way off.
Saw a talk on Brython at PyCon. It's slow but maybe someday it'll be the future.
Whoa, javascript looks a little cooler now. One thing I like about javascript is the inline regex.
https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS#python
&gt; I find it more conveniant to access dict keys as obj.foo instead of obj['foo'] I suppose I have two remarks: * I don't see how it's more convenient. (If anything, it's less flexible as your dict keys now can't contain hyphens, spaces, etc. as well as a bunch of other problems.) * Even *if you could* demonstrate were more convenient, I very much doubt the increase in convenience would outweigh the Weird Magic factor you've introduced to your codebase.
&gt;Query takes js and makes it as easy as css to use What do you mean by 'taking JS'? It's just a library written in Javascript. The language itself is unchanged. When you use jQuery, you're using Javascript. It's well and good for Javascript to be 'easy to use' but to do so requires abstraction from the elementary features of the language, which, unfortunately, actually have to be written. 
You forgot 3. return statements 4. continue statements 5. break statements 
This thread has been linked to from elsewhere on reddit. - [/r/programmingcirclejerk] [Why aren&amp;#x27;t browsers using Python instead of Javascript?](http://np.reddit.com/r/programmingcirclejerk/comments/23jjwq/why_arent_browsers_using_python_instead_of/) *^I ^am ^a ^bot. ^Comments? ^Complaints? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag) ^I ^don't ^read ^PMs!* 
Long time Php programmer and have been using python for the last 2 years on projects where I can. Good things: * With Python there is a library for EVERYTHING. As most C libraries have python bindings on them. Some libraries that are good are the graphing libraries (matplotlib) the maths ones (numpy,scipy). There are vision recognition libraries etc. Essentially you wont get to the point where you can with Php where you go "Damn, there is no half way decent library for that". It means you are not limited in what you are writing. * Once you jump off the web and get into application development Python is the way to go. Php is only for web in practicality. * It is easy to learn most of the language. Forget about the *"do it all in one line as an exercise"* python guys - just write need code that is maintainable. The one-liners confused me first up and made me think that I could only be good if everything was done in one line. * It has less kludge in it's punctuation (no $, no ; no {}) this makes it easier to read and type. * No more having to look up (haystack,needle) or (needle,haystack). No more trying to remember is there were underscores in that function name or not. * Python is a growing language and a lot of folks are very excited, while Php has peaked. * I have found that due to there being a standard for coding, it means the code available when seeking help is generally very good and very consistent (ie Pythonic) * And finally, Python is a full language. Php is only intended for web (and has been shoehorned into other applications), while Python can be applied to many other applications (mobile via Kivy, web, applications, raspberry pi etc.) Bad Things: * Python hasnt really tapped the general web market. There are plenty of ways that python can be used on the web Django, web2py, flask etc but in reality, and despite what the downvoters say, Php is MUCH more widespread on the net than python. But, it is making inroads. All in all, for web, I try for Python first then usually end up with Php (just cause I'm faster in it and know all the traps) while for apps, I go Python. There are many Php vs Python posts on the web - have a quick search. The above points are what I have found most useful in my role as a web programmer for a business (management information, reporting, tracking applications etc) 
JavaScript's async nature works really well on the client side...while python has async libraries like twisted but it is natively a synchronous language. Plus another reason I have preffered python over Ruby is that I have found python devs to be more versatile as the community seems to support the "right tool for the job" mantra where the Ruby community wants to use it everywhere...hence the creation of coffee script. 
No, because here you also have to pay attention if you do use semicolons, e.g.: return { A: 1, B: 2, }; This doesn't work, because a semicolon is inserted, despite the code being intended to explicitly use semicolons
Yep, if your implementation doesn't include certain builtins like `io.open` then Python could be just as secure as JS. In fact Chrome's PNaCl now lets you run CPython in the browser. However the page(DOM)-to-NaCl communication is not really optimised for web apps like the DOM-to-JS communication.
When you are serving code so many times, it just makes sense to minify it. gzip still works very well on minified code, in fact it could be better because the variable names are more similar.
S/he means that JS would be a lot easier to write if it had `document.querySelectorAll` which takes a CSS selector. Which it now does.
Have a look at the plot generated by the above code after ~30 seconds [here](http://imgur.com/pq0JJwq). First two waves correspond to my sweeping the accelerometer from horizontoal to vertical, and last 'stepped' wave corresponds to me quickly placing the accelerometer vertically (from initially being horizontal) on a table, and then back down.
Duly noted thanks! 
javascript and python are in competition for just make up some syntax and you're probably right-- but javascript narrowly edges out python even in that category :)
&gt;there even is node.js to write your whole server application in JavaScript too Whether it's a good idea to do so or not is debatable ;)
I made that same comment on a thread similar to this one. Aren't the compiled versions of python files better at this? (pyc,pyo,pyd,...)
Luckily SSH and SSL are different things, otherwise it would have been even more catastrophic than it is now!
&gt; such as replacement characters for indentation levels/newlines. you mean like braces...? http://www.pythonb.org/
Things like [skulpt](http://www.codeskulptor.org) already compile Python to JavaScript, so the object models are really very compatible. If you start poking at frame objects and the like, the subterfuge will fall pretty quickly, but for what most people think of as "Python", the internals work pretty much the same. Exceptions are a different question.
Dynamically typed simply means a variable can change types. Strongly typed essentially means things like `1 + 'a'` won't work. In a weakly typed language, it might guess that you want to change `1` to a string, or might convert `a` to it's ASCII value.
I am not going to comment on you code but I will tell you why you are being (rightfully) downvoted. What you've written is a terms of service violation, the bans you are trying to avoid exist explicity to prevent this kind of usage. Here's a couple of posts doing something similar with the same result: http://www.reddit.com/r/Python/comments/1ihpcu/googlelib_code_structure_changed_it_has_google/ http://www.reddit.com/r/Python/comments/1gewmu/googlelib_now_does_texttospeech_and_has_a/ You won't be getting much feedback here because you're violating Google's ToS and very few if anyone thinks it's a good idea. Furthermore, your action could end up getting those proxies IP banned or severely rate limited by Google. Finally, **please do not release this library and if you're going to use it youself, _use your own IP_**
parent's post is very much correct. PHP is much farther along in web, with multiple great frameworks to choose from that are very well supported and each has a huge userbase backing them. python out of the box isn't ready for web like a LAMP install is. you're going to have to do significantly more sysadmin work. there are only a few mentionable web frameworks for python, and they're not nearly as developed as say, zend, cake, or laravel for PHP. that said, python is light years ahead in practically everything else, especially data science &amp; machine learning. PEP (the python style guide) is much more widely accepted than any PHP style guide. also, job availability is much higher with PHP, but wages are often 2-3x higher in python jobs if you can get one. this is often a killer in business propositions because finding good devs is already hard enough... finding devs for a slightly less used language at significantly higher costs is just that much harder. http://readwrite.com/2014/01/08/in-demand-tech-skills-of-2013-java has some stats based on recruiting. PHP is #2 after java. python is #6. some people say PHP has peaked, but i don't agree. facebook has put a ton of resources into advancing PHP. a few companies occasionally support python (google is probably the biggest name), but it's not nearly what facebook has done for PHP. this is not to say you shouldn't dev in python. it's absolutely great... just that if you're just doing basic webdev, and you had to make a decision today, i'd still pick PHP. i currently use both... php for webdev, and python for ML.
Shhh, don't let the general public know that, and stop being needlessly worried.
You make a convincing argument about those job stats... Thanks for the input!
What the server allowed the browser to download either the native python version, or the version that was compiled to javascript. The python version would have to have some advantage such as being faster provide a better experience. Then, if you download a python extension for your browser, you'd get the python version, otherwise you just get the javascript version.
&gt; Dart is a decent compromise, but it won't see any real uptake I work on Dart. Given it's youth, I think we're doing quite alright already. Take a look at [this graph](http://sogrady-media.redmonk.com/sogrady/files/2014/01/lang-rank-114-wm.png). Details [here](http://redmonk.com/sogrady/2014/01/22/language-rankings-1-14/).
Python used to run in Internet Explorer on Windows but I don't know if it still can. Mark Hammond packaged Python as a generic scripting language on Windows and provided the interfaces that were needed (Windows Scripting Host?). Few people used it.
Wow, that really is impressive. &gt; DCPU-16 ASM And now I got sad.
That means two completely separate versions of the site to maintain. Nobody is going to want to do that. 
How do you define truth video? And grounding? That first sentence was Greek to me.
From what I understand, strongly vs weakly typed is how you specify components of the language. You don't say "int a" in python. The variable A can be anything, which means it's dynamic, but also means it's weakly typed since you can, in your example, type a + "string" without a complaint.
I envision only one version of the site, which has both .js and .py files on it. Depending on if you have the extension or not, you will download one or the other.
"has both .js and .py files" means two completely separate implementations of the logic, which is twice the work to write, twice the work to test, and twice the work to maintain. Again, nobody would ever voluntarily sign up for that. 
I've often wondered about and wished for this BUT what would be ideal is having a choice of many languages in the browser, not just Python but also Ruby, Perl, Lua, Tcl, Groovy, LISP, hell even client side PHP. Comped languages don't seem to fit so well but anything interpreted would be doable. Freedom of choice is a good thing - that's what you have on the back end and what's missing on the front end.
 1 + "a" #&gt;&gt;&gt; Traceback (most recent call last): #&gt;&gt;&gt; File "", line 1, in &lt;module&gt; #&gt;&gt;&gt; TypeError: unsupported operand type(s) for +: 'int' and 'str' 
Former JS VM browser guy. Off-hand list of technical issues: * Would have to implement a new VM for Python in all probability to guarantee necessary sandboxing (could fork, but the sandboxing requirements would mean a lot of close review to ensure nothing missed), and would have to evaluate closely what parts of the Python stdlib to include. * If a page can include JS and Python (or $otherLanguage), we then have cross-VM GC. That's… difficult. And slow. * The DOM is ugly enough in JavaScript. It's even worse in Python. Or one could design a whole new API, which is a huge can-of-worms in and of itself. Assume there is a hard constraint that no matter what one does, you *cannot* regress JS performance (it's used everywhere on the web, Python is used nowhere; browsers are far more judged on JS performance as a result). This means that practically one won't be able a single VM to nicely implement both languages (as anything so close to JS would complicate Python; anything closer to Python will regress JS which per above cannot be done), and hence multiple VMs are practically necessary. If one does need to implement a new Python VM, as I'd suspect, then that's a huge amount of engineering resources, and can one really justify the cost of that? Is the web really better served by that than improving JS? The JS VMs aren't going to stop being important — you're still going to have the cost of maintaining and improving them, so the Python VM would purely be additional cost. And why Python? If we're going to add a new VM, why should we use Python? It's not clear Python is *sufficiently* different to JavaScript to really justify all of the additional cost.
My favorite part: &gt; **_I_** find it more conveniant Writing code is usually a team sport and I while I've seen some really odd things out there, I don't think I've ever met someone who thought this was a good idea. A class to wrap some specific attributes sure, but not he whole dictionary.
Yes. My bad. Statically typed.
&gt; Without a doubt, you've seen a clock like this in demos of HTML5 How presumptuous!
The python process. For instance, if you run winrs [computer B hostname] python -m "SimpleHTTPServer" From computer A, an HTTP server will start on computer B. But, if you close the console window that you ran winrs from, the winrs process will die, the python process on computer B will die, and the server will shut down.
Why do you choose python over ruby, perl or php?
&gt;maybe someday it'll be the future. lol, I like that turn of phrase. I guess the future will not have been what it will be.
This is a big one. Javascript does a very good job of meeting the needs of async in browsers. Python doesn't lend itself to that syntactically, though you can make it work with certain libraries. For example, in Javascript an asynchronous callback can look like: do_thing(input, function(callback_data){ ... }); In Python, callback functions can't be defined in-line unless they're a single statement. The best you could do is: def do_thing_callback(callback_data): .... do_thing(input, do_thing_callback) Python has greenlets and such for pretending to have multiple synchronous threads, but I find the callback model to be more effective at asynchronous tasks.
ok, that was cool
While it's kinda half-assed and a pain in said half of an ass, lambdas can accomplish callback functions fairly well.
PHP isn't my favorite language, but you haven't been paying attention if you haven't seen the revolution in the last few years. The introduction of Composer and the modern features incorporated in the last few releases have made frameworks like Laravel and Symfony possible and a pleasure to work with. Drupal 8 is poised to be the best CMS ever made IMO. I don't really think it's fair to say PHP's time has passed. If anything, it's healthier than it's ever been.
 $a = NULL; $a--; `a` remains NULL. $a++; `a` becomes 1. Yeah no, I think I'll stay away from PHP.
It's my opinion that this is one of the cool things you can do in Python... That you shouldn't.
Why? I've never understood the appeal. It seems to combine two awful concepts in programming: Javascript (which is unintuitive and annoying in many ways; Coffeescript improves some of this, but it's still nowhere near Python or Ruby level) and asynchronous handling via callback hell.
By that page's definition, Java, Python, Scala, Haskell and every other language that allows user-defined types are all "weakly typed". It's mistakenly using "strong typing" as a synonym for "not extensible", which is so wrong that I had to read it several times before I believed that's what they're actually saying. I've seen many people try to define "strong typing" in my time as a programmer, but I've never seen something that outlandish before. Most of the time, when people talk about "strong" or "weak" typing they're talking about type coercion. Something that's "strongly typed" only has what they view as necessary coercions. The problem is that there's no consensus on what's necessary and not. The folks who designed OCaml would say that Java is "weakly typed" because it allows you to use the same operator for int/int, int/float and float/float operations. The folks who designed Java would say that it's "strongly typed" because it throws an error when you try to add an int and a string. The folks who designed Python would probably shrug and say "Who cares?" because you can overload operators to do whatever you'd like in Python, including type coercion. It ends up being an arbitrary and meaningless distinction that gets thrown as a pseudo-insult by people who think that some other language is too "loose" with types. Please don't contribute to that. We have plenty of precise, unambiguous language that works much better for discussing the design of programming languages.
Well I guess it goes back to the original query that OP had. I like that I don't have to switch between languages throughout the development of an application, and a code's readability to a non-coder of that language doesn't help me at all.
It's definitely vogue.
JavaScript fits the following criteria over Python, which provide benefits in a web environment: - more expressive in terms of asynchronous interaction - faster - more optimizable (but still not enough, hence Dart / asm.js) - Historically, the language which has always been used in browsers Debatably, this last one matters very little in the long term.
jQuery is not that great nowadays. It's seen it's day, IMO. And there are many alternatives to sass that are more expressive and faster.
*edit* Figured out the other issue But I'm stuck with the following error: request_token, request_token_secret = yahoo.get_request_token(method='GET',**params) File "C:\Python34\lib\site-packages\rauth\service.py", line 242, in get_request_token r = self.get_raw_request_token(method=method, **kwargs) File "C:\Python34\lib\site-packages\rauth\service.py", line 215, in get_raw_request_token **kwargs) File "C:\Python34\lib\site-packages\rauth\session.py", line 210, in request return super(OAuth1Session, self).request(method, url, **req_kwargs) TypeError: request() got an unexpected keyword argument 'oauth_callback'
&gt;Whoa, javascript looks a little cooler now. One thing I like about javascript is the inline regex. import re match = re.search('(\d+)', some_string) print(match.group(1)) Isn't much harder than: var regex = new RegExp(/(\d+)/) match = regex.exec(some_string) console.log(match[1]) That works as of ECMAScript v3, not much easier at all (note: the `new RegExp` is included for readability)
It's also about the language itself. Recent versions of JS (ECMAScript 5 and the upcoming ECMAScript 6) have had language-level changes to improve security (and JS already had a head start).
It's still a first class asynchronous IO design from the start, which is *much* better for writing scaling servers than Python's. 
Microsoft tried doing both JS and VBscript in IE. Didn't work too well for VBscript. Supporting multiple lanugages is hard to maintain. I'd go with Python and restrict the JS to legacy web parts for backward compatibility.
&gt; I like that I don't have to switch between languages throughout the development of an application No offense but this sounds kind of like a problem only for beginners to programming. Any developer worth his salt should be good at reading and writing in any language that comes his way. He should also know the right language for the job when given a task. Not only that, but the kind of Javascript you write on the server still looks quite different from the kind you write on the client. Node provides all of its own libraries and features and idioms, and then you have a whole different API when actually manipulating the DOM and rendering things. You will always have to change the way you program when you move from the client to the server. For example, if you make a PyQT app, your code and the way you write code will look very different from when you implement an API backend. The only thing that's the same is the syntax (and not a very interesting or unusual syntax at that) and a few boring language features. If a minor syntax change is screwing you up, then you need to spend more time practicing with different languages.
&gt; The main advantage of minification is to obfuscate the source code so it cannot be stolen, re-used or analyzed as easily. Great. Now I hear my prettyprinter laughing deafeningly at you.
I _like_ not having that switch, and it isn't there as a crutch. I've only dabbled with Node for a few hobby projects, and professionally am stuck developing in ASP.NET/C# :|
Damn this is neat. Who wants to explain to me why I should use Javascript instead?
I'm a beginner/intermediate developer and the idea of classes is just intriguing to be and I love basketball so I attempted to combine the two and PyBasketball was born! This is far from complete and I have a bunch more ideas and really this could be applied to a bunch of sports but I plan on adding a data scraper and options to choose what information to view and such but this is what I have now. I'll be posting all the bugs and issues in [PyBasketball Issues](https://github.com/robottom/PyBasketball/issues) and I'd appreciate if you could do the same or help me resolve the ones that exist. Not really sure how to end this so thanks! EDIT: Why are people downvoting this :(
Well, it is to ones advantage that Chromium and Firefox are out there and make up a majority market share combined. It would take a lot of work, but you can make branches with Python scripting in them of both.
If what you are doing is fairly simple and doesn't require waiting on IO then you can probably get by with timers. If it is any more complicated then you should probably use threads. The main concept to understand here is Qt's event loop. Any Qt thread (including the main GUI thread) is iterating through a series of events. In the main thread this includes updating/drawing the GUI elements. If any one event takes a significant amount of time then the event loop can't continue on usually resulting in the GUI hanging in some way. Depending on how long your update calculation takes I'm actually surprised you saw it update at all. Depending on how many updates you did and how long each one takes. In either solution (threads or timers) make sure you operate on one update at a time. I usually have my threads operate on their own timer. Timer triggers, a function is called, an update is sent. I'll leave the research as an exercise for the reader. I've never gotten a very good example when I've asked stackoverflow or mailing list questions on a boilerplate for Qt multi-threading so let me know if you find something good.
Twisted, Tornado and gevent *don't* give you everything Node gives you, and that is specifically why `asyncio` is being celebrated at the moment (although it's only for 3.3 or 3.4). Specifically, all node.js code is compatible with all node.js code. This isn't the case in between all those libraries. With some extremely limited exceptions, if you write a gevent library or application, it ain't never gonna work with someone else's thing that runs on Twisted. Node.js coders don't have to deal with this problem at all. And their implementation is a canonical one, that runs really well on Mac, Windows and Linux, is implemented for File IO as well, is written efficiently in C as an underlying library... I could go on. You get much much more from Node than any of python's 3rd party async libraries, pretending otherwise probably means you haven't worked with node much or ever.
Those are valid points. If only it was made in a nicer language... And you're right, I have never once written any Node code. I have looked at a fair bit though. None of the libraries I listed do async file IO, true, but it is usually quite rare that the blocking time of reading or writing to files will bottleneck an application at all. A two-way network trip may take 1 - 3 seconds to complete, but a file read or write is such an order of magnitude faster 99% of the time. I've never written a Python app that would gain a perceivable speed increase with non-blocking file operations, though I can see cases where it could be useful. I would wager that the majority of people who use Node do it so they can make and receive HTTP requests (and maybe sometimes other kinds of network requests) and database queries (which will usually also be just a network request) asynchronously; any other async operations are going to be sugar coating for most use cases.
So a couple of things that might help... a) Opening and closing a file will definitely extend your data collection time. Python's 'open' returns a file descriptor (as opposed to a file, which is technically something different). You can use 'open' outside of your animate function and then either use the file descriptor as a global variable, or passed in (either or.. both shown below)... file_descriptor = open(filename, 'w') ... def function(i): global file_descriptor ... file_descriptor.write(data) ... function(i) .... file_descriptor.close() or file_descriptor = open(filename, 'w') ... def function(i, file_descriptor): ... file_descriptor.write(data) ... function(i, file_descriptor) ... file_descriptor.close() b) the *mode* you've chosen ('w') in the open command will create a new file each time you run your program. Instead, you may want to append to the existing file rather than create a brand new file. To append, you can use: file_descriptor = open('serial_data.txt', 'a') c) matplotlib will inherently have a delay associated with starting up and displaying a plot. I think you may have intended to have something that was really more real-time (i.e. more like an oscilloscope). I don't know if you need the data later or if you just want to see what's going on while it's happening. If you need more help here, let me know. It's more involved and I would rather know if you need it before I present it. d) Finally, if you're not aware of http://www.stackoverflow.com, then I think it would be worth it to do some googling/searching on that site. There are quite a few different question/answers that could help. Reddit's cool, but often it's not all that helpful for specific problems. Reddit is far better at pointing out blog posts to read...
I'm really liking Clojure's functional handling of regex. It's just `(command pattern string)`, with no flags or groups to deal with. `re-matches` returns the string if the entire pattern matches it, `nil` otherwise. `re-find` returns the first occurrence of the pattern, else `nil`. `re-seq` returns a lazy sequence of matches. If you use grouping parentheses, you get back a list of sequences with the overall match first in each, followed by the subgroups, which makes for easy iteration. (re-find #"[0-9]+" "abc123def45gh987zy") ; =&gt; "123" (re-seq #"[0-9]+" "abc123def45gh987zy") ; =&gt; ("123" "45" "987") (re-seq #"[fb]ar" "foo bar baz far faz") ; =&gt; ("bar" "far") (re-seq #"(foo).*(bar)" "fofoofabarba") ; =&gt; (["foofabar" "foo" "bar"]) (re-matches #"bar" "foobar") ; =&gt; nil (re-matches #".*bar" "foobar") ; =&gt; "foobar" With destructuring binding you can assign submatches in one shot: (let [license "ABC-123" [full lpart npart] (re-find #"(\w\w\w)-(\d\d\d)" license)] (str "The plate " full " has number part " npart)) ; =&gt; "The plate ABC-123 has number part 123" The equivalent python or js would be more complex. This is assigning the input string to a variable, the resultant match and subgroups to 3 other variables, and concating some of the results into a meaningful string. You wouldn't want to write something like this for production code (if the match fails, you get "The place has number part "), but it still shows off some nice power.
This seems pretty easy to implement. Just tidy the code in classic style, then strip braces and trailing semicolons and run it through regular Python.
Because it's slow and will probably add a whole heap of overhead. Consider an 'import time' statement could result in the entire time module and it's imports being sent over http. In addition to the whole Byrthon interpreter and it's dependencies. You already get *some* of that with things like jquery (although browsers can ship with versions of jquery and can cache versions sourced from CDNs like the Google one.). Even better they can optimize for things like jquery selectors, instead of running the JavaScript code they can do it natively. If it did get adoption they could add CDNs for it. It could also potentially be done in the browser but full native support for Python would add about another ~25MB to browser sizes. Also then you have to deal with people on older browsers running python 3.4 when python 3.8 gets released. And people on IE not using it (although MS are apparently Python friendly for some reason). Plus Python doesn't have much in the way of a security model.
[How is that different from nearly every other language with regex?](http://ideone.com/DhY24u)
&gt; Switching to Python would make not much sense, every Web developer would have to relearn everything, browsers would need to start adopting it while still needing to support JavaScript for old websites. Had that been followed outside the web dev world, we'd still be using C if not FORTRAN or maybe even COBOL. In no way do I want to recommend changing languages every time some new language has some desirable feature. That would be chaotic. OTOH, we shouldn't indefinitely stick with aging languages just because they're widely used.
Turing completeness is absolutely irrelevant here. Pretty much *all* the useful languages, as well as the better part of the useless ones, are Turing complete.
Not fair. You instanciated the variable `regex` in javascript and then exec'd on `some_string`. You didn't even save the regex for the Python version. You can easily exec on a new regex in one line and have it still be legible. &gt;&gt; /(\d+).*/.exec("1234hello") ["1234hello", "1234"]
Because /r/lolphp. Python is not a great programming language (I know, unpopular opinion on /r/python...). It's an OK language, with a few great ideas, a few bad ones, and a lot of conservative middle-of-the-road decisions. It works, there are relatively few gotchas, the performance is adequate, and it provides reasonable tools for common abstractions. Not great, but good enough. PHP however is a disgrace. It is not so much a programming language, as it is a wild uneducated mix of Perl, C, Java, Smalltalk, C++, Objective-C, Shell, JavaScript, and whatever the PHP folks thought would be "useful", every single feature implemented without thinking anything through, and bolted onto the language in an ad-hoc fashion. [PHP Sadness](http://phpsadness.com/) and [Fractal Of Bad Design](http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/) pretty much sum it up. Python's shortcomings are, well, shortcomings. Imperfections. Every language has them, and I believe you can't make a programming language that doesn't. PHP's problems lie way deeper though, and I consider them highly un-fixable, to the point that I think using PHP for a new project in 2014 borders on criminal intent.
A new loop may block Qt's loop, you can call QApplication.processEvents (or QCoreApplication).
VBScript used to be in IE as well.
* Chicken and egg. Websites use JS because that's what the browser provides; browsers implement JS because that's what websites use. * JS is actually a better fit. Python is impossible to sandbox; JS is sandboxable by design. * JS's execution model is perfectly suited for browser scripting, and pretty straightforward to implement. We don't need threads in the browser, and frankly, they'd make building a browser even more of a headache than it is already. * Python is not that much better. Sorry for the unpopular opinion, but other than a bit of (arguable) syntax niceness, Python doesn't have a lot to offer that JS isn't capable of, at least not things that you'd want in a browser. * JS is more and more becoming the "machine language of the web", that is, people are starting to use something-to-JavaScript compilers over hand-written JavaScript - coffeescript is the most famous one, but there are JavaScript backends for many compiled languages, and it is much easier for such a compiler to gain traction than to get someone's favorite language into a web standard. * Time. Just think about it: it took 20 years to get JavaScript where it is now, and JS is a very simple language. I would expect *any* general-purpose language to require at least 5-10 years before a browser implementation would work as well as JS does now. * JS in the browser exists. Python in the browser doesn't. (See also the very first bullet point). There's probably more to it, but that's what I can think of.