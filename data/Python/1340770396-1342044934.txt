Community is quite active but the gap between versions is ridiculously long so most "outsiders" think it's dead. For example, the gap between 0.36 and 0.37 is 11 months.
One example would be Qt. PyQt and PySide both have their own take on how to wrap the Qt C++ libraries. secondly, "mainstream" is not even slightly relevant. people need all sorts of libraries. for example, I would want to wrap OpenMesh, which is only relevant to a small group of people. 
Looks brilliant. It's a release that will surely empower Python 2x developers to consider migrating their code base to 3. That said, this one stills concerns me: &gt; PEP 414, explicit Unicode literals to help with porting 
Why is it concerning? It actually even further empowers Python 2 developers to maintain a hybrid codebase.
Again, elaborate. It is a good one, as many people use it and it is C++. I also explained that it does not have to be mainstream. As long as there is a single C++ library that you wish you had bindings for, it is already worth it. 
That works for me too to but one of the goal of py3k was to clarify how Python deals with unicode data. Reverting the unicode literal sends a conflicting message I believe. PEP 414 says: &gt; Just as support for string exceptions was eliminated from Python 2 using the normal deprecation process, support for redundant string prefix characters (specifically, B, R, u, U) may eventually be eliminated from Python 3, regardless of the current acceptance of this PEP. However, such a change will likely only occur once third party libraries supporting Python 2.7 is about as common as libraries supporting Python 2.2 or 2.3 is today. But this will never happen if libs never start getting rid of them at all. So the question then is "aside from porting issues, does it make sense to keep the unicode literal at all on technical merits?". I didn't follow the whole thread and I can only assume this was debated obviously. I'm just not convinced it was the right move. For some reason, not being happy with a feature owes you downvotes 'round here. sigh. 
It was discussed furiously but in the end it was decided that practicability beats purity and we want to send out the signal to people that are porting code that we care about them.
That's what I got from the PEP indeed. It's a great move socially, I respect it. Just feeling uneasy with the technical outcome of it :)
Think about it this way: starting with Python 3.3, you now have the *opportunity* to *emphasize* the fact that your strings are unicode strings! :-) That might sound pointless, but in the field of mathematics we frequently use terminology or notation that is technically redundant because we are writing ultimately for other human beings and we want to emphasize a particular property of an object in order to reminder the reader about it.
&gt; I didn't follow the whole thread and I can only assume this was debated obviously. Of course--there was a long, tiresome discussion. This *is* the Python community we're talking about ;-) The one and only reason to restore the Unicode literal was to facilitate source code that run on Python 2 and 3 simultaneously. Guido talked about this a little in the discussion iirc (but I can't find it, maybe it was in person at PyCon): during the development of Python 3, he thought the possibility of having source trees that worked on Python 2 and Python 3 was low, that porting to 3 would be a one-way trip. It turns out that shared source trees actually aren't that hard--in fact that's the route Django is taking. He certainly never foresaw the "six" library! I think the Unicode literal problem was one of the biggest pain points for this approach. Happily Python 3.4 makes it go away, thus making Python 3 much easier to support, thus making supporting it more likely. &gt; But this will never happen if libs never start getting rid of [libraries that support 2.7]. I wouldn't sweat it. As Python 3 adoption grows, Python 2.7 support will naturally start to wither. Supporting both languages has a nonzero cost, and that cost will eventually outweigh the benefit of supporting people stuck on Python 2.
If a project can live with only supporting Python 2.6+, a clean hybrid codebase is already possible using `from __future__ import unicode_literals`. For example, the Django port was done this way, and doesn't use PEP 414 functionality.
Thanks for putting things into context like that. I'll admit I have very little need for the unicode litteral so I, wrongly, assumed it was the wrong answer to the right question.
Ah, but that's exactly why they are needed. The WSGI protocol specifies three different string types: 1. unicode 2. bytes 3. native (unicode for 3.x, bytes for 2.x) Prior to this change, if you wanted to write code that works on both 2.x and 3.x from the same codebase, and which uses all three of the above types, you have a big problem. If you used `from __future__ import unicode_literals` then you can get #1 and #2 but never #3. If you don't use `unicode_literals`, then you can get #3, but then to get #1 on 2.x you have to use u-prefixed strings. And those barf on python 3, so you've failed again. Allowing that to not barf is the action that clears this logjam. 
Actually, Hynek, if you look at the python-dev thread, I wasn't opposing the PEP, but felt it was reasonable to point out potential downsides. IIRC all my comments were about 3.2 support or the ambiguity of mixing `'abc'` and `u'abc'` in code. Edit: grammar.
Nice. The transparent conversion of Linux escape commands to Windows, means my command line app will be as pretty on Windows as it is in Linux, with exactly 2 additional lines. That will save me a days work at least. Is the author here? Please post so we can deluge you in upvotes.
My favorite feature in this release is `raise ... from None`. I was writing something two days ago that I wish I had this for. Python always goes over and beyond and continues to surprise me. Since it was a personal project, I will be more than glad to migrate to 3.3 and update my code.
Python supports a source file with multiple lines.
Can you explain what that does/ where you would use it? It's not so much I'm too lazy to Google it as I'd like to know the use case as well.
My use case is buggy, so I'll whip up something different. I haven't tested this, so pardon me if there are unintended errors. I know this is a bad example of why one would use it, but perhaps it would give you a good idea. try: some_float += 5 except NameError: try: some_float = float(input()) + 5 except ValueError raise ValueError('You did not provide an integer.') from None
I must admit that I don't get all the fuss about Sublime Text. Having used Wing and now using PyCharm my conclusion is that both are far superior as Python IDEs. On Windows Sublime Text doesn't even look good. Anyway, IDEs are a very personal choice ...
Just chirping in to say, stop thinking this is an IDE! It's just a really good text editor. Plain and simple.
&gt; Due to muscle memory burn-in, I also recommend: &gt; alias mate='subl -w' Wow, I thought I was the only one.
Weirdly, anytime I see a Sublime screenshot it is the OSX version.
The code is all dependent on a lib called Live so find that. EDIT: Actually, there are quite a few unsolved dependencies in here. EDIT2: This code is fucking rancid.
Are you able to step thru code line-by-line with your terminal + Sublime Text combination? That's just one thing I love about IDEs, and can't imagine not having this ability.
PDB works fine from the terminal.
If anyone else prefers editor over full-blown IDE, then Komodo Edit is also multi-platform, extensible and it's free. I've been using that for a while and now I'm going to give Sublime a try.
Yes a 60 dollar text editor. 
It doesn't have a debugger.
And motivated enough to get the thing in and prevent it from being deleted because it doesn't fit one of the wikipedia standards according to some blockhead.
... and costs money.
I've used PIL to overlay text on images. It's not the cleanest interface to interact with images IMO, but it was pretty easy to get text on top of an image. I'd say use PIL.
How does this compare for one accustomed to vim?
 "trim_trailing_white_space_on_save": true Damn, why did it take me until now and seeing this site to implement this?!
Yes of course, but ST2 is certainly not free in any sense.
You can use PIL's ImageDraw module for it.
Haha well shit, sounds promising for me
Great post. One thing that minutely annoys me though is "subl". What an ugly combination of letters. Why not simply `st2` ?
Not really, especially if it makes you more productive.
Here's [Sublime Text 2 on Linux](http://files.blackflags.co.uk/screenshots/screenshot-2012-06-27.19:42:39.png).
 ln -s /wherever/your/sublime/binary/is /usr/bin/st2 
To myself and others, it is.
PIL lets you use TrueType so if you had some good fonts, it would look fine. [PIL+TrueType](http://www.leancrew.com/all-this/2008/11/truetype-fonts-for-the-python-imaging-library/)
So what do you think is the difference between a "really good text editor' and an ide?
Agreed
I like the text editor, I want the developer to keep working on it. If I can throw a few bucks his way to help why not?
I've spent 8 months with Textmate (2.0 alpha), 8 months with vim and 8 months with Sublime Text 2 trying to figure out which one I loved the most and I absolutely love ST2. Esp with vintage mode enabled so that all the quick editing muscle memory I acquired during the vim time can still be used. 
What makes it not free when you can keep using it without paying?
Having a built-in debugger is the most essential thing in an IDE for me personally.
You wouldn't consider a plugin to do something similar? I think I'd rather have something simple like ST2 and pick and choose what additional features I want instead of some behemoth like Eclipse where, for a while anyway, doing anything other than Java or using plugins was painful.
Not free "in any sense" does not mean it must be open source. 
It has vim bindings. But it's not even close to the real vim.
That's fine- I was concerned more with the absurdity of MarketParasite's comment than the merits of Sublime Text.
[This has come up before](http://www.reddit.com/r/Python/comments/t43db/what_is_the_difference_between_list_and/c4jd9im?context=3): I (and others) prefer the literals because of the semantics, others (like you) prefer the words because you feel it reads better. I don’t personally feel strongly about the issue, I just do it the way I prefer.
The reason I bought Sublime was that it allows me to have 80% of the features of a full-blown IDE across *all* languages in *one* editor. I'm currently juggling Python, C, C++, Latex and soon Javascript, switching between them multiple times a day. Having open PyCharm, KDevelop, Kile and whatever I'd use for Javascript was getting cumbersome. As for the alternatives vim and emacs: Granted, emacs and especially vi(m) are ubiquitous. However, I'm not a travelling sys admin consultant that works with foreign machines on a daily basis, so this is a non-issue for me. More importantly, neither vim nor emacs is really free. You have to figure in the opportunity cost of getting familiar with the keystrokes to become more productive. This barrier is much higher for both emacs and vim than it is for Sublime. I would even say that this difference in time is worth more than the $60 if you're decently paid. Also, Sublime looks nicer. Yes, I'm vain. Lastly, I'm making a living off programming. I would love to give away my work for free, but I need to pay rent, buy food, pay off student loans. I can understand that other programmers want to make money, too. And Sublime isn't a weekend project, so while the price tag may be on the high side, I'm happy to support colleagues in their endeavour. Also, I can deduct it from taxes. Hehe.
I never stop working on projects!
I like () and []. list() and the like feel a bit like using sum() instead of +.
One is a text editor, the other is an integrated development environment. One has the objective of making it fast and easy to edit text. The other aims to provide a full set of tools for creating code, from project management, to text editing, to building, to testing and debugging.
Terminus 9pt :)
This. Despite all the features, the main reason I love it is that the scrolling is silky smooth on all platforms.
Or even `x = 1,` (though that is almost guaranteed to trip you up when someone doesn't notice the trailing comma and assumes x is an integer).
Sublime pretty much includes code creation, project management, text editing, and build systems, albeit in simple ways (which I like). The only thing missing is a debugger really.
I use `tuple()` and `list()` when: - When you have something like a generator that you want to expand to a list, e.g. `foo = list(func_that_returns_generator())`. Of course, you shouldn't do this unless you really need it; most of the time you don't as you can simply iterate over the generator directly. - When you need to make an element-wise copy of a list or tuple, although it's probably more idiomatic to use the slice operator for this. - When you need to pass a constructor, e.g. `defaultdict(list)`. For everything else, in particular literals, I use the braces and parens. I don't buy the argument that it's easier to read. You can't be a Python programmer and not understand what this means immediately: foo = ['bar', 12, 99.1] That isn't made any more readable by writing it like this: foo = list('bar', 12, 99.1) In fact, I would have to stop and wonder why it was written that way, and if this person had a good reason for doing it or if they just had a screw loose. Besides, if you're going to claim that's more readable then you would have to also claim that this: dict(red='exasperate', toaster='pelican') ...is preferable to this: {'red': 'exasperate', 'toaster': 'pelican'} ...which is borderline madness, given that the former can't deal with keys that aren't valid identifiers, and is therefore not suitable for general use. So if you're forced to use `{}` for dicts, I don't see why you wouldn't use `[]` for lists out of consistency. 
I know you only added them for explicitness, but the first and third cases aren't candidates for literal syntax in any case.
How does it compare to Eclipse's extensibility?
Looks like no one likes the dict. I was born this way.
You have a "BREAK" key on your keyboard?
A web browser, or mechanize style library. RESTful apis embrace hypermedia, not http. You use them by following links and forms. What you are doing is consuming rpc - where all the url schema and verbs are defined in advance, so they must be hardcoded into the client. hth 
Yeah, Pause/Break right next to SCR LK. It's standard in all keyboards, I think? [The top-right button](http://i.imgur.com/UyfsE.jpg)
Thanks, will check it out. Just as an aside, I thought light table was gonna support python at launch? Sorry, not *trying* to be pedantic, I just am :(
http://www.reddit.com/r/programming/comments/vqi7y/jarvis_like_light_table_but_for_python/c56q6qk sums it up nicely: &gt; Open source? No Kickstarter project? Available now? &gt; Begone with your witchcraft! 
with link, if you've somehow never heard of the requests lib: http://docs.python-requests.org/en/latest/index.html
And I don't think you understand what a price premium is despite my having posted the definition. 
&gt; The only weird line is h = httplib2.Http(".cache"). Why would I instanciate an HTTP object? Shouldn’t the HTTP.request method be available as a function of the httplib2 module? Seems like a design flaw to me, but that’s not a major problem anyway. That's because the object contains relevant state which is used for things such as keepalive connections. Otherwise you would have to keep such things global in the module and that is just silly.
I spent a few hours trying to get used to it, but I can't after coming from vim. I guess having learned vim in a few days and now having used it efficiently for about 3 years makes my habits hard to break. Also, screen + vim + python as a pseudo IDE works great for me... unless I have to work on the Solaris machines at work in which case it is, screen + vim + (language compiler) + ssh + scp :P
Or `"Spam".equals("Spam")`....
Actually, I create empty dictionaries in the same way, but I didn't think to include it.
&gt;This is because in a function, "i" is a local but at toplevel it is a global. Well that was fairly straight forward. If you add a "global i" after "def main():", you get more similar timings. 
The bytecode disassembly in the comments reveals the difference. Storing things to the global scope uses STORE_NAME instead of STORE_FAST. To understand the difference, it critical to know that Python stores frame variables in two different ways: 1. As an array for all parameters (even keywords) as well as all variable names identified during compilation. 1. As a dictionary of other local names that were assigned dynamically (such as via locals()). Most of the time for functions, the first case is used and STORE_FAST really is just popping a Python object from the stack and sticking it in a variable slot on the frame. However, STORE_NAME doesn't get to make such assumptions. It has to probe the current frame and determine if the locals object is a dictionary or a Python object and assign accordingly. Worse, this likely ends up with dictionary assignment, which is far more expensive than array assignment. As for why the global scope doesn't get the fancy array-like variable assignments during compilation I can only assume is due to historic reasons. Perhaps someone else can clarify/correct my explanation to help bring that into focus.
When people submit stackoverflow stuff here, they keep the title the same. Cruise02 wasn't asking for the answer, he was showing us the answer.
Right on. I only use list() notation to convert from a set
Ah. It would be nice if someone put that in the submit area or the sidebar or something. Sorry to have added nothing to the conversation.
arg :( I can't really fix it without changing the URL in Pelican so I just added a note. Thanks for noticing
Why are we forwarding stackoverflow to reddit?
Well, you **could** write `defaultdict(type([]))`, but that's the worst of all worlds, really.
Ah, but I read the "explicit" (in "explicit is better than implicit") as "unambiguous" as opposed to "conspicuous". There is nothing ambiguous about "[]" (it always means an empty list.) I generally prefer concision. If code is busy or heavily nested then it lacks concision--and increasing verbosity for the sake of salience seems like an odd prescription for such code.
If you are interested in Python, I advise you to subscribe to python tag at [stackoverflow.com](http://stackoverflow.com) directly. Unless, of course, you are proposing to forward every Python posts there to Reddit here.
&gt; If you are interested in Python, I advise you to subscribe to python tag at stackoverflow.com directly. I will not do that because this will give me tons of crap I don't want to read. Reddit is a place for posting interesting things. And this question+answer was very interesting for me. And be honest, how often do you see an SO post here?
nah, don't have time to read stackoverflow posts like that, unless I am searching for something. And I am not proposing to forward every post here :) I am just saying, this one in particular I don't mind and we can let community decide on reddit. (Remember good old downvote button?)
It wasn't my question originally, I just thought it was interesting. Thanks for the tip about re-wording the title. I'll do that if I find more interesting questions in the future.
Fair. But at least add some description why you thought it was interesting and worth a discussion. With no additional contribution, this feels like a spam or karma whoring.
Fucking globals.
main reason why i spent 10 minutes setting up keybindings for my most used vim commands and am (probably) staying with this beautiful editor
I preempted this response. I kind of agree with you on the definition of explicit. But also: &gt; There should be one-- and preferably only one --obvious way to do it. Mixing and matching falls under this. I prefer the longer form since that's more readable to those who are coming to the language fresh. I also prefer the longer form simply because it's *less* line noise in my eyes. Overall though, this isn't a big issue for me but this was a hella bikeshed post and I just cannot resist.
I have only one suggestion on using PIL: use Pillow instead
I personally use the type names when copying. a = list(b) vs. a = b[:] The first is both more readable (to me at least), and it works on generators, unlike the slice notation.
You added to the conversation, as you elaborated on the original answer, but I was helping make you aware. =]
How do they work?
&gt;considering there are many other tools in the same price range, or well above Yes like free. A price premium is a relative figure. Even if 60 dollar is not a large amount for you, that has to be taken in relation to how other products are price on average. Maybe I'm not leetzor like you but I've really never seen another text editor that charges the same price range. It's also nice that you throw around words like professionals though, as if that is not a form signalling to say *'it's what professional use!'*. Well ask the suburban dad why he paid 700 dollars for a fly fishing rod that he never uses. 
the creator - madflag - is active in the /r/programming thread http://www.reddit.com/r/programming/comments/vqi7y/jarvis_like_light_table_but_for_python/ (I'm just the poster; in no way involved)
That's exactly what happens. Check out [PyFrame_FastToLocals](http://hg.python.org/releasing/2.7.3/file/7bb96963d067/Objects/frameobject.c#l868) called e.g. via the implementation of [locals()](http://hg.python.org/releasing/2.7.3/file/7bb96963d067/Python/bltinmodule.c#l1319) (via [PyEval_GetLocals()](http://hg.python.org/releasing/2.7.3/file/7bb96963d067/Python/ceval.c#l3793))
you should read up on [nltk](http://nltk.org/) but I don't think that has anything to do with machine learning. But it should have tools for relating texts, or at least tools to build the tools to relate texts however you want. [Programming Collective Intelligence](http://shop.oreilly.com/product/9780596529321.do) may also be of interest to you. 
Great, thank you.
Try going through this: http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2011-statistical-machine-learning-for-text-classification-with-scikit-learn-4898362 Provides a solid introduction.
Haha I literally *just* got done watching this. This was definitely along the lines of what I was looking for, but not nearly enough code =/ Ah well, thanks anyway!
ok cool. Try this then: http://pyvideo.org/video/622/introduction-to-interactive-predictive-analytics and here'r the setup instructions: https://us.pycon.org/2012/community/tutorials/195/ Touches sentiment analysis,classification etc.
Don't worry too much about the negativity - if your post wasn't interesting we wouldn't all be reading and upcoming it. Good on ya for sharing - I learned something new that'll help me in the future :) - (though I try to stay away from globals as a rule anyhow :)
http://docs.python.org/library/functions.html#locals &gt; **Note:** The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter. 
So.... ?
Still need help man? I'd be more than happy to look at what you've got and help out.
I can probably re-route Ctrl+f but how to do that for ex commands?
I don't think that qualifies as sexual harassment. There are numerous other adjectives I could apply. Creepy, slimy, ignorant, disgusting, lascivious, lecherous, lewd, and depraved to name a few. But he didn't put his hands on her, nor did he follow her when she called him a jerk and walked off. He has no position of power over her, so no threat to livelihood, nor did he work with her. She'll probably never see the dumb ass again. Random stranger being dip shit in a bar does not equal sexual harassment. Further, it was done _after_ the conference and no where near the conference. I don't think the conference officials should be required to police the surrounding areas for indecent behavior on off hours. If it'd happened anywhere during and at their event, they should take full recourse, kicked him out, barred him for life, whatever. 
It works for me (even as a one-liner, as you put it): $ python Python 2.7.3 (default, Apr 20 2012, 22:44:07) [GCC 4.6.3] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; def name(x): return 'Hello,'+x ... &gt;&gt;&gt; name('reddit') 'Hello,reddit' &gt;&gt;&gt; How are you "printing out" the function? The problem is probably there. Also, I think this belongs to /r/learnpython 
For some reason, it wouldn't work in the python shell, but it would work when i opened a new script, but thanks for helping me 
My only worry is that the he-said-she-said nature of any such situation makes it difficult to enforce "zero tolerance" with a clear conscience. My feeling is that the situation as described in [this precipitating blog post](http://juliaelman.com/blog/2012/jun/3/lets-get-little-louder/) was bad enough that it warranted getting police involved, and that law enforcement are both better equipped and far more empowered to deal with such complaints than conference organizers. I know some will probably accuse me of victim-blaming or point out how self-conscious harassment victims can be and how dismissive police can be, but really, if you're going to defer to an authority, why not the one legally empowered to do something about it? It's not really a conference organizer's job nor place to adjudicate a conflict of this nature -- depending on what the police tell them they can choose to take appropriate action, from excluding the accused from the conference until the issue is fully resolved to excluding them from future events if charges are being pursued or the accused is developing a reputation for this sort of thing. I do think a clearly stated conference policy on these things might do some good, provided it painstakingly specifies the boundaries. I don't think it's a stretch to say that there exists a rather significant subgroup of male programmers who are not exactly worldly, and may have little experience interacting with the opposite sex -- for their benefit as much as any woman's, they probably need to be told *exactly* where the line is to be drawn in polite adult company.
Oh god, you just burned my retina. Also, sure. In a fight between my love of freedom and my love of places that are free of discrimination, the later so far wins. There are plenty of places in the computer world where you can say whatever you want (including reddit), so conferences should be inviting.
So, some dude tried to flirt with some girl, and now you're creating a big and loud movement? Next step: separated python conferences for women and men.
Sometimes people just glance at the title and go straight for the comments without actually clicking the link, so your explanation is still useful. Upvote to you.
Don't forget to make sure that all conferences also publicly promote: anti-racism, anti-antisemitism, anti-fraud, anti-rape, anti-theft, anti-&lt;insert more stuff that isn't the conference's fault but is illegal, amoral, and unethical&gt;. * edit: anti-semitism -&gt; anti-antisemitism
If you confuse flirting with harrassment, that's your problem, not other people's. 
"Sexual harassment is intimidation, bullying or coercion of a sexual nature" -http://en.wikipedia.org/wiki/Sexual_harassment Sounds like it fits the description
anti-discrimination is a superset of anti-racism, anti-semitism and many other antis.
You have to be careful to balance your anti-s if you don't want to wind up being a promoter of antisemitism.
I’d suggest to fix the title and add a redirect for the misspelled URI. BTDT far too many times. ;)
I would focus less on the python side of things and more on the theory and mechanics. Have you read the wiki on LSA? http://en.m.wikipedia.org/wiki/Latent_semantic_analysis#section_2 I'll outline something similar for you to get a feel for. Principal component analysis on the documents. The basic idea is that you find all the unique words in all of your documents. Then you count up the frequency of each word of each document. You form a matrix(or really a ndarray) where element i,j is the count of the jth word in the ith document. The shape of this matrix will be documents by unique_words. For each column you find the mean and standard deviation. You divide each column by its respective mean and standard deviation. Now if you find the singular value decomposition, U,s,V = numpy.linalg.svd(mat) You'll find a interesting view of your data. U is shaped document by document(d x d). s is a diagonal matrix shaped document by unique words(d x w) and V is shaped unique words by unique words(w x w). If you perform matrix multiplication on the above matrices your shape would be ((d x d)(d x w))(w x w), the inners cancel out, (5x2)(2x7) will be shaped (5x7). So your matrix would be (d x w) exactly the same shape as the starting matrix. In fact it should be very close to the starting matrix(within some machine epsilon.) But why did we do this you asked? Because U,s,V are interesting. The columns of U are orthogonal to one another. The rows of V are orthogonal to one another. There are termed respectively the left and right singular vectors. s is a very special matrix. All the elements are zero except for the main diagonal, which is all positive and decreasing(usually). Each entry is associated with the singular vectors. It is the amount of variance spanned by that vector. You can think of this another way as importance. The higher the value the more variance is capture by that singular vector. In fact you could drop the lower ones and approximate the original matrix controlling for the amount of variance you want to keep! Pretty freaking neat. Now what is interesting is that you have the best single vector you could find that could either matrix, mat * mat.T, which will be document by document shaped and have entries of the dot products of document i, and document j or the matrix mat.T * mat which corresponding represents the words. You found the best single vector that represents the relations between either documents or terms. Pretty neat. Now what is interesting to look at is a scatter plot of the first vector versus the second, first versus the third, second versus the third, etc... All on one nice plot and labelled. If you see a structure that resembles a clustering then your principle component analysis was successful. If a high percentage of your variance, defined by the cumulative sum of the singular values normalized by its sum, is captured by a couple vectors, then your principal component analysis was successful. There's a lot more to it, but this is like half a page of python and some googling. Don't go to blackboxes, try to understand the mechanics. Principal component analysis is a great motivation that is incredibly useful in real world settings. You should be able to work it out on paper for a 3 by 3 system. Bigger thoughts. Successful natural language processing isn't about fancy algorithms so much as it is about descriptive features. Features in our case were word counts. Observations were documents. A natural extension of word counts is bigram counts. You could tag each sentence with parts of speech, which requires fancy analysis. You could have a feature representing the counts of each part of speech. You could have a feature representing anything that derives from the data. This is the really crucial part of machine learning that sets the great models apart from the mediocre ones(in terms of accuracy at least.)
Well, I thought explaining it in a comment would be a more constructive mean than just a downvote, which gives no feedback.
I might end up doing this. I was lazy :)
So, at a post conference social event a drunk douchebag conference attendee tries to pick up one of the conference attendees? What the hell does this have to do with Python conferences or their organizers? 
If you don't mind using bbcode to author your posts, you could use [postmarkup](http://code.google.com/p/postmarkup/). Then you could write something like this: [code python] import this [/code]
Alexis showed me how to change the title without breaking the url. \o/ In pelican you can add a :slug: option so you force an url that's not built using the title. 
People want those painstakingly outlined boundaries, I get it. They want to know the rules and understand the lines hey can't cross. They're afraid of unfair application, they're afraid of misunderstandings, they're afraid of accidentally getting on the wrong side of that line without even meaning to. I get it. But, life isn't cut and dry. Relations between people are not simple. Human interactions are nuanced and steeped in context and subtle undertones, and frankly there is *not* a way to do this without some amount of subjective judgement. The point isn't a perfect system, but a better one.
Because lots of things that should be unacceptable in a conference are not illegal. E.g. Is it legal to hit on someone in a bar? Yes. Should that be something women should expect to happen in conferences? No. If you call the cops, they'll say it's all OK. This is where the conference organisers have to step up.
It's especially noticable in tech conferences.
In fact, there are several on the list already! Including several Python conferences themselves.
I'm not blaming her... but I'm blaming her.
That was post-conference and not during the conference. Big difference.
You cannot control someone in a public place regardless of what "code of conduct" the conference adopts unless that place is "rented out" by the conference exclusively.
It really isn't clear that the post-conference social gathering was part of the conference.
Yes, there should be one. I agree. Sad that there has to be.
Just for clarification, was the bar event cited a conference sponsored event?
Yes that depends a lot. If it was in the venue that was where lots of people from the conference went, with 'offical' conference suggestion, then it's part of the conference.
&gt; You cannot control someone in a public place regardless of what "code of conduct" the conference adopts Sure you can. You ban them from coming to the conference. Or, if you don't know in advance, you ban them from coming again. You don't let them do a talk at the conference etc. (It's also helpful for the conference to publically call them out on it, so people know that sort of thing is unacceptable)
&gt; I went to the conference director the next day and explained what had happened. He looked at me and sighed, confessing that he never should have allowed this guy to come to the conference. He went on to ask me what I thought he should do. Wait. What? Really? He is organizing a conference and is asking me what to do? Wasn't there a policy in place for this sort of thing? One conference attendee was disrespected by another and reported the behavior to the conference director. The conference did not have a policy to deal with it or offered the harassed attendee any reassurances. I think this *does* fall under their jurisdiction and they could have "kicked him out/bar him for life" that same day, or at least reassured the harassed attendee that a policy would be put in place for the future. 
It all depends on what you need them for. There are a number of good examples on stackoverflow for more advanced features. For simple usage, I often just go with something like: class Status: Unknown = 0 New = 1 Old = 2
I don't think it matters. What if a coworker harassed you at a happy hour after work? Wouldn't you still be justified in reporting it to HR the next day? It's not a company's responsibility to discipline its employees in all matters outside of work, but if one of them is making another employee feel unsafe (even outside of work), it's time to step in.
Try using a dictionary.
It's still not clear what you're actually doing. Are you reading data written by this application using these structs from a binary file, socket, etc? In that case you need to use the `structs` module to reproduce the layout. If you're just asking how to do something similar, use a dict. Python doesn't have structures because it doesn't need them, it has dicts that can be used to create arbitrary data structures. You can also use named tuples if you have a lot of data and don't want to duplicate the field names each time. 
It’s amazing how people who have never been affected by any type of discrimination decide for the rest, that it’s not a big deal and not our problem. But it _is_ our problem. Because _this_ is _our_ community. And I will not tolerate that people get discriminated or harassed like Julia without any reaction from _inside_ the community. Because that’s bad for our community. For every single person of us. A code of conduct is not about giving women or other minorities the power to get people they dislike out of conferences just by accusing them. So stop bringing that up. It is a firm statement by the organizers and everyone who decides to take part of such an event that _we_ as a community value every member of it and don’t want assholes make them feel not welcome. That if someone harasses them we’ll be there for them and won’t just shrug our shoulders and/or relay cowardly responsibilities to ominous third parties.
You can do this a couple ways (sorted from what I would likely do, to what I would least likely do): 1) You can create an class with no functions. Voila, a struct (in practice, if not in principle). 2) You can create a dict that has each of those items as a key: tabSOME_COMMANDMSG["anotherCommand"] = "C" 3) You can create a list with positions representing the values: CMD_NUMBER = 0 tagSOME_COMMANDS[CMD_NUMBER] = 128
I am a nice guy but I also don't think this belongs here and this woman is making herself out to be a victim over something that happens daily at bars. If you flip the genders and a woman was hitting on a male in a bar he would be all over that and would be posting in some thread "I met a chick at a bar, and she hit on ME!".
Although in that case anti-sexual harassment **at work** law would come into play.
You don't need the comma in a zero length tuple. `()` works just fine. Also, the literals are faster, because you don't have to call the function, the data structure is just created directly.
A bit of both. I don't have the whole program so I'm trying to figure out the code myself. I believe the data comes in the form of these structs and there are functions that use these structs to carry out further commands. I will try the dictionary idea for now.
Have a look at collections.namedtuple.
I believe dicts are faster, but I'll allow someone who knows better to chime in with proof.
This post needs some examples.
It may also have to do with people like you who prefer clever comments to actually explaining the problem. Did you think your comment will now make dr_root think there is such a problem?
1. traceback. _ _file_ _ will show where it's actually loaded from. traceback is a Python module, not a C module, so there are no tricks. 2. Typing "import traceback" again will not reload it. You need to do "reload(traceback)" for that. reload is not very reliable, though. See the docs for why. 3. There are no classes anywhere in the traceback module, so I'm not sure what you're talking about. But monkeypatching the traceback module works fine. (Example deleted because reddit insists on trashing my code even though it's documented to leave things alone if they start with 4 spaces.)
&gt;Why are you jumping straight to liability here? One may ask why people are jumping to conclusions while hearing only one side of the story? You haven't heard the organizer's side of the story. Or to the alleged guilty party (although that may be easier to corroborate). 
Well, thanks. The console was pointed at my ironpython library and not the Python27, __file__ was helpful. 
Fuck. That yellow burnt my eyes out.
I second this
The incident that prompted this seems very much akin to the Rebecca Watson debacle, except there was nothing ambiguous about the behavior directed at Julia. I don't attend many (any) Python events, but clearly this behavior needs to stop.
check out the [construct module](http://construct.wikispaces.com/)...i used it recently on a big project (reading j1939 traffic from a small network of nodes) and it worked great.
Hmm, I don't see it like this ... I don't say because she kept talking to this guy it's her fault that she has been harassed. I'm just giving a general advice of what I believe is the best behaviour when confronted in situations like this. That's a huge difference. 
I'm not not :-). Really, I don't blame her at all. That's why I started the post like this. Maybe the "are not to" is the wrong formulation for trying to give a general advice (I'm not a native speaker). I'm trying to say: "It's not your fault but certain countermeasurements can help handle situations like this."
The conferences do not have to be liable to try and do something about bad behavior. Liability would come into play if making a guarantee "You will not be harassed" and conferences can't guarantee that, of course, and don't try to. But we can guarantee the opposite, "If you harass, you'll be out".
Yay! Another reason for us nerds to fear talking to women.
At what point does the conference "end"? Where's the boundary? Suppose Hynek says an off color remark about the Italians today at a bar in Germany (no less) after a meeting with some of the core developers. Suppose there happens to be an Italian sitting next to him when he says it. And suppose the Italian gets offended. And let's just suppose the Italian happens to also be one of the guys at the development team, and decides to bring it up. Hynek gets kicked out for being a sports fan, having a bit too much alcohol and saying something stupid -- which we all do. Really? The "we'll kick you out" is a bad, gut reaction to something that consistently happens every weekend in bars across the United States. And it's pretty clear there's still just one side to the entire story. As a matter of common course in a business setting, it's generally accepted that people will be "safe". I think many are questioning what happens after the conference and whether or not a conference really should be sticking its nose there. It's a bad idea to be extending conference 'authority' past the doors of the conference.
And why do you think that is? Couldn't be sexism in the field or anything, which would include sexual harassment. 
I'm indifferent to the situation, but being loud doesn't get results. Why not suggest a code of conduct? This wouldn't be too difficult since other conferences have them already laid out.
http://docs.python.org/library/struct.html
I find it strange how you go for the "victim" explanation first, instead of basic demographics and common sense. Do you think fashion is a female-oriented hobby because it discriminates against men?
Maybe you didn't finish the block. See the "..." in my comment? I just pressed enter there.
Original case? Tech conferences have had this problem for as long as I've been attending them.
Again you are expecting strict and objective boundaries but these simply can't be outlined for human interaction. Subjective calls have to be made, the problem is when they refuse to make any call at all. It isn't a gut reaction, it is a consequence of actions taken by an individual and a decision that won't be made lightly. But, we can't ignore the incidents and we must *make a decision* in the first place.
&gt;I would suggest that a 'common sense' explanation includes the possibility of women being pushed away by harassment. And so it does, but it's not the simplest explanation. There's the mentality that if some group's not succeeding, there must be flaws in the system that hinder equal opportunity. That's understandable as it is often correct. But as the flaws are combed and removed from the system, sometimes nothing changes. Then we draw the conclusion that the discrimination must be rooted even deeper than we thought. "The problem is... the problem must be... sexual harassment! Yes, 98% of women in open source experience sexual harassment, and that's why the field is male-dominated! I mean, look at this incident of a woman getting harassed by a jerk (which was quickly disapproved by the rest of the community)!" Strange times.
Nah they just stalk them and threaten to rape them, and make kitchen jokes, oh and hit on them in professional settings, and talk over them, and assume they don't know what they're talking about.
&gt;I believe the data comes in the form of these structs and there are functions that use these structs to carry out further commands. That's a description of every program ever.
I want to know when we started making a big deal about a woman getting hit on in a bar? I must be missing something because this all sounds pretty fucking stupid to me.
It seems to me, though, that the people who care *aren't* going to be there for those who are harassed and who don't feel welcome, at the very least in the short term. I think *boycotting* conferences that don't have anti-harassment/anti-discrimination policies is going in the opposite direction from what we need. We need people who care about this *to show up* at the conferences that haven't implemented anti-harassment and anti-discrimination policies yet, both to push for such policies and to be the ones who have the courage to step up when they spot harassment taking place. That--not boycotting--is what "getting louder" should be.
Freedom includes the freedom to decline events, and the freedom to publicly express your reasons for declining events, and clearly declaring the criteria under which you will or will not participate in an event. Nobody is saying "you can never say X!". Many people are saying "If you say/do X, you will be be shunned by us and we will not participate in your events". Making decisions for oneself in response to the actions of others is pretty close to the core definition of freedom. This is not trading freedom for civility. This is exercising freedom in pursuit of civility.
Some observations that I don't have time to make a coherent comment out of: I'm not aware of any book that you'd see on a list of truly great programming books, that deals specifically with Python. That list doesn't seem dated at all. I think Python's niche is too small for one to be a "Python developer". You should always have a few more languages under your belt. I think that Python probably needs more emphasis on unit testing than less dynamic languages, because there are classes of bugs that the Python compiler won't catch for us. I tell other developers at my company that _Code Complete 2_ is like a cheat code for the rest of the bookshelf, it's about everything.
Packt offer [this book](http://www.amazon.com/Python-3-Object-Oriented-Programming/dp/1849511268) on Python 3 from an OOP perspective.
Patterns exist to compensate for language shortcomings. What is a "design pattern" in Java, for example, is an idiom or one-liner in another language. I think what you mean is "what should I read to learn idiomatic Python?". I suggest you read the recent parts of the python standard library and most of effbot's code. By all means stay away from Zope, Django, Twisted, and other large, old-ish projects if you're looking to learn what clean, readable code looks like. (That's not a knock on those projects, just an objective acknowledgement that they contain far too many WTFs/LOC). 
Thanks
i pledge to only participate in conferences that permit all kinds of harassment well, not necessarily all kinds, i am not that picky. as long as i can call black people niggers and women whores, i'm good to go
I have signed the pledge, because I want to go on record as agreeing this is crap that should not happen. I'd like to say that this is also about the *community* being willing to say, "dude, that is totally out of line, cut it out", right there, right then, when it happens. We can call for codes of conduct, zero-tolerance, etc. - and those are useful things - but where they need to be is inside the brains of every attendee: "I personally will not stand by if I see someone hassling another person. I will step in and say directly: that's not acceptable." I think the statement should include that too, but otherwise I'm on board with it.
Go with a dictionary: they're good standard Python constructs, and functions can use them to carry out whatever commands your heart desires.
This is your site/code? I applaud the effort to do it yourself, but you might want to give beaker a look. The disk read/writes might cause performance issues; beaker allows several faster alternatives (memory, memcache, redis?). Also, the loop through every session in trying to find the next session id will grow as you acquire sessions. An alternative would be to use an ObjectId (which has a strong likelihood of being unique in even large scale solutions) from pymongo (MongoDB wrapper) as the filename, try to write it, if it the file exists, try again (and repeat).
Thank you!
I'd add constants and avoid repetition. RED = 255, 50, 50 def random_color(r=255, g=255, b=255): r = random.randint(0, r) g = random.randint(0, g) b = random.randint(0, b) return r, g, b print(random_color(*RED)) Also, use always elif when you have several exclusive ifs. Otherwise multiple ifs can be executed in the same frame and you probably don't want that, among other possible bugs (judging from the final else, which is executed whenever you don't press K_DOWN). Add empty lines to delimite and show better the blocks. Put all that in a function or two, for reusability and because local variables are more efficient than global ones. E.g. init() and main_loop().
The overwrite check is just for creating unique session ids. If they have the session id and whatever security authentication you use matches, you can then use the preexisting id. But, yeah, if you move to a different backend, this sort of thing will be more managed for you, and you won't have to worry about it.
Really? You can be banned for life from conferences by the unsupported testimony of any one woman who just doesn't like you? That's not even close to what I'm getting from that pledge. How is that even close to "there should be an anti-harassment policy at all conferences"?
&gt;But as the flaws are combed and removed from the system, sometimes nothing changes. I posit that this has yet to happen in any significant way as regards programming. I'm out of my field in commenting about open source in particular, but I do know that in the US, schools struggle to enroll women in computer science, and that one of the leading causes is a combination of institutional sexism and a more personal misogyny; on limited time I found [this](http://www.aaup.org/AAUP/pubsres/academe/2003/JA/Feat/Ross.htm), dated 2003, and some other leads on more recent statistics by searching 'women computer science 2012.' It's reasonable to think that the lack of women in education about programming for whatever reasons would lead to less women being involved in open source. So, sure, harassment isn't the complete explanation, but it is part of the umbrella problem of sexism.
I applaud the effort but there are some issues: - glob.glob can be very slow. It is better to determine session names using uuid - for new sessions it is better to create the file in _init_ even if you write it in it in close to avoid concurrency issues - files in use should be locked else they will get corrupted on high traffic - accessing the file system is a bottle neck. If you have more than 1000 session files, opening a session file will become the slowest part of an app (in web2py we solve this problem using random subfolders of the session folder). - bottle may be serving multiple apps (and perhaps different domains) and there should be a way to separate sessions for the different apps (in web2py we do it by using a session name prefix). The web2py code for session is [here](https://github.com/web2py/web2py/blob/master/gluon/globals.py#L403) feel free to steal as much as you like. I would really like to have a good session mechanism built into bottle. 
If immutability is a huge concern, use a named tuple. But still, there is absolutely *nothing* that prevents me from just doing this: class Foo(object): def __init__(self, a, b): self.a = a self.b = b fun = Foo(1, 3) fun.c = "something completely different"
screen.unlock() indentation seems out of place.
(un) fortunately it can basically be bypassed with `try: ... except BaseException:` since all exceptions must be derived from that class. I'm sure some evil massaging with a metaclass could fool exception handling, but that exercise is left to the reader.
What's wrong with UnicodeError?
&gt;It's not hard to discover the extent of the problem. Go into almost any IRC channel with a female username. Or look at the comments on any female-initiated thread on /r/geek, /r/linux, /r/coding. Or soend some time reading geekfeminism.org Not hard *only* if one is looking. You may not realize this, but most people who read those subreddits are casual readers like myself. People like me will almost never see what you're talking about. What's obvious to regulars won't be to occasional readers. That's in no way a fault of the occasional reader. My point was that dr_root more or less was asking what the problem was, and you did not inform him. Furthermore, trying to get people to feel guilty is a sure-fire way of getting people to ignore you. If you were aiming for any kind of advocacy, your comment negated that effort. 
&gt;Why are you getting so offended? If you don't know how someone feels on the Internet, it's best not to make guesses, as you'll usually be wrong. 
Fixed for enterprising young classes: https://gist.github.com/3021651#file_random+assignment
I usually make SomethingWentWrongError and call it good.
Except many of those patterns are very un-Pythonic. 
In most cases, 'design patterns' exist to compensate for language shortcomings (and you're right that Java is the paragon of the design-pattern syndrome). However, at times I think that view works allright for relatively trivial undertakings but when you need to do tackle something more complex there might be just a couple of techniques that are somewhere in the realm of 'design patterns' that are more likely to help than hurt. To give one concrete example: some programmers, if they need to work with a problem domain that has that 'hierarchical' feeling to it, will handle it with some form of tree structure. In many cases a strict tree literally does not model the domain well -- for instance let's say the domain is actually far more accurately and usefully modeled by a directed acyclic graph. In such a case, modeling it with a tree can be anywhere from clunky (at best) to missing the entire point of the modeling task. It so happens that one very nice thing about trees is that they are very easily dealt with using very simple programming constructs, and hopefully noone needs to refer to things like 'design patterns' when working with them. But take the next more general step and use a directed acyclic graph instead of a tree, and suddenly you have a real potential for difficulties in tree traversal, whether nodes are to be visited more than once, whether concepts such as "inheritance" hold or are desired or not, all kinds of subtleties that weren't there in a tree. And it just happens that the "visitor" pattern (if I'm even naming it correctly... I've happily avoided design pattern books too!) can help maintain some sanity and some important invariants while working with such a graph. So again, I basically agree. But in some more wild and wooly cases there are a few pattern-ish practices out there that really might belong in a program. But it's all relative to the developer and the problem domain.
That makes sense. I thought it would be some esoteric programming thing that I've yet to encounter, and I'm glad to learn Occam's Razor applies in this case.
- By using `for event in pygame.event.get()` you're causing a spinloop, which uses up 100% cpu even if the game isn't doing anything. Instead use `event.wait()` which will block until there's an event to process. - You don't have to lock and unlock the surface. The drawing methods handle that for you. lock/unlock are provided in case you might need to do a batch of drawing operations. - Any time you have the same thing repeated over and over with minor changes, that's a sign that you can eliminate repeated code. Here's how I'd implement it: . from random import randint from sys import exit import pygame from pygame.locals import * WIDTH, HEIGHT = 1280, 720 pygame.init() pygame.display.set_caption('Colour Basher') screen = pygame.display.set_mode((WIDTH, HEIGHT), 0, 32) colormaker = lambda *rgb: lambda: [ randint(0, c) for c in rgb ] keymapping = { K_LEFT: colormaker(255, 50, 50), K_UP: colormaker(50, 255, 50), K_RIGHT: colormaker(50, 50, 255), K_DOWN: lambda: [randint(0, 255)] * 3, 'other': lambda: [randint(0, 255) for _ in range(3)] } while True: event = pygame.event.wait() if event.type == QUIT: pygame.quit() exit() elif event.type == KEYDOWN: r = pygame.Rect((randint(0, WIDTH - 1), randint(0, HEIGHT - 1)), (randint(10, 100),) * 2) pygame.draw.rect(screen, keymapping.get(event.key, keymapping['other'])(), r) pygame.display.update()
I use `raise hell` (which will, like yours, actually raise `NameError` in the general case).
I think it’s better if you read codes (for example, Python standard libraries or well known libraries) than books.
No matter which programming language you are using, each developer should definitly read [Design Patterns: Elements of Reusable Object-Oriented Software](http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/) (Gang of Four) from Erich Gamma, Richard Helm, Ralph Johnson &amp; John Vlissides. Software design patterns are language independant (if only by definiton, it's about patterns not language specific implementation). So a good book about software design patterns is not written for a specific language (and GoF is definitly one of the best).
Actually with the way things are worded right now, and the feedback I have seen along with the timing of all of this in relation to a blog post: yes I do expect them to kick you out. I think your scenario is much more reasonable: an apology. But then again what I see is "we will kick you out."
Brilliant! This is exactly the kind of thing I was looking for. +1 pythons to you, good sir!
You because something is common doesn't mean it's right. Just because something is common doesn't mean she isn't a victim. There's a difference between bars where people go to hit on each other (and likewise when people go to a bar to hook up), and a conference event that occurs in a bar. It's a semi-professional thing. Just because it takes place in a bar, doesn't mean it's free for all. Conferences promote the "going to the bar before/after the talks". It is unethical of them to claim "oh it's a bar, there are no rules there, free for all". They are responsible.
I don't really get it right now. Can someone be kind enough to explain to a person who hasn't slept in 72 hours what is this about?
I think mackstann is correct. Are you suggesting that no part of the stdlib should use another part of the stdlib so as to keep them "modular" and "separate"? If `http.client` starts using `logging`, that doesn't force you to use it, any more than it forces you to use all features of `http.client`.
Because signing such a petition is an official stand from Python Italia which requires discussion and authorization from the board. And since the conference is in 2 days, we're quite busy. We'll eventually discuss it, just let the conference pass.
What power? A secretary getting harrassed by her boss may put up with it because he holds actual power over her - to fire her and prevent her feeding her kids or paying her rent. Some random loser at a conference has no power over this woman. She can literally give him the finger without any ill effect. He has as much power over her as any other guy she walked past on the way to the conference. Did they all have power over her? I guess being harassed by a homeless guy on the way ot the conference might make her less likely to go to a conference (or leave the house) in the future , but you could hardly claim that he was then in a "position of power" over her. At least not without accepting that *every single person in the world* is also in a position of power, which makes the concept entirely useless.
That's why I suggested adding the null handler. If you don't call logging it forces nothing on you.
It's just a joke. OP has sometime trouble finding which standard exception to use, so as a joke he made a bit of code which raise a random exception from the standard exceptions module. There is also another code example in the linked gist with a fake object to which you can assign member but the member name is ignored and instead generated randomly
In python 3's http.client it calls the following: import email.parser import email.message import io import os import socket import collections from urllib.parse import urlsplit Why not add one more? 
most of the patterns in the GoF book are either inapplicable to Python (Factory), trivial to implement in a line or two of code (Decorator, Iterator), or just a bad idea (Singleton).
&gt;No matter which programming language you are using yeah, most pattern work perfectly well in non-oo languages..
wow this looks pretty cool
I think it's almost certainly for historical reasons. That said, logging is a debugging tool and, although you definitely want it during development, once you've pushed a working version to production you might simply not want logging anymore.
How to collect all exception classes (that have been imported): stack = set([BaseException]) all_exceptions = set() while stack: base_class = stack.pop() all_exceptions.add(base_class) sub_classes = set(base_class.__subclasses__()) stack.update(sub_classes - all_exceptions)
Absolutely, thus I suggest adding the null handler so that if you don't call the following in your script: http_logger = logging.getLogger('http-client') there is zero performance hit or development impediment for not using the logger module from http.client. I disagree that it's a logging tool, it's more than that. It can be IO for other tools to hook into if you build command line based apps, and if you use the console then you're not limited to python. You can use whatever your shell environment supports. 
A not-so-subtle hint: If you want people to appreciate what you're presenting, then don't use an example that you obviously haven't tried!
I don't think he had performance in mind when he wrote this.
What Python framework would you suggest? I've heard good things about Flask.
That is an excellent looking piece of code. There are so many little gems buried in there for a new programmer to study. I especially liked the anonymous closure. :)
Do you have admin priviliges on the target machine? If yes, my recommendation is to not use freeze utilities, but write a setup.py for [distutils](http://docs.python.org/distutils/introduction.html) that installs your script and all dependencies in one go. You can specify dependencies with the "requires" keyword and even give specific version numbers, if necessary. Edit: If you can't install packages on the target machine due to lack of permission, have a look at [virtualenv](http://pypi.python.org/pypi/virtualenv/).
Each time I read such articles, I have an irresistible desire to point out that languages are not the same to their implementations. I think the title should be s/Python/CPython 2.7 or lower/. Nobody treats GCC nor Clang as C. Equally, you should not treat CPython as Python anymore.
Looks like the problem lies in conflicting versions of glibc. glibc is typically binary-compatible with newer versions of glibc, but new versions are not binary-compatible with older versions. My suggestions is to try to freeze your script on a system no older than Ubuntu 10.04, so you could try 10.04 or even 9.10.
&gt; once you've pushed a working version to production And that's it? It carries on working for ever more? In certain situations where you can't debug a running system, logging is perhaps the only means you have of peering inside the system to try to figure out what's going on.
Absolutely.
I have this idea about syncing files from one computer down to any number of slaves using cloud services such as DropBox or UbuntuOne. But I just don't have time to work on it right now. So I figured I would ask here if anyone is willing to help with this. I just want to see something realized from it. I set up a project in [Launchpad](https://launchpad.net/rainwater) but I have very limited experiences with this, and I wouldn't mind some help with launchpad itself too. 
You know, I am not generally a big fan of crazy dynamicism for various reasons, but this library really shows how it can be used for awesome effect, as you can see in the first example: @function(ret=Int, args=[Array(Int), Int]) def reduce_sum(A, n): var ( total = Int ) total = 0 for i in xrange(n): total += A[i] return total What I think is so cool is that the 'var' function acts almost like new syntax for declaring typed variables. The trick is that pymothoa actually examines the abstract syntax tree and when it sees a var(...) node it effectively strips it out and instead make's a note of total's type --- and if you leave the var(...) statement out of the code above, then pymothoa will complain because it needs to know the type of all variables! Nifty stuff. :-)
You should investigate this as a basis for secure distributed storage: http://tahoe-lafs.org/
out of wensleydale http://code.activestate.com/pypm/wensleydale/
I have been talking to a few people in the engineering/scientific community and there seems to be quite a significant move from Matlab to Python. Having made that move myself, I can only encourage it. Python is so much more powerful than Matlab. That said, I am anxiously waiting for Numpy/Scipy/Matplotlib on PyPy since there are some things that are slower in Python because of its lack of a JIT. Basically anything that can not be vectorized (recursive functions etc.). Luckily, there are things like Blitz which can be used to mitigate that. Oh, and Py3 support for Numpy/Scipy/Matplotlib would be great, too. I think matplotlib is the one thing that is holding my whole stack hostage in Py2.7 at the moment.
Actually you can't write #define 2 3 because macro names must be identifiers, and besides which even if you could it is very different from replacing the value 2 wherever it appears in any expression (as opposed to merely the literal value 2) with the value 3.
The biggest difference that I see is that unlike Cython, pymothoa does not requires you to put your code in a separate file that needs to be compiled; everything is done inline. However, you do need LLVM to be installed rather than Cython.
effect.
Why is there a big dip in May/June? They suddenly removed a bunch of packages? Why?
Anything is welcome. We just need to set up a working group somewhere I guess (the launchpad thing I did or a new one at github) and then go from there. See the other replies I've made in this thread.
Seems to be very similar to numba. 
Indeed. Oops. 
You may wish to consider the Python package svgwrite http://packages.python.org/svgwrite/index.html It writes out svg which can be shown in a browser. It is not ment to be an interactive graphical package but the svg output does not need browser plugins anymore because basic svg is available almost all browsers.
Sometimes test / dummy packages are removed from pypi (e.g. [like this](http://pypi.python.org/pypi/Anika/) or [this](http://pypi.python.org/pypi/amoi/.lol.)). That may be it.
Launchpad is usually more directed towards Ubuntu/Debian users, although cross-platform uses have been spotted. Github is a bit easier to use, and a bit more popular for os independent projects (not to mention in my opinion it has a much clearer interface)
&gt; I think my strong suite is in thinking of ideas and concepts and not so much about doing actual programming For future reference, this right here will scare people away from any project you propose. I assumed you at least had an implementation idea... Have you done any research for this project? Have you at least checked that this doesn't violate the dropbox EULA?
Yep. Then he hits us with this gem: &gt;To be honest, I think my strong suite is in thinking of ideas and concepts and not so much about doing actual programming. Move along. There's no project here.
Yeah I know, this is my own blog, self-promotion is a shame. But I want to promote this device in the Py community because it freaking rocks.
I was writing something exactly the same as democratic jukebox but in php and with mpd. 
Very cool. A question about your blog. Are you using MD or RST for your markup? How are you getting the 'Note' box? Thanks! 
I use reSt and for the note box, you can do it with the ..note:: markup. See the raw source here. https://raw.github.com/tarekziade/blog/master/entries/raspberry-pi.rst I also had to tweak the CSS a bit so the box would float. See https://github.com/tarekziade/blog/blob/master/theme/static/css/main.css#L448
mpd looks really interesting
Includes support for postgresql hstore and sqlite full-text search. Currently hacking on support for postgresql ltree.
it is indeed very much alive. the core team is constantly improving performance, tools and the features.
What?
In which case "python" isn't a language, but rather "python 2.7.1 built on gcc 4.2.0 x86 for windows on /O3" is a language, distinct from the /O0 build. That's why "the implementation is the language spec" gets messy. (also,all those numbers were made up. Mentally substitute the real ones) 
The Monty Python sketch. They're out of a number of popular cheeses, including Wensleydale --- not the shopkeeper, the cheese. 
Thrift (https://thrift.apache.org/) and Protocol Buffers (https://code.google.com/p/protobuf/) are both useful for fast cross-language data serialization. Both Thrift and Protocol Buffers define data structures in a language-independent format. [EDIT] https://github.com/Cue/fast-python-pb
I actually did this a while back using pyevolve, if that counts. It was really more for a desktop background than anything else, though. Here are some of the images it produced: http://imgur.com/a/GFW0f#0
Could you tell us more details?
One, it sounds like you're trying to build a site scraper. I'd like to advise against this and advise you to look for an API. Second, if it's a website you're looking for, the answer is most likely PHP. PHP was *made for* the Web, so one can't hope to beat it in a web-off. (Don't get me wrong, I love the flexibility of Python, but using it for a web page just isn't right. It's like using a screwdriver for a nail.) 
[Nodebox 2](http://beta.nodebox.net/)
It's not bullshit, and it's not a bug (it's the unavoidable result of just how much of the implementation is exposed by the `ctypes` API, and of the reference semantics of the language). (edited:) True, it wasn't "introduced in a minor version update"; it was always there. But basically you don't know what you're talking about at all.
It has been stated but I'll leave it as my only suggestion (I'm still a noob myself, but recently hit a problem with this.) State if once and then follow it with elif statements instead of lots of if and then else. So Edit: Formatting derping if: #some sudo code elif: #some other code elif: #yet more code 
What about flask and django for example ?
Avoid "from import *", it is very hard to refactor later and save only a very few typing. I believe this construct has been removed in Python 3. Moreover you already import pygame, so it should be enough, you can call pygame.local.screen.lock() If you want to keep it short, you can do import pygame.locals as pgl pgl.screen.lock()
Thanks for mentioning Numba, I didn't know about it. It's similar but NumPy-aware. https://github.com/ContinuumIO/numba
PHP has built-in support for HTTP, but from the server side: it doesn't include a Request object or generic HTTP library, so your client-side code will usually end up using curl_*(), which isn't the nicest. You could also use the HTTP extension, but it's not installed in most builds I've used, and is unavailable for Windows at the moment. My advice is to use something like [Buzz](https://github.com/kriswallsmith/Buzz) for making HTTP requests in PHP. Python has http.client and requests, either of which is much nicer than procedural cURL in PHP. So, I'd say they're about the same in ease of use if you pick the right libraries.
Python wasn't *made* for server-side web content though. Sure, it supports it, in the same way PHP supports CLI input and GTK, but that's not what it was designed for. 
I've found ruby naturally steps in where python leaves off....Every time I've looked into php it's been a total pain in the ass.
So what? It does it damn well, and better than PHP.
Let's hope it works reliably, it's the first time we attempt it.
Is there anything supposed to be on? All I see is Alex Martelli's first slide on the lasagne track (awesome track name, btw!), and no sound. Edit: now it works :)
I disagree: PHP was built for a small subset of programming tasks (generating HTML), and has been expanded out - I could be harsh and call that feature-creep. Python is a general purpose language that has some specialised libraries and frameworks to make serving websites and generating HTML easier.
There could perhaps be some additional parts going into things like default constructors and session life-cycles and transaction management, etc., but I wouldn't confuse what's there now with that detailed verbosity.
Please don't use things "for which it is easy to write a parser" if they aren't accepted things. JSON, YAML, XML, ini, and other formats should work perfectly fine.
The core concept it's quite simple, an hash of the webpage is generated and each time that hash changes the page is reloaded using Javascript. Even though the implementation it's not definitive it's already available inside the development repository of the debugbar, feel free to give a try. It works with TurboGears 2.1.5 too.
All is in this "(within reason)" of yours. For me a strict separation of logic and config is highly desirable. My problem with code config is that it inevitably ends with such evil things as: if DEV_MODE: server = 'this' else: server = 'that' Doesn't look so evil but when you have 30 values to configure and 5 context flags similar to DEV_MODE, then you get a big smelly spagetthi plate. Then you never know if, where, why and how come a config has this value instead of that one.
I personally prefer python code, but I've run into too many admins that have problems with it, so I always go with normal configuration files. The more liberal a configuration parser is in what it accepts (unquoted string, for example), the better for admins.
Looking forward to using it in my next project. The HStore functionality makes all the difference for me. Just love it how clean and minimal the code is!
That's why I suggested: if DEV_MODE: from dev_settings import * But yes, I completely understand. My current django settings.py leaves much to be desired
&gt; Why should that be inevitable? In any team, in any project involving multiple persons, you need to put some guards near the cliffs. That's a reason for unittesting. That's why Java. That's also why pylint... And developers are lazy (me first), so when having to update a few lines in the config, they will hack a nasty if conditional instead. If your config is text, it has many advantages (eg portability) and it also prevents "clever" logic to infiltrate in the config.
Python code. Here are some arguments from [IPython's documentation](http://ipython.org/ipython-doc/dev/config/overview.html#the-main-concepts). They have a very good configuration system in place for a pretty complicated, highly configurable package. &gt;Configuration files that are themselves valid Python code. &gt;This accomplishes many things. First, it becomes possible to put logic in your configuration files that sets attributes based on your operating system, network setup, Python version, etc. Second, Python has a super simple syntax for accessing hierarchical data structures, namely regular attribute access (Foo.Bar.Bam.name). Third, using Python makes it easy for users to import configuration attributes from one configuration file to another. Fourth, even though Python is dynamically typed, it does have types that can be checked at runtime. Thus, a 1 in a config file is the integer ‘1’, while a '1' is a string.
It's more than interesting. It's the absolute shit for home network and even internet audio services.
That's quite a blanket statement. Sometimes a Python file with a list of values is fine. YAGNI.
I would stick to JSON. Sublime Text 2 does that too.
ini is good for me, it's as simple and interoperable as it gets.
Use the safe loader if the input is untrusted.
I prefer to use flat text files where I currently am. I'm the only developer so I've made all of my applications configurable from a single file. This way if I die or something my coworkers can still use the code that automates things across some 30 servers without any code changes at all.
I like yaml because unlike .ini files, XML, and everything else I've ever used, yaml has built-in support for datetime objects.
&gt; pickle files ಠ_ಠ
I'd recommend YAML over JSON. To my mind there are some important features that JSON lacks that a config file should have. 1. Readability: Config files should put a premium on readability. It is a primary place for readers of the code to go to see how the application is working, Extra clutter like quotes and commas make it more difficult to see what's going on. Even worse, the fact that json ignores line breaks and indentation means that you can write horribly unreadable config files. 2. Bulletproof syntax: It should be hard to accidentally break a config file. This is not the case with JSON. It's very easy to forget a closing brace, add a comma after the last element of a JSON object, or use single quotes instead of double quotes. 3. Easy editing: With YAML, a one line change is a one line change, and almost all of what you write is the data you want to include. With JSON, you might have to add braces if you're adding a level of indentation. If you're adding an element to a list, you might have to edit the line before it with a comma. You spend too much time arguing with the syntax, and not enough configuring the code. There are other good options. I don't think JSON is one of them, though. JSON is great for information interchange, but YAML is better for configuration.
Or if it absolutely has to not be human readable because crazy: BSON or msgpack.
Does Sublime Text 2 do xml, ini or python source files, too? PyCharm does xml even better, what should we use now?
I used to create nice xml's, but once I needed to get things done, I switched to python code. So, don't create overhead, until you really need it.
I thought you meant that admins have problems with code configs because the users, who configure the software on their own profile, get to inject code into programs.
See things like this are nice, but I don't want to install some script on every machine I work on (lots of VMs). Learning the standard set of tools (including cURL) is a good thing since they are installed everywhere.
link down, a fix will be deeply appreciated 
If it's anything beyond a one-off script I tend to use yaml. My current position requires me to use ruby though, and there seems to be a lot more yaml buy-in from the ruby community.
Here's Configure - a configuration toolkit for YAML: https://github.com/andreypopp/configure
Don't you have a standard build/image for your machines? Incorporating your own toolkit into those builds can make your life easier. 
I must admit that I might have been a bit harsh to ST2 the other day (but not every time) and my post here is sarcastic (ST2 is coincidence), so I take your critismn in general, but in this context it's just insane to provide as only argument for JSON as config file format that ST2 can display it nicely. Actually I think (hope) the downvotes are a result of my sarcasm and not because people really think that one should choose JSON because ST2 can do it ...
PHP is poorly-refined aluminum. It will work a lot of the time, and it's cheap as hell and easy to work with, but if you're trying to build anything that needs serious structural integrity, you're going to have to [bend over backward](http://www.readwriteweb.com/archives/facebook_gets_faster_debuts_homegrown_php_compiler.php/) just to keep it from breaking down.
I can get behind this comment.
&gt; Ideas are cheap. Code is not. [We find that more than 50% of the growth in each country in our sample derives from innovation in the United States, Germany, and Japan.](http://www.sciencedirect.com/science/article/pii/0022199695014071) [Open source software provide cost reduction ... 31% of the software and services market.](http://carlodaffara.conecta.it/the-economic-value-of-open-source-software/) [our analysis demonstrates a distinct economic advantage of pair programmers over solo programmers](http://www.tandfonline.com/doi/abs/10.1080/00137910309408770) Ideas from three countries can explain 50 % of the growth in a lot of other countries. Code can only explain 31 % of profit in computer software and services market. *Ergo: ideas are not cheap, and some code is free* (and that free code brings a profit smaller than the one from ideas). Also, it's good to collaborate in programming.
What are the top three specific issues you have with the talk?
&gt; It should be hard to accidentally break a config file if you've worked on a large enough YAML file, they're very easy to break by missing a single whitespace.
Exactly this, it's easy to add stuff like this to your build process/devops. Or alternative the poor mans way, keep a bash script around to setup/configure your box. You shouldn't be stuck with the default installed tools. I wouldn't want to manage my boxes without `htop` and `httpie` and the many other goodies out there. 
Why not PyCurl ?
Don't know why you have been downvoted. Anyone care to explain?
Command line interface.
Like I said, &gt; all the user can mangle is data they could mangle manually anyway (i.e. that which they have read/write access to) It feels you're arguing just for argument's sake.
the standard is wget not curl
Yes.
http://xkcd.com/927/
Never heard of root exploits? Plus the fact that an attacker (e.g. an evil co-worker walking up to the user's unlocked machine while the user went to pick up a coffee) could embed code into the user's config file, which would let the attacker run arbitrary code using that user's credentials.
Any suggestions on validating YAML in python? By this I mean both ensuring that it is well-formed as well as ensuring that it matches a schema of some type - has all the necessary elements and nothing else. If you're using Ruby or Java you can use Kwalify. I was thinking of playing with [DictSpec](https://github.com/olt/dictspec). But would love to hear what others are doing.
It's essentially a UI for requests.
You speak of some kind of dream land.
Well If you do DSL (domain specific language) then a source file is obviously the right answer. But on the opposite of ruby, DSL are not frequent in python. If you know how to code use hierarchical like structures (yaml or json which are interoperable). Any class should be insanciable with a dict like structure and thawed (serialized) this way. Config are basically parameters to instanciate classes in the proper states. If you don't do DSL or can't instanciate/serialize a class in a tree like structure, then use config.php, it might be what you are seaching fore. 
It's irritating because this is a great solution. I guess a "cleaner" one would be to have a local config file with some sort of inheritance. TBH using code to config works fine for xmonad and django and I like configuring those things.
Giving untrusted people write access to anything just opens up a huge vector that isn't solved by using a .ini file.
No I'm assuming you have access to whatever box you work with. If I didn't have access to a box I need to work with. I wouldn't touch it with a 10 foot pole, and well I couldn't anyways as I wouldn't have access to it. curl is not a skillset. deveops is.
I wasn't saying that curl is a skillset, I inferred that it's a tool part of a skillset and that you shouldn't be relying on third party modules as part of your skillset. Having access to a box and being able to do whatever you want to a box is two completely different things. Are you going to install python and httppie just so you can use a pretty version of curl? Btw, I am playing devil's advocate here.
Never, sadly.
javascript. There's a whole industry doing this called web analytics. 
It's expected a year from now, but I don't really think it's needed.
I didn't downvote, but on your point, my company uses that. For example on my local machine I have a "local_settings" that imports "local"(generic developer machine settings) which imports base settings.
At my last job, I moved all of my projects to Python 3 and that was about three years ago (3.1 came out June 27, 2009 - I moved around August). I now work at Canonical and my current task is porting parts of Ubuntu One to Python 3 for the Quantal release. I think what we have coming up in Python 3.3 could be the tipping point on our end. It's going to be a damn good release and hopefully everyone tries it out. ---- My answer to the question is: whenever *you're* ready. Distros and companies will follow your lead. If you want Python 3 and you write code for Python 3, it will catch on. If everyone gets over the "I can never port" mentality and just fucking tries it, it will work. It's really not as hard as everyone tries to make it out to be. Sure, it's probably hard to get your boss at Big Time Bank to let you spend time on the Twisted or Django ports, but while your wife is watching Dancing With The Stars, you can probably review part of the patch (reviews are what's actually needed to get Twisted on Python 3 - not code). If you're working 60 hours under tight deadlines at Big Time Consulting, it's probably not in your time sheets to spend time porting NLTK. Instead, look through your codebase and see what other dependencies you can *remove*. Too many people I talk to have too many dependencies, seemingly for no good reason other than it being easy to type `pip install somebullshit`. Removing `somebullshit` might make it easier for you, especially if it's not likely to be ported. Take this whole [Julython](http://www.julython.org) thing and run with it. Run into August. Run until it's Python 3 you're running.
As soon as [this list](http://python3wos.appspot.com/) turns pretty much all green.
Yup, I also think that v3.3 will convince a lot of people to switch. The new Unicode API (making unicode strings use less memory) is really cool, and the u"" literal is going to make porting much easier. Many libraries on PyPi have already made the switch anyway, so I'd say that we're already sailing at a good pace.
I've been using it for three years now on a solution that runs everyday. As long as the libs are there for your specific needs Python 3 is fantastic. More importantly the issue with libs is slowly fading away. The situation is similar to what you see with C++. Many are moving to C++11 as fast as they can because like Python 3 much has been corrected and improved. Others are forced to restrain themselves due to library support or other factors (in other words real issues). Then you have the stubborn that won't switch just because. I hate to say this but much of the delay with Python 3 seems to be the last group mentioned above. Many seem to have an irrational resistance to the move to Python 3. I'm not sure why. 
&gt; Are you going to install python and httppie just so you can use a pretty version of curl? Seriously, yes, I would. For me, it's just a simple matter of adding it to a chef configuration and deploying it. Maybe a 10-20 minute job. Python is also normally installed on most linux distros. Here it's a nice one-liner: `python_pip "httpie" do; action :install; end` 
In my limited time with ConfigParser, I couldn't even store a dictionary in it without doing something silly like using eval() or storing each part of the dict as a variable and doing something like foodict = {} foodict["bar"] = configparser.get(foosection, bar) With json you can simply store the dictionary almost the exact way you would in python code. afaik xml is about as good as configparser for dicts though.
no
Probably not until RedHat Enterprise Linux supports it. Lots of enterprise applications target RHEL, and won't break compatibility with the python version it comes with. I'm personally glad to be targeting RHEL 6 now so I can use Python 2.6, as 6 months ago I had to be 2.4 compatible for RHEL 5. Enterprise environments move slowly for the sake of stability. I know I won't develop for Python 3 professionally until RHEL supports it. That said, my personal projects tend to run on both 2 and 3 where possible. 
Sorry, I meant Numpy without the other two isn't always sufficient for the projects I work on (which require statistics, linear algebra, though I know Numpy does have some linear algebra support). I'd heard about Matplotlib being ported, which is cool. I have no issue with Python 3 at all - I'd love to use it, and it's what I used when I started learning Python. But (and I think this is a fairly common problem), it's difficult to switch until commonly used libraries are also ported. Pygame and the Python Imaging Library are other libraries I've needed that aren't ready for 3 yet. edit: Just remembered that use PyIMSL some at work and I believe it's only available for 2.6 or 2.7. 
Website that sends requests to a page to get basic information (such the karma score on a [reddit user page](http://www.reddit.com/user/mr_pleco.json). The script then takes into account several pieces of information and then writes html on the home website accordingly.
Where do you find scipy? The sourceforge page (for OS X at least) only has 2.6 and 2.7 listed. I do see that it's available for Python 3 for Windows, however. Do you know about Linux?
How is this different from [rsync](http://en.wikipedia.org/wiki/Rsync)?
Reinventing the...
It's my understanding that they only recently began to support 2.7 on GAE.
What is expected a year from now?
Who cares ?
elegant code
Yup. The two notable exceptions from that list (as listed at the very bottom) are wxPython and PIL, both of which are absolutely mandatory for me. My other must-haves are reportlab, ssh/paramiko, and BeautifulSoup. That's not even including the various web frameworks.
Since version 4, BeautifulSoup should work just fine with Python 3.
You may have 'accidentally' something, just sayin'
I will wait for PyPy. PyPy dramatically improves my build process.
&gt; Too many people I talk to have too many dependencies, Amen. I see too many projects that require to import half of the world, in exactly the same configuration/version as used on the developers machine. The real fun starts when some of the dependencies used to be on google code/github, but are now moved somewhere else.
But pygame 1.9 is almost completely ported and pygame 2 supports python 3 anyway
You can find Windows binaries for a Python 3 compatible Python Imaging Library [here](http://www.lfd.uci.edu/~gohlke/pythonlibs/)
Here are [instructions](http://stackoverflow.com/questions/8605847/how-to-install-matplotlib-with-python3-2) for building matplotlib against Python 3.2.
I find that to be more dependent on the developer.
I went back to C to brush up on it for my own little shell project and wow, :(, after using Python it's so incredibly annoying.
So sad it doesn't list CherryPy which was one of the first web framework to support py3k :/
I don't entirely disagree with you, but I just spent a fair bit of time pinning down some import problems that were less than self explanatory. from os.path import walk foo = walk(some_dir) from os import path foo = path.walk(some_dir) import os foo = os.path.walk(some_dir) Are all equivalent in that they raise an error, cause what you actually wanted was either: import os foo = os.walk(some_dir) or from os import walk foo = walk(some_dir) And there's: import os dir="/home/user/stuff" if os.isdir(dir): os.path.chdir(dir) Which fails magnanimously, because isdir() is from os.path and chdir() is from os.
Thank you! I brought up my adversity to over-dependance on third-party packages in the #python channel some weeks ago and I got absolutely castrated for it. People seem to think that the *only* problem with dependencies is how you manage them, i.e. the build process/getting the packages set up on a new machine easily and automated properly. There's a whole slew of problems behind that as well. Adding complexity to your project by introducing unknown code, code which developers need to understand and possibly debug which the team didn't write themselves. Code which is dependent on the vendor for updates and changes if your team hasn't got time to be sending patches upstream. Deplexity!
I'm curious, what type of job do you do and what's the industry you work in? I'm considering a career switch ;)
For some projects, now. It's currently at the point where the effort in screwing around immature dependencies is going to be less of a pain than porting later down the line.
Ouch!
&gt; curl [and] how may be more difficult than using PHP Nah, I mean it's not very nice to use *within* PHP. I was talking about PHP's [cURL extension](http://nz.php.net/curl), which provides a light wrapper around the C library. I just find that using the PHP's procedural cURL functions almost always requires quite a bit of boilerplate. For example, you'll be using string functions to split the response headers from the response body (explode($response, "\r\n", 2)), rather than doing it in an object-orientated way, where you have an HTTP Request and Response object to work with and extend.
Regarding the "shit ton of money" part. Can you elaborate what you do?
Julython sounds cool. But can't we do this in February when it's dark and cold and wet outside and not in July when we in the Arctic can finally venture outside without (much) fear of death by exposure?
I'm pretty sure that matplotlib 1.5, which will have python 3 support, isn't released yet. But *please* correct me, and I'll spend the rest of the week porting to python 3. With the amount of import from \_\_future\_\_ that I've got going on, it should be a breeze.
Please, explain.
I started developing in python fairly recently, and not everything I need has been ported to python 3 yet. But I make sure to put this at the beginning of every file: # encoding: utf-8 """ Describe the purpose of this file. """ from __future__ import absolute_import, division, generators, nested_scopes, print_function, unicode_literals, with_statement This enables a bunch of python 3 syntax, which is both a general improvement, and should make porting to python 3 easier, when those last couple of libraries are released. 
I'm praying for pypy to support matplotlib. I'm doing on-demand rendering of [weather forecasts](https://www.sarweather.com/forecast/result/20120629-221836-a60c:ff4ac28125cd/interactive/temperature/0) onto tiles being overlaid on google maps, and I wouldn't mind if this were ~5x faster...
Some simply say it's because they don't like the removal of the print statement.
Really ? I learned in an university in a developing country (Vietnam) and I can choose any programming languages for my class if it fairly popular and I can give clear instruction on how to setup and run it. You should ask your processor to do this :)
why?
python2 is default on (now) older linux distributions. Those older linux distributions are still used a lot and a lot of frameworks are build around them. In addition python2 is still a really good language, so the cost of migrating is really tough to justify. When I wrote my previous framework, my company had to support older stuff, that meant python2. And in fact in part of the project it meant supporting 2.4. My guess is once distros like centos support python3 out of the box it will become easier to use python3.
Python 2 is not EOL. Security fixes to it are still coming and will be. To me, Python 3 doesn't really have any significant amount of new features to port 240 kLOC to it. OK, so in some rare cases I can use nonlocal instead of wrapping an immutable value in a list and some other minor features.
I'm just gunna be blunt. There are no 'good' or 'bad' languages, 99% of the quality of software is derived from the quality of the programmer. If you know a programming language, if you can write it well, and you can use it to achieve the result you need, then it's fine. You have a task. It needs to be done. Programming languages either can or can't achieve what you want, they either have the features you need or they don't, and that's not something you need to think about, just pick one that can do what you need to do (Most languages can do most jobs thesedays). The real decision is: How fast can *you* implement your solution in language X, and is that fast enough? Maybe you have years of experience in perl, and no experience writing python, so why choose python then? Maybe there's some framework or plugin for python, which means you don't have to write the meat of your application's functionality from scratch, and that framework/plugin isn't available in another language, in that case, why choose anything else? For the sake of argument, let's assume you know nothing about programming at all. In this case, I'd say python is the choice for you. In terms of speed, you'll get the job done probably as fast as if you use php, but you'll probably be using better design patterns. Also, python will be more easily deployed, python is installed by default on pretty much every linux distro, so most servers you get your hands on will run a python script immediately (I would leave worrying about web servers to someone else, logically, that someone else might be you, but don't fall in to the trap of "I'm writing in php because wamp/lamp is easy to install and I don't know about web servers").
Batteries included (not only the standard library but also this awesome stuff in PyPI).
I'm not sure of any kernel dependencies, but I had to deal with centos 5.4 (and it was with customer machines so the dependencies we could install were very limited.)
well, most of the ports are automatic ports and not very well tested. so it's rather that when the list turns green we can start with the real job.
PIL has private ports to p3k http://stackoverflow.com/questions/3896286/image-library-for-python-3 ...and [Phoenix is alive](http://wiki.wxpython.org/ProjectPhoenix). Nothing stable, but... if you want to play, you can. ;) 
Why explain when you can read the PEP: http://docs.python.org/dev/whatsnew/3.3.html#pep-380-syntax-for-delegating-to-a-subgenerator
Say you're writing a generator function. But it's getting large for a single function, or maybe you have some duplicated functionality. You'd like to refactor parts of it into their own functions. That's simple enough to do: for val in some_sub_generator(): yield val But if `some_sub_generator()` wants to truly interact with the main generator, such as by using the "enhanced" generator protocol (`send()`/`throw()`/`close()`), then things become ugly. The new delegating generator syntax lets you replace the above with yield from some_sub_generator() ...which correctly handles both the trivial case and the more complicated cases. See [PEP 380](http://www.python.org/dev/peps/pep-0380/) for details. 
I guess you're mostly right. There is still an awful lot of python wrappers around it, so there could be some improvement.
IIRC Ubuntu 12.10 will start shipping Python 3 as the default. That will ensure end users have Python 3 and might have to go to a bit of extra effort for Python 2 apps.
oh, yeah, and if your team has found the time to reinvent the wheel then certainly they have the time to send patches upstream (or as an alternative maintain a fork if that is difficult). Code reuse is good and dependencies is (mostly) a solved problem, so improve, recycle and be a good open source citizen ;)
Another reason is because is almost English, i.e., readability.
Waiting on Django here.
Yeah, I can never really tell when to use `os` and when to use `os.path` when manipulating directories, I have to look them up almost every time. It seems functions in these modules are distributed somewhat arbitrarily.
The community has replaced it: http://pypi.python.org/pypi/Pillow/1.7.7, and we can probably merge in those Py3 forks, just need someone to do the work.
Nice! Didn't know about those, thanks.
I forbid myself to use "import *", no exceptions. Have you ever had to split and move around interdependent packages full of "import *"?
Did not downvote but import * is evil. Martelli is advising against that thing strongly in Python in a Nutshell, and I think he is right. 
Hum. Python is not write one, read never. I would like to fight against the "save the keystrokes" tendency I find in some developpers. Please type a few more keystrokes, and make your code readable. That's what is important, because, a good reason to like Python is that Python code *can* be readable.
This is where having an example with a practical problem to solve would be so handy. I don't really get this code, and I often don't get code if I'm not told what it is the code is supposed to do.
Matplotlib is working with Python 3, at least on Linux. *Edit: I guess it's not official. I forget what I had to do to install it, but it definitely works on my system.
IMO, it will only happen when Linux distros start including it in the default installation.
dir() and help()
There's plenty of Python 2 code that will never be ported to Python 3.
it’s no problem; here on arch, everything is readily available in the official repos. what’s your OS/distro?
Django is targeting Python 3.3 with version 1.5: https://www.djangoproject.com/weblog/2012/mar/13/py3k/
I like it, but how would you handle multiple files well? Most projects don't only have one file. 
Also Mac OS X. They're currently on 2.7. It's just not worth the hassle of asking all your users to install a new version of python when they already have a an earlier version that works perfectly well installed as default. Is there a way to make computers with both versions installed differentiate between v2 and v3 compatible code? It's quite common to see complaints about print statements being spat out as syntax errors.
I'm working on that currently. My thought is something similar to the way imgur does galleries. 
I like the way github does it's directory transitions myself...
Hmm that's a good point and there have been some new tools released lately to do that kind of stuff. I'll look into it. Thanks!
looks slick, excellent work so far my only feedback is a minor 'nitpicky' annoyance - personally, i don't like dealing with alert popups, so perhaps consider changing the way the user is informed that the chosen filter does not return any results
Would you mind if I put your code on my code review site? I just posted to this sub about it. https://codetique.com You can get feedback in line on your code.
I haven't kept up on the latest availability of the device. Are they going to be available soon?
Okay, belated upvote. Newbie friendly or not, I still wouldn't recommend PHP to folks new to programming, because at some point they're going to grow beyond PHP. And then they have a problem, because PHP is sorta inspired by many other programming languages, like C/C++, Perl, I guess maybe a bit Java... but then, in reality, it's nothing like those languages. And then, if they try to learn a language that isn't just a huge collection of spare parts, they will have to learn everything about programming again, and probably unlearn quite a few things PHP taught them. They might conclude other programming languages are hard or confusing and give up.
I completely agree in fact I have some notes in my JS about changing that. It's more place holder stuff until I can get some time to come up with a more elegant solution. 
Or use backticks, since `__file__` is actually a piece of code.
Theoretically, one could make universal functions to handle the differences. There's two main ways to do it: check the version or do try except. try except: def uinput(prompt='') 'Universal input function' try: return raw_input(prompt) except NameError: return input(prompt) But sometimes it's not so simple. You can't catch syntax errors. For example: from sys import version_info as _version_info _version = _version_info[:3] def uprint(*args, **kwargs): if _version &gt;= (2, 7): #some exec() or code.InteractiveInterpreter().runsource() voodoo else: #some other exec() or code.InteractiveInterpreter().runsource() voodoo
I won't mind. I just checked out that site earlier (and reviewed some things myself) and it seems an interesting way to do code review.
Agreed, but that doesn't really answer the OP. When you think that will be?
Good post. It really feels more and more to me like the GIL is what's holding Python back. Without the GIL Python would arguably be the best multi-purpose language out there. If the CPython implementation of Python 3 got rid of it, I would be switching and I would be excited about switching. As it is... yeah... I'll probably look into Python 3 sometime this year, but I'm not really in a hurry. 
That really helps, I think I get it. Basically it replaces for q in some_generator(p): yield q with yield from some_generator(p)
Meh, I learned javascript, then haskell, then php, and I've had a fine time picking up other languages after that horrific initiation into programming.
There's a [port available](https://github.com/vsajip/django/) which [passes](https://gist.github.com/1373553) all of the test suite and is the same code for 2.x and 3.x, and anyone can help by testing it ...
There's a [port available](https://github.com/vsajip/django/) which [passes](https://gist.github.com/1373553) all of the test suite and is the same code for 2.x and 3.x, and anyone can help by testing it ...
Same. I *want* to use Python 3 to help the transition. But until Django and Flask support comes around I'm stuck with 2.x :(
Ugh. Yet another GIL rant. I wonder when people will stop wanting python to be something it isn't. Python 3 is awesome. The developers of Python have been working towards solving some *real* problems with Python. Namely, distribution, and binary compatibility. 3.2 introduced a stable ABI. This isn't such a big deal in unix-like systems, as C compilers are pretty easy to setup in these environments. In windows, however, this is a godsend. Now, it's possible to distribute libraries built once. If you want performant threading so badly, go ahead and implement it. You won't be the first. Just keep in mind that, if single-threaded performance suffers, it won't be accepted by the developers. 
Also, you should definitely allow the ability to import a project from svn, hg, and git
By default, Ubuntu 12.10 is going to have Python 3 on release.
I have. It seems like a really nice tool. I'm going for a simpler approach and one that you don't have to host yourself. Also I could be mistaken but it seems to take more of the standard approach to code review where by only your team or the people you invite are the ones reviewing the code. I want to make Codetique more like a Stackoverflow except directly focused on code.
Ah, yes. Much better. 
What I don't quite get is why not just include both code paths, and toggle them off a command line switch to the interpreter, maybe even make it accessible via the sys module, so modules that are heavily multi-threaded could flip it.
Yeah but it won't come out for a year or so.
Actually, we're streaming 7 tracks :)
because i can do this: from string import ascii_letters text = "19212323453242" if not any([l in text for l in ascii_letters]): print "no letters here" else: print "letters here" i mean, that's beautifull
* I like that there's less boilerplate than other popular languages. * I like that it supports features like list comprehensions, generators, and first class functions. * I like that it has an expansive standard library that enables me to complete most any task. And when the STL isn't enough, there's an even more expansive list of third party libraries that will do the job. * I like that I don't have to write getters and setters (boilerplate) due to `property`. * I like the community that constantly seeks to improve the language in a generally sane way. * I like named arguments and default arguments and variatic arguments and variatic keyword arguments. * I like that documentation is a part of the python mindset and that many functions and classes have docstrings. * I like the introspection and reflection capabilities of the language that make testing so easy. * I like the tools associated with python (ipython, vim plugins, etc) * I hate lambdas. * I hate that `str.join` won't implicitly convert objects to strings. * I hate that mutable objects defined in a function signature cause problems leading to inelegant code and boilerplate. 
Well Ubuntu is moving to Python3 with 12.10, I think that will give it a big push! Also, 3.3 is being released very soon and adds some features to make porting from Python2 much easier for people who still have issues. Finally Django is probably the only really big project that doesn't have 3 support yet, but it will soon!
Sounds good, let's just tell all of science not to do any experiments that are computationally bound. Python is great for prototyping or for problems with small data sets but some things need speed.
Have you looked at Rietveld? http://code.google.com/p/rietveld/
It's quite possible to have one single codebase which runs with Python 2.x and Python 3.x. Ports of pip, virtualenv, Babel, Whoosh, WTForms, Django and a bunch of others were done using this approach. It's not especially technically hard to do.
It's the projects like paramiko that are the major problem for me. I don't know of any ports or replacements, and it's not something that someone other than an expert on the topic can take care of.
OS X 10.7. 
Disregarding all the great things about the language Python: Sage Math, R statistics with Python, ArcGIS with Python, etc. :)
Added permalinks. Thanks for the feedback!
I like the style of this article. It explains why he believes a certain way of handling things is undesirable / not pythonic without going into "Python &gt;&gt; Java for ever".
NumPy and SciPy are fast and probably what you would use. Also pypy and hopefully in the near future both together.
Could the color choices of that web page be a little harder to read?
The big issues that most people seem to forget about the GIL is that removing it will most likely break a lots, if not most of the C extensions out there. If you think it does not matter, start asking why pypy has not conquered the world yet even though it is several *times* faster than cpython on most benchmarks (i.e. if cpython had no GIL, and if cpython had magic autoscaling of everything on multi-thread, it would still not be faster than pypy on today's 4/6 cores CPU).
&gt; Yet another GIL rant. No, not really: it's yet another 'Python 3 buys me little and costs me a lot' rant. As he points out, a developer could spend time learning Python 3 and get a marginal payoff--or he could spend it learning a new language, which might have a huge payoff.
This is why I moved to Ruby when I am not using C. Django is a fossil while Ruby on Rails still has a powerful community that is willing to adapt. Soon Ruby will overtake Python in speed, and in academia, and it will be all over for this decaying language. 
If a less-broken Unicode model is not enough of a reason for you to switch, I'm not sure anyone will make you see... Also, (quote) "This is not an 'I hate the GIL post, that's been done." How exactly is it _not_ an 'I hate the GIL' post?
Please don't use python for that. Details here: http://lateral.netmanagers.com.ar/weblog/posts/python-is-not-a-configuration-file-format.html
How about replacing your `any(...)` with this: any(l.isalpha() for l in text) Even more beautiful in my opinion!
"better than XML" in some metrics. "much, much, much worse than XML" in others, and I say this as someone who really dislikes XML. XML can be parsed by any language. Python can be parsed by python. XML can be written by any language. Python can be written by programmers.
Elaborate. That sounds like a good idea
i guess what i'm missing is the values of the "whatever". In python 2, i used to use "r", "rb", and "wb" and was happy, now I fight with encodings. I don't want UTF-8, I want ascii because the engineering programs I want to interface with use ascii and unicode SHOULD be an error. Not everyone needs unicode. I see the unicode change is the biggest thing that has slowed down Python 3 adoption. It certainly isn't the new float behavior which seems like a big deal at first and then you realize that you were just afraid.
so...that's not always a bad thing
i'd prefer to call them batteries. seriously tho, why do they need to rename things?
&gt;R statistics with Python Wait, one of the merits of Python is a library emulating features from another language? ...and I said something unpopular. 
I don't understand the problem. If you want strict ASCII just use `"ascii"` and `"strict"`. If you don't care about errors, then set it to `"ignore"`. Much easier than just hoping it doesn't blow up for unknown reasons in Python 2. 
yeah the IDE is a turn off. if only they provide a command line executable that worked. 
I would prefer the code be readable and tested, rather than just compiled. Compilers don't catch as many bugs as you might think.
People who are bite by GIL, should atleast donate $20(how much ever you can) http://pypy.org/tmdonate.html and see how it works. Disclaimer: I haven't donated myself, I will be donating by this month end or next month beginning. 
Oh my.... You might want to work on a mobile site/app to interface with the site - I just tried opening it on my iPhone, it didn't work out too well. Nice site desktop based, though
In my experience, you would just write your performance-critical computation kernel as a C extension and the rest of your program in Python. If you are lucky, you can do this with Weave/Blitz, or you just use CPython. This happens all the time with Matlab/Mex, too. I mean, you rarely need you UI and plotting code to be fast. PyQt and matplotlib are fast enough for most setups. Basically, they do exactly that: They are implemented in C, but you use them in Python. UI code is usually just a giant jumble of conditionals, which Python handles just fine.
Python 3 hate posts always seem very similar to Ubuntu Unity hate posts to me. There are many distorted opinions yet nothing that would really prove the haters right. And while they keep hating, the world is moving on and are using the new standards, it's not a big deal. Python 3 replaces older versions of Python, just like new versions always replaced older ones and Ubuntu Unity is the default shell now, just like Gnome once was. People are fine with that and people are using them more and more. I won't even try to debate those haters anymore, let them stay behind while everyone else keeps progressing. Let the trolls be trolls and don't feed them by explaining to them why the GIL is there.
Since this turned into a GIL-haters thread, I'll chime in about something that never quite sat right with me. The "use multiprocessing" is about getting around two deficiencies. One of course is the GIL and threading. The other is that the CPython interpreter itself isn't thread-safe (not 100% sure it's the case in Python3, but it definitely was in P2). The implication is that if you ever embedded Python as a scripting language in your app, then you get one instance of the interpreter in-process. So, even the single process, isolated, no-memory-sharing, message-passing, concurrency paradigm is not possible. It seems like a natural path toward eventually eliminating the GIL by first making cpython thread-safe, though I understand that it's a minimal gain and has to be done carefully to not get performance degradation.
Well the problem with mobile is that you just can't see enough code for it to be really useful. Tablets seem to have a large enough screen to make it work but phones just aren't big enough. I may come up with some kind of mobile version but right now there is just too much work to be done on the regular version to do that. Thanks for checking it out though, and not giving up on it even though it looks awful on phones. 
Cython to the rescue. Comes with support for OpenMP which makes data-parallel programing a breeze. Many numpy operations release the GIL permitting multicore execution. Of course, there's other options for multicore number-crunching: MPI for example. If think there are enough tools for CPU-bound parallel programming than the GIL is no longer an obstacle and brings many benefits (easy C-extensions, easy multi-threading for IO-bound tasks).
Why does every programming language community seem to think that (their) one language should be used everywhere? Diversity is a good thing, people ...
That's simply not fast enough for most hpc use cases. Those tools are more for proof of concept for hpc users.
I don't know which article you are reading, but the one I read here is not evangelizing that Python be used *everywhere*. The article pointed out some features of Python and discussed why they would make good use in the scientific community.
While I agree with the fact that reading code on a phone is near impossible, it's still not a bad option for people (You can view the site in a landscape mode which would help some). However, for now you might want to put a temporary splashpage for mobile devices saying "Sorry! We can't support your device yet, but we're working on it!" or something of that sort. At least it prevents people from viewing the site on their mobile phones and writing it off as a mash of text. I haven't checked it on a tablet yet, but does it work well on a tablet?
i will try that! thanks!
It's all good, except there might be memory leaks issues associated with long-running python programs with C-extensions.
also, i want people to upgrade; it's the only way python can avoid becoming like perl where 5 versions down the line people are still using python 2.7. packages need to catch up, but the explanation of some of the more subtle differences with python 2 is undocumented. binary documentation is limited, the inspect module doesnt work the same, setuptools is gone, wx and vtk arent supported. btw, i run an open-source project and support python 3 because someone asked me to. it's very difficult to support python 2 and 3 cleanly in the same code base because many people aren't ready to upgrade and won't be for years.
I just started trying to learn python a few weeks ago. My previous experience in coding was a high-school AP computer science course were we learned Java. Our teacher was found of figuring out the programs we wrote with pseudo-code before we would start typing. Python's similarity to psuedo-code makes it a major draw.
"also, i think it doesn't work on all python code. " this is plain FUD. PyPy works just fine with all python code.
[homebrew](http://mxcl.github.com/homebrew/) has it.
not when the goal is to kill a very expensive program (MATLAB)
oops: https://code.google.com/p/urssus/source/browse/trunk/urssus/config.py
&gt; For me, I look down on the GIL because other programming languages don’t seem to struggle with this. In Java, you can make threads, and they behave the way you expect. Same for C++ and Perl. Not in Perl. Nor in any other popular "scripting" language (Ruby, PHP, Lua). I don't wonder why is that, I wonder why it's Python that attracts the vast majority of GIL bashing. Is it because it's at the same time newb-friendly and ambitious (with its use in scientific world etc), so clueless people like Ted see the opportunity to boost their ego by "discussing" advanced problems? 
Exactly my point, thanks for your feedback.
You present a false dichotomy. Type signatures can make code *more* readable because they give you more information at a glance about what is going on. Furthermore, type checking + testing gives you more security than testing alone because you can forget to write a test but the compiler will never let you forget to satisfy a type signature.
one command releases: $ python setup.py sdist upload 
This post sounds a lot like me in my early days when I had first discovered Python (coming from a primarily C/C++/Java/MATLAB background) and thought it was the coolest language *ever* and that *everything* should be written in Python, for the simple reason that I didn't know much about the many other exciting languages in the world. :-)
&gt; You're taking an extremest position [against import *] and it's ridiculous. Well, err, I don't think it is very extreme to set oneself some rules like "no import *" or "no hasattr" or "no testing of private methods". These rules are like following PEP8, they help writing safer, cleaner, "consistenter" code. These rules are enforced by precommit hooks on pylint with a proper configuration. As much of a Python lover I am, I actually think writing Python production code without such lint checks and barriers is a bit of a madness. Same with Javascript. And the nice thing with Python is, contrary to Java, you can tune the barriers to your liking and your needs, but it do not mean you can write production code within a team of 10 coders, this kind of code other will rely upon for years, without any barriers, and allow anyone to freely use metaclasses, introspection and other black magic when what is needed is explicit code passing around data. &gt; why did you even ask the question? Because I have an opinion (pro-text, as you noticed) and discussed it with teammates and was not convinced by their arguments. So, in order to see if I was missing something useful I could learn, I was fishing for other arguments in favor of (script as config). I actually heard some good points but I still think the text config is the best choice when nothing specific requires a "script as config".
&gt; your configuration is code I agree configuration can and often should be very close to the code, and for instance should be tracked and maintained the same way. However I think configuration and code are things of two very different nature. Code should be some pure logic engine that is fed with data and config, and react accordingly. Therefore we have these DRY rules, these factorisation, and best practices to handle code properly (like covering it with tests). Configuration is another nature. It do not need to be DRY: I don't mind copypasting an Apache config block and changing some lines in it to get another directory (up to a certain limit, obviously). Configuration should not describe how to do things, it should describe what to do. Ideally business rules should be configurable, and written in configuration files. When they are two complex, a mini language can do the work but this is another topic. For the implementation details of a "configuration discovery", I am not sure but if you have general configuration values and some mode-specific values (like dev vs prod) then maybe it can be done with three configuration files and no overwriting mechanism (which is a bit too "magic" for configuration).
While I may even agree with you, you just said that it does not run all python code. This is plain not true. It does not run all C code that's using CPython extension API which is a horrible implementation-specific abomination. It does not make it less of a python. It makes it definitely less usable and we're trying to address it, stop spreading FUD however.
Repo.js
Isn't the real 'PR' problem the fact that it is called Python3 instead of just plain python? From a non techie standpoint I'd say that wording would end up being the biggest barrier to upgrade acceptance. 
The argument, which I basically agree with, is that scientists are not going to spend a lot of time learning several programming languages. They learn one and then force it to do what they need. We really want that one language to be a general purpose swiss-army-knife language. Otherwise, eventually, you see something like a matlab web app, because people applied what they know.
Well, matplotlib 1.2 hasn't been released yet, so unless there's an Ubuntu time machine... The PPA system lets you use newer packages if you want them. I've got [a PPA](https://launchpad.net/~takluyver/+archive/matplotlib-daily) with the development version of matplotlib updated daily.
I'm currently using python in my data conversion because I need to be able to convert data from .xlsx to .mat (and also convert from files separated by location to files separated by date) matlab doesn't have support to import .xlsx files python with openpyxl and scipy can do exactly what I need in as few steps as possible. there is probably some program, or some bash script I could run to convert the .xlsx files to .csv or something more friendly, but the thing is - I already know python - I don't have to learn something new to handle this data.
Cython generates and then compiles pure C. And there a alot of HPC users using Python (with all kinds of C, Fortran or Cython extensions).
&gt; I'm an engineer and i don't care about GUI programming that much Let me give you another example how we non Americans can use proper Unicode support: This is how we used to code in German: woerter = [] for wort in woerter: pass This is what we can do now: wörter = [] for wort in wörter: pass So this is not about gui or web development at all.
 NameError: name 'OAuth' is not defined You forgot to import things.
I'm quite out of touch with modern Java practices: last time I wrote any substantial Java code was at the university. Any time I had to interact with Java code after that was not really pleasant. Care to point a few open-source projects that show how it *really* should be done?
Removing the GIL has nothing to do with the C API. In fact, that's probably the last thing that would be affected. All attempts, thus far, at a GIL-less interpreter have resulted in poor single-thread performance. To the python developers, this is unacceptable. 
CPython probably won't get rid of the GIL. I doubt everyone will switch to PyPy, but it wouldn't be a bad thing. CPython would remain the reference implementation, and that would be fine.
RPython embeds R, and makes it callable from Python. Is that the package you're talking about?
Disclosure: I'm the author of the article I've already said it to a few people in the comments (on the blog) -- my purpose was **not to attack Java**, but to go against Javaisms creeping into Python for no good reason. Java looks and works in some way, and that's fine, but the fact that Python's threading module **borrows the design** of Java's threading is silly -- we can do much better in Python (again, from a Python perspective). Java's threading was included in **JDK 1.0**, long before the introduction of anonymous classes. As for the choice of a DB engine -- that was obviously just an example to show how interfaces can't predict the exceptions that their implementors might raise/encounter, especially when two libraries (that know nothing of each other) are used together. And just to clear things out -- I'm way beyond "a passing acquaintance" with Java.
Why are all scientific articles in the IMRAD format (introduction, methods, results, and discussion)? Because having a common tool for everyone makes exchange and collaboration easier. And exchange and collaboration is really important in science. Ergo: not having diversity can sometimes be optimal to having diversity.
YAML! Lots of expressiveness, portable between languages, no ability to execute code in config (usually and advantage), easy to read. 
Google have two excellent libraries: Guava (http://code.google.com/p/guava-libraries/wiki/GuavaExplained) and Guice (http://code.google.com/p/google-guice/wiki/Motivation?tm=6). For database access I'm inclined towards MyBatis: (http://www.mybatis.org/core/getting-started.html). For any kind of XML templating I use Freemarker (http://freemarker.org/). For full text search, Elastic Search (http://www.elasticsearch.org/). For webapps, GWT (https://developers.google.com/web-toolkit/). LamdaJ does some tricks with proxies to give you an almost functional syntax (http://code.google.com/p/lambdaj/wiki/LambdaCollections).
Thanks! Creating packages was an afterthought, the main use case is to automate and test releases, to avoid brown bags. Also with these features you can merge a pull request from GitHub, bump the version and release to PyPI without needing a terminal. There's lots of automation that can be built on top of this.
Ah. My thought had been that moving to a GIL-less interpreter might require a change in memory-sharing model in order to maintain performance. (i.e., a share-by-message instead of share-by-memory approach.)
I will definitely be doing that. Thanks for the input.
The main purpose of the GIL is to optimize single-threaded performance. Fine-grained locking introduces huge performance penalties. It's far more performant to lock the whole interpreter. I don't mean to come off as abrasive. I'm just trying to quash the misinformation that the GIL was implemented out of spite or laziness. It's a very simple solution to a very complex problem, and it works. PyPy may solve the problem in a different way, with STM. However, CPython will likely remain the way it is in regard to threading. 
You need to learn a a couple of things about reading comprehension. First, have you ever heard of a literary device called [hyperbole](http://en.wikipedia.org/wiki/Hyperbole)—a statement used more for its effect but not to be taken literally? Second, never pick a sentence or a paragraph out of context. Yes, he did use the word *everything* but his lead sentence was why it is important for *science*. Moreover, the list he gave was a list of tasks usually needed to do to write an application for use in science. The rest of his article was very focus on why using Python *in the scientific community* is beneficial. Can you be honest to yourself and ask do you really feel that the author was advocating to every single person on the planet or was he mostly targeting toward the scientific community?
Wow, well said. The concept of "Javaism" has been creeping into my mind as a way to explain the loss of `import this`-Zen in so many Python packages.
It seems there's a misunderstanding. This is Python calling the actual R runtime, not Python implementing the R semantics.
I'm far too green to understand half of that article, but I did see a complaint against the logging module. Why? That thing rules!
indentation, quick development
[This page](http://weasyprint.org/features/) details what is supported. `@font-face` is not, at the moment. It is definetely something we would like to have, but we still need to figure out how to load fonts into Pango from Python.
Hey, that's a decent reason to do this. My current use of wkhtmltopdf suffers from the issue of not being able to specify where the page should break properly. When you support font-face, I'll be all over this. Thanks for the explanation.
It is called "python". We call it Python3 to distinguish between Python 3.x and the legacy versions, 2.x
Splitting the user base is very much like losing users. By not making 3 backwards compatible they've made users choose between gaining features or keeping what they've got working. 
You could argue that position. However, clinging to backwards compatibility between major versions is just silly. Major version revisions are an opportunity to fix major problems and shortcomings in the language that only years of use can find. I think that the way the python developers handled the 2-to-3 matter is just about the best way that it can be done. 
You may think it's silly, however I would say that a lack of backwards compatibility makes it two different languages. Sure, there could be some code sharing (Just as C and C++ can share some) but it's two languages now, each having a subset of the original user base.
actually, it is. python developers recommend you code in english because english is a common language. i've translated 2000 lines italian code, so while it can be done, it's not recommended practice. that said, i think that's a silly recommendation, but i doubt guido cared about that. some unicode support would have been in the code since python 0.1 if he cared.
no one said the code cant be recompiled, but running C code and Fortran code is required of EVERY language. To me, swigged code is python code and PyPy needs to eventually handle it, but i'll be more careful with how i word things.
ready for another 5 year upgrade cycle :P
yes, but sometimes just leaving the data as strings is really the fastest implementation method. i wrote a data converter and found that floating 10,000,000 values and int-ing another 10,000,000 values wasnt the most efficient use of computing resources. I switched it to string processing and speed it up by a factor of 100.
Follow-up : http://blog.ziade.org/2012/07/04/my-raspberry-pi-juke-box-follow-up/ I got all the peripherals \o/
Then you might be disappointed to find that I didn't say that I have a problem with Python being used to design things, but that it isn't adequate for safety-critical applications. 
I never said Python should be used everywhere, just for science. And even with that there are going to be plenty of exceptions where it's not useful, but I assumed people would figure that for themselves. Really the advantage of python is in standardization - so much of science depends on bits of code to get the final results that there's a serious risk to the reproducibility of experiments if people can't run each other's programs. And since python is free, no one is excluded from doing this because of needing expensive software packages. And again, obviously sometimes there's no choice but to use commercial software - there's caveats to everything but they're long and boring to go into and frankly you can probably think of them for yourself! P.S: I think if you witnessed "diversity" in a lab environment you'd be much less keen. I once had to deal with a monolithic Fortran program that took plain text inputs. The guy who wrote it required the input to be so arcane that someone else wrote a Perl script that processed a different input and created the correct one. He didn't modifiy the Fortran one because he didn't understand it, and in any case F95 sucks with text processing. Then someone else came along and tried to automate input generation and loading. Only other people's PERL is notoriously hard to read, so this guy ended up writing yet another program in Matlab, which talked to the Perl program, which talked to the Fortran one. Nobody single person understood the whole stack, debugging was non-existent, adding features impossible. If everyone had known python, none of this would have been necessary!
Or, sometimes well-meaning decisions cause massive headaches later BY creating compatibility-breaking changes. Why do I expect anything else? Because there is an implied contract of trust between the users of a language and the developers, and in this case the trust was violated for very little reason.
You can do a lot of big number crunching with python by using the right tools. Use numpy to crunch big arrays, use multiprocessing for parallelism, use Pypy to speed up algorithms, use python-openCL/clyther to offload computation the GPU, use Cython to compile speed-critical bits. Or even your number crunching algorithms in C or F95 but use python to glue it all together (they do this a lot at CERN). Or just get a fast PC and let it crunch overnight. As they say, the first rule of optimization is "Don't". For a lot of scientific work it doesn't really make much different if your program takes 1hr to run or 4 or 6 since you end up leaving it running overnight or while you do something else - you're not usually working under business deadlines so it doesn't really matter.
type-safeness is a function of the program, not the language. Python is actually fairly strongly typed, it just doesn't force you to declare types everywhere. You just expect things to work and in places where it's critical you do type checking. Basically you can write a program that works well in any language (how easy that is is a different matter), whether or not it's "dangerous" doesn't have anything to do with language syntax!
Self-consistency always trumps compatibility when language evolution choices are to be made. Once you avoid making changes for the sake of compatibility, you might as well stop developing the language. Again, these weren't changes that they sneaked into a minor release. These changes were held off until a new major version was to be released. In no project that I've ever worked with over a long period of time has preservation of compatibility been a priority when developing a new major version. Nobody is forcing you to upgrade. The 2.7.3 tarballs are still there. You could even fork the 2.x series if you feel that the 3.x series is heading in the wrong direction. 
[What?](http://2.bp.blogspot.com/-VCgZVRdwDUo/TbDSYmObUHI/AAAAAAAAADM/bOPhVB3Un6M/s1600/Lil_Jon_Dave_Chappelle_L_461c9a590d.jpg)
&gt; Let's assume you have just bought the memorable domain name idrinkink.org I actually own the `memorable.name` domain &gt;_&gt;
You actually don't even need fine-grained locking to make CPython thread safe, you just eliminate all global state from the interpreter. Every function throughout the source tree would be modified to accept a pointer to the one massive struct that contains all of the state of an interpreter instance. However that type of massive change would touch every library in the ecosystem and would, for a long time, make python fragile. Like I said, it's minimal gain and I can understand why nobody would want to do that.
That's actually the other reason I'm using python - I could have just written the python script to convert xlsx to csv, then used matlab for csv to .mat, but I only have matlab on one of my desktops, so if I want to do anything of use on netbook for instance, I have to remote into my desktop. I don't know if you've ever tried loading matlab with graphics over ssh, but it is so painfully slow
Can you elaborate on what you mean by a "brown bag"? And what sort of testing do you mean? One interesting possibility would be to integrate with a CI service like [ShiningPanda](https://www.shiningpanda.com/) or [Travis](http://travis-ci.org/), so that you couldn't release a changeset that didn't have a green light.
Have you come across [clear climate code](http://code.google.com/p/ccc-gistemp/)? NASA's GISTEMP climate model was assembled from FORTRAN, shell scripts and Python, connected by intermediate files. When climate change started getting controversial, some volunteers decided to rewrite it in Python, making it as clear as possible, so it was easier to check. The results [matched up very well](http://www.nature.com/nclimate/journal/v1/n1/fig_tab/nclimate1057_F1.html).
Then what's the solution? Just up and change it to `python` and ruin all programs in the world?
Ummm, wrong. Type-safeness is a function of the language. And Python is weakly typed.
Consistency for the users should nearly always trump any other consideration when choices are made for tools. That includes languages. Any other attitude results in alienated users. 
Have you seen the PrinceXML toolkit? Weasyprint appears to be a library that does things similar to princexml. Of course, with weasyprint, one can extend the library. 
i'm not talking about how versioning works, or anything technical for that matter. the original post was about marketing.
Comparing Python to C for safety-critical choices is akin to asking which tool is better suited for brain-surgery, a mallet or vice-grips. Either COULD do the job, sorta. Can't say I want to be the victim of the result. Then I'm glad that you don't make safety-critical software for a living. I do, and have for many years. The gold-standard for safety-critical languages is Ada, simply because it is type-safe and easily readable. No scripting language should even be a consideration, simply because it is subject to both the problems of the developed application as well as the current history of the use of the interpreter. But, even compiled Python still shouldn't be a contender, because it is subject to both type errors and integer overflows. 
Use Python, but make sure you use the Requests library and not urllib2 from the stdlib: http://docs.python-requests.org/en/latest/index.html For HTML parsing you might want to look at BeautifulSoup, but ideally you'll be getting back JSON, so just use 'json' from the stdlib. In fact requests has JSON built in, so your code is extremely easy: import requests data = requests.get("http://www.reddit.com/user/mr_pleco.json").json If you are new to Python, some top tips is to use virtualenv to make setting up isolated environments easily (and without system wide package installs), and use IPython so that you can try all this out in a very nice shell. 
Hey nice blog post. Have you given any thought to posting a basic working example though, something which is runnable as is? (assuming the tweeter key's are changed of course) Doing this would show how all the individual pieces fit together exactly as they need to and I think make the blog post a lot neater. This way if a novice wants to get a basic Twitter login/auth up and running, he or she wouldn't have to additionally figure out Blueprints or how to implement the `twitter_factory` Just a few thoughts :)
&gt; There are a few more things left to get nailed down, but the momentum is good. As a Python programmer for about a decade, I don't really see that that's the case. But then, I'm using the lull to learn Go, so I'm probably biased.
We use PrinceXML for thousands of documents/hour, but this looks to be a promising project, especially since its open source and a Python module! Like the others mentioned, font-face is a show stopper. I don't know enough of the PDF standards to figure out how to even try to start hacking that in. (A lot of our PDFs are tiny and print on very small labels, on the order of an inch or two on each side. We have to use specific fonts at tiny sizes that are designed for the particular type of printers we use (thermal)) Edit: I don't see it mentioned; does it do arbitrary XML/CSS? We didn't try to shovel our docs into HTML structure; it was just a lot easier to to emit things like &lt;patient&gt; &lt;name&gt;pytechd&lt;/name&gt; &lt;/patient&gt; than &lt;div id="patient"&gt; &lt;span class="name"&gt;pytechd&lt;/span&gt; &lt;/div&gt; with the tools we had at the time. Not a huge deal to rewrite in terms of HTML, but...
You have to think a little out of the box here, since it's not a normal "overflow" error. However, since maxsize is the largest size that containers can have, what happens when we add more than maxsize items to a container? OverFlowError. (Yeah, this is a bit of a weaselly answer, but it kind-of, sort-of applies.)
that's comparison is terrible considering the quantity of data. that's not a numerical precision issue. there's a huge offset.
thats the max size for an integer, not the max size for a long integer &gt;&gt; &gt;&gt;&gt; a = 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999999999999999999999999 99999999999999999999999999999999999999999999 i could keep going, but you get the point. there's no error
and of course statically typed programs don't have this problem... &gt;&gt; a = [1]*99999999 doesnt produce an OverFlowError, it produces a MemoryError, add another digit and you get an OverFlowError
Perhaps it would be more useful for the caching function to return a tuple or an object, and pass the status along with the value, so you can check if the item was found or not. Of course, this assumes that you wrote the caching function, which might not be the case. That's just my initial thought. Something along the lines of: status, obj = cache.get('my item') Also, instead of your functions returning None, you could write them to return an empty instance of whichever data type it's using. So {} for dict, [] for list, etc.
about your flair: `"ZGphbmdv".decode("base64")`
I'm not clear why you don't write a class and/or function which encapsulates all the involved steps. def query_db(arg): cached = existing_cache_system.get_cached_query(arg) if cached is not None: return cached # run query manually # cache query if appropriate # return result Any reason something like this wouldn't work?
Sentinel return values? What is this, C? We have exceptions... use them!
They give you more information. But, it describes the compiler type, not the human type. In addition, it only gives you information in the actual declaration. When the variable is actually used, in the context of that code you lose the type. You cannot determine the type from usage. x += 1 Is that a float or an int? Yes, its a silly trivial example and ideally the type should be easy to find out. But in the context of that line, the static type gives no extra value. You should be able to determine the human type from the name. Which you can do in both languages, however static types add line noise. More information is not necessarily better. Plus, its seems this is just degrading into a general static vs dynamic argument. Which has been debated many many times, its a trade off, both with pros and cons.
Exceptions are for exceptional conditions only IMO, depending on context, "NO_RESULT" may not be "exceptional" As pointed out later a cache miss is a much more valid "exceptional" behaviour than a no result (again I suppose that depends on context).
What if, for whatever reason, you want to be able to cache the value NO_RESULT? Then you have the same problem you had before. Exceptions are the only way to completely avoid this. If you try to read a value from a cache given its key, and that key does not exist in the cache, that sounds like an exceptional case to me-- the function reaches a state in which it can not possibly provide coherent output for its input.
I don't think this is accurate. Look at [iterators](http://docs.python.org/py3k/library/stdtypes.html#iterator-types). When you call \_\_next\_\_() on an iterator with no items remaining, it raises a StopIteration exception.
Excellent, high quality article. Author sounds like a very skilled debater :) Most outstanding issue really is confirmation bias. "This tool is the best" "But... you haven't tried any other tool?" Probably worth posting in /r/programming or /r/coding.
... which fits well with warbiscuit's suggestion of using a singleton as a sentinel value, except instead of having the do_query function return it the cache can return it. KEY_NOT_FOUND = object() thing = cache.get(name, KEY_NOT_FOUND) if thing == KEY_NOT_FOUND: thing = do_query(name) cache[name] = thing If do_query(name) returns None, then None gets stored in the cache. None != KEY_NOT_FOUND, so you don't get a false cache miss the next time around. 
Erm ... what was getting at is if you say to the database "give me back a list of all the guys named Steve", then if there isn't anyone called Steve, it should give you back an empty list, not an unexpected thing like None or False or 0. Of course, there are some situations, like looking up a user by a user_id which is a primary key, where you might want the function to return just a single user rather than a list of users with length 1. But it might be appropriate in those circumstances to throw an exception because you that magic primary key you got from *somewhere* turned out to be *wrong*. ... There, I said it, Django gets something right :-) 
Except the thing is, there is very little difference between Python 2 and 3 in terms of syntax. He talks about it like it's some major transition, when it isn't for most code. Just look at the hyperbole here: &gt; Sure, there are some neat bits and pieces that I would get in exchange, but a less broken Unicode model and some cleanups of syntax and the standard library are not nearly a big enough carrot to convince me to migrate existing, known-working code to what is **effectively a new programming language.** I'm honestly sick and tired of people sticking to outdated stuff. I can get enterprises doing that, but you'd think open source software would update more quickly.
and in case you missed, there's also live streaming: https://ep2012.europython.eu
Dude, you folks really work hard - I'm really surprised this videos are already up and available; thank you!
We use [cairo](http://www.cairographics.org/) and [Pango](http://www.pango.org/) to produce PDF, so we don’t really need to know how text and fonts embedding work in PDF (thanksfully.) Currently we just pass `font-family` to Pango and let it find the installed fonts and do its thing. The only blocking step for `@font-face` is to figure out how to load the font into Pango. Unfortunately much of the API is not available from Python through gobject-introspection. We should just go and ask on the Pango mailing-list already. (We *do* have some [PDF post-processing](https://github.com/Kozea/WeasyPrint/blob/master/weasyprint/pdf.py) to add hyperlinks and bookmarks, but this is much simpler than fonts.) WeasyPrint is HTML-only for now (because this is all we needed and nobody asked for more) but extending it for other XML dialects should be easy. It really is a CSS engine much more than HTML. For HTML we have an [user-agent stylesheet](https://github.com/Kozea/WeasyPrint/blob/master/weasyprint/css/html5_ua.css) and some code for elements that need special treatment like `&lt;img&gt;` or `&lt;style&gt;`, but not much. Please do open feature requests on our issue tracker! (Edit: typo)
I'm surprised no one has suggested this yet. Raising KeyError (or a new exception such as CacheError) seems like a good way to do it, but then you have to wrap all the function calls in try except statements, which (depending on the size of the codebase) could be a ballache.
Yes, WeasyPrint’s use cases are very much like those of PrinceXML. The difference is that we’re open source and 8 years late :) But we’re catching up feature-by-feature.
Yes, in the case of a collection returned, the empty collection seem to be the best choice when nothing has been found, but what to do if you ask for a unique value, and no value found is a normal case that you prefer to handle without exception catching, like with a *get_me_user_if_exists(id)* function? Then None seem to be the correct return value, but its meaning overlaps with other None result. Returning a *no_user* singleton would make it not so obvious to handle, especially in a "if not user:" context, or would you use **__non_zero__** black magic? Edit, sorry for the boldface, not very used to reddit markup and didn't find a &lt;tt&gt; equivalent.
while i've read on python.org that raising errors are Pythonic, I never understood why. i only raise errors when there's been a problem. in this case there's no problem; it's just a special case. can you explain why you would use error handling to deal with this case?
Man, with a title like that I just had to read it. Nice clear style too. Thanks.
IIRC in Lua you have a GIL, and when you are embedding Lua, you can provide your own macros for taking/releasing it (but it still should work like a GIL). And you can run several interpreters in the same process, sharing nothing, of course, similar to what Perl allows in a way of parallelism. It's not "slightly different", it's not having free threading, period.
Yes, I prefer to use the sentinel as an argument like this - that way it does not catch out users who did not expect it (and who might add KEY_NOT_FOUND to various results). Otherwise, if the cache function always return KEY_NOT_FOUND on cache miss, , you can try to make KEY_NOT_FOUND have some falseness: class _KeyNotFound: def __nonzero__(self): return False KEY_NOT_FOUND = _KeyNotFound() Then don't-cares can just do: v = cache.get(key) if v: print "Value", v And carers can check: if v is not KEY_NOT_FOUND: print "Cached value", v 
An advantage of exceptions is that you are forced to handle them immediately. If the function returns a sentinel and you don't check for it, there's a chance your code might carry on without the sentinel value causing an exception (or worse, a bug) until much later on, and you wouldn't notice it until it's too late. An exception, on the other hand, will just kill your program/thread at that point and you are almost certain to notice it during development/testing.
Alternatively, if the function is returning an arbitrary number of collections (including zero) with arbitrary results (including `None`), it could be implemented as a generator. This allows the code to use Pythonic constructs like for result in function(arguments): operate(result) else: no_results_found_handler() And most importantly, because generators hold state, it might be possible to handle cache/memoization implicitly (depending on whether OP's use case allows it), rather than having an explicit variable holding it.
More pythonic, have the cache raise an exception if nothing was found, no *None* needed. def query_db(arg): try: cached = existing_cache_system.get_cached_query(arg) return cached except: # run query manually # cache query if appropriate # return result 
To solve the split discussion problem, or to solve the configuration file problem? :-)
Why not use requests? I mean, it takes lots of lines of code to do that with urllib2 and friends, and more lines means more potential bugs. Of course it's easier to tell them to use requests than to introduce them to httplib, httplib2, urllib, urllib2, cgi and whatnot. requests should probably be in the stdlib though, but that will then only work for e.g. Python 3.4, one would still need to have a PyPI dependency for earlier versions, and that's fine, there's nothing wrong with having a dependency to requests just because you're consuming some JSON from an API: that's what requests is made for.
You never know, somebody could have overridden `__eq__` brokenly on whatever `thing` is. `is` is, there is no userland hook for it, it tests identity (which is what you want for a sentinel singleton) and states precisely that.
wrong use of for/else &gt;&gt;&gt; for a in [1]: ... print a ... else: ... print 2 1 2 
I think in this context raising an exception is the correct thing to do if (and only if) finding no user is a special case or an abnormal result. If it is expected and normal, for instance if this user id is coming from some user input, then returning something that has the meaning of "no user" seem better. In fact it comes to collapsing two functions, user_exists() and get_user(), into a single get_user() that tells you nicely that if the result is not a user, then, well, there is no user at this number. The code becomes as simple as it can be: u = get_user(123) if not u: return 'oh no!, no user' # do something with this user return 'you got it' Raising an exception in this context and having to catch specifically an exception seem to be hindering a bit the readability and simplicity.
Uhm, I'm not talking about noobies. I'm talking about production sites. If you literally just need to load up a simple bit of JSON in a POST request. It's like 10 lines of code with pretty indendation. Receiving JSON is even fewer.
It's always going to be a PITA changing the behaviour of the cache in any way (return values or exceptions); I just think raising an exception is the better way to do it. Plus, if you forget something, "unhandled KeyError on line x: cache.get(foo)" is going to be a hell of a lot easier to debug than "SomeRandomError on line some-unrelated-line: can't contatenate str with tuple"
My instinct here is to say the cache code is badly written: it doesn't seem pythonic to represent failure with a return code, if that's how you get your data out. Instead of returning None if the cache is empty, you should throw an exception. Over the lifetime of the program, if it needs caching, misses are going to be the exceptional event. That way, there's no value at all your cache can't handle.
Yeah; our users are on thousands of different workstations that we cannot control, thus the need for @font-face. For some things we could get by with standard/core fonts (Arial, etc)..
I personally think this syntax is so confusing that *any* use of for/else is the wrong use.
Pango *does* embed fonts. (And @font-face would not help if it did not.) The issue is to instruct Pango to load a non-installed font, from Python.
Yes, I do know it, I know lots of people who work there too. Just think of the time and money they would have saved if they'd used Django instead of PHP ;-) 
Isn't it essentially just a `finally` equivalent? After the for loop is done, the `else` gets run?
Of course, that's why a major version bump was done. This signifies incompatibility. Users have the choice of sticking with the 2.x series or upgrading. I don't see how this is a problem.
I think you're probably right - perhaps not in initial costs, but certainly in maintenance and improvement.
or _How to use package managers_. Pretty useless "article".
What sort of thing are you looking for? I liked the ones on Social Network Analysis, Clone Detection, HotPy, the PyPy JIT. On the less technical side, Permission and Forgiveness and Ask your BDFL were good.
This would probably be awesome as a Firefox or Thunderbird addon....just saying :)
Lua does not have threads. Lua will not, out of the box, use multiple cores. The lua interpreter state instances are not thread safe, but lua itself is ( you may run multiple interpreters in multiple threads ). Lua has coroutines, but these are very different. 
Hey jefftheboss thanks for sharing! I think that the way scrapper.py is currently implemented, it generates a list of all links... but then after writing to file just the first link in that list, it trashes the entire list by overwriting the links variable when it opens the next page. So I think you maybe want to first write to file all links found before moving on to the next page. Or maybe you could append to the list of links remaining to process. It might also make sense to keep a hash of pages already processed so that you don't process the same page twice. Hope that helps! :)
It's not even using the package managers correctly, because it's mixing distro-provided things with self-compiled things. You can replace all the junk in the article with: $ apt-get install python-mysqldb python-psycopg2 python-pymssql python-pysqlite2 And this way you also get automatic security updates and bugfixes. Of course there is an argument to be made for controlling versions of things by not using distro packages and embracing virtualenv, but this article completely fails to articulate that, and it reads like it was written by someone that wasn't aware that distro packages exist for all of these things. 
You're right, of course. I never build my my own binding if I use database installed from package. I would not use Django or django-somethingsomething from a package but I'll let my database stuff be handled by Debian developers.
Version "bumps" signify anything you want them to, but the bump doesn't explicitly mean anything. And it's not a problem as long as you don't mind dividing (And annoying!) your user base, making the future of your language fuzzy, and just generally admit to the world that you may not care about your users. No problem at all.
I think the idea of "I can't give you a meaningful return value" sums up exceptions perfectly.
this is reddit sorted http://pastebin.com/Zj4xXF4r
Then you could equally say "it makes programming more difficult than it should be." My problem is that your statement is too generic, in that it doesn't provide useful information to someone asking the question "what is negative about the GIL?". If that person is doing I/O bound work, or has a single processor, or work where the compute kernel is in C, with a released GIL, or probably several other cases, then GIL is not a problem. It's only for a few categories of programming style where the GIL is an issue.
And there are a tonne of projects out there that never need to use Python at all. What's your point?
Was my statement incorrect?
and it makes single threading significantly faster. The [multiprocessing](http://docs.python.org/dev/library/multiprocessing) module makes it easy to use multiple cores. If the difference in performance overhead between threads and processes is too much for your task why the heck are you using an interpreted language in the first place? There's a lot of talk about how broken our tools are (the GIL, the recent kerfluffle about PHP, how terrible C++ is, etc), but somehow people are still managing to write tons of useful software. The blogosphere would be a better place if people spent more time doing cool stuff (like the topic of this thread) and less time moaning about how hard everything is.
Chill. The. Fuck. Out. Did I say shit about multiprocessing or it being impossible? No. I answered a question. If you read up, you'll see that question. Why I use the tools I do isn't any of your business. You seem to forget that the tools we use is that they are all "useful software" that was written by somebody. If it weren't for "kerfluffle" about how bad they are, you wouldn't be writing Python, you'd be writing assembly. So show some fucking respect that are people like me who complain.
No, if anything, it makes multithreading much easier, just without much performance improvement.
ubernostrum suggested exceptions which was my first idea, but I have another one: return a tuple of two-items, one being the actual value and the second a boolean representing whether that value was cached or not. then `(None, False)` would mean "cache is empty" and `(None, True)` would mean "the value None is cached"
&gt; To an experienced programmer, empty() is extremely surprising. If you know — or at least have some idea — about how to implement a programming language, you'll understand terminology like lexer, parser, interpreter etc. So when you see empty(), you think “how on earth does that work”? Out of curiosity, you try empty($var || $var2), even though that makes no sense. You then deduce from the error message that the implementation of the language must have a gross layering violation. You think “this programming language must have been designed by complete amateurs — I don't want anything to do with it”. as an inexperienced (with compilers at least) programmer, I would love to hear the explanation behind that reaction.
It makes multi-threading for CPU-intensive tasks slow and useless and it makes extension writing a waking nightmare. It is why we sometimes say fuck it, this will be easier in C.
Did you add support for portaudio's callback API? I recently started using pyaudio and I'm relatively happy with running the audio IO in its own thread and filling the buffer myself.
That makes sense especially with the differentiation between SomethingException and SomethingError. I always had in my mind that the they were synonymous, but they don't need to be used that way. thanks!
Why not try [Further neck and and shoulder massage training](http://www.youtube.com/watch?v=itn8W9zI0Wk&amp;list=UU98CzaYuFNAA_gOINFB0e4Q&amp;index=1&amp;feature=plcp) ☺ 
thanks for the reply! it's still not entirely clear to me why/how you can infer the oddness from the syntax alone, to me it made "kind of" sense because both `empty` and `isset` work on the variable itself and not its contents, in fact the variable may not even exist at that point (`unset` falls within this category too). also `isset` checks for existance but `empty` checks for that and also a falsy value, they're not exactly the same. what is really odd is what PHP considers "falsy" but that's a different issue :)
haha, dammit I was about to post this too :) I find rather interesing how much focus that commuty has on language theory (among other theories). Haskell is/seems a great language but obviously you need a lot of background to *get it* maybe you can use it at some basic level but you'll definitely need that to take advantage of the advantages it provides.
Wow. Much appreciated!
Nice, could I use this for realtime audio visualisation? I was using the normal version via stereo mix before, but it starts lagging fairly quickly.
A quote from Alex Martelli about import star: "Most likely, your programs will be better if you *never* use this form". Emphasis is his. Python in a Nutshell, page 143.
Yes, it was. Overall, multithread programming in Python is not difficult. For example, with concurrent.futures it's 3 lines to kick off jobs to a thread pool (one to import, one to start the thread pool executor, and one to submit the jobs). The exception is the lack of scalability across multiple processors when running multiple CPU-bound Python threads and using something besides the IronPython and Jython implementations. 
Hi, I think this is fantastic. It fills in something a nice niche in between full blown code-review tools that are intended for a single organisation and more open things like this. One thing is that logging in with my github login doesn't seem to work, and I don't even get an error message, the login box just goes blank white. Oh actually I just tried my google account and got the same error.
But does this implementation have multithreading at all? I can't find it.
Sure, you can do that. The callback overhead is fairly manageable. On my old Core2Duo 2.5, I could go down to block sizes of down to 8 samples and still have smooth playback (that is ~5000 callbacks per second). For visualization, you could easily go for some 50-100 ms of delay, so 2048-4096 samples per block should work just fine.
hmm, actually it makes extension writing easier, because the extensions don't have to care about reentry-safety or any other hassles coming from multiple threads, as the GIL makes sure the extension is only called in one thread at the same time ... But yes, it makes multi-threading on multi-core a non-solution for performance problems. You have to use full processes to gain anything from multi-core.
One thing I don't like about this post is the emphasis on the openness of the code. How is it different from e.g. app written in C++ with open code available on the website? For sure too much about proprietary issues, not enough about another aspects which makes Python so cool. 
well python is easier to learn and understand other people's than C++ - after all one of it's explicit goals is to be readable. For sharing to be easy you also want everyone using the same tool as much as possible so that you don't have to learn a new thing for every project. Python is the best choice because it is so versatile and already is quite extensively used in science.
I would *guess* that if you are using numpy and, say, 1024 samples block size, an FFT should be possible. But that really depends on your specific setup. Just try it. If the audio starts to sound choppy, it's too much ;-)
I agree but it is not argument after stating that Python is better because people can see your code. If you put your code on the website people can see it regardless of whether this is Python, Perl, C++ or Java. Python easiness and readability is another feature so statement that " If people don’t have the costly software needed to run that code, then they are prevented from running that experiment in the exact way it was originally done." is also IMHO misleading since you don't need any costly software to see and run C++, Java, Perl or many other languages. Even C#, created by Microsoft in a response to the Java, can be edited and run without MS Visual Studio, even under Linux.
Ipython
I'll throw a silly question out there. Does this implementation of Python support tail call optimization the way Haskell apparently does?
I mean extensions to work around the problem by creating co-routines. Can't be done, at least not by me. 
What? why? def read(key, default=None): try: return self._cached_values[key] except KeyError: return default 
Have you tried [r/learnpython](http://www.reddit.com/r/learnpython)? 
http://learnpythonthehardway.org/book/
There are some pretty good books like [Learn Python the Hard Way](http://learnpythonthehardway.org) and [A Byte of Python](http://www.swaroopch.org/notes/Python). I am currently reading [Invent your own computer games with Python](http://inventwithpython.com/chapters/) Also, keep in mind that [Codecademy](http://www.codecademy.com) will soon start releasing Python courses for beginners. Their previous courses in other languages have been great. So it's something to keep an eye out for.
Yeah, that's much better. I don't use Python very often, and I forgot that dict[invalid_key] raises an exception.
Would love to see a video of this talk, if available.
http://www.youtube.com/watch?v=KOvgfbBFZxk
Nice, thanks!
Hey I also wrote a similar tool! But why do you need Django for that? So heavy :P (granted if you already have django, but w.e.) Designed for non-programmers to use. It turns markdown into a website! https://github.com/ultimatebuster/funnel (sorry for the shameless selfpromotion ^.^)
Why not just use solr?
Thanks. It may prove useful. http://eli.thegreenplace.net/2009/08/20/frames-and-protocols-for-the-serial-port-in-python/ 
Have we progressed so deeply into our dependence on social media that we don't refer to speakers by their real names anymore? :/
Social media has nothing to do with handles one way or the other. I used a handle on Fidonet back in 1993, and people who use Facebook today generally use real names. Depending on how you look at it, "Mark Twain" was Sam Clemens's "handle". The point is that in this particular case, redditors are more likely to know mitsuhiko by his handle.
well if I'm faced with some language construct that deals *with the variable* and not a value I already know it won't work with an expression. I agree that making it look like a normal function can be confusing but, and maybe because I don't know about compilers, I already know that those are like "metafunctions" that work at the language level not the evaluation level. thanks for the reply! ps: seeing a function in terms of the input/output types is true for statically typed languages, neither Python nor PHP are in that category so you might expect a certain "something" because it's how the function is supposed to work but there's no guarantee therefore it doesn't help much to think about types in this case.
it'd be cool if you could put the html docs up too. i haven't figured out the best way to do releases. i use setuptools for install and doxygen my files and pack it all in a zip. any other suggestions?
I have done a fair amount of data harvesting/ webscraping and I wouldn't use anything but python now. Scrapy would be my first choice it is threaded fast and handles exceptions for you. If you need to access a page that has uses JavaScript and AJAX that you can't manipulate just through simple HTTP requests I would recommend Selenium Webdriver with it you can get to any thing you could get at browsing with Fire Fox. Supposedly you can drive Selenium using Scrapy but I haven't tried this yet. I should probably add that Scrapy code is written in Python and is based on Twisted and the Python bindings for selenium were the easiest for me to get working.
Elegant code, great language, iPython, etc. :)
That is not correct. Most people who learned multithreaded programming did so on hardware without multiple cores. They did so because threads simplify certain types of programming, at least for some people. For example, to run the GUI in one thread and application logic in another, or work with locking I/O calls (e.g., spidering), or serve web pages (e.g., Django). The GIL only affects people using multiple cores. A more complete categorization of reasons that someone might use multiple threads is at http://oreilly.com/catalog/multithread/excerpt/ch01.html . It includes "Simplified design", "Increased robustness", and "Increased responsiveness." These three factors are not based on having multiple CPUs. Moreover, many of the people interested in high-performance computation in Python write their kernels in C/C++, release the GIL, and use Python to control how the different components work. For them the GIL is not a bottleneck; more a speed bump. Other people have small data exchange of simple data types, with high CPU work. For them the multiprocessing module is a perfectly acceptable solution. Yes, there are people for whom the GIL is a problem. In my experience, those are rare - or at the very least, not a majority of the people. I of course suffer from bias error; where is your evidence that a majority of the people who would want to do multithreaded programming in Python are in need of, and suffer from the lack of, multiprocessor scaling?
Just for autocomplete? Overkill.
Indeed. Actually, we are interested in both the best and the worst company. :P
&gt; I already know that those are like "metafunctions" that work at the language level not the evaluation level. And that's what makes experienced programmers cringe - the concept of a function-that-is-not-a-function is a trap for the unwary, another special case that you need to learn, and a sign that the rules are arbitrary. My point about function input and output wasn't really about types. In Python if you see the use of `abcd(xyz)` you know that it takes one value, and that the function you call will get a reference to whatever xyz was at the time of calling. It doesn't matter what that value is or how you generated it. Maybe the function will work, maybe it won't, but you know the syntax is correct. In PHP, if you see the use of `abcd($xyz)`, you don't have any guarantee that what you pass to abcd will even parse correctly, because you don't even know abcd is necessarily a function.
How's it better than vim? How's it better than emacs? Edit: it's a simple question. There are no features listed on the OP link. It's always the first question to ask about editors. Why should I use it when there are mature, robust, powerful, ubiquitous editors already out there for free?
There will always be personal preference. I don't say that it's better. It's just a side project that I wanted to share.
Borrow from Java doesn't mean it is bad e.g., `concurrent.futures`. You don't need to subclass Thread: t = Thread(target=func, args=(arg1, arg2)) t.daemon = True t.start() # ... t.join() `logging` makes simple things simple, complex -- possible. If you don't need the flexibility it provides just use the bits you need. You could read [Basic Tutorial](http://docs.python.org/howto/logging.html#logging-basic-tutorial), Advanced Tutorial, Logging Cookbook depending on your needs. You could start with: import logging logging.basicConfig(filename='example.log', level=logging.DEBUG) logging.debug('This message should go to the log file') logging.info('So should this') 
Okay, I just had a quick look at it on Ubuntu 12.04 and it definitely needs more features. So far it isn't even better than gedit. Although I saw some codecompletion stuff in the configuration, it doesn't seem to work. Once I tried to copy ST2's completion feature because it is really nice. Maybe you can use it: https://gist.github.com/2628336 (interesting part starts at line 73). Other features I'd like to see: * virtualenv integration * projects should be able to contain whole folders, not only files * python shell should run in the directory of the currently viewed document, so that I can import it directly * syntax highlighting themes (don't reinvent the wheel here, choose a theme format that other editor support, so I can use their themes) That's it for now.
I got bored and wrote a proxy for making AJAX requests to anywhere without the cross-origin policies getting in the way. Probably shouldn't be used for anything.
I understand why you have been downvoted. But I do understand you're point. I have yet to find a text editor which surpasses vim.
It seems mainly for touch screens can you make android apps with it
why is it called sanity - its just a lib for Design By Contract
You are completely right. The website is terrible and is just obsolete as well and that's the next thing I plan on really changing. I was yesterday finally finished with doing some backend stuff and I wanted to get it out and released just to make me happy :) I wasn't thinking about having something really representable apart of the actual project which is of course retarded -_-
Yes, your sample size is much smaller, and across a more recent time frame, than mine. It was you, though, that made the global statement about how GIL impeded multithreaded programming. Have you looked at concurrent.futures? Its multi-process executor makes process pools, like what you would use for some times of machine learning algorithms, much easier. You get, what, 4x better performance on a quad core box? If you _needed_ multithreading for performance then you would have been much happier with the &gt;10x speedup by implementing the core code in C. Or with pypy's speedup - it's good for this sort of thing and you probably could have gotten 5x better performance using it. The first time I used multi-threaded programming was to turn a callback-based API into a iterator. Create the callback object with a queue, spin the main function off on its own thread, and read from the queue to get the values. The GIL had no effect on that code, even though I was on a multi-processor machine, since I only had one execution thread. 
If your cache is usually not empty (or if you're not worried about speed), you could raise an exception when the cache is empty, leaving you free to return None where there are no results.
I only like celery with peanut butter.
I only like celery with peanut butter.
ok so the problem is that it *looks* like a function, not what it actually does. btw isn't this somewhat similar to Python's `del` statement? it also looks like a function but, just like PHP's `unset` it only works with vars.
Emacs! ;-) All joking aside, I understand the pleasure and learning from side projects, but I also think the effort put into these projects could be better utilized contributing to projects with wider impact. For example, improving the various python plugins for vim/emacs! Either way, keep hacking on what interests you. That's the most important thing. You might end up creating something better than anything else that is out there. 
Backticks are the &lt;tt&gt; equivalent: \`\_\_nonzero\_\_\` produces `__nonzero__`. 
Bookmarked for later viewing thank you!
I can't give you an absolute advice, just tell you my observations in one very specific industry (large automotive) in one specific region (Germany). So, things may look completely different in other industries and regions. A lot of guys here (at reddit) make there livings with Python, so listen to their advices, too! In this area it's all about standards and there's a lack of developers. The standards are mainly Java EE and .NET (Sharepoint is growing). From this point of view I would need to recommend Java. However personaly (a bit irrational) I would start with .NET and C#, as I think C# is much nicer than Java. Also, I think Windows 8 will create some opportunity, as a lot needs to be rebuild for Metro. Having that said and if time allows, I think the perfect way to broaden your skills would be: 1. Add your PyQt experience to your CV !!!!! Understanding Qt and GUI programming is quite an achievement! 2. Learn Django to understand how web-apps generally work and to consolidate your Python skills. It's just much easier to get a general understanding for the web with Django than to dive into Java or .NET. Then just create a little app. Publish it in any way and add it to your CV. 3. Learn C#/.NET or Java EE and redo your little app.
No! Be an expert mainframe developer. While the overall market is shrinking, the pool of experts is as well (think 10 years from now, when the first/second gen of mainframe developers are retired). Mainframes still run a fair bit of the world, particularly if you are IBM. That said, it doesn't hurt to have wide skills. Django and PHP skills if you want to do web work. Any two of Java, C++ and C# if you want to do application (desktop and mobile) work. Ignore C++ if you want to do only mobile.
Hey, I enjoyed your article about building the bookmarking service. Just saw you have posted a bunch of other articles. Keep up the good work!
Hadoop is the new version of mainframes, isn't it? Lots of people will be needed in that area soon enough. Big data, man.
I'm 25, and have been a Mainframes developer for the past 4 odd years. I guess I should also be heading down the Management role down the line, but i'm much more interested in programming. I'm travelling to US for an onsite project in Mainframes for a couple of years. For the past couple of months, there is an acute shortage of mainframe requirements in my company (and it's the Biggest in India), which was an eye opener for me. My pay is not so great when compared with the economy, and would get paid more if I switch companies, but seeing that there are not many companies that have a mainframe openings, and that mainframes itself is not progressing, I would like to equip myself with better tools for better survival. I wanted to try Java, but kept hearing so many bad things like 'it's bloated, ageing, clunky, has no future, et al. I also heard almost the same things about C++, so i'm really confused. I want to learn something that would be relevant in the future, and since I don't have professional experience with that language, would like to establish myself in some way so that I can cite that as a reference.
Thanks a lot for your advise. Could you point me for some ideas of such small/medium projects that I can do to add value? I mean, is there some site for such ideas? Or would it add value if I contribute to some opensource projects?
What benefits does one get through logging into your own service via a third party? I'm not bashing it, just curious to get people's views.
You eliminate the problem of needing a login and password for every site. You can allow users an easy way to validate and authenticate themselves without needing to register which. You also do not need to implement your own registration and authentication, because someone else has done it already. How many accounts and how many passwords do you have? Honestly I have no idea how many I have, but I am more likely to register if I can click an authorize button and not have to go through a nine step form just to use a service. To go on a rant slightly, some services lately are only offering facebook login and are losing a lot of potential users that way. Only allowing one service is a really bad idea. At least offer twitter, google, and facebook.
Go ask this question in the PHP group and you will get some very different answers. Take all of them with a grain of salt and remember in humans confirmation bias is very strong.
As a full featured IDE i would recommend [PyCharm](https://www.jetbrains.com/pycharm/). A good alterantive would be a good programming text editor like [Sublime Text 2](http://www.sublimetext.com/). I would choose Sublime Text over vim, because it's much easier to learn an contains a full python interperter to extend it's functionality - perfect for every python programmer. Personaly i use a combination of both.
I recommend PyScripter if you're on Windows.
If you want a embedded interpreter I recommend eric5(Written in python and requires pyqt) or PyScript.
But `del` doesn't look like a function. It's a statement and looks like one. Perhaps you've seen examples where people put erroneous parentheses around the variable?
Indeed. See for instance http://blog.dispatched.ch/2009/05/24/vim-as-python-ide/ (even if a bit old)
Rad2py? http://code.google.com/p/rad2py/wiki/ScreenShots
best advice i've seen: to start with vim, don't use any plugins. use it for a few days or a week, notice something you'd like to have available or that is taking a lot of time, then search for the plugin that handles it (because it will exist). if you turn on all these plugins, some of them can make it more difficult to learn.
I recommend you look at eclipse + pydev as well.
Or Emacs, which has a similar learning curve as Vim.
Agreed. The powers of VIM are turned off by default. Don't expect yourself to be fluent in it in a week or two. Here are some resources: * [OpenVIM](http://www.openvim.com/tutorial.html) * [VIM Tutorials by Derek Wyatt](http://www.derekwyatt.org/vim/vim-tutorial-videos/)
There's auto save and save before running a module. It crashes very rarely and even if it does, you can set it to save automatically.
This questions has merit though: &gt; What's the optimal way to edit-&gt;test-&gt;repeat? I feel there must be a better way than I'm doing it. Edit: For those of you asking, I use terminator (I'm on linux). I keep (at least) one window in terminator open in vim for editing code, and another for running the script I'm editing. So my cycle is essentially: Edit code in vim, save. Ctrl+Tab to the python window, &lt;UP&gt;&lt;Enter&gt; to rerun the script. Error occurs: Ctrl+Shift+Tab back to code window. Back to step one. This really doesn't incorporate vim into the full cycle as it is only used for editing the file itself.
http://blog.dispatched.ch/2009/05/24/vim-as-python-ide/ good start.
emacs is an elisp interpreter and you do whatever you want with it. not considering it for it's possibility to do many things is ridiculous and stupid.
[Wingware](http://wingware.com/) works fine. When you click "Debug" to launch your code, it launches in a separate interpreter process, which if it crashes, does not take down the IDE. I saw this happen a couple of times recently, when my PyQt code caused QtCore to crash. Wingware was still there ready to edit some more.
Am I the only one that's annoyed by these "use vim", "no no, use emacs, it better than vim" answers when ppl specifically ask for an IDE, not a god damn text editor with extensions ?! They have ridiculously steep learning curve and they look ugly. They were designed work GUI-less interfaces and that age has long passed. Any of PyCharm, Komodo or pydev/eclipse is better. 
Could you elaborate on ipython REPL?
I'm going through the same thing. All I did so far was a shitty prompt-driven calculator. I'm now trying out the Tkinter module for GUI programming, as it seems to be Python's out-of-the-box GUI library.
No, you're not alone. We see python IDE recommendation posts frequently and there are always lots of comments on vim and emacs. The thing is neither are IDE. These posts don't help OP. However, as an emacs user I disagree with you on emacs being ugly.
You could do worse for a Python development environment though. Emacs is fairly great for that. Integrated graphical debugging, linting, highlighting, code navigation, even refactoring.
All good advice, but I'd recommend tabs instead of plain buffers (:tabe instead of :e, then gt or gT to go between them). The reason for this is that it is easier to see which files you have open.
Could this possibly be sidebar-ed? This question seems to pop up every other day...
Well, I mostly use the REPL (https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop) of iPython, and not its notebook. When I need it, I open with ConqueTerm a split buffer in which I execute bpython or ipython, and to which I send visually selected python code or currently edited file, for interactive execution.
&gt; C++ because it's simpler than Java. What on Earth gives you that impression? I would say the complete opposite, by a large margin. *EDIT:* There is also a tremendous disparity in where these tools are deployed. There has to be, imo, a large preponderance towards Java opportunities in the marketplace - the strengths and constraints of C++ make it a much more specific choice. .. wait, do you mean C#?
 % vimtutor
+1 for Wing IDE and its great debugger. Check it out if PyCharm's powerful code analysis features ever seem to make it too slow. Wing does much of the same stuff but maintains a very responsive interface.
It's never about the core language only, there are always tons of frameworks and libraries involved. Unfortunately it's hard to know in advance which ones, until you get the job. That said, first read an introductory book, then read _Effective Java_. It's great and will get you thinking about the issues involved in programming Java, and if you understand it, puts you ahead of most of the competition as far as the core language is concerned. But keep on trying to find that Python job. They're not as ubiquitous, but it's more fun to do day to day :-)
&gt; ctrl-z to [background Vim,] run the file, fg to get back in Vim Even for experienced folks, I would recommend against bg/fg of Vim. Instead just have multiple terminals open and alt-tab between them, or use screen/tmux.
I just copy pasted this from mine, and I prefer 2. The most important thing is being consistent. If I share with someone who prefers 4 spaces, it's very simple to change the indentation. 
I'd like to bet that there are far more python plugins for vim than for sublime text 2, so simply asserting that with sublime you'll "be better off" is rather bare and wholly unsupported. I mean, by all means, argue for ST2, but at least come up with some points for it that vim can't share.
Pyscripter is decent.
They can be essentially turned into one if you put enough effort into it though. That just comes from them being so extensible. Eclipse starts off as just an application framework, it's just plugins you put into it that turn it into a vast, hulking behemoth of a java ide.
I have never used this, but the python standard library module [gettext](http://docs.python.org/library/gettext.html) is widely used. I grepped some sourcecode from several One Laptop per Child / Sugar projects, and the python line: from gettext import gettext as _ Is used often. And I have a few examples of django projects that use it as well.
mind = blown
I'm not the right person to ask - I choose languages for aesthetic reasons rather than professional ones, so I know only enough Java to get myself out of trouble :-). If faced with the same decision I'd go for C#, as the language is much more interesting. Probably /r/java will have some useful advice for you.
+1 for PySide. I'm two months into a job writing a plotting application in python, and PySide + MatPlotLib has made the whole thing so easy
I can't find anything in [pep8](http://www.python.org/dev/peps/pep-0008/) or the [google style guide](http://google-styleguide.googlecode.com/svn/trunk/pyguide.html) that says otherwise.
bpython in a conqueterm sounds like hell. what's wrong with vanilla python?
&lt;esc&gt;:w&lt;enter&gt;&lt;C-z&gt;py.test&lt;enter&gt;fg&lt;enter&gt; or, at least, that's how I do it.
As long as you understand what it does and even better, how it does it, you're in the clear. You'd be surprised at the amount of copying, pasting and gluing that goes into real-world development. Example: I need a SHA256 checksum function. I copy-paste it/use one from a library. Do I need to know what it does? Yes. Do I need to know exactly how it does it? No, not as long as it works correctly.
Your edit: At least you know how to use quite advanced regular expressions. I get stumped pretty quickly, but I can see how these would be a lifesaver in vim!
do those even work in conqueterm? it's not exactly the best terminal emulator ever.
The go-to answer to this question, IMHO. Writing a bot teaches all kinds of things. Networking, multi-threading, server/client architecture, etc. The best thing is, it's really easy to start, and you can just keep adding new features and stuff. Suddenly you're noticing that your bot stops responding when fetching from external network resources, and before you know it you're putting in multi-threading. You have to kinda be active in a botless IRC channel for it to really work though.
Thanks, glad you enjoyed.
but when a test fail, you then cannot use quickfix to get directly to the offender... why leave vim at all?
I take a pragmatic approach and have no real preferences. If it makes sense to have a large amount of lines in a file, I won't think twice about it. I've written .py files containing only one line, and I've got another project where a single .py file has 1588 lines. That last one has a single class in it that drives a commandline tool; one method per supported command. Made sense to put all that in a single file. So basically, I don't care about the nr of lines in a file. Good design is more important. That said, a large amount of lines in a single file *can* be an indication that some refactoring is in order. 
what is this quickfix you speak of?
Just did a ctrl+f after "PyFlakes" and saw nothing.. So yeah, pyflakes is easily the best plugin for vim. It will syntax check your source code on the fly and tell you when you syntax error, don't use local variables, imports unused variables, etc. [pyflakes on vim.org](http://www.vim.org/scripts/script.php?script_id=2441)
Text adventure game! Make it multiplayer if you can :D
After much searching and testing, i also settled on PyDev. It gets the job done, but it does have its quirks with imports and methods of various classes. Overall, it seems to be "confused" most of the time when it comes to code-completion. Im new to python so i like to have an IDE that knows what methods are available, so i dont have to go to documentation. I also like to step through via debugging. It is definitely no VS or Matlab, that is for sure. BTW, i am a scientific programmer, not a web one.
Works like a charm, thanks!
_ is usually used to discard variables, for example when you are unpacking a tuple or returning a result from function and you want just a part of it.
I highly recommend the [snippetsEmu](http://www.vim.org/scripts/script.php?script_id=1318) plugin, regardless of which programming language you're using. One thing that sets this above the other snippet plugins I've tried is that you can use snippets from within other snippets with this plugin.
&gt; Is not Django a server side technology? How can it be replaced by Javascript? The consequence of single page apps is basically that far less will be done on the server side. If the UI is done in Javascript and communication with the server is just REST-style data communication, Django is overkill. Its whole templating engine is superfluous and its URL processing can be done better by something that's focused on REST. Then you're left with a model layer, and then why not use SQLAlchemy? Of course there's lots of momentum and existing Django extensions, it can do a lot of different things, but for teams that aren't already Django teams making a new web app, Django isn't an obvious choice anymore.
One class per file?
That makes me question how much you know about Emacs. You know, Emacs is not really a text editor at all. It is a Lisp virtual machine, which happens to run a text editor as its default program. Thus, virtually *everything* within the Emacs text editing engine can be customized and changed using Elisp. To do the same thing in Python, you would have to implement the whole text editor in Python thus exposing all its functionality to extensions. Don't get me wrong. I think Sublime Text is friggin awesome and very much a modern day replacement for Emacs or Vim. But in terms of extensibility, it does not even come close to Emacs--And that is not even considering its lack of source code and documentation.
As a general rule, I aim for zero classes per file unless I can't help it. 
Why copy paste instead of just importing the module?
Cool, glad to hear Wing IDE might be useful to you. Sorry, I forgot I had a reddit inbox or I would have replied sooner. Don't hold back from contacting Wing's support/development team for help and suggestions; they are very responsive and constructive.
Why downvotes? I think while not a recommended behavior, there are situations which justice this. For example, when coding using PyQT, I like to have each window/dialog as a separate class in separate files.
This is actually what pisses me off the most about Java. Each and every public class must be in its own separate file. I usually scream (this isn't metaphorical either...I actually scream) "FUCK YOU I DO WHAT I WANT!" every time I write another public class in java and it bitches at me during compile...
I've never bothered. I think taking a few seconds each time to check the docs is cheaper than spending a lot of time with flash cards.
Force yourself to use it for everything, not just for programming, at least while you're learning it. Things will take longer at first, but within a few days you'll start to get the feel of it. And keep looking for better ways of doing things that seem clumsy, through books, blogs or videos. That takes time, too, but it will pay off.
A file should be as long as it needs to be. If a file is getting unwieldy, that's often a sign it isn't organized well and may need to be refactored into more atomic units. If you find you have a lot of files containing classes with a single method, that can be a sign you're overdoing it on the organization. But not always. Sometimes a class has one method because that's what makes sense. If you find your individual methods have a lot of code in them, that can be a sign your algorithms are obtuse and need to be clarified. But not always.
Scripting languages come with bad attitudes. 
My best friend in `~/.exrc`: :map &lt;Leader&gt;p :w \| :!echo Running %:p:. &amp;&amp; python3 %:p This will write changes to the file, echo "Executing &lt;file_name&gt;", and finally execute the Python script that is open. To those that are interested here are Java and C versions: :map &lt;Leader&gt;j :w \| :!javac -d %:p:h %:p &amp;&amp; echo Running %:p:.:r.class &amp;&amp; java -cp %:p:h %:t:r :map &lt;Leader&gt;c :w \| :!gcc %:p -o %:p:r &amp;&amp; echo Running %:p:.:r &amp;&amp; %:p:r With all of these, you can type out all of the arguments you want after pressing the mapped key. By the way, `&lt;Leader&gt;` defaults to `\`
I think your time would be better spent writing code and reading docs than memorizing apis.
Does anybody use vim on Windows?
No, `raw_input` makes it cristal clear that no `eval` is involved. Using `input` would be error-prone. If you forget to redefine `input()` on Python 2.x it might work as before e.g., `n = int(input("number:"))` but it hides the bug (an arbitrary code may be executed). Even Redhat is moved on to Python 2.6. It is harder (and therefore less useful) to do same-source development if Python &lt; `2.6` also should be supported. So `from __future__ import print_function` is ok.
 &lt;C-a&gt;1 py.test&lt;enter&gt;&lt;C-a&gt;0 ...for me. I'm sort of a Screen junky. These days, I'd probably suggest noobs start with tmux.
Ah. Thanks for the clarification. I guess I just mean the *feel* of using Sublime is more similar to the feel of using a relatively lightweight Emacs installation. I don't mean to say that Sublime is as extensible, nor am I aware of how Emacs really works.
I've just started learning vim, because I read this thread. The command to launch vimtutor in cygwin on Win7x64 (and I'm sure many others) is just `vimtutor` on it's own line. Finished it and had a great time. Luckily WingIDE lets you switch the keyboard to vi/Vim so you can combine them both. So far, the best tip I've read was right at the start, when it tells you how to memorize the four directional keys `h,j,k,l` and it tells you that `j` looks like a down arrow, I've been trying to associate all the keys with a similar mnemonic fashion. `w` for 'word' `b` for 'backword', `0`(zero) for index 0, `$` for a dollar sign at the end of a value ie `100$`, `u` for undo, `r` for 'replace'. I'm sure that as the commands get more complex it'll be harder, but it's a good start anyways.
I'm a senior web developer and I copy and paste code from tutorials, articles and documentation all the time.
&gt; I feel there must be a better way than I'm doing it. How are you doing it? Perhaps others will also share, here's my two cents: If a file you are editing starts with #! /usr/bin/env python or #! /opt/local/bin/python or something that like that (osx here though). bash ``which python`` to find out what that would be on your system, and if your are on windows then... this is probably the wrong answer for you. The next thing is that the file needs to be executable. ``chmod +x`` it. Then, in .vimrc, a mapping such as: nnoremap &lt;BUTTON&gt; :w&lt;BAR&gt;:!./%&lt;CR&gt; inoremap &lt;BUTTON&gt; &lt;ESC&gt;:w&lt;BAR&gt;:!./%&lt;CR&gt; Now, when you press &lt;BUTTON&gt; you cause the file to be saved and then executed. What you see is the output, but you have to then [press enter] again to return to vim. What I don't like about this method is that there are lots of things not to like. Instead, I go all out. I hardly ever use the preceding method. I make a button using whatever operating system provided method (mac or win) to launch a term window and run ( an environment variable pointing to ... ) Thats not enough though, this is mac, so we need some gratuitous Automator and AppleScript action: er.. service tell application "Terminal" repeat while (the count of windows) is greater than 0 close the last window end repeat do script "$SOMETHING" activate end tell It does the job of launching $SOMETHING in a terminal. Since I use iTerm2, terminal was just kind of sitting around unused, so I thought, hey instead of grepping for and killing process ids, why not just make it so I always run tests using terminal instead of iTerm2, then I can just set terminal's preferences to *DON'T BITCH AT ME * and nicely, whenever I press &lt;BUTTON&gt; in whatever program, sure enough Terminal launches and tells me all about my silly errors, but unlike initiating this action from within vim, I don't have to press enter to resume vimming. Next problem: *We're not in vim anymore, Toto!* Well, it turns out you can make another ( automator &gt;&gt; applescript &gt;&gt; system prefs &gt;&gt; keyboard shortcuts &gt;&gt; services ) button. This one is even more simpler: tell application "MacVim" activate end tell Those two buttons serve to take me through as much of a e&gt;t&gt;r cycle as I need. Maybe I need more but Nah. two automator services created, two miniature applescripts, hooked up to two buttons. Works for me! Not a lick of this relates to vim. I should have just said something about mapping :!./% and moved on...
For teaching yourself, I would say no. You understand how it works, you can change it to suit your needs, and the next time you need something like it you will either remember it and write it yourself, or just copy and paste from your old project until you learn it.
You can always start from https://github.com/amix/vimrc then through trial-and-error to figure out what suits you best 
Nothing really. It is a tool that serves a purpose. It's just that there are better tools to use when you're doing the edit/run loop.
Makes sense. I use bg/fg for compiled languages, where there is little interactivity. For python I typically use ipython with the %ed magic, or just two side by side windows.
&gt;As a general rule, I aim for zero classes per file unless I can't help it. That's my tendency too. I think the main abstraction unit of Python is the module. Each time I see a classmethod I feel uneasy: why not a module level function? But that would get us to another discussion...
It doesn't need to be in any of the two to be a good idea. That said I'm not particularly allergic to files that are longer. 
I don't want to learn more than one windowing control ... I'd much prefer if I could have it inside vim, but conqueterm isn't quite good enough to really feel like home.
It sounds like you use the wrong editor.. you can always make those helper thingies inner classes and move them out later if they are useful generally. When in Java, I do that instead of those horrible anonymous classes for listeners and callbacks.
I've tried WingIDE, Spyder, and PyDev. Pydev: nice, but a bit buggy. Hard to set it up to run Python from the program, use pylint, the debugger. Free, but pydev extensionis cost $$$ and are buggy as hell. Spyder: fewer features than Pydev, but easy to use. Lacking in a few features (e.g. support for Doxygen), but I use it for my side projects at home. I'm still new to it. Free. WingIDE: better than PyDev and Spyder, amazing debugger that is sooo intuitive. Most expensive, but definitely recommended. Very, very easy to use.
How do I set the cursor in vim to appear at the end of the letter that is currently selected, rather than the start? random string| #instead of : random strin|g where 'g' is the selected letter Or, even better, can I change the cursor to a block, rather than a vertical line?
 import random print('#' + str(random.random())) Copy, paste, `/join`, and go!
My advice to you is to set some time apart for learning vim. I think it's a bit of a steep learning curve, especially if you are used to a GUI editor. Maybe ease the transition a bit by using gVim (graphical vim). It's got all of the functionality of regular vim + GUI goodness.
Whatever you do, don't think about eating the shovel!
Depends on context, e.g. if you are a student it may be considered plagiarism under your school's policy.
I see you haven't actually used a vim or emacs. 
No one is going to ask this guy what he meant by "all lambda"? In Python? I think there might be much broader disconnects happening here.
it's not erroneous, parenthesis are optional but it's valid syntax to use them. you can argue that PHP's `empty`/`isset`/`unset` should also have optional parenthesis (like `echo`) but if that's really the problem I think it's not as much of a disaster as it seemed from the post. anyway, thanks for the replies!
As long as you have an understanding of what the code is supposed to do you're simply practicing code re-use.
Do you know [Editra](http://editra.org/)? Your project look a lot like it.
One thing to understand is that a lot of us are using vim because in school we had to use these shitty HPUX and Sun machines where your choices were vi, emacs and dtpad. Emacs was slow and dtpad was an unbelievable piece of shit, so you really just had the one choice. Now it's 2012 and we're running gvim on our macbooks because that's what we're used to. We'll try Sublime Text or PyDev or Eclipse, but it feels like they're just trying to make a better dtpad. We can't respect that shit. What I'm trying to say is that you're young. You have your life ahead of you. It's a new era. You will never see an HPUX. Might as well give the new shit a chance. Just because you see a bunch of old guys are smoking behind the office, doesn't mean you should take it up.
I'm not pro-harassment or pro-discrimination. But fuck off already. This is r/python, not r/politics.
Around 1000 lines I get slightly nervous, about 2000 lines I really start wondering whether refactoring is in order... Having said this, in many cases a single-module library is easier to use. Btw, http://www.faqs.org/docs/artu/ch04s01.html estimates 400-800 lines to be the optimal module size... (The study is pretty old. I would not be surprised if larger monitors and better tools shift the optimal size even further up) 
I've found that `"*p` and `"+p` circumvent the paste settings and paste without indentation. Both are the same on Windows, but + is the copy buffer on Linux, with \* being the selection buffer. Vim must be compiled with +gui for this to work. You can also copy to either with, e.g. `"*y` or similar. I use these to avoid the mouse altogether, even when I'm hopping into other editors and REPLs.
for what purpose? that just ups your file count which i find to be more difficult to manage than large files. i group my classes with other similar classes. when i hit 1500 lines or so, i generally split the biggest class or two off.
it's easier to make a class b/c then you dont have to manage variables or long lists of arguments. however, it's highly overused. it's also easy to fall into the pattern of never writing a standalone function.
The important thing is that you don't have to keep the ctypes manual open to use it. I think the real competition is cython which has a lot of mindshare including the numpy interface. But if the team is dedicated they may be able to beat it.
as long as the code isnt GPL/LGPL, you're fine. my recommendation is to just try to contribute back to the community when you can.
tldw
yup, even wrote a post about it http://codefoo.posterous.com/setting-up-vim-for-all-of-us
I have these lines in my .emacs so I can add breakpoints using C-c C-t: (defun annotate-pdb () (interactive) (highlight-lines-matching-regexp "^[ ]*import ipdb; ipdb.set_trace()")) (add-hook 'python-mode-hook 'annotate-pdb) (defun python-add-breakpoint () (interactive) (py-newline-and-indent) (insert "import ipdb; ipdb.set_trace()")) (define-key py-mode-map (kbd "C-c C-t") 'python-add-breakpoint) (Watch out for the tab character in the `highlight-lines-matching-regexp` call.) 
To bring some sense to the Pypi -- would be an amazing achievement. Look at the Go language dashboard. Oh, shit, they got rid of it. Well, there used to be a really nice table which showed you which packages were getting the most attention. But I guess they got rid of it. Idiots.
I am a new emacs user and wanted to make this same post after the vim post. edit: Took out earnest enthusiasm.
Also, one of the amazing things I've found is that there's a mnemonic to be had for almost everything. I'm 4 years in and still finding it to be very well thought out this way. Not *everything* works. Some are just helpful positionings, like &lt;c-o&gt; and &lt;c-i&gt; for jumps. They're right next to each other. Also, # and * don't mean anything, but are inverted versions of one another. If you touch-type, they're under your middle fingers, so they seem related that way. Also, ^ and $ take you to the beginning and end of a sentence, and touch-typing properly, they're your index fingers, so again it feels paired well. These also match up with regular expressions, where ^ means bind to the beginning of the input, and $ means bind to the end. It's not quite the same, and they aren't quite symmetrical, as ^ takes you to the first non-whitespace character, and $ takes you to the last character, even if it's at the end of a series of whitespace characters, but they were chosen because of how helpful they are. You usually want to jump to the first character in a file, and if there's trailing whitespace, it's good that $ shows it to you, because it really shouldn't be there usually. $ is more of an inverse of 0, though. There isn't (to my knowledge) a way to jump to the last non-whitespace character natively.
https://github.com/AeroNotix/dotfiles/blob/master/.emacs
These are both great tips, thanks!
I know how to do this... s/mind/blown/g BECAUSE THAT'S WHAT YOU JUST DID
For me it's 200 and 500 respectively. I really don't like scrolling through files.
Write one. It will be informative and you can have exactly the features you want.
I agree on this also. I'm mostly using ST2 now due to it's speed and great selection of plugins, but PyCharm might make sense for large Python-heavy projects, especially if you need a good debugger.
Looks interesting. Do report back if it's good.
I've heard of it never used it though. Both projects are nevertheless very different. The same system for the actual editor is used but I think almost every editor uses stc anyways.
He's fine if it is GPL/LGPL as well. He drops a copy of the GPL in his source directory. Nothing in his description says or implies he is doing this project as some kind of closed source black box.
Pathetic is to further group vim and emacs users into simple generalizations. And then top it off by perpetuating the hate and envy they supposedly all carry between them.
I can't help but to feel sad about this being called 'Distributed', let alone 'Distributed lock manager'.
What would be the right name ? s/Distributed/Global ?
Actually, without divulging too much: yes, I'm working on what is a personal project at this time, but which I have ambitions to expand into a commercial implementation in the future. 
I agree. Python code should be relatively easily skimmable and longer files mean I have to keep more in my head than I want to.
I will try out python-mode. Didn't come across it earlier.
I wouldn't know, yet IMO it's not because something uses some transport to work with some other entity, it's all of a sudden a 'distributed system'. In this case: - What if the 'server' process dies - What if a 'client' process dies prior to releasing a lock it acquired before Writing a DLM which matches the expectations coming with that term (thinking about the OCFS2 DLM or things like Zookeeper, Chubby and others) might not be *that* hard (a basic Paxos implementation should do), it sure does require some more work than what's in that recipe. Overall: a standard system consisting of a single server process and some clients doesn't match my expectations of a 'distributed system'. The latter requires the actual functionality (i.e. managing locks) to be distributed (i.e. spread across multiple processes, presumably on multiple hosts).
As always, I am around to answer questions as conference chair.
Thanks! I've had my eye on this app but never pulled the trigger.
The "Free" button appears to be a glitch, as I am still prompted for Credit Card info and cannot complete the download otherwise.
Came to say the same. What planet is this?
Because the developers are greedy and just in it for the money.
I wouldn't know, but if there isn't, either wait for one or make one yourself. Don't accept crap like this.
I also think the idea of paying for Python is stupid. So, I'd like to bring to everyone's attention that there are other ways to get Python on a jailbroken iPhone/iPod touch without supporting this product. [This](http://code.google.com/p/yangapp/downloads/list) page contains compiled Python binaries for a jailbroken iphone. To install, simply place the `.deb` file in `/var/root/Media/Cydia/AutoInstall` creating the nonexistent directories along the way, then reboot. 
Well, I don't get it either. Ask the customer to write your tests? Neva gona hepan. Forget it. Give up. Go get drunk. By the way Guido seems to know a lot about agile. He put the unit tests in the language. Also looks like he red some books in the past: http://www.artima.com/weblogs/viewpost.jsp?thread=32026 But it is all scam, so it is ok to ignore it now. 
Yes, shame on the developer for wanting to get paid for his work. How dare he!
Welcome to OSS development. Guy makes cool Python IDE for iOS, and he's a dick because he would like to get paid for his work.
So, how much does this normally cost? $3? And what's the cost for me to build my own free &amp; open source'd python app that'll work on a non-jailed-broken iphone? Sounds to me like paying ~$3 is a hell of a good deal.
I've been waiting for someone to do this. I hope the author is going to make a library available for other iOS developers to embed Python into their own apps. Besides that, this must have taken a lot of work to accomplish with Apple's sandboxing requirements. Good job!
Nice link! It's one of Python's key distinctions that a lot of Python programmers don't even know what those Design Patterns are. 
Yes, definitely spend $100 on the developer license for iOS and then spend a few weeks learning your way around it. By all means, don't give this guy $3. Oh sorry, I mean $0.
polymorphic models - its supported directly in sqlalchemy and there are various django packages for it
Thanks for the suggestion. I will see what Babel can do for me.
Thanks for the suggestion. I will see what gettext can do for me. Looks more straight forward and since I am writing programs and not web pages this may be what I need.
Yeah, the only exception is podcasts since they aren't iTunes "products".
This is pretty cool, I may do a pull later tonight and add the ability to append a few things to the command such as the full path if necessary or maybe even setting environment vars? I commonly have to pass commands like this: 'export NAS_DB=/nas; /nas/sbin/server_mount &lt;blech&gt;' It'd be nice to do this as ssh.server_mount(cmd_path='/nas/sbin', env={dict}, etc...) 
Anyone got a good virtualenv solution in vim? I tried virtualenv.vim but gvim has issues finding the necessary environment variables. I considered using a proper IDE because using vim feels like a massive kludge as much as I like the basic editing functionality (which you can get with most IDEs) - but I couldn't find one I liked, so I'm stripping down my vim config and trying to build something really nice up Edit: Fixed my issue by using a horrible hack to the plugin in ./ftplugin/python/virtualenv.vim change call s:Error('$WORKON_HOME is not set or is not a directory') return 0 to let $WORKON_HOME=$HOME."/.virtualenvs" return 1 (or wherever you keep your virtualenvs, but ensure no trailing /) 
I'm new to Python and don't know a lot about text editors like Vim and emacs. Can someone explain why one might want to use these over something like Notepad++ or an IDE?
You do know that open source doesn't mean free right?
Good. Yes and my questions have found answers by juju, thank you.
Thank you. Just what I needed.
open source != free
i paid for this app, worth it
what did you do ?
Is this a full Python implementation? If so, how is it not against iOS TOS? If not, what's the point?
You thought Apple had put a terminal (rxvt even) as standard in their consumer appliance? What reality do you live in? Does your computerized car come with an rxvt?
if you want to write apps in python, run them on iOS, android or desktop and be able to submit them to the apple store or google play, check out kivy: http://kivy.org 
Its a fun toy, but without any os.fork() I can only do so much. Still -- about as good as its going to get, and now FREE! Fun times: os.walk("/") looking for writeable files.
Requires iOS5 ... fuck! im still on my 3G 4.1, if I load anything higher it runs sooo slow.
Just added myself to this and I don't think it goes back through the month and finds all your commits, just the ones from when it initially starts tracking?
Try using the "VS Command line" from the start menu under the VS menu, i don't remember exactly what its called as i don't use windows. But starting that should activate the VS shell integration. IIRC this is how i fixed similar issues i have have.
For most of the history of computers, every program ran in a single thread/process. So something like the GIL is not a real problem in terms of functionality. It does make it a little trickier to make effective use of modern hardware, but most applications don't strictly need to be maxing out four cores. Similarly, people ran webservers back when we only had 4MB of memory in a typical machine and it was fine. Now we have 4GB or more, so an increased memory footprint is not necessarily a problem. Really, the question comes down to *your* needs. Python and C++ are both great languages but each has a different focus, and you need to ensure that the language you choose aligns with your various needs, whether they concern performance, concurrency, resource usage, development time, 3rd party library availability, ease of maintenance, code size, etc.
There are actually very few reasons not to use Python. One of Python's faults is that it is not good for mission-critical, time sensitive code; the flipside to that is that C code can be invoked in your Python scripts. If anything is slow, write it in C.
this.
I think the app in question, in addition to including a Python implementation, has some nice touch-friendly ways of editing code interactively, etc.
I may have misread the comment to which I originally replied. My interpretation was that you reading that, because ZooKeeper was centralized it was a single-process system. I came to this conclusion after you proposed that it may be possible to, in fact, build a P2P system in which all hosts agree on who holds a particular lock. ZooKeeper and Paxos are both ways to build such a P2P system. In the case of using memcached or redis, you are still relying upon a centralized server, but you don't get any fault tolerance guarantees (like you would with ZooKeeper or Paxos). In all three systems, you can emulate a "mutex" or a "semaphore" and the difference is not so much in the normal case, but in the failure case. In any case, most distributed "lock" systems really boil down to "lease" systems because the lock may be broken after a timeout. I borrow the term "lease" from Google's Chubby system (Burrows, OSDI 06). edit: reword
It's no longer free guys.
What protocol is used to replicate the actual data? I see that Multi-Paxos is used for leader election. [http://hyperdex.org](http://hyperdex.org) (Disclaimer: I'm one of the authors)
Congrats to my iOS brethren who now can get Python running on their device. I for one will continue developing apps for BlackBerry 10 and the PlayBook using Python 3.2 that comes installed on it. 
Yes it's a full implementation. Apple removed the restriction on interpreters a long time ago. They still don't allow *downloading* code.
&gt; closed-source python implementation
Just looks like a 'factory' to me.
&gt; Is there anything you've come across that directly defies that? If my team was full of C#, Visual Basic, or Haskell programmers, I wouldn't consider Python the first choice language, because I want to get the best out of my team. If I absolutely needed to run in the least memory possible, Python would be off the table because it's just not that efficient. If I knew that performance was completely paramount, I wouldn't choose any language that didn't let me micromanage memory allocation or create objects on the stack. If I needed cutting edge 3D graphics I would choose an appropriate game engine first and then use whatever language worked with it. If I needed to write an app that needed to be deployed to end users but not easily decompilable, I would avoid Python. If I needed to get the maximum performance out of multicore machines and couldn't afford to accept some latency in order to gain more throughput I wouldn't touch any language or runtime with a GIL. And so on. &gt; I could write in a JVM language like Java or Scala, but we're gun-shy here because of the whole Oracle v. Google debacle. Java itself isn't going anywhere. As for Google's implementation, why does that matter to you? Sounds like a hidden platform dependency that you've not told us about, which makes it harder to recommend a suitable choice. If I was REALLY lawyer shy, I would avoid any open-source language because if it happens to have accidentally infringed any patents, there is no central language owner who is both motivated and financially able to agree licensing terms with the IP owner to authorise all its users to continue using it. At least with a commercially backed language there is a chance of that happening should a lawsuit go against them. 
A better way to phrase it may have been "its good, but don't rely on any functionality that relies on forking", so modules like pty, subprocess and a few others that I use relatively often are a no-go.
Well, it needs to be multiplatform, so nothing hidden. Python can be run on the same platforms as jvm . There aren't any hard memory or threafing requirements. It's just a user space app.
So no urllib?
I think the idea of expecting other people to provide you with things for free is stupid. It's brilliant that they sometimes do, but that shouldn't lead to a sense of entitlement.
So by "free for today" you meant free for 9 hours?
So what's stopping the download and execution of Python scripts?
I think I have an idea but I'd love to see an answer to this as well.
Wow, it's open source, it should be free everyday. 
perhaps, but if it's free on every other platform and not on iOS that blows and makes Apple look really bad, 
Yeah, but generally paid software is proprietary, especially smartphone software
I'm not really interested on having random packages downloaded and installed on my machine without my prior say so and installation.
That's not a useful answer. What **exactly** have Apple done to Python to cripple it? Or is it not crippled?
This is likely because range(1, 100, 2) is not any more inconvenient than [1:100:2] or similar, and is actually clearer in many ways (especially to new users). I really don't see what this buys you beyond saving a few characters here and there (without improvements in clarity/obviousness).
Why must it always be right in the middle of my finals week? I demand a rescheduling!
This looks like a troll post - I mean, look at this guy's picture. Ridiculous.
That is fair, you're right
I agree w/ LinFTW, I think that would be rather dangerous for stability and security
just the speed to do a reload/restart is enough for me. nginx is instant, apache takes 2-3 seconds. Anyway, with Apache being slower and having a more complex and hard-to-get config i dont think its strange that people chose nginx. 
I suggested [something similar](http://erezsh.wordpress.com/2009/06/02/pysnippets-improving-code-reuse/) two years ago. It was met by a lot of criticism. Personally, I think it's a great idea, and all problems associated with it can be solved easily (as long as you trust pypi, and only download the package once).
Your example only shows how to misuse \_\_new\_\_, not that the naming convention has no real benefit. If I see something like this: &gt;&gt;&gt; f = Factorial(10) I usually expect f to be an object of type Factorial now. I'd be skeptical about the merit of such a type, but maybe it behaves like so &gt;&gt;&gt; f.value 3628800 &gt;&gt;&gt; f.n 10 &gt;&gt;&gt; f.n += 1 &gt;&gt;&gt; f.value 39916800 &gt;&gt;&gt; f.n 11 But no, you just returned an integer instead of a Factorial object. I'm confused, because convention taught me that I should have a Factorial object now. I have to look into your documentation to know why you decided to make a class for this, not a function. The other way around, if I see &gt;&gt;&gt; f = factorial(10) I'd be reasonably sure that f is now an integer. I'd be equally surprised if it was something like the Factorial object described above. Encoding type information in capitalization is helping the reader to discern information about the behaviour of an object. Of course, if you break that convention, you confuse your readers, causing more work and bugs down the line.
I would notice that `isinstance(HTTPClient(), HTTPClient)` is false, for one thing. That I can't subclass HTTPClient. That while I can see static methods on the returned object (if any), I can't call them on the factory function. Classes are not functions, that instance creation uses a function call syntax is a happy coincidence. What exactly do you mean when you say "why not judge objects based on their behavior, rather than type?" Do you see the two types of behaviour here?
I dont feel any need to prove anything, if you ever have restarted nginx and apache its obvious. Use whatever you want, i was happy with Apache for well over 15 years before i switched to nginx so i know its a competent webserver, still prefer nginx's speed and configuration, YMMV.
The guy added various features like an editor and whatnot, why would it be surprising he wants at least some compensation for 1. the work, and 2. the dev license.
It's an interesting concept that could perhaps be handy in some occasions, but normally you wouldn't want your code installing packages automatically. I prefer just using my pip requirements file over this, I want to decide when to install something.
You make a good point.
I've seen code that uses a StudlyCaps function as a factory as if it were a class. It doesn't bother me. But many Python folks have an unfortunate sense of entitlement when it comes to extensibility via inheritance. They feel entitled to subclass everything that "looks like a class" without any thought at all, and they are indignant when they cannot, even if the original author never intended the thing to be subclassed (maybe because the thing is meant to be used as part of a larger composite, or because the thing that looks like a class isn't actually any API at all).
It's not crippled. If you break the review guidelines, though, your app will either not be approved or be removed from distribution.
since I first saw it on paris perl mongers I asked what discipline it was, they said french artistic coding. see here : http://paris.mongueurs.net/aplusplus.html
Nice!
pretty sure you can afford 2.99
Beautiful.
Obfuscated code, one liners, code golf (not totally the same, but related).
It's for fun. Do you think calling out to the perl executable from python to add 1 to a number is a serious attempt at "pythonic" coding?
It's possible but not permitted.
I just found that r/badcode has [BBCC](http://code.reddit.com/wiki/help/faqs/badcode?version=5#WhatdoesBBCCmean): Brilliantly Bad Code Competitions. I think I just found my new favorite subreddit &lt;3
Duckface.
yes.
import humor
This is one area of Python I think it falls down. Using convention to aid in showing information is filled with holes. Whereas in a language like Go, an 'instance' of a type is create like so `inst := T{}` and you can easily see at a glance what you're doing. Whereas functions in Go are `val := func()` which is the regular syntax.
But with even more awesome?! How is this possible?!
too obvious :) += is clearly disqualified. I can't see how to use datetime, and time.sleep(1). It should fail on leap seconds though. 
Good idea! lambda i: i-(lambda t: int(t.time()-(t.sleep(1),t.time())[1]))(__import__('time'))
Wow, CPython, PyPy AND Django? How do you find the time to be a jerk?
Looks useful. Forked!
I'm partial to using itertools for such trivial methods lambda i:__import__('itertools').dropwhile(lambda m:m==i, __import__('itertools').count(i)).next()
principle of least astonishment. OP blew the fuck out of it. Excellent examples BTW.
bpython then ctrl+S http://docs.bpython-interpreter.org/ It works almost as ipython. You may experience quirks with scipy/matplotlib
Good point. I guess it's just style not substance then.
I call it intellectual masturbation
I only use bpython. C-s and C-r (rewind) are worth every penny.
&gt;In fact, it rarely did. Flask did, however, give me all the tools necessary to create whatever I wanted. I don't think this is true. I don't think what Flask actually gives you these tools, but rather it makes it feasible (or easy) to incorporate other tools (external libraries) to Flask. But then, I don't think it would be more difficult to add external tools to other micro frameworks such as Bottle. In other words, all of the Flask recipes or snippets -- which btw are quite useful -- can be adapted for Bottle, for example. The existence of the recipes, though, gives an impression that you can much more with Flask than with others. In a sense, the only thing Flask has to its advantage is that its author is a prolific writer (code, docs, and opinions). 
I call it having fun. I guess we have exclusive opinions. Python is a serious language, but some developers can't help to have fun. Such a pity ^_^ 
Works in most 4G languages too.
 # generating function lambda i: ((lambda rec, i, A, n: rec(rec, i, A, n))(lambda rec, i, A, n: A if i == 0 else i + abs(i - ((i &gt; -1) - (i &lt; 0)) * rec(rec, abs(i) - 1, A * n, n + 1) / abs(i)), i, 1, 2))
 class Number(int): def __init__(self, number): self.number = number def __repr__(self): return str(int(self.number)) def IncrementByOne(self): self.number += 1 number_five = Number(5) number_five.IncrementByOne() (It was painful and oddly cathartic to write this.)
I doubt I'd get my money's worth out of it though, besides, my iPad is jailbroken.
I find this to be a visually beautiful tool that will probably be very handy for me. Thank you for the link!
This works for me most of the time. lambda i: i+int(round(__import__('random').random()))
By the definition of the original author of the REST Architecture, there's no way that this qualifies as REST. Most importantly, it lacks hypertext as the engine of application state. Nice API tho. 
From your description, it's not entirely clear what problem you're having. Looking at your code as it's formatted, the most likely problem is you aren't properly indenting the `work` method of `me`.
What do people think of Graham Dumpleton's comment about using cProfile at regular intervals to get full detail without taking a serious performance hit? Sounds like the preferred solution to me, but I don't know jack.
thanks, I hadn't thought about"=="
This solution works great, thanks.
[Thatsthejoke.jpg](http://cdn1.sbnation.com/imported_assets/479178/thats_the_joke_medium.jpg)
Can it save to the clipboard rather than to a file? I'd find that much more useful. (Note I don't use either IPython nor bpython yet but that'd be the one feature to make me select one).
Basically the only time I ever really use 'is' is when comparing to None
Like False, True and None?
I really like their visualization. I'm pretty sure it is actually useful in practice.
Python noob here. How do I use this?
Yes, but how would you save that to a file? This is not about listing history %history does it really well, its about saving a big class/function definition that you just tested to work fine into a source code file. The current method seems to be to test/write the code in ipython shell, then if it works, copy-paste it to your source code file.
This is to do with IPython, not bpython. The article doesn't tell you how to save code to a file in bpython, but how to do so IF you are using IPython.
I'd just add that you don't need an else-clause in your if-statement: the else-clause isn't mandatory. The way you are currently doing it indicates to me that you are still planning to write the else-clause's content but you just haven't gotten around to it.
 lambda i: i+(abs(i)&gt;&gt;int(__import__('math').log(abs(i), 2))) if i else i**0 or: __import__('functools').partial(int.__add__, 1) or: __import__('functools').partial(__import__('operator').add, 1) or: lambda i: xrange(i, abs(i)&lt;&lt;1)[1]
As long as this is in r/Python and not PyPI, I'm okay with it. I do get turned off by the obnoxiously clever and self-referential aspect of Perl culture, though, which I see as a defence mechanism against a sometimes-absurd language.
Knowing that incrementing will yield a smallest integer larger than operand: lambda i: next(j for j in range(__import__('sys').maxint) if j &gt; i)
And you call yourself a programmer? You forgot to make a class for an Incrementer object, that has several child-classes like IncrementByOne, IncrementByTwo, ..., and only then you pass a Number instance to the IncrementByOne, which will return an int, because fuck consistency. 
There's more to *slice*-ing: l = ["a", "b", "c", "d", "e"] l[3:0:-1] == l[slice(3, 0, -1)] Gives "True"
Captain obvious explains ... more python tutorials at 11
About the conversion from HTML, are you talking about the various [scripts](http://www.fpdf.org/fr/script/index.php) from the FPDF website? These look pretty limited. &lt;shameless plug&gt;If you’re interested in PDF typesetting from HTML, have a look at [WeasyPrint](http://weasyprint.org/). It is a full CSS engine rather than just having a few HTML tags for specific tasks.&lt;/shameless plug&gt;
my brain just broke
I'd say using recursion at the age of 12 is fairly impressive.
Not when you don't really know it as recursion and fail to understand stop conditions... Also, using strings and atoi and itoa for simple operations. Ew.
I learned something today. I followed this from /r/shittyprogramming and wasn't expecting something like _this_ to show up.
a foolish consistency....
You seems to already have your reponse but for the futur, know that there is an /r/learnpython for question like this. This subreddit is reserved for news and articles
Not much use unless you already know which functions you need to pay attention to.
I tried the command you gave and it doesn't work. print _ih[1:4] #This lists all the lines between 1 and 4 I even tried !cat {print _ih[1:4]} /tmp/output.txt 
The code given in the article should work on Windows as well. you just need to change the output directory instead of '/tmp/t'
I have IPython configured to automatically log all of my interactive sessions, this allows for me to easily load up the .ipython/logs/yearmo/$(epochtime).py log files and copy to my hearts content. Being able to grep for anything also comes in pretty handy, even going back years. Somewhat silly I know, but I love it :) The top of the log file lists the directory &amp; command line parameters used to invoke IPython. 
Good news and bad news: pyPdf was unmaintained. Now it appears to have **two** forks. What I hope you'll find good news is that its [PyPDF2](http://www.reddit.com/r/Python/comments/qsvfm/pypdf2_updates_pypdf_pypdf2_is_an_opensource/) fork *is* actively maintained. For example, now we need to add the posted tutorial to our documentation list (for reasons not worth explaining now, it might be the weekend before we get to that). Other news: I'm committed to contacting Mr. Reingart to pursue a re-unification of our efforts.
I think there might be a little confusion here. [Mariano Reingart](http://reingart.blogspot.com/) is indeed a (co-)author of several things, including web2py, but *not* pyPdf, originally created by [Mathieu Fenniak](http://mathieu.fenniak.net/).
I wasn't aware of the html to pdf conversion when I wrote the article. Maybe I missed an example on their site. Can you link me to an example? I can update the article with the new info if you could. Thanks!
A oneliner would be nicer ^^ this code is too readable, therefore not entreprise grade.
this project needs to be packaged properly. it's a [bunch of files in one directory](http://code.google.com/p/pyfpdf/source/browse/) without even a setup.py. a project that's not even aware of this most basic convention is a non-starter until that's fixed.
yeah, do you have a one liner ? :) 
it saves to bpaste (F8) :) for sharing quick code (like when on #python) it is awesome.
You've got some pretty fundamental errors. If you're interested in learning the language, check out LPTHW (Learn Python the Hard Way) http://learnpythonthehardway.org/ Related to you specific code snippet, I'm guessing you want a four digit number between [0, 10000). So really what you probably want is a zero padded string representing a digit [0, 10000). E.g., pin = "%04d" % random.randint(0,9999) print(pin)
Post this in /r/learnpython.
More confusion than I realized! Mr. Reingart's pypdf is NOT related to the original pyPdf nor its PyPDF2 fork. I'm slogging through the misinformation (much of it spread by me), and will eventually publish something both authoritative *and* accurate.
One of PyPDF2's [ambitions](http://knowah.github.com/PyPDF2/) is proper packaging. It's greatly tempting to ask snarkily "what *is* the most basic convention" for packaging in Python today?", with the emphasis on that final word.
very nice.
The most basic convention for at least as long as I've been using Python, about nine years, has been the setup.py script built on distutils and optionally setuptools. This is not expected to change.
Fair enough. I agree that that's a good first target. Thank you for your level-headed response.
Yeah, that threw me when I wrote the article. Who doesn't include a setup.py file nowadays?
except in the sentence "PHP sucks."
Two forks? Where is this second fork located at? 
I meant relative timing. The resolution issue is why I suggested making the frequency of stack recording tunable, though I feel I should point out that any profiler that couldn't do relative timings is basically useless. Obviously, this profiler display relative timings of some sort using the size of the graph nodes.
Oh, I get it. But many novice programmers wouldn't. I've seen many programmers -- even skilled programmers -- see a clever trick and decide to adopt it. I'm just adding the disclaimer that this really isn't the best and explaining why. Although if you really want a laugh, check out the Daily WTF's wonderful [programming contest](http://thedailywtf.com/Articles/The-Worse-Than-Failure-Programming-Contest.aspx).
fortran do it faster :) 
this oneliner is ok? lambda n:int(__import__('re').findall("%d \+ 1 = (\d+)"%n,__import__('requests').get("http://google.com/search", params=dict(q="%d+1"%n)).text)[0]) 
I'd start with [Learn Python the Hard Way](http://learnpythonthehardway.org/) - it will help you get set up on the Mac and I believe that you will eventually write some simple web stuff. I think that it will be a great review/config session for you. Good luck!