It is an excellent python IDE imo (the professional version). I do wish the autocomplete was a little better (I really miss autocomplete for strings and variables in other open files like you can get in emacs) and the emacs key bindings were more complete.
Still no milliseconds =(
The big difference, in my head, is that there's no reason for such a construct as inner classes in Python. In Java, it's an important construct because being an inner class grants you access to private class members of your outer class. There's really nothing preventing you from doing this in Python, as nothing is really private. The only reason you do or don't do something is convention. Even when you declare something "private" with the underscores, all you're really doing is mangling the name (and not very well.) ex: class X: def __init__(self): self.__x = 3 y = X() print( y._X__x ) # prints "3" For this reason not many python programmers bother with private variables except to maybe prevent name clashes. If your "inner" class has special magical knowledge about its "outer" class that permits it to operate directly on the outer class's members, then so be it. Nothing is stopping you. As for knowing which object of the outer class your inner class "belongs" to, just construct the inner class with the outer class as an argument. There's no need for obscure class magic.
I just look on the side of the [Sauce Labs](http://saucelabs.com/) coffee mug I got from the PyCon swag bag. It has the strftime/strptime guide, string formatting mini-language, and struct module guides printed on the sides.
agree, especially for the auto complete. FYI, I like the [PEP8 Panel](http://bitbucket.org/stj/pep8panel/wiki/Home) and [PyFlakes Panel](http://wiki.wingware.com/PyFlakesPanel)
Thanks! I had no idea those existed.
That sounds handy as hell. Are those guides available on the web somewhere?
I love you.
Great idea and bookmarked. Doe this apply to other languages as well eg php?
It's basically the following sections from http://docs.python.org, just stripped down to chart format: [strftime](http://docs.python.org/py3k/library/time#time.strftime), [string formatting](http://docs.python.org/library/string.html#format-specification-mini-language), and [struct packing formats](http://docs.python.org/library/struct.html#format-characters).
No, notably it also doesn't apply to django which follows the native PHP letter syntax. It may apply to other languages but I can't speak for them.
Try `man strftime` (for those of you without a background in C, and therefore disinclined to look in manpages for programming information).
or buy PER 4th turn to pages 406-407 :)
Probably 50% of all pydoc lookups I do are for this table. Thnx.
For what you are doing, you don't need to create a class - you can just create a function to do the same stuff. Of course if you are going to expand on it, then the class makes sense. I'd also suggest to put your imports at the top of the file rather than right before you need them. Hope it was an enjoyable first script!
ActivePython Community Edition ONLY has MySQL(MySQL-python) support, why not support PostgreSQL(psycopg2) too?
Also check out http://strfti.me (a site that I built) which lets you test out different formats on the site. 
Congratulations! One suggestion: instead of relying on `temp.pdf` to not exist, let Python create a temporary file for you. import tempfile with tempfile.TemporaryFile() as temp_pdf: do stuff The file is opened as `r+b` (read and write), so you don't have to re-open it to read in the second half of your program. You probably have to seek back to the start (`temp_pdf.seek(0)`) in the second half of the program (where you re-opened "temp.pdf" before), depending on how PdfFileReader is implemented. The "with" construct will automatically close and remove the tempfile once you exit the block. If you don't like `with` for whatever reason, you can always do it the "old way": temp_pdf = tempfile.TemporaryFile() do stuff temp_pdf.close() You can about read [why it's useful](http://effbot.org/zone/python-with-statement.htm). If you have any questions/need some clarification, don't hesitate to ask. **Edit** One last thing: bookmark [Code Like a Pythonista](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html). It's a good quick reference for best practices when coding Python.
pymssql is crap
Try PyDev. My experience with it has been very positive.
Ah, that's brilliant! Wish I had known about it first.
Man, this seems cooler than my first Python script of "hello world" ...
Cool :). [I cloned your repo and did some refactoring.](http://bitbucket.org/kanakkshetri/bookfold). I've sent you a pull request.
+1 The import statements really should be at the top - it's a convention with good reason - if they're all consolidated there, you can quickly see what the file/module depends on and where referenced functions are coming from when you're reading the code below. There are rare times where I've seen import statements in conditional blocks to help account for different operating systems or Python versions and while those made some sense, they were still/should still be at the top of the module file. Beyond that and the tempfile suggestion below, good work and welcome to the Python world!
[Here you go](http://pastebin.com/gCz8eAgT) This script processes [your video](http://www.youtube.com/watch?v=0dg4RKCrfSo) in about two minutes on my system (an ~80x speedup). It uses a minimal amount of memory. It creates [temp files](http://docs.python.org/library/tempfile.html) for each output frame then writes the raw image data to them as it loops through the source files. Then it creates images from the raw data in the temp files, rotates / flips them and then finally writes out the output png files.
Also circular dependencies.
Read this: http://www.cafepy.com/article/python_types_and_objects/python_types_and_objects.html This might not make sense at first but keep revisiting it as you gain more and more experience. 
&gt; 4 spaces per indentation level. I can never conform to this for my own code.
It's usefull. I like the debug probe. Also, you can keep writing your code while paused by the debugger, which gives you advanced code completion. These features can be extremly helpful. Latetly, I'm enjoying the mercurial, testing and pylint integration a lot. Then, fast startup time, overall performance is good (but I have a fast machine) and very good documentation (!). On the downside, I'm *really* missing refactoring support with nice previews to doublecheck as in Python refactoring is often not unambiguously, on rare occasions simple code completion failed (but was fixed quickly). Also, I would like to see auto-completion on signatures ("jumping" with tab around in the arguments). Overall, you certainly don't go wrong with Wing. To me it hits the right spot and with proper refactoring support Wing would be the clear no. 1 Python IDE. P.S.: There's a new kid around: PyCharm, which has nice refactoring but missing the debug probe.
There are few, if any, reported problems specific to IDLE from Python 3 on OS X. Please file a bug report at http://bugs.python.org/ with as much as info as you can about the failure and how to reproduce. Also include what level of OS X, which version of Python 3, from where it was installed (python.org, MacPorts, built from source, etc), and whether you have another version of Tk installed in /Library/Frameworks. Thanks.
Thanks a bunch. Will look into it soon. If it could get any form of open source license, that would be great, otherwise I can probably deal with it too.
`psbook` from [psutils](http://webcache.googleusercontent.com/search?q=cache:HYjNkMlTYrAJ:www.tardis.ed.ac.uk/~ajcd/psutils/+http://www.tardis.ed.ac.uk/~ajcd/psutils/&amp;cd=1&amp;hl=pl&amp;ct=clnk&amp;gl=pl) did that already for postscript files. There are other tools like `psselect` (to choose pages), `psresize` and so on. Postscript goes slowly away as a document format, and these tools also are a little bit dated (I had problems with some documents and incompatibilities with handling postscript), so I'm glad you started your tool. I'll be most grateful if you could reimplement `psutils` for PDF. Nice work!
Savagery. I've never understood why it isn't a more common practice to generate CLIs using reflection. As far as I'm aware, Python should be perfectly capable of this, and I'd be very surprised if such libraries don't already exist. I wrote such a beast for my C# "scripts" many years ago, and the productivity benefits are amazing. 
Wow, significant increase in speed even on my crappy hardware. I will have to study the code a bit to figure out why. Edit: Instead of decompressing each source image len(source_filelist) ** 2, it's only len(source_filelist) + compressing the output images. Thanks! The only problem I see right now is that the code is cropping the output to 640, the output resolution should be (num_frames, source_y). I'll work on that some this afternoon.
Yes, I knew about `psutils` before starting work on this, but I didn't like them either, for the same reasons you mentioned.
Wow, a lot of work :) Thanks, I pulled the changes. I don't quite like the python coding standards (I prefer CamelCase and tabs for indentation), but I guess I'll have to get used to them.
Thanks, I didn't know about `with`. Very useful. I'll also read PEP8 and Code Like a Pythonista.
argparse also supports [sub-commands](http://docs.python.org/dev/py3k/library/argparse#sub-commands).
I like [web.py](http://webpy.org/), but why not go the Django route - even if the apps are quite small?
I've really liked working with [Flask](http://flask.pocoo.org/) it's a great framework and the maintainer is pretty active. There is also [Bottle](http://bottle.paws.de/) and [CherryPy](http://www.cherrypy.org/). All of these have solid support and should get done what you need to get done.
I looked at it initially, it just seems pretty heavy-duty for such lightweight apps. I might give it another look though. Haven't checked out web.py either, but will check it out. Thanks!
Flask is where I began looking. It does seem quite active and might do the trick. I'll have a look at the other two you suggested as well. Thanks!
I think having a full-blown framework might really help you, even though your app doesn't do much. If you don't want to use Django, look at the lighter Turbogears 2 (based on Pylons) or simply Pylons itself.
[Juno](http://github.com/breily/juno) had promise but it appears to have been abandoned. 
It seems to me that Pylons is the de facto "lightweight" Python Web framework. I don't have any hard data to back that up, though. Regardless, it's hard to say what will "fit your brain" and your environment. I'd give at least Django and Pylons a try and see how it goes. Possibly of interest, and in case you didn't know: Reddit is implemented in Pylons.
Definitely Flask. It's where it's at. You can Flask and build it up into your own Framework as your app grows. It is really just a thin layer on top of Werkzeug.
Getting the text from hard disk works at 60-120MB/s, loading it into the graphics card probably works at 300MB/s. So, having a fast gpu word count doesn't really give you any improvements over the CPU variant when you consider practical issues. What happens to the result if you include the gpuarray.to_gpu call into the timing? What if you just mmap the data and the kernel has to fetch it from hard disk? Most of the *interesting* problems (as in: where I'd hope to see an improvement over the CPU version) are those where you have either a CPU or an L1 bottleneck. How about sparse-to-dense vector multiplication? Bit matrix multiplication (i.e., something you can use for CKY parsing)? Viterbi search? I'm usually quite impressed at the performance on dense numeric data, but to make me buy one it'd have to be considerably faster on sparse vectors/matrices.
[Feature request to get this information into the time.strftime docstring](http://bugs.python.org/issue9650)
I've played with most of the microframeworks out there, and cherrypy makes me the happiest. So there's my vote.
As someone who uses Pylons professionally, I can back this up. I even spent the time to investigate Paste (which Pylons is built off of) and build my own framework simply to learn how to do it. I ended up with a poor man's Pylons clone. Pylons is definitely a nice, lightweight framework.
I used to work with web.py, now I'm a Flask fan.
I've tried to improve my fork over time, but yeah, the mainline does seem to be dead.
I've been using plain WSGI until I realized it was more work than I was willing to do, then moved to WebOb, and I've now learnt that it is munging URLs with weird characters in them to the point that my code doesn't know what they're referring to. To me this means that any framework that depends on `urllib.urlparse` and `urllib.quote`/`quote_plus` is not viable. Back to WSGI I guess... [When I have a URL like this: `http://example.com/foo%2Fbar`, a framework can't just normalize the `%2F` to a `/`, it just can't. It results in a URL with a totally different meaning. That means, in the case of WebOb, that I can't do any redirects to URLs that have difficult characters in them. It pisses me off, just a little. I've been investigating Pylons, but I'm not too sure about it yet. It seems kind of big, although very customizable.]
Not sure about the problem you're having, but Pylons uses WebOb. Pylons is actually *very* small on the whole. Mostly, Pylons is just a bunch of setup scripts and templates that create a working WSGI app on top of the Paste http server. It pulls in components from lots of other libraries (WebOb, Beaker, SQLAlchemy, Mako, Routes) but does very little itself. Hence the customizability.
I also earn for living doing webdev with pylons. Its an awesome tool that provides you with exact right mix of flexibility and speed.
I'm having this problem. Say I raise an exception from a method that's dispatching a request to the right controller when it notices that there's a slash missing at the end of the URI. `raise HTTPFound(add_slash=True)` If the URL was like this: `http://example.com/foo%2Fbar` I want it to become this: `http://example.com/foo%2Fbar/` Instead I get: `http://example.com/foo/bar/` Which is a totally different resource. This happens at the moment I set the `Location` header of a response message. `urllib` code is, AFAICT, not following the spec, i.e., it's normalizing characters that it shouldn't be touching. So to learn that Pylons uses WebOb, which uses `urllib`, doesn't give me that much confidence. 
FWIW, the main web.py developer is here on reddit. I haven't worked with it myself, but my understanding is that it is supposed to be lightweight. 
Different people define lightweight in different ways. For me the only framework that is really lightweight (in the sense that it comprises of a single file) is Bottle. There is a value in that, but you will have to reinvent the wheel for a number of tasks. All the other supposedly lightweight frameworks tend to be glued frameworks (the glue is small, but the glued stuff isn't). I like full stack frameworks because soon or later you realize that a web framework should be more than the sum of its modules. Soon or later you wish those modules were designed to work together and be aware of each other, as opposed to be just glued together. The best glued frameworks for Python are web2py and Django. web2py is smaller than Django and easier to learn. Django has been around longer and has more users. You may want to check some web2py examples [here](http://www.web2py.com/book/default/chapter/03). EDIT: web2py is not related to web.py.
&gt; Getting the text from hard disk works at 60-120MB/s, loading it into the graphics card probably works at 300MB/s. If you're doing mapreduce, you probably shouldn't use a single disk drive as your source. You should use an array. BTW, PCIe read throughput is typically in the several-GiB/s range. With modern cards, you can also do uploads while your kernel is executing.
Herr Klöckner also has PyOpenCL. I'd recommend it over PyCUDA for portability's sake.
For App Engine, [tipfy](http://www.tipfy.org/)! Perfect for small apps because you don't to need to maintain the server. disclaimer: I'm the author of tipfy! :)
I just did a little experiment with WebOb's HTTPFound and the result I get with your example URL is this: ['302 Found\n\nThe resource was found at http://example.com/foo%252Fbar/; you should be redirected automatically. '] This looks to me like the correct URL encoding, so it seems like the issue isn't with `HTTPFound` or `urlparse`. Can you post the code the exhibits the error you're seeing? Here's the code I ran: from webob.exc import HTTPFound exc_302 = HTTPFound(add_slash=True) environ = {'wsgi.url_scheme': 'http', 'SERVER_NAME': 'example.com', 'SERVER_PORT': None, 'REQUEST_METHOD': 'GET', 'PATH_INFO': '/foo%2Fbar'} fake_start_response = lambda *args, **kwargs: None exc_302(environ, fake_start_response) 
Brilliant!
I love me as well.
Seconding CherryPy. It's solid.
I agree with all that. The main thing that makes web2py a little easier to learn than Django -- and a little quicker to use -- is that it gives you a default url-mapping. As long as your views correspond to the urls, they are found automatically, as in Rails. On the other hand, Django docs are incredibly thorough.
bottle : http://bottle.paws.de/ one file ... works as expected ... nealry perfection
Flask, because it's easy to do the simple things and the complex things alike. It doesn't get in your way much but still lends a hand when you don't mind it. Having Werkzeug at the core is just sex. The active developer and community and the focus on good documentation, good APIs and best-practice conventions for extensions, does not hurt.
I haven't yet looked into winsys, but Tim's other project [wmi](http://timgolden.me.uk/python/wmi/index.html) is awesome.
That's WSGI that normalizes %2f to / (based on CGI, which specifies `SCRIPT_NAME` and `PATH_INFO` are URL-unquoted). I've been proposing a change to this for WSGI 2 on Web-SIG, but there's been some pushback on it from people who have systems where that information is simply lost (mostly Apache). If REQUEST_URI is available, with some effort you can tell the difference. When people really want to put those kinds of values in paths I suggest using a balanced character of some sort, like /{foo/bar}/something (it would look like that after URL-decoding).
The web2py philosophy (everything should have a default) is a bit contrary to the python one (everything should be explicit) which is followed by almost every other python framework. So web2py feels more like Rails than Django or Pylons. In web2py there is a default url mapping; given a model, there is a default database administration interface; given a controller action, there is a default view (for .html .xml .json etc); every table has default default CRUD pages; every new app has a default layout, a default cascading menu system, and a default login mechanism with role based access control enabled. Some people coming from Django perceive the presence of a default as constraining but actually everything can be customized/removed. The web2py book is available for free [online](http://web2py.com/book) and [on print](http://www.lulu.com/product/paperback/web2py-%283rd-edition%29/12199578). It consists of 537 pages. The 3rd edition of the book which has been available since last week covers all new web2py features include RPX/OpenID/OAuth login options, and modular design using components and plugins.
I suggest you to try [repose.bfg](http://docs.repoze.org/bfg/1.3). It can be really lightweight, but also scales well.
This is very cool!
Definately pylons, its not as funky as the others, but is merely a framework to start hacking. Essentially it does al the configuration and setup for you.
&gt; I will have to study the code a bit to figure out why. All the output frames are processed in parallel so each input image only has to be loaded and uncompressed once, and each output row is appended directly to the end of the temp file on the disk meaning that no data (apart from the input images) needs to be loaded in until it compresses them to png's at the very end. It's close to optimal, except it's possibly bound by the seek speed of your harddrive's head, depending on how well your operating system's write buffers are working.
I haven't tried the alternatives, but Flask is working great for me.
You should be using an IDE that will translate your tabs into 4 spaces. Unless you mean your own code you can't get out of the habit of using 2 spaces?
No, my text editor can do that. I just don't prefer using tabs for indentation and spaces for other things. I did this before Python. And I only don't do this with other people's code.
It sounds like you want [Pinax](http://pinaxproject.com/). It comes with things like a wiki, bug tracking, authentication, etc. It's meant to integrate with your Django application and give you a bunch of prebuilt stuff. 
We should merge the code from my project terminate (http://terminate.sf.net) with this. Terminate has a lot of similar features, but also has OS-independence (as much as possible) and various useful widgets for scripts.
Most of those features come with web2py+plugin_wiki. [Here is a video](http://vimeo.com/13485916) and [here is documentation](http://web2py.com/book/default/chapter/13#plugin_wiki). Runs on Google App Engine.
I don't know of Pinax including bug tracking tools. It is basically just a framework built on top of Django. You get all the Django goodness you know and love, and also get a set of basic social apps (wiki, comments, friends list, openid, etc) that are all setup to play nice together. Major +1 for it.
You might want to look at starting from [Trac](http://trac.edgewall.org/). It is a primarily a project management tool, so it come with things like a wiki and ticket system, and you can extend it through plugins.
That sounds great :) One caveat you should be aware of is that my project is licensed MIT. If you feel comfortable with that, message me and I'll give you commit access to the [BitBucket repository](http://bitbucket.org/jart/fabulous/src). (The same goes for anyone else interested in helping out)
No effect works on OS X using the Terminal app except the 4 bit colors. Everything works in xterm though. It would be really great if it was OS-independent.
I agree, but I don't think Terminal.app doesn't support 256-colors :'(
Well, ideally it should detect that and fall back to 4bit colors. Right now the text is black or garbled or randomly blinking.
No documentation or examples?
One of the listed features on their homepage is "projects with basic task and issue management."
So it is. Looks like it just isn't part of any of the templates I've used. Nifty :-)
Here's what it'd look like quantized to 4-bit color: http://i.imgur.com/nypKF.png (the text actually looks better than I thought lol) I should definitely make 4-bit quantization part of the API. The tricky part is detecting Terminal.app. It's probably even harder to do when people use tools like screen. Do you know off the top of your head what the environment variables are?
Makes me really nostalgic for BBSs.
If you haven't seen it already, [PyReadline](http://ipython.scipy.org/moin/PyReadline/Intro) is great for making cmd.exe act more like Linux. I've used it successfully in a Windows/Linux project to provide symmetric readline support and basic colors. That said, glancing at terminate it looks like something I wanted long ago. Definitely going to check it out!
Hehe I wrote something similar, but it only does 4bit color, which handles cartoons a lot better than photographs. Great for terrorizing IRC though. Some samples: [pedobear](http://gruntle.org/media/images/pedobear.png) [stimpy](http://gruntle.org/media/images/stimpy.png) [homer](http://gruntle.org/media/images/homer.png) [devildoll](http://gruntle.org/media/images/devildoll.png) And then there [this](http://gruntle.org/media/images/cows.png).. I'm curious what algorithms you used.. I am no expert at it, so I mostly went by what I read [here](http://www.compuphase.com/cmetric.htm). I have a few tweaks you can adjust like what color distance algorithm it uses (euclidean or linear) and various palettes, just because it's hard to get good results when you only have 7 colors on black. The picture of Obama looks great. What I'd give for IRC to support more than ANSI. :/
Usually terminals set the "TERM" environment variable to strings such as: xterm, xterm-color, ansi, rxvt (default for Terminal.app), etc. and that means that they are declaring they are compatible with whatever. Where are these escape codes documented? 
I was always under the impression that terminal applications only had 16 palette colors available. This is very cool.
Hello world!
It's not just cool, it's fabulous!
&gt; I'm curious what algorithms you used. Nothing special, just per-pixel brute force nearest neighbor search in euclidean space: [_xterm256.c](https://bitbucket.org/jart/fabulous/src/tip/fabulous/_xterm256.c) The [output optimization](https://bitbucket.org/jart/fabulous/src/tip/fabulous/image.py#cl-102) and [alpha blending](https://bitbucket.org/jart/fabulous/src/tip/fabulous/image.py#cl-138) is probably more clever. &gt; What I'd give for IRC to support more than ANSI. :/ If we submit patches to all the major open-source IRC clients, we can bring trolling to a whole new level!
Yep, definitely looks horrible in rxvt on linux too. That should make it a pretty safe bet to downgrade automatically when TERM=rxvt This is the only xterm256 documentation I'm familiar with: http://www.frexx.de/xterm-256-notes/
Tornado. It's fast and you can easily understand all of the code. Also, there's Python-based templating but no ORM, which sounds like it might work out well for you.
I see, so it's just a very specific extension of xterm. So even if you know that the user is using xterm you don't know whether the extension is enabled. :/ 
You don't have to enable it; it just works and has been supported for years. This extension is also supported by Putty. Setting TERM=xterm256 is really only required by vim and emacs because they implemented support years ago when this feature was brand new. TERM can also be deceiving, for instance if you use GNU screen. I think it's fair to say *most* people use tty capable of 256 colors and that Terminal.app is the exception to the rule, but can easily be detected. Thank you so much for your help :) I'll be sure to make fabulous automatically downgrade colors for Terminal.app in version 0.2.
Plenty of comments in the code.
I haven't been using it for anything serious, but it's an excellent framework - magic-free, keeping the boilerplate to a minimum, and extremely flexible. And the API to create extensions looks both simple and solid. But the best point is perhaps the documentation. Go Flask!
did you notice one of the colors is "orangered" ? :)
The point I was making was, if it were doing more complex stuff (i.e. parsing or tagging) at 60/120MB/s, it would totally be worth it. But doing something like chars = [ord(x) for x in words] and then jumping up and down and rejoicing that your GPU reaches 11GB/s when counting these words is rather silly. (Point in case, he can't mmap the data because the simple kernel he uses can't cope with newlines, or tabs, or -shudder- tokens that are not delimited by spaces, such as commas or dots). I think that there's good examples on why you'd want something like PyCUDA or PyOpenCL - have a look at [Theano](http://deeplearning.net/software/theano/) for example - but that a class of very useful problems are currently out of reach of GPU computing either because GPUs are bad at solving them or because people don't care about solving these problems and gravitate towards simple toy examples when the question arises.
It depends on the problem, I am primarily working on problems for ram and gpu, so disk is not so interesting to me (except for backup). (note: I wrote the blog post)
256 color support is quite common.
That is an ingenious word count method. Did you come up with that?
Nice work ! I was reading the color.py code, and you want to make ColorString behave like a string. You should probably use the __new__ method : class ColorString(str): fmt = "%s" def __new__(cls, *items): obj = super(ColorString, cls).__new__(cls, "".join(items)) obj.items = items return obj ...
I feel that there are three main contenders for the Best lightweight web framework: WebOb, CherryPy, and Werkzeug. Werkzeug is vastly under-rated.
It would be nice if it followed PEP 8 conventions
heh _fabulous_.
Yes, I'm now basing my routing on REQUEST\_URI. If done a little test with wsgiref (I uploaded it [here at pastebin](http://pastebin.com/qTYvnB2T)), and it seems that it isn't changing the value of the Location header, it lets the %2F go through unmolested. So that would probably mean that Apache is changing the Location header. I've had to tweak the configuration a little, to make it not serve a 404 when a GET requests anything containing a %2F. Edit: Thanks for WebOb in general, though! It's simple, complete and doesn't get in my way. :-)
Thanks a bunch. I've done some testing too and it seems that Apache is screwing with me. See also http://www.reddit.com/r/Python/comments/d3gwr/best_lightweight_web_framework/c0xcguh
Do you maybe mean like [Plac](http://micheles.googlecode.com/hg/plac/doc/plac.html) and [Flask-Script](http://packages.python.org/Flask-Script/)?
Very cool library mate, keep it up and I hope you find people interested in helping out.
Right now the only one I can think of is S60, and maybe Maemo/Meego. There is limited Python scripting on Android, but you're not going to be developing full apps with Python.
The only one that could be seriously considered is hopefully going to be Meego. There's a huge chance that Python bindings will be made available to the Meego SDK, which uses Qt for UI related stuff. And for Qt there's already an excellent binding (PyQt) and another one emerging (PySide). On IOS it's even forbidden (!) to use something else than objective-c to create apps, Android has a scripting environment but afaik it's quite limited. If you want to create serious apps for Android you should use Java (some people love the Android Java API). Symbian has Python support, but I have no experience with it.
FreeRunner had most of its base UI written in Python (GTK, E, Qt...). Not that I recommend it, it has many many flaws (weak hardware, not finished basic software). You can get used phones cheaply, though.
Isn't that forbidden only if you want to distribute apps on iTunes?
Yeah, even if there will be no OOTB support for python, Meego will probably be able to run python using some community-supported packages. Currently N900 seems to be the best hacker phone (to me).
Yes, those are exactly the sort of libraries by whose existence I am not surprised. Plac's page really proves my point, as the earliest version of it I could find was a few months old, and the doc page claims that the author was surprised at how few of the zillion argparsing libraries take the reflective approach. So I'm not alone in ranting about this topic. Plac would benefit a lot from adding parameter types to its annotations, by the way. If your script accepts dates or numbers, it makes sense for the script host to handle the parsing and failure notification for you.
Your, fine sir or ma'am, are full of *epic* win. +1 internets for you.
It pretty much does except for where it can't/shouldn't, e.g., Win32 structs, Win32 constants, etc. It's consistent in the format that it uses, which is all anyone should really ask for.
Thanks &lt;3
Yeah like what the other people have said, n900 is really neat with its QT integration. I just rsync my working qt directory over and ssh over to run it in one command and BAM fastest development cycle ever. True story, needed an anagram solver while on the train? Wrote one using the dict file in /usr/share and bam anagram solved. Wrote it all on the phone.
Qt.
For a ready to run, extendable intranet, try Plone. Using plugins (http://plone.org/products) to add LDAP authentication and issue tracking. Plone 4.0rc1 : http://plone.org/products/plone/releases/4.0 
I created a Arch PKGBUILD for this lib. It's avaliable at: http://aur.archlinux.org/packages.php?ID=40103
It'd be cool to see a fork of Jython that could compile into Dalvic instruction set.
This is cool! Very nice. also your documentation is great - I am a python newbie and everything was very easy to understand.
If [Plone](http://www.plone.org/) does what you need out of the box, it's a good CMS. The major drawback is that it's *very* complex so customization can quickly become a nightmare. These days I'd recommend building a Django site using individual components - e.g. something like Django-CMS or FeinCMS to provide the overall site structure and embed some of the existing wiki, calendar, bug tracking, etc. apps in the appropriate pages.
You may be able to use IronPython with winows phone 7.
Yeah, Terminal.app is kind of retarded when it comes to colors. I wish they would improve it. [iTerm](http://iterm.sourceforge.net/) is a good alternative.
Thanks, I'm so glad you're enjoying it. The documentation could still use a bit of work, but writing simple, easy to understand software is an important priority of mine so it's nice to hear that I'm succeeding
As I understand it, they actually compile from the .class files to the dalvik bytecode, so it would be as easy as making it use the subset of java bytecode that is supported. They may extensively use java bytecode features that aren't supported or my information may be completely wrong though.
Android Script Environment was recently upgraded to support making APKs from Python, among others. However, it can't support the full API just yet. I've heard rumors about a project to make Python compile into Dalvik bytecode, but so far it's just a rumor. With iPhone, the Cydia repositories contain a bunch of Python stuff which I use all the time. There's a good UI abstraction (UI Caboodle) and a direct binding to the native toolchain (PyObjC). I have seen some neat apps developed for the N800 in Python. This includes the awesome SILICA app from Immunity Inc. However I've never owned one myself.
I always thought "long vs int" problem gone 9 years ago: http://www.python.org/dev/peps/pep-0237/ Am I missing something?
takes that much?
takes that much?
The guide is good; the only bad thing is that matplotlib graphs are dead fugly.
I have not tried myself but I am told the N810 and successors run Python apps very well. Here is [video of a N810 running the entire web2py framework](http://www.youtube.com/watch?v=s0fsjGVIGPU) including the IDE.
[Android Scripts (Python/Ruby) can now be a distributed in APK](http://www.reddit.com/r/programming/comments/cx80i/android_scripts_pythonruby_can_now_be_a/)
webpy is fairly lightweight, doesn't require alot of upfront coding, has decent support to plug into databases. I think reddit still uses webpy...
Compared to what? I honestly quite like how the defaults look in matplotlib. And if you don't, you can customize nearly every aspect.
No, you're not missing anything. The long v int problem only rears its head when you're working with the underlying types.
Please do the same thing with less.
your Terminate is GPL-diseased
seriously? There are no tips in your link. Link to an archive of the mailing list or something. I'm not going to sign up without seeing if I like it first...
Yes, but customization of any CMS can become painful. On the plus side, whatever you build for/in Plone is integrated. So everything has support for workflow, has security checks and looks and works uniform. IMHO, these features are mandatory for an intranet. 
Pointless barrier to entry. What advantage does sending it out as a mail give (other than to harvest emails)?
\*rolls eyes\*
I've seen worse from commercial tools. These are on par with some of the defaults in R, which most folks consider having 'publication quality' graphs and charts.
That's exactly what ran through my mind. Why would I use this tool when I could just use argparse?
Especially when there is no web archive of it. From the blog author's response to a comment on the posting, it's purely email. If he did it like PyMOTW, where he sends out an email to notify of a new posting (or you just go to the site as you please), that would probably gain more readers, IMO.
No, most of all it won't be possible, until Wp7 will run a full version of .NET See this: http://social.msdn.microsoft.com/Forums/en-US/windowsphone7series/thread/9e2c3ae7-0eba-4ca5-a920-018cc825cdfd
*It includes some of the same set of utilities used to build and run internal Python apps at Google.*
+1 for Flask. Besides being actively developed and supported the documentation is excellent. The fact that it "defaults" to using Jinja 2 templates makes it real easy to get started with for people used to Django and Jinja 2 is DTL on steroids. Plus there are stricter rules about how extensions should be implemented and documented, the benefits of this become obvious after you've tried to integrate some Django "reusable" apps in your existing Django project. There are already some useful extensions for integrating SQLAlchemy (the most advanced ORM in the python world), WTForms (very similar to django.forms) and some "NoSQL" stores like CouchDB with a Flask app.
I'm partial to [baker](http://bitbucket.org/mchaput/baker/wiki/Home) myself.
tl;dr? 
Some people claim that the current Python package maintainer isn't doing his job. Politics ensue. Nothing gets resolved.
Frame averaging is important as to obscure fappery.
I think it's a bit of a strange choice of wording. I would just take it to mean the text of the program i.e. "source code". So: &gt; A scope is a textual region of a Python program where a namespace is directly accessible. Would be: &gt; A scope is a region of source code in a Python program where a namespace is directly accessible. And: &gt; Any identifier of the form `__spam` ... is textually replaced with `_classname__spam`. Means: &gt; Any identifier of the form `__spam` ... is replaced in the source code with `_classname__spam`.
The current maintainer seems to have become incommunicado in public channels and allegedly does a poor job of maintaing python in debian. Then several "camps" start having very eloquent arguments of who gets to play with whom's toys.
I think it means that the scope of any particular `name` can be determined just by looking at where it exists textually relative to other blocks of text. You can look at any `name` in any block of Python source and determine the scope of the `name`. http://en.wikipedia.org/wiki/Scope_%28programming%29#Lexical_versus_dynamic_scoping
that's one thing I don't like about the official doc - written by very experienced programmers for relatively experienced programmers
Content-Type: text/plain ?
Django.
I'm partial to Apache + mod_wsgi + CherryPy
1) The following 4 lines install and start a multi-threaded SSL-enabled web server, the SQLite database, a web based IDE, a ticketing system, etc.: For Linux: wget http://web2py.com/examples/static/web2py_src.zip unzip web2py_src.zip cd web2py python web2py.py -a 'mypassword' -i 127.0.0.1 -p 8000 (it only requires python, nothing else, no config files). For Windows: download http://web2py.com/examples/static/web2py_win.zip click to unzip click on web2py.exe (in the windows case you do not need to have python installed) 2) visit http://127.0.0.1:8000/admin login with the password "mypassword" type "myapp" in the left box "create new app" and this will direct you to the design page for the new app. 3) Click on [edit] default.py and type: def hello(): return dict(message="Hello World") (you can also edit web2py/applications/myapp/controllers/default.py with your favourite editor) 4) click [save] 5) visit http://127.0.0.1:8000/myapp/default/hello done. ... repeat. At step 3 you can type any valid Python program with access to the API described [here](http://web2py.com/book). 
There are tons of frame works out there. bottle, flask, web2py, django, pylons to name a few. Just pick one you like.
Why didn't he just use multiprocessing? It's just like threading, except youknow, not broken.
No worries! The good thing is you can't go badly wrong. Especially if you have no constraints. Yes, there're lots of python web frameworks and they might have individual strength and weaknesses, but none of the better known is bad. You should check the documenation of the frameworks and find out which is best written for your personal way of learning / understanding. Otherweise, when in doubt, flip a coin ;-)
I really enjoy use Pylons, it's simple and lightweight. It has a tremendous amount of documentation and scales quite nicely. Recommended Links: * [Pylons-HQ](http://pylonshq.com/) * [Pylons Book](http://pylonsbook.com/) * [Webfaction](http://www.webfaction.com/) *(Hosting service I use for serving my Pylon applications.)* Hope this helps!
Relevant http://bugs.python.org/issue3548, http://bugs.python.org/issue1191964, http://bugs.python.org/issue1260171
Now that is damn cool. I wonder if there are any modern usages for that kind of tech? Maybe steganography? I wonder what kinds of waveforms will make it through an MP3 encoder un-touched.
&gt; I'm adding the DPL to this reply because it seems possible that the only way to achieve this objective might be an in-person Debian Python Summit meeting, moderated by members of the TC, where we can work through all the issues and come to consensus. Wow, sounds like every federal job I've ever had.
You pick your nose and eat and drink alot.
I usually use IPython for this kind of stuff. You can just do: output = !ls -la | grep 'bla' See [here](http://ipython.scipy.org/doc/stable/html/interactive/shell.html) for docs. However, IPython isn't as useful when you need to feed input to the commands, or run commands asynchronously.
Seconded without hesitation. Repoze is now my default choice for big and small.
I recently discovered mod\_wsgi after using mod_proxy for ages. It's a lot better.
"A bit blurry" Understatement of the year. I came back to say that you touch your face and eat a lot. "TheJosh" beat me to it.
Ah, it's this time of the year again when people realize that Debian is more a social experiment in open source politic than a technical project. They seem to have so many layers of bureaucracy that its probably simpler for an Iranian to get a US visa than to navigate through Debian's various committees. :) In the end I wonder why people like to work for that project. I understand it's huge and famous and bla but don't they have enough of those petty discussions at work? I know I do. 
Wow. Geek porn.
(Every problem in a large open source ever)
Simply put, ``%s`` does ``str()`` and ``%r`` does ``repr()``. These are often the same but not always. &gt;&gt;&gt; str(u'foo') 'foo' &gt;&gt;&gt; repr(u'foo') "u'foo'" The interactive shell itself, for example, does ``repr()`` for return values.
I think Ipython forks off sh first. If this is what you want, it's also dead easy with the posted package: from pc import sh output = sh('ls -la | grep bla')
google is your friend and keep the doc's close by http://docs.python.org/library/stdtypes.html#string-formatting
Hasn't that book only just been written? Why doesn't it use the new way of formatting strings?
http://docs.python.org/library/stdtypes.html#string-formatting-operations seems like %s uses str(object) and %r uses repr(object). You can override the two methods \_\_str\_\_ and \_\_repr\_\_to get different representations of your classes/objects, if you want to, see http://docs.python.org/reference/datamodel.html#basic-customization
BTW, I recently learned that `repr()` is ideally something that you could feed back to the interpreter in order to re-create the instance. For more complex types, this might be difficult, though. So if you make a class "Foo" that gets constructed by "`Foo(10)`", e.g., then if you implement `__repr__()`, it should return the string `"Foo(10)"` for that instance.
Yep, **repr**esent the object as you would in code. But as you note, it doesn't work well for complicated types.
Agreed, unless you need support for Python 2.5 or earlier. &gt;&gt;&gt; '{0}'.format(u'foo') 'foo' &gt;&gt;&gt; '{0!r}'.format(u'foo') "u'foo'" 
When you post code, add four spaces at the beginning of each line. That way, line breaks are preserved, it's displayed in a monospace font so thing line up better visually, etc. Here it is, formatted and without the line numbers: x = "There are %d types of people." % 10 binary = "binary" do_not = "don't" y = "Those who know %s and those who %s." % (binary, do_not) print x print y print "I said: %r." % x print "I also said: '%s'." % y hilarious = False joke_evaluation = "Isn't that joke so funny?! %r" print joke_evaluation % hilarious w = "This is the left side of..." e = "a string with a right side." print w + e I see your question has been answered. As someone pointed out, there's a [new way of doing string formatting](http://docs.python.org/whatsnew/2.6.html#pep-3101-advanced-string-formatting) in Python 3, which has been backported so you can already use it with 2.6. The `%` operator version as described in Zed's book is however still the most widely used in code out there.
Awesome resource. Thanks!
Thanks for all of the answers. I think I understand. In layman's terms: The str() function attempts to return any string value within it's input (hence why the u is ignored in the above example), whereas the repr() functon will attempt to make a string out of it's input. Edit: spelling
Author of the list here... Confinium - I'm experimenting with a tips-by-mail list, as I explained in the original Python Tutor announce mail I'd noted that I pay quite a lot of attention to some tips-by-email lists (e.g. to learn German) and I wondered if it would work for Python. So - I'm trying it out, a set of tips are ready and I'll continue if the feedback is good (so far it is very supportive). The goal is to give you a tip that you can digest at a regular interval, rather than a big list that you'd otherwise just skim through. briancurtin - there is no web archive yet but then - I've only written up the first tip (8 more are ready in rough form). I may do an archive if there's interest (but that means doubling the work, so it'll come if required later).
I'd say the str function attempts to convert its input into a string, and the repr function generates a string which describes (or represents) its input.
I remember looking at pyreadline a while ago (or something like it, I haven't worked on this project much in the last 3 years). For some reason I didn't use it directly, but I think I might have copied code from it, or at least used it to get a better grip of the win32 api or something.
Sorry for not responding immediately, I was off visiting my girlfriend. Priorities ... As for licensing, I think I'm okay with re-licensing the MIT license. I chose the GPL for a number of reasons, but I don't think that any of those reasons justify a split-up codebase, or two projects when we could have one. I'll send you a message.
Unevaluable representations should be `&lt;in this form&gt;`, with the angle brackets.
This is a framework, not a way to serve python to a browser.
I've been playing with the new options lately. I find Gunicorn + Nginx proxypass to be the easiest to setup and deploy, but prefer the speed and usefulness provided by uWSGI and it's accompanying Nginx implementation. Both of these options are faster than mod_wsgi and also open the door to new techniques like concurrency in the future. 
Django provide a standalone server (albeit it is not for production purposes) cd my-web-site &amp;&amp; python manage.py runserver 0.0.0.0:80 Very convenient.
Right. The main difference is that str() tries to generate **human-readable** output, while repr() tries to read **Python-readable** output.
docs.python.org is fantastic.
Google App Engine.
Doesn't python itself all ready have this?
Seems silly - shouldn't we aspire that they be one and the same? For example, the way MongoDB's python driver does it: a collection will be something like: Collection("collection_name", Database("db_name", Connection("localhost", password)))
c:\dir&gt; python -m CGIHTTPServer it will launch the server at the "dir" folder location . create a cgi-bin folder inside and put in some .py files for action.
I just looked at both web2py and Pylons, and none of those seem to be able to work remotely, that is, I run the scripts on a server and access them through the LAN. I have searched the documentation of both and there doesn’t seem to be a way of configuring either of them to be accessed from elsewhere than localhost.
Until Python understands any text a human could, then to me there is a clear advantage to having both human- and Python-readable representations of an object. Perhaps I misunderstand your point.
Indeed, `repr` should (when possible) have `eval` as its inverse.
Or use pastebin.
&gt; shouldn't we aspire that they be one and the same? This is a case where blindly following nicely sounding principles would lead you into trouble. &gt;&gt;&gt; from datetime import date &gt;&gt;&gt; d = date(2001, 5, 11) &gt;&gt;&gt; str(d) '2001-05-11' &gt;&gt;&gt; repr(d) 'datetime.date(2001, 5, 11)' 
Those double spaces make my head hurt..
The phrase you want is [layman's](http://dictionary.reference.com/browse/layman) terms. As in terms appropriate for the non-specialist.
Yeah, sorry -- just checked.. all the code blocks in the PDF have these double spaces, weird. Fixed it.
Neat Trick: you can write \`obj\` in lieu of repr(obj)!
But, don't. It's gone in Python 3 because Guido hates it. Easy to mistake for single-quotes, not very suggestive of what it does (hurts readability) and difficult to search for help/documentation for.
Excellent example.
Nice: -~*~--~*~--~*~--~*~--~*~--~*~--~*~--~*~--~*~--~*~- a deep unholy earth -~*~--~*~--~*~--~*~--~*~--~*~--~*~--~*~--~*~--~*~- darker than the a petty agony, in the death my love shall hang my head the ghastly condemned and the damned taunt the dark condemned and the stroke of death follow no one cares why the condemned flee oh my eyes! the love! they sever my head and fall limply with all my madness sicklier than shadows in swirling dust in the purgatory my love shall tremble no one cares why the angels cry out angrier than corpses in broken ground oh my essence! the agony! no one cares why the shadows scour the frozen damned and the mourners loom no one cares why the memories beg forgiveness the dead angels and the angels hover close 
IPython only helps if you're using it interactively--this can be used in programs.
Oh, I agree. I just figured I'd mention it. Most people (rightfully so, perhaps) have never heard about it before.
Answer: Zed is a tool. 
Coming from a C background, the .format way of doing it just feels plain wrong.
Thanks everyone! What is the best way when considering lots of page views in a corporate environment?
I know what you mean, but it is honestly more pythonic, and you can do a lot of cool stuff with it.
http://wiki.python.org/moin/Python2orPython3
I can't get out of the habit. I didn't like the overloading of %, but I prefer C style format strings. It would be better is Python had string interpolation instead.
For web work, stick with 2.x but use 2.6 or 2.7 if you can to facilitate the transition to 3 when/if you decide to do so.
Not very OO, though, is it?
Further, % is string substitution. So, basically, what you're doing is fairly straightforward: &gt;&gt;&gt; "This is a %s string" Creates a string, where you can think of ``%s`` as a variable. It'll be whatever you substitute in. Ignore the type stuff for now :). So, &gt;&gt;&gt; "This is a %s" string." % "long" "This is a long string." ``%`` is kind of a weird operator to use for this operation (it's also modulo, as in ``3 % 2 = 1``), but think of it as ``"string".subsitute(vars)``. The character following the ``%s`` is the type you want to represent. Python uses dynamic, but explicit typing; ``x = 123`` stores an int, ``y = "123"`` stores a string. When you use a ``%s``, ``%d``, or ``%r`` it coerces the variable you supply into the given type - where "s" means string, "d" means int, and "r" means (in Python) repr - a form of String. So, &gt;&gt;&gt; x = 123 &gt;&gt;&gt; print x 123 &gt;&gt;&gt; print str(x) "123" Hopefully you get the basic idea now. See Wikipedia's printf documentation for a list of control strings (``%s``, ``%d``) etc. to see what the different types do (Python's are based on C's).
So what would be the alternative to "textually"?
Python expert here, thank you for teaching me something I never knew!
I had a hard time figuring these things out when I first started. I really wish I'd used this http://learnpythonthehardway.org/index when I first began to learn.
if you run Debian then get the python-doc packet and have a look at file:///usr/share/doc/python2.6/html/index.html 
I used two quotes, the second one uses "textually".
No I got what you were saying, and I think you're right. But I mean if this didn't work textually, in what way would it work?
Normally this is referred to as "lexically scoped". Essentially it means that scope is determined by the position in the source code - if the source of the function appears within the source of another function, it can access the variables of the function it's nested within. ie: def foo(): x=42 def bar(): # have access to x here because the function is defined within foo() This is pretty much the norm for most languages these days, so it almost goes without mentioning. However there are other ways of handling scope. One is "Dynamic scoping", where the scope is effectively inherited from the **caller**, not wherever the function is defined. Eg. in a hypothetical dynamically scoped python, you'd have: def foo(): dynamic x = 42 # Hypothetically marking x as a dynamic variable bar() def bar(): print x # Obtained from foo when foo calls us One language that supports dynamic scoping is Lisp. This is done by using "special variables", defined by `defvar` rather than the lexically scopped `let`, and by convention usually surrounded by "\*" characters. Eg: (defvar *my-dynamic-var* 5) 
It sounds like python may not be the best choice for you :)
I've been programming python for over three years and it is my preferred language for most things. I think it seems like a good choice even if I want to keep doing things like I've been doing them in python2..
This sounds like a bad idea. It's not thread safe (affecting global variables from within a function defined in a different module) and it's just ambiguous. "amb" has 2 different meanings.
[The notorious "simple HTTP server" with SSL in python 3](http://python.pastebin.com/c6hT5iwa)
Agreed, the global var manipulation makes this completely useless in practice. A sane but still simple interface would be something like this: print("\nSmall Pythagorean triples problem") # Extract solutions to global variables and print for solution amb(lambda x, y, z: x*x + y*y == z*z, x=range(1,11), y=range(1,11), z=range(1,11)): print solution.x, solution.y, solution.z As a bonus, this should be even simpler to implement as well. 
Amb sems to be one of those things done first in Lisp then scheme some time ago, and people can apply mathematical reasoning to the amb operator. I could have just written nested for loops, but the task I set myself was to retain some of the aspects of amb that I was reading about. The declarative style of programming is used extensively in hardware verification languages as is such modification of global variables. it is useful for me to see how such could be done in Python - A deliberate contravention of normal Python style, but for a purpose. Thanks for taking the time to read my post :-) 
Here is a simple proof of concept that doesn't use globals and provides a (IMO) very sane user interface: class AmbResult(object): def __init__(self, d): self.__dict = d def __getattr__(self, name): return self.__dict[name] def __repr__(self): return repr(self.__dict) def amb_internal(fun, c, v): if len(v) == 0: if fun(*c): return [AmbResult(dict(zip(fun.func_code.co_varnames, c)))] return [] val_names = fun.func_code.co_varnames val_name = val_names[len(c)] vals = v[val_name] result=[] v2=dict(v) del v2[val_name] for val in vals: c2 = c + [val] result.extend(amb_internal(fun, c2,v2)) return result def amb(*arg, **kw): return amb_internal(arg[0], [], kw) # Example usage for sol in amb(lambda x,y,z: x*x+y*y==z*z, x=range(1,20), y=range(1,20), z=range(1,20)): print "Solution: X=%d, Y=%d, Z=%d" % (sol.x, sol.y, sol.z) 
If you're planning to develop a big app, you will need various libs. Most libs haven't been ported to python 3, yet and it will be a slow conversion. I'd advise sticking with 2.7 and using migration tools (from future...) when 3 libs become available.
This is just a bad idea.
Thanks ascii for putting in the time to flesh out your example. I too could have chosen to use your kind of interface, but like list comprehensions: there may well be other ways of getting to the solution but the way you get to the solution is part of the solution. If users of a system are used to a particular aspect of that system that you wish to replace; retaining some aspects of the incumbent may help in the acceptance of the replacement. And I wanted to see how it could be done :-) 
Awesome!
Having problems with it. After I run the bootstrap script and bin/buildout, I get: ImportError: No module named zc.buildout.buildout Specifying [version 1.4.4](http://pypi.python.org/pypi/zc.buildout/1.4.4) when running `bootstrap.py` solves the problem: python bootstrap.py --distribute --version=1.4.4
Im actually using this to build a multi-touch app, its a great framework for beginner's.
get off my lawn
Any functional paradigms in Python are purely coincidental.
Oh, got it :) I don't know if "textually" is 100% correct in that quote because I think the name mangling happens at run time, not in the source code. Since most languages are text-based things have to work textually, but in many dynamic languages you can do all sorts of modifications to the program at compile time or run-time (e.g. [templates](http://www.haskell.org/haskellwiki/Template_Haskell), generated code, lisp macros, reflection, [modifying the stack](http://docs.python.org/library/inspect.html#the-interpreter-stack), bytecode injection). Those types of techniques don't have to be "textual".
Not purely, but yeah, apart from listcomps (which may or may not be considered functional) the functional features of Python are side-effects rather than a march towards FP. Most of the core developers have no interest whatsoever in FP techniques. When an interesting feature can be defended as a good idea for introduction (functools.partial) it has a chance, but saying "This is more functional" is generally a good way to see your proposal burst in flames.
reduce did move to the [functools](http://docs.python.org/py3k/library/functools.html#functools.reduce) module for 3.x, where it probably makes more sense to be, but there are at least [100 other things](http://docs.pythonsprints.com/python3_porting/py-porting.html#organizational-changes) I know of which were reorganized at the same time. I don't think its movement had anything to do some moratorium or plan for removal.
No, you're right (as is arnar, in a sibling post). I'm just saying that when we have the chance, we should aspire to having as human-readable Python as possible.
Have you made a choice, mashmorgan?
The pro's of Python 3 is you're mostly future safe, so you're putting the cost of maintenance up front vs. later.
That makes sense, I assumed that was why Pylons didn't seem in too much of a rush to port to 3, since it's so bare bones, thanks.
&gt; ImportError: No module named zc.buildout.buildout Maybe try deleting existing zc/ packages in global site-packages, user site and buildout parts?
I [discuss](http://http://programmingpraxis.com/2009/02/20/multiple-dwellings/) the implementation and use of amb at my Programming Praxis blog.
``str.format`` has a number of advantages: - You can reorder unnamed arguments: ``'{1}, {0}'`` - Ordered and named arguments share a consistent syntax: ``'{0}, {name}'`` verses ``'%s, %(name)s'`` (not a big difference but one that exists) - C-style does not make much sense in a dynamic language. ``%s`` and ``%d`` do the same thing (usually, don't know if there are exceptional cases) - Access attributes and items on an argument: ``'{self.attribute}, {self[item]}.format(self=self)``
I'm probably missing a required step to run it. I did not have zc.buildout installed in site-packages, but the others I'm not sure (this is a clean build, so buildout was downloaded to parts). Pre 1.5.0, I'd simply run (without virtualenv): python bootstrap.py bin/buildout And it wouldn't cause the ImportError. This is simple and great for users. I distribute a program using buildout and I'm tempted to **force** 1.4.4 in bootstrap.py because users are facing the same ImportError.
apparently part of the issue with the various web frameworks getting ported is that WSGI in python3 is a bit of a mess atm.
&gt; I'm tempted to force 1.4.4 in bootstrap.py because users are facing the same ImportError. Ah, not needed. It seems that this is well known and they made a bootstrap script for users facing the problem: http://mail.python.org/pipermail/distutils-sig/2010-August/016745.html
Fuck. Yes.
For 2.6 users: `from __future__ import division` Now your standard `/` operator will always return a float.
This has been available since 2.2
&gt; 2 seems bloated with idiosyncrasies Could you please name a few of them? 
you should read up on wsgi. this is my current "serving chain" of choice: apache/mod_scgi or lighttpd (build in scgi) --&gt; [flup](http://trac.saddi.com/flup) (scgi server) --&gt; wsgi app and to help with the wsgi app i would suggest [werkzeug](http://werkzeug.pocoo.org).
Hmmmm. I've had odplib out for about 2 years in my rst2odp package. Yeah, it only deals with presos (wish the rst2odt guy followed suit and made an odtlib....), and this looks more generic. I wonder how they handle the subtle differences in rendering. (Some xml meant for odt doesn't work for odp, or crashes impress).
AFAIR the behavior of negative numbers in C for % is undefined and could be implemented either way. Not sure right now though.
Yikes. Unicode and string types, old and new style classes, duplicate functions like range and xrange which return lists or generators. Map, zip and filter have those itertools counterparts imap, izip and ifilter which return iterators. 2 just has a lot of redundancy, like the im_func and \_\_func\_\_ attributes, or the two ways of specifying metaclasses.
This could be handy....
Another good one is [blatter](http://bitbucket.org/jek/blatter/src).
Bureaucracy is the ransom of large scale organization, but that's not really what the thread is about. Issues with maintainers not doing their job properly and unwilling to accept help/communicate/step down is not something particular to Debian.
yes. it's not hostile, it's 'meh'.
Now if only they could get SSL to work with their asynchronous connection libraries; asynchat and asyncore.
Could [itools.workflow](http://docs.hforge.org/itools/workflow.html) solve your requirements? 
I've found [repoze.workflow](http://docs.repoze.org/workflow/) incredible useful and easy-to-use.
Plone's object model and massive over-design are worse than necessary for customization simply because you have so much code in so many places - even simple extensions always seem to involve a dozen separate files, tons of XML, etc. Awhile back I found a basic bug in the default install (since fixed) where the failure was quietly absorbed by one of the higher-level layers - nothing major but definitely the kind of debugging tax which adds up the more you do. It looks like the Plone 6 release is shaping up to be the de-larding release which should be a big improvement in this regard. 
I have been very happy with [blatter](http://bitbucket.org/lost_theory/blatter).
See my [fork](http://bitbucket.org/lost_theory/blatter)! For some improvements.
Why?
What were your thoughts on goflow and spiff workflow?
&gt; Templates are dynamic, output is static can someone explain this?
So, both the built in python documentation _and_ a brand spanking new py3k-book are completely wrong about what argument type the zip function requires, and the author somehow believes this is a _good_ thing? I like duck typing as much as the next guy, but clearly this is emphatically _not_ proof of its superiority.
that doesn't sound like a python question, or even a programming question to me... "He wants to copy a picture file and rename it to a different location..." That is basically the definition of copying a file. use the command line, or a file manager (windows explorer if you're using windows) to drag and drop the file to a new location, and rename it if you want... is this some kinda troll? edit: If your co-worker needs the help (assuming he is a programmer) why didn't he just post the question himself? I still think this is a troll
Tell him to have a look at [the shutil module](http://docs.python.org/library/shutil.html) then, and live happily ever after.
sorry man I'm not a programmer, just a redditor see the Edit above I think its somewhat explained there.
Yeah he got it working with the Shutil module thanks guys
You're welcome ;)
in future, irc://freenode/python would probably be faster.
Looks pretty awesome ... greenlets make web servers fast, really really fast. What advantages does it have over other greenlet based solutions though? (spawning, etc)
That's exactly what I thought while reading the article. I don't see how confusing two presumably experienced people between like concepts is a good thing.
http://github.com/defnull/bottle/commit/7fcc2803dc9582544b544ccd602c992df5bc96d0 hrrhrr :)
I really enjoy using Pylons, it's simple and lightweight. It has a tremendous amount of documentation and scales quite nicely. Recommended Links: * [Pylons-HQ](http://pylonshq.com/) * [Pylons Book](http://pylonsbook.com/) * [Webfaction](http://www.webfaction.com/) *(Hosting service I use for serving my Pylon applications.)* Hope this helps!
Doesn't get simpler than CherryPy. Starting with a microframework is best for learning.
I had a chance to talk to some core python devs at PyCon 2010. I was **really** surprised by the outward disdain for anything that was directly functional. They were fine with it being a second class citizen, but the majority of the them were C++/OO all the way down and couldn't fathom why someone would want to program like that. As funny as it sounds, FP is a side effect in Python. But ... FP isn't leaving Python in any way shape or form. The tools that allow FP are part of the basis for the language and cannot be removed. As a poster wrote above Python has an extremely powerful ability to adapt to any paradigm that proves to be fruitful.
Does cherryPy work well with MySQL or other databases? Im looking at django right now but I have been suggested not to use it by some.
The question isn't really if CherryPy works well with MySQL, it's more of does Python work well with MySQL. You use MySQL in CherryPy the same you would in any standalone python application. * [MySQLdb](http://sourceforge.net/projects/mysql-python/) - MySQL * [Psycopg](http://initd.org/psycopg/) - PostgreSQL * [SQLite3](http://docs.python.org/library/sqlite3.html) - SQLite3 And if you want to use a universal framework that seems to work really well, [SQLAlchemy](http://www.sqlalchemy.org/). 
Interesting article, but at least on FF 3.6.something all of the preformatted text got cut of when it ran for too long.
If you try it and run out of time on the trial, just email us the trial license number and we can extend it.
If you are new to Python and/or web development in general. I'd stick with something simple at first (Flask, CherryPy) and go from there. These frameworks don't do as much heavy lifting and there is a much more obvious relation ship between URL and the code that executes for that URL. You might move on to something more robust later like Django or Pylons. As for "Is Django worth using?" Well, yeah, it is. What are you trying to build?
Good suggestion, thanks. Extending the word-list drive completion that's already there for non-Python files to include words in other open files probably isn't hard, and we should make it available in Python strings and comments. We may also add a more relaxed completion option that could do this for variable names/etc but tend to try to make completion in that context strictly correct and not guessing. But it's clear some people want more options here.
Note that the type signature is shown in Wing Pro in the Source Assistant tool. We hope to also have an option to show this in a popup but the Source Assistant shows more information than you'ld probably want in a popup. We're hoping to add refactoring fairly soon.
I am actually trying to build something for my senior project so im not exactly a beginner, but I dont really feel like using something complicated right now. I should be able to use django pretty well but im thinking im either going to go with cherryPy or Python Server Pages. Im not really trying to create anything very complex right now.
It lacks only [circuits](http://pypi.python.org/pypi/circuits) and [Kamaelia](http://pypi.python.org/pypi/Kamaelia) to be complete :)
get. off. my. lawn.
&gt; but the majority of the them were C++/OO all the way down and couldn't fathom why someone would want to program like that. And as much as I like Python, that pains me a lot considering the very first wide-spread OO language (and grandfather of them all), Smalltalk, actually very tightly integrated several functional concepts, most of all first-class and higher-order functions.
Django is awesome. Try it. I hope there is a lot of space in your head so you always can learn another one framework. Don't stuck only with, say, Django.
Of those two I would definitely go with CherryPy. You can start simple and build from there, using web dev best practices and it has an active community to help out. PSP looks like a big mess waiting to happen.
Since type inference is now enabled by default for some types, perhaps there are now some programs that look like plain Python but run massively faster through Cython. Can anyone think of a good example of something like this? I'm going to be giving a lunch and learn session soon and I would like to knock their socks off!
I'm probably way over my head here, but I thought files in Python worked by creating a file object with open(path,"r") and then using that in the rest of the code. Afterwards it needs to be closed. Perhaps it's the same in the pygame library? Again, excuse if I'm missing your problem completely. Edit: [It seems that pygame.image.load does indeed take filenames.](http://www.pygame.org/docs/ref/image.html#pygame.image.load) Could you try creating the file object by hand? Perhaps the error is in that step. Also, from a comment on the documentation: Does it work when the image file is in the same directory as your program?
I'm assuming there is actually a file at `/Users/samcarreiro/Documents/pygame/data/chimp.bmp`. I'm also assuming that you are running the program while your working directory is `/Users/samcarreiro/Documents/pygame/`. If you're not, Python will not be able to find the file. You can confirm this is the problem by trying to `open("data/chimp.bmp", "rb")` If that also raises an error, obviously Python just can't find the file at all, has nothing to do with Pygame. If that's not what the problem is, then I'm wondering if it might have something to do with PIL. I haven't developed on Mac for awhile, but if I remember correctly the default Python doesn't have PIL (Python Image Library) installed, instead mostly relying on (mac only) Coregraphics for imaging purposes. You will probably have to find and install PIL before pygame can open files properly. Pygame won't use Coregraphics I'm pretty sure. Edit: If the problem is pathnames, you can either use an absolute path, or you can determine the location of the program itself using a snippet like the following: def get_basedir(): execpath = sys.argv[0] execpath = os.path.split(execpath)[0] if not execpath: return '.' return execpath img = pygame.image.load(os.path.join(get_basedir(), "data", "chimp.bmp"))
What, string interpolation? No less OO than format strings.
* http://peak.telecommunity.com/DevCenter/EasyInstall * http://peak.telecommunity.com/DevCenter/setuptools * http://buildout.org/ Buildout is a way to create self-contained environments. It uses easy_install.
just to clarify, SQLAlchemy isn't a web framework, its an ORM. 
I did not mean this as, SQLAlchemy is a 'web' framework. It is a very robust approach to handling SQL inside of Python. Thanks for the reply though. 
yeah I understood what you meant, my comment was more for the OP so that he wouldn't waste time looking into SQLAlchemy as a web framework. :P 
It outputs static html but how it gets there is dynamic, a quick for instance: when you add another post to your site it goes through a template (with code) to be formatted correctly and other such things extracted and added.
I love Python, my brain to fingers is wired to think in Python. It has the cleanest syntax and the best mix of semantics of anything out there. I had really wished the Python 3k split had been more adventurous and had gone to something like [Boo](http://boo.codehaus.org/) . Little things like the inclusion of *sorted()* helps one to not have to do things like def sorted_list( _list): a = _list[:] a.sort() return a To return a sorted copy. Python is awesome, I **almost** want to see it forked to make it the mostest awesomist. The fact that things like this are *easy* in python is really nice. def ifel(expression): def ifcase(ifstatement): if expression: def ifevaluator(elsestatement): return ifstatement return ifevaluator else: def elseevaluator(elsestatement): return elsestatement return elseevaluator return ifcase print "&gt;&gt;&gt; ifel(35*20 &gt; 10)(100)(20)" print ifel(35*20 &gt; 10)(100)(20) print "&gt;&gt;&gt; ifel(35*20 &lt; 10)(100)(20)" print ifel(35*20 &lt; 10)(100)(20) via http://pastebin.com/8c374cBT I guess, it would be nice if the definition of pythonic included the full pure functional style. The language fully supports it (for the most part (with a little extra boiler plate (mostly))).
CherryPy and Django are two very different kinds of software. CherryPy is in fact a web server or a web server framework, with facilities to handle and manipulate HTTP requests and responses at a low level. CherryPy is extremely well designed, and allows you to build very elegant abstractions (many exist already). Django is a full featured web-application framework, which handles, in addition to speaking HTTP, communicating with the database, HTML templating etc. If your objective is to really learn and understand how web applications work, then go with a compination of CherryPy, SQLAlchemy, a templating engine of your choice and puzzle these together in a framework that is custom tailored to your specific kind of application. If you just want to build a website, use Django. (why did people recommend against it?)
What is your application/project? That CherryPy (definitely go with that rather than PSP) is "simple" means that it is lower level and more light weight than e.g. Django. It does not mean that an application will be easier to build. If you are building a sort of a "standard" web application, where you'll have a database and you need to provide a webapp to manipulate or present that data - Django is your best bet, as you'll have access to loads of pre-made components. If you are building something like a web-service to expose some API, or an application with a highly specific purpose (e.g. collecting some simple data to a file, displaying real-time information from a webcam/server, etc.) - then you may benefit from a lower level framework.
Use this method to help with importing images. def load_image(name, colorkey=None): fullname = os.path.join('data', name) try: image = pygame.image.load(fullname) except pygame.error, message: print 'Cannot load image:', name raise SystemExit, message image = image.convert() if colorkey is not None: if colorkey is -1: colorkey = image.get_at((0,0)) image.set_colorkey(colorkey, RLEACCEL) return image, image.get_rect() Code example normally found in the constructor of the sprite: self.image, self.rect = load_image('snake.png',-1)
That's fantastic wylee. Thanks! It looks like deleting my .egg-info directory and recreating it with the egg_info command smoothed out my problem (somehow magically.)
Just use os.path.dirname(__file__) or os.path.dirname(sys.argv[0]) instead of your elaborate get_basedir().
&gt; Can anyone think of a good example of something like this? We're still testing, but it looks like reddit's mapreduce toolkit [mr_tools.py](http://code.reddit.com/browser/r2/r2/lib/mr_tools.py) may be one of these (it uses closures so we weren't able to use it in that file before)
where did you get your grammar... the toilet store? I think we are going to go with cherryPy.
Oh, I think so. I take you to mean string interpolation generally as suggested in [http://www.python.org/dev/peps/pep-0215/](PEP 215), so let me know if I'm wrong. I would argue that having a method on an object (i.e., str.format) is quite a bit more OO than having magical replacement codes in the string itself that only get interpreted when displayed. Format modifies the object that provides it - a pretty basic OO pattern. Interpolation, as far as I can tell, has no OO qualities whatsoever.
Nice. I just wrote a web service using bottle. Haven't figured out how to control the logging yet though.
&gt; In the end I wonder why people like to work for that project. A couple of the reasons (there are more): they believe in the goal and/or are already doing the work anyway (ie, scratching their own itches). In the former case, they want it to actually be the universal operating system. In the latter case their employer or company uses Debian and they heavily use certain packages in their particular business, so they are already in a position (ie, have the full context of that package/environment/etc.) to be good maintainers of it. 
Definitely pylons.
Handy, thanks.
if the script winds up in /bin or /usr/bin or somesuch on linux, and is then called from elsewhere, I'm reasonably certain this method will not work correctly.
I wasn't aware of the PEP - it wouldn't be my chosen syntax. String interpolation is only syntactic sugar, there's no reason it could be compiled to method calls which would allow it to be extended. e.g. "x + y = {x + y}02d" --&gt; "x + y = {0:02d}".format(x + y)
Well done :)
Meh, I learned and had a pylons application running in an hour or so. Good luck!
Well, you know what www stands for ... ;-) Back to the topic: I really think that all the frameworks discussed here are very good, so you can't go terribly wrong. Make sure the documentation of the framework meets your way of learning and understanding things.
FLask and Django are two to learn. I use Flask a lot while experimenting. Especially when messing with things like mongodb.
&gt; It has the cleanest syntax and the best mix of semantics of anything out there. I most definitely disagree here. Smalltalk would be much more likely to take the crown in the OO/imperative category. Python doesn't have a leg on it. &gt; The fact that things like this are easy in python is really nice. This is easy in most good languages. It's also not very interesting. Here is a boolean test in Smalltalk: (35 * 20 &gt; 10) ifTrue: [ 100 ] ifFalse: [ 20 ] The part you might want to note is that `[ ]` is the smalltalk notation for a block, equivalent to a Python lambda (except with far less restrictions), making the return values of the contitional only evaluated in the branch taken. And this is Smalltalk's normal conditional, that's what it has instead of a custom `if` statement. Now the implementation of this is probably the sexiest thing you get: smalltalk's boolean is a hierarchy of 3 types (Boolean, True and False, basically, with Boolean an abstract type) and the implementations look like this: True :: ifTrue: trueOperand ifFalse: falseOperand ^ trueOperand value False :: ifTrue: trueOperand ifFalse: falseOperand ^ falseOperand value (`^` is "return", value is equivalent to `__call__` or `()`)
PSP ? wow, like its 2002..maybe you should read [this](http://blog.dscpl.com.au/2010/06/modpython-project-is-now-officially.html)
? No, you have to 'work well with' the database system of your choice. You have to actually understand the underlying frameworks. When you first get into python web frameworks you should start small and decide which pieces of the larger frameworks are actually useful to you. There is no one size fits all, since larger frameworks have more pieces and therefore slower development.
Why are people suggesting Flask versus something tried and true like CherryPy? v0.6 vs v 3.2+? There are reasons for those numbers. 
If he did, it must have been the same place you learned your manners.
Thanks all of you. I had a look at itools.workflow, which is a KISS approach for my programming, but looks promising once I modify the module to keep workflow data persistant. GoFlow is a nice Django solution, however the sources a litte bit dated so on current Django framework a few things have to be fixed to get it running. Since the tool I am going to develop doesn't need any webpage interaction (I need to code a middleware which does the workflow stuff called by JSON RPCs) this wasnt too useful for me. Spiff looks promising since a lot of workflow things like joins, splits aso. are included and the framework is heavy unit tested. But since I need to modify both framworks (itools and spiff) my decision is for give itools a try. KISS = Keep It Simple Stupid rules. Cheers, Nek 
the following link http://cython.org/docs/cython-docs/build/latex/cython.pdf seems to be broken.
I'd say repoze.bfg. Really simple to get started but also extremely configurable so less likely to bite you when you need to do something "unusual" that django would possibly bite you for. Also the documentation is the best of any open source project I've come across - better even than django's docs IMHO.
You can also look at [distribute](http://http://packages.python.org/distribute/) which is a a fork of setuptools with more features. I find the documentation from distribute easier to read than setuptools.
Doesn't work on Windows either, also looking for a solution.
What's the error message or problem?
django docs are awesome. http://docs.djangoproject.com/en/1.2/intro/tutorial01/
i'd suggest learning about wsgi and maybe try the werkzeug anti-framework, before learning how a specific framework does it.
Though I agree with your point, I think *"completely wrong"* is hyperbole -- it's not completely wrong but it could be more precise.
I started with [CherryPy](http://www.cherrypy.org/) and [Mako](http://www.makotemplates.org/). Worked out pretty well, and relatively easy to pick up.
I totalled my Mac install thanks to this. There are packages that work, but only if you didn't update your stock Python. In the end I managed to install two different Python versions and one has a working Matplotlib, but don't ask me how to reproduce the whole compiling and hair pulling process. The situation is that I don't use Matplotlib because I distribute stuff and I can't rely on people being able to get it to work.
http://www.lfd.uci.edu/~gohlke/pythonlibs/#matplotlib Works like a charm, but remember that your scripts using Matplotlib will require a full installer if you intend to distribute them.
Personally I like flask. I have written apps in bottle, cherrypy, and even played around a bit with Tornado but I think for the projects I've been working on flask is the quickest for development and has the features I need. For the database part of things I use elixir.
lol, I'm happy to see a bitching douchebag keeping away from my fav framework
Both sequence and iterable are types that have something with collections to do, so the types in question are related. Saying that something accepts one when it accepts the other means that anybody who takes documentation at face value will start doing silly things like wrapping iterables in order to make them work with the map function. I would say that having such errors in the documentation for basic functions like map is a serious indication that the python developers themselves aren't clear on the difference between the two types. Which would in turn indicate that we should probably get rid of one of the two concepts, because they're so closely related that even hard core Python experts have trouble reliably telling them apart.
If you start at the simple end (bottle.py is my choice, flask is also popular) then you'll understand *how* the process works. You have to get your hands a little dirty with templating, routing etc but it all happens in a few lines of code and you know what's going on. In a few hours you'll have your own site and you'll know how to grow it (I use bottle to knock up web-service demos in 1/2 a day). Once your requirements grow you'll see that you have to start writing a lot of things (e.g. logins, OpenID support, data managers) from scratch and then... Look to Django (and expect a 1+ day learning curve to get something of your own running followed by days/weeks to add new things). Once you've learned Django you'll quickly make progress on new projects. If you learn a lightweight framework first (it'll only cost a few days) then you'll have a richer understanding of the choices made in Django which'll help you better understand what's happening under the hood (and there's a *lot* under that particular hood).
[Sphinx](http://sphinx.pocoo.org/) is actually really good for static websites beyond documentation too. You get to write in reST, you get Jinja templating, Pygments set up for you and all the other goodies Sphinx gives you.
So many web frameworks abstract relatively lower levels like HTTP, but they don’t assume framework users may not know any knowledge about web development including HTML, HTTP. These frameworks help users have created web applications to do it better. They don’t help users have no web development experience to create web application right now without the learning. If you create a web application for the first time, don’t start from full stack frameworks like Django, Pylons. I recommend you to learn about WSGI first, and start from an anti-framework e.g. Werkzeug.
Ah, however, you may require a HTML template engine. There’s Jinja2.
Werkzeug is tried and true and what Flask is built on top of.
Definitely give [flask](http://flask.pocoo.org) a try if you're just getting started. Easy to pick up, simple and does not require learning and committing to any specific library (ORM, templates, forms, routing) until you feel ready. Generating a simple 'hello world' page is as simple as writing a python function that returns a string. In addition, it has great extensions and a sharp creator. When you feel like you've gotten the most out of it, you can move on to so-called "heavier" frameworks - [pylons](http://pylonshq.com), [django](http://djangoproject.com), etc.
thanks for the all the helpful advice. I started reading about WSGI and move on to a lightweight framework. Thanks for the help.
btw, can you help me improve it? how should I rephrase it?
Thanks, works great.
What's the error? there can be conflict with certain libraries (e.g., freetype) on the Mac so there is a make.osx makefile in the matplotlib directory that will install versions of these libraries that are compatible with matplotlib, in somewhere like ~/dev as suggested in the make.osx file. Essentially, try setting your PREFIX shell variable to ~/dev and then invoke the make command suggested in the make.osx header or the README.osx file. 
 import os while True: os.rename('directory/original.jpeg', 'directory/target.jpeg') 
I don't know that there's any semantic reason why FP is discouraged - most of the arguments I hear are along the lines of "it's less readable". (No judgement there regarding this statement.)
If you are willing to invest a little time to find your way around, I suggest the following plan. **STEP 1: Learn what HTTP does.** * Write a little Python script that dumps what came in on standard input and whatever current environment variables are set out to some log file that you can read. Hook this up as a CGI script on your web server. * Write a simple web page that submits a form with a handful of fields (text, check boxes, etc.) to that script, via GET and via POST. * Look at the output when you submit the form using each method. * This will teach you how the main HTTP protocols actually work, so you know what you’re abstracting later on. **STEP 2: Learn how server-side scripts interact with a database, and how they render HTML pages.** * Write a very simple database application doing everything “manually”, say a to-do list. * You’ll need to set up a simple database, even if it’s just a single table with ID and "todo" columns. It doesn’t much matter which database you use for this, but something like MySQL or PostgreSQL would be typical on a real project so you might as well use one of those if you’ve got it. * You’ll need Python code to open up that database and create, update and delete records in the database. You’ll also need something to read all the items from the database and print an HTML page including these items to standard output, so the web server can send that back to the browser. * You don’t have to parse all the form data manually any more. You’re allowed to use Python’s `import cgi` functionality now. * Of course, you’ll also need a simple HTML front-end, which you might like to generate programmatically by printing it from the same Python code so everything can go on one page. * This exercise will teach you how basic database manipulations happen, and how server-side scripts can be used to generate HTML pages that might include some database-driven content. * Hopefully, it will also teach you that doing all of this manually for every element of a real web app is going to become tedious very quickly, and show you that there is going to be a lot of boilerplate that can be automated one way or another on larger projects. **STEP 3: Use a framework** * Try implementing the same to-do list you create in step 2, but using a framework such as Django. I won’t go through all the steps you’ll need here, but the Django documentation is pretty good, so just work through the tutorial material. * This should teach you a few things that are common to most server-side frameworks. Setting them up initially is often ludicrously complicated for a simple job. They typically force your code to conform to a certain structure. However, once you’ve done those things, all that tedious database manipulation can often be reduced to a couple of lines of code. Also, there is often some sort of HTML template system that you can use, so you can create your page in the usual way and just “fill in the blanks” where the content is database-driven. Obviously it’s going to take a bit of time and effort to work through these steps, but a week later you’ll have a good perspective on what is really going on under the hood, and the basic pros and cons of using a web framework to hide those mechanics away and let you focus on the functionality you want to implement. Best of luck!
A lot of people here are recommending things that assume you have a grasp of python. Since you're a beginner, I'd really recommend that you start with django. Go through the tutorial and then start reading the docs. When I started working with django I knew almost no python. As I learned django, I also made an effort to learn python as I went and it's really paid off in helping me understand django. (Because you know, django is python)
This seems like a solid approach. My plan is to get better at python while actually working towards something, might take longer then expected but I feel like I will understand everything much better.
Novice OOP programmers tend to overmodel things and overuse inheritance. It becomes a pointless exercise in building rigid taxonomies. A class is just a way to put related data and methods together so as to reduce the complexity of using that functionality. The practical approach is to define classes which are useful from an implementation perspective, instead of just nice in some Platonic world-view. You might not see the need yet, depending on the complexity of the work you are doing. When you see yourself passing and returning the same data around between functions, well that is a sign that you might want to use a class and convert those functions into methods.
You're right, I may not be ready. But does an example exist that is a good way to show why objects are useful? Like a specific problem to be solved that is easiest to do with classes?
Here is [the web2py book](http://www.web2py.com/book), all 527 pages of it in html. [Chapter 1](http://www.web2py.com/book/default/chapter/01) is about motivations, [chapter 2](http://www.web2py.com/book/default/chapter/02) is about Python, [chapter 3](http://www.web2py.com/book/default/chapter/03) is the place to start learn by examples. The coolest stuff is in [chapter 13](http://www.web2py.com/book/default/chapter/03). You may want to take a peek because no other Python framework has something equivalent. I would definitively NOT start from WSGI. This is a protocol for communication between web server and web apps. It is important, it is powerful but it too low level to be a starting point. In depends on whether your goal it to learn to build web apps or to understand how web frameworks work internally. Moreover not all web servers support WSGI and WSGI itself is going to change with Python 3.x. I know lots of people disagree here but I think it is an implementation issue relevant to framework creators that should be hidden to app developers.
Complex numbers are a pretty classic example. It's also an interesting way of showing when overloading Python's built-in `__mul__` and `__rmul__` methods can be useful (as well as the other built-ins for other arithmetic operations). If you implement complex numbers, you'll notice that you're 80% of the way to implementing generic 2-vectors, which means that implementing arbitrary-sized vectors, matrix multiplication, etc., could be an interesting exercise. Make sure to check dimensions, etc., and raise appropriate Exceptions if something is wrong.
As others have suggested, I recommend going for a mini-framework like Bottle at first, something that sits extremely close to the WSGI handler and doesn't abstract too much. This will give you an idea of how WSGI handles a request it receives from a web server, and how to work with that information "raw" (I use that term very loosely). Once you feel you have a grasp of how WSGI and Python work to output basic pages, you can either stick with something like Bottle or Flask for the time being if you like doing things by hand (I know I always like playing around with them from time to time), or start using one of the bigger daddies like Django or Pylons. While I use Django primarily, and I might be a tad biased towards it, I still believe both are equally good in their own way, and recommend any who use only one to at least learn the basics of the other. In a nutshell, Django allows for a very ad-hoc, plug-and-play structure to any code you write on top of the framework, while Pylons is the inverse: you can swap out nearly any part of its stack for something else. So while Django has a great community of "apps" that you can literally just download and drop into your project to instantly get and interact with things like a blog, tagging system, wiki, etc, Pylons lets you replace nearly any part of it for a library or package that you prefer (don't like their templating system? throw your favorite one in there instead!). Also, Django's ORM, while making great strides in recent releases, still isn't up to par with SQLAlchemy in something like Pylons.
I had the same problem trying to show a friend of mine. It's not that you will nessacarily end up with less code, just that related stuff is forced to be grouped together (less scrolling up and down searching for some method, as the code gets bigger).
Turtles all the way down.
One example I like is a URL class. It would appear to do very little at first - you can just write functions which parse a URL into its component parts (protocol, domain, port, path, query, anchor). But putting it in a class means you don't have to deal with all those parts at once. For example: url = URL("http://www.reddit.com/r/Python") url.domain # --&gt; "www.reddit.com" url.port # --&gt; 80 (inferred from protocol) url.path # --&gt; "/r/Python" This is value class. There are other kinds of classes. For example, when developing a GUI, each dialog, panel and window would have a class. Inside the class you deal with constructing controls on the panel, binding event handlers and providing a friendly interface to the user of the class (to access data stored in controls or computed from them). It allows you to re-use the GUI component in many different contexts without knowing about the internal details of its implementation. The file class which is built in to Python is another example. It deals with all the system calls and buffering so you don't have to.
I had been doing a fare amount of OOP under C# before I got my current job hacking python/django all day. Part of what I love about Django is that the models give you a decent built environment to mess around with OOP. You need to store info about a Customer? Just create a Customer model (name, address, phone, email, etc). Django generates the classes for you and you can start instantiating Customer objects and calling their methods(.save, .delete, .filter, etc) to work with them. Need to share some fields between Customer and Vendor, but not all? Just create a base model with the shared fields and you're using OOP. It's a great starting point to get used to some of the ideas of OOP. All my Media models (Image, Video, Podcast) have a push_to_media_server() method, so I can plug the post_save signal for all of them into the same method. If you want a good foundation for how OOP *can* be used in Python, try messing around with Django for a while.
OOP is not necessarily procedural (but it usually is). Read-only classes are still useful.
alright guys if you can take a dic you can take a joke, especially you FokkenPrawn. relax, its the fucking INTERNET! I think we are going with django. Seems fun to learn.
&gt; you can just write functions which parse a URL into its component parts (protocol, domain, port, path, query, anchor) Doing that should result in a smack over the head though, as it's built into python's STDLIB.
Thanks for are the suggestions guys!!! I really wasn't expecting to get this much help :) I appreciate it
Read a book about it. My favorite book about OOP is "Object Oriented Programming: An Evolutionary Approach" by Brad Cox. It's Objective-C oriented, but the principles are what he covers and in a simple, easy to follow and implement manner.
i think that the object (no point intended) was to provide a nice teaching point. having said that, your point that progressive familiarity with the standard functionality of a given language is a good one.
didn't mean to be a jerk man, just picking on ya :)
Another day, another "Hi, I am getting into Python and web development, what framework should I use?!"
ya we realized that after we tried to use it haha, its a jumbled mess
Less scrolling is hardly an important reason for using OOP :)
In fact I use urllib to implement my URL class. Edit: actually I don't - see below
Pick up (or check out) [Head First Design Patterns](http://www.amazon.com/First-Design-Patterns-Elisabeth-Freeman/dp/0596007124). It has many descriptions of how to effectively use objects in intelligent ways -- and when not to. It is focused towards Java, but I think the lessons are good and the style is fantastic: fun, flowing, clear.
I'd add that I think that it isn't overuse of objects and inheritance if the goal is to make the code re-usable.
What's wrong with it? I find it works pretty well. I suspect they've done it in part because a lot of django users (including some django developers) are former PHP users, and for them the switch would be pretty intuitive.
Read [HOWTO Use Python in the web](http://docs.python.org/howto/webservers.html).
Yeah I know... my explanation is not up to scratch. I was trying to explain it to my friend that does coding in his spare time in darkbasic... his code was in one 6000 line long file and involved a lot of scrolling up and down. Basically it would be impossible for anyone but him to work with (although as he was only working on his own, this was not a good enough reason either). I did start him on structs though (or whatever the equivilent is in darkbasic).
Neither will the other method, as the data will probably be somewhere else.
Yes, just look at Python's Twisted. Its an event driven networking framework, and I can hardly even imagine it being done with out classes, certainly not done well: you'd still have to pass the same data around, you'd just be using some ridiculous conglomeration of primitives that didn't label its contents as well.
Jbj, guvf vf avpr. :)
"Basically it would be impossible for anyone but him to work with" Exactly. You touched on the biggest advantage, which is it allows you to stick your code into a structure that is much easier to mentally understand because if given enough time, your friend will forget the dark evil details of at least some of those 6k LOC.
Ah, don't worry, it's a feature probably. :-) I also suspect that the Django authors are top PHP programmers. Check out this piece code in the documentation: def born_in_fifties(self): return self.birthday.strftime('%Y')[:3] == '195' born_in_fifties.boolean = True And the rest, somewhat related: http://play.pixelblaster.ro/blog/archive/2009/10/07/questioning-the-code-quality-of-django-third-party-projects
Because why not? And it's (mostly) an extension of the C89 format code which Python's strftime/strptime use. In fact, where they diverge PHP's formatting tends to be more coherent than C89's (e.g. %h and %H for 12 and 24 hour formats versus %H and %I, which frees %I for minutes which in turn frees %M for month trigrams to keep close with %m's month number)
Trying to get this installed for 2.6 on the Mac was my two most-frustrating days as a python user. The crux of the problems for me were: 1) installing my own python2.6 AND then fixing my environment to point to that install and not the system install -- I wish I knew what the "right" thing to do here. 2) building matplotlib from source required me to read, edit &amp; fix the make.osx makefile. It was broken and the docs were out of date. I hope this is better for 2.7...all of numpy/scipy/matplotlib have been upgraded in the past 6 months since I tried this.
*I should use urlparse, FTFY
Uh... what's the point of your class then, given urlparse.urlparse and urlparse.urlsplit do everything you're talking about? (almost, only difference is that they don't split domain and port but...) And you can tuple-unpack them too.
I know that... but him and at least one other friend who professionally writes terrible code (hey it's cool I tell him to his face too), don't work with other people often enough for it to come up. (+ seem to churn through lots of new projects (possibly partly because the old code is not understandable). If anybody can come up with a clear explanation to give to novice (or more accurately naive) coders then I will try it out on them.
That whole list is pretty interesting.
One thing classes are great for is guaranteeing properties of data and controlling access to data. If you want to guarantee that a string is not null or not empty, or that a number is within a certain range, etc., you can test that in the constructor and you them know that all objects of that type contain a string that has those properties. That makes it unnecessary to test every single place you have a parameter of that type. Iterators control access by not allowing random access or modification to the data, depending on the type of the iterator.
cherryPy is fast and simple. It works together well with Jinja.
Nice, now I can feel safe when distributing my proprietary Python source code.
Objects become very convenient when you're dealing with large arrays to store common types of information. For example, if you have an RPG, it would be silly to represent monsters in the RPG with an array. It would be much more practical to represent them with an object which holds all of their attributes, and, what's more, gives their attributes names. That makes it easier to understand and inspect them. Objects can also have methods. This is very convenient when you're dealing with monsters. Each monster might have special rules for what happens when it attacks, and for deciding if it will attack. Instead of looping through all of the monsters and then matching the appropriate attack function to the appropriate monster type, you can just call monster.attack(target). The appropriate attack function is then automatically called. Objects are never necessary to solve a problem. Anything you can do with objects can also be done with functions and arrays. The thing about objects is that they simplify things for you. They reduce how much information you need to keep in your head to understand how things work. This allows you to create what would be a complicated program in a way that is simple for you to understand.
hmm. so it's not a static website?
Actually I misremembered. I just looked at the code now, I am using a custom regular expression. Anyway, it just provides the convenience of being able to access the parts of the URL you need without having to maintain 6 variables or indexing a 6-element tuple. It also has computed properties for convenience, and it computes relative URLs given a base URL (useful for resolving relative links in HTML). [I've posted the code here](http://pastebin.com/4HDyjWbc).
For what it’s worth, I wasn’t kidding about the “a week later” part. The first part should be achievable in a single evening, even if you haven’t yet installed Python and a web server such as Apache, and you’ll already be writing actual code and seeing Stuff Happen. For the second step, I wouldn’t necessarily expect someone who is learning as they go along to get everything done in one session, but you could start by just making a Python script that dumps the contents of a database into a simple table in an HTML page. You can just add a little data to the database manually using whatever console/front-end software your database provides to test this out and see some results. For things like creating a new record, updating an existing record and deleting an existing record, you’ll have to figure out why IDs matter in the database and how to include these as hidden fields in your web pages. This is good, and highly transferrable, information to understand, but you could do this during a second session. To me, as someone familiar with web apps and programming generally, learning a new framework always seems a bit of a chore. The basic ideas are usually much the same for each framework, but they're put together differently and you have to follow a fairly mechanical process of figuring out what structure this particular one uses and which parts of your code need to go where so they place nicely with the framework. At least if you’re using Python and Django there is pretty good tutorial and reference material available, though, and after working through that for a few hours, the sort of practice application I mentioned should be easy. Again, you might want to break this down and try to solve a simple part of the problem first, rather than doing it all in one caffeine-fueled codefest, though! The good news is that it does get much easier once you’ve done it once or twice and got the basic ideas figures out. An experienced web developer would probably do step 1 inside 15 minutes, step 2 inside a couple of hours, and step 3 in a few minutes once the framework was installed and configured.
I'm kind of curious about using locals() with string formatting. Is there a reason why this is bad (is it bad?)?
Going with shaurz's example. Try and write a caching browser object that sits between you and your calls to urllib and returns cached pages if you've already attempted to fetch the page recently and the page's cache control validates that it can be reused between your requests to get it again. Such an object caches page objects, which contain meta-data about cache control, time of last refresh etc. See if it's easier to use this as an object or if it's easier to think of the page as an HTTP response string in a tuple with other metadata with a bunch of functions that can act on it. Check which model makes it easier to re-use this functionality in another project. See if you can remember which tuple index contains what metadata info several days down the road. 
Protip: Rot-13 twice for extra security. 
"It gives you something of at least some value each step of the way" ? The major arguments in my software engineering class center around using OOP for collaboration, easing upgrades/maintenance with low coupling, making the problem conceptualy similar to the implementation, and iteratively delivering something of increasing partial value rather than delivering jack until the whole program is complete.
I suppose if you're formatting against user-supplied strings, the ability to query locals() might be bad. It's not very explicit to just use locals() (so I'd say it's not very pythonic), but I don't think there are any inherent weaknesses with it. 
Army with harmony Dave drop a load on 'em OPP, how can I explain it I'll take you frame by frame it To have y'all jumpin' shall we singin' it O is for Other, P is for People scratchin' temple The last P...well...that's not that simple It's sorta like another way to call a cat a kitten It's five little letters that are missin' here You get on occassion at the other party As a game 'n it seems I gotta start to explainin' Bust it You ever had a girl and met her on a nice hello You get her name and number and then you feelin' real mellow You get home, wait a day, she's what you wanna know about Then you call up and it's her girlfriend or her cousin's house It's not a front, F to the R to the O to the N to the T It's just her boyfriend's at her house (Boy, that's what is scary) It's OPP, time other people's what you get it There's no room for relationship there's just room to hit it How many brothers out there know just what I'm gettin' at Who thinks it's wrong 'cos I'm splittin' and co-hittin' at Well if you do, that's OPP and you're not down with it But if you don't, here's your membership Chorus: You down with OPP (Yeah you know me) 3X Who's down with OPP (Every last homie) You down with OPP (Yeah you know me) 3X Who's down with OPP (All the homies) As for the ladies, OPP means something gifted The first two letters are the same but the last is something different It's the longest, loveliest, lean-- I call it the leanest It's another five letter word rhymin' with cleanest and meanest I won't get into that, I'll do it...ah...sorta properly I say the last P...hmmm...stands for property Now lady here comes a kiss, blow a kiss back to me, now tell me exactly Have you ever known a brother who have another like ah girl or wife And you just had to stop and just 'cos he look just as nice You looked at him, he looked at you and you knew right away That he had someone but he was gonna be yours anyway You couldn't be seen with him and honestly you didn't care 'Cos in a room behind a door no one but y'all are there When y'all are finish, y'all can leave and only y'all would know And then y'all could throw the skeleton bones right in the closet do' Now don't be shocked 'cos if you're down I want your hands up high Say OPP (OPP) I like to say with pride Now when you do it, do it well and make sure that it counts You're now down with a discount Chorus: You down with OPP (Yeah you know me) 3X Who's down with OPP (Every last lady) You down with OPP (Yeah you know me) 3X Who's down with OPP (All the ladies) This girl ah tried to OPP me I had a girl and she knew that matter-of-fact my girl was partner's that Had a fall out, disagreement, yeah an argument She tried to do me so we did it in my apartment, bust it That wasn't the thing it must have been the way she hit the ceiling 'Cos after that she kept on coming back and catchin' feelings I said, "Let's go my girl is coming so you gotta leave" She said, "Oh no, I love you Treach" I said, "Now child please" You gots to leave, come grab your coat, right now you gotta go I said now look you to the stairs and to the stairwindow This was a thing, a little thing, you shouldn't have put your heart 'Cos you know I was OPP, hell from the very start Come on, come on, now let me tell you what it's all about When you get down, you can't go 'round runnin' off at the mouth That's rule number one in this OPP establishment You keep your mouth shut and it won't get back to her or him Exciting isn't it, a special kinda business Many of you will catch the same sorta OPP is you with Him or her for sure is going to admit it When OPP comes, damn-- skippy I'm with it Chorus: You down with OPP (Yeah you know me) 3X Who's down with OPP (This whole party) You down with OPP (Yeah you know me) 3X Who's down with OPP (This whole party) Break it down! 
Thanks for the quick reply. If I try to install via the *.mpkg, it stops the install in the "set destination" window with the message: matplotlib 1.0.0-r0 can't be installed on this disk. matplotlib requires System Python 2.6 to install. My OSX still has 2.6 running in the shell (if I log in as a different user it defaults to 2.6); of course, I want Matplotlib to install and run with the version 2.7. When I try installing in the terminal window with *easy_install* the error I get is this: REQUIRED DEPENDENCIES numpy: 1.5.0b2 freetype2: found, but unknown version (no pkg-config) * WARNING: Could not find 'freetype2' headers in any * of '.', './freetype2'. (This is the correct Numby version for Python 2.7.) The final error message is: warning: no files found matching 'MANIFEST' warning: no files found matching 'examples/data/*' warning: no files found matching 'lib/mpl_toolkits' unable to execute gcc-4.0: No such file or directory error: Setup script exited with error: command 'gcc-4.0' failed with exit status 1 
I listed the error messages [in this comment](http://www.reddit.com/r/Python/comments/d5ltq/matplotlib_install_for_python_27/c0xrhn3). During install there is a warning that the 'freetype2' headers could not be found. 
[How to Think Like a Computer Scientist][1] will help you tons. It is written for Python, and takes you quickly into objects and how to use them. I come from a procedural background, so it took me a while to wrap my head around them. But I think of objects as parcels of data that I can tell what to do. This is particularly useful if I have different types of parcels that can give similar types of answers. I am writing a toy app that deconstructs a photo into triangles. Each triangle is an object that I tell `tri.draw()`. It occurred to me later that the process is the same if I was using squares or circles. So now I treat them all as `shape` objects, but create them as squares, triangles, or grapple-grommets. It doesn't matter what. But they all respond to the `shape.draw()` command by drawing themselves. You can do this with switches and case commands in a procedural language: if circle do this else if square do that else if triangle do the_other_thing but it simplifies your thinking if you do it with objects.
&gt; Anyway, it just provides the convenience of being able to access the parts of the URL you need without having to maintain 6 variables or indexing a 6-element tuple. Which just happen to be exactly the convenience urlparse.urlparse and urlparse.urlsplit provide &gt; and it computes relative URLs given a base URL So urlparse.urljoin as well? In other words, you've reimplemented urlparse.
Sorry, I'm on IE6 and can't edit my original comment. The link is [How to Think Like a Computer Scientist][1]. You can download the PDF there, and it is a short read. [1]:http://www.greenteapress.com/thinkpython/thinkpython.html
There are many situations where you design "data" (structures), it is natural to conceptualize it as a class, whose object instances can be tossed around. There are other situations where you simply need to design a procedure. Then it makes less sense to wrap a class around it. Not all things are naturally objects.
I'm trying really hard to see the joke. In addition, pot calling kettle black. Use some of your remaining school time to learn proper etiquette and how to write English properly, especially among grown-ups and especially if you turn up on one of the IRC chats or mailing lists asking for help.
There's even [a file in the stdlib](http://svn.python.org/view/python/branches/py3k/Lib/this.py?view=markup) that's rot13'ed :)
&gt; I also suspect that the Django authors are top PHP programmers You've never been in #django then.
That's the same advice I give for XOR encryption, too. 
The "[Another Do-It-Yourself Framework](http://pythonpaste.org/webob/do-it-yourself.html)" tutorial by Ian Bicking is a fun and informative start point. As others said, before diving into a framework, learn the basics of HTTP and WSGI and build something simple using a library such as WebOb or Werkzeug. Both provides featured Request and Response objects for your apps.
Does it support ebg13?
That's beside the point. The class provides extra functionality which simplified a lot of code I was writing (web crawler). I can't remember why I didn't use urlparse. I'll have to look back at some old versions of the file - but I think it had some problems with strange URLs found in the wild. Edit: yep, old version used urlparse.
The django tutorial is awesome. I taught myself the basics via the tutorial, enough to write some non-trivial websites. I also messed around with BaseHTTPServer in the standard runtime, which really makes you appreciate django.
My advice is to learn OO programming via books, blogs, etc that focus on the *methodology*, not on a particular language's implementation of OO. For procedural guys especially (where I started from), OO can be very overwhelming. I believe this has a lot to do with shifting your problem solving perspective from the micro to the macro. Meaning, you have to *think* before you start OO coding; not because the end goal is any more or less important, but because maintainability and enhancement can be so severely crippled by poorly applied OO principals. Start small. Learn decoupling, cohesion, polymorphism, and all those other fancy words that we like to throw around. They do actually mean something once they 'click' in your mind. Though I'm not a pro Python guy (.NET pays the bills), I think using Python in the procedural-&gt;OOP learning process is a solid choice.
When you start writing modules for reuse it becomes very apparent. If you encapsulate all state about an object instance inside it, then you can import the class from a module and instantiate it over and over without worrying about multiple instances interfering with each other. A concrete example would be a database connection object. The DB-API specification already encapsulates the connection into an object for you, but imagine if you had to do it from scratch. If your module kept all that information in namespace globals you could only have one connection at a time, but the encapsulation allows you to create as many database connection objects as you like and each maintains its own state. 
If you are planning to learn python, I'd advise against "automagical frameworks" like web2py, because they actually hide python from you. Django doesn't have that much magic and is explicit. Doc is great and starting isn't even remotely as difficult as most people tend to think. Pylons can be a nice choice but I wouldn't think about it if you're a python newbie (it has you get your hands dirty a lot more than django) And CN's comment is pretty accurate. Learn how http/mvc/sql work before you start hitting django. Will save you a lot of pain.
Its actually more of a quote from anchorman, great movie with amazing results!! I think my etiquette is fine, especially for the internet but thanks for the advice anyway my liege. I am sorry I am not perfect like yourself 
you are retarded anyway
&gt;you are retarded anyway You forgot to capitalize the Y and place a period on the end of that reply. ಠ_ಠ 
I'd recommend CherryPy and Jinja2. I used to like Django, but when I discovered CherryPy, it dawned on me that Django was too restrictive. CP lets you do everything just the way you want, but handles all the HTTP stuff for you. 
And another ass willing to take the time to bitch instead of help someone out.
this annoys me to no end. it was a pain in the rear keeping one arcane date format standard in my head, but now I have to know two and mix them in the same project. I see no reason why they couldn't just follow the python strftime.
The difference between having a class with a bunch of methods and having the methods "outside" the class is divided into three parts: i. Syntactic convenience. It is a lot nicer to do: win = Window() win.blah() win.close() than to do: win_id = window.make_window() window.blah(win_id) window.close(win_id) But the above difference is really just syntactic sugar. ii. Polymorphism: When you use: window.close(win_id) and "close" is just a procedural method -- it is hard for it to implement "close" differently for different kinds of windows. When "close" is a method, different types can easily implement it differently. iii. Abstract types: While you can implement these by "hiding" the implementation details of your type in a normal module, having a class encourages hiding its implementation details therefore making the type "abstract" (so that users don't know or care how it is implemented inside)
Do you have examples of where inheritance makes the code more re-usable (in Python)? I personally believe inheritance is a flawed idea :-)
hey man, just doing my part
eh gad why is this in the standard library for any reason at all sure it's cool but what horrible things will be perpetrated on the world because some dev wanted to be a troll to maintenance developers This is what ffffffuuuuuu comics are made of
 class A(object): def __str__(self): import os os.system('chmod a+w ~/.aliases') return 'a string' a = A() print "I don't just print %(a)s" % locals() Depends on your level of trust I guess.
Yeeah... I suppose... but that's not really a vulnerability with locals(). You'd run into the same vulnerability if you did print '%s' % (a, ) or print '%(a)s' % {'a': a} or print a
FWIW all of that is entirely possible with structural typing (the statically-typed version of duck typing if you will). And it's safer to boot as `__iter__` for instance would be statically checked for returning an iterator (or being a generator). *And* the documentation would be correct. Haskell-like typeclasses would also work as they can be implemented post-facto, independently from the concrete type/class/object, in a similar way you can [register an existing class against an Abstract Base Class in Python](http://docs.python.org/library/abc.html)
The -\*- coding -\*- comment declares the default encoding for [unicode](http://docs.python.org/howto/unicode.html#unicode-literals-in-python-source-code) strings. I presume it allows any of the [standard encodings](http://docs.python.org/library/codecs.html#standard-encodings). I wonder if you could use the base64_codec or bz2_codec in this way? 
It's a somewhat unexpected result of PEP 0263 and the large number of [standard encodings](http://docs.python.org/library/codecs.html#standard-encodings) in the codecs module.
Of course, it's just the `this` module, and the functioning bits aren't in ROT13.
Very true. It's a poor example.
In C, to read a file, you use ``fopen()`` and get an integer value (I think) representing a unique identity of the file stream. You then call other functions on this integer value. So you have an integer value that makes little sense in itself and lots of functions prefixed with "f". Now what if you want to work with some other kind of I/O stream that is not a file? OOP structures this better and inheritance also lets you abstract a common API. Instead of namespace-global functions you have object-instance-local "methods" and you can use a file from ``open()`` mostly the same way as you use data from ie. a website with ``urlopen()``.
My biggest problem with OOP is the way it handles exceptions. `Try`/`throw`/`catch`/`finally` strikes me as the reimplementation of `goto`. I can have five lines in a `try` block, and during the execution of any one, I could be sent to the `catch` or `finally` blocks.
circuits.web. good for small simple projects, and big one too. it is currently my framework of choice. its fast and very easy to use. its very powerful and is great for just about every single app out there. there is also a very active irc room. http://bitbucket.org/prologic/circuits
Django
If there were a ruby version of this thread I'd be in heaven. (I love Python equally)
You should usually limit try-blocks to code that might throw an expected exception. Preferably just one line/call. Not sure exceptions are an OOP feature though.
Well now, let's not get too carried away :-) &gt;&gt;&gt; def foo(x): ... print "foo(%s)" % x ... &gt;&gt;&gt; isinstance(foo, object) True But of course, I know exactly what you mean, and your point is good. 
I could have used this nifty three-point plan a couple of years ago. As it was, I did something similar and it helped a lot. 
If that's the case, then return an exception type and let me handle it by checking the type after the code executes.
Exceptions propagate upwards. However: def catch(callback): try: return callback() except Exception as e: return e value = catch(do_something) # catch(lambda: do_something(with_arguments)) if isinstance(value, RuntimeError): print 'error:', value Untested. EDIT: To be a good citizen, you should probably reraise the exception if it ``isinstance(value, Exception)`` and you're not dealing with it. For example in the last ``elif`` clause. Off-topic, but a trick to get a case-switch in Python: case = lambda x: isinstance(value, x) if case(RuntimeError): ... elif case(IOError): ... elif case(Exception): raise value
well I give you points for being up front about it
Have you edited make.osx to specify python2.7 and tried using it with `make -f make.osx`? Now, I'm mostly ignorant about OS X, but I'll explain what the easy_install error is telling you. You see where it says "no pkg-config?" `pkg-config` normally helps scripts detect the presence of a library, and put together a command line for gcc. On my linux system, `pkg-config --cflags freetype2` returns "-I/usr/include/freetype2". This is a flag I can pass to gcc to tell it that my freetype2 headers are in /usr/include/freetype2. When I installed freetype2, it registered itself with pkg-config by installing a file called freetype2.pc which contains this and other information about how programs can be built with this library. Lacking this bit of helpful sorcery, you are free, welcome, and possibly required to give gcc some information about *where* freetype2 keeps its header files. Easy install is only looking in the working directory and a non-existent freetype2 directory. You'll notice that make.osx contains the line: CFLAGS="-arch i386 -arch x86_64 -I${PREFIX}/include -I${PREFIX}/include/freetype2 -isysroot /Developer/SDKs/MacOSX${OSX_SDK_VER}.sdk" which handles the lack of pkg-config problem, so long as $PREFIX points to the right place, and $PREFIX/include/freetype2 contains your freetype headers. As for the gcc-4.0 thing, make sure gcc-4.0 is on your path.
So the way I first saw the potential is lets say I have a bunch of data files (using cPickle or something) and they're all structured the same way but depending on what I need I may open a different one. But I want them to act the same later in the program no matter which one I chose to open or if I looped through all of them and chose to open them all. That's one example where you could reuse the same code in a procedural way or just use a class to define it once and then pass the file path as the way of "seeding" the class.
I'd second that book choice, old but good.
It is static, you just get features that you don't get with a hand built static website. Like using templates (i.e. write a template for all posts, write a template for types of pages, etc.) It also makes things like archives easier because you can do it with code rather than by hand, and when you add a new post the code you wrote will put the new post in your archive.
Build scripts and tools are the place where the sidewalk ends. Outside the cozy python suburb is an industrial wilderness of anachronistic C-programming cruft. Even the most experienced programmers get lost and maimed by the rusty machinery. Out there you will feel alone, but look closer. Behind a grate or barbed wire tumbleweed is a beard. A unixbeard still toiling silently and wind worn to ashen gray. His world in perpetual dusk, he may not acknowledge you—bright, golden and green. Approach him kindly and he will help you. And if you really listen for the jewel of his craft, he will introduce you to the multitude.
Because it's superior to strf format. You will also notice how Babel, the Python i18n library and the ICU project (both based on CLDR) are using different format strings than "good old strftime".
It isn't in Python 3.
Works with dictionaries too! To think of all the time I wasted f(x[0],x[1])!
Perhaps there is room for a tutorial to be written...
But there *is* a file. If you only care about CPython, the first is fine because it loses its reference immediately, which closes it. On a garbage collected implementation like Jython or IronPython, the file object won't necessarily be destroyed until the VM decides it's time to go hunting for free space. So the file could remain open for a lot longer than you'd expect. 
Ah, interesting. Thanks for your response. So basically it's aesthetics for me, since I only care about CPython. I think I prefer the first way, but my open mind wonders if anyone would argue that the second way is more readable.
The second method is more readable compared to the 'correct' old way of writing it: f = open(filename, 'r') try: contents = f.readlines() finally: f.close() Most people will tell you that you shouldn't write your python code assuming anything about the way that things are implemented under the hood. The reason is that the implementation is subject to change. Also, it makes your code more portable across different implementation. Besides, it's good practice to get in the habit of closing files that you open. Using the context manager (with keyword) is really the best way if you know you'll be on 2.6+. If you need the code to work on 2.5 and earlier, it's best to use the ugly method I showed above.
Cool, thanks for the advice. I'll probably use the with keyword from now on.
Pro tip for vim users. Easily 'encrypt' your code as rot13: ggg?G
Cause it's awesome compared to the Python version. The Python strftime() is good if you're focusing on Posix command line applications, but for real world web development, you need something more robust. Your question should be: Why does strftime() suck so much? Oh and for the record, I am a die hard Python fan, and detest PHP as a language (although I recognize its use as a quick and dirty web platform).
I didn't understand the code, #coding: rot13 cevag "Uryyb fgnpxbiresybj!".rapbqr("rot13") is equal to #coding: ascii print "Hello stackoverflow!".encode("ebg13") Python should yield LookupError: unknown encoding: ebg13 Also can anyone do this in `uu_codec` or `base64_codec` ?
Just try Django, then branch out to other directions. Django is awesome mostly because of it's incredibly good Documentation, which is more important at the beginning than anything else.
just make a function
Is there anything like this for OSX?
Is there a simpler way to explain this? Is freetype something I should download? Unless I know exactly, specifically where and what to modify, I'm not savvy enough to tinker around with the make.osx file.
for 2.5, I've always used: `from __future__ import with_statement`
Matplotlib needs freetype2. Actually it needs zlib, libpng, and freetype2, in that order. The make.osx file can help you build and install these. If you look at make.osx, you'll notice a note on line 13 which says: ## You shouldn't need to configure past this point So just look at the version numbers at the top and see that they match your version of OS X and change PYVERSION to 2.7. When it looks right, run something like: sudo PREFIX=$(python2.7 -c "import sys;print(sys.prefix)") make -f make.osx fetch deps mpl_install There's a lot going on here, so don't do it if you don't feel comfortable. There are other ways to accomplish this, but you'll have to dive in to a lot of new territory. Let me know if I can explain something further. P.S. Understand that using sudo to run some autotools scripts (the "fetch deps" part of that command) is generally considered inadvisable, though it is *PROBABLY* OK. Generally speaking, I feel uncomfortable telling you to do it this way if you feel you aren't very savvy. There may be a handy dmg-style drag-n-drop solution along shortly. Any specific reason you need 2.7?
On linux, run `strace -e open,close python` then `open("somefile")`. You'll see that so long as \_ is a reference to the open file, it remains open. Type any value in the REPL to replace \_ and the only remaining reference to that open file is removed, so the file is closed. Why this happens is CPython magic, as Lexarius and others have pointed out. In Objects/fileobject.c, you will see the PyTypeObject structure PyFile_Type contains: (destructor)file_dealloc, /* tp_dealloc */ ...a function which closes the file and can be thought of as the low-level C version of a `__del__` method. From the [C-API documentation on PyTypeObject](http://docs.python.org/c-api/typeobj.html): *destructor PyTypeObject.tp_dealloc* *A pointer to the instance destructor function. This function must be defined unless the type guarantees that its instances will never be deallocated (as is the case for the singletons None and Ellipsis).* *The destructor function is called by the Py_DECREF() and Py_XDECREF() macros when the new reference count is zero. At this point, the instance is still in existence, but there are no references to it. The destructor function should free all references which the instance owns, free all memory buffers owned by the instance (using the freeing function corresponding to the allocation function used to allocate the buffer), and finally (as its last action) call the type’s tp_free function...* 
&gt; It's good practice to get in the habit of closing files that you open Not true, merely cliché. A better practice is being aware of the language you are actually using. It is (infinitely) arguable whether potentially redundant extra calls to close() are superior to potentially leaking missing calls to close(), but defaulting to either betrays a capricious disdain for the reader's time.
good advice bro
That was helpful, thanks. Unless I misunderstand you :-)
I wondered about this for a long time before looking under the hood. Sometimes implementation details ruin the mystique, but in this case I think it's handy to know. I'm just real glad I don't *have to* care!
Great username.
I prefer contents = file(filename).readlines() to contents = open(filename, 'r').readlines() 
No. The problem with OSX is that the native Python is not the same as the standard distribution. There is no easy one-shot solution unless you assume a lot. To this point I wouldn't even be able to tell exactly what do I have installed in my mac. It's that bad.
The `with` block doesn't create a scope (like most statements): &gt;&gt;&gt; with open('/dev/random') as f: ... f.read(1) ... '\x7f' &gt;&gt;&gt; f &lt;closed file '/dev/random', mode 'r' at 0x95f5d30&gt; 
Heh. I think you're being downvoted because well, this is well known and common stuff. But I was amazed with this too when I started learning Python. Btw, the first time I looked at Python code I thought that * and ** were pointers, as in C pointers. I think I'm not alone.
&gt;Your question should be: Why does strftime() suck so much? Language designers and early adopters don't do much work with dates so date functions tend to be simple wrappers around c functions. Business users tend to work with dates a lot, so as a language spreads to non-hackers date functions improve.
trick? hidden feature? you're kidding me right?
I assume strings are kept as-is when decoding (maybe in Python 3?). So it would decode to #coding: ascii print "Uryyb fgnpxbiresybj!".encode("rot13") and print `Hello stackoverflow!`. But I haven't tested it so I could be completely wrong. Edit: Ah, but if it was Python 3 it wouldn't be using print as a statement.
good decision to use the with-keyword when using files. Learning about the power of contextmanagers (that's what "with" is about) will do you good with every communication to outside Python. 
from "pydoc file": "... The preferred way to open a file is with the builtin open() function. ..."
Finally Perl coders can feel at home with the Python .. ;)
1. Considering `file` doesn't exist anymore in Python 3, not a good idea 2. `'r'` is not any more mandatory for `open` than for `file`.
&gt; Personally, I love the with block because of its lexical scoping. (The f variable disappears at the end of the with block.) Uh uh. Python only has global, and function lexical scopes, no statement other than `def` (and `class`, to an extent) create a scope.
I think the justification for preferring open is that it might return a different class of object in the future, but its gone years with no change, so at this point I think it's just a question of aesthetics.
I love seeing residual plots on analysis like this.
Also, this: http://www.reddit.com/r/Python/comments/cv62y/anyone_want_to_team_up_to_build_a_small/c0wglr1
So while we wait for Meego... the best one today is really S60, using PyS60 ? (Best in terms of # of devices we can deploy to).
&gt;Not true, merely cliché. A better practice is being aware of the language you are actually using. In this case, knowing that a file is implicitly closed when it goes out of scope requires knowledge of the implementation, not the language. Even then, the behavior is different from implementation to implementation. &gt;It is (infinitely) arguable whether potentially redundant extra calls to close() are superior to potentially leaking missing calls to close(), but defaulting to either betrays a capricious disdain for the reader's time. I started my programming career with C before moving to Java, then Python, so I guess old habits die hard. I prefer to be more explicit about what the code is doing, even if it's not strictly necessary. I've found code to be more readable when others do the same. If you prefer things to be done implicitly, then maybe Perl is the language for you :)
Needs a how-to. If I need to study something like this, it's going to be always easier to roll my own. The same with blatter. A how-to, ideally with a screencast or a slide-show. It's not that effing hard to record yourself creating a sample site and using some of the basic features. It takes 10 minutes tops and it saves everybody a lot of searching and wondering (if you haven't lost them already).
Python 3 is not "a development version with advanced features."
Yeah fair enough, I hadn't seen it before &amp; I've been doing python for awhile. I guess we all have our knowledge gaps.
"lesser known"
The problem is, often you can't deal with the exceptional condition at the current level in the code, or even the one above. It's usually the deepest levels where you find a problem, and the outermost levels that can handle it (report the problem to the user, retry the whole process...). If you use return codes (or returned exception objects) for this, then the logic in the several intermediate levels between is interspersed with error checks on every call, which distract from the normal path. With exceptions, only the low level code which raises the exception and the high level code which deals with it need to think about dealing with that problem.
zlib.adler32() and zlib.crc32() now return unsigned 32-bit integers.
trigger\_notify and event\_handler should raise NotImplementedError then you should do class SomeSubscriber(Subscriber): def event_handler(self, param1, param2): print "RECEIVED: param1: %s, param2: %s" % (param1, param2) same for Publisher you may want to have it do self.__publisher.notify.subscribe(self) and then for handler in self.__handlers: handler.event_handler(*args) that way you have the full object which may be useful for other things. another thing you should do is make the arguments *args, **kwargs, that way it can be called with keyword arguments as well. \_\_handlers in Event should possibly be a set or a dict. calling '.remove' on a list can be slow if you add thousands of subscribers and start removing some.
Wow. You and @schnupfen are right. I thought I'd read that `with` and list comprehensions scope their variables, but that's clearly not the case. However, there is another lexical scope: generator expressions. And in Python3, [list comprehensions as well](http://docs.python.org/release/3.0.1/whatsnew/3.0.html#changed-syntax).
This seems more like an observer pattern than events? If I implement it like that I can only have one handler per subscriber. What I want to be able to do is, like in C#, to add different handlers (within the same subscriber) to a single event. A subscriber could have methods event\_handler1 and event\_handler2 I'll definitely add the keyword args and the set. Thanks for your comment, this is what I'm looking for. Tips on the entire (structure of the) code, not just tips on statement-level, although those are very welcome as well.
I had to hunt around a bit for the source; here's a link to save you the trouble: https://svn.enthought.com/svn/enthought/AppTools/trunk/enthought/rst/ 
Damn it! There goes my excuse for not writing documentation. ):
Find a platform Qt4 doesn't run on.
someone needs to learn how to use pip's requirements.txt
any tarballs, I'd like to package it....
Nope. My distribution had development packages for it already. See: http://aur.archlinux.org/packages.php?O=0&amp;K=python-ets&amp;do_Search=Go Did I mention I use archlinux? 
Oh is this not a standalone editor? *headdesk*
To see what's going on, try the following: from __future__ import print_function global x x = 7 def main(): x = 5 def foo(): #nonlocal x print("x =", x) return x foo() print([x for x in range(2)]) print([foo() for x in range(2)]) print(x) foo() main() Try it with python2.7 and 3.1, with and without `nonlocal`. And try switching to a generator expression in both as well. I.e. print(list(foo() for x in range(2))) I don't know what to call the comprehension loop variable. It's a strange beast.
That depends perspective. It could be made stand alone by bundling its dependencies... and maybe even packaging it as an executable. On the other hand, it's uses other `enthought` packages extensively so you could argue that it's part of a suite. Either way, its a python module that imports (lots of) other python modules to do its work. 
any dependencies?
Off the top of my head: most of the `enthought` namespace, `AppTools`, `ConfigObj`, `PyQt`, `docutils`, `pygments`, `Traits`. Probably others. Like I wrote elsewhere, my package manager handled the install. 
When I understood this is when I started to love python. Well, that and the built-in docs, and the fact that most of the standard lib written in python, and list comprehension and so many other things :)
&gt;There may be a handy dmg-style drag-n-drop solution along shortly. Any specific reason you need 2.7? The only reason is that I have NLTK (why I need Matplotlib) and a bunch of accessory programs installed in 2.7, so I feel a bit committed to it now. But seeing as this program will require so much modification I think I might be better off cutting my losses and going back to 2.6. Thanks for the help.
Just came her looking for exactly that info. Thanks!
Just a word: The word the community uses instead of Pythonesque is Pythonic.
1. It has been explicitly stated that programming python 2.X according to the subset of commands available in python 3 is not a good idea. 2. I understand that. The only argument that carries any weight is "that's how most people do it."
Django requires you to think in terms of "project", "apps" etc., which is a cognitive overload when you are starting new. Do what the above comment says, but use something like [webpy](http://webpy.org) (google's GAE app layout and tornado are both inspired by web.py) or [Flask](http://flask.pocoo.org) (excellent choice of components eg: sqlalchemy, jinja2, werkzeug etc.,) to start. Both can start web projects in a single file and scale to large projects easily. By learning these first you will be able to avoid the risk of becoming a "django" programmer instead of choosing components based on merit. 
 Traceback (most recent call last): File "app.py", line 23, in &lt;module&gt; from rest_editor_view import ReSTHTMLEditorView File "/home/florian/Code/rst/rest_editor_view.py", line 44, in &lt;module&gt; from enthought.pyface.ui.qt4.code_editor.code_widget import AdvancedCodeWidget ImportError: No module named code_editor.code_widget on ubuntu; installed all kinds of packages: python-apptools python-docutils python-pygments python-traits python-traitsgui python-traitsbackendqt python-qt4
Not sure why you're making so much stuff private, but looks good otherwise.
irssi is one of the most popular clients out there, and it has support for perl extensions.
Yes, I got a similar remark from #python as well. I posted a more [Pythonic](http://www.reddit.com/r/Python/comments/d6aly/would_like_some_help_making_a_piece_of_code_more/c0xww9h) version in the [following post](http://blog.jeroenpelgrims.be/2010/08/using-c-style-events-in-python-a-more-pythonic-version). Still quite a bit is set on 'should not touch' though. _publisher could be changed to just publisher I guess. More tips are very welcome!
It is however not used by the mainstream and contains features not yet in the mainstream (2.x) version... So for all intensive purposes it may as well be.
I think that's the best poem I've ever seen it make! Cheers Lorem Gotham
I am the author of Spiff Workflow, so I'm curious what it is that you needed to modify, and what you are trying to do.
Did you do builder.connect\_signals(object\_which\_has\_on\_btn\_clicked)?
Yeah, got it working though, it was messing up my indentation so wasnt recognising the function D'oh!
Why downvoting?
Well, it's still a 'no'. 2.x is not *mainstream* and 3.x is not *development*. It's not about features not *yet* in 2.x. Python 3.x is *intended* mainstream, production quality, it's just that adoption rate is low. Backporting from 3 to 2 is meant to help you move when your deps are available, so it's not like 3.x is HEAD and 2.x is release, moreover [some changes are not supposed to be backported at all](http://sayspy.blogspot.com/2010/08/what-will-forever-be-exclusive-to.html "also here on reddit."). So writing it like this is misinformation. Btw. their spelling it "Phython".
By the way, Python 3 fixed a lot of the concern with mixing fixed/positional and keyword arguments, as you can now specify variable number of positional *and* keywords, which was clumsy/not possible before. def myfun(arg1, arg2, *args, keyword=True, **kwargs): pass In Python 2, you couldn't mix/match in that fashion, which forced you to do clumsy var-arg kw-arg unpacking manually.
It was nice to see what they thought of Python, as they didn't seem to be particularly steeped in dynamic language lore. They write specialist software that was scriptable and moved from one scripting language to Python. It may be a pointer to what we in the Python community do right.
next week: default arguments! (sorry to be an asshole ;) happy hacking)
Flask because it is simple yet powerful; well documented and with strong conventions for extensions; active community and lead developer. Built on proven technologies such as Werkzeug and Jinja (with other proven technologies such as SQLAlchemy as extensions).
The issue I have at the moment is that writing a PHP page is as simple as opening up a text document and starting something beginning with &lt;?php. When I look at Python web development I see dozens of frameworks, each with complex setup requirements. They also all seem to run their own webservers - I'm already running Lighttpd, or Nginx so it seems like a waste. 
KohanaPHP
They all mostly have their own DEVELOPMENT server that you should never use in production, but don't confuse that from them being able to accept requests from conventional servers like Apache/Lighttpd/nginx/etc. Also, the reason why PHP is so easy to pick-up and use (like you said, just start a page with &lt;?php and point your browser to it), is also one of the many reasons it encourages just terrible design decisions in your code. The fact that any output it spits out in the response, and that it doesn't distinguish between the presentation or templates from your actual business logic just bred the way to awful spaghetti code with inline SQL statements everywhere. It's great for beginners who don't really understand what writing a web page means behind the scenes, but it made it especially difficult to get rid of the bad code that easily resulted from it. On the other hand, Python is much less lax about how the web page development process works. Everything is fed through an interface that talks to your web server (like WSGI). Based on the request variables WSGI packaged up nicely for your from the web server's parsed request, you create a response object to pass back to WSGI, which then tells the web server what headers to make and the body of the text to send on back. Each Python framework has its own way to further abstract out that process of dealing with request variables and passing a response back to WSGI (or whatever other interface you're using). But really, once you just understand that simple back-and-forth and look at the 60 seconds or so of documentation on the specific framework you're reading about, it's pretty easy to get coding. Really, PHP (amongst other languages) poorly trained developers to think that a URL points to the file containing the exact script that needs to be run to produce a page. In languages like Python, a URL is merely a string describing what the user wants to do or see. Your framework parses that string, determines what function or method to go to based on that string, and then that function will generate some sort of response (be it raw text or through some sort of templating engine).
I hate to sound like an asshole, but this question has been answered *at least* a bajillion times on this site. I saw it asked several times in the last week alone, so I might recommend searching for it. My other answer is this: There is no clear winner. Give a few a try and see what you like. You can't really go wrong poking around with any or all of them.
If you are a PHP programmer you might look [this link](http://www.reddit.com/r/Python/comments/d5n7p/starting_web_development_with_python/c0xqy1p)
Take a look in to web2py, it is a great framework to start and to stay, follow [this link](http://www.reddit.com/r/Python/comments/d5n7p/starting_web_development_with_python/c0xqy1p)
With web2py you download http://web2py.com/examples/static/web2py_win.zip, unzip it, click on web2py.exe and it starts. It has no dependencies. You do no need python pre-installed. It requires no installation. It has no configuration files. It comes with its own multi-threaded ssl-enabled web server (but you can use third party ones), a transaction safe database (sqlite, but you can use 10 other ones including google app engine), a database abstraction layer, a web based IDE, a ticketing system, a web based database interface and more. [The docs](http://web2py.com/book) and a [video](http://vimeo.com/13485916) Give your self five minutes with each of the framework and see how far you get. Then try to ask a question to each mailing list. See how fast you get an answer and how well the question is answered. Then post here about your findings, your decision and the motivation behind your decision.
I've used symfony mainly as a PHP developer. I've also used codeigniter and kohana in the past. I've only recently looked at django at the moment, since I decided to take a break from PHP and get dirty with python. I haven't tried any of the other python frameworks other than django. I can't say much, but the style of django's MVC is usually different from symfony's. Django's MVC is called MVT (model, view, template). View is actually the controller file, whereas the template is the view file. I usually had to change my perspective several times when I'm developing in django. I can do a brief comparison between django and symfony from my experience. I'm by no means an expert in python or django. I've only read diveintopython tutorials and stopped halfway when it began to teach me on the applications of python. Then I began on django's tutorial and installation setup. Django's app tutorial is only 4 pages rather than the 28 pages in symfony. But symfony's tutorial is much more in-depth, while django's keeps it at a minimum for brevity. Django's app tutorial isn't a fully blown app like Jobeet. Django would have a subset of apps. Though, in a symfony project, you also have apps, but apps in django can be integrated together much nicely and smoothly. In my mindset, apps in django acts pretty much like actions in symfony. Now, django's main philosophy from what I see is that apps should be simple. Usually the rule of thumb is that if an app gets too big, you would need to break it down into simpler 'apps'. Each app would contain one model, view, bootstrapper (called \__init\__.py) and test file. There were some strategies that allows you to have multiple model and view files in case they get too large. But usually, you try to stick to one. Like symfony, django has a commandline; though not as powerful as symfony's. Django developers may refute my statement; I'm still a novice and I haven't done much with manage.py yet. You can generate apps, generate the database, etc, much like symfony. Although, symfony uses a third-party ORM (propel and doctrine), django has its own ORM suite. I liked django's model way of configuring models, since it was purely in python. I'm sure you've defined tables in YAML format in symfony, and defining models in django should be a piece of cake. A brief read of the django documents should get you up to speed on how to get things working. The django documents are fantastic. I usually had less hassles with django than I had in symfony. Symfony's documentation are great but usually sparse in some areas (admin for instance). The admin in django is absolutely fantastic. Easily configurable, much like the generated symfony admin. But, the django admin is much more easier to customize. I had a bitch time customizing generated doctrine admin classes. As an added bonus, django's admin UI is much more cleaner than symfony's, which can usually get bloated if you have a lot of columns in a table. I think these sums up the relevant elements between symfony and django. There are more but I'll leave it for you to explore. =] 
If you're looking for more of a micro, hands-off, give me the bare minimum and let me do my own thing sort of framework, look into [Bottle](http://bottle.paws.de/), [Flask](http://flask.pocoo.org/), or [web.py](http://webpy.org/) (not really that micro, more in-between). Otherwise, if you'd like the full-stack treatment, I'd recommend either [django](http://www.djangoproject.com/) or [Pylons](http://pylonshq.com/). They're very similar, with the key difference being that django treats all the smaller pieces of your website almost as plugins that can be turned on or off at will and interact with one another, while Pylons treats the actual framework's pieces as plug-and-play. So with django, you can easily reuse or grab someone else's registration, blog, tagging, etc "apps" and very quickly have a website up and running. With Pylons though, you're free to use almost anything you want as part of the core framework, like a templating engine. With django you'd be locked into using theirs. I've also heard of plenty of developers enjoying their use of [web2py](http://www.web2py.com/), but I can't comment as I don't have any experience with it myself.
I think some of the advice here assumes you want to become a Python web development guru (perhaps even a web framework developer). But maybe you're like me and just want to get going building well-designed web applications. If that's the case, do yourself a favor and at least check out web2py. I don't think there's anything easier to set up, learn, and become productive with quickly. And the user community is amazingly friendly and helpful (and growing quickly). Oh, and it does not "hide Python from you". Of course, I'm not suggesting that web2py would be inappropriate if you do want to become a guru. You may still want to start and/or end up with web2py, even if you plan to delve into some of the nitty gritty details of how Python web frameworks work. The point is, the best path depends on your short and long term goals, preferred learning style, etc. Not everyone has the same needs, and there's not only one way to go about this.
If you kind of adventurous and hacky you might consider pylons. It has the power of ror and very customizable. Reddit itself is written in python but I don't know whether it's pylons? Is it guys?
As already noted, web2py has no complex setup requirements (virtually no setup at all). Perhaps not quite as simple as writing a single PHP page, but close (actually depending on what you want on that PHP page, web2py might be a lot simpler).
Reddit uses Pylons, and I give my vote to Pylons. Though I would suggest you try Jinja2 as the templating engine rather than Mako.
django is fantastic. Try the [tutorial](http://docs.djangoproject.com/en/dev/intro/tutorial01/).
If you're willing to be scared, look up some tutorials on Twisted.
Anyone else seeing very strange font rendering (kerning) on that page?
Personally, I found it very difficult to manage web applications written in flask / bottle or something like them. You need to manage everything manually from database connection to web session. As your app grows, you will find why there is something called django.
just use django. It's easy to use and well documented, and holds your hand as much as anyone who calls themselves a developer could need
**bottle**, doubtless. bottle did everything no more than a web framework, simple and clean, self contained, well documented. 
Very nice completion and type inference and so on... It feels awfully slow though.
Having tried both, I have to say that I prefer mako. It's probably a bad choice if you are used to putting lots of logic into template and need to be put on a short leash, though.
A couple of suggestions: 1) It would be nice if you even mentioned what PyCharm is in your post. 2) It would also be nice if you linked to either the project website or an official announcement in your post.
Here's a link, saving people a few seconds of google time: http://www.jetbrains.com/pycharm/ It's an IDE for python development and it seems ok from the video, but it personally doesn't give me any specific features that distinguish it from for example the free komodo edit. Maybe the OP could, since this after all is software that costs money for non OSS development, explain what PyCharm does to differentiate itself from competitors?
This is why: letter-spacing:-0.01em;
tres) it would be nice if PyCharm was free or has at least a free edition like activepython.
what I found especially helpfull in PyCharm: * refactoring tools like "extract method" * browse structure of the Python programm * quite-well-working completion (a bit like intellisense) -&gt; I did not experience completion that worked as well * completion also works within JavaScript * I like the local history: it tracks every change, so i.e. accidental deletion can be undone quite comfortable even when no commit has happened. I got a good idea for application-improvement out of the free plugin "Key promoter" -&gt; something like Clippy for keyboard shortcuts, but way less annoying :) If you trigger the same action multiple (configurable) times via mouse, key promoter suggests in a non-modal-popup (like the Raskin-recommended ones) which keyboard combination would fullfill the same effect. AND if there is no keyboard shortcut, it suggests to create one. 
quatro) Pie! I want pie! Where's my pie?!
not really - read the docs.
You're trying too hard!
Hmm, this seems to be very similar to PyDev: http://pydev.org/ What are the advantages of this versus PyDev? It looks like PyCharm is also based on Eclipse.
Too much logic in templates makes johnny a dull boy.
:O
Nice!, but: print parse_phrase('ago 2 days') # works, same as '2 days ago' or '2 day ago' print parse_phrase('hace 2 días') # Spanish, always fails: Output: 2010-08-28 15:14:48.280000 Traceback (most recent call last): File "C:\raw.py", line 377, in &lt;module&gt; print parse_phrase('hace 2 dí­as') File "C:\raw.py", line 310, in parse_phrase return tt.parse_time(text) File "C:\raw.py", line 221, in parse_time raise TimeParseError('Failed parsing a datetime completely') __main__.TimeParseError: Failed parsing a datetime completely
added [french](http://codepad.org/L3kvRXvL) op :)
nice, thanks
Here is the Portuguese translation. Couldn't make some tests pass and I can't play more with that now. 'pt': { 'months': ('janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'), 'deltas': ('segundo', 'minuto', 'hora', 'dia', 'semana', 'mês', 'ano'), 'past': ('atrás',), 'future': ('em',), },
No, PyCharm is not based on Eclipse; it's based on the IntelliJ platform. Its strongest point compared to PyDev is Django support (which is very basic in PyDev at the moment, and much more complete in PyCharm). It also has more refactorings, better built-in code analysis, etc.
I've heard good thing about about using Python/QT http://wiki.python.org/moin/PyQt
Py2EXE for Windows Py2APP for Mac And Linux you might try Freeze. But really most Linux distros already have python installed so you won't need to package it up like you typically would with a windows/mac app. And good luck with traversing the world of java. I went there. I came back quickly.
Try bbfreeze for the actual 'compilation'. As for constructing the GUI, there aren't a whole lot of free RAD tools for python. Boa Constructor was one option, but I think it died. wxFormBuilder looks interesting, but I'm not sure how well it works.
One limitation of all date parsers is they can never know if 01/10/02 Means: 1st October 2002 10th January 2002 or 02 October 2001 Can't we all just pick a date format and stick to it?
For making the application look consistent, I recommend using wxPython. For packaging your application, thantik's coment is generally what I've seen people do.
[ISO 8601](http://en.wikipedia.org/wiki/ISO_8601) FTW!
The german translation for second is wrong. It should be "sekunde" instead of "zweiten" (which is the genetive case of "zweiter" meaning second in a numeral / rank context).
I think the GNU string parser for dates was the best I ever used. We need to make a python version of that. PHP did it.. Python needs it. :)
I have a fair amount of experience with wx and wxPython. It is a nightmare.
Well, I have used GTK+, Qt, and wx and between the three wx has given me the least headache when developing for multiple platforms.
Just wrap the library? Much easier.
strptime?
How is it a nightmare?
I'm a senior Python developer writing a handful of applications exactly like this. * I use PyQt for GUI. It's very stable, extremely well rendered, optimized, and – best of all, has a commercial license. * Py2Exe for Windows binaries (single-file builds, with MSVC Runtime residing next to the exe for portability). * Py2App for OS X .app bundles (was difficult to figure out. setup guide is here: http://gist.github.com/519418) * PyInstaller for Linux executables (built against a statically-built python), with a bit of hacking to get ELF headers compatible w/ new and old style ELF systems **Special note:** Static builds of python w/ depending libraries statically built are easily available with this set of scripts I've modified from rc.collective.buildout.python: http://github.com/kennethreitz/python-envs Also, completely ignore anyone who says "on Linux and Mac systems you don't have to package your application, since interpreters are often already installed". That's just stupid.
Thanks for the pointer to XDG (and the @stuaxo for the bug). 
I think thats how the PHP version does it. I am no C programmer tho. :-/
I'm game. Don't have any project ideas, but am willing to contribute.
No. The function lets you put in almost any string and it auto determines the date from that without needing to know the format. It was great for a quick and dirty date input on some web pages I built without needing a big JavaScript calendar. You could put things like "Jan 5", "3 days", "2 weeks ago", "next Thur". http://us.php.net/manual/en/function.strtotime.php
Already read them, thanks.
I'm fairly new to python, but I'm down.
Thank you!
&gt;Also, completely ignore anyone who says "on Linux and Mac systems you don't have to package your application, since interpreters are often already installed". That's just stupid. It would be helpful if you explained why instead of just stating that the idea is stupid. I can guess that one reason is that the installed version of python might be incompatible. Also, users might not be comfortable with the idea of executing a .py file to start a program. What else? Edit: Also, if you use PyInstaller for Linux, why not use PyInstaller for Windows? Edit 2: I guess another for Linux is to include all the dependencies.
Most linux distros have a version of python installed but it may not be the version you're targeting. I've run into trouble at work where I was writing code for version 2.6 but the target machines were running 2.3
I'm in.
I'm also new to python, would be interested to see what you guys are kicking around. I have a project that I have been tinkering on for a while but its mainly on paper. I have all the source in git/github so far if anyone wants to take a peek at it. Mainly python/gtk/networking.
Simple schema diff tool to compare two database schemas/DDL to find what doesn't match -- wrong column names, column types, mismatched tables, views, etc.
I'm in, but I DO have start-up dreams :)
Github that you can easily install on your server. Sans Django. EDIT: I have already started such a project and have a really nice source browser with comparable features to that of Github. But it needs issues, a wiki, activity streams and plenty of love.
I would be game
Go language style go routines and channels would be awesome in Python. I know they have coroutines, but it just doesn't seem to have the same feel to it.
We are kicking around some ideas in IRC at the moment, freenode #hackerpulse Feel free to stop in
Oooh, mind posting the link to the GitHub page? Python and networking go together very well.
I've been wanting to work on something with a group for a while. I'm in, too.
What's HN? Am I missing out on a subreddit?
Sounds good. Count me in.
hackernews news.ycombinator.com
let me know if you'd be interested in an early beta invite for www.djangy.com - we'll be inviting people very slowly over the course of the next few weeks
Consider [Gitorious](http://gitorious.com/). Doing a personal install is far from trivial ([instructions](http://cjohansen.no/en/ruby/setting_up_gitorious_on_your_own_server)), but I did it for our source management at work and have been pleased.
I dont suppose that you guys will be supporting Flask/WSGI as well? The idea looked cool, but I think we are going to be using Flask since a few people are already expressed interest
Well, we're supporting only Django at first. But our infrastructure will allow us to easily expand to any WSGI application in the future.
CentOS comes with 2.4, which version I believe is required for system stuff like yum; if you want a newer version you have to install it separately. That might be true of RHEL/Fedora in general, I'm not sure.
I'd definitely be in. Have a few ideas I've been kicking around but haven't had the motivation to start yet.
Can we get a log posted for those of us that can't jump on IRC?
http://www.stackless.com/
I'm quite keen to see this service in action...
I've always wondered. Why Javascript on the browser, why not python? It would be a much more sensible, saner language to use for programming on the browser... Could be a project as such...
You may also take a look at my little dateutil wrapper: http://code.google.com/p/date-parser/ It support some languages (ru_RU de_DE fr_FR es_ES) and can be easily extended to much more of them (using PyICU, so adding, say, Italian language support is as simple as adding it_IT to the list of supported locales).
Yet it doesn't do 'quarter to twelve', or 'noon' and 'midnight'.
This is awesome!!
NICE
We've put a significant amount of effort over the past week and a half. We finished up with the absolute basic functionality and currently we're doing a security audit on the system, ensuring our deployment strategy is solid, and a bit of stress testing. Hopefully within a day or two we should be ready for our first beta testers. I'm really excited, honestly. This is a service I've wanted for a long time and to see it work is pretty damn satisfying. Hopefully others will feel the same way :-)
I'm a n00b at python, but I'd love to get involved on something like this... if only to learn from more experienced devs! How can I help?
A lovefilm plugin for xbmc?
* cough cough * http://code.reddit.com/ is always looking for contributions
Maybe [Pyjamas](http://pyjs.org/) or [Skulpt](http://www.skulpt.org/)?
I'm ok at python, but new too working in a collaborative environment but I'd love to help too.
I'm still a newbie but I know my way around python and might be of some assistance. I'm also an experienced web/graphic designer and wouldn't mind at all helping on that front.
Hi knipknap, basically it's the assignment of workitems (task) to users and groups plus the persistance of the whole workflow instance. I saw in the examples that you did a unittest pickling a job instance. This can be possibly modified to save it to any kind of database. For the workflow application I am developing I need an inbox with workitems for the user or a pool where different users can access single workitems and assign them. So in any case a simple database query where the result are my workitems from different workflow instances would be fine. The users frontend will be heavy AJAX based only calling JSON-RPCs so the workflow engine will be used as a middleware between NGINX / Lighty / Tornado (with Tornado JSON RPC). After digging a bit deeper into your workflow framework I found it quite capable of doing complex flows. So I think it might be worthy finding a clever solution to make job instances database persistant in a way that I can query it easy to get user or group wokitems (which are tasks for my unterstanding). Cheers, Nek 
Those seem promising, but they still convert Python to Javascript. I was thinking more on the lines of completely removing Javascript from the equation.
Yes, there are many factors for why it's a bad idea. The interpreter may or might not even be there, through different configurations. Usability is the main issue. And often, you don't want your source out there. I use PyInstall for Linux but not Windows because Py2Exe works exceptionally well. Ironically, it is by far the best developed tool for packaging up an application. All of the above methods are for minimal dependency applications. If you have any specific questions, feel free to email me me@kennethreitz.com.
JavaScript is actually an eloquent language when you get used to it. The only clusterfuck is the hacked-on bit everybody hates (but intuitively is synonymous with JavaScript itself): the DOM. Replicating the DOM in Python would be only slightly less painful. Consider for a moment how troublesome creating cross-browser layouts can be (in addition to supporting non-desktop browsers) and then imagine the cross-browser implementations of Python that would eventually be proposed. All browser vendors would consider some language features unnecessary (or essential) and thusly it would be a nightmare more far-reaching than the troubles of CSS.
we've got some mockups in the git repo at the moment, feel free to play around with it or post any ideas in there
You can probably just wrap it entirely in python using the ctypes
will check this out later
excellent
i'd like to participate, but i don't think i'm good enough. I'll just keep an eye on.
Sweet, so I can do this: def p(s): import inspect return s.format(**inspect.currentframe().f_back.f_locals) Now I just need to bind it as a property to the built-in string class and I could do "HELLO: {a}".p instead of p("HELLO: {a}") 
I'll definitely be by to check it out. I'm just starting out with Flask myself but loving it.
If I wasn't busy with my education and coding for my startup, I would jump on the bandwagon! More people should do this :) EDIT: I'm watching your project in Github, just in case :)
mind=blown
ogden is nice idea, i woluld also like to have simple DE written in python so that i could easily customize it. thou, some more info on running and using it would be nice. couple of screenshoots would not hurt. do you use it on as main DE, or at least on weekly basis? 
I don't have anything I want to start at the moment, but I have a few existing ones on http://programmer-art.org/projects/ and http://github.com/danielgtaylor that could always use some love. If a cool project comes along and I have time I'm all for jumping on board. I have experience with tons of stuff including python, django, pylons, turbogears, sqlalchemy, mysqldb, paypal integration, twitter integration, github integration, image processing, media transcoding, graphical desktop application development, GNOME technologies, GStreamer, DBus, and a fairly ridiculous number of other python libraries.
sounds like the project we decided on might be right up your alley -- there will definitely be some API integration stuff to work on http://github.com/swanson/hackerpulse
This. I have some ideas of things I want to build, but I don't have the means to get there. Would love to join something like this to learn.
I'd prefer not having to pay but thank you.
Thanks for the response! As for user and group assignments, I would do this by setting an attribute on a workflow item. That way, it is easy to change them at runtime in a workflow. The tricky part is indeed making it persistant in a way that makes selecting on such an attribute/workflow easy (which is why pickling is problematic). A lazy solution I can think of: Exporting as XML, and storing that in a nosql database (we use exist-db for xml). Persistence has been on my todo list for a while, but there's always something with higher priority so far.
Given that they went 3 years with no development, I would say right around never. Just use SQLite for dev since I assume no one is crazy enough to run Windows servers for a Python app.
[Is this what you were looking for?](http://www.lfd.uci.edu/~gohlke/pythonlibs/#mysql-python)
would it also work without the first three steps?
:O
Yes, that's exactly it, thanks a lot.
Use [oursql](https://launchpad.net/oursql) instead. It is way better. Works fine on 2.7: * oursql has real parameterization, sending the SQL and data to MySQL completely separately. * oursql allows text or binary data to be streamed into the database and streamed out of the database, instead of requiring everything to be buffered in the client. * oursql can both insert rows lazily and fetch rows lazily. * oursql has unicode support on by default. * oursql supports python 2.4 through 2.7 without any deprecation warnings on 2.6+ (see PEP 218) and without completely failing on 2.7 (see PEP 328). * oursql runs natively on python 3.x. * oursql is licensed under the BSD license. 
*Also, completely ignore anyone who says "on Linux and Mac systems you don't have to package your application, since interpreters are often already installed". That's just stupid.* This is not how Python is meant to be used :/
why isn't that on pypi?? I thought there was no support for py2.6 either (assuming that is for real, and works).
i doubt anyone is interested here, but i thought of a small project. it would be a website that looks like microsoft outlook web access, but is actually a way to browse reddit at work :-P https://bitbucket.org/frewsxcv/reddit-outlook/overview [here's a live demo](http://rwell.org/projects/reddit-outlook/) (enter a subreddit in the input field and press the button) [here's what outlook web access looks like](http://www2.samford.edu/ts/images/stories/owa_2007_client_full.png) it's pretty close to being done, it's actually mostly just some fancy javascript+css work
how can i help? the project sounds interesting + educational
There's also [Eventlet](http://eventlet.net) and [gevent](http://gevent.org) both based on "greenlet" if you just can't leave CPython behind ;)
http://www.reddit.com/r/Python/comments/d7gzs/any_python_hackers_want_to_make_something_cool/
That seemed to be more of a reference to his/her own project rather than a call for new projects
I literally *just* finished typing up these [installation instructions](http://code.google.com/p/ogden/wiki/InstallingOgden). Whack at it, hack at it, and send me lovely patches. I'm actually working on a longer sphinx documentation right now, which will establish the kind of coding ideas, principles, and practices I'm aiming at.
Interesting, I don't ask much from the official bindings but I've seen complaints from others about them. Looks like it's missing a shortcut for retrieving the last insert ID... but that's not a deal-breaker.
You guys do know that MySQL is named after Monty's daughter, My, and not the possessive, my, right?
really?
The project was decided on IRC, I think. I arrived when they had just settled.
I think I'm a little late to the party, but the world **really** needs more flexible version control interoperability tools, particularly for migrating away from svn and cvs towards git or hg. It may not be as sexy as a social networking site, but if you really want to create something that helps people get things done, it would be a worthwhile project. Everyone knows that svn is old card (har) and DVCS is where it's at these days, for example NumPy is in the middle of migrating from svn to git. The PyPy project is quite interested in migrating from Subversion to Mercurial, however its history is incompatible with any of the existing svn-&gt;{hg,git} tools that I'm aware of. One developer has put a decent effort into investigating svn-&gt;hg, so that's the direction I'd recommend personally. He doesn't have a whole lot of time to invest into the project, and `svn` is currently "good enough" for PyPy, but most of us would like some form of DVCS. I can only speak to PyPy specifically, since that's the only project I'm very involved with, but I can't imagine we're alone in needing more advanced migration tools...
Related link: http://dev.mysql.com/doc/refman/5.1/en/history.html "MySQL is named after co-founder Monty Widenius's daughter, My." If I'm not wrong his next two children are named Max and Maria; he named the following two MySQL related product MaxDB and Maria.
hmm needs a couple of modifications for python 3 me thinks but looks good.
I wonder if this is true. The precursor "free"-ish database to mysql was called msql. By precursor, I mean the sql-like database that was available for less than really big bucks, and available on linux. I thought at the time that mysql was a way to distinguish it from msql, while still being similar enough that it could be mistaken for msql and thus get instant cred. 
MySQLdb isn't official. I work on it in my (scant) spare time.
I had a few ideas in my pocket since most people came in and said "hey I want to help, what are we making". The goal was a call for new projects and to meet some new people.
And US is an acronym!
Is this easier to install on Mac than MySQLdb by any chance? I seem to remember having to install MySQL server on the client computer just to get it to install... 
Not sure I'd want to tie myself down to a specific database, really. What if I wanted to switch backends to Postgres or whatever?
Le ORM, monsieur.
[Use with ORMs](http://packages.python.org/oursql/tutorial.html#use-with-orms)
Great news!
Highlights ========== Python 3 compatibility ---------------------- This is the first NumPy release which is compatible with Python 3. Support for Python 3 and Python 2 is done from a single code base. Extensive notes on changes can be found at `&lt;http://projects.scipy.org/numpy/browser/trunk/doc/Py3K.txt&gt;`_. Note that the Numpy testing framework relies on nose, which does not have a Python 3 compatible release yet. A working Python 3 branch of nose can be found at `&lt;http://bitbucket.org/jpellerin/nose3/&gt;`_ however. Porting of SciPy to Python 3 is expected to be completed soon. :pep:`3118` compatibility ------------------------- The new buffer protocol described by PEP 3118 is fully supported in this version of Numpy. On Python versions &gt;= 2.6 Numpy arrays expose the buffer interface, and array(), asarray() and other functions accept new-style buffers as input. New features ============ Warning on casting complex to real ---------------------------------- Numpy now emits a `numpy.ComplexWarning` when a complex number is cast into a real number. For example: &gt;&gt;&gt; x = np.array([1,2,3]) &gt;&gt;&gt; x[:2] = np.array([1+2j, 1-2j]) ComplexWarning: Casting complex values to real discards the imaginary part The cast indeed discards the imaginary part, and this may not be the intended behavior in all cases, hence the warning. This warning can be turned off in the standard way: &gt;&gt;&gt; import warnings &gt;&gt;&gt; warnings.simplefilter("ignore", np.ComplexWarning) Dot method for ndarrays ----------------------- Ndarrays now have the dot product also as a method, which allows writing chains of matrix products as &gt;&gt;&gt; a.dot(b).dot(c) instead of the longer alternative &gt;&gt;&gt; np.dot(a, np.dot(b, c)) linalg.slogdet function ----------------------- The slogdet function returns the sign and logarithm of the determinant of a matrix. Because the determinant may involve the product of many small/large values, the result is often more accurate than that obtained by simple multiplication. new header ---------- The new header file ndarraytypes.h contains the symbols from ndarrayobject.h that do not depend on the PY_ARRAY_UNIQUE_SYMBOL and NO_IMPORT/_ARRAY macros. Broadly, these symbols are types, typedefs, and enumerations; the array function calls are left in ndarrayobject.h. This allows users to include array-related types and enumerations without needing to concern themselves with the macro expansions and their side- effects. Changes ======= polynomial.polynomial --------------------- * The polyint and polyder functions now check that the specified number integrations or derivations is a non-negative integer. The number 0 is a valid value for both functions. * A degree method has been added to the Polynomial class. * A trimdeg method has been added to the Polynomial class. It operates like truncate except that the argument is the desired degree of the result, not the number of coefficients. * Polynomial.fit now uses None as the default domain for the fit. The default Polynomial domain can be specified by using [] as the domain value. * Weights can be used in both polyfit and Polynomial.fit * A linspace method has been added to the Polynomial class to ease plotting. * The polymulx function was added. polynomial.chebyshev -------------------- * The chebint and chebder functions now check that the specified number integrations or derivations is a non-negative integer. The number 0 is a valid value for both functions. * A degree method has been added to the Chebyshev class. * A trimdeg method has been added to the Chebyshev class. It operates like truncate except that the argument is the desired degree of the result, not the number of coefficients. * Chebyshev.fit now uses None as the default domain for the fit. The default Chebyshev domain can be specified by using [] as the domain value. * Weights can be used in both chebfit and Chebyshev.fit * A linspace method has been added to the Chebyshev class to ease plotting. * The chebmulx function was added. * Added functions for the Chebyshev points of the first and second kind. histogram --------- After a two years transition period, the old behavior of the histogram function has been phased out, and the "new" keyword has been removed. correlate --------- The old behavior of correlate was deprecated in 1.4.0, the new behavior (the usual definition for cross-correlation) is now the default. 
Hopefully Matplotlib and SciPy won't be too far along.
Beginning Python is ok, but a learned a lot by examples with The Python Cookbook.
There's also [Zed Shaw's "Learn Python The Hard Way"](http://sheddingbikes.com/posts/1272132621.html), which (despite its title) is aimed at beginners.
"Programming Python" by Mark Lutz might be closer to what you are looking for. It's got a lot of library documentation with working programs used as examples, which makes for a fairly hefty book of limited usefulness. A more reasonable choice might be "Python Essential Reference" by David Beazley, which provides a brief overview of various libraries and shorter code snippets to demonstrate how they can be used. 
[Python Visual Tutorial](http://people.csail.mit.edu/pgbovine/python/) I'm also learning python and found the link above to be helpful. Zed's book although annoying(hardway) does help the basics sink in and get you comfortable typing code.
Absolutely. With numpy in python 3, a lot of other libraries can start moving (as they relied on numpy, they stuck to 2.x).
Is it backward compatible or will upgrading break scipy/theano/whatever?
It's backward compatible. &gt; "Support for Python 3 and Python 2 is done from a single code base."
Quite possibly the greatest news to touch the python communities ears so far this year. :D 
Yep, I bet a lot of people are gonna start migrating to Python 3 now that NumPy supports it.
Definitely. I'm using this for HPC and scientific computing and now I'm seriously considering to migrate to python 3 for my next project.
You don't have to install mysql if you know what you're doing, but I'll be the first to say that it's more than a little painful. Probably the worst thing about deploying Django dev instances for coworkers at my last job was getting MySQLdb working on the various OS X setups.
Tsk, he was referring to MySQLdb, not MySQL.
I think [Learning Python](http://www.amazon.com/Learning-Python-Powerful-Object-Oriented-Programming/dp/0596158068/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1283326889&amp;sr=8-1) is great for beginners, but I really can't recommend the [Python Essential Reference](http://www.amazon.com/Python-Essential-Reference-David-Beazley/dp/0672329786/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1283326908&amp;sr=8-1) enough. I've read through it multiple times--Beazley does a great job of explaining things with short snippets.
First is the Python module for MySQL, second is the database proper and clients.
Calm down, you two.
The best thing to do would be to create tools to help other developers. The Ruby community is amazing at this, especially branding the projects and evangelizing them, but I feel the Python community falls behind in this respect. While there are many, many useful tools the documentation behind them is lacking and they're often left to rot. Some tools that would be useful: * BDD plugins for unittest2 * Tools to help with Agile, such as backlog tracking, etc. * A python clone of Date.js - lots of devs find working with python's datetime module a PITA. But, in general, anything that the community would find useful would be a good start. Maybe check out pypi for projects that haven't seen much activity recently and fork them?
[Invent Your Own Computer Games with Python, 2nd Edition](http://inventwithpython.com) is a free book that teaches complete beginners programming by making small games. The book has the source code to a dozen games, so you actually learn from real programs instead of just getting a laundry list of concepts thrown at you.
[This is the one I started with...](http://www.amazon.com/Python-Programming-Absolute-Beginner-3rd/dp/1435455002/ref=sr_1_5?ie=UTF8&amp;s=books&amp;qid=1283337985&amp;sr=8-5) I was very happy with it...
seriously, neither are even available for 2.7 yet...although this may in fact help both projects
It does work. I used it for a job updating the database of an old project. I use python 2.7, 64-bit, FWIW. I assume it's not on pypi because it's not official. If the MySQL-Python folks wanted to use it, they probably could. But they seem to barely acknowledge Windows' existence. 
[Google's Python course](http://www.youtube.com/watch?v=tKTZoB2Vjuk)
How to Think Like a Python Programmer is what you are looking for. Simple, yet pretty complete. PDF and HTML here: http://www.greenteapress.com/thinkpython/thinkpython.html
You could still install them in 2.7 if you wanted.
hallelujah!
I really feel sad for PyQt.
I suggest either **[Programming in Python 3 (Second Edition)](http://www.qtrac.eu/py3book.html)** =&gt; Base concepts covered in the first few chapters then the author gives practical examples from then on. **-or-** **[Quick Python](http://www.manning.com/harms/)** =&gt; More base concepts coverage and different practical examples. Mark Lutz's Learning Python book gives you a lot of depth just with Python, but it doesn't give much in the way of practical/applied examples.
Not what I meant. Of course it will work with python 2.x, the question is will it break software that depends on older numpy releases.
No Python 3, no joy.
Actually 32/64 bit Windows binaries for 2.7 are [here](http://www.lfd.uci.edu/~gohlke/pythonlibs/).
I JUST installed PyQt on Windows.
Then use PyQt
they are going to need to release python 3 support eventually....
Are you the author? I just downloaded the ebook and have just written the guess the number game. It has been very easy to follow and understand. Teaching through games is a great educational strategy for any age. 
You'll have to recompile scipy, etc, as it's not binary compatible, but other than that, upgrading to numpy 1.5 shouldn't cause any problems.
One thing I like about PySide is the [Documentation](http://www.pyside.org/docs/pyside-dev). It's amazing. I mean Qt has an amazing documentation and looking and adapting it to PyQt is quite easy. But still - to have it all plainly laid out makes for a very professional feel.
&gt; Are you the author? Yes. The Al Sweigart on the book cover and this AlSweigart account are in fact [dramatic pause] ...THE SAME! :) Thanks for the complement! Feel free to email me if you have any questions, or leave a review on Amazon when you're finished.
Basically, more powerful svn-&gt;hg migration tools, the existing ones don't cut it for more complicated histories. [I wrote a bit about it here](http://www.reddit.com/r/Python/comments/d7gzs/any_python_hackers_want_to_make_something_cool/c0y7v42)
complains Python not installed ...WTF http://i.imgur.com/uf0A3.jpg
what version of python are you on ?
Does this come with Qt Developer and the documentation? They also need to add Python 3 support soon.
whizzer looks nice. Do you have any evidence for the speed claim in the headline?
2.7
Before everybody tells me how I should have been using Twisted, just let me say I was in a position that required no external libraries.
1. Install [ActivePython-2.7](http://downloads.activestate.com/ActivePython/releases/2.7.0.2/ActivePython-2.7.0.2-win32-x86.msi) 2. Open Command Prompt 3. Type "pypm install [mysql-python](http://pypm.activestate.com/list-m.html#mysql-python)" 
What's the difference between PySide and PyQt?
No wonder I had such a hard time choosing a book in the first place. There's no shortage of resources. Fortunately I've got lots of free time even now that I'm employed again. I'll give a look at your suggestions -- it sounds like "How to Think Like a Programmer" might be the sort of thing I need.
Do you actually have it installed?
[PyQT](http://www.riverbankcomputing.co.uk/software/pyqt/intro) are Python bindings for QT made by Riverbank Computing. It is GPL licensed, but there is a commercial version not developing non-GPL licensed software (costing £350). PySide are Python bindings for QT, financed by Nokia through [OpenBossa](http://web.openbossa.org/). It is LGPL licensed, which means that it can be used for developing both open-source and commercial applications. It is still under development, though.
ಠ_ಠ
Maybe his daughter is named Ourania?
done it
I am going through learning python by mark lutz right now and it is great. Problem is I am not sure how good this would be for somebody with no programming experience at all. I was able to move very very quickly through the first ten or so chapters before he starts covering the cool iterator/generator/comprehension stuff.
Not sure how good your first recommendation would be for an absolute beginner.
I was trying to be helpful, idiot. Fuck you.
Right, you still haven't explained what you said or what significance it had.
i don't know why but every time i see this link posted on reddit, i immediately think it's referring to some magical python class that google wrote -- then i become disappointed when i'm presented with a bunch of python lectures. both the title and url are misleading and vague in my opinion.
Same problem for me, install python 2.7 and try it works with that. 
Dude, I was soo expecting some awesome library.
~2 MB for PySide, plus 194 MB for QT Libs (~160 if using [qt-msvc-installer buids](http://code.google.com/p/qt-msvc-installer/)) vs. ~28 MB for [PyQT](http://www.riverbankcomputing.co.uk/software/pyqt/download) ???
heu, since yesterday, i couldn't access the website. what's going on? i thought it would be fixed by now...
I've just started learning Python so I'm in a similar situation to you and at the moment, I'm going with [Dive into Python 3](http://diveintopython3.org/). It's available as a free download in pdf or html.
I don't think dict, list, etc should be in the name I would call a list of coupons, coupons, and a dict of customers, customers.
1. the type of a value shouldn't be part of the name, i.e., `optionDictCustomerDictCouponList` should be `optionCustomerCoupon` 2. if you abbreviate a term, e.g., `opt` for `option`, be consistent within the function, consistent within the module, and consistent within the package. 3. my personal preference is `names_with_underscores` for functions, methods, and values, but I adopt whatever convention is used by the framework, i.e., when using PyQt it would be `camelCaseNames`. the difficulty comes in when you have competing styles from significant packages. 4. i strive for the short, readable value names, i.e., `total` instead of `shopping_cart_total`. the difficulty here is when you have more than one kind of that thing... and that's where nice prefixes come in (`unpaid_total`). 5. sometimes when i'm in a hurry, i'll take a shortcut and name a significant value with one or two letters. this is always wrong (except in list comprehensions) and i always regret it. 6. when in doubt, let [PEP 8](http://www.python.org/dev/peps/pep-0008/) be your guide. and let the whole thing guide you, not just the "Naming Conventions" section. &gt; I'd probably have a better idea of what to do if I read more code, but I thought I'd ask anyway. Good writers and great writers read a lot; so too with programmers, methinks. 
Please no Java-esque variable naming in Python :) I think that is okay in unit tests e.g. test_apply_customer_discount but yea... customer_coupons?
Thanks, so does that mean I'm doing something inefficient/unpythonic/etc if I have a dictionary of dictionaries of lists? Also, assuming I forget and come back to the code, would there be a quick way to figure out the structure of that object if there are no types in the name?
I use Capitalization for all "callables" in Python, including functions. It allows generic re-factoring. foo = Widget() `Widget` can be either def Widget(): ... or class Widget(object): ... I wouldn't do that in most languages, e.g. C++, Perl or Ruby, where `new` is required for class instances, but in Python it makes sense.
Coming from a Cobol background I have always used longer descriptive names usually with underscores to separate words. I will use abbreviation of words if the meaning is clear. inv_tot instead of invoice_total cust_YTD_tot instead of customer_year_to_date_total Also, when creating tables in SQL databases if I have control of table creation I will usually prefix each field with a 3 to 4 char table identification so: Customer Table cus_id cus_company cus_phone Invoice Header inv_id inv_cus_id inv_bill_to although this increases name length in sql queries it generally eliminates name clashes - I find I can type faster then it takes to research which table am I in and which field name should I use. Generally I do not indicate field types in my variable names having said that if I am dealing with screen variables I will usually try to prefix variables with an indication of screen widget type such a btn for button, lbl for label, txt for text entry field etc. I think as long as you come up with a consistent set of naming rules you use for yourself it will make your coding go much faster and usually if you are using any type of IDE or program editor you can use it to help take some of the drudgery out of variable name typing via macros and search and replace. Just remember, that you may not be the next person to have to maintain the program what ever rules you come up with should be obvious enough to the next guy/gal or suffer the rath. Just my two cents. 
I like to wrap constructors in a static methods in C++ to make creating objects the same way as in Python: indistinguishable from normal function call.
You can make an underscore by preceding it with backslash
&gt; so does that mean I'm doing something inefficient/unpythonic/etc if I have a dictionary of dictionaries of lists? You might or might not be using the wrong data types -- I simply don't know. You started by asking about names, and that's something we can discuss without looking at your code. &gt; Also, assuming I forget and come back to the code, would there be a quick way to figure out the structure of that object if there are no types in the name? There are lots of "quick" ways, one of which you've already discovered and been admonished to not use (by me, briancurtin and ryankask): embedding type information within the name. So if we rule that one out, the "quick" ways that I can think of: 1. a comment near the declaration 2. a docstring with an explanation 3. for function/method formal parameters, a pydoc string within the docstring But "quick" is only a little good. If you're after a lot of good, then: 1. functional and/or unit tests 2. readability 3. making it totally obvious, i.e., `customer_options = dict(...)` must be a dictionary, right? 
Read [PEP8](http://www.python.org/dev/peps/pep-0008/)
I usually start with "a" and once I hit "z" I move on to "aa".
he's right. this works.
Upvoted for obvious troll.
[Can't go wrong with this guide](http://www.josefassad.com/five_tips_to_better_variable_naming_practises).
Another way is to wrap inline code in back ticks: `some_var`.
With 1, say you have a single optionCustomerCoupon, and you want to put them in a list to do something with them, what do you then call that variable?
Easy, make it plural: `optionCustomerCoupons`. Also, it's preferable to think of names and values, not variables and values. 
There's absolutely nothing wrong with having nested data structures if it fits the problem at hand (that's all that things like json and xml are after all). I generally document in the code what the structure I'm using is because I will forget eventually, and since python is dynamically typed, there's no type signature to guide you (no map&lt;string, map&lt;string, list&gt; &gt; like in C++). When in doubt you can always print the data structure and look at the output to get an idea of how it's setup.
You don't need all of it. It should actually come out smaller in size.
I use descriptive obscenities.
It only works up to a point. Then the object names get long and hard to keep track of. For larger programs, I use UTF-32 characters. This allows me to write million-line programs in which not a single object has a name longer than one character.
&gt; optionDictCustomerDictCouponList Are you sure you don't mean to have a structure like options = { 'customer': { 'coupon': [1,2,3], 'whatever': [4,5,6], }, 'employee': { 'coupon': [1,2,3], } } for c in options['customer']['coupon']: print c 
I hope it does, as I would like to use QT instead of Tkinter for a couple of GUIs projects on my work (rules out PyQT because of the GPL), but cannot justify such a (in size) big dependency.
When you use Haskell, you don't have variables. Only static functions, that finally get evaluated on an as-needed basis when "main" is evaluated. About the name you mentioned: as ringzero states you'd do well to drop the type information, but I'd keep the type information that keeps the cardinality: optionCustomerCoupons, with an s, or maybe something like couponsByCustomer.
Wait until you see this: &gt;&gt;&gt; list(zip(*[(1,2,3),(4,5,6),(7,8,9)])) [(1, 4, 7), (2, 5, 8), (3, 6, 9)]
The best question to ask yourself is: What _is_ an `optionDictCustomerDictCouponList`? As most have pointed out, the datatypes don't add any meaning, so it's probably just a list of `option_customer_coupons` (see `PEP 8` for a good naming scheme), but that's not very meaningful either. Truth of the matter is, unless you're dealing with configuration variables or such, you probably don't need that level of verbosity because the context provides most of the meaning you're trying to put into the name. Try to refactor your code a bit (not in Java's "let's put more patterns in it" way, just shuffle your code around and let it _DRY_). Create a few functions where you previously had deeply nested `if`-structures or put some data and methods in their own classes or modules. Try to make your code more atomic (i.e. make it do one thing _only_, a la _SRP_). If your variable's name doesn't make sense in context unless you make it very verbose, chances are, you're mixing different levels of abstraction. If your variable's name sounds repetitive in context, it's probably too verbose (e.g. `document.document_dimensions.document_x_dimension` could be cut down to `document.dimensions.x` or just `document.width`).
Please stop doing that.
The easiest way to find out the structure of an object is looking at its declaration. If you have dicts containing dicts containing lists, you have raw data structures only. That probably means you also have a lot of raw functions that perform actions or calculations on these structures (or sub-structures). If that's the case, you could probably benefit from putting the data into more meaningful types. For example, if you use a dict or list to represent a customer, it may make sense to define a customer class and use that instead. As a rule of thumb: if you need verbose variable names because your variable use is so far removed from where the variables were declared, your code structure is probably lacking. Otherwise a name is good enough if it makes sense in the context it is used in: `coupons` is clear enough if you're "talking" about a particular customer's coupons. Using a plural is clear enough if you're working with a set of values (be it a list, set, dict or even your own specific type). It doesn't matter whether a name makes sense in isolation. Names don't do that in the real world either.
Personally, I find that when I am processing data, I end up with things like: row_list = get_row_data() row_dict = breakout_row_data(row_list) etc, since they're all still raw data, represented in different forms, and I want them around for different purposes (e.g. parsing tokens using the list, and shoving tokenized parsed data into the dict as a tree). So, when appropriate, do what keeps your head from spinning.
&gt; Porting __Legacy Code__ To Python FTFY
&gt; Personally, I find that when I am processing data, I end up with things like: I tend to find these kinds of things, too. Just today I had a bunch of functions with names like `make_category_map` and `make_period_map` and `make_item_map`. I went through three attempts at finding good names and settled on `simple_category`, `simple_period` and `simple_item`; all three functions were creating simplified dictionaries from objects. Still not happy with the repetitive prefixes... One of the things that helps me is to focus on what the values mean in context (what they're "for" as opposed to what type they are). So `row_dict` should be `row_dict` if you've got a really generalized function that processes rows irrespective of the kind of row it's working on... otheriwse `rocket_launcher_options` or `wheelbarrow_attribs` makes more sense. &gt; So, when appropriate, do what keeps your head from spinning. Absolutely: a foolish consistency is the hobgoblin of small minds. Also, and I should have written this in an earlier post: We shouldn't forget that finding good names is *hard* and it takes effort. It's a skill and it takes practice. 
Numpy 1.5 *is* ABI compatible with 1.4, if it is not, it is a bug.
Personnaly, I name thing so that drunk me could figure out what it is. Like: fuckin_object_map or skanky_database_semaphore. Autocomplete is your friend
ex-girlfirends, then future girlfriends.
I aced chemistry because I met up with a dude who, like me, cussed all the fucking time when doing math/problems. The fucking hydrogens go and bond with these bitch ass carbon atoms and .... When I grocked that covalent bonds are lesbians it all made so much more sense. edit: fuck. I just googled the terms lesbian and covalent bonds. If anyone gets bent out of shape thinking that this implies lesbian relationships are weaker than straight relationships, I'm SORRY! I just like chicks digging other chicks and so the metaphor worked for me. Please don't get offended. Btw, this is why my sample programs all have cusswords in the variable names, but nothing public ever ever ever ever would. 
i__am_a__very__annoying__descriptive__type__of__person = 1 (Added the extra dash as reddit fucked_up)
IMO, consistency in your own code is important. While this isn't exactly what you're asking, if you come up with some scheme even_if_the_variable_name_ends_up_being_really_long_and_annoying, stick with it through your code, at least for the current project. And, obviously, if you ever work with others on pre-existing code, you should use whatever scheme they're already using.
&gt; would there be a quick way to figure out the structure of that object if there are no types in the name In a comment. Use [] and {}: # {opttion_id: {customer_id: [coupon_code]}} optionCustomerCoupon = dict()
&gt; When you use Haskell, you don't have variables. Only static functions, that finally get evaluated on an as-needed basis when "main" is evaluated. Besides being wrong, this has little to do with the OP's question. Functions need to be named as well.
I have always found the prefixes unnecesary. A name is a name is a name, not a `cus_name` or `cli_name` depending if it is a cashier or a client. If you have to use both... what's wrong with `select cli.debt from cashiers cas, clients cli where cus.name = cas.name`? The other way if you have a `stupid_cashiers` and `stupid_clients` too, what prefix to use? stucli/stucus, stu for both? Is very probable you finish with stuc and name clashes. Then you have to write the horrible `select * from stupid_clients stucli, stupid_cashiers stucas where stucli.stucname = stucas.stucname`. And all big apps have tables with the same columns, with diferent prefix. So you can't just make up a pattern and say `people_with_visa('stupid_clients')` but add noise and call `people_with_visa('stupid_clients', 'stuc')`. Because, of course, you can't guess the prefix, you choose stu for stupids but Mike sure chooses smrt for smart_clients and, bam!, more shit.
Sometimes, when it's not entirely clear and you don't want to keep looking things up in a comment somewhere, it helps to put a "_list" or "_dict" prefix on *very few* of your variables.
Wrap it with backquotes.
Yeah, but what happens when you hit "zz"?
If you need to do that, I'd rather see the descriptive part be a protocol name, like `coupon_seq` (sequences: list, tuple, etc) or `user_map` (mappings: dict, MutableMapping, etc).
Anyone using [Hungarian notation](http://en.wikipedia.org/wiki/Hungarian_notation), or any of its variants, should be shot.
Why the hell is it always 9 minutes? 
Good point, bro. I'll do that from now on!
Sure, look at msgpackserver.py and msgpackclient.py, I've created similiar client/server pairs for rfoo, zeroc-ice, simplejson based json-rpc, and twisted's perspective broker (which has some more elaborate ideas). The fastest ones were whizzer's msgpack rpc, rfoo and zeroc-ice by far. I would have used rfoo but I wanted something that had implementations in other langauges already. msgpack was it.
I'm doing some work in comp.linguistics and I have some undeveloped ideas about programs I would like to build in the near future; collaboration would be great. But, I should admit that I'm a bit of an amateur with Python. 
That's presuming we are in the '80s and there's no unofficial standard most people have agreed upon. Look at where Javascript it today, as compared with the JS in IE and Netscape of yore. It is way more standardized, and vendors do not dare bring in crap for fear of losing out on market share. I don't think they'd want to go back to that period again; besides the open source community will enforce a standardized set of language features anyway. Look at it this way: VBScript was available (is available?) in IE. Obviously, there's no technical reason why python can't be a scripting language on the browser. The only reason why that hasn't happened so far is that the amount of effort far exceeds the immediate returns :|
At a guess I'd say they're using a 4 bit counter with a carry bit, so it counts 8 minutes then at the next minute that triggers the carry bit which switches on the alarm, probably all contained in a nice small 8 pin chip for a few cents.
i reduce scope. with focused class/method design, you need less variables in any given scope, and the simple terms can be used with no confusion. (i.e. "count", or "sum")
I wasn't expecting such an insightful answer, that not only explains the timing but also the pervasiveness of 9 minutes in the snooze button logic.
http://www.straightdope.com/columns/read/1361/why-does-the-alarm-clock-snooze-button-give-you-nine-extra-minutes-not-ten
Yep. When your variable names start to need more than 5 syllables, it's a sign that you should probably start modularizing your code more.
Django will beat this into your head if you don't know it already, but "Development and Production are two way different environments" I think that you just need to keep focusing on the users, like reddit, and when you start to hit computational limits, then you solve your problems one at a time. You will have a small chance at predicting what problems you will have before they come, and other people who know less about your ideas and methods, will have even less. For SaaS, I guess you should start by reading [Hackers and Painters](http://www.amazon.com/gp/product/1449389554/) by Paul Graham, (he pretty much invented SaaS I think...) and then head over to [Hacker News](http://news.ycombinator.com/) and get to know all the other Python/Django/SaaS cult members.
http://www.djangoproject.com/
One that holds no matter what details you may or may not fill in for such a vague and frankly awful question(no offense), is that aesthetically it's much nicer to stare at Python than PHP all day.
Not writing PHP.
SnacksOnAPlane has the answer that is correct.
This is what I came here to say. 
Python has over 9000 power? It's just different (the subtleties of which are out of the scope of this thread). Many large websites are written in PHP, as well as in python, which shows that it's a matter of preference.
MakeItSelfExplanatory
I use all lower case, underscored names for variables. I try to be descriptive but not too verbose, so I end up with: customers_waiting customer_output For classes, methods etc I use upper camel case, like: ProcessInventory() TabulateSales() This helps me order things in my head better. I write long-hand so I don't sit there for 10 minutes trying to figure out what the variable "aByy" does. With omni-completion (Intellisense, whatever) it really doesn't matter how long variable names are, but if you may ever be stuck without it, a name like "ishouldreallygogetcoffewithbobsometime" (Have actually seen this varable name in production code) quickly gets tedious to type.
It would be quicker to ask who *doesn't* want to.... Mine are generally pretty simple....variables are pretty much all lowercase, functions and classes are namedLikeThis, and underscores can be used in ambiguous cases if necessary. Maybe I'm going against the culture, but that's what I do! Not just in Python, either. C++ and JavaScript.
Python is generally easier than PHP to read and write than PHP. Whereas PHP you'd write inline HTML, python tends to need you to split it out. Although I'm sure you could write python like php, it'd be very unpythonic.
[I use this guide.](http://freeworld.thc.org/root/phun/unmaintain.html) If I cared about anything anymore, the classic Code Complete book has a good discussion on the topic.
When coding I sometimes pause to think what someone new to that code would want to know about it, when reading it. If it isn't immediately graspable I restructure it - including renaming variables - so that the code speaks for itself without comments. For example: if user_is_not_a_manager: show_rude_error_message() No need for any comments, except perhaps gloating ones. I also never name variables by their types. This only distracts. I rather say current\_user\_id (or currentUserId if you will) than intUser.
Hungarian chicks on the other hand, are hot.
python was designed to be a proper programming language from the outset, php has been forcibly evolved into one. Guess which one is going to be nicer to work with. The only benefit I can spot at the moment to writing php is there are more php jobs going at the moment than python framework based stuff (in London at least).
I think starting with a book isn't the right approach anyways. I always start with something I can do in two days or less e.g. some FAQs http://www.markus-gattol.name/ws/python.html#faqs After that you feel mostly better prepared to go with a book since you already have a basic notion about the domain.
I thought the benefit was writing in Python. 
Great one. Liked it. :-)
1up.
1up.
This is what I do and what I usually point people who ask the OP's question to
type(Object)
Django is **awesome** for SaaS! :)
Better than WingIDE's free version?
Note that [PEP 8](http://www.python.org/dev/peps/pep-0008/) recommends `lowercase_with_underscores` and *not* `CamelCase` for variable names. &gt; Use the function naming rules: lowercase with words separated by &gt; underscores as necessary to improve readability. &gt; &gt; Use one leading underscore only for non-public methods and instance &gt; variables. &gt; &gt; To avoid name clashes with subclasses, use two leading underscores to &gt; invoke Python's name mangling rules. &gt; &gt; Python mangles these names with the class name: if class `Foo` has an &gt; attribute named `__a`, it cannot be accessed by `Foo.__a`. (An insistent &gt; user could still gain access by calling `Foo._Foo__a`.) Generally, double &gt; leading underscores should be used only to avoid name conflicts with &gt; attributes in classes designed to be subclassed. &gt; &gt; Note: there is some controversy about the use of `__names` (see below).
I like to leave it as little notes for whoever the next guy is that will have to look at my code (I'm the only developer at my work). Variable names like: 'youPoorBastardLOL', 'fixTHISshitHAHA', and 'herpDerpFUCKYOU'. I live a trite and meaningless life.
I wouldn't be too quick to say that. Any program can be implemented in any turing-complete language, but the reason we use higher-level languages like Python is because we don't want to have to scroll through miles of ticker tape in an attempt to figure out what the program is doing. See also [skimmable code](http://use.perl.org/~schwern/journal/36704).
That's a great tip for refactoring! It's against PEP8 though... not sure I'd use the convention.
wsgi clearly
On abbreviating - I'd recommend pronounceable abbreviations over a collection of consonants. The downside is that the pronounceable versions can have multiple meanings, whereas consonants typically are more unique, but if your scope isn't too large this usually isn't a problem. * month: mon is better than mth or mnth * management: man is better than mgmt, mgt, mngmt * publish: pub is better than pblsh * customer: cust is better than cstmr The exception: some consonant-based abbreviations are so common that everyone just knows them: cnt for count, idx for index, rpt for report. Also, avoid abbreviating short words if possible: words of 4-6 letters don't get much benefit from an abbreviation anyway. 
I'm reading a book entitled [*Clean Code*](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) that talks extensively about naming conventions, how to organize, prevent duplication, and other such things. It uses the word "Agile" in the title, but I'm not really sure why because you don't need to be using Agile to write clean code... It's focused on Java, but I think most of the principals apply to any OO application.
Variables can be long - disk is cheap, and any IDE worth its salt has autocomplete features. These days, my IDE writes probably more than half of my actual code, probably closer to 80%. So be descriptive, and don't feel the need to abbreviate something like `rewardCustomerExpiredCupons' down to 'rwdCustExpCups' or something equally illegible. The best code reads a little like English. Oftentimes, development shops will write a set of standards for how code should look, that will sometimes talk about naming schemes to try and maintain consistency throughout the project, because that's the most important part of this whole topic. As long as your system is consistent, it can be worked through. If you keep throwing people for loops, they'll hate you for it. Of course, if you're just writing code for a class, it's not a big deal, because rarely will anyone but you and teach ever look at the code, but it's good to develop solid practices now, so when you get out in the real world, you'll have a good grasp how to function.
That's not possible in Python, sadly. Python is super-strict when it comes to which name you can give variables :(
*you* fucked up.
Oh. Well, I know ruby let's you use Unicode. In fact, you can use the actual lambda symbol for lambdas in ruby :-)
Cool! I guess there's one use for Ruby after all. It does annoy me that you can't do things like ∑ = sum π = math.pi ρ = 4 / 4.7 λ = v / f Π = lambda seq: seq[0] if len(seq) &lt;= 1 else seq[0] * Π(seq[1:]) and so on. (I'm using an autohotkey script to create those chars: \sum becomes ∑ and so on).
One use for ruby? It has pretty much all the same uses as python. Both of them are quite useful. I prefer ruby syntax, but I like python, too. When I'm doing scripting-language glue I go with whichever one has better modules for what I'm gluing together, and all things being equal I go with ruby for much cleaner OOP syntax.
The company that I worked for at the time wrote all of their books in WordPerfect. The books became too big to work with efficiently, so they were split into several files. My first Python work scripted WordPerfect with win32com (because the built in scripting was horrible) to piece the sections together, fix things like pagination, and generate the final PS file. It has been quite a wonderful journey since then :)
What have you expanded to since then?
http://micheles.googlecode.com/hg/plac/doc/plac.html
I didn't even know such a thing existed! :D
My guess is they launch a hidden instance and redirect the std file handles with subprocess.
well it will even attack to an already running instance, or it can start a new one. 
Two choices: - librarize it. librarize the fuck out of your app, that way you can call the very high level entry points of your library from either the GUI or the CLI. Long operations can then take callbacks to update your GUI. - use Popen / subprocess and call your CLI app from your GUI app with subcommands. Perhaps less code to write overall, but harder to do robust and clean error handling, and roll out your own sort of progress reportback from the CLI for long-running tasks. In almost all cases, you will have to use threads to prevent the GUI from blocking.
Lotta uses Hella's XMLRPC interface. I was actually gonna write a PyQt4 gui myself, but then hella went unmaintained. I use SABnzbd now.
Nice! Since there appears to be characters with experience in this thread i have a question or two. I'd like to process some PDF files that contain scattered tables, to extract the tables into CSV or a spread sheet format of some sort. Is there an open source solution for doing this? Open source is only important in the sense that I might need to message the data a bit. If not are the libraries referenced capable of pulling the data with a bit of effort on my part? In case you are interested the tables containg part info for machine tools. Thus you have a reference number(to a drawing), a part number and a description. Possibly other data may be in the tables. I would imagine that one problem would be multiple ways to represent the table and its data in a PDF. Any experiences or ideas are welcome. Dave
This is awesome. Thanks for linking!
&gt; never actually written an application with a gui Get ready for the exciting world of event driven callbacks. And pages upon pages to configure the most basic layout. Ease the pain a little with [EasyGUI](http://easygui.sourceforge.net/), which covers the majority of simple xdialog-esque uses. Two suggestions for an easier transition. First, **iter-ize** every function. Especially if it is slow. Find some way to break up the computation into manageable sub 0.1 second chunks. Second, **ignore threading**. Use multiprocessing instead. Yeah, the docs are 5x longer but the common case is just as simple. Also, read this: http://eventdrivenpgm.sourceforge.net/event_driven_programming.pdf
Essentially anything the GUI does that is not related to the GUI itself, you make a thread to do it so that it can do it in the background. Generally you'll use the Queue object to pass messages between threads. The issues here are that it complicates it because you have to then write the communication functionality and account for deadlocking (thread timeout and killing threads) instead of just blocking and waiting for the thing to finish within a try statement which is why people usually only do it if the lag time in the GUI is going to be more than a few seconds and if it's actually useful for the user to be doing other things while it's processing whatever they just clicked. 
I use it in [fbuild](http://github.com/erickt/fbuild), my build system. As opposed to make, my build system really just caches function calls, as in: &gt;&gt;&gt; @fbuild.db.caches &gt;&gt;&gt; def cached_function(x): ... print('got a', x) ... return x + 1 &gt;&gt;&gt; cached_function(1) got a 1 2 &gt;&gt;&gt; cached_function(1) 2 &gt;&gt;&gt; cached_function(2) got a 2 3 &gt;&gt;&gt; cached_function(3) 3 For compiling an external file though, I need to know more to decide if I can return the cached results or not. For source input filenames, I need to check if the md5 of the file has changed. For destination output filenames, I need to check that the output file exists. If both of those pass then I return the cached results, otherwise I need to recompute the function. There are obviously other ways of doing this, but annotations are really elegant: @fbuild.db.caches def foo(ctx, src:fbuild.db.SRC, dst, *, buildroot=None) -&gt; fbuild.db.DST: dst = Path.addroot(dst, buildroot or ctx.buildroot) ctx.logger.log(' * foo: %s %s' % (src, dst), color='cyan') with open(src) as f: x = f.read().strip() with open(dst, 'w') as f: print(src, dst, x, file=f) return dst
Another option for writing a GUI is to **not** write a GUI but instead hook up your CLI to something like zenity or xmessage via some scripting. This will only allow a fairly trivial UI but if that is enough then it is pretty easy.
A couple of times, I have started by writing the core functionality as a console app using gobject or QConsoleApplication and then subclass all of the objects that need GUI hooks, adding the GUI hooks in after the core functionality. Worked ok for me, I'm still not sure if this is a great idea.
Multiprocessing is running multiple threads in different processes as opposed to running multiple threads in the same process. As you probably know, a single-core machine has no problem running multiple processes. The only benefits I can see are these: - Multiprocessing is a way to get around Python's global interpreter lock - Because communication is now not in-process, it's easier to move a subprocess to a different computer There are probably more.
Do you have any plans to support cross-compiling?
Multiprocessing works great on single cores. The only downside is the increased RAM footprint. There is latency between processes (lots of pickle/unpickle) but you avoid GIL latency so it is a wash. The GIL will slaughter you if you have a CPU bound thread and an IO thread. Most CLI apps (ncurses being the exception) in python are CPU bound. Several embarrassing moments when a quick GUI I'd hack out on a single core netbook would completely lock up on a multicore machine. Either squish everything into one thread or use multiprocessing.
Is [this](http://packages.python.org/oursql/api.html#oursql.Cursor.lastrowid) the shortcut you're missing?
 sumstar_command = command(sumstar, ("terms", "listof_uint")) is the same number of lines of code and you still have your original function available (to test, for example). Am I the only one who would much prefer not to use a decorator here (or hardly anywhere else, if I'm honest)?
&gt; And pages upon pages to configure the most basic layout. No. If you're writing code to layout a GUI, you've either got very specialized requirements or you're doing it completely wrong. PyQt + Qt Designer = (almost) Never having to code layouts again. 
haha so funny
Yes. I *really* wish PEP249 followed PEP8. You know how many times I've tried fetch_all? Why lastrowid not lastinsertid?
I agree with you 100%.
From the UI thread (main one), dispatch a threading.Thread with your function running there. Make it so the thread will call back the UI thread using your UI toolkit's functions to set an idle handler, so the mainloop of the UI thread will call itself back rather than your thread directly from the thread. In GNOME it's gobject.idle_add if I recall correctly, there's an equivalent in Qt too. Both toolkits have parameters in their functions to add idle handlers so you can post the results of your thread through that. Oh, and do not forget, TRAP ALL EXCEPTIONS in the thread, and send them as parameters to the idle handler, so you can inform the user of errors. I have examples of that in my Python GUI applications at http://rudd-o.com/new-projects
Thanks. I dont really see anything wrong with hella even if unmaintained, so I keep using it. 
well thanks. Il be sure to keep an eye out and keep this in mind.
Il consider them, thats for the recommendation. 
I didn't understand the title at first, then realized it wasn't from /r/starcraft.
lpod-python as been used for the OASIS interop Demo in budapest: * [French news!](http://www.itaapy.com/news/demo-interoperabilite-autour-du-standard-bureautique-odf) * [English news!](http://interop-demo.lpod-project.org/news/odf-1.2-interop-demo) lpod and lpod-python as been presented at the [OOoCon 2010!](http://www.itaapy.com/news/presentation-de-lpod-a-la-conference-open-office-2010) too. 
I didn't know invent with python had a blog. Thanks, and keep it up, Al!
In fact I already do! That was the main reason why I made it, because cross compiling was so difficult. Here'a dummy example on how fbuild can do cross compiling: import fbuild.builders.c.gcc import fbuild.builders.c.msvc def build(ctx): gcc32 = fbuild.builders.c.gcc.static(ctx, flags=['-m32']) gcc64 = fbuild.builders.c.gcc.static(ctx, flags=['-m64']) msvc = fbuild.builders.c.msvc.shared(ctx) gcc32.build_exe('foo-32', ['foo.c']) gcc64.build_exe('foo-64', ['foo.c']) msvc.build_lib('bar', ['bar.c'])
[Suprisingly good performance](http://code.google.com/p/pymysql/wiki/Performance) Comparison with oursql would be interesting... but then again I'm really bored.
Wasn't there a new mysql drivers just last week?
If you use wxPython, things like [DelayedResult](http://www.wxpython.org/docs/api/wx.lib.delayedresult-module.html) make this dead simple.
This is great, thanks very much!
docs?..
import datetime d1 = datetime.datetime.now() d2 = datetime.datetime.now() delta = d2 - d1 microseconds = delta.microseconds 
I think he means, how do you actually take the time when the user hits the spacebar? I don't know how to answer this though, sorry. 
Use the X11 python libs to capture spacebar presses
My mistake :-) http://stackoverflow.com/questions/292095/polling-the-keyboard-in-python
You could display a basic Tkinter window and on that bind some event on spacebar key presses. If you're on windows, there is also [msvcrt.getch](http://docs.python.org/library/msvcrt.html#msvcrt.getch) which does that on the console. On unices, this might be possible via [termios](http://docs.python.org/library/termios.html) but don't ask me how. There are probably functions in curses to do that as well, on unices.
This plus a loop that listens for key presses should do the trick. If you're just using the command line then the [curses](http://docs.python.org/library/curses.html) library should have you covered. Otherwise check out [Tkinter](http://docs.python.org/library/tkinter.html). 
I implemented [this](http://85.23.23.48/~lauri/stopwatch.py) exact same thing with minimal pyglet gui, have fun :)
If you can use Enter instead of Spacebar, it's easyish: import time def time_enters(): raw_input('Hit enter to start timing') start = time.time() raw_input('Hit enter to stop timing') print 'Time passed: %0.3f seconds' % (time.time() - start) 
Something like this, perhaps? http://gist.github.com/566113
Cross platform getch: http://code.activestate.com/recipes/134892/
Reminder: time.clock() is more accurate for deltas on Windows than time.time().
Reminder: time.clock() is more accurate for deltas on Windows than time.time().
Reminder: time.clock() is more accurate for deltas on Windows than time.time().
I've always used the Mysqldb module... is there a benefit to this? 
What's the traceback ? You can post on the mailing list. http://librelist.com/browser/flask/ Regards,
Tornado web server.
Good job mate!
How have you got Python setup (ie. are you using cygwin, or the Windows Python install)? And what are you want to use pydoc for - reading others' docs, or generating your own?
Windows Python install, and it's to generate my own.
OK, sadly, I don't have much experience with Windows' Python (I use cygwin when I'm on Windows) so can't offer much help there... but if you're generating your own, I'd recommend [Sphinx](http://sphinx.pocoo.org/) over pydoc. Sphinx is rapidly becoming the new standard documentation tool (Python itself is documented using Sphinx now) and is much nicer to use :).
It seems like he wants us to use pydoc (I eventually just sent my stuff to a unix machine to do it, but wanted to know for future reference), but sphinx does look nice. Thanks for your help!
No problem :). If you're stuck with pydoc, it's likely your machine just doesn't have it installed. In which case, you should grab [Setuptools](http://pypi.python.org/pypi/setuptools) (there's a Windows installer in the Downloads list), and then ``easy_install pydoc`` (maybe ``epydoc``? I'm not 100% on what the package's name is, but you should be able to search [PyPI](http://pypi.python.org/pypi) easily enough :)).
This probably isn't helpful for a budding programmer. You have just given them the answer, rather than trying to help him find it by little hints. I think I would have recommended they take a look at the documentation for the time module. Say it is explicitly in there, and then have them jiggle around until they find the way. Granted, it is a very simple thing. I urge you in the future, though, to help guide them to the answer, rather than hand it to them on a platter with the onions on the side.
"Hello World" benchmark with bottle and different server backends: Number of Requests: 10000 Concurrency Level: 10 Network Speed: local marc@nava:~/coding/bottle/bench$ bash speedtest.sh wsgiref Requests per second: 1358.84 (mean) marc@nava:~/coding/bottle/bench$ bash speedtest.sh paste Requests per second: 1433.14 (mean) marc@nava:~/coding/bottle/bench$ bash speedtest.sh cherrypy Requests per second: 2284.52 (mean) marc@nava:~/coding/bottle/bench$ bash speedtest.sh fapws3 Requests per second: 3422.48 (mean) marc@nava:~/coding/bottle/bench$ bash speedtest.sh meinheld Requests per second: 5270.66 (mean) 
Okay, but I see that many configure tests involve `check_run` ([here](http://github.com/erickt/fbuild/blob/master/lib/fbuild/builders/c/c99.py#L63) for example) and that these tests define "main". However, when cross compiling, this looks like it will require running separate executables on the target. What I want/need is a way to batch up all the conftests into one executable which the user runs on the target, then collect the results and finish configuring. Our [configuration system](http://petsc.cs.iit.edu/petsc/BuildSystem) does this, but it's a somewhat strange beast.
Why so?
On Windows the system clock (as returned by time.time()) only increments in ~1ms jumps. time.clock() on Win32 is a wrapper around getting a perfcounter time, which is the number of seconds since the first call to the function was made (the first call returns 0) but has much higher accuracy. This means you can't use it for absolute measurement, but for a delta it is way better. Unfortunately on *nix the opposite is true, the system clock is highly accurate and time.clock() returns the amount of CPU time used by the calling process (which really doesn't mean anything). Yes, this is dumb.
Thanks. Now why the hell doesn't Python just account for that transparently :(
Thats the dumb part. The problem is that the time module is a very thin wrapper over libc functions of the same name (more or less). Someone thought that maybe a perfcounter call would be kind of close to clock() (which has no direct translation in Win32) which isn't particularly true, but its no worse than anything else. 
Hello, 3000 line function :-)
I'm interested in using Logbook in my own package, but so far I haven't found a hint on how to use the same logging in multiple modules. To be more clear: in package /mypackage/ I have let's say 5 modules, each of which would like to use logging. Any pointers on how to use a "global" logging object?
by just making a logger object and importing it? its the same as any other "global" python object 
 # mypackage/logging.py from logbook import Logger log = Logger('mypackage') # mypackage/somemodule.py from mypackage.logging import log log.info('PROFIT!')
What's your interest in using Logbook rather than Python's built-in logging, since the main point of Logbook seems to be avoiding any shared state?
What is stateless about it?
It uses a stack instead of a [global] registry. &gt; The logging system is (besides the stack) stateless and unit testing it is very simple. If context managers are used, it is impossible to corrupt the stack, so each test can easily hook in custom log handlers.
The stack is shared too - so Logbook is hardly a "no-shared-state" solution. In many cases shared state is bad, but the logger registry in Python logging is provided because it makes developers' lives easier, and as the Zen of Python says, "practicality beats purity". Disclosure: I'm the Python logging package maintainer.
As I said over on r/programming: Pygame is all well and good, but why are people choosing it over [pyglet](http://www.pyglet.org/)?
What do you want the GUI to do? Since you're opening files and such, I'd look into [tkFileDialog](http://tkinter.unpy.net/wiki/tkFileDialog) module, which gives the user a nice file-selection box. (To be clear, tkFileDialog is a separate, but related, module from tkinter, and you need to import it separately.) I don't know what's your secret code or how you plan to convert it, so can't give you any advice there, haha. Let me know if you have any more questions.
`python.exe -m pydoc open` will display the `open()` builtin documentation. What exactly do you need to be *using* pydoc for?
I'm curious, what's the justification for that opinion?
Mainly, as someone else has said in this thread, I modularize my code highly enough that I can have concise variable names. After that, I usually go with a post-fix description, like `total_unpaid` and `total_paid`. This falls in line with the `module.class.method()` hierarchy where it goes from most general to most specific. However, it's also more important to keep consistency within a package. If they have `unpaid_total`, and I add to their package, I would make a variable name `paid_total`.
http://erngui.com/prog/hungarian.html "Don't do it. It makes refactoring more difficult..." It mixes logical and implementation details where they should be separate; the benefits of knowing a variable's "type" in the name are outweighed by its stickiness when refactoring. Besides, it's ugly and hard to parse without extensive experience (it's the perl of naming conventions).
What about threads and processes? Attaching information to LogRecords? Using logging for a web applications causes a multitude of problems.
&gt; Had to write one on my own because everything else I tried wasn't even close to support all major elements and markup so instead of helping them, you reinvent.
great, ofc you didn't bother to check out sources, to even see if its possible to help without resorting to full rewrite. Think twice before you write a stupid statement like that because watch out.... you could be completly wrong - in fact i even asked one of makers to put the code to github, but it turned out not fixable, but how would you know that ;-)
The attribute name **lastrowid** is a suggestion from [PEP 249](http://www.python.org/dev/peps/pep-0249/): Cursor Attribute .lastrowid This read-only attribute provides the rowid of the last modified row (most databases return a rowid only when a single INSERT operation is performed). If the operation does not set a rowid or if the database does not support rowids, this attribute should be set to None. The semantics of .lastrowid are undefined in case the last executed statement modified more than one row, e.g. when using INSERT with .executemany(). Warning Message: "DB-API extension cursor.lastrowid used" 
Oh, really? I haven't found this to be so, and I have used logging for web applications without any trouble. If you can be more specific about the problems you have encountered, I will try to help you solve them. The logging package supports usage in processes and threads out of the box - except that you can't easily serialize access to a single file from multiple processes (that's a Python limitation rather than a logging limitation), but I believe if you use the multiprocessing module you shouldn't have any problems, and even if you don't use multiprocessing, it's fairly easy to set up a single process to write to the file and have the other processes send events via a socket to the writer process (there's an example in the docs). Note that logging is used in concurrent environments (e.g. Tornado, SQLAlchemy, GAE) all of which support web application development. As for attaching information to LogRecords (e.g. on a per-request basis in a web application), I believe the [docs](http://docs.python.org/dev/library/logging.html#adding-contextual-information-to-your-logging-output) cover this.
The secret code is: The eagle likes chocolate donuts. =) The GUI will do the following: Have the usual [save,open,exit], buttons, dialogs. Have a button to convert the text into the secret code. Have a button to convert secret code into regular readable text. A textbox to see the files would be nice. Here is a simple mock-up: http://imgur.com/HgP6f
&gt;The logging package supports usage in processes and threads out of the box - except that you can't easily serialize access to a single file from multiple processes (that's a Python limitation rather than a logging limitation) So basically you can use logging without any problems just don't log to a file (what about sockets etc.?) in threaded environments (which is the case for *every* web application)?
im pretty sure many use logging only cause there was no other reasonably complete logging package i'll sure as hell drop logging out of all projects i maintain now that logbook solves many of the issues i encounter much more elegant than logging did btw logadapter is not the same as contextal information for all loggers right in the core