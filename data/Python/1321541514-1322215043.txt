Actually, after thinking about it overnight, I don't have the position I held yesterday: What if you don't *know* that the code has bugs in it? What if the bugs are subtle? What if the replacement works the same (but faster) 99.9% of the time, but there's this edge case... I'll be honest, I'm not sure what problem you're trying to solve. I've been using Python for a very long time and haven't really had any issues with the module system. 
With python, to write a closure you do this: def outer(): def inner(): pass return inner This seems simple enough, until you need to mutate the enclosed state: def outer(): x = 0 def inner(i): x += i return x return inner This won't work in 2.x, and requires modification to work in 3.x (the improvement I was talking about): def outer(): x = 0 def inner(i): nonlocal x x += i return x return inner This works, but it's cumbersome (what should be nonlocal? should we just nonlocal everything? What if we miss something?). Lua's handling of closures is so much more natural: function outer() x = 0 return function(i) x += i return x end end As for coroutines, they're more of a hack of generators in Python. Again Lua has proper coroutines. I know the obvious answer to statements like this is "Just use Lua if you like it so much.", but I don't actually. It's standard library is vapor compared to python's, and python's more powerful constructs are just too tasty to avoid. In reality, coroutines and (to a lesser extent) closures are non-pythonic. This all goes back to writing python code as if it were some other language. 
I disagree. The documentation says: &gt; Create a new dictionary with keys from seq and values set to value. I am passing it the value [], so it should copy it. The documentation doesn't make me think I am passing a default object.
I don't have any recommendations, but the standard answer is to look on the [ads section of WHT](http://www.webhostingtalk.com/forumdisplay.php?f=45). If you're not familiar with the various kinds of hosting, what you're using now is shared hosting, as you share a server with a large number of other sites. It's the cheapest of all the options, and is usually characterized by hosts that lure you in with offers of unlimited storage and bandwidth. This is deception, pure and simple, because they always have clauses in their TOS/AUP that state that if your site gets too many hits or otherwise starts using too much CPU, they will suspend your account and/or make you buy a more expensive package. They are only able to offer unlimited packages for a couple of dollars a month because they know that most sites will use hardly any resources, and they know that they can always suspend any accounts that try to use too much. Some shared hosts do offer ssh access, but it's never root access. This means you can install things under your home directory, but not like you would as the administrator. Maybe virtualenv is a viable option here for being able to install your own modules, I don't know. It could depend on the details. The next step up is VPS/VDS, where multiple users still share one server, but it's virtualized and partitioned into guaranteed chunks of RAM/CPU/storage/bandwith. Here you get root access to your own server which means you can freely install whatever you want as if you owned the machine, but you're still sharing with others. At the low end you can find VPS plans for $5-10 a month, so it doesn't have to be costly, but you do have to be your own server admin which for some people might be an issue. 
It makes doing a jumptable optimisation much simpler. In ASM it's a common idiom to basically just use a table of addresses (your case statements) and an integer (your switch value) and jump directly to the corresponding address. This is nice and quick, but if you only had a tree of if/else statements it would be much more complex to write a compiler that could optimise it to a jumptable. The first C compilers were not especially exciting (compared to what we ar used to these days) partly because there just weren't that many highly optimising compilers around back then. Now there's loads of well practised knowledge about developing complex optimising compilers. So obviously they made the language in a way that they could actually implement, and since they were coming from assembly they wrote things that let them express the sorts of things they would do in assembly. Given the state of modern C/C++ compilers I suspect that we'd never even have bothered with switch. Or at least it would have much greater flexibility and utility than it does now.
I don't know what you mean by `exit` and `quit` being special cased but this works: z = exit exit() Anyhow, exit could have been a keyword like `break` or `return` though I like it better as a function so I can easily use it in the python switch idiom. 
[This is a dupe](http://www.reddit.com/r/Python/comments/m67s3/pep_405_python_28_release_schedule_never/).
You can implement it: https://gist.github.com/1320421
I came looking around because I wanted to write my list, but this one is awesome. Maybe also a better default interpreter like http://codespeak.net/pyrepl/. The default interpreter is very barren, the one that comes with idle too.
Sounds like you could use a better IDE. 
Sorry, but, at least in the case of C#, you're wrong. I wrote up a little test app that does the same three comparisons, once in a case/switch statement, and one as a chain of if/elses. After compiling and disassembling, the code is identical between the two. They both compile to a series of branching jumps. Java also runs its own bytecode, so I would imagine it performs similarly. I don't know about C++ yet, because I haven't tried disassembling one of those yet.
A switch in C is really a forward goto though. You can do ugly stuff like switch(val) { const char *str; case 0: str = "0"; if(0) case 1: str = "1"; printf("%s\n",str); } not to mention Duff's device. Of course, those abuses are not a valid reason not to implement switch for the common use cases. 
If you don't have the application written already you should develop it locally before you start looking at hosting. How you write it will inform what kind of host you'll need. Other people might disagree with me, but I think if you've never looked at Python web frameworks before try Django out. If for the only reason that there is large amount of learning resources available and it's fairly mature. If you don't like it move to Pylons, Flask, CherryPy etc...
I'd rather see the condition *after* the loop. Python has been described as executable pseudocode, and it should read like it runs: do: iterate() until condition() 
On the other hand, I find parts of Haskell really easy to explain to people who have some measure of mathematical experience. It really does look like math, and this is appealing for certain types of people.
Note that usability guideline doesn't say 4 inches is optimal either. This isn't a novel. After indentation for a class, method, condition, loop, condition, you're not left with much area to work in if you stop at 80.
I know. My point still stands. Without an explicit first argument, you couldn't do what I described.
Hold on to your hat. It is very likely that Ubuntu will ship Python 3 as base essential -- all Python system tools written in it -- in 12.10. (All other versions installable with APT, of course.)
&gt; The documentation doesn't make me think I am passing a default object. What does that even mean, a default object? The value you passed, [], is the value to every key, as the documentation says. The documentation says nothing about making a copy of your value for every key. How would it go about it anyway, using copy.deepcopy? 
I get burned by utf-8 handling quite often. I wish there were better support for encoding stuff in general. 
* Some weird things are globals and not methods (len(), sorted()...) * The syntax for deleting an item from a dictionary rubs me the wrong way * The fact that you don't declare a variable before using it result in weird hacks like the "global" keyword * Multi-line lambdas would be nice * "yield" is somewhat broken in that it's hard to use for (say) coroutines, or really anything other than simple generators
True enough, from a readability point of view, 80 characters of text *sans indentation* is probably optimal.
They can go die with those prices. What does that thing have that any other combination of tools to get realtime doesn't? Let me tell you: absolutely nothing - maybe just a PRICE &gt; 0! The way I see it: a-holes discover python -&gt; they proceed to learn python -&gt; they launch their "greatest" work ever (since their previous work was probably all php junk code before) -&gt; they hope to get rich off the back of people who would license their "amazing creation". Thank you, but this reddit submission gets a downvote for the crap it really is and CookedNoodles gets an upvote for noticing that page. 
He also put the test for your variable on the left side of the or, which (because of lazy evaluation) means your condition is not tested the first time. It also means the firstrun/hasrun variable gets tested and fails in every subsequent run of the loop, which tickles my premature optimization senses as a bad thing. Profile it to make sure.
Another tool, if a lot of the time is spent in the runtime you can use `valgrind --tool=callgrind` + `kcachegrind` to see what functions in the runtime are taking up time.
He did do that, didn't he.
&gt; I don't know what you mean by exit and quit being special cased They aren't part of the language but are patched in such that they appear to be. &gt; but this works: I don't follow the significance. &gt; Anyhow, exit could have been a keyword like break or return though I like it better as a function so I can easily use it in the python switch idiom. Which is exactly what you should not do. ``exit`` was put in as a convenience for interactive use but because of the haphazard way it was added, it is now left in to avoid breaking applications that used it but should not have.
One could complain about the lack of quirks which can make programming boring in the long run. ;)
via [fijal](http://lostinjit.blogspot.com/2011/11/analysing-pythons-performance-under.html).
It is highly confusing that they swapped PEP identifiers like that. Any idea how or why that happened?
&gt; Sorry, but, at least in the case of C#, you're wrong. It's entirely possible that C# doesn't make jump tables from switch statements. I never said it did. I'm fairly sure it does in Java and it generally does it in C and C++ too when the compiler thinks it's a good idea. Also how do you know C# just doesn't leave it up to the JIT compiler to decide what would work best?
The bugs issue still isn't relevant. You could have subtle bugs in any module.
No, of course not. I just think they should be compared by identity.
What the JIT compiler does is fairly irrelevant here. The code that the JIT compiler sees *is* a chain of branching jumps. It doesn't see the source code as I typed it (the case/switch statement versus the if/else chain), so it has no idea what the original context was. I wouldn't be at all surprised if the JIT compiler *did* compile down to some form of jump table, which would only go to prove that case/switch and if/else forms are equivalent. I guess I don't completely understand your beef with it. If it's just a readability thing, that's fine, that's something that varies from person to person. But from a technical standpoint, there isn't a difference between the two, and if a compiler can't treat the two identically, I'd have to wonder what bizarre assumptions it's making.
For the joke "PEP 404 Not Found"? (I'm aware the un-release schedule is 404... I was trying to be silly...)
My comment is correct. Python does the equivalent of ``num_range.extended_range(nr1, 9)`` but that is not what it actually does. When you access ``nr1.extended_range`` Python creates and returns an instancemethod object which is a callable object containing im_func and im_self (and/or ``__self__`` for Python 3). The ``__call__`` method of the instancemethod object then invokes ``im_func(im_self,*args)``.
Yes. The difference is that, in C or C++ or Java, you can "beautify" the source by applying an algorithm that will automatically indent in a consistent way, and find trivial errors as well. For C/C++/Java source files, you can left-flush the entire file so all indentations are lost, and (a) it will still compile and run, and (b) you can beautify it again, thus restoring its appearance. On the other hand if you left-flush a Python source file, you have to hand-repair it because you've sacrificed essential information. 
It's really an issue?
I find myself actively filtering out tabs on important projects, especially if I had previously used (programming editor) KWrite on the Linux platform, which unless explicitly reconfigured will auto-indent using tabs. 
When identifiers (and URLs) change, it just creates annoying problems and confusion. E.g.: * https://www.google.com/search?q=pep%20404 * http://www.reddit.com/r/Python/comments/lu334/pep_404_python_virtual_environments/ Am I losing sleep over this? No, not really. But I guess I feel like they should know better than to swap identifiers and URLs around.
[Relevant](http://mail.python.org/pipermail/python-dev/2011-November/114427.html) Basically they thought it'd be funny to have un-release schedule called "PEP 404 Not Found" and author of PEP 404 agrees. One member did suggested it should be "PEP 410 Gone" rather than 404, though.
Well, yes, but it takes 30x-60x more time to run your application. Sometimes unacceptable
Ah, thanks. I had a feeling a logical explanation was hiding somewhere. :)
except that it's not supported in 2.x branch
Very true, the whole point of Python 3 was fixing things that were done incorrectly and this is a good example that was fixed :-) Not invalidating the complaint, just showing there is a solution out there.
Yes integers are mandatory in C and, no, the fallback method in C is the binary search. If this increased look up speed isn't included, then there really is no use for a switch statement in a language.
The documentation asks for a value. Generally, that means that it is copied. When you pass a value to a function (in C) it is copied. When you pass a reference to a function (I am using the term object), it's memory address is passed. Here is a for instance if you call xs = dict.fromkeys(range(2),0) xs[0] += 1 You get a new shiny value of 0 for each key, and the second line doesn't modify them all. It's copying 0 into each key. If you do i=0 xs = dict.fromkeys(range(2),i) This also copies a new value of 0 into each key. Not a reference to the object i. My complaint is that this function has different behavior depending on type. If i is a dict or a list, you get the same problems. So why does it use a reference to the object as the default for some data types, but actually copies the value when it is others?
Is there a doc/PEP I can look at?
We're not talking about the "exit" variable bound to an explanatory string that's there now: daike's suggesting making "exit" actually exit the Python shell be modifying the REPL to intercept that input (ie. instead of a read-eval-print-loop, there'd be a read-if-"exit"-then-exit-else-eval-print-loop.
You are confusing things, please let me explain. In Python, *everyhing* is passed by reference. Don't believe me? Check this out: a = 234 # think of id as the memory address of a variable print id(a) # prints 37566368 def test(v): print id(v) # prints 37566368, because a is passed by reference. test(a) b = a print id(b) # prints 37566368, because b and a are the same so far Now you need to know that there are *mutable* and *immutable* types in Python. strings, ints, floats, tuples are immutable, lists, dicts, and basically almost everything else is mutable. Immutable means that the value cannot be changed. If it should be changed, a copy is made. To continue the example of before: # this does not modify the value of `a` in place because ints are immutable. a new integer is created. a += 1 print id(a) # prints a *new* identity, 37566392 print id(b) # prints still the same, 37566368 This is why in your example, an integer value for the dict seems to be copied. It is not, it is copied the moment you modify it. On the other hand, lists are mutable (modifiable in place), so its id() stays the same. I hope I made things clearer. If you have any questions, feel free to ask them.
The directory structure would start out as: &gt; mycompany/ mycompany/__init__.py &gt; import mycompany # executes __init__.py &gt; import mycompany.bestdivision # only need one .py file, no subdirectory needed unless making a subpackage. &gt; # subpackage like: mycompany/bestdivision/ mycompany/bestdivision/__init__.py import mycompany.bestdivision # runs __init__,py. 
&gt; We're not talking about the "exit" variable bound to an explanatory string that's there now We are not because that isn't what we have now. ``exit`` is bound to a site.Quitter object. &gt; daike's suggesting making "exit" actually exit the Python shell be modifying the REPL to intercept that input (ie. instead of a read-eval-print-loop, there'd be a read-if-"exit"-then-exit-else-eval-print-loop. I'm not sure that's what dalke is saying, but you do not need to do that. [I've already posted](http://www.reddit.com/r/Python/comments/mejfc/are_there_any_things_about_python_that_you_do_not/c30flsg) the change necessary to have ``exit`` exit the REPL instead of displaying information about calling exit (something that has caused a wart in Python because now applications can call exit() instead of sys.exit()).
Amazing idea, thx for the submit
&gt;That would imply stuffing everything under the sun into some class or another with all that entails, but that's not what I was trying to advocate. lol, you're taking me too literally. That was just a quip meaning "you're forcing things that aren't naturally classes into being classes". &gt;When you have a function that needs to persist state across calls, you're either A) Not really in need of a function, but a method, B) Need to supply that state to said function as an argument or C) Use currying as appropriate. B. begs the question of how to save the argument state between calls (and how to get it back from the function). It sounds like you're suggesting using a global variable to hold the state (or else passing it along as an arg to every function in the system, ie. "state-threading"). C. doesn't really make sense. I assume by "currying" you actually mean "partial application" (ie. making a version of the function with some argument built in), but again, this just begs the question of how the state is being stored and transmitted. BTW, the use of mutable default args, like in cosmologicon's post above, is actually just a form of overridable partial application. Look, there are several ways to persist state between calls: * store it in a global. * thread the state through every function (and other callable) involved, so it's being passed along from procedure to procedure. This is basically a purely functional way of doing global variables. * use a closure (in 3.x) * use a class method * use a callable instance (with persistent state stored as class attributes * use a mutable default arg * (have I missed any?) Of these, the first two really do have issues, but the rest are all credible choices. You're insisting we must always use a class method to make calls that have persistent state, even if a function may be the more intuitive choice. I'm saying there's no reason for such an arbitrary restriction. It just makes code look contorted and unnatural. Sometimes a closure is just what's required: if I don't need the full power of the class system, why should I have to use it? As for mutable default args...well, mainly I see them as "pseudoclosures" that can simulate closures in 2.x, but the truth is, I don't perceive them as hacky at all. I did a little, at first, but now they just seem like the natural way python default args work...and they provide quite a concise - even elegant - way of persisting state. I haven't really started using Python 3 yet, but when I do, I won't be surprised if I occasionally still use the technique. 
&gt;But then your API changes for everyone else. exactly - it's not worth contorting the interface (not to mention sprinkling the function's internal code with "()"s) just to save one line initializing the default. I like elegant code, but elegant interfaces are even more important. 
I'm actually not confused. I understand why this is the case, I am sorry if I was not clearer about this. I understand the difference between mutable and immutable objects. As the thread is things that you do *not* like about python, this is one thing that I do not like. Mostly, I don't like this because I can't think of a case where you would want the current behavior. Why would you need all the keys in a dict to be paired with the same object? I understand that in the mutable case, this may save considerable space over copying, but if you really want all those keys to be paired with the same object, creating a dictionary seems unintuitive, and maybe the code should be restructured. It may also save space in the immutable case, as you only need to create new objects when you modify the existing ones. But, if I know a priori what my keys are, chances are I know all of them will be modified in some way (if they weren't why store them in a dict?). It's not a misunderstanding of the way things work, I understand why this happens (sorry if I didn't telegraph it), but it doesn't seem natural to me in this case. I guess maybe if different collections of keys are meant to point at the same object? Something like l1 = [] l2 = [] xs = {} xs[0] = xs[1]= l1 xs[2] = xs[3] = l2 But you could almost certainly do this in a more natural way...
&gt; Whereas classes are a namespace, not a scope. I thought these were generally synonymous. Is this a standard distinction, or just one in Python?
I've had to maintain other people's python code, and I've written some. For the last few years I've been doing mainly perl, but I really do like python. That being said, python sucks, and its community sucks. This isn't particular to python; every language sucks, just in different ways. Python's community is just more defensive than most others, which is sad as I think it makes it a weaker language than it would be otherwise. Python sucks because it isn't expressive. For a long time, I thought that python was trying to be a better perl. This confused me a lot, since python is dreadful at being expressive. After a while, I realized that python is a really crappy perl, but it is an absolutely wonderful Matlab. It's also a much better C++ and Java for many of the things that they are used for. Going in between some Matlab code and python is really the clearest one for me though. Both are designed to split up obnoxiously tricky mathematical code into digestible and maintainable snippits, python just does is 100 times better. If python became expressive, it would suck in other ways because of it. Python sucks because it fails at OO. There is that horrible awkward split between builtins and module code. They just feel different and out of sync, and it makes things unpredictable. Ruby does a lot better job here, and perl admits that it is a problem and has some modules to let you do things consistently. I haven't worked a ton with python's classes, but they seem much more limited and awkward than what I am used to (Moose). Python sucks at testing. Okay, it is miles ahead of PHP, so the ease of testing perl code might have just given me unfair standards. There isn't a lot of good, easily googleable documentation on how to test complex code, and the testing libraries don't make things nearly as easy as I'm used to. (Or I'm not able to easily find out how to use the good stuff) Python's community doesn't consider that you might want to do something different, which sucks. It appears rare that factories allow you to pass in a custom class for the objects, and the code in modules seems to be written with specific use cases in mind. I know the second is a bit nebulous, but I'm really not sure how to explain it better (give me a year to really get used to python). I find python modules very hard to plug together compared to perl modules. I think the perl community is very used to stringing together a few dozen modules, adding some secret sauce, and packaging it back up as something new. From this experience, they are used to writing code that will be used by other code. My experience with python is that most of the code is more of a matlab model, where you get a library that you use in a script the way they intended, and call it a day. That's most of the big ones. It's a good language, one of the best, but it still sucks.
I guess I can sympathise with the view that identity comparison is the more fundamental operation on mutable values. That makes sense. Even make equality require more work by making the programmer write their own value comparison function -- that could have its benefits. But using an operator that has a quite different meaning in another context is a horrid idea. It enshrines the idea that the meaning of a line of code is dependent on what might be going on in other source files .. yuck. On the other hand, I guess if we throw away the conceptual distinction between equivalence and identity, we can immediately go the extra step and bring approximation under the same banner so that `==` can be used on floating point values.
So I don't own the code for the mycompany module, but am making a subpackage, so do I just leave that structure empty? 
&gt; It sounds like you're suggesting using a global variable to hold the state Negative. I'm not advocating the use of globals. &gt; You're insisting we must always use a class method to make calls that have persistent state, even if a function may be the more intuitive choice. Not at all, although that *is* what I would do in cases where said state can be reasonably modelled as an object. That's why I mentioned B as an alternative to A. If a function is more appropriate, it should be operating on a object or objects representing the state that one wishes persisted between calls maintained by the calling code. You make that sound a lot worse than it has to be though. While true that one *can* write code that ends up having to pass down a lot of arguments deep into a call hierarchy, that is to me indicative not of a flaw in the approach but in the design and implementation. In order words, that would be symptomatic of Bad Choices having been made elsewhere. Currying was my mistake; Forget about C then. &gt; It just makes code look contorted and unnatural. It certain can, yes. &gt; I don't perceive them as hacky at all. Well, if it works for you, that's great; By all means carry on just as you like. I just don't feel like following suit.
How would you implement dict.fromkeys? Would you seriously take the value and copy.deepcopy it for every key? I think the function as it is now is intended to be used with immutable values for the value parameter. A hidden deepcopy would be too much in most cases. The dict comprehension is the better option in any case, I believe, as it clearly shows what is intended, and works for your case too.
The difference is that approximation is parameterizable. :) making "x == y" equivalent to "abs(x - y) &lt; EPSILON" wouldn't be reasonable since people have different ideas about epsilon. I don't think that it's fair to say it has "quite a different meaning in another context". The fundamental question "x == y" answers, in the scheme I'm suggesting, is "can I substitute the use of x for y (or vice versa) with no change in meaning or behaviour?" Further reading on the topic: http://home.pipeline.com/~hbaker1/ObjectIdentity.html 
I'm saying that I don't want "exit" as a builtin, but it's not hard to see how it could be a keyword, like return, which is a synonym for raise SystemExit(). A good friend of mine some time back started with Python and one of the very first things he asked was "why doesn't exit do the right thing?" I sent him code which replaced exit with something whose __repr__ did the raise SystemExit, which made him much happier. It could even have been an repl-only extension, as "_" is; that seems to be what IPython does. But as for me, ^D or ^Z is fine.
create the bestdivision subdirectory and put in the: __init.py__ file.
This proposal adds a new keyword, and the only line of condition-based control flow in Python which does not end in a ":". That seems like a lot of change in order to save a couple of lines and improve readability only slightly. I think a better alternative is: while 1: print("iteration") break if condition() but it goes against the idea in Python that control flow should be obvious. For example, a simple scan of while 1: print("iteration") break if condition() print("Still going!") doesn't highlight the break statement as well as: while 1: print("iteration") if condition(): break print("Still going!") 
Python has significant indentation.
If you are using the versions of the libraries that came with Ubuntu, then this is an Ubuntu issue, please take it up with them. If not, then you can tell us which versions you are using.
Man, Zed's write-up hits a bunch of nails on the head for me. It's exactly how I've felt. I think I remember asking why there wasn't some command that was the inverse of another, and I was told by many pythonistas to use slice notation, and to stop complaining, because this was the accepted way to invert the method. I've run into this several times. He closes saying that it's a programmer affliction, and I must agree. I've worked directly with programmers who have that mentality. They'll write one operation one way, and half-ass the reverse of it through some other, non-intuitive way, then argue and get defensive about it until you give up and go away. The conceptual purity thing is a pain. I have code that won't work between 2.5 and 2.6, and it comes down in some cases to a simple thing like 2.6 needs parentheses around part of an expression.
The more I'm hearing about Ruby, the more I'm liking it.
I'm starting to feel this. As expressive as Python once felt to me, it's starting to feel rather limited, which has come as a surprise. I feel like I'm hitting the walls on what it can do already.
See also http://pypi.python.org/pypi/pyprof2calltree/ , a slightly slicker packaging of this code.
Check out this wiki page, it describes many different types of parallel processing: http://wiki.python.org/moin/ParallelProcessing Personally, I would just setup hadoop on each of the servers and distribute that way. It's really quick to setup, and handles things like fault tolerance for you. It would easily max out all the servers, and if you have 130k you need process, your input file would just be one row for each calculation you need. You can use Amazon's Elastic Mapreduce to get up and going almost immediately in a distributed environment (and it's relatively cheap if you keep the server size small). That way you can play around with it without devoting a lot of time to initial setup, and move to your own cluster as you want to process the full calculations (or just fork over the cash if you want to have AWS do it).
I would look into [zeromq](http://www.zeromq.org/) for very straightforward multiprocessing. Combined with [python bindings](http://www.zeromq.org/bindings:python) you can whip up some powerful code quickly. I've spent most of my past year working on a system leveraging zeromq for process scaling and [redis](http://redis.io/) as a sort of shared memory. 
My apologies in advance if I'm about to teach my grandmother to suck eggs, but in case it's of value, a few thoughts outside of the clustering idea too. 1) Have you considered porting to [Cython](http://cython.org/)? I would assume you'd be in a position to be able to declare the type of variables with fair confidence. 2) PyPy? It might speed the whole thing up for you with no work re-factoring your code. 3) Use c variants of the modules instead of pure python, e.g. cmath instead of math (I'd imagine you probably are) On the clustering front, ZeroMQ or RabbitMQ message queue programs both have python interfaces. It should be relatively straight forward to [leverage one of them for clustering](http://taotetek.wordpress.com/2011/02/02/python-multiprocessing-with-zeromq/). 
Yes, I do. I shouldn't have to run my code until I know what exceptions it might toss. While I've gotten a lot better at this, it's still a constant pain. It's possible my workflow is completely broken, but considering the number of python applications that I see that die horribly with a runtime errors, I am not alone.
I though 2.7 was the last of the 2.x series. Will 2.8 be it?
I don't think a custom MQ-style solution makes sense in this case. (Same comment to food_eater above.) There are good pre-written methods of distributing work, some mentioned by rckimbr above. To which I would add that *mincemeat* is a pure python map-reduce. Even copying a subset of data to a usb stick and physically walking over to the idle workstation would be more efficient than learning MQ-stuff just for this purpose. However I agree about checking that the code is optimal before thinking about parallelisation. In addition to your options, numpy should be considered. And as always, try profiling to understand what part is slow.
I profiled the code and most of the time is spent doing FFTs so I didn't think there would be much benefit to using Cython.
This doesn't directly answer your question, but I'll ask anyway: could your algorithms be improved? If you're willing to post the source code, I'd be happy to take a look. I'm not an expert but I find it enjoyable.
I've used EfP somewhat in the past, though my config has moved pretty far from its defaults by now -- do you know much of anything regarding how PDEE stacks up ideally to EfP? That is, differences, advancements, regressions, etc.
As for the livecd, you might be thinking of the Ubuntu Enterprise Cloud installer; https://blueprints.launchpad.net/ubuntu/+spec/server-maverick-uec-liveusb has some breadcrumbs, I haven't followed it in a while (that link predates the switch to OpenStack, for example.) (For 3 machines, I'd suggest just copying subsets of your data around first, *then* looking for more clever approaches while it's running :-) 
I'd lend you my time machine, but sadly it's out of fuel. It baffles me to think some people do things that are this complex. All I do in Python is penis mountains.
It looks like it's the same developer (gabriele lanaro). I think he's putting his time into PDEE.
Use ssh to send the input data to the remote machines and remotely start a python consumer. Easy as pie. You don't need anything particularly fancy here if you're just spinning up workers on 2 or 3 machines.
i had some success farming out simple jobs using gearman. i have friends who had good success with mr. job as well.
Here is the repo: https://github.com/arkottke/pyrotd
I did something very similar to this for my PhD thesis. I spread a bunch of independent calculations across dozens of grad student computers. Typical parallel processing solutions may be overkill since your calculations do not need to communicate with each other (I presume). All the computers I used had a network file system, which made things very easy. I had a small script that would ssh to each computer and start the calculation. The starting parameters for each calculation were obtained from a lockable file on the shared file system. The file contained a pickled list of starting parameters. Each process just had to lock the file and pop an item off the list, save and unlock the file. File locking is generally frowned upon, but it worked great for me since it was very simple situation. Eventually, we installed Condor ( http://research.cs.wisc.edu/condor/ ) which does exactly what you want. It will even pause the calculation if someone starts using the computer. If you're only using a total of three computers though, it doesn't seem like it would be so hard to just split the calculations into three chunks and manually start on each computer. Especially so if you have a shared file system.
I agree that it is probably easiest just to split the calculations into batches. I was interested in clustering just to tinker with something new.
Nope different, developer. This one is andreas-roehler: https://github.com/pdee/pdee Edit: correction: it's both of them.
No. 
It's both of them: https://github.com/pdee/pdee/contributors
PyInstaller is not in your list, and I have had a lot of success with writing one .spec file and my program compiling on windows Linux and mac, so I suggest giving it a try if you haven't. actually, this is the only error i have ever encountered with it, and is easily solved: http://www.pyinstaller.org/ticket/159
Stick the tasks in a [celery](http://celeryproject.org/) queue, run workers on the individual machines. Easy peasy!
Is it asking that much for you to read the link before responding?
I'm surprised no one has mentioned [IPython's parallel capabilities](http://ipython.org/ipython-doc/dev/parallel/index.html).
This is definitely the kind of code you want to rewrite in C/C++. You can easily get x10 if not 100x over that kind of tight loops. And don't forget to profile it!
Try using [Pyro4](http://irmen.home.xs4all.nl/pyro/)! It's more lightweight than [Twisted](http://twistedmatrix.com/trac/), and fairly easy to set up a distributed task processing system with name server, dispatcher and any number of workers. There is an simple example in the source (examples/distributed-computing). Good luck!
have you looked into map/reduce frameworks, particularly hadoop or hive? they're designed to tackle large calculations really, really quickly by leveraging distributed computing. if you must use python, i would try to employ a map/reduce strategy and utilize numpy wherever you can. using multiprocessing helps, but you should have multiple nodes that can receive data, compute them, and feed them back to a master node. another really easy route is using gearman and supervisor on multiple machines - you just have to queue up the job server, and supervisor makes sure your python scripts are running. your python script is responsible for receiving jobs from the queue. this is a really elegant solution because multiprocessing and networking are complete afterthoughts because they've been abstracted. 130k jobs can be done in 22 days if you found 10 machines with 8 processors. [derp](http://mikecvet.wordpress.com/2010/07/02/parallel-mapreduce-in-python/) [disco project](http://discoproject.org/) [mincemeat.py](http://remembersaurus.com/mincemeatpy/) but a [hadoop/hive](http://hadoop.apache.org/) is your best route. but it's a bitch to set up. also consider your hardware limitation. your laptop and two workstations isnt going to be enough, even if you have hadoop installed -- which is your best solution, because JAVA computes data quicker than python. the best comment i've read here is to spin up an mapreduce instance on amazon. you can make your cluster as large and performant as you need and you can solve your problem in a matter of hours. 
I tend to use ipython a lot when I am developing/debugging so I will definitely check this out. Plus it has docs generated with sphinx!
I guess you didn't like my joke :-(
The loops really aren't that tight since most of the CPU intensive work happens with numpy arrays and FFTs. As mentioned, I have profiled the code and the biggest factor is all of the FFT calls. Also, similar code written in FORTRAN only reduces calculation time by about 30%.
To quote Gabriele (EfP README from git HEAD): &gt;The starting point is emacs-for-python itself and I’m developing new features mostly there *[in PDEE - dhr]*. So, for old/current users I’m always there for you, but if you want the package of the future go for PDEE!!!
What are you using to compute the FFTs?
I agree that the order of the second is more natural, and I support efforts to bring something like it to Python, but losing the name isn't really the advantageous part. Why not call it `normalize_to_lowercase` or whatever? It could be a useful clue to future debuggers.
I was confused because the `a = g(x)` was on the same line as the colon. So basically he just wants `def` without the name.
MPI
I really like the way you write and comment your code. Reading that was very helpful. Thanks
Yes, I would highly recommend this. You can do everything with 0MQ -- multiprocessing on a single machine, on several machines, in one-to-one or one-to-many or many-to-many or whatever-you-want configurations... and the best part is that it's always simple.
This. So easy to set up and get running.
Another SSH solution: [WinSSHD](http://www.bitvise.com/winsshd) is free/inexpensive depending on the license you require. I've been using it for a while now and never had any problems with it. AFAIK, it's not based on Cygwin. Plus, it integrates tightly with [Tunnelier](http://www.bitvise.com/tunnelier) if you need to do any digging ;)
cool, didn't know about it.
I've tried 3 or 4 times to get pymacs/rope/ropemacs integrated into my emacs env. Each time I wind up nowhere. This is by far the hardest and most frustrating integration effort I've had to make in my ~6 years of using emacs. 
Assuming it's been profiled and sufficiently optimised, I'd just use `parallel` to send the jobs to different machines. It's basically just an advanced `xargs` that can ssh into machines and run the jobs there. It's probably not the most elegant solution, but it should get the job done and be quite quick to set up.
For some weird reason, I recently reached a point where I could no longer produce a valid .exe in my Fusion virtual machine. I still haven't found out why. During that panic, I tried EVERYTHING I could find and ended up going back to py2exe after I accidentally discovered that building on on C: produces a valid .exe (my Projects folder is on E:) I tried PyInstaller, I tried cx_freeze. All had their issues. I do remember pyInstaller fondly. It did things a little bit differently than I was used to but I remember liking some of the interaction. I fail to remember what was wrong with what it produced but I do remember that I tried it before uninstalling/reinstalling a couple of versions of python, wxPython and definitely before reinstalling Windows. 
Nope, Python has a distinction between the two. [Python Scopes and Namespaces](http://docs.python.org/tutorial/classes.html#python-scopes-and-namespaces)
Strange, I'm reminded of Ruby's [until](http://www.techotopia.com/index.php/Ruby_While_and_Until_Loops#unless_and_until) (which is NOT a do-while loop)
I don't know what kind of language you could use that would make it *obvious* what kind of exceptions would be thrown? You can make really informed guesses, but to be certain it would require looking through documentation+bugfixing. Python allows you to rapidly determine what exceptions are being thrown, however.
I think you meant KSM, KMS is Kernel Mode Switching.
I've run your code and profiled it. 80% of time is this function: {numpy.fft.fftpack_lite.rfftb} 
If your programs need to share data whilst running, you should consider using [pupyMPI](https://bitbucket.org/bromer/pupympi) ([pupyMPI docs](http://diku.dk/hjemmesider/studerende/bromer/pupympi/index.html)). It's basically MPI implemented in pure python.
Nitpick: "Setting", rather than "Switching".
It's definitely worth a look. I think it's the best language for quickly throwing stuff together. http://ruby.learncodethehardway.org/ might be a good place to start - I've not read it but people seem to like it.
How have I not known about this
There's [PEP-3150](http://www.python.org/dev/peps/pep-3150/), which proposes: sorted_data = sorted(data, key=sort_key) given: def sort_key(item): return item.attr1, item.attr2 ..but I suspect it's unlikely to be implemented, at least any time soon
Python 3 has function annotations ([PEP-3107](http://www.python.org/dev/peps/pep-3107/), which could almost be used to make something that looks like static typing, http://stackoverflow.com/questions/1275646/python-3-and-static-typing
Hm, I imagine it would be possible to write an emacs mode to display the `#end if ...` lines, without actually modifying the file..
As suggested in comments up a bit.. def blah(): print "Optional syntax seems.. unnecessary" # end ...or: end = None # ... def blah(): pass end 
 hostname = 'rm *' hostname = `rm *` ..seems like as good a reason as any to require a slightly more explicit means of running subprocesses
The amount of file stat'ing the import mechanism performs. When `import mymod` is imported, every directory on `PYTHONPATH` is checked for mymod with .pyc extension, .pyo, .py, .so. It also checks a lot of __init__ files and such With a lot stuff on PYTHONPATH, and all of those being on NFS mounts, it can cause noticeable interpreter startup slowness The other thing I dislike is Python 3. It's definitely a "better language" for it, but it's just too impractical to port given the benefits
Whoops, my bad. Sorry :)
Aye, crap. I thought I was reading from the head. Sorry, my mistake.
Not quite a distributed solution, but have you considered writing an implementation of the FFT routine using Cuda or OpenCL? This seems like the kind of problem where the GPU might be able to give you something like a 50-100x speedup. Also, the Cuda SDK comes with a couple of examples that use Fourier transforms on the GPU (for creating ocean waves for instance). 
Especially since your problem is embarrasingly parallel and require little communication I'll say pupyMPI would be a fast way to leverage a cluster. I am assuming that you have SSH connections to the computers that you plan to utilize.
What? state = [st for s in state for st in states[(s,letter)]] is equivalent to state = [] for s in state: for st in states[(s, letter)]: state.append(st) (and that's why I prefer C#'s syntax: `from s in state from st in states[s, letter] select st`)
Actually, this will not work because state inside the list comprehension does not refer to state outside the comprehension. The line correspond to: new_state=[] for s in state: for st in states[(s,letter)]: new_state.append(st) state = new_state
So for a given set of states find all possible next states. I'm not sure what's so hard to understand. It's pretty cool though. Pretty cool, though. I might have to use it sometime.
That should be equivalent to: state = [states[(s, letter)] for s in state] Which I take to mean, that *state* will contain all states that are reachable with an input of *letter* from the states contained in *state* before that line. That would be exactly what you would want to do to simulate a NFA.
This is not strange at all. The guy just had the order of iteration for the comprehension syntax backwards. What I'm surprised by here is that they stored the current states as a list rather than a set. This is exponentially less efficient in some cases.
Like many have said, this isn't super complicated. After doing functional programming for a while I got obsessed with using map/filter in python, and then that lead to an obsession with using list comprehensions everywhere. Rather than "Strangest line of python you have ever seen : NFA simulation" the title I would have chosen (relative to my own experience) would have been "Most lines from that shitty unreadable code you wrote two years ago when you thought compact and unreadable code was cool".
you need to flatten it so you can use state in the next iteration. that's pretty much the only role of the second for loop.
You're right. I just skimmed it and missed the fft call.
I shudder every time I have to look at code that I wrote when I was learning list comprehensions.
I'll throw in one more piece of advice: A good way to get the next generation of troubleshooters to hate you is to say you've solved a problem without saying how. There may be hundreds of people googling for a solution to your issue, and your 15 minute resolution might not be obvious to them. So unless it was something particular to your own setup, it helps to at least mention what caused the issue.
Absolutely, ZeroMQ is wicked-simple to set up and works beautifully over a network. Just pickle any data objects that you want to pass between machines, and unpickle on the other end.
Its obvious that it is clear to the OP *how* to use it after it was explained. What OP seems to be saying is: "I have no use for it." 
 &gt;&gt;&gt; states = {1:[2],2:[3],3:[1]} &gt;&gt;&gt; state = [1,2,3] &gt;&gt;&gt; print [st for s in state for st in states[s]] [2, 3, 1] &gt;&gt;&gt; state = [1,2,3] &gt;&gt;&gt; ostate = [] &gt;&gt;&gt; for s in state: &gt;&gt;&gt; for st in states[s]: &gt;&gt;&gt; ostate.append(st) &gt;&gt;&gt; print ostate [2,3,1] &gt;&gt;&gt; state = [1,2,3] &gt;&gt;&gt; print [st for st in states[s] for s in state] [2, 2, 2] 
Check MIT's StarCluster (it's aimed at Amazon EC2 though) http://web.mit.edu/stardev/cluster/
I've invariably gone back and replaced all but the simplest list comprehensions with proper loops after needing to add more functionality later.
List comprehensions and generator expressions beat the crap out of map/filter in python. I think they're more efficient internally too, or were at one point.
Yes, please share your solution. For the love of Cthulhu.
rinetd would work 
&gt;code golf &gt;identifier names not minimized
List comprehensions work syntactically the same way as generators, and the generator (st for s in state for st in states[(s, letter)]) is equivalent to for s in state: for st in states[(s, letter)]: yield st I've always found double-list-comprehensions like this counterintuitive, because I try to parse it as `[st for s in [state for st in states[(s, letter)]]]` except with flattening. But written the way I show above, they make sense. You take the loop clauses and nest them in the order they appear. Simple. That said, I would probably prefer `sum((states[(s, letter)] for s in state), [])`. Edit: You know what, let's refactor the whole thing. As others noted, sets of states are more appropriate than lists, and the use of `defaultdict` here seems a bit overkill... from optparse import OptionParser from itertools import groupby, izip def parse(line): a, b, c, d = line.split(None, 3) return ((a, b), d) def run(_): # wtf is a beseda? with open("machine.txt") as f: state, final = set(next(f).split()[1:]), set(next(f).split()[1:]) # Here's where I show off ;) transitions = dict( (k, set(izip(*v)[1])) for k, v in groupby( sorted(map(parse, f)), lambda x: x[0] ) ) for letter in word: state = set.union(*(transitions[(s, letter)] for s in state)) return bool(set.intersection(state, final)) for b in OptionParser().parse_args()[1]: print [(b, "YES" if run(b) else "NO") (Yes, I deliberately obfuscated some things while making others clearer. Problem? :) )
In general, map/filter are somewhat faster with built-in functions, but significantly slower with user functions, IIRC.
Strange. I'm constantly replacing loops with list comprehensions after discovering that the loop is silly, and never really regretting it. "More functionality later" is a code smell indicating the need to actually extract a new function.
He posted the code earlier, and another poster profiled it. The application is apparently spending 80% of the time in numpy.fft.rfft(), which is implemented in C and has had many eyes on it over the years.
You think having a two-level list comprehension is more *comprehensible* than simply two indented loops? To each their own.
`setcap 'cap_net_bind_service=+ep' $(which python)` To allow python to bind to ports below 1024. The security implication here is that an arbitrary python script could run in place of a standard system daemon and intercept traffic.
If you don't pay $1200 Euro a year to write code in a [custom IDE](http://www.planetframework.com/documentation/1.10/Developing/Development-environment/), then how do you know it's *Enterprise Ready*. Seriously... charging for a custom IDE should not be under a heading called "developer friendly". I don't even care if it's optional... Don't built an IDE for your *web framework*.
I never end up needing a two-level list comprehension of the sort illustrated. Nested ones, sometimes. But then I use indentation to reflect the nested structure. Edit: But it isn't so much a question of comprehensibility as it is of avoiding the distractions that come from setting up an initially empty list and adding stuff to it. List comprehensions let you focus on the what rather than the how.
o_O ...(uWSGI sets my video card resolution) \*hours pass\* \*actually reads article\* \^_^ ...(Ohhh, KSM)
This is correct, in both my experience, and according to the python optimization guide.
it's not really a custom IDE, its pycharm with some mods. if it isn't it looks an awfulll lot like it.
Maybe there's a GPU implementation that will do it a lot faster. There are certainly dedicated DSP cards if you're really bound by FFTs and the alternative is waiting for years. EC2 has instance types with CUDA GPUs, although they're expensive. Edit: Yep: http://wiki.accelereyes.com/wiki/index.php/FFT_(Vector)
I know you were just expanding it literally, but the second for seems silly: new_state=[] for s in state: new_state.extend(states[(s, letter)]) state = new_state 
There's a guide?!
Thanks a million for the interview question link. I don't think I've learned this many tricks in 15 minutes ever!
Yeah I had no clue [extended slicing](http://www.reddit.com/r/Python/comments/dxvtv/favorite_python_interview_question/c13qusw) existed! I picked up a lot of sweet tricks from that thread too, hope to bust em out in the interview
Yup. [Guide.](http://wiki.python.org/moin/PythonSpeed/PerformanceTips)
Excellent list. If you want some good ones on the astro side, here are my favorites. **Propulsion:** [Physics of electric Propulsion](http://books.google.com/books?id=xX43AQAACAAJ&amp;dq=electric+propulsion&amp;hl=en&amp;ei=UgzHTti-HofZgQeSltFg&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=10&amp;ved=0CGIQ6AEwCQ)-Robert G. Jahn [Space Propulsion Analysis and Design](http://books.google.com/books?id=GLWHQgAACAAJ&amp;dq=space+propulsion+analysis+and+design&amp;hl=en&amp;ei=eQzHTuHVEsKrgwevw_xH&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=1&amp;ved=0CC0Q6AEwAA)-Humble, Henry, and Larson [Modern Engineering for Design of Liquid-Propellant Rocket Engines](http://books.google.com/books?id=TKdIbLX51NQC&amp;printsec=frontcover&amp;dq=modern+engineering+for+design+of+liquid-propellant+rocket+engines&amp;hl=en&amp;ei=qQzHTtnxAo2_gAeFkZw4&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=1&amp;ved=0CC0Q6AEwAA#v=onepage&amp;q=modern%20engineering%20for%20design%20of%20liquid-propellant%20rocket%20engines&amp;f=false)-Huzel, and Huang **Spacecraft Dynamics and Control:** [Principles of Dynamics](http://books.google.com/books?id=j_RQAAAAMAAJ&amp;q=principles+of+dynamics+greenwood&amp;dq=principles+of+dynamics+greenwood&amp;hl=en&amp;ei=jQzHTqyWG4jDgAfPnNVR&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=1&amp;ved=0CEIQ6AEwAA)-Donald T. Greenwood (edit):formatting
Most perl-like line of Python I've ever written: y = ','.join([x[max(0,i-3):i] for i in range(((len(x)-1) % 3) + 1, len(x) + 1, 3)]) 7 Internet points to anyone who can figure out what it does without needing to run it.
Was there some kind of problem with using Bottle's @validate decorator? http://bottlepy.org/docs/dev/tutorial_app.html &gt;Validating Dynamic Routes &gt;Using dynamic routes is fine, but for many cases it makes sense to &gt;validate the dynamic part of the route. For example, we expect an &gt;integer number in our route for editing above. But if a float, characters &gt;or so are received, the Python interpreter throws an exception, which &gt;is not what we want. &gt;For those cases, Bottle offers the @validate decorator, which validates &gt;the “input” prior to passing it to the function. In order to apply the &gt;validator, extend the code as follows: from bottle import route, run, debug, template, request, validate ... @route('/edit/:no', method='GET') @validate(no=int) def edit_item(no): ... &gt; At first, we imported validate from the Bottle framework, than we apply the @validate-decorator. Right here, we validate if no is an integer. Basically, the validation works with all types of data like floats, lists etc. &gt; Save the code and call the page again using a “403 forbidden” value for :no, e.g. a float. You will receive not an exception, but a “403 - Forbidden” error, saying that an integer was expected. 
I'll just post this here too: Most of this works unless you need to request the socket after you do some other stuff that you don't want to be superuser. I made a project called [tradesocket](https://github.com/DeadWisdom/tradesocket) a while ago. It allows you to pass back and forth sockets on a posix system between processes. What I do is spin off a process at the beginning that stays superuser, and the rest of the process drops down in permissions and then requests the socket from the other.
Are you using backticks to indicate [sarcasm or irony](http://www.reddit.com/r/geek/comments/mh0il/sarcasm_font_solved/)?
E.g. Part II http://vanity.aclark.net/talk/Django#comment-368088083
It is actually good. Do you have plans to make it multi-platform? 
Nope, why? I'm using it to refer to Disqus' "like" feature.
Building a comma separated string of numbers... duh.
Why backticks then?
No reason, just `like` the way they look.
Bingo :) Here are your 7 internet points, don't spend them all in one place!
Backticks aside (I admit I should have left them out), I get the feeling people aren't getting this. Enter a Python package (hosted on PyPI, including downloads, for now). Then go to the talk page and like or dislike it and add a comment on it. At least in Plone CMS land, this could be really valuable for gathering sentiments on various add-ons e.g. http://vanity.aclark.net/talk/Products.PloneFormGen#comment-368095869. Probably in the general case too. At least, I thought it was a cool idea ;-).
Exactly. I must have stared at that code for five minutes trying to figure out why they used a list instead of a set -- surely there was something I wasn't getting? But no, it's just doing exactly what it looks like. :-( By the way, the blog post screwed up the formatting a bit; [here's a better version of the code](http://pastebin.com/QLW1BfFj).
You are correct sir.
[Here](https://gist.github.com/1378687)'s my try of the same problem. It's probably the most un-pythonic code I have ever wrote. :O 
@validate is a generic input parameter validator: it doesn't handle query string parameters and doesn't support optional arguments.
Well, if they claim to be Python experts, you can break the ice by asking what happens after you execute `obj.__dict__['__dict__'] = None` and then go on a tour of Python object model internals, including metaclasses, what does `(lambda:'').__get__` do, etc.
This is great, I like seeing more quantitative finance libraries showing up for Python. So much code in that area is written for Matlab which is kind of a shame.
this is a pretty natural/pythonic out of the box solution for remote work, and takes care of much of the setup and maintenance a distributed system would normally entail. http://codespeak.net/execnet/ more advanced patterns can be done by hand via various queuing systems, but they entail more work both for the app and deployment management.
&gt; It is hard to explain why it does not work. Why? You have to explain the difference between local and global variables anyway, right? So you just add that since python does not have variable definitions, it implements such and such heuristic to distinguish between locals and globals. By the way, I personally like how this seemingly dirty and simple rule works for typical usecases. And how in general python is a bunch of hacks (sometimes interacting in quite a contrieved way) that somehow make it so comfortable to program in.
There is a reason that PHP is so ubiquitous in the web development market, and that is that it is extremely easy to get up and running with. PHP was developed with the purpose of web development in mind, and is widely supported by hosting companies. Its very structure, with code and HTML mixed together, is testament to its background. Also, for this reason, you won't find PHP being used much outside the domain of web development. Python on the other hand, is a more general purpose language. It can be used to do web development, but it is also used to do a million other things, like scientific programming (scipy), game development (pygame) or general scripting. So, for web development, the benefits of python are just those that you've already listed. The benefits of a cleaner, more well-designed language. In the long run, you'll probably be able to write better code in less time. In the short run, your PHP experience is going to be worth more to get things done quickly. For you, as a developer, an additional benefit of learning python is that you will be able to do work in a far wider range of fields than you can with just PHP. The same is of course true for many other languages, such as Java or C#. And of course, working with Python is just plain fun. To me, it is a breath of fresh air after coding some PHP.
Just give it a try. I was using php for 6 years and after switch to python feel myself better than ever.
Which is better, a driver or a putter? It's usually crazy to talk about which language is better, because different languages are designed for different purposes. I've written books about both PHP and Python, but I'm still not really an expert in either. I like them both. PHP is used almost exclusively for server-side web development. Although you can use it in other ways, it's rarely done. If you're using PHP, you're probably writing on the web server. Server-side development has its own quirks, and PHP has evolved to manage those quirks pretty well. It's a late-bound, dynamically typed interpreted language. These decisions all work pretty well in the server world where flexibility may be more important than speed. It's a good (if not perfect) language, and it's well suited for the problems it was designed (ok, evolved) to solve. Perhaps the biggest reason to continue using PHP is the huge base of support. The vast bulk of CMS systems use PHP and MySQL, and it's available for free on nearly any server already pre-installed and configured. Python was not designed primarily as a server-side language. It was intended as a multi-purpose language, and it does that job very well. Python is one of the few popular scripting languages today that doesn't adhere to the C-style syntax rules, which gives it a refreshing spare syntax. It takes a while to get used to indentation instead of braces, and there are a few ugly idioms in the language (__name__ == "__main__", for example) but it's a nice language. It's far easier to teach Python as a first language than PHP, but mostly that's because we can teach Python as a console or GUI language first without having to begin with the complexities of the web server, and because the syntax rules are a bit easier (no semicolons, few braces and parentheses.) Python has an incredible core library, with nearly everything you might want built in, and a solid base of add-on modules. In addition, the core of the language is well-thought out. For example, the List class (which is a super-array type) already has everything you need to make it act like a stack, a queue, or an ordinary array. There are some incredible Python frameworks out there, and also some good ones for PHP. While the frameworks are wonderful, I think it's best to think of them as a whole new language. Knowing Python doesn't mean you're going to understand Django, just as knowing PHP doesn't immediately translate to CakeWalk. Any time you're talking about a framework, you've got a new level of server complexity to install and manage, and a new learning curve. I don't think the underlying language should be the main reason you pick a framework. In short, if you're already a solid PHP developer, you have access to all the power you need. Don't feel like you're missing out because you don't know much about Python. However, it really won't take you long to learn Python, and the experience will broaden you tremendously. Python is a really incredible language, and I could see it beginning to take over PHP's dominance of the server space. It's also just a more fun language to program in. Hope this helps...
a putter because mini-golf is the best.
E.g. Part III http://vanity.aclark.net/talk/Plone#comment-368154902
If you're learning something new, it's always going to have a learning curve. You're not going to know whether this particular language suits your needs unless you jump into it. I stopped even thinking about PHP a few years back after having used Python. At this point, if I can do it in Python, I will. Otherwise I'll pick up a different language based on a specific need (performance, environment, etc.). Python is my first go-to for just about everything. 
Yes, Python has also improved my masterbatory skills as well.
In general Python has a cleaner, more legible syntax, for example compare the following code in PHP: $rect = new Rectangle(300, 200, '#00C957', null, null, 0.5) To the following code in Python which makes use of named parameters: rect = Rectangle(300, 200, color='#00C957', alpha=0.5) With named parameters we can skip over parameters we aren't using (ie border width and border color) and we can explicitly specify the name of other parameters so anyone who looks at this code can tell what is going on. Here is another contrived example of where I think Python code is cleaner than PHP. In this example, we have a constructor for a bus object, the constructor of which takes one 'driver' and an unlimited number of passengers. First in PHP: &gt;**Note**: It has been [pointed out](http://www.reddit.com/r/Python/comments/mi2m8/i_use_php_whenever_i_meet_a_python_guy_they_tell/c315uud) you would never really write a method this way in PHP, so I've added an example later on that is [more realistic](http://www.reddit.com/r/Python/comments/mi2m8/i_use_php_whenever_i_meet_a_python_guy_they_tell/c316852). public function __construct($driver) { $this-&gt;driver = $driver; $passengers = func_get_args(); // Get all parameters passed to this method unset($passengers[0]); // The first parameter passed is the driver, not a passenger $this-&gt;passenger = $passengers; } Here is the above code in Python: def __init__(self, driver, *passengers): self.driver = driver self.passengers = passengers Another example that comes up a lot is array slicing. In PHP: $new_list = array_slice($list, 1, 5) In Python: new_list = list[1:5] Python also has [list comprehension](http://www.python.org/dev/peps/pep-0202/), [decorators](http://stackoverflow.com/questions/739654/understanding-python-decorators), generators, [doctests](http://docs.python.org/library/doctest.html), multiple inheritance, etc. With Python, I also find it is much easier to use code from other peoples projects. Primarily this is because Python makes very good use of namespaces which PHP has gained only recently (and with an implementation that I don't care for). Additionally, the relevant white space of python combined with clear coding standards ([PEP8](http://www.python.org/dev/peps/pep-0008/)) means that Python code tends to look and work the same way. Using PHP code from different libraries means having a mashup of different styles and autoloaders. The best reason to learn Python isn't because it is 'better' but because learning a new language will help make you a better programmer in general. As for *gotchas*, the biggest advantage PHP has over every other programming language I've worked with is how easy it is to set up on a server. 
Upvote for rational discussion and not language bashing.
&gt;I've written books about both PHP and Python, but I'm still not really an expert in either. That kind of makes you an expert.
Having learnt Python after getting bored with PHP, the single most important feature that I miss when working on PHP projects now is explicit imports. Reading PHP code is a nightmare, you have to go through every damn file pulled in by require/include, and every file those files pull in too, just to understand where the functions and classes and constants are defined. And although PHP has namespaces of a kind, there's nothing preventing one file from screwing with another by altering global variables. In contrast, Python gives you [a small set of built-in functions](http://docs.python.org/library/functions.html) and after that you have to [explicitly say what other modules you want to use](http://docs.python.org/tutorial/modules.html). And you even get the chance to alias the module on import just in case its name conflicts with something (or if you just like to save some typing and want to shorten the names).
Because a wet sock is better than PHP ;-)
Relevant: [import soul](http://xkcd.com/413/)
I do mostly PHP development for a living, but I find Python more intuitive. That's a personal thing. Some immediate advantages to Python are that it's much easier and more reliable than Bash scripting, so you can build all kinds of utilities that you wouldn't normally write in PHP anyway. And you can build and deploy desktop apps without too much hassle compared to some other languages. As a skill-set, Python applies more readily to more problem domains, so it's a good return on investment that way. On the other hand, everybody seems to want to PHP, so that's what I write in.
PHP has to initialize tons of stuff (db connections, etc) for every page load. With python sites, the site is running all the time so it only runs the necessary functions to deal with the request. I used php for years then switched to python. PHP is great for very small very quick projects, but other than that python is fantastic.
&gt; Which is better, a driver or a putter? This is not a good analogy. You have to compare two tools to one situation ("Which is better for cutting, a knife or a fork?", which is still not a good analogy to web development, obviously).
For web development, I don't think that the language difference itself is the main selling point for Python. What really makes Python better for web development, in my mind, is: a) Web frameworks that are easier to use, and under much heavier development than their PHP equivalents. I switched from a codeigniter/kohana setup a few years ago to Django, and experienced an enormous boost in productivity. b) The enormous difference in how the languages are implemented. It shows everywhere. Python does not just constantly improve it's frameworks, but the web servers are built in python as well, and offer the same fast paced improvements and innovations. There is a ton of innovation around Python implementations as well, notably PyPy, which is a python runtime written in python, now rivaling the speed of the HotSpot JVM. c) With Python, you get an enormous community of people who are doing other things than web apps in python (like DNA sequencing and machine learning), and you as a web developer benefit from their contributions to the python package index. The beautiful syntax is just a bonus :)
IMO "breath of fresh air" is the most underrated benefit of python vs php debate. ⬆ for mentioning it.
The Python language *is* that much better. However, it is impossible to be convinced that a certain set of language features will be so much better than what you are used to just from a description of them - you have to use the language, and see how the various features fit together. (This is called the blub paradox. See http://www.paulgraham.com/avg.html - it can sound arrogant, but having used PHP for years and then Python I'm confident that Python is the *much* better language, and I've never found someone with the same experience who thinks otherwise). However, I'll try to give some examples of how certain language features enable certain things, and use examples from the web development world. There are a bunch of language features that you might not ever think you will need, but the times you do use them they save you an awful lot of work, or might remove certain pervasive bugs that otherwise require huge discipline to stamp out. Over time you find that you could not live without them. Frameworks often make use of these features, and make practical things that would be impractical otherwise. (note - everything is *possible* in PHP, but that isn't the question). Example 1): **metaclasses** (along with the ability to modify classes from outside them) make the ORM of Django and SQLAlchemy so much better than anything I have seen for PHP (disclaimer: I haven't used any PHP ORMs, I've only had a look at documentation of how they work out of interest). Of course, it would be possible to port SQLAlchemy to PHP in some way, but without certain features of Python it would have so many warts and inconveniences when it came to using it that it wouldn't be worth it. It's pretty rare that you write a metaclass yourself, but you use them unknowingly a lot via libraries, and it's there when you need it. Example 2): **operator overloading**. Besides obvious uses for custom numeric classes, this feature gives SQLAlchemy a very nice way of producing complex SQL expression from Python code - http://www.sqlalchemy.org/docs/core/tutorial.html#conjunctions (Note - the '==' operator in the example code does not return a boolean, but an object representing a SQL '=' operator which can be used later in constructing SQL). Example 3): **keyword arguments** (including syntax for both calling and receiving specific keywords, or any number of keywords). Of course, you can work around it using various techniques like an associative array for optional arguments, and using compact()/extract() but that is like saying you can do OOP in C - you can, and I have done so in the past, but code becomes more and more cluttered by the noise of managing things that are not actually related to what your code is doing - marshalling parameters in and out of datastructures etc. rather than *using* those parameters. The marshalling work you need to do for keyword arguments is usually non-existent due to nice syntactic support, or very minimal and easy when you do need to do it. Example 4) **first class functions**. A classic example of when these are useful would be doing a sort by a custom comparison function. In PHP, it is ugly and brittle, since there are no first class functions. In Python, it is easy, simple and robust. (Yes, I can think of various ways around it in PHP, but all have significant disadvantages, usually including a lot of noise for what should be a very simple task). Example 5) **The ability to subclass builtin types**. This might seem very esoteric, but in Django's template language, this feature forms a key part of the template's autoescape mechanism, which has been keeping many web apps free from XSS exploits with extremely little effort or inconvenience. (Basically, you can subclass the builtin 'str' to make a 'SafeString' subclass, which works exactly like a string, because it *is* a string, but is flagged to not be autoescaped. This means you can have autoescaping on by default in the template engine - vital for anyone serious about getting rid of XSS - but you can also specify strings that have already been escaped, and can do so anywhere in your source code, however far it might be from the template that will eventually consume and render that string) Example 6) **First class classes**. In Python, a class is a runtime object that can be passed around in just the same way that you would pass a string, integer or array around. It can be dynamically subclassed. So, you can write a function that will accept a class as a parameter and return a custom subclass. When would you use such a thing? Well, perhaps not very often, but certain framework/library code will use it. For example, Django has a 'lazy' function will turns a callable object (e.g. a function) into a lazily evaluated version that will only be evaluated when it is needed. The type of object returned must act as a proxy for whatever type of object it wraps, and so must dynamically subclass any number of builtin or custom types - which it does: https://github.com/django/django/blob/d04f72fb31bab43386e12963c1c6dec23ae16143/django/utils/functional.py#L53 . The internals you wouldn't normally see, and would rarely have to code, but the result - easy lazy evaluation - is extremely useful. I haven't even mentioned **generators**, the **'with' statement**, **list comprehensions**, **descriptors** and nice **introspection** support. All these things mean that Python makes it possible to produce great libraries and frameworks. As a core developer of Django, the thought of implementing Django in PHP is too horrific to contemplate. Of course, any one feature of something like Django could be copied as a proof of concept, but I'm confident the project would never have got where it is, and still be in good shape in terms of maintainable code, if it had been attempted in PHP. Finally, overall PHP 'feels' like it is made of duct tape and string with features bolted on, whereas Python 'feels' like it is made of ... Python. That consistency gives tremendous power, because you can really understand and predict the language. Python has some nice abstractions, like a powerful implementation of classes, but unlike PHP, you can peel back the covers, and discover 'objects all the way down', and those objects are a fairly easy to understand set - lists, dictionaries and functions (and tuples). 
Fantastic answer. I had a similar experience: I brushed Python off as not worth it for web development, and in the beginning of the year, found myself needing to learn it in order to work on a project. It was, quite simply, a breath of fresh air. Everything made sense, it was intuitive, and there was a wealth of documentation and best-practices. You can tell a lot of thought went in to building the language.
I have the ZCE PHP certification. I can confidently say that I know PHP at an expert level. Ive been working in PHP since theres been a PHP. That said, the more I get a chance to work in Python, the more I feel like I'm actually getting things done. As far as web frameworks go, Python is superior IMHO. Django and Pyramid applications are so friendly to developers, you almost feel like you're cheating when you're setting one up. And designers who typically work on Wordpress sites almost cream themselves when they see Django's templating system. If I can use only one word to describe working in Python, it would be this: clean. Everything in Python is cleaner than in most other languages. Sure there are gotchas, but they are few and far between. One of the most empty arguments I hear against Python is the fact that whitespace is syntactically relevant. To me, this is more of a whine than anything else. The benefit of this to me vastly outweighs the alleged inconvenience. You can pick up any piece of Python code and be able to read it without having to decipher the author's individual stylistic biases. You can't do this in PHP or Perl. In those languages, you are at the mercy of whoever wrote the code...you hope they weren't a cowboy. TL;DR: You get more done and in less time with Python.
As I mentioned in my comment below, in using Django you are using the following features of Python that are not found in PHP: * metaclasses * descriptors * ability to subclass builtin types * dynamic subclassing (first class types) * first class functions * operator overloading * variable keyword arguments and variable positional arguments and probably various others. Often you won't be aware of these features, but they are vital to making it feasible to implement Django. As a developer of Django, I'm confident it would just be impractical to produce this framework with PHP.
&gt;For you, as a developer, an additional benefit of learning python is that you will be able to do work in a far wider range of fields than you can with just PHP. The same is of course true for many other languages, such as Java or C#. While I do love python, the truth is, you'll have a much easier time getting a job if you know Java or C# than if you know Python... Big companies love Java and C#.
Or makes the books terrible.
the more you learn, the more you know that you don't know. To the general population, I am a guru. to the programming community, I am a python expert. To the python community, I'm just another programmer, and to my circle of pythonista's, I'm 'meh'. I say I'm 'meh' when someone asks about my python abilities, but there is a lot of perspective going on. I've given presentations and such, but not about anything astounding.
Why, oh why had they to fuck up Python so badly? There are millions of programs all over the world using the traditional C language format. WTF can you do with the new format that you couldn't do with the old % operator that justifies throwing away decades of knowledge and starting over from scratch? WTF do you gain by transforming such a widely used operation from a symbol that can be created with two keystrokes to a string that needs eleven keystrokes? Fuck, even Samuel Morse had the insight to make the most used characters the shorter ones when he created his telegraph code. Py3k is doing its best to become a language of interest to academics only. 
&gt; You can tell a lot of thought went in to building the language. A lot of thought [*does* go in](http://www.python.org/dev/peps/), continuously.
Explicit imports and docstrings are the two things I love about Python the most. And I could give up docstrings if I had to.
I know the feeling; I'm far more comfortable with C-style %-ing myself. It's probably best that I leave advocacy of format() to those with a more modern approach than I. I hope someone follows up here ... In the meantime, http://www.python.org/dev/peps/pep-3101/ captures a small part of the analysis that led to the adoption of format() for Python2.6.
Props for being humble. Got a blog that you write? I'd like to see how your brain works.
If you want something similar to Django's templating, but in PHP, take a look at [Twig](http://twig.sensiolabs.org/). It was originally created by Armin Ronacher (the guy who created Jinja, which is basically Django's templates, but better), and worked on extensively afterwards by Fabien Potencier (the guy who created Symfony). [Here](http://fabien.potencier.org/article/34/templating-engines-in-php)'s Fabien's blog post about it.
Sorry, I didn't mean to imply that work isn't constantly going into it. 
The format method is an improvement over the % operator that takes oh minutes to learn, and its not like % is going away (AFAIK). Quit trolling.
PHP *does* have first-class functions. And, in fact, I'd say that [their anonymous functions](http://php.net/manual/en/functions.anonymous.php) are better than Python's, since they allow freakin' blocks, not just a statement.
Nice library. Bad name. 'parse' is way to generic. May was well call it 'perform' or 'dostuff'.
Absolutely, PHP is, from a language power perspective, incomparable to Python. Still, I don't think that is the main selling point for someone like OP. For him, the main selling point is that Django will massively improve his productivity. It is the end effect of the power of Python (Django), not the underlying power itself (metclasses and so on), that makes Python a superior choice for him. At least in the short term.
PHP is a mess. Python is much less of a mess.
&gt;its not like % is going away (AFAIK) According to all I've read about this it is planned to be considered "deprecated" in Python 3.1 and eliminated in Python 3.2 As for how much it takes to learn, why should I learn a new thing that introduces no needed features? I've been programming since 1975, I've written millions of lines of code during these 36 years and do you know how many times I've needed advanced string formatting beyond what the C-style offers? Never. When you write code like I've done, millions of lines over decades, you'll appreciate the advantage of pressing shift-% instead of .format(). Count them, eleven keystrokes. Python was supposed to be a language suited for quick prototyping. Py3k is doing its best to change that. 
&gt; Is it as fast as PHP PHP is one of the slowest languages out there.
Basically this, as a former-PHP-expert that used it in almost every website (including Drupal framework etc), I found that Python is much more elegant than PHP, and allows for more possibilities of creating a more perfect website. It's especially useful for creating websites with a ton of custom processing code. Reddit was even coded with Python because of the website's complexity. But if you're just going to make a portfolio site or a blog--I'd recommend sticking to PHP.
Looks a lot less powerful than PCRE; a real shame to take such a succinct name like "parse" for something so lame.
Decorators too. Blew my mind a few years ago when I realised you could retro-fit pretty much any function into a json-rpc service with a single line.
It's still in 3.2. I've written millions of lines of code myself. And do you know how many times I've needed advanced string formatting beyond what the C-style offers? Countless times. And you have to, you just implemented it in another way, just as I did. Eleven keystrokes? Seriously? And I thought I was a grumpy old coder at 37. P.S It's 10 keystrokes if you don't take your finger off shift for the second brace. There, saved you a keystroke.
Never was conscious of this, even though I definitely felt like it was a breath of fresh air after being burned out by php
Unicode, for one thing!! Mind you, it was a kludge in python 2.x, which resulted in a lot of non-unicode apps being written and as a result, completely needless bug-fixing down the line. Someone where I work wrote a whole bunch of text parsing crud that works on string slicing, doesn't work with unicode-decoded DBCS text. I think PHP5 is a lot better than 4 though, just one example that springs to mind; I had to set up a SOAP to JSON-RPC proxy a few years ago and had a PHP 4 server to do it on. Looking around for a sensible XML decoder, I had found 2 dozen half-assed and not very good attempts at it in various forums, but nothing official. In 5 it became a one-liner.
I like how you can import things from the future in Python. Afaik you can not yet do that in PHP.
Sorry, but website complexity has nothing to do with it. Example: Facebook, a much larger website, is built in PHP.
Really? Ever use FPM with nginx and memcache?
Upvoted because I don't think you deserved downvoting for that. There are quite a few startups using Python, and some big companies (like Google) are known to do a lot internally with it. But my impression is that a lot of big established business use Java or .NET. Perhaps it's because they both have big stable businesses behind them.
Can you defend the GIL? That seems to be the definition of a python expert, someone who can take an obvious misfeature and make it sound like something other languages are lacking.
I miss generators even more! Too damn handy.
Also: Python 3 is less of a mess than Python 2.
Like perl, php is much easier to get stuff working *well enough*. That means that there are a *lot* of frameworks and libraries that have been live long enough to have few bugs, but are internally festering septic tanks. Python libraries are also generally written more recently, and in large part they are based on existing perl CPAN libraries - like version 2 of any program, that makes them generally more consistent and coherent.
&gt; However it misses some nice features of other “bigger” framework. One of them is a nice way to handle and validate query parameters. There are some improvements in 0.10 (coming next week): * The `FormsDict.get()` method now accepts a "type" parameter: e.g. `request.query.get('page', type=int)`. If that triggers a `ValueError`, you'll just get a default value instead. No need for try/catch anymore. * The FormsDict supports an attribute-like access (dot syntax), too: e.g. `request.forms.name` instead of `request.forms.get('name')`. These always return a unicode string. Decoding or re-encoding (Python 3) of byte values happens automagically (utf8 by default). If anything goes wrong (decoding error, missing key) the string is empty, but it is still a string. This avoids all the nasty isinstance() checks. If you want to get the real, unmodified value, you can still use normal dict methods. * The route syntax got an upgrade: e.g. `/object/&lt;id:int&gt;` or `/api/&lt;action:re:save|load&gt;`. This is a great replacement for the old `@validate()` decorator and works with custom "types", too. The old `:key` syntax is still available of cause. **tl;dr** Bottle does more than you think. And it is still evolving. Next release comes soon, yay :) 
Import things from the future? I've never heard of that. Do you have any links?
Isn't facebook built in a custom version of php?
Having moved from PHP to Python, I can tell you that the more consistent and readable syntax, libraries, etc. is wonderful, but not really a reason by itself to switch if you're already getting work done. There **are** some good reasons to switch (or at least try) however: * Python is a general purpose language, which means you will be able to use it in more contexts (command line scripts, small utilities, etc.) and the libraries available are going to cover a much broader range of functionality than PHP. PHP has a CLI, but it's not nearly as good as a real general purpose interpreter. * Having a real interpreter means testing code in real time. Instead of writing a short script and running it to test something out, fire up an interpreter and try variations out in real time. You'll use this more than you can imagine and using an enhanced version like bpython gets you command completion and inline documentation at the same time. * Real threads. In web development, being able to spin off long running processes is incredibly freeing and useful. PHP just doesn't have any good support for this (that I know of). * Performance: even with APC, Python is going to run faster overall than PHP. This is more a factor of how the languages interact with the web server than anything inherent in the languages (Python apps load into memory, rather than being interpreted from scratch each time). Mozilla has been migrating to Python from PHP, but they never deploy code that isn't faster than the PHP code it's replacing. So far they've never run into a situation where Python wasn't performing better than the PHP with less code. * The less-code, more readable nature of Python does mean that working with legacy systems or 3rd party code is a lot easier to deal with. When I run into questions about Python code that can't be answered by documentation, I never hesitate to dive into the code to see how things work. I always cringe at doing that with PHP. I'm not sure how this would be for you, though. * The community around the web development in Python (and Ruby) are very focused on tool building. Tools around testing, deployment, automation, task management, hosting, etc. just crop up like mushrooms around these languages in a way that doesn't seem to happen for PHP. This probably stems from the fact that deploying applications in these languages *is more difficult* but also the general nature of these languages makes it easier to build tools in them. I do feel that I am faster at delivering good code and that the code I write is easier to debug in Python, but that is something you would need to discover for yourself. I think it's worth learning Python even if you continue to do most of your work in PHP, just to write utility scripts and take advantage of some of its capabilities. Before I made the switch, I was writing sites in PHP and using Python to manage recurring tasks, quick scripts and long running tasks (like video processing, etc.). I hope this helps.
Well that's the point - the situation isn't specific enough. If you asked 'In golf which is better driver or putter?' it would be a far too general question - it needs to be broken down. (As in this person is asking "Which is the best cutlery a knife or fork?" - and he's saying you can't ask that - it should be 'which is better for cutting?' or 'Which is better for eating from?' etc)
&gt; As for how much it takes to learn, why should I learn a new thing that introduces no needed features? Granted your point, the basic problem with printf() is that it accepts any argument at compile time, then fails at runtime when the arguments don't match up. If this wasn't an issue, I think you wouldn't see so many people trying to eliminate it. It's been deprecated in C++, even though it's still there and probably won't leave because of legacy code. In Java, famous for strict type-checking, it was actually *introduced* as a String-class option, I think to pander to C and C++ programmers who might be considering a switch to Java. But printf() is now looked on as a leftover from the bad old days of C programming, where the programmer had to look after memory management, type verification, and dozens of other things that are performed at a lower level in newer languages. I should add that Linus Torvalds regards C as the only worthwhile language. 
Exactly, I'm saying his point don't stand as the situation is specific enough. OP wants to know why one would choose Python over PHP, therefore we should give him the major differences between the two languages. Overall, I agree with twopi's post (not everything, though), I just don't like this analogy in this context.
It's incredibly relevant. What if it works fine in the default module, but not fine in the other module? What if the difference is so subtle that it's hard to detect? What if the user of your code files a bug report, and you go back and forth trying to replicate the issue, when the root of the problem was a subtle bug in the automatic replacement for the default module. Time was wasted. Granted, if you were using a system that allowed the user to create implicit replacement for modules all wanton and such, then that'd be the first question you'd ask, as a developer. However, the possibility for variables within the same code is just asking for trouble. What if this custom module works fine for application A, but not application B? You tell the user to uninstall the custom module, but then it kills application A? If you, as a developer, want to use "faster" modules in python, you can already do this and fall back to "slower" modules. You just have to do it explicitly.
The docs still say it 'may be removed' in a future version of Python, but I don't see it happening any time soon. I think there's far too much code out there using it, and it's too convenient to easily give up. The nascent [what's new in 3.3](http://docs.python.org/dev/whatsnew/3.3.html) page so far has no mention of removing it.
Thank you for this post, it really helped me realize why I am so partial to python. The versatility is refreshing. I always felt the PHP syntax suffered from a combination of all the syntax traits I dislike from C++, Java and Perl. I really enjoy the ease of python's syntax to allow you to pull real objects out of thin air given just a string. I love operator overloading and the interactive console. I will be very satisfied when python stabilizes much the way Perl has, until that time this is my largest complaint about python.
What do they have to do with PHP?
&gt;I should add that Linus Torvalds regards C as the only worthwhile language. I guess I'm in good company then... The problem I see with all those concepts of "modern" languages is that they are always changing. C seems to be the only language that was born (almost) perfect from the start. This means I can take a library someone developed thirty years ago and it will compile and work perfectly. No other language does that. The value of perfectly tested and validated libraries is something that, unfortunately, too many people don't understand. 
Oh yeah, I guess you're right. Ignore me.
Python isn't stable? Python 3 was released in 2008 and it broke backwards compatibility for the sake of fixing the language. I really don't see another update like that in anywhere near future.
I think so, but keep in mind that they're using a slew of other languages under the hood. I think (and I'm too lazy to really get the proof on this) they're using Erlang or Scala for some stuff too. 
php, lol
It's built with [HipHop](http://en.wikipedia.org/wiki/HipHop_for_PHP), a silly tool to transform PHP code into C++.
&gt; I'm not bothered with the fact that PHP was not designed and has inconsistencies etc., because I know my way around it well enough that it doesn't matter. That's an interesting argument for (or against?) PHP. Anyway ... Python can't easily be compared to PHP. The latter originated as a sort of Perl knockoff, then grew like a backyard weed. IMHO PHP is a series of compromises and ill-fitting adjustments over time, sort of like Windows. Let's compare programmer effort level. I want to produce a beginner-level matrix of numbers -- let's use the times tables as an example. Here's the Python code required: import sys for y in range(1,13): for x in range(1,13): sys.stdout.write('%4d' % (x*y)) print '' Here is the result: 1 2 3 4 5 6 7 8 9 10 11 12 2 4 6 8 10 12 14 16 18 20 22 24 3 6 9 12 15 18 21 24 27 30 33 36 4 8 12 16 20 24 28 32 36 40 44 48 5 10 15 20 25 30 35 40 45 50 55 60 6 12 18 24 30 36 42 48 54 60 66 72 7 14 21 28 35 42 49 56 63 70 77 84 8 16 24 32 40 48 56 64 72 80 88 96 9 18 27 36 45 54 63 72 81 90 99 108 10 20 30 40 50 60 70 80 90 100 110 120 11 22 33 44 55 66 77 88 99 110 121 132 12 24 36 48 60 72 84 96 108 120 132 144 I've programmed in PHP [rather extensively](http://www.arachnoid.com/php_writer/index.html), and I find it verbose and cryptic after a certain complexity level has been passed. Now I find myself figuring out ways to code something in Python, both to save time and to have a more coherent source file for future reference. It seems to me that Python has better namespace segregation and class support, a much larger library of utilities, and an increasing codebase for Web activities. 
Python was the first language I learned. I'm not a professional programmer, but I started using C++ for awhile, which I also really enjoy, but then going back to python after using C++ it didn't even feel like programming; I felt like I was just writing very clean pseudocode almost. As far as a learning goes as well the interactive interpreter is invaluable, definitely helped me learn the language much much faster, and with the standard documentation system you never need to even have references open outside of the libraries them-self. 
I assumed he was more so just referencing that it'll give you a different way to see things and open up new concepts. Though I would say php and python are rather similar and you'd likely gain *more* from using c#, *maybe* from java as well, but it all helps. At this point I know c, c++, c# (somewhat), and python, as well as the web languages. Though I've never programmed a single line of java in my life I'm confident I could start on a java project and be caught up enough to be on base with whoever I was working with within a week. 
For extra credit use Redis as the broker since it is also easy to set up. RabbitMQ is a pain in the ass.
I've tried to make the switch, but ran into deployment problems. So I asked reddit: http://www.reddit.com/r/Python/comments/kx2yn/how_does_rpython_deploy_python_apps_easily/ I understand what they are saying, but I feel it's just another layer of complication that I don't have time for. I'm a one man show when it comes to wed dev for my company. To each their own. I've continued web development with PHP and use Python for everything else. I love Python, but couldn't even get a web app running on ep.io. I could devote more time to it, but I just feel comfortable in PHP. I upload the files via FTP, maybe set some permissions and they execute. I do not feel comfortable shelling into a server and messing with the internals to get my Python web app running. 
Unsure if youre out of practice in PHP or whats going on but you made the bus code more complex than it has to be. It's essentially the same as in python. public function __construct($driver, array $passengers = null ) { $this-&gt;driver = $driver; $this-&gt;passengers = $passengers } 
I don't think it's silly. By the time Hip Hop was developed Facebook probably had a massive code base in PHP. It is easier for them to transform their PHP code into C++ and get similar performance increases than to rewrite the entire thing into another language.
&gt; C seems to be the only language that was born (almost) perfect from the start. It certainly changed things in its day -- days I lived through. But to me, a language that doesn't change is a language on its way to becoming a museum piece. I hasten to add this isn't true about C, which changes regularly. I have any number of old C programs that won't compile any more because of all the "official" changes (C90, [C99](http://en.wikipedia.org/wiki/C99) and [C1X](http://en.wikipedia.org/wiki/C1X), as examples) that have rendered them obsolete. If I want them back, I have to rewrite them. 
From bad to worse. Ouch.
I don't care how valid their reasoning is; transforming PHP code into C++ is silly.
Their custom version is a subset of PHP. 
lambdas are meant to be inline functions, not general-purpose anonymous functions.
Yes, it's still in 3.2, but it will eventually be removed.
Heh. It's their mechanism for introducing backwards-incompatible syntax changes. For example, print was changed from being a statement used like this print "Hello world!" to being a function, which would be used like this: print("Hello world!") (There is a lot more you can do with the print statement or function.) The plan of action was to make this change the default in Python 3.0. But, to make transition smoother, they introduce in python ~~2.5~~ 2.2 the future import system. So in python 2.6, they introduced the "print_function" future import. If you used it, instead of keeping the old default behaviour in python 2.6 of using the print statement, you would receive the print built-in function. All you have to do to use the new syntax is to put the future import at the beginning of each file where you'd use the new syntax. In this case: from __future__ import print_function print("Hello world!") At the end of the deprecation cycle, the new syntax is made default and the corresponding future import ignored. The [list of future imports](http://docs.python.org/library/__future__.html) is listed in the python docs. People sometimes joke about it and say they can litterally get anything from mankind's future, such as levitation and whatnot :)
The standard library is just so much nicer in Python. Explicit imports as you mentioned, but also consistent naming, using objects where appropriate rather than using functions with connection references or something as their arguments...
I've wanted to learn Python for a while &amp; feel the same as OP. The fact that python isn't just for web programming is probably a good reason for me to switch over since I spent a lot of my focus on PHP for applications which I could be making more portable if I feel one would be better suited as a desktop application versus stored on a web server.
Well, only the display logic of FB is in PHP. The interesting parts are in Erlang, C++, and (I think) Java.
Yeah, that was a really bad example. However, with complex inheritance hierarchies you do sometime run into situations where you don't know how many parameters are going to be passed to a function. I did just this week in a PHP project, and making it work was much harder than if it had been in one of our Python code bases. Basically, I was working on an extension of PHP Zend Framework, and I was subclassing `Zend_Db_Table` to make it easier to use a non-default class for generating select statements. The subclass had a parameter `$_selectClassName` which would be generated by the Table's `select()` method -- problem was, depending on the select class used, I would need to pass `select()` a different number of parameters -- and I wanted to leave things open for more parameters later. I ended up having to do something like this (from memory, so this code may not quite work right): // Method of Database Table class public function select($from) { // ...skip some code that uses the $from param... $args= func_get_args(); unset($args[0]); // we already used the first param, and don't need to pass it on return call_user_func_array(array($this-&gt;_selectClassName, '__construct'), $args); } Ugh... what a mess. In Python, I could have done something much cleaner (again, quickly typing untested code, but you get the idea): # method of Database Table class def select(from, *args, **kwargs): # ...skip code that uses the 'from' variable... return self._selectClass(*args, **kwargs) #The _selectClass property is a Class Ta da! Much cleaner. 
[Language reference](http://docs.python.org/reference/simple_stmts.html#future). It's used to introduce elements that break compatibility. For example, integer division yields integers in Python 2.x and floats in Python 3.x. But if you say from __future__ import division you'll get floats.
And this is a great reason that PHP is so prevalent. It's stupid easy to name a file .php and it just runs. I used PHP when I first jumped from vbscript/jscript + IIS on Windows to Apache+PHP ( but Postgres instead of MySQL) Eventually my app grew to the point that it was really hard to manage all the include files and get a real good picture of what was going on. Also, I was limited to the performance of the local machine. At that point ( 10 years ago ), I switched to Perl ( Python had not yet won that battle ), but at that moment I had to learn about CGI, FastCGI, mod_perl and the various options for linking your app process with the web server. It was a big jump at that point, but once I got through the learning curve, I found that having the app decoupled from the web server process is a requirement for scalability. Being able to distribute your app over multiple servers while freeing up the main webserver to handle serving just static resources, you gain a huge array of options for coping as your app grows.
Not likely. People have been whining about it enough that I can't see it being removed before Python 4.
Looks neat! I've long thought that regexps are unpythonic and someone should make a good alternative to them. 
https://github.com/DavidJFelix/switch_case That's the cleanest I could do... you like?
I learned C++ and Java before Python and they made me give up on programming. Python brought me back!
Is it a job you're going to enjoy doing though? 
It's a bit of a contrived example, but the point was when you call the constructor like this: Bus("driver", "passenger 1", "passenger 2", "passenger 3")
Considering each refcount increment dirties the page and Python is ref counting left and right... Does this actually help?
How else would you optimize performance? JIT compilation is quite common.
PHP isn't a programming language. it's an HTML templating system with a bunch of stuff bolted on. comparing it to a programming language is silly.
+1 PHP-FPM with Nginx is pretty quick. Even the PHP-CGI configuration with Nginx is quick. 
Google "PHP FPM"
It's not relevant. If you want code to work, you have to test it in the environment/configuration you're going to use it in. If I want my code to work with both the `json` and `cjson` modules, I have to test it with both. This isn't any different from any other code change. Doing it inside the module with `try/catch` or doing it from outside the module via parameterization makes no difference at all.
yeah, im hoping noone would do that
same result. I'm using notepad++ with the nppExec plugin to run it, if that matters.
This would be amazing, dealing with `__hash__` and the GIL can be a real pain.
Future imports are older than Python 2.5. In 2.2 they added a future import for division. 
AFAIK it was built completely in PHP at first and then modified, but I can only speculate. Regardless, my point is that you can build complex websites in both PHP and Python. However, PHP is pretty much limited to web applications (yes, I know about PHP GTK but it sucks and doesn't seem to be maintained anymore) while you can build anything you want with Python. I spent 6 years writing websites in PHP (and I still do for a living), but learning Python was one of the best decisions I made (and it only took me few days to transition).
&gt;We are not because that isn't what we have now. exit is bound to a site.Quitter object. oh. Sorry, I just assumed (somehow overlooking the fact that functions are just objects and in the same namespace as everything else in Python). Maybe it's because I tend to avoid callable instances for some reason. &gt;1] I've already posted the change necessary to have exit exit the REPL instead of displaying information about calling exit (something that has caused a wart in Python because now applications can call exit() instead of sys.exit()). That really is appalling. Putting any side-effect in __repr__ is atrocious, but one that exits the interpreter...::shudder:: Do you really have that in your site.py? I'd think it'd wreak havoc. I mean, wouldn't IDEs, etc, call repr to get representations of objects for their popups and browsers and stuff? If you went to check the contents of __builtins__ or whatever, wouldn't you close the repl? 
It won't exist forever, that's the FL clause of BDFL.
Relevant: http://codegolf.com/
&gt;And although PHP has namespaces of a kind, there's nothing preventing one file from screwing with another by altering global variables. That's why you avoid global variables like the plague.
You kids and your fancy readable python! I won't hear of it. print('\n'.join(''.join('{:4}'.format(x*y) for x in range(1,13)) for y in range(1,13))) **EDIT:** If anyone has come up with a great way to format nested list/set/dict comprehensions and genexps, please show me what you're doing.
I do love this combo...although FPM still needs some bugs worked out. I had to switch back to mod_php due to working with some very large Oracle data sets that would make it barf :(
Working for a big established company is often worse no matter if it's your favorite language or not. You cannot shine and often can't work on interesting projects as programmer 480 out of 740 developers. 
might be why
I have to say earlier I tried to write a version of this after writing the conventional syntax above, using list comprehensions, but I didn't come up with anything that wasn't embarrassingly ugly. As to "you kids", [I just might be older](http://en.wikipedia.org/wiki/Paul_Lutus) and been programming longer. Not that it matters. :) 
but they get shit done...
If my choice is doing something I love and not getting paid, vs getting paid and doing something 'fun, but not as good'... I'll opt to do the latter by day, and the former by night...
*Python's lambdas* are. No other languages's lambdas are meant to be just inline function.
That's doesn't make PHP (its official implementation, at least) any faster. PHP's VM is slow compare to many other dynamic language's VM. It's like you are replying with "Ever use PHP ffi to call function implemented in C?". It might even make that program faster than most language out there, but it doesn't meant PHP is not slow.
Run it with the actual python interpreter. Both your method and the correct method work just as intended in the actual python interpreter.
My point was that it doesn't really matter if you want to build a web-application. Python wins in other areas.
Not true.
HipHop is the exact opposite of JIT.
Hah, small world! I remember hacking HTML in Arachnophilia way back in the day (e.g. Netscape 4/IE 4 days).
You're confusing low overhead with performance. Not the same thing at all. A good FPM setup will process lots of requests, but it doesn't do shit to actually speed up things that are computationally intensive. 
You're using Python 2. Don't use `input` ever! `input` does the wrong thing in Python 2. It's more or less permanently broken. Use `raw_input` instead. (This is fixed in Python 3, where they got rid of the broken input and renamed `raw_input` to `input`.)
Notepad++ is probably putting the output into some sort of buffer.
Yeah, but that's a false choice. You can get paid for doing what you love.
If they decided that running C++ was a performance benefit, then it isn't the least bit silly. Between the size of the existing code base and the productivity gains writing in PHP would bring, it doesn't seem the least bit silly. &gt; I don't care how valid their reasoning is Great point. 
i/o buffering is hiding somewhere...
Yeah but Python makes complex stuff easier because it's less of a general pain in the ass.
Sure, I've been working a job like that, but in reality, very few people get to do what they love for a living... none of my friends do...
To clarify, in Python 2 `input` is bad because it evaluates whatever the user typed as a Python expression, as if it were typed at the interactive prompt. This means that the returned result is not always a string, and a malicious user can easily do arbitrary bad things like deleting files and destroying the space-time continuum. The `raw_input` function keeps the inputted text in string form without evaluating it, which is the more sensible default, since you can always call `eval` afterwards if you want the original sketchy behavior.
Oops! Thanks!
It's a pretty poorly implemented feature then. I mean, we've still got anonymous strings, anonymous numbers, anonymous lists, sets, tuples, dicts, user-defined objects...actually we've pretty much got anonymous everything except functions and modules, and we've even got a limited form of anonymous function. Someone needs to fix all this so we can have nice, readable code.
Correct. Typically when I hear people complain about php's speed, it's due to them using mod_php. As far as actual performance, php, python, and perl can run almost identically, depending on what each is used for; some run certain methods better than others.
I'm probably going to get downvoted, but I can say working as the only programmer in a small and/or startup company can also suck.
Here's my pretty unfathomable (but faster) version: from itertools import imap, izip, starmap, product from operator import mul print '\n'.join(imap(''.join, izip(*((imap('{:4}'.format, starmap(mul, product(xrange(1,13), repeat=2))),) * 12))))
Thank you, my implementation was eating up CPU cycles like mad, and I need this multiplication table ready by 5 am!
Oh absolutely. Every job CAN suck, especially the punishing hours people put in at startups. It's just my experience (and those I've observed from friends in the industry) that those in small teams tend to fair better. It's more rewarding to be 1 of 1-3 people who built that back office system at a shipping company than the guy who wrote the bar code driver code for Windows. And not because it's Windows ;) It's more about doing something meaningful and demonstrable, to yourself, your co-workers (including the non-techie), and looking forward on your resume. 
Herminator pretty much sums it up. Another way to look at this is that PHP = Personal Home Page. Now obviously PHP has grown a lot from its beginnings but it is still a web programming language. The only thing I don't like about Python is the use of indenting to identify program blocks. Mainly because I've been bitten at least twice by this. It isn't a problem if you are coding everything yourself but if your editor Borks somebody else's code you want to use, you suddenly have a debugging session on your hands. 
Use F5 and run: c:\python27\python.exe -i "$(FULL_CURRENT_PATH)" Substitute the path to your installed version of Python in place of `c:\python27\`. The -i option drops into an interactive session after the script exits. Or to change to the directory of the script first, run it like this: cmd.exe /c cd "$(CURRENT_DIRECTORY)" &amp;&amp; c:\python27\python.exe -i "$(FULL_CURRENT_PATH)" 
How big would your database be? If you currently use Excel I suppose it can't be that big. What I would suggest is SQLite for the database and then use Python to build the app. This if you want to go the app development route. However why bother? It may be far easier to use any one of dozens of database managers out there with MS Access being just one example. Frankly I'm not sure what sort of data you intend to keep in this registry, if it is just names and addresses you could use a phone book app. In the end a good answer isn't possible because you took zero effort to tell us what the registry is, what data is contained there nor what processing has to be done on that data. In the end I'd first look for software that already does what you need. If that can't be found a database manager would be the next level to look at. Writing a full app seems to be a waste unless there is something really demanding about this app. 
What operating system? Which version of python? Is this 32 or 64 bit?
Windows 7 32bit for python 2.7
As long as you have the appropriate installer the only thing that might make it stop is if it doesn't have the permissions to write to the directory. It's unlikely but it's possible. An easier way to install packages for Python is with easy_install or pip. The script easy_install may already exist on your system in the Python scripts folder (for example C:\Python27\Scripts\easy_install.exe). From the directory you issue the command: `easy_install.exe install PIL`. And the script would install it in the correct location.
Try the installer created by [Christopher Gohlke](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pil).
in [/] your root should be an absolute path hence start with a / dies the images folder exist in /path/to/root ? what does the CP server say (look at the log which should display on the console) Are you sure you are using 2.3.0 and not 3.2.0?
This worked. Thank you
What I really need is an highly optimized internal hash table to speed up indexing / data realignment operations. It won't need to deal with reference counting at all, for example, and the table can be created with a rough expected size in mind to reduce the number of resizings needed. Will make parts of pandas a lot faster but could probably be used to speed up the internals of various other libraries. 
⬆ for the ⬆.
Pillow is a fork that works better for some
Enjoy your Java. Also, enjoy bashing languages you aren't competent enough to comprehend.
If you use web2py basically the scaffolding app is a web based registration system out of the box which you can manage via the provided web based database administrative interface. 1) download 2) unzip 3) startit 4) click administrative interface 5) login 6) fille the box "create new app" and give it a name. You have a registration system. You can customize it to allow registration using Google or Facebook and add more registration fields. EDIT: Here are some additional code you can use to map the people who register: 1) install plugin_wiki from the web2py web site 2) add this code # add fields to default table (in models/db.py) db.settings.extra_fields['auth_user']=[Field('address'),Field('latitude','double'),Field('longitude','double')] # auto compute latitude and longitude using google service def lola(form): form.vars.longitude, form.vars.latitude = geocode(form.vars.address) auth.settings.profile_onvalidation=lola # create a private web page to show all registrants on map (in controllers/default.py) @auth.requires_membership('managers') def show_map(): return dict(map = plugin_wiki.widget('map',table='auth_user')) web2py works with almost any database system. Just change the db connection line.
Changes in C have been very small, and mostly added a few features, like the complex type, for instance. The only real problem you'd have running old C programs would be in implementation dependent extensions, like they did in the early PC era with 16-bit x86 programs. 
&gt; Changes in C have been very small ... Not small enough to prevent invalidation of dozens of old C programs for dozens of reasons, all of them of course excellent changes for code coherence and reliability. 
But then we would need to ask raskai98 if his goal is to get the registration system running without understanding why it does, or whether he would rather learn the path to making a registration system, with a registration system as the final goal. Which one is it, mr raskai98?
Pretty cool, but we should remember that fluent style is different from functional style and vice versa.
Would be nice to see options other than European, and dividends.
Save yourself a whole lot of time and effort and just continue using a spreadsheet. If you need concurrent access, use a google spreadsheet. If that isn't sufficient, search for some open source software that does what you need. You will end up having to maintain anything you write from scratch, so think long and hard before you decide to go that route.
&gt; should I learn a new thing It's actually not a "new thing". C# has had that same format function long before Python ever introduced it. The printf syntax is decidedly unpythonic anyways, what with dynamic typing and all that. On a related note, what's the equivalent to `"{0}{0}".format("hello")` with printf? (prints `hellohello`)
I actually tried writing functional Python after writing quite a bit of Clojure and found that it offers pythonic shortcut constructs to 99% of my use cases (like map and filter). So I can still take advantage of functional approach without all the Clojure shenanigans (like dealing with JVM and awkwardness of stateful code when I have to use it). E.g., the example in the TFA can be rewritten as: ' '.join(['I am'] + ['%3.3d' % x for x in range(1,20) if x &gt; 5 and x &lt;= 7 and x != 6]) If you want to write Lisp or Haskell, stick with Lisp or Haskell.
If linux is an option, you should really try it. Installing any python package is just a few clicks/keystrokes.
Try [Pipe](https://github.com/JulienPalard/Pipe). It's also pretty cool. [Pipe: Infix syntax for Python](http://dev-tricks.net/pipe-infix-syntax-for-python)
I found this library few years ago and I started my adventure with Python. It's not easy to use especially for someone which has no experience with Python at all, but it gives huge possibilities in console user interface. After many tries I wrote my first app [urwidcmd](http://code.google.com/p/urwidcmd) small file manager.
Very true, but Python has the advantage of putting every module in its own namespace. You would have to go out of your way and mess with `__builtin__` to achieve in Python what is everyday in PHP.
If you like regular expressions and anything to do with perl, you'll love a cryptic name anyway.
They're mainly using PHP compiled to C++. They use erlang for the chat server. I think that's about it, I've never heard about them using scala. My sources are a google-tech-talk from one of the build management engineers at facebook and various blog entries from facebook employees I've read over the years.
That'd just make you a blind fanboy.
Yes, I know. That doesn't mean it isn't frustrating.
This. Google Docs [has a sweet form builder](http://docs.google.com/support/bin/answer.py?answer=87809) that puts information directly into your spreadsheet.
 "%s%s"%("hello","hello") You can create constructs that make it even more cumbersome if you wish, but that's not how the real world works. Notice how your very contrived example takes 34 keystrokes against the 35 needed for the classic way. Pyhton is a language that's useful because of the easy way it lets you build quick prototypes and small scripts. That's why I use it instead of Ruby or Java. By making it necessary to use long-winded texts to accomplish what could be done in a shorter way they are not improving it in any way. If I have to type a lot of stuff I'd rather do it in the comments, explaining **why** I did something, not **how** the language works. I'm not worried about a novice finding it easier to understand that the "format" method is used to format a string. If he doesn't know what each operator does he should go back to learn the essentials before trying to understand code. &gt;C# has had that same format function long before Python ever introduced it. I didn't know that, but I find it hardly to think a construct invented by Microsoft is a recommendation in any way. It has been over ten years since I last had to worry about stuff like *HWND hwndFound=FindWindow(NULL, pszNewWindowTitle);* and I'd rather not have to learn how to program the Microsoft way again. 
amount of traffic has nothing to do with complexity. PS they just does not have balls like twitter to rewrite codebase in more modern language
I'm not a fan of PHP but I disagree. PHP is too powerful to be called 'HTML templating system'. There are tons of great products that are powered by php. For example Wordpress and vBulletin. You can't make things like that happen by a 'HTML templating system' you need a programming language and that's what PHP is.
This is vaguely reminiscent of the REXX inspired [tparsing](http://www.python.org/ftp/python/contrib-09-Dec-1999/DataStructures/) module of Aaron Watters which had some nice features like below &gt;&gt;&gt; T = Template("&lt;X&gt;X&lt;X&gt;", "X") &gt;&gt;&gt; T.PARSE('&lt;A HREF="index.html"&gt;go to index&lt;/A&gt;') (['A HREF="index.html"', 'go to index', '/A'], 36)
Twitter went from Ruby and Rails to Java and some custom framework. In other words, they went from a modern language to an old one because the modern language didn't perform well enough at their size. 
The mysql_ functions which you're referring to are in the process of being deprecated. PDO, the suggested db layer makes proper use of OOP, and mysqli has a choice of either working with objects (the reccomended way), or old style mysqli_ functions. 
Oh, that's good. What about files though? Is there an OO way of doing that now or is it still `fopen()` and `fread()` etc?
So sick of this facebook shit. The language doesn't matter much, the data storage structure is what really makes a huge website work. Youtube converted from php to python for what it's worth.
Obviously the driver. You could put with a driver, but good luck driving with a putter.
Fine, I guess you need me to be serious. Greatest travesties in software engineering history have been committed in the name of optimization. People who write bad code always defend themselves with "it's faster" or, god help me, less memory hungry. That may be, but the fact is that 99% of all code we write is not performance critical. Any work to optimize that code isn't just unnecessary, it's counterproductive. Feel free to google "premature optimization" for more info. My point? They should write the performance critical bits of their codebase in a faster language. Making that easy was one of the original ideas of Python. And don't you dare tell me it's not possible in PHP. When you're transforming PHP into C++, you're essentially working with the worst of both worlds. You don't get compile time type checking and lose the flexibility of dynamic typing. Facebook choosing to write a tool that rewrites their entire codebase into a completely different language is akin to translating an entire book for the sake of a few passages. Actually no, it's more akin to writing an automatic tool to translate the original language into another except it understands only every other word and produces output that looks just wrong to everyone who understands it. Running the code through an external tool also means that you're introducing additional logical layers to your whole development process. If anything goes wrong with *any* of them, you're going to have bugs in your hands. Assuming that PHP and GCC (or whatever compiler they're using) are stable, that still leaves us with HipHop, which is very much a work in progress. Debugging in that environment means that you need to understand all of those layers; good luck finding people who have all the skills necessary. But Facebook is a fringe case. They have a wildly disproportionate amount of end users in comparison to engineers when compared to any other company in history. In this case it might actually be profitable to sacrifice a whole lot of developer time for that little bit of extra speed. From that point of view it might even make sense. But from developer happiness point of view it definitely does not - especially since there *are* better ways to achieve those goals. tl;dr: HipHop *is* silly.
Rewrite the performance critical bits of the code in C++.
As much as it would be cool to make a little django website I think the Google docs form idea is the most pragmatic.
Scala is more modern than rails :)
You seem to be lost, [/r/ruby](/r/ruby) is over there.
This is a great read. Thanks.
It was modified when the complexity grew beyond the ability of PHP to handle it :-) You can indeed write any program in any Turing-complete language, assuming that it has the right I/O mechanisms. That doesn't mean it's practical, however. Agreed that Python is fantastic compared to PHP.
Oh, I thought they had a lot more Java than Scala (I.e their web interface and a lot of other code was java, and a couple of backend services were scala)
even their specific graph database(like 90% of complexity in twitter lol) written in scala
Glad I wasn't the only one to think of REXX when seeing the word "parse" used in this way.
Nice ass-umption there. I've used C++ and it was ... memorable. Though fundamentally broken might be better. 
Some side questions 1. What is the analog of `.do(print)` in jQuery? Does anyone know? I just tried `$('li &gt; a').do(console.log);` and Console said $ has no method `do`. 2. "For instance, when should one use map/filter rather than list comprehension? When should one use itertools instead of the default dict/list builtins?"
I'd love to see `mocha.LazyList` implemented with maybe generators or iterators. `mocha.Set` too. As for &gt; Dict(a=1, b=2, c=3).count(lambda *x: x[1] &lt; 5) I think the following is better for readability. Dict(a=1, b=2, c=3).count(lambda k, v : v &lt; 5) Dict(a=1, b=2, c=3).count(lambda _, v : v &lt; 5) 
I agree that urwid isn't a easy library to get start with, and I think this is a reason why it isn't more popular. Thanks for sharing your application, it will help and I will read it. I think as well that urwid as many possibilities.
The first version of Python was released a few years before the first version of PHP. The standard library has grown and matured since those early releases, long before PEAR was established. Perl's influence is obvious in Python's implementation of regular expressions, but apart from that I would say Python is in many ways an explicit rejection of Perl. Whereas Perl says "There's more than one way to do it", Python says "There should be one-- and preferably only one --obvious way to do it." Java is arguably the contemporary programming language from which the greatest number of features have been stolen. Decorators are much like Java's annotations; the logging module in the standard library is effectively a port of Java's logging library. Programs written in Python are more consistent and coherent than programs written in PHP because the language itself is more consistent and coherent. &gt;&gt;&gt; import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! 
First thing off my head: You have the benefit of having long running process that serves the responses, so you can do things like loading whole binary GeoIP to lookup visitor IP's without speed penalty - having loaded libs and sometimes big data is great benefit over php where you would have to load this per request - while APC helps its still not nearly as efficient.
&gt;Programs written in Python are more consistent and coherent than programs written in PHP because the language itself is more consistent and coherent. The features of the *language* aren't particularly important to the typical programmer, it's the usability of the libraries we're generally interested in. Programs written in python are more consistent because the *libraries* they use are more consistent. And pythons libraries are *heavily* influenced by perl's.. as they should be. Perl's libraries have had a lot of use, and grew based on what features people needed; they therefore serve as an excellent resource while trying to build libs for another language. Take a look at perl's Net::HTTP, for an example - I think you'll find it fairly familiar. Python is a rejection of the design of the perl *language*, not of its libraries. The 'zen of python' belongs under some other post. I think that whole thing is a little silly, if somewhat effective - it's a design philosophy, something which more languages ought to make explicit. And preferably not in poem form.
I'm not sure this is correct. I'm a professional Python developer, and while the Python job market is certainly smaller than Java and C#, it seems more favorable to the developers. It's hard to find good Python developers. Most of the Python shops I'm familiar with could use more developers if they could find the talent.
You could write $('li &gt; a').map(console.log); But jQuery's map function passes both an index and the value, so you'll get a numbered list. You could also write: $('li &gt; a').each(function() { console.log(this) }) Apparently jQuery objects have a `toString()` method, and in this case the A elements stringify as their href attributes. If you wanted something else, you could write e.g.: $('li &gt; a').each(function() { console.log(this.text) }) ...to get their text.
Python is a very beautiful language and has some good tools for web development. However, the Ruby webdev community is *much* bigger, and the tools are much better developed. I'm a Python/Django developer who is now learning Rails. Things that used to take a couple of weeks in Python (e.g., configuring OAuth support) I was able to get done in 15 minutes in Ruby --- and I barely know the framework. In terms of syntax, I'd say Python has a more elegant design, but for sheer getting-things-doneness, Ruby wins hands down. I know lots of web startups in the SF Bay Area, and the vast majority use Rails.
I'd recommend this, too. If you haven't done programming in 15 years, coding a web app likely wouldn't be simple. If you want to try coding for the fun of it, I'd recommend something like Django. It's a very well-documented framework that makes basic registration easy. Another option is to look for existing tools or web sites that help you manage softball leagues. I'm sure somebody has solved this problem before.
Common, give me one free reading example. One of the interviews, that one shouldn't give code away for free, which I can see your audiences main interest lies in.
Make it a Django app. Almost all of it will simply be in the admin interface, which is generated automatically for you. Later you can make a few views, but they won't be hard at all.
I am assuming he does want to undertand how it works. In fact web2py was created as a teaching tool. The scaffolding application I am talking about is very readable and when it delegates to function calls it mostly uses functions defined in a single ptyhon file (gluon/tools.py). And it is all very well documented and explained here http://web2py.com/book/default/chapter/08
Bookmarked it, went back later to read, paywall, but no enticing free content. Set some py out, and you'll get more bites. I am always looking to know that what I find behind a paywall is different from what I can get free elsewhere. I leaf through books before buying it at the book store so that I can get a feel for an authors value. Even at Amazon.com, I can read a few pages. I can go to Costco and they have free samples of some of the items they sell. I can test drive a car. This is just good business sense. 
Good points. I've added that to my todo list. Cheers.
Those two are not equivalent. These two are: *python2.7* x = int(raw_input('enter a number: ')) print x ** 2 *python3* x = int(input('enter a number: ') print(x ** 2) `input` in python2 actually evaluates the expression, which isn't always an integer literal, so you need to be very careful with it. `raw_input` in python2 and `input` in python3 simply return a string with the user's input.
Sounds about right, thanks for being not-lazy unlike me :)
I am not the author, but from twitter account off main developer it looks like yes. http://twitter.com/#!/MeanEYE_rcf/status/116606224698576896
It's funny, they say they can accommodate open-source projects and the like to an extent, yet the link to contact them about it is "broken".
 import sys print "enter a number" sys.stdout.flush() ... perhaps?
It might be a rude thing to say this, but it has to be said: it's not free, that's why it sucks. Now, I understand that the author(s) wants some appreciation for his/their work in form of money, but come on, you use Python, PyGame, probably some free editor/ide, and probably many, many more free things. It's like an unsaid law: you take something (for free), give something back (for free). That's why we have so many libraries and tools. That being said I think what you're doing is awesome, and we definitely need more this kind of things, free or not. 
It's a pretty cool library but every time I've tried to use it I've had trouble with the docs/examples and had to read the source code to figure out what it was doing.
&gt; Mozilla has been migrating to Python from PHP, but they never deploy code that isn't faster than the PHP code it's replacing. So far they've never run into a situation where Python wasn't performing better than the PHP with less code. Interesting! Got a link for that? (not that I don't believe you, but I'd like to read more details) Also I personally prefer IPython over bpython. I gave bpython a try and some of its features are pretty amazing and awesome (like the rewind feature), but there was something IPython did that bpython didn't ... yes now I remember, IPython has wonderfully tight integration with Pylab, especially with the new QT Console in their latest 0.11 release. I do admit that I didn't spend *that* much time getting Pylab to work in bpython. Especially if it manages to produce inline figures/plots like the IPython QT Console, they might have a convert ;-) [I see bpython has a GTK version, so it might be possible]
Ramen.
I agree that it's not easy to get into urwid at the start, but I'm sure it worth the effort to learn it. So while I'm learning, and ask myself a bunch of questions about urwid, I through it might be useful for others to write it down in some blog posts. Sometime, few code about the same thing, with differents angles might help to get it started faster (even if my code could be naive). My aim is to adapt one of my program write with Python/curses module, to urwid. Maybe I wont, but I can't go wrong to exercise myself.
yeah I have the old 2.3.0 version. My bad, I do have the absolute path in my config file, I just wrote it wrong on this post, I'll edit that. 
But what would that alternative give us that regexp cannot? You could opt for something like Emacs's rx where you use s-expressions to symbolically specify the expression; that does work really well, but it's pretty verbose.
Other models will be implemented soon, the next one will be Merton which takes dividends into account.
I thought it was a very good write up and the more "talk" a project has on the web the better.
it's a templating system **with a bunch of stuff bolted on**. if it were a proper templating system you couldn't make wordpress, but instead they've thrown in a bunch of stuff like database interfaces that have no place being in a templating system, and this leads people to abuse it. the "powerful" bits of PHP are the shitty bits. if you just use it as a templating system, it's good. when you start attempting to use it as a programming language, that's when you start to see the differences between PHP and a real programming language.
First to answer your questions directly: * No as far as I know there is nothing that PHP can do that Python can't. Except for the part where you write `&lt;?PHP .. ?&gt;` right in the middle of your HTML, which a serious PHP developer wouldn't do anyway cause they'd be using a templating language. * "Will I be able to write better code in less time?" Maybe. It's hard to tell. Django is pretty damn good for rapid prototyping and you get a really nice auto generated admin backend for free. But afaik a project called "PHP Cakewalk" also does this, so I don't know. It won't be more time, and probably your code will be better. * Is it just as fast? Other ppl ITT said it's actually faster, so I guess, yes. * Frameworks varied and battle tested? Going to go with "Yes, *absolutely*" on this one. * Shortcomings to Python? Maybe that still pretty much every webhost supports PHP almost per default, and you need to look a littlebit further to find one that seriously supports Python. On the other hand, this was a worse problem 5+ years ago, and even two years ago I had no trouble finding a very experienced/friendly/supportive Python host with the additional restriction they had to be located in the Netherlands so our (Dutch) client could get support more easily and quicker (plus various other advantages of not being located in the US that I didn't consider at the time and aren't really relevant to this discussion). So in short it may take you 5 minutes extra time to find a good Python webhost, as opposed to 5 seconds to find a good PHP one. Some tips for the budding Python webdeveloper that picks the Django framework (from personal experience): Don't use the included Django templating language, instead use [Jinja2](http://jinja.pocoo.org/docs/) which is nearly identical in syntax and functionality, but much more versatile. The reason for this is that it's actually compiled to Python code (kinda like Smarty does in PHP), instead of sort-of-interpreted-on-the-fly like Django's built in templating. The result of this is that if you ever need to write your own non-trivial filter or new templating functionality, *Django makes this a nightmare because you actually seriously have to extend and build upon their parser writing your own parsing code* (this is such a bad practice it astounds me in an overall awesome project like Django). Jinja2 allows you to do this the Pythonic way, with a decorator, which is exactly all it should take. Substituting Jinja2 for Django templating is as easy as(https://docs.djangoproject.com/en/dev/ref/templates/api/#using-an-alternative-template-language) including it in your project and using Jinja2's Template.render function instead of Django's, and possibly a simple wrapping function to duplicate Django's helper function render_to_reponse. [Django also has some info in their docs about switching](https://docs.djangoproject.com/en/dev/ref/templates/api/#using-an-alternative-template-language) but it seems more complicated than it should be, and [Jinja2 docs simply explains the few syntax differences](http://jinja.pocoo.org/docs/switching/#django). The only "downside" to Jinja2 vs Django-templating is^1 that you might end up exposing too much application-logic to your template designer. Because Jinja2 is compiled to Python code it technically you *could* dig quite far into the application logic by traversing the right objects, even performing database queries from the template which is of course **BADWRONG** so you just shouldn't do that :) The real problem, however, is that they speak about some mythical job description of "Template Designer", being someone who is on the one hand able to write well-formed semantic HTML augmented with templating instructions that include for-loops and if-statements (aka quite a bit more technical than your average Web Graphics designer that you prefer to just make mockups in Photoshop+Dreamweaver because you'll end up fixing their HTML anyway) yet on the other hand supposedly will get confused by the increased exposure to "application logic" in Jinja2, not understanding where the separation lies (basically the line is that if you end up making DB queries from the template, ask the application guys to include it in the view function so you don't have to do it in the template. end of story). Sorry I got sidetracked for a bit there :-) **TL/DR** : use Jinja2, not Django's built in templating. ^1 According to a discussion on Django's dev mailinglist, which I'd link you to, were it not that the link appeared in [this blog post](http://lucumr.pocoo.org/2008/9/16/why-jinja-is-not-django-and-why-django-should-have-a-look-at-it) by Jinja2's author and it's been deleted for some reason unknown to me, nor was it indexed by Archive because of pocoo.org's robots.txt rules :-/ Oh and when coding for Django, get yourself a good IDE with the functionality to jump to function/class definitions even if they're in a completely different file from your library include path (such as Django modules). PyScripter for Windows is IMO *really* good for that (ctrl-click any keyword like it's a hyperlink), if someone knows of a good Linux IDE that properly does this, I'd love to hear cause I haven't been able to do this with the relative ease as PyScripter let me. Anyway this is useful because sometimes looking at the (pretty well-commented) Django module code is a quicker or better way to get to know what you want than reading the docs. *Back to PHP!* About the communities (which someone else mentioned ITT). What I see with PHP is a lot of "the blind leading the blind" happening--if you'll pardon my apparent elitism--lots of inexperienced people asking inexperienced questions get answers from only-slightly-less-inexperienced people that may still be very helpful and well-intentioned, but not always the best way to solve the problem, a correct answer to what was actually the wrong question, or just plain bad practice. Python seems to have a lot less of that. I don't know whether this is because of PHP's popularity, or because a lot of Python modules are also written from the perspective of discouraging "doin it wrong". My guess is a bit of both, but more of the former and a bit less of the latter.
I'll do it with documentation for $300.
I've seen my fair share of Facebook's source code. There's no shortage of calls to array_* in their PHP.
What about it?
 #This is a comment Maybe there's a few too many comments?
That's not OOP yet, at least not in the standard library. There's probably a few wrapper libs, but it's obviously not the same.
As it was already pointed out, TCO makes stack traces much more complicated. Also, relying on TCO is kind of dangerous. For instance, it's easy to miss that TCO is not applicable in this case: def factorial(n): if n &lt; 2: return 1 else: return n*factorial(n-1) And finally, TCO is simple syntactic transformation that does not obfuscate program as much as you might expect, so doing it explicitly by hand in cases where you absolutely need it is not a terrible idea.
It's unfortunate that I can't provide feedback on your magazine content since I need to pay for it first. You would attract a lot more readers if your first magazine publication (in its entirety) was free, with subsequent (monthly?) issues at a fee. You could even market this fact: "get the *very* first issue free!!!111!". Think of this losing a little money in order to turn a profit, by getting the word out that "PyGameZine exists, and it's fantastic reading!". To be honest, your 'supporter' scheme seems needy and desperate, and needs to disappear. I'm not one to dictate your business model but look at how other magazines market themselves, including the professional ones. They might accept donations but not one that I know of has your 'supporter' model. Personally, I think you would be much better off with a 'per issue' fee (say $10.00 per issue) and a discounted 'subscription fee' (lets say 10% off for a year subscription: $10.00 x 12 issues emailed directly to a subscriber = $120 less 15% = $108 per year). It's definitely a lot more sustainable and predictable than your current model, IMO. If you got a mere 5,000 people taking up your '$108 per year' subscription option (given that this is the Internet, your exposure is potentially hundreds of thousands, probably millions of people), that's $540,000 right there. Certainly a lot better than asking 540 people to donate $1,000. That said, focus on content, not dollar signs. It's easy to tell whether something was written for quality or for money making. Hell, even run a competition where if readers subscribe, they go into the draw to get a free copy of some professional software package (a commercial Python IDE may be a good place to start) valued at X amount of dollars, providing you can get a developer on board. Given that this is a digital magazine, it's not hard to see that if your content is good, PyGameZine will spread like a raging wildfire. I would be **more than happy** to pay $108 per year for quality content emailed directly to me, especially since the PyGame library has a lot of potential. Your magazine would definitely bring some much needed exposure to the library. **Prove** to your potential readers (including me) that your content is **worth** the asking price, otherwise you will not get the support you are hoping for. Harsh words, but ones which I believe needed to be said, and which I say without venom. I want you to succeed in this venture. To be honest, reading websites, blogs and documentation about Python (and PyGame) all the time sucks. Your magazine would be a breath of fresh air. PyGameZine has **a lot** of potential but you need to look at what other magazines are doing and how you can learn from their lessons. Good luck, I hope to see a free copy of your first issue soon. :)
Coming back to bpython+Pylab, I just did a few Google searches and failing that some DuckDuckGo searches, and could not find any step-by-step explanation of getting Pylab to work with bpython, and more than a couple of results that mention things like "unlike bpython, IPython supports a --pylab profile out of the box" :-) Also, bpython's documentation seems to be severely lacking as in it seems mostly stubs? And that's saying something because IPython documentation isn't exactly stunning either (IMVHO) (though maybe IPython's docs have improved since last time I looked). Anyway I can *really* recommend IPython, as well as going through the extra trouble of getting `ipython-qtconsole` working which requires installing the `ZMQ` library (which I had to build from source) and of course QT.
`pip install pillow`
-vvv http://pypi.python.org/pypi/Pillow
The anonymous function support is not quite the same as full first class functions, because you can't use already existing, named functions in consistent way. It seems you can only refer to existing functions by using a string that resolves to the function, and a string is different from the function object itself. 
I dispute that anonymity produces readable code. Just the opposite, I believe. I think that this numbers = (int(word) for word in input.split()) even_numbers = (i for i in numbers if not i % 2) squares = (i**2 for i in even_numbers) matching_values = set(i for i in even_numbers if cond(i)) is more readable than this: matching_values = set(filter(cond, map(lambda i: i**2, filter(lambda i: not i %2, map(int, input.split()))))) Using names along the way adds implicit commentary that aids the reader.
I'm not asking for something that can do what regexps cannot. I'm asking for something that makes it simple to parse text while not looking like an explosion in a typewriter factory. Right now, I have to choose one or the other. I can use regular Python to cut up my text, but that's a pain in the butt, or I can use Python's regexps to cut up my text but A) however many years later, I still don't feel like I really understand regexps B) it looks terrible and is difficult to maintain. Edit: Here are two regexps in one of my programs. START_LINE = r'^\[\^(.*?)\]\:(.*?)$' INNER = r'\[\^(.*?)\]' I would much rather that those looked like START_LINE = '[^{}]:{}' INNER = '[^{}]' Of course, I'm not completely sure I understand this new format either. How do I specify that `START_LINE` refers to a whole line, but `INNER` can appear any number of times in the middle of a line? I don't know. But maybe I'll figure it out if I read the documentation for this thing some more. Next time I do a project that needs regexps, I'll go back and take a look at this.
&gt; you use Python, PyGame, probably some free editor/ide, and probably many, many more free things. It's like an unsaid law: you take something (for free), give something back (for free). Er... some of those free libraries and tools that the authors are "taking" were actually created by the authors themselves. These are three of the big names in pygame. They've already "given back" a much larger "something" than I ever have. But I agree that they'll get more interest if they make at least some of the content free.
The idea is cool, the website is terrible. Now you might not think it would matter but since you are wanting people to pay then projecting the right image is important, that page could have been assembled in minutes, how am I to know that I am handing over my money for a decent product (note: I am not questioning your veracity here..). 
Maybe I'm just old, but `parse` looks like &amp; reminds me of REXX's [parse](http://en.wikipedia.org/wiki/REXX#PARSE).
Well, I for one thought it was a cool idea and plunked down $4.99 just to support the idea. Five minutes in, I think the presentation is pretty rough, but I'm liking the articles. Looking forward to more!
I don't care if it's blank. PyGame developers need to know how much, we who use it, appreciate their incredible efforts! I'm buying!
Maybe it compiles fine with Microsoft's compiler, but MinGW-w64 errors out. I fixed one problem and another popped up. Plus I'd have to obtain import libs to link the optional libraries: zlib, libjpeg, freetype, lcms. If a package has a few C/Cython extensions that compile without a hitch, I prefer installing from source on Windows. But in this case I think it's far simpler to just use an exe installer. 
And now, with an [Arch package](http://aur.archlinux.org/packages.php?ID=54187)! (unofficial repository)
Right, good point. I forgot about that, and yes, that is rather... "unsettling" is the word I usually use.
+1. I've always been a magazine junkie anyway, going back to 8-bit home computer days. Add to that the authors are creators of and contributors to Pygame, and I'm in for $4.99. That said, the content will have to be pretty good to get me coming back for $5/month. By comparison, Imagine Publishing is putting out iPad versions of their magazines for the same price. I know you're serving a niche market, but you should try to get the price down if you want this to be successful. Just my opinion! **EDIT**: Ok, I paid my $5 and got access to the content this morning. Constructive criticism: - The content is poorly formatted, in both the PDF and the web versions. Some code samples are shown in a variable width font that makes it hard to differentiate from the rest of the text. - One article is missing all of its code samples and a whole section. It's missing in both the PDF and the web versions - The PDF looks like it was printed from the web content, which on its own wouldn't be that big of a deal, but every page had "TEST DOCUMENT" printed on it, split between that page and the page before it. There are also no navigation links within the PDF. - In an interview, the interviewer asks a question about a problem with some of the interviewee's code. What proceeds from there is a stack trace that goes on in the PDF for about a page and a half. What value does that add to the interview. Overall, I love the idea, but the execution is pretty poor.
Sorry for mistake. It should be [1600x1000] but everyone can simply change geometrical dimensions.
Sort of cool, what is the thing on the right, a chicken?
I can appreciate Moka for what it is, though I think this type of library really thrives when applied to a specific problem domain.
It looks like fenix.
More proof that python is just a bit too idiosyncratic to fix with a library, and just a bit too elegant to ditch.
Definitely a chicken. It's me, too chicken to say I don't like this wallpaper in case it hurts this dude's fillings.
You have to either blit a background image, or fill the screen with a color before you draw the next frame's hand image.
I was basing this off of a 2009 talk at DjangoCon Portland, but this is a more updated slide deck: http://2011.djangocon.eu/talks/18/ One interesting set of slides shows different configurations of Django starting out slower than their CakePHP site and then surpassing it in requests per second as they tuned it. I think that makes a good point about PHP and Python performance: scaling is never simple, but Python is going to give you more knobs to twiddle to get it right. The other interesting thing is to compare the LOC count of the two implementations. That's more a Django-vs-CakePHP comparison, though. I can't find the original 2009 slides, but there was a quote in there from a Mozilla developer (paraphrasing from memory), "I've been a PHP developer for 8 years and a Python developer for 6 months, and I don't want to go back." A little too inflammatory for the original reply, but I don't think that's an atypical reaction to making the switch.
Thanks, "fenix" is way cooler than "chicken" ! http://www.google.com/search?q=fenix&amp;tbm=isch
Thanks, "fenix" is way cooler than "chicken" ! http://www.google.com/search?q=fenix&amp;tbm=isch
Thanks, "fenix" is way cooler than "chicken" ! !https://www.google.com/search?q=fenix&amp;tbm=isch
Thanks, "fenix" is way cooler than "chicken" ! [https://www.google.com/search?q=fenix&amp;tbm=isch]
I like the fact that someone fucking up the formatting will bork the program. That way people won't commit code with fucked up formatting.
Thanks, fenix is way cooler than chicken. [http://www.google.com/search?q=fenix&amp;tbm=isch]
i believe that there is also a technique similar to blitting a color, where it determines wether or not each pixel has changed and only blits those. 
i believe that there is also a technique similar to blitting a color, where it determines wether or not each pixel has changed and only blits those. 
I'd like to have a command line, web service and curses interface for a module that I'm working with. Would anyone recommend this library over any others for curses?
Hey brad2008, do you think fenix is way cooler than chicken?
There is a third method: use dirty sprites. I found them totally useless for my projects (redrawing the entire scene is the cheapest thing to do because my background changes all the time), but if your background is fixed then you can expect a big performance improvement with dirty sprites. But yeah, maybe these dirty sprites would be an early optimization, and these are bad :).
can you tell me more about dirty sprites?
What do you know about normal sprites?
I know a guy who thought my focus on indenting was a bit anal, but he wasn't really a programmer (he thought he was) and later choose python as his hipster language of choice. I got a chuckle out of that. Note: Please keep in mind that I'm not saying python is a bad hipster language, only that this *specific* guy had that pattern of making choices. He had to pick whatever the least common thing was. Dvorak for keyboard layout, prob never learned to type and gave up. Postgres - willing to bet he still hasn't used it. Can't stand Wordpress because its just too "common" - wanted a multi-person blogging platform with all the functionality of Drupal or Wordpress developed in house. Didn't like Disqus, Livefyre, or IntenseDebate and wanted a distributed commenting system developed in house too. Its all some strange form of technological hipster masturbation for him. He somehow could not see that the cost of developing those types of things in house when there are already several competitors that have dumped millions of dollars or nearly a decade of work into a project is a poor ROI if the focus is supposed to be the content.
You just need to blit over the sprite from the last frame with the same portion of background as it exists in, then draw/blit the sprite at its new location
I don't think this is premature optimization. Supposedly they got a 50% increase in server efficiency by doing it, so that is not negligible when people typically talk about premature optimization. Usually premature optimization refers to optimizing small sections of code thinking it will greatly improve performance when it shows that in most cases it doesn't. FB takes PHP code converts to C++, then compile the C++ to make a ~1GB binary file they can distribute to ALL of their servers via torrents in ~15 minutes. They have a lot of analytics tools to measure site performance with each release change and compare it to what is trunk. If you want more background on the deployment process there is a great video on their engineering blog.
The calc example is a lot slower than I would expect..
&gt; a serious PHP developer wouldn't do anyway cause they'd be using a templating language. There are plenty of "serious" PHP developers who don't use extra templating languages. PHP **is** a template language, that's the entire purpose it was created for and it's damned good at it. It doesn't need another engine riding on top of it. What *serious* PHP developers do, regardless of which template engine they use, is organize their code properly so that business logic is separated from presentation code, and HTML only exists in files meant to hold it. Besides that tidbit, you're spot on.
As much effort as I put into learning all this stuff when I started... I'm tempted to answer you properly. But at the same time, the more I play with using OpenGL to do pixel-perfect sprites, the more I'm tempted to say "fuck blitting, OpenGL rocks". Once you get it set up properly, it is truly incredible the stuff that OpenGL lets you do easily (and FAST!) even if it does have some of its own frustrations and idiosyncrasies. Fortunately other people have already answered your question, so I can have a clear conscience when I just say: "fuck blitting, OpenGL rocks".
I haven't tried on Windows. pillow worked for me when PIL didn't on Ubuntu. When installing in a virtualenv, PIL would install but not see libjpeg and so would throw a runtime error when I tried to decode jpegs. 
It's very good to know the raw byte pushing basics though. Nothing beats unsigned char *video = (unsigned char*)(0xA0000000L);
I want a script to parse a hard anal pornography folder and replace all faces with character from Angry Birds. Do you think this will serve humanity?
And hiring Java developers is cheaper than finding a Ruby developer.
That's a retarded argument. You can develop a huge complex site with fortran if you like. But it would be easier with PHP, and it would be even easier to make such a complex site with Python. My argument still stands and is valid.
No idea about Twig right now but I've tried it half a year ago and sadly it wasn't that good with many features missing. Had to go back to Smarty.
The documentation looks very attractive.
Seriously, it seems as if it's sending each individual press to the server. And getting a result, well, it's slow as hell.
&gt;Can you defend the GIL? What, like in a bar fight?
Having the same problem here! I just want to run a smallish web server and make it server static files as well, I do not want a damn config file for that. Cant I pass the "config" to wsgiserver when starting it somehow? CherryPy docs is not good in this sense. 
Just 50%? Latest benchmarks I saw had C++ at 3000%-5000% speed over PHP. If the code it produces is that horribly inefficient, I'm gonna have to take it back, it doesn't make sense even from a numbers point of view. Optimizing code that doesn't need to be optimized is always premature optimization. Optimizing your WHOLE CODEBASE is beyond that, a class of idiocy on to itself. They would get far better results by properly rewriting the performance critical parts in a fast language. And it wouldn't make any difference deployment-wise. Also nice job ignoring any points that don't have to do with your precious speed.
Is there any reason why you have to use IIS?
Some call this method dirty rectangles. [StackOverflow](http://stackoverflow.com/questions/76651/dirty-rectangles) to the rescue. There is a sample with pygame and some pointers.
&gt; Greatest travesties in software engineering history have been committed in the name of optimization. At Facebook's scale, even tiny optimizations can have huge impacts. Go look at the HTML for Google. Notice how it doesn't end the page with `&lt;/html&gt;`? It seems silly to omit these seven bytes of data, doesn't it? Consider that Google serves well over a billion pages per day. 10^9 pages served per day \* 7 bytes per page ~= 6.5 GB per day. Google transfers at least 6.5 *GIGABYTES* of data less per day, just by dropping an unnecessary closing tag from the end of their pages. They actually make more optimizations like this, including also dropping `&lt;/body&gt;`, but I figured I should keep the example simple. By the same token, Facebooks statistics page claims half of their 800M active users check Facebook a day. Even assuming everyone of these only checks, say, five pages a day on average (HA!), that's still 2 Billion pageviews per day, or (if evenly distributed) about 23,000 requests per second. At that scale, minor performance tweaks really matter. 
Perhaps something like [isap_wsgi](http://code.google.com/p/isapi-wsgi/) would do the trick. I wouldn't call it "web framework", but it would get you in the business of serving a python app under IIS. Alternately, you could look into a FastCGI based setup, although that would probably be more complicated. (Or a CGI setup, although I'm mostly just assuming IIS supports that, although CGI is not really a great solution) You'll probably end up caring about what WSGI is, and while that opens up a whole world of frameworks, in your case you probably would just end up with a bare WSGI application: def application(environ, start_response): start_response("200 OK", [("Content-Type", "text/plain")]) return ["TOTALLY OKAY MAN"] (I haven't used IIS, so I'm just pulling from what I know is out there.)
Unfortunately yes. The page I'm writing will monitor some applications that are hosted on a dedicated server by a Hosting company. They provide the means to monitor if you give them an url that returns "OK", "NOT OK". This script is run every 5 minutes and if the server returns a "NOT OK", we are both notified and can take the necessary actions. So in theory I could host this url everywhere (not sure if the hoster allows this), but because of the tests I want to do I want to host the script on the server itself, furthermore, if the script doesn't respond, we are notified too, and I don't want to be notified if there is no problem with the server. Last, I don't have access to any other server at the moment. If IIS is really too hard to do this kind of things, I see 2 options: * don't use python, but ASP.NET (would need to translate my script and I don't know anything of ASP.NET) * install an other webserver and host the page on a non 80 port (not sure if our hoster allows this, so I would need to check it). Both options are only a last resort, if IIS really is not feasible EDIT: formatting
ERR_TOO_MANY_REDIRECTS (in chrome)
I said that Facebook is a fringe case. Regardless, a 50% performance increase from rewriting everything in C++ is ridiculously low.
* Click on first demo: Communication problem, bla bla bla... * Click on second demo: The page is not redirecting properly. :(
even 2MB of gained memory means money :) Suppose a python object (like a template) taking 6 pages. Refcount is updated only on one of this pages (i mean the page containing the PyObject structure). So you still have 5 sharable pages. In addition to this, uWSGI is a c app, so most of its parts can be shared (even if a good part of it is already shared thanks to fork() COW). Think about massive hosting, where you have dozens of unrelated uWSGI instances (so no COW in place) that can share pages. KSM in very undeterministic, some kind of apps could get a huge boost, others will gain pratically nothing. 
A URL shortener, really? &amp;#3232;\_&amp;#3232; 
And not even a single demo worked. 
The jist i get out of all these posts is python is better because it stole CPAN from perl. PHP is born out of the complexity of learning perl. CPAN was born out of the lack of standard libraries. PHP has many of the features that CPAN brought to perl. Python is a better language than PHP &amp; perl. Use python since it has all the same libraries as CPAN, but easier syntax to stomach. How about this. Use what you are productive with, make your living, and eventually learn to use the language you love in your job, get a new job and use your favorite language. Don't tell people they are stupid or uninformed about their language of choice. Many times learning one language over another is about environmental resources which were of immediate usefulness. Python has been gaining momentum for the last 5-6 years. Many people have known PHP far longer. Stepping out of ones comfort zone is good only when it does not affect ones ability to feed themselves.
You might want to try [pyisapie](http://pypi.python.org/pypi/PyISAPIe/1.1.0-rc4). 
I suppose it is the right time to pop the Gandhi quote: "First they ignore you, then they laugh at you...". Pypy is really taking shape. (My only minor regret is the lack of support for gui lib, but numpypy is really the killing features here) 
At various points (at least twice I think), that Gandhi quote has been the channel topic in #pypy.
CherryPy
Ok guys, you've convinced me. I picked up php/MySQL in a week this summer from a book while doing a bioinformatics project. I'm interested in learning python, primarily as it applies to webdev. A secondary goal would be scientific / engineering computing (I'm a matlab geek/former TA). What books or resources do you suggest for learning python? Also, how does python handle scrubbing inputted data?
&gt; technological hipster masturbation Something we can *all* empathize with.
I used to be a big PyPy sceptic. Now I'm only a small PyPy sceptic! Mostly this is because I am on Windows and it's a hassle to test it to find out if I'll see any gains, especially times when they claim it's released for this platform before it actually is...
Just installed pypy, and I love how the interpreter feels so much faster than cpython.
Any further info about numpy changes? Or is it only dtypes?
&gt; Let's compare programmer effort level. foreach(range(1,12) as $y) { foreach(range(1,12) as $x) { printf("%4d", $x*$y); } echo "\n"; } Not really sure how your python example is any cleaner than this, they are pretty much the same. There's a couple more characters in the Python version, but I'd say the programmer effort is exactly the same. In fact, I would even argue that that PHP version is more readable due to range in Python stopping at n-1. Glancing at the Python code I first assumed that it went up to the 13 times table. Range seems to act differently in Python than in most all other languages I've encountered.
I still don't get it.
Try Ruby.
Uh yeah, I think so.
I've never had problems with Python's speed even though people claim it's slow. Even when you make a GUI program in Python it seems to be just like any other. But maybe my needs are too meager.
[web2py](http://www.web2py.com) is very easy to setup, learn, and use. Perhaps instead of serving it via IIS, you could install it as a [Windows service](http://web2py.com/book/default/chapter/11#Start-as-Windows-Service) (and run it on its own port). As for running your script, you could set up an [RPC service](http://web2py.com/book/default/chapter/09#Remote-Procedure-Calls) using the `@service.run` decorator. If you need help, ask on the [mailing list](https://groups.google.com/forum/?fromgroups#!forum/web2py).
+1, use this in combination with [bottle](http://bottlepy.org) to put a thin wrapper around your script that is WSGI compliant.
Probably in your head. Running Hello world in CPython takes 0.04 seconds of real time. Make no mistake, CPython is not _fast_, but it does not have a problem with startup speed.
Last I checked before disabling it, ubuntu had an apport hook that makes cold startup rather slow.
I've found my pygtk apps spend most of their time waiting for the user, and when they do have something to do, it's usually database or IO bound. Similarly for web apps... but of course, mine don't get 1000+ views / second (I think quora.com switched to pypy recently). That said, I've also got a bunch of pure-python crypto code, which spends all of it's time creating lists of integers, and performing all kinds of crazy calculations on them. *That* stuff, I notice the speed difference. One function I just tested takes 27s under CPython, 5s under pypy 1.6, and now 2.3s under pypy 1.7. That makes me happy :)
I'm running 11.04 with an unmodified CPython, and like I said, Hello world takes 0.04 seconds. Too lazy to reboot and check cold startup speeds.
I have not tried this recipe but it is supposed to work: http://www.web2pyslices.com/slices/take_slice/128
Almost 12x improvement for free is always good :)
 echo 3 |sudo tee /proc/sys/vm/drop_caches; time python -c 'print "Hello World"' # real 0m7.485s sudo dpkg-divert --rename /usr/lib/python2.7/dist-packages/apport_python_hook.py echo 3 |sudo tee /proc/sys/vm/drop_caches; time python -c 'print "Hello World"' # real 0m4.604s echo 3 |sudo tee /proc/sys/vm/drop_caches; time python -Sc 'print "Hello World"' # real 0m1.783s And 0.032, 0.021, 0.012 without dropping caches. (I can't really compare PyPy, it is not using system libraries here) But yeah, it doesn't matter anymore if I don't drop the caches; it was problematic for a command that I invoked almost as often as `ls` on a machine that had a slow ide disk; the differences were of maybe 150ms as I recall. 
&gt; CPython is not fast, but it does not have a problem with startup speed. While it's generally "good enough", startup speed has regressed with each version since 2.5. The Mercurial people noticed it, then I did a little profiling in Visual Studio and simple benchmarking. It's another one of the many things I'd like to look into for 3.3 before we get to a point where people really start to notice it.
python -m SimpleHTTPServer in the directory you want to serve
It is. It sends a JSON like this for each press: for(;;);[{"changes":[["change",{"format": "uidl","pid": "PID56"},["2",{"id": "PID56","width": "100%"},"1.0"]]], "meta" : {}, "resources" : {}, "locales":[]}] From the "Sampler – Core component examples", it seems each component sends its state to the server after some change.
Actually PyPy is dynamically linked, but it fares badly due to an [enormous binary](http://wyvern.cs.uni-duesseldorf.de/~cfbolz/pypysize/): 7.9, 6.2 with -S, 0.056 and 0.015 warm.
&gt; (I think quora.com switched to pypy recently) Yup, http://www.quora.com/Alex-Gaynor/Quora-is-now-running-on-PyPy
When you work at a startup, all you can afford to eat is ramen. There's even a term for when your company is just profitable enough to feed you: ramen profitability. I believe Paul Graham coined it. 
&gt;There are millions of programs all over the world using the traditional C language format. And yet many modern languages have moved away from it. Do you really think they had no reason? The main one is internationalisation - C formatting is problemmatic in this regard - it tightly binds the order of the parameters with the order they appear in the string, when in other languages, the order may in fact be reversed. In python's case, there are also two other fairly big warts with the `%` syntax. First, what do you think this function does: def f(x): print "%s" % x If you answered "prints the string representation of x", you're wrong. In fact it does the following: 1. If x is a non-tuple, print the string representation of x 2. If x is a one-item tuple, print the string representation of its first item 3. Otherwise, blow up with a TypeError The special casing of tuples allows subtle bugs where you intend to display generic objects, but it chokes when someone changes exactly what object gets passed. Another issue is the precedence: print "The answer is %d" % 6*9 is usually not what you want. "%" just doesn't have the right precedence to do what you usually want by default. It's also unneccessarily verbose for dictionary args (admittedly, these aren't standard C syntax either, but they're definitely something we want in a formatting syntax). Compare "%{greeting}s world" with "{greeting} world". Other things the new form can do that the old can't: - More expressive. "Hello {0.name}".format(some_object) instead of having to expand the object in the code. - You can mix positional and dictionary styles - Tidies up things like padding and alignment - You can repeat positional arguments. ie "{0}{1}{0}".format(quotechar, val) - It's extensible (custom formatters for custom types)
I really doubt you can feel the difference. I am sure you can measure it, but not feel it.
I'll have a good look at this, thanks 
perhaps I have dreamed too big for myself. The database has around 700 records
much better than the $4000 we were quoted by another association :)
your post more than any other told me I'm way over my head with the programming idea :)
Thank you all for helping me with this project. I truly appreciate it. I'll definitely look more at google docs to see if it can do what I want. writing the code is over my head and I'll bail on that idea.
I'm really looking forward to PyPy as the future of Python. Too bad donation to PyPy doesn't look really good :(
In this release: * Added dtypes * Added comparison methods on arrays and the ufuncs for them. * Added some more methods and properties to array (shape, size, copy). * ufuncs now are of the right type, and have various properties and methods, including `reduce()` * Exposed some more constants in the numpy module * You can now use tuples in a few places, they're restricted to being single item though.. For next release you can expect: * multi-dimension arrays * exposing all the box types (e.g. `numpy.int64`) and using them throughout * Supporting complex and custom dtypes * Who knows what else!
Everyday, I go to r/python... secretly wishing the PyPy guys would share something awesome. *PyPy now comes with stackless features enabled by default* &lt;- Mind blown. Congratulations on the release!
What I like is that Python is very stripped down in terms of syntax. Which means that writing Python feels very much like writing pseudo-code. Most of the time when I'm writing code in Python, it's as if I'm literally writing what I want the computer to do, which just happens also to be valid code.
I got it.
You have to be willing to take a slightly smaller salary.
blit doesn't make an image start blitting. It blits it exactly once. Your screen is like a chalk board or a painter's canvas. Blitting is like drawing on it. If you then want to get rid of what is on there, you must explicitly erase or overwrite it.
A single lock is much more efficient than fine-grained locking when there's not much contention over threads and resources because the act of locking and checking locks is expensive. So this made good sense back in the early 90s. Now, not so much, and I don't think anybody now tries to claim it's an optimal approach today.
I would like to do so many things, it's just a matter of time. I'm more of a programmer than a web developer though, would ruby benefit me much? Does it expand your understanding of programming, introduce new ideas, or anything like that? I really know very little about it. I was thinking the next language I learn, which may be awhile until I start, would be a functional language for those reasons.
That seems like a horrible piece of code to have to write.
I believe Twitter used Ruby on Rails. Ruby is very logical, almost psuedo-code, where everything is an object. Great little language and definitely worth a few minutes of review.
I love you BTW :)
welcome to ViewState hell!
I've used CherryPy for this before and it was quite easy using [this tutorial](http://docs.cherrypy.org/dev/progguide/REST.html).
Excactly. I've got a PyQt app and the heavy duty visualisation stuff is done by the C++ lib anyway. If you're app is data centric than Python's performance shouldn't be an issue. At least I have none. That said, things like creating indexes could be faster and if you get it for free with PyPy: Great! We just need a way to use PyPy with PyQt and the lots ... but I guess and understand that the PyPy guys have other priorities.
Even though I can't use it in my projects and probably understand only small parts of what's going on and how it works, PyPy makes me feel good. 
Django plus this has been wonderful for me for creating REST APIs: http://django-rest-framework.org/
Some web frameworks advertise a "REST" as a feature. But REST is a concept lacking a single concrete implementation. Any web framework can "do REST". It's likely any given web framework's "REST helpers" are sort of just training wheels that will help you understand HTTP better; you will ditch those training wheels sooner or later though. Usually it boils down to (these days anyway): accept JSON, return JSON, register views using the request method as a predicate.
Ptah 0.1 was released; it provides an interesting REST/Model integration. It is also built on pyramid. http://pypi.python.org/pypi/ptah humans on #ptahproject
A lot of IDE's automatically parse your files for TODO and FIXME, are you sure yours doesn't have a panel that's disabled?
I just create a TODO text file in the project directory and track it in the same manner as the rest of the project files, using Git.
So basically Python with a more complicated syntax.
Pyramid is the right tool for the job, its enough framework to get the job done, but not enough to get in the way!
I generally use Kate and nano/vim for development. Maybe I should just start using an IDE. I hear Pycharm is great.
Plus you don't have to put up with the Axe spray smell all day at the office.
Oh ok. Never heard of that quite honestly. Thanks for the explanation.
PHP is the only language HR could remember the name of.
I'm glad to see somebody bring up the benefits of Python deployment. Not only the base structure, but there are many options depending on what you want to build. There is mod_python, uWSGI, Gunicorn, etc. You could use something more tailored to building asynchronous applications as well. Most of those options are heavily supported and developed. Beyond the python wsgi interface, you also have interpreter options. cPython, Pypy, rPython, etc.
&gt; def f(x): print "%s" % x &gt;If you answered "prints the string representation of x", you're wrong. In fact it does the following: &gt; 1. If x is a non-tuple, print the string representation of x &gt; 2. If x is a one-item tuple, print the string representation of its first item &gt; 3. Otherwise, blow up with a TypeError How would the following work: "Hello {5}".format(x) when x is a one-item tuple? &gt;More expressive. "Hello {0.name}".format(some_object) instead of having to expand the object in the code. print "Hello %s" % some_object.name is even *more* expressive, since it makes it obvious that name is a property of some_object &gt;You can repeat positional arguments. ie "{0}{1}{0}".format(quotechar, val) That's only a problem in the classic style if the argument is a function with side-effects. In that case you must use a temporary variable to avoid re-evaluating the argument. &gt;It's extensible (custom formatters for custom types) print '%s' % custom_object.__repr__() Why reinvent Perl's "There's more than one way to do it"? BTW, the biggest PITA in Python is internationalization. If they really did a true effort in fixing that shit, I'd be all for Py3k. The problem is that Python tries to do too much and does not enough in this respect. 
Like I said it's a contrived example. But what if I want to write a printf() similar function? Surely this method would be more elegant than using an array, don't you agree?
Do them. Edit: tongue in cheek guys sorry ;)
The CPython people are intending to abandon development on plain old Python in favor of Python3. As a result pypy is to some extent the future of Python no matter what else happens...
AFAIK that's just file_get_contents() and file_put_contents() for read and write; works with URLs too - much improved over the old way with filehandlers IMO. They're still just functions though - but I'm curious to hear how OOP would improve them?
Nginx with Pypy, hold on to your hat.
Glad it was useful. The web2py google group is very helpful in case you want to join.
web2py restful APIs http://web2py.com/book/default/chapter/09#RESTful-Web-Services
About what? I was just agreeing with you.
Pycharm is great. A pycharm [help page](http://www.jetbrains.com/pycharm/webhelp/using-todo-lists.html) on TODO.
OpenGL shaders, like OpenCL, can beat raw memory writes.
I didn't know what you meant by ramen but someone explained it to me in another comment. :)
I use PyScripter, which is Windows only, but works *ok* with Wine, so far. Other than that, if you've got nerves of steel, try Emacs.
Back when I did PHP, you had to do stuff like $file = fopen("myfile.txt", "r"); $line1 = fgets($file); $line2 = fgets($file); fclose($file); Whereas, in Python: file = open("myfile.txt") line1 = file.readline() line2 = file.readline() file.close() or with a context manager: with open("myfile.txt") as file: line1 = file.readline() line2 = file.readline() One advantage is that all of the functions related to file handling are nicely tucked away and not cluttering up the namespace. The other advantage is that Python has this concept of a file-like object - an object that implements all of the methods of a file object, but doesn't necessarily write to a file on disk, but rather to a string in memory, or a network location using a variety of different protocols, or something you haven't thought of. File-like objects can then be passed to any function that expects a file. Oh, and one last example, looping over lines in a file (although, this is more about the fact that Python has lots of pretty syntactic sugar that expects objects with certain methods): $f = fopen ("myfile.txt", "r"); while ($line = fgets ($f)) { if ($line!==FALSE) print ($line); } fclose ($f); vs with open("myfile.txt") as file: for line in file: print line
I'm struggling to find a sensible example that I could code for you. It just doesn't make sense to re-implement printf()...
I've seen entire server applications written in PHP that have absolutely nothing to do with HTML. Hate on PHP all you like, but your statement is nothing but biased elitism.
So basically, a port of [Vaadin](http://www.vaadin.com) [Muntiacus Demo](http://www.muntiacus.org/sampler) [Vaadin Demo](http://demo.vaadin.com/sampler) Note that the Vaadin demo runs much better, so I'm guessing the Muntiacus servers are under heavy load from reddit. *Edit:* I should read the front page, it says it's a port of Vaadin. The Vaadin guys were on FLOSS Weekly [a couple of weeks ago](https://vaadin.com/blog/-/blogs/843768) and I thought it was a very cool idea for rich intranet-type apps, but was disappointed in the Java requirement.
I'm in no startup. I'm the only programmer. Ramen = Amen for Pastafari. 
this is a very unfavorable benchmark for pypy. pypy really shines for long-running processes (for instance: definitely not mercurial), because not only does it have a big binary (all rpython modules are in it), but also a jit that requires a warm-up time before things really get fast (but when they do ... wow!) the pypy interpreter itself is quite a bit slower than cpython (check out the "timeline" page on http://speed.pypy.org/ to see the difference), but the jit gets better and better all the time - it appears the pypy people see no elegant way to improve the interpreter, so they focus on the jit instead.
I hope you have shown your love [at the pypy/numpy donation page](http://pypy.org/numpydonate.html). I have!
Eclipse automatically tracks and lists comments containing "TODO:" in a project's source files. I'm not necessarily recommending Eclipse, but it does manage this in an easy-to use way. 
Our company has used [ISAPI_Rewrite] (http://www.isapirewrite.com/) to allow requests recieved by IIS to be passed off to a Python (CherryPy actually) server. As the name suggest it's an ISAPI filter which is installed within IIS. While I'm here selling other peoples products ;-) ... I'll mention that we run that cherrypy web-server as a Windows Service using [FireDaemon] (http://www.firedaemon.com/) . There are certainly other ways of achieving the same end but FireDaemon is certainly nice and straightforward. There's another option I've never tried myself and that is use Classic ASP with Python as the scripting language. There's a [description here](http://www.4guysfromrolla.com/webtech/082201-1.shtml) and a slightly less aged [microsoft knowledgebase article here](http://support.microsoft.com/kb/276494). Before .NET came along (and so saved me from VBScript hell) I had given it some thought myself but I was never clear how the Python intepreter could be started (or shared) for each page request. Anyway I include it for interest.
&gt; According to all I've read about this it is planned to be considered "deprecated" in Python 3.1 and eliminated in Python 3.2 That is obviously wrong. &gt; I've been programming since 1975, I've written millions of lines of code during these 36 years and do you know how many times I've needed advanced string formatting beyond what the C-style offers? Never. Good for you.
Vim user here, and personally, I find that inline TODO/FIXME comments do the trick rather nicely; Most of the code I work on is 600~3k lines / file. If I don't know what to do next, I just /FIXME, scan through the results and work on what ever I feel is most important, or what I can do given how much time I have. Vim makes me work on these thanks to the highlighting my colourschemes provide. If this is not enough, I imagine you're probably working on a team of 5+ people and maybe scrum, in which case you should have regular discussions with product owners as to what they feel should be fixed. As for tools, at work we use Jira.
&gt;when x is a one-item tuple? It'll print a 1-item tuple (assuming you meant "{0}" there - if you meant {5} it'll fail for the same reason %s formatting does with not enough parameters) . There's no special casing for tuples needed in the new format syntax. The only reason it's there in the % syntax is because you need a way for a binary operator to provide multiple values. For a function, there's no need - it's one value per parameter. &gt;`print "Hello %s" % some_object.name` I did say *without* having to expand the object in the code. The advantage is that you can do more in the (localisable) data, allowing you to be more customisable (eg. different naming schemes using different fields, or other cases where slightly different data is needed). &gt;`print '%s' % custom_object.__repr__()` Not the same thing. You can have custom format *strings* - ie allow your own format codes as an embedded format. Eg. datetime implements the strftime format codes as an embedded format so: "The time is {0:%H:%M}.format(datetime.now()) extracts just the hour and minute part. This keeps all the formatting logic in the format string.
Don't switch to an IDE! Use this bit of Vim script instead (if you like Vim): imap &lt;F12&gt; &lt;C-o&gt;:ShowTodoList&lt;CR&gt; nmap &lt;F12&gt; :ShowTodoList&lt;CR&gt; command! ShowTodoList call s:ShowTodoList() function! s:ShowTodoList() cd $my_project silent grep 'TODO\\|FIXME\\|XXX' **/*.[hc] cwindow if &amp;buftype == 'quickfix' resize 10 let w:quickfix_title = 'To-do list for $my_project' endif endfunction Of course this is a minimal example, you'll have to change some things: * Change the `cd $my_project` line to navigate to the root of your project directory * Change the `**/*.[hc]` pattern to match the files you want to scan (you can type `:edit $pattern&lt;Control-D&gt;` to see how Vim expands the [glob pattern](http://vimdoc.sourceforge.net/htmldoc/editing.html#wildcards)) If you know a bit of Vim script, you can extend this in all sorts of fancy ways, e.g.: * Strip comments markers so the to-do list becomes a bit more readable * Automatically update the to-do list every once in a while using a [CursorHold](http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold) automatic command * Use some kind of inline marking for priorities of tasks, so that you can filter the contents of the to-do list Hope this helps, if you have any questions feel free to ask!
&gt;assuming you meant "{0}" there No, I didn't. You mentioned a run-time error, quoting from your post, *"3. Otherwise, blow up with a TypeError"*. My question is, how does the new format method handle errors like that? &gt;datetime implements the strftime format codes as an embedded format If datetime already handles that, why do you need to rewrite it? Do you see? It's all contrived examples, 99.99% of the cases are handled by the classic % operator, the very few exceptions are already taken care of. There's absolutely no need for a new format! Try finding an example for some place where I get a significant new functionality from the new format. Let's see if that justifies all the hassle in changing the existing code, let's see if that justifies typing ".format()" instead of just "%" for **all** the cases where this new functionality is **not** needed. 
Django might have 'bloat' depending on what you think is bloat; however, TastyPie is really a top notch way to generate a REST API. It provides a boat-load of functionality after a handful of code pointing it to an existing Django Model object.
How about this? # model db.define_table('todo', Field('title'), Field('details'), Field('priority',requires=IS_IN_SET(('high','medium','low'))), Field('deadline','datetime'), format='%(title)s') # controller @auth.requires_login() def manage_todo(): grid=SQLFORM.grid(db.todo, fields=[db.todo.title,db.todo.priority,db.todo.deadline], orderby=~db.todo.deadline,editable=True,deletable=True) return locals() 
Many projects will definitely not be (perceptively) sped up by PyPy Things with "lots of loops" would usually have the biggest improvements, for example [running this raytracer](http://www.lshift.net/blog/2008/10/29/toy-raytracer-in-python) in CPython takes 1min20 or so, and in PyPy takes about 5 seconds, which is about a 16 times speed up with no code changing Although PyPy main.. selling point is speed, it does have other benefits. For example, [sandboxing and Stackless](http://pypy.org/features.html), and also because it's written in Python, it seems relatively easy to develop compared to CPython
I found [this tutorial](http://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html) on the "RPython translation toolkit" helpful in understanding how PyPy "works" It explains how to write a Brainfuck-interpreter in RPython (which that takes 11 minutes to execute `madel.b` with a python interpreter).. it is then, by some high-tech sorcerery, translated into a compiled executable and runs in about 12 seconds
I've barely used NumPy, and don't have any idea what a dtype or ufunc is, so this might be a silly question, but.. how much NumPy code would be capable of running now? Is there examples somewhere of code that will work/wont work?
What were you missing? I haven't used it beyond trivial things, so I'm curious to know.
Hm, looks like check_output is only present on 2.7+.
&gt;No, I didn't. Then I don't really see the relevance. It deals with passing the wrong number of parameters exactly the same way %s does: by raising an error saying you passed the wrong number of parameters. Whether those arguments are a one element tuple or otherwise makes absolutely no difference. OTOH the special casing of tuples makes for very non-obvious behaviour that's a cause of subtle breakages in unexpected cases. It's just a bad API. Thus the way the new format deals with it is in having an API that doesn't have that design flaw in the first place. &gt;If datetime already handles that, why do you need to rewrite it? You don't need to (for datetime), but datetime does it by implementing a custom formatter, exactly the same way you'd do it for a custom class of your own you want similar functionality from. The reason it can be done there is because the ability exists in the format syntax. &gt;99.99% of the cases are handled by the classic % operator, the very few exceptions are already taken care of. Hold on - even if we buy that datetime is the *only* possible case where this would be desirable (and I disagree - pretty much anywhere where you've a similar multi-part object may benefit (eg Decimals, rationals, complex numbers), or just want to display something different ways, the % operator *does not do this*. There just isn't the interface for it for datetime to hook into it. Instead, you'll have to do 2 separate formatting steps: one to format the datetime to a string (via strftime or similar), and another to embed this formatted string in the main formatted string. &gt;Try finding an example for some place where I get a significant new functionality from the new format. I should point out that you've raised rather minor objections to *some* of the more minor points I gave as an afterthought, have given an invalid objection to one of the two main warts I gave, failed to address the other, and also completely failed to mention the one issue I explicitly gave as the *most important* one: localisation. C style positional arguments just aren't suitable for this, and are a bad habit to get into in any modern code. The justification for switching is to use something that isn't bug-prone and unsuitable for i18n.
So what you're saying is, variable number of arguments is never appropriate?
How much of the reasoning are you permitted to do ahead of time? :) Seriously, though, what have you tried?
I don't tend to have huge projects, really. So, TODO comments, and if I think I'll forget about those, a note to self on my Google Desktop.
No, definitely not.
Seconded on using Hadoop. Even if the task is not very data intensive Hadoop makes it trivial to farm out your tasks. Check out [Dumbo](https://github.com/klbostee/dumbo/wiki)
Well I understand that the 3 digit palindrome must be within range[909,1000, 10] and I understand that there must be a for loop within a for loop at some point. The 4 digit palindrome is 1001, and I just need to find a way to write a program that can test the sum of every 2 and 3 digit palindrome and know that 1001 is the right answer. Though I can not include 1001 in my logic, I need to find out what the 2 palindromes are. EDIT: Just to clear things up, I'm not allowed to use the statement "if x + y = 1001, print x,y"
http://bottlepy.org/ will suit your needs the most accurate way.
Speaking from experience in the Django world, the popular REST APIs ( Tastypie &amp; Piston ) become a real pain to manage if you need to start writing custom behavior for your handlers. Like serializing non-standard fields or working with custom validation on the rest verbs. Piston's serializer also has some serious performance issues when serializing many-to-many relational models. But if you work with generally vanilla Django constructs in standard ways then they'll save you ton of time.
It looks good, but it would be nice if the binaries worked on RHEL.
[Tornado ](http://www.tornadoweb.org/)
And the whole point was when such a scenario arises Python handles it much better than PHP. So what are you arguing here...
That in that specific scenario, an array of passengers is almost always going to be a better representation of the data.
It's merely an example to demonstrate how variable number of arguments work in each language. Try to look past this specific example.
I followed your link and didn't find the puzzle. Why do you know that the 4 digit palindrome is 1001? The two digit palindromes are in [00,11,22,33,44,..,99]. so 99 + x &gt; 1000 since that's the smallest x to get 4 digit result. So x &gt; 901 if x == 99 def ispal(n): n=str(n) # integer becomes string return n==n[::-1] # original is compared to reversed and the result is returned print 'this kinda proves it works. 898 is a palindrome: %r' % ispal(898) # now onto serious business # you want to loop one var from 10 to 99 and another from 100 to 999 # for each iteration you should make sure both are palindromes # and you want to get the ones that when added toghether produce # a palindrome of length equal to four. # # http://docs.python.org/tutorial/datastructures.html#list-comprehensions print ['%dx%d=%d' % (a,b,a+b) for a in range(10,100) for b in range(100, 1000) if ispal(a) and ispal(b) and ispal(a+b) and len(str(a+b))==4][0] #only the first result gives this: this kinda proves it works. 898 is a palindrome: True 22x979=1001 but I think the b range can be made from 901 to 1000 compliments to medecau 
 def ispal(n): n=str(n) # integer becomes string return n==n[::-1] # original is compared to reversed and the result is returned print 'this kinda proves it works. 898 is a palindrome: %r' % ispal(898) # now onto serious business # you want to loop one var from 10 to 99 and another from 100 to 999 # for each iteration you should make sure both are palindromes # and you want to get the ones that when added toghether produce # a palindrome of length equal to four. # # http://docs.python.org/tutorial/datastructures.html#list-comprehensions print ['%dx%d=%d' % (a,b,a+b) for a in range(10,100) for b in range(100, 1000) if ispal(a) and ispal(b) and ispal(a+b) and len(str(a+b))==4][0] #only the first result have a good one
If you are looking for something much smaller and more targeted than Django or Pylons or... well many of the others, bottle is the way to go. It's tiny and it's focused, and it does what you want!
I use pickleDB while coding a text-based game I'm fiddling around with. It's simple and extremely lightweight. key-value. database. python.
https://bitbucket.org/prologic/circuits ^^ circuits.web has this built in quite nicely. The project (lacking some docs) is very good and stable too. Example of a REST API web app in circuits would be: from circuits.web import Server, Controller class Root(Controller): def GET(self): return 'the get response here for index' (Server('0.0.0.0:8000') + Root()).run()
What the? Who downvoted this person without even offering a constructive feedback?
Isn't this essentially just shelve?
Wouldn't that make Python3 the de facto future of Python? I agree that Pypy is the future so far as amazing new features is concerned, but CPython is still going to be CPython.
I was just about to say that. http://docs.python.org/library/shelve.html
&gt; it's damned good at it In my opinion, not really. * It's ridiculously verbose * Unless you use something like Zend Framework, it lacks basic templating features such as placeholders/blocks and partials. * Requires you to escape everything you print to the page * lacks some of the more advanced features of other templating system like extra looping constructs (loop.first, loop.even etc...), filters, inheritance etc... all of which can save you a lot of work compared to raw PHP. I agree that seperation of concerns is very important, but if you've split out your view layer already, why not use something optimised and built for the task? 
The structure of this [is kind of naive](https://github.com/patx/pickledb/blob/master/pickledb.py#L32). It's a bunch of a module level function definitions accessing a `global db` variable. If you desire to create multiple pickleDB databases this is going to cause problems. I don't see a usecase where this is better than either the standard library's shelve or Redis.
Easier IMO. To each his own.
Upvote for twig! It's come a long way since fabpot picked it up and it's now a conerstone of the new Symfony2 framework.
You want a real parser, something EBNF based. My favorite for python is [Funcparserlib](http://code.google.com/p/funcparserlib/). Minor note, I just spent a few minutes trying to spec out your example, but it is really ambiguous. Best I got was letter = some(lamba x: x in alnum) start = beginline + a('[') + a('^') + many(letter) + a(']') + a(':') + many(letter) + endline inner = a('[') + many(letters) + a(']') parser = many(start | inner | letter) But I was blanking on how to turn a newline into a pair of beginline/endline tokens for the parser to grab. I've written a little guide, http://kmkeen.com/funcparserlib/ that gives a nicer example of the library.
That's not how it works with computer languages. A language exists outside of its implementation. If you manage to popularize a variant you don't end up with just the variant. You end up with two languages.
&gt; "First they ignore you, then they laugh at you...". ... then you speed up runtime by 4x, then you port numpy, then you win. I think said Gandhi said something like that.
The only downside to shelve is, it seems to be easy to corrupt, and you have to work around that. I'll have a key that shows up in .keys(), but when you try to access it, it'll throw an exception.
This guy obviously didn't bother searching google for similar implementations before writing this. He's re-implemented something in the std lib: shelve, dbhash(bsddb), dbm, gdbm, anydbm, etc...
the arrays and data types are used behind the scenes in numpy for all the linear operations and matrix operators, that's why it's a big deal i think.
There is [SplFileObject](http://www.php.net/manual/en/class.splfileobject.php) which is part of the [SPL](http://php.net/manual/en/book.spl.php) (Standard PHP Library) which is a small, but slowly growing collection of utilities and interfaces.
Not 100% true, there is [SplFileObject](http://www.php.net/manual/en/class.splfileobject.php) which is part of the object oriented section of PHP's standard library.
We've been using piston for a while, and it's pretty solid. You can avoid the serialization hit by returning the relevant information as a dict (or nested dicts) rather than the django models... it's not the prettiest, but at least it does provide a way around the issue, making 95% of your code convenient, and the other 5% performant (where it needs to be).
If you really want hints: I used a nested loop. There is a builtin function for reversing a list, as well as converting a string to a list, as well as comparing strings, and converting ints to strings. These are the tools they are expecting you to use. Splice with negative step is clever, but if you submitted that to me, I would assume someone told you.
i didn't, but the point upofadown makes is retarded
"The Python 2.7 series is scheduled to be the last major version in the 2.x series before 2.x moves into an extended maintenance period." CPython is the mainline. The CPython devs explicitly stated that they will remain the mainline for the foreseeable future. (PyPy only works on a few platforms, and few select versions. It's also now several years behind the language forefront.)
If PyPy made the mature decision to immediately abandon 2.x for 3.x, they could play a much larger role in the future of Python. PyPy is useless to me since I moved to Python3 over a year ago.
Self-referential post ahead, and I'm unabashedly in favor of TastyPie. I did a talk @ PyOhio on this, generally about creating REST apis, and a little on python. Slides: http://issackelly.github.com/Creating-Web-APIs-that-are-a-Joy-To-Use/slides/slides.html#intro Video: http://python.mirocommunity.org/video/4390/pyohio-2011-creating-web-apis- Later I did a talk @ DjangoCon in more depth w/TastyPie. Hopefully worth an hour if you're investigating this stuff. Video: http://blip.tv/djangocon/building-apis-in-django-with-tastypie-5572790 Slides: http://issackelly.github.com/Building-Web-APIs-for-Django-with-Tastypie-Talk/loupe_project/static/slides/index.html#intro There's also good support both on the mailing list and Stack Overflow for TastyPie.
Can't really say right now but one thing I know I wasn't ok with was the fact that a variable defined insade any loop wouldn't be visiible outside of that loop.
Sounds like you made a poor decision. The python world is still on python2, and pypy is following that.
Should be image/png. edit: okay, I see you did use image/png, despite saying text/png. Did you try capitalizing "Content-Type"? I'm pretty sure that's supposed to not matter, but I'm just throwing out ideas... What if you do: `self.write(ex_plot()); self.finish()` ?
Why did you choose that rather than tastypie?
Suffers the same problem as shelve does. It does not lock the db and therefore it gets corrupted when accessed by two processes or threads. the all point of key:store values is that they can accessed concurrently, safely and efficiently.
Yeah it's a shame that things move so slowly. I am regretting it. Peace of mind does not trump functionality and support.
oh great, another key-value data store. goody.
I did try capitalizing content-type, actually! Just tried splitting up the write and the finish (to check), but no dice. Edit: Thanks for the heads-up; I fixed my post.
Link please.
Man, it's like I wrote this. Scrum, JIRA, vim, TODO, small team, a handful of 600-3k line files... it's my life.
Immediate abandonment is not typically described as a mature solution.
[Flask](http://lucumr.pocoo.org/) with [Flask-API](https://github.com/namlook/Flask-API) Is a solid starting place. It's lightweight, so you don't get a lot of scaffolding, etc to get you started.
This is an april fools joke right? https://github.com/patx/pickledb/blob/master/pickledb.py#L29 He just made a wrapper for json Not only that, but he writes to the file after every single operation
My solution was pretty half assed
Solved it.
REST is a set of principles that a tool may help you in putting into a real service, but at the end of the day YOU are the one designing the REST web service, not the tool. Use whatever tool you find easy on you with basic support for routing and HTTP dispatching.
http://docs.python.org/release/3.1.3/library/subprocess.html
I've donated a week ago, and the donations bar didn''t move at all ever since. It was "$2567 of $60000 (4.2%)" back then, and it's the same now. I hope they got my money and it's just a refresh issue...
"so, what does your dad do anyway?" - "you know, hippies from the sixties... .... *SNRK*"
Not really immediate abandonment when python3 has already been out for 2 years.
Unfortunately those bars need to be updated manually.
I keep todo stuff either in a bug tracker, or my Getting Things Done system, not in comments in the source code. (With rare exceptions, as usual.)
 &gt; Welcome &gt; pickleDB &gt; is &gt; a &gt; lightweight &gt; and &gt; simple &gt; key- &gt; value &gt; store. (at 1200px wide you get one word per line, there are better damn ways to center content...)
great link, thank you
I have a todo text file (if its a personal project I'll source control it) for features, and inline #TODO for functionality/enhancements. I've tried to use a more managed system (web based interface with tasks, level of effort, priority) but personally I didn't see any improved productivity. That said, now that I think about it, if I could have a tool that allowed me to sort todos by PRIORITY divided by LOE it probably would be helpful. I still would keep inline #TODO statements though.
I agree with that as long as you have a single project that you are working on. The issue comes about when you need to context switch.
I use flask, flask-peewee &amp; flask-wtforms, and run it with cherrypy while also serving the static files. All python in a single bundle. 
You could try making a mockup with SimpleHTTPServer to see if it is Tornado, or something else.
I submitted this link because if watched [this](http://www.infoq.com/presentations/Running-a-Startup-on-Haskell) presentation related to haskell and, according to the speaker, the most important idea to get from there is to have a look [QuickCheck](http://en.wikipedia.org/wiki/QuickCheck). Hence, I looked for QuickCheck implementations in python and found paycheck (there are others, but this ones seems to be more actively maintained). So my real question is if you have used something like this and if you have found it useful.
This is so silly, so naive and so adorable. I think I'll roll one of these my own just to get something into the pypi. 
yep, he was quite some guy...
I don't want to be rude, but the code is just shitty. Take this from professional Python coder. Sorry, mate.
It was generated with [bloat](https://github.com/martine/bloat) and [webtreemap](https://github.com/martine/webtreemap).
The hello world barely even measures code speed, just load performance. PyPy could start up as fast as CPython with some smart relocating, and maybe by moving some resources outside of the executable.
Why do you need a data storage daemon for a desktop application? Python comes with SQLite, which is pretty good as embedded data storage. If you want something more "fancy" I suggest you to have a look at the ZODB, a python object database that can be used as embedded storage. 
You can ship a small service manager with [supervisord](http://supervisord.org/); it can launch redis/memcached for you. As far as databases, you can use sqlite in-process.
after reading some responses, I don't know why people iterate from 10 to 99, or from 100 to 999. Wouldn't be more simple to generate the palindromes? it's not difficult and minimices iterations 2 digit: [a*11 for a in xrange(1,10)] 3 digit (not a 1liner for clarity): for a in xrange(1,10): for b in xrange(1,10): a*10+b*101 I would probably put both as generators and simply add and check for a 4 digit palindrome Edited to correct the for expression
+1 for SQLite. As it is the most deployed database, I tend to think it will be enough for almost any desktop application.
I don't think they should *abandon* Python 2 yet, but I would like to see Python 3 on PyPy. The changes in Python 3 are something we want for the long run, and we are now getting a lot of the key libraries ported. I don't want the community to get split over PyPy vs. Python 3. I have donated a bit to the [Python 3 PyPy port](http://pypy.org/py3donate.html) - I'd encourage you to do the same.
You've got to be kidding. I am always in the middle of a TODO, but I come up with new TODOs at about three times the rate that I complete them!
I have no idea what that is, but I'm intrigued.
If it suits your use case, SQLite is designed for this sort of case, and is included in recent versions of Python. I realise that's not exactly answering your question, but it's worth mentioning.
So does this just throw a whole bunch of random things into each parameter?
TIL that `subprocess` has some neat new convenience functions. I still like my convenience function better though. :-) "Convenience module for subprocess." from subprocess import Popen, PIPE class ReturnedError(Exception): pass def run(command, input="", binaryout=False, encoding="UTF-8", stdin=PIPE, stdout=PIPE, stderr=PIPE): """Returns result of running 'command'. 'command' can be string (will be split) or a list.""" #Deal with unicode #If you want some other encoding, send us bytes. if not isinstance(input, bytes): input = bytes(input, encoding=encoding) #Subprocess wants a list of commands if hasattr(command, "split"): command = command.split() process = Popen(command, stdin=stdin, stdout=stdout, stderr=stderr) output, err = process.communicate(input) if not binaryout: output = output.decode(encoding) #Raise errors, but make the output salvagable if err: e = ReturnedError(err) e.output = output raise e return output
How does this compare to http://dan.bravender.us/2009/6/21/Simple_Quickcheck_implementation_for_Python.html ?
By the same logic, there's no need for bug trackers, because you should just fix any bug as soon as you know about it. We know that's not practical.
I've never been very fan of urwid's signals (while urwid is very cool but not very intuitive). I've always prefered [louie's signals](http://louie.berlios.de/) which are stupidly simple: def hello(): print "hello" louie.connect(hello, "say hello") louie.send("say hello") # will print "hello" and return a list of tuple of (called_function/callable, return of the function) (Yes, you can give a parameter when sending etc...) I've never understood why people makes things more complex.
I think that this is awful code as well. Global variables are best avoided in general. (By the way, you only need to use `global` when assigning to a variable in that scope, not when indexing/keying the object. But still.)
This is a nice command for grepping for your FIXMEs across the codebase and putting them in the quickfix pane. :noautocmd vimgrep /FIXME/j **/*.py&lt;CR&gt;:cw&lt;CR&gt;
http://www.web2py.com/ My favorite web development framework.
&gt; I've always prefered louie's signals which are stupidly simple It seems to be simple indeed and could be useful, I'll have a closer look into it, for sure. &gt; while urwid is very cool but not very intuitive Agreed, but unfortunately, it's not like we have much choice about ncurses library for Python. Thanks for the tips. 
I think pylint can catch TODO comments as well.
Hi, I implemented something similar just for fun. I call it **pdicts** :D http://pypi.python.org/pypi/pdicts/0.1 It still is silly and it sucks but, given your professional status, is it in anyway better? :)
For future web users: CherryPy with flask-peewee main.py from admin import admin from api import api from models import * from views import * import cherrypy import os PATH = os.path.abspath(app.static_folder) cherrypy.tree.mount(None, '/static', {'/' : { 'tools.staticdir.dir': PATH, 'tools.staticdir.on': True, }}) cherrypy.tree.graft(app, '') cherrypy.engine.start() cherrypy.engine.block() 
Can I interact with supervisor with Python? class MyApp(object) def init(self): self.rd = RedisDaemon(socket='redis.sock').start() self.r = redis.Redis(unix_socket_path='redis.sock') def exit(self): self.rd.stop() 
How fast is SQLite for lots and lots of data (100,000+ rows)? Just that Firefox uses SQLite for it's awesomebar, and that's bloody slow.
Hmm, apparently FTS4 isn't compiled in SQLite by default :&lt;
18 comments (before this one), and I think someone's mentioned just about every mainstream Python web framework (Django, flask, bottle, tornado, web2py, cherrypy, pyramid), plus a few I've never heard of. moos3, you've won this game of "web framework bingo".
I think this really only makes sense when and if there is a significant amount of stuff written in Python3. The magic of PyPy is that it can greatly speed up *existing* code.
Yet iOS uses sqlite for all it's storage and it works just fine. SQLite is perfectly fine for 99% of embedded db needs. The work of ensuring correct indexes and perhaps even sharding if the data you're storing is very large is going to be a lot less effort than attempting to bundle a 3rd party library, or even worse, server/daemon. Seems like the easiest thing to do would be to seed it with some test data and make sure it performs up to your standards.
I suck because I don't track any of my TODO but I promised myself that I would use [Trello](https://trello.com/) if I wanted to track them. Looks great and seeing those "Done" lists should be quite nice. 
supervisord exposes an [XML-RPC command interface](http://supervisord.org/xmlrpc.html)
This is true, and if you're careful about the way you write your code (utilising \_\_future__'s etc...) then porting your code when the time comes is just a 2to3 away...
I'm fairly certain PyPy has no intention of maintaining a Python 2 release past CPython which, for all intents and purposes, is Python's reference implementation.
Python already has a similar framework, supporting several frontends (jquery, qooxdoo, zk): http://rctk.googlecode.com/ Works reasonably well and very pythonic. Even supports Python 3
The problem: aa + bcb = dddd Code: for a in range(1,10): for b in range(9, 10): for d in range(10): r = a*11 + (b*100 + d*10 + b) rs = str(r) if len(rs) &gt; 3: if rs[0] == rs[3] and rs[1] == rs[2]: print 'Solution:', rs, a*11, ((b*10 + d)*10 + b) break
PyPy will maintain Python 2 version for the forseeable future. Among other things, our translation toolchain is Python 2 so we bootstrap on it. We however don't plan to introduce new language features to 2.x branch, so it'll be python 2.7 forever.
As I understand it then, lots of values just won't work, because json won't understand them, and that's why [jsonpickle](https://github.com/jsonpickle/jsonpickle) was invented.
He's actually not using jsonpickle, he simply imports json as the name pickle. Weird to say the least.
I'm a bit of a noob. What does that second one do? You're creating a method that returns a blank string, but you're not calling it. What does the method.__get__ actually do?
Check out [web2py](http://www.web2py.com), which makes it very easy to [generate a RESTful API](http://web2py.com/book/default/chapter/09#RESTful-Web-Services) for your database models. In particular, look at [`parse_as_rest`](http://web2py.com/book/default/chapter/09#parse_as_rest-%28experimental%29), which lets you define URL patterns that map request args to database queries; and [`smart_query`](http://web2py.com/book/default/chapter/09#smart_query-%28experimental%29), which enables you to pass arbitrary natural language queries in the URL. If you need help, ask on the [mailing list](https://groups.google.com/forum/?fromgroups#!forum/web2py).
[http://bugs.python.org/issue1578269](http://bugs.python.org/issue1578269)
How does your approach relate to redis? Some comparative tests would be nice.
On a personal note we are using redis as an internal data store, one reason we went this method is that there is a web interface for it as well: https://github.com/nicolasff/webdis So basically we are using a MVC type framework, where python dumps stuff into redis and then the HTML5 page pulls in data via jquery and webdis. Web interfaces may exist for the others but I guess it really depends on what you need it for. Another thing to consider is I don't know how well redis deploys on windows (I'm a linux guy). 
As far as I know, Opera browser uses SQLite for history (storing and indexing content of up to 50,000 webpages) as well and it works fine. Opera also features mail client and I believe mails are stored in sqlite too. As mentioned bellow, the biggest advantage is that it is ready to go wherever you have python installed. Try it out at least and report if you remember (I'm interested). For performance tips, check this wiki article on stackoverflow: &gt; http://stackoverflow.com/questions/1711631/how-do-i-improve-the-performance-of-sqlite "Using the same compiler (and compiler options), the same version of SQLite and the same data we've optimized our code and our usage of SQLite to go from a worst-case scenario of 85 inserts-per-second to over 96 000 inserts-per-second". 
I was able to reproduce your problem with the lower case `content-type` but not with `Content-Type`. The browser has probably cached the response, so you need to do a force reload to see a difference. In Firefox this is Ctrl-F5, I don't know what it is in Chrome. The issue is that your request starts out with a default `Content-Type` setting. If you then call `set_header('content-type', ...)` you end up with two headers. I modified your example as follows: print "before: %r" % self._headers self.set_header("content-type", "image/png") print "after: %r" % self._headers And the output with lower case is: before: {'Content-Type': 'text/html; charset=UTF-8', 'Server': 'TornadoServer/1.2.1'} after: {'content-type': 'image/png', 'Content-Type': 'text/html; charset=UTF-8', 'Server': 'TornadoServer/1.2.1'} ...which results in a response that looks like this: $ curl -s -D - -o /dev/null http://localhost:8080 HTTP/1.1 200 OK content-type: image/png Content-Length: 17895 Etag: "a36f259f7074afac217481a4042de1adc3b854be" Content-Type: text/html; charset=UTF-8 Server: TornadoServer/1.2.1 This also explains why different browsers react differently -- do they use the one that's spelled correctly, the one that comes first in the headers, or the one that comes last? Anyway, with the proper spelling and a force reload both Chrome and Firefox treat it as an image instead of html. 
The function type implements the [descriptor protocol](http://docs.python.org/reference/datamodel.html#implementing-descriptors), and that's how method binding actually happens. class A: pass A.f = lambda self: 'zzz' o = A() print A.f # unbound method print A.f(o) print o.f # bound method print o.f() The binding is not done by the interpreter specifically, it isn't, like, oh, I'm asked for an object's attribute, it doesn't have one in its own dictionary but I found it in its class hierarchy and it's a method, so I have to feed it the instance first. No, it all works through the standard descriptor protocol, namely the `__get__` method. Note: so the simplified description of the attribute lookup "first in object's `__dict__`, then if not found -- in its class hierarchy", is a lie: it's another way around, it's searched in the class hierarchy first, then, if it's not a descriptor or a non-data descriptor (doesn't define `__set__` or `__delete__`, function objects are non-data) then it's allowed to be overridden by an instance attribute. Note2: class objects _also_ define a custom `__getattr__` which which invokes the descriptor protocol on instance attributes (that's why `classmethod` can work, at all). So when you write `A.f` where `A` is a class, then: first `f` is searched in the metaclass and all its parents, then in the class and all its parents. Python object model is one of the hairiest things I've ever seen, which is all the more surprising given the apparent simplicity of the language.
If only right? I wish I could just sit down and code everything I've ever wanted.
Not a bad idea. Simple and to the point. How do you keep track where things need to be done? I.e function x in file y? (Probably just like that!)
I need to just sit down and learn more about vim. I generally use Kate, or nano for quick command line editing.
This might be the way to go. I just find it easier to make the notes in the code without making a context switch to another app/web browser.
Why have I never looked at pylint before? Something to learn this holiday weekend. Thanks!
At that point I'll probably just use Trello or BaseCamp or the like. But if I do write my own, this may be part of it.
I only had a true appreciation for those who contribute without compensation to OSS when after a few years I realized I enjoyed software development more before it was my job. ;) 
You're still using anonymous values. You've named the generators, but you haven't named any of the numeric/boolean expressions, eg: 2 not i%2 i**2 Name those and maybe you'll be more credible when you claim "forcing people to give things names is definitely a feature, not a bug". At the moment, you're just naming stuff when you happen to make the judgement call that it makes for more readable code, same as anyone else. That does not support making arbitrary restrictions on that certain kinds of values can only be expressed by first using a special-purpose construct to define them and bind them to a name.
Caching! Of *course*! Thanks a bunch. Some derping around and a ctrl-f5 and I got it working. Way cool.
&gt; How fast is SQLite for lots and lots of data (100,000+ rows)? As with any database management system - it depends on the algorithm (query) the data structure (model, partitioning, indexing), and the intelligence of the DBMS. But generally speaking SQLite can handle well-written, index-driven queries on 100,000 rows with no problem. I run complex analytical queries against large volumes (100 million rows) and while I can do that with DB2 on my laptop, i wouldn't bother doing that on SQLite (or MySQL either for that matter).
short answer: yes that's what with is for, to do that kind of cleanup automatically
With proper indexing sqlite will be very fast...(0.01-0.1s response time) And I do work regularly work with sqlite dbs of 10M+ size.
Yes, your implementation is better than the one the OP submitted. If you're looking for constructive feedback consider the cases where PersistentDict needs to be torn-down, also consider thread-safety.
It's not awful, it just strikes me as beginner work or somebody who just moved to Python. All these "it's shit" comments are actually kind of disheartening considering the OP is the author of the library. Can we as a community be a little more accepting of people who go out on a limb and submit their open-source libraries?
You can't deny my feeeelings! *dramatic arm movements*
Awesome!
In Python it's extremely rare to need to deal with such low-level primitives. What are you writing? If you're doing concurrent IO, you may not even need threads, and can use an event loop such as [Twisted](http://twistedmatrix.com/). If you can't avoid using threads (and you should if you can, because they will make your program slower and harder to understand or debug), then use threadsafe queues (`Queue.Queue` in the Python standard library) to transfer objects between threads.
Here's the documentation on `with`: http://docs.python.org/library/stdtypes.html#typecontextmanager It's designed for this sort of convenient setup/cleanup.
It's disappointing to see several "It sucks" posts that don't justify their claim with constructive criticism. I'll list here the specific objections I have. * This module may duplicate something that is in the standard library. I'll leave the details to those more familiar with the standard alternatives than I am. * The operations are defined as module-level functions that use global variables. This is a classic example of code that can be better implemented using a class. Functions and globals should be refactored into methods and instance data. This gives you the ability to use more than one database in the same program. * The load function should not catch IOException, because it is not good to fail silently. In general, the user of the library should get to decide what to do when an error occurs. * Each function that mutates the database reopens the file without closing it. I think this would lead to leaking open file descriptors over time, until the OS refuses to let you open another file. I don't know what the proper way is to sync access to a common file in the case that you have multiple processes. But this way is bad even for a single process. * Functions like `append` are defined that differ from the way they are used in the standard library. No one expects to call `append` with two arguments. It would be better to create some kind of intermediate object with an append method that takes a single argument (effectively Currying the function). * Functions like `set` and `get` should be replaced with `__setitem__` and `__getitem__` so that they can be used like dictionaries. Similarly for `llen`. Check out the source code for some custom collections to see what kinds of special methods you can use for operator overloading. In general, your abstract datatype should behave as much like a standard library abstract datatype as possible. * Creating separate functions for dealing with different kinds of value data (lists, etc.) is a bit sketchy. It likely introduces more work than it saves. A more general framework would be to store arbitrary data without assuming that it is a list or some other structure. * FlushDB is a misnomer. "Flush" normally means to bring the backend file up-to-date with respect to the in-memory data, not to clear the database of all contents. Hope this helps.
To expand on frymaster's short answer, with is very similar to the try/finally block. Essentially, any object in python can define \_\_enter\_\_ and \_\_exit\_\_ methods. If they do, they can be used as the 'target' of a with statement. The \_\_enter\_\_ function will run when entering the with block, and the \_\_exit\_\_ function will run when leaving (it will always run, much like a finally clause). In the case of a lock object, it'll act as you expect: the \_\_enter\_\_ waits on getting the lock, and \_\_exit\_\_ will release it.
Thank you for your feedback. Could you please give me another hint about what do you mean by "torn-down" (I cannot connect this to anything in my experience with python). What should happen in a case where the dict needs to be torn down. As for the thread-safety, could you give me a hint about what would you predict happen with the current implementation or an idea about how to approach this. Thank you again. 
Bottle.py is awesome. A few weeks ago I was thinking about writing up an article on making simple APIs with Bottle; if you're interested please encourage me to do so.
&gt; Is there a pypy time? - if you can feel it (?) then there is Former #pypy irc topic.
aaww... how cute. If you ever need something more robust, written in Python -&gt; [ZODB](http://www.zodb.org/) **enterprise ready**
I'm a PHP guy who has recently been writing in Python. The most difficult task in switching over was figuring out how to create the development environment that suited my needs (keeping up with new releases without impeding system installed versions, virtual environments, git integration, etc..). I took the opportunity to build an image 'unshredder' script in Python and it was - as herminator put it - a breath of fresh air. Installing modules and creating environments for testing purposes using different versions of python is a cinch. As far as the language itself goes, it just feels natural when you're writing it. The only thing you'll have to get used to is remembering not to use curly braces everywhere. As a guy who was in a similar situation as yourself, I recommend it highly!
I would like to formally thank the OP. Because your courage to post this thread, I became inspired to implement "a simple and extremely lightweight key-value database for Python" myself. I called it [pdicts](http://pypi.python.org/pypi/pdicts/0.1) because I plan on adding some more classes. Right now it only has a simple dictionary-like object that saves everything in a sqlite3 database and has an in-memory buffer for quick read access. In the process I learned how to work with github and how to publish in pypi. It is my first Open Source project that works and is properly published. On a side note, it completely changed my day. I was happy for most of the afternoon from this small accomplishment. Thank you again. 
Do whatever you want.
Yeah, it's easy enough to mention any related line numbers in your todo list. I'm a bit of a minimalist, and I don't use a full-blown GUI IDE with built-in note-taking and such... just Vim. Although I should note that there are perfectly capable [note-taking scripts](http://peterodding.com/code/vim/notes/) available for Vim.
You can do whatever you want, but keep in mind those standards are there for a reason. Pretend in 6 months you've stopped working on your module and something needs fixing. Would you rather try to figure out what the variable cerberus really does, or would you rather just name it appropriately to start, and then you can get straight to the fixing of the bug.
Yes that's the idea. Well the "real" idea is to generate typical edge cases, so not *entirely* random. Not sure how well-implemented this version is, but the interface looks decent. There are no examples for using this with custom classes; that would be a nice addition.
The output looks very similar; I wonder if one was inspired by the other.
I've written a curses emulator built on top of Pygame which will work on all platforms (and support unicode): [Pygcurse](http://inventwithpython.com/pygcurse/)
When the eccentric name has marketing value. I would say there isn't much to be gained with funky functions and variables. The best package/program names are catchy but with tongue-in-cheek semantic value. 
But, names with little puns are awesome and great in a local scope. For example, eyeD instead of id
You don't need a framework for this. Can IIS just run a script as a CGI? googling for "IIS CGI" seems to indicate this is trivial. The only thing you need to do is print "Content-Type: text/plain\n" before you output anything else. 
Cool, that's what I meant by "past CPython" btw.
not sure how to take that entirely.... but no problem i guess ;)
For my current uses I wanted the smallest, simplest option and I liked this one when I tried it. I didn't need the extra features that other frameworks had. Also, it's a newer project written for Django 1.3 and the way it builds a self-documenting browseable version of an API from docstrings was really nice.
!~!DO IT!~! Seriously, though, i feel the void surrounding bottle.py has to be filled. Should you write an article, i'll gladly leak it through my channels. 
thank you for your feedback. very helpful!
This appears to be so much better than the standard ncurses. I often have to write a cheap wrapper of my own construction around ncurses just to neaten up my own code, but this should work so much better.
someone forked it and made it or started to make it way better https://github.com/medecau/pickledb/blob/master/pickledb.py
Be clever, but not too clever. It's easy for someone to simultaneously appreciate your wit and resent your lack of restraint.
Blessings actually started from such a wrapper of my own, built to help with [nose-progressive](http://pypi.python.org/pypi/nose-progressive/). Here are a couple messy comparisons with other libs: * Larger than termcolor (153 non-comment lines vs. 62) but provides both high- and low-level interfaces. That is, you can work with individual escape codes, or you can use the automatic wrappers. Blessings is terser to use. It also does more: cursor movement, pipe savvy, and access to *all* terminal capabilities should you need them. And you get access to the "bright" renditions of all the colors. And it works for non-ANSI color terminals. * Smaller than couleur. Does colors pretty much like it, except that Blessings also gives you access to the "bright" color palette. Omits couleur's indentation management and its 2 custom template languages (the one with the "and" and the "|" characters and the one that does implicit formatting of streams). I figured Python already has enough templating syntaxes built in (3 at last count), and I like a little bit of explicitness.
I've always liked [Monocle](https://github.com/saucelabs/monocle/blob/master/examples/client_server.py) (check the decorator)
Sounded interesting until I got to the bottom and saw it is GPL. Lame.
Was thinking about changing it. BSD?
Anything non-viral, BSD, MIT, PSF, etc. Personally all my new projects are under Apache. My employer has a nice summary as to why http://www.opscode.com/blog/2009/08/11/why-we-chose-the-apache-license/
If its not Python, how come the Python interpreter runs it perfectly fine and produces the intended result? Surely it would raise a syntax or NotImplemented error if this wasn't Python? I think what you mean to say is "I'm going to poo-poo this solution because its not the style of programming I prefer, as I'm hiding in my mother's basement behind the anonymity of the internet and have no fear of reprisals for being a giant ass!" The only reason I can see that you don't understand single digit multiplication by 11 produces a double-digit palindrome number is that you suck at maths. This is primary school stuff. People who suck at maths have no business criticising other programmer's work. 
pickle a dict and be done with it?
Opened https://github.com/erikrose/blessings/issues/13: “Switch to a more permissive license. There's no point requiring GPL-itude for the sake of a lightweight terminal library, and I want maximal uptake. Apache 2 looks like a decent choice—I like its patent language—except that the FSF deems it incompatible with GPLs 1 and 2. (3 is fine.) Perhaps BSD or MIT would minimize barriers to adoption.”
Yes, I know - my point was meant to be that his approach won't work, and that there's a package that already does the right thing.
I wrote a similar library called terminate about 5 years ago, for some CS labs. It eventually shared it with another project called fabulous, but I think that was abandoned. It would be nice if these projects could get merged. By the way, your API seems pretty nice and easy to use; however, you won't be able to achieve support on MS Windows unless you change it (or perform super evil magic).
why the bleep would you drop caches?
my "approach" is a joke because of the name pickleDB... not because i wanted to use json and pickle mashed together.....
Thanks! Glad you like the API. If you still have fabulous around, I'll certainly have a look at it. For Windows support, I'd recommend using Blessings in concert with colorama, a little shim that translates ANSI codes to Windows console calls: http://pypi.python.org/pypi/colorama/0.2.4. Supporting Windows internally would probably double the size of the library. :-) (Though I'm always interested in patches that prove me wrong.)
circuits.web is what your looking for its awesome
I had a look at fabulous—nice work! The blitting of images to the terminal is especially fun. My goal with blessings is to keep it small, learnable, and simple, so while I might someday add 256-color support (though I'm in no hurry to do so), I'll probably forgo tacking on bits of a logging library and image blitting (which could be done as a layer on top, distributed separately). Still, thanks for the pointer!
&gt;If PyPy made the mature decision to immediately abandon 2.x for 3.x, they could play a much larger role in the future of Python. PyPy is useless to me since I moved to Python3 over a year ago. If you made the mature decision and did not abandon an extremely stable and well-supported platform for a not-yet--well supported platform, then you would not now be suffering from the lack of 3rd party support. 
How about LGPL? It's for exactly this sort of situation. (Not that there's anything wrong with a permissive license).
i got tired of always having to pickle dicts so thats why this was created. pretty simple... some of these people are really taking this to the next level!
IIRC, Python3 had terrible io performance issues until 3.1.... And even now 3rd party support is, well, spotty. Overall, "wait and see" still seems the only sane solution for most people with real production code running on python. 
This looks good. I agree that curses isn't always what you'd want. Sometimes a "pseudo-GUI" terminal application is appropriate, but those times are not always.
just wondering how yours is better then mine if people critized mine for being "shelve", which to those of you who said "he must not have searched Google for shelve" i know shleve exists it doesn't work quite the same as pickledb actually.... anyways if i was critised for copying shelve then pdicts is is like the EXACT same thing. as in response to the shitty comment. please be more explanatory? saying shitty and professional doesn't really give me much to go on... and i know that there should be a class and the using the global vars was just away to get around this. but if that is the only reason you don't like it (which i doubt) please tell!! we want to get better not trash each other. Workaphobia gave great great great feedback. maybe a more constructive comment like that next time? thanks a bunch, cheers!
jediknight's implementation of a persistent dict was "better" in the sense that it was more idiomatic Python, but of course it was the same ideas as your code and the shelve module. His code implemented the points that Workaphobia pointed out. Like I said up above, don't let the elitism get to you. Normally /r/python is a kind community... I don't know what happened here. Certainly, writing naive code is something we've all done.
You really have to think about what might go wrong in the locked code and what it means if it does. I rarely bother to trap and unlock for my stuff. If something blows up that bad there is usually no way to save the behavour of the program in some meaningful way. Just blindly unlocking is sometimes the wrong thing to do.
thank you!
version 0.3 updated with alot of your guys improvements... again, any feedback? http://pypi.python.org/pypi/pickleDB
Depends on the crowd you're developing for. If if you're writing code for you and three of your Python hacker friends, then yeah, use whatever crazy naming convention you like so long as it's universally understood. If you're developing for the corporate world then use professional judgement.
except not lame, but otherwise you're right... I guess... or not
How did you come to choose PyGame over Pyglet?
I've thought about something like this but it leads me to think I need to be coding in a non-procedural language like Prolog so that test cases can be generated reasonably well.
Well, it's a void I'd be happy to fling a few words at. Maybe next week!
OK, good to know.
I think you're asking about thread mutexes, not specifically locks in general. Anyone care to point to a good reference on the lingo in this problem space?
I can't seem to figure out how to use it. I unzipped it on my Mac and not much happens when I open any of the files. 
I use SQLite as a key-value store and performance can be tuned to be practically as fast as the other build-in DBM-style data stores. There're lots of ressources, e.g. http://web.utk.edu/~jplyon/sqlite/SQLite_optimization_FAQ.html 
Not specific, but general: Keep coding, keep reading reddit (and stackoverflow, planet python and the python tutor and general list). This is one of my all time favorites: [Teach Yourself Programming in Ten Years](http://norvig.com/21-days.html) 
It's what I already knew.
That depends. If you're programming on a desert island, who cares? You can use CamelCase in Python, and underscore_style in Java, and the roof won't fall in. But if you work with other people, adhering to the group's coding style signifies your willingness to function as part of a team. This is especially important in commenting -- what's obvious to you may not be at all obvious to someone else. 
the main limitation of SQLite is concurrency. For desktop use, SQLite will beat all of the others in most if not all aspects.
I'd prefer BSD or LGPL, so that they're GPL compatible. It'd be a shame not to use a nice library out of "viral" concerns.
&gt; stop asking for permission
You could make a decorator for a function that requires a lock. Though the with statement seems more appropriate. Question for everyone: What would be the most efficient way of waiting on a lock without eating up CPU?
That's neat, I'm guess it doesn't work over SSH or listen to your terminal colours/fonts though?
I saw GPL and thought "good for the software ecosystem."
I made a mistake it shouldn't do xrange(1,10)*10 but just xrange(1,10). I was testing if that could be typed and forgot to remove. I'll edit the post to correct it Also, I didn't do a oneliner for the second one to improve readability as I stated in my previous post. You didn't understood me, iterating might not be as expensive, but then you have to check every number generated with string operators which probably is a lot more expensive, isn't it?. I, on the other hand, only generate palindromes and need to only check the solution to see if it's a palindrome. Of course a solution for every size of palindromes would be optimal, but he wasn't asking for that and I didn't try to come up with one. Finally, I wasn't giving a complete solution (hence the lack of function definitions, comments and such), but just a pointer on how to do it differently form what others said. If you really want, I can write you the full solution, although you can probably expand from what I wrote.
To see what happens when memory is tight or when the executable hasn't been run in a while. The results aren't unrealistic in my experience.
OK. Here goes the explanation: 1) I will generate 2 digit palindromes, and 3 digit palindromes. 2) I will add them. 3) I will check if the result is another palindrome and has 4 digits. To generate 2 digit palindromes (11, 22, 33...): I iterate from 1 to 9 and multiply the number by 11. To generate 3 digit palindromes (101, 111, 121, ..., 202, 212, ..., 999): I generate numbers that have the 1st and last digit equal, and iterate for the middle digit # (b*100 + d*10 + b) # Once added both palindromes, I convert the result to a string # if the string has more than 3 chars AND it's a plaindrome: if len(rs) &gt; 3: if rs[0] == rs[3] and rs[1] == rs[2] # It means that I found the solution Finally, some heuristics: # Since I know the result is a 4-digit palindrome, it means the 3-digit palindrome should be 'big' enough so that added to a 2-digit palindrome, would reach the 1000 range. # The biggest 2-digit palindrome is 99, so the 3-digit-palindrome should at least be 909. I hope it helps. 
GPL is poison for libraries these days, does nothing but segregate the world into GPL and "Everyone Else" factions.
The browseable, self-documenting APIs of DRF are a real plus in my experience.
That was a fast solution. The proper one, IMHO, would be to have 2 and 3-digit palindrome generators and a function to check if a new number is a palindrome. E.g.: def generate_2_palindrome(): for i in range(1,10): yield i*11 def generate_3_palindrome(): for b in range(9, 10): for d in range(10): yield b*100 + d*10 + b def is_4_palindrome(num): rs = str(num) if len(rs) == 4: if rs[0] == rs[3] and rs[1] == rs[2]: return True return False def main(): for p1 in generate_2_palindrome(): for p2 in generate_3_palindrome(): p3 = p1 + p2 if is_4_palindrome(p3): print 'Solution:', p1, p2, p3 break 
:P
I think it's okay.
But have a reason.
I don't think any of these methods would eat up CPU.
Yeah, especially more subtly misspelled names, in a way of a pun. Fuck you.
I think this trick should work: if len(name) &gt; 15: line += next(file) This just gets the next line and adds it on to the current one. You may need to play around with adding .rstrip() to remove newlines.
You can create an iterator yourself then consume the next line as necessary. fileiter = iter(FILE) for line in fileiter: if len(line) &gt; 15: line = line + next(fileiter) # Now you have 1 or 2 lines to clean up Use `fileiter.next()` for Python &lt; 2.6.
All I can say is, "How on earth had I never run across the 'next' command?" Works, and thank you very kindly.
I see that this would work as well. Again, thank you.
Waiting for a lock does not eat CPU time, it blocks. Your process/thready basically gives up control to another CPU thread until next round, where it checks again. The underlying lock implementation usually takes advantage of locking primitives available in a particular OS's kernel.
A file object is its own iterator, so `iter(FILE)` just returns a reference to `FILE`.
It's not stopping you using it in a business environment: it's stopping you taking libraries written by people who agree with the message of the GPL, and producing software that does not agree with the GPL. Saying it's "poison" is utter hyperbole, and is merely masking your (rather egotistical) belief that authors should pick licenses for your business use rather than under their own moral code. How about I say that charging for development environments is "poison" because it segregates the world into rich and poor? I'm not silly enough to say this though, because I recognise that if someone wants to write something and charge for it, that's fine, and I don't have to buy it. I'll go and find a free alternative. Here's what you should do in future: Come across a GPL library you want to use -&gt; Find a non-GPL alternative In this case you seem to have lucked-out, because the author is considering switching license in your favour.
You have already run across it, you just don't know it yet: the `for ... in` construct works on any iterable object. To be iterable, that just means that you have an `__iter__()` method which that returns an iterator, and an iterator is simply something that has a `next()` method which returns values until there are no more, and then raises a `StopIteration` exception. Since the file object itself supports this `next()` method, it can act as its own iterator, i.e. `iter(file) = file`, which means that `for line in file` is syntactic sugar for writing a loop that repeatedly does `line = file.next()` until a `StopIteration` exception. 
You are looking for the actual 'n' string in your getTotal function. The correct line would be: n = form.getfirst(n,'empty') # notice the missing quotes Also, judging from this snippet of code, I think you do things way badly. Using plain cgi is cumbersome especially for a beginner. Python has many lightweight frameworks, I didn't do the research but I think you can find one that will work with 2.5 And one other thing: querying the state of the current player from the player is just a bad idea. what stops me from sending 99999 as my health? And this is just when I want to break the game mechanics, if I want to break your code then I could send any non-number string to the getTotal function and the int(n) code will just throw an exception. 
Instead of using the literal `'empty'` as a default value, it's more Pythonic to use `None`. If I understand your problem correctly, you want the function to take in the name of the attribute to retrieve. The first problem is that you shouldn't have quotes around `n` in the first argument to `getfirst`. Second, if you assign to variable `n` then this value replaces the value that was passed in (`'yourHealth'`), and I don't think you want this. Third, is `500` a suitable default value for all attributes, or only health? If it varies, you probably don't want to hardcode an integer there. Finally, you want to return the value you're retrieving or else your function doesn't do anything. One possible rewriting: def getTotal(attr, defaultval): n = form.getfirst(attr, None) n = cgi.escape(n) if n == None: n = defaultval else: n = int(n) return n x = getTotal('yourHealth', 500) print(x)
This isn't about programming style, we'll be following PEP8 fairly closely. I was just wondering about... Well, Twisted uses a reactor loop, and keeps going on about factories. I'm itching to name something a "Hellion". That sort of little thing.
You don't need quotes around n in the second line. When you call getTotal('yourHealth'), you're already passing a string. Calling form.getfirst with 'n' makes the first argument the string 'n' and not 'yourHealth'. n = for.getfirst(n, 'empty') should work.
What makes python "fun" in my mind is that it's essentially pseudo-code. So the written code should tell you, the programmer, as well as anyone looking at the code afterwards, exactly what the code does. I love, love reading through Python code. That's not really true for other languages (well, *maybe* strongly functional ones like Haskell or SML). I think you can use odd names so long as they make sense in the context of the code. For example, say you have a class that grabs complex objects, takes them apart, extracts key pieces of data, and returns the complex object with the data removed. I don't see how you could name that class anything *other* than Otter. Sometimes a metaphor is the best possible way to name a class or function. 
&gt; It was originally hosted at DiveIntoPython.org, but the author has pulled down all copies. It is being mirrored here. bit of misleading title but good service anyway.
Groovy! Thanks for giving me the lowdown on exactly how this works. It's always nice to know how code is actually working, and not just what the outcome is. The better my understanding, the less silly questions like this I should have in the future.
Ok so that code worked although I did have to put single quotes around 'None'. So I think I understand what's going on here. Previously I was using n in too many places, so the variable had no idea what I wanted it to be? Does that sound correct? And with return n what does that do exactly? Thank you so much for your help. Now I just need to understand exactly where I went wrong. Edit: Also I have no idea how to include code within a sentence like you did.
You're saying that someone new to writing code is bad at writing that code? I've never heard of such a thing. I completely understand that players are capable of changing the numbers in a GET request but a commercially valid game isn't something I was really shooting for in a project I was using to LEARN Python. But thanks anyway.
You can even get django running this way if you must. We have that in prod for an albeit departmental app but in prod none the less.
No. He left. End of story.
Just to add: for new code, next(file) is preferred to file.next(). The former also works without changes in Python 3. If you need to work with older versions of Python, you'll need file.next().
Hi, on your way implementing python 3 would it be possible to preserve the old print statement so we can continue using "print x" in quick and dirty scripts? I think this can be done without breaking python 3 codes in a way similar to... if a_line_of_code.lstrip().startswith('print '): re.sub('print (.*)', 'print (\1)', that_line) 
Is there a function I call to wait for a lock?
&gt; It is also availablelanguages" title="Dive Into Python in your language"&gt;multiple languages&lt;/a&gt; Woah, how did that happen?
To `write like this`, put a backtick mark on either side of the text. (The backtick is the key above Tab on most keyboards.) I think you had to put quotes around `None` because `cgi.escape` probably requires a string as input. Of course, escaping is only needed if the input is actually present and is a string. So I'll amend my recommendation to n = form.getfirst(attr, None) if n == None: n = defaultval else: n = cgi.escape(n) n = int(n) return n That is, if the attribute is not present, don't escape anything, just use the default value. The main problem in your original code was that you had quotes around `n` in the call to `form.getfirst`, so it would try to retrieve a field named `'n'` rather than a field named with whatever string was in the variable `n`. I changed some uses of `n` into the new variable `attr` because conceptually `n` and `attr` are very different. `attr` is the name of an attribute that `getfirst` should lookup, and `n` is the value returned by `getfirst`. While you could mix them, it's not good form. From the moment the first line is run, the attribute name in `n` would be overwritten with the value, so you wouldn't have the name later on in the function if you wanted it. Returning is how you send data from a function back to the line of code that called it. I'd suggest a tutorial on function calls for more details, it's too much to go into right now.
I think you're greatest confusion is about how function arguments work in python. Not sure what language you do have experience with? In any case, the argument `n` acts like a local variable *within* the function. So you can assign it a new value, as you do, but that won't change the value of the argument that was passed into the call. In fact in your case it's not very obvious how that could ever work. Returning values back to the caller is always done using 'return'. Note however that quite often in python variables refer to objects that can change (as opposed to simply containing a value). Like in the following example: def add_salt(x): x.append('salt') y=['pepper'] add_salt(y) print y In this example, in the first line a set is created and `y` refers to it. In the second line `y` is passed into the function, and after the call `y` is still referring to that same set, only the set has been changed within the function. 
Hello, thank you very much for your crits, and for buying the zine. * updated the code listing fonts. Added some new images for one interview. Tweaked some spacing. * I went through each one, and couldn't find the missing code. Which article is it? * The PDF has been improved a lot. "Test Document" on each page is gone. The Table Of Contents is there now. There is better spacing between articles now, and the external links work. The front cover is there. * good point. That has been removed. thanks again.
thanks!
Actually, using Colorama makes the most sense. There might be some limitations to that approach, but it at least makes your library much more testable. Great job :-)
I'd still go through the iter() call to make sure your piece of code also works for other file-like objects that might not be their own iterators. Better to stick to the protocol, I think.
I did something similar on a submarine I built last year. The server used a simple gstreamer command for the video, but the client was built with python and GTK, and the rest of the sensors were managed with python scripts. Here's the relevant code for the video stream: http://pastebin.com/apN101tX And, I hope you don't mind I if I show off my little sub: http://dougroyal.com/next-challenge-a-positronic-brain/
But what if you have no control over the environments that your code will be run on? What if newjson comes out, and your customer read on a blog post that it's 10^300 times faster than cjson! Now, in your code, you've tested against json and cjson. You know they work. However, your customer foolishly reconfigures python to use newjson, but it fails! So he files a support ticket. And the snowball begins. I think it's perfectly reasonable for the programmer to have strict controls in the code as to what specific modules that their software uses. 
`lock.acquire()` Then do a `lock.release()` when you're done
Vote up for this is exactly what I have been wishing!
When are you going to "insert a blog title" or did you leave it like that on purpose?
Ha, great name. EDIT: ok, I got a chance to take a look and see that there's a heavy CMS focus, and am am wondering if this is a good fit for a need that I have: to provide CRUD on a large number of configuration tables in a database: * 10 different configuration tables * Each may have 1-3 referential integrity constraints, and a few check constraints * Use of the interface is just occasional - so usability &amp; consistency with the rest of my app isn't critical * Authentication ideally via ldap groups at the table level * Database is DB2, model is complete. * SQLAlchemy ORM features aren't necessary, would prefer to just use the abstraction layer. Any thoughts?
If my customer changes the code, the customer is responsible for bugs introduced by code changes. How is that any different from what we have now?
Don't get me wrong. Maybe my wording should have been better (not native english speaker, sorry) I did not meant to insult you. My post was meant to point out the weaknesses of your implementation that you may not have think about. I think it is a good way to learn programming by creating code then have someone who can tell you how bad it is and learn from it. No one writes great code at first. Actually, most of us never will. 
This is just another mirror. There were mirrors up the day Mark Pilgrim took the original site down.
it's for adding 0... duh.
But in this case, it is safe to assume that anxst was working on an actual file.
+1 for MIT (or revised BSD).
For the curious: [fabulous at PyPI](http://pypi.python.org/pypi/fabulous/).
No. It's actually ambiguous to have both the print function and statement.
So if I: i = 0 for n in xrange(10): i += 1 next(n) I'd end up with an i of 5?
Cool. I'm sorry for the confusion. I understand users can bypass a form, even when hidden. Is there a way to pass variables between page loads without using a form?
No, but a good solution to this problem is to store your variables on the server in a permanent data storage (typically a database) and give the user some kind of token/session id to decide which values belong to which user. And don't forget, users can bypass anything, not just a form. Double-check every value that comes from the client side. 
No, because `n` is not the iterator. The iterator is whatever is returned by `xrange(10).__iter__()` which is what `for` evaluates before starting the loop. When you write it as you have, that value is anonymous so there is no way to call `next()` on it, but since an iterator has an `__iter__()` method that returns itself, you could write this as: i = 0 foo = iter(xrange(10)) for n in foo: i += 1 next(foo) And you'd end up with `i` being equal to 5. 
Downvoting. Sorry.
Kcool, one last thing, why is it foo = iter(herpnsherpn) And not foo = herpnsherpn ? (Where herpnsherpn is any iterable).
So the lock.aquire() will block until one is available? I guess if I'm using multiprocessing, then process blocking wont affect me.
The other fun thing is that, because Blessings doesn't really keep any internal state, you can use it for its conveniences and intersperse curses calls if you want to do windowing or anything.
Yes, it will block that particular thread. If you're doing multiprocessing, then yes, that process will block. Note, in the [multiprocessing docs:](http://docs.python.org/library/multiprocessing.html#synchronization-between-processes) &gt;multiprocessing contains equivalents of all the synchronization primitives from threading. So indead of instancing a `threading.lock()`, you would instance `multiprocessing.lock()`, as they're cross-process aware, instead of cross-thread.
I see - I think I'll get around to a DB once I learn more of the core concepts - I'm coming from PHP so things are a bit more strict. I have to wait on upgrading my server through my host until after the holiday. Am I able to install a framework just by uploading it to an FTP and connecting it to MYSQL? I know a lot of python is based around PostgreSQL but I have to work with what I have for now, sadly.
Because we want access to the iterator, not the iterable that produced it. `herpnsherpn` has no `next()` method, so if you did as you wrote you'd get an error on the `next(foo)` line (unless it happened to be a `file` object instead of a general iterable like `xrange()`.) Iterable means that something is capable of giving you an iterator. A single iterable object can have any number of simultaneously active iterators. In other words, `xrange(10)` is an iterable object that is capable of generating any number of iterators that each independently count from 0 to 9. Each time you call `iter(xrange(10))` you get a new one. And that is what `for A in B` does, it calls `iter(B)` to create a new iterator, and then uses that value to iterate. So to advance that iterator from within the loop, we need to somehow save that value of `iter(B)` so that we have access to it, which is why we create the iterator and hand it to the `for` instead of letting it do it. (It still tries to call `iter(B)`, resulting in `iter(iter(B))` but as I mentioned already, an iterator has a "pass-thru" `__iter__()` so that this is the same value.) 
Awesome, got it, thanks man.
The most important vim command I ever learnt: :vsp
Broken &lt;a&gt; tag?
The mirror has been up for a while. Hey, eventually .org will expire and then someone can buy it out.
Ambiguous it is. I am aware. However, most of the time people don't insert spaces between function name and left parenthesis, so this substitution would seldom break python 3.x code. A command line switch like --strict could be added anyway in case. (Or just a command line switch to turn on this behavior..) On the other hand, being able to write 'print x' brings so much convenience to script writers who prints a lot (consider how often "echo" is used in shell scripts). So far print has been the only thing keeping me (and probably some library authors) from liking python 3.x. CPython made a not-so-considerate desision and they wouldn't admit it. There could have been a __builtin__.printf function with the print statement implemented atop, and everybody would be happy to upgrade. Now with two mutually exclusive "print"s, the lexer gets confused and decides to accept only one kind of them. (I am suggesting this behavior could be improved though.) The reason of my original post is I think it would be great to still be able to use "print x" in PyPy after it has moved to 3.x. That would be a big favor to python 2.x users. 
Not until Dec 2015, it looks like. Maybe by then we'll have transitioned to Python 3!
He's not changing the code now, he's changing the environment. To the developer, this might as well be the same thing, but to the customer, it's a world of difference. 
Ctrl+F. I know, I know, I'm terrible.
I find it hard to believe that the major obstacle to 3.x adoption is the print function. Python 3 had many other more difficult to adjust to changes.
Then I don't know what "the environment" means. I was talking about module loading being done in code.
Why is this? I never quite understood Python's mix and match of methods and functions for objects. I much, much prefer Python to Ruby, but at least Ruby is quite standardized on everything being a method, if I recall.
It's my most used facility suddently requiring 4 more hard-to-press keystrokes, and this added cost brings no profit at all. There are other difficult changes, but this one affects me most. Maybe me alone. 
I wonder where Dive Into Python *3* went...
Reactor and Factory are names of design patterns. The value comes from identifying architectural patterns in your code so that you can talk about and reason about your code at a higher level. Hellion isn't a design pattern and if you identified a design pattern, it wouldn't be helpful to name it that because it's not very descriptive. Project names, on the other hand, often don't have the option of being very descriptive due to collisions with similar projects. You couldn't exactly call Python "Programming Language". So rather than being descriptive, people select names pretty arbitrarily. If you can name something descriptively, you should. 
Oh, I agree. I don't see myself using python 3 until all the major libraries support it. My comment was just suggesting that there was no way for him to have predicted that python3 would catch on so slowly especially since it had been released for over 2 years. Python 3 is a better language, but the way they handled the migration is just terrible.
[http://www.diveintopython3.net/](http://www.diveintopython3.net/)
Could have at least pushed his sites elsewhere before he decided to become a monk.
Ah, so it has proper lexical scoping. I'm actually kind of fond of that, but I can definitely understand it being annoying if you're not used to it.
You could try this [MIT course](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/index.htm). The problem sets go beyond typical tutorial-style exercises. 
I'll check it out. Thanks!
Apparently the CMS focus only comes from the Ptah demo, not Ptah itself. in other words the demo is not meant to imply Ptah is a CMS, just "a tool to build a CMS".
I shall play with this. Good work, sir or ma'am.
Yeah, Python is pretty consistently inconsistent about what's a method and what's a function. ;-) The reason they switched to a function in Python 2.6+ is that the old `obj.next` method didn't have a way of doing a default value when the iterator is exhausted. That means in the new style you can write things like: line = next(FILE, None) if line is not None: ... It would be trickier to do that with the old method style. In general, the function system has the advantage over a plain method that it can be more flexible and have fallbacks that you can't do with just a method alone. So, `len`, for example, will go through a bunch of fallback code when it turns out that something doesn't have a `__len__` method.
2to3 would do *that part* for you.
I quoted the source.
awesome site. very cool.
My code wasn't optimized for speed. It was a simple implementation for the problem exposed. That said, I agree with you on readability before speed for most cases. 
Create a function to search through a directory and its subdirectories, that returns a list of files with an extension the user specifies. I did this awhile back, and it was a good thinking exercise.
Why not just do console.log($('li &gt; a')); ?
Oh, drat.
I don't think my first post in this thread was even trying to be an optimization (but happened to reduce the number of operations from other solutions). It really was the first thing I thought, if you are not comfortable with it, I'm sorry. I do agree with your statement, but I don't think it applies here.
Go through [Learn Python The Hard Way](http://learnpythonthehardway.org/book/). Do all the extra credit too! I cannot stress enough the importance of "Don't Copy&amp;Paste". Typing all those exercises helps your fingers "know" python. Read the [Good to Great](http://jessenoller.com/good-to-great-python-reads/) collection. There is no shortcut. You just need more immersion. As for the educational project, use the Sivers method: &gt; Finish this sentence: “In a perfect world…” - @sivers If you do this on a piece of paper, after a few lines you will stumble on something interesting to implement in python for yourself. 
This site looks good, but it isn't doing much. It doesn't do grid comparisons like django-packages (at the moment anyway), and doesn't have the vcs-stats either. What will it be used for?
Tag comments with TODO (missing features) or XXX (hacks, fragile stuff), and occasionally run git grep -E 'TODO|XXX' Maybe flesh out things that need design in a plain text TODO file next to the README.
yep, it doesn't even show a description. no metadata at all.
What is it supposed to be? * Download counts: See PyPI. OK, these are summed over all versions of a package. No obvious option to sort by downloads, or to get data like downloads per day. * Comments: *Another* venue that package maintainers might need to patrol for complaints, questions and bug reports. * 'Trash reports': After clicking a dozen or so packages, this seems to be a service to swear at you if any version has a description less than 40 characters long. Possibly a useful thing to check, but it's not immediately obvious what it is (it just says "NO" for most packages, meaning they're fine), and would work without the swearing. * Favouriting: Typing in a package name appears to raise it to the top of the list. I can't see any '19 people like xyz' counter. I can see the desire for a site building on PyPI to add social features like ratings and discussion. And I realise this is an alpha. But I don't see who it's intended for. For potential users, it offers no description or classification of any package - web frameworks are mixed in there with scientific libraries - and no clear indicator of how any package compares to its alternatives. And it doesn't look very useful to developers, besides possibly checking the 'trash report'. What I think could be useful is something building on the trove classifiers in PyPI. E.g. if a web developer wants to try using Python, find the 5 most popular web frameworks and show a brief crowd-sourced description of each, explaining how it differs from the alternatives.
Thanks for the update. Have people decided yet which applications are going to be ported for 12.04? I'm an Ubuntu user with some experience of porting code (albeit not GUI apps) to Python 3, and I'd be interested in helping out.
TL;DR : * for next version (LTS) 2.6 dropped, support for 2.7 and 3.2. * 2.7 wasn't in last LTS so PPA with 2.7 to ease transition. * Move your code to python 3, most projects are starting to do it (with Fedora and Ubuntu help) * 14.04 will probably not have python 2.7 by default.
That can't possibly be made accurate. You are summing up two values that go from 0 to 100 on a scale of 0 to 100. This is will return off-scale values if the sum of the values is larger than 100. I'm having problems understanding the usefulness of mixing the stats of two different things. Anyway, here we go. * Sum the values and divide by 2. i.e: RAM is 80% and PROC is at 10% STAT will show 45% (if you add more datapoints the sum is divided by the number of datapoints.) This will give you a false sense of availability. If you are looking for a machine that is available for a task that consumes lots of CPU you may set it on a machine with STAT 48% but CPU nearly at 100%. * You could compare the stats of both RAM and PROC and show the larger. i.e: RAM is 50% and PROC is 80% so the STAT will show 80%; RAM is 40% and the PROC is at 5% STAT will show 40%. This is pessimistic has you may have machines with lot's of CPU available but not so much RAM and the STAT doesn't tell you what's available. * You could have it spit out multiple values CPU, MEM, DISK, BDW and leave the analysis to the receiving end.
The question was what was the equivalent of `.do()`, i.e. something that maps a set of values to another function. 
I agree. When I implemented similar thing (limited only to strings, though), I called it "unformat".
It's probably worth mentioning Python distributions like EPD, ActivePython or Python(x,y). They all now have free versions (Python(x,y) is completely free), and could save you a lot of time getting stuff set up.
Slowly but surely...
Maybe we're not on the same page then. You were describing a situation in which doing this: import json Could import one of any number of modules based on your environment's configuration (environment being the system that the software will be running on) If I misunderstood you, then I humbly apologize.
I've not yet looked through the code, but your example didn't mention (unless I missed it...) redrawing portions of the screen. Is this possible? I ask because: 1. I remember doing this ages ago with ncurses 2. I'd like to write a client for a bomberman game I'm working on that will work in the terminal, so redrawing is critical to me! It seems like the example of nose-progressive probably **does** do screen redrawing, so I guess I'm really looking for confirmation before considering your library :)
As nicofff and medecau said, it's likely that what you want is not actually an optimal solution for a problem that you are having. I'm guessing that nicofff has identified what you would use this python script for - OP, could you please confirm? If you do want to do something like this in python, instead of using a tool like nagios, then I think that you do *not* want to combine the numbers for servers. Let's say you have 3 servers, and you get a display like so: S1: 10 S2: 17 S3: 55 S4: 22 Those numbers are devoid of meaning. But if you have this: S1: Load: 40%. CPU: 75%. Disk: 48% S2: Load: 92%. CPU: 60%. Disk: 10% S3: Load: 80%. CPU: 90%. Disk: 30% S4: Load: 05%. CPU: 08%. Disk: 95% Then, at a glance, you have a much more detailed view about what's going on; it's extensible, you don't have to think of an algorithm for combining things that don't combine well, and you can head to the data fortress with extra disks, extra bandwidth, bigger fans, as needed. It will also let you see when crazy shit is happening that doesn't make sense like: S5: Load:99%. CPU: 01%. Disk: 00% I'd imagine that if you have an alogrithm converting Server 5's numbers to some "master value of okayness" then it will look like it's moderately okay, but there is clearly something *really weird* happening there.
easiest way if you are interested in helping is probably to contact one of the ubuntu python team https://launchpad.net/~pythoneers or https://launchpad.net/~pythonistas
some recent updates from a key Jython dev here: http://fwierzbicki.blogspot.com/2011/11/contributing-to-jython.html
An alternative approach would be to add a JVM backend to PyPy. I'm far from well informed about this subject, would a specialist care to comment?
I was thinking that for a first project It would be good to organize it like this. Feed the program a folder that is essentially an album. From here I would be able to rename the Album, and artist meta data. I think this should be sufficient for reorganizing most the data. I don't really know how I would reorganize my entire collection so it may be easier and more effective to organize per album.
That's not fun. [Internet access is a human right.](http://www.wired.com/threatlevel/2011/06/internet-a-human-right/)
changing the path and installing pip is one thing. getting a compiler setup and wired in so that you can do things like pip install PyCrypto on windows is another bitch all together.
On Windows you can do this with the CoreTemp shared memory DLL. With Linux: [Piping this](http://www.cyberciti.biz/tips/how-do-i-find-out-linux-cpu-utilization.html) might be really helpful. As other people have said, this will not be an accurate measure at all. I speak from experience when I put the CoreTemp shared memory DLL into a while loop, the very act of reading the temperature increased the temperature of the CPU.
Might I suggest teaching her how to login to the router over HTTP? I guess you could make a GUI front end to the router's http service if you really wanted to.
 import glob import os def chomp(str_cwd, str_dirname, dummy_fname, int_pathlen, list_files): os.chdir(str_dirname) _str_dirname = str_dirname[int_pathlen:] for filetype in ["*.jpg", "*.arses"]: for filename in glob.glob(filetype): list_files.append(_str_dirname + os.path.sep + filename) list_files = [] str_dir = raw_input("SADHIFASIDHIS: ") os.path.walk(str_dir, chomp, None, len(str_dir), list_files) print(list_files) Glob and os make that way too easy.
Go for one of the ideas way beyond you. How are you gonna grow without challenge? Split one of them up into very small pieces, and do one piece at a time. If that still scares you, play around with pretty much everything to do with all the data types. Lists, strings, dictionaries, numbers. Get a real feel for the language.
Thank you, that is all I needed to know.
* 14.04 will *potentially* not have python 2.7 by default. Two years is not a long time to ensure that all important python programs are ported to python3. I think 2.7 has some life in it yet.
What is meant by not by default is that it won't be on the CD (default installation) it will probably be moved to universe and still installable (and installed automatically for the program that needs it) so it's just the program installed by default with the distrib that won't need it, in this regard I find 2014 a long time.
2.7 should be kept forever. What will you do if you need a program that depends on Python 2? There are software packages and libraries that have been well tested and validated. Why risk introducing new bugs by migrating them? That's why [LAPACK](http://www.netlib.org/lapack/) is still in Fortran 77 and there are no plans to migrate it to anything newer. There's no reason to throw away thirty years of combined experience just to make it more "modern". 
$40 for a 77 page ebook, no thanks. 
Ironic that he closes with 'pesky UnicodeErrors' as I've just ported one of my tools from Python3 to Python2 because you can't do: with open('badlyformattedfile','r') as f: for line in f: dosomething(line) in Python 3.2.2 if badlyformattedfile contains single-byte unicode charaters beyond 0x7F not escaped with the ampersand method as specified in the standard. The "for line in f" blows up with UnicodeError and there's nothing you can do about it (except re-write massive chunks of code to deal with 'bytes' rather than 'str' and open() in binary mode) The nice thing was all I had to do was `from __future__ import print_function` and change class SomeClass(metaclass=ABCMeta): to class SomeClass(object): __metaclass__ = ABCMeta As pretty much everything useful has been backported to Python 2.7.2, screw Python 3 and the foreign-speaking horse it rode in on. 
No, there are a lot of ways of dealing with it. The most obvious is bytes, but you can also add an `errors=` argument to tell it to ignore bad codes or you can use an encoding besides UTF-8 which doesn't consider an values to be out of range by adding an `encoding=` argument. See `help(open)`.
Yeah, but parents take away human rights all the time.
The kid's mum isn't the government.
2.7 will definitely* still be available for ages to come. This is about what's in the default install. *It's not me making the decision, but I can't imagine they would get rid of it.
Not being the government isn't the issue - everyone should respect human rights, not just the government. However, it's generally accepted that certain rights (like the right to free movement) can be restricted for children. Whether that's morally justified, or a pragmatic compromise, I'm not sure, but I think few people would criticise a parent for temporarily disconnecting their child to get them to do chores.
There was a mostly working implementation at one point, but as far as I know it isn't maintained. The point of Jython is for Java / JVM integration, and once you have a sufficiently working JVM backend you have the integration to work on too of course. (Plus having the JIT able to generate JVM bytecode that Hotspot can JIT and can be garbage collected. Possibly easier in *very* recent versions of the JVM with InvokeDynamic support.) I'm not sure that maintaining the JVM backend, integration and JIT support is actually any easier than maintaining Jython - which has the great advantage of already existing and working...
It's probably worth mentioning [PEP 397 Python launcher for Windows](http://www.python.org/dev/peps/pep-0397/) It could save some time especially for multiple version python's installation.
Yes there is something you can do about it. You can specify the goddamn encoding when you open the goddamn file in text mode.
PHP is PHP, and Python is Python. I think they're better at different things, to be honest. If you have time, or wanna have fun, dive into Python, by all means. If you don't, I don't think learning it would improve your general skills, or employability, or anything.
wat? why not just consider two numbers? You may find this useful http://www.pixelbeat.org/scripts/ps_mem.py 
There's no encoding for "badly formatted utf-8" According to the specification, utf8 using single-byte encoding can only store entities up until 0x7F. When the file contains, e.g. 0x99 - its badly formatted. (to be more specific about this, it's an ELFF log file from a proxy server and a User-Agent string contains the trademark symbol encoded directly as 0x99 instead of `&amp;trade;` - the correct encoding in order to use 0x99 would be two-byte representation of everything with 0xc20x99 for the trademark symbol) Edit: formatting
I think by default it'll be good to just have 3.x. If people need 2.7 they can just do a sudo apt-get to grab it. Ubuntu is helping to push python 3 and is definitely a good thing for the python community.
This isn't about "all important Python programs", it's about all of the tools it takes to run a default Ubuntu system fresh off an install image. If you want to install something after the base install that requires Python 2.x, that'll be a dependency the tool will have to pick up.
Thanks for the feedback! Let me see if I can address everything. Downloads: I'm saving the download counts in hopes of graphing them at some point (https://github.com/ACLARKNET/vanity_aclark_net/blob/master/src/vanity_app/vanity_app/views.py#L225). Comments: Sure, but PyPI turned theirs off, so if they aren't patrolling there, where else? Trash reports: Yep, they can be improved. Run zopyx.trashfinder on the command line to see what else it does. Favoriting: fixed. Audience: See: http://pythonpackages.com/about. Description and classification: coming in a future version, for now I added raw metadata e.g. http://pythonpackages.com/pypi/pyephem As for your last point, that's what the discussion section is for, in part. I'm not sure what else I can do to head in that general direction though i.e. to make it into what you describe. I'm open to suggestions!
We're going to be calling the opencomparison.org API at some point.
Fixed, click on any package here: http://pythonpackages.com/pypi.
Thanks!
While I agree with the sentiment, LAPACK is not the best example because I bet most people (especially on ubuntu) install it from binary.
Seems like Python 3 doesn't support this kind of "programming by incident" or "handling broken input by incident". I think this is a good thing, even if it has caused you some frustration and more work in the first place. P.S.: You have all my sympathy. Encoding problems feel like being visited by Brick Top (hint: nemesis). I see him way to often ...
Having run into this problem in another language (Common Lisp, FWIW), this is actually a good thing, although it doesn't look like it now. If the file is broken, then you need to think harder about how to fix it the right way, rather than just slurping it in and pretending. You'll be glad in the long run, seriously. This forces you to consider what you're actually trying to do, what you're trying to do it to, and what you're trying to do it with. But yes, it does _suck_ when something that 'just worked' stops, and for no obviously good reason.
http://www.dd-wrt.com/wiki/index.php/Access_Restrictions
I don't use Ubuntu, but it'd be great if they re-referenced 'python' to point to python3 instead of python2, the way Arch did.
have you tried [Gargoyle](http://www.gargoyle-router.com/) ? Its a derivative of dd-wrt with all the nice GUI and stuff.I use that all the time to throttle bandwidth of my bandwidth hogging porn-junkie roomie.
Do you mean redrawing the contents of the terminal to match an offscreen window buffer, of the sort curses.newwin() creates? Blessings works one level lower than that: it draws directly to the tty, so yes, you can redraw anything anytime you like. If you need "window" bookkeeping done for you, I don't see any reason you can't use the capability-getting conveniences of blessings (like some_term.bold) and still call up to curses for the windowing stuff. If you just mean changing the character that's at some given coordinate, then yes, Blessings supports that directly, with both the location() context manager and direct access to the absolute and relative cursor movement capabilities. It even provides sugary names for the absolute ones: move, move_x, and move_y.
The `errors=` argument looks useful, thanks! 
So it's code that executes at the end, unless break is called? Any other features I should be aware of?
Or look into http://www.ex-parrot.com/pete/upside-down-ternet.html - turn his porn upside down when he hasn't done his chores.
The else triggers on the while loop either the first time, or when the loop is finished. It triggers no matter what, making it useless. And the for loop, it triggers when the loop is done, which also makes it useless, since you can just put that same code right after the loop. I don't see the point. Am I missing something?
&gt;A break statement executed in the first suite terminates the loop without executing the else clause’s suite. If you break a loop, then the else clause doesn't execute.
Ah ok, so you use it to test if a loop has been completed. It seems like it'd much more useful to be able to test for a break.
In Python 3, any time you do `str(my_bytes)` you can throw in an `encoding` and `errors` setting. In Python 2, you can use them when you do `my_bytes.decode(encoding="blah", errors="ignore")`.
I agree... this is one of the language features of which I never really saw the point...
**edit**: As Cosmologicon pointed out, the code is semantically wrong. I will leave it unchanged however. It still makes a valid point! When I read about this in the python docs, the first thing that popped into my head was: "Why call it `else`?" One of the beauties of Python is that the code is *very* "readable". It just "makes sense". But this breaks this IMO. If someone new to Python reads this, there is a *high* risk that the person will read it as "Loop through this block. If the block did *not* run successfully ('else') then run that block". Which is not quite what this means... For this reason, I *never* use this construct. If I *really* need something to run only if the loop runs to the end, I would do something like this: sentinel = False for a in range(10): if int(raw_input("Enter a number")) == a: break sentinel = True if sentinel: print "You never guessed the number!" This is *much, much* easier for everyone to understand.
If one interchanges internet access for other rights like access to food or water and chores for heavy work then we have slavery. I don't have kids of my own so I shouldn't judge nobody's decision regarding education methodology, but this sounds bad.
Agreed, reading through the comments and trying to understand how it worked, I asked myself: "Isn't that opposite of what is should be...?"
&gt;"Why call it else?" Same reason as it's called "else"in an if-statement: it's the block where the condition doesn't hold. It sounds a bit odd, but it's consistent with the if-statement. Plus, the most natural word to use in English would be "then", which would be pretty confusing.
I agree. I guess they didn't want to create a new reserved word for it.
Imagine your are looping, looking for a datum that satisfies some condition. When you have found it, you break; the else will execute if nothing is found. At least, that's how I've always understood the name.
I haven't had much cause to use it, but when I have it's been extremely helpful.
Not checking your facebook and not eating are in completely different ball parks, I don't even think they are the same *game*. Stop being dramatic.
Huh? If you're already calling break, you don't need an additional test outside the loop. You've clearly already got one inside it.
Yeah, you're absolutely right. Unfortunately, from the mailing list discussions it seems Guido has been using Python for so long that he thinks that `else` feels natural to him, which means this won't be changed. There was a proposal to change it so that `else not break` had the current meaning and `else None` meant "empty loop" but it went nowhere because the current meaning is so encrusted.
Also, you can install, boot, and use Ubuntu without ever installing LAPACK, or Fortran for that matter.
Worse, because it's so rarely used you can't trust whoever comes after you to understand it, which means you basically have to either not use it or add a bunch of comments to explain it.
Not to be that guy, but your code is wrong. If you fail to guess a = 0 but guess correctly on a later loop, it still tells you that you never guessed the number.
Small is beautiful and if it is delivering as it promises, those $40 will be the one of th best investments you will make. In order to get a better perspective, consider that your time is valuable. Think about the amount of time something could save you and multiply that by your hourly rate. 
 def guessed_number(a): return int(raw_input("Enter a number")) == a if not any(guessed_number(a) for a in range(10)): print "You never guessed the number!" 