Or [ctypes](https://docs.python.org/3.4/library/ctypes.html), or [Cython](http://cython.org/), or [CFFI](https://cffi.readthedocs.org/en/latest/), or directly writing [C extension modules](https://docs.python.org/3.4/extending/extending.html).
Cool tip for anyone who doesn't know: In Chrome, you can automatically extract XPaths through the Dev Console which you can adapt pretty quickly for your uses with a basic knowledge of XPath. Saves a lot of time for deeply-nested elements, etc.
That article is good - and the lead response gets to the meat of the question - "untyped" in the language of the lambda calculus is not "untyped" for computer programmers. &gt; even the behaviour of operations with different primitive types doesn't require explicit casting. E.g. x = "1" + 2 gives a type error in Python but doesn't in Javascript. `x = "1" + 2;` works in Java too (though giving a very different result), and Java is even a strongly-typed language. Arithmetic operators in Javascript try to coerce their arguments to be numbers. That doesn't make the language untyped. Heck, there's an explicit `type()` function in Javascript. I'd buy "weakly typed" or "dynamically typed" for Javascript though!
It only helps load time of your application. All that step does is get rid of the step where python compiles `.py` files to `.pyc` files. You get the same benefit if you just run your python application, stop it, then run it again. The second run will load faster because the `.py` files are already `.pyc` files.
Thanks! I'll see what's up.
I'm glad!
Is there a reason to use pow(x,2) and sqrt(x) instead of x\*\*2 and x\*\*.5 ? Edit: Also, why use Decimal for the minkowski nth_root function and not just x**(1/n_root)? It's not like you can actually use infinity with this minkowski algorithm anyway.
This is simply retarded. Its clear the author is not a native English speaker. Its also clear that the author has no clue why certain distances are used over other distances. I have no clue how this got so many upvotes? Im guessing /r/python likes cartoons?
I have no idea what this is supposed to do.
This article isn't so good at telling you when you might want to use some measures over others, as if the author doesn't always know.
Can confirm. Saw it in person - awesome talk!
Awesome! Thank you for a detailed answer. Covers a lot of doubts I had.
This. I'd imagine most of your work will be graphics related which will be done in a separate (probably native) graphics library. I'd imagine any stuff you do in Python itself should run more than fast enough. If not, look at Cython as others have suggested, or PyPy may speed up execution. 
Or depending on your needs and libraries, pypy or cffi.
Just chiming in to say this guy is flipping awesome. There's like 4 or 5 of his talks on youtube. If you're like me, you walk away from each one thinking *damn, he answered so many questions I didn't even know I had.* Answers that turn you into being a better, more pythonic, python programmer. As far as I can tell, his talks are uniquely targeted at all skill levels beginner, intermediate, advanced. tldr Can't wait to watch this.
It traverses the entire repo history and constructs a dictionary with useful information (sha1, file_path, commit type, etc). If you have ever tried to do a clean up of a giant repo full of binaries then you might find this useful. 
Thanks, ill look into Anaconda
thanks for the answer, I'm doing some parsing and dict lookups inside the webpage that consume extra latency that I want to get rid of. Edit: this seems to be the problem **your Python code have global lists or dicts that grow over time, and you forgot to remove the objects after use** Any idea how it can be fixed ?
I think what the OP meant was that a lot of the stuff he talks about are meta-things or human-things that don't directly relate to writing code. This particular talk, for example, would also provide something for users of other languages, and non-programmers, in addition to python programmers of all levels (where we define level as the ability to write and understand code). By contrast, a lot of other speakers would either carry zero code (like advcoacy talks) or provide nothing for non-coders (like coding talks) or be aimed at a particular level of coder.
Why not both? Sometimes a static method in Python makes sense, although functionally it is equivalent to a regular module-level function, and static methods in Java are not any different from regular functions in C++, with the class playing the role of the namespace.
I think this talk was undeniably aimed at programmers only. 
Right, but people differentiate between ANSI C and C11, much as they differentiate between Python 2 and Python 3. Just because "C" refers to a whole family of languages doesn't mean that there aren't distinctions between the many flavors of C. And changing a language from dynamically typed to statically typed isn't exactly a small thing, unlike adding keywords or changing corner cases.
No, I agree with you. I think staticmethods are useful for organising functions.
XD. Yes it does. Needed to solve a problem, thought others might find it useful. Just ship it... Right?
I've been writing Python code for years and never knew about @property to avoid having to write getters and setters. Now instead of class Computer(object): get_ip_address(self): . . . I can do class Computer(object): @property ip_address(self): . . . And users of my class can simply do print comp.ip_address Rather than print comp.get_ip_address() But what happens when a user assigns to ip_address?
But she didn't have kids, you can only tell jokes if you don't have kids remember.
You have to write a [setter](https://docs.python.org/2/library/functions.html#property) if you want to do that.
try it (spoilers: yup)
does anyone want to do a matplotlib adapter? all those setters and getters...
He is a programmer/teacher with a fandom. Flipping awesome doesn't do enough justice to his awesomeness.
SPOILER WARNING: Man, when he showed the code cleanup example starting at 12:37, I immediately noticed the try: finally: and thought, "hmm, looks like we could use a 'with' here". Then the PEP8-ifying began and it distracted me so much that I completely forgot about the 'with'. Great example. 
I'd like to point out that [MyPaint](https://github.com/mypaint/mypaint) is written in Python (and some C/Cython), and is one of the most responsive apps of any kind I have had the pleasure of using. You should definitely look into [NumPy](https://pypi.python.org/pypi/numpy), btw. This is what MyPaint uses for much of its image storage and manipulation. It provides.. basically everything you could want relating to N-dimensional arrays (eg. image data). If I had to list 10 amazing things about Python, NumPy would be one of them. As someone who's done a lot of graphics processing using NumPy and Python, my personal experience is also that speed issues generally reflect problems with the design of your algorithm, rather than any unacceptable overhead inherent in Python.
Know how to use pip is a integral part of python programming. Once you have the basics, it should be the first thing you learn how to use.
https://www.google.com/search?q=atan2&amp;ie=utf-8&amp;oe=utf-8
But classes instantiate objects, and objects are data and the methods that act on them. So what does that make a static method?
Loading the data into an sqlite3 database can make analysis fast and easy. When I find myself writing loops with all kinds of dictionary lookups I often realize this could be expressed much more clearly with an sql statement or two so I create a quick ':memory:' database with sqlite3 to do the job. Why introduce an external dependency like fabric? The python subprocess module can do this just fine (and pass the cwd= keyword instead of using lcd). Any script that can be downloaded as a single file and run with just the python library gets an instant karma boost for me. Packaging boilerplate can be added if and when the script grows into something bigger. What's the deal with all the underscores?
I think it's also worth pointing out something similar that he didn't mention in the talk: (I'm going to use the 10x analogy which is a bit broken but bear with me!) You can be a 0.5x programmer, but still contribute more than 1x. This is a concept that people find difficult to grasp, but it's absolutely true. I see it regularly. A person who is a 0.5x programmer will almost always know some things that no other team member knows. Why? Because programming is huge. If one person knows something that no one else knows he/she can save hours of painful debugging from other members of the team. If those members of the team are 10x people, effectively that 0.5x person is now _for the team as a whole_ a 10x person for every hour he/she saved for that other person. Basically a team is not the sum of its parts but the product of its parts and the more we realise this the easier I think it should be to stop thinking so much about 10x programmers or whatever.
I fail to see how this contradict anything I said earlier. 
I think it's not very pythonic because it's supposed to be intuitive to anyone used to matlab.
While the article is a good showcase, this isn't exactly the best example: def delete_order(self, id): con = self.get_db_connection() with con: cur = con.cursor() cur.execute("delete from order_item where order_id = %s", (id)) cur.execute("delete from customer_order where id = %s", (id)) In Java (EE 7, as the author was using), this would be: public void deleteOrder(Long id) { em.createQuery("delete from OrderItem oi where oi.id = :orderId") .setParameter("orderId", id).executeUpdate(); em.createQuery("delete from CustomerOrder co where co.id = :orderId") .setParameter("orderId", id).executeUpdate(); } There are some differences though. The Python example is using resource local transaction (the DB connection is the handle into the transaction), where the Java example uses XA transactions automatically (any transactional resource joins the ongoing transaction, but if there's only one such resource it optimizes to resource local only). In isolation it may not seem like much, but when you have multiple methods calling each other passing along the connection becomes quite a chore, especially when those methods can be called separately as well (we actually had a large system doing exactly this and it became troublesome to maintain).
I don't really use `contextlib` (I have used `@contextmanager`), but this looks really shiny!
I've done this some months ago, haha, people called it a "weird ass metaprogramming journey", but I liked the result, even though I wouldn't use it on any serious code :P https://gitlab.com/edricgarran/scopy
Python 3.5 release schedule: https://www.python.org/dev/peps/pep-0478/ Though I don't see it mentioned explicitly.
when that organizer comes on stage to try to get raymond to wrap it up http://i.imgur.com/Zdba25C.webm
Python 3 won't have a "killer app" i.e. some feature X whose presence all the sudden leads to its adoption. There is simply no reason to *not* start a new Python project with Python 3 and that's all. 
Thought this was a self post and already had a list of things to write. This'll do.
OpenCV has no Python 3 support.
If you're curious to learn how to do it, check out the [Real Python courses](https://realpython.com/) as we detail how to use GIS data with Django + DRF + MongoDB. (Note: I am the co-founder/author)
Use scapy to sniff the network, then just parse each packet for the data you are looking for. 
for 3d programming, opengl is ok. for games, jsut go with unity. C# or JS is not that hard to grasp. 
Thanks for the remainder. Python 3.4 and 3.5 added some new features to contextlib that need to be backported.
Why on earth is it using sorted(list)[0] instead of min() and max()? That isn't a good comparison...
If you are using windows, portable python allow you to run Python + panda without the need to install it : http://portablepython.com/wiki/PortablePython2.7.5.1/ You can just have it on your usb key and play from here.
Hmm at least on Py2 this does not work or i don't know how the access it (and neither does my IDE): class Test(object): @property def test(self): """ Test docs """ print 'Foo' T = Test() print help(T.test) #prints help for None 
This article is very subjective. All that has been proven by it is that the used functions perform better on `numpy.Array` than on python `list` when using integers. However, it completely avoid talking on the fact that: - Python `list` are made for heterogeneous types while `numpy.Array` works on homogeneous types. - Python `list` supports adding and removing elements where `numpy.Array` does not. - The used functions are not described anywhere therefore we cannot assume that the algorithm is the same - The `sum` of python `list` takes more time than the `mean` which is suppose to take more time. And `numpy` `mean` takes double the time of `numpy` `sum` - The protocol only runs the function once, where it should run the function at least 100+ times and get an average
this is interesting. 
I think everybody, except the organiser had that reaction! He could have just announced that everyone is free to leave for meal, but it is not mandatory! I would have rather skipped a meal to hear the rest of the talk!
Yes, I've just noticed that you support full nesting, while ExitStack doesn't, I'm not sure why, I guess they thought that it would complicate the model of the behavior when you mix the use as a context manager with direct calls, like in the "Catching exceptions from `__enter__` methods" example.
No, it's poor design plain and simple. The reason matplotlib is that way is because it precedes getters and setters being in Python. It's just a question of someone doing the work.
This is one of the things he talks about in this video: https://www.youtube.com/watch?v=HTLu2DFOdTg
Yes, that's why it would be a massive undertaking. I think the end product would be worth it, but it would take a lot of effort.
Keep in mind that like everything properties should be used in moderation. There's a sort of unwritten agreement that accessing a property shouldn't do much work (at least not repeatedly) and return different values, while calling a function named `getSomething()` can. So to use the OP's example, if you allow the user to write if len(ne.routing_table): log('blah blah {}'.format(ne.routing_table.description) for route in ne.routing_table: ... You'd better make damn sure that it doesn't do three requests to the network interface, possibly returning different values as well. Making a costly call then returning a cached result is acceptable, returning a lightweight wrapper object over a different API that caches results is more or less acceptable, going to the network adapter is not.
thanks for your suggestions, I'll change this when I get home
Seems to be supported in their trunk. 3.0 is currently in beta.
I was thinking about something like that, seeing that this is highly dependent on correct spelling, thanks!
There is no "good" 3d python game engine I'm aware of. There is [PySDL2](https://pysdl2.readthedocs.org/en/latest) which seems a bit higher than PyOpenGl, but if you want to get serious you better change language (or build something yourself).
&gt; Python list adding and removing elements where numpy.Array &gt; does not. You forgot a 
Well there's this repo https://github.com/faif/python-patterns But really getting Design Patterns: Elements of Reusable Object Oriented Software is the classic place to start.
IMHO, there is no "great" Python 3D engine, although Panda3D is probably the best. You could also look into Delta3D, Blender game engine and PyOGRE, although I've never had much luck with the bindings for the later. 
Panda3d is actually very usable. It's not cutting edge and it's not a turnkey solution for game development in the way that unity is. But if you want to experiment with 3d games in python, it'll probably do everything you want it to do. I've used it A LOT both for home projects and at work for scientific stuff (simulations). It's reasonably full featured: I've used it for 2d and 3d, it has integrated physics (bullet), joystick/gamepad input, procedural generation, shaders. I've since switched to Unity for my personal projects, but if was intent on using python, I would definitly still be using panda, and I still use panda extensively at work. So I don't think there's much reason to be apprehensive about it. However, unless there's been a recent change, I believe panda3d uses python 2.7.
Any single item is going to be irrelevant to the majority of new projects, but taken in aggregate, many new projects will still be unable to use Python 3. Anyway /u/kay_schluehr was explicitly saying that there was "no reason to _not_ start a new Python project with Python 3 and that's all," which is obviously false as there are still many such reasons.
Not sure if it is a good idea to give all your customers addresses to a third party.
You may be interested in https://github.com/faif/python-patterns
So, would there be a keyword the user would have to put to end the cycle? Something like exit? If that's the case you could have a ```while True:``` for loop, ask for the input, append it to the list and print it, and have an exit condition if the string entered is exit or something? Sorry I thought the list was fully populated and you just wanted to print out the elements within it.
Check out [marisa tries](https://github.com/kmike/marisa-trie/) if you're interested in a fast, space efficient algorithm. 
Thanks, that was quite helpful. Looks like there is a 1.9.0 build, actually https://www.panda3d.org/download.php?platform=windows&amp;version=1.9.0&amp;sdk
for some business that may be unreasonable, but others its fine. In the case of validating shipping addresses - you already have to give it to a 3rd party (the shipper).
I apologize if I'm not of much help, but design patterns are something I believe you should be trying to abstract in your mind, so you can realize on your own how they apply to the problem you're trying to solve and *how to implement them with your tools*. So... to sum up, any design pattern book/resource will do. EDIT: But I will save you some work: In Python, modules are singletons. Don't try creating a singleton class, just create a module. And the borg pattern is unnecessary when you have import XXX as YYY.
But if I'm a mail spammer (I'm not), I now have a list of new potential clients to send bullshit mail gussied up to appear super important.
Bound to old Python2-code and not wanting to constantly swap between the versions, might be a reason for the next years. Personally I stay with 2 so far, because there is no real advantage, but a big disadvantage in form of bug-probability.
Imho it is not! The way to start is definitly "Head First Design Patterns"! The classic book is rather the next step, after one got the first steps and got into the whole topic, sense and object oriented principles. But beware: Besides some patterns like Singleton / Borg are considered anti patterns nowadays, in Python lots of pattern appears in different way than in static typed languages like Java (that is chosen for the book). Duck Typing and Python object model enables often to implement patterns in a trivial way.
Hi, not entirely sure what your question is, but 1) in this example, the values in the deque are tuples with the node to process and the prefix to that point. This is because each node contains no reference to the values of previous nodes, so you need to have the string that previous nodes encode when you process any given node. 2) As for why empty collections are falsey... that's a pretty common convention, not just in Python. 
Well, yes, but bulk mailers have far better sources of address data than this.
Yeah, I figured that much out. I am now toying around with the 1.9 build with python 2.7... which is actually quite nice. Thank you for your help.
I'm teaching a class in design patterns using Python right now. I have the Head First book and GOF on my desk. I find the Head First book completely unreadable myself. About half my students like it and the other half does not. It all comes down to a question of personal taste.
This is basically the right approach. Design patterns are just big ideas that have to be implemented appropriately for your application. Keep in mind that a lot of the literature around design patterns is written in terms of C++ or Java. You'll have to supply your own Pythonic twist on them.
See? A little inference goes a long way!
Live capture.
I can reproduce that (on Py2, and with a few tweaks, Py3). But it doesn't mean what you think it does. Try amending the final line to refer to T rather than T.test. There is a very good reason that `help(T.test)` prints help for None. In fact, your code says to do so, since your getter does not return a value. To illustrate, you could try adding a line 'return 11' to test() after the print. I agree that it's a problem that T.test doesn't show help for the descriptor test rather than the value returned by the property getter for test. Not sure if there are any IDEs that do the helpful thing here.
Actually I told people that your talk is a reference for things to do, it was awesome!
Nice refresher, thanks for the talk!
There's also [SageMathCloud](https://cloud.sagemath.com/). Youtube [video](https://www.youtube.com/watch?v=_ff2HdME8MI) that provides background and overview.
Excellent. &gt; https://github.com/stefanoborini/modelviewcontroller-src Thanks
Excellent overview &amp; tutorial - thanks for posting it. -Austin (the author of Murmur3)
Thank you, that was a very cool talk! I've been looking for a fast bloom filter implementation in python and the two that i found were https://github.com/jaybaird/python-bloomfilter and https://github.com/axiak/pybloomfiltermmap Neither of those fit my need but hopefully this information might be helpful to someone :)
Print sorted list? List = [] list.sort () For line in list: print line
Yeah it's very much up to the reader, head first was alright but I spent a lot of my time waiting for them to move on to the next thing. But like I said that's the classic book to start with, just to learn design patterns. Once you know the patterns it's easier to recognize what python already has and why some patterns are pretty much pointless in python.
Sublime text and learn python the hard way to get you started you won't look back.
Awesome talk, very informative. Thanks!
Being a beginner in Python, I've enjoyed it a lot: will be looking forward to what you do next :)
Assuming you mean creating a website with Python, you'd want Flask, Django, or Tornado.
Can't beat asking though...
/r/learnpython No one can give you the solution to your question. You will have to figure it out yourself by learning how to program. Be prepared to take a while to accomplish what you want, and spend more time writing and troubleshooting code than asking for the solution from others. Look at [pillow]( http://pillow.readthedocs.org/en/latest/reference/ImageDraw.html) and the arc function on that page.
little late, but my intro to programing class uses an online response-ware system to take attendance and answer some questions. I found out that you weren't penalized for wrong answers so I used selenium to check for a new question every few seconds and put in a random answer. Now I have "perfect attendance".
eh I disagree I'm learning Haskell and I love it, but one thing I love about Python is that they try really hard to make it so that there is only one correct way to do any one thing. This effort goes a long way towards eliminating any sort of doubt about which of these similar scenarios is optimal, and it's gratifying to see that the most "pythonic" expression usually wins out.
As a python guy in the industry for at least a decade now... I may not know everything, but I have one insight that may be helpful. As you go from the entry to mid-level, to senior... design patterns are mostly important because they are tools for communicating with others. I can write a framework that performs operations on a tree without using the visitor pattern, but naming a class `NodeVisitor` tells my colleagues, superiors, subordinates, whatever... a lot more just from inspection than `TreeAnalyzer` does. Edit: learn about them, but they aren't there to do your engineering for ya.
What I meant was that I don't think these are not things that should be considered "Tricks for your code run faster" as the page states. Instead I see it as you do, more evidence that writing code in a more pythonic fashion is usually faster and easier to comprehend. To me it seems like the author confused making code run faster with micro-optimizations which on the grand scheme of things usually do not make a great deal of difference to runtime.
Kudos for mentioning pbkdf2 and knowing the current best practices. I was pretty apprehensive at the point where you were mentioning salt and md5. Too many people think you can stop there. Too many people think md5 is enough on its own... A few interesting things that you didn't mention though, that people might want to be aware of. pbkdf2 will take options, such as a variable number of rounds to run the hash function. Many people recommend 100,000+ rounds of sha256, but I'm not sure how much is best if you use sha512. Either way, you need to check your performance with whatever you pick, because as you said, most people don't want to wait 5 seconds to log in. There's a bit of controversy between pbkdf2, bcrypt and scrypt. A lot of people will recommend scrypt over bcrypt, but some will say scrypt is too new to be considered safe. Regardless of those, pbkdf2 has been around for a bit and known to be pretty damn secure. Personally I'd recommend that one over the others because I've heard lots of cryptographers vouch for its security, in recent times, but I was recommended to use over 100k rounds of sha256 as its options. I believe django will use pbkdf2 by default. Great stuff though. Tons of devs don't know the password hashing stuff, except might have heard that you have to salt them. It's scary how many businesses (and not small ones) still just use md5. And some dudes just store the password. Ugh. If I click forgot password and you email me my password, I'm going to be pretty damn irritated. But a side note for people, make sure you're not recreating the wheel with cryptographic stuff. Use high level options whenever available. Never roll your own crypto unless you know what you're doing, and that includes using crypto primitives like AES. If used wrong, that can be very insecure. Just because you figured out how to encrypt with AES256 in CBC mode doesn't mean your scheme is secure. There's a lot more that goes into it.
cherrypy! 
[Godot](http://www.godotengine.org/) is a game engine available for Mac, Windows and Linux. It is open source and its scripting language comes from Python. You should check it out.
The single source file is about a thousand lines long. Consider breaking it up into smaller modules. I try to keep my modules between 300 and 500 lines.
it's on github if you want the sources
I actually didn't wake up before answering :D
&gt; Another thing, people need to watch out and limit password length. Django had a vulnerability where you could try to pass in a 1MB size password and cause a denial of service. This is actually a flaw in the PBKDF2 implementation that Django uses. PBKDF2 uses the password as a HMAC key for each round in the computation. If the password is longer than the required key size, it gets hashed. A good implementation of PBKDF2 will perform that hashing once at the start. Django's implementation does it for each round of computation. A good implementation of PBKDF2 will not have a noticeable speed difference when hashing 20 char long passwords or 10MB long passwords.
I'd recommend Flask, and this is a good place to start: http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world
I see this as a good way to learn about tries, but not a great thing to use in your Python code. Tries can squeeze some performance out of your lookups in a language like C, but in Python, there will just be way too much overhead compared to other approaches. You could implement it in Cython, but then you still have to deal with translating your values to things you can manipulate in C. Tries lose because Python has a very fast data structure that does almost the same thing: the dictionary. Dictionaries indexed by strings are necessarily fast in Python because almost everything is one. Every method you call on every node of one of these tries is going to be looked up in a dictionary anyway. Even Julia -- a JIT-compiled, type-checked language that should just be faster at data structures -- has trouble competing with Python's dictionaries of strings. ("But dictionaries aren't the same as tries," you may object. "How do you test a dictionary to see if you've got a prefix of a look-up-able value?" I'd say the answer is to make another dictionary of prefixes.)
I wish you were around when matplotlib was being developed.
Disclaimer: I'm not an expert, but I did implement a Bloom filter once. For the given hypothetical scenario, yes, you would need all the images to rebuild a new Bloom filter with a larger capacity. However, I thought the image thing was kind of a weird example, not only since usually you wouldn't use a Bloom filter in that way, but also since it wouldn't even work and since real-world examples of Bloom filter usage are plentiful. The known malicious website thing is a good real-world example. Supposedly Chrome used to use a Bloom filter to check if you were trying to visit to a known malicious website, without having to know the entire gargantuan list of known malicious websites. Google has the list, Google builds the filter, Google sends the very compact Bloom filter out to Chrome users, Chrome quickly and easily consults the filter every time it goes to a new site. Much bandwidth/time/responsiveness saved.
also its never a good idea to hard delete order transactions, use soft delete
I feel like I finally understand bloom filters, thanks! Can you share information on how you made the presentation? It looks really cool and I am not familiar with it.
some of them: https://github.com/vinta/awesome-python#web-frameworks
You'll need to post some code with a more specific question. What do you expect to be working? What happens instead?
There's a module called [ggplot](http://ggplot.yhathq.com/) which is more pythonic, but is very limited in comparison and only works with pandas (which makes quick and dirty plotting a pain + bootstrapping and bayesian calculations difficult). I would love to see matplotlib that's nicer to use, and there's a lot that ggplot does right.
Suggestions: - Write some tests. Doesn't even need to be 100% coverage, just try and simulate your use cases to make sure they generally work the way you expect. - Finish writing docstrings, look into sphinx for formatting and styles so you can generate docs. - Consider doing your csv output using a formatted logger; this will give better control over output if you decide to use this library in some other project, also loggers can do heaps of cool stuff. 
You're right that one doesn't preclue the other, but I think that the lack of getters and setters is a historical defect. It is not Pythonic, and that is poor design for a Python library. I think pylab tried to mimic the matlab API. I don't like pylab either. I am much more comfortable with an OO interface rather than a stateful module.
Thanks! Great to hear that :D
Awesome, will definitely check it out. As I replied to others, I thought I'd leave it as a single file to make it easier for users to just download a single file, make it executable, copy it to /usr/local/bin and run it. Although now that I think about it, even with multiple files, I can have a single file that imports everything and launches the scan, so it should still be easy for users. Thanks for the feedback :D
I considered making it more modular on the beginning of the project, but I thought it would be easier for users to just download a single file, make it executable, copy it to /usr/local/bin and run it. Do you think it is a valid concern? Thanks for taking the time to look at it! 
Would this be something that could be improved with a patch or would it change the return values of Django's PBKDF2 implementation if you did so?
So I tried this on my website and it just kept on going forever while printing out urls. Is this a security thing through godaddy or is it a bug?
Good one, didn't know about that! There were some other instances throughout the code. Already pushed a fix. At first I didn't quite understand the problem, because the object properties that used the default lists had different ids when I compared between different objects. After a while I figured that they were different because it wasn't assigning the arguments directly to object properties - instead was iterating the arguments and creating a new list as an object property. Still could give me headaches in the future, thanks a lot for the heads up!
As far as I remember, **is** and **==** are not the same thing. **is** tests for identity, while **==** tests for equality
Yeah sure! I'll PM it to you cause the website is still in the works and I don't want it out there just yet 
Awesome tips. All written down on the ToDo list. Really appreciate it. Funny that I actually have a test.py file with some tests, but added it to .gitignore for thinking it wouldn't be useful in the repo. Will polish it with more test cases and add it to the project. First time I'm hearing about dosctrings, will look it up and try to improve formatting. Never used a logging library, have to check that out. Thanks again for taking the time, mate! 
You can learn how to make it a pip installable package by reading up [here!](https://packaging.python.org/en/latest/distributing.html)
Keep in mind that you ~~need to~~ should assign a new variable to the returned value of a function. def five(): return 5 x = five() print(x) &gt;&gt;&gt; 5
Just tried it, and it doesn't seem to be a bug. Here's the problem - godaddy network range has 32766 hosts in it. And every single host seems to have a reverse DNS entry (which is usually not the case). So the script will print 32766 lines at the end - all godaddy hosting servers. You should cancel that step and use the other results. This actually reminds me that the script should have a flag to control reverse scan on entire network ranges, allowing a user to cancel it. Again, thanks very much for testing it!
Since I'd already written all that, I figured I may as well give a full implementation for comparison: class Trie(object): """Trie implementation, with set-style interface""" def __init__(self, items=()): self._children = collections.defaultdict(Trie) self.is_terminal = False for item in items: self.add(item) def add(self, item): self.get_node(item).is_terminal = True def __getitem__(self, key): """Retrieve node at specified item, if any words exist with that prefix. Otherwise, throws a KeyError """ current = self for ch in key: current = current._children.get(ch) if current is None: raise KeyError(key) return current def __contains__(self, key): try: item = self[key] return item.is_terminal except KeyError: return False def get_node(self, key): """Obtain position for given prefix, creating nodes if it doesn't already exist""" current = self for ch in key: current = current._children[ch] return current def __iter__(self): if self.is_terminal: yield '' for char, node in self._children.items(): for subword in node: # Recursively iterate. yield char + subword def __repr__(self): return "Trie([{}])".format(", ".join(map(repr, self))) (I made a few minor changes - contains is now `__contains__`, so you can just do `'foo' in my_trie`, and I did change `__getitem__` since I didn't like the fact that it created dead nodes. Also added a `__repr__` for convenience.
/r/learnpython please
Nice Pillow reference :-)
i like the "where" idea. not sure about how the extra indentation level would mess things up for the interpreter, but even if it was back one level, it would still be more readable than having everything packed into the signature
Not to mention more consistent and easy to code fold.
I think you may be misunderstanding a little, going by your names here, unless I'm misunderstanding your analogy. &gt;Now we can bake some brownies with these three categories &gt;`chocolate_caramel = Baking_Dish(flavor = ["chocolate"], filling = ["caramel"], height = ["5 cm"])` You seem to be saying chocolate_caramel here is a *brownie*, made with your baking dish, but really that's not how you should be thinking about classes. Rather your Baking_Dish class should not be considered a brownie-manufacturer, but something that describes *Baking Dishes*. Ie. I'd expect the thing you get back from `something = Baking_dish(...)` to be a baking dish, not a brownie. You could maybe consider the class itself as basically the platonic idea of Baking Dishes, which all *real-world* baking dishes derive from. Ie. the baking dish in my kitchen is a kind of baking dish, but it's not the "concept of baking dishes", it's an actual real baking dish that I can touch and use. The class is that notion of the *kind of thing it is* - that it's a baking dish, not a mixing bowl or a spoon, or a brownie. All baking dishes are instances of the Baking_Dish class, and all brownies are instances of the Brownie class. As such, I'd expect the members of a Baking_Dish class not to be things like flavor or filling, but rather things like material, size etc. Your above description would thus make more sense if you replace `Baking_Dish` with `Brownie` everywhere, since it's *brownies* (instances of the Brownie class) that have attributes like flavor etc. Of course, if you were to write a program involving baking, you may indeed have Baking_Dish classes, whose **instances** are indeed involved in making brownies, but don't confuse this with the notion of classes. Classes aren't about what you *use* to make things, they're about what kind of things those things are
Hi: This is considered bad form: except Exception as e: pass You should specify the exceptions you expect to receive.
I don't really like either of them, which leads me to think that I'm not really interested in any typing when I'm writing 95% of Python code. The intention, I assume, is to continue in Python's tradition of supporting multiple programming paradigms. That's cool, but in this case code that has the type annotations is less readable, and readability is the main reason I chose to use Python in a project. I don't see this going mainstream in Python.
Yup. If somebody had just told me that Class was the Platonic Form for particular instances, then it would have all made sense! (goddamn philosophy degree....)
This has actually been fixed long ago. See: https://github.com/django/django/commit/68540fe4df44492571bc610a0a043d3d02b3d320#diff-dd9c116fcefaf3916ace2608656311e0 Looks like this made it into the 1.7 release.
Why did you have flavor = ["chocolate"] and not flavor = "chocolate" ?
Glad I could help! In Python you can create lists of values like this my_list = ["item 1", "item 2", "item 3"] That's a list called `my_list` with three individual values in it. By typing `flavor = ["chocolate"]`, `flavor` becomes a list with only one item `"chocolate"`. Since a brownie can only have one flavour and one height, making those variable lists makes little sense. `flavor = "chocolate"` is the better solution. Then you can also ditch the `for` loops in `recipe`.
OK. I understand. I added the brackets because it was printing out as: Flavor: c Flavor: h Flavor: o Flavor: c Flavor: o Flavor: l Flavor: a Flavor: t Flavor: e So was that because of the for loop?
No, you don't *need* to assign a new name. In the above you could also do this if you wanted to: print(five()) 
Yep. In Python you can just loop over a string to get the characters that make up that string. But you don't need to do that in your example. To print the flavour, just type `print "Flavor: ", self.flavor`
Thanks for this. The concept of classes has never given me much trouble, but where I still struggle is determining when it's best to use objects in my code. When I'm designing something, I can clearly pick out where my objects are most of the time (e.g., the typical Customer, Car, and other easy stuff that pop out in the problem domain). However, some times it becomes difficult identifying when an object needs to plugged in to glue some other classes together. I haven't really found a good resource for that yet.
Very minor comments. Overall the code looks very good. This line (and similar): if ips is None: ips = [] is not very pythonic. I'd rewrite it as: ips = ips or [] Exact same result and much easier to read. For the `__eq__` function I'd just use `return hash(self) == hash(other)`. `if ips and domain or domain:` can just be rewritten `if ips:` 
I think all type hinting should happen on a separate file, or with decorators. The proposed syntax is terrible imo.
Are you running your server on 127.0.0.1 or 0.0.0.0? The latter would work. The former cannot be seen by other computers.
Agreed, this is almost always the case. In cases where I use this, I try to be clear why: try: risky but non crucial thing using external library or something except ExpectedException as err: handle expected exception except Exception as err: pass # since it's not too important, if there's an error, just keep going
The post explains how tries work well, a good job!
To allow tools (static checkers in IDEs) to identify problems. I.e. "you passed this function a number but it expects a string".
why soon?
Cool. But that syntax is horrible. I've never been a fan of Python's annotation syntax or really any language that inlines types with the parameters. def my_func(a:int, b:str = 'hello') -&gt; tuple: return (a, b) Like what. That's ugly. Sure, it communicates a lot of information. But after playing with Haskell for some months (writing only trivial programs, but still), I *really* like the way it communicates types: myFunc :: Int -&gt; String -&gt; (Int, String) myFunc a b = (a, b) The type signature is out of the way which reduces line noise. What if I had a higher order function? my_map(f:Callable[Any, Any], it:Iterator) -&gt; Iterator: return (f(x) for x in it) Uuuhhhh....so much line noise. Compare: myMap :: (a -&gt; b) -&gt; [a] -&gt; [b] myMap f xs = [f x | x &lt;- xs] I'm not proposing that Python straight up steal Haskell's type signature system. But, it's about 1000% better than every other typing system I've been exposed to. ;) If I had been present, my question to GvR would be is it possible to define a signature like this with the type system: a -&gt; b -&gt; b Allow any type for the first argument, allow any type for the second argument but only allow a return of the same type as the second argument?
It's actually inspired by [rbenv](https://github.com/sstephenson/rbenv) - RVM has a lot of issues that rbenv/pyenv and a few others for similarly dynamic languages avoid.
www.codecademy.com/python should help
Were your at the talk by any chance? If so I wonder if there was any reaction to the syntax aesthetics among the audience?
I've always thought of `@` as "wrapped with" or "enclosed by" since the symbol is an "a" inside a circle (mostly). At least in terms of decorators, I'm not sure what the logic was for reusing the symbol for matrix multiplication was. I'm a big fan of Haskell's type signatures because the type is out of the way but still incredibly informative.
Instead of using a code block for where, why not ape the current `__annotations__` and just do... def my_func(x, y) where {'x': int, 'y': int, 'returns': int}:
To answer your question: If you provide a data parameter to urlopen,it will send a post rather than a get request. For example, instead of: urlopen('http://example.com') Do: from urllib import urlencode post_parameters= {'username': your_username, ‘password‘: your_password} encoded_parameters = urlencode(post_parameters) urlopen('http://example.com', data=encoded_parameters) Alternatively, use the requests library which has a much nicer interface: http://docs.python-requests.org/en/latest/ (Post written on my phone, apologies for any errors)
When I think Data Science, I essentially just think "applied machine learning." If you want to be thorough and rigorous, I would suggest grabbing a [real analysis](http://www.amazon.com/Real-Analysis-Edition-Halsey-Royden/dp/013143747X) book and reading up to the section on sigma-algebras and their measures to understand what probability measure really is. Don't go full Terrance Tao, just enough to get an idea of why probability measure obeys those "axioms" that they throw at you and expect you to just accept. Then, maybe check out this [free pdf](http://www-library.desy.de/preparch/books/vstatmp_engl.pdf) and read the first 3 chapters, then skip to 6 and 7, then to 11. After this, head over to [kaggle](http://kaggle.com) and try your hand at some data science projects there. Kaggle has a nice way of arranging the project in a way that clearly communicates what the goal is, and even subtly suggests your plan of attack. Plus, I think you can view submissions from others and look at what they're doing. Alternatively, check out the [cs229](http://cs229.stanford.edu) course at Stanford by Andrew Ng. Don't bother with the coursera version of his course; it's too watered down and really lacks the rigor you'll need to understand the stuff. At some point in the past Ng had a camera crew in the lecture and they recorded a whole semester worth of content. Try some of the cooked up homework problems, and don't use scikit-learn; write the algorithms yourself.
You might want to check out this [link](https://docs.python.org/3/howto/sockets.html) Particularly this section: *A couple things to notice: we used socket.gethostname() so that the socket would be visible to the outside world. If we had used s.bind(('localhost', 80)) or s.bind(('127.0.0.1', 80)) we would still have a “server” socket, but one that was only visible within the same machine. s.bind(('', 80)) specifies that the socket is reachable by any address the machine happens to have.*
Define your terms.
Sorry, I do not have any definitions for "your terms" --- ^(I am a bot. If there are any issues, please contact my [)[^master](http://www.reddit.com/message/compose/?to=Spedwards&amp;subject=/u/Define_It)^(].) ^(Want to learn how to use me? [)[^(Read this post)](http://redd.it/31vrec)^(].)
Define SPI
Sorry, I do not have any definitions for "SPI" --- ^(I am a bot. If there are any issues, please contact my [)[^master](http://www.reddit.com/message/compose/?to=Spedwards&amp;subject=/u/Define_It)^(].) ^(Want to learn how to use me? [)[^(Read this post)](http://redd.it/31vrec)^(].)
Exactly.
I can't see anything wrong with your Python code, so here are three possibilities: * The JavaScript code WebForm_OnSubmit may be adding or removing parameters before submitting the request, causing your request to differ from what is expected. Use a tool like firebug to see what your browser ultimately sends. * VIEWSTATE values may include some form of CSRF token, causing them to be valid only once. In that case, you'll need to send a first request to fetch the form, parse out the VIEWSTATE value and send that with your request. * The remote server is checking the user agent and rejecting ones which don't look like a real browser.
Heck, just make it a straight up decorator: @typedef(str, int, int, returns(str)) def my_method(name, value, addend): # etc
Unfortunately, he went over time and there was no time for questions. Actually, Guido intended it to be a technical talk for a small audience, but there was no more time/space for another small talk so it ended up being one of the closing keynotes, which is not exactly the right setting to address detailed technical concerns.
Type hinting wouldn't change any underlying behavior, it would give editing tools something to help the programmer know what sort of data they're working with. You could reduce the amount of "except TypeError" in your code.
Then you should hate this syntax, right? Not only does it get the ducks to wear clothes, they are bizarro looking clothes.
You don't need to close comment lines with another `#` # This is a comment # So is this # But we don't need any more #'s. #'s don't close comments. 
Agree it's ugly. (See my thread about this [here](http://www.reddit.com/r/Python/comments/32k023/is_it_just_me_or_is_the_new_type_hinting_syntax/).) Is it a done deal or is there still time to ask the BDFL to rethink the syntax?
Doctype+pycharm does this already...
PyCharm would have to reimplement their entire code base and us users has to change all that code AND the pycharm way is used by documentation tools already. I don't see how making a new syntax would DECREASE duplication of effort in this scenario.
I commented there. :) I think we're stuck with this eye sore as annotations in this style have been around for a long time. I think the only way we're going to get around the ugliness is using a decorator that takes some typing information and matches it to arguments in the function's signature and populates `__annotations__` that way. 
...I suddenly think I know [who wrote this post about a week ago...](https://www.reddit.com/r/programming/comments/30dpt9/im_collaborating_on_a_new_programming_language/)
I'm sorta curious as well- aren't there already libs (distorm?) to handle (x86/64) at least?
I love you, thank you. This is great.
Sample output anyone? 
Adding prettier type hinting would require language changes that are planned, but are not done (though they are being considered). It would also break compatibility with previous versions.
We are considering using tries to store [n-grams](https://en.wikipedia.org/wiki/N-gram) in memory, and our previous solution with dicts used some 2GB of RAM which we consider too much. Cutting it down to below 1GB, or even just a few 10s of MB (50x-100x less memory as stated in the README) would be amazing. A slow aspect of our solution was reading the n-grams from a file to memory on program startup. &gt;build-time is very bad (serial build, though we can partition the tries in some cases) Would this be even slower with this particular trie structure? Or is the build-time in this case a one time thing that can easily be saved to a file and loaded at a later time?
Wouldn't it need to be `if ips and domain:`? 
Why is nobody asking the hard-hitting questions that he deserves? For instance: How can hash functions and bloom filters up my horse-drawing game? After you retire, when you look back and consider your life's work, what do you think will be your biggest accomplishment, and why is it HorseDrawing Tycoon? How soon can we expect an expansion?
Fuck yes, RaymondH is the fucking MAN. I've been a fangirl ever since he was doing some talk, someone interrupted with a question which would be answered later, and RaymondH said "true or false: This is my first rodeo." What a guy.
me@you.com == me [at] you [dot] com @ in python now is the mATrix multiply
I guess that makes sense. Then again, it's a symbol in a language, maybe I'm just reading too much into it.
Sigh. Breaking backwards compatibility is too scary, especially after the troubles with getting folks to v3. So we get this ugliness instead. 
My definition tends to be whether the language has implicit type coercion- that is, is 1 + 2 the same as 1 + '2'.
I personally find the syntax and reasons a tad silly, but I do recognize that you aren't easily going to confuse @decorate def myFunc(): pass with m = myMat() n = myMat() mn = m @ n
While a nice writup, your Python code breaks several of the PEP8 guidelines, especially naming conventions for functions. I suggest you rewrite your code according to this.
-1. This is a repost of a very active thread with plenty answers you could have found by just typing the name of the article into the search box : http://www.reddit.com/r/Python/search?q=Type+hinting+in+Python%3A+focus+on+readability+
Validating USA shipping addresses in Python you mean. Cause last time I checked, not all countries have states and the script require them. The entire world read reddit, not just american. And we do receive mails too. Now, as I can see no encoding mention of any kind, I suppose it's ASCII only, which is again a very english speaking centric point of view. But it's ok there is only 3 billions asians, they are not a big deal.
You've done a tremendous job on this tutorial and the previous. Thank you for your awesome contribution!
great job! its really cool that you've written an open source tool. I frequently utilize open source tools in my work at the dayjob, but I can't really use anything that doesn't have a decent test suite. How can I even be sure that it works as advertised if there are no tests? 
The README says: &gt;Listings of publicly available microcode updates are included: These are the .CSV files, apparently generated by this code (I haven't tried it).
Perhaps I should have been clearer, this post is asking whether folks think the new syntax is ugly and unreadable. This question is timely given Guido's PyCon talk this week. I merely reference that blog as an (admittedly lazy) way to provide context and exemplify the fact that there are alternative proposals that are arguably more readable. I could have equally linked to the section in PEP 484 that references the same blog and other proposals. tl;dr This is not meant as a redundant discussion of that same blog post; it's meant as a timely discussion about the readability of syntax itself given Guido's PyCon talk.
Second example is nearly valid VB6. :P
I want a separate file even less than ugliness. No devovling into header files *PLEASE FFS*. I don't want to have two windows open for a single function definition.
Actually I think it should be just `if domains:` Because if domains false the neither `ips and domain` and `domain` is true and if domains is true `ìps and domain or domain` will obviously be true. EDIT: But the condition may have been brought like this to improbe the readability of the code EDIT2: After I readed the code the condition seems like it should be `if domains:`
Yes, you're right. 
It definitely could help performance, but not with the crud cPython interpreter. There's PyPy (which already has a syntax for types, which is basically required for getting the most performance), and work on using LLVM. Anything JIT related would really benefit.
The official syntax is rubbish. I love the where statement, that feels like it should be part of the language. It fits in perfectly. I'm not sure about the extra level of indent, though, but that's minor. To anyone complaining about errors occurring due to having to retype parameter names, as soon as you type the where statement and press enter, the IDE could automatically populate that list of parameter names and keep them updated. 
Try [OWASP ZAP](https://code.google.com/p/zaproxy/), with that you can see what actually was posted and can figure out the changing parts.
But, when sending, you need to bind to the interface you want to send to. If you use INANY_ADDR, which is what "" means, the "default" interface, decided by the OS, will be used.
I think it's OK, but I can't yet say how it will affect the readability of a large codebase, since I've yet to see one with it. Perhaps someone can link something?
Basically it looks like Scala function signatures to me. I suppose after awhile you will get used to them.
I'm sure that's the case, as you can more or less get used to anything. But the arguments that reference other languages to support this fall flat for me. Python shouldn't look like other languages. It should look like Python! Not to say it should be different for the sake of being different. But it should be willing to be different when needed to be pythonic.
GET PEP8'D, OP.
Ahah! This is great! I don't think people will appreciate the syntax, but how could you write an easy to read brainfuck interpreter with a straight face?
Capital letters are usually reserved for classes. Your naming conventions really puts the pythonista off when glancing at your code unfortunately. Also for reading and writing CSV, I'd usually just use these two function from the [pandas](http://pandas.pydata.org/pandas-docs/dev/generated/pandas.io.parsers.read_csv.html) library: df = pandas.io.parsers.read_csv(old_path) df.to_csv(new_path) Much much simpler.
Again, it's being done last minute because the PEP still isn't finalized. There isn't even going to be any work done in regards to typing the standard library. You're more or less just getting the mypy imports in the standard library. There is no reason why it can't be completed next version. It's not like they're even going to break forwards compatibility to use `Str` because it's not even used. It's just going to work in previous versions. If you want to only support Python 3.6, fine use str.
Hack upon hacks... sounds about right. If it was "my world" I'd have it all as xml string w/in the script. But that's a different fight. 1) Partially because I'm not the owner of all the test scripts. And I would modify as I could, but we are using Clearcase for version control across multiple physical sites. Trying to get people to make minor updates b/c the script works in the test environment is worse than pulling teeth. 2) I don't want to run the script twice. I'll have to response to this when I get back to work tomorrow. What I remember is that import allows for the script to know if the class was present, and then the execfile to be able to parse the contents of the class. If I could do it all with one call or the other, I'd be over the moon.
This is /r/Python, so good luck getting an unbiased opinion. :P Maybe go ask in C#, too. There is Python the language, and there are the different interpreters/compilers that turn the language into machine code that actually executes (cPython, cython, Jython, IPython, etc). Two very different things. The language alone has little to do with speed (look at javascript 10 years ago, and now with the latest engines, same deal). But, I wouldn't hesitate to use C# for a stand alone GUI, that's basically what it was designed for. It'll be a drag and drop breeze to get the main GUI up, and everything you need will be in the standard library. Performance wise, C# will be *much* faster than cPython (it wasn't designed for performance), and most likely abit faster than anything but cython. But, this might not matter with low fps animations. You should consider the personal value of your experience too. If you put this on a resume, will you impress people more with a Python GUI or C# GUI? (I don't know the answer to that). Might be worth learning GUI design with Python and QT since you could run it anywhere. The biggest use case of Python is back end and glue for faster code, or general scripting. You wont find as much graphical GUI photo editing type stuff. Source: I use Python professionally for GUI and web back ends (cause fu python guis, might as well make a website). I've used C# professionally in the past for GUI and image processing. edit: And cPython doesn't have concurrent threading...stupid GIL.
I think it may be beneficial for the beginners to start off using the basic csv library in python's std lib. I did when I started writing python and some of the processing I was doing on CSV files was getting out of hand... like hundreds of lines of opening up CSV withs and reading them into lists of lists, sorting, doing some processing and then spitting files out. I had heard of pandas but never gave it a try, one of my co-workers showed me how to do some simple stuff in pandas and also encouraged me to consider using dictionaries instead of forcing everything into lists or lists of lists. After about 10 minutes with pandas I saw how some 10 / 20 line functions would get shortened to 4 lines using pandas. Also there is a speedup (if properly vectorized) using pandas and numpy. Here is a sample of code that is operating on some theoretical time series data showing how much percent pwnage I dish out every day. import pandas as pd # csv looks like # date, pct_pwnage # 2015-04-04, 100 # 2015-04-05, 100 # 2015-04-06, 110 # etc df = pd.read_csv('hey_ninnyninny_this_be_my.csv') print df.columns # gives you the columns print df.columns.tolist() # gives you the columns as python list print df.head() # print first 5 rows print df.head(14) # print first 14 rows print df.tail() # print last 5 rows for col in df.columns.tolist(): print 'hey look at me I found column {}'.format(col) # lets find all rows where my ownage exceeded 100% ownage = df[ df['pct_pwnage'] &gt; 100 ] # write out subset dataframe to file # make sure to add index=False option otherwise CSV will # output with an index column which we dont want! # feel free to try it without the flag just to see, you won't like it =) ownage.to_csv('my_pwnage_data.csv', index=False) Here's my final two cents, learn with CSV python library first, use it, push to limits and realize you are limited, learn pandas and numpy, start pwning noobs. 
This is awesome.
I really like obiwan, but going by its github page I think it's quite unknown to the general Python public.
Keep in mind that using an actual checker decorator like that one imposes a substantial runtime overhead. I think someone benchmarked it a while back for some fairly simple functions and it was something like 30-40x. A special one for annotation wouldn't be a bad idea though.
~~~For cPython, but the likes of PyPy and all the other JIT compilers being developed (including an LLVM one that I'm especially excited about) will be able to use it *immediately*.~~ If you're using cPython, you don't care about performance anyways. You'll literally get better with Javascript in your browser! Edit: PyPy is too smart! I guess it would only [benefit cython](http://docs.cython.org/src/quickstart/cythonize.html)!
SPI Flash memory? 
i see, [this](http://stackoverflow.com/questions/11247934/f2py-prevent-array-reordering) explains more. it would be best to have these in fortran order from the beginning i think, i don't mix ordering honestly.
Yes, together `__enter__` and `__exit__` allow this. I liken the behavior similar to operator overloading in C++ if you have any experience doing that.
That interesting -- is there a python-ideas thread about those planned changes? Would love to see that. And would those changes really fundamentally depart from the function annotation based approach in PEP 484?
The best way (that I know of) is to put the processing in a different thread to the gui. I won't try to explain how to do it because my poor explanation would probably do more harm than good but this should help get you started http://www.tutorialspoint.com/python/python_multithreading.htm https://docs.python.org/2/library/threading.html
I can't imagine that the update would be manual. PyCharm can already parse your existing notation, the new notation is defined, you're done.
&gt; That interesting -- is there a python-ideas thread about those planned changes? No idea. I saw it in Guido's pycon video the other day. https://www.youtube.com/watch?v=2wDvzy6Hgxg &gt; And would those changes really fundamentally depart from the function annotation based approach in PEP 484? Not really. My understanding is you swap out `List` for `list`, but everything else is the same. It's not done and maybe it won't be done, but it might.
For a while, I've been cooking up my own scrapers with requests and beautifulsoup/lxml. This looks like a great abstraction! I appreciate the support for both XPath and CSS selectors. (I feel bad for not knowing about any of the [existing systems](http://scrapple.readthedocs.org/en/latest/intro/existing.html) you review either.)
https://pypy.readthedocs.org/en/latest/faq.html#would-type-annotations-help-pypy-s-performance &gt; As PyPy works right now, it is able to derive far more useful information than can ever be given by PEP 484, and it works automatically. As far as we know, this is true even if we would add other techniques to PyPy, like a fast first-pass JIT.
PEP8 onto thyself, not onto others. I love that one. 
Flask is quick and easy but does not have batteries included meaning you will have to implement many features yourself. With this being said many a extension exists for flask to do most things required. django is a juggernaut that has most batteries already included and lots of nice lil pre packaged solutions but with this comes some complexities and nuances that are unique to django itself. I personally prefer Flask
Definitely Flask, it's great for learning. 
Tests also provide a means of collaboration and reasoning about a new feature or bug fix. If someone wants a feature or a bug fixed, the first step might be to add a test that demonstrates the desired functionality, or demonstrates the bug...(the new test initially fails, because the software doesn't meet this new requirement yet) then someone else can write the actual code that implements the feature/fix to make the test pass. This is a collaborative version of Test Driven Development.
I always at the very least log the traceback of the "unimportant" exception. This can be accomplished with: import traceback try: x = [0, 1, 2] y = x[4] except Exception as e: traceback.print_exc() #or if using loggers logger.exception('oops') edit: finished my comment... 
It sounds like his script is meant to be called as more of a shell tool than a Python module, in which case installation into a users Lib/site-packages is fine, but also adding a script to PythonFolder/Scripts might be a good practice... kinda like pip and other Python based command line tools.
I agree... if you're going to demonstrate pro's and con's of numpy vs. standard library alternatives, one should at least use the best possible alternative... (such as the statistics library that you mentioned)... the use of sorted instead of min/max further demonstrates that this isn't a fair comparison.
Actually, what did framework you use for your presentation? Obviously html, but was there software you used to put the hand-drawing stuff together?
How does it relate to scrapy ?
Scrapy requires a user to create classes for spiders, items, selectors etc. Scrapple abstracts this process, and avoids the need to directly write a program. Scrapple is based on the ideas of two projects - Ducky (which is a research project) and Scrapy. Ducky uses key-value based config files to build simple extractors, but supports only CSS selectors. Scrapple improves on the idea of Ducky, by providing support for multiple selector types (XPath and CSS), like Scrapy.
Going to second the requests library suggestion. http://docs.python-requests.org/en/latest/ In general, a lot of this kind of work can be done using Chrome/YourFavoriteBrowser's developer tools. See exactly what HTTP requests your browser is making, and then make them yourself. Usually you have to auth and get a session cookie, and then use that cookie in each of your future requests. A request "Session" object handles this for you. Your code, in requests (using a session): import requests uva_auth = ('username', 'password') response = requests.get('http://ww4.uva.br/UniversusNet/NotasFatalasTotais.aspx', auth=uva_auth) print response.content
Yeah...you're using the wrong tool. Use docopt. It's not painful. http://docopt.org/
what is your hardware interface? did you plug an SPI device into your computer speakers? Your question makes no sense.
Unless you're using `send` (which I've _never_ seen anyone use for anything useful), `yield from x` is exactly equivalent to `for tmp in x: yield tmp`, and while it does look prettier, I wouldn't say it really fixes some deficit.
If you can't trust the comments, why do you have them? :P
I've used it, and not in a toy project. I am sure when imaginary numbers were invented, the usefulness of those weren't immediately obvious. But let's not digress this conversation by using anecdotes.
thx ! it was dum of me not to check the bottom of the page
Python 3 is more than 6 year old now. The fact there is still this kind of debate prove they made a mistake by breaking the compatibility while manifestly not giving sufficient improvement to motivate people to overcome the difficulty to pass to python 3. Maybe if they would have managed to greatly improve the speed or provided an easy way to use it in browser as a replacement of javascript (if it's possible), most would have passed to python 3 by now.
please delete this submission then.
Would love to read some feedback.
I'm not claiming obiwan is prefect, just that the general idea behind it, of using what looks like existing python syntax, is imo much better. I'm sure the Lambda keyword or - &gt; syntax could be used in a sensible way.
Good points! I will have some refactoring to do soon :). Thanks for taking the time to look at it! 
Yeah, /u/DDVDA gave me a class on testing in another comment here. I'll work on that and get some testing scripts up. Thanks for the heads up!
First of all, thanks a lot for checking my code out! 1 - Good point! 2 - I'm doing it that way to be able to compare objects based on their main attribute (.domain or .ips). If I use hash(self) == hash(other), the script won't properly know how to test for similar objects in a set for example. 3 - Very good point, I was basically being unnecessarily verbose :) Will issue a fix soon! Thanks again.
I think both too :) for that I suggest to try ImportD: http://importd.readthedocs.org/en/latest/ which is pure Django, but with instant setup like in Flask !
No, I agree, but there's no *good* solution for this. And we're probably saddled with this eyesore for a *long* time because function annotations have been around since...3.0 I think, actually. Frankly, I'd find myself using decorators if and when I *really* need to annotate functions. Which makes that actually kinda like Haskell, but not really. Maybe something like this on the surface: @annotate(x=int, y=int, returns=int) def mysum(x, y): return x+y You could just dump whatever kwargs appear in the decorator into `__annotations__`, or you could do an all or nothing check. from functools import partial, wraps import inspect def kwargs_decorator(deco): @wraps(deco) def wrapper(func=None, **kwargs): if func is None: return partial(wrapper, **kwargs) return deco(func, **kwargs) return wrapper @kwargs_decorator def annotate(wrapped_function, **kwargs): argspec = inspect.getargspec(wrapped_function) # or use itertools.chain, same result if set(list(argspec.args) + [argspec.varargs] + [argspec.keywords] + ['returns']) ^ kwargs.keys(): raise TypeError("All or nothing type annotations.") else: wrapped_function.__annotations__ = kwargs return wrapped_function @annotate(x=int, y=int, thing=list, flags=dict, returns=int) def f(x, y=1, *thing, **flags): pass f.__annotations__ {'flags': dict, 'returns': int, 'thing': list, 'x': int, 'y': int} Note that I wrote this in 3.4, where inspect.getargspec is deprecated and inspect.fullargspec and inspect.Signature are preferred but were never backported to 2.X and Signature was added in 3.3. 
I agree with the semi-standard advice; use python3 unless you have a *specific* reason to use python2, like the need to use a library that only supports it. In practice, for a new user, this is almost certainly not important and you can just use python3.
This list is missing many of the best talks about actually learning python. Better title would be "A Roadmap to Learning About Analytics in Python." 
&gt; If you speak any language *including* English, Python 2 is woefully deficient in that area. (FTFY) Let's not be naïve about the use of “unicode” characters‒be they text or punctuation‒in normal English text. 
I've heard that there is slow movement towards argparse, but optparse is still the prominent method. 
That's great, don't forget about `.format_map(locals())` for that!
As you get more comfortable programming, the language you are using starts to matter less. I actually think learning several languages built around different paradigms is a great way to really understand how to program. I'll use Python 3 unless there is a compelling reason to stick with the previous version. That being said, I have projects in Python 2 as well for specific libraries.
Nope. Parts of Python 2's Unicode handling were fundamentally broken- silently failing and corrupting data, so that when an exception was finally raised, it was far far away from the source of the error. A backwards incompatible change was the only way. http://python-notes.curiousefficiency.org/en/latest/python3/binary_protocols.html
I think it depends on the way you want to learn. Many people suggest Flask as simpler and Django as more complex. I went through some Flask tutorials at first and felt that I wasn't learning what I was doing but just creating whatever the tutorial was building. Django took a bit longer to get through but I feel that I can explain what I have created. It was also easier to convert my idea into a (somewhat) final product. 
I'll look into subprocess. Thanks!
the truncation example: '{:5.5}'.format('xylophone') is a bit vague. there's two 5s there...which one does the truncation? Both? if I wanted to truncate to 6 characters would I do `{:6.6}`? The kinds of things a newcomer would wonder about, I think. It might be more clear to have an example like this: '{:20.5}'.format('xylophone') so that you can clearly see that the first # is padding and the # after the dot is truncating. Or if you don't want to combine concepts just this: '{:.5}'.format('xylophone') Just my two cents...I'm definitely bookmarking this page as a handy cheat-sheet! --- edit: same thing is done in the number truncating example: '{:2.2f}'.format(3.141592653589793) why put the first 2 in there at all if you're just showing how to do truncation?
Good points, thanks! We'll definitely going to improve on those points.
Django is more feature-rich than Flask and has a huge ecosystem of apps which can really boost your productivity once you become comfortable with it. Having said that, it does have a learning curve. If you're new to web dev, it will much easier to get started with Flask.
Python3 in production, all the way. It's not worth the hassle of python2 compat unless you have real and serious reason. working text support and improved standard library are golden.
Thanks! Funnily enough thats exactly what I'm typing up at the moment :)
Thank you! I've updated these two examples. They are (hopefully) far less confusing now :-)
If the main argument is "Python is not fast enough", why don't we make python faster? I've heard sometimes that every respected language is self-hosted, that is, the interpreter/compiler is written in the language itself. It baffles me that CPython is still the reference implementation, after twenty years of the language and after a major version, and not something like Pypy
That is Python 2.7. Its goal was to ease movement to Python 3 by backporting as much stuff as possible (without breaking compatibility with Python 2.6). The bigger challenge with Python 3 is that many modules and packages people care about have yet to be migrated to Python 3.
yeah, much better!
Ignoring the greater issue for a minute, you can simplify your regular expressions a bunch by using case-insensitivity. https://docs.python.org/2/library/re.html#re.I That aside, this adage comes to mind: "I tried to solve a parsing problem with regular expressions and now I have two problems." Postal addresses are not *regular*, i.e., they aren't expressions of a regular language and thus cannot (reliably) be parsed with regular expressions. Here's a detailed treatment of the problem on Stack Overflow: http://stackoverflow.com/questions/11160192/how-to-parse-freeform-street-postal-address-out-of-text-and-into-components What you have appears to work for fairly well-formed input but you'll find it breaks down pretty badly on various corner cases and "dirty" inputs. If it works for the cases you're throwing at and you're satisfied with its performance, then good on you. However, for this to be a robust library the Python community would consume, you need to consider a radically different approach.
Damnit I will add that thank you!
It's people like you that make this community awesome
Touché
This is a cool program, but what if you need to access services from other computers? Are the only options to either memorize a string of characters or bring a flash drive with this program on it? As a solution to this issue, you could consider adapting the program so that instead of using the hash value directly, it instead uses the hash to select words from a database. The SHA256 hash returns 256 bits, which you could use to generate sixteen 16-bit integers. If you had a database with 2^16 words, you could then use those integers as keys for that database, allowing you to select up to sixteen words that are used in the password. At the expense of some security, you could just select three or four words, which still gives 2^48 or 2^64 different password possibilities. (If the use of this system is secret, the search space is even larger, though of course it is bad practice to assume such a scenario). To illustrate what I mean: password = input("Please enter your password:") website = input("Please enter the website:") username = input("Please enter the username:") key = (password + website + username).encode() n = hashlib.sha256(key).digest() n = int.from_bytes(n, 'big') words = [] while (n &gt;= len(database)): index = n % len(database) n = n // len(database) words.append(database[index])
Yeah, you need that boilerplate in every single file, which is awful
At the time of this writing you have another bug! Line 14: ...`**5` should be ...`**.5`, you lost the decimal point. For square roots, I personally prefer to `import math` and use `math.sqrt()`. In my opinion it makes the intentions of the calculation more clear, and you are less likely to make the typo you just made.
That's why we put up this site, because many developers don't know all of the features that are available. As for whether calling `.strftime` is "better" - I'd say no because it hides the date format in the parameter list rather than where the rest of the formatting is happening. Of course if you just need a formatted date outside of a string formatting operation there is nothing wrong with using strftime.
Thanks! Glad to hear it!
Well, what I meant was that a string of four common words was much easier to remember, so you wouldn't need to bring the database with you. You would use the program as it is now, but if you do need to go somewhere else (maybe somewhere without python installed), you can just remember 3 or 4 common words.
&gt; I've heard sometimes that every respected language is self-hosted, that is, the interpreter/compiler is written in the language itself. I've never heard this, tbh. Almost always the core of the language is written in something (C/C++) that compiles directly to the target architecture, with large parts of the language's modules written in the language itself. Lua and Emacs Lisp are other examples of this pattern. Even PyPy is written in RPython, which is a subset of PyPy designed to compile into C.
This subreddit is not really what you're looking for please check out /r/learnpython for basic questions regarding learning to program with python That being said - there's nothing wrong with using many variables in general if they each serve a purpose. However in your code I see many area where you could combine variables together - for instance your could get rid of one variable num3 or num4 by combining those two expressions: new_var = math.factorial(R) * math.factorial(N-R) this combines the calculations for num3 and num4 if you don't ever need num3 again except for the calculation you store in num4 there's no reason to have it be stored as a separate variable -does that make sense? 
That was what I was suggesting, yes. Though having the same entropy is difficult, and I think it would be safe to sacrifice some entropy. Say, a list of 2^16 words of 4-8 characters each, which would only require about 65 KB to store. If you used just 4 words per password, that would still be 2^64 (about 1.8 * 10^19) possibilities, which is more than sufficient in my opinion.
Problems I ran into were fixed following these 2 pages: http://www.marinamele.com/from-a-python-script-to-a-portable-mac-application-with-py2app https://bitbucket.org/ronaldoussoren/py2app/issue/137/py2app-problems-using-enthought-python
As a note, the standalone for PyDev would be LiClipse http://liclipse.com (and not IntelliJ) -- which was updated at the same time.
This is great. Kudos and thank you for continuing to improve an already excellent tool.
Yeah, it's a bit too much for a Python conference. But I guess if you need some portion of your program to go really fast and you would like to make use of multiple cores, it seems Rust is "more friendly" alternative to C in that it's much harder to screw up (w.r.t. memory management and threads). The only ugliness/unsafety left is the border between Python and Rust which has to be "C-compatible". But maybe someone will step up and provide some generic glue code that makes things pretty again – even at the border.
that would require the word list to be secret (at least thats my understanding of your suggestions) electrum randomizes as number and converts it to base 2048 (which is the word count in their dictionary) 1 =&gt; first_word 2 =&gt; second_word ... I could add a word list of any length and convert the generated password (long word lists result in less words required than short lists)
Really great page. I'm a long-time (&gt;15yrs) python programmer who, embarrassingly, still hasn't made the move to the new style string formatting. This has definitely pushed me several steps closer to making the switch.
+1
Now I'm pretty sure we want the same thing Do you have any experience regarding whether websites will accept such passwords? (needs lower- and upper-case letters, needs a number, needs a special character) I guess passwords consisting solely of words would be rejected by most websites (I could append something like "aA8!" to every word list, tho)
Thanks! It's now at #2 but maybe it'll rebound...
Good resource, but its missing thousand seperators imo.
Can someone help me out, I'm looking for a way to check what numbers a string contains and then return the number(s). I found a lot of way to check if they contain a number (just returning true or false), but not how i should get those numbers returned. Also the string will be containing letters as well but now it's just the numbers I want returned. 
Nice! But the only difference in 3.4 is auto-enable AFAICT. Otherwise, this already works in any version of Python going back to at least 2.3 with the following in ``.pythonrc``: import readline import rlcompleter readline.parse_and_bind('tab: complete') And while I'm at it, it works with pdb too via the following in your ``.pdbrc``: import rlcompleter pdb.Pdb.complete = rlcompleter.Completer(locals()).complete 
Follow the tutorials and go out for a big steak instead. The documentation is really all that you need. Scikit-learn is one of those ridiculously easy to learn libraries Python is so famous for. (This is assuming you already have some core competency in machine learning. If not, your money and time might be better spent gaining that.)
I thought it was a tool to automatically extract data from the web like diffbot does.
I don't think you quite follow. Optparse is used to parse command line arguments. You write some code that sets options and it makes a pretty command line thing. With docopt, you write the pretty command line thing and it figures out based on the POSIX standard what options you set. It's easier because you don't need to worry about what options to use; you just write the printout. As an added bonus, it looks exactly like you want it to.
 your_string = 'hell0 world4' numbers = [] for char in your_string: if char.isdigit(): numbers.append(int(char)): #numbers = [0,4] You're welcome
The main problem with Python 3 for me is the new docs style. They are basically less readable than Python 2 docs.
https://github.com/jhermann/priscilla/tree/master/pyenv if you need it pre-packaged (for DEB-based distros).
I actually learned something in those 25ish minutes. I had no idea about bloom filters but those things are pretty clever, and I like clever things! Great talk dude!
Or use Anaconda and leave all this complexity far, far behind.
Today I learned about `.pythonrc`. Cheers!
I just use [IPython](http://ipython.org/).
I use PyCharm because it brings me a lot of useful insights/shortcuts/features e.g. auto completion, repository manager, coding style, etc...
David Beazley did a talk?!! It's 2:30 am but I gotta watch this.. Shit! Whatever!! David Beazley!!!!
you could also do that as a list comprehension: your_string = 'hell0 world4' numbers = [int(char) for char in your_string if char.isdigit()] # numbers = [0, 4]
Shortcuts are a big one, also being able to create more at your will. Thank you for your input.
Thank you for your response!
Pycharm does some impressive amount of static analysis for a dynamic language, and it's syntax highlighting is pretty nice. (I find vim doesn't differentiate tokens enough for me, compared to ruby code)
You shouldn't need transitive dependencies on your requirements file, because: * Your project depends on A and not on B that depends on A. * If A updates B version in his requirements, it must issue a new version, if you keep every transitive dependency, you would have to update both dependencies (however just A project owner knows why B is being updated). * If A decides that no B dependency is needed anymore, that he can roll his own solution for what B was suppling, then A new version must be issued, if you keep every transitive dependency, when updating your A version you would have to check if A dependencies changed and remove from your requirements manually. Usually you only depend on what you depend.
There will not be simple examples, because the whole async mechanism in Python is badly designed and overcomplicated. Examples in docs are as simple as they can be. Compare them to C# or Dart async/await: https://msdn.microsoft.com/en-us/library/hh191443.aspx?cs-save-lang=1&amp;cs-lang=csharp#code-snippet-1 https://www.dartlang.org/articles/await-async/
I posted last week: http://www.giantflyingsaucer.com/blog/?p=5557 
- You can use tuple unpacking when dealing with things that return sequences: basename, ext = os.path.splitext(path) - You've got the expression `os.path.join(root, filename)` repeated in several places; try doing that just once in a common location. - Modifying `dirs` when using `topdown=False` doesn't have any effect, because the list of directories has already been visited by that point and it's too late to prune them from the list. - Consider only writing out a new file if there was actually a change made, which will probably save some IO. - Instead of multiple checks for `replaceall.py` (which I assume is the name of this script?) scattered all over the place, do that once: for root, dirs, filenames in os.walk(...): for filename in filenames: if filename == 'replaceall.py': continue ... - Instead of doing two passes, you should combine the directory renaming into the same pass. You just have to edit `dirs` to reflect the new names. And of course you'll need to lose `topdown=False`. 
Thanks for the (awesome) explanation, I will have to write some tests right away!
Will definitely give it a go!
Excellent article, practical and clear examples. Thanks!
Thank you so much for the reply! &gt;You can use tuple unpacking when dealing with things that return sequences: Great shortcut! &gt;You've got the expression `os.path.join(root, filename)` repeated in several places; try doing that just once in a common location. Moved to top of loop, but only used in one place anyways. &gt;Modifying dirs when using `topdown=False` doesn't have any effect, because the list of directories has already been visited by that point and it's too late to prune them from the list. &gt;Instead of doing two passes, you should combine the directory renaming into the same pass. You just have to edit dirs to reflect the new names. And of course you'll need to lose `topdown=False` When I wasn't using `topdown=False` the function wasn't finding all the directories. I'm not sure what I was doing wrong since now it seems to work. How's this look? Is there another way to update the dirs list rather than a list comprehension? Seems like overkill. import os directory = 'D:\\Dropbox\\www\\boilerplates\\testdir' find = "foobar" replace = "foobar" # walk through the directory from bottom up for root, dirs, filenames in os.walk(directory): print dirs dirs[:] = [d for d in dirs if d != '.git'] # skip .git dirs for filename in filenames: path1 = os.path.join(root, filename) if filename != "renameall2.py": # name of the script. Don't change yourself! # search and replace within files themselves filepath = os.path.join(root, filename) with open(filepath) as f: fileContents = f.read() newContents = fileContents.replace(find, replace) if (newContents != fileContents): with open(filepath, "w") as f: f.write(newContents) # rename files (ignoring file extensions) filename_zero, extension = os.path.splitext(filename) if find in filename_zero: path2 = os.path.join(root, filename_zero.replace(find, replace) + extension) os.rename(path1, path2) #print "file: " + path1 + " renamed to: " + path2 for thedir in dirs: if find in thedir: newdir = thedir.replace(find, replace) path1 = os.path.join(root, thedir) path2 = os.path.join(root, newdir) os.rename(path1, path2) dirs = [d.replace(thedir, newdir) for d in dirs] #update the dirs list #print "dir: " + path1 + " renamed to: " + path2 
Sublime Text 3 with Anaconda is my choice. All the purdy colors.
&gt; Is there another way to update the dirs list rather than a list comprehension? How about: if '.git' in dirs: dirs.remove('.git') or: try: dirs.remove('.git') except ValueError: pass or: try: del dirs[dirs.index('.git')] except ValueError: pass Personally I think the latter two are rather clunky in the looks department. Technically the first one has to search the list twice, so it's not the greatest from an algorithmic standpoint, but the difference is likely negligible, and it reads the best.
I often point people to: https://scipy-lectures.github.io/
Gotcha, will try to improve it and integrate with pip. If I can get it in the Python path like /u/flutefreak7 said, then even better.
AttributeError: can't set attribute
Why does Google Chrome have to roll out the worst fucking GUI for bookmarks the day everyone posts me links :(
Josh would you be interested in getting paid for tutoring. An hour a week or so? I knwo R and to make the most of my time need to learn how to feed certain arguments into my classifiers, basically I have a csv, and after I load it I might need you to teach me how to make that list into a readable dictionary for the classifier. You don't need to know machine learning for this.
The author's use of the term "hashing" to turn, e.g. `cat` into `act`, seems dubious and misleading. This process isn't a hash at all. The use of the term "normalization" at the end of the document seems like a better fit. The approach *does* make use of a hashtable (and thus, gives you **O**(1) amortized lookups) *but not because of the normalization of the words*, rather because python dictionaries, and by extension, `ordereddict`s, are implemented using hashtables. That being said, the `zip(normalized, words)` approach at the end is very elegant. 
Incase it got missed, please share a few links so that I don't miss out on them ! Thanks.
There is also bpython, which is pretty cool: http://bpython-interpreter.org/
They've tried to make Javascript faster, but eventually you run into a wall. That's why Mozilla made asm.js - because even after millions of dollars that Google put into making JS faster they still didn't get C performance out of it until you actually use C semantics. What chance does Python have?
I think whoever needs one of the abandoned pypi package in their Python 3 workflow will have to bite the bullet and do the conversion. Can't wait for getting in touch with the original developer. When the developer finally wakes up and realizes his project's Python 3 port is more popular than his own code, he should be welcome to get involved. P.S.: I had a grueling few days porting pysparse to Python 3, mostly because this was my first time working with a C extension and I learned a lot. I should now figure out how to package it and upload on pypi.
Really? *Everything* you ever wanted to know? Maybe if you have ultimate control over all of the strings in your app but... ### hellllp mééééé! --- &gt;&gt;&gt; input_s = 'm\xc3\xa9\xc3\xa9\xc3\xa9\xc3\xa9\xc3\xa9!' &gt;&gt;&gt; input_u = u'm\xe9\xe9\xe9\xe9\xe9!' This doesn't look like standard ASCII English! Who the hell doesn't speak standard ASCII English? Why are they putting this garbledigook into my pristine app? Dammit, ok, let's see... &gt;&gt;&gt; template_s = 'hellllp {}' &gt;&gt;&gt; template_s.format(input_s) 'hellllp m\xc3\xa9\xc3\xa9\xc3\xa9\xc3\xa9\xc3\xa9!' Sweet, that worked... &gt;&gt;&gt; template_s.format(input_u) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; UnicodeEncodeError: 'ascii' codec can't encode characters in position 1-5: ordinal not in range(128) Shit, you bastards! Ok, lemme try unicode... &gt;&gt;&gt; template_u = u'hellllp {}' &gt;&gt;&gt; template_u.format(input_u) u'hellllp m\xe9\xe9\xe9\xe9\xe9!' Sweet! That worked... &gt;&gt;&gt; template_u.format(input_s) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 1: ordinal not in range(128) Fuckfuckfuck, doesn't **uni**code mean it can handle everything **uni**versally? This shit's broken. Lemme ask my buddy how to fix it... &gt;&gt;&gt; def uformat(format_string, *args, **kwargs): ... unify = lambda s: s if isinstance(s, unicode) else s.decode('utf8') ... format_string = unify(format_string) ... args = [unify(s) for s in args] ... kwargs = {k: unify(v) for k, v in kwargs.iteritems()} ... return format_string.format(*args, **kwargs) ...what? Ok, if you say so, whatever, lemme try it... &gt;&gt;&gt; uformat(template_s, input_s) u'hellllp m\xe9\xe9\xe9\xe9\xe9!' &gt;&gt;&gt; uformat(template_s, input_u) u'hellllp m\xe9\xe9\xe9\xe9\xe9!' &gt;&gt;&gt; uformat(template_u, input_u) u'hellllp m\xe9\xe9\xe9\xe9\xe9!' &gt;&gt;&gt; uformat(template_u, input_s) u'hellllp m\xe9\xe9\xe9\xe9\xe9!' Awwwww yissssssss! Note: Even this won't work universally, and also this is Python 2.7 so you'd have to do things differently in Python 3. Also, what about `join()` or `'' + u''` and other string operations? Working with strings isn't always as easy as it seems. (Don't even get me started on working with time...) さようなら！！！
Have an upvote. You're right. Asyncio is a PITA to grok and the documentation is horrible. Other languages do it so much better. 
Killer? Hmm, I _really_ like the improved iterators in the standard library, and type annotations as well. Plenty of our code starts with a block of lines of `assert issinstance(input, class)`. Along with mock in the standard library, and some other "nice to have" features, I agree. There are no single "killer features" ( well, yield from ?) that convinces many. 
True but I assume he probably doesn't know list comprehensions if he's asking such a basic question, otherwise I would definitely do it that way too!
No problem ;D
I made the switch very recently. I really pushed hard against using it because %s is just so damn easy to type and the tuple/dict thing makes it so easy to do pretty much anything, and you don't have to type `format`. But now, it's great. Being able to mix the order up in the string without changing the order of the tuple is awesome. And there's still `**dict` if I want to go that route, and I do a lot. I personally prefer it now because it's easier to see what's going on. %s might be easy to type but it's easy to miss too.
what about using a debugger ?
I had to use this on OS X, otherwise it would just insert regular tabs. readline.parse_and_bind('bind ^I rl_complete')
Also export PYTHONSTARTUP="$HOME/.pythonrc"
I watched most of these when they appeared on the official youtube channel, but I was a bit surprised how often the speeches have intersections regarding the topics and how simple the tutorials are kept. I enjoyed the shorter presentations (30-45min talks) a lot more than the 3 hour tutorials. Of course the latter are aimed at the on-site participants. Don't get me wrong, the tutorials are also really great as an online learning source, but very often they showed simple operations. For example creating a pandas dataframe, selecting data, simple aggregation... nothing fancy. Staying with that example, I'd really like to see at least some time series/index usage, perhaps with interpolation and aggregation. Personally I just started using Python a few months ago for some simple machine learning applications.
I absolutely agree. These are the main reasons I use Pycharm. Also it is one of the few IDEs actually providing a working "dark theme" for my OS, which goes easy on my eyes during the late hours. About the features... as a beginner, I don't want to look up the name of every function in the online documentation, if I know it from other languages, so the auto completion helps a lot. The only thing that bugs me is that I can't have different projects open at the same time. Again, as a beginner, it is sometimes neat to just open a file from another project and check "How did I do this again?" - or maybe there is even a way for that, I didn't explore that much yet. Edit: Also the PEP8 compliance hints are a big plus to get used to a good code style.
Check out his second bit on types: https://www.youtube.com/watch?v=2wDvzy6Hgxg
That worked. THANKS
Would love if you could elaborate here. I don't see how other languages are much different from how python solves the async stuff except from inventing new keywords. Instead of the introduction of a new `await` keyword you can reuse the versatile `yield from` idiom. Instead of the `async` keyword you simply annotate the function with `asyncio.coroutine`. So where is the difference except from that other languages had to adapt their syntax while Python can elegantly reuse already available generator features?
* vi keybindings * available on every system by default * also available for odd systems you come across from time to time, like Windows * doesn't need an 8-way 4Ghz processor with 128Gb of ram and 4x 4Gb SLI video cards, with RAID10 SSD's to run really slowly * Extensible * supports editing any text, not just a few chosen languages, most of which are irrelevant (like Java and .WHATEVER) * runs great in tmux instead of drawing its primary window on top of more important stuff like the terminal * starts up in three keystrokes... v i &lt;enter&gt; 
Similarly, you can add [history storage](https://docs.python.org/2/tutorial/interactive.html): historyPath = os.path.expanduser("~/.pyhistory") def save_history(historyPath=historyPath): readline.write_history_file(historyPath) if os.path.exists(historyPath): readline.read_history_file(historyPath) atexit.register(save_history)
The thing is that A shouldn't have pins for B and lots of the time B is not in the control of A, so breakage can occur.
I have c and C# too. But without actually something to aim for. I wouldnt know what to design/do
Well I'm in engineering. I'm trying to pick up as much as I can while on work placement. I don't know enough to be able to do something important or major, but something that can keep me on my toes with it all, is all I'm really looking for. 
Thanks. For me (on OS X) it works with aclark's pythonrc and your addition to my ~/.bash_profile.
If your main development language is python, then sure. If you're a hobbyist or just want to smash out a small script to help you with something, odds are you aren't using any of those tools.
This is my .pythonrc: $ cat .pyrc # encoding: utf-8 import sys try: import readline import rlcompleter readline.parse_and_bind("tab: complete") readline.read_history_file('/home/robin/.pyhist') import atexit atexit.register(readline.write_history_file, '/home/robin/.pyhist') print('(tab completion loaded)') except Exception as e: print("(tab completion not loaded)") raise #sys.ps1 = '\033[34;1m┓\033[0m ' #sys.ps2 = '\033[34;1m┃\033[0m ' #sys.ps1 = '\033[31;1m▸\033[0m ' #sys.ps2 = '\033[31;1m▾\033[0m ' Having a history file is really useful. (Also, you can see I had a "wacky prompt" phase.)
Amazing thanks so much, you're a trooper! Seems like everything python dev related becomes more difficult on a mac eh?
Great explanation.
What was the topic exactly ? they almost don't talk about python.
The tab width changes based on the reader, spaces don't. x = [ 1, 2, 3 ] Would probably get messed up in some editors with tabs, but not with spaces.
You can rename git repositories right? Just call it something. I called my stuff `ezcsv` and `Automaton` and shit. I don't think it's that important until people start using it.
It seems like the main issues involve getting women involved which is great. More diversity would be fantastic.
If the owner doesn't care about the package or its porting, it is very, very unlikely he will try to ask others about porting. He might not even know about open source at all. He might have just wanted to put his code on github to show other people that he's there. Mailing the owners, forking their projects, convincing others to use the Py3 fork, etc by other people who are more engaged in porting to Python3, that's what needs to happen more.
Moving Python2 projects to Python3 is very important now that they don't want to continue Python2 any more. There might not be any more important topic for the health of the community and language core.
I hate the iPython prompt, so I'm still using the regular python repl... and this is great!
That sadly doesn't work. Just tried it in Python 2.7: tab is still inserted.
 for i in range (0, data_len): labels_high += self.set[i].atts[num_atts - 1] Come on.... You're using Python, not Fortran. You can write this code in much better ways which make it less fragile. For example, the code above needs data_len and num_atts to be set to the right values or you will get IndexErrors. Changing it to avoid these makes the code more robust and easier to read. for item in self.set: # Use iterators not indexes labels_high += item.atts[-1] # Negative indices to get at the end of a sequence or even labels_high = sum(item.atts[-1] for item in self.set) Watch Raymond Hettinger at [PyCon 2013](https://www.youtube.com/watch?v=OSGv2VnC0go) &amp; [PyCon 2015](https://www.youtube.com/watch?v=wf-BqAjZb8M) for a true expert explaining why pythonic code is not just a style thing. Edit: I admit, I'm assuming that data_len is len(self.set), num_atts is the length of the atts sequence, and labels_high initially equals zero, but considering they weren't given I think those are fair.
I am seriously uncomfortable about this undying push for diversity. Yes, diversity is cool, and I have no issue at all with any "uncommon" person contributing to projects, but this push is just weird. Frankly, the most insulting statement is that diversity somehow improves the quality of the project and introduces us to completely new ways of thinking about stuff. That's not how it works. A woman doesn't have magical unique view skills, and a man is completely capable of having unique views himself. Diversity *can* improve a project, but that's diversity of skillset and technical background, not whether someone happens to have a different skin tone or has a different set of chromosomes. As a woman, the thing that makes me most uncomfortable is the idea of tokenism. "We don't have enough female devs! Hire them!" And so, women are recruited into positions simply because they're "diverse", not necessarily because they're good. And how would it feel being a woman and being accepted into a team or project, not knowing whether you were accepted because you are a capable human being, or just to fill some diversity quota? It feels fucking terrible. I'd love more diversity, but I strongly disagree about this blind approach for equity. And of course there is some work to be done with regard to hostility towards minority groups in programming, but I don't believe that positive discrimination is the right way.
I did some cleaning up: https://gist.github.com/gvx/0e52c57d8bcd087cc35c It could be cleaned up even further, but I've tried to mostly preserve the behaviour and at one point I got bored and stopped.
Many of my favorite keynotes and talks are those that discuss the broader topics involving the culture among Python enthusiasts and the broader culture in the tech industry. Many members of the Python community have stated in the past that it is the appeal of the community that has kept them involved in Python, not the language or the programming itself. The reason I watch pycon videos and come to reddit is on order to experience and participate in Python's culture, which I'm proud to be a part of. I think discussing the healthiness of our culture, the future of our language and the community of those who enjoy it, and addressing the symptoms of unhealthy aspects of our culture are all awesome and fascinating topics. Addressing these topics at a huge convention with Guido, who is instrumental in shaping both the language and the attitudes of its community is a great opportunity four us to all grow together and open some healthy dialog - this conversation included. All that said, your opinion is completely valid and represents a lot of folks I'm sure who prefer more technical content. If we really want diversity, we need to listen to each other more especially when we disagree.
Except for whether or not they should be pushing to discontinue Python 2. That might be even more vital a topic.
DO: pick something suggestive DON'T: preface everything with "py"
The whole thing blew up quite bad after the Adria Richards issue at a previous Pycon. There is a lot of sense of victimization, whether perceived or real, that needs to be addressed. 
Tell that to Java. If you have a process interpreter or VM how does the concept of self-hosting really even make logical sense? RPython is compiled to C. It is still Python, yes, technically so long as you ignore the dynamic parts of Python and are happy with using it as a C precompiler. Is the argument then that Python ought to be a compiled language?
There really is no such thing as a pythonic name for a project. 'juliet' is fine. 
Anyone can make mistakes or create a bad design. Need to learn from these mistakes and build something more pythonic.
Could you not just, like, import the functions into the interpreter? Or, if your REALLY need to paste, use IPython's %paste magic? I feel like the interactive interpreter should be optimized for interactive use, not big mechanical stuff like this.
That looks nasty as hell, and very different from everything in the standard library.
Whats up with the lady that takes up the question period to platform her own opinion instead of actually asking a question? 
&gt;Frankly, the most insulting statement is that diversity somehow improves the quality of the project and introduces us to completely new ways of thinking about stuff. That's not how it works. A woman doesn't have magical unique view skills, and a man is completely capable of having unique views himself. Diversity can improve a project, but that's diversity of skillset and technical background, not whether someone happens to have a different skin tone or has a different set of chromosomes. If you are talking about blind application of diversity, or diversity being push to the extreme, without any thoughts, then yes. But anything -- not just diversity -- that is pushed to the extreme thoughtlessly is counter productive. On the other hand, diversity in a group can really improve productivity. It's not always the case, in all cases. But men and women do think differently and tend to have different approaches to problem solving. All of this talk about introducing diversity into groups to improve long-term productivity really has merits. But like I said, anything -- not just diversity -- pushed to the extreme without reasons is counter productive.
There's more to programming than code. A lot of conferences that have popped up have had non-programming related talks. PyTennessee, for example, had a talk on mental health in technical settings that addressed the Imposter Syndrome. If you want strictly code related talks, you are welcome to not watch non-technical talks exclusively. 
Well it's perfectly natural to think ill of things that are different, but that doesn't mean that they are. The code for the value of y is intentionally extreme. Simple examples are of course easy to read regardless. I'm curious how you would make the same code more readable?
Guido is using his insidious CPython control to keep you from going back to 2. Humor aside, I suspect the atts list is sized differently - you should verify the data objects are providing the same between versions.
Cool, RPC over email! I've wondered why this wasn't a thing for a while. :) Immediately desired feature: Is it possible to (perhaps with a keyword on the `server.command` decorator?) allow functions to receive the email object? That would allow you to set up RPCs that did stuff with attached files, or email body content, etcetera. It'd make writing responsive email bots trivial, which would be fun to play with! *edit*: While I'm suggesting features, RPC that returns data would of course be better again, so being able to define and decorate functions that receive a "mail-back" function, perhaps a callback on the server itself, would be cool. For example, a simple mailing list bot could then look like this: list_name = "[discuss-derp]" recipients = set("john@doe.it gerry@foo.bar herp@derp.co.uk".split()) @server.command(list_name, receives_body=True, responds=True) def relay(email_obj, return_mail): """ Because the decorator says it receives_body the first argument expects an email object. Because the decorator says it responds, the second argument is a callback expecting an email object and a list of recipients. """ from_recipient = get_sender(email_obj) post_to = recipients.difference(set([from_recipient])) email_obj = set_reply_to_header(email_obj) return_mail(email_obj, send_to=list(post_to)) server.loop() 
That happened at all the keynotes until finally one of the speakers forbade it.
Can you really give an example of silent data corruption? And how all these massive incompatible changes in string handling were necessary to avoid it?
 x = [1, 2, 3 ] def check_val(val): if is_long(val): return val else: return strings.error_long_message def couple(): return (object, object) y = point_prover(check_val, twins = couple(), args = False, where = 0, another = None) Lambdas are generally bad form, your variable names are awful, and your indentation is haywire.
I found the questions at the end of the talk interesting. Especially the one about whether or not mediocre people have a place in security-related domains. Even though I agree with Mr. Kaplan-Moss, my initially reaction to that question was "probably not". He, however, seemed to be positive about that. Do you think mediocrity is acceptable everywhere?
It seems to me that girls, at a young age, are discouraged from following more male dominated career paths like development. Seeing more women in this realm would, I think, encourage more women to join the technology industry. As it is, I think there are a lot of men who are only in this industry because there a lots of jobs and it pays well, even though they might not care for it or even be competent. When 50% of the human population represents such a small percentage of developers I think we miss out on some really smart people.
&gt; The statements he made sounded like he was trying to hit on every woman in the audience rather than influence women into devving. That's not the impression I got. I think he genuinely wants to help. The reason it sounded "weird" is probably that it is actually weird because we do not hear these statements every day.
You're missing the point. 
Explain to me how the opportunities for women to participate are somehow lesser than those of men.
I like a good find-in-files, a good debugger, and simplicity. I haven't found a single editor with an indexed find-in-files. One day :( I go between pycharm and sublime text.
From my reading of your post, it sounds like you'd rather advocate for a discussion over whether or not the sun will set. The sun is setting, and no amount of discussion will fix that. The discussion should be "What needs to be done before the sun sets?" 
Oh, okay. Let's just keep missing the point on purpose then. 
pep8.1 for pythonic project name :)
I haven't seen the talk yet since I'm at work but I imagine the concern about diversity isn't so much that women have a different perspective on things but simply that there are so many women who don't see software development as a career path that could be potentially good developers. I think the industry as a whole don't have enough good developers it would be nice if more people would just consider it as a career path and see if they're good at it instead of just dismissing it outright and targeting a demographic that is 50% of the population isn't a bad idea. As for the tokenism thing. I don't think recruiters go out of their way to hire women. There's no affirmative action for women. I think the push has always been to get women interested in the field, since so many women just dismiss it as an option outright.
Nothing can beat Pycharm. Pycharm makes the developer life a lot easier with smart completion, code navigation panel, many addons and excellent debugger. The only downside is that is heavier. Computers and memory are getting cheap, but in a third world country like mine a 8 GB ram computer is still expensive. For quick editing my second choice is Vim, Emacs and Geany that supports many programming languages. For me the perfect text editor must be: * Customizable in a programming language like Python, not esoteric like Vim programming language or emacs lisp. * Lightweight and Fast * Custom Syntax highlight * Code completion * VIM key bindings, editing mode. * Have a shell panel * Lines bookmarks * Project and directories bookmarks The text editor that has most of its qualities is Sublime. It could be the perfect text editor if it had a navigation panel like that: http://imgur.com/UV3W3Xf
Thank you for writing this. I absolutely agree! I work for a larger tech company and we have, as is the current trend, a huge diversity push. It's currently focused solely on women but will be expanding to all other minority areas. It's absolutely tokenism and it's ended up hurting parts of our org as we fill spaces with uninterested or under-qualified people. We've got some really kickass women too and I think this hurts them just as much. I'm really sad to see this being the path of things but no one dares speak up because they'd be deemed sexist, racist, misogynistic, etc.
Let's assume that becoming a Python dev is purely meritocratic. Women make up about 30% of the American computing workforce, according to the DLS. Assuming that there is a broad diversity of talent across all genders/races/etc. the chance that all there would be no women in the pool of 185 core committers would be male is (1 - 0.3)^185 or 2.203 * 10^-29. Such an absurdly low number would suggest that either becoming a Python dev is not purely meritocratic or that there or women are incapable of coding out of a paper bag. You are a woman and seem to be a capable coder so I would assume the former. 
You give the application a directory, and it loads the code into specialized data structure, something like hadoop mapreduce for quick retrieval. I do code reviews as apart of my job, and I spend **most** of my time waiting for find-in-files :( :( :(
This seems very superficial.... Very little evaluation or description.
Thank you for this, your input has been really valuable to us! We appreciatte it a lot!
https://github.com/karan/Projects https://codeboom.wordpress.com/2012/07/30/10-mini-programming-projects/ http://www.reddit.com/r/learnprogramming/comments/2a9ygh/1000_beginner_programming_projects_xpost/
pyMyProject isn't the best choice
It's a [keynote](http://en.wikipedia.org/wiki/Keynote), not a talk.
I want to add one thing: programming doesn't have a large "break the glass ceiling" movement compared to other male dominant fields, rather than women being actively kept out by men. There have been a ton of news stories about this lately and it seems more like there just aren't a ton of women who want to learn to program just to make a statement. What female programmers there are seem to be like most male programmers: put your head down and work, don't try and change the world. They want that money and like/are good at programming, just like men. The stories I heard did talk about the glass ceiling and how computers in general are still a "boys club" but every actual female programmer they talked to didn't claim they were systematically kept out. They mostly just don't like the boys club they found in college/the workplace, which is WAY different than how women were treated when they first entered the work force at large. I'm not saying it's perfect, but it really seems like the programming field's diversity problems are slowly correcting them selves. I'm not sure we could "fix" the problem any better than natural human ambition seems to be doing. 
If a project gets large enough to have many users it should no longer have a single maintainer. If you're using Github for hosting you can create an organization like &lt;ProjectName&gt;Community, transfer the ownership of the repo to that organization and then give additional people commit access based on their contributions. Reduce the bus factor!
Thanks! This makes me feel a little redundant, but these modules are interesting!
I do have a problem with that mindset, as someone who grew up without a male influence on my life, I think having some male teachers or whatever during my formative years would have been beneficial. I made friends with, who I consider, my first male mentor when I was 25 and that was too late to fix some problems. That's not to say that my mom isn't awesome(she's probably the reason I'd consider myself a feminist), but she won't have the same experience as me.
The version had to stabilize. This is a rather normal procedure in mature projects like Python.
Hmm so its like wine. Must keep it hidden away in cellar until it becomes ready by itself.
I don't think it was any worse at PyCon, but 99% of the entire QA* was that crap. Most of it very cringe worthy. Edit- *by 'entire QA', I meant for all of the talks that I saw, not just the keynote.
I don't think that this is secure. For one you could just have `&lt;whitelisted@emailaddress.com&gt;` as name, so `sender` would be `&lt;whitelisted@emailaddress.com&gt; &lt;blackhat@hacker.com&gt;`. Generally source email addresses are not strictly checked, so relying on the source address is not secure. Besides that it is vulnerable to [MITM](https://en.wikipedia.org/wiki/Man-in-the-middle_attack) attacks. Besides that this it looks good. Maybe putting tests in a seperate modugolem.dele could improve readability. I think it would be good to indicate the expected type in the docstring. E.g. `Server(mail_service, poll_interval)` it's not directly clear what type `mail_service` should be. I guess a MessageService? If MeessageService is supposed to work as an abstract base class, you could let it inherit it from [ABC](https://docs.python.org/3/library/abc.html). Ofcourse that's not required, but might be a bit "clearer"/"more readable". I like the context manager for POP3! Summarized I realy like your module (even if I only outlied ways to improve)! Keep coding!
Eh, I don't think that they rub it in too much, 1 mention as a tag line isn't too bad. Overall, people making computers do things for humans is good, although I do agree/think it's a little redundant in certain cases. (eg: "I design the web for humans." "Oh good, I thought it was for my dog." )
I would have thought if you looking for better code and better documentation you might have followed the comment style given in pep8. You don't seem to have done so at all.
What's up roommate?
Mine just imports [see](https://pypi.python.org/pypi/see), which I love.
I think wrong person? I don't have any roommates with a black jk. You should lift that by the way.
I started playing with this type of thing a few months ago, but due to security/complexity/other priorities, I dropped it. I'll take a look at this. 
Awesome thank you. I definitely need to clean it up some more, I just figured I'd share it, nothings perfect. A lot of the edits you did were either bad habits I'm trying to break, or were left over from me testing while writing it. Appreciate the help
I think what you're missing is that what's fun for the core devs doesn't make a difference to the community - their fun isn't going to stop the community fracturing, or indeed dying into a tiny minority language like smalltalk.
Just watched the video and really don't see anything "socially awkward" or that look like he's "trying to hit on every woman in the audience". I think comments like that are totally unreasonable.
I'd rather open a port to a well protected machine, than risking someone sending random commands back home :-) My home (grown) surveillance, a few Raspberry Pi's with cameras, some D18B20 digital thermometers, and more, is started/stopped by a docker container running a web service, which then sends commands to the server via MQTT, which then takes action and starts/stops services on other machines via MQTT. The front web service handles authentication, and the backend server handles authorization. The frontend runs it's own mosquito broker (another docker container), to which the internal server connects and subscribes to a given topic. The internal server also runs a docker instance with the internal mosquito broker. The internal MQTT commands are implicitly trusted via SSL/TLS certificates, and the MQTT 3.1 username/password authentication/authorization. It's all written in Python, using the paho-mqtt module. I've considered moving authorization to the individual nodes, but I prefer the "single signon" like approach. Edit: forgot to mention that I'm currently playing with Node-RED (http://nodered.org) to see if I can use that instead. 
&gt; the most insulting statement is that diversity somehow improves the quality of the project and introduces us to completely new ways of thinking about stuff Diversity isn't just women. There's also cultural diversity and it's hard to argue that it won't bring in new viewpoints. As for your other point, tokenism, "Am I here because I am good, or just because I am a disabled lesbian female African?", then you do have a point. However, hothing else is going to fix it this side of the next millennium. Our generation has to bear it so that future ones can benefit.
&gt; Python 2 is scheduled to be EOL'd upstream officially and for good in 2020. &gt; We're in 2015 now (wow, that went quickly), and keeping our release cadence up &gt; (3 years a pop) puts Stretch up in 2018, and Buster in 2021. Crazy!
That's talk is just another evidence (after awful type annotation and overcomplicated asyncio) that Guido is slowly loosing touch with the reality. Lack of women and diversity issues problems of Python? WTF?
That's delightful. However, if Guido likes giving keynote addresses at conferences, this isn't a strategy which supports that. The rest of us who actually want to get some work done naturally care about a vibrant community and not having our code rot. Fortunately, there's PyPy which can bear python 2 into the future if need be.
Hah, good q! It is documented here at least: https://docs.python.org/3/tutorial/interactive.html
Hmm, interesting thanks! I've used django and never knew about that. It's a little different than what I was going for but it's still awesome.
I know, right? When I discovered I could do that I DRF, I was just completely blown away. Also, great job on the code. 
It's true that this is an indicator, but not as much as one might think. Especially nowadays were it's really easy (just 1 or 2 clicks on a new github project).
I agree. I don't believe in changing how people handle the project the moment they lose interest in it. The interest is often the only pay-off in the first place. But trying to get a maintainer group started once a project gets users, that's not so hard to do and that's still something to do when the motivation is at the top anyway. 
I don't think any reasonable person would describe XML as "for humans."
Here's the bigger concern: the GIL, or Global Interpreter Lock. It turns out that, for CPU-bound threaded code, Python is not a good choice, as the GIL is locked for every python expression, meaning that only one thread can only ever be doing work at a time. Now, for IO-bound work, the story is different- the GIL is released for blocking IO operations, so multiple threads can be waiting for IO (or sleeping or things like that). However, in general, only one thread can ever be doing CPU work at a time.
This was a brilliant talk. Loved it. Was one of my top 3.
Yep I paid to go to this one. There were cameras. Still something about being there that is great. Usually in real life by the time I get a chance to sit down and watch these things I am beat and end up falling asleep
You're right, we do seem to differ on what "equal opportunity" means. It becomes an argument of semantics, but in this situation definitions are everything. So, my viewpoint (for better or worse) is that equal opportunity means that everyone is free to attempt to do a thing. Essentially, there is no law against them trying or no penalty for the attempt (except potential failure). I often use the analogy of hanging a $100 bill 7 feet in the air. You've got people who try to grab it: Someone at 6' tall, 5'5" and 5'. Line them up and have them try to grab the money. They all have equal opportunity to grab it, but obviously the taller people will have greater advantage. Good for them. Others may say that that scenario is not equal opportunity because they don't all start at the same height, so maybe they suggest giving a chair to the shorter people to stand on. I see that as crossing the barrier from equal opportunity and into equal outcome. You're essentially guaranteeing success. Incidentally, people liken the "giving a chair" example to affirmative-action-style policies. Unfortunately you're correct when you say people are given freebies all the time. You're referring to what is essentially nepotism. Arguably, this is also a harmful practice. The answer to which isn't to give MORE people a free ride in the name of diversity. I believe also that nepotism is a grey area, legally. It's very possible people participating in it may be breaking some laws. I only mention that because bringing it up as a comparative is a rather moot point. Things like that will always happen because some people are shitty. You also mention things like networking and appearance. These two factors aren't free passes or favoritism, really. It takes a lot of work to network properly. It's really like another job and set of skills to hone. Personally, I'm ok at it. I know I need to improve this skill to get further, while also relying on my technical merit. I'm not sure exactly what you mean about appearance, but learning to upkeep yourself, groom, dress appropriately, etc, is also a skill. It goes into one's arsenal of talents to apply towards success. If you meant something else by appearance, then you'll have to clarify. Thank you for taking the time to post your opinion. I enjoyed reading through what you had to say.
Haven't seen that one before, thanks!
It was 2014. Make up your own mind. Quite frankly I don't care if he's the biggest sexist misogynist on the face of the earth, the artist is generally judged independent of his work and his work is of terrific magnitude.
There is still a place for threading, but I think what you want (if you want to stick with Python) is multiprocessing instead of multithreading. No GIL issues with that.
Hehe, brought back memories - I had something like this using mail and uucp to control a BBS back in the 80s. You've made me feel old! Personally looking at your requirements, these days I'd use a software VPN, put a rest interface up for the control functions and then have a public facing web server somewhere accessing the Pi over the VPN - just goes to show how many different ways there are to skin a cat though!
I could never understand why this is not enabled by default. It really useful and never seems to cause any problem.
First note, don't use `str` as a variable name, it's a builtin. Second, you can't do this. Look at top answer [here](http://stackoverflow.com/questions/15375368/slow-word-by-word-terminal-printing-in-python).
Ok thanks, I will look through those. And yeah it will probably be a command line game.
&gt; DON'T: preface everything with "py" Right, all the cool projects END with "py" 
It's good to prioritize hiring people with vaginas? If women really are just as capable and will take 27% less pay then companies would be on that shit like moths to flame. They wouldn't need a government mandate forcing equal outcomes on everyone. 
Blender has a python API, you could make an addon (some procedural 3d stuff, maybe?).
Agree, in fact I often change the repo description :P
Your idealism is inspiring but the real world is much more complicated. 
Can you share more info on the rate limiting?
It gives people more options.
I could look into that
I knew about `logger.exception()`, but did *not* know about the `exc_info` option. Also, they shouldn't be using: try: # something except: # something else This will catch things like `SystemExit` (raised when you call `sys.exit()`) and `KeyboardInterrupt` (raised when you attempt to `Ctrl+C` your app).
Sorry...trying to implement SSL. https://www.tylershaw.codes/posts/2015-04-python-to-markdown.html
Can you explain?
I'd say it depends on what you are doing with it. One thing to keep in mind is that there are some nice modules out there that have not yet been migrated to 3. If you are learning Python just to learn Python in general and not for any specific purpose, I'd go with 3. If you are learning for a particular project, look more specifically into what modules you would be using. I'm using 2.7 solely because the introduction book I started with used 2.7. I do import print_function from __future__ though.
The security issue is easy to fix, you just have to sign your email with gpg and check the signature before executing.
https://github.com/search?l=Python&amp;q=nameko&amp;ref=searchresults&amp;type=Repositories&amp;utf8=%E2%9C%93 which gives us https://github.com/topiaruss/nameko-chat Which isn't that much.
Thanks. Its weird, I've found nameko-chat before but github returns 404 to me. Thanks again.
All you're points are valid, never heard of ABC but now it's in there. As for the security concerns, I added a note to the readme clarifying that this is not a secure way to do remote procedure calls. Just so I don't give anyone any illusions about safety. Thanks for the kind words!
I'm definitely interested! I subscribed to the mailing list. Is there anything else I need to do? (This is my first time contributing to Debian)
But then it wouldn't "be accessible from anywhere, a pc, a tablet, a smartphone, ..." at least not without first somehow transporting your key to that device. And I wouldn't characterize GPG as "easy enough for my grandmother to use", although that is a bit sad. But generally you are right of course.
And in case people have missed it: there's [PyVideo.org](http://pyvideo.org/) which currently has nearly 3 thousand Python videos indexed, including 134 from [PyCon US 2015](http://pyvideo.org/category/65/pycon-us-2015).
I've always thought it should've been called SQLchemy, skipping the repeated - el -al syllables makes it easier to pronounce. 
Wow, thanks! Gonna have to go find some cool ones to watch. 
I'm kind of sorry for OP, whose solution is neat too, but I prefer this. I'm a big fan of YAML, and I like to depend on as few external libs as possible, especially if it's just for some syntactic sugar. On the other hand, not caring about *how* the settings are kept is interesting too. 
This is a bit too much for my use case, but kudos to you that you got all that running ! paho-mqtt looks very useful
Yeah, it's Zawinski's Law of Software Envelopment: &gt; "Every program attempts to expand until it can read mail. Those programs which cannot so expand are replaced by ones which can.'' I guess things never change :)
**And** there is a [Kodi plugin for PyVideo](http://kodi.wiki/view/Add-on:PyVideo), so you can indulge yourself with hundreds of Python-related videos from the comfort of your couch! \o/
Did you check in the [OSM Wiki](http://wiki.osm.org/wiki/Frameworks#Data_Processing_or_Parsing_Libraries)? Maybe [osmread](https://github.com/dezhin/osmread) could help you?
&gt; It's good to prioritize hiring people with vaginas? Who knows? We've prioritize hiring people with penises for 4000 years, who knows what we're missing out on? &gt; If women really are just as capable and will take 27% less pay Do tell which of those you think is not true. Go on, don't hold back: do you think programming skill is negatively affected by the possession of a vagina? Or that women on average don't accept 27% less pay than men on average? &gt; then companies would be on that shit like moths to flame. They wouldn't need a government mandate forcing equal outcomes on everyone. Pure free-market fanboyism. The reality is more complicated. Companies are not hyper-rationale machines. They are run by human beings that have exactly the same irrational biases as any other human beings. Why do you think that most new companies fail? That the average life of a company is 30 years? People come and go but companies are potentially immortal, and yet most of them don't even live as long as the average life expectancy of people in ancient Rome. That's because they are run by irrational people, and once they get big enough they turn into bureaucracies. Companies make stupid decisions all the time. They can be insulated from the harmful effect of such stupid decisions due to market capture, inertia, redundancy, government-backed monopoly, social forces, etc. Companies are both subject to the same biases as the rest of society (whether good or bad), and constrained by those biases even when they don't share them. Think about a company that decided that they would hire nobody but convicted pedophiles, on account that the workers would be so grateful for a second chance that they would be desperately loyal and willing to work for peanuts. Do you imagine for a second that such a business plan would succeed in today's anti-pedophile climate? They would be hounded out of the market in weeks of the news going public. Entire societies can be trapped in a toxic world-view that hurts their economic efficiency. Think about Saudi Arabia, where half the population is treated as virtual prisoners, with extreme restrictions on their movement. With few exceptions, they cannot even get gainful employment selling burgers at McDonalds (or whatever the Arab equivalent is), let alone attempting to make a profit in the most efficient and innovative manner possible as the free-market says they should. Markets are social institutions, and can get trapped in dysfunctional situations. Consider the possibility that the western capitalistic IT industry is trapped in a *slightly* dysfunctional situation with respect to up to 50% of the potential pool of programmers. There are degrees between "100% free-market with no inefficiencies" and "North Korea". Nobody except maybe a couple of nutcase extremists thinks that the western IT industry is as bad as Saudi Arabia when it comes to women. But maybe it is *a little bit* bad, a little bit inefficient and biased. Isn't it worth fixing that? Take the fabled 27% pay gap you mention, and let's suppose it is true for the sake of the argument. It's not necessarily the case that the only two explanations are "The evil Patriarchy oppresses wymmin!" or "Women do 27% less effective work than men (due to working fewer hours, raising babies, etc)". Maybe its a little from column A, a little from column B: social biases are responsible for 13 points of the pay gap, and women getting pregnant is responsible for the other 14 points.
I'm not an expert in SQLAlchemy, but doesn't PHPs Doctrine provide similar functionality and possibilities? They are all data mappers, if I'm not mistaken. Not saying that one better than another, just looking forward to same good experience in SQLAlchemy after using Doctrine. Also, another question to django users - is it worth using and learning SQLAlchemy for every app in django or django orm is just enough?
What is the advantage compared to just use aliases ?
Is pyGal easier to use than the Bokeh library?
I absolutely do, and I'm not the only one. From time to time people speak up about the lack of male teachers, especially primary school teachers, due in part over [the hysterical fear of pedophiles](http://www.adelaidenow.com.au/news/south-australia/men-too-scared-to-teach-for-fear-of-being-falsely-accused-of-childsex-offences/story-fni6uo1m-1226913910688) ~~and the assumption that any man within fifty feet of a person under the age of 21 is a pedophile~~, and how this was [harming the teaching industry and the children themselves](http://www.perthnow.com.au/news/western-australia/decline-in-male-teachers-a-real-cause-for-concern-says-education-minister/story-e6frg13u-1226479501048). (Some of whom now have no male role models in their life outside of television.)
&gt; we are exactly where we expected to be after this time. Except that the original deadline was extended, because the core team expected uptake to be MUCH faster. This is "build it and they will come" development; some people are coming, maybe most will, maybe most won't. As to your "mature and nuanced" view, you gloss over the question of upgrade paths. In this case, the upgrade path offered has always been fantasy-land transpiling. The community has come up with solutions like six, which work, but aren't a great deal of fun. The whole project was based on the fantasy that there was a huge demand for a "better" python. Python 3 in its next few releases probably will be a better python in multiple ways, without being a worse python in any way; but it doesn't follow that there is a huge demand for it, and that demand will remain pent up without a proper upgrade path. As to "it takes time to learn what the right way to migrate is", it takes a lot less time if one looks at what other groups and languages are doing. Basically every other language with a smooth upgrade facilitates a single codebase, by allowing the old version to be used in the new version in some way, and possibly mechanisms like transpiling or binary compatibility to allow the new version to be used with the old version. We still don't have a 3to2 transpiler or anything like it.
&gt; I'm not an expert in SQLAlchemy, but doesn't PHPs Doctrine provide similar functionality and possibilities? They are all data mappers, if I'm not mistaken. The core of sqlalchemy is [a fairly low-level and schema-centric query builder](http://docs.sqlalchemy.org/en/rel_1_0/core/), the data mapping ORM layer is built on top of that.
Just for the ease of access [CheckiO Website](http://www.checkio.org)
It is really unfortunate that I can't find that guys talk from google. But regarding the architecture: Given that the requirements and the circumstances change all the time I really like the idea of iterative development/design. Some things should be of course decided/designed up front, but a lot of things can be made in an 'ad-hoc/when you need it/as you go'. You can create beautifil OOP code up front, but if you do not refactor your code as you go, it will wind up in a mess. Again, these are my views now on the subject and it is fair to say, that there is really no one good way of doing things. But probably not designing anything up front is just as bad as designing everything up front. Re-iterate, refactor, roll with the changes as you go. Of the two books I'd recommend the pragmatic programmer first, it is relatively short, not too dry, generic book about how to approach development. It is important to say, that I have not read Clean code yet, so I really can't compare the two (this is a bit based on my reading of Code Complete, which is I think too dry and too much and kinda gets boring as you go) I've found the video: https://www.youtube.com/playlist?list=PLOU2XLYxmsIJ7HGm2bv20QrtwcWemSRCI 
I can think of an advantage for each case if you work in multiple shells and multiple directories. If you create an alias in one shell you either need to run the alias in each shell or save it to an alias file and source the alias in each shell. If you create a shell script, but you want to run it while in another in directory you either need to put it in your path, us a relative path to get to the directory, or cd to the directory. Seems like it would be good for banging out quick aliases while you are working. I use ! completion a lot, but I constantly have to check if I am going to be getting the right command. By explicitly adding commands to butler I could be sure that I am getting the command I want. In a team environment, I'd still prefer an alias file that could be thrown in version control because I doubt I could get everyone on the team to use a new tool.
Nice reply, but I felt a bit of contradiction… may I ask you to clarify the difference between: &gt; do not write code to construct SQL commands and &gt; SQLAlchemy is a tool to build SQL What do you mean by the first one (_construct SQL code_) and by the second one (_build SQL_)? And, most important, why the first one is so terrible and the second so awesome? Don't get me wrong. I love SQLAlchemy and your reply is really nice. I just want to clarify that so I can check what I might be missing. Many thanks!
There's no contradiction. He's saying to let a library handle the heavy lifting for you, because you will likely get it wrong in subtle but important ways.
Nothing yet! More to come soon, thanks for offering to help out, you rock!
Usually for such type of tasks either I create a fabfile (in case it's a python project) or write a Makefile otherwise. But I see your point - tab completition is good. Maybe I'll try this out. 
Then may be you should update the example in screenshot? (mostly noob here, so I don't know what it should be, or else would have sent a PR)
You dont get the tab completition. That's the main point. You could write many small bash files for each command you want to have a tab thing, but then if you want to group some functions together you'd probably combine them into one bash script with different functions. And then table completition is gone.
&gt; Do tell which of those you think is not true. Go on, don't hold back: do you think programming skill is negatively affected by the possession of a vagina? Or that women on average don't accept 27% less pay than men on average? They don't, on average, accept 27% less pay. For the same job, they tend to average 95% of same pay. Where discrimination occurs, it tends to be in promotions. E.g., a woman is doing the same job of a less qualified male because she's seen as less of an authority figure than the male, which means that she's making about the same money for the job role she's in, but she got passed over for manager, so her wages are artificially constrained. In that regard, the OP is correct in that "equal wage" laws are actually harmful to women, because it means that women promoted into positions would now have to extract exactly equal pay as her male peers who have been doing the position for years, while similarly promoted males will have no constraints, which will likely (in my opinion) exacerbate the issue further, because now it will not only be more likely that males will continue viewing other males as betters, but they'll be financially de-incentivized from promoting women to boot. FWIW, my wife runs a non-profit organization that teaches women to program to 1) encourage more women into the tech field and 2) help abolish gender discrimination, at least in the field of technology, which has more meritocratic tendencies already than most fields. Accepting the wage gap as canon is actively harmful to women, especially as there are [many](http://www.huffingtonpost.com/christina-hoff-sommers/wage-gap_b_2073804.html) [sources](http://time.com/3222543/5-feminist-myths-that-will-not-die/) [that](http://www.wsj.com/articles/SB10001424052702303532704579483752909957472) [reliably](http://www.washingtonexaminer.com/a-yearly-reminder-that-the-gender-wage-gap-is-due-to-choice-not-discrimination/article/2563010) [debunk](http://www.cbsnews.com/news/the-gender-pay-gap-is-a-complete-myth/) [it](http://www.forbes.com/sites/realspin/2012/04/16/its-time-that-we-end-the-equal-pay-myth/). That said, there *is* discrimination against women, in most fields, and while sure, some of their life choices are slightly detrimental to their careers (and I offer no opinion on whether that's right or wrong), the core of the issue is that women aren't seen as equals, or as capable, and the result of that is pernicious in both fact and deed. 
&gt; I consider SQLAlchemy a major "selling point" of Python Shudder. In my experience, it's a great way to prototype applications that are unusable once they get into to production. Having torn all of the sqlalchemy out of our biggest applications (we replaced it with just native SQL using the awesome psycopg2 library), we now have maintainable, high performance code. I'm never looking back.
That makes sense, thanks for replying!
It's not that different though, apprently abs01ute's solution also relies on the PyYAML lib.
Hah, yes. I'm not sure if it was one of these, or from some other con, but there was one presentation someone gave about machine learning (that one DID go way over my head, but it was neat to see how accessible that stuff can be) and the audio was terrible! All kinds of static, distortion, robo-voice, etc... Like they had the receiver for the wireless mic inside of a running microwave or something. It was ridiculous :P
I'm so happy now their snippet show the import statements as well.
Congrats to the Dev team. A signal achievement!
I think the point is: SQLAlchemy is a library that constructs SQL commands. Use that, **don't** do it yourself with e.g. string interpolation.
missed a trick :)
Run in terminal: export $PYTHONSTARTUP=$HOME/.pythonrc Put this line in .bashrc for linux and .bash_profile for mac. 
Yes, I know. I am kind of a Django developer now and I use it's ORM which now has some PostgreSQL features and it's really easy to switch in PostgreSQL on such a level. But I came from a sysadmin field so what I am talking about is a real understanding of what PostgreSQL is. How to spin it up, configure replication, understand what the VACUUM, ANALYZE, work_mem, maitenance_mem, WAL are and so on. That's why I am so happy with this talk :)
Haha, Ive been watching the playlist via chromecast afterwork. The top guys were seriously ON POINT this year. 
&gt; However, when you use a SQL database in a different language (than SQL) you better not write SQL commands yourself in this other language and (even worse) do not write code to construct SQL commands. Sorry, but I think this is very bad advice. SQLAlchemy is a really impressive tool, and a great help if you've got to knock out a hundred CRUD queries, and especially if you need to support multiple databases. But the benefits are greatly diminished if you're writing more analytical, reporting queries. If you're writing these queries against a single large database and want to get the most performance out of it, then you will generally write SQL. And anyone interacting with a database should be able to write SQL for adhoc reports, analayis, testing, etc. Seriously, writing SQL isn't like writing your own crypto - anyone can do it. SQLAlchemy just gives us more portability &amp; productivity at a cost in performance and a different kind of complexity (extra abstraction layer).
What would you all like to see next besides load balancing?
I started watching this one [Richard Jones - Introduction to game programming with Kivy - PyCon 2015](https://youtu.be/U14P8gtjQmU) of late thought I haven't finished yet.It's really interesting 
I recommend [fish shell](http://fishshell.com/), aka "the shell for the 90s" it has the best autocomplete, and history you have ever used, and its reguarly updated.
He's not saying don't write sql. He's saying don't use python strings to construct sql queries. Or any languages strings for that matter. If you're accessing a db through a programing language and not directly, then use a library. If a library won't suffice, work directly with the db and use sql as you suggest.
I'm going to take this opportunity to plug [fish](http://fishshell.com). I started using it once and it overnight became my favorite shell. It's amazing the things that can be accomplished when you stop shooting for POSIX compliance. In this case, you can make an alias with [alias](http://fishshell.com/docs/current/commands.html#alias) (which is actually just a thin wrapper around a [function](http://fishshell.com/docs/current/commands.html#function) definition). Then you can use [funcsave](http://fishshell.com/docs/current/commands.html#funcsave) to save the function definition in the fish configuration directory, where it will be automatically and lazily loaded when needed in future fish sessions.
Basically I agree. You can write SQL yourself and it is fine. And SQLAlchemy adds some overhead. However, in my use cases I never had issues with SQLAlchemy adding too much overhead. Not at all. Instead I can create rather complex queries easily, and I gain some really nice features. For example I can add some filter to some subqueries *conditionally*. And since I can add sql function expressions easily (http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html#sqlalchemy.sql.expression.func) I never had issues of not being able to access whatever feature I needed, even when being out of scope for SQLAlchemy initially. You can do all that without tampering SQL statements. It is pure joy! In the end of the day I have to tell that the most complex (and efficient) queries I ever wrote I did by using SQLAlchemy. Maybe I never reached too complex stuff. Your milage may vary. I'm fine with anybody who just says (or knows or just claims) that certain things are better done in SQL itself. I can't tell. All I have to tell is that I'm fine with SQLAlchemy and I find it really impressive. And it is way different from using a simple minded ORM.
I would be *amazed* if PyPy created the equivalent of a Python 2.8. Having such a major language fragmentation would be a huge split in the community.
What do you mean by proper separation?
ELI5 SQLAlchemy, why use it over sqlite3 for example?
Congrats SQLAlchemy! https://storm.canonical.com/ https://launchpad.net/divmod-axiom Also the good stuff. 
I've not tried the Bokeh library. I just tried pyGal in a virtualenv and it worked so easily I went with it.
Dear Jesus: Please let this one last longer than all the other ones that didn't last long at all. If this happens, I'll reconsider my atheism. Love, /u/bbbryson
Thank you /u/L43 and /u/jcdyer3 That was helpful for the n00b here (: Issue clarified, no contradiction anymore. Yay.
&gt; pycon 2015 youtube channel and sort by popularity Link: https://www.youtube.com/channel/UCgxzjK6GuOHVKR_08TT4hJQ/videos?flow=grid&amp;view=0&amp;sort=p
Thanks for linking that! 
&gt; PIL was given as an example - Pillow is widely considered the replacement, but you have to know that. Awesome! Hadn't checked on this recently, but the last time I looked PIL support was the main thing holding me back from Python3. 
ELI5 why you can't use Google. http://www.sqlalchemy.org/features.html
Not if they had identified huge issues with Unicode handling that required massive, backwards incompatible changes to the language's text model. Also, they didn't cease work on python 2 for a good, long time. Python 2.6 *and* 2.7 were both primarily feature backport releases to the 2.x line, and included 3.x features like improved exception catching syntax (`except Exception as e`), set literals, set and dict comprehensions, nested with statements, and the print function. The fact that the Unicode changes weren't backported to these releases (besides `from __future__ import unicode_literals`) should be an indicator that it simply can't be done in a backwards compatible way. The fabled 2.8 release that everyone's clamoring after, to "ease transition to python 3", has been in existence for the last 7 years, in the form of Python 2.6 and 2.7. You can't really expect them to support it forever, though they will continue maintenance until it's EOL'd in 2020. Of course, python is an open source project. You're completely welcome to fork Python yourself and create a 2.8 release (though beware of trademarking issues). However, the core development team isn't beholden to every whim of the community to whom they've given *ample* time and assistance to move from Python 2 to 3.
It scales just fine for everything I've ever tried to do with it.
You missed an inverted comma in your third example. It should be: ./smj7.py -q '@decem, #live, $infanta' 
&gt; We still don't have a 3to2 transpiler or anything like it. https://pypi.python.org/pypi/3to2
sqlite is a database. Like mysql, or postgres. It's where the data is actually *stored*. However, SQLAlchemy is an ORM, which stands for "Object-Relational Mapper" (or Mapping?) (http://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it) It's like an intermediate layer of code that sits between your program, and the database. So rather than querying the database directly like: results = cursor.execute("SELECT * FROM results;") You do something like: results = Results.objects.all() And you can get more complex, without dealing with SQL specific stuff: recent_jobs = Results.filter(complete=True).order_by(date).limit(1) You have models (Results class, in this example) that have methods that interact with the database. I'm a super beginner at SQLAlchemy and only built a few sites using Django, but that's my ELI5 understanding of it. (and that's pseudo-ish code, above!)
You wouldn't use SQLAlchemy instead of sqlite3, but rather as a tool for working with sqlite3 and other databases. SQLAlchemy is broken into two sections: Core and ORM. Core provides a consistent database connection API with pluggable backends, session/cursor/connection management, schema reflection, a python query language, and so on. The ORM is built on top of Core and provides flexible declarative and procedural APIs for mapping database tables to python objects. I generally stick with Core because I often work with legacy databases and prefer the database to drive my code rather than code to define the database. On self contained projects, the ORM works quite well, much better than what you may have experienced in Java. Neither API prevents you from writing raw SQL when needed but the python tools save on boilerplate for simple, load-by-id style queries. Overall, SQLAlchemy is one of my favorite python libraries and is my recommended method for working with any SQL database.
The fact that there hasn't been update on a Python fork should be an indicator that there simply isn't the demand for it. There have been plenty of open source forks that have supplanted (or at least matched) the original, because the either the original was deeply flawed or there was sufficient demand for the features of the fork. I don't see a fork of Python 2 to create 2.8 meeting these criteria. - The [pillow](https://pypi.python.org/pypi/Pillow/2.8.1) fork of [PIL](http://www.pythonware.com/products/pil/) - The [suds-jurko](https://pypi.python.org/pypi/suds-jurko/0.6) fork of the [SUDS](https://pypi.python.org/pypi/suds) SOAP library - Outside of the Python world, some obvious examples are Ubuntu from Debian, Firefox from Mozilla, and WebKit from KHTML.
Huh, good to know. Thanks for the info
They just posted episode 3. They have commercial support so I hope they will at least make it a few months. I am not sure how they will do if they release weekly podcasts.
I think it is much better if you pronounce it as "Sequel Alchemy"
SQLAlchemy is a library that interfaces with many different database systesm. I use it all the time to connect to a remote postgres DB we have sitting on AWS. 
Yea, I know. I posted at the top of the article that I still have to add that. That doesn't make it useless.
thanks for the answer - and that sounds like a good approach to the migrations problem. if I could push you on one thing: what are these crazy powerful things that I might want to do that I can't do with Django ORM? If you really push Django ORM to the limit it can really do a lot. But maybe I don't appreciate a whole range of things I might want to be doing. 
I've only scratched the surface. All I know is that I've been on a couple projects that have some intense use of SQLAlchemy that is intimidating to try and read through.
Some auto-generated help in case you want to see how to use it before running it: % ./smj7.py -h usage: smj7.py [-h] [-l LOCATION] [-q QUERY] [--database DATABASE] [--freshen] [--prune] [--force-rescan] [--json] [--show-paths] [-i INDENT] [--force-serial] [--syntax] [-d] A simple command-line media indexer and jukebox. optional arguments: -h, --help show this help message and exit -l LOCATION, --location LOCATION the location to search for media files [~/Music] -q QUERY, --query QUERY input an SMJ7-style query, followed by playlist commands, and disable interactive mode (see --syntax) --database DATABASE the location to store the media database [~/.smj/smj7.sqlite] --freshen search for new files and scan them, and update existing entries in the database, useful when adding new albums or changing metadata --prune delete entries from the database if the file no longer exists (Note: if you suspect a large amount of files, use --force-rescan instead) --force-rescan nuke the database and start from scratch, useful when a lot has changed since the last scan --json skip playback and interactive selection, just output matching results in JSON --show-paths include path information in JSON track output -i INDENT, --indent INDENT with --json, # of spaces to indent by, set to 0 to dump block of text [2] --force-serial disable parallelized media parsing, useful for slower machines or older mechanical hard disk drives --syntax show SMJ7-sylte syntax guide -d, --debug enable debug mode Note: mplayer is required to play files.
Raymond's talks are always brilliant, and entertaining. ;)
I don't get it! Historically releases have been two years apart. So I would expect Stretch in 2017 and Buster in 2019. Was there any change on this?
Why the hell is this dependent on having Flask?
I heard CTRL+R is pretty cool ;)
Based these examples off of the Python docs/examples [1]. You could do what your suggesting (I tested) if you not interested in capturing what is offered [2] which I admit my examples are not making use of. [1] https://docs.python.org/3/library/asyncio-task.html [2] https://docs.python.org/3/library/asyncio-task.html#asyncio.async 
To use Django just as RESTful backend. And write a seperate javascript single-page site.
SQLAlchemy is very much an ORM+toolkit rolled in to one. They both have uses and strengths and the documentation does a great job of distinguishing that the two exist and have their own uses.
OK. thanks. Good article though.
Thanks for the link. Max Kanat-Alexander is quite ambitious and makes bold statements. But the last video was exactly about what I was asking. And in general what I do is this incremental approach he talks about. Now at least I know how is this called :)
I've actually never met a problem I had to step down into raw SQL for, and I've done a LOT of crazy things with SQLAlchemy. I do sometimes have to step into a junior dev's code to add joinedloads/optimize their queries a bit - but looping through a record set and fetching a new set of records on each iteration will kill anything.
Thanks for the feedback. I definitely agree that the format you're proposing is interesting. I decided to do only one host (i.e. no cohosts) for most shows because it is already VERY difficult to schedule the recording with the timing of the guest, myself, my job, my kids, etc. Adding another person only means fewer shows so I decided to go solo. That said, we'll have shows with multiple guests soon. Thanks, Michael
Just as a timely anecdotal follow up to this discussion. Interestingly enough, I've been informed that there are job openings at my company for my job (we're adding more people to this team, not replacing me). So I intimately understand the skills required. I will be in charge of interviewing candidates. I was just told in no uncertain terms that if a woman applies, regardless of her skillset, we are to hire her due to the diversity initiative. This is exactly lowering the bar. So, my argument was never a straw men to begin with. This is literally happening. I guess it's up to you whether you want to believe some stranger on the internet, but whatever. It's happening and I have to be a part of it.
so what does this PEP propose aside from duplicating a lot of keywords?
I'm sorry, but there is no way you could read the PEP in 5 minutes. It's all explained there.
I could have read it in 7, in any case I didn't because I hoped someone could give me a quick tl;dr;
I'm not sure what you're trying to say? Sequel is the same, "ORM + toolkit", though I'd say that ORM is just one of the tools in the kit.
Read the Rationale section :) That's a quick tl;dr; The document is fairly long, because the topic is actually very complex. But the aim is to make async programming in python easier, and to enable some things that were much harder to do before.
That a yield statement can pass variables to the task that is handling them. Learned while in the audience of this talk: https://www.youtube.com/watch?v=MCs5OvhV9S4
&gt; but looping through a record set and fetching a new set of records on each iteration will kill anything. So bad that it has a name: N+1 Problem
I would like to see something about zero down-time app updates.
I wonder how many folks are aware of the object relational [impedance mismatch problem](http://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/).
&gt; A bunch of new keywords and a more difficult syntax – yield froms are obvious as hell. await isn't. It's strange to hear that 'await' is a more difficult thing than 'yield from'. You probably haven't ever tried to teach 10 programmers at the same time how to use asyncio properly, and what's the real difference between yield/yield from. If you did and it went well -- kudos ;) &gt; if 0: yield from asyncio.sleep(...) This is an ugly as hell hack, sorry. And btw, you can continue using 'yield from' and @coroutine decorator for the eternity.
Yes, but you will likely need to invest in a particular Python technology e.g. web development then market yourself accordingly. I would dedicate several months (or longer) to developing your skills before trying to make $$$. Even then, there are no guarantees. Good luck!
thank you ... perhaps imposm.parser is faster
It's look like a good idea to use postgis... I'll read documentation to see if it's usefull for me. 
Sounds like your company has terrible policies then. But there's definitely a middle ground between "Hire women unconditionally" and "Everything is already perfectly meritocratic, so you shouldn't give any thought to how you're selecting people." In a similar situation I'd probably advocate for an approach that isn't so skewed one way or the other, but I suppose you're at the mercy of whoever decided this policy is. 
&gt; It's strange to hear that 'await' is a more difficult thing than 'yield from'. 10 chars vs 5 chars. Furthermore, bare yields have been around for a long time (2001), so most IDEs and editors highlight it properly. New syntax would both harm existing Python 3 code and force everyone else to play catch up. Adding additional reserved words and substantially inflating the grammar adds further complexity. &gt; You probably haven't ever tried to teach 10 programmers at the same time how to use asyncio properly, and what's the real difference between yield/yield from. If you did and it went well -- kudos ;) I am the walking Python reference for my team. And we do use AsyncIO. One thing I've found – like generators, developers only "get" it after they've written it a few times. Something about coroutines always bolluxes people up I guess. &gt; And btw, you can continue using 'yield from' and @coroutine decorator for the eternity. Unnecessarily snippy and dismissive. On the contrary, just because others can avoid using a feature is in fact not a compelling reason to modify the language. I would observe other languages (c++ for instance) and the ensuing complexity within. Languages easily add features but do not easily deprecate them.
I'll admit to being a bit behind, but I'm still really excited about dict and set comprehensions.
What's about iTunes11?
Why would you do that, though? It already has to be called. foo.__len__ is going to return a function with no arguments whether it's a property returning a lambda or a normal instance method.
In general, running a flask app on the Pi is not too complicated, and it would solve your security issue as well as returning better data to the user (streaming updates, for example) and just be much more re-useable for future projects as you evolve what you want to do. I can't comment on the ease/accessibility of the previous poster's stack, but there's plenty of options.
I've developed auto complete fields using JavaScript and PHP so I guess it wouldn't be that hard to do it myself. Is this a better recommendation than any of the other ones here?
I've made autocomplete fields using PHP and JavaScript before. I'm sure I can figure out how to hook it into a self made Django REST service. Is it better to go down that route or should I do what you did?
Print is a function. Just super annoying to put those parenthetic quote wrapped strings in there ("he said as an aside").
Yeah no idea what they were thinking there, print "Hello World" Was the quintessential Python is so simple example. 
if you used python 3 you'd know this
I suspect this would be the kind of thing that you'd only use when manipulating \_\_new\_\_() and you need a dynamic version of some of these functions
It's obvious in hindsight, but attribute lookups against a class fall through to the class's class, e.g.: class XMeta(type): def __getattr__(cls, key): return ['nope!', key] @property def pants(cls): return ['yep!'] class X(object): __metaclass__ = XMeta print X.x print X.pants ... ['nope!', 'x'] ['yep!'] Since yield is an expression, you can write generator lambdas: import itertools def a(x): yield ['a', x] def b(x): yield ['b', x] c = (lambda n: (yield b((yield a(n))))) # I have no idea why you'd want to do this. print list(c(1)) # Or this, but it seems intriguing. print list(itertools.chain.from_iterable(c(1))) ... [&lt;generator object a at 0x10535cd20&gt;, &lt;generator object b at 0x10535cd70&gt;] [['a', 1], ['b', None]]
a,b = b,a
That there is `str.format_map` method, which is similar to `str.format(**dict)`.
I used this website to refresh my memory on basic programming test questions. It really helped me out. Now I don't stress as much with programming tests because I've already done so many.
Is print('Hello World') really significantly less simple?
Python's protocols are a pretty neat feature in general. One quick follow-up on creating iterators with `__len__` and `__getitem__`. If you have `__len__` return `float('inf')`, you get an infinite iterator. For example: class FourEach(object): def __len__(self): return float('inf') def __getitem__(self, x): return x // 4 for x in FourEach(): print(x) 0 0 0 0 1 1 ... 
* Proper cluster management using Swarm * Deploying docker container updates via fabric with zero downtime * Deploying infrastructure using Terraform instead of Docker Machine * Tying infrastructure together using a discovery service (Consul, etc) instead of hardcoding. Think of HAProxy and # of appservers :) * Centralized logging with Docker * Publishing from private docker registry
Thank you. that was an excellent talk. I'm still wondering about the [] on LHS
I'm not sure I get it. Can somebody explain the benefit of it compared to yield from and coroutines ? If it's just a different syntax, i don't see the point. "There should be one way to do thing" is important. So unless it bring something significant, I feel it's going to clutter the language. Python is simple and clean. Now with annotation, it will become possible to write hard to read code. Should we really add another thing to the syntax ? Or am I missing something here ?
I meant, why did it work in the first place
Bokeh is a more foundational library, using canvas, meant to support interactive applications. It looks like pygal uses svg, and is built around higher level charts. 
[inspect.getcallargs](https://docs.python.org/2/library/inspect.html#inspect.getcallargs) has been really useful to me recently. I found out about it a month ago when I was in the middle of writing a function to do exactly what it does and hit an issue with handling bound methods. It turns out my time was wasted. It's really nice when you're trying to handle some callback hell disaster with unknown/unknowable-until-runtime argspecs involving args/kwargs generated far up the stack from your actual call.
This is kind of a small one but the use of _ as a dummy variable sticks out to me. For instance, if you want to do a `for` loop but it's not important what the iterator is, you can make this very explicit by doing something like for _ in range(10): print("loop") You can also use _ for when you want to do something like grab only one of the values of a return that's a 3-element list. So let's say you have a function `position_vector` that returns `[x-value, y-value, z-value]`. You know how you can do something like x, y, z = position_vector(&lt;value&gt;) right? Well if you only care about the y coordinate you could do _, y, _ = position_vector(&lt;value&gt;) This helps make it explicit that in that function call you only care about the y value.
They were thinking it's useful as a function, which you can use in all kinds of places where you need more flexibility than a statement.
That's how inheritance works in almost every OOP language.
I don't think of metaclasses as a typical feature of OOP languages.
Four new magic methods that mimic existing ones, a new built-in exception that is like StopIteration but not really (I can't knock that, I've done it before) and two new keywords, one of which just gets tossed in front of existing things. I'm not convinced. And what was that bit about sys? It seems like this PEP is wanting to throw stuff in four or five places all at once. Why not locate the stuff related to decorating async stuff in the async module? And not sys and types where I wouldn't think to look for it.
Not that this isn't cool, but I've always found the terseness of Haskell to be a major point against it. I feel like I have to stare at Haskell code for a few minutes before I have any inkling of what it's doing. One of my favorite parts of Python is its use of ASCII identifiers for operators and keywords; it makes the code much more natural to read.
The OP originally wrote: &gt; It's obvious in hindsight, but attribute lookups against a class fall through to the class's class, e.g.: Completely ignoring the explicit `__metaclass__ = XMeta`, that's exactly how multiple inheritance works in PHP, Java and C++ to name a few languages. 
You probably wouldn't use it to swap like this, but there are cases where it's more clean to do multiple assignment like this, especially when the new values are dependent on the old ones, like in my Fibonacci example.
See also: [`inspect.Signature.bind`](https://docs.python.org/3.4/library/inspect.html#inspect.Signature.bind).
Yes. Also, breaks all 2 code on 3. It was just a terrible idea from start to finish.
Releases are signed by the individual release managers, so there's not one key. The [website](https://www.python.org/downloads/) gives a list of all the keys, and a [link](https://www.python.org/static/files/pubkeys.txt) to the keyring containing all of them. That keyring is served over TLS, so its authenticity is ensured by verifying the Python.org TLS certificate which is signed by a CA.
I can absolutely understand that. When I first learned Haskell I was really put off by the terseness, but once the learning curve is passed (which I am definitely still mounting) it becomes incredibly expressive. In this case, there are 3 standard functional concepts going on here: (:) - the function that prepends to a list Example 1:[2,3,4] ~&gt; [1,2,3,4] zipWith - Python includes a zip function. It returns an iterable containing ordered pairs created using each element of two other iterables. zipWith is a generalized zip function that combines the pairs using some arbitrary function of two inputs and one output, rather than constructing a tuple. In this case, we give it (+), to sum the pairs. Example zipWith (+) [1,2,3] [4,5,6] ~&gt; [5,7,9] tail - The remainder of a list, without the first element. This is very useful for 'consuming' a list until you hit the empty list, by recursing with the tail after acting on the head. Frequently, Haskellers will 'pattern-match' lists in their function declarations using this syntax: '(x:xs)' -- this means that, within this function declaration, 'x' represents the head of the list, and 'xs' represents the tail. So you can use the value of x, and recurse with xs. Examples: tail [1,2,3,4] ~&gt; [2,3,4] sum [] = 0 sum (x:xs) = x + (sum xs) So, putting it all together fibs = 0:1:zipWith (+) fibs (tail fibs) 'Seed' the list with 0 and 1, then let the recursive algorithm handle summing and concatenating the next set of results.
That I can go if 5&lt;x&lt;10:
python3 exception chaining - see pep3134
I learned that obscure language features confuse people. I learned that I could write in a clear concise style without decorators or iteratees and everyone was happy.
I didn't know this existed in Python! I've seen the wildcard character _ in SML and it's absolutely awesome. Even though some functional programming ideas are being added to non-functional languages, I'm a little disappointed that functional programming is still sometimes neglected since it's such a pleasure to program with.
You're a good man Charlie Brown.
I have several degrees in physics and while that's not mathematics I feel it may include some math. I have never heard patentheticals called brackets ever. This is probably due to brackets having particular use in mathematics such as defining intervals or the Poisson bracket to give two examples.
[Keyword-only arguments](https://www.python.org/dev/peps/pep-3102/): Required kwargs, and not allowing positional args to "fall through" to kwargs. In [1]: def fun(hello, *, size): ...: print(hello, size) In [2]: fun('hi') TypeError: fun() missing 1 required keyword-only argument: 'size' In [3]: fun('hi', 5) TypeError: fun() takes 1 positional argument but 2 were given In [4]: fun('hi', size=5) hi 5 
Mind blown!
itertools and collections are perhaps the best "bathroom reader" docs in the standard lib.
In your first call to sp.call, the outputFile variable has the path to the file. In the second, it has a closed file descriptor. Use a different name for your file handle. Also, I suggest that you look at using context guards for opening files.
If you want a `while True:` loop but want to be able to log how many iterations actually happened from itertools import count import random for i in count(): if (random.uniform(0,1) &gt; .5): break print("loop exited after {} iterations".format(i)) With this and `enumerate`, the whole `i += 1` thing is pretty much useless :)
decorators aren't an obscure language feature depending on the context. If you're using a framework/library of some sort that makes extensive use of them, then anyone needing to use it has to learn.
super works in class methods as well!
I'm very torn about this. On the one hand, unlike other programming tricks, this is a genuinely useful construct. I've used it multiple times for production code. I wish other languages had this as well. On the other hand, it's too easy for this to be confusing. Even in your example, it's not immediately clear if the 'else' clause is tied to the for loop, or if there was a typo and it's actually meant for the inner 'if'. I wish instead of "else", they used some other word for the 'for...else' construct.
That in strftime, you can add a dash to strip the zero from directives that give out zero padded decimals: %d = 09 %-d = 9 This is because Python is using the C implementation of strftime behind the scenes and strftime(3) from C lets you do that. Please be aware that this is platform specific though, due to certain platforms having a C implementation that adheres to the old C standard. And by certain platforms, I mean Windows.
how do you fail the for case or I guess how do you reach the else? 
Don't miss Beazley's 3-hour tutorial on generators from last year: https://youtu.be/D1twn9kLmYg . Goes into a lot more depth about using generators/yield (and yield from) in diabolical and mind-blowing ways.
First you should note that unlike in other languages (e.g., ML) where use of `_`, skips an assignment, in python it just assigns to a variable named `_`. I usually try to avoid using `_` as an unused variable name as it can overwrite your gettext i18n (internationalization) function which is traditionally imported as `_` (e.g., in [python documentation of gettext](https://docs.python.org/2/library/gettext.html) or it defined in [django](https://docs.djangoproject.com/en/1.8/topics/i18n/translation/#lazy-translation) ). For your example you can just fetch the one you need with indexing -- e.g., `y = position_vector(&lt;value&gt;)[1]`. Granted `_` is a bad function name in python; e.g., things can get screwed up in the ipython console, where your last output is assigned to `_`, but it is a standard convention from other languages -- so just have to live with it.
I learned that `self. blah` is the same as `self.blah` In retrospect I guess it's obvious that whitespace in expressions doesn't matter but this one really surprised me that it doesn't throw an error. 
For those puzzling about /u/Ph3rny's example, it's because chaining binary comparison operator `a COMP_OP1 b COMP_OP2 c` is syntactic sugar for `(a COMP_OP1 b) and (b COMP_OP2 c)`. For example, `5 &lt; x &lt;= 10` is syntactic sugar for `(5 &lt; x) and (x &lt;= 10)`, which is undoubtedly what was meant. Thus, `False == False in [False]` is syntactic sugar for `(False == False) and (False in [False])`, which evaluates to True. But if you meant `(a == b) in some_list` or `a == (b in some_list)`, you should never write it without parentheses as (neglecting this language feature) you would need to know which has higher precedence `==` or `in` (which only language experts will intrinsically know and experts will know that it actually doesn't consider precedence but evaluates it as `(a == b) and (b in some_list)`).
Somewhere very early in my development I got the idea that keystrokes were the most limited and valuable resource I had to concern myself with when writing any kind of code, and I was initially put-off by python and it's whitespace and it's widely enforced style guide, etc... But now that I've got code that I actually use in the performance of a real job that I make regular updates to, etc... I'm starting to get it. But then you I see stuff like tuple unpacking and it makes me think of that idea of packing as much logic as you can into the shortest number of keystrokes at the cost of readability, etc... Not that this even *does* that, necessarily, but that I couldn't really figure out where it made sense to draw that line, and tuple unpacking was firmly in the 'grey area' for me. One of the little 'ah ha!' moments I was talking about in that other thread was when Hettinger casually mentioned the idea of 'Thoughts per line' and it finally clicked for me. Tuple unpacking, list comprehensions (I also strongly distrusted these at first), etc make so much more 'sense' now. I'm not sure if this is a credit to the language, or I was just too out of sync to "get" Java and C++ when I was dealing with them in the past, but I'm definitely starting to drink the 'Pythonic Kool-Aid' now.
Came here to ask this. I thought this program was actually a great idea at first. Then I realized it was a great idea, and it has been implemented since the dawn of UNIX time (ok, ok, Bourne Shell didn't have aliases, but you could write functions in `.profile`, which is more powerful anyway. Apparently the C Shell was the first shell to offer the `alias` command). But srsly, if OP is so damn lazy, why is he duplicating effort? Furthermore, if this is /r/python, why is he posting his redundant shell scripts here?
That is correct. In the event that the for loop does not explicitly execute a break statement, or the iterable object is empty, then the code within the else clause is executed. &gt;&gt;&gt; for i in []: ... print i ... else: ... print 'nothing' ... nothing &gt;&gt;&gt; for k, v in {}.iteritems(): ... print k, v ... else: ... print 'nothing' ... nothing 
Doesn't shelve suffer from [portability issues](https://mail.python.org/pipermail/tutor/2010-May/075961.html) that pickle does? 
I don't really like this. Not explicit enough for my tastes.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 6. [**Call by sharing**](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing) of article [**Evaluation strategy**](https://en.wikipedia.org/wiki/Evaluation%20strategy): [](#sfw) --- &gt;Also known as "call by object" or "call by object-sharing" is an evaluation strategy first named by [Barbara Liskov](https://en.wikipedia.org/wiki/Barbara_Liskov) et al. for the language [CLU](https://en.wikipedia.org/wiki/CLU_programming_language) in 1974. It is used by languages such as [Python](https://en.wikipedia.org/wiki/Python_(programming_language\)), [Iota](https://en.wikipedia.org/wiki/Iota_and_Jot), [Java](https://en.wikipedia.org/wiki/Java_(programming_language\)) (for object references), Ruby, [JavaScript](https://en.wikipedia.org/wiki/JavaScript), Scheme, OCaml, [AppleScript](https://en.wikipedia.org/wiki/AppleScript), and many others. However, the term "call by sharing" is not in common use; the terminology is inconsistent across different sources. For example, in the Java community, they say that Java is pass-by-value, whereas in the Ruby community, they say that Ruby is pass-by-reference, even though the two languages exhibit the same semantics. Call by sharing implies that values in the language are based on objects rather than [primitive types](https://en.wikipedia.org/wiki/Primitive_types), i.e. that all values are "[boxed](https://en.wikipedia.org/wiki/Boxed_type)". &gt; --- ^Interesting: [^Eager ^evaluation](https://en.wikipedia.org/wiki/Eager_evaluation) ^| [^Partial ^evaluation](https://en.wikipedia.org/wiki/Partial_evaluation) ^| [^Lazy ^evaluation](https://en.wikipedia.org/wiki/Lazy_evaluation) ^| [^Strict ^programming ^language](https://en.wikipedia.org/wiki/Strict_programming_language) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqgaedb) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqgaedb)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Why not just s[-1] to get the last character?
Hm I need to look up dict comprehensions but without any special syntax a dict in Python can always be represented as a list of tuples making ordinary list comprehension perfectly capable of creating a dictionary.
How does this thing compared to Java's hibernate? I never use sqlalchemy so far...
How does this thing compared to Java's hibernate? I never use sqlalchemy so far...
what would be the 'proper' way to learn all these things? going through the official docs?
Raymond Hettinger talks about that in one of his talks
I'm not sure I'll ever use it, but that's *awesome*.
Also, any non-trivial use of `__del__` is going to be really weird when your program is exiting. Oh, you had something useful you were trying to do? Too bad, half the standard library's been deconstructed and replaced with `None` already.
I prefer, in the python style of "explicit &gt; implicit" and readability, stuff like `width, unused = get_positions()`
"CRM114 is a system to examine incoming e-mail, system log streams, data files or other data streams, and to sort, filter, or alter the incoming files or data streams according to the user's wildest desires." Starting your README with that would be an improvement.
Pyramid is good. Check out web2py and mini framework like flask and bottle. Write your own with werkzeug.
I got points taken off on a test for using this on a written test. I challenged the professor to type in my code verbatim. Made a 100. :)
Flask is awesome. Much leaner than Django (which I use at work), and vell documented. Nice tutorials everywhere. And Miguel Grinbergs flask mega tutorial has everything you'll ever need. 
Well, there's also the non-iterative approach: http://upload.wikimedia.org/math/5/9/9/5992591704ae747ece79e8808dcadd63.png where http://upload.wikimedia.org/math/4/9/e/49e8a76ceee7c67c84383ebdf06683be.png
Then I start wondering why a function is giving me so many irrelevant, nameless, positional return values. Also, I'm not saying that there's no other way to handle it! It's just my preference.
Thanks for making yet another pissing contest.
Wow thank you for this. That was really confusing but makes so much sense now. 
This cost me an hour recently... &gt;&gt;&gt; li = ['foo', 'bar', 'baz' 'hello', 'world, ] &gt;&gt;&gt; len(li) 4 &gt;&gt;&gt; li ['foo', 'bar', 'bazhello', 'world'] Automatic concatenation when you don't put a comma in a list!
There's really not much to it. Python with paho-mqtt and Mosquito MQTT broker. Setup a couple of Docker instances to separate the services on different virtual machines. Took a couple of weeks to write (evenings only). MQTT enables me to write new services that listen for events, I.e. I have a service that listens on "/notification/#" and whenever it receives something it forwards it as apush notification via pushover.net. That being said, I've reimplemented it all, including RRD graphs, in node-RED in less than a day, so it would seem node-RED is the way forward :-)
Try Morepath for something newer and off the beaten path. Full disclosure: I created it. For something really different try Nagare.
[A link to libcrm114](http://crm114.sourceforge.net/wiki/doku.php?id=wikihome) and a couple of phrases explaining why it's great would be useful too, I guess.
Wheezy.web is an interesting an quick one but imho requires too much boilerplate to get going. Ymmv.
Thanks, I just tried it in IDLE again it would seem that I did indeed just manage to fuck it up somehow. Anyhow, good to know, as someone who's fond of my TI-83 and its "ANS" button this could be nice. I could also see using this for exmaple, if it works in scripts and not just in interactive shell, for cases where I build up a string over a few lines to avoid having it run way over the edge of the page. (I'm a believer in not strictly adhering to the 80 column rule but something's wrong if your line is 300 fucking columns or whatever.) For instance, with something like string_output = "This is a test." string_output += " I like dogs." string_output += " Cats are nice too." it's clear enough what you're doing, but being able to refactor that to make use of `_` would certainly help make things even *clearer* since the `_` would make it extra clear that you don't care what the intermediate values of string_output are.
I like tornado whenever there's a possibility of needing something like websockets. It also has a lot of really nice features built in that don't get much fanfare (e.g., the `tornado.options` module for handling command line and configuration file options as well as setting defaults). It has its own templating system built in which is pretty good (although I think Jinja2 is a little bit better; for 90% of things, though, they are essentially identical). My only real complaint about tornado is routing is annoying compared to Flask (although if I remember correctly when I looked into Django, its method of handling routing is about the same as tornado). I've toyed with the idea of writing a little utility to add Flask-like decorator-based routing for at least simple GET requests. As others have mentioned, Flask is also quite good. Some things I like about Flask are its extension ecosystem, the werkzeug debugger (it's incredible), and as already mentioned, how it handles routing.
`__new__` does this. `__init__` is equivalent to a constructor in java or c++. `__new__` allows you to do silly things like make a class a factory or singleton transparently though.
It's got nothing to do with lists though, two string literals "side by side" get concatenated by the parser: &gt;&gt;&gt; ('foo' ... 'bar' ... 'baz') 'foobarbaz' that's convenient when you want to split up a string over multiple lines as you don't pay the cost of a runtime concatenation.
Take a look at *closing* in the contextlib library for automatically closing connections. 
Django's ORM is (generally) more suitable for Django projects. This is because it integrates seamlessly into the Django admin, form fields and other aspects of the framework. I might use SQLAlchemy for, say, doing complex reports but for the odd edge case and 99% of the project I'd just go with Django ORM + raw SQL. If you're not using Django, SQLAlchemy is hands-down a better ORM/data mapper, both design-wise and on a per-feature basis (and in any case it's non-trivial using Django ORM outside of Django).
`contextlib.contextmanager` is neat because it's lightweigh, though beware: contrary to a full-blown context manager object (with an explicit `__exit__`), the "cleanup" is *not* going to run in case the block raises an exception, unless you wrap your `yield` in a try/except or try/finally. So the "correct" base implementation is: @contextmanager def tag(name): # setup try: yield aValue finally: # teardown Contextlib also provides `contextlib.closing` for all the old stuff which has a `close` method but wasn't update for context managers, that's a cool one.
I like the design of Pyramid most of all - it has a very elegant way of handling things like authentication/authorization. Flask however has more extensions for getting things done. Depends of course on what you're thinking of building - I'm doing leaner backend APIs in my side projcts so I'm not so concerned about things like a template engine. 
It's probably worth mentioning that most of the times I've gotten involved with super-long strings, there's been an element of setting up a dynamically-generated string output. So doing it the way I wrote it out above seems beneficial for helping to call out where the dynamically-generated piece is being put in (I'll usually either give it its own line, or if I've already got a bunch of lines, stick it either at the beginning or end of one of the `+=` string concatenation lines to avoid further blowing up the number of lines I'm using. Or if it's a string with multiple dynamically-generated segments, I might want to give each of those segments its own line to help keep track of which chunk of code is generating which piece of the string.
Is it possible to write this using only total functions?
That's not just in lists. Try this: &gt;&gt;&gt; "hello" "world" 'helloworld'
/u/Lucretiel did that when (s)he said: &gt;Any other language has to have all kinds of state preservation variables and temps to do that.
I just checked and confirmed that it'd actually work using the same identifier multiple times. It assumes the last value to which it is matched.
that's damn annoying that "feature". I can't see any use for it and its a source of bugs. It would be better to raise an error if you forget the comma
Yeah, it's 4am right now (when i saw this) but can send you some stuff tomorrow!
I am not sure I see the point compared to tox though. tox -epy27 -- somecommand args Works just fine for me. 
Read again. It's not a typo.
&gt; What's the most recent new Python feature you have learned? Well, to my defense, this is easy to misunderstand: *What's the most recent new Python feature you have learned?* :-)
I've edited the post with a more elaborate example.
Uh, that's precisely why you should use _: to make your intentions more explicit.
&gt; Any IDE worth its weight will toss a warning Most people don't use IDE's... and Python happens to be a language where an IDE isn't nearly as important. It's not obvious that "" "" will concatenate, and it's definitely unpythonic and should be removed. It's really weird that it's still there.
Kinda neat, but while True in `__iter__` is much clearer
Another reason not to rely on `__del__` is that it may not work as desired in implementations that use true GC rather than ref counting like PyPy or Jython. It gets called when the last reference goes out of scope in cpython. In GC languages it may get called at any point later than that. Or not at all.
Agreed. If you need access to `len(whatever)`, though, your version wouldn't work. That's probably a pretty rare use case, but it's good to have the trick available when you need it. 
Come to Ireland then. Or presumably the UK too. Calling them parentheses is an American thing to my understanding (and consequently, a lot of English as a second language people too).
Hm. OK. THat means that probably pyGal is ok only for some small charts because as far as I know SVG can handle without troubles only a limited ammount of elements. If I have lot's of dots for example it will lag.
It's just blog spam. Pyramid and Pylons ? Grok ? It just feels like a random "top 10" list.
Note that, while new to you, that behaviour is actually an *old* thing about the language. It was basically the only way you could make things iterable before the introduction of iterators. Iterators and the `__iter__` method were introduced because there are cases where you've something that you want to be iterable, but which doesn't really support this more general case of **indexing** (which is a superset of iteration) - eg. files or other serially accessed streams. The only way was to do it before `__iter__` was to do it like this and pretend to support indexing in general, but have it break if something accesses things out of order. Speaking of old ways of doing things: &gt;raise IndexError Don't do this in modern python. It's also a legacy thing where raising the class and raising an instance of the class are treated the same, but the right way to do it is to create an instance (and while you're at it, giving a message is also a good idea). ie: raise IndexError("Index out of range") For some of the history behind why they are treated this way, it's due to the even older way exceptions were first implemented in python, where exceptions were essentially strings. The syntax for calling them was basically: raise IndexError, "Message text goes here" (Here "IndexError" wasn't the modern exception subclass, but basically a variable that had a string value of "IndexError"). When exception classes were introduced, they needed to retain compatibility with old code, so in essence, they just treat `raise ExceptionType, message` as equivalent to `raise ExceptionType(message)` and when message isn't present, as just equivalent to calling with empty arguments. However these days strings as exceptions are *long* dead. New code should really raise an instance.
That's pretty crazy.. can you point to some code that relies on it? When the abstract base class stuff landed, an extra dunder method was added to allow controlling `instanceof()`. Never used it and mostly would be suspicious of any code that did
Would you mind sharing the responses?
It might be, but in this case, there will never be the empty list passed in anywhere -- fibs always begins with 0 and 1. The partial functions in here won't ever hit undefined cases.
Interesting. I like the lack of ambiguity in the terminology parentheses (), brackets [], braces {}. 
 python3 -m http.server 8080 Starts a small web weever over port 8080 **from any dorectory** It's built into pythin 2.x as well but the command is more complicated.
One somewhat related neat thing in python 3 is that you can do similar stuff via a varargs style syntax. Eg: &gt;&gt;&gt; *the_rest_of_str, last_char = "hello" &gt;&gt;&gt; last_char "o" (There's one difference in that it'll convert `the_rest_of_str` to a list, rather than a string (ie `["e", "l", "l", "o"]` instead of "ello") You can do pretty neat generalisation of this, like: &gt;&gt;&gt; first, second, *middle, last = "hello" # becomes "h", "e", ["l", "l"], "o" respectively. It works for other types than strings, like lists and tuples, and also for iterables. Eg. want the first and last lines of a file? with open("some_file.txt") as f: first, *middle, last = f 
A simpler way to work with strings by using `str.format_map` and `locals()`. &gt;&gt;&gt; car = "Honda" &gt;&gt;&gt; year = "2006" &gt;&gt;&gt; owner = "Bob" &gt;&gt;&gt; print("{owner} has a {year} {car}.".format_map(locals())) "Bob has a 2006 Honda." 
Digging around the standard library is a good start. Another is to read other people's code. I've learned a bit by coding the exercises over at exercism.io. When I submit my solution, I'll see others' solutions. I've picked up many handy tricks that way.
the string could be empty and s[-1] will still work returning an empty string
ps would be interested in hearing any suggestions you have for incentivizing beta students...and a new Tesla for everyone is not scalable
appreciate it!
excellent. if you are selected you can delay your start until your exams are over.
I wasn't wrong, either- You have to keep a third variable besides a and b; that's your state/temp variable.
I mean the correct way to do it would be `(s.rstrip() for s in list_of_strings)`, but his/her example used map, so I wanted to show another cool way you can use map.
12 &lt; {} -&gt; True
You meant `c = D()` or `d = D()`.
As does "while"
Super isn't bad style if you know exactly how MRO is going to pan out. It's the kind of thing that if both the writer and reader understand it, the tool can be very convenient and effective.
Raymond's talk!
Why is it better? 
Keep in mind that shelf pickles your object, which makes it slow. If your object are simple enough and performance might be an issue, use json and one of the faster json library (e.g.: ujson).
From my experience, I'd say: eval your needs precisely and if you need a rich user interface, go with a javascript framework and use Django as REST, like said Glueon. If you just need some autocomplete fields, stay with the django extension.
Thanks! Perfect description. I've looked at both Beowulf and Parallel Python in the past but never more than a cursory glance. I have a use for PP in mind and will be checking it out soon.
Fair enough, but isn't that literally the exact same, minus 9 characters?
The example given by Allison Kaptur in her fantastic CPython talks at PyCon2015 was: &gt;&gt;&gt; False is False is False True
[py.test](http://pytest.org/)!! Don't bother with unittest!
~~a good use for those computers that are 10+ years old that you don't want to throw away~~ a good way to needlessly waste electricity on something your smart phone could probably compute faster
This exact problem actually caused me a good 8 hours of debugging 8 layers deep in a recursive loop. Fucking else clause wasn't indented. 
I really like this python3 feature. I often find myself wishing I had it when working in Python2.
I am surprised by the implicit print added in the for loop. I always use: for i in mylist: print i So this is the newest thing I learned about the python shell. Thanks.
It's not often that I find someone who I agree with so much on this :D I'm often criticized of "reinventing the wheel" or other such things, but I don't like working on a project and not knowing how the tools I'm using work, or when it's not that, I enjoy finding out how things work first hand by making them myself, and seeing why different solutions didn't work/weren't optimal. All very exciting stuff for me. After I can get a working model of my current problem, I'll take a look into your suggested modules, but I'm confident that this problem should be able to be completed with just math, so thank you for the suggestions.
Not necessarily. For instance, `a.__getattribute__` will use an instance-level `__getattribute__` which wouldn't be used in normal attribute lookup (dunder methods are generally looked up on the type, not the instance): &gt;&gt;&gt; a = A() &gt;&gt;&gt; a.__getattribute__ = lambda k: 'yes' &gt;&gt;&gt; &gt;&gt;&gt; a.__getattribute__('b') 'yes' &gt;&gt;&gt; a.b Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: 'A' object has no attribute 'b' &gt;&gt;&gt; getattr(a, 'b') Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: 'A' object has no attribute 'b' 
Found this out the other day: if you put the comprehension in parentheses, it's now a generator expression. If you pass it to a function, you don't even need parentheses. all(x % 2 == 0 for x in range(10))
I guess im lazy and would just put a celery on the machines and send jobs over a messagebus :-/
Hmm I don't know if I like this. For example I work a lot in Tkinter with canvas objects and use the object.coords() method which returns x0,y0,x1,y1. If I only care about the x0,y0 position of the object, I'll typically only create those variable and just ignore the x1,y1 that get returned with Obj.x, Obj.y = object.coords()[0], object.coords()[1]. 
Not sure I like the precedent of polluting def for a limited scope use case either. This is the reason decorators exist in the first place!
👌🏻
huh, thanks, I didn't know they (partially) fixed that in 3.4!
Welp, there goes my Saturday. 
Consider this example: You're making a 3D game, so you're going to need objects to have (x, y, z) coordinates. And you decide to go with a location tuple instead of objects have x, y, and z as separate attributes. Then for whatever reason, you find yourself needing to query just the z coordinate. Would you rather refactor to x, y, and z being separate attributes, or have to find some other way to get just the coordinate out, or would you like a clean way of getting the information out?
If you know your tuple contains [x,y,z] grabbing the z index should be clear enough with position[2]. 
Given that I'm often operating with two editors open side-by-side, excessively long lines of code are a meaningful inconvenience, and while I wouldn't advocate mindless adherence to line limits, I'd say that the cases where it really makes sense to have &gt;79 character lines are pretty rare. Are you nested 3+ levels deep? Occasionally this is unavoidable, but "flat is better than nested," so you should at least consider refactoring. This will often fix the problem. Are you only nested 2 levels deep? Then your logic is over 70 characters long, which often means you're doing too much on one line. Obviously there are exceptions, but the advantage of being able to count on a maximum width for setting up your workflow isn't trivial either, and the video seems to ascribe no value to it. The specific 79 character limit is maybe a bit of an anachronism, and I could see raising the limit to around 90 characters, but I *do* think that the advantages of having a hard upper bound outweigh the readability cost of the occasional line-break.
I can understand the list length issue. Early on in my education I didn't know the canvas.coords returned 4 positions. Someone looking at my code may not know that either so yeah, I see the value. I'd just rather document well instead. 
Yes. `__instancecheck__` and `__subclasscheck__` are what was added with abstract base classes. isinstance(x, SomeType) is equivalent to: SomeType.__instancecheck__(x) where instancecheck is usually (maybe has to be) implemented on the metaclass, eg. type(SomeType). Now all of this allows you to use abc.ABCMeta as your metaclass, usually by deriving from abc.ABC. ABCMeta implements both `__instancecheck__` and `__subclasscheck__` together with an .register function all so that you can do: class Sequence(abc.ABC): pass class MyListLike(Sequence): pass class MyListLike2(object): pass Sequence.register(MyListLike2) issubclass(MyListLike, Sequence) # =&gt; True issubclass(MyListLike2, Sequence) # =&gt; True However what this does not easily let you do is to create a type where each instance pretends to be a different isinstance() of any number of other types/ABCs. The `__class__` hackery will let you do this. And was available even before ABCs and `__instanecheck__`. **An example from Django** `SimpleLazyObject` which is used like this: a = SimpleLazyObject(lambda: True) isinstance(a, bool) # =&gt; True b = SimpleLazyObject(lambda: []) isinstance(a, list) # =&gt; True Here's the implementation where they override `__class__` with an property: https://github.com/django/django/blob/14ecbd02a337c15ffd0c319d14a56bf21127f42c/django/utils/functional.py#L296 In fact, the python-dev maillist had discussion about this exact class because it did not work on python 3. However the was to do with special handling of `super` together with the `__class__` hackery. Though it is fixed by now. 
I have to look all of those words up sometimes. I have a a rough idea of what those mqtt things are. I have set up a restful API through django and served with nginx in one evening in the past. So, I would agree with OP that this is overkill. I would suggest that OP, at their skill level, go with flask or django. But, could you comment on what the benefits of your more complex system would be?
I learned that one can annotate functions in Python 3, even if the annotation doesn't have any practical function yet: def square(x: int) -&gt; int: return x * x evaluates as entirely proper Python. Hooray! 
Why not? Swapping variables is a thing. A really clunky thing that requires a temp variable. This is clear, concise, and at the interpreter level, faster. 
I love this feature and I wish it were available in all languages. I hate it when I have to keep a boolean in java and babysit so that it would contain the correct value at the correct time. It's such a distraction from the actual content of the loop.
The standard formulas everyone knows... # it's pseudo python x = R * cos(theta) y = R * sin(theta) theta = arctan2(y, x) R = norm([x, y]) = sqrt(x**2 + y**2) # use norm; it's better In cylindrical coordinates you can do: # what you did and you don't need to convert theta2 = theta1 + dtheta we also get some new formulas from complex numbers x * cos(theta) + i*y * sin(theta) = R * e^(i*theta) # Multiplication r0*e^(i*theta0)*r1*e^(i*theta1) = r0*r1*e^(i*theta0+i*theta1) # Division r0*e^(i*theta0)/(r1*e^(i*theta1)) = r0/r1*e^(i*theta0-i*theta1) # Exponentiation (De Moivre's formula): (r0*e^(itheta))^n = r^n*e^(n*i*theta) 
for this particular example you'd probably just go for the triple quote though, no?
you can also do count(start=0)
Haha, this is pretty rad. Reminiscent of Ruby's `"#{}"` syntax. 
`-m SimpleHTTPServer` for the python2.x peeps
I guess it's just not something I've really had to do before. Usually I'm trying to update a variable (like adding on further substrings)...but yes, I can totally see why this would be great if you *did* want to swap variables. 
Not quite. This is actually because comparison operators (`x &lt; y`) fall back to `id(x) &lt; id(y)` (which is completely insane btw!). Thank goodness they fixed this in python3. small ints happen to have particularly low ids because they're initialized during interpreter startup (There's a similar *wat* moment when using `is` to compare particularly small ints vs particularly large ints, but I don't have an interpreter handy)
Pygal looks like the python equivalent for nvd3 or something like that which is packaged up all nice, but less flexible than d3. If you have a simple dashboard app that isn't interactive or is dealing with smaller data sets, it should work fine.
`iter(foo) is iter(foo)` is a really neat technique (and a fun talk from pycon) for writing functions that can accept iterables but not consumable generators. Suppose you write a function called `avg` like def minmax(values): return min(values), max(values) but then you realize that `minmax(i for in range(5))` raises `ValueError`. `min` consumes the whole iterable and then `max` tries to consume it also, but finds it is empty. The interesting thing to note is that if python can replay the iterable (can start again at the begin of a `list` or reiterator over `xrange` or reiterate over something defining its own `__iter__`) then `iter(foo)` is a new object. If it cannot, `iter(foo) is iter(foo)`. Back to the example, you might instead write def minmax(values): assert iter(values) is not iter(values) return min(values), max(values)
FWIW, I wrote my own stuff in about 100 lines of python and some BASH. Of course, I wasn't able to distribute the same task across multiple machines - I had multiple similar tasks, that each machine would compute and update the server with the completion status
Yeah, but imagine a beowulf cluster of those.
Awesome thanks for your help man. 
There's a difference between syntax errors and bad practice warnings. For example, Eclipse with Java will warn you if you're concatenating in a loop and suggest you use a StringBuilder which is more efficient. 
No idea sorry - I've not touched Java in over a decade!
Is ujson really faster than pickle for simple objects (dicts, lists, etc)? In any case, shelve is nice because it's zero effort. There's no explicit load/dump step to worry about, no issues with encoding, etc. It's a plain dict interface.
I * believe* that is because any time you have an expression in the interactive shell, the result is implicitly printed.
That's how I feel. The same with function annotations. Just have `async.coroutine` be the decorator that marks something as...well, a coroutine like it currently does. The await keyword I can live with, but just make it a syntax error to use await and return/yield/yield from in the same block. I'm not sure about async for/with. But there's got to be a better way. Then again, maybe I'm way off base because I don't use asyncio.
Yes, that was what I used in the past -- a list comp that produced key/value tuples, wrapped in a call to dict. So dict comprehensions are not some mind blowing improvement, but they really make that technique cleaner and more elegant looking.
I wonder if you're aware that problems can have solutions ?
Does this problem?
I really enjoyed this talk. The concise discussion of what makes a library Pythonic was fantastic. Probably a must watch for anyone who presents or uses an API in their Python code. 
Love it. Sending it out to my team for sure.
I wonder if you are aware that there is value in mapping columns to attributes on objects, regardless of the impedance mismatch, and thus why the majority of developers using OO languages continue to use ORM's. IMO, the problem is devs who lack the experience/imagination to come up with better abstractions than what falls out on a uml diagram and instead will throw the majority of the application logic in the same object that provides the row mapping. A similar problem is loading all kinds of coordination behavior that is really application logic into controllers. It's also an impedance mismatch problem but dealing with http instead of sql. Again the problem is lack of experience/imagination. Not existing abstractions or the libraries that implement them. 
you first
Along the same lines, I was pleasantly surprised to learn that `enumerate()` takes a second argument since Python 2.6: &gt;&gt;&gt; list(enumerate('abc')) [(0, 'a'), (1, 'b'), (2, 'c')] &gt;&gt;&gt; list(enumerate('abc', 1)) [(1, 'a'), (2, 'b'), (3, 'c')]
I guess you've never hacked on something old/slow/inefficient because you saw value in the learning and in making it do something new? Also, joy, surprise, pride, etc. BTW, I agree with the smart phone comparison... it would be great fun to cluster some of those, too!
 [Richard Jones - Introduction to game programming with Kivy - PyCon 2015](https://youtu.be/U14P8gtjQmU) 
Next time I would mention in the title of your reddit post that you're working with a data set too big to be loaded into memory or something similar. Otherwise I think people (myself included!) are going to think "Yet another intro to data analysis with pandas" link and ignore it.
I was surprised because I thought that "for i in range(5): i" as a whole is a statement with no meaningful value, but the shell peeked into the internal of the block and print out i's values. I can't imagine how this is implemented in python shell by following the general read-eval-print-loop rule, without treating loops specially.
You're apparently good at repeating what you've read(Atwoods Opinion). I'm not claiming the problem is solved or could be solved. So if the rest of your comment was supposed to be debating me about that, you should probably read again because i'm not typing all that again. Or continue bitching about things you have no control of. I dont really care. 
God I love downvoting people who talk about shit they know nothing about.
Thanks for pointing out.
&gt; Numpy is fast because it's just calling a bunch of C and Fortran code. You could say the exact same thing about R or Matlab, which happen to be other popular languages for crunching numbers. I say "other popular languages" because according to the [2014 KDNuggets Survey of Programming Languages for Data Science](http://www.kdnuggets.com/polls/2014/languages-analytics-data-mining-data-science.html) python is currently the 3rd most popular language, with R the most popular and just barely losing out to SAS for second place.
This should have been pretty obvious, but I learned that I could use an instance method as a decorator. &gt;&gt;&gt; class FunctionList(list): ... def register(self, func): ... self.append(func) ... return func ... &gt;&gt;&gt; fl = FunctionList() &gt;&gt;&gt; &gt;&gt;&gt; @fl.register ... def foo(): ... print("foo") ... &gt;&gt;&gt; @fl.register ... def bar(): ... print("bar") ... &gt;&gt;&gt; fl [&lt;function foo at 0x01039A08&gt;, &lt;function bar at 0x013E18A0&gt;] &gt;&gt;&gt; fl[1]() bar
&gt; Similar to str.format(**mapping), except that mapping is used directly and not copied to a dict . So probably to avoid copying or maybe for a "cleaner" syntax.
cool! Thanks. I will probably end up looking at this sometime.
Go watch Beyond PEP 8.
100% agreed. I used to be a big fan of 4-space indents, but I've been using 2-space indents for a lot of non-python programming lately, and I'm kind of coming around on the question. At this point, I really don't have much preference between 2-space or 4-space indents, but I *do* know I hate long lines!
Gosh I killed a lot of puppies.
Let me comment it up and throw it on Git real quick.
I used Basemap for a bit, but I decided that the final product that I wanted to display would be much better served in Google maps. (Basemaps weren't detailed enough for my purposes.)
&gt; Sometimes it's hard to squeeze a name down to just 4-6 characters. You absolutely shouldn't be doing that. Doing that makes your code more unreadable.
&gt;Given that I'm often operating with two editors open side-by-side Should I shorten my variable names and potentially make them more unreadable to accommodate you? &gt;Obviously there are exceptions, but the advantage of being able to count on a maximum width for setting up your workflow isn't trivial either, and the video seems to ascribe no value to it. He did say roughly 90 would be better. Personally I think a hard limit of 100 would be ideal. A 95 character line is *much* better than an 85 character line where the programmer damaged their code to get it under the limit. A 100 character line means you probably don't have to do any damage to get it shorter and you're likely to be improving instead.
Learn html. Python replaces the things you have listed.
If people you're working with all use 4-space indent, you have no other choice, it's not entirely up to you.
I have markers at 80, 90 and 100. Recommended, soft and hard limits respectively. Works a treat for me personally. 
So I can use just Python for web development?
&gt; Should I shorten my variable names and potentially make them more unreadable to accommodate you? Definitely not. Well, if you're using 15+ character variable names all the time, then maybe, but generally no. On the rare occasion when you need more than 79 characters, add a line break somewhere. Yes, that can be ugly, and the code will be a little less readable, but it's a trade-off, and it shouldn't happen often, and occasional loss in readability is more than compensated for by the advantages of having a hard cap. If you're getting 80+ characters lines often it almost certainly means you're doing something wrong. &gt; He did say roughly 90 would be better. I don't even disagree that longer might be better. I just didn't like the 'roughly' part. For any project you should have a hard limit, and it should be low enough that at most reasonable resoluations with a readable font size you can reliably get 2 full-width terminals side-by-side. I'd have to play around a little to form any real opinion on what the optimal length is, but I agree that it's probably greater than 79. &gt; Personally I think a hard limit of 100 would be ideal. Wherever the optimal point is, for any open source project I'm definitely sure it's lower than 100 right now. A lot of people do work on WXGA laptop screens, and that would be annoying for them. I guess 100 could be ok for a private project if you know everyone has 1080p screens or something
Loved the talk, but I don't know how it could be implemented better. The Python community in general is very self-aware with these kinds of issues. I don't think a "you should change the way you think" initiative will be very effective, though it might be needed. What do you think the root of the problem is? Is it ego? Is it romanticizing good programmers? 
Yeah, that's why I didn't suggest the 2-space indent in my original post. It's an option I think people should consider, but I'm definitely not advocating it is a real solution to the problem all the time
Python can handle the back end. You will still need to use HTML and css to display content to the user.
Hybrid attributes looks very cool, thanks. 
noted, I've made an update.
This. Would have been more specific, but I was on my phone. Sorry.
Can be, but only if it has a very limited context (e.g. a small loop or a few lines within a context handler). If you are passing a variable among various different methods &amp; different file it really pays dividends for it to be long, descriptive and disambiguated. The person who comes along and changes your code later won't be scratching their head thinking "just what the hell *is* this log object and what does it do?".
I enjoyed the [Rust](https://www.youtube.com/watch?v=3CwJ0MH-4MA) talk, the [Bokeh](https://www.youtube.com/watch?v=O5OvOLK-xqQ) talk, and the CPython talks were really interesting: https://www.youtube.com/watch?v=ZSIRGLmQTLk https://www.youtube.com/watch?v=HVUTjQzESeo 
Check out his other videos too. All of his videos are worth watching IMO. Hettinger makes it super interesting.
Generator expressions often look better split across lines anyway. Break it right before the for and the if. (You wouldn't write a for loop on one line.)
&gt; Are you nested 3+ levels deep? The nature of my team's code means I'm virtually always within both a class and a function. Throw in an if statement or a for loop at I'm at 3. Throw in anything even slightly more complex than that, plus descriptive variable and function names, and you hit 79 characters real quick. We recently moved our max length from 80 to 100 with virtually no complaints. Before that, people frequently just ignored the limit when it was inconvenient, making it even more annoying because it wasn't respected. Now, people actually put in some effort for longer lines and I think everyone's benefited.
[Sasha Laundy - Your Brain's API: Giving and Getting Technical Help - PyCon 2015](https://www.youtube.com/watch?v=hY14Er6JX2s) I saw it live, and watched it again later, and then emailed everyone at my company to watch it.
Is anyone aware of a good resource for finding the magic methods utilized by various "interfaces" in python? For example, contextmanager uses `__enter__` and `__exit__`, iterables use `__len__` and `__getitem__`, and so on. I tend to avoid creating these even though I'm fully aware of them and their uses because I'm never sure that I've covered all of the use cases and expectations for doing so.
^^^^^^^^^^^^^^^^. Here's the media found in this post. ^^^^^^^^^^^^^^^^. ^^^^^^^^^^^^^^^^. |Link|User| |:-|:-| |**[Rust](https://www.youtube.com/watch?v=3CwJ0MH-4MA)**|*[erewok](/r/Python/comments/331w6r/_/cqh5i2f)*| |**[Bokeh](https://www.youtube.com/watch?v=O5OvOLK-xqQ)**|*erewok*| |**[Richard Jones - Introduction to game programming with Kivy -...](https://youtu.be/U14P8gtjQmU)**|*[ktkization](/r/Python/comments/331w6r/_/cqgr2nj)*| |**[Jacob Kaplan-Moss](https://www.youtube.com/watch?v=hIJdFxYlEKE)**|*[manfre](/r/Python/comments/331w6r/_/cqgyau5)*| |**[Sasha Laundy - Your Brain's API: Giving and Getting Technica...](https://www.youtube.com/watch?v=hY14Er6JX2s)**|*[MyWeekendShoes](/r/Python/comments/331w6r/_/cqh7dm4)*| |**[Performance by the Numbers](https://www.youtube.com/watch?v=UAztOuO1ANQ)**|*[phinar](/r/Python/comments/331w6r/_/cqgy3vl)*| |^^_______________________________________________________________________________________________|^^______________________________| *^Downvote ^if ^unwanted, ^self-deletes ^if ^score ^is ^0. ^Comment ^will ^update ^if ^new ^media ^is ^found.* [^about ^this ^bot](/1vjdw9) ^| [^recent ^playlists](/r/radditplaylists) ^| [^plugins ^that ^interfere](/1m21ku) ^| [^request ^blacklist](/message/compose/?to=radd_it&amp;subject=Please blacklist&amp;message=Please add me to the /u/PlaylisterBot blacklist.) ^| ^R.I.P. ^u/VideoLinkBot
Scheduling troll putting them at the same time. They need to do a live coding duel next year.
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
Could you let me know if this works if you download the file? The embedding works fine on my local IPython notebook setup, but breaks on nbviewer. https://github.com/zphang/gmaps
Beyond PEP8. That had some real good tips for some people who miss the point of cleaning up code.
Here's another solution (can't post on SO). This is based on the main insight in the top answer, that the string will belong to the set of its rotations (nontrivially). I wanted to see if I could get something just as fast without using `str.find`. It's equally as fast when tested against things that *don't* repeat themselves, and 8-10x slower when tested only against repeating strings. def principal_period(s): if s in (s*2)[1:-1]: i = 1 n = len(s) skip = set() while True: while not n % i == 0: k, j = i, 1 while k &lt; n: skip.add(k) k *= j j += 1 while i in skip: i += 1 if s[:i]*int(n / i) == s: return s[:i] else: i += 1 while i in skip: i += 1 else: return None EDIT: just tested without the sieve logic and it's marginally faster for the dataset on the SO question: def principal_period(s): if s in (s*2)[1:-1]: i, n = 1, len(s) while not s[:i]*int(n / i) == s: i += 1 return s[:i] else: return None
First result on google is a pretty cool rundown on each one: http://www.rafekettler.com/magicmethods.html
##HOLY CRAP THAT WOULD BE AWESOME.
Does anyone actually use ast.literal_eval? I understand why we shouldn't use eval but this half measure doesn't seem like it would have a good usecase.
&gt; I do and I am unapologetic about it. Here's one I picked earlier: postgres_stderr_log_handle I'd probably shorten it to `postgres_stderr`. `handle` really doesn't clarify a whole lot, and by default any reasonable coder will assume `stderr` is a file handle. If it were a filename, I'd be willing to get a little wordy and go ahead and call it `postgres_stderr_filename`, but you shouldn't be passing around and using filenames all over so that shouldn't be much of an issue. &gt; They can't necessarily determine these things from context, because it's being passed into a different method in a different file. In this context, the variable name could quite potentially be something different in the other scope. Is it being passed to a function that writes a log? Then the function should probably just call the variable `logfile` or something like that. This will depend on what the function does obviously. &gt; The line limit should not be put in place to accommodate your or anybody else's personal choice in text editor or monitor. It should be there to help make the code more readable or not at all. Right. And part of readability is having lines that don't wrap off the end of the screen. The reason for character limits on a line is to make the programmer consciously put a line break in an intelligently chosen place instead of leaving it to be wrapped or truncated by an editor that can't handle the whole line. If all of your expected readers have 100-column wide editors, then fine! Go ahead and make the limit 100! But if many of your readers are going to be viewing your code in 80-90 columns, then if you have 100-column lines all over it's going to be totally mangled by their editor. If you really don't care about accommodating your readers, then just do what you wan't! &gt; It's 2015. Even my $100 phone can accommodate 100 character lines. If you're content working on code with just one file open and visible at a time, and don't find utility in having two side-by-side then sure. I'll note that the speaker certainly made use of side-by-side view though. It would have been a lot harder to follow if his code hadn't all been short lines of code.
It does have a good use case. eval can be a security risk and literal_eval is considered safe for arbitrary user input. It parses it, does not execute it, and only returns it if it's a literal. OTOH, passing "os.system('rm -rf /home')" into something that runs eval is certainly not safe. &gt;&gt; ast.literal_eval('os.system("ls")') ValueError: malformed string &gt;&gt; eval('os.system("ls")') 0 
Don't be silly, `reverse` is too readable!
&gt; I'm referring to dealing with the problem in a practical sense in order to get things done. Read no further than this, because I deal with fucks like you every single day. Committing atrocities in the name of "getting things done" is exactly the kind of shit that keeps me up at night. Go fuck yourself.
I built a data analytics tool and it allowed you to specify custom queries/filtering of the data using lists entered into a text box. EDIT: And yes I'm sure there are better ways to do this, but it was a tiny feature on a massive 2 year project that just needed to be implemented. If users heavily utilise the feature then we would improve it.
Since all the obvious frameworks have already been mentioned and also because you're already familiar with django, I'll go ahead and suggest you take a look at two very different approaches to web development: - webalchemy (basically the Python version of Meteor) - Aspen (I'm still on the fence whether this is genious or just insane)
Is that all of your code? Because if your IDE is telling you those functions are not used, it's simply a hint to let you know that you can maybe remove them since nothing uses it anyway. But if something else calls your code and will use those functions, you can ignore the message. 
Yep. 
The author mentions that this is not suited for computation but better for IO bound tasks like webscraping. Is it really? I would have thought that the bottleneck for that would be the bandwith of your internet connection. Why should it scale with numbers of computers?
"from \_\_future\_\_ import something" is intended to import python 3 functionality in python 2. There is also "from \_\_future\_\_ import print" which imports the functional form of print that is used in python 3.
It may sound a bit naive to ask, but how would you compare this to like Cellery or RQ? Is this something suitable for web clusters?
On most cloud services each instance gets its own bandwidth slice from the providers massive pipe.
Hey, instead of manually typing out the alphabet like that -- and using a dict to store it -- take all of that out and at the top of your file add: `from string import ascii_lower, ascii_upper`. Strings are indexable just like `list`.
GIMP is not written in Python, but if you look at how dimension fields (eg. width, height, PPI) in GIMP work, you can see what is essentially equivalent to literal_eval is very useful. It allows you to express, for example 'add 128 to the current image width', rather than having to calculate mentally what current_width+128 is, and substitute it in. or 'multiply the image dimensions by 1.2' (ie. increase them by 20%), or even 'divide the image height by (45/13)' Like pqu's example, this is a UI enhancement application of the idea. I suspect other applications of the idea will also be UI oriented. EDIT: as d4rch0n points out, this is incorrect. It's based on a misremembering of what literal_eval exactly does, so feel free to ignore it.
... Huh... I wonder; do I want to let users potentially shoot themselves in the foot such that advanced users can return different handlers based on state...?
Yes you are right. /u/Vorticity has already mentioned that `__future__` is used to import Python 3 functionality. I have clarified it in the article as well. 
What state are you talking about?
Your welcome =) 
Maybe a user will want to handle a failed password in a different way depending on how many times they previously failed the password, and they'll decide the best way to do that is to have different handlers? I'unno, I'm not a user. (Yet).
Really nice concept! But putting an empty list or any mutable in the default arguments is a code smell. I really recommend using type annotations for that use case. Anyway, thats just a nitpick, I'll try out argvee anyway.
This script gives an automated answer based on the number of youtube views. It also works with other conferences on pyvideo.org.
My bad, didn't notice the link I just assumed it was a question due to the title . Love the script though, think I'll play with it soon. (If you hadn't mentioned it I probably would have missed it, thank you for being so nice) o7
Yeah, that's a good point. I was going from, obviously faulty, memory of what literal_eval exactly does.
Debain releases have been, and will continue to be, 2 years apart: http://en.wikipedia.org/wiki/Debian#Release_timeline 
Unfortunately it does.
Why unfortunately? If you want it to return 0 you could use 1//2.
Nope, I just need to know more than one is present. Thanks for your suggestion, I always seem to forget that `timeit` exists.
I just ran it, important to note: - python3 - pip install pafy requests The results are very similar to: https://www.youtube.com/channel/UCgxzjK6GuOHVKR_08TT4hJQ/videos?view=0&amp;flow=grid&amp;sort=p
Also switched from rails to python (django) and agree with almost everything thats said by /u/sonobenissimo (except about the indentations :) ). Also did some flask work but didn't find it a huge difference due to having worked with sinatra previously. I think the languages are similar enough that you won't gain as much in terms of knowledge, compared with switching to something like go or haskell. But then again, learning more languages is never a bad thing!
Ah, okay, that makes sense. 
On that note changing the behaviour of all following divisions by that import instead of specifying exactly what you want when you divide looks like the perfect ammunition for shooting one self in the foot. Swapping default behaviour around is just evil and cruel when it stops being obvious.
I'm relatively new to Python and I'm stuck with Python 2 since I'm using the VTK, so it's helpful to me. Why would it be detrimental to have information available on both?
There is also `from __future__ import braces` if you don't like whitespace.
The attitude I'm taking these days is that for packages which are likely only to be used in new codebases I go for Python 3 only. If it's something which likely to be of use in a legacy codebase then there's more of case for Python 2 also. If the code was really text/encoding/Unicode heavy that would push me away from Python 2 support.
Be sure to check out [Flask](http://flask.pocoo.org), too.
Because it's confusing for newcomers. I've almost literally heard people quit because of the confusion. (the compability break from Python was still a great choise though, but a very hard one) Nevertheless, I understand you appreciate it. Might be best if it would be primarily written for Py3 , but a mention of "here's how to do it in py2".
Totally unrelated to Pycon, but there is an AWESOME video about a guy who's been doing python for years and years, and he gets brought in to be an analyst for a copyright violation suit....he has to look at all the code and a bunch of other stuff...anyways, the story is about Python and its utility in that situation. Don't know where its at...but its an awesome video to listen to (don't even need to watch it) about python
I would use Celery for running the tasks and monitor them with Flower. http://docs.celeryproject.org/en/latest/index.html http://flower.readthedocs.org/en/latest/
Excellent, thanks. I'll have a look.
Just a friendly reminder that PyOhio's call for proposals are currently open. Submit a talk today! We love first time speakers. http://www.pyohio.org/call-for-proposals
Ah yes, the silver bullet.
I'm far more bothered by docs.python.org automatically directing you to 2.7 doc page. e.g. https://docs.python.org/library/random.html
&gt; Totally unrelated to Pycon, but there is an AWESOME video about a guy who's been doing python for years and years, and he gets brought in to be an analyst for a copyright violation suit....he has to look at all the code and a bunch of other stuff...anyways, the story is about Python and its utility in that situation. &gt; &gt; This is David Beazley! http://www.pyvideo.org/video/2645/discovering-python
I think the second one is better to read and as you said it short-circuits, so it might be faster. But I'd refactor it to use `any` and check for inequality, because it read more like a sentence that can tell about your intentions: "if any value is not like the first value, do something" But this is just a question of taste, I guess. Other than that, as already mentioned, just `timeit` using your real dataset.
`3 // 2` Were you aware of this trick?
The easiest way to port your code is to use the built-in 2to3 module. It will do 90% of the work for you. There are also fantastic Googleable resources.
Hey, do as you please, but you don't seem to be showing much commitment. 
No relevance to iTunes 11 at all
Santa Monica has a ton of jobs too. 
web2py is considered the anti-django (and perhaps anti-python) by the Django and Flask people. I don't think this is justified; it is different than Django, for sure - and it sets up namespaces in a way that makes things particularly comfortable, but does get purists up in arms.
Hmm, this talk didn't clear things up particularly well for me. Maybe it's because I'm a very visual person and IMO this topic cries for some nice class diagrams. I also didn't understand why he was using `super().foo()` instead of `self.foo()` all the time. What's the difference? And is it different in Python 2 and 3? I'm using 2 exclusively. **UPDATE** Okay, I wrote this comment after watching only 30min of the talk. After that it got kind of visual but it was too confusing. Also the `self` vs. `super()` question was answered in the Q&amp;A (way too late :/).
I'd use the first one as it is clearer. If speed becomes an issue, I'd first measure the whole program to see if the issue is in that bit of code, and if so measure both algorithms like suggested and switch it if and only if the second one gives a serious improvement in performance.
From what I remember it was so that it works with inheritance properly right? It'll keep calling `foo()` up the chain?
Celery makes a lot of sense for running millions of message-driven tasks with low-latency, lots of parallelism, and recoverability. Which is an entirely different problem from running a backup.
not sure what you are trying to do, but suggest that you need to build a searchable index of your commands - see whoosh or sql-lite's capacity for this. (https://pypi.python.org/pypi/scout/0.1.3 ) - I used this kind of approach to build http://www.talkigy.com
`super().foo()` calls the next `foo` in line. `self.foo()` starts at the beginning of the inheritance chain, so it would probably call `foo` of the current class instead of the one which is next in line.
As I said, the question got answered in the Q&amp;A of the talk ;)
after your if statement put another if statement with and then use continue if true to go to the next number and if false it will fall to your print. Also use a comma after the print statement to suppress the newline. good luck!
&gt; but just telling you this flat out would have sounded a bit harsh. It wouldn't have. It's my own fault that I didn't watch it til the end. The MRO thing is still very confusing though. Now I could go and read about [the algorithm itself](http://en.wikipedia.org/wiki/C3_linearization) but I'm too lazy to do that. That's part of the reason why I watched this talk in the first place. Unfortunately it didn't do a very good job explaining it.
Probably because itertools.product can do this over N inputs, returning a single tuple instead of the nested tuples you would have with multiple multiplications, or you can use nested for loops or list comprehensions. These implementations also work with any iterable, not just lists. There also hasn't been much of a desire for it, anyone coming from another language would be quite confused, while addition is pretty intuitive for anyone. 
The only important thing you need to know about the mro is that it's monotonic: if you can successfully define the class, then it is guaranteed that every base class in its class hierarchy will appear in the mro before all of that class's own ancestors. 
I use it as the deserializer for my serializer (serpent) which outputs python literal expressions. They are more expressive than json. For example, they can contain sets, something json doesn't have. 
As mentioned by other people in this comment thread, there are plenty of other serializers/deserializers, such as json (which is faster; a builtin module as well; and a standard), for converting strings to data structures and vice versa. Is there something specific about Autodesk Maya that requires data to be in a Python literal format?
I actually agree. I thought it made more sense to do integer division by default; I can't shake the feeling that this change was made to be more newbie-friendly, which isn't necessarily a bad thing, but I would have preferred the py2 behavior... Oh well. I've dealt with worse things in my life.
I do think `self` would have been more appropriate than `super` in all of his example code, since he was never overriding the base class behavior in the first child class. It would have been more useful if, say, the `Pizza` class had a `get_dough` method of its own that did something like: def get_dough(self): return super().get_dough() + " kneaded out flat" Then the `order_pizza` method would just call `self.get_dough()` where the magic stuff would happen. You probably shouldn't call `super` if you don't expect a method to have been overridden (and want to skip the overrides from your current class and all of its children). Most of the time you're using `super` to get the previous version of the current method (which you're in the process of overriding).
In the future, please post these questions to /r/learnpython 
From the sidebar: &gt; If you are about to ask a question, please consider /r/learnpython. Homework-style questions will be removed, and you'll be encouraged to post there instead. So I wouldn't be surprised if this is taken down soon, but: In order to get 10 items per line, you'll want to keep a count variable that keeps track of how many items you've already put down—you can increment it every time you call the print function. When printing the last item in a row, you need to print without the end parameter (or just substitute `end='\n'` to get a newline). You do have lots of options on how exactly to structure that. Try anything you can think of until something works, and you'll learn better the more of it you do yourself.
No the iTunes 11 reference makes sense. When you select an album it uses similar /dominant color matching to change the highlighting to match
Read [PEP 465](https://www.python.org/dev/peps/pep-0465) for all the historical reasons why this hasn't been the case and the proposed solution of how to solve this in Python 3.5
Thanks. That was my thinking as well.
Yes, people with jobs who I work with at my... job. You're a fucking idiot.
"One word: plastics."
Only if you do basics. Interfacing with OS and protocols when Unicode is involved became a lot more involved and complex.
You're going to need to give us more information than that. A good place to start would be: what script?
/r/learnpython
I don't understand the second example with the people. how do you call a parent (err the next one in line) who doesn't call its super. he said something about an adapter but I'm not sure how that's supposed to work.
Using `print(.)` instead of `print .` wouldn't cost much. OP please... The other issue is that `__future__.division` import, you should really present `a//b` which is the way forward to perform rounded divisions. The future is now.
If you want to move anywhere outside of webdev or devops, Python is a good choice. "Pure" ruby has little commercial usage aside from chef - while it's not incapable of other tasks, python has a much much much larger community doing non web-y stuff. Most importantly it means you get libraries for all manner of wonderful things.
Be thankful you're not a physicist trying to get a job in data. 
Is it difficult? (asking as a physicist trying to get a job in data)
&gt; You're a fucking idiot. And you're clearly a team player. You calling me and idiot is not nearly as convincing as how I dismantled your entire argument and made you look like an idiot for the whole world. 
I'll mention I'm a PhD who studied theoretical condensed matter. Used a ton of python, but obviously no databases, pure machine learning, or manipulations of large data sets; all pen and paper quantum field theory taken to a point that needs numerical solution. All the NumPy and SciPy you could ask for. For those that don't know, many body quantum mechanics (quantum statistical mechanics) is highly transferable to the world of machine learning. Any PhD could easily hit the ground running (like a cheetah) in a machine learning environment. The analytical thinking and highly evolved mathematical skills physicists have should be making companies wet themselves, but they don't see it that way. You're going to have to become an amateur machine learning practitioner, working full time to solve interesting problems all while being unemployed or working at your current job. Then blab about this project on your resume so it'll make it past the waste bin.
https://github.com/areski/python-nvd3 or seaborn or prettyplotlib or ggplot, if you're into that sorta thing. 
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
OO! big fan of d3.js, did not realize this existed for python... exactly what I'm looking for. thanks :) 
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
&gt;requirements are a wish list So much this. I'm in a different industry, but "Oh yeah, I've dabbled, but I haven't had the chance to really use it in production. One of the reasons I'm excited about this job is for the opportunity to really dig deep and master this..." 
I use SQL for my research along with the scientific python stack. I've been doing it for about five years now but finding a permanent position is not so easy.
I am using Python 2.7. I downloaded the most recent version of the Pygame .msi off of their website and ran that installer. I am running on Windows 7 64-bit. Do you want me to expand on how I installed Pygame?
I can't imagine that pickle has any binary compatibility issues. That particular link is purely speculative, and they don't make any mention of it in the documentation. I can't imagine they were foolish enough to let endianness be a big deal... a byte is a byte on any platform, so as long as they serialize all their data to a byte stream in a deterministic way (i.e., one byte at a time) then I'm sure it's fine.
If you are writing a module, the top level name of the module will be used as a namespace anyway. If you need a namespace inside of an existing module or whatever, then using a dict is fine. Python usually handles scoping internally with dicts anyway.
That's still not enough information to answer your question. - I don't use Pycharm — does it install its own Python interpreter? Do you have multiple interpreters installed? - What happens if you try `import pygame` from the stock Python interpreter? - Where did the module actually install to? - Did you match the bitness of the module and the interpreter? Lots of people install the 64 bit version of Python and then try to install a 32 bit version of a binary module, for instance. 
Namespaces are implemented with dicts, but that doesn't mean you should use the terms interchangeably. They mean different things; a namespace is a specific example of the kinds of things you can do with a dict. (For that matter, a dict is a specific example of a mapping, but that doesn't mean all mappings are dicts. A list of tuple pairs is a mapping that isn't a dict, for instance.) 
Hi, So in python 3 the print is actually a function now so it requires that you use ()'s. The shell will hold your hand when you return variables and go ahead and print them for you, but when running a regular program it will not, it will also throw an error when if you forget the ()'s
I think the best way to understand super is just playing around with PyQt a bit One day you'll have a specialized button widget, and you'll want the button press to do whatever it is that buttons normally do (super call) and then some extra stuff afterwards. Voila! That super-init call you've been making every single time you instantiate a widget, kind of by routine without really knowing what's going on, now makes perfect sense. You want to do do all the millions of tiny things init has to do as routine (set up painters, hookups, god knows what's going on in there), and then some on extra on top, pertaining to your app. In fact, learning PyQt was an incredible way to just learn everything OOP-related in Python
I am truly sorry for the lack of information. I was on my phone when I was typing out the previous info and neglected to be thorough. 1. I do not know if Pycharm installs it's own interpreter. I am starting from zero here; my knowledge is quite limited. All I know is that I have not installed any interpreters myself. 2. I originally did try *import pygame* using the stock Python interpreter, but I got the same results. 3. Upon installation of Pygame it does not give me an option to select the directory, so I do not know where it is installed. 4. I did try matching the 32-bit Python installation with the 32-bit Pygame, but when that did not work I found a 64-bit Pygame from a different website. Before trying each time, I would do a complete uninstall of both Python and Pygame. Please forgive me for my cluelessness. 
No problem. It trips up a lot of people. In python 2 the ()'s weren't required but they switched it up when they moved to 3.
@Fabian, nice library. Thanks for that. I recall seeing something similar a while back but for the life of me cant seem to find it now. Anyway, is this is a fork of(or based on) easyapi? If so, could you please post a link to what you based it off of. It would be useful to see the differences, pros/cons etc. Thanks in advance. 
Mix-in classes via inheritance in python are a form of composition. If there are no overlapping methods it's all pretty equivalent.
My new favorite to pretty print JSON: cat file.json | python -m json.tool So imagine piping the output of curl to it... bliss!
Yeah, I would argue that this is more of an issue of using bad editors than anything else. For example, Notepad can often result in problematic line endings, which can be a problem in many languages and not just Python. Why not use Notepad++ instead, where you *can* indent blocks and it has a variety of features that make coding more convenient. Of course, I'm a vim-addict myself, but I can completely understand why people would want something more basic - Notepad++ provides that experience on Windows. I believe Gedit provides similar capabilities on Linux operating systems. 
If anything I feel it makes the code even more readable, I am a function over form guy, so as long as my code runs I don't really care how the indents are and how it looks( I know I'm a horrible person), but it's syntax in python so I do it automatically.
Cartesian product and matrix product are not the same thing.
I think that's what he was talking about when he told us to do away with the traditional Java-esque answer to "what's inheritance useful for?". His answer is code reuse, and indeed he shows how his use of inheritance allows him to reuse code. I've seen way too many cases where you could argue that in the philosophical sense something was-a something else, but having one inherit the other not only did not enable code reuse, but actually required even more code just to make the inheritance kind of work.
I'm finally getting to use Python at work. ANOTHER benefit of indented blocks is that it can make code reviews very easy. It doesn't take long before you can see smelly code without even reading it.
I have found it is best to install modules is via pip vs downloading and manually installing. My only other concern would be did you download the pygame version to match your python version? There is a 32 and 64 bit....but there is also a 2.7 and 3.4 version as well. You have to match the versions and the bits.
Yeah it is cool, but how do you stop the server once you've finished with it? 
Ctrl+C ?
Upvoted for unpopularity of opinion, but I disagree. Editors can certainly paste code without screwing indentation. However I just tested both ipython notebook and pycharm and both seem to screw the indentation upon pasting, so this seems like a tool problem. It's a bit frustrating as Eclipse does it well in Java - there is no need to reindent after a copy/paste from different indentation levels.
Indentation would always be derived from the level you pasted into. Also, if you need pass as part of an if branch, the you should really just leave that branch off.. And use not to negate your question if you need to
I've upvoted you because you're adding value to the discussion, but I think your argument about code blocks having to be zero or more statements instead of one or more is a pretty poor one, simply because you wouldn't ever have a code block with zero statements in it, even if that fits your contrived description. Adding or removing levels of indentation is trivial and can be completely automated as long as there is a continuous flow of indented blocks (1-2-3-2-3-4). Which, again, is a trivial requirement because that's exactly what you'd want in an actual program. If you show me one snippet of python that cannot be re-indented mechanically, I will eat my hat. (EDIT: Made the "call for examples" clearer: was "(...) that cannot be indented mechanically", changed it to "(...) that cannot be **re-indented** mechanically")
Job listings are generally written by HR people with no clue about the technologies involved, who go "Oh, we need a guy with ReactJS experience? Well we don't want any inexperienced developers now do we? Lets add 5+ years React experience required." So take "requirements" with a healthy dose of salt and don't let it stop you from applying. Sure they would love someone with 5 years experience in a dozen technologies, but they'll happily take someone with less experience if they are otherwise a good fit.
In what sense is Java not a high level language?
&gt; That said, 3.5 (I think) will have the @ operator for matrix multiplication. It will, but it's an undefined operator in base Python that should, but is not required to be used for matrix multiplication.
I'm always thinking, for better job prospects, I should switch to Ruby. What's that they say about green grass?
/r/learnpython please, and delete this post.
Well that is a good point, I could live with that as well. I guess the important thing is that the refactoring step should be there, otherwise the codebase will grow unmaintainable by time (probably). I have no opinion about what is better: to refactor up front or after. There is one thing though. Before implementing a feature, you don't really know how the feature will be implemented, you can't predict everything you will need and so it is prone the "don't write code you don't need" smell. The pragmatic answer is probably inbetween, some thing should be refactored before implementing a feature, some after. Either way I'd say both approaches are much better, than not doing any refactoring. (Of course there will be situations, when maybe not refactoring the code will be the better, more pragmatic choice. But that must be by decision, not because "I don't refactor at all, so I won't do it now either". If we think about the possibility of refactoring and come to the conclusion, that we should not do it in some situations (while knowing the pros/cons), it is fine by me.
Doesn't work for me at all. Pycharm 4.0.3 on Linux. It just does regular text paste.
As per this [stackoverflow answer](http://stackoverflow.com/a/20418945): Settings | Editor | Smart Keys | Smart indent pasted lines
Sweet! Works perfectly.
One issue is that the print on line 25 says "&gt;" but the test was for "&lt;": elif (similarity_percent_lst[each_number] &lt; biggest_percent_similarity) == True: print "\n" + "similarity_percent_lst[each_number] &lt; biggest_percent_similarity" print similarity_percent_lst[each_number] + "&gt;" + str(biggest_percent_similarity)
That's all totally true, but you neglected perhaps the worst aspect of it: it represents a hugely unfamiliar aspect for people familiar with languages with more conventional control structures. I really love Python except for that one fucking thing.
I'm not sure what you're trying to demonstrate here. That's not valid Python.
I think a problem with indentation-based languages is that they don’t necessarily work well for a mixture of procedural and functional programming. There is a good reason for `lambda` not taking a block, because it would make the code layout pretty hard to reason about (if it were even expressible in a sane way syntactically). This, in a way, restricts the use of functional idioms in Python and forces code to be written more linear, more in a procedural style. So, of course, the following code is not really expressible: y = [lambda x: print(x) x*x for v in [1,2,3,4,5]] In my opinion, syntax-relevant whitespace is less of a problem in a language like Haskell, because one can always fix crazy nesting with using a `where` clause in an idiomatically accepted way. (And without `do`, everything can be a one-liner anyway.) On the other hand, Haskell code, with its mixed-length indentations may – to the untrained eye – look far less clean than Python’s clean 4 spaces style.
If I convert that while loop into a for loop, I can make the argument that there's actually more than one statement (in the human, natural-language sense) even if you can represent it as a single loop with no statements (in the compiler sense). for c in getchar(): if c is EOF: break if c.isspace(): break 
I have always enjoyed his talks and example type presentation. 
My apologies, I should have placed it in a function, that would have been more clear. I actually intended the code to return if it was the 20th of the month, so Vim's got my intentions wrong, there. If there were brackets, this would not have been the case. So let's build a better example - you want create a directory, deleting it first if it already exists. if os.path.exists(path): print "Deleting file", path shutil.rmtree(path) os.mkdir(path) If you've got a situation like this, where you have a condition and code that continues unconditionally beneath it, it's not clear where the indentation should end. Vim indents this code to: if os.path.exists(path): print "Deleting file", path shutil.rmtree(path) os.mkdir(path) Which leaves you without a directory.
It's actually not lamba, but [list] behaviour, e.g.: x = 1 y = 2 z = [x + y * 2 ] print(z) is also valid
Well, if I copy that snippet into a piece of actual code I'm working on in Vim I get a mess (http://puu.sh/hkokW/30b321b5e7.png), and then if I auto-indent it, I get the incorrect indentation (http://puu.sh/hkomA/8a88f8f804.png). I'm not sure what the state of my setup is so it might be my fault, but it's clearly hard to automatically indent. If the paste destroys your indentation, it's impossible to get back without human eyes.
I'm not arguing for auto-indenting an amorphous blob of Python code. Of course you can't do that, just like you can't auto-indent a blob of C without braces. I'm arguing that there's no **correct snippet of Python** that cannot be *automatically* re-indented to another indentation level. That's what OP suggested. (or, removing the double negative, that every syntactically correct Python snipped can be automatically re-indented).
Yes, it is not syntactically possible to have any blocks inside round or square parentheses. Same goes for function application: map(lambda x: x*x, range(5)) is expressible but there is no supported way (and no way which would not look confusing) to make that a (fictional) multi-line lambda: map(lamda x: print(x) x * x , range(5)) 
Fair enough. I think we may have interpreted OP's point in different ways. I read it that his original complaint regarding whitespace was exactly that it can't support auto-indentation in the same way that bracketed C can.
It's really cool feature - until first large merge conflict you need to resolve where nesting levels change... 
The argument isn't that you can't auto indent non-indented code. It is that you can easily add or remove indentation levels to correctly indented code.
Don't be part of the problem: ditch 2 and work in modern Python. 2 is EOLing in 5 years, and that's a concession to the dinosaurs! Maintaining compatible code hurts readability, requires compatible tests to be written and run, and increases your maintenance burden. Why bother? 2 is for legacy, not new stuff. Your code is new, ergo not legacy.
I took the statement "If you show me one snippet of python that cannot be re-indented mechanically, I will eat my hat." to be a rather separate one involving re-indentation from scratch, rather than simply altering indentation levels. I've taken this leap because the original comment said "I can cut code from one place and insert it in another, reindent the entire file, and everything is peachy", and so I've demonstrated that this doesn't always work.
A namespace is essentially a collection of names bound to values. They are sometimes **implemented** by a dict "under the hood", but not always, and the implementation detail is really irrelevant, and they're not the same thing. I'll give a few examples of namespaces: 1. Variable scopes. Basically, every time you assign to a new variable via: some_name = some_value you are creating a *binding* of this name to that value in some namespace. If you do it at the top level, this will be the global namespace. If you do it inside a function, it'll be that function's local namespace. When you want to *look up* a name (ie you use `some_name` in an expression, python will look in a set of namespaces till it finds something with the name "some_name" - first it checks the function's namespace, then any enclosing function's namespace, then the global namespace, and then the builtin namespace (where a bunch of standard functions and types live). Ie. it'll only ever look in the global namespace if there is no local variable with the same name. (For the record, the global and builtin namespaces here use dicts, but function namespaces do not - rather they use an array of slots attached to the function frame, and the bytecode compiler will translate names used in the code to the corresponding index. This is why local variables are faster than global variables. 2. Class / instance namespaces. Often namespaces are hierarchical, where a variable (defined in some namespace) actually leads to something that has a namespace of its own. Classes and instances have their own namespaces, and again, there are rules as to how these are searched. If you look up something on an instance, python will first search in that instance's namespace (generally implemented via a dictionary), and then in the class's namespace (There are also a few complications here regarding descriptors and metaclasses, but I'll ignore them here). 3. Module namespaces. Similar to class namespaces, modules have a list of names bound to values. This is basically the global namespace of that module (ie. whatever is in the global namespace when inside that module is exposed as the module namespace when accessed outside that module). You can thus get statements like `datetime.datetime.now().year` that involve multiple namespace lookups - first we find the value for "datetime", which will be bound in the global namespace to the datetime module. Then we look up the name "datetime" in the datetime module's namespace, and find it's bound to the datetime class. then it looks up the "now" name on the datetime class, findint it bound to the now class method. We call that, getting a datetime instance, and then look up the "year" name in that instance's namespace. Put simply, a namespace is a space for names. Anywhere you have names that map to values, you have a namespace. There are a whole bunch of things that have namespaces, and pretty much every piece of python code is likely going to involve multiple namespaces. 
Unfortunately indentation isn't always held as sacred as characters by most text editors, and is often destroyed or damaged by copying and pasting :(
python doesn't subscribe to the strict "is-a" paradigm. the only point in extending classes in python is code reuse. the "is-a" is just a special case of code reuse.
Whelp, looks like it's time to update production!
I contribute to pygal...it's a little messy under the hood, but it does make it really easy to style your graphs.
Do you mean an [argparse.Namespace](https://docs.python.org/2/library/argparse.html#argparse.Namespace)? If so, not much..it behaves like a 'dot dictionary,' where keys of the dictionary are class properties. For small objects there's no harm, but there's significant overhead the larger the dict becomes.
actually i proved you wrong. you just didnt bother reading it. atwood agrees too at least in deed. so your sacred cow is a false god. and like all trolls when proven wrong you resort to insults and cursing and hopes that getting the last word in will somehow redeem you. 
I'll take rarely typing "pass" over constantly typing, erasing "{}" all day long. Also errors over wrong indentation (which are rare and easy to spot) over errors caused by optional / implied brackets. Not supporting cut'n'paste programming is a feature. It is trivial (at least in my editor) to [de|in]dent a block of code same amount.
I generally stick with matplotlib, but my co-worker who does a lot more plotting than me swears by ggplot. It looks very promising, I'm planning to give it a spin for my next project.
You are very wrong my friend. Only good programmers do that and this is the only correct way to do it. 
:retab 
I didn't intend to be a rude, although I have to admit a bit of sarcasm in my comments. Not going to cast doubts about your experience. I've worked on many interesting and complex projects in the past decade, now I'm hiring others and would pick in ten cases of ten someone with an analytic mind, general algorithm development knowledge and team work experience over someone with a deep knowledge but a limited set of tools. Tools can be learned/refreshed after a few weeks at company training, but abilities to solve non-trivial tasks can't be gained so easy, even impossible. Most important is a showcase of past work (best available on public repos like Github or Bitbucket) and solving a few problems in a limited time with tools of their choice. The tools used afterwards, after got hired (if not quite foreign), are secondary. If there are more candidates with on par skills, then their specialization in tool(s) starts to play a role, but no other way around. I know about a broad offer of instant jobs for codemonkeys (web market?), where only 1:1 implementation of prebaked algorithms submitted by a developer or a senior programmer is to be expected, but hope we don't talk about such cases.
Why is he using notepad to program? : /
Why do people use vi? (Time to start a war)
I just wanted to share my personal opinion. Both brackets and indentation have advantages and disadvantages. i've worked with both personally prefer indentation. Also i'm new to python, not programming in general. I just used to use C++/Java
Gushing about whitespace while calling out &amp;&amp; over and (there are times when &amp;&amp; is needed over and) is kind of dumb. They are just language features. Will you go to a c# forum and gush about .NET next?
Paul hit up Pyatl last week and I'm glad he did. It wasn't a super technical talk, but it was fascinating nonetheless. And apparently putting "Special guest speaker from Disney" is like putting chum in shark infested waters. We were *packed* like getting a little friendly with your neighbor packed, sneaking chairs from the next room packed...you get the idea. 
Ahh yeah - dumb question :-(
Vi actually works &amp; was designed for programmers. Notepad was never intended for serious use.
 sequence = [1, 5, 19, 3, 41, 6] now print (max (sequence)) or if you need to understand the logic of how to implement it: highest = 0 for item in sequence: if item &gt; highest; highest = item print (highest) Please move further posts to r/learnpython I leave finding the bug in my implementation as an excercise for the reader :-) [edit: go on, cargo cult it, i dare you!]
'Course, there's an emacs command to do that. C-x M-c M-butterfly
/r/learnpython please
That's a problem of editor-supported style vs official style, not one of syntax.
FWIW, we don't need `pass` per-se. The syntax *could* be fine letting you just write: try: foo() except: `pass` is there to be pretty, to simplify the grammar and to act as a sanity check.
&gt; If you really want the syntactic sugar you could make a class that overrides __mul__ Wouldn't that make the code highly unreadable? When I read code, I have certain expectations as to the effect of expressions like a*b and a+b.
This is new in Python 3. A bare * forces the caller to use named arguments for everything after the star. For example: &gt;&gt;&gt; def foo(*, a): pass ... &gt;&gt;&gt; foo(3) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: foo() takes exactly 0 positional arguments (1 given) &gt;&gt;&gt; foo(a=3) # ok Edit: in the future, you should probably ask this kind of question in /r/learnpython.
Just consider indents and dedents to be like curly braces and no isomorphism gets broken whatsoever. It's not like you weren't gonna parse whitespace anyway. I suspect that to be how Python deals with this internally, can anyone confirm?
Works in nested loops with count() on each loop?
Wow, this is going to be a big release -- and still over a month till feature freeze. Two new operators! One brand new one (@), and one kind of reintroduced one (% for bytes). And my own (totally unbiased ;-) favourite: [PEP 471](https://www.python.org/dev/peps/pep-0471/)'s os.scandir(), which speeds up os.walk() several times on Linux, and an order of magnitude on Windows. I do like the fact that Python is definitely not at a stand still feature-wise, but a moderately serious question: are new features being accepted into Python more readily than they might have been a few years ago? When does this become a liability?
I've written lots of VBScripts in Notepad. But I find it difficult for Python scripts.
The issue is lack of backward compatibility I assume.
I'm glad you like it. Some time in the future when you ask yourself why there are no multiline lambdas in Python think about this thread and you'll know the answer.
 a=1 or a = 1 What's the correct way to do it in Python and what good programmers would choose?