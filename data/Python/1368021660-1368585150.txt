Wow. Thanks.
If you'd like to dive into Stefan van der Walt's code [here](https://github.com/stefanv/growcut_py), he's done a really nice job of tuning the GrowCut code using Cython (it outperforms the numba code, which is also in the repository). My next blog post will be looking deeper into performance metrics and comparisons.
It's an interesting idea, and it's the same premise that the PyPy and Unladen Swallow projects followed. Instead of working on the general problem first, numba tackles the specific computational problem first. There's nothing that technically prevents you from doing this, but as others have said, this is only going to produce speedups where Python's looping is really hurting you (such as computational kernels).
* http://en.wikipedia.org/wiki/Ontology_editor &gt; http://www.mkbergman.com/862/the-sweet-compendium-of-ontology-building-tools/ * http://networkx.github.io/documentation/development/tutorial/tutorial.html#adding-attributes-to-graphs-nodes-and-edges * http://networkx.lanl.gov/reference/readwrite.json_graph.html 
I saw an [old package](https://pypi.python.org/pypi/musicbutler/0.1.7) a while back that uses speech recognition that I copied a bit of to test with. You could look at it and see how it's done.
You could use LGPL, for example. Or more permissive BSD/MIT.
speech recognition quality for practical purposes is much less about the software/technology than it is about the available training data. 
I used this couple of years ago, and it worked ok. API was not terrible :) http://code.google.com/p/dragonfly/
You need a cool map example. I still don't really grok currying. 
+1 for dragonfly and WSP (windows speech recognition). I'm on a Mac and wish I had it that easy... I will need to find a Dragon serial to move forward. Lots of good info here (for M$ and Unix folks alike) http://hackaday.com/2010/07/09/get-started-with-speech-recognition/
http://devstack.org/ "A documented shell script to build complete OpenStack development environments."
1. I'm not familiar with that particular scenario (how does it break?). It does offer parsing based on a format string with different syntax than strptime (more like moment.js) 2. Am not sure, will have to check that out. 3. yes...arrow.get(mydate) or arrow.Arrow.fromdatetime(mydate).
Ha! Partially. Was thinking more of "Time's Arrow", as in the Arthur C. Clarke short story and Star Trek: TNG episode :)
I definitely understand the concern about mutable state on these things. My hope is that the risks are minimal enough and the utility / benefits worth it. I've encountered enough scenarios where having a mutable datetime would be awfully convenient. But I agree, definitely a chance for confusion / mis-use. Keeping an eye on the feedback / use of this feature, for sure.
The supported range is the range supported by datetime. And yes, it could be, already have a pull request for some russian support. This has been a big feature request already so I'm expecting a lot more work to be done in this area.
I wrote my own parser. I like dateutil.parser, but a) the default format matching I think is unsuitable in some cases, and b) I wanted to take a shot at writing my own.
Do you want to train your own Speech Recognition models or do you want to use available models and do recognition with them? Either way, I'm unaware of anything specific for Python, so my suggestions are to integrate other tools in your Python code. In the case of the first option, you can use [HTK](http://htk.eng.cam.ac.uk/) and wrap it with some Python. Shouldn't be too difficult. For the second option, you can use [Microsoft's Speech Platform](http://msdn.microsoft.com/en-us/library/hh361572%28v=office.14%29.aspx). You can quickly write a tool in C# that uses the SR backend and returns the text and then wrap that in your Python code. Sorry if it's not exactly what you need, but that's what I'm familiar with. 
Very good suggestions. I could unpack the fields all at once, true, but it's a bit annoying to debug that long format string when I mistype something, so I opted for a slightly longer class.
I second HTK, it's what I use as computational linguist and there is a Python [wrapper](http://www.e-gymraeg.org/wispr/pyhtk.htm) available although I haven't tested it yet.
&gt; I'm not familiar with that particular scenario (how does it break?). It does offer parsing based on a format string with different syntax than strptime (more like moment.js) But is that written in Python or does it use strptime at some point? (I'm hoping the former) &gt; Am not sure, will have to check that out. I *think* it does, having done some testing. &gt; yes...arrow.get(mydate) or arrow.Arrow.fromdatetime(mydate). `arrow.get(mydate)` throws this: TypeError: Can't parse single argument type of '&lt;type 'datetime.date'&gt;' I'm using `arrow==0.2.0` &gt;&gt;&gt; arrow.Arrow.fromdatetime(datetime.date.today()) AttributeError: 'datetime.date' object has no attribute 'tzinfo' 
Having your cake and eating it is easy enough: fields = [ ('sig', 'I'), ('version', '2s'), ('flags', '2s'), ('method', 'H'), ('modtime', '2s'), ('moddate', '2s'), ('crc', '4s'), ('csize', 'L'), ('usize', 'L'), ('namelength', 'H'), ('extralength', 'H'), ] localhdr = namedtuple('localhdr', [f[0] for f in fields]) format = "&amp;lt;" + ''.join(f[1] for f in fields)
Ahh, and there's Eddington's arrow of time, which is the likely ancestor to all three uses. A name's always good when there are multiple reasonable ways for it to work. 
Ahah, you meant from a _date_, not a _datetime_. I see now. That is not currently supported. Would be pretty straightforward to add that functionality, or modify arrow.Arrow.fromdatetime to accept a date as well and default out the time args.
* http://www.reddit.com/r/learnpython/wiki/index * http://www.class-central.com/search?q=python * https://www.google.com/search?q=site:docs.python.org+elif * https://www.google.com/search?q=python+docs+elif
I can't say I agree with using * for composition. You can't overload dot to match Haskell, but go with something rarely used like &gt;&gt;. You also lose support for varargs and named arguments, and aren't copying the docstrings or argspec to the wrapped function. The decorator library gives a tool for doing this, *wraps* I think.
Google API might work. You need to request keys and you get a few hundred uses per day.
Thank you for that useful link.
Have you seen kivy yet? http://www.kivy.org
The full documentation (and browseable source code) is available on the GitHub page (https://github.com/lihaoyi/macropy), if anyone was wondering. There's also a link to it on the PyPI page.
Pretty sure WinRAR handles corrupted RARs and ZIPs just fine...
First thing I saw is that you need quotes around your file name.
Especially with powershell remoting it's the right tool for this job
How hard did you have to look to find an algorithm that couldn't be vectorized? Also, how does Cython do on that code?
Also, either use os.sep, forward slashes or double back slashes for path separators. c:/Users/Austin/etc c:\\Users\\Austin\\etc 
Wonder if we can implement function advising [like Emacs Lisp](https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html) with this.
so does 7zip, and you should be IMO using 7zip (or peazip, or whatever). But yeah, he said that in the topic, this was more of a "oh look zip files aren't that complicated, I can just parse them with Python, cool" than a practical solution.
Well, OP said: &gt;Most of archivers will error out on a corrupt (eg. partially downloaded) ZIP file. which is probably _technically_ true since there are a lot of archivers out there. But the reality is that the most commonly used archivers can handle it just fine.
You could also use construct, though that might be overkill: from construct import * # for demo purposes #NOTE UL = unsigned little endian ZipStruct = Struct("ZipStruct", ULInt32('sig'), Bytes('version', 2), Bytes('flags', 2), ULInt16('method'), Bytes('modtime', 2), Bytes('moddate', 2), ULInt32('crc'), # changed to int ULInt64('csize'), ULInt64('usize'), ULInt16('namelength'), ULInt16('extralength'), ) localhdr = ZipStruct.parse("data") 
Wow, I wish that Tracing feature was available in something like the Online Python Tutor. It's a little tricky explaining to students how expressions are calculated, when it's rendering at the statement level...
The `log%` is quite nice... 
it's the most common complaint I hear about Tk. it's plenty powerfull otherwise.
Any hope on getting this ported to 3.x?
I am the author of [pyshop](https://github.com/mardiros/pyshop) which can mirror pypi too and I am pretty sure you miss some details. Package update when a new release has been done. I haven't see any mechanism of refreshing ? Are you ok with case insensitive for package name ? You don't deal problem with "_" and "-" (for example, pyramid_celery is named pyramid_celery but sphinx_bootstrap_theme is named sphinx-bootstrap-theme ) (I didn't take the time to test your code, just read it) 
I really hope one day I will know programming well enough to appreciate what it does :)
Perhaps there's a comma in one of the subject values? Or really any of the values I suppose. If we could see a sample of the data, that might help.
The input, 'dtype', shouldn't be a list. I believe it should be a type. http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html
There are no commas, but you have that set as the delimiter?
Well, by default dtype is float, do you need a type other than that? What are you trying to do with the list?
dtypes can be a list [http://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.html)
I don't think the list he's passing looks valid. Messing around a bit in an editor, looks like the last tupe is missing a field. dtype=[('subject',np.str,8),('left',np.str,8),('anterior',np.str,8),('RT',np.uint32 , !!! )] Where I added the exclamation points. The other objects all have 3 fields.
Bingo. The comment just above I stuck !!! in for where the length should be I think. Edit: dtype=[('subject',np.str,8),('left',np.str,8),('anterior',np.str,8),('RT',np.uint32 , !!! )]
Have you seen this? http://pyvideo.org/video/1735/using-python-to-code-by-voice Also ... what exactly are you trying to do? Describe the use case as best as possible.
Using tuples. int is a fixed type, 3 the field’s shape. void is a flexible type, here of size 10: &gt;&gt;&gt; np.dtype([('hello',(np.int,3)),('world',np.void,10)]) dtype([('hello', '&lt;i4', 3), ('world', '|V10')]) It depends on what you want to do. You could conform the first 3 entries to the last one and remove the third field 'length'. Or you could conform the last entry to the first 3 and add a 'length' field. In this case it would be the length of the longest input you'd get in that field ( I think ).
1 1 1 640.52 Is that your data? (str, str, str, uint32)? In that case I would do (int, int, int, float) Length would be like 32 for all of them. (Not sure... guessing length for numbers is size) Doesn't seem like the length field would be necessary, just option possibly for a performance boost. Base python objects have length built in I think. 
Some day? If anyone wants to give it a try I can mentor your effort, but until I have a better plan of where the project is going in the future, it wouldn't make sense for me to spend a whole chunk of time to port it over and then maintain the fork.
For future reference a traceback is the lines of code Python dumps as where the error occurred, by default should be printed out just above the Error message. 
Yeah, I don't usually care about pretty. My big complaint with Tk is its archaic API. I suppose it does the job, though. Though, it's pretty cool to embed some TCL code into my project to freak my co-workers out.
Yeah, looks like you want to do something like this: Data=np.genfromtxt('C:\Users\Austin\Desktop\FinalData470.csv', delimiter='\t', dtype=[('subject',np.uint32),('left',np.uint32),('anterior',np.uint32),('RT',np.float)]) or Data=np.genfromtxt('C:\Users\Austin\Desktop\FinalData470.csv', delimiter=' ', dtype=[('subject',np.uint32),('left',np.uint32),('anterior',np.uint32),('RT',np.float)]) You could add in the length field if it still complains (or if you want to).
Big data 1) Mostly due to a lack of hadoop/storm like technology that is geared for business. iPython's distributed system seems interesting but haven't had time to look into it. 2 ) Compiled JVM languages when tuned correctly are still faster then interpreted though PyPy may eventually give them a run for their money. Otherwise it's a fantastic glue language alongside being a good general purpose language for almost any task I can think of. Right now my work life is split 50,40,10 by Java, Python, and Lua ( Redis ) and I don't see that changing for a while. 
Something like this. dtype=[('subject',np.uint32, 32),('left',np.uint32, 32),('anterior',np.uint32, 32),('RT',np.float, 64)]
Can it search my $PYTHONPATH for modules too?
considering the amount of magic / extra-Python-ness involved here, it'd be really helpful if your examples included whatever import statements are necessary for running the examples. (and maybe they already do) E.g., in your AST example, how is `name` defined? 
https://en.wikipedia.org/wiki/C%2B%2B http://en.wikipedia.org/wiki/Haskell_(programming_language) http://en.wikipedia.org/wiki/C_Sharp_(programming_language) http://en.wikipedia.org/wiki/OCaml ....
Can you think of a syntax that macropy would enable for function advice? I love advice systems / aspect oriented programming and really want a nice python library for it. I always thought decorators would make the perfect syntax, e.g.: @around("post_comment") def apply_formatting(message): return NEXT(formatter.format(message)) @before("post_comment") def reject_spam(message) if spam_checker.is_spam(message): raise SpamError I did a little [experiment](https://gist.github.com/lost-theory/760f6416d2cc9eb02ed9) with a similar syntax using the Aspyct library.
&gt;When the import line to be added is in the simple / direct format (eg. import os) impy will not need any help unless it can't find the module in the $PYTHONPATH.
It's his 5th post about this so far. 3 in /r/python and another 2 in r/learnpython. 
What's up with that first line? it's formatted differently than the rest. What happens if you try on a copy with that line removed?
pure evil!
This is also incorrect. The size field specifies a shape / element count, not a byte or bit size (the latter information is encoded in the type object.). With this data, the shape of all the fields is 1 (meaning it can be omitted, since that's the default.)
I love these kinds of things. Could you link me? I really want to make another one, but I forgot almost everything so where would you suggest I learn from to program a text adventure in python?
http://static.rust-lang.org/doc/tutorial.html#borrowed-pointers
That is a good point, I'll update the readme when i get the time. Not every snippet will be executable, but at least the ones at the top of every section should be runnable as-is EDIT: I updated the readme; all the top-of-section examples now include their relevant imports
MacroPy gives you a decorator macros that can re-write the decorated definitions (either function or class) in any way you want. So you could do stuff like tracing every statement within the function, or count how many times each line of code executes. The examples you're describing seem pretty trivial to accomplish using normal decorators though; simple before/after/around advice doesn't need macros, you only need them if you want to really mess around *inside* the body of the function.
Your first input line contains spaces instead of a tab. Fix that. And of course you are using tabs as delimiters in the file, so you should be using `delimiter='\t'` With these two fixes, Data=np.genfromtxt('/tmp/foo.csv', delimiter='\t', dtype=[('subject',np.str,8),('left',np.str,8),('anterior',np.str,8),('RT',np.uint32)]) succeeds for me (/tmp/foo.csv is where I put your data sample) However as fuzz3289 pointed out, you really want something more like Data=np.genfromtxt('/tmp/foo.csv', delimiter='\t', dtype=[('subject',np.uint),('left',np.uint),('anterior',np.uint),('RT',np.float)]) Which also works for me. Finally, there is the question of whether you want to use `genfromtxt()` at all. Because what is returned from `genfromtxt()` is a *generator* -- something that lazily reads lines as they are required; this is often used if you have a large amount of data (300+ megabytes, say) and you want to loop over it analyzing each entry. In most other situations you want to use `loadtxt()` instead. It accepts the same parameters, but returns a simple NumPy array rather than a generator. In general when loading data, you will mainly want to use `load()` or `loadtxt()`.
Nailed it.
Should've seen that, thanks!
I was in the class you presented in today; fantastic job on both the presentation and the code!
Am I the only one use Google's API? (The voice input button you saw on most Webkit browsers) curl --data-binary @my_recording.flac -H "Content-type: audio/x-flac; rate=8000" "https://www.google.com/speech-api/v1/recognize?xjerr=1&amp;client=chromium&amp;pfilter=2&amp;lang=en-US&amp;maxresults=1" | python -m json.tool 
* http://en.wikipedia.org/wiki/Functional_programming * http://en.wikipedia.org/wiki/Logic_programming * http://docs.python.org/2/howto/functional.html * http://docs.python.org/3/howto/functional.html * https://github.com/kachayev/fn.py * https://github.com/logpy/logpy * https://github.com/benanhalt/PyAlgebraicDataTypes * https://pypi.python.org/pypi/pyDatalog * https://github.com/RDFLib/rdflib-sqlalchemy * https://github.com/lihaoyi/macropy * http://docs.zope.org/zope.interface/ * http://docs.pylonsproject.org/projects/pyramid/en/1.0-branch/narr/zca.html * https://pypi.python.org/pypi/flake8 * http://en.wikipedia.org/wiki/Mixin * http://stackoverflow.com/questions/533631/what-is-a-mixin-and-why-are-they-useful * http://docs.python.org/2/library/operator.html * http://docs.python.org/3/library/operator.html * http://python-3-patterns-idioms-test.readthedocs.org/en/latest/Metaprogramming.html
im down with any plugins that use automagic!
http://www.reddit.com/r/semanticweb/comments/1dvakc/schemaorgdataset_standard_schema_for_linked_data/
&gt; What I want is a place to store "x has y relationship with z", such that I can later make n-depth queries against it. Further, I want to do it in the most "standard" or "correct" way possible. * http://www.reddit.com/r/Python/comments/1dvc7s/how_to_do_functional_programming_in_python/c9v8792 * https://github.com/logpy/logpy * https://pypi.python.org/pypi/pyDatalog * https://github.com/RDFLib/rdflib-sqlalchemy * https://github.com/RDFLib/rdflib-sparql * https://github.com/RDFLib/rdflib-sparqlstore * http://pythonhosted.org/virtuoso/rdflib.html * http://wiki.opencog.org/w/CogPrime_Overview#Local_and_Global_Knowledge_Representation
Can't wait to debug code written with this... Especially that one "clever" person on the project. 
http://en.wikipedia.org/wiki/Smart_pointer
Here is the [list of open source](http://www.findbestopensource.com/tagged/speech-recognition) Speech Recognition software. Most of them are in Java and C++.
How many more people are going to create modules named Vimpy? Here's mine: http://github.com/LimpidTech/Vimpy
Very nice! Just gave it a test run then, and it looks like it'll be very useful for those cases where I realise I want a `defaultdict` halfway through coding something, and have to import `collections`. One issue I ran into: the first thing I tried was typing x = [1, 2, 3] for i in itertools.cycle(x): and then trying to get it to import `itertools` for me, which didn't work. From what I can tell, the file has to be free of syntax errors before the auto-import will work? Once I added some code within the `for` block, I could go back to that line and the auto-import worked just fine.
You've gotta be careful with unofficial APIs though because they have a habit of breaking.
If that breaks, every not up-to-date webkit based browser audio input breaks.
&gt; localhdr = namedtuple('localhdr', [f[1] for f in fields]) Don't you mean f[0]?
I think it is evident that there are legitimate use-cases for this. When a new tool comes along, you have a few options: You can choose to ignore it and not use it. You can use it to make cool stuff. Better yet, you can improve it. Make it harder to misuse. Document patterns and anti-patterns. Or you can whine about the punk kids and their new-fangled toys, reminiscing about the good old days when you could code in assembly on the PDP-11.
Well spotted, apparently broke the code when I replaced map(itemgetter(0)) by a listcomp and was not careful enough
&gt; pyshop perform the automatic background downloading and caching of files? Yep, it's in the description: "Pyshop also mirror packages from PyPI safety (using ssl by checking certificate)." Maybe it's not clear enough. &gt; I've not implemented updating/refreshing yet; You should notice that in your description project if you already knew. &gt; I use is the one implemented in distlib Oh I don't know that package. I will take a look! &gt; Release early, release often (hopefully :-) I can't agree more. I 've written the first version of pyshop in two weeks. 
My opinion based on my experience is as follows. I would not look to make a "Python career." You're pigeonholing yourself into one language - what happens if what you really need to use is C, Ruby, Haskell, or some other language? Yes, I am aware that Python is fucking awesome. I love it too, but I wouldn't love being a 1 trick pony. Even if many developers have a degree in computer science, I will tell you that what you learn in school isn't anywhere as useful as what you teach yourself - both in whatever it is you learn and the fact that you learn how to learn effectively. I dropped out of school before finishing my degree in CS because it became apparent that I could learn all of it on my own, and eventually did so. If you want my advice on stuff that will serve you well: -Learn how use Linux. This served me more than words can describe. -Now that you know Python, learn what you can do with it. Try using WSGI and Apache to see if you like web servers. Look into TJ O'Connor's "Violent Python" to see if you like security. There's tons of great applications for Python out there. -The "use a github account as a resume" thing is only a half truth. Yes, having a github profile full of developed projects looks awesome, but experience, and some 'proof' that you know things (either an excellent interview where you come off as very knowledgeable, or, sadly, a degree). I think degrees are stupid and unnecessary, but I have managed to find a strong way to work around it using social engineering. 
Be capable, then prove it. I'm just finishing my degree now, and I can easily say I learnt more programming for fun than I did during my degree course. I gained from my degree - I now have a piece of paper showing basic competence, and I did an internship that got me a job, so for me, the degree was worth it, but you definitely don't need it (so long as you can find someone willing to hire you without a degree, which in the computing field, shouldn't be a problem). CompSci is a great field because practically everyone uses software. You can work in pretty much any field, which gives a fair amount of flexibility and options when it comes to employment. I recommend working on as much open-source stuff as you can, it's not only good for experience, but also all of the edge stuff - learning how to use source code control effectively, work with others, adopt a defined code style for a project, etc... StackOverflow is also a good way to show that you have knowledge, and a good way to gain it as well. Go on there and look at Python questions. If you know the answer, answer, if you don't, make it your business to find out the answer. Then check other people's answers later and see if there is a better way of doing it.
Based on my personal experience it's possible to build a career by learning on your own. I did it by learning python on my own and later on I started developing websites with django. I've done about 1-2 projects for my friends (simple business pages) and after that I applied to a small firm which developed websites in django. After a year I moved to big company in which I work on large projects. You don't need to study IT at university to do it - I am about to finish law so that might be unusual :) As my personal resume I used 2 pages which I've created. I would start with smaller company which creates some sites or other projects and later try to look something bigger which will boost your skills. 
Say we have f(x,y) = x + y. Suppose we want to calculate f(2,3) = 2 + 3. We can do it via currying : f(2,y) = 2 + y call this new function g(y) g(3) = 2 + 3 call this new function h() h() = 5 f(x,y) -&gt; g(y) -&gt; h() What if we wanted to calculate a bunch of f(2,y) for y arbitrary? Rather than call f(2, y) every time, we can just create a partial function g(y) = f(2,y) instead and reduce the number of arguments we need to pass. Currying is just using the partial function in functools multiple times until you create a function where you don't have to pass any arguments. Ive used it a few times to really clean up some Python code, but there are other methods to do whatever it is you are trying to do usually.
Another Brisbanite checking in. Are there any tasks in your current job that could be automated using Python? This can often be a good place to start because if you can spend even a bit of time being paid to write code then it looks good on your resume.
Self taught and driven is the most sought after characteristics in the cs field. The problem without having a formal background is you often overlook a lot of the nuances and will be very much behind when it comes to understanding what the code does and why it works. That being said you won't get anywhere limiting yourself this means you have to be able by to use other languages and be able to learn them quickly. Maybe you aren't the best java guy but you are driven so you pick up the basics in a week and keep at it. The formal education more than anything is teaching you how to learn and how to solve problems. 
Do you think degrees in general are stupid just CS degrees?
&gt; Is it possible to build a career on self-taught skills in this field? Yes. I have.
&gt; I would not look to make a "Python career." You're pigeonholing yourself into one language - what happens if what you really need to use is C, Ruby, Haskell, or some other language? Yes, I am aware that Python is fucking awesome. I love it too, but I wouldn't love being a 1 trick pony. I agree and disagree. I specifically looked for (and found) a job where the work was almost exclusively in Python. I left a job primarily because the codebase was to be rewritten from Python to C#. That said, I also want to use the right tool for the job - Node.js is certainly on my radar for some highly-available API stuff we're talking about, specifically because it sits on top of MongoDB. Personally, I market myself as a "developer with a particular taste for Python" or similar. The Python *community*, however, is something that I absolutely must remain a part of. That's what makes the language special to me, and I've reorganized my live to be a bigger part of it. &gt; Even if many developers have a degree in computer science, I will tell you that what you learn in school isn't anywhere as useful as what you teach yourself - both in whatever it is you learn and the fact that you learn how to learn effectively. I dropped out of school before finishing my degree in CS because it became apparent that I could learn all of it on my own, and eventually did so. I don't have a CS degree, and quit college around the end of my Freshman year as a Computer Engineering major. I agree that it isn't necessary, but I also see that I have knowledge gaps in some areas, particularly in algorithms and architecture. Most of that is remedied with experience, but there are definitely things out there that will make you a better developer if you go out and learn them, that you'll likely never encounter if you're not proactive. This doesn't really apply if you're wanting to build a few websites, granted. &gt; -Learn how use Linux. This served me more than words can describe. I can't agree more. I started playing with Linux in the late 90s, using Mandrake. Today, I use OSX. If you can switch to Linux today, *do it*. If you're stopped because you need Photoshop or something, then bite the bullet and buy a Mac. OSX is based on *BSD, so 95% of Linux knowledge cross-applies. &gt; -Now that you know Python, learn what you can do with it. Try using WSGI and Apache to see if you like web servers. Look into TJ O'Connor's "Violent Python" to see if you like security. There's tons of great applications for Python out there. Yep - and don't forget scientific computing. The Python world is effectively partitioned into two groups - web developers, and scientists. For example, PyCon this year was one week, and was followed immediately by PyData. Most people attended only one of those conferences. Knowing both sides of the fence, even only a little, effectively doubles your chances at landing a job. &gt; -The "use a github account as a resume" thing is only a half truth. Yes, having a github profile full of developed projects looks awesome, but experience, and some 'proof' that you know things (either an excellent interview where you come off as very knowledgeable, or, sadly, a degree). I think degrees are stupid and unnecessary, but I have managed to find a strong way to work around it using social engineering. I kept my LinkedIn account up to date, and created a profile at StackOverflow careers. Answering questions on SO in a very thorough way and being able to link to them will help establish credibility before you set foot in an interview situation.
I was in pretty much the same boat a few years back. I was a customer rep at an insurer, and I started getting into Linux at 27. After a year or so I realised I wanted to be a professional web developer and I started teaching myself. I learnt HTML, CSS, JavaScript, Perl and Python, then after a few years I got a job as a PHP developer on the basis that I wouldn't have any trouble picking up PHP. It's not often you see Python-specific jobs. PHP is not my favourite language, but if you can write code in it reasonably well you can usually find work without issue. It may be that once you're established you can get to use some Python - after nearly 2 years as a developer I'm now looking to use Django to build a web app at work.
&gt; A "career" is simply doing the same job a lot, and hopefully getting better at it. I'd say a job becomes a career not when you become good at it, but when you are fully confident in your abilities and instead start to focus on taking pride in quality work and teaching others to share in the fulfillment you get from it.
Numpy ndarray isn't designed for iterating one element at a time. Also, its \_\_getitem\_\_ isn't especially fast. There are some other caveats as well. Basically, using it as a drop-in replacement for python list, even for one of the supported types, is not a good idea.
Yeah that also works, but I wanted to replicate the "no external dependency" things. Also FWIW in `struct` the `L` format specifier is a 32b unsigned (same as `I`), `Q` is the 64b one.
I love stackoverflow. That community is a model for what any helpful forum should be, I believe. It never occurred to me, however, that answering questions there could be a good career move. One other thing: I liked your breakdown of "most of the python world" into the two categories of web development and scientific computing. I find I'm primarily interested in the latter and presumably, one would need a degree in the applicable science to land a programming job, right? This is contrasted with web development where statistical theories and knowledge germane to the science in question would be unnecessary? I ask because I've been considering taking another degree to do this kind of work.
Same for me.
Good points. but.. what is realtime-critical code? Do you mean critical systems like ATC ? Or real-time/online learning systems ?
You're welcome :)
Do you mean things like this? x = numpy.array(whatever) for i in range(len(x)): x[i] *= 2 Then not only are you right, but also -- ooh, you better believe that's a paddling. When I said iterating, I meant running your iteration in a pseudo-vectorised way (it's still an iteration underneath, in the C part of Numpy): x = numpy.array(whatever) x *= 2
In my specific case, I'm talking about the Jack Audio System (jackd). The callbacks clients supply to the jack server have to be realtime-safe, that is, they must not issue any OS calls that might block. This includes I/O of any kind and any kind of locks, semaphores, or mutexes, obviously, but also `malloc` and `free`. The only way I see this happening with Python would be a custom implementation that explicitly avoids OS-level heap allocation altogether and uses its own memory pool instead.
 # Power pow = F(lambda x, y: x**y) In this example, the first parameter is 'prefilled', and the second one comes from the list: # 2**1, 2**2, 2**3, 2**4 assert map(pow(2), [1, 2, 3, 4]) == [2, 4, 8, 16] To be really useful, you need to be able to choose which parameter is applied and which remains. In haskell there are operators that swap parameter orders of functions. I didn't implement this (yet :P) It could look something like this: # 1**2, 2**2, 3**2, 4**2 assert map(pow.swap()(2), [1, 2, 3, 4]) == [1, 4, 9, 16] This wouldn't be hard to implement either.
I agree. Haskell has a lot of awesome features that I didn't implement. I just started out with composition and currying because I think they're interesting. I don't know if all of the features you've mentioned could ever be implemented in python, especially type checking. Perhaps lazy evaluation could be done with generators, or some other way using classes instead of primitive types..
Sure this example is not supposed to be a full-fledged functional programming library, rather a demonstration of how to implement (some of) functional programming in python. As you can see in the source, its only 20 lines of code, so it would need a lot of work to be compatible with named arguments etc. As for the '*', I've chosen it because composition is usually expressed with the multiplication symbol.
You might want to consider [Kivy](http://kivy.org/#home). It's more of a gui framework than Pygame, but can do similar things. It's got solid cross platform support, and will probably be less of a headache than what you're suggesting. If you don't mind using Ruby, there's also [Chingu](http://ippa.se/chingu) + [Ocra](http://ocra.rubyforge.org/) for easy distribution.
Well, for the type checker to be useful, you'd have to shoehorn Python into a statically-typed language, and throw away all the benefits of its dynamic nature. I don't think you can have both, really. Laziness is certainly possible in general - after all, that's what generators do already. Implementing Haskell-style thunks should, I think, also be possible with clever wrapper classes, so at least the usage would be transparent, if not the creation. The purity part; well, I just don't see that happening without a static type checker, and even then you'd probably be turning the language into something completely different. Mutable state is just so incredibly baked into Python that without it, it just wouldn't be Python anymore.
I'd like to say a few things about the Linux part, myself, even if this is late. I totally agree with switch to Linux - but I recommend setting up a dual boot with Windows at first. Not too hard to do, the only thing you would need to watch out for is reinstalling/upgrading Windows, so keep that disk/flash drive ready. The reason? For one, the mentioned Photoshop and similar tools. You can usually find good replacements, Gimp, LibreOffice, etc... Usually these can export in the formats of the program they replace, but keeping windows let's you check/fix it - and use Word or whatever if it's on a deadline and you can't figure out, say, tables. I see a lot of developers say using macs and sshing to a server to work - which is something I am thinking about myself, maybe with a dual boot of something else (arch Linux) when I can't get it done on OSX. Just my 2¢. PS. I wrote this on a phone, so pardon any spelling errors, just easier to reply than finding this again on a real computer.
Yeah, and it's a useful piece of proof. Either way you need to be able to point to very specific things you've done to show your value. It's skipping a step to think that employers will give you a job based on the YouTube videos you've seen.
The link in python weekly has P**n instead of Porn just so that the spam filters don't send the email to the spam folder.
While I agree that self-motivated workers can be valuable, being in a university environment presents a lot of opportunity for growth. I learned most of my "work" experience from past jobs that I was only able to get as an attending student. On top of that, I've had nearly unlimited access to any research papers on the web.
I'm using that from now on when people ask what I do. "Fundamentally? I solve problems, how I get that done, well you see, that is a secondary concern..."
If you have to write an anti-spam backend engine for some middleware that feeds a website you'll be working in the website world, and yet you might be doing machine learning, probability and math. Isn't that scientific computing? My point being that the line splitting those two worlds might be very thin at times. +1 for having a good profile in StackOverflow, I've seen plenty of job offers asking for a link to your GitHub and SO accounts. And I'm surprised no one's mentioned it yet, but [online courses](http://www.class-central.com/) will fill in the knowledge gaps you may have about computer architecture, algorithms or pretty much any other computer science related module + more. They're also nice to have in your resume nowadays.
If you intend to make no changes to your code, you might be better off just using VNC to your already written applications. VNC can run in-browser on the visitor's side with [novnc](http://kanaka.github.io/noVNC/). You would then need to run separate instances of your application for every concurrent user. Otherwise you could split your application into a client-server architecture. If you make that split so that the server is thick and the client thin, you could just use Angular.js or something like that on the client side, and engineer some JSON interfaces on your fat server, written in python. Besides Google Native client there is also Mozilla's asm.js.
Do I really have to give out my email address to download the PDF?
For what it's worth m4dc4p extended the setup above to also generate [palm](https://github.com/bumptech/palm) protobuf bindings which are *much* faster than Google's pure Python bindings. Palm's API can be nicer as well.
One of the most important lessons in [*Code Complete*](http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670) is that you don't code *in* a language, you code *into* a language. That is, your understanding of the parts of your program needs to be independent of the language you happen to be using. Language features can help you be less verbose, or more efficient, or whatever, but good abstraction is what really matters, and it's always up to you. Highly recommended book for professionals or future-professionals.
I'm all self-taught. I would take small gigs on the side to make sure you like having clients and doing tasks for other people (very different than tinkering on your own).
What kind of interacting do you want to do? If it's just clicking on things and simple animations you could probably do it all with javascript (or jquery). I found the tutorials at [code academy](http://www.codecademy.com/) to be very useful at showing what is possible with jquery (and how easy it is). If you went that route you'd basically make a bunch of web pages, which you could then organise and control with a python web framework. Depending on how complicated it all is, you could use [bottle](http://bottlepy.org), [flask](http://flask.pocoo.org/), or [django](https://www.djangoproject.com/), in that order of escalating complexity.
I agree that degrees are helpful on the employer's part for the signalling. That is one of the main reasons why I got a degree was so that I could "fall back on it" if needed. I took advantage of the university environment and was able to get real life experience in the "learning by doing" classes. That helped me a good amount when I first started (science labs particularly come to mind), but now I think a single year on the job would more than make up for it. I attended about 7 universities while getting my degree because during the summer/winter I would enroll as a non-degree seeking student somewhere and take (mostly science) courses. It could work for a self-learner too. 
As have I.
lol fuck your mother
Here is one more https://platipy.readthedocs.org/en/latest/pythonista.html
Since you're already into developing desktop applications with Python+PyGame, what I would do is to send the participants the experiment as a packaged application and then develop a server to receive the results and save them to a database. If you are not worried with participants hacking your experiment, that's a good choice, and the software running on the server would not have to be very complicated.
I got to implement a bunch of reports, the sort of stuff that management really like to see. It really felt that I had to jump through hoops to get at grouping and having, it can be done but its a PITA. It seems to me it encourages people to write inefficient code, like the fetch N records and then follow N foreign keys one at a time, rather than simply joining.
Great! I especially like that it now has JIT-ed stackless features. Does anybody know what is the status of numpy in pypy? Can I do the least-squares matrix fitting using it?
Now I really want to try gevent with pypy :D
Duplicate .. already submitted http://www.reddit.com/r/Python/comments/1e0o6b/pypy_20_released/
The effort is only partially funded last I checked so its not progressing as quickly as they would like, but it is being worked on.
NumPyPy is my day job since the beginning of May, it should progress faster now.
Awesome! I'm really happy to hear that, its my hope that pypy can get numpy in because I think that's one major limiting factor on why pypy is not more widely used. So many of the really interesting libraries are dependent on it.
it is probably better to aim at eventlet instead for it supposedly works right from the box (as opposed to gevent)
I was talking to a friend about Kivy and how their docs were kind of meh, then I went to their site... THEY COMPLETELY REDID THE DOCS! I can't wait to think of a neat game and implement it with Kivy.
I've always been confused about this, but if I have a lot of cpu bound code, will I see a performance improvement if I use threads in pypy as opposed to multiprocessing in cpython? I assume memory use would be much better and I wouldn't have to deal with synchronization between multiple processes. 
&gt; If you have to write an anti-spam backend engine for some middleware that feeds a website you'll be working in the website world, and yet you might be doing machine learning, probability and math. IMO, math is programming. You need a good foundation in at least algebra and basic statistics, period. By the time you start in on machine learning, genetic algorithms, and heuristics, you probably have an intuitive understand of much of it - but believe me, you can benefit from structured classes, be they online or in person. &gt; Isn't that scientific computing? My point being that the line splitting those two worlds might be very thin at times. There is a lot shared in the type of work, but they are definitely distinct communities.
&gt; shaving off at least a second That implies that your shell took (I assume a lot) *more* than a second to start at one point. 
PyPy still has a GIL, so threads won't fully use multiple cores. (The STM code that eliminates the GIL isn't mainline yet.) That said, PyPy is usually faster than CPython, so it can still help.
This is the reason I asked. I learned most of what I know about programming, but it was a professor who got me started and set me on the right track. And besides programming, I learned most of what I know about signal processing, psychoacoustics, physics and math from the university. I find that there are things that are easy to practice and thus easy to learn on ones own. Programming is one such thing. There are other things that are much harder to learn outside of class.
I would add that the formal education also gives you the knowledge base underneath it all that helps you make sense out of why things are the way they are. This is usually helpful, though it can limit one's thinking to only "proper" solutions at times.
&gt;There are other things that are much harder to learn outside of class. Very true. Some industries/subjects just don't put what you need in the textbooks... And others it is oh so helpful to be able to ask questions. I have about 500 neuroscience questions left unanswered because I have only learned about it from reading textbooks. I'm considering taking a mid-level neuroscience course just so I can ask my questions. 
Just for clarity, it is almost always faster than CPython(there are some exceptions), in some areas this is extremely meaningful, in others its not even noticeable. 
Oh I think you're right &gt;.&lt; It's been a while, I just remembered it as looking like the middle dot... still, the star comes closest, don't you think? unless there would be a way to use 'o' as an operator...
End of next week, barring disaster :)
The Chrome extension is written in JavaScript and only callable through JavaScript or as an extension. There's a few ways to do what you want: 1. Write something in JavaScript that imports / copies functionality from the extension. 2. Port JavaScript functionality to Python. 3. Find a JavaScript interpreter with Python bindings.
It's like a cookery forum in here! Great suggestions, thank you. I want to head down the open source route as much as humanly possible. Both look great and celery looks fairly solid. In more practical terms what would be the security issues I would need to look out for and how could that be implemented. I had thought of a https server on the client and send files back and forth and commands to via that, execute on the client with a persistent python web server 
Yes, that's exactly what I meant. If you can map your problem to some combination of supplied ufuncs, numpy array is the way to go, otherwise it's a liability.
i suppose i should post the [reference implementation](https://bitbucket.org/stoneleaf/aenum) and the [PEP](http://www.python.org/dev/peps/pep-0435/) this is great news!
I have a ton of code using gevent though...I have no desire to switch it all over to eventlet. I'd much rather replace my gevent install with the pypy-hacks branch in a virtualenv than swap out code.
It will help speed up CPU bound code, but it won't help with parallelization currently, to the best of my knowledge.
Is the memory usage approaching that of Cpython? Historically that was a weakness of PyPy but I do not know if that is still true.
So far, everything about Arrow seems far superior to Delorean except for the iteration by timeframe (which is the current reason why I use Delorean). Get that implemented and this will uncontestedly be the best Python datetime library.
I don't think you are going to get very far here because your assertion that pointers are not necessary is wrong. For example, if I were to ask you to write a program to set the byte located at a certain memory address to 0xFF, how would you do this without a pointer? And before you say that this example is too contrived, this is precisely how memory-mapped IO works.
yeah, I am still trying to shave some time off of it. I think when I really noticed that I needed to do something was when I switched to oh-my-zsh. I am using prezto now but always looking for ways to shave a few seconds.
If pointers were "necessary", Python would have pointers. The example is somewhat contrived in the same sense as I could give an example that would require static typing, but that doesn't make static typing necessary and certainly not necessary to implement an algorithm. But that's really not what I'm asking. As I stated at the end, I'm looking for a definitive/authoritative reference that will refute the idea that certain algorithms simply can't be implemented without a pointer type. I've already been told that you *need* a Char type, more than one Integer type, etc. and the claims are getting somewhat ridiculous. I'm a step away from implementing zip in python myself just to prove the point. Oh, and regarding the question - I shouldn't be able to access a specific memory address, pointers or not. The OS' memory manager should be mapping my program's memory address space to real memory space (and possibly virtual memory space). My program's 0xFF has no necessary relation to the physical 0xFF. Randomizing programs' locations in memory is a technique used by modern OSes to thwart programs that try to use buffer overflow attacks. On Linux, you'd write to /dev/mem just like a file to access the actual memory space. In Python you'd use the mmap module of the standard library to do memory-mapped i/o on Linux and Windows... still no need to define a pointer type in the language itself. http://docs.python.org/2/library/mmap.html 
&gt; With CPython 2.7, using dict() to create dictionaries takes up to 6 times longer ... No idea what's up with that blog, but [the 6 doesn't display in Chrome for some reason](http://i.imgur.com/ImKDKEr.png).
Nobody knows the future, but the PyPy team is really good. And STM has been done in other languages, so we know it's possible. The only question is whether it'll be fast enough to be useful. Currently it's way too slow to be useful. Watch http://pyvideo.org/video/1739/pypy-without-the-gil for pretty recent information.
It's fine for me in Chrome, Chromium, and Firefox. Maybe you have a screwed-up font?
It's just that one instance, the rest of the numbers show up fine. Weird.
How magical is your parser? As someone who writes a fair few quick'n'dirty website scrapers, being able to have Python automatically determine the datetime format itself saves me a lot of time. I thought your library was highly usable and functional, but if it can't perform this common use-case how do you justify your language? To me it seems to be "yet another datetime library". &gt; humanization Humans aren't clean, don't be afraid to get a little dirty.
Same here.
LOL. only applicable if you are in a java shop I suppose. otherwise, meh...
The fact of the matter is that python doesn't do low level very well and a better approach would be to take advantage of the fact that CPython can add support in C. It is possible to pack data using the struct module in a articulate bit ordering however it's generally best to stay away. Overall yea it's possible to do such things but you shouldn't try to force a languages weaknesses just because you can to win an argument.
Is there binaries for Fedora 18 (64bit) available ? I am getting this error now: ./pypy-2.0/bin/pypy: error while loading shared libraries: libffi.so.6: cannot open shared object file: No such file or directory When I tried 32 binary on the same machine: ./pypy-2.0/bin/pypy: error while loading shared libraries: libssl.so.0.9.8: cannot open shared object file: No such file or directory 
Pointers are array indices. Nothing more and nothing less.
Despite the name, it's my understanding that they're no longer a bunch of hacks, and now simply a different approach to writing the engine core for gevent.
Python obviously uses pointers in the CPython implementation in various places, both for the standard library and of course for builtins, and for the language itself. So, the argument is a bit silly. `mmap` is of course implemented in C, with pointers, but you don't need to actually use pointers when writing in Python. The only reason you don't need to use pointers in general though is because so many data structures and algorithms baked into the language do use traditional pointers in their implementation. So no, Python pointers are not necessary, because the language provides you with good enough abstractions so that low-level code already written with pointers won't have to be muddled with by the programmer themselves. Pointers in general are necessary to implement lots of things, though; they just aren't necessary in most cases cases if you're already writing in Python.
Interesting, I actually wasn't aware of the `__closure__` attribute.
Speaking of iteration of timeframe, I just pushed an update which adds range and timespan range iteration. This is NOT in the pip version and probably won't be for a few days, but you can get [on github](https://github.com/crsmithdev/arrow). See the docs [here](http://crsmithdev.com/arrow/#arrow.Arrow.range) and [here](http://crsmithdev.com/arrow/#arrow.Arrow.span_range). As it sounds like you have a definite use case for this feature, I'd be especially curious to hear any feedback as to functionality, interface, etc. Thanks!
I haven't ruled out implementing some kind of auto-parsing functionality, but currently it requires the format string to be explicit. I think that's a good base to build on. Also, humanization refers to producing strings like '2 hours ago'.
I've just given you an example of a program that you can't write without pointers. Your claim that the programmer never needs to access an address is also wrong, since that is precisely what you need to do for memory mapped IO. So an authoritative source that pointers aren't necessary just doesn't exist, since such a source is simply wrong.
&gt; Also, humanization refers to producing strings like '2 hours ago'. Ah, I took it to mean that the library was designed to be utilised by humans. A quick look at the library shows that this is obviously not the case. It's a real shame, I was hoping this could be what `requests` is to `urllib`.
Its seems like forever. I want it to be done so badly.
One more Chrome/Windows user, same issue.
Saying Python doesn't use pointers is very wrong. It uses them, but you just don't see them. An excellent example of this how a list behaves: a1 = [] a2 = a1 a2.append(123) len(a1) == 1 a1 == a2 This will create a reference to a new list under variable a1 and copy it's reference (pointer) to variable a2. Afterwards all that happens to a2 will also be seen under a1, because a1 is same as a2. To understand why this is in fact needed and not optional, it is important to understand how function calls and argument passing work in low level (eg. in C). Arguments can either be passed by value, which is done when values are "simple" (eg. int, string, float), or they can be passed by reference. Arguments passed by value persist only within function call, while arguments passed by reference persist in memory after the call ends. And finally, when calling a function, arguments passed by value are copied in memory, while arguments passed by reference stay at the same location, and only their location (reference, pointer) is passed. No copying is needed, which makes it faster, and sometimes this is also the only way to make stuff work. If this wasn't the case, you would be copying complex memory locations (eg. objects in memory) meaning a lot of memory usage (which is both slow and causes memory fragmentation) and an even harder problem, which is that your CPU is supposed to understand how to copy objects. **tl;dr**: Both you and certain people you have been discussing this issue with are wrong. They should have pointed to you, that Python uses pointers (references) a lot, even if you don't realize it. Hell, even it's garbage collector works on "refcount", meaning it keeps account of ... pointers.
Same.
If bd808 is trying to say that, then (s)he's exactly right. C models storage as a logically single linear array of storage cells, and pointers as indexes into that array. You can do just the same in Python if you like. It would be horribly slow and awful to follow the code, but it would work. Plus, Python and C are both Turing Complete, and anything one can compute, so can the other (or, the Church-Turing Thesis would be falsified, which would be **really** interesting!)
Extremely long, well articulated and interesting... no wait theres a graphical glitch *ignores article*
Messing around in the element inspector, it seems Chrome is omitting all the numbers at the beginning of each line (in the source file). So "abc 123 456 def" shows up just as "abc def" But it seems to only be that element styling; Lots of lines in the preformatted text have lines beginning with numbers, but they show up fine. 
I think the reason people like to use dict() over {} ist that you don't need to quote the keys.
A *few* seconds? Good lord!
Wow, so it happened! This is great news, finally a standard that hopefully libraries will soon pick up. 
&gt; there are some exceptions Anything dealing with docutils for instance. pypy definitely doesn't like docutils.
["The market for something to believe in is infinite."](http://gapingvoid.com/2004/06/27/the-hughtrain/) Find people with problems that can be solved by programming. Understand their problem and solve it using your py-fu. The more expensive the time of the person you are trying to help is, the higher your chances are. Just to give you an example: I used to work for a plastic surgeon. Plastic surgeons talk about "conversion rates", the number of consultations that turn into interventions. Most doctors offer consultations for free BUT they would rather spend time in the OR, making money. I created a software that saved the doctor time by improving the conversion rate for the breast augmentation. That was also lucrative for me for a few years. 
I like this a lot. It will add some wanted prose to some of my code.
Microoptimization. Doug Hellman does a real service to the Python community in general with MOTW posts and his other expositions, but this is useless information. Use whichever is clearer (which I agree happens to be `{}` in general).
http://www.code.org/
This is not the reference implementation though :-) The reference implementation is https://bitbucket.org/stoneleaf/ref435 But now that the code goes through review for stdlib inclusion, the most updated source will be found here: http://bugs.python.org/issue17947
This is pretty nice. It opened up some existing projects well, browsed through them pretty easily. It has good default colors. I prefer PyCharm's tab structure. That uses vertical lines to show the tab indent. Ninja's "....." just feel like they cluster the visual space too much for me, but I see you can turn them off. 
For this I'd use Puppet: http://puppetlabs.com/ Create a puppet master server and assign it a static IP or good DNS resolvable. Build out your AMI's to start up Puppet which checks in with the master and then builds out however you want it to. Alternatively, take a look at Chef: http://www.opscode.com/chef/ But basically what you want has already been written. 
Oh gosh...
Your comment is bad, therefour you are bad.
Ah, let me clear up any confusion. "Humanization" is a term that specifically refers to producing strings like '2 hours ago'...so when that's advertised as a feature, that's what it means. However, this library is *very* much inspired by requests, and takes a human-friendly API very seriously. I'm curious, do you have any feedback as to why you feel it doesn't accomplish that?
PyCharm, or wait for SublimeText 3. 
What would be the benefits of enums in Python?
&gt;The properties of an enumeration are useful for defining an immutable, related set of constant values that may or may not have a semantic meaning. Classic examples are days of the week (Sunday through Saturday) and school assessment grades ('A' through 'D', and 'F'). Other examples include error status values and states within a defined process. Personally, I would find it great when wrapping C and C++ code. If you look at wxPython for instance you have a lot of variables written in ALL_CAPS that are actually constants. I have been wrapping C++ code to build automated tests and I would sometimes just like to iterate over an enum to apply each value once but I can't even easily find out which ones are grouped together.
Switch to Sublime 3 beta if your plugins allow you
Yes, but in the vast majority of cases they *are* strings.
Maybe in your code. I regularly use all kinds of stuff, including ints, frozensets, tuples, and more!
Finally! This is something that I personally have wanted for a very long time.
Maybe I've misunderstood, but you can assign values to non-string keys using {}.
I've found PyCharm is decent if you use Java 7. JRE 8 has some very strange lag issues, even on my extremely fast machine.
Eric IDE has a lot of nice features, project management, collaboration to allow one to chat with and perform collaborative editing with other users, etc. http://eric-ide.python-projects.org/
&gt; but this is useless information You're right, 21.1 microseconds vs 13.6 microseconds seems rather absurd. I dare say that this is irrelevant to 99% of python codebases out there. If by some odd chance hash table creation is the absolute bottleneck in an application then the dictionary creation entry point should be the C-API ``PyDict_New`` not through the source level. Or better yet use a [C hash table](https://github.com/pydata/pandas/blob/master/bench/bench_khash_dict.py) like Pandas did. 
This is perfect. I plan on using this in my code.
http://wiki.python.org/moin/IntegratedDevelopmentEnvironments I personally like Eclipse+PyDev, it's well supported and stable. Memory usage for this particular IDE can run a little high compared to others, but that's about the only downside.
Maybe try using Ninja? 
Yes! Sweet, sweet enums. Is there a third party module that implements the 3.4 enums somewhere?
Motivation behind this is unclear for me. 
More stuff on python IDEs on stackoverflow (see: http://stackoverflow.com/questions/81584/what-ide-to-use-for-python, for example). Would not be able to tell if any is similar to Matlab though. I personally use vim.
I've tried to use this IDE because I liked the visual aesthetic of it. It has never worked well for me.
Better than Eclipse? WingIDE (my favorite), PyCharm (probably better for web dev people) Similar to Matlab? iPython Spyder is mehh...Eclipse is mehh.. EDIT: ohhh...I finally gave iPython a chance because I have to give an interactive presentation next week. It's very different, but exactly what I need...
What's better about Sublime 3 over 2?
Take a look at the trial version of [WingIDE](http://wingware.com/)
Nice, but I'm a bit scared of the huge ammount of prerequisites for such IDEs... Sublime Text is just like 'copy&amp;run'.
Lucky for you that's [one of the sections in the PEP](http://www.python.org/dev/peps/pep-0435/#motivation).
Yes I've read this. I use python but I am not a programmer, so maybe that is why motivation is very strong for me. Seems like semantic sugar, all these could be easily done will just classes. 
iPython indeed. Check out this Pycon US 2013 presentation quite relevant for teachers: [Teaching with the IPython Notebook](http://pyvideo.org/video/1744/teaching-with-the-ipython-notebook) ! 
Same here, I don't understand why you wouldn't just use a dictionary or a class.
The only 2 other IDE oriented towards scientific development (somewhat similar to Matlab IDE) that I found are [IEP](http://code.google.com/p/iep/) and [PythonToolkit](http://pythontoolkit.sourceforge.net/). Have a look at them. However, if you are teaching Python for general programming development and not just for scientific development, I would not recommend those IDEs. It might ease the pain in the short run, but it might be detrimental in the long run. A simple text editor and a working console is often enough in my humble opinion. I like [the beginner setup](http://learnpythonthehardway.org/book/ex0.html) proposed by the book *learn python the hard way*.
Well it's about time. Now where's my switch statement?!
Stop questioning sublime text. http://i.imgur.com/MUhMz58.png
Right!? How has this not carried over to Python yet?
emacs
I have no idea how a switch statement isn't an if/elif/elif/elif/elif.... statement.
It depends on what is being switched over. If it is something that has a hashcode defined then a switch jumps directly to the correct case statement (constant time), otherwise it is just replace by the if/elif... at compile time (linear time). 
Holy crap, that's genius. How come this isn't a PEP already?
Adding depth to the me-too train - Me too!
Creating sets of pure logical constructs. For their example they use weekdays. If you made a weekday class, and then made the 7 weekday objects, it wouldn't make sense. Would it ever make sense for a client to make a new instance of the class? It's not really a full fledged object since you're never modifying anything, it's not storing any data. It is only itself and that's all it is. As for dictionaries, a weekday isn't a string, so why represent Thursday as "Thursday"? Instead represent it as an enum and then when you reference Thursday, you're actually referencing the idea of the weekday Thursday. Tl;dr: Allows you to reference a set of things as their self, instead of a representation of the thing.
You can already kind of do this with a dictionary.
That sounds pretty cool. Can you show me an example? My Python-fu isn't particularly strong.
Personally, I love IPython. But they never interacted with a command line (without a workspace browser and file explorer). They want something more IDE-like, I'm afraid. On the other hand, maybe I should just make them use the command line. It could prove to be a valuable lesson to them.
PyCharm for full-featured heavyweight dev, or lightweight text editor like Sublime Text, Vim, Emacs, etc... I find the rest of the stuff fall kinda in the middle of that spectrum and are half-assed IDEs and half-assed eidtors.
Spyder often gets stuck when using PyQt. Somehow it does not run scripts any more and needs to be restarted. This is happening about every hour per student. It's really annoying.
 def function_0(args): do stuff def function_1(args): do other stuff def function_2(args): do other other stuff switch_dict = { 0: function_0, 1: function_1, 2: function_3, } ########### # when you need to use it result = switch_dict[switch_case](args) You can use a default_dict (is that the right name?) so you get the same affect as the default/last entry in a C style switch. Since I suck at programming, you should probably search around before you use something like this. Here's one result I found http://stackoverflow.com/questions/10369537/using-dictionaries-in-python-in-place-of-case-switch-statement
Umm..from your description I'm reasonably sure Python is not the way to go. Perhaps look into Puppet or Chef.
But with this you're guaranteed to get every subtle detail right every time.
&gt; They want something more IDE-like, I'm afraid. WingIDE + a breakpoint and it's pretty IDE-like, while being a script.
Can you please point to the repo where you are working? I'm curious to track it. I tried out Numpypy for the first time today and didn't get very far. Looking forward to seeing your progress.
All I really use is Sublime Text 2, but I've used PyDev before and that seemed pretty good. I haven't tried any others such as WingIDE
OK here's why emacs is better than and IDE, *ESPECIALLY* for beginners: IDEs hide a lot of detail of what is going on behind the scenes. emacs is a syntax highlighting editor and you can keep a window open to run your code at the same time. This allows the beginner to stay close to the actual programming details instead of being insulated from them by an IDE. &lt;rant&gt; I have been a professional programmer and engineer for over 30 years now and I've taught CS at the graduate level. We already have too many GUI button pushers who think they're programmers and produce garbage. If it were up to me, people would be taught Python first and assembly language next. You have NO idea of how many lousy programs I have seen come at the hands of these GUI-trained "programmers". Good programming is all about understanding the detail of what is happening at every level of the system, not looking at pictures that abstract that knowledge away. &lt;/rant&gt; EDIT: Oh, and vim is also a good choice too, it is just more clumsy to use for this sort of thing but one can overcome that with the use of 'screen'.
See my answer to bastibe above. I rather think I've forgotten more about this than you're likely to learn in the next 10 years ... bro.
Careful. To make the jump constant time you need the hashes restricted in a relatively small target set. The same problem exists for very sparse switch statements in C/C++ compilers - these will sometimes be generated as if/else chains to avoid huge jump tables.
Goodness, sorry! I posted this comment before, but didn't go through, so when I reposted the comment, I guess I had the wrong link. Thanks!
Once a certain pattern emerges over and over again, it starts making sense to encapsulate it in a single santioned, tested and reviewed method. As of today, most Python programmers who've written non-trivial code bases self-invented some sort of enum, or copied a recipe from somewhere. The time has come to reunite them all ;-)
Do the breakpoints work well with PyQt?
Have you tried [Enthought](https://www.enthought.com/products/epd/) ? 
While I agree with your sentiment, my students are going to be engineers, not programmers. Their programs typically are not published. I am trying to convey as much useful programmer knowledge as possible, but that is not the goal of their curriculum. They primarily need tools to solve their engineering problems. Again, personally, I would totally use Emacs and Python for that. But many of them will never need to be a particularly accomplished programmer or even computer user. It is already quite a challenge for them to learn Python. I would love to teach them more about how to use computers and how to become a more well-rounded programmer, but that is not the goal of the course I am teaching. They are supposed to learn how to use Python as a replacement for Matlab.
I AM an engineer and anyone aspiring to that profession should be expected to become an excellent programmer. These days no engineering discipline can function without solid software implementations to support it. Programming is no longer the purview only of professional programmers (my grad degree was in Theoretical CS) but it should be considered a baseline requirement for ANY technical or scientific degree. In my view, you shouldn't be able to get a degree in Biology, Chemistry, Physics, Engineering ... without excellent programming skills any more than you could get one of those degrees without Calculus and Differential Equations. But that's just me ... I realize modern educational techniques demand that you professors consider the self worth and self esteem issues of your students more seriously than the content you're trying to convey. Not your fault, but tragic ...
Maybe you are right, It was suggested above and I had a look.. solid but I don't think it needs to be that 'big'. There is a size restriction, some security restrictions but the main thing is that it's consistent across the board. When I hire someone to maintain it I want one person to be in control. Python on ec2 (or app engine) and python on the clients. Web servers and sockets are a breeze with py so I have no qualms about the communication. There will be some heavy database work done in java, I just want to see them and talk to them over the web. Client side everything will be done with python, cython (maybe) and shell scripting. I really appreciate the feedback though, I am open to other suggestions and will be considering them. Thank you
I hear you and I think you are bang on, I wan't to find some good libraries or possibly a very lightweight sass/software. I just don't want to overcook it, the heavy lifting will be done client side and that will be a lot of scripting to control the os etc. I will never really be communicating with all at the same time, maybe 10 at once except for code pushes (git?).
I don't use PyQt, but they work well with wxPython. There's a free 30 day trial, so you can try it out. Oh...I didn't mention that, it costs money (so does PyCharm), but I'm not sure if there's a student cost. I got WingIDE through work and PyCharm for free because of an open-source project.
I really would have preferred a literal. Shake = &lt;vanilla: 7, chocolate: 4, cookies: 9, mint: 3&gt; In reality, I don't even care what they map to. If I was interested in a mapping, I'd use a `dict`. I'd love to see it as simple as: Shake = &lt;vanilla, chocolate, cookies, mint&gt; if some_item == Shake.chocolate: do_stuff()
&gt; And now Python becomes a little more like Pascal. :-( You say that as if it were a bad thing. ;-)
This doesn't have anything to do with named tuples.
Komodo edit.
Yes but it's a subtype that you're creating based on Enum. Enum is already implemented for you and (will be) heavily tested. It might be trivial but if you re-implement enumerations everytime you go to use them it would be a mess. I think part of the motivation was to have a standardized way to use enumerations with other stdlibs
One option is to use VS 2010, you can [download the integrated shell and Python plugin for free](http://docstrings.com/2013/04/16/develop-python-projects-in-visual-studios-for-free/).
So, it's just a standard module, not an actual language construct? I mean, I'm sure it's sturdy and gets things done, but it seems kinda cheap and work-aroundy.
I posted this above, but... Wingware will grant full professional licenses to instructors for all of their students. https://wingware.com/store/free
I've often wanted enums in Python. Mainly for error prevention: it prevents a lot of the spelling errors and so on when you roll your own closed set of values. Yes, you can do this on your own. But it's so much nicer to have this done for you as a built-in class. Here's a half-baked solution. &gt;&gt;&gt; class Enum(object): def __init__(self, **kwargs): self.__dict__.update(kwargs) self._vals = kwargs def __iter__(self): return self._vals.iteritems() &gt;&gt;&gt; enum = Enum(a=1, b=2, c=3) &gt;&gt;&gt; enum.a 1 &gt;&gt;&gt; enum.b 2 &gt;&gt;&gt; enum.c 3 &gt;&gt;&gt; for item in enum: print item ('a', 1) ('c', 3) ('b', 2) Much better to have Python do a proper one for me.
There's an IntEnum class which is a subclass of int and Enum. All members will be required to be ints.
Rookie here. Isn't this a performance issue since Python is slow with functions? I'm asking because right now I am using second-order functions to transform coordinates and they are called over and over for hundreds of thousands of points. It's slow as hell.
`defaultdict` so super close, in the collections module. 
Well, this is why I said I suck at programming and to not trust my advice. Anyway, Python isn't really known for being fast, so if there's something you need done super-quickly over and over, usually write it in another language.
It's in the PyPy repository : http://bitbucket.org/pypy/pypy
Thats pretty nice.
For one it makes sure that you aren't abusing the enum values like you can in C, for instance. The motivation section states that it would disallow things like `my_enum.wednesday * 2` and will make sure that all enums have mutually exclusive values (i.e., no two enum states from any two enums will be equal). Basically it just provides promises to the programmer about what can/cannot/will/will not be done with the data. 
one ~~ring~~ enum to rule them all
&gt; it's pretty cool to embed some TCL code into my project to freak my co-workers out. that would freak me out as well ._. what about the api is archaic though? I enjoy it.
I don't see how it's inelegant really, it's basically a class with some magic to it. I'm pretty sure you can implement it in pure python (it might even be)
I was thinking along the same lines too. My particular complaint is that they require mapped values for every member (eg Color.Red=1). In my book, that's a mistake because it will often mean littering code with irrelevancies mandated by the library. The greatest benefit (IMHO) of enumerations is their use as a restricted value type with symbolic names. Value mappings shouldn't exist unless needed by circumstance.
Or run it in PyPy; the optimizing JIT will see it's being run over and over... and make it fast magically! No C needed :D Or write it in Cython; where it goes almost at C speed, but looks and works basically like python! Or use a C-extension like numpy, where all the actual work is done super fast anyway!
Never happend to me, and use it on 5 different pcs.
After all the thinking you have done, do you really believe emacs is on par with MATLAB for scientific work &amp; exploration? &lt;:^ )
Have you tried making use of numpy? It should be great with vectors.
or just use `my_dict.get(case, default)`
Can you ELI5? Is an enum just like an iterable dict?
dicts are iterable... Enums are just a set of named values which are referred to by name whenever they're invoked, but are internally stored as a simpler data type, in this case an int, but in other languages often other simple primitive types too. They're actually really simple, and essentially just "nice" as a language feature... they don't "allow" you to do anything you couldn't do already. Hope that helps.
A self-referential comment. Clever.
[Check this thread.](http://www.reddit.com/r/learnpython/comments/1c8jg2/conclusions_of_a_begginer_about_finding_the_best/)
I don't really care if all of the members are of a certain type, I just don't want to have to write a class every time when I think that a literal would be nicer.
Thank you for this; it saves me having to encode the whole thing in Python myself! I did try to make the latter two points you raised. 
Python isn't inherently "slow with functions", just in CPython function calls are *relatively* expensive compared to doing more iterative logic. In any case, this function-based switch is always only one function call, so I wouldn't worry about it. It would be kind of interesting to know how many chained elifs (with trivial conditions) you'd have to go through before it becomes more efficient to use a function-based switch in CPython, though.
&gt; They should have pointed to you, that Python uses pointers (references) a lot, &gt;even if you don't realize it. Actually *I* ended up pointing that out to demonstrate why Python didn't need a pointer *type*, and one person then said I lied about Python not having *pointers*, sigh. :-) But thank you very much for explaining this (shorter and more clearer than I tried to). Hell, even it's garbage collector works on "refcount", meaning it keeps account of ... pointers.
&gt;I've just given you an example of a program that you can't write without pointers. It's an example of a program you can't write, period, because you can't know the real absolute memory address with a pointer. Using the memorymap feature of the OS one can and does do this in python without the language having a pointer type. &gt;Your claim that the programmer never needs to access an address is also wrong, &gt;since that is precisely what you need to do for memory mapped IO. And yet mmap allows a python programmer to do this without a pointer type. "Memory-mapped file objects behave like both strings and like file objects. Unlike normal string objects, however, these are mutable. You can use mmap objects in most places where strings are expected; for example, you can use the re module to search through a memory-mapped file. Since they’re mutable, you can change a single character by doing obj[index] = 'a', or change a substring by assigning to a slice: obj[i1:i2] = '...'. You can also read and write data starting at the current file position, and seek() through the file to different positions." &gt;A memory-mapped file is created by the mmap constructor, which is different on &gt;Unix and on Windows. In either case you must provide a file descriptor for a file &gt;opened for update. If you wish to map an existing Python file object, use its &gt;fileno() method to obtain the correct value for the fileno parameter. Otherwise, you &gt;can open the file using the os.open() function, which returns a file descriptor &gt;directly (the file still needs to be closed when done). &gt; So an authoritative source that pointers aren't necessary just doesn't exist, since &gt;such a source is simply wrong. You'd best inform Guido Van Rossum then, or write out a PEP. 
Redis is pretty quick, so it might not block disastrously. Apparently [redis-py](https://github.com/andymccurdy/redis-py) is thread-safe too, and there's [txredisapi](https://github.com/fiorix/txredisapi) (which I haven't used) which does Twisted. 
That would limit a hypothetical Python switch statement to only accepting hashable types - which would exclude sets, lists, dicts and any user-defined class that didn't implement \_\_hash\_\_(). That's quite a significant limitation, before you even consider the headaches of debugging objects with inappropriately implemented \_\_hash\_\_ functions. If you were to remove that limitation, you would have to check for equality with every case statement - which would actually be a less-powerful version of chaining elifs.
So, programmers hate all web developers? That makes sense. (We're not all like that)
How else would you do it? Bare in mind that you can't introduce new language keywords on a whim.
Not only is it slower, the items in the dict can come out in a different order when you iterate over them. You shouldn't rely on the order of items in a dictionary anyway, of course, but if you're using a library that happens to do that, it can cause some [inexplicable behavior](http://stackoverflow.com/questions/16107832/specifying-dictionary-argument-with-dict-or-braces-matters-in-set-bbox).
Because while doing a hash table lookup is constant-time, its still often a lot slower than doing a linear search until you get to a quite sizeable number of elements. And while the compiler can do this relatively efficiently with a fixed-size hash, when was the last time you saw a switch statement with over a thousand cases?
&gt;It would be kind of interesting to know how many chained elifs (with trivial conditions) you'd have to go through before it becomes more efficient to use a function-based switch in CPython, though. For me it's more about the clarity of the code than the performance. Sometimes switches just make more sense.
There may be a bit of a melt down going on right now... hasn't worked for at least 5 or 6 attempts over 1 hour range. Looks really cool based on the code @ github.
I'm interested in hearing more about your thoughts on Ansible vs Salt. Would you care to elaborate? 
This seems like something we should wrap for use in IPython -- create alternate views with their own __repr_html__ defined. I think I'll play with this when I get back to a real PC.
Right, but this isn't on a whim--this is a standard feature planned for inclusion in a release. Consider this semantic change that was included in 2.6: http://www.python.org/dev/peps/pep-3110/#semantic-changes
Great, now I need to switch to Python 3.4. Oooooor I could stay on 2.7 FOREEEEVEEEEEEEER!!!!
Explicit is better than implicit. Code like: RED = '#ff0000' GREEN = '#00ff00' BLUE = '#0000ff' print("My favourite colour is {}".format(BLUE)) Can now be more correctly written as: class Colour(Enum) red = 1 green = 2 blue = 3 my_colour_mapping = {'1': '#ff0000', '2': '#00ff00', '3': '#0000ff'} print("My favourite colour is {}".format(my_colour_mapping['Color.blue'])) Because non-native-english speakers may get confused about what a 'BLUE' actually is, so you need all those redundant inclusions of the word 'Colour' to help them figure it out. (No, I don't see how something useful that everyone wants like requests gets rejected from stdlib but this crap gets in) 
What's the benefit over just doing: class Color: red = 1 blue = 2 green = 3 I don't get the usefulness of it 
But you don't have to write out all the class boilerplate every time because there's a functional syntax for that: &gt;Animal = Enum('Animal', 'ant bee cat dog')
You're doing Enum's wrong if this is your intended use case. If you need explicit values you don't want enumerations.
OH! That's significantly better, thanks for clarifying. I hadn't gone through the entire PEP yet (working on homework), I had only looked at the syntax for defining a subclass. I'd still like a literal, but I'm perfectly okay with the functional API provided.
I am currently working with a climate modeling team, and I find the "2 kinds of users" explanation to be pretty accurate. (Though there are plenty of other groups as well. Students, home users, etc) My job description falls pretty solidly on the "web" side of the fence at the moment. I spend my days trying to make the analysis tools easier for the scientists to use, and am picking up bits and pieces of how they work along the way. I haven't asked around very much, but at least some of my co-workers have PhDs in oceanography. I know one of my co-workers has a PhD in Computer Science. The project lead used to be a climate scientist himself, but transitioned to building tools instead. I only have a BS in Computer Science, but over time, I can easily see myself transitioning to a scientific computing role here. My advice would be to find a "web" position that allows you to grow into a "scientific computing" role over time. Once there, put out some good code and wait for the inevitable moment when they'll need more help with one of the analysis tools. (You shouldn't have to wait long) That is your chance to volunteer to help and begin your gradual transition to the other side of Python. Good luck, it is definitely possible! 
Ruby's :symbol is pretty neat in this situation
Yeah personally I'm not the biggest fan of the functional syntax but there is a good discussion about why it is the way it is on the python-dev mailing list.
Some enums you don't want any sort of ordering and I believe named tuples are ordered. The more important part of PEP 435 is that the enum module fits in Pythons type system better than named tuples allow. For example how do you check the equality of a set of enumerations using named tuples? What are the types? How can you add to an enumeration? etc...
The current implementation of the PEP is in Python.
Your choices are basically variants of [gevent](http://gevent.org/) , [Twisted](http://twistedmatrix.com/trac/) , and [Tornado](http://www.tornadoweb.org/en/stable/). IMHO all three will work, and it comes down to which one you find most congenial to work with. In my case it was Tornado, but I still think about using gevent or twisted. Generally speaking if you're doing mostly web and database stuff, Tornado is a good answer; if I needed to talk to a bunch of different protocols I'd look at Twisted. I'd look at gevent if I needed to do a big clean project and found that Tornado was lacking in performance for that application. But that's me. Look around, make your own choices.
It's trying to be consistent with the rest of Python
You have my 2.7 sword.
No difference other than a bumch of helper funcs and __eq__, __lt__, __gt__, __getitem__, __call__ defined.
You're paying more for less commonly used cases. If you need just Something.CONST, class will do it for you. The rest is so easy to implement I am baffled this needs stdlib inclusion
Off the top of my head, Ansible requires nothing to be installed except ssh.
You can do this with one of the Reddit API wrapper modules (PRAW seems to be the done thing right now) and possibly `urllib2` or `requests` (if you need to detect and 'unwrap' images from wrapper pages, such as flickr or tumblr.) I have, in fact, done this myself, in the form of a script that finds image or video links in the topmost 400 items of a subreddit, and writes a metalink file that can be imported into DownThemAll. I can give advice but don't ask for the source code -- I think this is the kind of thing that shouldn't be redistributed.
1. Comparisons against non-enums / enums of a different type are always False 2. Printing an enum prints the *string* value of the enum. Otherwise, they're no different than this: class Color(object): red = 0 blue = 1
`Enumerations be pickled and unpickled:` ebonics in a pep?
&gt; Motivation behind this is unclear for me. If it's anything like the trinary operator then Guido's motivation might be "because everyone's been bugging me and I'm tired of saying no".
Tornado is pretty easy to use, here is an example I recently wrote. https://github.com/schwiz/websocket-server
I love DreamPie. Works great, especially on windows.
I still don't fully understand what you want to do. Can you give a more descriptive explanation of your end goal? I may be able to make a better suggestion.
according to your post history, all you do is spam reddit with these things fuck you and if this is your job, I hope you get fired
I'll give a +1 to gevent. Specifically, check out [gevent-socketio](https://github.com/abourget/gevent-socketio) and [gevent-websocket](http://www.gelens.org/code/gevent-websocket/). I'm using gevent-socketio and django to create serve up live notifications received via a message queue, but there's no reason you can't hook into redis (which can be used as a backend for django's cache mechanism for even more easyness)
Coming from the background of language philosophy, I am thinking about what you've written here and I have been thinking about it for 20 minutes. It both helps me to understand and confuses me to say this "represents a thing as itself instead of a representation of a thing." This is not a criticism of how you expressed it: I think there's a large concept here but I'm pretty confused.
The problem is hard to reproduce, but I will try to explain it in a bit more detail. The students are working on some simple PyQt GUI program. They also use PyAudio. Both libraries have a run loop on an independent thread. The students change something in the script, then run the script, change something again, run again... But sometimes the scripts won't run any more, or they experience strange run time behavior that is not explainable with the code. It seems there is some existing state from previous runs that is polluting the current run. Sometimes, this can be fixed by closing and restarting the command line. The problem does not occur if they open an iPython command line and type `run script.py` from there. Sometimes the problem can only be fixed by restarting Spyder. Spyder never stops responding (it does not "freeze"), but scripts are getting executed incorrectly or not at all. I will try to reproduce the problem more clearly and send you a bug report if I can find a consistent trigger.
2.1.11 as included in Python(x,y)
Repetition and verbosity. With elif, you have to supply the same variable over and over and over again.
Wow, interesting timing. I just looked into it in 2.7 and found a [way to easily implement it](http://stackoverflow.com/a/1695250/173957).
wow sorry to hear you're so angry about this one buddy. Yeah I probably should use reddit for something else but instead i'm just a teacher with a hobby. Good luck to you mate.
Using gevent with redis works fine. You just have to realize there may be increased overhead if you use redis in a synchronous manner (see [here](http://stackoverflow.com/questions/10656953/redis-gevent-poor-performance-what-am-i-doing-wrong/10663498#10663498)). For websockets, there is [gevent-websocket](http://www.gelens.org/code/gevent-websocket/). I use gevent, redis, pymongo, bottle, websockets, and zmq, all within a single process and it works great for me.
I have to disagree there. Many of our students are going to be doing clinical studies. They use programming to build GUIs and test signals for testing patients and for statistical analysis of the results. Others are going into acoustical engineering, where they have to measure, simulate, and improve upon acoustical objects such as cars, dishwashers or airplanes. Again, they need programming mostly for simulation and analysis. Many of them will not need to be expert programmers. In fact, I see a tendency that those who are able programmers tend to slide into more and more programming-centric roles, which many of them regret later on. As a side note, I am German, and I find that there are some weird differences in the term "Engineering" between the US and the European mainland.
That's why I always run my Spyder scripts using the command line...
Have a look to [ginsfsm](http://ginsfsm.org)
Ok the main thing I dislike about this is that it entirely ignores my GTK theme/icon theme. Why the hell would they do this?
I've used the following quite successfully: https://github.com/MrJoes/tornadio2 (socketio in tornado) But honestly, node/scala are probably better.
/r/pics ... sure ;) ... It's definitely for /r/gonewild ;)
I tried to reproduce the problem, but failed. Either the problem only exists in the particular version of Windows/Python/Spyder installed on the student's computers, or it is the result of some weird user behavior.
I started writing a syncing system between a server and my client in Python. I use Sublime Text as my editor, and it is cross-platform so I have no problem changing between platforms.
Sublime Text + Dropbox = seamless cross-platform environment. Apart from the Python installs, obviously.
I suspect PyPy already constant-folds variables that are used in all the tests of an elif, and their hashes if the comparison is hash-based. As others are pointing out, using a switch statement that always hashes would make things slower.
I'm going to. My current code is basically my first Python program, very dirty and non-optimal. Second-order functions are very neat for safe handling of situations like "if the config file says 'TransformationFunction=Foo', return code that will take user's input arguments and process it using function Foo", but there should be better solutions and I should really start making objects instead of just bunches of functions that need access to a lot of arrays.
It is a wonderful thing if a language is well enough designed that new features (like enums) can be added by normal developers via normal processes (like modules) rather than only being addable by the core language team (with special syntax).
&gt; You're paying more for less commonly used cases. "Paying more" how? 
I'll just repost this: class Colors(Enum): red, green, blue = range(3)
This. Also making sure to install the same packages and versions of Python.
1. Use virtual machines to have the same environment everywhere. Coding in a VM is a Good Thing (got a new computer? Copy your VM and you're all set...). 2. Consistently commit projects + conf files (.vim etc.) to a remote VCS (private repos on Github/Bitbucket or on a cheap virtual server) That should do it.
There's an existing `enum` package on pypi, and if I remember correctly it works in a very similar way.
Well I know what enums are for and I consider that TL;DR confusing. The gist is this: * Weedays are a concept * Each weekday is an instance of the "weekday" concept * So it makes sense that "weekdays" would be a class, and each "weekday" would be an instance of the class. * The regular Python syntax for that might be: class Weekday(): pass monday = Weekday() tuesday - Weekday() wednesday = Weekday() ... But you probably would want to group them into a namespace, and "Weekday" is a good namespace, so you might do something like: class Weekday(): pass Weekday.monday = Weekday() Weekday.tuesday - Weekday() Weekday.wednesday = Weekday() Now you can do that with less code: class Weekdays(Enum): monday = 1 tuesday = 2 wednesday = 3 And you get a lot of automatic goodness like Weekdays.monday.name and "for weekday in Weekdays()" 
I use an Xubuntu install on a 16GB USB stick on my home PC and my school's computers, and on my laptop I have a separate install. I sync stuff using Git (and Github) along with Dropbox, and I've just started using Ubuntu One, which so far has worked just like Dropbox for me. I edit in Sublime Text (would use it on Windows at school, but they block us from using un-whitelisted executables). I can get onto Skydrive at school, which I used because Dropbox is blocked, but now I'm using Ubuntu One it's much easier - I'm not limited to using a browser.
* One git repository for my settings * One git repository for my source code when I switch between work and home, all syncing is just a git command away. If a project requires elaborate setup (e.g. installing dependencies or downloading some data, I write a short bash- or python-script with the necessary apt-get's to set it up on new machines. That script goes into the projects git repo. Of course, all my systems run Linux and I make sure that all of them have more or less the same software environment (IDEs and libraries installed etc.). But that's just a one-time investment of setting things up when I set up the machine.
SublimeCodeIntel is huge. I will use ST3 when that is working. I check every few weeks here: https://github.com/wbond/sublime_package_control/wiki/Sublime-Text-3-Compatible-Packages
Seconding this. I just got a virtual private server on a public IP address for around $40US a year. It's got a five gig virtual disk and a terabyte of bandwidth a month. I use about 20MB a day logged into it via ssh. It has the added benefit of being a convenient place to host private git repos, serves as a simple web server for hosting low-interest content I occasionally need to share and can even provide domain name or mail services. I got a domain for it for about $15US to make it more convenient for me, but it isn't strictly necessary. If you aren't a command-line jockey, you can probably even load up a simple XFCE desktop or something without too much trouble and use VNC from where ever you are.
All my development in the past five years has taken place either on my Linode (for personal projects) or on a company VM. Realistically speaking, I never need an "offline environment." I'm genuinely interested: how often do you find yourself without a network connection, but with time to code?
&gt; !&lt;shell command&gt; Holy shit TIL, thank you!
&gt; [4]: %timeit TIL, thanks. &lt;3 IPython
Vagrant (the virtual box wrapper) and github would be a good fit for this. You would just need to keep your Vagrant setup files and your github private key (Dropbox?) and then you could automatically set up your dev environment and clone your repo. 
Woah. That sounds magical. Would you be willing to share? :D
I'm using a remote desktop to a could instance for work related stuff.
It is a bit problem for me, because of Qt licence. I want to sell my software without releasing it's sources.
Thanks for your answer bastibe. The problem could be triggered by the fact that Spyder is built with PyQt and your students are using it too. For example, I think two applications can't start the main event loop at the same time (the one triggered with QApplication.exec_()). To avoid this you can tell your students to open the "Run configurations" dialog (the one that opens on every first file run) and select the option "Execute in an external system terminal". That will use cmd.exe to execute their code which means it will run completely outside Spyder. Besides, this option opens a new terminal every time, which avoids the problem you report about picking up the state of past executions. Another option would be to install our just released Spyder 2.2 and try to run the code on IPython, because we have a really great integration with it right now and I think it has some code to handle running PyQt apps inside it (despite being based on PyQt too).
Sure! Go here: http://www.lowendbox.com/blog/ramnode-15-60year-128mb-ssd-openvz-vps-in-atlanta-seattle/ Use the link on that page to get 35% off of the cost of the server when you checkout. There is currently a 40% off coupon ("SOMUCHDRAMA"), but it may expire soon. The 35% will be good for a while. I went for the 256MB KVM SSD option because I use KVM at home and like it. Other people swear by OpenVZ, but I don't know anything about it from a systems standpoint. It probably won't make any difference to most people as just a user. I paid for a year in advance via paypal and it cost me $38.88. After you get through the purchasing process, you will get some emails describing the next steps. You can remotely load an OS using a very simple web-based application. I used the 64-bit Debian minimal load, but pick whatever you want from the list. They have lots of options: https://clientarea.ramnode.com/knowledgebase.php?action=displayarticle&amp;id=48 I did upgrade my debian load to wheezy (7.0) which was just released, and you need to make sure you stay on top of system and security updates or you will get pwned. After that, install whatever you like to use and play around with it. I'll be happy to answer questions if you try it and get confused. I'm planning on making a simple pseudo-anonymous epub hosting site with my first one. http://www.epubdepot.com/
Don't bet your career on Python. Sooner or later, when you have to deal with huge amounts of data, you may have to start using static languages like C or Java. Always choose the right tool for the right job. You don't really build a career on Python, rather you build on doing something you love. And how do you know what you love, unless you've tried out all the different languages and programming paradigms out there ? There could even be some language that interests you more than Python ! 
I did some asynchronous wxPython programming a while ago and I find that very hard to believe. The toolkit has, like every other GUI, some peculiarities that if ignored will make your code behave strangely, but if you follow the documentation closely you should get a very solid application. 
Qt is LGPL, I don't see a problem.
http://qt-project.org/doc/qt-4.8/lgpl.html the qt license problem went decades ago
 class Dumb(Enum): nilved = 1 class Useless(Dumb): pass
This is the correct answer. Using git (or some sort of revision control) is proper form anyway, but being able to just come home and do a pull --rebase and be back in action without missing a line is pure awesome-sauce. Reading all these posts about dropbox/usb sticks is giving me chills. 
Do you perhaps mean Vagrant? I only know Varnish as a caching proxy server.
good god that is ugly
Fixed, thanks. 
Unaware of this. Thank you good sir
type safety? who wants type safety in python?
Then don't use that syntax, there are other ways of defining an enum. From the PEP: &gt; It can be a whitespace-separated string of names, a sequence of names, a sequence of 2-tuples with key/value pairs, or a mapping (e.g. dictionary) of names to values. Animal = Enum('Animal', 'ant bee cat dog') Animal = Enum('Animal', ['ant', 'bee', 'cat', 'dog']) Animal = Enum('Animal', {'ant': 1, 'bee': 2, 'cat': 3, 'dog': 4}) Animal = Enum('Animal', ('ant', 'bee', 'cat', 'dog')) Take your pick
My fault, sorry and thank you!
Wow, this looks amazing. Thanks!
Sage notebooks are similar to matlab's, but the Sage environment might not be close enough to pure Python. IPython should be a good compromise: it has notebooks, but it also works well for plain Python development. You can also shell out with `!cmd` for committing and the like, launch an editor with %edit, use cd and ls.
I rather like wxpython but haven't ever tried QT.
if you spat some code into a pastebin and asked for help I'm sure people would be able to help you be "more pythonic" and more efficient at the same time :) This video is also *awesome* for just learning a truckload of ways to write good python- https://www.youtube.com/watch?v=OSGv2VnC0go
Don't forget to back it up, just in case :)
[PyQT is not LGPL](http://www.riverbankcomputing.com/software/pyqt/license) [PySide is](http://qt-project.org/wiki/PySide_FAQ)
Then buy a development license for PyQt. If you're selling software a $500 library license shouldn't be a hangup. The money goes into PyQt becoming better. For example PyQt5 should be out shortly. 
I use one of two things: * PythonAnywhere * SSH server on my Mac, that I remote into. I have all my code in Dropbox so it's available in each (mostly instantly). Both of these solutions work decent, even on my iPad. I've found the SSH server is more robust, but PythonAnywhere works in every browser I've tried.
Not every software costs thousands of dollars.
Started with Tk on a small project, mostly because it comes with Python on Windows. That way my users wouldn't have to install a bunch of libs. But the UI for Tk pretty much sucks. I switched to PyQt4 and have to say it's awesome. Qt designer is very nice, the slots/signals work really well and it's easy to use both to make threads work nicely together. There's also QSettings which handles cross platform config file storage quite nicely. Qt is also very visually pleasing. To get around end users needing to install it, I'm using PyInstaller to build binaries. That's also worked out very nicely. It's easy to use and works without a lot of hassles. Though I'm still trying to get a Mac install up and running to build Mac binaries. This is a pretty good course to watch to learn Qt under python: https://www.udemy.com/python-gui-programming/ You can use PySide instead of PyQt if you need a LGPL license, but PyQt is under heavier development since the commercial licensing pays for work on it. They're currently working on Qt5 support which has some nice new features.
Depends on the environment I am working in. Usually I pick Tkinter or gtk+.
I ws looking into very sophisticated solutions but in the end I just went for Dropbox. It's working really welll.
The one I've used is Maple, but it was a long time ago.
Filling that __dict__ with functions you'll rarely if ever call. 
Don't you bother about other platform users?
I'm sold on Vagrant and Puppet (which can be used to provision identical virtual machines with a single command) along with git for the code. Put your vim config files and settings in a git repository. Copy your sensitive info to each machine once as part of the initial setup. 
OT: PyInstaller - thanks a lot!
I've used wxPython, TkInter, and PyGTK. I like PyGTK the best because the documentation is decent, the API is easy to understand, and it has a pretty large set of standard widgets. I wouldn't recommend trying wxPython. It's awkward to use and there are a lot of "gotchas" that are documented on random mailing-list threads that you'll waste countless hours trying to find... TkInter is great for small stuff. It's not as feature-rich as PyGTK or wxPython, but it'll get the job done. After reading all this praise for PyQt, I think I'll use it for my next project :)
I use virtualenv and/or buildout+mr.developer to reproduce the exact environment on the machine I happen to be developing on. This also allow the deployment of the application that is being developed to be rolled into the same repository, so that if it can't be reproduced with ease (i.e. bin/buildout or pip install -r requirements.txt) on a new machine it means it's a problem need to be fixed.
One more fix needed. "...keep your varnish setup files..."
YES YES and YES - First off join [Linkedin](http://linkedin.com) , make sure you join python groups and actively try to be involved in answering. Ive gotten lots of requests to handle backend jobs. Secondly create an [Elance Account](http://www.elance.com) and put your skills as far as python is concerned. Do you work under windows or linux, you could put worked under both OS's if you have You will receive job offers and you can bid on them. Third, setup a simple website advertising your development. You can do all this for free. I freelance in many languages, I dont even know half what many of these pro's know, I do have a computer science degree but it was worthless, I get subcontracts because I can do the job, not because of my degree. Lastly, dont be afraid to expand into other languages. R is simply amazing when it comes to statistics. I went through a coursera course on data analysis and put that on my resume and immediately snagged a nice research spot with a phd student. 
PyQT4 ( QT4 and QT5 ) is dual licensed http://www.riverbankcomputing.com/commercial/pyqt PySide is good for QT4 but if you need features in QT5, PyQT4 is the only option I know of at this time ( last time I researched it was two months ago, looking for QT5's Webkit module with Python bindings ).
PyQT4's already got experimental QT5 support ( they forcibly swapped in QT5's library and patched a few of the bindings so it doesn't have QT.Quick yet ).
Qt is the only real choice for cross-platform development if you want a UI that isn't terrible. Is PySide still alive with Nokia selling it off, etc.?
TraitsUI and Chaco kicks ass for scientific work with NumPy.
[Oh gosh darn it.](http://i.telegraph.co.uk/telegraph/multimedia/archive/01786/polar-bear-cub_1786691i.jpg) Thanks! 
Instances don't have a copy of the functions or even the function pointers. They just have a pointer to their class and the class has the function. A method on Enum takes up the same amount of memory whether your application has one Enum or a million.
First, caveat: when mobile, I generally work on small side projects &lt;5k LOC. - [Nexus 7]( https://play.google.com/store/devices/details?id=nexus_7_16gb ) (8gb) - Dropbox (via [dropsync]( https://play.google.com/store/apps/details?id=com.ttxapps.dropsync )) my mercurial repo, but only check in at my Macbook later. (i need to switch to git which has android client, just lazy) - [DroidEdit]( https://play.google.com/store/apps/details?id=com.aor.droidedit.pro), which lets me launch - [SL4A, Python]( https://code.google.com/p/android-scripting/) - [Logitech bluetooth keyboard, with stand/case]( http://mobile.logitech.com/en-us/product/tablet-keyboard-android-win8-rt?crid=1242) Some will say it's too underpowered or too small of a screen. Well, it's at least 10x faster in Python than my first "high end" PC ran C, about 2x resolution, and my eyesight is still sharp. But like I said, small projects. If someone built a real, code indexing, multilingual IDE for Android... well, as they say, "shut up and take my money". 
 warranty = max([li.find_all('b')[1].get_text() for li in lis]) Use a generator expression here instead of a list comprehension by removing the (outer) `[` and `]`. It's more efficient and less typing. 
I wanted to use it, but seeing how long they drag wx-3.0 release I gave up on wx(python).
One problem I had with PyQt was that the only documentation I could find was very much taken from the C docs; I've come to expect better from python projects. Was I just missing some resource? 
Thanks. Never heard of a generator expression, but I'll see if I can figure it out. 
Huh? It's a strongly typed language. e.g. 2 + '2' TypeError: unsupported operand types for +: 'int' and 'str'
Tk. The pack geometry manager is by far the best way to build a GUI.
the normal ones are mentioned in the thread, if you want something similar to Qt/QML but in python then http://kivy.org is a nice UI library.
Why didn't you use this: http://repl.it/languages/Python ?
because there is no good argument to do so.
There is also [Cyclone](http://cyclone.io/). Which is the Tornado API running on Twisted. 
Many agree that switch(x): case opt1: case opt2: ... case optn: case default: is more readable than a long chain of if x == opt1: elif x == opt2: ... elif x == optn: else: and Python is all about readability. Edit: forgot "case"
You don't have to. Qt offers LGPL license. This only covers Qt. You only need to release code if you're making changes to Qt itself. 
Tkinter. The standard. Although I haven't really tied anything else I guess..
GTK, because I'm using GNOME, and because I learned it in the times when Tk looked terrible (I don't know if it still does), Qt required a commercial license for non-GPL software and WxWidgets were looking weird due to reimplementing some basic stuff. I didn't need to write much UI software recently though, so I haven't had the chance to evaluate the changes in other libraries.
can you demonstrate the type safety benefit of the enum?
possalby :P
Thank you.
In my case I started first with this approach, but when wanted to log or print statements that contained enums I only would get the numerical values which was not that helpful. I ended up with writing my own implementation (did not want to have dependency on external packages). Having something like that built-in would help a lot.
This is an area ripe for change. While there's several good options for GUI, none feels reasonable for skinning a small GUI with minimal effort with default behaviors you don't have to design in detail but work nicely anyway. IMHO all of the good ideas are being shunted into web frameworks and maybe no one will ever bother to back port them to desktop app development.
It seems both Dropbox and Google Drive use wxPython.
I'd love to use these, but they're inscrutable! They look like a computer scientist wrote them, with perhaps a one level of abstraction too many. Enthought provides lots of recipes, but that's not enough to make up for missing documentation and impenetrable organization. Can you tell this frustrates me?:-)
I tend to just use this: http://pyqt.sourceforge.net/Docs/PyQt4/classes.html 
Depends on your purposes and what environments you want to support. If you haven't programmed in GUI before, start with Tkinter because it's the included default/easiest/fastest to get started using. If you want to support as many platforms as possible and don't mind a little extra hacking to make things work, see if [Kivy](http://kivy.org/docs/gettingstarted/intro.html) can do the trick!
God have mercy on you if you use switch statement for something like this even outside of Python. Could you show an example that is more likely to happen? For example only one case performs assignment to a variable? 
`import ruby` does not work for me :/
It's not very in depth, though. It seems one always ends up going to the qtproject website for thorough documentation.
&gt; PyQt5 should be out shortly. [citation needed] (dates and class implementations would be awesome, but I couldn't find much details when I looked a couple of months ago)
IIRC, they had support for Qt4 classes. Not new ones. I'd be great to see full support of QT5's classes.
Yes, it uses QT4's class signatures but QT5's objects, I know this is true of QTWeb and a couple dependencies of that were updated. 
for a more common, use the same technique, but dispatch to a function: func = {1: do_work_1, 2: do_work_2, 3: do_work_2}.get(a) return func() if func else 'cannot route'
I do virtually zero GUI development that doesn't live on the web, so SSH is more than good enough for me. If I really need to edit some files I'll symlink the project into Dropbox before I hit the road so I can at least edit files while mobile.
'scool. You have my upvote. I always appreciate the effort to maintain good standards of usage. 
That argument is a false dichotomy: there are many ways to achieve that end. See the pythonic 'dictionary dispatcher' idiom: def route_simple_action(a): return {1: 123030, 2: 2230302, 3: 33030}.get(a) or def route_complex_action(a) func = {1: do_work_1, 2: do_work_2, 3: do_work_2}.get(a) return func() if func else 'cannot route'
Has anyone had any luck with Enthought's Traits UI? It makes it very easy to program simple GUIs, but I had some trouble tweaking some of the details the way I could with PySide.
On OSX if you look inside /Applications/Dropbox.app/Contents/Resources/lib/python2.7/site-packages.zip You'll see ```ui/wxPython``` is sitting there. I guess it's the same on all platforms... otherwise why use wxPython.
I mean't single underscores, which are cosmetic. I'm having a hard time deciding if internal class methods,variables(which are not a part of the interface) should be prefixed with underscores to signify that they are internal.
readable code &gt; terseness I would immediately refactor this into an if-elif-else block if I came upon this code.
I've been using pygobject because although I don't use gnome, I mostly use gtk apps. The documentation isn't very good though, and as noob i've had to do a lot of googling. I usually find answers on stackoverflow in the form of code examples. I haven't tried glade yet though. 
I know. Still is extra functionality not needed for most uses.
yeah, yeah, clever syntax, but it's limited in its use and practical application. What if you had 20 or even 100 cases to your switch statement, like from input? Your abbreviated form would turn to unmaintainable mush. Also, your switch statement is malformed: switch a: case 1: return 123030 case 2: return 2230302 case 3: return 33030 else: return -1 ["else" is more pythonic than "default"](http://www.python.org/dev/peps/pep-3103/)
Gtk + Glade. Because the glade tool is neat, the API is well documented and the result is as portable as with QT, but with a nicer gnome3-like look and feel.
You need to define do\_work\_# functions separately. How is that any more compact/pythonic than using if-elsif statements? You could say that you use right tool for the right job, but then we could make your initial example even simpler and would work better in right use case: return (123030, 2230302, 33030)[a-1] What you are suggesting could also be done in C for example: uint8_t a; [...] func_t func[] = {do_work_1, do_work_2, do_work_3}; return a &lt; sizeof(func) / sizeof(func_t) ? func[a]() : NULL; Yet that language still has a switch statement and it is used extensively.
From http://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles : &gt; In addition, the following special forms using leading or trailing underscores are recognized (these can generally be combined with any case convention): &gt; &gt; * `_single_leading_underscore`: weak "internal use" indicator. E.g. `from M import *` does not import objects whose name starts with an underscore. &gt; &gt; * `single_trailing_underscore_`: used by convention to avoid conflicts with Python keyword, e.g. &gt; &gt; `Tkinter.Toplevel(master, class_='ClassName')` &gt; &gt; * `__double_leading_underscore`: when naming a class attribute, invokes name mangling (inside class `FooBar`, `__boo` becomes `_FooBar__boo`; see below). &gt; &gt; * `__double_leading_and_trailing_underscore__`: "magic" objects or attributes that live in user-controlled namespaces. E.g. __init__, __import__ or __file__. Never invent such names; only use them as documented
Unfortunately, I have to agree with your assessment of wxPython. Even more unfortunately, I became pretty invested in it with a couple projects of mine before realizing it. It all looked pretty good with the examples, but those "gotchas" are a major pain. It feels to me like there are some inconsistencies way deep in the libraries that break stuff which shouldn't break. 
I came here to suggest the same thing. Having your front end written in HTML and JS has serious benefits not the least of which its the fact that you can run your app from anywhere and on anything with no dependencies to worry about.
I think the switch looks better and it's more intuitive as an already established structure for coding.
This. Apart from mobile apps, you can simply use the browser to do most of what you want.
The C doc's are probably the most authoritative as PySide/PyQT4 are not libraries in themselves but a thin to medium thick wrapper/interface around the C library. 
Unfortunately having followed PySide's mailing list for a while now, there doesn't seem to be a concerted effort yet for making PySide QT5 compatible. edit: s/make/making/
 &gt;&gt;&gt; dir(1) ['__abs__', '__add__', '__and__', '__class__', '__cmp__', '__coerce__', '__delattr__', '__div__', '__divmod__', '__doc__', '__float__', '__floordiv__', '__format__', '__getattribute__', '__getnewargs__', '__hash__', '__hex__', '__index__', '__init__', '__int__', '__invert__', '__long__', '__lshift__', '__mod__', '__mul__', '__neg__', '__new__', '__nonzero__', '__oct__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdiv__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'bit_length', 'conjugate', 'denominator', 'imag', 'numerator', 'real'] Do you need that functionality for "most uses" of integers?
reportlab
html/css/js because portability and shit. 
not completely correct. &gt; One git repository for my source code no, as many as you need. 
PyQt for its beauty, easy of use, powerfulness and compactness. 
I know it's fashionable to make fun of VB6 but damn that was easy GUI. I made all sorts of complex and cool GUI applications *(not for IP tracking!)* with it back when I hardly knew anything about programming. I think I was around 10 years old or something. Today, it would still take me longer to make one of those simple GUIs with Python than it took back then with VB6. It's really sad.
I was in a similar situation, then I bought a laptop and I take it with me everywhere. :)
GTK. Because it stays on topic and doesn't have its own sockets and strings.
Erroneous comparison. Most methods above appear frequently in numeric computation. This (enum) is a glorified class factory with class variables and a crap load of special cases whereas type() and zip() in a function would've done the same for the majority of cases where people do: if a == Constants.CONSTANT: etc,. Not convinced this is anything but additional cruft for cruft's sake.
And what about swing with jython or better yet does anyone know if javafx 2.2 can work with jython coz javafx 2.2 has preety good looking GUI
It should be noted that since Mountain Lion, OS X users have to install xquartz to run programs using QT. From Leopard to Lion, X11 was installed by default.
This is the best bet. Assuming you want people to *use* your application, put it on the Web.
You might want to check out [xhtml2pdf](https://github.com/chrisglass/xhtml2pdf).
You should write the lot in QML
I'm sure he didn't mean he wanted it that badly. 
I tend to think Flask, despite being a microframework, is a little heavy for serving static content and (likely) a single dynamic endpoint for message-passing. Using built-in `http.server` (`BaseHTTPServer` in 2.x) saves you that dependency. The other advantage of a web UI is that occasionally JS will provide you with functionality that's otherwise annoying to add (e.g. PNG writing requires PIL or PyPNG, but under JS just write a canvas!)
 &gt;Erroneous comparison. Most methods above appear frequently in numeric computation. Most use if integers is not in "numerical computation." Simple counts dominate.
I like this idea! I'm gonna check this out when I get back to work. Thanks for sharing! 
nope - lots of entries can be handled: return { "option1": 4, "option2": 55, "option3":554, ... "option59":99229 }.get(a) In fact as the number of "switches" increase, the value of my method does too: there is less boilerplate: we don't have 'case' or 'return' written 200 times, That's a saving of 2000 characters. Its also much easier tor read as the comparison value and return value are on the same line, and there is no tab indexing so much easier on the eyes. I also argue that if you have 100 if...elseifs then you are doing life wrong,
Weasyprint is quite good, although it can't be installed in a virtualenv as it depends on a good deal of GNOME code (GDK, cairo, gobject etc) Another drawback is that jpegs don't appear to render properly and everything must be converted to PNG before being included in a PDF generated with Weasyprint. However, the important thing to note is that it is being actively maintained and issues can be resolved.
It's not hard, just a bit limited depending on situation. Here is my script to generate PDF using only Python standard library and pdflatex (MiKTeX): [dpaste](http://dpaste.com/hold/1143353/). Usage: gen.py 10 --output "existing directory"
python-birt project has bindings to BIRT which can generate PDFs based on reports you design in their report designer. The free version of reportlab works okay but there are a lot of quirks to it and a few performance issues in my experience. 
how is a dict unreliable? if a==1: return 5, if a=="b": return 66, is basically if a==1: return 5, if a=="b": return 66, which is just extra boilerplate compared to a dict: look how many times you use 'if...==..return" with 200 if elses - by the time we get to the last item, there have been 100 equality comparisons - but with the dict the answer is jumped straigt to.
This doesn't really have anything to do with the post – it's true no matter how you get a `dict`, whether with a literal or via the class. `dict` objects are unordered hash maps.
"it already exists" != "its a pythonic thing to do"
If you use Firefox, bookmark that page then edit the bookmark. Set q as the keyword and change the URL to: http://pyqt.sourceforge.net/Docs/PyQt4/q%s.html Now you can type "q widget" or "q abstractbutton" into your address bar and get the docs quickly. Firefox calls these keyword searches (yet another feature copied from the Opera browser).
"there's another way to do it" != "there isn't a better way"
This should get you started. from PyQt4.QtCore import * from PyQt4.QtGui import * from PyQt4.QtWebKit import * class Browser(QApplication): def __init__(self): super().__init__([]) self.window = QWidget() self.window.setWindowTitle("Non-tabbed browser") self.urlbar = QLineEdit(self.window) self.urlbar.returnPressed.connect(self.visit) self.web = QWebView(self.window) self.web.urlChanged.connect(self.urlChanged) self.layout = QVBoxLayout(self.window) self.layout.addWidget(self.urlbar) self.layout.addWidget(self.web) self.window.show() self.exec() def visit(self): url = self.urlbar.text() if not url.startswith("http://"): url = "http://" + url self.web.load(QUrl(url)) def urlChanged(self, url): self.urlbar.setText(url.toString()) Browser() http://i.imgur.com/iICyr90.png
Porting the code should be fairly easy. See this comment for an example of just how similar your code can be across toolkits: http://www.reddit.com/r/learnpython/comments/19nwuw/where_to_start_when_you_want_to_learn_how_to_make/c8q7mvm The main difference? If you switch from wxPython, you'll get to remove a lot of those "update the window/layout/whatever to fix what I've just done" calls.
&gt; Enthought provides lots of recipes, but that's not enough to make up for missing documentation and impenetrable organization. I agree; the poorly maintained Sphinx docs turns off many potential users. What has helped me (in descending order of helpfulness): - Private training material (provided during 3-5 day onsite training) - Solved Exercises (there are a LOT) - Slides - Recipes - Mailing list - Source code: and yes the Chaco source is fairly abstract My speculation is Enthought might still see their UI development as a work in progress since currently the heirarchy of packages has now reached Enaml: PyQt/wxPython &gt; Traits &gt; TraitsUI &gt; Chaco &gt; Enaml The Enaml presentation is worth seeing: http://blog.enthought.com/conferences/pygotham-enaml-pygotham-talk/
It's still pretty easy from PyQt4.QtCore import * from PyQt4.QtGui import * app = QApplication([]) win = QWidget() win.setWindowTitle("Tracker") bar = QProgressBar() bar.timerEvent = lambda e: bar.setValue(bar.value() + 1) bar.startTimer(250) layout = QVBoxLayout(win) layout.addWidget(QLabel("Tracking the killer's IP Address")) layout.addWidget(bar) win.show() app.exec() http://i.imgur.com/oSCUQyi.png
I've made a few small GUIs with wx, what sort of things did you run into?
Django. If you're doing a GUI in Python, you probably are trying to do something crossplatform. But crossplatform apps suck. Just make a damn webpage instead. If you want to do an app, use the native language for it (ObjC, C++, C#).
oh man [deleted] was actually clueless to argparse. facepalm.jpg
wait it's not 'free' ?
My point was, since using `dict()` creates the dictionary twice, it can result in them coming out in different arbitrary orders.
I did look at server-sent events. It can be done as REST for updates coming from the client and using SSE to send status updates back to clients/players. But a) not sure how to support SSE in iOS client, b) SSE would double number of open TCP connections per session. 
+1 for PyCharm!
It has been possible to work with wx in py3k for some time. You can get the Phoenix builds from [here](http://wxpython.org/Phoenix/snapshot-builds/).
&gt; Other people swear by OpenVZ, but I don't know anything about it from a systems standpoint In short: it's less overhead, meaning generally lower costs, but has some problems when you need lower level stuff (closer to kernel), e.g. if you want to run an openvpn server in there.
My group has written a number of non-trivial apps (scientific instrumentation applications) based on TraitsUI. Overall, it's an excellent way to create complex desktop apps. It is the case that some GUI layouts are hard to achieve with traitsui so we've needed to accept some minor compromises in this area. However, Enthought have a "next generation" replacement for traitsui called Enaml (Enaml is Not a Markup Language). This is a declarative gui description language. I've been experimenting with this over the last week or so and I'm very impressed. It has a new layout system which is flexible and easy to use. The Enaml code itself has much less "magic" than traitsui and I was able to make a Enaml binding for my own wxPython custom widget just by copying how the other Enaml library widgets did it. Traits-views / Chaco etc interoperate with Enaml seamlessly, as you'd expect. Basically, I think we'll be using Enaml for future apps. Definitely recommend you take a look. There is a good set of slides on this at https://github.com/enthought/pygotham/tree/master/enaml 
And if you bother to learn javascript and websockets, you don't even have to reload the page to do things :)
I second PythonAnywhere. It's awesome, easy to work with, and free
What exactly is this supposed to do?
My take: if you don't find it burdensome to do so consistently, then do so.
http://www.python.org/dev/peps/pep-3115/ &gt; \_\_prepare\_\_ returns a dictionary-like object which is used to store the class member definitions during evaluation of the class body. In other words, the class body is evaluated as a function block (just like it is now), except that the local variables dictionary is replaced by the dictionary returned from \_\_prepare\_\_. This dictionary object can be a regular dictionary or a custom mapping type. I still don't know.
They'd better be **really good** if we've taken this long and not decided for good that we don't need them after all. Edit: I checked out the PEP and I'm satisfied for now.
I guess you don't like `namedtuple` either then.
There's more than that. (Also, a special `IntEnum` type is provided where the values are required to be integers and the type-checking rules are different; in this case, comparisons against integers, and other `IntEnum`s of "different type", can be True.) * You can extract the `.name` or `.value` of a value of the enum type. * You can "construct" instances of the type (which, thanks to what I'm assuming is `__new__` trickery, just looks them up) from the corresponding value; `Color(1)` would give you the `Color.red` value. Similarly, you can look them up by name from a string rather than an identifier (`Color['blue']`). * When the enum class is created, it will automatically check (using what I'm assuming is metaclass trickery - although I didn't actually think it was powerful enough to do this...) that you didn't try to use the same name more than once. It will let you use more than one name for the same value (in this case, looking up the value gives you the first declared name). * You can iterate over the enumerated values "naturally", and also examine the name-value mapping explicitly via the magic name `__members__`. * You can (and should!) compare the values by identity (like `my_color is Color.red`). You will be prevented from doing less-than/greater-than comparisons, even though numeric values are involved. * Pickling works, and you don't lose type information in the process. * You have the option to create enums in two ways: either with syntax like you showed (but inheriting from `Enum`), or with syntax like `namedtuple` uses. 
The problem is that some users simply don't like these things. It depends on the app though. But for certain apps, I'm bothered to hell when people think they have to reinvent graphical user interfaces by doing all the stuff in the browser, breaking default browsing behaviour (such as back/forward buttons destroying your entered data since everything is AJAXy). Also, performance is sometimes an issue.
&gt;This is a very ignorant way of looking at it. you're right. i have no idea what i'm doing. 
i'd suggest not using directly websocket, but a library such as sockjs to allow long lasting connection even in non supported browser or environments. there is plenty of python projects for sockjs servers [1] as for sockjs vs socket.io, here is a comparison by the developer who has the most used socket.io and sockjs libraries in python [2] [1] https://github.com/sockjs/sockjs-client/blob/master/README.md [2] https://groups.google.com/forum/#!msg/sockjs/lgzxVnlth54/NbQKNEAzB5cJ 
Even if they're strings most of the time, you could do something like `{'d-1': 'aabbbcc'}` which isn't possible with `dict`.
It can be pretty clunky for somethings though, for instance if you want a native looking app, or you just don't want everything in the browser. Personally I wish there was a GUI environment similar to a browser but where you don't have to swap languages. I think there's some experimental projects to have webkit but with python instead of JS as a scripting language.
Great library but it can be a pain to install (on OSX anyway if you want to use virtualenv). Also not sure how python3 support is these days. And it's not very pythonic...
I agree it has lots of potential, i think you could build UIs that are as cool as some of the JS webapp stuff but without every leaving Python. And they have a pretty good bundling system which is something really lacking in pyQT (at least on mac, you have to do all kinds of voodoo to successfully bung qt into an app)
I just saw __prepare__ for the first time today in the implementation of an alternative syntax for Enums. ie, so that you can do class Colour(Enum): green blue red darkMango (here: https://news.ycombinator.com/item?id=5691483) I think I'm going to use this. 
If you have a few weekends to kill, I'd suggest veering off in a completely different direction to taste-test the other stuff out there. Go functional with Haskell, low-level with C or stack-based with Factor and just test the waters. I feel a bit trapped by Python since I've been using it for ages and I can't find another language in the same category that I like as much, but sampling tiny bits of completely different languages and communities has helped me branch out and find a path for myself.
It's a good move since you won't "unlearn" Python, so you'll be a "Python expert" anyways (8+ years of experience of Python). Therefore, by branching out to other programming platforms, you will be a Python expert and also a programmer specialized in the platform you choose. That being said, I'm myself a Rubyist, but I've also done some Python, and I can tell you that Ruby and Python are more different than it seems at a first glance. They follow different philosophies, and they take different approaches to main areas (like Object orientation). However, the thing that you have to ask yourself is "where do I want to go ?". If you want to learn a platform which is similar to Python, then Ruby is a good candidate. But as I'm telling you, the most important thing is not which language/platform do you want to learn, but where do you want to go with it.
Just a few remarks: If you are about to be a freelancer, then you must have a plan. Picking a language or application and learning it, is not a plan. You have to have clients by now. If you have them, then you have their needs to meet. I have never met a freelancer, who learned something at home or at school, and sold that knowledge to a client. They always worked in projects on other fields and picked up the new ones. Or worked (semi)employed. Myself included. I thing python is not that established. A python expert sounds not so good, as a java expert. The codebase is not so big, and not so important. After one learns how to program in anything, then learning something is done by doing it. You can learn more about programming, by learning other approaches, as malonedotcc suggested.
As for 1: yes, learning is always good. As for 2: Go is interesting, and for myself, I recently found myself experimenting with Android, instantly remembering that I dislike Java because it's so mind-numbingly boring, so that now I'm picking up Scala. It's a quite elegant language, and as a Python programmer it makes me feel 'welcome', so to speak.
I felt the same way, and recently dove into Go. I find it pretty easy to learn and use, thanks to a couple of nice built-in features (coroutines, channels, interfaces, etc). It's still pretty low level, so you can play around with pointers (for example) and still benefit from "high level" languages features (from the top of my mind, garbage collecting). I feel it's a pretty good compromise bewteen C and Python.
the ones that don't need tweaking across the different machines. Off the top of my head, I can think of the following: .ssh/config , .screenrc .toprc, .config/geany/ .gitconfig, .mozilla/firefox/ .thunderbird/, .purple/ (the mozilla, thunderbird and libpurple directories are just rsync'ed across a server, they don't go into git, as I don't see the point of Version-Controlling them)
IMHO you're thinking about it the wrong way and you're considering entirely inadequate alternatives: You already know a light-weight, high-level, low-performance, dynamic-typing, interpreted scripting/programming language. Why the heck would you learn another one (Ruby or JavaScript). You need to learn a language that **complements** Python, not one that is pretty much redundant. You're not going to gain new insights from another Python-like language, and you're not going to use the language afterwards. Think about it: why the heck would you want to learn Ruby? Both languages have more or less the same usecases, so at the end of the day you just know two tools for exactly the same kind of job. Every new project you're going to start afterwards you'll have to decide which one to use, because both have the same scope. There's absolutely no gain to it. If you want to expand your horizon, listen to /u/malonedotcc , he gave very sound advice on languages that will really teach you new ways of thinking about programming and solving problems. Even though you might not use Haskell, LISP or Forth in the real world afterwards, they'll change the way you'll program forever, in a good way. The same goes for C. It'll teach you to think low-level, and show you the real costs of memory allocation, Pointer-handling etc. It'll allow you to gain a deeper understanding of how to tweak programs because you'll be able to know what'll truly go on on the CPU. Personally, if you want something of more practical use, stick with C (or C++). It's the most basic of languages and will teach you a lot about efficiency, memory and all that other good jazz. And afterwards you'll be able to write your most performance-critical apps/parts of apps in C and use them from Python. Interopability between the two is ridiculously easy. If you're looking for a brain-teaser, I'd go for LISP or Haskell.
Practical: Learn Go. It's fast and managed and well designed. Interesting: Any functional language. Scala, Haskell; hell, lisp. I've "learned" some haskell, but I certainly don't think I've done enough to fully grok how to write naturally with it yet.
Erlang is probably a nice complement to Python. I like to call this the web service mullet. Erlang for web services and Python for a flexible web frontend. 
For a Python developer, you're welcome to take on some of the ideas listed: 1. **C programming.** C is great for low level code and OS programming. Nearly all drivers are written in C, and there's a lot of code out there written in it. CPython has C API, so by writing a simple C module you can get to learn a little bit more about CPython implementation while learning C. By learning C you get to know a lot about the hardware and a bit about the compilers and debuggers. Going low means you will get a better understanding of what is happening under the hood and hopefully means you will debug system level problems faster. 2. **PostgreSQL.** SQL is a great tool to know. PostgreSQL has some pretty awesome features (regexp queries FTW!) and a great security track record. Similarly as above, PostgreSQL has a PL/Python extension, which you can use to get to know both how PostgreSQL internals work and how Python interpreter behaves embedded in PostgreSQL. For an exercise: you can't implement cookie based authentication against Django app in PL/SQL alone. 3. **Scientific python.** Python has excellent tools for scientific programming. I just recently discovered [ipython notebook](http://ipython.org/notebook.html) and it's awesome. There's also [numpy](http://www.numpy.org/) and [scipy](http://www.scipy.org/) and some other pretty nice stuff, say [pattern recognition](http://pypr.sourceforge.net/). But, yes, scientific programming and researching requires a lot of effort for little perceivable result. And there's usually a steep learning curb, meaning you need to put in some serious effort before you even start getting any results. 4. **Android.** Mobile is hot, so there should be bucks. 5. **Learn something valuable and get good at it.** This is something that works mostly for the long run. Statistics, natural language processing, speech recognition, image recognition, etc.
This. Especially the point about trying C if you want something that is likely to be applicable in the real world, but will expand your horizons and approaches to coding. Especially in the realm of pointer management - incredibly frustrating, but unbelievably valuable.
Why?
I would definitely look into Javascript and Node. It's a fairly simple language, but Node's style of event-driven, concurrent-by-default code is really eye opening, especially contrasted with Python.
I find it essential to have a specific itch to scratch (or job to do) for which a new language is a superior fit. For example, I had a need for an Android app tailored to my requirements, so I learned Java. If you can find a relevant domain to code in, that's half the battle. I'm now in a similar situation to you: One of my existing repertoire of Python, C++, C# and Java would be an outstanding choice for any of the problems I currently need to solve. Does there even exist an application domain where (e.g.) Haskell or Clojure are obviously the best choice?
Scala is a good step "up" in abstraction level, without feeling too unfamiliar or impractical. C++11, C or maybe Go for lower-level work. Especially as a python guy you can do useful things in production using extensions, where C++ and C come in handy (glue it together with cython for maximum value). 
It's a shame the documentation is poor. I'd love to use it more but found it hard to figure out how kivy intended us to do more complicated things.
Building a little Webkit browser in gtk is easy-peasy too. You just drop a widget in a frame. And the UI design with Glade is as easy as UI design in Visual Studio.
(Spyder dev here): Thanks for the detailed instructions. Several people have shown interest in installing Spyder in CentOS, so would it be ok if we put them in our wiki? (with proper attribution and a link pointing here of course). About IPython: According to its documentation, it should work with Python 2.6 and 2.7. Are you able to run IPython outside Spyder or not? I say it because it could a problem in our side, something that we need to fix...
Other things being equal, I think branching out into more programming languages once you’re confident with your first one is always a good idea. Even if you don’t use another language as much, learning different programming styles will change the way you think and give you more options in whatever language(s) you do use day to day. If you are using Python for back-end web work, the most obvious complement seems to be JavaScript: 1. The combination lets you can develop complete systems both client- and server-side, which extends your range considerably. 2. In many ways, Python and JavaScript have similar strengths and weaknesses, so this should be a relatively easy transition. 3. Python and JavaScript are different enough to appreciate that when you shift programming languages some things look different but are really the same basic idea underneath, while some things look similar but can have very different implications. 4. There is a potential further advantage if node.js is useful to you on the server-side. If you’re using Python as a general purpose language or simply want a bigger jump, I’d recommend C: 1. C is much closer to the metal than Python, which is an advantage in itself if you want to do many jobs that Python is not equipped to handle: systems programming, high performance work, etc. 2. Because it’s relatively low-level, learning C will force you to consider data structure and algorithm implementations and detailed memory management and concurrency and other widely applicable ideas that are often abstracted away or provided out-of-the-box in the standard library in higher-level languages. This will give you a greater appreciation of what is really happening under the hood in those other languages, and allow you to make better choices generally. 3. C is the foundation on which several other popular languages have been built. It is not necessary to learn C if what you really want is to learn C++ or Java or C# or Objective C, but having familiarity with the "basic case" could be a useful head start compared to coming at these larger, more complicated languages directly from Python. 4. C is the *lingua franca* of programming. Even if you never write a line of actual C code yourself, if you ever want to make two different languages communicate directly on your project, there is a good chance that you will be making one of them act like a C function and the other act like a C function call. Knowing that common language is a widely useful skill in itself. 5. A combination of Python and C fits together rather well, and gives you options for writing most of a project in Python but certain low-level or performance-intensive parts in C, which again increases the range of projects you can take on significantly. If you’re looking at this from a practical, professional development point of view, then I honestly would not recommend anything for your short list except for those two languages, and then I’d choose between them based on whether your interest lies in general programming or web apps. Many other ideas have been suggested in this discussion, and I would certainly encourage you to explore some of them later, but given your stated goals, I don’t think they will offer anything like the same benefit both in their own right and as a foundation for your long-term professional development at this stage.
yeah, I figured it might be.
Just noticed that my 4 main languages - Python/Java/C#/C++ - are the same as yours! In answer to: &gt;Does there even exist an application domain where (e.g.) Haskell or Clojure are obviously the best choice? [Parsec](http://www.haskell.org/haskellwiki/Parsec) (Haskell) is a very nice tool. I believe there are versions of it for various other languages too, however I've never used them, so can't comment and anyway I think Haskell is a natural choice for it. As for what it does, its wiki page says: &gt;Parsec is an industrial strength, monadic parser combinator library for Haskell. It can parse context-sensitive, infinite look-ahead grammars but it performs best on predictive (LL[1]) grammars. Which in English means it's a tool for creating parsers. If you haven't had too much experience with parsing, I'd recommend [this book](http://www.amazon.com/Language-Implementation-Patterns-Domain-Specific-Programming/dp/193435645X), which uses Java for its code samples. 
I have used Qt but I am looking at using Quickly to simplify PyGTK [(see video intro)](http://www.youtube.com/watch?v=ssnlPS2dOqc). It also provides integration with launchpad for packaging, if you want to distribute. I think it would be a great place to start.
Well.. It is a bit complicated to make a web app which comunicates via COM port. :)
I'd say Go and C. Perhaps Rust. Haskell is fun, too.
dude! this would be such a major solution to the "my declarative schema system can't order its members!" problem
Scala programmer here. You just made a VERY good choice. Scala is to Java what C# is to C. It's a nice introduction to functional programming without taking away your procedural tools.
I would also recommend learning Lisp (or something from the family). I just finished up an undergrad A.I. course where we used Racket Scheme. I was familiar with Scheme but had never really used it the way it was intended be used. Learning how to program in Scheme correctly was a really eye opening experience for me and it changed the way I think about programming. If you want a Lisp you can get more practical use out of take a look at Clojure.
I do C# at work and Python for fun, and I was delighted to see something like extension methods in Scala. Even doing a type cast looks beautiful! Scala does it with what C# programmers would call a generic extension method, which makes a lot of sense, even in C#.
I totally agree, with the guys above and below me - C and C++ are great tools to learn. And think about this, almost all the tools "we programmers" use are written in C and C++ - that's a great place to be :)
Id suggest checking out Go and C++14. Go is a fantastically pythonic language, very readable, very efficient and naturally supports massively parallel operations. C++14 supports many features Python has had over C such as lambda functions and for each loops. These two languages are extraordinarily powerful languages and have memory management and low level control which is one of Pythons major drawbacks.
That's true, but if you don't want to alt-install 2.7, then the above works :-)
Yes, by all means please do post it on the wiki. Glad to help. You can either point here or to the StackOverflow question. I'm not sure which sticks around for longer. And you are correct: IPython does work with Python 2.6. However, when starting Spyder with IPython and Python 2.6 installed, you get the following error: [dougthor42@localhost Downloads]$ spyder Traceback (most recent call last): File "/usr/bin/spyder", line 3, in &lt;module&gt; start_app.main() File "/usr/lib/python2.6/site-packages/spyderlib/start_app.py", line 72, in main from spyderlib import spyder File "/usr/lib/python2.6/site-packages/spyderlib/spyder.py", line 100, in &lt;module&gt; from spyderlib.plugins.inspector import ObjectInspector File "/usr/lib/python2.6/site-packages/spyderlib/plugins/inspector.py", line 36, in &lt;module&gt; from spyderlib.widgets.ipython import IPythonControlWidget File "/usr/lib/python2.6/site-packages/spyderlib/widgets/ipython.py", line 12, in &lt;module&gt; from IPython.frontend.qt.console.rich_ipython_widget import RichIPythonWidget File "/usr/lib/python2.6/site-packages/IPython/frontend/qt/console/rich_ipython_widget.py", line 15, in &lt;module&gt; from IPython.external.qt import QtCore, QtGui File "/usr/lib/python2.6/site-packages/IPython/external/qt.py", line 67, in &lt;module&gt; raise ImportError("IPython requires PyQt4 &gt;= 4.7, found %s"%QtCore.PYQT_VERSION_STR) ImportError: IPython requires PyQt4 &gt;= 4.7, found 4.6.2 [dougthor42@localhost Downloads]$ Also, if you try and start Spyder from the Apps-&gt;Programming menu, you don't get any feedback on failure-to-load. The panel item shows up for about 10 seconds and then just disappears. No splash screen, no notification on why it didn't load. Edit 5 days later: holy shit, I just realized that it was IPython sending the error, not Spyder... Man I'm dumb. 
The way the information for the attribute order is recovered relies on implementation specific (sys._getframe) and effectively undocumented (all the code object stuff) APIs.
To throw in a couple more points on the javascript side: As far as application development goes, you're not just limited to browser based development. [Gnome](http://www.reddit.com/r/javascript/comments/17w0z5/javascript_to_become_primary_language_for/) likes it, Windows 8 has HTML5 app support and [node-webkit](https://github.com/rogerwang/node-webkit) could be useful for cross platform client side development. Official and by default server side support with JScript.NET, Rhino and [Nashorn](http://www.infoq.com/news/2012/11/Nashorn-proposal). You could always do this with JPython and IronPython but those are pretty big dependencies to throw in a package or deployment. Since there's so much engineering put into embedding javascript into everything, it's also become a compile target for a [bunch of other languages](https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS#python). Javascript is simple enough and used in enough places that everyone should learn it. That said, you won't get very far without some big libraries and frameworks. Like you say, "simply learning Javascript does not automatically make one a full-stack developer". But javascript gives you a pretty wide set of choices to work with. 
Also I forgot to mention: If you need to make any changes to the instructions for the Wiki to make them better, clearer, or whatnot, feel free to do that too.
Me too. I store my projects on dropbox, ergo they are available on all my machines.
YES! If you have some experience with inline iPython and iPython notebook graphing and are interested in helping with this, shoot me a message. It's not something I've worked with before, but I really want to have full iPython integration. 
There are no general purpose programming languages. Every language has it's own strengths and weaknesses. One part of being a professional programmer is knowing your tools and when to use them. If all you have is a hammer, everything looks like a nail. Learning a new language shouldn't be a major task for a competent programmer. Of course it takes time and effort to really master something, but usually it should be enough to just read through some "Learn language X in N days"-books. Don't stress yourself with studying. Just relax, read, and enjoy. You might not be able to use the new language for anything real, but that's not the point here. The important part is to learn new forms of thinking, new algorithms, data structures, etc.
This is a great post because its easy to say that you should play around with this or that language, but what language would you make serious sacrifices to learn well? My suggestions would be the same that I have chosen for myself because they both complement Python and have long-term professional value. I have ranked them in the order I have learned/am learning them. 1. **Javascript**: Despite the note that Javascript is too similar to Python it's value as a professional skill is huge and I would argue that its a complement in these ways. a) While Python is well-designed and relatively logical, Javascript is quirky and lacking some core features, and doesn't even offer a consistent virtual machine to run on (i.e. the browser). This has taught me new ways of thinking and approaching a language. In addition working in a callback-based environment expands your ways of thinking if you haven't done a ton with Tornado or Twisted. And you can't slot it along Ruby because last time I checked, Ruby doesn't work in the browser. 2. **Java anyway** : Yeah, I don't like it either but again it's professional draw is huge and you need a statically-typed compiled language in there. You also can get into native Android development and there's a ton of interesting projects written in it. Plus you understand why other languages do things a certain way since Java's influence on other languages can't be overstated. (ok, maybe on Reddit they could.) 3. **Erlang** : This language has a huge demand for programmers but few US-based skilled ones. (Erlang is taught as a core language at University in Europe). And of course its very much many things Python is not, which is why there are more than a few projects that combine Python and Erlang. Of these languages, it was also the most fun to learn. It was not my first choice as a functional language, but I got forced into writing some Ejabberd modules and I got hooked. Erlang outranks other functional languages in it's pragmatism and maturity. But it's less theoretically pure and doesn't have as good of a "corporate" user/developer as languages like Scala (Twitter). 4. **C** This is the one I haven't learned but others with a strong computer science background could probably put it higher on the list. Certainly the ultimate way to optimize Python is to rewrite the slow parts in C. The rest has been better covered by other commenters already. Of this more money-grubbing list, its also the least typically in demand, but the jobs that do demand it are usually pretty senior. -1. **PHP** (read through before flaming) I hate PHP. H-a-t-e it. However, I did have to learn it for a project and made the mistake of briefly putting it on my resume. If you are a senior developer and you know PHP you can pretty much write your own ticket. For me, they really couldn't pay me enough to write PHP all day, but the combination of Senior experience and PHP is so rare that you get Magic Unicorn prices to do it. Good luck and please let us know what you chose.
5 is particularly important. It never hurts to have a niche.
&gt; IMHO you're thinking about it the wrong way and you're considering entirely inadequate alternatives: I guess you replied before my edit but just for the record, I'm thinking about it from a job-market point of view. &gt; Think about it: why the heck would you want to learn Ruby? Both languages have more or less the same usecases, so at the end of the day you just know two tools for exactly the same kind of job. Which is pretty much what I wrote as the reason for not having learned Ruby yet. &gt; Every new project you're going to start afterwards you'll have to decide which one to use, because both have the same scope. There's absolutely no gain to it. There's at least one: access to twice as many (or more) job opportunities and projects in the domain I am most familiar with, (backend) Web development. &gt; Personally, if you want something of more practical use, stick with C (or C++). I'm kinda surprised with the several recommendations for C. For the record I had learned C way back in the university 15+ years ago and I appreciate it for its educational value in teaching how a computer works behind the scenes. From a practical point of view though, what options does a C programmer have in 2013 outside niche areas such as operating systems, compilers and embedded software? I honestly don't know what's the job market like for system programming in general but I'd be surprised if it's anywhere close to Web development or application programming. 
Inclusion into a release which should be backwards compatible with previous releases. 'as' was already a keyword used for imports. Adding a new 'enum' keyword (which I assume is what you're suggesting) would be destructive to any code in the wild which is using 'enum' as a variable name.
I indeed replied before your edit. For what it's worth, C is still the most popular and most looked-after programming language on the job market ([source](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html). Although TIOBE might not be 100% accurate, C definitely isn't a "niche" language at all. It's "niche" areas are general purpose application programming (even programs written in other languages often have some of their routines outsourced into DLLs written in C. And the embedded area is of course far from a "niche". But I'm guessing with your background those areas aren't really the kind of thing you'll want to get into. Also, don't forget that there is a quadrillion shitton of legacy code out there written in C that needs to be maintained. From a web dev job perspective: I don't know what the job opportunities are in your area, so if you're only looking to go into web development then that's far enough, although in that case, Java will probably take the cake: since larger backends are often written in it. It also allows you to branch out into both application development and mobile development. Scala would be the young and edgy (and more exciting) alternative that you could try your hands in, but job offers are probably very sparse.
&gt; (Erlang is taught as a core language at University in Europe) Any examples? I'm in Europe and haven't encountered it anywhere.
&gt; Erlang is taught as a core language at University in Europe No it isn't. But I agree it is a great choice.
Thank you will look into that
&gt; Is branching out to other programming platforms and communities a smart (or even necessary) move Most certainly, even at some point if you become a "Python expert" you'll hit up against C programming as you delve deeper into the language internals. My advice is to learn a language that *isn't like Python*. Learn something that will be a stretch for you ( i.e. not a dynamic scripting language like Javascript or Ruby ). Some ideas: Haskell, Erlang, C, Pure, Scala, Go, Rust.
&gt; Python is gaining popularity Good news, python is widely considered mainstream. 
I prefer C/C++, but demand for Java has got to be higher that C/C++
Take the url from that and dump it in a file. Not sure how to format code import simplejson import urllib.request import threading def callReddit(): print('Calling reddit') url = 'http://www.reddit.com/r/seattle/.json' content = urllib.request.urlopen(url).read() loaded = simplejson.loads(content); listOfLinks = loaded['data']['children'] for link in listOfLinks: print('title: '+link['data']['title']+ ' URL: '+ link['data']['url']) t = threading.Timer(20.0, callReddit) t.start() t = threading.Timer(20.0, callReddit) t.start() 
C++14 is a natural extension of C++11 and should have gcc support by 2014. Also, 10 years for C++11? What experience do you have to support that? Because IBM already uses C++11. The software industry is far more agressive than you seem to believe sir.
Don't get me wrong, I'd like to see it adopted I'm just not optimistic. It's already been 2 years, I don't believe Google even allows its employees to use it yet.
if you're just looking for a language that will get you more jobs, learn C# and/or Java. The majority of boring programming jobs out there use one of these two languages (just search dice.com to see). If you're shooting higher, then probably C++ (you can make super amazing amounts of money doing C++ coding) There's also upcoming job markets in Scala and Go (moreso Scala, but learn Java before Scala IMHO). 
It's more responsive because plugins are executed out of process, it has better support for auto completion, a global symbol browser etc.
You want [virtualenv](http://www.virtualenv.org/en/latest/) which is most easily installed and used with [pip-win](https://sites.google.com/site/pydatalog/python/pip-for-windows).
&gt; I don't know how you work in Python for 8 years and never pick up the fundamentals of SQL. I'm curious, how did you jump to this conclusion?
This doesn't automatically make it a bad idea. Have you seen the implementation of namedtuple?
Python on android doesn't require root.
you're welcome. Good luck. 
no
you can try out my class as well: udemy.com/coding-for-entrepreneurs... you don't need to be an entrepreneur to benefit greatly from it. Use promo code "hacker" to get it free. It covers Django in depth (7+ hours)
Any web application requires a backend database. 8 years ago, the nosql options were barely on the radar and most were pet projects, and even 8 years later I can't find direct references but I'm almost certain 95% of lump databases depend on some SQL implementation. Desktop Python isn't a very lucrative field from my job inquiries into it. It is great for scripts (I have several custom ones I use for services I wrote) but you just don't make a career out of it like you do python on webservers. Maybe scipy and numpy, but they are extremely niche and markets infinitesimally smaller than the web frameworks industry.
Use venv and Linux
&gt; your using index would only work with numbers, and all the numbers must be in series. This is not as flexible as a dict, which can have many many types as keys. Also, updating the value at for 84 means physically counting to it - which is too much like hard work, and prone to human error. This is exactly the point I wanted to illustrate. While my example fits your use case yours can solve superset of problems that can be solved using mine. Though, your solution can only solve subset of problems a switch statement could. The example that you gave it isn't really best use case for switch, and you might use the solution you proposed even when switch statement is available. &gt; Your C argument: I could say "but mindfuck uses whitespace as syntax therefore its a good idea". These implementations aren't pythonic, and the argument ad populatum that "C does it" only holds water if you argue C is the template language that we are striving to emulate - which we are not (try from future import braces for a taste). Apologies, I was not clear enough. What I meant to say is that C language has switch statement and also allow this "pythonic" solution, yet majority people still prefer to use switch. The reason for it is that the solution that you proposed cannot be used to solve majority of problems (or the solution would be more complicated) that switch is used for. 
Thanks. I actually signed up under the initial free go-round. I ran into some trouble installing the python MySQL modules, but once I fix it, I plan on doing yours as well. I'm unemployed currently so I have tons of time on my hands to learn Django. 
Are you implying the implementation of namedtuple is not a bad idea? :)
YMMV, but I had a bad experience with Python Launcher. First, it had little to no docs. Then, it got my machine into a weird half-state, where it wasn't setup well for either version of Python. Finally, when I uninstalled, it screwed up my Python installation (Probably as a result of the previous problem) so much that I had to re-install Python... None of these were huge problems, but they were annoying enough that I'd rather not repeat the experience.
Perhaps I will want virtualenv if I can't get an answer to my question. Time will tell...
The title led me to believe this was an /r/ladybonersgw post.
 $ healthy healthy healthy v0.1.1 ----- score: 100 
PyQT is good, you should try it
I'd be a bit of a hypocrite otherwise :)
Google "Kivy", thank me later.
You know, I'm also having pretty good luck with wxPython. I have some pretty sophisticated applications, and they are performing very well. The book on the subject is excellent. Binding them into a windows .exe and using InnoSetup to install the whole thing is also working well. On the whole, wx seems to be what it's supposed to be. Of course, reading the documentation thoroughly and testing meticulously helps. I have each panel of the application in its own class, with a dummy window that loads and tests it in isolation. Then the larger aspects of the application get to aggregate (in sliderwindows, notebooks, etc.) proven application components. I'd do this for any GUI library, but it's nice that the wxPython architecture makes it easy to do. Having said all that, I've done similar things using Ttk, and they turn out pretty well, but I think the wx applications are more performant and they handle complex situations better. Oh, also, wx works very well with multithreaded applications; you can generate events on independent threads that you can catch in the GUI thread and things all just kind of work out. I've been very pleased with this. Sorry to be so verbose. :-)
You can use the pyinstaller, py2exe, etc. programs to package (and something like InnoSetup to install) applications regardless of which GUI library you select to use. A Python application becomes foobar.exe and can be distributed standalone. It's very handy. I personally package and create installers for Python applications written using both Tkinter(Ttk) and wxWidgets. It works fine for either case. I have looked at PyQt; even bought a very nice book for it; but it's just way too big for the applications I ship. Ymmv. In any case, the decision to use (or not use) py2exe is independent of the GUI library you plan to use. Kivy is also very nice, but it's a big jump from Tkinter. If your immediate problem is how to send out your programs, Tkinter + py2exe + InnoSetup should get the job done. ( I can post sample scripts for this approach if you're interested... )
No I think he's saying that a namedtuple is a good idea but the implementation is quite horrible.
Wrong kind of Python.
Close enough.
namedtuple does not rely on any implementation specific APIs. The only thing that happens if sys._getframe isn't present is that namedtuples cannot be pickled. In any case each implementation comes with its own stdlib so introducing implementation specific code is not that big of a problem.
Learn C. Anyone who considers themself a programmer should learn C, then should learn the machine idioms that live underneath it. You fundamentally cannot write performance sensitive code without understanding the machine you're writing code on. Big-O only gets you so far.
Thanks for writing this. Are you aware of the cheesecake score system? http://pycheesecake.org/ Also, personally, I'd make "no description" a -20 or -30 :-) Also, surely it's unfair to deduct the "not updated" penalty if you're querying a specific version which might be very old, like in the Django example?
Are you asking or did you forget to provide a link to something?
risky click
Try C# It's totally different. There's tonnes of demand for it. The windows dev environment can be a killer, especially with the massive outlay for a copy of visual studio, but you can get quite far by investing the in the mono ecosystem from Xamarin for no outlay, and make yourself a plausible mobile application developer; definitely a domain python lags in (kivy is interesting I suppose, but I've not heard of anyone doing useful things with it personally). If you're trying to diversify and remain professionally up to date, *dont* go learning C++; it's fast becoming a niche. Pick up some C# app development, have a play with unity (there's work there, but it's not very well paid), and if you can get yours hands on a copy of visual studio, investigate the MVC web frameworks. All imminently useful and employable skills; and totally different from python. :) (edit; wow, so many other 'learn go' and 'learn c' replies; just a comment; dont. They're both cute languages and certainly worth learning *in general* but have virtually zero employment prospects. If you're looking for a 'weekend hacks' thing, sure, but keep that in mind...) 
PythonAnywhere works very well and it syncs with Dropbox and it hosts personal git repos and it has lots of web goodness set up and ready to roll. *And* it has durable, shareable web consoles (i.e. shell in a web browser) which works places where SSH is firewalled. If SSH isn't firewalled, they support that too. TLDR: PythonAnywhere is awesome. Check it out. 
No, I meant how did you jump to the conclusion that I "never picked up the fundamentals of SQL". For the record I did, probably a bit more than just the fundamentals. 
If you are looking for a free RML implementation, z3c.rml is probably the closest and it is being actively developed. https://pypi.python.org/pypi/z3c.rml 
I was trying it out after hearing about it on this thread. It really does solve most of my problems. Only... I don't see an offline mode. Sometimes I have really abysmal cell data service (I'm in the USA, it's a fact of life here, even in tech areas), but would like to still hack on my projects.
Find a *hard* problem and solve it. The skills and additional tools will then come naturally.
The answer is JavaScript. Sorry.
Quite nice ! But, you see, some packages just don't need updates : a simple tool for example can be pushed without requiring further modifications..
I personally prefer bottle.py. it does all the basics of web framework, even the websockets, and it's a single file you drop in your project folder :)
Since `exec` is a statement in python2, the grammar won't allow it, but in python3 `exec` is just a builtin so `app.exec()` is no longer a syntax error.
Thank you for posting this. I'd be interested to see code comments to help understand what is happening there.
So already_done will probably never be large enough for this to matter... but if you're going to be using a data structure for a 'x in s' query, consider using a set() instead of a list(). The list() 'x in s' lookup is O(n), vs the average case 'x in s' being O(1) for set(). http://wiki.python.org/moin/TimeComplexity
I think %path% is enough. But restarting the computer will reset that setting. Not sure though. If you are lazy I'd use absolute path in cmd.exe, then you don't have to do something special.
I agree, but not completely: if something like healthy is very thorough, it actually might be hard to get a perfect score, but comparatively easy to get a good one.
Is there any specific metadata that you think it should be looking for to make that happen? 
Exactly. I don't think my package `bcoding` will need many more updates in its life. Edit: The only thing I can come up with right now to take this into account is looking for the number of open issues/pull requests on GitHub, bitbucket, ... If that number is greater than 0 and there is no activity, apply the penalty, else don't.
http://kivy.org/planet/ is broken
Thanks a lot, i will definetly go try it, pretty sure i have tried py2exe before and failed because of tkinter but there must be some tutorials out there for that exact problem. I will definetly look at Kivy just didn't know if you could use pyinstaller or py2exe with that.
I write in python 3.2 so i apparantly can't use kivy...
&gt;I don't know how you work in Python for 8 years and never pick up the fundamentals of SQL. This describes me, as well as many I've worked with. Not all Python developers deal with databases. I work in games. I develop tools, pipelines, importers, exporters, translators, UI stuff, and more, all day every day in Python, and have for at least 6 years. I've never needed, nor used a proper database. This is the case for many in the film and games industries.
I totally could have worked in Python for 8 years and never touched web stuff, nor anything else "requiring" a database, certainly not an SQL-based one. I didn't happen to, but it's quite easy to imagine.
Prepareable looks for `__new__` in the class of which it is the metaclass and replaces it with preparing_contructor. preparing_constructor gets the frame in which the class (of which Prepareable is a metaclass) is defined and within that frame it looks for the code object that describes the class body. That code object contains all names that are used within it, ordered by appearance in the class body. That information is then used to sort the attributes and add them to the namespace returned by `__prepare__`, then the wrapped constructor is called and the result returned. The code does a little bit more to handle a few cases such as there being no `__new__` to replace, or no `__prepare__` being defined but that's not really important. If you don't know what frames and code objects are I suggest taking a look at the documentation which has some information on them and playing around with them in the repl. Metaclasses should also be explained in the docs but basically a metaclass is a class whose instances are classes, so by giving a class a metaclass you can define it's behaviour. As metaclasses are really just classes, they can have metaclasses as well, which you can see in the code, where Prepareable is a metaclass of FooMeta, and FooMeta is a metaclass of Foo.
Shame, they have a grant for 3.x support so maybe soon!
KDevelop has a good Python plugin. There are still some wrinkles, e.g. it doesn't realize that `from . import name` indeed introduces `name` into the scope (so it puts yellow squiggly lines below each occurrence) But for all I know it's very good. It also has a debugger interface. (That one is atm just for Python 2 unfortunately)
That's good practice anyway.
This is a good idea. I started coding it for Github, but then thought about all the different repo sites the code could be stored in and got a little overwhelmed. If anyone would like to help out with this I'd appreciate it!
Just don't use spaces ;)
I think this is true. I wrote healthy in the hopes that it would start a discussion on what the community thinks a healthy package is, and it can grow accordingly.
These are good ideas. Feedback like this will only make healthy better. Maybe the not updated penalty can not be applied if the package is old, as you said.
Not concrete, as in it will never change...it should change, based on what the community thinks. I was just looking for a word that suggested it was actually written down and implemented, rather than in everyone's head and assumed.
If I had to go from fulltime employment to freelancing/consulting (and assuming that I'm not a data guru or perf-tied guy), I'll: - improve my web capabilities: everything is now, at some point, web-based, so - Javascript and some of its unavoidable library should be learned (ex: jQuery), - REST concepts should be fully understand, - try to be fluent in both Ruby and Python. Yes, a lots of website are Rails based, this is not so hard to learn and there are subtle differences between python and ruby that are nice to understand, - learn about functional programming, Haskell is tough to learn but underlying concepts are astonishing and will give you new insight about programming, - lots of comments told you to learn C, I'm agree in a sense that this is a low level language where you can learn more about how programs work (memory management/allocation, ...), but if I were you, I'd rather capitalize on my high-level languages experiences. Finally, and this is not about languages, I believe that every developer should more than familiar with: - TDD based programming and Continuous Integration, - Git (or other DVCS), - at least one cloud platform, - some key-value store (MongoDB, CouchDB, ...) (and DDAAS services). Trust me, fully use some services may require more time than learning a programming language! [EDIT]: I miss mobile engineering, I do believe that apps are sometimes unecessary if you're providing good responsive web designs.
Yes, but still the use case is big enough so that there's an optimization for only-string-dicts in Python's dict implementation.
I see. How about a 'simple' formula? Anyway I like the qualifications you have there, does it come from a PEP or something like that?
That argument is pretty useless: obviously someone uses `dict(...)` in order to create dicts with keys that he knows are valid Python identifiers, or he'd not use `dict(...)`.
Congrats on the new release. Never used Kivy, but only because I'm a python noob.
Not particularly shorter or faster than the if/elif/elif/else you would normally use ... Also, you need to use thread locals for this to work with threads. It would be a nightmare to support on all the platforms (stackless, gevent etc) imho ...
No better time than the present! It's pretty easy to get started.
I'd rather use this pattern: import sys def some_work(case): print "some work with: ", case def qool_work(case): print "qool work with", case def my_default_work(case): print "some work done here with: ", case cases = { 1: some_work, 2: some_work, 3: qool_work, } if __name__ == '__main__': try: case = int(sys.argv[1]) except IndexError: case = None if case in cases: cases[case](case) else: my_default_work(case)
Sure. It would be useful if you would do something like the following first: from .issue_url_handlers import handlers def get_issue_number(possible_issue_tracker_urls): for url in possible_issue_tracker_urls: for handler in handlers: issues = handler(url) if issues is not None: return issues return None A handler just has to return None if it can't handle a URL, else the issue number. If that function returns a number &gt; 0, apply the penalty. That way we can just add providers of the functionality via adding them to the handlers list. You could also apply a different penalty if no issue tracker can be found (returned None), but that would only be fair once we support a reasonable number of trackers.
He was talking in reference to hruske's suggestions. I read that as implying you DID pick up the fundamentals, at least, and hruske's suggestion might not have been a good one. I do however think it was worth a mention.
To be honest as a python n00b I wish id started with kivy. Python on mac is a crazy world of venv and paths and other things that dont make sense or work if you are not on linux, while kivy makes it all nice.
Why do kivy reinvents Python packaging with Garden? Having a centralized list of Kivy plugin makes sense, but why "install, update, uninstall"? 
Kivy is something I'm not ready to commit to using, but something I really root for. I would like to use it some day.
We don't reinvents python packaging at all. We don't ask you to write a setup.py or anything like that. It's just a wrapper to download a zip of the repo, unzip, and place it in the right directory. If the user provide a setup.py, and/or upload it to pypi, you could also use standard tool for managing it. And if you don't like the tool, feel free to install it by hand, or with pip, if the user did the work.
Thanks for reporting, it's fixed!
Indeed. I don't think I'd use it either. *sstack* would need to be thread local; and yes, gevent would cause problems. But I love the way Python gives you scope to abuse the language.
The Yeco link is dead http://kivy.org/#gallery
 if case in cases: cases[case](case) Malkovich Malkovich.... Malkovich, Malkovich, Maaalkovich. Malkovich! &amp;#3232;_&amp;#3232; 
I had not seen pycheesecake. It seems like it is a little behind the times: it's on Trac and the GitHub clone of it is empty: https://github.com/ericholscher/cheesecake It also doesn't seem to be pip-installable. We can probably use this as a guide for suggestions.
maybe not important but the site is very broken on mobile browsers
From experience: PyGTK won't help you there. It's tied to a interface -- and so seems Kivy, although I just glanced through the documentation. None of them seem to export the interface to a HTML/JS/CSS. I'd suggest this: First, take a look at [Bootstrap](http://twitter.github.io/bootstrap/). It offers a few HTML widgets ready to use. Also, [jQueryUI](http://jqueryui.com/) have a Draggable object that's pretty easy to use. Then you'll need a server side; personal option, I'd use [Flask](http://flask.pocoo.org/), although [Bottle](http://bottlepy.org/docs/dev/) seems easier and more explicit in some points.
Yup. Most of your UI stuff is going to be JavaScript, traditionally you'll just be using Python to generate your HTML. To do that, you can go with a full stack framework like Django, which has a great community and excels with rapid development, or micro frameworks like CherryPy, Flask, or Bottle, which give you more freedom to choose your own ORM/templating/form libraries, but also typically mean a bit more overhead in getting things up and running. I tend to go the route where I have more freedom, and typically work with CherryPy using libraries like SQLAlchemy, Mako, and WTForms, but that's very much a personal preference. Once you've actually got your tools in place to generate your HTML, Bootstrap's a nice JavaScript/CSS library to get up and running quickly, and jQueryUI has some very useful pieces. They are in no way mutually exclusive, you'll very likely find yourself using both tools to accomplish different things
PyGTK, Kivy and the like are for native apps- you won't be able to get these running in a web browser. If you want an interactive interface in a browser, your only option is JavaScript that runs on the client side. You can use Python for the back-end on the server.. or any language you want, really. (But Python is a pretty good choice :p) It's hard to give more guidance without knowing exactly what it is that you want to do- if all that matters to you is the GUI and you don't need data persistence, user logins or anything like that, then you may be better off serving static webpages from a bog-standard web server. Web dev is a different beast from desktop/mobile apps because the client-side environment is so limited. Take Google Docs, for example- your standard desktop office apps can open and save files from your computer without depending on Internet access. In Docs, the editors are implemented using JavaScript - as they require a complex client-side interface - but files are stored on the Google servers, and you can't change that. On the other side of the spectrum are apps/sites which don't use JS at all (or simply use it for minimal enhancements) and do all the processing on the server side. You click something, your browser sends a request to the server, the server returns a new webpage reflecting the changes. So.. yeah. If you want to mess around with Python web dev, get [Flask](http://flask.pocoo.org/), read through the docs (which are extremely good IMO) and play around with it and see what you can do. There are other web frameworks but I think Flask strikes a sweet spot between being simple and approachable and also scaling up for larger apps. I'm currently developing my first Python web app (but not my first Python project - I've been using the language for years) using Flask, and I'm very happy with it. Good luck!
nice. i like creative uses of context managers
Terribly ironic, for sure.
This is an amazing project. I'm going to enjoy digging around in your code. Thanks so much for sharing this.
We do mobile apps, not mobile website :) We are already under website redesign, so it should be better when it will be done.
Do you guys have any plans on implementing a fully functional advanced UI toolkit/widgets offered by frameworks/libs like Qt?
Well, shit. I wish I had more than one upvote to give. Thank you! I'm now going to go in to work and fix all the many places I know I've used "is" for equality checking.
For those who may not know, instead of list.sort(), you can use sorted(list). EDIT: Fixed brainfart. Thanks Lattyware!
This is what pyobjus will give to you: a wrapper to access any Objective C API from Python. But it's not currently working very well. We'll see after the GSOC, if the proposal from the student is selected and accepted :) Our goal is to have the same thing as pyjnius for Java.
How useful is Kivy for non-game apps on iOS? Sounds like it'd be fairly limited in terms of using native functionality. Also, would it be possible to run Kivy Python scripts directly on a device using a Python interpreter (many are in the Appstore)?
You could create a folder of symlinks and use `add2virtualenv` from [**virtualenvwrapper**](http://virtualenvwrapper.readthedocs.org) and/or a **.pth** configuration file. From http://docs.python.org/2/library/site.html : &gt; A path configuration file is a file whose name has the form `name.pth` and exists in one of the four directories mentioned above; its contents are additional items (one per line) to be added to `sys.path`. Non-existing items are never added to `sys.path`, and no check is made that the item refers to a directory rather than a file. No item is added to `sys.path` more than once. Blank lines and lines beginning with # are skipped. Lines starting with import (followed by space or tab) are executed. In addition to [`add2virtualenv`](http://virtualenvwrapper.readthedocs.org/en/latest/command_ref.html#add2virtualenv), there's also a [`toggleglobalsitepackages`](http://virtualenvwrapper.readthedocs.org/en/latest/command_ref.html#toggleglobalsitepackages) command. type add2virtualenv type toggleglobalsitepackages
I'm constantly doing this and the easiest way I've found is: python script.py # python 2.7 C:\Python32\python.exe script.py # python 3.2 It's faster and I don't have to mess around with virtual environments. Set your preferred python to "python". I'd prefer to use 2.7 only, but such is the life of an open-source developer.
The classic is the mutable default argument. Say you define this function: def test(x=[]): x.append(1) return x You might expect to get `[1]` each time, but you will actually get `[1]`, then `[1, 1]`, then `[1, 1, 1]`, etc... This is because that default argument is not evaluated each time the function is run, but once when the function is defined. This means that the default value is a specific list, which is empty the first time, but from then can be modified. This tends to trip up newbies, but makes a lot of sense when you get used to it. The solution is pretty simple: def test(x=None): if x is None: x = [] x.append(1) return x Another common one is the belief that something like this should work: x = [1, 2, 3] for number in x: number += 1 assert(x == [2, 3, 4]) This, naturally, fails as `number` is just a reference to the item. As `int`s are immutable, `+=` just assigns a new value to the name, and so the value in the list is unchanged. Unfortunately, most people just do what they might in another language and loop by index (which should never be done in Python). The correct answer is to create a new list. The best method is to use a [list comprehension](http://www.youtube.com/watch?v=pShL9DCSIUw) to do so: [number+1 for number in x]
You're right, I didn't *facepalm*. Thanks.
&gt; If you want to check if two objects are equivalent, you must always use the == operator. makes sense to me
Wonderful! I've just started to learn Kivy. It's good to know it's going strong.
But "is" is what you want for booleans. I find people baffled by: &gt;&gt;&gt; 0 == False True &gt;&gt;&gt; 1 == True True &gt;&gt;&gt; 2 == True # WTF? False 
The number one mistake posted in this subreddit, *by far*, is this: if item == "apple" or "banana": 
I always wondered why this was the case... I mean, it isn't like it's hard for python to store an unevaluated expression. That's what a function is! So why did they choose to make the default args evaluate right away?
Absolutely. Can't tell you how many times I've written code like this. A Pythonic alternative (that actually works): if item in ("apple", "banana"): # do bla 
well I'll be damned. That 2 case is a true WTF. Especially because if 2: print 'hi' prints 'hi', so it certainly evaluates to True. Although "2 is True" is False as well, so I don't think you really want 'is' either
False. &gt;&gt;&gt; 1 == True True &gt;&gt;&gt; 1 is True False
It would be nice to tell people who don't know what Kivy is.
That first one got me once when I was defining a recursive function.
Overhead - it would make function definitions more complicated (they now have to store the expression), introspection impossible (at the moment, you can inspect on the function, pull out the arguments and their default values - if the default w, and calls less efficient (each time the function is run, the default argument would have to be re-evaluated). Not to mention that it would produce even weirder bugs. If you did `def test(x=blah.test()):`, then delete `blah`, calling `test()` would cause an error. I think this also shows how unintuitive it would be - when you see a function call in a situation like that, you expect it to be evaluated. Not evaluating the default argument straight away would be some magic that would be really weird in more cases than the current situation. Not to mention mutable default arguments are actually pretty rare. Put that all together, and given the work around (using a sentinel value, usually `None`, then constructing the mutable variable at the start of the function) is so simple, it makes the most sense to do it the way Python does. Edit: Just to clarify about inspection: &gt;&gt;&gt; def test(x=1): ... pass ... &gt;&gt;&gt; import inspect &gt;&gt;&gt; inspect.signature(test).parameters["x"].default 1 Now imagine functions have default expressions instead of default values. The only way to give that to us is as a compiled bytecode object. That is essentially useless for inspection (you could execute it to get the value, but that could cause side-effects).
Actually 2 is True being False is *exactly* what you want. 2 is not the same thing as True, its just truthy. Python strongly wants you to do non-comparison if statements: if x: # works if x is nonzero num, nonempty string, list, dict, etc print "Do stuff" But if you want to do something if and only if x really contains the boolean value True then if x is True: print "Do stuff" Is what you want.
One should only use `is` to check the IDs of two objects. The ID of an object is returned by `id(obj)`, and for now is the memory address. Python only keeps track of one `True`, `False`, and `None`. As such is true, the following only evaluate to true because they each refer to one object twice. &gt;&gt;&gt; x = True &gt;&gt;&gt; x is True True &gt;&gt;&gt; y = False &gt;&gt;&gt; y is False True &gt;&gt;&gt; z = None &gt;&gt;&gt; z is None True &gt;&gt;&gt; id(z) # your value here will vary 505555964 &gt;&gt;&gt; id(None) # but this one will match 505555964 Now, `1 == True` because Python will auto-convert True and False to 1 and 0 respectively, so ~~the~~ then your last line is the same as &gt;&gt;&gt; 2 == 1 False Finally, while it's not entirely straight forward, the reason code under `if 2:` will execute is that 2 is mapped to the boolean int space and so is evaluated as 1, which maps to true. **EDIT:** I accidentally left out some words in the `1 == True` explanation.
That's because `True` and `False` are just `1` and `0` with fancy `repr()`s.
`is` checks identity. (Provided by the implementation.) `==` checks equality. (Provided by `__eq__()`.) `if` statements (alongside `while` loops, the ternary operator, etc...) evaluate `bool(x)`, which gives *thruthiness*. (Provided by `__bool__()` in 3.x, and `__nonzero__()` in 2.x). There is no WTF here as different operations are being performed. The issue is that people think of `if` statements as being an implicit `if condition is True:`, when in fact its `if bool(condition) is True:`.
You don't want "is" either. &gt;&gt;&gt; 2 == True False &gt;&gt;&gt; 2 is True False &gt;&gt;&gt; bool(2) == True True &gt;&gt;&gt; if 2: True ... True &gt;&gt;&gt; True if 2 else False True The "truthiness" of 2 is only reflected when you are casting the 2 to a boolean. In the case of comparison operators, the boolean (True) will get cast up to an integer, and will compare as 1. Logical operators, or statements that expect a boolean value, will implicitly cast the integer (2) to a boolean.
why is 1 equal to True and not 2? (Neither should *really* be equal to True.) Another poster said because True and False are just the integers 1 and 0 under the hood, which is likely the correct answer. But when I wear my Python hat, I don't care about that, and it is unlikely to be the case in anything by CPython anyway. The convention in programming languages is 0 is False and nonzero is True. If you allow 1==True you need to allow 2==True as well. Anything else is WTF territory.
I have yet to find an explanation as to why. I understand None/True/False are singletons. but that just means there literally is no difference between *==* and *is* in this case.
except that this is bullocks.
Because `True` and `False` are `1` and `0` in Python. This was a decision made way back in the roots of the language - Python originally didn't even have a boolean type - `1` and `0` were used directly (hence the use of the term `__nonzero__()` in 2.x rather than the expected `__bool__()`). When they were added, they were added as a subclass of `int` to ease the conversion: &gt;&gt;&gt; inspect.getmro(bool) (&lt;class 'bool'&gt;, &lt;class 'int'&gt;, &lt;class 'object'&gt;) Mainly this stuff was done as it was considered useful to have boolean values act as integers (mainly for backwards-compatibility). [PEP-285](http://www.python.org/dev/peps/pep-0285/) contains the rationale: &gt; &gt; 4) Should we strive to eliminate non-Boolean operations on bools &gt; in the future, through suitable warnings, so that for example &gt; True+1 would eventually (in Python 3000) be illegal? &gt; &gt; =&gt; No. &gt; &gt; There's a small but vocal minority that would prefer to see &gt; "textbook" bools that don't support arithmetic operations at &gt; all, but most reviewers agree with me that bools should always &gt; allow arithmetic operations. It's not the perfect setup for bools, admittedly, but [practicality beats purity](http://www.python.org/dev/peps/pep-0020/). In general, this isn't really a problem, hence the reason it wasn't modified for 3.x.
I have a personal crusade against sys.path.append, because it does unexpected things. Here's an example, though it takes some setting up. Make a directory "pkg"; touch the file `__init__.py` inside it. Now create a file pkg/mymod.py. Inside it put the following code: class MyException(Exception): pass Now fire up your python shell: &gt;&gt;&gt; import sys,os &gt;&gt;&gt; sys.path.append(os.path.join(os.getcwd(),'pkg')) &gt;&gt;&gt; import mymod &gt;&gt;&gt; import pkg.mymod &gt;&gt;&gt; mymod.MyException is pkg.mymod.MyException False "mymod" and "pkg.mymod" have both imported the same file, but they are different modules. This is particularly insidious in the case of exceptions, because your except clause matches on "is". In other words: &gt;&gt;&gt; try: ... raise pkg.mymod.MyException ... except mymod.MyException, e: ... print "Crisis averted!" ... Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; pkg.mymod.MyException 
Here's another nice one: ll = [lambda: n for n in range(5)] print [l() for l in ll] You'd hope this would print `[0, 1, 2, 3, 4]` but in fact the result is `[4, 4, 4, 4, 4]`. Annoying, but inevitable once you understand that the `n` in `lambda: n` is being reused. Indeed: n = 3 print [l() for l in ll] prints `[3, 3, 3, 3, 3]`. Ho hum. The simplest (hacky) fix is to define ll2 = [lambda n=n: n for n in range(5)]
There definitely is a difference - equality is defined by `__eq__()` on an object, so an object could, if it decided to, tell you it was equal to `True`. Using `is` ensures you only get a positive response if it *actually* is `True`, which filters out weird bugs in rare cases. Obviously, it depends on whether or not an object acting like `True` is valid in your case. &gt;&gt;&gt; class Test: ... def __eq__(self, other): ... return True ... &gt;&gt;&gt; Test() == True True &gt;&gt;&gt; Test() is True False
Commentting as on my phone and need this for later reading. Awesome post! 
 &gt;&gt;&gt; False == 0 True
&gt; This happens because the CPython implementation caches small integers and strings, so the underlying objects really are the same, sometimes. Strings are not cached, they're interned. That's slightly different: [you can ask for a string to be interned](http://docs.python.org/2/library/functions.html#intern) (interning is dynamic) (note: don't intern stuff, there's almost never a reason to manually intern a string)
 issubclass(bool, int) # True `bool`s are `int`s.
Though this can lead do an other possible misconception: if item in ("apple"): which is the same thing as if item in "apple" and will "work" (`"apple"` will match), but may also yield false positives and will be... less than efficient.
* A tuple is not created by the parens but by the comma. Except for the empty tuple. `()` is a tuple, `1,` is a tuple, `1, 2` is a tuple, `1, 2,` is the same tuple. Aside from the empty one, parens are only there for grouping and visual clarity. * "tuple unpacking" doesn't unpack tuples, it unpacks iterables. `a, b, c = xrange(3)` is perfectly cromulent * Iterating on a dict directly will only iterate on its *keys*, whereas iterating on a list or set will iterate on its *values* (not that you could iterate on a set's indexes) 
Thanks!
It comes up on StackOverflow a lot as well.
This one just got me yesterday, if I hadn't known about this I can't imagine how much time I would have lost trying to debug it. 
Is there a use case for which sys.path.append is the correct solution?
... Assuming you also remember that the parentheses also *do* make the tuple, if it's empty.
~~It's also important to note that "x in y" only performs identity testing, not value testing. For instance:~~ ~~y = (H(13), H(16))~~ ~~x = H(13)~~ ~~assert x in y # This fails without __new__ wizardry.~~ EDIT: I stand corrected. I recall this having been a problem in a previous project, but it's entirely possibe I got it mixed up. 
This is just flat-out false. `in` does equality tests (by default, naturally, one can implement `__contains__()` however one wants). &gt;&gt;&gt; 1 in (True, ) True &gt;&gt;&gt; 1 is True False Edit: To be even more clear: &gt;&gt;&gt; class Test: ... def __eq__(self, other): ... print("Equality check between {!r} and {!r}.".format(self, other)) ... return True ... &gt;&gt;&gt; Test() in (1, ) Equality check between &lt;__main__.Test object at 0x10a49db90&gt; and 1. True
Glad to see the rationale behind #4 there, thanks.
One of the actual benefits of the old default argument gotcha is that you can use it to define functions in a loop.
There's some useful cases where interning stuff can save you :)
About the list.sort, in ruby method doing jobs in place are clearly identified (often by a !) in their names, python does not and it yields to beginner's pitfalls. Moreover, I saw also this idiocy one time (not really a python misconception, but a more general misunderstanding of programming): bool('True') # --&gt; Hooray: it yields True! bool('False') # --&gt; Yes, it's also True ;) Last, take care, lots of library overrides the equality operator!
Hmm, I see what you mean: &gt;&gt;&gt; True * 4 4 
I'm really new to Python but for the second example couldn't you use: x = map(lambda x:x+1,x) and not have to create a new list? For large lists I'd guess it would be inefficient to copy it every time you want to change it. 
|`is`|True|False|0|1|2| |:-:|:-----:|:---:|:-:|:-:|:-:| |True|True|False|False|False|False| |False|False|True|False|False|False| |0|False|False|True|False|False| |1|False|False|False|True|False| |2|False|False|False|False|True| | `==`|True|False|0|1|2| |:-:|:-----:|:---:|:-:|:-:|:-:| |True|True|False|False|True|False| |False|False|True|True|False|False| |0|False|True|True|False|False| |1|True|False|False|True|False| |2|False|False|False|False|True| I think Lattyware's comment explains the WTF in the second table.
No. I can't find it, but I believe somewhere in the documentation, it says to not use `is` for Boolean values.
The only thing that really burnt me was that importing a package named `parent` does not immediately give you access to its sub-package `parent.child`. You have to explicitly import `parent.child`.
Great to hear kivy will work on the Android emulator now!
Why would you want to compare equality with `True` or `False` though? The most common case I can think of is beginner code and for non-beginner code the only cases I can think of are very advanced indeed (e.g., pickling).
&gt;Unfortunately, most people just do what they might in another language and loop by index (which should never be done in Python). How would you then go about creating a "sliding window" of data in a list/tuple? For example x = [1,2,3,4,5,6,7] Loop through this list, first looking at position 0 and 1, next looking at 1 and two, etc... 
So the parentheses can be left out in an assignment... item = "apple", But not in the case of a conditional... if item in "apple",: Which would be a SyntaxError.
Here's something that troubled me last week: my_gen = (i for i in range(10)) print(3 in my_gen) # prints 'True' print(7 in my_gen) # prints 'True' print(2 in my_gen) # prints 'False' - WTF??? The problem: I thought that using 'in' was exactly like: for number in my_gen: # check number is present But that's not the case at all: Unlike the for loop (which 'restarts' the generator), using 'in' will consume the generator items, and will freeze at the found item. Additional 'in' checks will continue from the previous found item - not from the first item in the generator. If the generator is fully consumed, all 'in' checks would return False. I've fixed this by replacing the gexexp with a listcomp. I felt both dumber and smarter having fixed this bug. ***Edit: hell, now I feel MUCH dumber. Using a for loop restarts nothing (checked on Py3). Once the generator is consumed, that's it.***
Definitely a lot of code where I work that looks like `something = something == 'True'` when dealing with posted data.
Do you mean something like this? &gt;&gt;&gt; my_list = [1, 2, 3, 4, 5] &gt;&gt;&gt; for a, b in zip(my_list, my_list[1:]): print(a, b) 1 2 2 3 3 4 4 5
On a slightly related note, chained comparison expressions like `5 &lt; x &lt; 15` will work fine (that is, be true if x is between 5 and 15). Unlike in other common languages, you're not required to do `5 &lt; x and x &lt; 15`. 
It's still there, it's just more subtle than in ruby. In Python, in-place operations are named using their verb: list.sort() list.reverse() As where ones that are not in-place use the past participle: sorted() reversed() Generally, in-place alterations are methods on objects, while others are built-in functions (which makes sense again, as an in-place operation is natural to a specific data structure, as where the built-in functions are applicable to any iterable).
&gt;so the underlying objects really are the same, sometimes. Why did they make it work like this. It seems like really bad behaviour and everywhere else python is not optimized for performance.
Or have the package import `child` in `__init__.py` - but yes, this isn't a standard practice. On the other hand, it makes sense from a performance perspective - `import`s are not *free* in Python like they are in, say, Java.
 &gt;&gt;&gt; True + True 2 
As a note, the `for` loop does no such *restarting* of generators. Generators can't be restarted. Once an item from an iterable is consumed, it is gone forever. The reason you may feel that it's restarted, is because `for` loops automatically call `iter()` on the given object. This means for `list`s, for example, each time you use a `for` loop a new iterator is used, meaning it appears to be *restarted*.
I'd just use `if item in ['apple']`. Lists for lists and tuples only if the position has semantiv meaning.
I put the wrong link =( http://blog.appscale.com/2013/5/AppScale-170-Released
Not sure exactly what you mean, but you can use a different for loops depending on what you want. Ex: x=[1,2,3] for n in x: Print(x) OR for n in range(Len(x)): Print(x[n]) The second option is good for replacing values. Ex: for n in range(len(x)): x[n] +=1
It improves performance by a reasonable amount in an extremely common use case, and shouldn't really cause any problems at all. The only bad thing is it makes one potential error slightly harder to spot. The trade-off is worthwhile.
Thanks so much! Docs are hugely improved!
Yeah i kinda wish they were just regular python packages :/
I don't know of *any* programming language where logical disjunction works that way - so this is really just a general (and quite natural) newbie programmer error, nothing python specific.
You can do def test(x=None): if x is None: x = [] a little more elegantly, without an if check as: def test(x=None): x = x or [] if x is None it's set as [], otherwise left as is.
Well, in the list case, it's pretty arbitrary which one to use, since the argument will be expected to be iterable, and most iterables are only evaluated to false if empty. So replacing the empty passed list with a new empty list will do nothing in most cases.
Yup, I explain them all in the video I linked to in the great-grandparent comment. List comprehensions and their cousins are some of the most useful tools in Python.
Doesn't really answer my question. I have reasons for using idle including not my computer (work pc) and the tutorial i'm going through is specifically built for idle. I appreciate your opinion on whats good and what isn't, and that will affect my laptop, but it doesn't help me solve my current issue. Also, would it not be better to learn how to fix this so that i better understand how to fix errors in the future?
&gt;one potential error slightly harder to spot. Seems like much more than slightly. Potentially you could have code that works randomly in testing every time and then only fails in production. I would also argue that it does not help you much with performance either. The caching is only some times going to work. Your code should not rely on that. Instead the programmer should avoid making excessive copies of the same string. 
I never understood why 'is' was preferred here before - thank you for explaining it so clearly!
Or perhaps: cases.get(case, my_default_work)(case)
before a lot of these seemed like weird, esoteric gotchas. then i coded a couple of extensions in raw C and saw the underlying structures, and they make sense to me. (then i learned Cython etc ... and haven't looked back.) 
That's not a problem with `sys.path.append`. That's just a problem with poor python path management. You'd get the same thing if you defined `export PYTHONPATH=/path/to:/path/to/pkg` in your environment. 
and i'm starting to wonder if you even read my post, because i clearly said that 2.7 is working fine and its 3.3 thats giving me issues
In general, however, you just want to be doing `if x:`. It's a super-rare case you actually want to check `if x is True:`. Checking against `None` is a pretty common case where it's important to use `is`, as it is used as a sentinel value so often.
Yeah I can't think of a case where if x wouldn't be more preferable, unless I was dealing with disgusting code that returned either a boolean or a value. In which case, refactor :p
That difference isn't very subtle, honestly.
Interned strings are basically cached. It's a cache with an API.
In practice, though, comparing anything directly to `True` or `False` (whether it is with `is` or with `==`) generally means you're doing something wrong. You probably know that, but others reading your comment might not.
Yeah, it's a very old project. We even had its scores integrated into PyPI for a while but ran into issues so had to remove it.
There are a few other cases I can think of. For example, in very rare cases, you might need to do different things if a value is `0` and if it is `False`, for example. In that case, the simplest solution is to check if the value `is False`. Of course, you should be able to avoid that situation most of the time, but it is a possibility.
Although not related to Python, you mentioned that you have experience in Java. In that case Google Web Toolkit is worth looking at since it does provide a way to program in Java and produce a fully Ajax asynchronous website powered by Javascript. All the libraries of HTML 5 are supported, either directly in GWT or through integration of native Javascript. The GUI development is similar to Swing, while it has deep integration with App Engine which provides both a hosting site and a database backend.
So just to be sure, in py3, this will fail?: x = range(5) for i in range(3): for j in x: print "This gets printed 15 times"
For some sort of serialisation, perhaps. But I can't think of another use case, and you generally shouldn't need to write your own serialisation code, especially not in Python. (Depending on the kind of data and what is going to happen with it, either pickle or json should do the trick.) EDIT: I thought your reply was to a different reply I wrote. Anyway, this still falls under use case #2, because `bool` is a "dualton", so there is only one `False` object.
Simply changing it to x = [] if x is None else x Would be how I would usually write something like this. 
Yeah. Either use `x = list(range(5))` or use `itertools.tee` if the range could get rather large and you don't want to have it in memory anyway. (Note that this is exactly the same as in Python 2.\*, except with `list(range(5))` instead of `range(5)` and `range(5)` instead of `xrange(5)`.) EDIT: woah, I was wrong. I didn't know `range` was an iterable in Python 3 rather than an iterator. Thank you, XNormal.
And rightfully so. Is if 2 in 1, 2, 3: equivalent to: if 2 in (1, 2, 3) or if ((2 in 1), 2, 3):
This has nothing to do with `in` and everything to do with the fact that you are using a generator. Iterators such as generators get used up as you loop over them. There's no way to get at the previous values unless you have access to the iterable that the iterator was originally derived from. Compare this: &gt;&gt;&gt; def contains(n, items): ... for item in items: ... if item == n: ... return True ... return False ... &gt;&gt;&gt; my_gen = (i for i in range(10)) &gt;&gt;&gt; print(contains(3, my_gen)) True &gt;&gt;&gt; print(contains(7, my_gen)) True &gt;&gt;&gt; print(contains(2, my_gen)) False
Note that in cases like this where you are looping over the entire thing each time, using `itertools.tee()` will be less efficient than just making a list (and it'll end up storing the entire range in memory anyway internally, so no more memory-efficient). The optimal solution here is to construct the second range in the loop (this is natural given the contrived nature of the problem).
what issues did you run into? is it healthy could be integrated when it's more robust?
&gt; CPython implementation caches small integers and strings, so the underlying objects really are the same, sometimes. &gt;&gt;&gt; a=10000;b=10000 &gt;&gt;&gt; a is b True &gt;&gt;&gt; a=10000 &gt;&gt;&gt; b=10000 &gt;&gt;&gt; a is b False This is really tricky.
and the even more awkward `("apple",) `
 &gt;&gt;&gt; ll = (lambda: n for n in range(5)) &gt;&gt;&gt; print [l() for l in ll] [0, 1, 2, 3, 4] Use generator comprehension, not list comprehension.
For browser-based GUI, you want Javascript.
In my view code should run the same way every time it is run under the same conditions. Obviously this is not always possible. For example if you are doing concurrent stuff. I realize it is easy to avoid. But this is only true if you know about the behaviour. I just really like the clarity and explicitness of python. This aspect of python is neither. 
That isn't awkward - it still follows the rule that the comma makes the tuple.
I'm not sure I'd class it as tricky - the issue is comparing values with `is`, which is an identity check, instead of `==`. The caching of immutable objects really shouldn't ever be a problem, it's the mistake made before that which is the problem.
If the code is run under the same conditions, it will act the same. There is no way this will cause the same script with the same input to act differently.
To be honest, I think the ternary operator here is more convoluted due to the repetition of `x` than just using a straight up `if` statement. Sometimes dumping everything into one line isn't the best option.
Actually, its neither -- it's not a tuple unless [there are parentheses]( http://docs.python.org/2/reference/expressions.html#parenthesized-forms ). You can only omit parentheses with [`return`]( http://docs.python.org/2/reference/simple_stmts.html#return) because the comma is part of the expression_list in the `return` grammar. An [`if`]( http://docs.python.org/2/reference/compound_stmts.html#the-if-statement) requires an expression, not an expression_list, and commas are not permitted directly in expressions. That was probably more literal than desired, but I thought it a good start as it accurately answers the question. 
that's all you need, most of the time.
well holy shit. That fixed it. Any idea *why* the 64 bit wasn't working? I'm on a 64 bit system. I'd think it would be the other way around (obviously not though)
Looking deeper into this it depends on how tightly you define same conditions. Technically the behaviour is undefined. a = 100 b = 100 if a is b: print 'hello' This will or will not print hello depending on the version of c python 2 you use. It will also be different in other implementations of python. Also note that in any version of python. a = 4000 b = 4000 if a is b: print 'hello' will come out with a different answer. This the opposite of explicit behaviour and could easily slip through testing. 
I have personally ran into this one and wasted hours because of it. Maybe I just got unlucky though.
It was just an idea, don't know why the 64 bit version wouldn't work. File a bug report? Anyway on windows (even 64 bit ones) I thought the general advice is to just stick with 32 bit pythons unless you have a particular specific reason to require the 64 bit version. Much less trouble, much better luck finding suitable binary installers for third party libs and so on. Edit: maybe something on your %path% caused trouble in 64 bit land? Try starting the 64bit Idle with an empty %path%?
i did try an install without the path option, and that didn't help. Someone over in /r/learnpython told me that the 64 bit installer has some known issues that theyre working on
The extended unpacking assigns a list to b! I'm not sure why they didn't have it assign the generator (with the first element already consumed) instead.
Those would all completely negate the point of having the caching in the first place. 3 just flat-out wouldn't work due to Python's dynamic nature. You are making the assumption that every literal should be a different object, when that was never given. Why should literals produce new objects each time? It's a faulty assumption. It's perfectly all right for things to be undefined in a language. In cases like this, it's up to the implementation to decide how to implement it, which allows for optimal performance. What does this mean? It means that we shouldn't make assumptions about an object's identity. Fortunately, we don't *need* to. I take up a problem with &gt;Explicit means the behaviour should be obvious by looking at the code itself. That's not the meaning of explicit at all, and it's an unachievable aim. Python is a complex, powerful language that needs to be learnt. Part of that is knowing that `is` and `==` are not interchangeable. It's documented, and that's the most we can do without crippling the language.
For me this reads much easier, but I understand its a preference thing.
You float the idea of splitting `is` somehow, to a function that checks for identity, and one that checks if it's the same. That already exists. `is` and `==`. To add in another part to check if it's a cached object would completely defy the point - not only would you need to know about this problem to use it (hence, just using the correct method anyway, meaning there was no need it at all) , but it would require recording more metadata - at that point, it would be just as efficient just to make them separate objects. This mistake does happen, but people learn. By the same logic, we shouldn't use indentation as people often struggle with that. Python tries to make making mistakes less likely, but it's *never* been the case it doesn't let you shoot yourself in the foot. It's got a ton of introspection tools, `exec()`, and a ton of other things that can be abused just as `is` is being abused here. As to 'just using the same number objects' - so at the start of every file we have to do `one = 1` and then use `one` instead of the literal `1`? That's clearly a terrible idea.
Another hacky solution, if you don't want your lambda functions to have the optional parameter available. ll3 = [(lambda i: (lambda :i))(n) for n in range(5)]
Oh, OK, that explains it. I didn't know that `a, *b, c` worked. I think that in Python 2 (which only has this star notation for argument lists, not for assignment) this doesn't work.
If you open up Python and try it without the space, you'll find that the answer to your question is "no".
These are roughly the same reasons why Reddit and YouTube are written in Python.
Yes. Thus the “most cases”.
I have needed to use it in Jython to load in jarfiles. I can't think of another time, but maybe I've just been lucky. 
To be honest it was a long time ago but IIRC we had some issues calling out to the cheesecake server to process packages. Adding a scoring system to PyPI would be controversial, but I would like to add something to help package authors improve things. It might be that healthy, or something like it, could do that job.
Anyone know about kivy+pypy? would love to use something like kivy over SDL(via pysdl-cffi) for my graphics that I am adding to some code.
Yep, that's why I wrote 'restarts' :-) ***Edit - see my correction above***
There are. You probably won't encounter them.
In Python 2, `a, *b` does not work either. Extended unpacking was introduced in P3.
Excellent example, and you're absolutely right. I was also wrong in assuming using a for loop will somehow allow me to start from the first item in the generator every time.
Oh, does it matter in the case of Django settings? those are just constructed once if I'm not mistaken. Also, the awkward comma.
One case: `if x:` unfortunately crashes if x is a numpy array with more than one element. In my code, which almost always used numpy these days, that's pretty much killed implicit boolean evaluations.
:) version by mrjbq7 looks better
That unfortunately does not do the same thing, and in fact I'm sure I don't really understand what's going on: &gt;&gt;&gt; ll = (lambda: n for n in range(5)) &gt;&gt;&gt; [l() for l in ll] [0, 1, 2, 3, 4] &gt;&gt;&gt; [l() for l in ll] [] Drat. Ok, let's squash the generator straight away: &gt;&gt;&gt; ll = list(lambda: n for n in range(5)) &gt;&gt;&gt; [l() for l in ll] [4, 4, 4, 4, 4] Um. Wasn't expecting that.
Oh Great. Glad you got in. There's a lot of good tutorials on getting mysql working so definitely google any problems you come up with. I just recently added support for sqlite3 so you can get going without installing django. Good luck bud. Cheers
You're welcome. Would you rate the class? the ratings help me and other students a LOT... also if you ever change your mind on ratings, you can! Let me know if you have questions. Cheers.
You're welcome. Would you rate the class? the ratings help me and other students a LOT... also if you ever change your mind on ratings, you can! Let me know if you have questions. Cheers.
You're welcome. Would you rate the class? the ratings help me and other students a LOT... also if you ever change your mind on ratings, you can! Let me know if you have questions. Cheers.
hahaha! pretty funny. Yeah the codes started failing because of unanticipated demand that just kept piling up! Did you get in the class?
You're welcome. Would you rate the class? the ratings help me and other students a LOT... also if you ever change your mind on ratings, you can re-rate it! Let me know if you have questions. Cheers.
You're welcome. Would you rate the class? the ratings help me and other students a LOT... also if you ever change your mind on ratings, you can re-rate it! Let me know if you have questions. Cheers.
You're welcome. Would you rate the class? the ratings help me and other students a LOT... also if you ever change your mind on ratings, you can re-rate it! Let me know if you have questions. Cheers.
You're welcome. Would you rate the class? the ratings help me and other students a LOT... also if you ever change your mind on ratings, you can re-rate it! Let me know if you have questions. Cheers.
You're welcome. Would you rate the class? the ratings help me and other students a LOT... also if you ever change your mind on ratings, you can re-rate it! Let me know if you have questions. Cheers.
I guess it doesn't matter for that. But I've been in a few situations where my algorithm was generating lists by the millions, and there was a noticable performance improvement by switching it to tuples instead of lists. It's been a while so I don't have the numbers handy anymore, but ever since then I just instinctively reach for tuples unless the algorithm absolutely requires mutability.
Clojure attempts to give you nice tools for working with threads and concurrency, you can in one way say that is the niche too Clojure. Clojure is also a hosted language, so learning Clojure enables you to code for web (ClojureScript compiles too JavaScript), the JVM and the CLR.
(lambda: n for n in range(5)) is a generator expression. The first time through, it has five values: [0,1,2,3,4] The second time, it is exhausted: [] The delayed iteration keeps from "leaking" n. list(lambda: n for n in range(5)) == [lambda: n for n in range(5)] This is a list comprehension, it creates a list with the "leaked" var n. This is equivalent to the ol' JavaScript closure dilemma: a = [] for n in range(5): a.append(lambda: n) Now: a == [lambda: n] * 5 == [lambda: 4] * 5
As stated above, this is because of interning, not the space: &gt;&gt;&gt; a = intern('hello world!') &gt;&gt;&gt; b = intern('hello world!') &gt;&gt;&gt; a is b True But **_don't_** intern your strings.
High on my list of gotchas: * Mutable vs. immutable types (as types bind to values, not names, it is not usually obvious whether a certain variable contains a value or a mutable reference). * Mutable vs. immutable types in closures (this is especially confusing for people coming from e.g. Scheme or Javascript, where you can modify variables from a containing scope through a closure - in Python, you can only do this for pass-by-reference types). * Lazy vs. strict evaluation in general: it is not obvious from an invocation whether the result is lazy or strict. * Standard functions that return lazy generators in Python 3, but lists in Python 2 (e.g. zip()); the gotcha is that when you try to iterate over the result of such a function call twice, the second iteration will silently fail to produce, i.e., even though the code suggests you are generating a list and iterating over it twice, it is as if the list were cleared after the first iteration. * Unicode vs. bytestrings; naive code will default to byte strings, and it will "work" completely as expected as long as you feed it ASCII data - but as soon as the code receives a non-ASCII character, it breaks. * Format strings: formatting a `unicode` object into a byte string will result in a byte string, subtly eliminating the unicodeness from the processing; most of the other string processing functionality will automatically promote everything to unicode as soon as at least one unicode operand is encountered, but this doesn't work with format strings.
Yeah, the problem is that both comma and parentheses are overloaded tokens in Python, so they need disambiguation rules to tell whether you mean grouping parentheses, function call, or tuple.
At least some programming languages will tell you that the code you wrote doesn't make sense because "banana" is not a boolean.
In-place sorting has different performance characteristics. Typically, in-place implementation consume less memory (at least by 50%), but for those algorithms where an in-place implementation is possible, it is usually either less efficient (i.e., it requires more operations), or it is not stable (i.e., elements that compare equal are not guaranteed to retain their original ordering). The biggest practical consideration, however, is that in-place sorting is destructive, which can be kind of a maintenance burden and a subtle source of bugs (especially when you're sorting a list that you have received as an argument - the caller might not expect you to sort the list it gave you).
Yeah, but does that really qualify? It's not really Python-specific, actually.
It's subtle for the beginner who can't tell the difference between: list.sort() and list = sorted(list) and doesn't really think about why each is the way it is.
TIL how to make a generator. Would have thought that'd create a tuple in the same way [i for i in range(10)] creates a list.
Thanks for this clarification! Alas, I always feel uncomfortable with those sorted/reversed/len builtin. This methods work on iterables, why aren't they method of an iterable class (and list/str inherits from it)? Nevermind, I'm not gonna rewrite python :) 
There are a few options to use Python for client-side programming Take a look at [Brython](http://www.brython.info), an implementation of Python3 with an interface to the DOM. All it requires it to include the script brython.js (&lt;script src="brython.js"&gt;), to run the function brython() on page load (&lt;BODY onload="brython()"&gt;) ; then you can include Python code inside tags &lt;script type="text/python"&gt; 
The list allocation is an order of magnitude slower than the sort (Python 2, Python 3, and PyPy, using the fixed benchmarks in Alex Martelli's SO answer), that turns out to dwarf the algorithmic difference. You make good points about correctness however.
This is better IMHO: if item in {"apple", "banana"}: # ... it also works with a set of length 1 without gotchas: if item in {"apple"}: # ... The syntax is Python 2.7+, but 2.6 is near EOL anyway (in October 2013 it will stop receiving even security fixes).
oh wow, I think I've got that first one in production right now.. good thing I've never had to make use of the default parameter. Going to fix this asap; cheers!
Actually, it is the comma. For example, the following works fine: &gt;&gt;&gt; for x in 'apples',: ... print x apples I think its the "if" here that's the special case, presumably because the syntax makes this ambiguous - should it mean "Is the 1-tuple ((x in apples),) true" or "Is the boolean (x in ("apples,"))" true. Throwing a syntax error seems a bit odd though, since "x in 'apples'," seems to treat it as the former, with the "in" having higher precedence, but I'd guess this is just a "refuse to guess" case in python's grammar, since you almost certainly never want the always true (x in "apples"), case in an if statement. There are similar cases where it's also ambiguous, or the precedence would give a different result without the parentheses, but I think it's still the comma that's creating the tuple, since this is the only thing that's actually always *neccessary*. There is a case where parenthesis are always required for tuples, but it's not the 1-item tuple, but rather the empty tuple "`()`".
I wondered that too - even PHP can do this with [autoloaders](http://php.net/manual/en/language.oop5.autoload.php)
You are right; the extra memory allocation alone is likely to take longer than any speed benefit you might get. That's why I mentioned the semantic difference as the most important factor.
This has nothing to do with not having lexical scope - indeed it's actually a *consequence* of lexically scoping, since its the correct result for closing over an outer variable that those closures refer to that variable. You can reproduce exactly the same thing in scheme (and many other languages too). What may confuse you is that it'll depend on what *creates* a new scope. Ie. the n in the list expression doesn't create a **new** variable n *internal* to the list scope, but rather binds to the same variable that is closed over by all the created lambdas. Eg. in scheme, it's equivalent to a loop issuing a set! not a (let. 
Which address is the redis server bound to? I'll bet it's localhost and not the real IP. Can you connect via redis-cli from another machine? 
&gt; So for example "a is_c_code_pointer_location b" and "a is_unique_object_creation_match b" Fun fact: these both would be exactly the same thing as `is`. Unless... with the latter you mean that if you have `b = FooObj()` and `FooObj.__new__` returns a cached version of `a` instead of a new object, then you would want `a is b`, `a is_c_code_pointer_location b` and `not (a is_unique_object_creation_match b)`. But that's not possible, because there is no difference between `a` and `b`, so for that to work Python must be changed to add a "cached reference" type that is created if `__new__` returns an already existing object, that is a complete proxy for the original type with the exception of a check with `is_unique_object_creation_match`... but that makes no sense whatsoever and breaks my head.
Subclass, not the same thing: `assert True == 1 and False == 0 and isinstance(True, int)` Besides: don't compare ints via `is`: `assert 1025 is not 1025`
Python isn't a strictly typed language. The iterable interface is just a few functions you need to implement in order to make something an iterable, you don't need to subclass anything - it isn't Java. The built-ins will function on anything that fits the spec (although in the case of the functions we are talking about, it's actually sequences, not arbitrary iterables, although the same thing applies). In Python, if it quacks like a duck, it's a duck. No need to make it subclass duck, just make it able to quack.
That isn't really true, or at least, not more so than with anything you want to name. Python tries to ensure there is one good way to do something, but clearly and programming language of sufficient power to do everything someone will want will also allow you to do things in crazy ways, if you want.
Tuples will be faster than sets here, as they construct much faster. If the set was much, much larger, and this was happening repeatedly, then it might be worth using a set as the check for membership is much faster on a set than a tuple.
Cool. Good to know you seem to have had no trouble learning it. 
Because `import`ing in Python executes the module/the package `__init__()` - if it automatically delayed the `import`, it would change behaviour.
Note this is fixed in 3.x: &gt;&gt;&gt; True, False = False, True File "&lt;stdin&gt;", line 1 SyntaxError: assignment to keyword
It's because `is` checks if they are the *same* object, which isn't what you want to do. You want to check if they have the *same value*, which is done with `==`.
I had to check that one for myself: &gt;&gt;&gt; bool(np.array([1, 2, 3, 4, 5])) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all() Ugh, that is horrible. It should perform like Python data types and just return `True` for any non-empty array. I get they feel that the behaviour should be that of either `any()` or `all()`, but that's not how it works in any other Python data structures, and I don't see this error helps anyone.
My ipython ouput for ll = [lambda: n for n in range(5)] was [&lt;function __main__.&lt;lambda&gt;&gt;, &lt;function __main__.&lt;lambda&gt;&gt;, &lt;function __main__.&lt;lambda&gt;&gt;, &lt;function __main__.&lt;lambda&gt;&gt;, &lt;function __main__.&lt;lambda&gt;&gt;] Not sure why.
Cool, I can make a GUI interface using gui2py to track an IP Address
Hmm, maybe I should clarify: the first complaint is about the fact that Python has mutable and immutable types, and their semantics are wildly different, but it is also a dynamically-typed language, which means types bind to values, not variables, and this in turn means that you can't tell from a variable what its semantics are. For example, when you see this: def foobar(a, b): a += b return a ...it is impossible to tell whether this function has side effects or not, because it depends on the types of arguments you pass. Try it out: a = (1,2) b = (3,4) foobar(a, b) print(repr(a)) a = [1,2] b = [3,4] foobar(a, b) print(repr(a)) 
Well, python is a dynamic and strongly typed language (I don't know what do you mean by strictly, but english is not my native language). abs, reversed would work for any classes that defines a `__abs__` or `__reversed__` method (... as for other builtins). IMO, I don't see benefits to define the abs or reversed method in the global scope when I have to implement those double-dashed method in order to have them work. Once again, I feel fine with this behavior ;) 
Yeah, you are right, didn't exactly consider the case with `None`.
it is made for python 2.7 though so can't be sure it works on 3.2
A common one is that a `tuple` is an immutable `list` that saves memory. In reality each type serves its own purpose and one should never prefer one over the other based on how much memory it uses: * A `tuple` is exactly that: a vector of fixed length with each member representing a well-defined field. In a `tuple` the position is significant, not the order. It should only be used where in C you would use a `struct` and where a `namedtuple` is an overkill. * A `namedtuple` is a vector whose elements can be reached using named aliases in addition to their numerical positions. Makes it much harder to accidentally refer to the wrong field. * A `list` is a dense array. Order is important but position isn't. It should be used where an iterable is needed and a generator would not fit as a replacement (for example the value needs to be mutable). * A `deque` is a double-ended queue. It's much faster than a `list` when doing a lof of additions and removals. It's very well-suited for all sorts of FIFO/LIFO buffers and stacks. * A `set` is just that: a set. Neither order nor position matters, the only important factor for a value is it either being or not being contained. It's a good candidate for membership tests (`x in {1, 2, 3}`) but it really shines when you need to work with unions, intersections etc. If you're dealing with a collection whose members are unique chances are you're looking at a good candidate for a `set`.
Again, its the [`for` statement]( http://docs.python.org/2/reference/compound_stmts.html#the-for-statement), not just the comma. &gt; for_stmt ::= "for" target_list "in" expression_list ":" suite &gt; ["else" ":" suite] There is no grammatical ambiguity. `for` uses expression_list which permits comma, while `if` uses expression which forbids comma. if `if` used expression_list instead, comma would be permitted with no ambiguities in the grammar. 
Don't forget using Booleans with string multiplications. You get 0 or 1 occurrence of the string, depending on the truth value. print "DON'T PANIC" * (num == 42)
Yes. `True` and `1` are separate instances, but both are the same value.
I did some research and you are correct. bools shouldn't be ints but because of archaic reasons they are.
I'd argue there are better ways to do that these days, like the ternary operator. Not quite as concise, but less cryptic. Edit: Another classic use was to emulate the ternary operator, in fact: `[false_case, true_case][condition]`.
Fair enough. With `+=` and friends, things become really confusing. They probably shouldn't modify the original `a`, only change its binding, to fit better with regular assignment/binding and arithmetic expressions.
Yeah, generally I'd prefer the ternary operator as well these days.
&gt;Again, its the [1] for statement, not just the comma. Well, rather it's expression_list, which is used in plenty of places in the syntax and does produce a tuple (without brackets needed). ie, from the same document: &gt;&gt; expression_list ::= expression ( "," expression )* [","] &gt;&gt; An expression list containing at least one comma yields a tuple. A parenthesised expression list does too, but in virtually all circumstances, those parentheses aren't needed. Though I'm a bit curious as to *why* that restriction is in the grammar for if only. As you say, it's not the case for for, or a statement etc. I'm guessing the only reason is that the way its actually evaluated is useless for an if (gives an always true statement). 
Why would lists be more expensive to construct?
I've only used PyQT and Tkinter, but I MUCH prefer PyQT over Tkinter. It's just SO fast at getting things done. I can create one QAction and then use it throughout my program for things such as toolbars, menus etc.
Sorry but I don't know how to add a text to a link, so here's some additional info: CherryMusic is built on top of CherryPy, so it's a standalone server. The database is sqlite, so there's nothing to setup. It has been in the making for the past 9 months or so and gets regular updates and fixes. Please check out the code on github and write some issues if you experience any :) https://github.com/devsnd/cherrymusic EDIT: some more info on the python side of things: CherryMusic runs with python 2.6+ and python 3. We actually started to write everything for python 3.3, but over time we realized that this would limit the number of people using the program. So we started to carefully backport a lot of features and tried to put everthing in a compability module. It was a hard journey, to finally get it to run on python 2.6 without uglifiying the whole codebase too much. But in the end I think it was worth the effort.
&gt;Fun fact: these both would be exactly the same thing as is. No they would not. is_pointer would be exactly the same. But is_unique_matched_object would not. In almost every case it would be the same. But if you said a=1 b=1 a is_unique_matched_object it would return false instead of true. Again I don't think this is a good solution. By far the best solution would be to not cache objects as it only introduces bugs including performance bugs for the sake of tiny gains in performance that can be replicated with trivial programmer work. 
Because you haven't called the functions yet!
I think the reasoning is that in some other contexts, you use 1-elt numpy arrays like scalars, where you'd want bool([0]) to be false. Numpy arrays also screw with other basic things also (like == returning a boolean array rather than a single boolean), so if you might be using them you have to be careful about lots of things.
I think you would be better off trying to understand how a framework like Django works, but if you really want to start from scratch then I would suggest looking into CGI. [This tutorial seems pretty good.](http://www.tutorialspoint.com/python/python_cgi_programming.htm)
Try the free Udacity webdevelopment course CS253. One of the founders of Reddit (also written in Python btw) teaches webdev using Python with a lower level approach than Django there. Good luck!
That video was very informative, thank you!
Yeah, I anticipate using Django eventually, but I remember using Ruby on Rails and wishing I would have understood Ruby more, but not just Ruby alone, the way it interacted with the database and everything. I think frameworks like Django are excellent tools to make development easier, but I want to be able to appreciate why they are designed and be able to function without them. I like being able to fall back on raw skill. 
There's a *huge* [tutorial on flask by Miguel Grinberg](http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world). It takes you from the installation of the framework, the making of a twitter clone, and the deployment on heroku, with a lot of content.
I'm not familiar with the Rackspace Ruby/Slicehost experience he referred to. Can anyone elaborate on that?
For the record, you can't add text to a link post. Also, this looks really handy, I'll give it a try.
I'm not 100% sure, but it sounds like this approach will allow you to freeze execution of a currently executing function, modify local variables, and continue execution without losing state information. At least that's what it sounds like, haven't had time to dig in to the source yet. 
Yup. The command/control backplane for Slicehost was originally built in Rails. After we were acquired by Rackspace, Rackspace Cloud Servers were built on the same technology, but hidden behind some weird JMX Java panels and APIs. We abused the hell out of rails (using activeresource as a primitive RPC layer for instance), and eventually ran into trouble scaling to support the increased traffic from the Rackspace side. At the same time, we were having trouble hiring ruby guys with the right kind of operational experience, so we started replacing pieces of the service with Python on the backside as the first step toward rewriting the whole shebang and releasing it as an open source project. At the same time we found out about nova, which the Ansolabs people had released recently, so instead of making another one we teamed up with them to create OpenStack.
Oh duh. print ll :X
Start with WebOb. You'll be doing your own routing, and next thing you'll know you'll be building your own template engine.
I started with Bottle and found it easy to use in order to get started with the basic ideas of routing. The installation is super easy and the tutorial on the homepage is great. At work when I had to start create som internal monitoring tools for my colleges i quickly learnt web2py. I find it very easy to install, run and start using. There is a great video-introduction on the website and the book is a very good documentation. Some people do not like the "batteries included" approach but I have, as a beginner I have found it really helpful to get a structure, and then start to modify it when I needed new functionalities. Although web2py does not require "raw skill" I feel it have helped a lot with the understanding of web-frameworks and I will be much more comfortable when it is time to build something from scratch.
I recommend also looking at Pyramid http://www.pylonsproject.org/.
without using a framework? that would be pretty difficult pretty much the only language where you can easily put together web apps without a framework is PHP because it natively interfaces with Apache. python and most other languages need a bridge, in python's case it is wsgi. it is best if you use a lightweight framework such as Flask. all it does is basically allow you to accept and respond to requests.
Not if you are setting it right. Go into the Control panel&gt;System&gt;Advanced System Settings&gt;Environment Variables
So, parsing id3 tags etc is optional? how do you get an artist/album listing without it? Also, you may want to make mutagen a dependency instead of stagger. It at least seems to be actively developed still. Also, out of curiosity, how does your boundconnector deal with sql injection? 
I have both installed, and like /user/billsil, I just specify which one I want. I keep 2.7 as my default but I have both IDLE links in my taskbar and if there is a program that needs to run in 3.x I create a shortcut for it that calls 3.x Changing path is enough if you are calling it like c:&gt; python script.py if you are clicking on the script.py file then you need to associate the .py file type to the other interpreter. 
You probably want to get familiar with wsgi rather than CGI. And wsgi isn't that complex. Anyway, I would recommend [this](http://docs.webob.org/en/latest/do-it-yourself.html) as it helped me understand all the pieces that all these frameworks try to make easier. 
Think of an iterable as a container or container-like object. An iterator represents the state of a walk through the container (e.g. current position). A container can have multiple concurrent iterators that may or may not generate the same sequence. The for statement (or other consumers of iterators) can use either. This is the tricky part. 
Yup, I think you're spot on. Python likes to "help". I'm guessing folks would also confuse "`if x in a,b,c:`" which would parse as "`if ⟨x in a⟩, ⟨b⟩, ⟨c⟩:`" with "`for x in a, b, c:`" which groups as "`for ⟨x⟩ in ⟨a, b, c⟩:`", not using the `in` binary operator at all, but merely appearing as though it does.
Terrible.
I've always heard this, but I have no clue what 'sorted in place' means. All it means to me is, 'it returns None instead of what you want' ...
One of the fundamental decisions about CherryMusic is to keep the dependency count low. I always hated to setup a database and install 400mB of KDE dependencies to get some little program running. So that's why cherrypy is and probably will stay the only non-optional dependency. Right now we are overhauling the search to support many different types of meta information. The biggest problem is, that the quality of information varies very much, e.g. sometimes the spelling of an artist isn't quite right etc. Right now, most of the search is an "intelligent" guess of what you're probably looking for. We'd like to combine ID3-tags, user generated information, (maybe audio fingerprints) later on. As filenames are the only information that must exist, we use that as the base. concerning the database connections: We just rely on the builtin functions of sqlite to escape all user input 
does this support actual streaming protocols or does it send the raw mp3 data and lets the browser buffer and playback?
cool thanks for the info. 
Tuples can be built at compile-time rather than runtime. Also, there are dedicated arena allocators for tuples of common sizes, since their size cannot vary once created.
How would `is_unique_matched_object`/`is_unique_object_creation_match` be implemented? Was my "Unless..." not what you intended? If you could write some kind of high level pseudo code that explains it, or something like that, that would be nice.
For a start, you should read http://www.reddit.com/r/learnpython/ (and you probably also should have posted this thred there). These are (according to me) very good resources: http://learnpythonthehardway.org/, http://www.learnpython.org/, http://www.python.org/about/gettingstarted/ and again http://www.reddit.com/r/learnpython/ 
If you want a low level look try this http://fragments.turtlemeat.com/pythonwebserver.php A bit higher up the simple http server http://www.linuxjournal.com/content/tech-tip-really-simple-http-server-python
Web2py is one of the easiest
@claird: Thank you. :-) @jpeg1992: The initial setup is a little tricky, especially as regards the inclusion of the VC++ runtimes, but it's very doable. After you get the scripts set up, you can create one big batch file that runs everything. If you are then using the excellent Visual Studio / Python Tools, you can then add the batch and other files as extra files in your solution and set up the build tool in your "Tools" menu. Then you can check in your code (I use tfs.visualstudio.com) and then execute the Build Package in the tools menu, and *poof* generate a foobar.exe file. Best thing is that if you get Tkinter and your other major dependencies into a package, you can just copy that setup for the next program, and the next one. It's a one-time investment to figure it out, and then it just works. 
This is not the same case at all. With django you learn Python, everything explicit, nothing magic. I once felt like you with Rails. But Python itself it's completely different, have you read the python zen?
There is no offline mode, but PythonAnywhereThereIsCellPhoneNetworkService is a longish name. If you want to work offline, though, there are nice python tools available for several portable platforms. For instance, you could use Textastic to hack on a bottle.py app on an iPad (which incidentally would allow you to preview javascript and html offline) and then sync the whole thing with Dropbox, so when you came back on-line, you'd sync to PythonAnywhere (also syncs with Dropbox) and then you'd be all set. You could also layer git on top of this for a little more orderliness. There is a how-to-put-a-git-in-a-dropbox tutorial around if you're interested. Anyway, there are all kinds of solutions around. I haven't mentioned Pythonista or Python for iPad or a number of other things. Oh, one more thing: if you're going to SSH into PAW (or anywhere else) from an iPad or iPhone, the "Prompt" app works very well; it handles control keys on BT keyboards really well. Most iPad apps don't. Some things to think about anyway... 
Every OS logs user access differently. In my case (Debian Linux) user logging happens in /var/log/auth.log I will make a daemon to watch that file for the lines you need to know a user has logged in and trigger email sending. The bonus question is a bit naive, you have to watch files in both computers. My bonus answer is you can execute remotely your script to watch using fabric: http://docs.fabfile.org/en/1.6/
I have not used ClojureScript yet. Mostly been working on the main implementation on the JVM :) You could however go ask in `#clojure` @ freenode, as they will be more then willingly explain it too you.
in layman's terms: in-place means, that the elements in the list get swapped while sorting. on the other hand, the `sorted` call creates a new list and adds the elements of the original list in sorted order to that new list.
 class switch(object): def __getitem__(self, index): try: return getattr(self, "case_"+index)() except AttributeError: return 'End' def case_hello(self): print "case hello!" def case_world(self): print "case world!" switch["hello"]
Is there a way to get it to work through a reverse proxy? Trying to set it up to work on port 80 with nginx I get this error File "/var/www/cherrymusic/cherrymusic", line 160, in &lt;module&gt; cfg_override=ConfigOptions.configdict File "/var/www/cherrymusic/cherrymusicserver/__init__.py", line 110, in __init__ self.setup_config(createNewConfig, setup, cfg_override) File "/var/www/cherrymusic/cherrymusicserver/__init__.py", line 143, in setup_config cfg.write_to_file(cfg.from_defaults(), pathprovider.cfgFile()) AttributeError: 'module' object has no attribute 'cfgFile' 
I have not been using visualstudio but gedit and just been executing in ubuntu terminal, doesn't surprice me it is tricky, but i will proberly figure it out. Thanks for all the advice, sounds like this is the way i will go when i finish the game. :)
Pretty cool. Wonder if this would work on an OpenWRT router?
I just tried chromium, and it works for me. I also loaded up a VM to try IE8, and to my surprise even that works. So I can't really tell why you're not able to see them.
Awesome that fixed that, now its complaining that its not the root directory. Gives me cherrypy's 404 when I visit the server though my proxy localhost/cherrymusic instead of localhost:8000. Complains that /cherrymusic does not exist. Is there a way to configure the path at present? 
Cool. So the CPU load is minimal?
&gt; under the hood Read [PEP 3333](http://www.python.org/dev/peps/pep-3333/).
I always ran cherrymusic directly and never behind apache or nginx... but of course it would be very cool if that worked as well. Could you give me more detail about your setup and or error messages? btw: there should be an error.log and server.log in ~/.local/share/cherrymusic
As long as you have on-the-fly transcoding disabled, yes.
productivity &gt; loyalty
Sure I'm using nginx for my proxy, I use it for a tornado application I run and I'm using basically the same set up. My nginx available sites file is like this upstream cherry { server 127.0.0.1:8000; } server { listen 80 default; ## listen for ipv4; this line is default and implied #listen [::]:80 default ipv6only=on; ## listen for ipv6 root /var/www; index index.html index.htm index.php; # Make site accessible from http://localhost/ server_name localhost; location / { # First attempt to serve request as file, then # as directory, then fall back to index.html try_files $uri $uri/ /index.html; # Uncomment to enable naxsi on this location # include /etc/nginx/naxsi.rules } location /cherrymusic { proxy_pass http://cherry; proxy_http_version 1.1; proxy_pass_header Server; proxy_redirect off; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_set_header Host $host; } } This redirects any request for localhost/cherrymusic to localhost:8000/cherrymusic Then in my supervisor config I have this to run cherrymusic any time the computer is on [program:cherrymusic] command=python /var/www/cherrymusic/cherrymusic --port 8000 stdout_logfile=/tmp/cherrymusic.txt redirect_stderr=true There are no errors in the logs, everything is working as expected, its just getting an error because I'm visiting /cherrymusic instead of / [130514-17:37] 127.0.0.1 - - [14/May/2013:17:37:38] "GET /cherrymusic HTTP/1.1" 404 725 "" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.63 Safari/537.31" Basically there just needs to be an extra argument to specify a path like so: python /var/www/cherrymusic/cherrymusic --port 8000 --path cherrymusic #the above line should result in the main page visible at localhost:8000/cherrymusic Or make cherrypy redirect all other paths to / 
Well, I get that. But I don't understand why it doesn't return a list.
Ah, I see, I'll add an option to set the path cherrymusic is served on... Give me a sec :)
Awesome thanks, note it should affect all paths including your apis. So now for apis it would be localhost:8000/cherrymusic/api/heartbeat I'm digging this might look into making an android client. What streaming protocol is it using?
would you expect that human.wear_a_hat() returns the hat he is wearing? The call is operating directly on the object, and therefore returns nothing. here's a good example from a question on SO http://stackoverflow.com/questions/10936737/why-does-django-orms-save-method-not-return-the-saved-object
Yeah, I read that. I'm kind of happy that it's not like Rails. 
No
Well basically everything is plain HTTP, including 206-partial requests, which reduces overhead in terms of seeking. But it isn't really optimised in that sense. Anyway, I was looking into making a mobile client as well, but the API is still subject to change; We're planning on making this completely RESTful, instead of our DIY-interface. Actually, the mobile client should only include a webview and maybe a special template for the frontend. More importantly, it should be able to keep the device from sleeping and map the physical buttons to something useful etc... However I would be delighted to help you create something like that :)
Its not the language its the libraries... I would upgrade in a minute if I could but I have too many critical apps that depend on them...
Why are you advocating this now? As opposed to a month ago or a year from now?
Great, I'm looking forward to it!
Oh how I wish it was so simple..
All android here, but the Dropbox angle is an interesting one. I already sync my Nexus 7 and Macbook that way. 
This looks very interesting, and I have it setup, but I'm getting this error on a lot of my directories: unable to list compact directory the console has this in it: UnicodeDecodeError: 'ascii' codec can't decode byte 0xbd in position 6: ordinal not in range(128) Other directories work fine, and I can play music from them.
thank you i didnt even know about that sub, now i feel stupid for posting here....
Be easier using the google scripts no?
Thanks for reporting this! Could you please tell me what OS you are ussing and the language of your OS? Also, could you provide the python version you are using and a more detailed stacktrace, so I can see where the problem is coming from? 
I felt this was appropriate for the python community in that * we program with a dynamic language * there is some amount of flexibility in language choice * we have some things to learn from python programmers * we hired someone from the ruby community in the last round and would love to be a bit more well-rounded * it's a job opportunity to facilitate research in diseases like cancer :) 
What needs to happen is more pressure on popular libraries to update. Python 3 is stuck in a dependency loop- libraries won't upgrade until more people use it, and people aren't using it because libraries won't upgrade.
Took me about 2 minutes to get this up and running on my Win 7 machine and I'm pumped to start using this to access my music from work. Very very nice work! This is quite slick and a great piece of work!
You haven't demonstrated enough understanding of the various issues to be in a position to issue directives, but thanks anyway.
http://pyramid.readthedocs.org/en/latest/#tutorials
https://www.djangopackages.com/grids/g/cms/
[Web frameworks](http://en.wikipedia.org/wiki/Web_framework) [abstract](https://en.wikipedia.org/wiki/Abstraction_\(computer_science\)) [design patterns](https://en.wikipedia.org/wiki/Category:Software_design_patterns), [architectural patterns](https://en.wikipedia.org/wiki/Architectural_pattern_\(computer_science\)) and [algorithms](https://en.wikipedia.org/wiki/Category:Algorithms) that [web designers](http://en.wikipedia.org/wiki/Web_design) and [web developers](http://en.wikipedia.org/wiki/Web_development) can implement in a [standard](https://en.wikipedia.org/wiki/Web_standards), [maintainable](https://en.wikipedia.org/wiki/Software_maintenance) [way](https://en.wikipedia.org/wiki/Category:Software_development_process) in order to [minimze](https://en.wikipedia.org/wiki/Minimize) [anti-patterns](https://en.wikipedia.org/wiki/Category:Anti-patterns) and [technical debt](https://en.wikipedia.org/wiki/Technical_debt). [Wikipedia](http://en.wikipedia.org/wiki/Wikipedia) links/tags * http://en.wikipedia.org/wiki/Category:Web_design * http://en.wikipedia.org/wiki/Category:Web_development * http://en.wikipedia.org/wiki/Category:Web_application_frameworks * http://en.wikipedia.org/wiki/Comparison_of_web_application_frameworks * http://en.wikipedia.org/wiki/Category:Python_web_application_frameworks * http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface#Example_application * http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface#WSGI-compatible_applications_and_frameworks Learning [Computer Science](http://en.wikipedia.org/wiki/Computer_science), [Web Design](http://en.wikipedia.org/wiki/Category:Web_design) and [Web Development](http://en.wikipedia.org/wiki/Web_development) Online * https://www.khanacademy.org/cs * http://www.class-central.com/stream/cs * http://www.class-central.com/search?q=web * http://www.class-central.com/search?q=python * **http://www.codecademy.com/tracks/web** * http://www.codecademy.com/tracks/python [Python](http://en.wikipedia.org/wiki/Python_\(programming_language\)), [HTML](http://en.wikipedia.org/wiki/HTML), [CSS](http://en.wikipedia.org/wiki/CSS), [Javascript](http://en.wikipedia.org/wiki/Javascript), and [HTTP](http://en.wikipedia.org/wiki/HTTP) for [Web Development](http://en.wikipedia.org/wiki/Web_development) * *http://docs.python-guide.org/en/latest/scenarios/web.html* * *https://github.com/defnull/bottle/blob/master/bottle.py* * https://github.com/Pylons/waitress/blob/master/tox.ini * https://github.com/seedifferently/the-great-web-framework-shootout * https://github.com/tastejs/todomvc * https://github.com/yeoman/yeoman * https://en.wikipedia.org/wiki/Responsive_web_design Related Questions * http://www.reddit.com/r/Python/comments/1c7snk/discussion_massively_parallell_cms/ * *http://www.reddit.com/r/Python/comments/spsbs/are_the_same_thing_a_web_application_and_a_cms/* * http://www.reddit.com/r/Python/comments/191f5v/making_a_simple_cms_in_python/ * http://www.reddit.com/r/Python/comments/1c6866/best_frameworklibraries_for_a_small_restbased/ * http://www.reddit.com/r/compsci/comments/1e3mht/is_rdbmss_and_sql_still_part_of_the_standard/ * http://www.reddit.com/r/Python/comments/1drv59/getting_started_with_automated_testing/ 
I wouldn't say it is really stuck, there is definitely progress being made on the issue of library support. Sure it could be faster, but things are coming along. 
Thanks, I've tried to fix the problem; Could you please try to use the latest devel version from github and see if it helped? https://github.com/devsnd/cherrymusic/archive/devel.zip
btw: the simplest fix would be to start cherrymusic using python3 instead, since all unicode problem are then gone :)
I dunno, Go lets you program fast and efficient servers, easily. That's basically its primary market. Everyone and their dad is writing application servers to host SaaSes, so I think it should pick up employability quite quickly.
When I try to browse, I get "failed to load file browser" and this traceback: File "/home/isdnpro/devsnd-cherrymusic-922d7b9/cherrymusicserver/cherrymodel.py", line 90, in listdir upper_case_files = map(str.upper, allfilesindir) TypeError: descriptor 'upper' requires a 'str' object but received a 'unicode' Also building my media library I got a whole heap of errors like: [130515-03:36] ERROR : file not found: /home/isdnpro/Torrents/Data/Triple JJJ Hottest 100/10000 Maniacs - Candy Everybody Wants.mp3 . skipping.
You work for Rackspace? Awesome, what kind of degree/training do you need to work there?
Came here to say this. 2 out of the 3 major third-party packages my M.Sc. thesis project depends on have no 3.x support. I'll be damned if I start over with different libraries at this point.
It will most likely be a Unicode translation issue... I had similar problems when I was writing a file browser. I had some files on my system encoded in a different locale than my system was setup for. The python module 'chardet' helps a lot, it can guess a filenames encoding. My quick way to solve getting a filename into Unicode is: def _to_unicode(string): """Converts a string to Unicode""" if type(string) == unicode: # Already unicode! return string import chardet encoding = chardet.detect(string)["encoding"] print "_to_unicode called, chardet.detect says %s" % chardet.detect(string) string = string.decode(encoding) return string 
If by pressure, you mean heaps of money and talented developers, then yes, I'm right with you.
Qt offers LGPL license. PyQt does not.
Ya, that's true. I can try installing it, but I dont know if it will mess anything else up :(
Oh, and if your interested, the web interface works great on a Blackberry Z10 (other than the above problem, of course).
Can you name them for us?