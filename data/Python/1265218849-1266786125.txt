i'm using sqlite for my local db and mysql for remote. Both have support for triggers, but the triggered operations can only be performed on the local database. so, i think it dosent help much in this scenario. Okay, reading this help me sort out a lot of things I had in mind. Thanks mucho! 
i'm just copying the data. Yup, having a script that goes about renaming schema information seems a lot easier in this scenario.
Whether you like a text-based template language or an XML-based one is mostly a matter of personal taste. Both have their pros and cons. But apparently you think that those who like one should be using Java instead. What a silly thing to say. Just flaming, not a reasoned opinion, I guess? Ah, well, I should not worry about this then. 
Why not use [urllib](http://docs.python.org/library/urllib.html)? [urlopen](http://docs.python.org/library/urllib.html#urllib.urlopen) returns a file-like object: import urllib, csv rows = csv.reader(urllib.urlopen('http://earthquake.usgs.gov/earthquakes/catalogs/eqs1day-M1.txt'))
I almost took a job a year ago for a Django developer position. The head developer told me that instead of using Django templates for output, they used XML/XSLT because it was "more flexible". The site only output HTML, mind you. Having experienced the clusterfuck that is XSLT, I turned down the job on that basis (they seemed quite religious about using it) - who knew what other horrors their architecture held ? 
It's nice... it's hard to get your head round (being a sort of functional language), but once you get it working it's like magic - you put your xml in, then out the otherside comes your html (or whatever).
Having talked to people on the GAE team, it sounds unlikely any time soon. In preparation for GAE they did an extensive security audit of the Python 2.5 code base, which would have to be repeated for Python 2.6, and there doesn't seem to be a strong motivation to do so.
I'd rather not find any code like this in any project I work on. Why the hell would you have objects whose exposed methods you are not sure of?
What are the implications of this if I want to use Mootools for admin stuff? Will there be the possibility of conflict?
Ugh. If you absolutely have to write something ugly like this (and you probably don't), at least use the callable() method.
This is very sad news. I feel like adopting 2.6 would help with adoption of python3.x tremendously. I thought Google would have more interest in this, especially considering their investment in Unladen Swallow, which is now being merged into python 3 instead of 2.6. Maybe if we said please?
I was unaware of that. Thanks!
http://www.python.org/dev/peps/pep-0391/#a-working-example
I'm guessing at this point 2.7 might be a more motivating target than 2.6 for Google. But people can star the issue to register their interest. Or maybe make signs and protest at PyCon ;)
I would except jumping to 3.x (with an SDK version rev) before moving any further in 2.x. It seems like GAE has the ability to run two versions of the system in parallel, so it should be possible on their end I would think.
You sound like my grandmama. Seriously, what I'm saying is if you like XML so much just go ahead and use it. It's far from elegant, certainly far from "the most fun I've ever had programming since I wrote my frist line of f-in pascal code in high school" those pointy brackets feel like splinters in my eyes. And regarding Java... If you've been living on Planet Earth in the last 15 years you should know why I'm referring to Java whenever the abomination that is XML is mentioned.
I am for it (although I only skimmed the PEP). The 'Rationale' section hits on most of my pains and having central configurations that I can reuse and subtly modify will simplify my life.
I've been using Python for the last 12 years or so. I've used text and XML-based templating systems in that time. I also think XML's useful, which is why I wrote the lxml library. I probably sound like your grandmama as you sound like a teenager. 
Agreed.
So this sort of introspection is inherently is a bad idea? Care to explain why? It seems to be consistent with the duck typing style...
As far as I can tell, all callable does is check for __call__, which is what I do. If I used it here, I would have to catch an AttributeError in the case that there not only isn't a method with the specified name, but not even any sort of attribute. I feel the code is cleaner without using callable.
One could argue that this is another case of them not being active in the FOSS community. A security post 2.5 should be easier if done actively as code is commited for final release.
As a fanatical Python user since 2001, I'm still on 2.5 for my own projects, and certainly have no use for newer versions on App Engine. FWIW, aside from some syntax additions for 3.x compatibility, most of the library changes that happened in 2.6 were related to things not useful on App Engine anyway - e.g. multiprocessing. I'm more than happy with them avoiding a massive increase in maintenance overhead for little benefit to the customer. Also note that the more minor versions of Python they deploy, the wider spread of versions used by customers, the less resources available to provide long-term maintenance for each individual minor version, and thus ultimately the more disruption in the long term as customers are shifted off minor versions going out of maintenance. I'd rather have a few years out of date interpreter than one that may unpredictably become unsupported.
why the guns ? why the violence ? can't web frameworks get along ?
2.5 is actually pretty new for most big apps. We just dropped 2.3 finally after discussing it for a year or two. Places like Debian and Apple move very slowly.
I would guess they skip 2.6 and go straight to 3. In fact, we should probably all do the same... 
[The actual PEP is here](http://www.python.org/dev/peps/pep-0391/) if anyone was having trouble finding it (I was...)
Would you like to build one with me? I'm looking for a project and primarily use Python.
Same here, I actually just migrated my application from RHEL 4 with Python 2.3 to RHEL 5 with Python 2.5 two weeks ago. Pretty simple code-wise, really, but involved a hell of a lot of meticulous testing. I wanted to move from mod\_python to mod\_wsgi as well, but the change management/risk management people felt that was *far* too much at once. \*rolls eyes\*
The only negative is that admins will hate it (more than the current thingy anyway) for apps-type configuration: configparser files are "regular" config files, which both unix and windows admin know. This new format isn't anything they know or have ever experienced. On the other hand, it looks far better and cleaner than the current schema, and more flexible as well. I like.
&gt; It's nice It's not. &gt; it's hard to get your head round (being a sort of functional language) I know functional languages. I've learned Scheme, Erlang, have learned Haskell at least 4 times. XSLT is only a functional language in that it has functions. A language which has no lists and needs 6 lines just to *setup* a 1-arg noop recursive function is dysfunctional, as far as I'm concerned. It's a god damn piece of shit of a language, functional or not. &gt; but once you get it working it's like magic - you put your xml in, then out the otherside comes your html Dude, I can do the same fucking thing with lxml and a Python function with 10 times the performances, put xml in, get whatever you want out, woohoo. There's no magic. XSLT is a terrible, terrible language. Its lack of modularity is only beaten by its verbosity and its unmaintainability. There are two good ideas in XSLT: 1. using XPath for node selection &amp; template matching. XPath, along with RelaxNG-Compact and Schematron, is one of the only 3 non-brain-damaged XML technologies (and you'll notice that *none* of them uses an XML syntax) (also note that this excludes XPath 2.0, which is fucking retarded) 2. Using templates for side-effect-free transformations with a default template of "copy current node as is and process children". There, that's it. 2 good ideas buried in an unusable garbage of an implementation relying on hidden contextual crap every-fucking-where (oh yeah, fuck `"."` by the way). I worked with XSLT for a year, never again. Next time I have to transform XML into XML (a stupid idea in the first place, as far as I'm concerned) I'll implement a library based on the only 2 good ideas in XSLT instead.
Where in my comment did you read that XML is not useful? It's as useful as any format designed for exchanging data between software systems, only far more often abused by people, and compared to others much less readable for humans. Whether to use XML or text based templates may be a matter of personal choice. And using XML templates may not be abusing XML if the output is XML (oh, wait, it can't be anything else). But, I have never met anyone who will refuse to express themselves in a text based template language or read such code, where I know tons of people who share my views on XML. And that's why even if I found XML templates tolerable I would never use them when there is an alternative. And I don't care if you wrote the software for the Apollo 11, if you abuse XML and I've to maintain your software I'll hunt you down and rip your head off.
And part 2: http://www.blog.pythonlibrary.org/2010/02/03/another-step-by-step-sqlalchemy-tutorial-part-2-of-2/
It is a bad idea because when you take an object as an argument or such, you really should know what that object is. Can you name an example where you'd have unknown objects and want to do something to some subset of them that have a certain interface? Why don't you know what interfaces they support?
&gt; Code reuse is better done by components/composition. I don't buy this but you'll surely present arguments that composition reduces boilerplate instead of adding it?
Use something else. Jinja2 would be a definite candidate. Writing XML/HTML for user agents to interpret and writing a text email for humans to interpret are too completely different design goals and thus use different tools makes sense to me.
Boilerplate is something not needed. Being slightly more verbose doesn't mean it is boilerplate. I hate boilerplate but I agree with a bit more verbosity if this makes the code clearer. I prefer class LivingThing(object): def __init__(self, id, behavior, weapon): self.id = id self.behavior = behavior self.weapon = weapon def Dragon(): Livingthing( random_celtic_name(), Agressive(side="all"), ConeAttack(name="fire breath", dmg=50)) Over the equivalent inheritance-based code, which may be shorter but less reusable. In this isolated case, the gain is not very strong but over a list of 100 different monsters, the components win hands down. Components have a more focused role and are easily better defined. This obvious for data structure (you should implement a tree and the related traversal algorithms once for all) but this is the same for almost any functionality.
o i c. thanks.
The BDFL himself works on GAE. I suspect they have strongly weighed the pros and cons of offering the various Python versions the the lens of many motivators. I guess we just need to trust that they made a good call here and star the issue if you want to weigh in on the matter.
NO! My framework is the one and only perfect framework. Every other framework is evil!
&gt; First, obligatory link: http://hsivonen.iki.fi/producing-xml/. Nuff said. Yes, well, if you want to do XHTML/XML, it's a good idea to do it properly. But nothing prevents you from producing well-formed markup even if there's nothing to force you to do that. I like well-formedness too, but I'm more interested in the overall pleasantness and cleanliness of a web-template framework. 
When you are loading plugins at runtime, for example. Except that you should always do it with a specific interface or attribute or something, not with duck typing-like approach.
hehe. BFG is a pretty funny name :) BFG == Big Fucking Gun, the term made popular by doom. 'BFG can be a good weapon in your arsenal.' Is kind of like saying BFG being 'a pretty good tool in your tool belt'. The gun looks pretty big on the cover. Would have been good to make the gun look bigger though. For example, by having a tiny person standing there holding it, with the BFG shooting webs. Maybe even tying in a tool belt somehow to make it even more obvious. Anyway... good to see people having fun with naming their projects :) Congrats on the book to Chris.
Thank you for the congrats ;-) Lest a manager-type be put off by the presumed abbreviation: http://docs.repoze.org/bfg/1.2/designdefense.html#the-name-bfg-is-not-safe-for-work
We're shooting *with* you, not *at* you ;-)
&gt; This new format isn't anything they know or have ever experienced. The PEP uses YAML to describe the schema, as it is more concise and readable than using Python source. However, you can use YAML, JSON or any file format which can be deserialised to a Python dict.
This guy just added *inline assembler support* to Python. Mind. Blown.
We agree then: using XML templates for producing HTML works just fine, and is not abuse. Besides the ability to express HTML in XML, there are also output filters that can turn it into "normal" HTML. Whether you've met people that agree with you on text templates is pretty immaterial, especially since they might know you froth at the mouth when you hear the word "XML" in a templating context. I do hope that you'll never be the maintainer of my software if this is an example of your attitude, and you're not going to grow out of it. Making XML versus text templating a religious issue where you condemn the other side is silly. Just have your preference and state reasoned arguments, instead of bluster. It's just a matter of tradeoffs. 
Well yeah but in any case not an ini-type file, right?
I would love to see a tutorial where someone implements a tagging system. Isn't there any easier way to add tags that already exist without checking for errors!?
I don't know - perhaps some other ini file reading tools like ConfigObj might work.
Why not just try to call the plugin - and catch exceptions? Checking "hasattr" is not a sufficient check anyway.
The PEP 391 implementation is now in Python's svn trunk (r77969), with unit tests. Feel free to have a play :-)
No, actually [scipy added it](http://www.scipy.org/Weave), and it's inline C/C++ support, not inline assembler support.
i lol'd
Fundamental language features are considered patterns these days?
*cleans up his github*
Wow, that's super fucking handy. I wish I didn't design my databases so relationally all the time, I'd love to use something like this or Tokyo for more data.
Diaper Pattern (or Diaper Antipattern) is a great name. Not only does it catch shit, it leaks out a shitty smell and fixing it is a nasty job.
There is a previous long-standing meaning of "Diaper Pattern" which means a background design of squares or diamond shapes. The term was commonly used in Heraldry. It's where the Baby Diaper got it's name. They were woven that way just so the depressions would catch the shit. I'm surprised that this guy didn't even acknowledge the original meaning.
everything is a pattern these days
Very good read. Thank you!
Could somebody clear this up for me? &gt;[...] errors should never pass silently (unless explicitly silenced). Sorry if it's a novice question - I'm a novice. How do you "explicitly silence" an exception?
Even *worse* than: except Exception: is: except: which catches SystemExit and KeyboardInterrupt. You almost **never** want that shit in your diaper.
"Explicitly silencing" an exception would be something like for x in foo: try: do_stuff(x) except IOError: pass It continues like nothing happened on *only* an IOError exception. That is explicitly silencing. If another exception occurs (like a TypeError, etc), that exception still gets raised, and not silenced. 
I don't see the problem with except Exception: in the outermost layer of your app (or the outermost layer you write in e.g. your network server or webapp) to e.g. log the exception and/or transmit or display it in a properly formatted way to the client.
He probably means situations where the error is an expected part of some library use, e.g. silence the parser exception when you use the parser to figure out if something conforms to a certain format.
The meaning of pattern in programming is really totally different than the meaning of graphical patterns. There is virtually no connection in our (programmer's) heads between the two meanings of that word.
"Explicitly silence" means you catch a specific Exception sub-class, and don't re-raise it; perhaps don't even log it. E.g.: try: risky_business() except MyBenignException: # specific pass # silence By catching the more specific MyBenignException, if your class hierarchy is right you won't be catching and ignoring problems that should really be escalated.
Sure, but OP describes just ignoring the Exception with a pass statement... I guess as a rule all exceptions should be uncaught (or at least re-raised) **unless** you can fully handle the necessary remediation at this particular point. That rule would even apply at the outermost layer, where code like: try: body_of_program() except: log.error('something went wrong!') would be flawed, as you'd catch and throwaway SystemExits: in almost all situations, they can't be fully handled here and should be re-raised
This http://github.com/alex/pyelection/blob/master/models.py#L37 is why you don't use bare exceptions (this is my code from my younger days feel free to mock it). Edit: Realized I wasn't strictly replying to your post, I don't disagree with anything you said. Also this is an equally good excersise in why you should write comments.
Oh, excellent. Thank you!
Oh, excellent. Thank you!
That makes sense, especially in combination with HotLikeARobot and jcb62's code samples. Thanks!
As an avid developer, user and optimizer of ATLAS, I'm going to have to point out that a sole comparison between ddot and NumPy's dot (*table 1*) is in no way exhaustive. If I recall correctly, dot is merely a collection of different BLAS routines, which are selected at runtime based on problem size, so effectively, dot's performance is the same as that of the BLAS/LAPACK it's linked against. edit: typo
Thanks!
Yes sorry about that. I wanted to use that URL but it was already posted in reddit some time ago.
tl;dr: I halved the execution time of my code by setting cpu affinity, and packaged the details into a module called [threading2](http://pypi.python.org/pypi/threading2/)
This is why we shouldn't have languages that force us to catch exceptions when we *want* them to float up to a higher layer and catch with a more generic error handler. I'm looking at *YOU* Java. Defining 15 different types of exceptions in every "Throws" directive all the way up the stack makes Jack a dull boy.
Yes, definitely this... although I think a standard would be a good idea going forward.
 animal = zoo.get_animal() assert isinstance(animal, Animal) if hasmethods(animal, 'swim', 'retrieve_frisbee'): animal.play_fetch_near_lake(frisbee) elif hasmethods(animal, 'swim', 'dive'): animal.play_fetch_near_lake(ball_that_sinks) else: print 'your animal sux' This way you don't have to think which subclasses of animal can do what.
Neither is except AttributeError
And add the exception that a method might throw to it's declaration. Then change every method declaration if we decide it doesn't throw an exception anymore or throws a different kind of exception. And make everything a class. Then if we decide something is not an instance method we make it a static method. Then we decide to group a bunch of static methods in a class that's not meant to be instantiated, because all it's methods are static and there's no point instatiating objects from it. Then invent a shitload of patterns to add to the complexity. But no one can possibly know all those patterns so everyone uses the singleton in absence of a better idea. Then hire a bunch of consultants to tell you to use more patterns.
This fragment made it into the stdlib ( code.py / runcode ) try: exec code in self.locals except SystemExit: raise except: self.showtraceback() else: if softspace(sys.stdout, 0): print 
I didn't say except AttributeError, as I explained it is not a sufficient check. You have to catch pretty much all exceptions when calling code that might be buggy -- and report them appropriately or what not.
I really wouldn't want to see this code in production... What if it has a method "swim", but it has different semantics/signature than you expect?
Title should be ,,On bullshit''. tl;dr: Python is not a FP language, therefore should be ditched ASAP.
Call what? The proper way is independent of the language and goes as follows: you load all modules in your plugins directory, then go over all types defined in each and collect the types which implement your special IPlugin interface. These are the plugins, then you can instantiate them. Most of the other ways -- requiring plugin types to have specially formed names, requiring plugin modules to export only plugin types (and place dependencies in subdirectories), requiring a special 'main' method to return a list of defined plugins, reading the names of the types from a special configuration file, et cetera, et cetera, most of these ways are dirty hacks, inferior to The Way in all respects. I mentioned this particular problem to answer your question: when do you have a list of unknown objects and want to do something to some subset of them that have a certain interface. This is when, for example. There are numerous other times when you need that, basically everything that uses reflection solves some problem of that kind.
Hmm... I'm using list comprehensions a lot... And yield has become part of my standard toolset... According to the article my next discovery will be itertools. Anyone know a good itertools tutorial?
But you've noticed the "Utilities needed to emulate Python's interactive interpreter." docstring at the top of that file, right?
The documentation is pretty good (including a few examples): http://docs.python.org/library/itertools.html You could also wade through the authors posts to the Python mailing list: http://groups.google.com/group/comp.lang.python/search?q=hettinger+itertools
I believe the Charming Python series has a few good tutorials on itertools. Here's one: http://www.ibm.com/developerworks/linux/library/l-cpyiter.html
Aye, been reading the docs. Seems like itertools is pretty wonderful :)
Thanks!
Of course. I know what it is meant for. So before someone states a universal Newtonian law it might be worthwhile to check the conditions under which it's true.
AFAICT from a cursory look around the internet, it's currently not working on Windows with Python 2.6. :(
Advocacy and sophistry. One of Python's strengths is that it gives you good enough support for these things in a way that's also easy to integrate with OO style. I'd much rather live with allegedly crippled FP than have to try to wrap my head around whatever FP languages are doing to emulate OO these days. Go on, call me bigoted. The reason the Python devs don't like this, AFAICT, is that it exposes the "there should be preferably only one way to do it" idea for the myth it is. There is **always** more than one way to do it, and if you try **too** hard to press your way of doing things, you'll lose huge amounts of mindshare for your language. What you can (and should, and Python does) do as a language designer is make all the **obvious** ways work **cleanly**.
I guess you wouldn't want to see ABCs in production either, since the same problem an arise there. Duck typing is a tradeoff.
I always look to functional programming blogs for their modest, well-balanced musings. Glad to see this one doesn't fail ! /has been using itertools for years. no haskell here
I use itertools constantly, but I have been learning erlang, instead of his suggested clojure or F#. While functional languages are nifty, I find that they positively affect the patterns in my python code, rather than seduce me into a functional-based project.
Unless **deathforge** is writing the virus from *Office Space*. Protip: beware the mundane details.
pycon italia, in florence (http://www.pycon.it): if nothing else, for the location and the food :-) (no, it's not an italian-only conference, there is even a real time translation service)
Have you seen [pycon.org](http://www.pycon.org/)?
EuroPython should be good stuff, if you're doing web stuff EuroDjangocon should be good fun as well.
Itertools is really pretty simple. Main thing is to use it, to get a feel for it.
Yes, it actually made me think about going to EuroPython (in the end of July). Yet, I'm looking for more conferences and reasons to go or not to go. Also, maybe there are some good, related, conferences that are not listed on pycon.org.
Cool, the Italian part actually scared me a little, if it really is in English it would be a fantastic option.
Any idea when and where the 2010 conference would be?
Fosdem starts tomorrow, I think.
For EuroPython I don't know, but EuroDjangocon was just announced to be in Berlin, at the end of May: http://djangocon.eu/
I agree.. list/generator comprehensions and itertools have become good friends of mine and while I have run into some limitations, I haven't felt the urge to move onto a more functional language. I guess it's functional enough for my use and the other benefits (community, stdlib, 3rd party modules, etc) outweigh the limitations for me.
&gt; there should be preferably only one way to do it That’s not the Zen quote. It’s, “There should be one-- and preferably only one --**obvious** way to do it.” There’s always going to be more than one way to do it, but the point is that there should be an obvious way to do it. There shouldn’t be two obvious ways to do it, because that means you have two overlapping APIs/syntaxes for the same thing, with no clear reason to use one over the other. 
Indeed, I discovered `itertools` years ago, and I appreciate the ideas behind functional programming, but I still wouldn’t want to write my stuff in Haskell or any other functional language. The point of a programming language isn’t to maximize “purity,” it’s to get work done in a way that doesn’t break your brain. FP breaks the brain at every opportunity. 
I had a similar problem, and after looking at various existing options posted here, I ended up making something simple using optparse, Python dictionaries and `simplejson`: http://github.com/dbr/tvnamer/blob/master/tvnamer/main.py#L211 I've posted an explanation and a simple example on StackOverflow: http://stackoverflow.com/questions/1880404/using-a-file-to-store-optparse-arguments/2211056#2211056
Must destroy RUBY!!!!
Oh noes. Finally a Python convention in reachable distance and then it's Djangocon... :-/ Hooray for Pylons. *sob*
Real men analyze kernel core dumps looking for network buffers for fun and lack of profit
EuroDjangoCon was good fun last year, even if you weren't a Djangonaut. For example Armin Ronacher was there last year (and he even helped out with the sprints)!
I'm Dutch too. I always go to EuroPython. This year it'll be in Birmingham, UK (like last year). 
"Last commit: 18 Aug 2008"
Fair enough... The two good ideas are good ones though, I look forward to the next time you have to implement that and seeing the library that happens :)
This is rad, I'll be playing with this later. Thanks a ton! 
Author --&gt; http://www.reddit.com/user/mdipierro
I like it, It seems at first like it would be limiting (Access of frameworks) but it is not. Just edit in your favorite editor, VIM here and I use eric4 to debug in if necessary. It is under very active development docs fall behind. So subscribe to the list. The DAL is fine, just wasting time using SQLAlchemy with it.
We use it. Its good. The list is very responsive and there is a lot of examples. ([web2pyslices.com](http://www.web2pyslices.com/main/default/index))
Come to Marseille in May for DjangoCong http://rencontres.django-fr.org/ 
&gt; I know functional languages. I've learned Scheme, Erlang, have learned Haskell at least 4 times. XSLT is only a functional language in that it has functions. A language which has no lists and needs 6 lines just to setup a 1-arg noop recursive function is dysfunctional, as far as I'm concerned. It's a god damn piece of shit of a language, functional or not. It's even more sad if you considered the predecessor to XSL-(T &amp; FO): [DSSSL](http://en.wikipedia.org/wiki/DSSSL) was based on Scheme (see [some examples of the transform stage](http://www.jclark.com/dsssl/examples/transform/)). 
Hm, I'll put it in my calender then. :)
I'm going to repeat a comment i left in the Hacker News thread for the post: &gt;... &gt;Point the second: itertools is partly a catalyst, partly an indicator. Once you get fluent with it, it illuminates pain points. &gt; &gt;Point the third: There is a new batch of functional languages that support the style that is a pain point, as well as fixing other issues that hurt in python. &gt; &gt;Lastly, not all python programmers will want to make the shift. But the ones fluent with itertools are more likely to be the subset that will. 
Pylons and Django are, in of themselves, quite different and suitable for different tasks. I guess it depends what you're building and your personal style of development.
Well, I prefer duck typing over Java-style/C++-style typing, but indeed since I have discovered Haskell's type-classes, I don't like duck typing very much anymore (As there is a pain-free typed way to get the benefits of duck typing). And I would really prefer to see much less "isinstance" calls, which are still far better than "hasattr" or "hasmethods" calls. "hasmethods" doesn't tell you whether the method you're looking for actually exists, only if a method by that name, which may or may not do what you think. 
1.0 beta 1 without any significant changes? forgive me if im missing something
I'm currently at a point where I'm trying to decide between web2py and Django. When you say suitable for different tasks, what tasks to you mean for which?
I would call dropping all backwards compatible stuff not insignificant. I think it is good to note that 1.0 follows the style in the current Pylons book. It does NOT have any of the legacy (pre-0.9.7) features. While 0.10 and 1.0 are actually the same, the difference is that 1.0 has the legacy features removed where 0.10 has them deprecated. Please correct me if i'm wrong here. 
1.0 PYLONS is about cleanup mostly. A lot of changes were in other components like sqlalchemy, beaker, webhelpers etc. 
http://www.cubicweb.org/ is what you want :)
Well yes; but this, too, is pipe dream. People think differently, and will therefore consider different things obvious. (It may also be subjective whether or not something counts as a "different way" ;) )
No, you want MY web framework instead. It has full enterprise grade buzzword compliance. You can tell because it says so on the website.
[shields up, launch photon torpedo, boom!](http://web2py.com/examples/static/lcars.jpg) EDIT: db.define_table('photon_torpedo',Field('target')) @auth.requires(auth.user and auth.has_permission('destroy')) def launch(): return dict(new_torpedo=crud.create(db.photon_torpedo), launched_torpedos=db().select(db.photon_torpedo.ALL)) 
Excellent!
I've considered playing with it a few times to see if I can make use of it. But I've been really turned off by the documentation. I find the scribd manual is clumsy and a pain to navigate. I will honestly admit that it has stopped me from giving the framework a fair shake.
Same here. :-(
You should find most of what you need [here](http://www.web2py.com/examples/static/web2py_manual_cut.pdf), [here](http://www.web2py.com/examples/default/examples) and [here](http://www.web2py.com/examples/static/epydoc/index.html)
Fair enough.
psycopg2 has served me well, but the web pages *are* not clear.
I would guess it's a stick figure of a monkey -- the origin of the name "bobo".
I use a hacked version of [bpgsql](http://barryp.org/software/bpgsql/), hacked in that it returns a dictionary rather than a list of values and also that it works in Python3, I'm doing a few more things to it and will be feeding my changes back to the author. psycopg2 has never once installed for me, I don't know if I'm the problem or it is because it obviously works for others yet I'm quite able to install anything else such as PIL.
Glad to see an intrest in this and the recognition that the gpl is poisonous to a lot of commercial applications. Lgpl would be fine but full on gpl for a web backend is rediculous. Heres hoping for a solid pythonic standard in the near future
Really? There's a dozen projects that do pretty much the same thing and sometimes it's hard to know which is right for you? Welcome to the world of open source software. Enjoy your stay.
There's what appears to be a good pgsql driver in existence, but it is very strictly python 3 only (py-postgresql). If that weren't the case I would've ditched psycopg2 in a heartbeat. Psycopg2 "docs" suck if you need anything more than simple 'execute' functionality. The mailing list *is* useful, but you shouldn't have to go there for things every other project shows you in the docs. 
It's been almost exactly a year since 0.9.7 was released. Having used Pylons for almost three years, this is pretty cool news.
This is anti-python ("one right way to do it"). Unfortunately, there is a lot of abuse in the community duplicating modules, frameworks, implementations, etc.
&gt; full on gpl for a web backend is rediculous Why exactly?
I disagree. The "one right way to do it" mantra refers to coding style and conventions, not to an entire application design. You might as well say that there ought to be only "one true" Python-based MVC framework. Different strokes for different folks, man. And "abuse" is a quite a stretch. People create something because the existing solutions (to them) are inadequate. They then release them in event that someone else finds them useful too. There's no abuse going on. If you don't like a project, then don't use it.
I've been using pyPgSQL for a couple of years now with good results.
thank you, thank you, thank you.
Distributing a GPL driver with a BSD database and BSD programming language can be a headache. It's not insurmountable, not by a long shot, it's just annoying. It strikes me that the best solution to this mess would be to LGPL (or even BSD) license `psycopg2` and semi-canonicalize it (e.g., with a new homepage somewhere on postgresql.org, and some bloody documentation for once).
anyone who makes a website will need to release the source code? while releasing code doesn't matter for a company with a solid user base, releasing your code just to have someone else run with your idea sucks. it's nice to get a few years under your belt before you pull the rug out.
Are you confusing the AGPL with the GPL? you don't have to release your backend code for a website.
I've never used web2py but just wasted some idle time browsing the code. In general, I find the tightly-coupled architecture distasteful and the code to have that hacky, organic feel that comes from too many additions and not enough refactoring. Some specific reasons I would never consider using it include this: except: ### this should never happen but happens in Windows pass Don't even log it? And this: arg0 = request.args(0) if arg0 == 'run': return self.serve_run(request.args[1:]) elif arg0 == 'rss': return self.serve_rss(request.args[1:]) elif arg0 == 'csv': return self.serve_csv(request.args[1:]) elif arg0 == 'xml': return self.serve_xml(request.args[1:]) elif arg0 == 'json': return self.serve_json(request.args[1:]) Ugly; never heard of a dictionary? And this: def _drop(self, mode = None): t = self._tablename c = mode or '' if self._db._dbname in ['oracle']: return ['DROP TABLE %s %s;' % (t, c), 'DROP SEQUENCE %s_sequence;' % t] elif self._db._dbname == 'firebird': return ['DROP TABLE %s %s;' % (t, c), 'DROP GENERATOR GENID_%s;' % t] elif self._db._dbname == 'mysql': # breaks db integrity but without this mysql does not drop table return ['SET FOREIGN_KEY_CHECKS=0;','DROP TABLE %s;' % t,'SET FOREIGN_KEY_CHECKS=1;'] return ['DROP TABLE %s;' % t] Suggests an awful design (how about making this a method of the DB interface?) and, based on the comment, an intense lack of interest in data integrity. And the existence of these: * [gluon/compileapp.py](http://code.google.com/p/web2py/source/browse/gluon/compileapp.py) * [gluon/import_all.py](http://code.google.com/p/web2py/source/browse/gluon/import_all.py) Just... no. If you have no intention of looking inside the sausage factory then this might not be a problem for you -- it doesn't matter if it's ugly as long as it works, right? (In my experience, this is actually what "enterprise" means. Make sure you get a support contract.)
This is the kind of insight I was looking for. The high level idea of the framework is appealing but the implementation is off. Guess it's time to take another look at Pylons.
Sorry, but having more than two active low level Postgres drivers is stupid. Two because the first might be GPL and Postgres might want a BSD stack to include with the distribution. There needs to be a point where people say, "this old code or method was bad. Let us congregate on this new and improved stack and deprecate the old" -- Otherwise you end up with CPAN.
I very much appreciate your post because it gives very specific points and gives me an opportunity to respond. * You are right. There are a few catch all. Usually it is to avoid unnecessary ugliness. Anyway, we are working on trying to eliminate them all. That error does not need to be logged. * Out implementation is easier to read and faster than the one you suggest. We would use dict if more options. We do it in some places. * You are looking into sql.py. The file dal.py is a complete rewrite that does what you suggest. sql.py is still there because it is faster and has been tested by a lot of people. If will disappear completely when we will be confident that dal.py is as solid. * You do not know what those two files are for. I do not have time here but I will just comment on import_all.py. The purpose of this file is twofold: a) force py2exe to package all python modules when building executables (if you know of any other way please let us know); b) force web2py to import all modules at start-up and check dependencies so that when visitors call an action that import a module that should be there but is not they do not get a slowdown (in reading the moment at that time) and they do not get surprises (errors due to lack of required module). You can find similar code if you cherry pick lines that you do not understand among many into the source code of any software project. For people who need it, the web2py site lists some companies willing provide support contracts.
I'm guessing that you've never contributed to open source projects? Things just don't work that way; as I alluded to in my OP. How do you propose that we'll implore upon people that there is only one right way? You might as well heard cats. 
In fact, I'm ashamed to admit I am responsible for a fork (though not really - its a commercial testing ground for code that eventually goes up stream). This is community building 101. If some group thinks they have the better solution, email the other maintainers and try to get them on board. Barring that, hopefully the wider community selects one and sticks to it. ..Even at the risk of technical inferiority. Then we can all expect one deployment platform and not build abstraction upon abstraction. Again, I'm sorry, but I just don't see the need for multiple *low level* Postgre drivers. High level DB APIs, sure: there are different trains of thought, but the low level interface? At most two and I'd hope the vendor supplied one was the only one seriously used and contributed to.
&gt; if you know of any other way please let us know It seems like the kind of thing that, if you have to do it at all, you're doing it wrong. Along with `appcompile.py`, it's obviously there to support an architectural decision that I vehemently disagree with. &gt; You can find similar code if you cherry pick lines that you do not understand among many into the source code of any software project. Yes indeedy, but it's always a strike against when thare are no comments to explain the purpose of the "magic". Inscrutability isn't a feature.
I assume the architectural decision you refer to is the decision to execute and not import models and controllers. Of course there are pros and cons of this decision and that is the most distinctive feature of web2py (since no other python framework does it that way). This decision is not an oversight but it was carefully pondered. It is because of this design decision that we argue web2py is easier to use and tomanage than other python frameworks. I guess there is some magic in web2py and we take that as a compliment. magic does not mean inscrutable. we have about 50 core developers and 1600 registered users. They understand it and are happy with it. I have worked with other web framework and I find their source code more inscrutable then web2py's. Actually, web2py source code is very easy to maintain because it is very compact compared with more popular frameworks and it do not relay on any third party libraries (except a couple of modules included with it).
That is your call but consider everybody is biased here. You should look at the source code of web2py, pylons and django yourself and figure out which one you understand or looks better to you. Let me give you a practical example. The web2py DAL supports 9 RDBS and does so in a single file of 142KB. It provides [very similar functionality as SQLAlchemy](http://www.web2py.com/AlterEgo/default/show/150) (others will disagree but you should check it yourself). SQLAlchemy consists of 65 files and 1.7MB (only *.py, not including tests and examples). Which one do you think is easier to read and maintain? Which one do you think is faster? Again, check it yourself. EDIT: before somebody feels offended... SQLALchemy is excellent and as an ORM it is better than web2py's. Specifically it has much better support for legacy databases. It is just that web2py's DAL is integrated with the framework better than SQLAlchemy is integrated in Pylons and that is its major strength. This tight integration is what some people do not seem to understand and refer to as "magic". You can use web2py components separately (the dal, the template, validators, etc) but they were really designed to work together.
Considering he's shelling out for a lot of that, and it's pretty easy to do what he's doing manually or via a batch/reg file, I think Python is a bit overkill. *If you only have a hammer...*
your mom is a pattern!
psycopg2 is in C, pg8000 is pure python, pypostgresql is in C. pypostgresql and pg8000 run on py3k, psycopg2 doesn't. psycopg2 also includes other extensions to the DBAPI that might be handy. Can you see why someone might want to make a choice here ?
&gt; SQLAlchemy consists of 65 files and 1.7MB (only *.py, not including tests and examples). Which one do you think is easier to read and maintain? Which one do you think is faster? Again, check it yourself. I was not going to get involved here, but since you mention us, SQLAlchemy is definitely easier to maintain (and to read, if one is familiar with larger-scale architectural design techniques). We can add support for new databases and DBAPIs with no modifications to core code. 3rd parties can add their own DBAPI/database adapters without having to bother me at all. The same goes for all kinds of expression constructs and ORM features - there's no central rats nest of linkages to rewrite every time something new needs to be supported. There *is* a reason applications with comprehensive featuresets and deeply tested behavioral contracts are larger and more abstracted than those without.
I've always been productive at web development. I started doing it in perl years ago. Then switched to python and my productivity went way up. Then, last year, I discovered web2py and never looked back. By my measure, web2py has improved my productivity 5 to 10x. I have not used Django or Ruby or any other framework because none of them were consistent enough. Web2py is wonderful because of its simplicity, consistency and performance. Forget the sausage factory. Try the end product. You'll like it.
I argue that it's not overkill in the slightest. If python can do it, why not use it if that's what you like and are comfortable with. The beauty of python is that it can be used however you want. It Can be a batch language, oo, procedural, whatever you want it to be. In fact I just happened to be wondering how to do such a thing because I wanted to create a game for my baby girl that would allow her to smash the keyboard all she wanted and show colors/shapes on screen and then revert the changes after program close. Python isn't just a hammer, it's a Swiss army knife, chainsaw, hammer, nail, and building material all in one nice little package
Do the web pages even exist?
&gt; Places like Debian and Apple move very slowly. Not as slowly as you let on. Snow Leopard, released in August of last year, ships with 2.6.1.
I am sure that is true and I said myself that "as an ORM [SQLAlchemy] is better than web2py's". I did not make an absolute statement but a relative one. I did not say SQLAlchemy is not easy to maintain. I just said web2py's DAL is much smaller (12x smaller) and, as far as web development goes, has very similar functionality. Given these facts it is ludicrous to accuse web2py of being a "sausage factory". In fact it was originally designed so that it could be taught to students (that is what I do for a living, I teach computer science). Anyway, web2py too is very modular (one module does Database Astraction Layer, one handles templates, one implements html helpers, one does form generation and processing, one defines validators, one does syntax highlighting, one traps and reports errors, ..., two modules, compileapp and main, put everything together). I did not bring up SQLAlchemy either, it was in the question that opened this thread.
Agreed. I'm a Unix Admin who has had to work on Windows a lot more lately. I know Python the best and tend to use that for scripting on Windows rather than batch, etc.
I'm usually all for re-using the same toolset as much as possible (rather than having a million different *overlapping* toolsets). But.. playing devil's advocate: &gt; why not use it if that's what you like and are comfortable with The extra dependencies?
Well, the last script didn't work. Line groups = NetUserGetGroups(pdcName,userid) fetches me an error.
PostgreSQL has this problem where other databases do not. Well... mostly everyone uses psycopg, but for licensing reasons people occasionally make other attempts, and pure-Python drivers have their own appeal (I believe people have tried that with MySQL too). This case is mostly just annoying, because a database adapter that uses the standard DBAPI and isn't buggy is all anyone really needs. There's not really a lot of room for novelty for this particular kind of library.
A whole 12mb of dependencies? That's including python + pywin32. When XP itself takes up 700mb on a minimal install? Why complain? How large of a download is Windows Powershell?
Installing it does take time and effort
So does writing a batch script or changing the settings by hand. Or even **best case scenario** hunting down the .reg file and then making sure that .reg file isn't changing some security setting maliciously.
&gt; Given these facts it is ludicrous to accuse web2py of being a "sausage factory". If you're not familiar with the phrase "not looking inside the sausage factory", it just means that you can consume something (e.g. delicious sausages) without thinking about what's inside or where it came from (meat offcuts swept from a slaughterhouse floor). In the context above it wasn't an insult, just saying that you can use software [web2py] without caring about its internals or development.
If your intent is to develop web applications then web2py is an excellent choice. If your intent is to learn more about Python web frameworks then I would go with something else. Magic is not a bad thing. It just keeps you from typing the same thing over and over. 
I did not know about that. I admit I had misunderstood.
OS X was using 2.3 for something like 6 years. Not what I would call a zippy upgrade policy ;-) Leopard moving to 2.5 was one of the things that allowed us to finally drop 2.3 support.
That's really very cool. Can anyone explain why it's so slow and unresponsive? Is this simply a limitation of pygame and python or is it an optimization issue with code itself? I've been researching pygame recently to make a simple pinball type game but I'd hate to go down the rabbit hole and find it unfeasible later after writing tons of code. edit: so unclear why someone would downvote a legitimate question... if my question is stupid at least have the balls to explain why it's stupid.
And as ConfigObj subclasses dict it *may* even be usable directly.
Close, it was more along the lines of "no, you can't have a pony"
It's most likely due to the whole screen reblitting all the time, that is very slow indeed. You'd be better of using C++ and SFML for something you want lots of people to be able to play without performance issues. Needless to say, Python is a fine choice for learning.
The problem is simple. He makes all an sprite and test collides in each event loop. Bigger maps are less responsive because he's testing if Mario touch the final flag from first time. Ordering the sprites for x axis in a tree and testing only a range the game will be very responsive. More info with a [profiler](http://code.google.com/p/jrfonseca/wiki/Gprof2Dot). But use cProfile, not profile.
That's pretty impressive. Well done.
[This is it -- no joke](http://initd.org/). No updates in 3 years.
DB-API is a minimal, lowest common denominator API. The various Python Postgresql drivers add whatever extensions are important to the authors, so that indicates there is plenty of room for novelty. [Here](http://wiki.postgresql.org/wiki/Python_PostgreSQL_Driver_TODO) is a recent attempt at a wish list. Edit: see [this](http://www.reddit.com/r/programming/comments/953m1/python_postgresql_driver_authors_hate_you/) for a good facepalm.
Yes, that happens a lot. This case is noteworthy, because there is one widely used and solid Perl/Postgres driver. Ditto for Python/MySQL. The Python/Postgres driver situation is now considered sub-par enough that people are discussing how to scratch this itch. 
mdipierro, those numbers sound really low to someone on the outside -- someone who doesn't consider the project their baby. It would be nice to get Pythonic web development out to the masses.. PHP scale.. because I think your framework solves a lot of problems that are all too common in web development: **security**, CRUD, authentication/authorization, and MVC design. Naturally, the question is how to do that :-). Some ideas from my head: * Don't alienate experienced devs for the sake of newbies. The import thing really has to go for web3py. You're going to put off a lot of contributors for the sake of giving newbies magic * Make your documentation free and public. The book is fantastic (I bought it), but if you really want your baby to see wide use you need this out in the public. It will pay off monetarily and other ways in the long run to have a large number of users rather than the small kickback from selling a necessary book. * Related to the import thing, don't assume everyone wants to develop their web apps from the web interface. Some of us have strong IDE preferences for better or worse. To claim "enterprise" status, you need to accept that. * Don't confuse magic with ease of use or robustness. You can have both, but sometimes it takes hard lessons. Prematurely locking down compatibility is a **weakness** in my eyes, even if I have to refactor my apps. Just some food for thought. I will be following your project and making toy apps in it while I experiment with some of the other Python web frameworks. I can't stress and praise you enough, I think you are on to something here, but there are some things you need to address if you want to make it big time.
Pygame calls into a pre-compiled and written-in-a-low-level-language DLL for the heavy lifting (e.g. blitting). That's not going to be the bottleneck, or at least it won't be something with much room for optimization.
Where could we get the newer version?
maybe we should ask When instead of Where :)
EuroPython 2010 will be in Birmingham. Get all the key facts from http://www.europython.eu/
[From PyGame's tutorial](http://www.pygame.org/docs/tut/newbieguide.html) &gt;There are two cases where this technique just won't work. The first is where the whole window or screen really is being updated every frame - think of a smooth-scrolling engine like an overhead real-time strategy game or a side-scroller. So what do you do in this case? Well, the short answer is - **don't write this kind of game in pygame**. The long answer is to scroll in steps of several pixels at a time; don't try to make scrolling perfectly smooth. Your player will appreciate a game that scrolls quickly, and won't notice the background jumping along too much. 
I see the website changed. Still a bit lacking on contents though. I'll be keeping an eye on this.
Headers are too big and overflow into the main text under FF3.0/Linux. It's not obvious which days in the advent/calendar thingie are actually clickable. Various links lead to weird places, like the «articles» link that goes to the frontpage - sure the frontpage has links to the articles, but then what's the point of the link? Overall, the site gives a bit of a «messy» impression. Nothing major, but I hope they tweak the site a bit more before moving on with it.
I think everything will be up for discussion in web3py (when it happens) and your input is very much appreciated. I will do what I can about the book. I agree with most of what you say. The exec(noimport) issue is really under-appreciated (;-). For example [this](http://groups.google.com/group/web2py/browse_thread/thread/dcbb1b8ee8fde952) would not be possible without it.
I agree with you. Web2py has always come off as "Hey look! We have X just like Y does!" immitation and not enough innovation. EDIT: SYNERGY!!!
dogg, aint u a professor? 
This is a personal project that I programmed for myself and I've just released it in case anyone else finds it useful. I have tested it on a windows machine and on a couple of linux machines (one is the server on my LAN where I am running it). I am open to answer any questions. The code is a bit long. I am actually using several different files and I've made a 'packer' to release it as a single file (in two versions), for ease of use.
Hiya mate, tried to run the new version in me ubuntu like, and ran into a few snags. * Filenames: rename data/hill.PNG : should be hill.png * gamelib/game.py line 184 should read "castle.png", not "Castle.png" * Head-butting the [?] bricks doesn't do anything. Ahhhh I need me mushroom?! * Sound lags: when jump, when dies (music continues), or when jumping on the flag (that took some time! :) I'll update this comment if I find anything else... but probably not, judging by how fast I'm drinking through this Patrimonio Corsican wine... nice stuff, but fuck me, it's only Monday :-) Edit... format, sound
Not quite what you're searching but we have built [internally](http://www.gamr7.com) something like traits... It is a really good idea and not that hard to implement. 
Yeah, that's my idea. There's a lot I like about traits, but I'm trying to decide whether to reimplement something myself, or whether to just go with traits. Thus far, I'm leaning toward using traits. Thanks for replying.
Awesome. The cython version is interesting too. And less clever people like me can write it ;-)
I've seen this software in Ubuntu's package repo and wondered what it's all about. I'm curious, too, whether anyone's used it and how well it worked.
Sounds like a winner, exactly what you may have wanted to make Python more resilient, robust and event-driven without having to write plumbing and boilerplate code.
It's very similar to another web design advent blog, can't remember the address.
Very nice work. I love that you took the time to pack it into a single file that unpacks on first use. I'm currently running/testing it on my home machine, haven't run into anything crazy yet ;)
Thanks. Have you checked the copy-paste feature? You can select text and images on a page and then paste them into the wiki (on the bottom box). Kind of google notebook. It locally retrieves copies of the images. I find it useful to save these pages full of equations rendered as gifs or pngs. I was using google notebook before this but google decided to stop its development (more than a year ago) and I am thinking they may just drop it completely any time.
Or maybe proprietary software is poisonous to free software, it's all a matter of perspective.
I like the way they approached the problem of making python web development more accessible to newcomers, especially people coming from the PHP world. Not that I found it useful myself, and I don't think it's the right approach to learning Python, but I've heard lots of complaints about every python tutorial starting with a terminal window. So people who find CLIs frightening and want to jump in web development with Python have an alternative. I like the way they approached the problem of making it easy for people to compile redistributable bundles of a web application. And the points I like about it stop right there. I'm not sure if calling it the Access of web frameworks does it justice. When I hear the word MS Access it immediately rings Unscalable Half Assed RDBMS. I don't know how web2py scales, I don't think its a half-assed web framework. But I think avoiding explicit imports is a sin. Using names like ALL etc when they don't refer to a constant is pissing on pep 8 which is a sin that should be right up there with the ones passed to Moses. And I immediately close the tab when I see the dreaded scribd widged.
Nice work. Thaks for that. This is something I am going to use right now. I will let you know if I find any bugs or issues.
In my experience, Traits is great to write relatively simple applications -- if you have a couple models, you know how they interact, and you want to write event driven programs, it's easy and straightforward. I ran into problems when I wanted to move beyond the paradigm of editing models and into a full application -- setting up the windows, more complicated GUI presentation and so on. It's all possible, but I found the documentation (at the time I did this) for the pyface module to be a bit lacking. However, lots of people have done it, and made some amazing applications, so don't let my troubles inform you too much. As for the python dependency aspect, this is something that concerned me as well. The software I wrote the traits code for was to be deployed in both desktop and server settings, and I found that in order to keep it working on both sides, I mostly had to keep the traits code out of the guts of the main codebase -- which worked just fine, but required me to write shell classes that manipulated the underlying objects indirectly. The Enthought Tool Suite as a whole can be a heavy dependency (particularly with VTK), but the TraitsUI code itself is not bad.
Thanks. I've been playing with it for a day or so, and this is largely my conclusion.
There are some nice ideas put to work here. I would think getters and validating setters are commonly used design patterns, and notifications sent by setters are a good use of the messaging pattern.
I'm not sure I understand this question. But, the pypy toolchain can be used for implementation of various front-ends and back-ends. I believe there are example JS, prolog, smalltalk and other front-ends available. There are also various back-ends such as LLVM (not supported now?), .NET, Java, C, etc.
I'd love to experiment with this. Does anyone know of a cheap entry-level multitouch display?
I have the [hp lt2105](http://h10010.www1.hp.com/wwpc/us/en/sm/WF05a/382087-382087-64283-3181050-3181048-4031739.html). I'm not sure what you mean by cheap, but its a big multitouch screen for a reasonable price. I have it, and I love it. I have been meaning to experiment with PyMT since I found out about it just a few weeks ago, but I haven't had the opportunity. If I remember it is really just a MT toolkit for pyglet, and I really enjoyed some earlier work I did with that. I love touch interfaces, I know a lot of people don't quite see the draw, and thats fine, but it feels so much more natural for me to interact "directly" with objects on my screen. All that being said, I am not a good programmer at all so I am really excited to see what other people do with this. 
Admirable alliteration.
I switched back to 1.3 a few weeks ago due to compatibility issues. Surprised it took them so long to finally pull it.
-1 for CC BY-NC-SA. Why NC?
Should people who are scared of a terminal window even be allowed near Python web development ? Agree on all other points though, and web2py code reviews by people who do know what they are doing scare me away.
I know people who came to Python from PHP or .Net and when they start getting into the language they say they avoided it because every tutorial and book on Python involved the CLI. So scared was probably not the right term to use there. I think I know what code reviews you are talking about. While all of them may be true I'd take all of them with a grain of salt. Some people in the python community (especially people behind some well-known projects) show some kind of strange animosity towards web2py.
Being a Pylons fan, you seem a good candidate for Django. It's not very flexible but OTOH you'll get quickly started and get a free admin interface along the way.
Try Django. The admin interface will save you tons of work.
I cannot recommend [this tutorial](http://genshi.edgewall.org/wiki/GenshiTutorial) enough. When you're eventually deploying, then [see this guide](http://cherrypy.org/wiki/ModPython).
Second Django, it has great documentation. [Start Here](http://docs.djangoproject.com/en/1.1/intro/overview/#intro-overview)
ugh. genshi is slow, and mod_python is not a recommended way of deploying python web apps.
great example of how trying to fit everything into a single file always makes a mess.
3rd Django...
Genshi is **not** slow compared to any other XML-based templating system. And there are other ways of deploying if you want them.
it is slow compared to *all* templating systems (as in if you include non-XML ones in the comparision). And the guide link provided is about mod_python, which really sucks and should never be used.
Why would you compare it to *all* templating systems? They're not comparable. They're designed for different things.
Look, do some research first. We have this **same discussion** every week. It goes like this- *Django*, **no Pylons**, no Web2Py. First read the archives and you'll see the discussion rehashed out; this is a [specific application](http://www.reddit.com/r/Python/comments/av2r8/creating_school_library_website_best_way/), but generally applies to your question. This discussion will be a lot more productive if once you've done a little research come back with some questions on about the finer points between framework selection. *That being said..* As others have mentioned Django is great. You may also want to look at [Web2Py.](http://web2py.com/). I've been playing around with it recently and have been extremely impressed. You can get up and developing quickly; I'm sure the main [author/evangelist/researcher mdipierro](http://www.reddit.com/user/mdipierro) of the project will chime in here shortly.
django gone to the highest bidder...
Not flexible?
All XML templating systems are slow.
It sounds like a small project. I'd do it in php. Not because I don't like django or python, but because you will likely be faster in php. The added complexity of a framework is not worth it for such small tasks. you can just code up the script and drop it in www and bam, that's your deployment. Now Django isn't hard to deploy either, but it's much more involved than PHP.
Care to explain why Pylons would be inadequate?
Why not?
Response: Try Django. Its great! :) 1) It's great for quick development (altho it took me a while to learn) 2) Great documentation 3) It has a weird name that sounds as cool as "Python"
Despite all efforts it's still one of the closest coupled web frameworks for Python. It's totally okay, as it enables certain features and simplicity (that's why I suggested it), but yet it's there. for example, you can't just start using a different ORM and expect everything work as usual. 
It's true, you could do this in PHP very quickly (especially if you're already familiar with the language). In reading the description carefully though, this is almost the perfect project for a relatively unmodified Django install. Just work through the tutorial and you are pretty much done, if I understand what you're trying to do.
&gt; Then thought of the stupidly obvious and googled within reddit. Can't really blame you, rarely is a site search as broken as reddit's.
I'm looking at bottle right now and it looks clean and simple. @OP - seriously ... take a look at this framework. You can get started right away and deployment seems very easy. 
I didn't. Perhaps I wasn't as clear in my posting or you just misread my post. When I said "It goes like this- Django, no Pylons, no Web2Py." That was intended to represent the general arguments around Python framework selection. It was intended to read like this: **Background:** *On a dark and stormy sub-reddit 3 dastardly internet scallions argue their choice of web framework. The discussion has descended so far down the thread, continued long after the thread was still being read by the general community, and had been down voted far past most filters. While the outcome of their argument concerned no one else- the original thread poster included.. yet they continued.* **DjangoRiffic:** Choose Django for your framework. **PylonDude:** no Pylons **GigaWeb2Py:** no Web2Py Reasonably, there's a good chance that English is not your first language. If so I apologize kind sir and have a wonderful day/night/evening/morning. :)
&gt; They're designed for different things. Like.. generating html from a mixup of html tags and instructions? 
You should have written it "Django. No, Pylons. No, Web2Py". I was confused as well and English is my first language.
Man, English is my first language and I still didn't get it. I do now though, makes sense now you explained it.
I thought you were actually agreeing with that statement because, like you stated, it's always advised to go with Django. Just a small misunderstanding. I appreciate the detailed explanation though. :)
Like I said, perhaps I wasn't very clear in my post. In my head, it made perfect sense.
No, Pylons.
No, Web2Py.
I was going to write the same comment. I don't know why people are down voting you. I'm very heavy into Pylons development. I've used it for almost three years. I really like it because it's extremely flexible and powerful (Reddit is probably the world's most used Pylons app, serving 200M+ pageviews/month). But Pylons is likely to be more frustrating than necessary for an absolute beginner. "Flexibility", by definition, means that you have a lot of choices and a lot of choices can be overwhelming for newbies. Django was the first Python-based MVC framework to really gain much traction. It was developed by a small team who came from the world of newspaper publishing. As such, it's really nice if you're writing an online publishing app, but can feel a bit constrained if you get far enough outside that realm. But the documentation is better than Pylons and, except for the zealots you'll find in any FOSS project, the community is great (not to say that Pylons doesn't have a great community too, it's just smaller).
Well I guess I get down voted by Pylons fans because I suggest Django and by Django fans because I called it less flexible. ;)
It might be faster to initially write it in PHP. But he'll learn more by doing it in Python. IMHO, that's a better long-term investment in skill development. The world already has enough PHP flunkies.
www.DjangoBook.com will be your BEST friend.
With databrowse, he might not even need any work.
Lots of discussion on what to do next. (I found out that Gmail starts a new thread after 100 messages during all of it, in fact!) 
Because NC makes the software Non Free and not Open Source.
I just started a similar size project and I've decided to use cherrypy and genshi
Yeah, seconded. It sounded to me as if he was cautioning people against those frameworks.
I used bottle for [this](http://imdbapi.poromenos.org/), and, while it was great to develop with, I get stupid "a transaction is open and needs to be rolled back" errors with the site, making it crash until I restart it. The weirdest thing? **I don't do any writes to the DB!** I don't know if this is a bottle or SQLAlchemy error, but I'd use Django with an sqlite DB for my next pet project. I would, however, recommend bottle if not for this crippling error.
I hear you there, but after a certain point, you end up writing SQL anyway for reasonable applications. 
You know, though, it's not as much as it's coupled as that it's integrated. I can't imagine decoupling it without breaking the integration. If you foresee that your app will not fit this model, you might want to use web2py or bottle or something, but if you think Django suits you you will save loads of time with how well the parts integrate together.
If you use a microframework like bottle or web2py (I assume, never tried the second one), it's even simpler than PHP. You just write your decorators for URLs, write the function and return whatever you want. No deployment hassles or anything, just a single file. I agree that Django is a bit of a deployment hassle for small apps.
I don't see how the long term skill development depends on the language. Bad coders will fuck up with python too.
"The most important feature addition in 1.2 is an "imperative" configuration mode. This implies: A repoze.bfg application can now be contained within a single Python file." This is THE killer feature. 
You know, I would be far more willing to look into this if they weren't forcing me on the front page to view a video to understand the thing instead of giving a quick text overview. I don't have time to be forced to watch videos for things I am not sure I might even need because there is no feature list on the front page. 
I'd be far more willing to look into this if the framework had a permissive license.
You mean it's been in beta this whole time I've been eating it? No wonder it didn't taste any good without the PeanutButter 2.5 patch.
awesome news, congrats
Actually from what I heard, ZPT (zope.pagetemplate) is faster than Genshi. But Chameleon is faster than ZPT, and you'd think it's faster than Genshi too then. I don't know how Chameleon's performance compares to the text-based templating systems. I'll note that I personally only rarely run into the case where the template language is the performance bottleneck of a system. There are typically other areas to optimize if a system is slow. Premature optimization and all that. 
Because you need to get author to relicense it for commercial use? If not, then why? Or do you mean that it's not FSF/OSI approved?
why the downvote? Just as the auto admin allows a djangoist to have a CRUD interface at almost no cost, databrowse exists to make it trivial to browse the stored data. That fits the requirements pretty well, and given databrowse comes with its own templates the only thing left to do is define the models. Not exactly huge work (if any)
A Python web framework thread ? Is it that time of the week again ? EDIT: as it seems to be, I'll recommend (as have others here) that you look at Django first because it's the most newbie-friendly and and has most support in terms of documentation and community. Also look at virtualenv, supervisord and fabric for your deployment needs regardless of framework. Read up on the WSGI spec and then look at mod_wsgi as you are already familiar with Apache. Whether you are going with Django or some other framework, do learn some Python first; a lot of Django projects I see nowadays through work suffer from Python noobisms and it's getting annoying. A lot of people here like Pylons; I prefer it to Django, but my favourite stack is a custom build of Werkzeug+SQLAlchemy+Jinja2. Try these out when you have a bit more experience under your belt and you want some more flexibility.
That's exactly what I wrote. ;)
Actually, only XML templating systems that parse the XML at render time are slow. XML templating systems that read the XML once and turn it into Python (which is then used for each rendering thereafter) are quite fast.
Just wanted to throw out grats to the whole team! I have been using and contributing to this project for well over a year now, and it is simply fantastic. For those who don't know, it was originally based on Pyglet, but really outgrew it very quickly...now they have a custom-written backend that I believe runs on top of PyOpenGL for more direct access to the graphics system.
False.
Er.. isn't mod_python what Django recommends by default, or did they stop doing that?
No, like Genshi might be a better choice when working with designers. Key word is *might*--it really depends on the situation. And, as faassen noted above, templates are rarely the bottleneck.
I welcome the idea of automating the creation of GUI controls from a model. I fail to see why one would need to use anything related to SQL and/or databases, even less TWO wrappers on top of that. Couldn't that be simplified? Model -&gt; Transform -&gt; GUI code for Toolkit X?
That's correct. This also had the effect of dropping the lines of code in Pylons from about 1400, to about 850 lines. So the core framework is now under 1k LoC.
So you want them to develop it and then give it to you for free so you can sell it? It bothers you that they wont offer up their time and effort for your profit? That's an interesting position to take.
Forget all those Django, TurboGears, Web2Py, Pylons arguments, Grok is where it's at ... Why Grok? * Schema and model are not tightly coupled: use objects from Zope Object Database, LDAP, SQLAlchemy, Web services, etc. and be able to auto-generate forms regardless of the persistence implementation. * Convention-over-configuration: Introspects your code, so that you get the benefits of succinct, less-typing benefits convention, without forcing you to layout your software orthogonal to it's purpose. e.g. doesn't force "models" into a models module, "views" into a views module, if you have a Book model and Book view, you can put them in the same book.py file. * Well packaged (mostly, Grok 1.1 provides a lot of fixes to the dependency tree), so easier to manage deployments. Also core parts are individually packaged, so re-useable outside of Grok (primarily of interest to Plone developers). * Caveman are way tougher than Ponies! 
use phpmyadmin
reddit has search? I didn't know that. I thought that search box was like the close door button on an elevator. It doesn't do anything (useful). It's just there to make you feel comfortable.
I don't want them to do anything exactly. I'm just saying I don't find it useful with the license it has. I don't see myself developing a database backed desktop application under the GPL. I find Django (BSD) and Twisted (MIT) useful. I also spend some of my time contributing to the projects I find useful in various ways.
I've tried to use this numerous times - everytime I enter cyclic dependency hell. Camelot required something of a specific version but another dependency required that original dependency to be of a different version. I want to say it was a melting pot of Camelot, SQLAlchemy, SQLAlchemy Migrate and Elixir ruining my day. I'll have to give it another go soon, see if the issue has been straightened out.
If I could abolish anything from the planet it would be celery. Like, before poverty and disease.
It looks interesting, but can someone share a real-world implementation example? I'm trying to figure out when something like this would be useful.
Because PHP isn't a programming language. It's a simply a half-assed collection of functions. It's why you have "strrpos", but "str_split" and why OO features were very late to the game and are clumsy to use. I could go on and on why I detest PHP. A craftsman is only as good as his tools.
In a web context it's useful any time you want to do something that takes longer than a user would be willing to wait for their page to load. For example we use it in our contact importer. User says "import my google contacts" we throw a job into celery to do that, and then return a message to the user saying their contacts will be loaded momentarily.
What are you using for your documentation? Looks great.
&gt; Created using Sphinx 0.6.4
"Forget all those Django, TurboGears, Web2Py, Pylons arguments, Grok is where it's at" no way bfg is the bee knees. :) Though I am fond of grok for some things. And actually your first bullet point has me intrigued.
Er, that's sqlalchemy. Funny you couldn't identify that despite knowing it came from the DB. Sorry about the jab -- I've had the same error, and it was part of the reason I finally ditched SA forever. Try reading the docs on flush, commit, autoflush and autocommit and telling me what they mean!
&gt; A craftsman is only as good as his tools. The phrase is actually "a poor tradesman always blames his tools". Not that I disagree that PHP sucks, but those who complain the loudest often write terribly in whatever language is hot this week.
Decoupling model from schema in Zope is done with zope.interface and zope.schema. If you're using BFG, you can probably fit in a form generation package from Zope-land (zope.formlib or z3c.form) which works with that. In Grok, zope.formlib is the default form generation toolkit. zope.schema is a pretty brilliant package. It extends interfaces, which only allow you to describe a set of method signatures and attributes, to also provide additional details about those attribtues. So instead of just saying, "Objects of IFoo have attributes a and b" you can say, "Objects of IFoo have attributes of a, which is a TextLine field, and b, which is an Integer field." This is pretty similar to declaring Fields for Models in Django. But Django only allows you to use those descriptions for classes which inhert from the django.models.Model class. But it's useful for any Python object to be able to be decorated with metadata about the fields it provides. It shouldn't matter if the object inherits from the Zope persistance class, the Django ORM, SQL Alchemy, or even it's a persistant at all. It's useful to use that formal schema descriptions for command-line inputs and web services for example. Any Python object can be marked-up with zope.schema, regardless of what the implementation classes are that compose that object. And Grok's default form library understands that metadata, so you can pull data from LDAP, declare the schema that the object provides (either via a simple LDAP fields to zope.schema fields mapping implementation, or just hard-coding it if only dealing with one or two types of models). 
Thanks for the kind words! Cavemen don't get involved in silly arguments, ME GROK SMASH WITH CLUB. :) 
Thanks for that good explanation of what makes Grok special. The model-centric development story without putting a heavy burden on what those models might be is really important. Schemas by the way can also be used for XML import/export, or JSON generation, and so on. I'll note that BlueBream can do this too, just less conveniently. :) And yes, BFG can do this too, though I think you'll need to do more work to make one of those form libraries work. 
And it's also done in Plone too. Although I'm dealing with some legacy Archetypes-based content types this afternoon - Archetypes did decouple schema definitions from class definitions, but not in such a way that you can usefully use Archetypes schemas outside of Archetypes model instances. 
I enjoy the loose coupling of Pylons quite a bit as well. But for the author of this reddit topic I too think Django is a better option.
Thanks! I looked it's just that those bottom bars throw me off. It makes me feel like that information would be in the bar and not the bottom of the page. I guess I'll do everyone a favor and scroll in the future. ;)
It is also useful for asynchronous post-processing of requests and batch processing, keeping load off your database. A classic example is a view counter to keep track of most popular stories, tags, etc. -- putting such data onto the queue avoids doing a db insert for every page view. 
It's not that, I do commit after every transaction and I still get it. If bottle isn't thread-safe for some reason, it might lead to subtle data corruption like this. It's not 100% certain that it's SA, even more so because SA is way more tested than bottle (I know many sites that use SA, not as many that use bottle). That's why I am dubious.
Um... yeah. As programs go, it's pretty simple. There's at least one bug in it, but you might not have gotten that far through your course yet so I won't blame you for not using a while loop. Also, you should probably mention that it requires python 3; not everyone has upgraded yet. Keep it up. Onwards and upwards, as they say.
I want to make an app to gather some data from an online API and I need some concurrency for it (say, 5 threads). I was thinking of using stackless and this fell into my lap, would this be something that fits my use case, or am I better off with straight up threads and a queue?
Thanks, added that its python 3. Where should I include a while loop? Thanks for the help.
Can someone summarize this? I only periodically check in with new version of Numpy, even though I use the package every day. After reading the messages linked to here, I don't really get what the issue is? EDIT: I did a little more research, and what I think happens is that, because of something to do with the datetime module, binary packages (eggs, I guess) using Numpy modules would have to be recompiled under Numpy 1.4 in its current state, and the Numpy people think this is a bad thing, and are proposing replacing the requiring-recompile-version of Numpy to something called either 1.5 or 2.0. Right?
To elaborate, the bug is that when you answer a question with something other than 'yes' or 'no', then the program just stops dead. What it should do is complain to the user and then ask the question again. You can solve this by putting the parts that ask the question inside a while loop and have the while condition be something like "while I don't have an answer that I understand", then have an if statement that checks for understandable answers. I haven't given you the answer in straight python so you can have a go at doing it yourself (requires knowledge of booleans). There are lots and lots of ways in which you could improve the program. For example, you could make a function that prints a line and then sleeps for an amount of time proportional to the length of the line. But that requires function parameters, and I'm wary of suggesting something you haven't learned yet.
I'm not too sure myself. The SciPy homepage didn't have any details on the pull and I couldn't find a proper explanation anywhere else.
ok sweet that makes sense, ill add that. No idea about the sleeping compared to line length. Maybe i'll save that for another time.
Boy, I sure hope everyone who writes their first program will post it here. There really is much too much interesting, useful content. I do so find it annoying having to wade through interesting Python links in order to see people's homework and scribbles.
That's what I mean when I say XML templating systems. You store yours in Python so you are no longer doing that. I store mine in memcached to overcome it.
[Gearman](http://gearman.org/) is also worth a look.
I didn't know there was such an idiom, sorry. Quite frankly though, I've grown pretty tired of arguing with other programmers about which set of tools are supposedly "best". I've been doing web development since 1997, starting with Perl. I then went into the world of MS tech until 2004-ish when ambitious web projects in my part of the country dried up. To keep a roof over my head, I turned to smaller jobs that were frequently written in PHP. PHP is a lot like ASP classic (vbscript) and it was a huge step backward for someone who was coding in C#. A few years ago I wrote a rather large app in PHP that caused me to exclaim "never again!" I learned Python and never looked back. I don't pretend to be objective, but I'm experienced and capable. If you want an even-handed opinion about PHP, then talk to someone else because I outright loath it.
Decided to give it a shot. And it installed Django as a dependency. WTF? That's like "Hey, I'm interested in that cup holder you have there." "Certainly, sir! And here's the car that goes with it!" ::uninstall:: Edit: This is a legitimate gripe. If you disagree, then please explain why. But simply downvoting me [doesn't do much for the conversation](http://www.reddit.com/help/reddiquette).
[QSystemTrayIcon.showMessage](http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qsystemtrayicon.html#showMessage)
How does this compare to Pylons? I see in the docs it tries to blend ideas from Zope/Grok, Pylons and Django. It looks promising, but I'm interested to hear about actual user experiences as well.
It can be as simple as Pylons or as complex as Zope. You only pay for what you eat. It's compatible with google apps if you want too. So what are you waiting for? bin/easy_install repoze.bfg http://docs.repoze.org/bfg/1.2/ 
Came here to suggest that that seems like something Qt would provide.
[They did](http://docs.djangoproject.com/en/dev/howto/deployment/modwsgi/): &gt; Deploying Django with Apache and mod_wsgi is the recommended way to get Django into production.
The reason for the dependency is that Celery uses the django ORM for all its database stuff. This made perfect sense since celery started out as a django app. At this point, I imagine it could be rewritten to use some other ORM/database abstraction, but then someone needs to volunteer the time to do it and to get it tested properly. 
NC can't be FSF/OSI approved because part of the OSD is "6. No Discrimination Against Fields of Endeavor". http://opensource.org/docs/osd
Thank you for explaining it.
Fuck you celery is *delicious*.
And it doesn't include django as a dependency.
I'm sure it can be as simple as Zope or as complex as Pylons, too. :) 
That's exactly the kind of thing you want something like Celery for - you really don't want to be messing around with firing up threads for long running processes in your front-end facing web servers. Much better to run the task "offline" by farming it out to a queue. AppEngine has a good queueing mechanism, so if you don't want to run Celery on your own server you can always farm tasks like that out to a smaller AppEngine application.
Have you tried a bit of salt: import hashlib as food celery = "celery" salt = "salt" yummy = food.md5( salt + celery ).hexdigest()
Yes. Django dependency will be removed, as soon as we have replaced it with SQLAlchemy, Beaker and something for django.core.dispatch (signals). Only the signals is a core part of Celery though, you can already use Redis/Tyrant/MongoDB or AQMP instead of database/cache. I'm sorry we wasted your bandwidth.
Oh come on, I don't enjoy php but it gets things done. You can hate php all you want, it's far more successful than python, ruby and whatever else is "hot". (Mind you python is OLDER than php! 91 for python, 95 for php). Also flickr, facebook and a lot of other high profile sites use PHP. It might not be good, but it's good enough.
i think I tried zope.schema in bfg a while back while going through a book on zca and ran into some dependency troubles. but that was 6 months ago. I assume the bluebream effort will likely make this more doable if it hasn't already. thanks for the info.
print 'helloworld'
i've been using it a bit more than pylons as of late. the reason I like it, (And this is a personal preference and not necessarily endorsed by the framework) In doing stuff in pylons, my models were clean, my templates were clean and all the logic was jammed into the controller methods. I never really saw a good abstraction to simplify the controllers to the point here I thought they were maintainable.(maybe I'm just not that smart). Anyway, bfg allows me to put the logic closer to the db model and further from the request via it's model traversal feature(I prefer to call it context traversal because I still call my db models models). So to me it's like a slight tweak to the MVC pattern that makes more sense in a web app context and leads to (at least for me) more maintainable code. Given that, I also like how lightweight you can make the applications and how they can be composed into larger wsgi applications in a variety of ways. I wrote this for my purposes in bfg and it's actually 4 bfg apps in one package so that when I need user registration I can configure that, or if all I need is authentication, I can configure that. http://bitbucket.org/twillis/identity.model/src/ I also wrote a bfg app to be a web front end to my music collection(sort of like jinzora) that I can start up whenever someone needs something and is on my network. http://bitbucket.org/twillis/spazzer/ Now the kicker, if I wanted to put user reg/auth around my mp3 collection, I have all the large pieces to make that happen. Some configuration, and some template changes would be the small amount of work I would need to do. Sure you can do this in other frameworks, but not with something as lightweight as bfg. my .02 
I was quite impressed with the "clicks" example, I hadn't thought of messaging another process to tally non-realtime in the background. However, reading the documentation a bit it looks like Celery takes a good amount of setup for a small script like mine (it won't be a web app, just something for my MSc project). Would you still recommend Celery, or is there something more lightweight (stackless/etc)?
ME GROK NOM NOM NOM :)
&gt;BAAAAAAWWWWWWWW someone made a self.post clearly labelled as their first program and I felt compelled to read it and then complain about reading it even though it was completely my choice to do so. Fuck off, would you?
I don't know why you should have dependency issues with zope.schema... zope.formlib, in the past you'd get an enormous quantity of dependencies. A month or so ago I released zope.formlib 4.0 which makes that a lot less crazy, though it still pulls in a lot that BFG doesn't use (but Grok and BlueBream do). 
IMDBAPI? Not really, but it's ten lines or so so I could post it if you want...
** flush ** : fires off all your pending INSERT, DELETE and UPDATE operations to the database. What does "pending" mean ? Well, the SQLAlchemy session keeps track of all the changes to the objects it's managing, and knows whether it needs to INSERT a new row, UPDATE an existing row, or DELETE a row. ** commit **: does a COMMIT to the database, i.e. commits the transaction. ** autoflush **: does the INSERT/UPDATE/DELETEs automatically when you call commit(), so you don't need to call flush() at all. ** autocommit **: does the COMMIT automatically after you call flush(), so you don't need to call commit() at all. Most of the time you'll have one or the other enabled. zzeeek will probably be along soon to correct me on this, but I think that's about right. EDIT: one thing you want to make sure of at the end of each thread/request is to call session.remove() to clear all the objects out, and to use a [scoped_session](http://www.sqlalchemy.org/docs/session.html#contextual-thread-local-sessions) to create a thread-safe session. I don't know anything about bottle, but if it uses SQLAlchemy then it should do this.
it was more than 3 months ago that I tried it, but I think I'll give it a go again when I get home to my play lappy
I have to admit, I have yet to deploy something like Celery in production for precisely the same reason - the setup can be pretty tricky. A cheap alternative (that I use quite a bit) is to have a "needs_processing" boolean flag in a database table and a cron job that runs every few minutes to handle those jobs. For an MSc project I'd imagine spinning off a few threads would be more than adequate, provided you know what you're doing. Alternatively, if all you need to do is fetch a bunch of data in parallel something like Twisted or Tornado (or my current favourite, Node.js) would be well worth a look.
Could you describe what seems tricky? It could help a lot! I don't think it's a good fit for @Poromenos example. Maybe if it was to be distributed to multiple machines, but for plain concurrency you could use e.g. multiprocessing. Also, @simonw, you do know you can just use the database with celery, right? Celery+RabbitMQ is made for scenarios where your jobs needs to be completed as soon as possible, but for the use case you describe here, an execution latency of possibly &gt; 4 minutes, it should excel when using the database/redis as the message queue.
McDonalds is also quite successful. 
I think so, it seems that if you have non-realtime tasks and a cluster of machines this would be a perfect fit. In my case, I think I'll get to know stackless a bit. Thank you both for the recommendations!
Do you seriously saying I should use Grok because I can put a view and a class into one file? Huh?
Grats for having the balls to self post this in python for the world to see. Don't be discouraged by the elitist jack-wads that will invariably post here. Good work, I haven't looked at the code yet myself but none-the-less it's very admirable to be diving head-first into the scene. I wouldn't mind seeing more stuff like this as I'm an amateur myself and I can learn even further by watching the mistakes others make, or the methods others use in the same level of learning as myself. Also, commendable to be taking the dive into Python 3 as well; you'll have much less of a headache on your hands in the next 2 years as some of us have coding habits to break first ;)
Thank you! I am really getting into and I want to learn more. I can't wait to understand half of the stuff posted here. lol
How long have you been learning Python?
You could just code up a Python script and drop it in www and bam. Then you wouldn't have to deal with the blight of a language that is PHP.
Hah, it's down for me. Also: http://downforeveryoneorjustme.com/http://ec2-174-129-96-143.compute-1.amazonaws.com/index.html It's not just you! http://ec2-174-129-96-143.compute-1.amazonaws.com looks down from here.
Link broken - is the link pointing to his server?
Yes, it worked a few minutes ago.
What is he trying to show here? It doesn't take a hammered website to characterize the Python threads sharing cores.
He's keeping similar traces as the one he shows on the page. On PyCon he hopes to have some analysis ready what happens with 512 threads on 2 cores as used by this website, and maybe present some idea for improvement (if necessary).
Its loading for me.
3 weeks now. Well three classes anyway. I am going to try and learn more on my own.
I posted a new version. I added the while loop and fixed some errors I found. Also made the story better and fixed the grammar. One thing I can't figure out is when they are asked to put in a number(int) and if they don't it "crashes." How do I solve that so it just asks them again?
He's trying to understand what happens with the GIL in an IO-bound application, rather than a CPU-bound one.
It started working again a few minutes later, it still seems a little stressed.
The only improvement idea he has is to write your software around the GIL. What does this test do to that a simple small simulator can't? I think we get the point already.
&gt; What does this test do to that a simple small simulator can't? The real world behaviour.
Well, that's an interesting thing to say but it isn't true. Shown in graphs and charts, he has synthetic benchmarks and evaluations so far that illustrated the CPU-bound switching problem quite well.
The word 'simulator' has a large coverage. You could as well -the usual definition I think- have meant a model that predicts the behaviour of Python without actually running CPython at all.
 while true; do for i in `seq 200`; do (curl -s "http://ec2-174-129-96-143.compute-1.amazonaws.com/tile/pack_4thr_1cpu/2/1" &gt; /dev/null) &amp; done; sleep 10; done;
any one of those three would be better :-) I use bitbucket and Hg - espically because eclipse plugin is good. But bitbucket recently has speed problems at least for me - but is cheaper than github for closed source projects. Github is faster than bb for me, and has a bigger community its paid packages are more expensive, and windows support for git is not so good. Bazaar - cant say i didnt use it yet, but it has support for windows, and free launchpad hosting for os apps - i hate launchpad site but its personal preference ofc. But let me stress again any one of those three would be better for you.
Hmm. Why do you think the other three would be better? Also - I have a media temple account and it looks like I can install the mercurial server on my gs service.
The version you posted won't work... there's a missing " on line 51. Several comments... **Always test your code before you show it to anyone!** :-D **Don't repeat yourself.** You have a dozen lines looking like: noun2=str(input("Type in another noun: ")) noun2=noun2.lower() Instead, def GetLowerString(prompt): return str(input(prompt)).lower() noun2 = GetLowerString("Type in another noun: ") pnoun1 = GetLowerString("...") **More whitespace!** It makes it easier for everyone. Put a blank line in between sections - it makes it easier to read. Put spaces around =, +, - and other operators. **Never write "if x == True" (also "for" and while).** The "if", "while" and "for" statements are expecting to get a value that's True or False anyway. Just say: while running: **Use longer and clearer names!** What does "machine()" mean? No idea...! **Use functions (def statements in Python) to organize your code.** I sorta covered this above (and am sorta out of time). **Read tons of other people's code** **Keep it up!!** Best luck.
the way you work with dvcs will suit you better if you are changing places or working remotely. And its really better way to work in teams - but it all boils down to workflow of your team. Also, no more stupid .svn dirs in every subdir, better binary handling iirc.
yea fuck .svn!! 
[I second the motion for BitBucket.](http://blog.bitbucket.org/2010/02/11/disk-space-is-cheap-have-some/)
I'm writing a scientific processing pipeline for work with very long running processes (a week or more at the long end, though usually a few hours). I was thinking about adding a web front-end and was looking at celery + django. I don't know either one, so it's more of an excuse to learn shiny new things. I tried to set up celery on my macbook for a couple of hours last night to no avail. The pip installation went smoothly but for the wrong version of python on my machine. I could access it from something like /usr/bin/python, but not from env python. I don't know whether it's a pip thing, celery, or my own for not having a cleaner installation, but I've not run into the problem before. I also had trouble getting rabbitmq working through macports, though that's probably my own fault.
indeed, sir - fuck .svn
Shouldnt this be titled: "David Beazley is doing another GIL expirement for his PyCon talk [shamless plug], and he wants \*you\* to hammer Amazons server on his behalf (and in the process, rack up an expensive invoice from Amazon) No?.. didnt think so
I like git. I started using it because of the Linux kernel but it is my VCS of choice. It is _FAST_, no surprise when you get a bunch of kernel hackers together. It is fairly easy to learn the basics. It also has a lot of nice surrounding infrastructure like Gitorius, github, gitweb, cgit, etc. Nice plugins for Eclipse and other IDEs too. I found I didn't like the web interface of Hg and never really tried Bazaar. I've never found myself cursing git so I guess I don't have a reason to now. Edit: Subversion is alright for corporate development but for personal use it would be more pain than it is worth. Doing anything other than using it as a versioning file system is a bit of a pain, to include branching and merging which are fairly important when you need stable releases of software.
Dropbox is your answer. I signed up for it to keep my project euler code moving around for fun on the desktop or laptop and it works magic.
The problem I always have with job queues is simply keeping the workers running. I'm a terrible sysadmin - if I can't run "/etc/init.d/something start" and expect it to keep running, restart itself if it fails and start up when the box reboots I get very nervous. I've just about managed to use god to monitor a couple of scripts now but I still don't really trust myself to set things up well enough that they don't fail to restart should my virtual server get rebooted. If celery shipped with a set of well documented, well tested Ubuntu init scripts I'd feel a lot more comfortable.
... and I just spotted http://github.com/ask/celery/tree/master/contrib/debian/init.d/
got one in python?
&gt; Quite frankly though, I've grown pretty tired of arguing with other programmers about which set of tools are supposedly "best". 100% with you there. And in fact, I've had similar experiences with PHP: 10 years ago I had the project that made me say "never again" ... more recently through frustration and the profusion of PHP skills scattered around relevant resources for my project I thought I'd give it another try .... jesus, it gets even worse. Then again, simple things can be built in it fast and deployment is never a hassle. It has a place. And the popular web toolkits are so overengineered I sometimes yearn for PHP's simple model, if not its simple mind ...
Awesome! Thanks for the feedback! I'll do all of those now. Machine is def I put the "game" in there so if some one said yes they want to re-play, it would just call machine again is this not a good practice? Also I'm gald you said that about white space I was a little weary having too much.
hah, funny... if I did then there would be no reason to perform this experiment to begin with! If you did try branching out many threads, each using urllib to download a file then only one could run at a time (since the urllib module is a python object and thus locked by the GIL).
Presently populating [its own twitter feed](http://twitter.com/redditron), to bless the world with his wisdom
thats strange - web interface of hg can be almost identical of that of git(you can cofigure that) ;-) also do you know any good git plugin for eclipse that actually works? i had issues with eclipse and github couldnt connect to it
 while running: doesnt work for me. Says it's not defined. Is this a 3.0 thing or am I missing something. (prob that that one)
ok. so what is that memcache module? please elaborate the README. in its current state, it's useless.
&gt; what is that memcache module? It's [python-memcached](http://pypi.python.org/pypi/python-memcached/)
&gt; Also I'm gald you said that about white space I was a little weary having too much. [PEP 8](http://www.python.org/dev/peps/pep-0008/), the official Python style guide, has a bunch of guidelines on when you should and shouldn't add in extra spaces etc. Other developers in the Python community will be grateful for it.
It crashes because the **int** function [raises an exception](http://docs.python.org/tutorial/errors.html) when it is given a string which hasn't got a number in it. You can solve this by using a try-except block when you ask a question that requires a number. There's a bug in your while loop; try answering "no". If I were you, I'd spend a little time learning how to separate out repeated functionality into functions. At the moment, you have lots of lines that look like this: adj1=str(input("Give me a noun")) adj1=adj1.lower() But if you were to define a new function called ask_question, then you could simplify them to all looking like this: adj1 = ask_question("Give me a noun") Just in case you don't already know about them, here are a few useful links: * http://docs.python.org/3.1/tutorial/index.html * http://docs.python.org/3.1/library/index.html * http://diveintopython.org/ * http://en.wikibooks.org/wiki/Non-Programmer%27s_Tutorial_for_Python_2.0
so i guess this will not work on windows :) was interesting in the markov implementation. i wrote one a while ago too.
I don't know, I only tried it on my Mac and on the Linux server where it's running right now. You could find another Memcached implementation and swap it out, or really any key-value store that supports `append` and `incr` operations
I have used Bazaar and Mercurial, and I like both of them. You can use bitbucket for Mercurial, and launchpad for Bazaar.
I'm not sure we're really on the same page. The XML templating system I was thinking of is Chameleon, which translates specially marked up XML into Python source code (once, effectively at startup time). Each time thereafter, that Python source code is run to generate output based on input fed to it for some particular rendering. The XML is never consulted after the first rendering. The fact that the input language is XML has no impact on the speed of rendering a Chameleon template. Chameleon is faster than, for instance, Django templates, and it's about as fast as something like Mako (which is considered quite fast).
Chameleon is roughly as fast as Mako. Mako is one of the the fastest widely-used non-XML templating system for Python.
maybe cumbersome was the word I was looking for :-) 
I think your looking at my older version. In my current version 4 I took your advice and added the def and fixed my while loops. Though I kept: while running==True: Statements. I'll look into the try-except online, thanks. Also, thanks for the links. Diveintopython looks cool. [this is my current version](https://docs.google.com/leaf?id=0B4Zbh4jo51XaOTk4Njk4N2YtMTE0NS00OGUxLWExNjctZDQ4ZjM5NTJlYTY5&amp;hl=en)
Err, yeah. Well, it's fixed now, in any case.
You cah use mercurial with github using the hggit extension http://hg-git.github.com/
 `http://ec2-174-129-96-143.compute-1.amazonaws.com/index.html` not `http://ec2-174-129-96-143.compute-1.amazonaws.com`
I'm using egit from jgit.org/updates/. Fedora 12 has it packaged and I've added it successfully to my Gentoo box and Windows 7 laptop. Functionality is exposed through the 'team' menu. You can to clones, commit, pull, push, branch, etc. It has a nice history viewer too. Sometimes on cloning a repo the team menu doesn't activate. Just click 'share project' and it will reread the .git folder and activate all your team options. Note that egit uses jgit -- a complete reimplementation of git in Java.
hammertime.sh #!/bin/bash function hammertime { i=0 while true do let i+=1 curl -s "http://ec2-174-129-96-143.compute-1.amazonaws.com/tile/pack_4thr_1cpu/2/1" &gt; /dev/null r=$? if [[ ${r} -ne 0 ]] then echo $1: $i - $r exit 1 fi echo $1: $i done } for j in `seq 200` do hammertime $j &amp; done WARNING: This does not exit on its own. The easiest way to terminate the loop is: killall curl Begin the fun: $ sh hammertime.sh This is basically a DoS attack, which is what the guy asked for... 
Personal favorites - first, a bit of philosophy: &gt; A scrap book and an understanding of the restroom And the short but effective: &gt; Combofix
Hey so in class right now I fixed/modified some more things and even added a post to twitter function! Thanks for all your help. I can't think of anything else to add to it. I am already past the requirements for the project. I want to get it online for people/friends to use, I think I am gunna research that next. Do you have any pointers. Thanks again for all your help! Edit: [my twitter](http://www.twitter.com/jshariat) is here
Some more gold: * There are no proofs whatsoever in my eyebrows. * Have you heard of wizard people, dear reader? * I knew i would have been spanking his needs to shoehorn * In a song. Israel promptly offered nothing to our lives. Also, it becomes second year, the us. It will be an injured, we are contemplating * Voted to dinner with me, but they will truly love pie And my personal favourite: * Fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap 
PyQT is too much for my simple requirement. Besides, deploying apps with PyQT [is a pain](http://arstechnica.com/open-source/guides/2009/03/how-to-deploying-pyqt-applications-on-windows-and-mac-os-x.ars).
You could probably make a troll-bot that simply scans threads for long comments and replies 'This' every time :-p
 cpus = 2 threads = 700 import threading import socket import multiprocessing import os import time crlf = chr(13)+chr(10) # reddit censors rn?? message = 'GET /index.html HTTP/1.1' + crlf + 'Host: ec2-174-129-96-143.compute-1.amazonaws.com' + crlf + 'Connection: close' + crlf + crlf def worker(): s = socket.socket() try: s.connect(('174.129.96.143',80)) s.sendall(message) while 1: r = s.recv(2**16) if r == '': break except: pass threading.Thread(target=worker).start() def begin(): print 'Starting process id: %s' % os.getpid() threading.stack_size(32768) for i in xrange(threads): threading.Thread(target=worker).start() time.sleep(-1) if __name__ == '__main__': for i in xrange(cpus): p = multiprocessing.Process(target=begin) p.start()
You fucking rule.
Well, I meant more along the lines of allowing me to hammer the server from my machine ;) I'm on a windows box unfortunately.
Your algorithm is sorta gay, or kinky: &gt; In the struck an asshole, and happiness. Because i just a retaining Cool of you to make an inclusive, unbigoted algorithm.
Thanks, now I can help hammer the server with my connection as well ;)
My girlfriend says she would follow @redditron if it updated about once an hour. Five minutes is too much.
And some more: * They're not picture of self-control * Ooh * Yea, it's about the road of playthroughs * How much. Let me snicker * We just fyi, nasa * Haha, at the conspiracies
&gt; Your algorithm is sorta gay, or kinky Why can't it be both? * I knew i would have been spanking his needs to shoehorn * Man. Xxx
Done. Five minutes was just for maximum fun while I was writing it initially
Sweet! I followed too.
hohohohooooooooooo! And it CAN be both :-) I didn't say xor.
Well there's the first problem! I'll write the script that'll fix everything up, let me just find out how to write a linux install script in python..... :)
Very nice! Why are you setting the stack_size? They really need to fix the gil though... any idea how that script scales? I would think since you are creating a new socket object for each thread shouldn't _need_ to block to often.
Clean code, but I don't think you should exit on non-zero return's from curl. When running my code on my servers I often got return code 7 and 52's! Then again, I was sending out ~700 connections every 10 seconds on each of two computers each with dedicated gigabit connection :D
I set the stacksize to limit memory use. The script doesn't scale as well as epoll and kqueue, but it works better than select, which is what windows uses. I wanted to have a script that also worked in windows.
Upvoted. I use Dropbox for everything too (additionally to hg).
If you have Apache installed on your box, here's an even faster one (by an order of magnitude, or greater) that uses ApacheBench to hammer away at it: while 1=1 ; do ab -c 1000 -i -n 10000 http://ec2-174-129-96-143.compute-1.amazonaws.com/index.html;done;
Its just a simple hack to let you exit from the forked processes, as killall curl causes them all to exit with a nonzero value.
The logo for the redditron twitter account is great, did you do it yourself?
Suggestions: 1. Mercurial clearly has more traction than Git in the Python world (and Python itself is switching to it rather than Git), but git has a bigger general mindshare. Ultimately they're both pretty good (the Git CLI is still shit though, as far as I'm concerned, but it also packs more punch "out of the box" versus the mercurial plugins you have to enable in your `.hgrc`) 2. Do not under any condition switch to Bzr. It's inferior to the other two by far despite what anybody will tell you (it's far slower for everything, it regularly breaks compatibility with itself, it doesn't have in-place branches, ...), and Launchpad is junk (the only thing it has going for it is that the bug tracking can track bugs across multiple branches (called Series in launchpad, fwiw), the rest blows goats compared to Github or Bitbucket; it might be a good host for huge projects — I really doubt that but I'm willing to give the benefit of the doubt — but it's shit for smaller ones). 3. Depending on the size of your projects, you could also give a look at darcs, it still has the best command-line interface by a long shot, and is still the only DVCS to correctly support cherrypicking. Also, keep in mind that hg is probably the easiest to deploy on one of your own servers (to setup your own repo/repos, instead of going through a third-party host such as github, bitbucket or google code)
I did a bit of playing with Markov chains a while back. I've nicknamed all instances "Odin" and he's available on Twitter: http://twitter.com/odintweets (based on the people he follows -- although I've disabled him autofollowing people who follow him for the moment) The first one I did though was the headline generator on this site: http://news.wafti.org.uk/ (The "LATEST:" ticker are the random ones; the "other top stories" on the side are written by humans). These are based on about 20-30 RSS news feeds. I also played around with a random walk along "related" songs on last.fm: http://www.last.fm/user/odinlistens There's an MSN and Google Talk bot too, but I don't maintain it very well. I might give out the address if people really want to see. Oh, and it's all in Python as well :-)
&gt; I signed up for it to keep my project euler code moving around for fun on the desktop or laptop and it works magic. 1. Dropbox is not good enough for versioning 2. Dropbox is sub-optimal when you want to share arbitrarily. &gt; I want to be able to have them backed up on a server that will allow me to share the scripts with others.
&gt; I have a media temple account and it looks like I can install the mercurial server on my gs service. Considering the most basic "hg server" is nothing more than a cgi script and a file or 2 of configuration (as well as the mercurial lib itself, of course), the only requirement to setup your own mercurial repository/server is that python be available.
Here Subversion is the odd one. I never use it when I have another choice. Git is fast, but requires you to setup keys etc. (not very user friendly, I'm not OCD enough for that). Mercurial has the best balance between usability, features and speed. Bazaar is slower then all of them (yes it still is) but plays very nicely with svn, so I usually use it to work on svn repositories. So the final recommendation is Mercurial.
Git &gt; Hg &gt; Subversion &gt; Bazaar Bazaar is awful. Its like a bad Git implementation. http://whygitisbetterthanx.com/ http://whybzrisbetterthanx.github.com/
Do you use virtualenv? In that case you should use: pip install -E $VIRTUAL_ENV celery Don't use MacPorts, use homebrew instead: $ git clone http://github.com/mxcl/homebrew /lol $ export PATH="/lol/bin:/lol/sbin:$PATH" $ brew install rabbitmq $ sudo rabbitmq-server -detached Homebrew: http://github.com/mxcl/homebrew
Zope's been around long enough to be simple, complex, cumbersome, easy and everything in between. 
He said Grok doesn't force you to layout software in particular ways. So you can put a view and a model in one file, or you can separate them out over multiple modules, or packages, or however you'd like to organize it. He also didn't say you should use Grok. He said Grok is where it's at, not that anyone should actually use it. :) 
&gt;Do you use virtualenv? I don't, but I've been meaning to learn it. Thanks for the advice. I'll try again this weekend :)
I approve.
Wow thanks for this
That's what she said. And me too.
Has anyone heard if Python would be promoted to supported(thus installed by default) language in Nokia's new Symbian plans?
&gt; Nokia's new Symbian plans? What? I thought it was going to be all about Maemo from now on.
That's the first positive word I've heard spoken about darcs. Good to hear. Thank you.
No, they've got new Symbian in the pipeline, open source no less. The new Symbian will eventually be QT based and be fairly compatible(source wise at least) with Maemo.
Well darcs used to have big issues in 1.x (especially what was basically a breaking bug), now it has smaller issues, but it remains my first dvcs love, and I think it is more "d" than most other dvcs. And the core idea is so damn sexy. And the command-line interface is drop-dead gorgeous. They changed pretty much all the command names (compared to CVS/SVN), as git did, but they did it to make things clearer/better, as git didn't.
[Chromakode](/user/Chromakode) made it, actually
Thanks! easy_install's lack of straightforward support for the equivalent of `setup.py install --home $HOME` has been a peeve of mine. Especially since PEP 370.
At least in the meantime the runtime will be automatically installed on some devices on starting a script. - I assume this will include all new s60 devices
Cool! Thanks for the informative response.
What you really meant to say: "Hey I want to start a flame war! Everyone pick a very similar technology and start arguing!"
Yeah, they're pretty much trying to take on Android by the looks of it: http://www.symbian.org/ Pretty much current S60 5th edition has been renamed to Symbian^1, and Symbian^2 is I believe a forth coming update to the mostly S60 environment, then around Symbian^3 or Symbian^4, it starts to merge with a Qt environment with the upper layers pretty much the same as Maemo.
&gt; the command-line interface is drop-dead gorgeous. Could you please copy/paste a partial session as an example of this? I don't know what you mean. 
&gt; Could you please copy/paste a partial session as an example of this? I don't know what you mean. Can't due to issues with macports, ghc and osx 10.6 (tried using the haskell platform installer, but cabal doesn't work), but basically the command names are clear, descriptive and precise. They mean what they say and do what they mean. Most of the time, when I see a Darcs command I know what it's going to do. and even `darcs help` is very well organized in sections. See http://darcs.net/manual/node7.html for an overview of the commands (and `darcs help` displays something pretty close to the menu at the top, section and all, except with a short description of the command to the right) It's close to what was recently added to `hg help` where topics are split between "commands", "installed extensions" and "additional help topics", but with categories of *commands* so it's much clearer. And commands related to a topic (e.g. "Querying the repository") are all grouped together, which is damn nice. All of that makes for a very pleasant experience. The only issue I had when I still used it was the lack of a graphing command (something equivalent to `hg glog`), it might have gotten one now, but then again relations in Darcs are *very* different than those found in a dag-based DVCS (such as git or mercurial) so I'm not quite sure how the "graph" would look like
dunno used same one and had issues with github, dont know why :/
I think I'm going to go with Hg + BB. Thanks for all the advice!
yeah sure unbiased comparison by employee of github ;-) you ppl dont have minds of your own ?
via [Will's blog entry](http://bluesock.org/~willg/blog/pmc/python_mc_org.html).
i'll admit it, i lol'd. i'd work jlint into our company's build process but when we're getting 100+ warnings from javac as it is, i think it would be wasted effort. :(
I gave everyone the ILoveYou virus to celebrate.
There's a pylint?
As a git user I agree with you. But like you said git is fast, so I am sticking with it for now.
too bad pylint gives so many false positives. I prefer using pyflakes https://launchpad.net/pyflakes
He's still right though, bazaar is terrible.
Ten times more enterprise than Django.
This is the official web2py book (2nd Ed.), converted from LaTeX to markdown. We are in the process of editing it to include a description of new features added in the last 6 months. Users can contribute by attaching wiki pages to book pages and by posting comments. Evey page has a threaded discussion. Syntax is markdown but all code examples are automatically syntax highlighted and all keywords in code have links to docstrings. You can also embed LaTeX expressions in between $...$. Pages have full revision history and editors can revert them. The search feature will highlight matching string in the found text. Translation is provided by Google. It is ok but sometimes wrong. The book is powered by web2py itself and hosted on Amazon EC2 for now.
What's that even mean? If you're going to take the time to bash another project, at least back it up.
Haha, it doesn't mean anything really. It's just the way it positions itself all over its website and on Wikipedia. The word enterprise is mentioned a lot in comparison to Django's website. To clarify, I wasn't bashing the actual project, as I've not used it. I was, however, sort of bashing their marketing.
For someone who is just starting out with Python and wants to make webapps, what is the major difference between this and Django? Which would be a better choice for a beginner?
[Django polls tutorial in web2py](http://vimeo.com/6507384) (video) and [syntax comparison](http://web2py.com/examples/static/web2py_vs_others.pdf) (this is a bit old, both have evolved since). web2py also has a minimalist set of [APIs](http://web2py.com/book/default/api) and that makes it easy to learn. 
First, this is probably the nicest looking HTML book I've seen. The integrated wiki is also a great idea. A few questions: - The subtitle of the book is "Enterprise Web Framework" Could you elaborate on why you chose to describe it as such? - I've never used web2py, but have used both Django and Pylons fairly extensively. Reading this book, it looks like web2py's components are even more tightly coupled that Django. Am I able to use a database that isn't listed in as being supported? Can I use stored procedures? Or, am I able to use the template engine that I prefer? - In the "Why web2py?" section of the book, you write *"Even as new functionality has been added, web2py has never broken backwards compatibility, and it will not break compatibility when additional functionality is added in the future."* Do you believe that taking such a stance on a young project will affect your ability to add some new features or fix architectural issues? For example, eventually moving to Python 3K will likely break backwards compatibility whether you want to or not. - Finally, what can you tell be about your policy as far as accepting patches? Your "[Contributor Agreement](http://web2py.com/examples/static/web2py_contributor_agreement.pdf)" concerns me. It appears that I have to assign joint ownership of my code personally to the primary maintainer of the framework. I feel this is incompatible with an open-source license, as it permits the author to someday release a commercial version of web2py using my code.
Thank you for the questions. 1) web2py was once called "Enterprise Web Framework" then we changed name to "gluon" and then to "web2py". We changed name because of trademark issues. The word "Enterprise" is there to refer to both "Businesses and Non-Profits" as opposed to just businesses, and to stress some of the features that those "Enterprises" usually requires and we provide: Easy of use, integrated IDE, support for multiple databases and distributed transactions, guaranteed backward compatibility. We want to stress that our target user is not the amateur programmer nor a Python expert willing to understand the guts of the system. 2) They are more integrated than Django's but still they can be used separately and to some extent replaced. You can use other template engines (people have used Genshi and Jinja2 with it without problems) if you have them installed. You can use stored procedures and raw SQL. You can use other database engines if there is a Python driver but they will not work with web2py DAL unless you write an Adapter. It is not too difficult to do so. 3) web2py is ~3 years old. We never broke backward compatibility since Oct 2007. We have no plans to move to 3.x anytime soon. When 3.x proves to be faster then 2.x for this type of applications and available on Google App Engine we will consider a switch. When/if we do so, it will not be web2py any more (web3py?) and we will break backward compatibility (not just because of the change of the language). 4) The contributor agreement we use is the same as the one SUN uses for JAVA and not very different from Django's. When you contribute you have to declare that you have the right to your contribution (did not steal from somewhere else) and give me the right to distribute it with web2py under any license web2py code is distributed with. You keep the right to your contribution for any use you want to make independently of web2py. Basically you cannot restrict what I do with your contribution and I cannot restrict what you do with it. I just need to make sure that if you sell something including your contribution the buyer cannot claim rights on web2py portions. EDIT: mind that when you release code under BSD and similar licenses you do allow everybody to release a "commercial version" of it. So yes, the license would allow me to change the license to something like BSD although I prefer GPL becuse GPL does not allow core developers to make a closed source derivative while BSD does. It would allow me to sell commercial licenses for special purposes (for example uses where GPL would be incompatible). What the license also says is that this does not limit your ability to do what you want to your contribution and also include it in commercial products as long as it does not limit my ability to do the same. EDIT2: For the record. We do not consider applications written with web2py derivative work (because they are executed by the framework, they do not import it), unless they explicitly include web2py source code, therefore we pose no restriction whatsoever on application licenses. You can released them closed source bundled with web2py binary (we already provide a commercial exception to allow this... one more reason for the agreement).
Agreed mostly; most python developers I know (not core python, just users of python) seem to be split between hg and git... more using git but that's just my experience. Also git is pretty easy to setup using ssh, especially if it's just for yourself.
hg is fast too :)
Bitucket should be a lot quicker since they switch their disk setup (and a side effect of that is that they now offer 1GB space for the free plan).
You forgot http://whyhgisbetterthanx.com/ ;)
i heard that web2py is so horrible and so slow on appengine. is this true? from here: http://stackoverflow.com/questions/76809/anyone-out-there-using-web2py
I have only experimented with web.py, web2py and Django. All have their merits, but IMHO web2py is the best of these for beginner and best overall if you start serious project from scratch. It has clear, almost "pedagogic" MVC design, it has enough features to be useful, and you can replace most parts if you really need to do so. 
Nothing in that thread says anything of the sort. The only mention of GAE there is a criticism of GAE itself, not web2py.
Try it yourself. These for example runs on GAE: http://w2popenid.appspot.com/init/default/wiki/main http://web2py-crm.appspot.com http://wavedirectory.appspot.com Mind that it gets faster as more requests/secs arrive because of GAE caching mechanism.
Congrats to the bfg team and especially to mcdonc who's put so much hard work into it!
I wonder if `Chr0me` thought you were "bashing" Django.
&gt; The word "Enterprise" is there to refer to both "Businesses and Non-Profits" as opposed to just businesses, and to stress some of the features that those "Enterprises" usually requires and we provide: Easy of use, integrated IDE, support for multiple databases and distributed transactions, guaranteed backward compatibility. You might as well start charging a buck for that then, homey
First I thought, "What's a micro community, other than a small community? And why is that good for Python?" Then I thought, "Oh, it's a MIRO community. What's a Miro Community?" Then I googled it, and I find out it's an [internet TV/video thingie](http://en.wikipedia.org/wiki/Miro\_\(software\)).
I consider enterprise an insult. I hope noone, ever, calls my software enterprise.
yeah i know, in my case its probably fact that i watch many repos and users, dashbord before cache is very slow. but im aware my issue is not common.
Is the GmailNotifier tool open? Could you just modify it? Barring that, how does it find out you have the new mail? From your description it sounds like it tells you that you have new mail **and** gives you the headers (letting you know that it's not worth reading), so it certainly sounds like what you want is feasible. Maybe fire up wireshark or similar and sniff what the GmailNotifier is doing to get an idea of what your code should look like (assuming that you can't just look at its source).
&gt; I've used subversion in the past and was happy with it. Now there is your own answer right there!
You might want to post this over at SO. Those guys are quick.
That's what she said.
It's a dll plugin for Miranda-IM, and it's closed source as far as I know. It displays the title in a Tooltip, and if you click the system tray icon it opens your browser of choice. Thanks for the suggestion. I'll try wireshark as a last resort if the high-level approach isn't successful.
Amazing stuff here. As it is a lot of info out there on python gets rather old rather quickly (MOST of my searches regarding python end up in 2000-2002 territory), and what I've seen from this video is that they are using a lot of Python 2.6, including __future__ imports in order to prepare people for the Py3k switchover. Thanks for this link, I'll be visiting it regularly and watching all the videos as my entertainment (sad, I know) for the next month or so.
The script you described is pretty short, in its simplest form. It's a little more complicated if you want to check that the last message in the mailbox isn't an even newer message. If you want to fetch anything (to compare dates, or whatever), you might try [ImapClient](http://pypi.python.org/pypi/IMAPClient) which build in imaplib. import imaplib m = imaplib.IMAP4_SSL('imap.gmail.com') m.login(username, password) m.select('INBOX') # * refers to the last message in the mailbox (which is probably the most recent delivery) m.uid(r'store * +flags (\deleted)') m.expunge() 
I posted an answer to your question on stackoverflow. Hopefully it will point you in the right direction. http://stackoverflow.com/questions/2260316/deleting-the-most-recently-received-email-via-python-script/2260366#2260366
I believe I found a solution to the gmail-specific issues we were encountering and I have updated my answer on SO.
Adding recent:username worked. Thanks, I really appreciate it. I would have never discovered that.
no problem, glad I could help!
Thanks. I'll use this if I decide to extend the script one day.
This is a very big step for the framework. Although I've never used it (except playing with it a bit), I was very hesitant to recommend it to anyone because this book was only available on scribd for free. Now if they would only stop using the word "enterprise" all over the place.
This again? How many posts do we need debating the merits of Python web frameworks? There's only one answer: try Django and Pylons, and see which one you like best. You can compare features until the cows come home, but the most important thing is which one fits your own mental model best. So just pick something simple (either a subset of what you intend to make, or something else) and write it in both. 
Did you read what i just said? I tried both.
My comment wasn't just for you. There have been loads of posts asking essentially the same thing these past few weeks, and of course every time someone asks, they get multiple recommendations. It's just not a thing someone else can give you a definitive answer to.
I tried searching on reddit for similar discussions, but i hadn't found any. I know it's usually just a personal choice, but you can't tell me there are no important differences. In my case, it's the flexibility part i'm confused about.
&gt; I don't care about reusability nor do i care about the time it takes me to develop a website. I just want full control. Then why are you looking at a framework? This is what frameworks are about.
What i meant was, it's not as necessary as flexibility.
Its a little weird to ask for maximum flexibility while simultaneously boxing yourself in to making a binary choice between Django and Pylons, especially if you've already tried both and still can't make a choice. Maybe try a third?
Control over what exactly do you want? If you want to use Django like Pylons you can. You can have as much control with Django as you have with Pylons. You actually can have all the benefits of Pylons (using any type of datastore, any templating language etc.). The problem with doing this with Django in some situations would render most of the stuff in django.contrib useless (Authentication, Admin etc.), depending on what you want to exclude from the django stack would also render some shortcuts and helpers useless. And some of the biggest timesavers are in django.contrib. With pylons there's no notion of reusable applications and you have to do everything by yourself, even writing the authentication part by hand is much simpler then figuring out how to configure repoze.who, AuthKit etc. Not to mention figuring out how to use the bazillion options for doing form rendering and validation.
Isn't it considered bad use to overly modify Django?
Modify? If you mean go up there and edit the code, it is. I'm not talking about something like that. I'm talking about not using parts of Django in your project. Like not having a SQL database (using something like MongoDB) or using SQLAlchemy instead of the Django ORM. Or not using any orm at all (doing everything with raw SQL and stored procedures). At this point with Django 1.2 it's very easy to use another templating system, there's a preferred oficial way to do it. So the only tricky part is the ORM which ties you to using SQL databases. And if you decide not to use it you can forget about using stuff from django.contrib or reusable applications. And the bad idea part here is that if any of your applications are made in this way (by ditching the ORM etc.) they won't be of much use to other people. So you'll sacrifice reusability for control.
your third option: cubicweb it's very flexible/adaptable (quite more than Django according to one collegue of mine that used both) and the only downside I can see now is the size of the community around it (it is small albeit reactive) disclaimer: I've been using it for two years and even contribute to it its main developper is the guy behind pylint
[Werkzeug!](http://werkzeug.pocoo.org/)
With a name like that, I defy you to mention something less than positive about Google.
Damnit you beat me to it!
At the moment, PyS60 has some of the worst code I've ever read. Will Nokia ever rewrite the bad parts? (eg. 99% of all the code). Last time I tried it, it didn't work. That's where I'm at right now...
&gt; With a name like that . . . like what? Are you talking about `Chr0me`?
I'd didn't forget. I just didn't care. 
yes
I've actually said a fair bit that was less than positive about Google lately. For instance, there's my article about *[how China exposed Google's hypocrisy](http://blogs.techrepublic.com.com/security/?p=3007)*.
/me is awaiting chr0mes response
It's entirely possible `chr0me` isn't watching this subthread that closely.
If you've used them both the differences should be obvious. If you want 'full control' and don't care about time or anything else you don't want a web framework at all, you want to build your own. Start with werkzeug and go from there.
I'm absolutely not experienced enough to build my own framework.
Here, I have upvoted you for your troubles
downvote, not python
That's how you get the experience! Especially if time is no constraint. Start here: http://pythonpaste.org/do-it-yourself-framework.html
Thanks!
Seems like a good idea but watching that podcast is pretty much unbearable. Would be nice if the author took the time to make one without so many typos and mistakes.
That is so awesome! I really like that integration.
Very cool!
Something missing from the instructions? I did exactly what it says and f5 does nothing. Running Debian testing and debian doesn't let . into the python_path when starting a python shell, if it matters.
Do you have other filetype plugins working? If not, try adding filetype plugin on to your .vimrc. You could also just type :filetype plugin on into vim.
thanks. that solved it. silly me :)
I agree. It was worse than no video at all. I hope the new one is more tolerable.
this doens't work for me on Windows or OS X.
Django tends to be document-oriented and about providing information (it comes from journalism after all). Doesn't mean you can't build a webapp out of it, but it's not the original focus/source and that has an impact on how things fit together, I'd say. Pylons tends to be more flexible, and maybe more webappy (à la Rails, which comes solely from the webapp side of web development).
My take on this one: Never consider only the mere technical merits of one framework. For most projects the thing that counts is documentation and community - and most projects are like that - they have deadlines. Sure, pylons is more flexible and you can swap components but you don't have the same "contrib" that you have in django. You should rather compare Turbogears2 to Django - Pylons is on a lower level, abstraction-wise. I see django as a framework made a lot of effort to make things real easy to learn and implement - and inadvertly created some nasty limitations. Take for example the ORM: making complex queries is impossible, and you can't control the output - what if you want to have control over what types of joins you have in a query? well - you can't. Or the slow and crippled templating engine (I won't elaborate on this one - just compare it to jinja). So essentially it's a tradeoff: Django - low entry bar, but limitations in subsystems - and you can't replace them because the apps in contrib are tight-coupled with every part of django; Pylons - high entry bar, but later on it *may* pay off. But this is largely irrelevant since you should be comparing django to turbogears2.
You mean you're looking for a framework?
Just do `while running:`. You don’t need `== True`. That’s the equivalent of saying, “If it’s true that it’s true that `running`.”
There are a number of things that all have to be lined up before you can get a program working on the web. Please don't take this as condescending. I have no idea what you know, I just want to make sure all the bases are covered, and you aren't missing some foundational pieces. A few questions: 1. Do you know how to write a web page using plain html and a text editor? 2. Do you know how to get that web page onto a server where you can view it online? 
In honesty, Google App Engine is probably the easiest to get up and go with. Django, while fantastic, needs you to sort out some stuff first (like setting up a database, a webserver, a python module for a webserver...). Whilst each part is fairly easy, it can take a while to get it all running properly. The [http://code.google.com/appengine/docs/python/gettingstarted/](app engine getting started tutorial) is a good place to get something working straight away that you can show people. In particular the chapters about "Hello world" and "Using the webapp framework". If you have any questions regarding any aspects of it, feel free to ask in here. 
Hi lumio, Think of "web" python programs like this: You hit a URL, a server program is running on the server and listening for these requests, it starts your python script file which returns a final HTTP response back to the user once it has completed (in a nutshell). webpy gives you a simple webserver you can run that listens for these messages for you (if you hear Apache2 with mod_wsgi, this is the same concept only far more robust). I assume you've tried the tutorial? http://webpy.org/tutorial2.en Once the server is running locally, you can view the results in the browser by usually pointing to (the webpy default) http://locahost:8080 So, if you have a function you want to run when the url '/hello' is hit, your function does some processing, and then can return a result. In the simple webpy examples, that could be as little as printing "Hello, World" or complex as redirecting the user, reporting errors, etc, but most of the hard work goes on in between the request handling and the final response.
Awesome, thanks. Great tutorial too, that was exactly what I was looking for.
You basically need a box with an ip address, and a web server listening for requests on that box. The web server looks at what the browser is requesting, runs some code, and then writes some text back to the browser.. usually in the form of HTML. You might try to get through a django or tornado (http://tornadoweb.org) tutorial. I think the latter is a bit easier to pick up.
Thanks, yeah I think I might try my luck there rather than my own server.
Well he can always start locally. $ python code.py Launching server: http://0.0.0.0:8080/ Is sufficient for hosting, and he can just print out plain text. 
Yes to both 1 and 2. I guess my biggest question is how does my .py file work on the web with what ever I choose. Is it something like the idle shell?
via [Tarek's Twitter](http://twitter.com/tarek_ziade/status/9135111252)
Ah ok. So they come to the page and it will have printed and then have some sort of input area and a submit button? or better yet do you have a link to a basic working example ? Thanks! p.s. I think after I make my way through these tutorials I'll be fine.
No. Essentially your python program will be generating HTML (or whatever content you want to serve over the web). Depending on what kind of program you write, you will also need to send HTTP response headers. You may be writing a CGI script, in which case the output of your program should look something like: Content-Type: text/html Encoding: utf-8 &lt;html&gt; &lt;head&gt;&lt;title&gt;A page&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;A page&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; In a CGI setup, you essentially have one python script per page, but the page has dynamic content, depending on your query string and any POST data you send to the page. A better option is that you can work with a framework like django or web.py or pylons which will abstract those details for you. Rather than having a script for each page, you have one (often) multi-file project, which catches all your HTTP requests, and then decides how to respond to them. 
If you're going with the most common server setup (Linux, Apache, MySQL, PHP), then your .py file will run through CGI. Basically, someone will visit http://your.domain.com/your_file.py, and Apache will execute that file. Anything that file prints out will be returned to the web browser. However, the web isn't as interactive as the console, so if your .py asks the user for input, there's no way for Apache to get that back to the user. You'll probably just get timeout errors. Your .py file needs to be able to take all it's input at runtime, and spit out everything all at once, without any interaction once it's started. On the web, this is done with forms. You get all the data you need from the user in a form, pass all that data to the .py file, and then it does it's magic and spits out the HTML you need. [Here's the wiki article on CGI](http://en.wikipedia.org/wiki/Common_Gateway_Interface) which should help you understand how to pass the information on from Apache to the .py file. Then [here's the python docs](http://docs.python.org/library/cgi.html) on the cgi module in Python. It helps take care of a lot of the basics in using CGI, like how to gather the data that Apache feeds to it. Everyone else seems to be pointing you towards frameworks, but I find it helps to understand what the frameworks are doing in the background.
aaah. *boosh* (mind explode) ok thanks it all makes sense now. Sweet I can't wait to get started. Also it feels good to have gotten that codemonkey off my shoulder.
Thank you so much for this explanation. I finally get it, and I can't wait to learn it. 
I never understood what the GIL was, until I found [this presentation](http://www.dabeaz.com/python/GIL.pdf) [PDF], also by David Beazley, which described some pretty horrible problems trying to run CPU-bound threads in Python. He found running processes sequentially was much faster than using threads in a multi-core system, and a threaded program will run even faster *if it is running on only 1 core!!* Wow.
In case it's not obvious, this is not a troll. David Beazley is one of the smartest guys around when it comes to the GIL.
In case you missed it ... the web2py books is [free and online](http://web2py.com/book). Chapter 3 teaches what you need to know. 
yeah the HTML will probably need a form, and a button.. much like a reddit comment box. ;)
Use appengine combined with [bottle.py](http://bottle.paws.de/). You have all the instructions for appengine deployment in the official [documentation](http://bottle.paws.de/page/docs#google-appengine). The framework itself is written in one file, so that you simply include it and start writing your code like this: from bottle import route, run @route('/') def index(): return 'Hello World!' I think this will be the easiest way for you to get a working app on the web written in python. Good luck. 
And this is an extension of that work. If you are going to PyCon you can hear it from the man himself.
I wish, but I'm nowhere near the level where I'd profit from going.
&gt; Twitter is over capacity. :(
His post says that the real world IO testing he did (with having everyone slam his server) uncovered a bad performance characteristic (likely on IO bound processes), he'll be talking about it and giving the full details in his PyCon talk. As a note he also specifically says he never would have found this without the real world test.
Where can I host and run my bottle projects, in the same way I use heroku to host my ruby/sinatra apps?
Thanks for the context; I was otherwise wondering why a single tweet had any significance. I use Python a lot, but I haven't gotten to know the community. I remember someone had been asking to slam someone's server earlier this week... 
&gt; David Beazley is one of the smartest guys around when it comes to the GIL. He seems to be quite experienced in gathering data. But oddly, he seems to operate in a vacuum. I'm a little surprised that his presentations are like a one-sided conversation. I would hope that the BDFL and other CPython designers would have some thoughts about his presentations. e.g. "OMG, good catch, this will be a tough one to fix!" or maybe "Yes, we knew that there were significant drawbacks from this design but SMP and NUMA hardware was much less common then than it is now" or maybe "Who cares, use multiprocessing or some other workaround."
Python web development is lot more fun than PHP web development. After trying Django and Google's app engine, have also a look at the excellent [Werkzeug](http://werkzeug.pocoo.org/) toolkit (Perhaps in combination with the [Jinja 2](http://jinja.pocoo.org/2/) template engine from the same author). It's very low-level and gives you a lot of possibilities. If you don't need all the bloated Django stuff or if you want to develop web apps the way YOU like, it's perfect.
Then I'm definitely glad I helped by letting `ab` loose on it all night!
Honestly the talks don't differ too much in difficulty from the pdf/presentation you've already read, so I'm sure you could handle it if you really wanted :)
Thank you, I just learned about something new (to me) and useful.
I'm sure in your case you want to learn all making a python web application but if you're ever looking for a really easy way to get some python code online give http://utilitymill.com a try. You can paste in the code, set up some inputs and whatever you print goes on the screen. 
&gt; searching on reddit I wouldn't normally say this, but... LOL
&gt; I would hope that the BDFL and other CPython designers would have some thoughts about his presentations. No, he's just loudly discovering what they've included on purpose. No matter the implementation, there had to be a trade off and the language designers (and especially Guido at the top) [are well aware](http://mail.python.org/pipermail/python-3000/2007-May/007414.html) of the costs/benefits and don't want to change it in CPython.
The new gil is only in 3+ right?
Twitter is not an appropriate medium to discuss programming stuff.
Huh? The very first thing you need to put on this page is a more succinct description of the project. Let me try: You've created a browser-based IDE that's intended to be used by designers working on a Django project. Amirite?
he discusses that too; he doesn't have time to blog while he's preparing his pycon talk.
Upvoted. I very much dislike how I have to scour the entire article announcing a new project/product, looking for wtf it is exactly. I finally realized what it is after I found "not TextMate, Emacs or VIM" and it put it in perspective.
What an awesome project! Could something like this be set up to remotely work on a django site? all files, not just templates
It's nice to be able to make someone's head go *boosh* once in a while. Happy coding!
In theory yes, there is also syntax highlighting for Python. However .. I'm not sure I would suggest it since some operations requires to restart the server (plus security concerns ..).
It's kinda hard to be concise while saying all I want to say. It's easy to dismiss this project for what it's not and the fact that I'm French does not help me to express my ideas in English as well as I would like. That said, *any* kind of help or contribution is more than welcome ;)
Reminds me a lot of the browser-based IDE that comes with web2py. It will be interesting to see how people react to this considering how people have reacted to the web2py implementation (which is not limited to only template files).
Can you elaborate a bit on that said reaction sir ?
The reactions have been mixed from what I have read. Some love it, some hate it (surprise!). The majority of the naysayers bring up the point that browser based editing can be security risk - if someone can get in, they can change your code. Obviously, this can be disabled on production in web2py, and looks like your system can be too. I say +1 for Django Ray - I like the idea. 
The old GIL is broken too. Just in slightly different ways....
Seems similar to the system I've been working on lately (http://github.com/coderanger/pynomic), except it isn't tied to GAE and doesn't let you edit code.
Hey man, don't take it as an insult. It takes balls to think that both an idea and your implementation of said idea is good enough to release to the world. It's certainly a cool looking project with a lot of promise. But us developers have a short attention span. Write a one sentence description of the project and put it at the top of the page. Sample code is also very good (though maybe not completely applicable to yoru project) These guys are doing it right: http://cukes.info/
but... why? What time or effort is saved by this? Designers who write HTML, CSS, JS, etc all have favorite editors already.
Well it depends pretty much on your development process and who you work with .. this project is certainly not a solution for everybody.
This is exactly what [web2py does](http://web2py.com/demo_admin). Because of the different architecture in web2py you can edit any file and never need to restart the server.
+1 to Django Ray
I love when sites like Twitter and New York Times decide that having their website in frames is UNACCEPTABLE. Oh well, since I deleted my account months ago I guess it can go back on the noscript shitlist.
If you read the parent you would see that he links to bottles documentation of how to run bottle in google app engine. I will link again http://bottle.paws.de/page/docs#google-appengine
Google App Engine is seriously the best!
Any idea where that link bug is coming from?
Pylons (including Paster) with NGINX
He's prolly trolling your perfectionist side with some backslashes ;-)
I would have thought that, but it happened to me a week ago or so. Weird.
Very nifty. I was going to work on a project with somebody, involving physical simulation, but stopped when we realized neither one of us wanted to write the actual simulation!
I discovered it the hard way. When I did some heavy multi threaded processing in python CPU usage wasn't going more than 33%. multiprocessing module works almost but when it doesn't it's pain in royal highness. 
I'm curious, how is the result meant to end up in a VCS? Because, like, if it's not in the VCS then it doesn't exist.
Yeh it's cool but I can't see the designers I work with giving up on their editors. To be honest I'd hate writing Python within a fancy textarea in a browser so it's understandable.
Yeah, no backslash trolling - it wasn't like that before. I'm sure of it. Maybe the new markdown engine reddit has put in? I wonder if they are aware of it.
Me too, minus the googling, thanks to you. :O)
No offence, but [whoooooosh](http://www.reddit.com/r/Python/comments/b0a0l/request_advice_on_web_development_in_python/c0kb4x0) :)
Seems like this should use Bespin. That also includes version control management, which would be handy for this. 
On one hand, this can be easily replaced by the SSH functionality in many editors. On the other hand, I don't need to give the designer SSH access to the whole machine or explain how to use it. On the third hand, I don't need to open another way for malicious people to steal/screw up my code. Never before has a project divided me so much.
Nice approach... somehow reminds me of a "Wordpress theme editor deluxe"... but definitely has its place in the django world. Can be especially useful if you want to fix HTML/CSS/Javascript quirks in IE, but develop your django project under linux. 
This sounds really useful to me! Often I need front end ammends done but there's too much involved in getting a front ender who's never used Django to set up a working build and database. Top stuff.
Well first it depends if you have to work with designers. If you don't, you're probably better off to stick to your actual methods .. &gt; On the third hand, I don't need to open another way for malicious people to steal/screw up my code. This is not the case now because it's only a working prototype, but eventually to access the editor you will have to first log on the admin interface .. I see it as a security concern only if you give the editor access to the main project's folder (instead of just media/ and templates/) or you give access to malicious people ..
Yeah .. I would really like to have used Bespin. There is LOTS of interesting feature in it (the console and VCS integration namely), but after trying to integrate it I quickly realized it was not quite ready for prime time and that it was way to much work to integrate. I would have ended up using it in standalone mode (losing most interesting features) and for what it's worth, Ray is currently build so the editor is completely encapsulated for the rest.. which means I can replace if I want.
This is why I need SVN integration .. it will work a bit like tortoise svn works ..
I'm more concerned about bugs/holes in the actual software, even when it's finalised. There are vulnerabilities discovered in software every day, so your best bet regarding security is to use as little of it as you can.
What terminal program are you using in the video? And heck even the VIM window that comes up.. what window manager is that in general? 
Followup: &gt; Ah hell. Just did a Python 3.2 benchmark that runs more than 300x faster on 1 CPU core than it does on 2 CPU cores. Die GIL die! http://twitter.com/dabeaz/status/9188761395
Okey, so IIUC, the tagline for this could be : Template editing TTW for django (through the web) - Or Zope meets Django 
did you go shopping instead?
Through the Web Editing for Django. Django, meet Zope. Zope did this in '98. We mostly moved away from it, but I think there are useful things we could bring back (to Grok): http://faassen.n--tree.net/blog/view/weblog/2008/09/19/0 
I like the idea, but wonder how it's distinct from something like [bespin](https://bespin.mozilla.com/) Maybe you can use bespin as a base? which gives you some scm, test and deployment built in.
Has OP checked out [nxt-python](http://code.google.com/p/nxt-python/)?
Really cool!
I would *much* prefer to see something like: &gt; from shell import shell &gt; shell('cat /etc/resolv.conf') I feel very uncomfortable with letting my namespace be directly defined by my filesystem...
As a ISP owner once told me; the only perfectly secure computer is an unplugged one.
Running bespin full fledged (with command line, VCS integration, file browser etc..) requires to use their backend .. which is something different than django. Their approach is very similar to what I want to do but not framework specific .. Initially I though I could tweak bespin to meet my needs but it has proven to be more difficult to do than to say. Edit: eventually a plan to support other editors (I know of a javascript Vim implementation and bespin can be used standalone ..). And even adding support for basic image manipulation (like resize/crop) could be a nice addition..
That's why I'm not talking about perfect security but about a balance of security and usability.
I liked how the syntax highlighting highlighted the `with` in `do something with data` at the end.
&gt; so to open a file, process its contents, and make sure to close it, What does that phrase mean? Do I or do I not have to use "close" after *with*, e.g. with open('text', 'r') as file: for line in file: pass file.close (Not a pro programmer by any means, and I always use *close* anyway.)
Usually you don't have to explicitly close a file, especially not for reading, but if you passed the file object to another library it might do something stupid like keep a reference to it. If you want to make sure a file gets written any time other than the exit of the program then you should close it explicitly. `with` statements are much cooler for things like locks.
Alright, thanks. 
I thought they were just explaining something wrong. Heh.
You do not have to use file.close() after the with in your example. As soon as the scope of the with statement ends, the file is closed.
I believe this issue is now fixed ;)
Did u notice any slowdown at the amazon EC2 latency or processing power during xmas? This was reported by some firms ( http://www.theregister.co.uk/2010/01/15/amazon_ec2_latency/ ) and is highly plausible, since Amazon probably uses their own EC2 infrastructure to run their recommendations algorithms and it's a busy date for them. Maybe reddit couldn't gather enough data to infer this, but if you have some highlight on this, it could be nice....
The whole point of using a with statement for opening a file is that it closes the file for you as soon as the with block exits. So this advice is good if you're *not* using a with statement, but if you are, you never need to close the file explicitly (in fact you'll get an error if you try, as it's already been closed).
Tell us more about Pylons!
Interesting. What did you want to know about Pylons that they pylons guys can't tell you?
I'll be there, and was planning to go to this talk anyway. Now that I know it's reddit-related, it'll be even more interesting.
Just your personal opinion of the framework mixed with some facts. Did it scale easily? Would you use it again if you were to start from scratch? Why Pylons and not Django, for example? Very general things like that. I've seen comments on other websites where people claim they were part of the reddit staff and some were saying Pylons had a lot of problems, so i'd like some clarity.
With some "magic comments" in your source files you can disable the checks that give false positives. Pyflakes is cool though.
Ah, ok. Thanks for notes. Will try to incorporate some of that. 
I'll come to your talk if you come to mine! :)
Which one is yours? :)
whoa, the fact that that's not a keyword usage changes my entire opinion of the article.
http://us.pycon.org/2010/conference/schedule/event/10/
No, I worked on a different project. The shopping meme is stupid, sorry.
oh so you do the coding too ? and is sharkgirl going to be there ?
Will it be recorded? Bit far from England! Best of luck jed.
I believe they will be recorded, yes.
&gt; oh so you do the coding too ? Not much anymore. I leave that to guys who are actually competent. :) &gt; and is sharkgirl going to be there ? No, but I'll bring another girl in her place.
Excellent, look forward to it.
Ok, I marked it on my schedule.
The only issue is if they forget to namespace the code, and don't test it against any community code using other frameworks. It is very easy to do this... though I'm going to wager that they don't do this... and it becomes a major issue. IMO the skill level of the community jQuery developers is severely lacking in comparison to others... every time I have to deal with a jQuery project it leaves a horrible taste in my mouth. It is for this reason I will use anything but jquery .... not necessarily because it is an inferior framework, but because the community is a bunch of monkeys.
Sounds like the using keyword in C#.
[from your textbook](http://web2py.com/book/default/section/3/6): db.comment.image_id.requires = IS_IN_DB(db, db.image.id, ') Is the last single quote a typo? 
I believe the with statement originates in Lisp and is probably much older than either Python or C#.
Should `file` not even exist after the code block? It would be such a a bad design choice if variable of `with` block survive the block scope.
tl;dr: With the new GIL the nonblocking IO operations release it and then have to wait for their turn, with the old GIL they kinda managed to snatch it back immediately. If you have some CPU-bound background threads, IO threads would have to wait for a relatively long time. The problem, restated: when an IO thread does a system call (such as `send`), it automatically yields, that is not fair in a case when the system call returns immediately. The IO thread in that case should have the remainder of its CPU slice to itself. His preliminary solution: modify all IO operations to try non-blocking IO first, release the GIL and go for a blocking call if unsuccessful. IMHO, impossible to implement =(. Blocking/non-blocking is a property of a socket (for example), setting and resetting it would incur a terrible performance penalty, unless we are OK with having that property on the Python level only, with runtime emulating it for us (i.e. all IO is really nonblocking, but Python provides us with the efficient blocking primitives). That seems like a good idea, actually! Also, trying nonblocking op first would NOT incur any terrible penalties, because when it fails it means that we are going to wait for milliseconds or worse anyway. Still, it means patching a hell of a lot of code, most of it in C. More drastic solution, as proposed by me, would be to dispense with OS threads and scheduler entirely and have our own scheduler with priorities, IO boost, blackjack and licentious women.
I think that's only true for cpython (and a few other python dists), not in say jython (which is the example that I've been hearing about). Thought... who uses jython? (serious question, I've never heard of a project using it).
By "explicitly" I really meant "not due to going out of scope". so maybe not so explicitly.
Is the clusterborked search feature a result of your predilection for Python or just laziness on your behalf?
in any python that supports the with statement, the file.close() above is redundant. (It also requires parens, but ya know)
It's not a bad decision because that block doesn't have its own scope, just like an if statement doesn't. You can mentally translate that code to: file = open('text', 'r') try: for line in file: pass finally: file.close()
Jython is almost exclusively used by people who aren't talking about it :D Corporations that need python to play nice with their existing infrastructure, it's also used by the Joint Strike Force people AFAIK.
I think I get it, but "thing" and "something" were confusing metasyntax.
Since python doesn't has a way to simply introduce a scope, anything you translate to a Python equivelant will pollute local vars namespace :-) In my view `with` block introduce new scope like loop variable in `for` loop should. But, well, Python also left loop variable live after the loop body. So I guess if the behavior is unconventional, at least it's useful to be consistently unconventional. ADDED: To clarify the last statement is not a complaint, it's an acceptance. Different language has different tradeoff. This behavior probably works suiably for a language where variable is created simply by assigning to it. This problem wouldn't happen with language that require a keyword to declare a variable, I guess we'll have to live with it. But at least it's consistent. 
Search is a 3rd party app written in Java, actually. And to what lazyness do you refer? The fact that we don't just put a google search box in there? That is on purpose. Our search and their search do different things. They can't sort by points like we can, for example. We also can't just use their API, because it costs money with the number of requests we do. If we change it, we want to do it right.
This has been around since how long? I must rewrite a ton of scripts now.
Do we require additional ones?
I've been using [Awesome](http://awesome.naquadah.org/), but there are [several](http://dwm.suckless.org/) [different](http://xmonad.org/) WMs with no window decoration. In fact, I think you can turn it off yourself in KDE and GNOME.
I'd like to have been sure that the "return thing" and the "with ... as thing" didn't refer to the same "thing" symbol. If not, maybe "return that_thing" and "with .... as my_thing" or something similar would have made the example clearer.
It originate as a pattern in Lisp but not yet a standard protocol, you end up with hundred of `with-xxx`. C++ with RAII/destructor is the early one with well defined "override this method and people will be able to use it the same way". 
Yet the complaints have been coming for two years at the very least. "Wanting to do it right" is a legitimate excuse when you're deferring the implementation of a feature between point releases, not when you've switched your entire production system to an entirely new stack in the meantime (as you've done with your transition to AWS). I personally am not as invested in the search functionality as some other users seem to be - I suspect that that's because I've been here forever and wouldn't even consider searching through reddit outside of google - but if "search by points" is your crowning achievement and main design goal then keep in mind that since your collective assertion regarding the inviability of "sort own comments by karma"-due-to-lacking-resources is to be believed then you haven't made any ways forward in regard to basically *anything* that would make your claim viable. Release something non-trivial and you'd see less complaints; investing *all* your effort in scaling up and out is essentially stagnation as far as long-time users are concerned.
Yes, but we need more minerals.
Will you be coming to PyCon? If so, I'd be happy to continue this conversation there. But briefly: &gt; "Wanting to do it right" is a legitimate excuse when you're deferring the implementation of a feature between point releases Search has worked fine for the last two years, up until about 2 months ago, when the Lucine could no longer keep up. We started looking at new solutions at that point. &gt; not when you've switched your entire production system to an entirely new stack in the meantime One has nothing to do with the other. We only changed the underlying hardware. Changing search at the same time would have complicated things. &gt; search by points" is your crowning achievement and main design goal It is neither, just one example of how our search differs from Google. &gt; then keep in mind that since your collective assertion regarding the inviability of "sort own comments by karma"-due-to-lacking-resources is to be believed then you haven't made any ways forward in regard to basically anything that would make your claim viable. Again, one has nothing to do with the other. One is run out of Lucine, the other our own database. &gt; Release something non-trivial and you'd see less complaints We will soon. We're talking to some partners right now about redoing our entire search stack. &gt; investing all your effort in scaling up and out is essentially stagnation as far as long-time users are concerned. We don't. In fact, we roll a couple new features a week these days. You should read the blog to keep up on them.
I don't know much about Mathematica, but you could always include the cost and portability of python code. With numpy and scipy, python can be very fast for numerical calculations, and if its still not fast enough, it can be easily extended using FORTRAN, C, C++, Matlab (or Octave) and R through a range of libraries to extend it.
You have access to every last photon of my interaction with reddit; check the logs and you'll see I lovingly and devotedly (ab)use your lovely new features to no end but it still bears little relevance to the fact that you've had a search feature that hasn't received a single compliment during the Obama Administration, and that's being generous. Now in reverse (edit: strikethrough reverse) order and on a paragraph per quote&gt;reply basis: I wish I could come to PyCon (the first and only time I was there was a lovely and rewarding experience) but I run a business that's been keeping me from anything even remotely interesting for the last two years. Changing diapers and burping marketing people takes a lot of time... Search worked beautifully for the last two years if your criteria were speed and unconditional pattern matching. If your goals, on the other hand, involved the need to find a comment thread or submission based on anything remotely fuzzy then you were inevitably out of luck. Regarding your transition to AWS I was implying that you invested a lot of time in what was ostensibly a period in which you were forced to approach all of your infrastructure and code in its entirety for the first time in ages. This could have given you an opportunity to revisit your code to a level that hadn't been afforded to you in the past and implementing an improved search would have been met with a lot of gratitude from your community (and spared you quite a bit of *ingratitude* since). Nobody asked you to meet or exceed google, just function reasonably. I wasn't making a blanket assertion, I was addressing a mindframe. last two paragraphs addressed in the first. In any case, best of luck with all of your future search-related endeavors...
I haven't used Mathematica in a long time, but Python + SciPy is very nice for the type of things Mathematica is good at. I found the following in my bookmarks, which might be helpful: * http://www.larssono.com/musings/python/index.html * http://www.larssono.com/musings/matmatpy/index.html 
You should be more concerned by making sure their choice isn't C++. Mathematica is fine, though a bit ugly. Students shouldn't have to spend $100 or however much the student edition costs. And there's this: http://www.pythonxy.com/foreword.php 
I agree you about C++. I singled out Mathematica the most simply because C++ doesn't seem to have much traction within the department. Thanks for the link, it seems really interesting!
Well, first there's a good economic argument; Mathematica isn't cheap, although I'm sure student discounts exist. Second, Mathematica experience doesn't generalize as well as Python experience does (although if you restrict the domain to the sciences perhaps this isn't true). Third, I doubt that Mathematica has anywhere near the rich ecosystem surrounding it that Python does. Finally (and possibly most arguably), Python is general purpose to the point of being Silly Putty, while Mathematica is more narrowly focused but probably can be called upon to perform in more general ways. I guess as I review this list, I see that I'm mostly making practical arguments and not technical ones. But I haven't touched Mathematica since the NeXT, so I'm way out of date on how it looks these days (it was pretty cool then, to be fair). But at the end of the day, you have to work back from the evaluation criteria your department is using. It may be that for whatever is considered most important, Mathematica may be the most appropriate choice. If the criteria are lined up to favor Mathematica, perhaps they need to be questioned more closely.
Last year they recorded everything and put them all up on blip.tv http://pycon.blip.tv/
(Physics grad student speaking here, with plenty of experience with both Mathematica and Python in real-world research use.) Mathematica is a *terrible* choice for a physics department's "official" language. If you're a theoretical physicist, you might scratch your head at that. If you're an experimental physicist who's written a single line of code in your life for an actual experiment, you know exactly what I'm talking about. Mathematica does math, and it does it well. It's also pretty decent for data analysis, though I have to say I wouldn't make it the core of my analysis pipeline. But Mathematica cannot do anything but math. And on a real modern experiment, you need software to control the thing; Mathematica cannot do this. Python can, seamlessly: it's a full-powered programming language with complete I/O capabilities, as well as a C extension layer that's widely supported and interoperable. On the last experiment I worked on, large parts of our experiment's control software were written in Python... along with the mostly-analytic code I wrote. My contributions could have been done just as well in Mathematica or Matlab, but neither of those two can easily implement any general-purpose control logic. There's just no contest, from an experimentalist's point of view.
I think it's people that must use Java but like Python better :)
Thanks for the tl;dr. I didn't have time to read the whole blog pos--er, bug report.
Thanks for your reply, good points! This is consistent with all of my experience as well.
SAGE (sagemath.org) is trying to become the standard open source math toolkit and it uses python as its language. Their site has some material (talks, papers) on why SAGE is better than the proprietary options. It's specifically written by and for academics. 
Yeah, in lisp you have a bunch of things like: (with-open-file (stream "foo.txt" :direction :output :if-exists :supersede) (format stream "Hello, World!~%")) So it makes `stream` be a file handle into foo.txt. When you leave the `with-open-file` the file gets closed. It also gets closed if there's an error (what would be an exception in other langs.) The `with-foo` pattern is a common name for something that gives you a handle on something and then also usually protection from exiting that block without cleanup. 
Many of my courses also require coding. I am happy to say that mine accept submissions in Python. Though I can't offer much technical reasons, I can say that Python is far easier to learn. I spent hours browsing through Mathematica documentation in my attempts to learn, whereas Python was incredibly easy. Learning Mathematica was not a good experience.
MIT's Introduction to Computer Science is [taught in Python](http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-00Fall-2008/CourseHome/index.htm) (which is why I finally decided to learn it and django at the same time. Was raised on C++, Java, and some Scheme.)
I couldn't agree more. I have written my fair share of monte carlo simulations and Runge Kutta routines. Python has suited me well for all of my computational needs. As for Mathematica, I just consider it a library of blackbox routines that are really only good for finding analytical solutions to equations...like a giant TI-89.
I was going to post your first argument, and Wikipedia says it pretty good too: &gt; Mathematica is proprietary software restricted by both trade secret and copyright law. If the idea is to use it for academia, IMO you should be able to check both the tools (the Mathmeatica engine) and how it is being used (your code).
Made even more awesome once you see http://pycon.djangodose.com/
I wish I could afford it :\
narwhalgirl?
One great thing about Mercurial is that you can just type 'hg serve' and it will set up a simple web server on port 8000 that you can view in a browser and push/pull changes. http://padcom13.blogspot.com/2009/06/mercurial-using-hg-serve-to-push.html
This. I also have experience with both Mathematica and Python in physics work. Mathematica is great for graphing complex functions and for solving integrals when you're feeling lazy. Python is good for solving problems that you specify.
That's what's it's always seemed like to me. I hear that there are ways to actually write code in Mathematica, and compile it too but I've never seen any examples of this.
IIRC, PyCon allows you to make your case (hardship/low income etc) for why they should give you a free or cheap registration.
I could have afforded the ticket. I was looking into it way back in the super early bird specials, plus im a student. Travel + Hotel is what kills me.
There's always [Couchsurfing](http://www.couchsurfing.org/profile.html?id=56YYYAP)
This is very true, but it looks like PyCon starts tomorrow :P maybe next year. I'm also aiming for DjangoCon this year in portland :)
`from __future__ import` in Py 2.5; out of the box in 2.6+.
&gt; Since python doesn't has a way to simply introduce a scope There’s `def` but I guess for a lot of people that doesn’t count as “simply”. I personally was surprised when I learn `with` doesn’t create a new scope. But I can see why it doesn’t. 
The big difference between Cpython and not-Cpython is if you do something like `data = open(my_file, "rb").read()` in Cpython the unnamed file object gets garbage collected immediately, since Cpython works by reference counting and after that line there’s no references to the file object. When the file object is GC’d, it’s `.close()` method is invoked, and this frees up the file on your disk. Most (all?) of the non-Cpythons use a different kind of garbage collector, so the file object isn’t guaranteed to get collected right away. It may take a while, which doesn’t matter for small everyday scripts, but for bigger projects, you may need to free up file objects as soon as possible. In that case you can just manually `.close()` it, but the `with` statement is a little more flexible and convenient. 
Ah, dont get mad. Hey if it makes you feel better, I almost did something once too, and then didnt.
Seconded. SAGE is amazing. It may be a bit behind Mathematica for doing symbolic calculations, but it can do as much as most undergrads need. Furthermore there is also Sympy as an alternative computer algebra system. Python has all the advantages of being a full language with immense support in real applications, and it loses no power symbolically as well. Instead, you no longer need to fumble with data import in mathematica because python, as a scripting language, excells at data import. Also don't forget to mention that other departments should be able to interoperate with such a standard language.
yes. sorry.
One of the things I was hoping for with the 'with' statement was the ability for the context manager to skip execution of the block. I don't think this currently works -- and in fact, testing out "break" and "continue" in seem to indicate there's no way to get this behavior from the body of the block statement, either. Does anyone know of a workaround? I'm thinking mainly of a use case where the 'with' block sets up, say, an MPI-parallel context that may not concern all processors, with a subcommunicator for those that need to handle the data. (edit: Upon hitting submit, I realized that perhaps the way out is by raising an exception that gets caught and handled by the context manager; but I sure would like to be able to handle this from the getgo, rather than raising an exception inside the body of the with statement.)
Mathematica and Python serve different purposes. Mathematica is a great symbolic engine. It can handle symbolic manipulations not just of ordinary algebraic expressions but, for example you can define your own commutation and simplification rules and that is important if you want to apply it to group theory or Feynman integrals or quantum mechanics in general. Other things Mathematica can do include handle tensors of symbolic expressions, integrations on the complex plane or other spaces, expand spherical harmonics. This stuff is critical in solving electrodynamics problems. This is routine stuff for most physicists. Stuff that no Python library can handle. If your department can afford Mathematica you would do a disservice not to use it. That said Python should play a role too. In fact students should learn to code some of the algorithms that Mathematica implements (the numerical ones, not the symbolic ones) to understand their limitations and pitfalls. Python is a good way to do it. Python also provides an interface to various 3d libraries (from panda to visit) that have no equivalent in Mathematica. I would say Python in better for classical mechanics, Mathematica is better for quantum mechanics.
This is really sharp. It completely removes a lot of crufty code needed to process args and simply lets one get down to business. Not to mention the automatic validation and built in help. This goes in my toolkit today.
Seriously, is self.reddit going to be your first stop for ever single question you encounter whilst learning to program? Every single one? You've already posted three self posts about your Python class. At this point, we should all get class credit.
Woah, how weird. I'm working on an NXT project for University at the moment, but I've been using [leJOS](http://lejos.sourceforge.net/), which is Java based. Looking at the documentation for NXT-Python, I think I'll be sticking with leJOS. Honestly, how can a project be at 1.1 and have documentation like that? Edit: They also have barely any samples and I've not got time to "read through the source" to figure out how it all works. C'mon guys, documentation!
Oh. My. God. Mind blown. WHY HAVE WE BEEN DOING THIS WRONG FOR SO MANY YEARS???
To be fair... Python code is usually very concise and easy to read through. But yeah, I feel your pain.
People complained about the Tweet being too short.
python is by far the best language. and with stuff like vpython you can easily SEE what is going on.
Looks similar to the optfunc lib Simon Willison wrote: http://github.com/simonw/optfunc
It's incredible how many command line parser libraries for Python there are (not even counting the two ones in the standard library). So far my favorite is [CommandLineApp](http://blog.doughellmann.com/2008/06/commandlineapp-30.html), though it seems [argparse](http://code.google.com/p/argparse/) has been gaining traction lately. And this one looks promising too, I'll give it a try. Has anyone made a systematic comparison of all these libraries? EDIT: It's not working for me right now; trying out examples from the README throw exceptions. I'm using Python 2.6, but from the README I gather it is not a Python3-only library. Seems like it is still in development?
In Jython the file will be closed at the end of the `with` block. But the now-closed `file` object may not be immediately garbage-collected in Jython, due to the way the JVM's GC works. And, of course, having a closed `file` object still in memory is not the same as still having the file open.
(Background: I am a mathematician and programmed Mathematica applications for college education for 5 years. I've been living clean for a couple of years; I use Python + C and SAGE now.) Just to point it out: Mathematica is pretty bad from a mathematician's point of view, as well. Why? It's obviously great at doing mathematical computations ... well, at least, we think it is. But since the algorithms are proprietary, we can't know for certain what is really going on. And this is a bad place for mathematicians to be in, since the entire point of doing mathematics is to figure out what is going on, in a given situation. Mathematics software needs to be open source; proprietary does not fit the spirit or needs of the mathematics community. Stein (creator of SAGE) and Joyner (major contributor to SAGE) wrote an [editorial for the Notices of the American Mathematical Society](http://www.ams.org/notices/200710/tx071001279p.pdf) a while back, discussing this point. Mathematica is really great in a couple of areas: (1) teaching math courses (I used to teach at a school with a Mathematica license, and used it almost every class period in diff eq); (2) computational decision processes in industry, where you need a combination of symbolic and numerical routines that work really, really well together. From my point of view (applied mathematician, in dynamics + probability = complex systems), Python + (C or Fortran) is the way to go. [Langtangen's book on Python scripting](http://books.google.com/books?id=YEoiYr4H2A0C&amp;printsec=frontcover&amp;dq=langtangen&amp;client=firefox-a&amp;cd=2#v=onepage&amp;q=&amp;f=false) demonstrates some great applications of Python for a physics audience, so that might be a good source of argument points for you. The other big point to make is that while trivial Mathematica computations are, well, trivial, Mathematica programming has a pretty steep learning curve. Programming Mathematica well really requires a good grasp of the functional programming paradigm (things often run more slowly in Mathematica if you use procedural structures like for loops). And that can have some bad consequences; imagine picking up a copy of Numerical Recipes, and instead of having to just tweak one of the algorithms, you have to entirely rethink the logic and recode the thing (been through that a few times; you get better at it, but it still sucks).
Ok so the next question - Can you post your prompt config? It looks very nice, is that custom or from some package? :)
Does it support tab completion?
Everything should be a command line app.
Very nice. I'd like a way to specify a lone command that doesn't take subcommands. There's the `"default"` argument to the decorator, but that only takes effect if the first argument doesn't look like a command. I'm thinking something that gets executed regardless of what the first argument looks like. Maybe something like @baker.command def __command__(arg, arg, arg): stuff Though, thinking about it, maybe nothing else "looks like a command name" if there are no other command names available. I'll have to play with it a bit. All around, this is pretty cool.
I am on the pycon recording team. Assuming all goes well, all talks will be recorded and uploaded, yes.
Thanks.
The thread you linked to is irrelevant. Dave started off by highlighting problems with GIL contention on multi-core machines. A new GIL was implemented in python 3.2/2.7 to alleviate these issues. The "new GIL" has new bugs that haven't been discussed.. This is *not* something they "included on purpose"
I found at least 2 places that have this "typo". I think the usage of IS_IN_DB in this book is not quite consistent with its usage in some other examples elsewhere on the website. Looking into the documentation of IS_IN_DB doesn't seem to help (a little cryptic): http://web2py.com/book/default/docstring/IS_IN_DB As web2py is claimed to have a small set of built-in functions, it'd be great if we have an excellent documentation of these functions (e.g. what each parameter means and a typical usage.) Thanks.
How is the Java threding model? does it have a GIL? it have a virtual machine, does it limit one thread at a time int the VM?
The file object still exists, but the file is closed, and trying to access the file outside of the 'with' scope will raise an exception. Python variables defined within the scope of a function exist until the function itself ends. While I understand where your comment if you have a C++/Java background, in Python you can access any variable inside a function once it's been introduced, whether it's a loop variable or some other type -- the scoping rules are simply different.
[I believe it's true for jython as well.](http://jythonpodcast.hostjava.net/jythonbook/en/.98/chapter6.html#context-managers)
It don't help. Titles overlap text. Firefox 3.0b5
Looks nice but my only concern is that with the decorator style, the definition of command line arguments are spread all over the code rather than in one data structure. It seems suitable for scripts like Django's manage.py but not as a general purpose command line parser..
What are you talking about? My first was about my very first program and they taught me how to make it better and some of the right practices. I wrote all the code. This one is to learn. and the last was a funny story. 
I found [Phil!'s ZSH prompt](http://aperiodic.net/phil/prompt/) a while back, and have been loving it. I've dropped my [.zshrc here](http://qwerjk.com/.zshrc), in case you're curious. If you're still using bash, [it really is worth switching](http://friedcpu.wordpress.com/2007/07/24/zsh-the-last-shell-youll-ever-need/). Your .bashrc should transfer over to zsh just fine.
It is nice to have all this in one place, but sometimes you just need to throw something together that works.
Can't wait to watch the screencasts!
This might be a good cause to overload `&lt;`, `|`, etc. So, one could say `shell &lt;&lt; "ls -l" | "grep blah" &gt; "output.txt"` or some such.
&gt; first there's a good economic argument; Mathematica isn't cheap, although I'm sure student discounts exist. I think this is actually a pretty big deal. Yeah, the department can probably cover the costs of its lab machines without too much hassle, but for students, not being able to install Mathematica on a home machine is a big deal. It means students will _only_ do things for class, never just for fun or to see what else they can do.
Yes it is. They didn't just fart out a new locking scheme, many smart people examined the options and selected this as the direction worth pursuing ([starting in this thread](http://mail.python.org/pipermail/python-dev/2009-October/093321.html)). Also, David never bothered tuning the newly exposed parameters for his application. From the release notes: &gt; Among the objectives were more predictable switching intervals and reduced overhead due to lock contention and the number of ensuing system calls. The notion of a “check interval” to allow thread switches has been abandoned and replaced by an absolute duration expressed in seconds. This parameter is tunable through sys.setswitchinterval(). It currently defaults to 5 milliseconds. 
Yup. The `get` function from the first code sample is busted on python 2.4 (I know! I know! I'm stuck on RHEL 5 at work). If you add an option to it, it works (`verbose=False`) for instance. 
That fix doesn't make things much better. For example, in a say.py program: @baker.command def say(word="foo"): """ say word """ print word As you observe, the default (word="foo") keeps the program from crashing when run without arguments. If I run 'say.py say' with no arguments, it works and prints 'foo'. However, if I run 'say.py say bar', it terminates with ... backtrace ... raise CommandError("Too many arguments to %s: %s" % (cmd.name, " ".join(args)) baker.CommandError: Too many arguments to say: bar edit: Oh, wait: if I run the program as 'say.py say --word bar' it prints 'bar'. 
&gt; I know! I know! I'm stuck on RHEL 5 at work Are you me? I went through the same Excitement -&gt; Letdown today too. :( Maybe I'll write a fix for 2.4 tonight... This would really be useful for me as I write a ton of one-off scripts.
Yes, that thread is much more relevant ;) Your premise was that David Beazley is just loudly discovering what everyone already knows, which simply isn't the case. He is the first to bring forward extensive data on GIL contention with multiple cores ([python-gil-visualized](http://www.dabeaz.com/blog/2010/01/python-gil-visualized.html)), and he reported the "Convoy effect" bug for the new GIL. I'm not saying he's 100% correct on this, but we can't dismiss it altogether, when even Antoine Pitrou (who wrote the new GIL) agrees it could be a problem. 
Your shell must do that. For example, newish bash has [custom tab completion](http://aplawrence.com/Unix/customtab.html). You just have to specify what options it should provide for completions.
Also look into spirit airlines if they're in your area. Join the $9 club and get awesome deals all the time. I'm flying round trip from south florida for 90 bucks.
So many good talks overlapping! I'm definitely considering attending this one.
Hey, cool! Out of curiosity, you know how they stick your head in a window on the bottom right? how big is that window?
That's not Pythonic at all though, is it? Might as well just use /bin/bash.
Is pythonic an issue when we’re trying to make a copy of a Perl module? More to the point, there’s something to be said for being able to pull text out of the shell and into Python then mess with it. Since the best language for doing shell stuff is /bin/bash anyway, why not use that interface where it’s familiar? 
You quickly run into problems doing it that way though. No error handling, no flags / options, no coercing arguments, no help message, etc.. As soon as you start adding those you are rewriting the functionality provided by a library like this, which is a waste of time IMO. I'd rather just use a nice library like this.
I'm sorry but what we are talking about here are not shell scripts but commands that handle switches for example, in Linux we have ls --long --all Your example here is just as shell script. Check out optparse to get an idea of what Baker is trying to simplify. BTW there was a project being developed to do similar for Django commands. Any news about this??
MUST.. RESIST.. BUILDING.. A WEB FRAMEWORK.. BASED.. ON.. THIS..
Probably not the best place to ask, but.. If I wanted to get started with the NXT stuff, can someone point me in the right direction? I want to know what to buy (i have nothing at this point), how to set it up.. etc. Look at the Mindstorm website, it looks like the NXT controller block has to be programmed before hand and then allowed to work on it sown.. is this true? Or is real-time communications between it and a computer possible? Also, based on this project (and leJOS) I'm guessing using Lego's "visual programming language" is not necessary to actually use this thing? :)
I think being Pythonic is an issue, yeah. And so does the author of shell.py, judging from the blog post. As to your second point, I agree that executing binaries and using their output is useful; for that I use the subprocess module. It'd be trivial, for example, to write a version of subprocess.call() that returned (exitcode, stdout, stderr) like shell.py does. But, yeah, using the shell is best for shell stuff, like you said.
Oh cry about it! I'm stuck on *Windows* at work! D:
One of the comments at: http://www.mechanicalcat.net/richard/log/Python/Something_I_m_working_on.3 suggested using python decorators for event handling. I think it might be cleaner.
Are there any usage examples for this?
&gt; Whoever said I was trying to replace optparse? You did: "Here's an example of simpler alternative to this library." People are dissatisfied with the standard library modules for command line tools, so they create their own. Big surprise. If someone creating a new command line library gets you all worked up I wonder what you think about the zillion non-standard web frameworks.
There isn't really a way to reliably encrypt a password. It's fairly trivial for anyone who wants it to figure it out because the encryption key/method are right there in the code. Here at work we have a copy protection system that needs a password (the project is in C++). Rather than store it in plain text we generate an encryption key randomly whenever a build starts, pull the password from a file and generate a source file containing the password encrypted with blowfish using the randomly generated key. The key itself needs to be stored though to be able decrypt the password. The point of this isn't to make the password unretrievable (you can't do that), it's to make it more difficult to retrieve. You want amateur crackers to have more difficulty cracking it than they are willing to attempt. An accomplished hacker will figure it out without too much trouble regardless of what tricks you use to conceal it. You could send off the action to a server that privately stores the password and have it actually make the request but that isn't practical in most cases.
Use keychain/kwallet or something else.
The grade of encryption doesn't particularly matter for this purpose. All that encryption provides is obfuscation so that people looking over shoulders can't casually read it.
Nice updated site.
If it's a password you really wouldn't want anyone to get hold of (e.g. banking), you shouldn't store it at all. There's no substitute for making the user enter it every time. If it's something that doesn't matter, just store it in plain text (that's what most web browsers do). For something in between, the operating system you're working on will probably have a "proper" way to do it for you; e.g. Gnome Keyring, OS X Keychain, KWallet, etc. (This usually means it'll be encrypted when the user's logged off, but automatically decrypted (by default) when they log on -- so not "secure" against someone coming across a logged in computer. If the password is important enough for this to matter, see first paragraph above).
If you're using gnome, hook into the Gnome Keyring API. It's poorly documented, so you might appreciate this example script that I wrote to store a wireless password: http://pastebin.com/f2c013bf5
So no chance i can use ConfigParser for this? :P
A quick Google search for "ConfigParser gnomekeyring" turned up [this result](http://pypi.python.org/pypi/keyring), which is surprisingly useful. They did what I expected: use ConfigParser for everything but the password, and then Gnome Keyring for the password.
You should look in to http://pypi.python.org/pypi/keyring it handles all of the mess for you. 
really depends on where this app is going to be running and what it's going to be doing.
Those can be used from the Keyring unified API. So its better to use Keyring I guess.
This is a good solution for securing local data, but it's kinda useless for any server deploy.
I = retarded.
There is a right way to do this, but it's HARD. You set up a centralized server for your master keystore that can only be brought up by hand -- someone has got to know a a pass phrase to bring the machine up, it's the only way to give strong encryption to on-disk secrets. Fault tolerance is left as an exercise to the user. Next, you invent a way for your server machines to get audited. You list a set of authorized machines in a database. When they come up, they connect to the key distribution center, and if they're authorized, you attempt to audit them (md5 of the kernel, scan for SUID binaries, what have you), and if the machine checks out, you give it the secret over a secure connection. But you can only raise the bar with this sort of thing. I haven't too often seen such a simple question that opens such a can of worms. Maybe a young child asking about god.
err... no. If he encrypts it he'll have to store the unlocking key with the encrypted password itself. In this particular case it HAS to be reversible, therefore not really secure. But encrypting it and using OS trickery to store the private key might be useful (use a unix socket to talk to a service that runs as another user that has access to the private key and encrypts/decrypts the password) and you *MIGHT* mitigate your code being stolen. But if you're compromised you're still fucked because eventually somewhere in the line the password WILL be plaintext. What this guy needs to do is just store the password in a config file, and if it ever gets compromised request a new secret key for the API.
I love Zope, but I'm not sure I want an object sore, ewwh
You're right, I wasn't taking into account this particular case of using encryption, just the idea of encryption in general.
Also durus is an excellent lightweight object db for Python: http://www.mems-exchange.org/software/durus/
easy\_install should die. It is anything but easy. I shudder whenever I find anything distributed as and egg or suggesting easy\_install. I just find the tar.gz and go for setup.py install. Anybody else feel this way?
The problem you are describing is almost exactly the same one facing DRM. You have some data that you want to protect, but you need to store it at an unsecure location. DRM usually solves this by encrypting the data, and then hiding/obfuscating the encryption key. No matter how you look at it, it's just a form of obfuscation, which is why DRM systems never last very long. Solutions like Gnome Key can, with the help of the session manager, use the password or other session information as the base for the encryption key, meaning that the attacker hopefully needs you password to crack the key ring. This can work pretty well on a desktop machine, but on a server, you're usually not logged in, so this doesn't really help. If you're serious about security and want to actually solve this, the only simple way to do it is for the machine to prompt the user to enter the password at startup and then only keep it in memory. Even if you do that, there are ways for hostile applications to sniff the password if you're not careful. Most people just give up. Most web site for example store the DB passwords in plain text config files.
&gt; It should obviously be encrypted, but how? This is not at all obvious. Ultimately, the application has to be able to decrypt the password, which means the key has to be some place readable too. If someone can read the config file, chances are they can read the key. You're only obfuscating. (Unless, of course, you're willing to have the user enter a key on app startup.) Some apps at my workplace do this, and it's caused developers plenty of headaches. Often the passwords are for databases, and we'd like to be able to connect from a client using the same credentials as the app to diagnose some behavior. Just put the password in the config file and make sure that it's only readable by the appropriate users.
Zope is great and terrible all at once. The upside of it is that it's remarkably well thought-out. The downside of it is that it's also very well thought-out. Does anyone actually use ZODB for anything other than a Plone backend?
Create a ssh public / private key pair between the servers and let it go passwordless.
&gt; &gt; Search is a 3rd party app written in Java, actually.
tl;dr
&gt; &lt;starcraft joke involving pylons&gt; wat
&gt; &gt; &lt;starcraft joke involving pylons&gt;
Wait, I always thought your name was Jed Berg? Dont permaban me to hell plz.
read the [test file](http://github.com/rfk/withhacks/blob/master/withhacks/tests/__init__.py).
I wrote [one of the articles](http://billmill.org/multi_line_lambdas.html) mentioned in the package description, if you have any questions I'd be happy to answer them.
Nope. Jeremy Edberg. J Edberg. jedberg. My ego isn't nearly big enough to ban you for getting my name wrong. :)
if you're on a *nixy sort of system, store it in a file that can only be read by a particular user, which your app runs as. 
Strange game. The only winning move is not to play.
Whenever I read about Python I immediately think of Monty Python. And this title just makes me think about the sketch from Holy Grail :)
Come here to say: it is a great news!
That's... kind of the intent.
Store the encrypted password in an env variable. You can hard code the name of the environment variable if you like but it just puts a layer of security between your script and your "sensitive" data.
The language is named after Monty Python, not the snake. 
I hope you are aware that python is actually named after Monty Python.
According to Python.com it's named after a man's genitalia.
I always did wonder, but I thought it was too much of a coincidence to ask. I didn't want to sound.. silly...
Can I replace my system's Python 2.6 with US 2.6 right now? Is it production-ready? If yes, how can I do it?
And python continues to approach perl ...
's
While imperfect, this is a very common solution. You can even make it a root-owned file and drop privs after loading the config. For bonus points, ssha the password and store that in file.
nice.
Since when is being well thought-out a downside? I use the ZODB all the time with Grok. I know the ZODB is also in use with other frameworks, such as BFG. 
I'll take that; thank you.
&gt; Since when is being well thought-out a downside? It's a tremendously detailed tool. That combined with a paucity of documentation (at least last time I used it a couple years ago) makes it *hard* for people to get started with it. Thanks for the info about Grok and BFG!
Hm, I think the average object relational mapper actually requires far more learning than the ZODB does. The basics are in fact very simple. But the paucity of easy to find documentation *was* a problem that hopefully has been taken care of at least to some extent with this website. The ZODB is not difficult to use stand-alone in a basic configuration, here's something I wrote a few years ago (also linked on zodb.org): http://faassen.n--tree.net/blog/view/weblog/2008/06/20/0
The first thing you have to learn when you start with Python, the difference between python.com and python.org.
I for one am not very pleased with this development. C++ dependency and the entire LLVM tool chain to compile Python? No thanks.
Could you explain why you think this is a bad idea? I'm not disagreeing, just curious.
http://www.python.org/dev/peps/pep-3146/#addition-of-c-to-cpython &gt; C++ can be disabled via ./configure --without-llvm, which even omits the dependency on libstdc++.
It dramatically increases the size of dependencies for embedded developers.
Why were embedded developers using Python, the most interpreted, runtime-heavy ("batteries included") language since Smalltalk?
Try using a language that's designed for systems software and performance rather than for being easy to code in.
Fuck McKinley!!
Typically the way you store passwords is by using a "one way" algorythm. MD5, etc. You never *decrypt* anything, you primarily just re-encode the password entered, and then compare it with the one stored. This is the most rudimentary form of password storage but is also the easiest. There are little ways of obfuscating the hash such as adding your own unique identifier to it (in essence appending text to the users password in an effort to make the dictionary attack on said password much harder).
Nice script, but we went from cat /etc/passwd | mailx blah@example.com to a 50 line script to accomplish the same thing via GMail... does anyone see anything wrong here? 
Yes... you don't need Python at all here, just install SSMTP
Python has been losing embeddability since the early days. It isn't a real use case anymore. Try Lua. Very similar language, and awesomely embeddable. 
its development is based on 2.6 from begining.
Your requirements are not very precise. Is it for a desktop app / a server app ? Linux / Mac / Windows ? Whatever machinery you come up with, your code will have to transform your encrypted password to a clear text one and at that moment a simple printf in your code will show the password.
Don't be too hasty. I write in python 2.6 alot, and use with everyday, in many scripts. But then I give a script to a coworker still in python 2.4 (there are still some libraries that run only in 2.4) and I need to replace every instance. On the plus side, its made me a bit more careful and a better programmer when it comes to scripts. I always write methods now that take file-like objects (streams) and write to them, rather then filenames. So a method never opens a file unless that is the point of the method. Quick example (I haven't checked it though): def action(file, a, b): file.write("%d,%d\n" % (a, b)) if __name__ == "__main__": with open(filename, 'w') as output_f: action(output_f, 3, 5) With the above script, I just rewrite the end bit, and don't have to rewrite it all. With larger scripts, this drastically reduces the amount of work, and it makes the module easier to use in the future (i.e. that filelike object could write to a database or over a network in the future)
If you want to install into $HOME use [pip](http://pip.openplans.org/) or [PyPM](http://docs.activestate.com/activepython/2.6/pypm.html) $ pip install ipython --install-option="--user" $ pypm install ipython And [ActivePython](http://www.activestate.com/activepython/) comes with both of them to save you the trouble of having to install them manually.
I wish it was as simple as that. With my ISP, outbound traffic to port 25 is blocked. Using gmail is just one of the ways to get around that.
Just checked out SSMTP. Yes, looks like it supports secure email (through gmail's servers). Nice! I was actually doing this via ESMTP (which also supports secure email). However, since I needed to send a mail from a Python script, I thought I might as well use Python's built-in library.
last time I checked, US was a failure so who cares anymore
I think that's a bit of a red herring. The most interesting features of this are the docstring and argument introspection, and you can manage your commands centrally and still get all that: if __name__ == "__main__": from baker import command, run # CLI wrapper around existing functions command(set) command(get) command(params={"force": "Delete even if the file exists"})(delete) # CLI-specific functionality @command def cli_only(): pass run()
I wasn't even aware that Mathematica was a real programming language. What do physics majors use Mathematica for that requires any kind of scripting? WTF?
By sensible do you mean really anemic? My $20 low-end VPS hosting plan runs a mail server, Postgres, Apache, a Django site that does extra cron batch jobs all the time, and a few other smaller sites. And I'm using less than 100MB of memory total. I agree that when you need to hold a billion objects in memory, Python gets quite noticeably bloaty compared to, say, C -- but that's not something a webapp will generally be doing.
Slight off-topic, but once I had to help a client with his mysql. He didn't want to store the mysql password in the config file, so he stored it in the mysql table. He then had (obvious) problems connecting to the mysql database to retrieve the password to the connect to the mysql database. The telephone conversation felt like an infinite loop.
I actually mix the two up (ESMTP and SSMTP) I'm not sure if one is better than the other. But, ya, I can see your point about sending directly from Python.
Thank you for putting that in perspective for me.
last time I check, US president was a failure so who cares anymore?
Can someone explain to me why Python doesn't have enums? Is there a style of coding to avoid using them? I just stick variable names in a class but it feels so awkward. 
Sounds pretty motivating. I'd like a HUGE RED BUTTON for that :)
Is this what they mean by putting all your eggs into one basket?
I'd suppose because short strings are automatically interned in Python, so you can just use strings in a lot of use cases for enums.
You are most welcome. On that note, are you a hiring manager? Need some talent?
Thanks!
That is awesome. :)
Do you have any links to these comments ?
Excellent work, well done.
Here's my excessively complicated version: http://pastebin.com/f2c1af1f0 I'm probably going to hell for the double-lambda thing -- it's to get around unwanted closures -- but at least I'm not manipulating bytecode!
Oh, thanks! I use Linux, but I'm sure there are build instructions somewhere... I just wish there were a .deb I can use.
I've used ZODB without Plone or any of the other Zope stuff before. I was using it as a test implementation of a store for patient medical records to try to illustrate that MS SQL Server paired with Java was not necessary. It was an extreme kludge with a front end implemented in straight-up BaseHTTPServer, but it worked fine. ZODB took all the thinking out of a database backend.
Variables (really, names or identifiers) aren't typed (which limits the benefits).
&gt; Can someone explain to me why Python doesn't have enums? Because not having statically typed enums makes them pretty useless? 
Compared to putting it into which other baskets? Do you want to put part of your eggs in the ZODB and part in a relational database? 
Thank you!
big red button is for rollbacks after you accidentally deployed by tapping your foot 
̀̀̀̀̀̀̀̀̀`̀RED,GREEN,BLACK = xrange(3)` ?
No i don't. I tried searching on google, but i couldn't find it. If i remember correctly, one of the comments was on stackoverflow.
I used ZODB for a multi-server batch manager, it had a few oddities to it but overall worked well for storing complicated state structures &amp; historical metadata. If I could do everything over again, I might use CouchDb and seed the worker machines with light weight twisted based universal service dispatchers.
Backing @fassen up, ZODB was stupid easy to get up and running.
I heard this got cancelled - anyone have an updated?
thank you for the little inside jokes on the bottom right of your slides. "the narwhal bacons at midnight" :D
Lack of this was holding him back before? 
I this really news? I'm not much of a python programmer, but even I know of ZODB...
I want this + PEP 382 support asap http://www.python.org/dev/peps/pep-0382 !
Nope! Gave the talk a little while ago. 
You're welcome. :)
There's now an actual web site! It only took um, 14 years or so for it to be created... 
Ah, thanks for pointing out the typo, it was fixed. 
Too easy.
I don't see the point on enums in a dynamic language.
I guess I never thought about it that way. I need it because I have python code interacting with some C code over UDP. The C code just passes it a struct with some nicely defined enums identifying it's content, the python code uses the struct library and some "constants" for packing/unpacking data.
 class Enum(object): def __init__(self, values): for i, v in enumerate(values): self.__dict__[v] = i c = Enum(['red', 'green', 'blue']) print c.red # 0 print c.green # 1 print c.blue # 2 Doesn't have pretty a `repr` (solvable by creating an EnumObject class and using it instead of `i`?), and should probably have much more error handling, but at least there's no nested lambdas!
I concur
&gt;if your .py asks the user for input, there's no way for Apache to get that back to the user. Not quite; CGI connects POST data to the standard input, so you should be able to read form data with raw_input(). Although you'd probably be better off reading the whole thing into a string with sys.stdin.read(), and then parsing it.
Associating a symbol with an integral value is only the beginning of what enumerations are supposed to do. There's a reason C and C++ provide `enum` instead of expecting you to just use `const int` identifiers, and why Java finally got a hack for enums.
The double-lambda trick is useful to know. I remember when I first figured it out for myself (after first figuring out why it wasn't working with a single lambda). The problem basically boiled down to y = [] for x in range(5): y += [lambda: x] # We don't have this problem if we generate # y with a list comprehension, but the original situation was # more complex, such that an explicit loop was required. [z() for z in y] # [4, 4, 4, 4, 4], aargh! # Fixing this is trickier than you might expect! y = [] for x in range(5): y += [(lambda w: lambda: w)(x)] [z() for z in y] # [0, 1, 2, 3, 4], yay 
&gt;Doesn't have pretty a repr (solvable by creating an EnumObject class and using it instead of i?) def __repr__(self): d = self.__dict__ return repr(sorted(d, lambda x, y: d[x] - d[y]))
Could we also get py2exe or similar that works across all platforms?
&gt;On the web, this is done with forms. You get all the data you need from the user in a form, pass all that data to the .py file, and then it does it's magic and spits out the HTML you need. I covered that. Interaction on the web is done through forms (and eventually, XMLHttpRequest). Either way, the script needs to run from start to finish with all the data up-front. If the script asks for input from the console, apache's not gonna know what to do with it. *edit: Ahh, I see what you're saying. I didn't realize cgi worked that way. That's awesome! I've got more to learn about now.
any links to video of the presentation ? 
I don't think it is up yet. I'll ask around today.
I meant a repr for the `c.red` attributes, not the class itself. From the original code example: &gt;&gt;&gt; Colors.red Colors.red ..where as my class just shows the numerical value: &gt;&gt;&gt; c.red 0 
This would be very beneficial but has to be done in a thread safe way.
It's only done once when you setup your environment, why does it need to be thread safe?
91% upvotes, and no comments. Meaning: this is cool.
i'm all for killing it - but i i ended up in the unfortunate case of needing it for some stuff, so i made it (and it was a major pain to deal with that hellhole)
I thought I remembered a blog post that he wrote, but I only found this: http://nedbatchelder.com/code/winutils/jot_py.html It is a relatively small wxPython tray application. I guess the biggest consideration would be that wxPython is pretty heavy.
pyqt.
Check out the book Rapid PyQT programming book. It's awesome
[Snarl is a notification system for Windows](http://www.fullphat.net/) [There is a Python binding pysnarl](http://code.google.com/p/pysnarl/)
no link?
ooh very nifty. I'll report back in a bit Edit: it's good enough :) 
Is this better? [Check out the book Rapid PyQT programming book.](http://www.google.com/search?hl=en&amp;q=Check+out+the+book+Rapid+PyQT+programming+book)
PySide. EDIT: please disregard, as kib2 stated it hasn't been ported to windows.
You should use `append` to add an element to a list instead of +=
yes ;)
no google?
I have google ;) . I just want to re-enforce the good habit of providing a link everytime you make a recommendation. Recommending something and then telling someone to go find it is just rude, that's what links are for. 
Any updates on how much faster Unladen Swallow is or will be? I haven't been able to find any recent benchmarks.
I wouldn't try to dissuade anyone from getting in on PySide, but do so knowing it is not yet stable or recommended for production-level projects.
That would be great but it's a much tougher problem and I don't know of any quality third-party solutions so it's probably far from being incorporated into the std lib.
LLVM is a really cool project and there's still a long road to improve it. I think it should be hard to mantain a project like that (Unladen), the API changes in LLVM at each release is not very friendly. Just by the bugs fixed in LLVM thanks to Unladen Swallow people, it's a worth project.
I'm on OS X, but it seems pyqt is cross-platform. Would you say its better/easier than wxPython? Its just that wxPython seems a little overly complex and its documentation is extremely cryptic.
Great article! This blog will go nicely in my feed aggregator.
Excellent work, [polar graphs](http://upload.wikimedia.org/wikipedia/commons/7/7f/Zeta_polar.svg) would also be cool to animate. 
Thanks, I can't believe I forgot to plot polar graphs animation, they should look amazing ! Maybe in next post.
I'm discussing techniques for lambda factories and you're going to have a beef with *that*? ;)
I might agree but doing that on a phone is a little slow and clumsy. He's providing useful info nd its a 2second job on a desktop to search it.
Well, I guess, you need to start with buying "Mindstorm NXT" set ;-), and that should be enough to get you started (you do likely need a Windows PC to use Lego's visual stuff (NXT-G), as it doesn't run on Linux, not sure about Mac though) Then I'd suggest to assemble a few standard robots to get an idea of what's possible... You can do some simple programming on NXT-G, just to get the general feel of how to control the motors/what to expect from sensors/ etc... I do think that Lego visual programming language (NXT-G) sucks (at least if you are a programmer): but it's definitely useable for simple tasks.. Fortunately, there are many alternatives. I myself am pretty happy with NXC (which is a C like language with a decent IDE, it's open source too). Both NXC and NXT-G are used for the programs which are run on the brick (NXT system block) itself And, yes, you can also control the NXT brick in real time from computer. I've used NXT-python for that and it seemed to work well (the communication is bi-directional: you can read sensors, etc) but I didn't do anything complicated. Good luck and have fun.
I'm actually very surprised that a programming language like python does not have one super comprehensive crypto lib.
i think i'll do version 2 in wxpython version 1 is just going to be pysnarl based :) Thanks everyone! Edit: version 2 is coming along nicely :) thanks again for the link
Qt and PyQt are vastly superior to wx in terms of design and documentation. The only reason it was not the dominant toolkit from the get-go was due to licensing issues, but that has been largely resolved now with Nokia's release of Qt under the LGPL.
I would like different threads to see different sys.path. I am thinking of a web framework where different threads may serve different apps. This may be utopic I know.
[Here's a desktop notifier I wrote a few years ago using wxPython](http://code.google.com/p/readertray/source/browse/trunk/readergui.py) - it behaves identically across Windows and Linux and should also run on OSX. It contains a threaded event loop that can be used to animate a notification window containing an icon and message that can be clicked on. It probably needs a couple of tweaks to customize it for your own purpose but the ground work is done.
At work I need to package a Python application, but py2exe won't work with Cygwin's Python. I'll give Pyinstaller a try next week.
 field_names = field_names.replace(',', ' ').split() *Cringe*.
PySide is not avaible on windows yet.
It also hasn't been ported to Windows yet. Which means it's currently useless for OP.
Anyone else think of Cryptonomicon?
nice! thanks
My mistake. I assumed they would have gotten there by now.
&gt; I would like different threads to see different sys.path. That's not what virtualenv is for. &gt; I am thinking of a web framework where different threads may serve different apps. Better start multiple process, it works today.
they did. http://www.synapse-wireless.com/ small devices with a stripped down python virtual machines, mash networking, way cool. Just saw them life @ PyCon. 
You can't just pick one out and start coding out of the box. There are certain steps you have to consider: * familiarizing with the project * examining the coding standards for that project * finding a possible enhancement or a bug to fix * examining the problem and implementatation * writing the documentation and some tests for your code * committing your code and sending a review request * possible fixes * merge with trunk I think you will be better off if you find something in your field of interest, rather then asking "what are the projects that need help". So I'll just list some common main stream project hosting sites, that have their own search functions and hopefully the OS community will get a coder++. * http://github.com/ * http://bitbucket.org/ * http://code.google.com/ * http://savannah.nongnu.org/ Good luck! ps: I think the python reddit community is smart enough and can handle an abbreviation such as OS. ;-) 
Look at projects that you use. Isn't there anything you would like to improve on them? Better start with a small, well-tested and well-documented project. 
Find something that's missing in the python toolset and MAKE it. For example, right now in my spare time I'm building a library to make new-programmers lives easier for creating GUI windows. It's in the same concept as 'EasyGUI' but uses the wx framework, allowing people who are unfamiliar with GUI work to just simply do things like: response = wxEasyGUI.yesnobox("Do you like pizza","Title") Without having to construct dialogs and handle all the extra stuff themselves. I much prefer to develop tools that either fill gaps (of interest of course), or to make tools that help ease new programmers into the language (which can also serve as rapid-development tools as well)...so... In my opinion: Libraries Libraries Libraries...\*throws chair\*
Github, bitbucket and google code are three good places to search for OS projects. The best way though is to work on improving something you are using anyway. Look at what bugs they have and see if you can fix them.
Github and Bitbucket are IMO the easiest way to contribute. Find a cool project, fork it, fix a bug or add some functionality, send a pull request to the project owner, and boom! You're an open source contributor :)
I agreed with this advice. The idea of Open source is to "scratch your own itch". Working on OS project that is not in your interested problem domain is equal to working on a boring work for no pay, it benefits neither you nor the project. Working on project that has potential to scratch your itch will keep you more interested in it. Eating your own dog food will also keep your from contributing dream feature with no real use case.
Work on CPython itself: http://www.python.org/dev/contributing/
[https://openhatch.org/search/?q=&amp;toughness=bitesize&amp;language=Python](https://openhatch.org/search/?q=&amp;toughness=bitesize&amp;language=Python)
Except PyQt is still GPL, one will need to wait for [PySide](http://www.pyside.org/) to get a LGPL Python Qt binding.
That's just what I came here to post.
Area man unable to do own research, wants to help with programming project
Enjoy your ban.
Keynote speech from the Reddit founders: http://pycon.blip.tv/file/1951296/
I think there are better ways to improve your skills than trying to exploit bugs in a tracker implementation --- also... you are about to fall into a yak shaving hole (learning another language, actually finding exploitable bugs,...) that might be to deep for you.
First you must learn how the system works, then maybe you can use the knowledge you gained to exploit it.
It's usually abbreviated as OSS to avoid ambiguity. Also F/OSS for free/open source software. 
Any talks that can be recommended?
thats the one from previous year...
ah, ok. I know that someone from reddit what was giving a talk this year. Let me try and find it... Edit: This flash interface is horrible. I'll let someone else dig it up.