ummmmmm. pylons/pyramid and django are not for the same audience. it would be more accurate to compare turbogears and django. 
agreed.... also http://www.scribd.com/doc/37113340/Why-Django-Sucks-and-How-we-Can-Fix-it 
Well you very well may be fired in 2-5 years and if you don't know what's hot then, you will have a harder time getting a good job. Programming today is not about skill or intelligence, it's about your ability to know just a little bit above the basics and implement while showing off a bit. So know your base but stay fresh in new tech. 
Django's only limitation is how you structure your applications, which takes about an afternoon to learn. Beyond that, it gets out of your way and you're free to solve your problem however you'd like. It gives you everything boilerplate you might need from a web framework. I've not once had Django get in my way when trying to be creative or solving a difficult problem, so I really have no idea where you're coming from.
I hope you know how tongue-in-cheek the title of that presentation is. And most of the points brought up in there either have been fixed or are in the process of being fixed in an forthcoming release.
+1 for flask (or bottle, or web2py), although I would say your choice also depends on the scope of your project. I find flask is a great fit for something like transforming a cli style script into a web interface, not to say this is flask's only use though. I prefer pyramid for projects with more complexity. Flask can do what pyramid does but, compared to flask, pyramid's stricter approach to MVC defines the separate pieces in much less of an ad-hoc fashion. Again, any framework would accomplish the same thing though. Once you understand how the framework expects to work, your code could move easily between most frameworks. EDIT: s/pylons/pyramid/g - I still use pylons 1, but worth pointing in the right direction I suppose
i would guess one might be composite primary keys. I will also say that one reason I moved from django was that the user model from django-auth for a particular app required some additional attributes, and it seemed that once you did that, every app that depends on django-auth needed to be forked. Tight Coupling kills. 
Well. More importantly, I think modules being singletons is a fundamental design mistake. Trying to work around this constraint doesn't seem to have any value; instead, treat modules like instances of any other class and manage their lifetimes in the normal way.
I agree that some level of DB is needed, if only for some basic housekeeping purposes, but after reading the feedback and thinking some more, it occurs to me that I may have a future need for some basic social networking features as well. Things like the ability to mark an output as 'public', allowing visitors to upvote them and possibly even comment on them. Does that shift the frameworks playing field? 
Hand-picking your Template Language or ORM is nice... but I've yet to run into a situation where the Django built-ins haven't satisfied me. And most apps aren't designed to completely solve every use-case. They're there to get the bulk of your work out of the way. While other frameworks might have some plugins for a few extremely general needs (like authentication), when it comes down to the actual meat of the site you have to write everything over again. I on the other hand take a quick look at djangopluggables, pip install an app, fork it if I need to modify some behavior, and I'm good to go. That's not something I can get with any other Python framework that I know of.
Anno Domini
Anyone who watches that presentation, if they had a fucking brain, would know that it is tongue-in-cheek Capt. Obvious. I would be curious to know how the app problem is being addressed. Because that seems to be unsolvable without forking. You seem to know about this... inform me so that I might convert back to django. :) 
Yup nailed it. Probably like many web devs in here, I play with python for fun and expanding my toolset, but ultimately PHP and a little Ruby on Rails is what pays the bills.
OMG AMAZING. I wonder if python runs on it as well. 
1. Calm down. 2. Class-based views. They're almost here, and they're awesome.
LOL
You do realize reddit, dropbox, youtube... (to name just a few top sites in the world) run Python and Python frameworks? LNMPy (Linux, Nginx, Memcached, Python the new LAMP) should be far more synonymous with scalability than .NET and Windows.
I've done years of PHP coding in early 2000s. But when I picked up Python in 2004 I could not go back. Sometimes I am kind of scared to try out other things, I may like em too much and never go back :)
This is not a thread about Django. Anyway, web2py also runs on iPhone, Windows Mobile and Nokia N800, but that is not news, we have known that for 2 years.
You just need to get a better feel for operator precedence. The logical junctors (`and`/`or`) have much lower precedence than the comparisons. Also, you misinterpreted the syntax: neither `if (player == 'P') or 'p'` nor `if player == ('P' or 'p')` make any sense. In the first case, the condition is "`player` equals the string 'P' and/or the string 'p' is truthy". In the latter case, the condition is "`player` equals the truth value of the following expression: 'P' is truthy and/or 'p' is truthy". You probably intended to find an abbreviation for "`player` is either the string 'p' or the string 'P'", i.e. `if player == 'P' or player == 'p'`. The correct shorthand for that is generally `if player in ('P', 'p')` or in the case of checking against characters even `if player in 'Pp'`. Of course chadmill3r is correct. You would normally _normalize_ the string to compare first. In this case this is as simple as converting it to lowercase.
I would second web2py for this. Very easy to get started (no real configuration or installation, comes with built-in server - you can start developing right after having unpacked the zip archive), does all that is required for this purpose. Of course, finding suitable hosting might be slightly more difficult than for PHP.
That seems strange to me that it would eval to true in that expression...but it apparently does. weird.
Django is great, but learning other frameworks and languages will expand your mind and improve your Python skills. In suspect that in the next couple of years the Haskell web frameworks are going to be come quite important. That might be something to look at.
With the possible exception of Zope, none of the Python frameworks are as fully integrated as .NET and Java EE, these both have highly mature object request broker architectures for example, WCF and CORBA respectively. I'm not just talking about serving content over HTTP in basic web applications. I've never seen Python used in an application like distributed transaction processing for example, it just wasn't designed for that purpose. Maybe I should have used a different term for the type of applications I develop, either way I have no loyalty to any specific platform or framework but there are simply things that the "full stack" application server environment does better.
You are right, it's a thread about python and frameworks running on devices they weren't explicitly designed to run on, in the python subreddit. Good catch!
Yeah you do... 6 years later and I find it fucking dull.
[web2py](http://www.web2py.com) is younger (and some might even find it exciting). Like Django, it is a well-integrated full-stack framework, though you will probably find it even easier to get started with. Its design was [inspired by Django and Rails](http://www.web2py.com/examples/default/what) as well as several [other sources](http://blog.gilsondev.com/2011/01/13/interview-creator-of-web2py/), with [ease of use and developer productivity](http://www.web2py.com/book/default/chapter/00) being primary goals. You should be able to [download](http://www.web2py.com/examples/default/download) it, run it, and start playing with the scaffolding app (via the browser-based admin/IDE) in about a minute, so low time investment to check it out (also, excellent [documentation](http://www.web2py.com/book)). If you decide to give it a go, there's a very responsive and friendly [mailing list](https://groups.google.com/forum/?fromgroups#!forum/web2py) that will help you out along the way.
&gt; @xiol "...how are you going to store and share the content that users ..." And now you are definitely talking about DB involvement, if only to keep your sanity. I would say any MVC architecture to start with, but be willing (and capable) to scrap out the first prototype when your DB design changes (new tables and relations). I trust you are OK with relational DB concepts - MVC works best when you really already have a good grasp of the underlying DB design.
&gt; Is there REALLY a reason to learn something else? Yes: ***Fun***. Trying new things can be fun, even if it doesn't have a direct impact on your paycheck.
I take a lot of Python scripts that were once CLI only and attach a web-interface to them at work...mainly things to make our job easier much like the tool you are designing. I know a little about a lot of things, same goes for the web frameworks. I love making things in different frameworks, it really helps me understand how they work. With that being said, the application you are making basically sounds like some glorified CGI and so a complex framework is not necessary. I recommend starting out with a framework that doesn't have an ORM, something you can get a "Hello World" test page within a minute. For that, I would recommend [CherryPy](http://www.cherrypy.org/)...there is instant gratification of using CherryPy **Hello world in 15 seconds** import cherrypy class HeyReddit(object): def index(self): return "Hey Reddit!" index.exposed = True cherrypy.quickstart(HeyReddit()) The nice thing about a lot of these frameworks is the ease of dropping them into a real HTTP server like Apache or Nginx. You could use ModWSGI or something...anyway have fun! 
For scalability, you can also [run it on the new DotCloud](http://www.web2py.dotcloud.com) (still in [beta](http://www.dotcloud.com)).
&gt; RPI MUD Sweet. there is also [r/mud](http://reddit.com/r/mud), and I'm sure there would be quite a few mudditors who would be interested in your proposal. I wouldn't mind something like this either though: some sort of neat RPG-ish, MUD/MOO/Muck-ish type game, *esp* if it was written in &amp; scriptable with Python.
If you are talking about enterprise I actually work in a Java and .Net SOA shop, for instance we use WebLogic as our ESB among other things. I am not at all impressed with .Net. Java on the other hand has a lot going for it and as far as Python is concerned Jython bridges that gap. Mainly due to the restricted nature of Windows, .Net and it's ecosystem, .Net doesn't even come close in terms of scalability or flexibility of Java and Python. Not to mention Java and Python's vast advantage in number of quality open source tools and libraries. I think of .Net as something an exec bought into because no one ever got fired for buying a Microsoft solution. And not as something synonymous for flexibility and scalability. ps. I don't work in a small shop either. We run some 1200 Solaris servers and a few hundred Windows servers. I can give you countless examples of where .Net failed to match Python from my personal experience.
Sorry, I just wouldn't hire someone with your attitude. Even if I were in a Django-only shop and we did Django all the day long. Why ? Nothing to do with Django the tool. It's a fine piece of kit and certainly a good choice for a lot of projects. But because you are in the same boat as the guys who think all you needed is Visual Basic, all you ever needed is Delphi, all you ever need is PHP... unwilling to look at other possibilities, other approaches, other ways of doing things. A dullard maintenance programmer who only learns what his boss, or the market, tells him to learn. At the moment I'm learning Pyramid and Flask, and I'm also learning Haskell and Clojure (slowly). I'm not learning them because I expect to land a cool job doing Haskell or Pyramid. Heck, I use Django at work too. I'm learning them because I think it will make me a better overall developer and because I have a genuine interest in things outside my immediate project todo list. If I'd had your attitude, I would never have even learned Python and Django; I would have been stuck doing PHP to this day. EDIT: apologies to the OP, having read his later edit. I (and I guess a lot of other responses here) were responding to a general attitude in the industry, not you personally, and it was wrong. You clearly do enjoy learning but like most of us have limited time. However it's very hard to get an answer on "what framework is best" because much of the time it's as much down to personal style and what fits your brain as features or job market, so the only way for you to find out is to read the docs on a framework, do a bit of experimental coding and see if you like it or not. That may take an hour or two of your time but will probably be more insightful than someone else's opinion. 
This is a good recommendation, though, as pointed out [here](http://www.reddit.com/r/Python/comments/ffw5q/choosing_the_right_framework_for_a_new_web_project/c1fmwtq), you don't necessarily have to go with a more basic framework without an ORM in order to get going quickly and easily. Here's "Hello World" in [web2py](http://www.web2py.com/examples/default/index): def index(): return "Hello World"
If you're already well versed in Django, I'm not sure it would be worth switching, but as long as you're looking, you might also check out [web2py](http://www.web2py.com). Like Django, it is a well-integrated full-stack Framework with lots of features. Primary goals are [ease of use and developer productivity](http://www.web2py.com/book/default/chapter/00). You should be able to [download](http://www.web2py.com/examples/default/download) it, run it, and start playing with the scaffolding app (via the browser-based admin/IDE) in about a minute, so low time investment to check it out (also, excellent [documentation](http://www.web2py.com/book)). 
I think you misunderstood me. I think it is limiting is a good way. It does all the framework stuff for you in a single way rather that an approach like Pyramid or Turbogears who give you the tools and let you put them together in a way that suits you. The fact that Django gives you the tools and the rig lets you worry about the problems that matter.
Flask and microframeworks are really great for build single purpose webapps or web services. I use them often for proof of concept stuff. Pair them with a nosql DB like Riak and you have a hell of a prototyping system. 
There's always a reason to learn new things.
Could one put a game on the Android market using this?
Really? I was under the impression the TG, Pylons and repoze.bfg merged to become Pyramid?
Ok if you say so. I will have to concede I have not used the Emacs that is GUI based like Eclipse. But I will take your word for it. 
Mind I was not complaining, just having fun. I think it is perfectly appropriate for you mention that Django can do this too. I know other people here do not consider this kind comments appropriate (in particular when I do it) - but I do, because they convey information - so I like to point out when others do it too. I learned something from your post and that is good.
Pyramid really should be in your top choices. * Its very fast compared to other python libraries/frameworks especially from the time a url arrives to the time your function gets called. * Its very well documented. I rarely went beyond the pyramid docs for answers. * Its very simple to do almost any sort of one time request/response (not streaming) sort of applications. * It doesn't try to cram to much of its own way of doing things down your throat. Mix and match anything you like pretty easily or stick with some common solutions. People find the zope aspect of pyramid a little off putting. Zope is a primary reason for pyramid being so fast and simple to write views for though so I found myself shrugging off that "negative" pretty quickly. Pyramid is not zope, though it certainly uses some pieces of it where it made sense to.
what was pylons 2.0 and repoze.bfg merged to become pyramid. tg joined the pylons project but nothing has come of it yet as far as I am aware. 
Seems so, I am watching a FLOSS podcast now about it with Mark Ramm (TG) and Chris McDonough(sp?, Pylons/Pyramid).
i used to do .net. And have since moved away from it(far far far away from it) A former colleague of mine the other day asked me for some ideas on how he might be able to attract "top tier" .net developers to his department. I was at a loss, there's not one thing I can think of in .net that I miss. Maybe wcf, that was fun to play with, but asp.net *shudder*, and everyone I would have considered "top tier" .net developers either already work for him by my referral, or have since moved on to sexier technologies. .net == java == COBOL
like the european stock exchange? that was a flagship .net project that FAILED, couldn't scale, lost tons of money. I used to work for a big newspaper company, their CMS(core of their network) ran on the MS platform. The ONLY way it scales to meet the traffic demands of their properties is because they have brilliant network engineers that devised a way to cache the fuck out of everything. If the CMS had to handle that load, the company would be out of business already. 
no one ever got fired for choosing COM/DCOM/ACTIVE/J2EE/CORBA. Those are spec's that only a manager can love. 
i'll admit, it is a bit confusing if you aren't familiar with the projects that merged. But Turbogears is indeed the fullstack solution the majority of people want in a web framework ORM+Forms+Request Dispatching + Authentication etc... What's tricky is that the pieces that tg uses are also standalone packages themselves. For tg2. request dispatching is webob and routes, orm is sqlalchemy, authentication is repoze.who/what, forms is toscawidgets form validation is formencode. all of these you can install in and of themselves with easy_install/pip Whereas Pyramid is the request dispatching(roues or traversal) and optional Authentication piece(built in authentication policy). And just as Turbogears 1 was built on cherrypy and Turbogears2 was built on pylons 1.0, it will likely be that turbogears 3 will be built on top of pyramid. FWIW, I'm working on a project right now that uses pyramid, sqlalchemy, toscawidgets2. If I had to guess what tg3 would look like, it would be using these packages. I'm probably wrong though. 
This is a great podcast about it: http://www.twit.tv/floss151
For fuck's sake, did you even read the OP? &gt;I am not religious about the tools I use in my work, so I am honestly asking for something that I possibly missed. He's not married to Django, he's genuinely asking about the merits of the alternatives, since he doesn't see any substantial advantages to using them.
I'm only just learning Python, but I've been programming for 12 years. If you have the time, it's always good to learn another framework or programming language -- even if you're just learning it a little. You learn a lot by seeing how other people do things. Sometimes you learn better ways of doing things and sometimes you learn what to avoid. But also, it keeps your brain sharp and engaged AND can help you keep up with technology as it advances.
Ok. So what would be your choice if you had to pick one today?
Ditto, almost. I did a bit of c++ but forgot most of it by the second year. Apparently I did a semester in Java at Uni but I really don't recall. Python is my 1st proper language followed by C (Arm, Avr, Msp), Java (again but with Android), C++ (again but with Qt) and PHP. Thanks to Python i'm now a bit OCD about readability, so much so that my colleagues don't understand my issues with non-standard formatting and lack of code-reuse (i.e they literally Ctrl+C/V everywhere).
I agree with everything you said. The typical performance gap b/t C and assembly, though, is 25-50% at most. The gap between C and (non-JIT'd) python can easily be 20X+. I would really like a simpler mechanism to inline/mix C with python. I realize I'm probably in the minority :-)
&gt; I will also say that one reason I moved from django was that the user model from django-auth for a particular app required some additional attributes, and it seemed that once you did that, every app that depends on django-auth needed to be forked. If you don't mind me asking, when you define a profile for a user object, sure you have access to it everywhere in the project, but why wouldn't you want to? Are you trying to have a second instance of *contrib.auth*? Because, I can't really see when a case like this would come up. It's also not difficult to extend the User model should you need to.
How are these SVG files being organized ? Are they tagged or categorized in some way ? How are you storing the metadata (tags) etc ? If it's largely static, you could get away with having some python scripts generate your pages (maybe still using a DB in the backend) and just serve the content using nginx. If you have more complex requirements - for example, you want to tag the SVGs for easier search - probably Django would be a good choice, as the admin would help you manage your data quite easily, especially since you'll be the only one uploading and categorizing the SVGs. You could still use command line/cronjob scripts for managing large amounts of them. In fact you could even combine the two - have a Django admin app for managing the DB, uploading content etc, and scripts for building the static parts of the site out of the DB and the images, with maybe some dynamic bits for things like search. 
Isn't that a good thing in a tool? If you're excited by your tools, that's attention that you're not devoting to your problem. I'd rather find my problems interesting and my tools just plain old dependable. That way, I'm focusing my attention on the places where *I'm* adding value, and not worrying to much about where other people have *already* added value.
They are not tagged or organized in any meaningful way at this point, however, if I implement the social networking bit described earlier, they will become tagged, via external ad-hoc tags assigned by users. I started this discussion thinking that I'd end up doing something like what you suggest, but I'm beginning to see some serious limitations in scalability and flexibility if I do. Hence, I'm more or less convinced now that one of the more complete frameworks is the best way to go, with Django and Web2py at the top of my "to be investigated" list. 
Not sure why you are being downvoted to suggest web2py, which is a great platform. You described it truthfully and gave a lot of helpful links..
Sure. Really it doesn't make a huge amount of difference which framework you use - more important is a sane data model and overall design. In my experience that's usually been the deciding factor in the success of a project than any framework, although specific requirements are better met by some frameworks than others (such as the Django admin in my last comment).
It could also be an indicator that you're basically solving the same problems over and over, and thus using the same tool again and again. In other words, you're bored with digging ditches but you're blaming the spade you're digging them with. Perhaps the solution here might be to get into different projects that may necessitate using different tools.
I've found Flask REALLY fun to work with. And it was the gate to learning PHP and Node via the same "microframework" perspective. Having said that, I still find django as more powerfull, robust and *complete* that any other alternative.
An excellent sum up of the problem. I had similar thoughts but your comment made them crystal clear. Now, regarding the path I will choose, I'll think about it, because Pewpewarrows is right too.
Freelancer, for about 11 years on this field.
Of course I have checked web2py. If I was starting from zero I could go with it. But now that I am already experienced in a full stack framework is it worth to learn another one to do the same things just in a different way? Even if this different way is let's say 10-20% better.
I glanced over the source (current revision as of writing: https://bitbucket.org/dahlia/futureutils/src/6de2fa42499b/futureutils.py) and found a few problems: for i, el in enumerate(result): yield el lock.acquire() del result[:i + 1] lock.release() Above, the 'result' list is mutated within a lock, but iterated over (more specifically, wrapped in enumerate) without a lock. The background thread appends to the list with the lock held. I'm not convinced that this is correct. It may happen to work with the CPython implementation of the list type, but structures safe for concurrent iteration and modification typically admit some added complexity, and advertise this safety in no unclear terms. Even if this can be shown correct due to some obscure detail of Python semantics, this argument *must* be clearly documented in comments; this is far too fragile under minor modification. In my opinion, it is most wise in cases like this to not be clever, and instead iterate only with the lock held. while True: i = 0 for i, el in enumerate(result): yield el lock.acquire() del result[:i + 1] lock.release() if isinstance(finished[0], Exception): raise finished[0], None, finished[1] elif finished[0]: break thread.join(0.05) thread.join() The intent of the thread.join(0.05) line is to wait for more results to be produced. The timeout is fixed at 0.05 (seconds I assume). This is silly and wasteful: - If join begins waiting, and a result is added -- well, too bad, you're still waiting. For 50 (!!!) ms, no less. - If a result is not produced for some time, you spin (slowly), checking the result list. This amounts to wasted context switches and cpu time. This is exactly what condition variables are for. Python has them. Use them. These issues need not even be directly addressed. The code in question is just a (poor) implementation of a thread safe queue; the [Queue module](http://docs.python.org/library/queue.html#module-Queue) would pare down the code to a few trivial and more effective lines. tl;dr don't use this yet
i expect there'd be a fair bit of work involved in packaging it up into an apk, but it should be doable.
&gt; I am not going to gain any substantial profit using them instead of Django There we go.
On the contrary, I think Django is much more suited to prototyping just because you have so many apps pre-written for you (plus South makes migration a breeze). You can plug various things in and have them work out of the box. Something API-based (or single-purpose, as you said) would definitely use Flask (e.g. I made an [IMDB API](http://imdbapi.poromenos.org/) using bottle in about 10 minutes). I love how much choice we have, nowadays.
 player = raw_input("Press P or R").upper() if player == 'P': print ('Horray!') elif player == 'R': print ('Oh no!') No need for ors.
Yes, I agree, it wouldn't necessarily be worth switching. Because Django is older and more popular, there are a number of web2py users who used to use Django (as well as other frameworks), and many of them say they feel web2py makes them more productive (e.g., [here](http://stackoverflow.com/questions/76809/anyone-out-there-using-web2py/3826962#3826962)). But as you say, you may be better off learning iPhone development or Italian. :)
Thanks. :)
Seriously. Basically, OP was asking what is most worth his while to learn next.
Now I have to read and mentally parse 4 lines instead of 1 with two levels of abstraction, just because you're afraid of line breaks. no thanks.
You have no problem, you are just bored. Browse those other frameworks to maybe know a little about what they offer, but unless you have a problem that is a pain in django, don't invest in them. imo.
Yes, it's possible to do so. When I get a chance, I'm going to look into ways to make it easier - right now, it's pretty hard, because there are a lot of tools that need to function to make it through the packaging process.
I think people are more complaining about the BS reddit title than the actual article and work in question.
Actually they are not, as I pointed out above. It is the module loader + cache which determines its creation logic, not the module object. Since I haven't yet encountered a use case where my program actually needed two distinct versions of a function/class with same name *at the same time* I don't see why treating a module as a singleton is immoral. I haven't even anything against a module being immutable after loading since I never use it for monkey-patches. Use a class instead. 
I write these articles, so this is shameless self-promotion. My goal is to post a new one every week. Enjoy!
&gt; This article is dumb because it's comparing python to C Because C is often used as performance baseline. Decision to go with C is in most cases based on performance consideration. If python gets faster, the boundary moves... 
&gt; And most apps aren't designed to completely solve every use-case. Probably not, because it's impossible. If you read my message, you'll notice that we're in agreement here. &gt; I on the other hand take a quick look at djangopluggables, pip install an app, fork it if I need to modify some behavior, and I'm good to go. I took a look at djangopluggables, and the pluggables don't look very convincing. &gt; Nexus: "A centralized, pluggable admin app for Django" -What's that? Django already has "an admin app", how does it need to be "more pluggable"? &gt; Django-Sharing: "Django row level object sharing app." -"Row level object sharing"? What the hell is this? &gt; Django-ForeignKeySearch: "ForeignKey search forms for the django admin" -Doesn't the admin already handle foreign keys in some way? What more is needed? Does this even provide that? And so on, and so on.. The whole thing reminds me of JavaServer Faces and all the "tag libraries" on the Java side. The idea is that you can just "plug in" a tag library of your choosing, and then experience whatever JSF-loveliness you perceive to await you. But the problem is that there's not a single tag library where every tag works, and the plugging-in -part doesn't quite work either. It's a total mess, and JSF itself is a steaming pile of shit on _so_ many levels it's not even funny anymore. Do djangopluggables even work? How useful are they if you often need to "fork" them to get what you want? 
What a silly conclusion... map, reduce and filter do not exist to be used in normal code, they exist to speed up operations. This is why they are nicely hidden away in libraries for use only if needed. lambda functions are, and always have been, used only for simple functions.
Really? I took one look at the syntax for Django Templates and started having flashbacks to PHP Smarty. Kidding aside, Django templating requires more complexity when creating new nodes than I prefer. From day 3 of my Django use, I switched to Mako and never looked back. And Mako + [Nemo](https://github.com/9cloud/Nemo) for HTML markup is bliss.
You're saying you use Cobra.... by choice? 
This is the must inane conclusion ever. How in the world is replacing the keyword 'reduce' with three lines of boilerplate «simplifying» the language. Once you've _learned_ the fucking language, a bit of code using the reduce function is much _more_ readable, because it contains exactly the same information, but without two lines of useless boilerplate. Not only that, but boilerplate code contains bugs, so ifyou stopusing reduce, you get code that, for a good hacker, is not only harder to parse, it will also contain more bugs. 
My friend once wrote a y-combinator using lambda functions. It was easily the worst python code I had ever seen.
This is also in 2.7, fyi.
Watch the videos on http://vimcasts.org Should help ;)
I don't get it.
From [AS recipes](http://code.activestate.com/recipes/576366-y-combinator): Y = lambda g: (lambda f: g(lambda arg: f(f)(arg))) (lambda f: g(lambda arg: f(f)(arg))) Not sure what to complain about. That's how Y looks like. 
Looks great! Will do.
Thanks for your advice. I am the author of this module, and I changed the code to use [`Queue` module][1] (you mentioned) according to your comment. &lt;https://bitbucket.org/dahlia/futureutils/changeset/e95989c5de00&gt; [1]: http://docs.python.org/library/queue.html#module-Queue
He doesn't get `reduce`: x = reduce(lambda x: x * x, seq) # wtf is this? This can't possibly work since `lambda` needs two args. So it is his fault, but of course he can choose the style he likes.
Heh. It might be that the guy was just careless, but it kind of looks like he doesn't understand how reduce works.
Once you have learned reduce, I find all but the simple cases are harder to read and maintain when compared to more explicit loops.
Agreed. Boilerplate is code cancer. A useless, disease prone outgrowth that any fit language would allow you to prune. The amount of boilerplate is my single largest problem with Java, and the noticeable reduction in boilerplate compared to other comparable frameworks from that time is one of the most important things Rails got right.
paper cut == hang nail == cold sore I don't like those choices. :)
Python thread synchronisation: the GIL.
I also think that map/reduce/filter are better to use once you learn them, but the syntax of Python sometimes makes me not want to use them. All these brackets, and having to put it the proper number of parameters, unlike in Haskell and its currying. No brackets and very nice partial application (I know python's functools but it's awkward to use). Generally, I find it a little awkward to mix like that functional and imperative styles.
| Because, I can't really see when a case like this would come up. Imagine it's September 2010 http://code.google.com/appengine/docs/python/multitenancy/overview.html
that was an April Fools joke
s/Python/CPython/
How long does it take to process the SVG files? If you're expecting a lot of traffic, and the SVG processing takes a long time, you will have performance problems. In that case you might have to use something for background processes, like [celery](http://celeryproject.org/). For a web framework, I recommend flask. It's easy to get going, very well designed, and stays out of your way.
http://i.imgur.com/dO26x.gif 
I looked at some of the cheat sheets available for vim, but the problem is, I can't learn them by heart. Also, I don't think it's practical to keep a sheet around (I use Vim on more than one computer). Therefore, when I'm stuck, I just google for a hint/setting/key combo.
is this Massimo DiPierro's second account ?
that's interesting So you'd want if player and player in 'pP' to get around it
How come web.py never gets any love?
Question, can you point it to IPython for the REPL?
That's what django-classy-tags is for. I prefer Django templates to not allow me to execute arbitrary Python code, so developers don't improperly blur the line between view and controller. To each their own.
I don't think you understand the concept of reusable components at all. If you're unwilling to look past a single tagline description to see what an app does, then I really don't know what to say. And yes, spending an hour to quickly modify someone else's well-done app for your use-case is infinitely more useful than spending a week coding a half-baked in-house version because you have a bad case of Not Invented Here syndrome.
If you have a rough time reading a simple reduce, you have a problem. Also, rather than using a lambda in your reduce example: &gt;&gt;&gt; from operator import mul &gt;&gt;&gt; reduce(mul, seq)
I guess it depends on what you're prototyping :)
Yep, true.
Oh god... import __future__ import unittest class FLUFLTests(unittest.TestCase): def test_barry_as_bdfl(self): code = "from __future__ import barry_as_FLUFL; 2 {0} 3" compile(code.format('&lt;&gt;'), '&lt;BDFL test&gt;', 'exec', __future__.CO_FUTURE_BARRY_AS_BDFL) self.assertRaises(SyntaxError, compile, code.format('!='), '&lt;FLUFL test&gt;', 'exec', __future__.CO_FUTURE_BARRY_AS_BDFL) def test_guido_as_bdfl(self): code = '2 {0} 3' compile(code.format('!='), '&lt;BDFL test&gt;', 'exec') self.assertRaises(SyntaxError, compile, code.format('&lt;&gt;'), '&lt;FLUFL test&gt;', 'exec') def test_main(): from test.support import run_unittest run_unittest(FLUFLTests) if __name__ == '__main__': test_main()
I hardly think the purpose of a jit is so a programer doesn't try to optimize their programs, the purpose is that higher level languages may be executed faster by using a jit or a mix of interpreted/jit as opposed to compiled to native code(default java or pypy vs c or hakell ghc vs cpython).
Sorry, I did not mean one of those three, I meant if you have any choice, django, cherrypy, write you own, any choice. With what's available today, for an average size project that might scale bigger later, what would **you** pick?
couldn't you possibly cache some jit code from the previous time to run at startup?
Yes, I think it is. Rename 'mul' to 'mult' or 'multiply' or something if you prefer, but the general form is far more readable to setting something to one and then writing out a loop. It's also faster.
Nice article! I am writing one too about Python thread internals, but with a much different purpose in mind. I noticed the same thing. POSIX semaphores are the backbone of all the synchronization primitives in Python.
Better, but the magic timeouts are still wasteful. class _PromiseQueueTerminator(object): def __init__(self): self.exc_info = None def promise(iterable): """...""" result = Queue.Queue() def iterate(iterable, result, finished, lock): try: for el in iterable: result.put(el) except (SystemExit, KeyboardInterrupt): raise except: ex_term = _PromiseQueueTerminator() ex_term.exc_info = sys.exc_info() result.put(ex_term) else: result.put(_PromiseQueueTerminator()) thread = threading.Thread(target=iterate, args=(iterable, result, finished, lock)) thread.start() def iterator(): while True: v = result.get() if isinstance(v, _PromiseQueueTerminator): if v.exc_info: raise v.exc_info[1], None, v.exc_info[2] else: break else: yield v thread.join() return iterator() Above, I've brought the 'out of band' completion notification into the queue. This allows blocking gets, without a timeout.
There are two Python modes for Emacs: python.el and python-mode.el. A version of python.el comes with Emacs, and python-mode.el comes with Python. python-mode.el should support IPython with the addition of ipython.el, which comes with IPython, but AFAIK, python.el only supports the standard Python REPL and Jython REPL. FWIW, I prefer python.el, and don't really use the REPL too much from within Emacs. I usually have a separate IPython session and/or an interactive Python in Emacs that I just send code to from the buffer, but don't really interact with directly.
i prefer the tuple syntax at that point: if player in ('p', 'P') 
I don't like those choices either. :)
I understand reduce, but that didn't give me pause - I simply read it as currying, forgetting that Python doesn't support that...
&gt; they exist to speed up operations No, they exist to enable functional programming in Python. Those who are used to these higher-order functions usually don't look back. I utterly fail to see why the author thinks list comprehensions are more readable than map and filter. The *one way to do it* should be to prefer map and filter over comprehensions, imho.
&gt; reduce(mul, seq) **Reduce** to a single value by **multiplying** the elements of the **sequence** together. Doesn't get much more readable than that.
Nope, just a happy user who wants others to benefit as I have. Anyway, the vastly different typo rate should make it clear I'm not Massimo. :) EDIT: Oh, were you asking because I suggested learning Italian (and Massimo is Italian)? I just pulled that suggestion directly from the OP's post: &gt;...not to mention something completely different like learning Italian or an instrument or whatever.
Hmm, I think you're right - reads better.
I keep finding myself coming back to this article to be reminded of what I should be doing. [Efficient Editing in Vim](http://jmcpherson.org/editing.html) 
\&lt;shameless self plug\&gt; [This pocket reference](http://ra3s.com/wordpress/dysfunctional-programming/2011/01/17/quickrefs-for-python-and-vim/) actually fits in a pocket, and you can print it out on a normal printer -- just cut and fold. I too am just now learning vim, so hopefully I picked a useful set of commands. The other references aren't quite so random. 
It's worth noting, but I didn't see it mentioned in the article, that the Python synchronization primitives support the 'with' syntax. This makes writing *correct* lock-based/synchronization code much easier, especially when dealing with code that could possibly throw exceptions. For example: my_lock = threading.Lock() .... with my_lock: do_this() do_that() do_the_other_thing() The with-block will run in the context of the acquired lock, and the lock is guaranteed to be automatically released even if the block exits by exception. It's even more convenient if you need to acquire multiple locks. #Python 2.7+ allows multiple contexts natively with lock1, lock2, lock3: foo() #Python 2.6 requires using the contextlib.nested utility from contextlib import nested with nested(lock1, lock2, lock3): foo() 
&gt; It turned out to be a permissions issue. I ran "cat" on the file, and it turned out that I didn't have access to it: &gt; &gt;cat: /etc/mycompany/certs/httpd/mycompany-wildcard.key: Permission denied &gt; &gt;I ran the command with sudo, and the problem went away. Oh man, that is NOT how to fix that problem... Reminds me of windows developers forced to use linux and just doing chmod 777 on everything, or running as root :(
&gt; I don't think you understand the concept of reusable components at all. Now why would you make an obviously false, hyperbolic statement like that? &gt; If you're unwilling to look past a single tagline description to see what an app does, then I really don't know what to say. I don't, and didn't, have the time &amp; energy needed to properly investigate the "pluggables". But here's one I mentioned in my previous message: "Nexus". - Its page on djangopluggables is empty: http://www.djangopluggables.com/packages/p/nexus/ - Its page on PyPi is empty too: http://pypi.python.org/pypi/nexus - Its "homepage" is on GitHub: https://github.com/dcramer/nexus and it really doesn't say much about what it is, and how you'd want to use it. Now again, it's been a long time since I've touched Django, and I'm unfamiliar with a lot of related stuff. But for example that pluggable there doesn't look very convincing. You know, there's bound to be lots of half-assed, _very_ poorly documented stuff there, that doesn't solve your problem, and maybe doesn't even work. Besides, how do you find something to use? Have you memorized the list of pluggables available, so that you'll remember them when you need them in your projects? Or do you sometimes just sense that there's something there you can use for a part of your project? Or do you just go browse the pluggables for everything you need? Say you've identified a part of your project where you could probably use something from djangopluggables. If your goal is then to go there, pick something suitable, and "spend an hour to quickly modify someone else's well-done app for your use-case", you're likely to be disappointed. - You might not find what you're looking for - The documentation might be non-existent, in true Open Sauce fashion. Do you really want to use something someone just plopped on GitHub with no docs? Do you want to read the code to figure out what the hell it is, and whether you can use it? - It might not be well made. It might actually be a piece of shit. The less documentation a piece of software has, the more likely it is to suck. - And it might turn out to be unusable, even after that hour of modifying it. Again, my point is that you're often better off using your own tools/abstractions, especially if you've made them low-enough level. It's easier to attach stuff to your application working from the bottom up, than to force some higher level abstraction to fit it. If you've really been using those pluggables in your projects, surely you've got a couple of examples of how things worked out really well. Tell me what you used, how you modified it, and how things worked out afterwards. 
Ask and ye shall receive (ripped from recent projects, all involved either one-line setups or minimal configuration/modifications): * django-taggit * easy-thumbnails * django-debug-toolbar * South * django-sentry * django-extensions * django-mediagenerator * django-mailer * django-notification * django-frontendadmin * django-markup * django-threadedcomments * django-oembed * django-filetransfers * django-autocomplete * django-socialauth * django-socialregistration * django-versions * typogrify * django-contact-form * django-honeypot * django-gravatar * django-axes * django-maintenancemode * django-classy-tags * django-bcrypt * django-floppyforms * django-celery * django-filter * django-uni-form * django-haystack * django-profiles * django-relationships * django-grappeli * django-admin-tools * nexus * gargoyle * django-voting * django-openid ...and about a dozen other utility and testing helpers. Or I could have spent thousands of hours writing these all in-house because of a severe case of Not Invented Here syndrome.
Well, without any details (which I asked for), I'll have to assume you just randomly listed some of them. Oh, and Nexus is listed too, so you'll be able to tell me exactly what it is, and why you used it etc. All in all, you seem a bit too interested in "winning" our little debate here. 
Nexus is a mini-framework for a pluggable admin area. Normally the Django admin "only" provides you with CRUD for all your apps/models/tables. Nexus abstracts that out, so that the admin is what you would normally regard as an admin interface in any other CMS. So now the normal Django admin is a single tab in the new Nexus admin interface, and you're free to add other admin components in there, such as their other apps like Sentry (a centralized logging and error reporting system) and Gargoyle (feature roll-outs dashboard). I could spend the next hour doing a small paragraph write-up for each of these apps, or you can learn about open-source communities and do your own research. The process basically goes like this: I need an app to do something. Hey let me see if something similar is on djangopluggables. Oh it is! Let me google it and take a look at the github page, docs, and project website. This one looks like it fits my use-case, let me install it and see how it works out. Most of the time it satisfies all my needs whole-sale. Sometimes I need to make some minor changes. Rarely all the open-source apps are outdated and useless, so I roll my own and release it. Do I really have to explain to you how open-source pluggable components work in a community? Yes, some you have to spend 30 seconds googling for because the documentation and description isn't nice and condensed for you on one neat little page. Whoop-dee-doo.
JITs save programmers from having to do certain optimizations. Just like compilers save programmers from certain boilerplate code (e.g. stack invocation). If you're working in a language with a good JIT, you won't have to do micro-optimizations so often because the compiler has done them for you. Instead you can focus on optimizing algorithms. Or you can even choose a suboptimal program structure from a performance standpoint because thanks to the JIT, you wouldn't have to spend time optimizing it to get it into a close performance range with the ideal performing program structure. 
Your example code inspired me, and so I changed the code. &lt;https://bitbucket.org/dahlia/futureutils/changeset/b5003a7292c4&gt; Note that why I didn’t define a new class like `_PromiseQueueTerminator` is that it’s not there is no possibility of `yield`ing a `_PromiseQueueTerminator` instance entirely — for instance, the following code print just `[]`, not `[&lt;futureutils._PromiseQueueTerminator object at ...&gt;, 1, 2]`. lst = [futuretools._PromiseQueueTerminator(), 1, 2] print list(futuretools.promise(lst))
There is no issue with my usage of a special terminator class. An end user who chooses to touch private members of your module can lay no fault upon you. Your 'continue' signal is creative, but again, you've found a circumstance better served by condition variables. Starting a thread, as you do in response to continue, is an extremely expensive operation. However, since you are already using the Queue module, this is already provided; see the maxsize argument to the Queue constructor (http://docs.python.org/library/queue.html#Queue.Queue) I recommend that you read through the following to get more familiar with threading concepts, especially condition variables: [Queue module source](http://svn.python.org/view/python/branches/release27-maint/Lib/Queue.py?view=markup) [Excellent online book on the topic](http://www.albahari.com/threading/part4.aspx)
Django templates allow you to have any kind of execution you want in a template tag, so if I like i can write a tag that manipulates the DB, or injects data upstream to a context processor. Mako simply makes it easier to write a template tag 
[Learn Python the Hard Way](http://learnpythonthehardway.org/index) Available as freely downloadable pdf or buy it from Amazon.
Check out SQLAlchemy. There's also a flask extension that integrates SQLAlchemy into your flask app. edit: Don't worry about the DBMS, if you use an ORM like SQLAlchemy you can always change the DBMS without changing the application code, except for the configuration line.
try `__file__`
is this completely outside the SL4A?
This, and then migrate to a [real database engine](http://www.postgresql.org/)
Yes. PGS calls from Python to Java using JNI, rather than a network socket.
Do you see that word in the title there? It says MySQL. You know what that means? **He wants to use MySQL**. Take your pompous bull shit and shove it up your arse. 
1- Calm down. 2- Most "noobs" I've seem to come from php or scenarios where mysql is more know/marketed. Postgres while being more robust, performant and stable is less known. Also there most of database tools in python land are better built for postgres.
1- Fuck yourself 2- Just because you favor PostgreSQL does not make it better I don't care if you want to recommend a solution that you feel will better accommodate the "noob". Do it without being a jackass.
Depends on how you want to go about doing it. Do you want to create an extension? "FileList.py" contains the structures keeping track of this. Usually the "flist" variable is a pointer to in, located throughout "PyShell.py" and the rest of the code base.
Flask doesn't really do the M in MVC. That's up to you. SQLAclemy works, or any thing else really.
You're being too aggressive again. But whatever. Have fun with your pluggables. Based on experience of open source software, I'm still not convinced though. 
I don't see why it's ok for someone to suggest SQLAlchemy but it's wrong for someone else to suggest Postgres instead of MySQL? If you're going to go with an ORM, choice of a database doesn't really matter from the application development stand point. Postgres offers better protection against data corruption and it's less known of the two. Out of the box I would say it's a better choice for a beginner just because of this one point.
Library installation and management is my least favorite thing about Python. If Python 3 could make somehow make package installation seamless and easy that would be a huge incentive to switch. I can dream... :-)
Yes, his attitude was a bit off, but it's still fair game to suggest switching to a different SQL database if it's likely that the OP hasn't been exposed to anything outside the LAMP microcosmos before. PostgreSQL is a bit more full-featured than MySQL and apparently performs better in various regards, so it's a good alternative. Note: I currently use MySQL. As for your earlier comment: it's generally safe to assume people who ask "How do I _X_?" haven't considered alternatives to _X_. The evangelism is indeed slightly misplaced, but if you're using an SQL-ORM, which RDBMS you are using "behind the scenes" really doesn't make a difference to your code.
Bento is not just a replacement for install tools, but also (and currently essentially) a tool to improve the steps until installation (including build, configuration, etc...).
Bento predates distutils2 for a couple of months, and is actually born of what I believe to be strong technical disagreement over distutils design issues.
&gt;Is python still used frequently today or is it outdated? I believe EVE online was coded in python. Also is ASM outdated? &gt;What kind of things are/were python used for frequently? I'm not sure how to answer this. &gt;What kind of things does python excel at and what kind of things does it fall behind? It's Turing complete so it can do anything you set it to... &gt;Do you suggest this as a starting language? Or should I start with something else? Yes, I personally would. *edit* also anything written in python is OS independent so long as you didn't write anything that is OS dependent 
Possibly interesting [graph](http://www.google.com/trends?q=perl+programming,+python+programming,+PHP+programming,+scala+programming&amp;ctab=0&amp;geo=all&amp;date=all&amp;sort=0) - Perl sort of matches the "older language not much used today" description of python you were given. PHP is a "web based language", in as much as that phrase means anything. Scala is a hip, new, upcoming language, but its actual usage is tiny. Python is quite popular, and is clearly going to be around for a while. Python's a fairly general purpose language. It's quite popular for things as diverse as heavy duty statistics, system programming and web development. It's less good at stuff that needs to run very fast, which probably ought to be written in C/C++/ASM etc. It's an excellent choice of starting language.
&gt; Is python still used frequently today or is it outdated? Python is widely used and it il rising, [programming language of 2011](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html) &gt; What kind of things are/were python used for frequently? One of the biggest interests of the communty is web development, then system scripting, networking, scientific analysis. &gt; What kind of things does python excel at and what kind of things does it fall behind? python excel for its great adaptation properties, an huge selection of high quality libraries. So imho the point is: with python you go well, and go fast. One bad point maybe is packaging and it is not so windows friendly. &gt; Do you suggest this as a starting language? Or should I start with something else? It encourages good programming practices, if then you'll switoh to other languages you will be apply those things that you have learned in python.
Python is quite popular. The person telling you that it is an outdated (="older and not much used anymore") language seems to be misinformed. Python is most prominent in web developement, scientific computing and as a systems language. nret is correct that much of EVE Online is written in Python, in particular a variant called Stackless Python. Python is also one of three official languages used at Google, together with C++ and Java. Python excels at rapid development. It is simple and expressive enought that you do not have to deal with too much "boilerplate" code as in Java, meaning you can focus more on programming actual functionality and the code that is needed to glue things together is neatly tucked away from you (mostly). Python falls behind languages such as C++ in terms of speed and low level systems programming, but not in such a way that it isn't used widely for mission critical applications. The recommendation to start with a "web based language" shows some ignorance. If you want to do (serious) web development you need to learn JavaScript anyways, which is certainly web based, but rarely used for backends. JS and Python have been converging on features lately. You should do yourself a favour and avoid PHP as a first language at all costs. It will give you the idea that programming is something much more limited, frustrating and ad-hoc than it really is. I study programming languages for a living, and have also taught them at the university level. In my opinion Python is the best language choice for a beginner. Edit: Clarify first paragraph with "older" -&gt; "outdated"
How does /r/python rate Pydev? I'm happy with vim, but sometimes I think it would be useful to have an IDE as useful and feature-complete as Pydev straight out of the box.
I'm going to have to agree with my highly downvoted neighbor and say that's unnecessary. MySQL is a very stable piece of software that's used in environments from the very small to the very big (and my company uses it on the very big side with a surprisingly small server investment). There's absolutely zero harm in any developer, "noob" or professional learning MySQL or using it for a project of any sort. I would argue that the popularity of MySQL is an asset (more helpful resources, more tools and utilities), and the implied downsides (lower performance, less robust, and less stable) are entirely overblown. Especially when you're consider he is using it w/ a micro-framework. PHP and MySQL may go hand in hand in the LAMP world, but MySQL is a seriously good DB. Furthermore, while postgres and MySQL are similarly close enough, considering the situation of trying to learn web programming you may discourage someone with a passing familiarity of MySQL from pursuing that further or trying postgres in the future if they run into problems. One step at a time is a good approach to learning things. I'm not trying to make any comparisons between postgres and MySQL, but running into an unrelated topic claiming that the OP's choice is somehow invalid is uncalled for. A suggestion of "You may want to try postgres, it plays better with python" would be a more appropriate comment. 
You can't go wrong if you choose Python. Outdated: No. But mature, tons of libraries for anything you want to do. Used for: Anything (Web development, Driving robots, System management, etc...) Excels at: All of the above. Falls behind at: Performance critical application. (But this will change really soon when PyPy is ready for mass adoption) I definitely suggest it as a starting language as it lets you to focus on get things done. It feels natural to program in Python. Python is gaining popularity in schools for teaching introductory courses to programming.
&gt;They suggested that I start with a web based language instead. What is a web based language these days? IMHO there's no better language to be writing for the web in. 
&gt; Is python still used frequently today or is it outdated? This depends on who's doing the using. I understand it's in heavy use at Google and NASA among other places, but if you want to get hired as a python developer in Western Europe for example, the market doesn't compare to the C++, Java or .NET market. In fact, it is just emerging (in this area - I don't know about others). &gt; What kind of things are/were python used for frequently? Prototyping and small scripts for automating repeated tasks is one thing I use it for. I have also used it for extracting structured data out of application log files (it's great for text processing), for automating testing and so on. It is also quite easy to embed in applications as a scripting platform. Others use it for web development, testing or as a general purpose language. &gt; What kind of things does python excel at and what kind of things does it fall behind? Python is very high-level (i.e. you can do many things with little code) and very prolific when you start with it (i.e. the time between you opening the first manual/tutorial and getting python to do what you want it to do for you is quite small). I understand it resembles perl in that regard, except it's much easier to read than perl (in fact python reads almost like pseudo-code). Regarding what it falls behind, I don't know. With python being a scripted language though, I expect it will not be used in performance-critical systems very much, but I might be wrong. &gt; Do you suggest this as a starting language? Or should I start with something else? It depends on what you plan to learn. If you want to understand algorithms, python is a good place to start. If you want to learn programming, keep in mind that while python will help you understand algorithms, it will not encourage learning in other areas (such as memory optimizations or data structures - use C or C++ for that). If you want to learn programming, definitely take it out for a spin, but keep in mind you will need something much closer to the machine if you want to learn the fundamentals.
&gt; if you want to get hired as a python developer in Western Europe for example, the market doesn't compare to the C++, Java or .NET market In terms of sheer number of jobs I'm sure that's true. In terms of supply/demand ratio, I'm not so sure. At least I seem to be turning down a fair amount of interesting, well paid work, despite not really going looking for it.
yup. the EVE online servers are coded in stackless Python. The Eve Client isn't tho. (just to clarify)
I had the very same adventure a couple of weeks ago and I thought that I somehow (*overnight*) became an incompetent and lost the hability of simply installing Python modules. Good thing I'm not the only one with this issue.
&gt; The person telling you that it is an older language seems to be misinformed I think they probably are, but even a stopped clock is right sometimes, and 20 years *is* fairly old - about the same as Java, a bit older than PHP, much older than C#.
What happened November 2007 to suddenly make programming so popular?
The most important point here is "You can't go wrong". Just f'n learn Python (in fact any language) and you can always pivot from there. The most important step here is DO NOT STOP learning something because someone told you there is something better out there. It will not detriment your learning whatsoever. And yes Python is heavily used in Web Dev...check out Django or Pylons/Pyramid. 
I would say that being able to stay on top of the complexity factor (code/infrastructure complexity grows exponentially to lines of code) is key ... In other words: simplicity is key. Both, Perl and Python can deliver in that area. Google however might have choosen Python for its slightly better integration with C++ back in the days (don't know, just guessing). http://www.markus-gattol.name/ws/python.html#why_python 
One Google employee once told me (and a bunch of guys, it was a Python Users meeting in one of their buildings) that a good portion of Google code is java. But even the Java guys use Python to describe their algorithms 'cause it's really easy to understand Python code.
Let facts speak http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html So, no, Python certainly is not going away. If at all it's going to be used by more people in the future than it is now. What things are done in Python? There is the Web where Python has become one of the major players. Second, there is system administration where you automate using Python i.e. even when the number of machines to administer goes up you still deal with O(1).
I really want to know that too.
Sorry, couldn't help but read this as "Why Windows makes a sucky dev OS" than anything else. Besides, I thought we all figured out that virtualenv was the way to go and it includes pip ootb and by using it's activate command sets up your path correctly. 
Don't forget about [lua](http://www.google.com/trends?q=perl+programming%2C+python+programming%2C+PHP+programming%2C+scala+programming%2C+LUA+programming%2C+BASIC+programming&amp;ctab=0&amp;geo=all&amp;date=all&amp;sort=0).
I'd second [Flask-SQLAlchemy](http://packages.python.org/Flask-SQLAlchemy/). It will help you get up and running with SQLAlchemy in no time. You can also if you wish use bare-bones [MySQLdb](http://mysql-python.sourceforge.net/MySQLdb.html) if you're happy writing all the SQL by hand (for a very small app, where you know you're going to be tied to MySQL, that's not such a bad choice). I'd recommend you use a *before_request* and *after_request* handler to manage your connection (assuming one connection to one DB per request): app = Flask(__name__) @app.before_request(): g.db = MySQLdb.connect(....) # whatever your connection settings @app.after_request(response): g.db.close() return response @app.route("/") def index(): c = g.db.cursor() c.execute("SELECT * FROM my_table") return render_template("index.html", rows=c.fetchall()) Remember to watch for SQL injection by using proper parameter inserting syntax. 
What always puzzles me is that pip depends on setuptools, although it is meant to replace easy_install. I need easy_install to install pip? Oh come on... The next thing that bothers me is that most setup.py files are a botchy pile of setuptools hacks. Look at the setup files for a non-trivial project. You almost always see subclasses of setuptools or disturils internals, imports, side effects or other stuff that should not happen at install time. This is the main cause why some packages break apart and vomit error messages all over the place when you try to install them with pip. Why is that? Why is it so hard? On one side, a setup *script* is a great thing. You can do fancy stuff you couldn't do with a *static* config file. On the other (real world) side, so much magic happens in setup.py that there is virtually no *standard* left in the way packages are installed. Not you (or pip), but the setup.py file installs your package. Virtually every package ships its own installer. There is nothing you can build or rely on. If something changes in the way packages are built or installed, you have to fix every single package out there and hope it is still maintained. An installer such as pip has no other way to control or fix the installation process than to monkey-patch the hell out of every setuptools/distutils/distribute package that might be installed and hope it does not break everything. This is why I think the whole setup.py/distutils/setuptools concept is flawed by design. **dl;dr** I want a setup.py file to *configure* and *prepare* the installation process, not to *control* it. distutils and setuptools are flawed by design.
So is Haskell, but I doubt anyone would argue that it is outdated. What matters is that Python has matured a lot as a language and it is still actively keeping up with the times.
This actually sounds like that second-guessing nature you get when you feel like you're investing in one option and want reassurance that you made a good choice. ;) Rest assured that all programming exposure is good exposure, and once you grasp the fundamental concept of programming and learn to think algorithmically, you can port those skills to any other language you may want to pick up. Personally, I prefer Ruby but often code in Python for its libraries (in my desktop applications). Sometimes I'll brush up on my PHP for making vBulletin plugins and I'm learning Objective-C for iPhone development, or I'll open up Visual Studio and write in C# for when I want to make an easy GUI. There's a lot of power in being a generalist programmer, and never feel like you're wasting your time learning a language. 
Someone asked this in a recruiting panel with a Google rep, and the rep simply explained that Google lets employees write in their language of preference. Due to a wider population of Python programmers, the culture just shifted that way.
"someone" is an idiot. anyway, answers. 1: yes 2: everything 3: getting shit done 4: yes 
&gt;Is python still used frequently today or is it outdated? [TIOBE](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html) and [stackoverflow](http://stackoverflow.com/tags?tab=popular) &gt;What kind of things are/were python used for frequently? [see the Related Tags](http://stackoverflow.com/tags/python/info): Web Development(Django, Google Apple Engine), Text Processing(regex, string, parsing, unicode), scientific programming(numpy), Database(mysql, sqlalchemy), GUI(wxpython, tkinter), etc... &gt;What kind of things does python excel at and what kind of things does it fall behind? easy to use, programmer friendly &gt;Do you suggest this as a starting language? Or should I start with something else? Yeah, Python is the right choice
what is a "web based language"? EDIT: seriously!... what? i googled it, but found no conclusive answer or list.
The only "web based" language nowadays is JavaScript. Complex HTML templates and Railesque magic are dead, server-side you only need to code to a REST[ful] API and do some HTML bootstrapping (for search engine support). Python's good for that, but so are *finally* statically-typed languages. 
The post brings up something I've always wondered about. Why is easy_install not part of the standard Python installation, at least on Windows where there's no package manager to install it for you? I know there's ez_setup.py, but why should it be necessary?
Python has been around for awhile but it's as modern as they come. It is constantly updated and Guido and other maintainers are not afraid to make major changes to keep the language up to date with today's challenges. Saying language is old is only important as far as maturity is concerned. Python is a mature language but very modern on the other hand, I would argue more so than many languages that came after it and most certainly more modern and elegant than PHP. Many new languages today actually borrow ideas from Python. Take Go language. It has a lot in common with Python and it's inspired by python's concise syntax.
October. My guess is the [iPhone](http://en.wikipedia.org/wiki/IPhone_OS#History). 
* Python 2.0.1 (June 2001) * Python 3.0.1 (February 13, 2009) I think python 3 is newer than C# and I'm going to be really happy when the new Java and C$ support ~~*yield*~~ and ~~*with*~~. Python is about as modern as they come. edit: C# supports yield (thx hillmanov) and with is called "using" (thx HLAR) which is the same as with. So I guess that leaves ~~try+except+finally~~ or does [C# suppport](http://msdn.microsoft.com/en-us/library/dszsf989\(v=vs.71\).aspx) that too? edit 2: So does python have any unique (vs c#) language features? Maybe yield being able to have a value?
The Windows Perl implementation was the biggest reason.
Because it is far from perfect. The distribute-fork and the pip-alternative exist for a reason.
&gt; I believe EVE online was coded in python. That's a weird example to use.. I've never even heard of EVE online. It would probably be more relevant to mention that youtube was written in python.
I believe reddit is actually built on Pylons.
It's good to see that once released in the wild, IronPython wasn't killed. 
Well I'll stop bothering, since it's pretty apparent you never intended to come into this with an open mind. I'll just leave this here in the hopes that one day you decide to broaden your horizons: http://en.wikipedia.org/wiki/Not_invented_here_syndrome
same thing for wxpython lovers http://www.xpython.org/ But the current version 0.3 is buggy
Even Javascript isn't unique to the web. E.g., it's the map/reduce language in Couchdb's views. Want to query the database? You need to write some Javascript.
It's definitively outdated: most of its developer were born during the 20th century; It's only used for useless things: it can't be used in your webos to do webgl toy demos in your webviews, so why bother? Moreover, it sucks at tail recursion and global interpreter lock, and since you're doing only hardcore multi-thread functional stuff, it really sucks. You should rather write your own new super-fancy language (or use brainfuck if you're lazy).
try this: from fabric.api import * from ConfigParser import SafeConfigParser config = SafeConfigParser() config.read("foo.ini") for server_name in config.options('Servers'): ip_address = config.get('Servers', server_name) env.hosts.append(ip_address) print "env.hosts %s" % env.hosts env.user = 'deployboy' env.key_filename = [ './secret.pem' ] def foo(): run('hostname') In your version, you did'nt call your "servers()" function, so at no time the config got read **at startup**. You probly tested like:: $ fab servers Which instructed fabric to initalize and then run your "servers" function set up with the "evn" dictionary. See fabric's "execution model": http://docs.fabfile.org/0.9.0/usage/execution.html Not that fabric interprets every module-level function as *command*, thus I'd just do the parsing on module level. HTH. 
Learn Scheme and you'll be able to bend spoons with your mind.
Unfortunately client side scripting is unique to Javascript (unless you resort to source translation or plugin provided runtime). I don't think anyone mind using Javascript for quick scripts. Try building complex applications OTOH... 
doesn't like you're using it with fab, and instead using it as a library. Read the [docs on this](http://docs.fabfile.org/0.9.3/usage/library.html)
is it still slow?
yup. once you add python's path to windows path and the scripts to the path, and configure mingw for setuptools, it's a little less sucky, but it still sucks. 
[C# already has yield](http://msdn.microsoft.com/en-us/library/9k7k7cf0\(v=vs.80\).aspx)
| you have to fix every single package out there and hope it is still maintained. same issue with linux, which is why distributions are key. 
&gt;Is python still used frequently today or is it outdated? If you put any sort of weight into those TIOBE indexes (I don't), Python just won. Outside of that, it's not at all outdated and it's definitely used very frequently. &gt;What kind of things are/were python used for frequently? The Mars rover. It was used in some way for the Joint Strike Fighter F-35 Lightning (more specifically, it was Jython). Financial systems use it. It's huge in the web area. All of the major hard drive producers run Python-based test harnesses. Microsoft shipped Python code for it's merchant server product back in the 90s. It's also gaining ground in the educational area. &gt;What kind of things does python excel at and what kind of things does it fall behind? It's really a general purpose language, so it excels at many more things that it falls behind on. One of the bigger fall behind points is performance, but defining performance is a case-by-case basis and something you need to evaluate. Is it faster than C? Probably not. Do you need it to be faster than C? Probably not. If you do, you can always write C extensions that are usable from Python. &gt;Do you suggest this as a starting language? Or should I start with something else? MIT and Michigan State University think so. I know there are others as well.
Do you mean slower than CPython? If so, its slower at some things and faster at others. So, it depends on what you're using it for.
Considering that reddit itself is written in Python (originally ~~Lua~~ Lisp, but it was ported/rewritten (not sure which one)), it's not exactly bad for web programming. As for your questions, I'll address them in reverse order (because I feel my answers will flow better that way round): &gt;Do you suggest this as a starting language? Or should I start with something else? Absolutely. Python is, to steal a great summary of it, almost "executable pseudo-code" - basically, you can take a look at a piece of code, and provided it's written at least somewhat competently, probably get a pretty decent idea of what it does. &gt;What kind of things does python excel at and what kind of things does it fall behind? Python excels at string processing, particularly (Perl is even better, imo, but its syntax is not so nice for me). But its greatest strength is that it's pretty decent at most things, and its ability to use modules written in C (with the default interpreter, anyway) means that as long as there's a C interface for something (there almost always is), Python can probably be extended to do it well. It's not so strong at low-level stuff, but then neither are most languages that are higher-level than C. And that's honestly not really an issue for most programmers these days. &gt;What kind of things are/were python used for frequently? Web applications are the main one at the moment (YouTube, for example, runs on Google's heavily-optimized Unladen Swallow fork of Python 2.x), though again, really anything can be done with it. &gt;Is python still used frequently today or is it outdated? Absolutely. If anything, though this is purely my observation, it seems *more* people are using it recently. **EDIT:** Lisp, not Lua. Good catch, sunqiang.
I think he's arguing the semantics of "old" rather than the viability of the language. I don't think anyone can argue in favor of it being outdated.
lolspeak?
It's a very good introduction to all those python web frameworks.
I thought IP would die after the plugged was pulled, glad to see it still alive.
I can't elaborate in detail, due to NDAs and such, but suds doesn't properly handle some SOAP features (for instance, substitution groups) that we need. (I'm sure it does handle a few that Scio doesn't, too -- SOAP is ... SOAP after all). There were also some lower-level needs we had around transport and logging that we couldn't see a good way to handle with suds. Rolling our own seemed like less work, especially since it wasn't clear at the start that we'd be allowed to release anything publicly, so using suds would have meant maintaining an internal fork. Simple soap came along (or came to our attention at least) too late for us to seriously try out.
Ah, yes. My mistake. I didn't read my own sentence - originally I meant to say "outdated".
Just because you haven't heard of it, doesn't mean millions of others haven't.
afaik, reddit is rewritten from lisp to python.
&gt;Google lets employees write in their language of preference. To the best of my knowledge this is not true: there are three blessed languages. Everything else is either prohibited or very strongly discouraged. 
Why would THAT be an argument for google? Google is not using Windows internally.
Whoops, yes. Lisp, not Lua.
That's well written, a good resource indeed! Thanks!
It's pretty much your choice what you use (if not a given by what your team uses anyway) to prototype something. Stuff that goes live however is mostly one out of three: Python, C++, Java. That's a rule, no way around it.
stackless python. care to explain? sounds neat.
I use Eclipse all day at work doing Java development. It's a big plus to be able to work in python using an IDE where I already know all the fancy keyboard tricks. That, and being able to use the eclipse debugger is the big win for me. Plus, Eclipse already has good integration for git/svn and stores change history for local files. 
&gt; Installing python on a windows machine doesn’t add it to the PATH. Also, there are no automatic shell associations. You have to know how to run your python scripts from the command line. 1 is true, 2 is false.
Out of curiosity, What about "Go"? Is it an approved language?
Python's popularity is actually going *up* over time as more libraries are written for it and it begins to supplant perl in popularity. You can figure out where python excels over other languages just by finding beginner's tutorials and looking at how things are done, seriously. In python, writing a string to a variable is essentially "string = raw_input("Enter the string")". Look up how to do it in C. 
Switching to it this semester in CS1 (Purdue - Indianapolis)
Watched it and it is a good podcast on where TG, Pylons and repoze.bfg are going.
http://www.stackless.com/
Please. As if I wasn't aware of "NIH". People sure like to throw that around though. 
I'm more of a Ruby user. I had always thought that the python crew was way more on-top of the Windows (and module installation, in general) use-case than this seems to indicate. Maybe we can all make a pact to ignore Windows and destroy all mentions of it in the hopes that it will just quietly go away. :)
No, it doesn't work that well. For one, it doesn't work with shared libraries and that's closer to python's import system. Second, it does not scale well. You can't run whole program opts across big source code because you'll blow off your memory (we tried).
From the original PageRank paper by the Google founders: "A single URLserver serves lists of URLs to a number of crawlers (we typically ran about 3). Both the URLserver and the crawlers are implemented in Python." I think this helps explain why Google chose Python more than any of these other speculations. The original founders of Google coded in Python, so they likely hired Python programmers in their original core engineering team. http://infolab.stanford.edu/~backrub/google.html
Like I said, I don't care that he suggested something. I care that he did so with a condescending attitude towards the original question. 
It's called irony.
Wasn't this fixed in this patch? http://bugs.python.org/issue6690 
Guido (creator of Python) prefers != and Barry (important Python programmer) prefers &lt;&gt;. Since Guido is the bdfl and consistency of the language was more important than silly syntax wars, the deal was made into an April Fools joke instead. See also: http://www.python.org/dev/peps/pep-0401/ 
Whats the status of postgres support in peewee? or mysql for that matter? I'm eager to try this with flask, but I've found the documentation quite scarce in this regards. I know there is a PostgresqlAdapter but I can't find anything about how to use it :-/
&gt; Maybe we can all make a pact to ignore Windows and destroy all mentions of it in the hopes that it will just quietly go away. :) But it won't. Windows is very much alive an kicking in business. For those of us who try to introduce python as an alternative language it sucks that some packages are so difficult to install. But good Windows support is critical for python (i.e without the excellent win32 and related work by Mark Hammond, Windows development with python would have been much more difficult). On the other hand you can't blame the library developers - they develop on their favorite OS, and in most cases that is not Windows. In my opinion what is needed is a community effort for better library management tools and better windows support for existing packages.
In other words, Windows sucks. It sucks indeed. 
Until you want to write a loop to bend spoons....
&gt; Maybe we can all make a pact to ignore Windows and destroy all mentions of it in the hopes that it will just quietly go away. :) Thats a dream. A very beautiful dream.
Oh - could be. I knew there was a patch raised for this about a year ago, since this came up on reddit, [here](http://www.reddit.com/r/Python/comments/99nyc/remember_your_in_operator/c0by7xi). I went looking for it, and found the rejected one I linked to downthread, but this looks like it might actually be the one I was thinking of. However, it doesn't seem implemented as of python3.1.3 though, since that gives the output above (with `BUILD_SET`), which is odd since it looks like it should have been committed over a year ago. [Edit]: Looks like it didn't go in to the patch stream since it's not a bugfix (not mentioned in the changelog anyway). Probably won't be in till 3.2.
Actually, it looks like I'm wrong. prum just [commented](http://www.reddit.com/r/Python/comments/ffne7/help_with_if_and_or_statements/c1fvpyw) pointing out [this](http://bugs.python.org/issue6690) issue, which *was* committed, so I may have been linking to the wrong bug. However, it looks like it isn't in the 3.1 stream, so probably won't be there till 3.2.
["Although practicality beats purity."](http://www.python.org/dev/peps/pep-0020) :)
EVE online is a space MMO [Here's some gameplay video](http://www.youtube.com/watch?v=Pzc8oPKXqvo) *ninja edit* I didn't know youtube was coded in python, but that's also a great example.
[So what ?]( http://code.djangoproject.com/browser/django/trunk/django/template/context.py) 
Why do you need 'with' in C#? What's wrong with this? var person = new Person() { Name = “John”, Age = 30 };
You could have just title this post "The Motherlode"
Python is probably the best choice to learn unless you fancy yourself a mathematician (and a bit of a masochist), in which case you might prefer a functional language like Scheme or Haskell. Python is good for anything that doesn't have to run super fast (game engines) or be deployed to lots of customers (desktop or mobile apps). Look at numpy/scipy for some scientific applications where it's gaining popularity as an alternative to Matlab. It's bad at parallel (multithreaded) computing.
to me it looks more like dependency injecton for new sets of modules which means its clean and self-contained
You have no clue what that is for. Do you? web2py class List is not a replacement for list. It is used to store what we call request.args which are parsed from the URL. Their value cannot never be None because they have to be strings so it is perfectly ok to define None as the lack of parameters. It allows users to do x = request.args(0) or 'default' instead of x = request.args[0] if len(request.args)&gt;0 else 'default' This is a good example of how web2py makes the life to the programmer easy and less verbose. Thanks for posting it. “No object is so beautiful that, under certain conditions, it will not look ugly.” Oscar Wilde
I wasn't attacking web2py. I got there googling for something and I thought it would be nice to hear what others think about. As I expected, someone posted the other phrase "Although praticality beats purity."
Well, you did point to web2py code with a link titled, "Special cases aren't special enough to break the rules." It's hard to come to any conclusion other than that you were suggesting web2py is breaking some rule. If that's not what you meant to imply, what did you mean? Remember, "explicit is better than implicit." :)
 s=s+str(random.randint(0, 1) Unclosed parenthesis right there.
major derp. thanks. i feel silly now.
Also, if you really want to do it this way, you should move the `a` and `s` initialization inside the outer loop. Otherwise, a will never get reset to 1 and so all you'll be doing is printing the same string in your outer loop. 
Wouldn't the [using statement](http://msdn.microsoft.com/en-us/library/yh598w02.aspx) in C# basically be equivalent to the Python *with* statement?
The code is on web2py, but I was not suggesting that the project was breaking a rule. I read this specific code, found it unusual and decided to post here. I didn't read the whole code of web2py to be able to make a assertion like that. I know that a few days ago there was some critiques to the project here on this subreddit, but my post is not related to that. My submission title was unfortunate and I apologize, as it sounds like I'm trying bring a flamewar against the project.
yeah, i found that out and fixed that on my own when i fixed the parenthesis. 
pip needs to depend on setuptools because many setup.py import setuptools (and use its features). As for your remarks, this is the rationale for a setup.cfg as used in the upcoming distutils2 and the bento.info in my alternative bento.
OK, but what did you find "unusual"? Does mdipierro's explanation clear things up, or was it something else? Note, the web2py mailing list is very friendly and responsive. If you ever have any questions about the framework or the code, ask there, and you'll get lots of help and insight.
Is this your project? You should upload the demo video to YouTube and embed it on your homepage or link to the video.
Damn, how much I miss NumPy. Seriously, that link makes me really mad that I have to use SAS for a class I'm taking right now. 
As a Lisper I sensed that shit from a mile away.
I have no idea what any of that means.. but.. great?
http://en.wikipedia.org/wiki/Part-of-speech_tagging "A simplified form of this is commonly taught to school-age children, in the identification of words as nouns, verbs, adjectives, adverbs, etc." It's an important first step to do more interesting stuff, like named entity recognition, sentiment analysis, fact extraction, etc.
&gt; It's bad at parallel (multithreaded) computing. I wouldn't go as far as saying it's bad at parallel computing. As you said, this only affects multithreaded code on Python implementations that uses a GIL. Anyway multithreading isn't the best aproach to parallel computing as it doesn't scale to multiple nodes. So Python is perfect for parallel computing.
Yeap, mdipierro's cleared things up. Thanks, I'll check the mailing list if I have any other question about the code.
I had to test that out just to be sure, and sure 'nuff it's true! I'll be derned. You have any explanation for that?
see [vpython](http://vpython.org)
It's True. :P The empty string does exist in all strings. as for why the empty tuple doesn't exist in all tuples, I don't know. 
Also, if you're going to [PyCon](http://us.pycon.org/2011/home/), there's going to be a [web2py tutorial](http://us.pycon.org/2011/schedule/sessions/26/).
I already got a nice answer on your(?) blog. Thanks for this. Now I have to understand everything. NLTK (and python) is new to me.
[Flask](http://flask.pocoo.org/) is pretty lightweight, but it does have sessions support (and with [Flask-WTF](http://packages.python.org/Flask-WTF/), form handling).
Maybe something like [Bottle](http://bottle.paws.de/docs/dev/index.html) would work? It's one file, gives you convenient access to all the web-relata. There is no ORM (AFAIK).
Try web2py. you can download and get it working in minutes. 1) Automatically handles sessions and gives you access to session variables. 2) The SQLFORM helper is very easy - you tell it the name of the table and it automatically creates a web form for all the fields. Or you can give it a list of the fields. Pretty much everything works with some sensible defaults or you can tailor if you need to. 3) It has models but again very easy to use. It does not have an ORM but has database query commands you can use which work with different databases. Or you can use SQL. 4) OK so it is based on MVC!! But it is really simple as web2py does all the work for you. 5) The templating language is basically python! 
[web2py](http://web2py.com) is a full-stack MVC framework, but I don't think it would be overkill for smaller projects. It's very quick and easy to use, even for simple things -- it requires no installation or configuration and has no dependencies. Note, instead of an ORM, it has a [database abstraction layer](http://www.web2py.com/book/default/chapter/06) (DAL), which keeps you closer to SQL. You can talk to the database directly, but you might find you like the DAL as a middle ground between straight SQL and an ORM. If you have any questions, the [mailing list](https://groups.google.com/forum/?fromgroups#!forum/web2py) will help you out.
You have lots of choices. People have mentioned Flask and web2py. I think [Pylons](http://pylonshq.com/) would also be a good choice. It's a full stack framework but very loosely coupled, you only use what you need. It is actually pretty good if you're working on a small project that you think has a potential to grow.
I'd love to, but I don't live in the US.
[Flask](http://flask.pocoo.org/) now has over 30 [extensions](http://flask.pocoo.org/extensions/). Also it is well [supported](http://flask.pocoo.org/community/) and [documented](http://flask.pocoo.org/docs/). Definitely look through the [example apps](https://github.com/mitsuhiko/flask/tree/master/examples) and [snippets](http://flask.pocoo.org/snippets/) to get an impression of it. EDIT: links, added snippets
take look at http://www.cherrypy.org/ 
Is lolspeak webscale?
JavaScript isn't beginner-friendly, though. It's quite unlike more conventional languages and most tutorials for it are wrong, outdated and terrible.
ORM's in Python are usually a great deal better thought out than ORM's in PHP imo. In Python they are usually done in pure Python, no editing this XML file here, editing that ini file there, editing another yaml file over there. Personally I find the django ORM great for everything I need to do, if I can't do it in that ORM it really needs to be a raw SQL query anyway. 
I guess [Flask](http://flask.pocoo.org/) or [web.py](http://webpy.org/) would be more suitable.
I wouldn't go that far. Because of the GIL, python isn't really a hot language for people developing parallelism frameworks. You're pretty much forced to do coarse parallelism using message queues or something like Hadoop. And tools like Hadoop aren't typically written in python, so you have a mismatch trying to get a Java process to play nice with your python code. I know there's an MPI implementation in python but I haven't tried it.
Try [Web.py](http://webpy.org/). It does form handling, templates, DAL, etc. Check the cookbook and API reference.
ORMs are like the best most timesaving thing for small projects, so I disagree with you there. I agree, however, that MVC can get overwhelming; I guess you could use Django totally wrong and not bother with the MVC part! If I was in a super hurry that's what I would do, but I also really like Django.
[Tornado](http://tornadoweb.org) is really great to work with, and despite (or maybe because of) being quite light, it kicks ass in a lot of benchmarks. I'm with you also, I hate working with ORMs.
JavaScript is terrible for what it's being used now. Unfortunately, it's currently the reality of webdev. Well, good programmers do their best with what they have; one just have to hope that from time to time this will result with good code.
While web2py is MVC it has a major difference when compared with other Python frameworks: it gives precedence to "do not repeat yourself" vs "explicit is better than implicit". This means everything has a default (although the default behavior can be changed). So if you just write a model you have a working app. If you just write controllers you have default views. Any function you write can be cached, served as html, js, xml, xmlrpc, jsonrpc, amf, etc. Try it online, without downloading here: http://web2py.com/demo_admin It also comes with a wizard that asks you some questions and creates a basic scaffolding app (including models/views/controllers/layout/authentication) for you. You can try it here: http://web2py.com/demo_admin/wizard web2py (including Database Abstraction Layer) is smaller than Django and any of the other frameworks using SQLALchemy (since the latter is bigger than the entire web2py). Yet the web2py Database Abstraction Layer runs on GAE too and supports 10 relational database engines). Notice web2py has DAL, not an ORM. We do not make records into objects but into python dictionaries. Each DAL expression maps 1-to-1 into a SQL query (you can do nested selects, joins, left joins, aggregates, and combinations thereof). web2py has no dependencies and does not require installation. You can run it off a USB drive for example. EDIT: example of complete web2py program with authentication (on top of scaffolding app) db.define_table('message',Field('body')) @auth.require_login() def index(): form = crud.create(db.message) messages = db(db.message).select() return locals() Notice if table 'message' does not exist it creates it for you and alters it accordingly automatically to keep it in sync with your model. The code in the example runs on Google App Engine without changes. 
I think there's definitely rooms for a middle-weight framework in Python. The light-weights in existence appear to be aiming for toy applications; while the heavy-weights have their own restrictions. A meaningful middle-weight is needed, I think. It should contain something like a lite weight like Bottle framework plus: + integrated simple database abstraction layer. + integrated simple authentication component. + a focus on the ease to get started, to develop to deploy and to scale. 
I would recommend numpy/scipy + matplotlib... If you can do the math and graph a series of stills ordered by increasing t, you can stitch the stills together into a movie using something else...
Are you sure you do not mean web2py? I do not think web.py has a DAL.
How exactly? The query syntax is usually more verbose than the equivalent SQL, you have to describe the tables, etc. Maybe if you aren't comfortable writing SQL by hand, but if you are it seems, well, awkward.
With web stuff, you have a whole other layer of validation and security to worry about, which takes up a good chunk of time on small projects. ORMs generally sanitize data for you and you spend less time writing code for ridiculous contingencies. Maybe it's just me, ORMs make more sense to me with things other than the simplest queries (and even then, those are just easier to deal with). I guess if you're really good at mysql there's no point in learning something new and dealing with its quirks, but I still google for syntax every time I encounter something more complicated than SELECT * FROM x WHERE y
I use [Flask][] with [SQLAlchemy][] for that purpose. When it grows more, I make its in-house framework on top of [Werkzeug][] and [Jinja2][]. …[Pocoo][] seems to save me always. [Flask]: http://flask.pocoo.org/ [SQLAlchemy]: http://www.sqlalchemy.org/ [Werkzeug]: http://werkzeug.pocoo.org/ [Jinja2]: http://jinja.pocoo.org/ [Pocoo]: http://pocoo.org/
Yeah, this is where I was expecting to go. I just was hoping to be lazy.
Tutorial? I am not a fan of the one on their site.
Mmm, I didn't know about WTF. Any comparison between this and formencode?
&gt; The query syntax is usually more verbose than the equivalent SQL Not by much, and they take care of building objects for you instead of returning a bunch of tuples (or if you're using something better than straight dbapi, a dict). &gt; you have to describe the tables Depends, and when you do they can oftentimes create the tables for you in the backend, so you don't have to create them yourself (you have to describe the table one way or the other don't you?). They can also take care of schema versioning (built-in or via a separate package) to keep code and db in sync. Though they are often lacking in access to e.g. stored procs.
&gt; It's a full stack framework No it's not. Pylons is only a controller section, it doesn't do routing, it doesn't do data access (db), it doesn't do templating, ... 
http://webpy.org/docs/0.3/api#web.db
WTForms is very similar to Django forms (without the Django dependency and with bindings to SQLAlchemy as well as Django models). If you're coming from Django you'll find it very familiar. As with Django it allows you to easily customize widgets and validators (validators are simple Python callables, very easy to write) and combined with Jinja2 you have a very flexible form rendering system - being able to specify widget arguments in the template rather than your Python code is a major plus. It's been a while since I've used formencode, but I found wtforms a lot simpler and more Pythonic and it handled most cases quite easily. 
Not exactly what I mean by a DAL, but thanks for the reference. 
Upvote for Flask. What WSGI server do you use it with? My current stack is Flask-&gt;Bjoern-&gt;nginx, but I'm always up for suggestion.
&gt; MVC always seemed like incredible overkill for smaller projects I've always found that there's no telling when smaller projects will balloon into larger projects. That's why it's useful to be organised from the get go.
This is how you create a new project in Pylons. $ paster create -t pylons helloworld Will setup SQLAlchemy ORM, Routes, Mako (few more options as well) templating. You can choose not to use an ORM at all or pick a different component but it comes with most of the tools a full stack framework comes with. So It indeed comes with all the components a full stack framework has. They are just loosely coupled 3rd party components. What's next, Turbogears isn't a full stack frameworks because all the components didn't come from the same team?
At the moment I'm using the Werkzeug debugging server! I've not deployed anywhere yet. I'm currently planning to use [gunicorn](http://gunicorn.org/), though. 
As posted in the comments. Generator expression works great for this def find(f, seq): return (item for item in seq if f(i)).next() It'll stop after finding the first match and it will be more efficient than what he wrote. 
My major objection with this is that the loop def find_fred(peeps): for peep in peeps: if peep.name == "fred": return peep is an idiom across many, many imperative languages and thus extremely readable. Mungling that into a "shorter" and "more concise" is possible, but nowhere near beneficial in my opinion. 
the multiprocessing module is actually quite good, but in any case, Python isn't winning any speed competitions.
Last time I used it, the pylons paster template did *not* install (let alone setup) sqlalchemy by default, and Mako is an option, though the default. And Pylons's docs seem to agree with this. &gt; So It indeed comes with all the components a full stack framework has. They are just loosely coupled 3rd party components. Which is kind-of the whole difference between a full-stack framework and not-a-full-stack framework. &gt; What's next, Turbogears isn't a full stack frameworks because all the components didn't come from the same team? The whole point of TG is to create a single cohesive distribution…
Thanks a lot. &gt; It's been a while since I've used formencode, but I found wtforms a lot simpler and more Pythonic and it handled most cases quite easily. Yeah, I'm checking out formencode because the project I'm on now uses it, but it seems far more complicated than Django's forms, which pretty used to.
Yep, except that using call the existing Dispose() method, while with requires that you write new methods for your objects.
To me it looks like you're confusing Python's with and Javascript's with.
&gt;C# supports yield (thx hillmanov) and with is called "using" (thx HLAR) which is the same as with. So I guess that leaves try+except+finally or does C# suppport that too? Even Java supports try/finally. C# isn't far behind Python features-wise, it even supports dynamic typing. To me, a more important difference is that Python's development is directly done with the community, while with C# we needed to wait .NET 4 before having an equivalent to os.path.join().
It raises a `StopIteration` exception when it cannot find the item.
Nonsense.
&gt; Last time I used it, the pylons paster template did not install (let alone setup) sqlalchemy by default, and Mako is an option, though the default. And Pylons's docs seem to agree with this. What did I say differently? SQLAlchemy is optional, but the paster template prompts you for it when you're setting up the Pylons project. If you decide to use it, all you type is "yes", provided you have it installed of course together with other Pylons dependencies you decide to use on your project. For instance in my Pylons deployments I use CherryPy as the http server instead of the default Paste. What makes Pylons full stack is the fact that it comes with the SQLAlchemy option and the Pylons setup project template will setup the ORM and model/ structure for you should you choose that option. This goes for Routes and templating. &gt; Which is kind-of the whole difference between a full-stack framework and not-a-full-stack framework. A *loosely coupled full stack framework* describes Pylons pretty well in my opinion. Compared to a tighter coupled "best of the breed" full stack framework Turbogears is.
not really up to date on my ORMs in python, but in rails you just do Class.find(id) or Class.find_by_column(value) where class, id, column, and value are replaced by what you actually want. that's quite the opposite of verbose!
&gt; A loosely coupled full stack framework describes Pylons pretty well in my opinion Makes no sense. The points of a full-stack framework are that it's a one-stop shop and that the whole package evolves as one (ensuring coherence and compatibility between the various pieces). This definitely isn't the case of a pylons project since all the parts are moving completely independently from one another. Sure the "lesser" half of the dependencies (Routes and WebHelper) are Ben's projects anyway, but the other half sure as hell aren't. &gt; Compared to a tighter coupled "best of the breed" full stack framework Turbogears is. Actually, TG would fit "loosely-coupled full-stack" much better than Pylons: the pieces are validated to ensure they match and helpers and stuff are added to make the whole more coherent and cohesive, but it's not like the various "best of breed" picked suddenly depend on one another: they don't, and you can pretty easily swap them out still. By comparison to an actually tightly coupled framework such as Django where swapping out components might plain and simply be impossible (I'm not sure you can replace Django's urlconf for instance), and even when it is possible it will cause significant loss in integration and functionality[0] (as well as make the wider community's work plain and simply inaccessible) [0] depending on what is "swapped out", significant parts of contrib may become inaccessible for instance.
I really urge you get over your irrational fear of MVC and just use Django, which isn't even textbook MVC but rather Model-View-Template. You don't have to use templating if you don't want to and you can have exactly as barren model definitions as you want. Hell, you can even bypass most of the models without losing the integrated contrib apps Django ships with. MVT is just an alternate way to structure server apps. The other big alternative is CGI files like PHP. It's not heavy or overkill for anything.
Minor correction: *next(foo)* is more portable than *foo.next()*. The *next* instance method has been removed in Python 3.
Although I usually prefer functional programming, the iterative version is simpler and more efficient than versions involving comprehensions. Its running time is O(k) instead of O(n), where k is the index of the first element i satisfying f(i) == True, and n is the length of the list (assuming f itself is O(1)).
It's not the I "fear" them. They just seem to involve lots of boilerplate code, and the kinds of problems I'm dealing with often don't break down into clean object hierarchies.
&gt; The points of a full-stack framework are that it's a one-stop shop.. Pylons provides this. &gt; ..and that the whole package evolves as one (ensuring coherence and compatibility between the various pieces). Pylons doesn't provide this, hence why it's loosely coupled, with the advantage of being able to use "best of breed" components, or not use an ORM if you so choose for instance. You can certainly disagree, but to me the qualification for a full stack framework is what you get "out of the box" when you create a new project. Pylons: - will setup the ORM for you, in the config.ini file, model directory, and model layout with necessary imports - will setup Routes, with default routes in place. - Mako templating engine will also be configured for your use. You can immediately start writing your ORM models, templates and routes, from the moment you created a project. Everything else is just semantics. Those are the main 3 components of a full web framework stack to me. Pylons differs from Django and Turbogears in that it's loosely coupled. 
Object hierarchies? The closest thing my reasonably complex apps have is SQL relations. The worst boilerplate I get is around extending Django's templating: I do things that work on the fringes of Django's given functionality. The bulk of the code is however as succinct as it gets. It's all functions I map to with the URL tree. Django doesn't make you do things the hard way, unless you consider configuring a web server to point at your app the hard way.
Financial aid deadlines are already passed. Maybe next year... -Broke-ass student on food stamps
Whoa, cool. I didn't know about next(foo). It's shorter and it lets me specify a default if I don't like the StopIteration exception.
I don't like the idea of limiting myself to a subset of language I'm using just because some of its syntax isn't universally known. Otherwise I would just code in C. Even C++ has a find_if template function which solves this problem in very C++ way.
So where exactly do I say "dont use generator expressions"?
use something like the live http headers extension for firefox to see exactly what got posted to where, and then do the same thing from python
On the contrary, SQL syntax is extremely and unnecessarily verbose. Take this query, for example: SELECT * FROM users INNER JOIN profiles ON profile.idUser = users.id WHERE users.age &gt; 5 The equivalent ORM query might be: Users.with(Profile).filter(age &gt; 5)
&gt; The query syntax is usually more verbose than the equivalent SQL Oh, really? Person.objects.all() SELECT * FROM people; Person.objects.filter(name="Jacob") SELECT * FROM people WHERE name = 'jacob'; Person.objects.filter(hometown__state='KS') SELECT * FROM people INNER JOIN cities ON (city.hometown_id = cities.id) WHERE city.state = 'KS'; Person.objects.filter(hometown__state='KS').exclude(name='Jacob') SELECT * FROM people INNER JOIN cities ON (city.hometown_id = cities.id) WHERE city.state = 'KS' AND name != 'jacob'; Look, there's plenty of reasons not to like Django's ORM without resorting to FUD. If you need help, I can give you some valid criticisms for next time, but please verify your claims before you make them.
Ok, now you have me all confused. You're fine with generator expressions but you don't think it's good in this context?
 items = ['waffles', 'apples', 'milk', 'chicken', 'etc'] print items.index('milk') # Prints position in the list print items[items.index('milk')] # You can fetch the found item from the list like this print items.pop(items.index('milk')) # Or extract (and return) it like this
Pretty much. My point is pretty much: For certain operations, there are loop idioms to write them down. A simple example would be "for (int i = 0; i &lt; a.length; i++)". I can look at this, recognize the idiom (0, less than array length, increment) and then know that this loop is going to do something with each element in this array. However, I could also do something different like "i = 0; while (i --&gt; 0)" and gain exactly the same effect. However, I don't do this, because in this case, I have to actually read and think if I get the bounds right, if the variable works properly and so on. In this case, its the same. In my head, I have this search-pattern ingrained: for element in collection: if predicate(element): return element If I see this, I can immediately recognize the structure and ignore all the clutter around it and focus on the interesting things (in this case, collection and predicate). If I now use generator expressions in this context in order to save myself some nesting or some lines, this structure disappears for no real reason (just making it shorter without making it a lot more readable is no real reason and that single next call on an iterable always looks suspicious). Of course, I use generators and generator expressions, because it can be very, very clear. Something like "max(value(element) for element in elements)" or "any(winIfMyMove(vertex) for vertex in followers(current)) is just amazing.
I think this is wonderful notion: If you think of software having multiple audiences then you can imagine situations in which adhering to python's idioms may be more or less important than adhering to industry idioms. On my current project I've got developers with different degrees of skill and focus. Those that work on the most internal libraries are expected to write with an orientation towards efficiency and make liberal use of python idioms. Those that write the glue-code on the outside are expected to write with an orientation towards maintainability &amp; readability. And often these developers have far less experience in python than other languages - or in our business domain. So, I'd rather see a loop than a more sophisticated feature in that part of the code base.
Django: Class.filter(col1=val1, col2=val2).exclude(col3=val3) or Class.get(id=id) Couldn't be easier, and far less verbose than e.g. SELECT * FROM Class WHERE col1 = val1 AND col2 = val2 AND col3 != val3
Is this what you're thinking of? combs = itertools.product('+-.',repeat = 3) 
&gt;What if a dictionary has two of the same key:value pairs? Not possible. Any attempt to write to the key 'orange' will over-write the previous value. See http://docs.python.org/py3k/tutorial/datastructures.html#dictionaries
Here is the short answer(s): Dictionaries can only have unique keys, so it is impossible to have two different values for any particular key in a dictionary. It is however, possible to have two different keys hold the same value. Since it is impossible to have two of the same keys, you can never converge them, but you can converge specific entries into new entries (or overwrite existing ones).
there are 27 ordered combinations of 3 symbols, there are, however, only (n-1+k)!/(n-1)!k! = 5!/(2!*3!) = 5 * 4 / 2 = 10 unordered combinations. 
 import urllib, urllib2, cookielib username = 'usernamegoeshere' password = 'password goes here' cj = cookielib.CookieJar() opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj)) login_data = urllib.urlencode({"user login tag name goes here" : username, "password login tag goes here" : password}) verified=opener.open('Login URL Goes Here', login_data) resp = opener.open('Response Page URL goes here') pageone = resp.read()
Thanks! Another two quick questions if you don't mind? One- Is it possible to split a string per character, as opposed to per white space instance? (As in with a built in function) Two- Okay, so if I were dealing with a simple file that dealt with repeating keys, can you accumulate, instead of it being overwritten? Example- Say I made a dictionary of my grocery list, and orange was mentioned twice. Instead of the new key value pair being orange: 2 since that is the latter instance, can it be accumulated to orange: 3?
Sounds like you'll need a custom machine. For that. I can't recommend Linode.com enough. You can get cheaper prices at prgmr.com if you don't mind the lack of a web panel.
1. Yes. http://docs.python.org/library/stdtypes.html#str.split 2. Simply make the value of the dictionary another dictionary, or perhaps a list or a set. Nested dictionaries are fun! 
As others have said, keys are unique in Python dicts. That being said, you can still (kind of) do what it sounds like you want to do. One way is the following: d = {} ... value = 2 d["orange"] = d.get("orange", 0)+value This would have d["orange"] == value if "orange" wasn't in d yet, and == value + the previous value for "orange" otherwise. Alternatively, if you want to make a list, you can do something like the following: d = {} ... value = 2 d["orange"] = d.get("orange", [])+[value]
for #2, take a look at collections.defaultdict
For Two- I would do something like def addToDict(dictionary,key,new_value): try: dictionary[key]+=new_value except KeyError: dictionary[key]=new_value 
One: Many ways to do that, a simple one that I like is: map(None, "Some string") Two: Use the 'get' method. It works like [], except that you can supply a default value. Your grocery example would become: grocery.set(grocery.get('orange',0)+1) Good luck with your homework! ;-)
I'm thinking you were down-voted because this can be accomplished without a try and catch (see others' examples below).
Hahaha thanks, and thanks everyone. Yeah, that's why I tried to keep the questions limited to function. I've actually already completed and handed in the assignment, I was just curious as to whether a more efficient means to complete my problem existed (Which, there obviously is.)
&gt; When I want to persist an object, I save it's inbuilt dict to a Mongo collection. Do you use pymongo ?
The following should also work for 2: mydict.setdefault("orange", 0) # Only sets orange if orange is not yet set mydict["orange"] += 1
I prefer the "setdefault" function for lists: d.setdefault("orange", []).append(value)
amazon ec2, new sign ups get one year free micro instance node (630 megs ram, etc.) and bandwidth/etc. which is enough to run a small site.
http://stackoverflow.com/
1 downvote does not a butthurt hivemind make. Although I could have thought out a smaller line count solution, I stand by the assertation that my solution is robust and interchangable(syntax is the same for number, string and array adding).
That works, too :)
Have a look at /r/learnpython Its great for these questions
This is exactly it. Thank you, to both of you, for pointing out my mistake!
figured it'd be just about as elegant in django. in fact, it fits every stereotype of rails vs django-- the rails reads like magic (how did it know that i meant id? how did it make those methods?), the python reads clearly but a little more verbose. but yeah, definitely better than SQL (and i really don't mind sql in general)
I prefer list("Some string") to map(None, "Some string") seems more intuitive.
I like pylons since you can use as much of it as you need. I was able to build a document conversion web service which invokes ooffice in the backend, and sends async responses to a client over XMPP If later I need to make a full web GUI / file manager, I won't need to re-write any code, just start building some views.
http://webfaction.com
Any particular reason to use gunicorn over something like gevent or bjoern?
I don't see anything about Tornado hosting... I guess you could just install it from a package via the shell and configure it to use the port they specify?
Aside from the defaultdict this is the best solution. Explicitly checking whether the key is in the dictionary before incrementing it is *far* slower than using try/catch.
The Django template improvements are nice. I wish Komodo IDE wasn't ridiculously expensive. There is no way I can justify the cost for my part time business (no Python at work).
os.popen is deprecated, preferred is to use subprocess.PIPE
Supposedly this one is good, http://genshi.edgewall.org/wiki/GenshiTutorial 
Rails version isn't much different.
FYI, [Komodo Edit](http://www.activestate.com/komodo-edit) is free.
web.py seems to be fine , i discovered that it supports firebird http://www.firebirdnews.org/?p=5362 and Now if i think between choosing a big fat framework and a microframework i would always choose the microframework even if it doesn't support a big fat ORM solution out of the box but you can choose to do so if you want 
Why must this not be used for important websites?
I've done something very similar, but done it as a CGI script so I can do it anywhere in the world. One thing this solution misses that I chose to add to mine was the idea of some transient salt for the password. I add in the current month in format YYYYMM and keep a track of when I generated each website's password. That way, I can change a password later on if I think it's been compromised. This approach with just a website token (I use its domain) and the master password means you have to change one of those two if you want to change the password.
I used to use this method, The problem was that since the hashing is based on a url it gets messy when you need to change a password for a one site. Say a website suffers a leak and they suggest you make a new pw - you'd need to change your master password - affecting all passwords - which means you have to change them on all sites. Question is, what can you use in this case? The domain + some variable that changes when you make a new pw. Anyone got an idea? Currently I use a substring of a long password, eg: 403jef03q89ufy08ji0o324jfi3f089j4hf0j for important sites, I'll use 403jef03q89ufy08 for less important: 403jef03q89 for sites like reddit: 403jef03 etc. If my reddit pw had to be changed, I'd just upgrade it to a the next level. The only annoyance is you might have to try a couple times to get the right 'category' of page if you don't remember it. Edit: think I just answered my own question, use eg. 10 characters of the hash by default - when you need to change a pw, tack on another character. So if your master + domain password for reddit.com = e12e0ui90uzjf4... your reddit pw is e12e0ui90u if you need to change it - tack on the 'z' making e12e0ui90uz - so at worst you make one more login attempt per password change. Of course if someone knew you use this method they could easily crack your new password...
I should have written "for 3.2" instead of "3.x". I read this last week in the "what's new in 3.2" document and was happy to see that your objection - which is true for older Pythons - was only an implementation detail. Python’s peephole optimizer now recognizes patterns such x in {1, 2, 3} as being a test for membership in a set of constants. The optimizer recasts the set as a frozenset and stores the pre-built constant. Now that the speed penalty is gone, it is practical to start writing membership tests using set-notation. This style is both semantically clear and operationally fast: 
First of all, if you are building and `array.array` object in your function, as it says in the title, and do it using its `append` function, then you probably shouldn't care about a single temporary `int` object created and destroyed repeatedly. Also, it might turn out that creating a list of ints and then packing them back into array is faster than calling `array.append`, and that would mean that you should ask yourself whether it's time to stop. I mean, it's nice to reduce load time from 3 to 2.5 seconds, but if the rest of the code takes five minutes... After all whenever you use any of the integers stored in the array, a temporary integer is created as well. Otherwise, consider using ctypes. It would be a bit awkward (and not threadsafe) because you shouldn't return memory allocated in a dll, so the general idea is: a parsing function allocates an internal array ('`int *`', I mean) and returns the number of elements, then the Python adapter creates a '`c_int * count`' array, passes it to the second function, which sees it as a plain '`int *`' too, copies the data there and deallocates its own storage. Everything should be written as a plain C .dll/.so, not as an extension module.
Get a VPS and use nginx as a proxy to it. https://github.com/radiosilence/servers.py/blob/master/skeletons/nginx_flask.skel Example Nginx server.conf
I meant: try: 1 / 0 except: # handle it finally: # you don't need to nest 2 "try" statements.
If you are dealing with large arrays, why aren't you using Numpy? Its loadtxt() function is precisely what you need. http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html#numpy.loadtxt 
Out of curiosity can the django orm do something like this as well (sqlalchemy)? User.query.options(eagerload_all('address.city.region')).filter(Region.id==4) and give you a 4 table join based on User.address.city.region
re: 2, You're better off using collections.defaultdict: d = defaultdict(list) for key, value in source: d[key].append(value) http://docs.python.org/library/collections.html#defaultdict-objects
prgmr.com is out of IP addresses. But linode seems pretty cool. A little bit expensive, but pretty cool. I'll check that.
Have you ever used it? How much do you pay? I'm concerned about the pricing by usage. 
thanks!
If you're gonna ask for help porting your software to Windows, you might want to show a little more respect.
I think there's a commandline utility that does screencaptures. Ahh, yeah, google says it's [/usr/sbin/screencapture](http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man1/screencapture.1.html). You could set it to take a picture and save it to a file (using subprocess.Popen), then just load that file with PIL. It'd be a bit slow because of the image-&gt;disk-&gt;PIL step, but if you don't need superfast interactive capture it should work. 
not particularly, I just happened to find it while looking for something else and it seemed interesting and useful (I hadn't even heard of bjoern until you mentioned it)
You can do it too. Since it's already available in Java, I would find it very strange that C# doesn't support it, and I don't really understand why we had to wait to have such a basic feature in Python.
I think so, yes: [select_related](http://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.QuerySet.select_related). If I'm interpreting your SQLAlchemy code correctly, I think the equivalent Django query would be: User.objects.filter(address__city__region__id=4).select_related('address__city__region') I'm not perfectly familier with SQLAlchemy, so it's quite possible that I got the translation wrong, but it's close, anyway. Also, I'm sure that SQLAlchemy version has more features/options because, well, SQLAlchemy always has more features/options. That's what it does well.
Yep that looks exactly like what the sa version does. The (minor) annoyance with both versions is that you have to manually specify albeit with syntax sugar, the joins. Would be nice if you could do User.filter(User.address.city.region.id==4) and have it *just work*.
Unfortunately it is not that easy. Its not a file full of numbers I want to have in an array. It's a more complicated and sparse structure I need to parse. But thanks for the hint though. Would be interfacing with numpy.array easier from C?
There is nothing to beware about. Nobody is writing multithreaded applications in Python.
Thanks for the answer! With C module, I mean an .so file I use as a module in python. That module currently fills a list using append and returns it. In the python code I create an array.array by handing over that list. I'd rather build the array.array directly but don't know how to do that. Yeah, you're right about reconsidering if I want to go on. It reduced the startup time from about 60 minutes to about 30 minutes, so probably worth it. I just wanted to check if I was doing something wrong or missed something easy. Because currently the C module is just a couple of lines.
yes. when pyramid was called repoze.bfg the docs were already more comprehensive than pylons. they are now even more so. The alpha releases leading up to version 1.0 seemed to be mostly changes to the docs. So the docs are quite good. http://docs.pylonsproject.org/ I wouldn't have any hesitation at choosing pyramid over pylons. 
didn't see any javascript integration in my brief look at the docs or resource injection. So If you need that I would suggest [toscawidgets2](http://toscawidgets.org/documentation/tw2.core/).
Thanks for the help. I was hoping to avoid having to write to the disk, but it seems like this might be my only option if I want to do this on my Mac.
[DotCloud](http://www.dotcloud.com/) is still in beta. It can host any [Python WSGI application](http://docs.dotcloud.com/static/components/python/). There are deployment tutorials for [Django](http://docs.dotcloud.com/static/tutorials/django/) and [web2py](http://docs.dotcloud.com/static/tutorials/web2py/).
My story: I've heard about Python few yrs ago, and since I'm that kind of guy who learns stuff doing things not-so-at-noob-level for a start, I jumped straight into Pylons (I needed to make a intranet portal for my job). Abviously, I left Pylons because at that time I didn't quite understood the whole MVC concept, add to it that I had problems understanding python code etcetc. Now, after few years of playing on and off with Python (and with a larger project completed recently) I decided to re-write that old intranet portal (which I wrote in PHP, God forgive me), I've read about this whole Pyramid affair and decided to give it a shot, especially after seeing the very good written Wiki tutorial (SQLAlchemy + URL routes). After less than two weeks of work, the portal is working at its basic functionality, and i'm still adding new things to it, without a hassle. I find it much easier to grasp than Pylons (this might be biased because I haven't really worked with Pylons more than tutorial). So, if in the long run you are considering moving to Pyramid, then start with Pyramid. Why bother messing with those bits of code, which won't be automatically upgradeable from Pylons to Pyramid (and according to Murphy's Law, this WILL happen)? Just my $0.02
does dotcloud run python? :)
You can actually just do `User.objects.filter(address__city__region__id=4)` in django, and it just works. The `select_related` bit tells you that you also want to SELECT the fields off of the other tables, rather than just filtering on them.
I do love the snobbery in the comment section...awesome!
I have to apologize for the OT, but I assumed this was an /r/starcraft/ post and you were asking a really noobish question about fast expanding as protoss. In which case the answer would be that expoing without a pylon would be a huge waste of time, since you'd be capped at 10 probes. I use Django, so I don't have a real answer for you.
"DotCloud provides a service nicknamed “python”, which actually provides Python-WSGI functionality. To run any WSGI-based application, you just need to push a wsgi.py file containing a WSGI handler named application, and it will automatically be served by a nginx+uwsgi stack." from [the docs](http://docs.dotcloud.com/static/tutorials/django/) WSGI is the bees knees. I just wrote this it also runs on DotCloud. from webob import Response application = Response("WSGI RULES!!!!!") :)
Another +1 for Pyramid. I've been really happy with it so far. I would definitely start with the tutorial in the pyramid documentation and go from there. It's also fairly easy to get questions answered via irc or their google group. 
Wow, I just realize that protoss have an ancient Egyptian theme going on.
Hopefully TW2 is nothing like the clusterfuck that was ToscaWidgets.
Yes, but how would you use that to find the first element where an arbitrary statement returns True? e.g., if you wanted to find the first element that has an 'm' in it.
Man. There's a _lot_ more reasons to beware of `pickle` and `cPickle` than that. This is pretty trivial.
Yes there are, but at least all (?) of the other things that I can think of are documented in the pickle module documentation. I would go so far as to call this issue a bug.
Would the downboat brigade care to correct me?
That is why you should (occasionally) pay attention to your math teacher in class. :-)
In Python, math.log takes an optional second parameter indicating the logarithm base. So, if you, say, want the log of 6435 in base pi, just use math.log(6435, math.pi)
I used a fair bit of Pylons about 3 years ago and liked it, but haven't touched a Python framework until recently. Django seems to have cleaned up the field in the meanwhile, but it apparently is still behind where Pylons was in many places. I've started reading the Pyramid docs and screwing around with the code, but my major worry is that it is so heavily based on Zope. Zope, for those who weren't there, was a god-awful piece of excrement that nearly throttled Python as a viable web language in the cradle. Has anyone here gotten deeply enough into Pyramid to know if it is a shitball like Zope, or if the Pylon devs were more restrained in design while incorporating Zope ideas?
1. Yes. Use the list constructor. 2. Yes. Use the counter container from the collections module with the update method.
Ah freshman year, good times :)
I'll second linode. You probably won't find customized Python hosting that can run Tornado, so I would just look for a good general purpose VPS or server with shell access.
I think that is an unfair criticism of Zope. Particularly of Zope3. (shitball is a strong word, zope works remarkably well for larger enterprise applications - not so much for smaller commodity websites/startups) Granted, I will never use Zope for a web application but there are a great number of awesome packages that have been pulled from Zope (repoze project) to be used in economic and straightforward frameworks. I would go so far as to say that a good deal of core python has been influenced by the developers of zope and the experience gained by the project. I personally use zope.interfaces and zope.schemas for my payment library - very powerful and beats, by a long shot, deeply nested dictionaries with complicated type checking. Pyramid is, quite simply, amazing. Read this thread for some great arguments from the (Pylons) developers: http://groups.google.com/group/pylons-discuss/browse_thread/thread/2056d8b0d7de7ee3?pli=1 Pyramid is its own framework, mind you. The developers have taken the best libraries of repoze (which are from Zope3) and deeply integrated them with a solid and lucid framework core - there is a reason why the Pylon's development team is completely embracing BFG as Pyramid. Pyramid isn't a merging of Pylon's code and BFG's code, it is a merging of Pylon's team with BFG's team - talent acquisition.
I also remember Zope... I really haven't looked under the hood, but generally speaking they've only taken a few parts from Zope. The Chameleon templates are the default in Pyramid, which are fast-loading Zope templates... I switch them out for mako templates which I really like. The nice thing about Pyramid is it's really flexible that way. If there is a part of it you don't like you don't have to use it.
Sweet fucking christ. it uses zca. As does twisted, but no one bitches about that. zca itself is pretty neat, but it's a rope that you can hang yourself with. pyramid's use of zca is an implementation detail you don't need to concern with. and the resource traversal (also from zope) is a very useful concept. 
Zope 2 was indeed a nightmare, but pyramid only uses stuff from Zope 3, mainly the zope component architecture, which is excellent. Pyramid is some of the best code I've had the pleasure to work with! 
/shrug I didn't have any problems with it. it's not easy like wtforms seems to be though.
You're right, and to be honest, your solution is what came to mind to me first. Had I written the code, I would have used a try/except.
Ehhhh, I've written better guides for python on windows, this one is lame. 
http://docs.pylonsproject.org/projects/pyramid/1.0/designdefense.html#pyramid-has-zope-things-in-it-so-it-s-too-complex 
That's a math basic, not a Python pro-tip.
Sure, it's not trivial, but it is possible. I wrote a web front end for my music collection and part of it was the process to scan through the id3 tags to populate the db that can be done from the command line. all you do is implement a command https://bitbucket.org/twillis/spazzer/src/5588e0a3b019/spazzer/collection/scanner.py#cl-230 and in your setup.py you need to register that command with paster. https://bitbucket.org/twillis/spazzer/src/5588e0a3b019/setup.py#cl-42 And then you will have a sub command for paster to run. the setup.py above registers it as "spazzer-scan" Hope that gets you going in the right direction.
I'm having a hard time understanding exactly what you're doing beyond loading a bunch of numbers from a file, but a few things come to mind: 1) If you can predict any aspect of the shape of your final data structure you should be able to optimize parts of the loading process 2) Given the choice between allocating a huge amount of memory once and then disposing of it OR allocating a small amount of memory and disposing of it constantly, python tends to do the latter faster. So if you can send the Py_Number objects into the array.array in smaller groups you may get a speed improvement. 3) Have you tried building an iterable of some sort and using array.extend? It may improve your speed. I'd also give another suggestion to try and find a way to load this into a numpy array, especially if you can determine ahead of time the dimensions of the array
I thought this post was about Starcraft until I saw which subreddit it was from.
OP_IS_DIAMOND_FYI
Honest question: Why didn't you try django? Or if you have, why did you stay Pylons/Pyramid?
Use a templating system: I recommend Jinja2, This is your V Also, use jQuery to make it easier to program and more compatible. Use a framework like Flask: This is your C You don't have any database content, so you don't really have an M. You could just archive the SVGs through some sort of hash and keep them in a directory structure. 
Nothing in the scope of what he stated indicates stored content.
Django is a terrible idea for transforming a CLI app into one with a web interface. Just... no. The idea is offensive. I have used Django and these other utilities, and it would take me three times longer with Django given the size of your project.
CherryPy and Flask have very similar styles. I use to recommend CherryPy, but now recommend flask because the routing is more straight forward, via decorators. I've made web services with both. Converitng a web service from one to the other is extremely simple. I recommend using a web server like Cherokee that makes it very easy to set up a reverse proxy and handle the static content. There is no need for the complexities of wsgi. Ports are there for a reason.
ORM for what?
If you start down this road you will shoot yourself in the head and never get it done. What use would you really have for your own login and registration system... or forums for that matter? If you want this functionality, attach yourself to a facebook or google API for authentication and social aspects. 
How big is the file and how long are the lines? If you're lines are very long you may be paying a penalty for first allocating memory for the lines (as a string), then allocating more memory for the split operation then allocating it again for the array of ints. It may be better to write this using a generator to read the lines in chunks and only build a full array for each line once. If you really want to go the C-route, try Cython as an easy way to write python C-modules. I would expect python to be able to create the data structure as fast as the disk can feed it data.
@monstrado recommended "starting out with a framework that doesn't have an ORM." I was just pointing out that just because a framework has an ORM does not mean it can't be used to get going quickly and easily (even if you don't need the ORM).
This might be a lame excuse, but I was introduced to Python by an old buddy of mine, which works a full-time job developing large applications for certain companies, and he used Pylons (among other things)
pyramid comes with ZPT (zope templates) as default, my first contact with them was when I installed Pyramid. I'm going to like them, so far. SQLAlchemy is used with transaction extension from Zope, TBH i'm not that python-savvy to tell if it's good or not, but it just sits there and doesn't come into way. I guess it works :)
I guess this could be considered the one time that coming from a MATLAB background helps.
Doesn't seem to support unicode in the interactive shell.
Windows doesn't use POSIX signals; it uses messages such as WM_CLOSE. But if you just want to kill the processes, here's some example code: import subprocess import csv KILL_LIST = ('notepad.exe', 'calc.exe', 'mspaint.exe') def main(): '''kill the processes in KILL_LIST (requires Win 6.0+)''' p = subprocess.Popen('tasklist /FO CSV', stdout=subprocess.PIPE) tasks = csv.DictReader(p.stdout) pid_list = [task['PID'] for task in tasks if task['Image Name'] in KILL_LIST] num = len(pid_list) if num &gt; 0: pids = '/PID ' + ' /PID '.join(pid_list) print "Sending termination signal to {0} PIDs\n".format(num) p = subprocess.Popen('taskkill ' + pids) p.wait() else: print "Nothing to terminate" if __name__ == '__main__': main() 
Perhaps you should look into [fabric](http://docs.fabfile.org)? 
Nope, not looking for a deployment tool.
Pyramid.
Which is a bad idea, they are deprecated in codecs and removes in Python3. Instead use the base64 and zlib modules directly.
This might be surprising at first, but not really surprising if you think about it. While the objects are being deserialized, the unpickler constantly grabs stuff all around, modules, classes, functions, when relinking the instances to their classes and everything that wasn't pickled. If I'm not mistaken, it can actually import necessary modules as well. So it might seem surprising if you're unpickling a huge list of integers, which could be done in background, sure, but which is not exactly the most common use case of `pickle/cpickle`.
missed that the first time around. thanks
truth. not sure why i felt i should put it here.
I obviously think too much in starcraft terms... I just was like: "It's called a *Nexus*! Not a Pyramid! And what's with this question anyway... I does not make sense" -_- An then I realised in what subreddit it was posted...
Watch this: http://twit.tv/floss151 Pyramid is definitely the future.
+1 Pyramid. Pylons is in maintenance mode, which means bugs will be fixed, but that's really just for existing deployments. Pyramid's where the action's at.
i love you. I will try this tonight.
[Flask](http://flask.pocoo.org). My god, I'm in love.
I didn't down-vote you, but I think it's because nobody has suggested using comprehensions. Moreover, the article commented on the same thing you commented on: &gt; I should note that the same can be achieved with the filter or reduce built-ins but they both require full list traversal where find requires traversal only until a True result is encountered.
groundhog runs circles around flask. you don't even know. :)
I don't think that has anything to do with it. cPickle dump and load get around the issue by freeing the GIL for some of the work that they do. dumps and loads could periodically release the GIL, too. Just releasing and immediately reacquiring after something like 1000 pickled objects would let other threads run reasonably well. I actually implemented something like this until I realized that dump and load already release the GIL.
I'm not going to say you should have paid attention in school, or some other snarky comment like that, however, I would recommend doing some math-related reading. For reference: This is often called [changing the base or the change of base identity](http://en.wikipedia.org/wiki/Logarithmic_identities#Changing_the_base)
https://github.com/derks/cement cement package uses paste for creating projects and such. 
Although this isn't efficient if you only want to find a single result, you can do the following to get a list of all matches. &gt;&gt;&gt; items = ['waffles', 'apples', 'milk', 'chicken', 'etc'] &gt;&gt;&gt; print [item for item in items if item.endswith('s')] ['waffles', 'apples']
Well, admittedly my reading comprehension (pun unintended) isn't the greatest. Now I understand. :-)
Except the WebOb. Flying spaghetti monster, I wish Pyramid was Werkzeug-based. Oh well, still awesome.
for a framework that started as an April Fools Joke (or for any framework), Flask is amazing
That is not a bug. It is how it is supposed to work regarding the GIL. It should also be clearly documented but it isn't a bug.
I'm not too knowledgeable about Python web servers, but gunicorn can use gevent workers, which I *think* means multiple processes. Also, gunicorn is ridiculously easy to use, and quite well supported (fairly popular)
WTH are you talking about?
the future is now. use what you like.
The only correct answer was given on reddit some time ago: http://www.reddit.com/r/Python/comments/edvws/an_often_asked_question_to_which_i_still_dont/c17dsh9
Free. You should be willing to invest in these things.
I recommend Cherokee for the sole reason that it has a nice interface vs. nginx's text files.
Very interesting. Thanks for posting.
I don't agree. dump and load do release the GIL. dumps and loads could do this as well.
Regarding TurboGears, my understanding is that it will be [merging into the Pylons Project](http://groups.google.com/group/turbogears/browse_frm/thread/a6ef71ebea4ebcb0#). It sounds like TG2 will go into legacy support along with Pylons 1.x, and they will also be building a new set of full-stack tools on top of the new Pyramid framework. EDIT: Originally, I mentioned another Python framework that guarantees backward compatibility because the OP seemed concerned about long-term viability and asked about the future of "Python web frameworks". However, mcdonc, the lead developer of the Pyramid framework, felt that the reference was not relevant here, so I have removed it. Anyway, for those concerned about long-term stability and backward compatibility, given the history, I would say Django is a much safer bet than Pyramid.
I was wondering the other day how something like this was done. Thanks a lot!
3Q
LOL, building a Pyramid (err, Nexus) before Pylons is a very brave strategy indeed... :-)
Hey masklinn, I also wanted something that was just for creating document structures by itself without the added weight of a web framework. After wrangling with pastescript, I ended up writing my own tool: http://www.huyng.com/projects/fdn/ I could be wrong, but this sounds like what you're looking for. Check it out and let me know what you think.
It seems like this page is just a copy from Dirks's python tools collection without mentioning the original source. http://dirk-loss.de/python-tools.htm
I wouldn't call that the "easy" way, but interesting nonetheless.
Or WebOb and Werkzeug merge. I'd second Werkzeug however. It wouldn't make much difference to the overall design of Pyramid, so you could, in theory, replace WebOb quite easily (and use synonyms e.g. request.POST &gt; request.form).
Flask is cool. I have a feeling that Pyramid is better designed for larger applications, though. The use of threadlocals in Flask - while a convenience - is one of the things that made Pylons difficult to handle as your application got bigger, and makes it harder to set up testing (the whole *app.test_request_context()* thing), and Pyramid has an excellent security system baked into the framework. That said, Flask is arguably easier to get started with than Pyramid. 
really like this blog post. I want to read C source code to improve my Python skill, I have used Python day-to-day for several years, and finished reading &lt;The C Programming Language&gt;, what should I do now?
There's nothing to stop you learning both Pyramid and Django. At the end of the day, it's all Python. All other things being equal (job market, community etc) there are two reasons to use one over the other: 1. Suitability for the requirements of your project. 2. How it fits your brain and coding style. The first is easier to quantify. Django comes with the admin app, which is a huge convenience. It has a ton of third party apps. If your project needs these, then use Django. On the other hand, Django also requires a lot of buy-in. In order to make full use of the framework - the aforementioned apps - you have to use their template engine, their ORM, even in some cases their predefined User and other models. Yes, you can strip all of these out, but it interop with other apps becomes harder. If that buy-in is OK with your project then go for it - you'll be flying. If your project requirements don't need an admin app, or you have stringent requirements on things like how your database model should look (you're using Couch for example, or a legacy DB) then Pyramid might be better. It has a lot of powerful concepts - like traversal - but more or less stays out of your way. Plus, you get to use tools that are arguably better than their Django equivalents - SQLAlchemy, Mako, Jinja2 etc. It has good core documentation (as does Django), is well-designed, and performs well, provided your application code doesn't weigh it down. The problem with Pyramid is that choosing these tools is a job in of itself. While SQLAlchemy has emerged as the gold standard for ORMs, and is the default choice, other things like form libraries are often fragmented and you spend too long trying to find the one library that matches your requirements, only to find it's unmaintained or poorly documented (looking at you, Flatland). Django on the other hand has a single form library that almost everyone uses. You may like it or hate it, but it's a standard everyone agrees on. It's therefore easier to jump between Django projects and feel at home immediately - this is a major advantage of a "rails" framework that heavily relies on convention over configuration. Pyramid offers freedom to do things your own way - provided you know what you are doing. For some developers, that's exactly what they like, and for some projects, that's the freedom you need. This means it probably appeals more to small teams doing their own thing, and to more experienced developers. 
I see, you're right.
I thought python dictionaries were implemented using RB-trees. Either way, cool.
[Beautiful soup](http://www.crummy.com/software/BeautifulSoup/) is a nice implementation for this type of problem as well.
That cast finally set me straight on what was actually going on with the whole, Pylons, repose.bfg, Turbogears, Pyramid thing. The future of all these framework looked uncertain for me, but in the end they are all consolidating forces to be able to make one kick ass framework. So I think Pyramid will be great, I am just not crazy about its name :)
D'oh. Didn't know you could do that. Thanks for the tip.
I agree. I always thought "repoze" was a cool name. Pyramid is a bit meaningless in this context, it sounds like a name a committee would come up with. Think of the best framework names: - Django: kind of hip and exotic - Rails: describes the whole philosophy of the framework in a single word - Spring: implies freshness + action (unlike the actual framework itself, unfortunately) 
It uses neural networks. So much for the "easy" part.
your ISP would probably frown upon it. 
There are at least 3 major implications: a) How much that is going to affect your internet speeds (concerns about bandwidth and data caps); b) how safe that is going to be; c) How much of your system resources are going to be drained/used. If you have an uncapped fast internet connection and a fast computer; then, for the sake of security, I recommend running cherrypy on a virtual machine like vmware or virtualbox and redirection the router's port only for that port and only for the ip associated with that virtual machine. If you decide to virtualize it, why don't you give it a try to amazon's EC2 and host it there? You can setup a micro ami that is free for up to one year (as long as you remain inside the free tier requirements).
Download the python source and read Python/ceval.c to see how the python virtual machine interprets bytecode-compiled python. See if you can write or modify some of this bytecode by hand. Read the source under Objects/ to learn how builtin python objects work.
It's a perfectly good idea, as long as you get very little traffic. Most simple websites do, so that's ok.
[Why not just use a regex?](http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454)
They could have went with "repoze.ng" :-)
You should have been on that committee. I like that.
I actually suggested a WebOb compatibility layer as a joke and Armin's and Chris' reaction was that it wasn't a bad idea.
A virtual machine is totally overpowered for most web applications.
Well thank god the Plone upgrade process was so broken, I could never move my site off of 2.1 because 2.1 does not have said vulnerability.
Werkzeug is actively developed and better designed. Though it lacks some things WebOb does, like the Range header, but also does a lot WebOb doesn't (like User-Agent parsing, bad example as you should rarely care about the UA). http://lucumr.pocoo.org/2009/8/5/pro-cons-about-werkzeug-webob-and-django/ (written by the Werkzeug author so standard disclaimers apply)
I used to run a little django website from home using dyndns, it was really only for my own use so traffic wasn't an issue, but it worked fine. You've got to take into account that most ADSL lines have limited upstream bandwidth, so it's not a good bet if you're expecting your website to be popular. Alternatively, it might be worth noting that the [google app engine supports CherryPy](http://boodebr.org/main/python/cherrypy-under-google-appserver), so it might just be simpler to use that, and let them worry about the hosting.
https://www.readability.com/ does this kind of stuff in some simpler ways... but all in javascript o_O
So you were just looking for something that is only python, has ssh built in, and can run arbitrary commands? That's fabric. It'll facilitate deployments or admin work, with a lot of overlap between them.
Simple, Clear and *holy fuck* that is clever!
&gt; has ssh built in You should not make up requirements as you go. &gt; That's fabric. It'll facilitate deployments or admin work, with a lot of overlap between them. You kinda missed the templating part of pastescript by a lot. And again, you're making up requirements as you go, I never mentioned deployments.
Not just the list. The entire article is a verbatim copy. Well-spotted.
Related: * http://jtauber.com/blog/2007/02/02/reverse_templates/ * http://www.holovaty.com/writing/templatemaker/
Most WSGI servers are pretty simple :) Thanks for the comment, I'll check gurnicorn out. If you're using bjoern, I made this script to start wsgi servers from the command line, but I'm sure it can be adapted: https://github.com/radiosilence/servers.py/blob/master/launch_with_bjoern.py
that depends on the resources you devote to the vm.......
have a look at http://tunnlr.com/
its all good, you can say it. this was apparently one of those commonly known things that I completely forgot about.
I have the same understanding of where TurboGears is going as you do. I like it on its face, but I'm a little reluctant to go with another new version of TurboGears - every 18 months it seems like there's a new version to upgrade to. Maybe I'm making too big a deal of that fact.
I bet this is somehow related to SABnzbd, which uses a cherrypy server. [to answer your question, I forward mine at home]
Is python virtualenv the same thing?
How do you know that dump or load is releasing the GIL? I would expect that releasing the GIL in the case of a blocking file IO operation is the responsibility of the file object, not the library that is writing to/from the file. 
The precursor of python, [ABC](http://en.wikipedia.org/wiki/ABC_\(programming_language\)) used B-trees for its container implementation.
eh after reading your link, I don't see anything compelling about Werkzeug as a web application developer. nothing jumped out at me like "oooh fuck I need that" 
Most ISPs just say "No servers" so that they a) don't have to support you, and b) have an automatic out against you if you start using a lot of upload bandwidth, which is quite possible with most servers but very unlikely with client-only apps. As long as you don't use much bandwidth, and don't try to complain at them when they change your external IP address without notice, most ISPs don't actually monitor for servers or even care. There are, of course, exceptions.
heh, yeah I read that first bit wrong, dropped the not. Guess I'm such an optimist that I redact negations ad hoc? (Though fabric is more than deployment only)
nope
Not a Python answer exactly, but doesn't the cronjob's stdout get mailed to the user anyway? Then you could just use print.
Yeah, I've tried Pylons and Django. I liked Pylons better. But I get the impression Django is a juggernaut. There are way more Django Hosting platforms (in vain of Heroku.) Its got built in AppEngine support, its got lots of developers using it... Those things are a little intangible when you try a 30-60 minute demo. I don't want to learn four or five frameworks. I want to learn one and really master it.
This is something I raised with my boss but he is under the impression that this soloution would not catch errors in the code, just that the job was run? I'm pretty much learning as I go here so sorry if i'm not making a lot of sense!
Pyramid also runs on appengine, and will run on Python WSGI hosting providers like ep.io, etc. It doesn't have as many users, for sure, however. You could come hang out in irc://freenode.net#pylons and ask some questions in realtime if you want to see how healthy the development community is and how many other folks are using Pylons/Pyramid.
If there are errors in the code, cron will send you the python traceback as the email
So if I ran the script as a cronjob, if anything went wrong I could have the server email me?
I would think building an extension for Python would be a much gentler introduction to using C, rather than looking at the internals of the language (which may be optimized for certain things or written in a way that's not useful for a beginner). It doesn't have to be anything crazy, but I think it would be useful, since you'd get a real sense of how objects in Python are created &amp; destroyed, what pitfalls there are in C, &amp;c. without having to go over your head quite quickly. 
*C*Python. Jython uses native JVM hashtables, and while PyPy uses the same algorithm the source is different.
I appreciate #pylons and have been in there from time to time. Its always been helpful. And, I was able to get one of my Pylons apps to run on AppEngine without too much problem. My main concern was that Django was becoming _the_ framework and it would suffocate the other frameworks. Now I'm a bit less worried about that / got a little perspective.
The output from the cron job will get emailed to the user that is running the job if there is any stdout/stderr. However, that user is often not where the mail should go, right? Most older unix shops have cron wrappers that let you do the right thing like email to a mailing list, etc. That or procmail/maildrop rules that will forward the message. Either way, whether the program errors out, or prints actual errors with your dns, cron will email that. The logging module does let you set up an output path to syslog, but I've got to say that it's a PITA to get all the pieces lined up, but since logging it lets you do trends, etc. on the logfiles it's the right way to go. Also, best practice is to eliminate the mail component. Here's a quick hack you can use to make your boss happy, though: /path/to/script.py | /usr/bin/logger -p daemon.error -t DNSCHECK That'll log any output from script.py to syslog at the daemon.error facility.level and add the string DNSCHECK to each line. You can look for more info on the logging module after you've got this in place if you need more control over it. 
And if you'd like to write a C extension module for Python, there is no better guide than Ned Batchelder's "A Whirlwind Excursion through Python C Extensions". http://nedbatchelder.com/text/whirlext.html
wow, that's a pretty nice supplement. Well, there you go, it's a pretty decent introduction to "real C" without swimming against the current.
Wow thanks for the reply! Looks like this would do what I need :) Also, I have a further question, I'm not that experenced with cron, does it provide a running log, something I can check to make sure it's running as expected? Thank for you help so far!
If anything went wrong the server **would** email you.
&gt; CPython. Jython uses native JVM hashtables, and while PyPy uses the same algorithm the source is different. For a good portion of Python's history CPython *was* "Python", unless you needed a niche Python (like when I needed to use Python with O'Caml for a project &amp; used Vyper). Now it's not so clear, and the nomenclature hasn't caught up with the times. 
Is what you want is something to monitor your code (working process) to ensure that it actually is running when and as expected? This is generally done with a secondary monitor or manager process, which could be written in anything...bash, python, c, etc. As a hack, you can always wrap your script with [try / except / except / ... / finally](http://docs.python.org/tutorial/errors.html#handling-exceptions) statements, and then take an appropriate notify / alert action (e.g. email / page). But usually you have a monitor or manager process which starts your working process, watches for it to complete and then notifies you if it worked or not. Something like [inotify](http://en.wikipedia.org/wiki/Inotify) could allow you to watch for a file update in a directory and then kick off an process based on that event. I've not used it, but there is a [pyinotify package](http://pyinotify.sourceforge.net/). 
For my money, nothing will ever beat the explanation of Python dictionaries at PyCon 2010. Video here: http://blip.tv/file/3332763
&gt;There are way more Django Hosting platforms (in vain of Heroku.) Yes, though we're starting to see more general Python WSGI hosts, such as [DotCloud](http://docs.dotcloud.com/static/components/python/), [Pydra](http://www.pydra.com/), [ep.io](http://www.ep.io/), [Stable.io](http://stable.io/), and [AppHosted](https://apphosted.com/). &gt;Its got built in AppEngine support What's the current state of App Engine support? My understanding is that the Django ORM doesn't work on App Engine, so you have to rely on the django-nonrel fork.
By looking at the implementation of cPickle, and also by running the simple script that I mentioned in my blog post. It is easy to demonstrate that dumps and loads hold the GIL so that nothing else runs, but just by changing those to dump and load will let other threads run.
Jamie Zawinski jwz@netscape.com wrote on Tue, 12 Aug 1997 13:16:22 -0700: &gt; The notion that everything is a stream of bytes is utterly braindead. The notion that regexps are the solution to all problems is equally braindead. &gt; Just like Perl. &gt; Some people, when confronted with a problem, think “I know, I'll use regular expressions.” **Now they have two problems.** 
That's a good idea too. I learn by taking things apart, and some people learn by building upon things. For me, building upon existing things leaves me with more questions. I think this is because the "what this is" part is presented in a way which is intermingled with the "how you use it" part. That's an added layer of complexity to unravel, or it remains a permanent black box where I end up saying "I don't know how this happens, but it happens in this way," and I don't like that. Taking things apart is really second nature to me, but some people do that and go "crap! Now I have all these pieces but I have no idea how they go together, so this tells me nothing." Everyone's different. EDIT: Also, you *wish* python was "optimized for certain things!" ;)
Vixie cron can be configured to log at the start, start+end, or neither of each job. You're better off having your job print out a start time header if you're logging, though. 
Well, I think adding to the *core* of Python could quickly spiral into a yak shaving exercise; if you're not familiar with the way that VM's work, or all the specifics of C, or the way Python glues things together, I think you'll end up spending a large portion of your time catching up on what you need to know before you start actually *doing*. What you say here just leads me to believe that this would be the correct course of action; you will get "instant" feedback, and you can build upon what you've learned quickly. 
After thinking about this a bit more, I think this might be the best solution for me(the hack), I just need to figure out how to instruct the server to record a completed run of the script to a file after it is run, which I guess google can help me with. I will however have a look at the links you have provided at work tomorrow so see if they might be a better solution. Thank you ever so much for your help :) 
I have a server running from my home box using DMZ forwarding at the router to my static IP. I've setup a simple script for generating playlists that work with common Windows and Linux MP3 players and setup a DynDNS hostname. Basically not matter where I am, if I have internet with port 80 open, I can stream any of my music to that machine. It's pretty great.
Could you elaborate? I thought Beautiful Soup was meant to parse (sometimes ill-formed) xml/html, providing a nice interface for navigating the document, etc... not determining what content is useful and what isn't useful in a document.
Sure, you get some result, but you haven't grokked the beast. I can't do things well until I know what they are. I'm convinced that people with top-down and bottom-up learning styles have really different brain patterns, and we each need what we need.
&gt; There are way more Django Hosting platforms (in vain of Heroku.) I'm not sure there are that many yet. Most support WSGI (ep.io for example) so they'll support Django, Pyramid, Flask or any other framework that supports WSGI. &gt; Its got built in AppEngine support It does ? Again Google App Engine will support any WSGI app, and you'll have to use their data store in any case. &gt; I don't want to learn four or five frameworks. I want to learn one and really master it. I've learned quite a few in my career, in several languages, and expect I'll learn some more. Don't restrict yourself to one way of doing things. For example, I'm applying unit testing techniques I've learned while playing with Pyramid in my Django projects. 
Well, I'm not certain; to grok, you need to first now how to lift the cup to your mouth. It's not as if we're talking about someone who *knows* C as an expert and has the ability to choose should I start at the lower levels &amp; work up or at the higher levels &amp; work down, with any meaningful metric. I also don't see how starting with extensions means you can't be a top-down learner, it just means you avoid getting side tracked with bits that aren't useful to the pursuit (which is to learn C coming from a Python background, for the sake of this discussion).
I was implying that starting with extensions is for top-down learners. I'm calling it bottom-up learning when you go "aha! the bytecode evaluator takes a byte in a switch/case loop and compares it to opcodes and does some actions involving reference counts and manipulation of this stack." I guess I also misunderstood the pursuit, but I think you're right. I was thinking about combining new C knowledge with python knowledge.
ISPs commonly block inbound SYN packets on standard servers ports for consumer grade connections. So, tcp/80, among others (usually all privileged ports) will not respond to outside traffic. I pay for a business grade connection, along with static IP, for this reason.
/note: tried to post this as a comment to his/her blog, couldn't because the wordpress is broke at the moment. Really excellent hack! I'd be curious how your false-positive/negative rate looked if you added one more simple criteria to your classifier: whether or not the line contains a common stopword. I would expect any random line of real English text to contain at least one english stopword on average. You could probably use that as a discriminator when your algorithm isn't sure one way or another.
Ah, that makes sense. I was thinking: * top-down: this is the python C API, and this is a Python script that uses it. Make your own. * bottom-up: This is C, this is why X happens to Y, this is how you combine X &amp; Y, this is the Python API that builds off those two, &amp;c. both valid approaches to learning, and both get you the same end result. Wrt this example, in the first approach you're looking at combining things that you find in the docs or in an example, and drill down into the details as needed, whereas the second approach you would focus on C fundamentals &amp; work up to the Python API. that's at least how I was approaching this. 
while repoze is a cool name, it's the project's name. the framework itself is called bfg. [big f***ing gun](http://bfg.repoze.org/). renaming it to pyramid is definitely a big step up. 
There's nothing wrong with it that you don't already know about. Go ahead.
When I do the hack, it ends up looking something like this: #!/usr/bin/env python import ... ... def main (): ... if __name__ == "__main__": import traceback, sys try: main() except: # anErrorLogFileName = "someErrors.log" # fd = open(anErrorLogFileName,'w') # or fd = sys.stderr print(traceback.format_exc(), fd) fd.close() if fd != sys.stderr # and then add the email code here with the file # as the text body (usually preferred) or as an # attachment If you want to make it fancy, then you can use the [logging package](http://docs.python.org/library/logging.html) to generate the file. This is often preferred as it will have the timestamps and you can have a better consistency. 
No it's not, Beautiful Soup doesn't provide that at all. Beautiful Soup is only a parser. It's also super slow. There are actually [multiple](http://www.minvolai.com/blog/decruft-arc90s-readability-in-python/) Python ports of Arc90's readability algorithm, which use a more advanced system of extraction than the one described in the OP. Although none of the ports are very optimized.
It's actually a good idea for a personal sandbox. Use DynDNS and you can even put a proper domain name on it.
See also: [Mongrel2](http://mongrel2.org/home) and [ZeroMQ](http://zeromq.org).
I've never seen this on a fiber-to-the-premises/fiber-to-the-box connection, even for residential use. Yeah, residential use doesn't give you a static IP, but honestly, on fiber connections the odds of you getting knocked are insanely low. That said, I haven't tried it on cable modems or direct service lines. If you live in the exurbs or the boonies, I have no advice.
Good to know, I would have assumed policies for residential fiber were no different -- I only have access to cable/dsl, myself. Blocking ports is standard for cable/dsl providers, at least with the major ISPs in my area it is. YMMV
http://www.meh.ro/wp-content/uploads/2010/11/meh.ro5863.jpg
No, sorry you're correct, as is rcklmbr. It's only roughly related, my comment made it look like it did the same thing.
your timing couldn't be better :D only just today I looked through the readability.js code and saved it to my harddisk for a more thorough analysis later on, planning to do pretty much exactly this. thanks for saving me (part of) the effort :)
+1 for ep.io. It's incredible.
I've noticed that when these Python web framework threads come up, someone posting a comment in favor of web2py frequently gets downvoted into the negatives. Can someone point out the reason for this?
I've been running my own web server for years, usually tied in with a Dynamic DNS service. For a while I used to have a private streaming mp3 server I wrote but got paranoid after some script kiddies zeroed in on the IP address.
an easy to do this is: &lt;cron stuff&gt; python &lt;some script&gt; &gt;&gt; some_log 2&gt;&amp;1 This will log all of the output of the program AND it will redirect stderr to that same file. the &gt;&gt; will make sure the log is appended to. Doing this negates the email cron sends you, though.
Readability is really great but you'll probably need to do the extraction server side. Some of the solutions are: - use a ported version, (Ruby) ruby-readability, (Python) python-readability, hn.py, (PHP) php-readability, and also check http://blog.arc90.com/2009/06/20/readability-now-available-in-three-delicious-flavors/ - use readability.js with node.js, details at http://arrix.blogspot.com/2010/11/server-side-readability-with-nodejs.html - execute readability.js in a layout engine like webkit with python-qt4 or python-gtk2, please see the source code and examples at http://www.betterprogramming.com/niftyarticles-extract-articles-from-any-webpage-with-python-webkit-and-readability.html
Instead of porting readability.js you may try running it server side in Webkit, with python-qt4 or python-gtk2, please find the source code for each library at http://www.betterprogramming.com/niftyarticles-extract-articles-from-any-webpage-with-python-webkit-and-readability.html
There is a logging module. It can email too. I use it extensively. 
"SyntaxWarning: import * only allowed at module level"
go on...
well. http://blog.sadphaeton.com/2009/01/20/python-development-windows-part-1installing-python.html http://blog.sadphaeton.com/2009/01/20/python-development-windows-part-2-installing-easyinstallcould-be-easier.html or you can visit this persons plagiarized but updated for windows 7 version. 
this looks pretty slick. I'll check this out when I need to write a cmd line util next.
Zen by example, love it. I think my coworkers at work need to see this.
what does "2&gt;&amp;1" mean ?
I don't think all of those examples are in the right order.
This is nice. I haven't read all of it yet, but it will definitely be read.
crontab it: script.py &gt;&gt; log.txt 2&gt;&amp;1
 ziprange = func.substr(Address.zip, 0, 1).label('ziprange') subq = s.query(Address.user_id, ziprange).group_by(ziprange).subquery() q = s.query(User, subq.c.ziprange).join(subq, User.addresses) q = q.options(subqueryload(User.addresses)) q.all() SELECT user.id AS user_id, user.name AS user_name, anon_1.ziprange AS anon_1_ziprange FROM user JOIN ( SELECT address.user_id AS user_id, substr(address.zip, ?, ?) AS ziprange FROM address GROUP BY substr(address.zip, ?, ?) ) AS anon_1 ON user.id = anon_1.user_id SELECT address.id AS address_id, address.street AS address_street, address.zip AS address_zip, address.user_id AS address_user_id, anon_1.user_id AS anon_1_user_id FROM ( SELECT user.id AS user_id FROM user JOIN (SELECT address.user_id AS user_id, substr(address.zip, ?, ?) AS ziprange FROM address GROUP BY substr(address.zip, ?, ?)) AS anon_2 ON user.id = anon_2.user_id) AS anon_1 JOIN address ON anon_1.user_id = address.user_id ORDER BY anon_1.user_id hence alchemy
Thanks for the link, I was at PyCon2010, but missed this talk.
A lot of good ones, but I don't agree with the "Readability counts" one. As the bad example it uses doc-strings for unit tests: &gt;&gt;&gt; factorial(30) 265252859812191058636308480000000L And in the good example, they replace it with a test-class with test functions. I find both the readability (I'm sure we all use the python REPL) and usefulness (it doubles as documentation) of the "bad" example to be the better one.
I guess it compiles, but it's not inspiring Python. For example, his load() function doesn't change any module state; it's assigning to some local variables, then returns nothing. Its only side-effect is to possibly cache some modules in sys.modules. 
I think both examples have the issue of separating the input and the output of the function under test too far. The doctest has a smaller separation, because its only "factorial()" and a linebreak in between them, however, the unittest has a boatload of complicated stuff in there which masquerades the mapping from inputs to outputs. I would write a test such as: def test_factorial(self): factorialValues = { 0 : 1, 1 : 1, 2 : 2, 3 : 6, 30 : 265252859812191058636308480000000L } for input, value in factorialValues.iteritems(): assert factorial(input) == output In my opinion, this is more readable than either of the two, because for one, the loop is simple and easy to understand (and thus, it can be ignored once it is clear how the mapping works), and once it is clear how the mapping works, it is easy to understand the test cases checked here, because there is the clue 'factorial' and a number of known values right next to each other.
This is certainly better than the second version in the original document. Perhaps the ideal test is your version, the assert test, plus one test in the docstring, like `factorial(3) == 6` (simple enough to do in your head, and immediately shows you how the function works).
I don't often use N++ for coding, but tend to turn to it (or python) for text file manipulations. The combination of them both together is insanely powerful.
~########################################### Too many hr elements for my taste. Can barely read the thing. ~###########################################
Oh wow... really? I've got to go try it!
Very, very nice, thanks! Beets already saved me a lot of time sorting incoming music. One question resp. request though, which I couldn't answer from reading the wiki: Is it possible to have beets log for which albums / files it could not find suitable tags and (also) those for which the user chose "use as is"? (Or rather, all those which were not processed "normally"?) That would make it considerably easier to manually sort these files afterwards.
web2py [response](http://www.reddit.com/r/programming/comments/fd9uu/be_careful_with_exec_and_eval_in_python/c1flozv)
This ANSI plugin is not compatible with your Unicode Notepad++. This plugin is not compatible with your current version of Notepad++. Do you want to remove this plugin from plugins directory to prevent this message the next launch time?
You can setup a custom app using their panel. They assign you a reserved port. Run your Tornado server on that port and away you go.
You can setup a custom app using their panel. They assign you a reserved port. Run your Tornado server on that port and away you go. They run nginx as the proxy for custom apps.
Thanks - this will be very useful in flat file manipulation. 
He may not have mentioned needing a database, but it is rare a website doesn't need storage for something and the default is a database. The main objective of the website might not need it, but something might. What about user accounts?
This blog series along with the book is pure awesomeness for someone starting out with language design. Keep up the good work.
I'm using the 0.7 version of the plugin fine with N++ 5.8.6 (Unicode). (Not because it didn't work - because the plugin manager has that version and I'm lazy)
redirect stderr (2) to whatever stdin (1) is. In my example: redirect stdin to append to some_log and then point stderr to whatever stdin is... in this case, some_log.
Hmm. If I call a function a module that calls "import" will I be able to see it? EDIT: Figured it out. modules are scoped just like variables. importing modules within a function are only visible within that function, however if you specify those modules as global then the rest of that file will see that module.
The reddiquette guidelines state: &gt;**Please don't: Downvote opinions just because you disagree with them.** *The down arrow is for comments that add nothing to the discussion.* Rather than simply downvoting comments, it would be much more helpful if people who disagree would reply to the comments and either point out errors or explain why they disagree. This provides much more useful feedback both to the original poster of the comment and to the readers of the thread. In the end, everyone will have a better understanding of the various frameworks and therefore be in a better position to assess which option might best meet their needs and preferences.
Thanks, I got that version to work.
I like the repoze name as well...oh well. I come to the Python game to late. Just starting to learn it. They probably wanted to get away from both names. shout out: **REPOZE.NG** is a better name!!!!
With 0.7, if you get the "This ANSI plugin is not compatible... " message, you need the VS2008 MSVC runtime (the link is shown in the description of the plugin in Plugin Manager). Alternatively, download 0.8 which doesn't need it. [Author] (glad you like it!)
http://flask.pocoo.org/docs/foreword/#what-does-micro-mean
It's a shame that the Python "lambda", "map", and "filter" syntax is so...crufty. In Haskell, function composition is much easier on the eyes. #Python halve_evens_only = lambda nums: map(lambda i: i/2, filter(lambda i: not i%2, nums)) --Haskell halve_evens_only = map (`div` 2) . filter even In Haskell I'd generally recommend explicitly using map and filter rather than a list comprehension, but in Python it's just way too ugly that way. sigh.
This is sweet! Thanks!!! In a related note: 99% of the envy I have for emacs' programmability just evaporated. 
Note: The article refers to finding "duplicate records" in the sense that they are *nearly*, but not necessarily *exactly* the same data, despite representing the same entity.
I started using Turbogears in 2007 on a couple of projects and looking back, I wish I adopted Django in the first place. I get the strong sense, at least from the Turbogears community, that the project leaders are more interested in toying with framework components rather than building a solid foundation for mission critical systems. Unfortunately, I have systems that are still based on TG 1 and the upgrade path is such that it would require less effort to simply port to Django. With this latest announcement to merge with Pyramid, I don't trust that Turbogears(or Pylons for that matter) can be trusted for long term sustainability. Initially, I rejected Django for the usual arguments - It is monolithic,ORM is not flexible enough, only suited to CMS type projects, etc I have been using Django since 2008 and in practice, I have found the usual arguments to be FUD. The documentation is fantastic and the framework has been a real pleasure to work with. In fact, I have found it to be flexible enough for use in the construction of systems with complex information models(rather than the bog standard CMS/website). There is also a sense of comfort knowing that the Django community is vibrant and growing and this is an important factor when pitching projects to potential customers.
I agree. But that is the very definition of scope creep to me. In personal projects I do my best to execute the simple form of something. I take those learnings to design something thorough. ...if I jumped into the what-ifs, I would never get anything done. On a sidenote: If I was rolling my own system I would use MongoDB and ignore the need for ORMs all together. It is the same as saving to a persistent python dictionary structure.
This is cool. I tried making a bot to play Z-Types for me. Since I didn't really know what I was doing, I just repeatedly sent every letter of the alphabet to the game. It worked till about level 33.. then it would crash firefox. Cool story. 
I'm really happy to get some feedback from someone who has done real development (and not just Hello Worlds) in both TG and Django. It wasn't exactly what I wanted to hear, but that is fine. Thanks
I suspect it's mostly because, no matter how tangential web2py is to the subject, there's a "50 cent army" of Web2Py folks who chime in on every reddit thread that has a topic approximating web frameworks. This one is a good example. It's pointless to start a discussion about it, as that discussion always ends with "well, I thought he should know", which is of course the perogative of every marketer. So you get people downvoting as a way to signal disapproval of the marketing method rather than starting a discussion about it.
&gt;there's a "50 cent army" But there's just as much if not more promotion of Flask, Django, and Pyramid on reddit. I don't see why you would level this accusation against web2py but not those other frameworks (including your own). &gt;chime in on every reddit thread that has a topic approximating web frameworks. This one is a good example. How so? This topic is quite explicitly about web frameworks, and the OP expressed concern about long-term viability and the future of "Python web frameworks". &gt;So you get people downvoting as a way to signal disapproval of the marketing method rather than starting a discussion about it. Yes, agreed, it's fine to downvote if you really think the comment is irrelevant and doesn't contribute to the conversation. But that doesn't fully explain all the downvotes web2py gets. For example, [this comment](http://www.reddit.com/r/Python/comments/fhj5c/middleweight_web_frameworks/c1fzgkt) has been downvoted to -2 (at the moment), even though (mostly less informative) comments promoting Flask, CherryPy, web.py, Bottle, Tornado, and Django in that thread are all comfortably positive. Keep in mind, this sub-thread started because of @qubitsu's puzzlement at the treatment of web2py on reddit. Others have made [similar observations](http://www.reddit.com/r/Python/comments/ffw5q/choosing_the_right_framework_for_a_new_web_project/c1fnm8m). Indeed, I felt the same way when I was first researching web frameworks. So, it appears that at least some disinterested parties who are not already commited to a particular framework find the treatment of web2py to be inappropriate.
The OP asked for help deciding between Django and Pyramid, AFAICT. You chose to take the widest interpretation of his last sentence and decided he really absolutely must know about web2py too. And maybe he should. Then again, maybe you could restrain yourself once and not mention it. It would be a welcome change, because he probably already does, you've mentioned it on every reddit thread you've been part of for months and months.
[This link was posted on the reddits](http://www.ibm.com/developerworks/web/library/wa-aj-pyjamas/) at one stage, looks interesting.
well just take a look at the conversation that started because of your question. Is it on topic for this? That's probably a good reason as to why web2py gets downvoted IMO
That seems tautological. Conversations about why web2py gets downvoted can't be the reason web2py gets downvoted -- the cause presupposes the effect.
i think the database ones are wrong: * 3: json or sqlite? it's apples &amp; oranges - do you want to dump objects you can reexamine individually later or do you want other processes to be able to analyze data? * 4: sqlalchemy vs explicit sql: single query? go with the fewer dependencies. Complex vs complicated - too subtle a difference anyway especially when mapping to explicit vs implicit differences between native sql vs orm.
I wouldn't have used map/filter for that; I would have done [i // 2 for i in nums if not i % 2] I think that the list comprehension is more clear, plus it's trivial to make it lazy by turning it into a generator expression by swapping out the brackets for parents.
it's in a thread that was originally a question titled "Pyramid and Django", I suspect some would consider this entire conversation in this location to be off topic. Do you not agree?
fwiw, I downvote flask, but I'm an asshole. :)
&gt;You chose to take the widest interpretation of his last sentence... Sorry, I guess I don't see how interpreting the phrase "Python web frameworks" as potentially including all Python web frameworks is a particularly "wide" interpretation. However, if I misunderstood the scope of the OP's interest, I apologize. Note, though, that I also made a point about the future of TG, Pylons, and Pyramid, and pointed out some WSGI hosting options that would work with Pyramid, so hopefully I contributed something of relevance. :) &gt;maybe you could restrain yourself once and not mention it...you've mentioned it on every reddit thread you've been part of for months and months. I have to say, this is a puzzling complaint given that you exhibit the exact same pattern. Over the past few months, almost every single one of *your* comments has been related to *Pyramid*. In fact, you've spent a lot of time defending Pyramid and clearing up misconceptions about it, so we have something in common. Why the double standard? To be honest, I'm starting to think you may have me confused with someone else. If you look at my comment history, you will clearly see that all of my comments about web2py are (a) in threads specifically about web2py, (b) in response to other comments about web2py, or (c) in threads asking general questions about web frameworks (and in every one of those threads, there are comments promoting other frameworks as well -- typically Flask, Django, and Pyramid). Surely it's OK to mention web2py in contexts where it's already being discussed or where others are promoting Flask, Django, and Pyramid, no? That's no different from you and your Pyramid peers. Please, take a moment to review my comment history, and if you find any that don't fit that pattern, please point them out to me. Thank you.
Sure. In any case, I wasn't arguing that this conversation is necessarily on topic, just that it being off topic doesn't explain why web2py gets downvoted. In other words, the poor treatment of web2py has to precede the conversations about the poor treatment of web2py, so there must be some prior cause of the poor treatment to begin with. But right, this conversation probably isn't helping. :)
In Python, certainly. That is what I was lamenting: that Python's higher-order functions are ugly to use. List comprehensions are quite nice, but Haskell-like function composition has the greatest potential for clear code, imho. I just wish Python would draw a little more from Haskell, but given Guido's attitude, that seems unlikely.
Nobody asked about Web2Py here. You brought up the topic, as you do in every thread where imagination permits the topic to be vaguely permissive to do so. If you found me chiming in unsolicited about Pyramid in a post that has Web2Py or Flask or Django as its clear topic, you'd be right about the double standard. But you never will. 
|In any case, I wasn't arguing that this conversation is necessarily on topic, just that it being off topic doesn't explain why web2py gets downvoted. /splodey
I tried it, and I definitely enjoyed not having to write Javascript (or much HTML, even). I think at times I was coding four times faster, but sometimes I'd get blocked by one confusing bug or another for a very long time. The downsides, from my first impression, were: * app startup in Chrome seems way too slow * some valid Python isn't handled/translated properly * code that imports pyjamas can't be tested without a browser I also started butting heads against its UI framework, which I found confusing and unpythonic, but nothing says I have to use that part of it. I'm sure most of my complaints are fixable or can just be tolerated, so I think I'll stick with it for this project. 
&gt;You brought up the topic, as you do in every thread where imagination permits the topic to be vaguely permissive to do so. Again, I really think you have me confused with someone else. I have several pages of comments, so if what you say is true, it should be easy for you to pick out at least a handful of examples where it was only "vaguely permissive" to mention web2py. &gt;If you found me chiming in unsolicited about Pyramid in a post that has Web2Py or Flask or Django as its clear topic, you'd be right about the double standard. But you never will. Sorry, perhaps there was a misunderstanding. Your specific complaint was, "you've mentioned it on every reddit thread you've been part of for months and months." I then pointed out that you show the exact same pattern, commenting almost exclusively on Pyramid for the past few months. I guess your real concern, though, is with unsolicited comments about one framework in posts that are exclusively about another framework. In that case, you'll be happy to know that I have never made such a comment. So, hopefully we can move on in peace. Thank you.
K, forget it. You win. Spam away. I'll downvote away. We'll call it detente. 
That doesn't sound like I win, or like anyone wins. I have now kindly asked you twice to actually take a look at my comment history and please point out examples of my alleged rampant commenting about web2py in inappropriate contexts, but you have not done so. Yet rather than simply admitting you were mistaken, for some reason you have chosen to persist with this specious claim. As the lead developer of Pyramid, I understand that you have a personal, professional, and financial interest in the success of Pyramid and related projects. And I wish you all success. But you should be aware that your position naturally makes it difficult for you to assess web2py in a disinterested fashion, despite your best efforts. Maybe just give that some thought. Thank you.
[Fred, Sheila and Jim](http://www.catb.org/jargon/html/F/fred.html)? Somebody here has a fond history with the BBC Micro.
I absolutely agree about the django part.
I only recently started to use omnicomp. So far I haven't run into problems.
I had similar issues with TG1. Its original premise was good - "best of breed" - but the best of breed then was pretty awful (SQLObject, Kid). The Django team back then made the right decision to do it all in-house. The earlier versions of Django weren't so good however and I think this is where they got the "Django is only good for websites" meme. For example, form validation used manipulators, a badly designed API that thankfully got replaced by newforms (now just forms); the models used quite a bit of web2py-style import magic and so on. Building anything that wasn't just mostly static pages using the admin for content was painful. Django since then has come on leaps and bounds and it isn't really the same framework it was back in 2005-2007. Memes however take a long time to eradicate (Java is slow etc). I never bothered with TG2 and frankly, I thought the idea was a mistake. As I see it there's room for two kinds of frameworks - the full stack, "rails" type framework where you get most traction by following conventions and the minimal DIY framework where you do things on your own or hand-pick your own components (a subset of this would be the microframework, like Flask or Sinatra, which provide a much smaller footprint but let you get going more quickly). In Python, Django admirably provides for the first case and Pyramid (or Flask) the second. TG2 tried to rival Django, but I think many people using Pylons had their own ideas of what components they needed anyway so didn't use it. That, and the fact that it had a monstrous number of constantly-breaking dependencies and piss-poor documentation.
Thanks - it seems like the way to go for a newcomer. 
Heh, that would be me. It's how I got into programming ...
Well, yes. But it's important to make the distinction.
Me too.
http://www.stackless.com/ its python optimized for multithreading put ultra simply
Yes it is important, but many people aren't making the distinction, which was my point ("the nomenclature hasn't caught up"). I wonder if this is because the other projects aren't "advertised" as much, or if people aren't paying attention, or if they simple don't consider alternative Python systems to by *Python*, but rather something else. It'd be interesting to "poll" the community.
Really liking PyCharm. I also really like that they are responsive to questions, feature requests and bugs.
I think this might be his best option as then he can format his sql to have each modifier on a separate line 
soap isn't pythonic you can't fix retarded
Just wanted to promote porting to python 3. I hope this isn't overly douchey.
I wouldn't say so. Always nice to have some sort of tracker. In any case (and I wish I could find citations for this), I think back in 2008 GvR was envisioning 2012-2013 as being the point where the tide started moving to 3.x, but not necessarily being complete til 2015 even. So while (according to that timeline + your tracker) things are probably moving along just fine, there's nothing wrong with something advertising the major libraries which *have* added support, just to encourage the rest of them, and give all us application developers a sense of where the rest of the world is :)
Some of these are a tad dumb (no offense, I realize it's probably autogenerated), for example: multiprocessing.
None taken. It is generated from pypi. All that needs to be done is to label it correctly by whoever maintains multiprocessing.
It does feel a little douchey for the projects that are charging forward (e.g. Django), but that might just be me. On the other hand, I know of at least one software project on the board that needs some significant support to move forward. It looks like the lead maintainer is basically looking for a reason to switch over e.g. a company with a Python 3 code base.
Why is the transition to Python 3 so hard?
Well the issue is that library isn't Py3K compatible, however multiprocessing is now part of the stdlib, same with simplejson.
This is a good question I would like to see answered. 
I took a beginning programmers class last semester, we learned python3, and I was sad to hear most of the cool libraries are nowhere near ready for python3 :( 
I see. Hmmm, do you have any idea how I can address this? Not that the chart is terribly bad, we're just going to have to wait for python 3 packages to be more popular than abandoned packages (including those that were abandoned because they have a py3k equivalent).
What was the point of stealing the design? I noticed you even admit it in the footer, but why do it at all? Cool idea otherwise.
Here's one I made a while back. http://www.danomagnum.com/wiki/Python3dCubeWorld
Because when you look at any function that handles strings you cannot tell if it is supposed to handle bytes, unicode or both. You cannot tell what needs to be changed if anything unless you understand how the code is used. You do not know what it breaks until you run it. And even if you run it you may not get any runtime error, just wrong results that may be hard to detect. The conversion is semi-automatic only for programs that do not handle strings. For programs that do handle strings you need to understand what the code does in order to port it to 3.x.
Because I wanted something pretty and I don't have the talent nor the time to make another design. I assumed it's ok because it is a pro-bono, open source, nice guy's website. If Paul Irish or Divya Manian prefer I don't use it then I won't. Though it will be painful to look at.
would be more positive to call it the wall of fame for those who ported...
I guess that it also takes a lot of time to rewrite C modules.
And some of the others just have different names for their py3k packages, for example unittest2py3k and xlrd3. It's irresponsible to post a list of "shame" without verifying whether they deserve shame and this page is giving people the impression there are a lot less libraries available than there really are.
Did you just copy-paste his design without his authorization? If you're so sure that he's a “nice guy“, why not spend thirty seconds to ask him and be on the safe side of things?
you might want to rank by cumulative downloads or over a span of time across all versions of a package if you're looking for a popularity rating.
http://paulirish.com/ &gt; Paul Irish doesn't care about attribution, bro. — It's all yours under a Creative Commons 0 license I'll still contact him just to make sure.
Because for those of us on the ground, in industry, there's no compelling reason *to* move to Python3. 
You're right, might have been less scandalous though...
For pure python packages and projects, even ones with large code bases, it is not that hard, just time consuming (and with time being precious, a lot of devs feel they would rather add new features and fix bugs, than port to py3k until there is a bigger demand for it). For packages that contain C extensions and have dependencies on C libraries, it is a whole other ball game. Take a look at http://docs.python.org/release/3.0.1/howto/cporting.html#cporting-howto for a start. On the whole, I think the overall progress of porting is going really well, and on track. With some distros not even having py3k in their repos and shared hosting guys still very happy with python 2.x, the major demand for py3k is a way off still, but as more packages port across, so demand will increase, so more will port, etc 
We're sorting it out. Thx everyone. :)
Bookmarked, thanks! (I noticed some "oddities", but it's this site idea that I really appreciate)
Django 1.2.5 is now provided with App Engine via the use_library() declaration as of SDK 1.4.2, [released just a few days ago](http://googleappengine.blogspot.com/2011/02/app-engine-142-sdk-api-updates-and.html), so I'd say they're fairly committed to supporting Django.
Most of them aren't that far away, it's just that the demand isn't there. Porting most libraries is as simple as a few hours of work.
"Wall of Shame" is not a good name for such a tracker though.
What you learned still applies to the 2.x series. There are guides that are helpful too. One suggestion is to find something that isn't P3 and offer to help make it so.
What paul said. Thanks for bringing this up! :)
Having gone through it, it really isn't that hard. However, if there's no demand, most people don't see a reason to spend a few hours on the initial porting, then any maintenance depending on how they go about the port. If you want to do it right, you'll need very solid tests and it would make sense to use continuous integration or at least run `tox` pretty often. You probably aren't going to get away with porting in one quick swoop. If you only have to support recent 2.x versions, say 2.6+, having a single codebase of both 2.x and 3.x functionality is easy. It's also easiest to maintain moving forward. If you're only dealing with a few thousand lines, it might take a few hours to a day. If you have to support a wider range of versions, the port isn't really that much harder, it's just going to be more involved. You'll end up making use of `sys.version_info`checks a lot more than you normally would. I ported around 20K combined of pure Python and a C extension in like a day and a half.
Not really. Probably the biggest difference in C modules is the way the module is actually constructed. Sure, there are Unicode differences, but if you don't deal with much of that, you'll only have a few `#ifdef` blocks around module definitions and the signature of the function that creates your module, and a few other easy to figure out places.
The intent is nice, the naming is terrible and does come across as douchey. "Python 3 Ready" or "Hall of Fame" would be much better. I think steering people towards p3-ready packages is a better idea than trying to "shame" those which are not p3-compatible.
Unfortunately, there won't be a bigger demand for it unless more packages are ported to it. It's a classic chicken and egg problem. The only Linux distribution I'm aware of that has made Python3 the default is Arch Linux, which isn't exactly hugely popular. If Ubuntu made the move, I'm sure things would start happening faster.
In the case of simplejson, it's still evolving independently and a number of improvements to the standalone package have not (as far as I know) made it into the stdlib. In dec', cherrypy rolled a change to use simplejson over Python's json if it's available.
It's not hard per se, but it's long (as expected by just about everybody). There are a number of trivial differences between Python 2 and 3 (module renames and `print` becoming a function) and other more fundamental issues in fixing past issues of Python (strings for instance, Python 2 has "bytestrings" and unicode strings, Python 3 has bytes and strings, all strings are unicode, and bytes have shed a number of strings-related methods: you can't really use them as strings anymore). If packages were extremely careful about their string management before they can switch easily, but packages manipulating lots of strings and playing fast and loose with them tend to break.
Yes, sorry if I wasn't clear. I wasn't referring to App Engine support for Django, but rather Django support for App Engine -- specifically, whether the Django ORM works with the App Engine BigTable data store.
You could just hardcode in skipping some of them. There is a finite list of packages that were rolled into stdlib
Definitely. Also, the explicit SQL code is *wrong*. There's no quoting or escaping in it.
Just skimming through this, I see several cases where the "correct" example is not just wrong, but obviously, *horribly* wrong. As in, it doesn't do what it's supposed to, and would fail with an error message if it were actually run. And, in some cases, that error message would just be an obvious, superficial failure masking the lasting, subtle failure underneath... like the unquoted SQL inserts hiding the lack of escaping leading to SQL injection holes. This is a complete FAIL at making a case for the Zen of Python; it seems almost like something written to **poke fun** at it instead, implying that Pythonistas care more about style than substance. ಠ_ಠ Cannot downvote enough.
Is incrementing python versions really that important? I never liked putting parenthesizes around my prints. 
Aaaaand this is why "Dive into Python 3" isn't selling worth a damn.
Nice list, but I think some are not update with the version numbers like Django, it at 1.2.5 not 1.2.4.
It isn't. Where I work, we have a substantial mixed Python and C++ application. It's relatively complex with a Python interpreter embedded into a C++ application and a bunch of Python modules implemented in both Python and C++, with boost.python. Our code is also very string/bytes heavy - which is one of the biggest differences between Python 2 and Python 3. Once the two major third-party dependencies we had (numpy and boost.python) became available for Python 3 porting our own substantial code base took one developer about a week, with no surprises. The secret is to have good unit test coverage.
In our case, with Python scripting as a soon-to-be-released feature of our product we didn't want to lock third-parties (customers!) into a dead-end technology (Python 2). We started developing on Python 2 but our first public release will be Python 3. I only mention this as a counter example to your assertion that there is no compelling reason to move from Python 2 to Python 3. It's not difficult either so long at any package dependencies you have have been ported.
Agreed. Our mixed C++ and Python codebase is much cleaner thanks to the clear distinction between bytes and strings. The porting from Python 2 to Python 3 has definitely improved our code.
My packages feature prominently in that list and I'm not offended. Nor realistically am I any more motivated than before ;)
Motivation for maintaining two parallel codebases is a big one. Technically pip has been ported (as a GSoC project), but we asked for feedback from people and got *zero* response. And making a port isn't terribly hard, but then you have to maintain it, two slightly and subtly different codebases -- one that people use (Python 2) and one that likely hardly anyone cares about (Python 3).
Uh, actually, that multiprocessing package is the backport for old versions of Python 2.x. It's shipped in the stdlib since 2.6
Yes, this naturally puts packages that haven't been updated much near the top, which are also of course the packages which don't support Python 3.
Yeah, I remember having friends in the US/Canada who's ISPs blocking incoming traffic on certain standard ports (http/s, pop3, imap and the like), I have never seen this done in the various european countries I've been in though....
And where is PIL ? Last time I checked it still hasn't supported python 3...
Yes, the funny thing is that if you use Cython, it generates code that can be compiled into Python C modules that work 2.4 - 3.1 (or not 2.4, I don't know the exact release but quite a big range). Edit: Yeah, I meant 3.1. Thanks for pointing that out, bryancole and Xiol and sorry for being so dumb.
IIRC, xlrd3 is dead.
It's no longer being developed, but it's there that you can install and use.
Well, it's okay, but I see Django listed four times. Why not list just the latest version of a project instead of every version that doesn't support Python 3? Obviously, if the current version doesn't support Python 3, older versions will not.
The Arch Linux move was *very* stupid. All it did was break things and scare people away from using Arch. It was apparently done without communicating with most of the Python dev community. For a while there, mentioning Arch's /usr/bin/python move on Freenode's #python was a kickable offense.
Douchey? A little. Effective? Also a little. This is probably a more effective approach: http://railsplugins.org/
it is douchey to call it a wall of shame. Instead of being a douche, how about porting some code if you're that concerned about it? 
It still would be much better if Python 3 support was rolled into the main project with 2to3 being used as conversion. That way any future modifications would include Python 3 support. XLSX support might be added, so that would be helpful. That said, if xlrd3 works...
Indeed. As a very noobish Python user, I wasn't too keen on the move either. That said, installing the python2 package and symlinking /usr/bin/python was all that was needed.
But what would would we gain? (Keep in mind I'm saying this in the context of things like exports and reporting, not shipping software to customers).
Actually, yes! Try the Usage page: http://code.google.com/p/beets/wiki/Usage In summary, you can say: beet import -l logfile.txt mymp3s And that will log every time you "skip" or "as-is" an album.
ಠ_ಠ
Because there are significant change in the language which will break a lot of code. Sometimes, silently. Oh, and there are no obvious tangible benefits to undertake this migration.. (python3 might be cleaner, but that's not tangible enough)..
| You motherfuckers giving out the free software, you better step up your game or you will be publicly shamed. | --signed ungrateful users
I just updated the code so the title magically changes to "Python 3 Wall of Superpowers" once it pushes past 50%.
Google App Engine and its SDK aren't listed?
Static typing doesn't sound so bad anymore? :)
Mentioning Web2py in this thread seems entirely reasonable. The OP didn't seem married to Django or Pyramid and even requested experiences with Python frameworks. Although I do acknowledge that the Web2py community gets a little overzealous here sometimes.
Yeah it is douchey. It is a wall of "shame" so you are shaming projects into porting. Some people don't see a good reason to port. It would be good if you at least present some reasons as to what exactly the benefits of porting to Python 3.x are. As a company we would gain _nothing_ by porting our software to Python 3.x now, but we would risk destabilizing the source and introducing hidden bugs. 
Dang, I read over that sentence. Thanks again! I think it's important enough to warrant its own subitem in that list, though.
Working with the bytecode seems more like middle-out learning. It's only one of several techniques to implement Python, and it doesn't show how the actual machine bits are changed, which I would expect from a bottom-up approach. The bytecode evaluator is, after all, running the Python _Virtual_ Machine.
because 16^2 = 256 and 2^16 = 65536
Yep, it's douchey all right. By trying to 'shame' people, you're acting as though they have some unfulfilled obligation. They don't. That isn't how free software works.
Truth that! Sometimes i'm dumb :(
I'm willing to do that, do you happen to recall any other modules other than multiprocessing?
Eh I don't know much about Python but even I could tell by clicking on multiprocessing that it was a backport.
And more specifically, the \*\* operator is right-associative, so 2\*\*2\*\*2 is the same as 2\*\*(2\*\*2).
[The power operator](http://docs.python.org/reference/expressions.html#the-power-operator) are evaluated from right to left
ubuntu would have to port all their code first which has dependencies which haven't been ported yet. :)
Thanks for your efforts. I really dig this.
Well, there's a [python-wrapper](http://jwilk.net/software/python-aalib) for [aalib](http://en.wikipedia.org/wiki/AAlib), or perhaps the [wrapper](http://caca.zoy.org/browser/libcaca/trunk/python/caca/display.py?rev=4398) for [libcaca](http://caca.zoy.org/wiki/libcaca).
A week full-time? That's a lot for an open source package especially when the ROI just isn't there. My simpler package took maybe 2-3 full days to port. However, maintaining 2 different code bases continues to be a pain and we stopped updating the python3 version months ago. Honestly, I've had almost no clients ask for python3 support, so why bother?
multiprocessing, simplejson, argparse, uuid
google found this pretty easily: [wcurses](http://code.google.com/p/wcurses/) it's just the basics, but I also remember this one from a while back: [WConio](http://newcenturycomputers.net/projects/wconio.html)
A logarithm is the inverse function of the exponential y = base1 ** x =&gt; x = logb(y, base1) where logb(y, b) is a base b logarithm If instead you're looking for y = base2 ** x =&gt; x = logb(y, base2) but only have a base1 log function, then you need to write base2 in terms of base1 base2 = base1 ** logb(base2, base1) thus y = base2 ** x = (base1 ** logb(base2, base1)) ** x = base1 ** (logb(base2, base1) * x) then logb(y, base1) = logb(base1 ** (logb(base2, base1) * x), base1) logb(y, base1) = logb(base2, base1) * x x = logb(y, base1) / logb(base2, base1)
http://stackoverflow.com/
Tried it, documentation sucks ass, moved on.
Ah, this one is easy, tear it all down and start over, because if you have duplication: YOU ARE DOING IT WRONG!
I guess I presuppose a working knowledge of CPUs at the gate level, or at least an understanding of assembly.
I used the Win32 API for a simple C++ console game a long time ago. The API is accessible via ctypes. Here's an example that changes text color attributes: http://www.burgaud.com/bring-colors-to-the-windows-console-with-python If it has to be Curses, it seems you're only option is wcurses as cymrow suggested. However, on first glance it doesn't look complete, which might be great if you're familiar with C++ and looking to get involved with a library. Otherwise, if you're looking to steer clear of C++ and ctypes, then WConio looks to be your best bet.
It works correctly in Windows, so I'd report it as a bug in the OS X build. The latest stable release is version 1.01, from 2011-01-10.
This will remain as is till the community overcomes its use (or it is ok to use) python 2 for now but in future you can use python 3 message. Guess what -- future will never come. One needs to go cold turkey some time for this. Also the backporting of python3k features to python2, though really good, is not helping either -- guess that is the main reason why many codebases don't feel the need to migrate and break their product, since all 3k features are becoming available in 2.
It did not break things when people followed the transition procedure (and it was quite simple) and all the in-repo python dependencies were rebuilt. Yes, I agree that abruptness surprised many people even inside Arch community. But the blame rests on them since it was lying in testing for months and no one cared to comment on it. OTOH, it has/had its share of benefits. Now most the packages which are py3k compatible are in Arch repo as py3k ones rather than python2 ones, also this is helping the intra-community python development to use py3k directly. A transition from python2 to py3k will of course be rough but waiting otherwise will be like Debian which I think may transition to py3k in 10 years or more.
I think you mean 2.4 -&gt; 3.1
In your case, I suspect, nothing; so fair enough. Your original response to KishCom is a non sequitur though: Lack of compelling reasons to move has nothing to do with how technically difficult it is to transition an existing code base. I'm concerned that all of the negativity around Python 3 end up in a Perl 6 scenario where lack of credibility of the new version becomes very bad for the language as a whole. 
I didn't mean break as in broken packages. It's not too difficult to patch a bunch of shebangs (replace /usr/bin/python with /usr/bin/python2). It takes work (thanks volunteers!), but is *relatively* simple. I mean more breaking any scripts that Arch maintainers don't have control over. Something like downloaded source code. I much prefer Ubuntu's/Debian's solution of adding Python 3 ports under the python3- prefix. I count 11 projects so far. Ironically, Arch doesn't (yet) have Python 3 packages for some of those projects. Time for me to request them? Edit: I just check the AUR. There are packages for all of those Python 3 projects, but they haven't made it into the repositories. Side note: The AUR is one of Arch's greatest strengths.
Not quite. The customer is doing it wrong.
http://pypi.python.org/pypi/PIL/ They don't host their package on PyPI so I can't rank them.
No, it can compile Cython code to C code that works in both the 2.x releases and 3.x releases at the same time.
simplejson seems redundant since json is built in and just about everyone falls back to it. Also setuptools?? Welcome to Distribute! http://python-distribute.org/pip_distribute.png 
But haven't you now locked your 3rd-parties into spending more time and money on re-writing or porting libraries they might have been able to use if you had gone with py2?
simplejson seems redundant since json is built in and just about everyone falls back to it. Also setuptools?? Welcome to Distribute! http://python-distribute.org/pip_distribute.png
He may have, but this needs to happen anyway. Making people realise it's time to be done is a good thing.
Check your other comment carefully.
Well it has to be done at some point! If they said "Python 3 is the default Python, but a python2 package is available and you can switch between them with update-alternatives..." then I'm sure it'd piss a lot of people off, but at least they'll start porting!
Just wanted to remind everyone that [Python 3 migration is on schedule](http://www.reddit.com/r/Python/comments/f7fjr/python_3_is_on_schedule/). Obviously, projects like this are still important to point out the packages in need of migration help, and the sooner the better. But just keep in mind that there's still another 3 years for the scheduled transition to finish.
Speak after me: Parenthesis parenthesizes parentheses. Now think about what you've done wrong.
Pfft, [searching wikipedia is easier than that](http://en.wikipedia.org/wiki/Logarithm#Change_of_base)
Have you tried changing the backend in your matplotlibrc, I don't know whether it'll work but it's worth a try.
I thought Django was ready for python 3
What did you move on to?
Perhaps, but we believe this will be a relatively short term problem. It's also much better than being locked into Python 2 forever by having recalcitrant clients refusing to upgrade their Python 2 scripts to Python 3. Better to start with Python 3 we think. The business is run primarily in our interest and only secondarily in theirs. ;-) 
I didn't know that slices were objects that could be reused and passed to a function. Thanks.
ubuntu is not going to say "python 3 is the default" until all their admin tools and other ubuntu goodness is ported, before that happens all the dependencies the ubuntu goodness depends on would need to be ported (pygtk etc...). if they ported their dependencies and their goodness, it would likely cover a large swath of libs, and porting wouldn't like be a big deal at that point. But to say it has to be done at some point is silly. There's servers purchased from dell in the last 5 years that have management tools on them that ship with and won't work with anything but python 2.2. I found out that lovely fact when trying to get mercurial installed on them. It's been a hot minute but unless things have changed recently, you couldn't do better than python2.4 on redhat for those licensed servers. 
Note that exposing excel functionality as a web service probably violates the license. One more reason to use free tools :)
Speaking of multidimensionality and slicing, here's a trick for reorienting an array of arrays. You can think of it as turning a table 90 degrees. Use the tuple-unpacking feature of function calls to make each subarray in the array into a series of arguments to some function. &gt;&gt;&gt; rows_of_cells = [[1,2,3,4], [5,6,7,8], [9,10]] &gt;&gt;&gt; map(None, *rows_of_cells) [(1, 5, 9), (2, 6, 10), (3, 7, None), (4, 8, None)] map() with function "None" is special. Results come out until every last iterable list is exhausted. Contrast with zip(), which terminates when the shortest list terminates. &gt;&gt;&gt; zip(*rows_of_cells) [(1, 5, 9), (2, 6, 10)]
I still maintain my offer for getpython3.com. I think I emailed you all about it awhile ago
Try this import irclib import time DELAY = 1 irclib.DEBUG = True network = "irc.quakenet.org" port = 6667 nick = "bottest123" name = "Test Bot" chan = '#testchan' irc = irclib.IRC() server = irc.server() server.connect(network, port, nick, ircname = name) time.sleep(DELAY) server.join(chan) irc.process_forever() 
I see the delay working as it should from the DEBUG verbosity, but it does not change the result. The "bot" is online on the network but is not joining the channel. I assume then the cause is some sort of difference between the 2 networks (quakenet and freenode), which is not contemplated in the irclib library. Is that possible?
If you're not specifically trying to learn something about IRC or Python, I would suggest building on top of Supybot (or its fork Gribble), because it already takes care of most of the plumbing you would need for most persistent, interactive bots. It allows you to start from the plugin level of what commands your module should respond to, rather than how to interact with IRC servers.
Thanks for the offer. But I think .net is better than .com The site has the basic functionality now. But I want to work on the features listed there. I am coming to PyCON this year. If anyone interested to work on this site during PyCON sprint, let me know.
OK. How about this: import irclib DELAY = 1 irclib.DEBUG = True network = "irc.quakenet.org" port = 6667 nick = "bottest123" name = "Test Bot" chan = '#testchan' irc = irclib.IRC() server = irc.server() server.connect(network, port, nick, ircname = name) server.execute_delayed(DELAY, join, (chan,)) irc.process_forever() 
If you want to promote something then promote it. The use of the word "shame" is just going to irritate those indifferent or actively opposed to the idea of Python3...
&gt; map() with function "None" is special. Results come out until every last iterable list is exhausted. Contrast with zip() There's also `itertools.izip_longest`, which takes an arbitrary fillvalue (in case you want 0 as you default). &gt;&gt;&gt; list(il(*rows_of_cells)) [(1, 5, 9), (2, 6, 10), (3, 7, None), (4, 8, None)] 
I'll keep this advice into consideration for the future. At the moment i dont need any bot to get any added functionality. I'm just trying to learn and understand something more about python (and related stuff) every day. For example, I've been an IRC user for maybe 10 years, and I knew that the IRC Protocol is that, i mean, the syntax for the join command is "JOIN #channel", that's it. Ofc in other networks there are added functiontalities. I saw networks with service like channel-protectors or nicknames-protectors. Stuff not even known on networks like IrcNet. But now this situation is totally twisting my mind. I should check some reference about quakenet from them self. And then check if the irclib methods are compatible with those guide-lines. But, i could be damned if i know why, www.quakenet.org appear offline to me. And only to me: http://www.downforeveryoneorjustme.com/www.quakenet.org
name join is not defined. Tried: server.execute_delayed(DELAY, "join", (chan,)) object 'str' is not callable.
Sorry, that should have been server.execute_delayed(DELAY, server.join, (chan,)) You might want to try a longer delay. Also, you might have to look for a ping with a code and pong back with the code. 
If you are interested in learning, I suggest that you write your own IRC library from scratch using sockets. That's what I did. It was a lot of fun, and I understand everything that my code is doing.
Wow, thanks. I didn't know `map` could take multiple sequence arguments.
DELAY = 5 did not work. DELAY = 20 **did** work! I think the problem is that I'm sending the JOIN command too soon compared to the messages the server needs to send back to the client to accomplish the connection. EDIT: More specifically i need to wait this: command: umode, source: botnick!botident@host.tld, target: botnick, arguments: ['+i'] before i can send the JOIN command and any other commands. which is not a message the server is sending, but actually receiving. There must be something in the irclib library which forces the client to assume the +i mode, or maybe it's a required state from server side?
Yep, that will be the next step. :)
Yes, you'll have to write an event handler that either processes the raw data (event string "all_raw_messages") or uses a specific event string such as "endofmotd" (I'm just reading the code here; I haven't used this module; is this documented somewhere?). The event handler gets added with add_global_handler(event_string, your_function, priority) Specifically I'm looking at the module code here: http://python-irclib.cvs.sourceforge.net/viewvc/python-irclib/python-irclib/irclib.py?view=markup The events list starts on line 1371.
The most informations about irclib are in the code it-self, very well and extensively commented. I found also stuff (examples, more than anything else) here: http://nullege.com/codes/search/irclib And here: http://www.devshed.com/c/a/Python/IRC-on-a-Higher-Level/ The last page of this tutorial is the list of all the events, which is the same you were refering in the sforge page. I dont think handling this situation will be an issue now that i know why it acts like that. Thank you again for your kind help.
the problem with this kind of framework and gwt IMO is that they really don't seem to reduce anything practical. Sure you get the 80% done very quickly, but it seems that last 20% is infinitely harder as you are wrestling with the framework as well as the browser and the language. I always seem to get into this mental process where I'm writing in one language hoping that I am going to generate what I really intend to implement in another language. The effort of that probably exceeds the effort to just learn/implement it in javascript in the first place. -- my .02
Actually, what I'm looking for is a way to easily place text in various parts of the screen (i.e. lay out a grid, update it every once in a while, accept keyboard input...) which curses seems to have good support for. Think a console utility that is laid out like one of the old rogue-likes or DwarfFortress (although I think that uses character tiles in a true graphics-based system.)
The major DSL providers around where I live explicitly block ports, major cable or fiber providers waffle on their policies, or "open" ports for residential lines, reserving the right to block the port if they choose. Search the [FAQs on dslreports.com](http://www.dslreports.com/faqnew), there is plenty of information on port blocks across cable, dsl, and fiber providers of consumer lines. Both these policies are means for ISPs to force anyone benefiting commerically, on a consumer grade line, to pay more for service -- at the discretion of your provider, of course. This is not going to be a problem for someone wanting to experiment with hosting, assuming the ports are not explicitly blocked. This was simply the point I was making above. Myself, as a system administrator, my livelihood is keeping my servers, regardless of size or traffic, *up*. I won't leave the availability of my servers up to the goodwill of my ISP.
logs have always been a weakness. thanks for the helpful advice :)
Used it today. So far so good, but it would be even better were it also to log those files resp. directories which were skipped due to insufficient tags and (hence) no musicbrainz result. ("This album ( - ) is already in the library!")
What is the last 20%? Creation of new widgets - or is it something else?
&gt; This will remain as is till the community overcomes its use That's true of almost anything. &gt; Guess what -- future will never come. One needs to go cold turkey some time for this. By many estimations, 3.x adoption is ahead of schedule. Remember, a general consensus was that it might take 5 years for wide acceptance of 3.x, starting from December 2008. Plenty of projects are supporting 3.x without needing to go "cold turkey". &gt; Also the backporting of python3k features to python2, though really good, is not helping either Can you support this? I've never once heard anyone say this. &gt; since all 3k features are becoming available in 2. There's a bunch, but back porting is certainly over now.
http://www.youtube.com/watch?v=tKTZoB2Vjuk
Brandon Rhode's "The Mighty Dict" is great: http://us.pycon.org/2010/conference/schedule/event/12/
PHP was designed with the web in mind, and everything else feels kludged on and rough. Python is pretty much the exact opposite (Though, through frameworks, Python does web based better than PHP does non-web). The only thing that makes one language faster than another to code/deploy in is your familiarity, and how comfortable you are within the language. PHP is as readable as you want it to be (especially if you're the one writing the code). I can go over PHP I wrote 10 years ago, and still understand what I was doing. PHP's OO support isn't horrible, but OO feels more fluid in Python (since Python treats everything as an object). I say do both, you only hurt yourself by limiting yourself. They're both relatively easy languages to learn. Then when you come up with a project, you can pick the best fit for the job.
&gt; I'm finally getting into OO and now I have finally come to the debate before I get head deep would it be worth it to learn Python (Django or Pylons) instead? Python is "more object oriented" (if there is such a thing). Everything, including all of the types, are objects with a common ancestor. This might force you to start thinking objectively (ha ha). &gt; My greatest concern from what I have heard is the templating engine is designed for certain things and isn't as flexible as PHP's. It doesn't *really* have a templating engine included with python. It's a general-purpose language. When you choose a [MVC] web framework (you gave Django and Pylons as examples), you will be offered a language for writing templates. Most frameworks let you easily change out templating engines. If you fall in love with Jinja2, you can easily jam it into whatever framework you wind up with. &gt; The reason I'm thinking of this is apparently Python is alot more readable than PHP and apparently much faster to develop in. &gt; Sell me on Python here people. No, go through the [official tutorial](http://docs.python.org/tutorial/) and make your own decisions. Do the same for web frameworks, they all have quick, easy tutorials that act as excellent litmus tests.
Why not leave them? If they have been rolled into the stdlib, then they will eventually drop in popularity.
that's a good idea. I think I'll finish up this project in php and then start my next one in some sort of Python framework.
short: yes long: overall python is a way better language and for non-web stuff it wins hands down as php is not a good general scripting language (a lot of this has to do with the implementation of the php interpreter instead of the language itself.). The issue with python and the web is the interface between the webserver and the python executable really hasn't been worked out fully. Sure wsgi is basically the standard, but it is a kludgely implementation on Apache as it forks from the Apache process and then just idles there. PHP can support any webserver configuration you can dream of and actually be much nicer on memory and easier to configure to use tools like suexec. IMO python really needs to have much better fastcgi (mod_fcgid) support as mod_wsgi is not much of an improvement over mod_python. mod_wsgi does do most everything fastcgi does but when there is already a standard way of delegating requests to an interpreter you should follow it. 
TIL about TIOBE. Thanks for the post. 
this is a great answer. thanks for not polarizing the two languages. 
the 20% that defines the logic you are trying to implement specific to the app you trying to build.
[Link.](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html) And I'm friends with Lisp (14), don't mind Ruby (11) and can cope with Perl (10) as long as I don't have anything to do with it. The real news is that we beat PHP (5).
yes, and use web2py or flask. :)
I wonder if you can approach this in 2 ways. * Track all I/O points and what goes in and out of them * Track all the variables and everything that happens to them. Both are very difficult. Python is a dynamic language. Variables could be nested inside classes and other deep structures, they could be accessed via properties, they could be coming from results of "evals" (shudder!).
Python syntax is generally beautiful. PHP syntax is generally not. This sounds like a frivolous difference, but it makes a big difference in maintainability. Of course, if the problem is found between the keyboard and the chair, then it doesn't really matter which language is used.
The best Python talk I've ever seen is Raymond Hettinger's "Core Python containers under the hood". He gave it at PyCon 2008: http://www.youtube.com/watch?v=hYUsssClE94 And again at PyCon Italia Due 2008: http://www.viddler.com/explore/python-italia/videos/41/ And, since the video quality is pretty awful, you might follow along with the slides: http://www.pycon.it/media/stuff/slides/core-python-containers-under-hood.ppt
What happened in early 2004 that caused such an earthquake? It must be a change with how they came up with the results, surely? EDIT: Oh, found the answer: &gt;Q: What happened to Java in April 2004? Did you change your methodology? &gt;A: No, we did not change our methodology at that time. Google changed its methodology. They performed a general sweep action to get rid of all kinds of web sites that had been pushed up. As a consequence, there was a huge drop for languages such as Java and C++. In order to minimize such fluctuations in the future, we added two more search engines (MSN and Yahoo) a few months after this incident. 
Remember this -- code is more than likely going to be read many times more than it will be written (especially important/reused code)... therefore, readability matters a lot. Python wins big in that department... That having been said, I think that Python and Javascript are the two scripting languages to learn at the moment. Beyond that, I'd aim at either one of the flavors of .NET (though that could be Python as well) or Objective-C, inasmuch as Microsoft and OS X and iOS platforms are big and will probably both remain so for some time. If android development is a priority, Java, of course, should be on the menu. 
I won't join in with the denigration of the other languages. What gets me is that Python is not first! I think that some company would have to make money from taking up Guido's offer and come up with a Python compiler that used the type hints available in Python 3 to turn Python into a Java/C/C++ compatable compiled language when enough type and intent information is given, but give warnings but still interpret those parts of Python that cannot be compiled. There is a hard-core of management out there who would never entertain doing a project with an interpreted language at its heart. Using two or three languages on a project has got to be worse than doing it all in Java, right?
You don't actually say what kind of "project I have wanted to do for some time" it is. If it wasn't web based then that would largely rule out PHP. I'll presume it is web based and suggest you also think about the way you are going to serve your project. It's still generally easier to find hosts for a PHP application compared to Python (even though the number of python app hosts is growing*). As an example: I look after a Cpanel server that runs both python/django and PHP based applications. After a recent OS upgrade the PHP one was up again in minutes, whilst I had to do a whole series of reinstalls of python version, MySQLdb, mod_wsgi, various python libraries before I could get the python/django sites back up and running (Note: I'm sure there was a smarter way but this was a rare situation but I'm happy to hear of a better approach). Having said all that I moved to Python from PHP after looking at which would be the best language to use to teach someone new to programming. I liked it so much, I switched, although I do still do PHP work. If I was to start afresh I'd say Python. Here's some reading material from Terry Chay (well known in the PHP community) for you to consider: http://terrychay.com/article/learning-programming.shtml * e.g.: http://djangohosting.org/ or even http://code.google.com/appengine/ 
could I ask you why you decided .net is better? did you do focus groups or run polls? this is important for me to know if I were to consider volunteering. I have not viewed .com but i find your site interesting. thanks. 
The reason Django's templating engine is less flexible than PHP is because it's designed for one specific thing: templating. PHP on the other hand needs *everything* written in the template, which sucks, and is the reason why there are templating engines for PHP. But if you absolutely must have a more flexible templating engine on Python, use Mako, in many respects it is similar to PHP (in-lining code, etc). I used to be a PHP coder but having to check returned results for handling errors is something I hate, and yes PHP does have exceptions, but the standard library doesn't use them for some reason. Don't get me wrong, PHP is still a good language, I just don't have to code anywhere near as many work-arounds (magicquotes, etc) in Python. If you are interested in Python web development, you might also want to check out Google AppEngine, but if you are an oldfag you might want to avoid it, because the lack of SQL will give you skin failure.
Exactly. If you start with 2.x, switching to 3.x later won't be very hard.
There's no way to do this statically. Here's a very common Python idiom that defeats most forms of static analysis: def foo(x): x.baz() At the call site for `baz` you can't know what the type of `x` is, so you can't make any assumptions about its behaviour. This is why JIT compilers are such a big win -- language runtimes like V8, JaegerMonkey, and PyPy can optimize based on the type of `x`, since they can inspect the actual object when compiling that call site.
What about [Cython](http://cython.org/), [Jython](http://www.jython.org/), [IronPython](http://ironpython.codeplex.com/), [etc.](http://en.wikipedia.org/wiki/Category:Python_implementations)? Am I missing something? [From Wikipedia](http://en.wikipedia.org/wiki/Cython): &gt;The special advantage of this seamless Python/C intermix approach is that existing Python code can be tuned to almost the speed of C by just adding a few static type declarations and by making some adaptations in critical loops - without requiring complicated interface code. The coding speed and the readability of the code remains very Pythonic. 
Raymond Hettinger's talk is wonderful, don't forget [Easy AI with Python, PyCon 2009](http://us.pycon.org/2009/conference/schedule/event/71/) and [Mastering Team Play: Four powerful examples of composing Python tools, PyCon 2010](http://us.pycon.org/2010/conference/schedule/event/86/)
Hell yeah. I started learning PHP 9 years ago and if I could do it again I'd learn Python instead.
I remember when Java wasn't acceptable because it wasn't compiled (it was) into machine code of the underlying CPU (it wasn't). It was actually relatively straight-forward (but non-trivial) to compile Java to C w/ a decent GC library, until the version that supported reflections and what-not came out. I was getting 100x speed-ups on a pretty complete feature set of Java (for the programs I cared about). This was pre-JIT days, though. Assuming a decent JIT back then, it probably wouldn't have yielded much... Except in startup times. EDIT: This might have even been back when Java was called Oak. So, a pretty primitive stack by today's standards (but *almost* the same ISA!). 
Programming in C# and Python, I'm pleased but a bit mystified to see an apparent link between the popularity of the two - anybody have any theories why, or (more likely, I guess) is it just coincidental?
I like python much more than I liked php. php always felt like I was putting together a bunch of hacks; using python with django feels more natural to me. ..could be for many reasons outside of the language differences though including my own coding experience (only a CS minor in college, more or less taught myself web dev stuff in HS / [college /] jobs )
I guess it is because they are both relatively new and the upcoming generation of programmers are more likely to be interested in learning them. This is the case for me, anyway, as they are the languages that I have decided to learn. As far as I see it, the two of them together let you do just about anything you may want to do.
Python had its first releases in the early 90s, and the still popular 2.x line around 2000. The first JDK was 1997. No, Python is not new. At all. It has mostly been used in academia and has more recently gotten attention as a more all-purpose language, for reasons I can't explain but I suspect have to do with Apple and Google's seeming embrace of it, along with Django maturing.
Relatively new on the scene, then. I think most people would class Python as a relatively new language compared to most of the rest on that chart.
Perl 6 didn't actually *ship* for ~ 10 years. Python 3 is nothing like that. It's been shipping for years now. It's just that folks are buying into it at a slower pace than you might like. I wouldn't paint it as a credibility failure, it's just a pacing thing.
Python was released 4 years before Java. Java is relatively newer than Python... its just had a ton more resources poured into it, increasing its exposure.
PHP is a huge pile of ugly hacks, but it's worthwhile to learn it and understand that first hand.
&gt;My greatest concern from what I have heard is the templating engine is designed for certain things and isn't as flexible as PHP's. Are you referring specifically to the Django templating engine? I've heard some (I think usually minor) complaints about its limitations, though given the way the framework works, I suspect you won't generally have any problems with it. Of course, you've got lots of other options to choose from -- check out [this overview and listing of Python web frameworks](http://wiki.python.org/moin/WebFrameworks). There are a number of different templating engines available, including some that let you use pure Python in your templates (e.g., [web2py](http://www.web2py.com/book/default/chapter/05), [pyTenjin](http://pypi.python.org/pypi/Tenjin/)).
Also, one advantage of being owned by a huge corporation instead of being open source its that there is someone to do a ton of marketing for you. Of course, there are other disadvantages, but this is one thing which is much harder to do for open source at first.
1) http://swilliams.ca/python-tutorials/ and then go to blip.tv and search for Python 101 and 102 from PyCON 2010 by Stuart Williams. Got me started with Python properly in the first place. Nice hands on tutorial. Goes to the intermediate level with ease.He is an awesome trainer. 2) Python Osmosis - http://www.youtube.com/user/ryanmshea#grid/user/4B416E115B44D973 -- Short introductions to the basic and advanced concepts. Edit: Thanks to the OP for starting an awesome thread.I hope more people chip in.
If you just want a job, learn PHP. If you want an interesting job, learn Python.
Your understanding of how mod_wsgi works is not necessarily correct and you also don't appear to be aware of the various features that mod_wsgi supports. It also shows that you perhaps don't understand one fundamental difference between PHP and Python. That is, with PHP the whole PHP application is effectively thrown away at the end of a request and thus it has to be reloaded on every request. Because it is thrown away it doesn't matter if the process is killed off between requests. In Python however, the application isn't thrown away on each request and it is therefore important that the processes handling requests stay persistent in memory. If you do not do that, then performance will be dreadful (ie., think CGI). Thus characterising that an Apache or mod_wsgi process can sit there idle with the application code loaded as bad is plain wrong as for Python it is exactly what you do want. Retaining the application in memory means that it is immediately ready to handle requests and can also handle multiple concurrent requests using threading at the same time. PHP cannot benefit from either of these things because of the fact it throws away the application at the end of a request and because it isn't thread safe anyway (at least its extensions aren't, don't know about the core these days). For mod_wsgi you don't need suexec because mod_wsgi daemon mode already has the ability to run WSGI application processes as a distinct user, including optionally enabled checks on ownership of WSGI script files and the directories they are in, much like what suexec does. Daemon mode of mod_wsgi even supports the ability to run WSGI application processes in a chroot environment. So, the feature set of mod_wsgi may not exactly match what mod_fcgid/mod_fastcgi can do but it has a lot of similar capabilities and is also able to do various things that the FASTCGI solutions can't. The mod_wsgi module being purpose built for Python also means it is easier to use for Python hosting, unlike FASTCGI solutions which can be a challenge to get set up and running properly.
Honestly, it would really help you to design the same project in both languages. 
NXT-G is now #15? lol.
you asked in the Python reddit. What do you expect? They're different tools. A language is one tool in your toolbox; it's not your entire toolbox. An incredibly important tool, but just one tool, nonetheless. Use what is right for the task at hand. Since you haven't stated what the task at hand is, it's impossible to say what is a better choice. Is Python a better language *overall*, in a *general* sense? Yeah. Fuck yeah. No question. But while PHP *is* a janky piece of shit with half-baked object orientation and a terrible error-handling system, it also runs everywhere and is much easier to get up and coding quickly for doing back-end web tasks. You want to code Django? OK. Go ahead. Are you reading Dive Into Python? They suggest you run Debian. So go use that. Now are you reading The Django Book? Well they suggest you use PostgreSQL. And everyone you've ever talked to says how Apache is the standard web server. But don't go relying on the official Django documentation info on getting mod_wsgi working properly and auto-reloading when you change any of the source code. Good luck getting a PostgreSQL stack on Debian hosted in Apache if you've never done it before. Yeah, you can do it, but if all you want to do is get up and running on a web app, you're going to spend orders of magnitude more time shaving yaks if you go the Python route than you will if you just write some brittle piece of shit PHP crap and host it on Bluehost or some other pauper's host. So what's your goal? Zen mastery, or a simple script? I coded PHP professionally for about a year. I don't use it anymore because it's a horrible piece of shit. In reality, I *do* like to write Django apps in a Debian environment and host them in Apache (no PostgreSQL yet... getting to it), but I *enjoy* doing all the tedious web server management bullshit. Fuck if I could explain why. But I'm glad I learned PHP, because even though it is a complete piece of crap, it allows you to get up and running quickly, which makes you *feel* like you're making great progress, but it doesn't abstract anything to the point that you don't understand the mechanics of what you're doing (::cough! Rails! cough!::). If you want to master something, to keep it with you for a long time, to code things outside of the web, use Python. If you want to do a one-off script or simple app, use PHP.
If you scroll down a bit, you'll see a table that compares languages with a 5-years gap. In Feb 1996 Python was ranked #22 while e.g. Java and PHP didn't even exist.
I make a lot of money as a jack of all trades software engineer. Last year I did 3 PHP contracts, one C# contract, and then a contract that involved Python, PHP, and Ruby. When clients or head hunters look for code monkeys, I usually win out because I am competent in a lot of languages. I hate PHP but I also respect it for being the far superior candidate to do web development while I fear that I only love Python as much as I do because I am not forced to use it all the time. tl;dr Monstrado is right, do you project in both or do two projects in either. Regardless of outcome, you still win.
what are you talking about? the whole point of fastcgi is the application is not effectively thrown away at the end of every request. The interpreter stays running. With python I assume you don't really need an opcode cache since you have pyc files so you can't really say that php will act different than python due to its ability to use opcode caches in fastcgi mode. The reason why mod_wsgi is worse is in daemon mode it doesn't just launch a persistent python interpreter, it actually forks off an apache process that runs the interpreter inside of it. If every language made an implementation like mod_wsgi and you had all of them loaded your apache processes would bulge to some crazy bloated size. With fastcgi this isn't the issue you can get apache processes that are less than 20mb with almost every security or convenience module you can dream of loaded. The reason why mod_wsgi is retarded with suexec is once you set the suexec flag (for your other fastcgi handlers) you have to manually setup yet another per vhost setting that tells python which user to use. mod_wsgi obviously doesn't make python easier for shared hosting as it means they have to recompile apache to support it, most shared hosts already have fastcgi setup. Cpanel the most widely used shared hosting platform doesn't even support mod_wsgi at all but it does support fastcgi. Also I'm only talking about Daemon mode in all of this, why anyone would want to go back to running interpreters inside of the actual apache processes I have no clue as php has demonstrated just how bloated this can get. It doesn't take much to realize that forking a 200mb apache process is going to take longer than forking a 20mb one. 
Python does web better than PHP hands down, with one simple caveat: it is not build into Apache by default. Somehow that alone makes it soooo hard for most people. It is really sad. To begin with, people should be setting up PHP as FastCGI for most implementations. If you are doing that, then it is just as simple to set up python as FastCGI.
Run your application on its own port and reverse proxy to it. If your applications actually need to be applications then you need Python. If you just want templating that you want to glorify as coding, use PHP.
Absolutely hilarious.
You may get biased answers in favor of Python here. As much as I like Python more than PHP, I would like to argue that the language itself doesn't matter. Sharpen your design skills so that you can apply it to either language. There are beautiful code written in both PHP and Python, and there are also ugly code written in both languages. Aim to write beautiful code in whatever language you choose.
You can also make your language decision based on the amount (and quality) of third-party libraries available for the language. I would say in the case of web frameworks, PHP wins using this criteria. Python is catching up, but it's not there yet. One example I can give you: I recently needed an E-commerce framework set up for a client. The best one I found (based on several criterias) was Magento, which is a PHP-based system. I did not find any Python based E-commerce framework/system that impressed me. But the size of the Magento community, ease of deployment, and quality of Magento itself won it for PHP in this round. I do hope that the next round when I evaluate another framework, Python will present more options.
Just to interject here, I'm pretty sure that forks (at least under Linux) are based around Copy On Write, and as such there shouldn't be any difference between forking a 200mb apache process vs a 20mb one.
Consider letting the upvote/downvote functionality serve its purpose, instead of posting a link to stackoverflow in every single post you see. If you are going to redirect people, consider [r/learnpython](http://www.reddit.com/r/learnpython), since people generally choose reddit as their place to ask questions conciously. If they wanted to ask at stackoverflow, they would have.
&gt;By many estimations, 3.x adoption is ahead of schedule. Remember, a &gt;general consensus was that it might take 5 years for wide acceptance of Yeah, looking at 2008+5yrs, py3k is ahead of schedule, in which case most libraries should be ported within next 1-2 years. &gt;Plenty of projects are supporting 3.x without needing to go "cold turkey". Again good for 3k adoption if the transition is smooth. &gt;Can you support this? I've never once heard anyone say this. That was just a guesstimate given the features which were backported during 2.6 and 2.7, 2.7 in particular had a bunch of backports. &gt;There's a bunch, but back porting is certainly over now. Yes, it should be over given that the last 2.7.x feature release is over now. 
Also see the excellent ones by David Beazley: http://www.dabeaz.com/talks.html
Python never really "peaked" unlike Java which peaked extremely fast and sharp or Ruby, with Rails and Objective C with the iPhone. The reason why Python grew considerably in the last two years might be that it is used as an introductory language at many universities and unlike its precursors it is really liked by programmers. Python has become the new BASIC and this is a good thing IMO. As far as C# is concerned, it eats the lunch of other languages formerly used by Microsoft programmers in particular VB but also C++.
Nothing, I was only interested in it because I thought it would be a nifty thing to learn, sadly, it seems those responsible for the project don't agree with me and made no attempt to help interested people learn it. I suppose if I absolutely needed to use it, I could just bite the bullet and read the source, but I code as a hobby, not a job, so I am not going to bother if it isn't fun.
Idiots are a necessary evil in many cases, so great effort should be exerted in ensuring that such people cause as few problems as possible.
Python is a far superior language, as it was designed to be from the beginning. PHP started out as a web scripting language and grew into a Franken-language. This said, learn both (and more). PHP is everywhere these days, so you might as well accept it and get to know it. There are some very good projects written in PHP (Symfony for example). The important thing is to learn good design with whichever language you are learning. Python and PHP both allow for good OO designs.
Although I agree that python's urllib(2) modules are awful, I don't like these ones either. I don't see why GET, POST, HEAD, etc need separate methods. And it doesn't seem like the library covers uploading files, something which I absolutely despise doing with urllib (I end up using pycurl most of the time). Great idea, bad execution (IMHO!).
Asking this question in the Python subreddit kind of already answers your question.
By using urllib2 I can use the eventlet coroutines. I'd love to see that possibility in this module as well.
What's with this? def delete(url, params={}, headers={}, auth=None): r = Request() r.url = url r.method = 'DELETE' # return response object r.headers = headers r.auth = _detect_auth(url, auth) r.send() return r.response Was something wrong with this? def delete(url, params={}, headers={}, auth=None): r = Request(url, 'DELETE', headers, _detect_auth(url, auth)) r.send() return r.response()
Normally .com is used for commercial sites, but this is a community site. I haven't done any poll to see the interest to develop the site.
Jython and IronPython are also just interpreted ;-) But explain that to the management of a company - although it doe not differ from Java...
You can't. some_module.range = my_IO_range And suddenly all statements like "`for i in range(10):`" in that module involve IO. Plus of course if `a` is a parameter, you can't know if "`b = a + 2`" doesn't have side-effects. So, as far as I see it, your options are: 1. Make your subset of Python _very_ restricted and not like Python at all. Forbid module fields assignment, class fields assignment etc. Basically, freeze the type system. Then try to reason about variable types somehow. 2. Trigger recompilation whenever something mentioned in (1) happens. Either try to batch recompilations somehow (but aliasing would be a pain in the ass), or mark everything affected as "dirty" (i.e. replace with stubs) and recompile when called.
_derp_
Not doing a lot for my blood pressure, but sure, it's interesting.
The FASTCGI process, the PHP interpreter core and perhaps even the PHP opcode cache if one is used may not be thrown away, but the in memory application state of the specific PHP application is thrown away. Thus the application code has to be re run on each request from scratch to reinitialise the application state so as to then be able to handle the request. This is what I am talking about. In Python all that application state as well as the loaded code persists between request and so it is possible to cache application state in memory between requests. You comment that 'if every language made an implementation like mod_wsgi and you had all of them loaded your apache processes would bulge to some crazy bloated size' is also wrong. In the case of mod_php and also the old mod_python the interpreter is initialised in the Apache parent process. In current versions of mod_wsgi that doesn't occur and Python is only initialised after the processes are forked. Therefore mod_wsgi does not cause any bloat in the Apache parent process to be inherited by all the Apache processes. If you are exclusively using daemon mode you can even disable completely any potential initialisation of the Python interpreter within the normal Apache child processes which static file handing is done in. On my MacOS X box the Apache parent process with mod_wsgi enabled has a RSS of only a few megabytes, and most of that is Apache itself. The normal Apache processes aren't much worse. Hardly the bloat you claim. Your comment is though valid for mod_php and mod_python. The problem is that there is this misconception out there, that you are propagating, that embedding Python in Apache causes Apache as a whole to bloat excessively. This perception arose because back in the mod_python days, not only did mod_python do lots of initialisation and preloading of Python code in the Apache parent process, Python installations also didn't provide a shared library. This meant that mod_python embedded a static version of the Python library with the result that when the library was loaded address relocations needed to be done, causing the code no longer to be shared and instead increasing resident memory in use. The mod_python module and Python itself also leaked memory on Apache restarts as well. This caused processes to balloon out by an extra 5-10 MB just to begin with where as mod_wsgi as it stands and with a decent Python installation incurs only about half a megabyte in the Apache parent process. So, mod_wsgi doesn't work like mod_python used to and Python installations these days are better at providing a shared library, unless you stuff things up by installing Python from source code and neglect to enable generation of a shared library when you install it. If you are still seeing bloated Apache processes, then you either still have mod_python loaded, are using a quite old mod_wsgi version, have a broken Python installation or simply screwed up your Apache configuration in some way as it shouldn't be that way. As to claims about shared hosting, guess what, mod_wsgi wasn't designed for that and doesn't advertise itself as suitable for that environment. The mod_wsgi package is principally intended for people who are self hosting their own applications in their own environments and more so where the Apache is dedicated to hosting of Python applications and configured appropriately for Python and not still running a configuration intended for PHP applications. It can also be applied to a degree in managed hosting for a limited set of applications, potentially run as different users. It is not suitable for mass virtual hosting of an arbitrary number of disparate users code, certainly not untrusted code, on a single Apache instance. So, no surprise that it isn't used in cheap mass hosting as it isn't intended to be for that. This hasn't though stopped hosting services like WebFaction, where they provide each user with their own Apache, from using it quite successfully. Some of the new breed of cloud based Python hosting services are also using it. So, be sensible, use the appropriate tool for the job and and for cheap overloaded mass virtual hosting on a single Apache instance that is still FASTCGI, that I will not argue with. Why you feel you have to poor scorn over mod_wsgi about something it is not intended to be used for I have no idea. Ultimately doing so is just FUD because it misleads people people into thinking mod_wsgi is no good for anything, whereas in the roles it is intended it performs more than adequately and has become the favoured hosting solution. 
What came first, the libraries or the demand? ;)
I love Python and dislike PHP very much, but if you've already started your project in PHP, you'll be better off finishing it. Otherwise you'll restart in Python, find out about Ruby or C# or whatever in two months, restart again... You need to _finish_ projects to get a good feel for a language, and that time is never wasted. If you end up disliking PHP, at least you'll know why, and you'll be able to judge other languages better. And you'll have a finished project! Make the next one in Python :-)
I'll grant you that in practice I've never seen mod_wsgi processes bulge much over the parent process. So I guess it is wrong of me to lump it in right next to mod_php, I never assumed it started the interpreter till after the fork, but thanks for clearing that up for anyone else who comes along. Are there any concrete benchmarks of the benefits of the application state caching? I can see that as both a good and a bad thing as depending on the way the application is designed it could end up serving a user different views of a site on a per request basis. The way I see it this is probably something that should be turned off by default as it will lead new developers to wonder why they have to touch their *.wsgi file everytime they make a change. Maybe though I'm looking at all of this wrong and really python people don't want new developers working on projects. They'd rather it be a niche language and not have every joe with an editor working with it like with php. I understand that mod_wsgi is not all there is to wsgi, but I really can't fathom why the python community wants to support a non-standard way of doing things. I guess this is because most people who use python maybe refuse to use other languages, but that is a pretty arrogant reason. 
Good, but we want Numpy for PyPy. 
There are different requirements from different people. 2.7 was very high both on request list as well as developers attitude. Stay tuned however, since at least I think PyPy would be a hit in scientific community with even rudimentary numpy support
Or more accurately: &gt; If you want a poor-paying job working with awful programmers and messy, untested code, learn PHP. &gt; If you want an interesting and fun job, learn Python and/or Ruby. (Had to include Ruby, I prefer it; sue me. :)
New release (v0.2.1) with file upload support! http://pypi.python.org/pypi/requests/0.2.1
As the project grows, there will need to be more logic in those functions. 
| your free software is not suitable to my needs yet, please try harder and get it done faster
What about restkit, httplib2, urllib3, and all the various projects that patch urllib2? There is a lot of overlap between all these projects, and no one ever seems to be able to cover all the basics: keep-alive, uploads, caching, proxies, form/basic/digest/ntlm auth, proxy auth, etc.... I don't see that you're offering anything new here. Personally, I'd prefer to see someone put together a complete set of patches for urllib2 that maybe has a chance of getting into the stdlib. A lot of these projects get started, but no one ever finishes. edit: and as zethr mentioned, asynchronous support with eventlet/gevent is increasingly important.
I don't want to cover all things http by any means. I want to keep it to the basics that I want to do 95% of the time, and make it as simple as possible. I'm tired of dozens of lines of code (and having to refer to the complex documentation constantly) to make simple requests. The goal is a stupidly simple API for: - GET, HEAD, POST, PUT, DELETE Requests - HTTPAuthentication - File Uploads - Cookie Support (upcoming) Re: Eventlet Support. Excellent feature suggestion. Any pointers on how to get started?
I would suggest you take a closer look at [restkit](http://benoitc.github.com/restkit/), though it's docs are a little slim beyond the examples provided. Supporting eventlet is easy. Since you are based on urllib2: from eventlet.green import urllib2
&gt; I will continue to move the bar I am setting to not stare down my nose at your project.
Sarcasm overload!
&gt; No one was sure what Maciej Fijałkowski worked on but he seemed to be quite busy.
 import os import shutil def scan_for_folder(dir='C:\\allfiles', folder="9501"): print "scanning", dir, "for", folder for root, dirs, files in os.walk(dir, False): if folder in dirs: path = os.path.join(root, dirs[dirs.index(folder)]) print "removing '",path,"'" shutil.rmtree(path) scan_for_folder() This might work? I'd recommend commenting out the shutil.rmtree to make sure it scans correctly. I ran this on a simple test dir and it worked, however, I am not responsible for any data destruction. Please test this before using it. 
v0.2.2 was just released, which adds support for eventlet and gevent. Thanks! http://pypi.python.org/pypi/requests/0.2.2
v0.2.2 was just released, which adds support for eventlet and gevent. Thanks! http://pypi.python.org/pypi/requests/0.2.2
webob.Request + paste.proxy.TransparentProxy = WIN
I am currently doing a similar sort of website, however I have manually collected the porting status of just the popular modules/frameworks. If you would like to use my initial research at all, check out http://goo.gl/SCImr
That may be an issue of escaping the slashes. try scan_for_folder(dir="R:\\FONRS\\04 - NEW DATA\\STORED DATA\\Old DATA\\test")
Done worfs_son.
I love PyPy, Python desperately needs it. The more cores my computer gets the further I drift away from Python!
Already posted just 2 days ago: http://www.reddit.com/r/Python/comments/fk4gs/the_python_3_wall_of_shame/
[Code Like a Pythonista: Idiomatic Python](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html)
The logic should go in the Request class itself, not a ham-fisted constructor.
you can see what each line or 'bit' does... if it's something that can be taught this way why not?
Everyone has been a big help :) Thanks for the info. As I am new to programming in general I will finish this project to get a good grasp on the workings.. Next I'll bust out the snake.
Ruby's framework looks the best to me, but when it all comes down to it I would much rather learn Python than Ruby as it's uses seem far greater.
Its just you.
k.
I guess it makes better flow. I still wish more tutorials would include the full working versions of their examples, e.g. for pygame. It's not always trivial to fill in all the code that they cut out.
None of that code is important or worth saving. It's only there to serve as a demonstration. If you want to write a reusable program, then it definitely makes sense to write a permanent script. But if you're just doing some throwaway experiments, why bother? Furthermore, the interactivity of the REPL makes it easier and faster to figure things out.
Does PyPy still not contain support for my precious generators?
It's a matter of convention I guess. 
[Doctests](http://docs.python.org/library/doctest.html). This is used very extensively in testing within many Python packages, specifically the functional/integration testing within Zope/Plone. The actual test code is executed by the machine to verify that the code works, and can also be read by another human to teach her how the modules are used internally and/or interact with each other. Plus the usual format is in reStructuredText which can be formatted into nicer formats with pandoc or other related packages.
Immediate feedback...
PyPy has supported generators for quite a long time. Are you thinking of RPython the language PyPy is written in? It doesn't support generators, and probably never will, but that doesn't affect Python level code supporting them.
It's me too.
Thee Reasons: 1. Because to understand Python you must understand that it is a dynamic language, fundamentally different from statically compiled languages like C, Pascal, etc. 2. It's a convenient way to play around with the language, and encourages you to do so. 3. It's cool.
I rarely use a repl, because if you want to modify the first line of a 3 or 4 line method, it takes way too much up-arrowing to re-enter all the lines. Do it in a text file and it only take 1 up-arrow and enter to re-run something. Everyone else is crazy!
In the context of documentation (like your link), many other lines of the script would be irrelevant to what the documentation is trying to explain.
PHP was designed specifically for the model it uses and the startup cost of loading application state and code every time has been made sufficiently minimal as to make the model acceptable. Python however is a general purpose programming language adapted for web programming. Python web applications generally have a large startup cost because of the amount of stuff they load, especially since the bulk of code would be Python code that has to be loaded and potentially interpreted. This is in contrast to PHP where all the PHP extensions are written as C extensions and are generally even preloaded. The end result for Python is that the large fat web frameworks can often take in order of a second to load. In worst case, the really fat ones take up to 3 seconds. Obviously you can see that this would be totally unacceptable and not suitable in a model where the application state were thrown away on each request. This is why Python web applications are generally very dependent on process and application state being persistent and never thrown away, the cost overheads of reloading are too great. As to why mod_wsgi is popular. That is because the existing FASTCGI/WSGI bridges and the FASTCGI implementations together aren't always straight forward to setup. Too often you see people struggling with getting Python web applications to work with FASTCGI using a WSGI bridge. This is especially the case with web hosting services who throw up FASTCGI but don't do anything special to try and make it easier for people who want to use Python. Some of the shortcomings are in the definition of FASTCGI, such as that there isn't really a stdout/stderr for FASTCGI processes when spawned from a web server, so if you have errors on startup, they can be lost and you have no idea what is going. Apache/mod_wsgi therefore in contrast usually provides a much simpler path to getting something running as it has specifically been tailored to Python and its requirements rather than trying to adapt a generic solution. FWIW, one could definitely come up with a package which made it somewhat easier to deploy Python web applications on FASTCGI and I did look at it and started working on some ideas at one point. In the end I abandoned the idea as not worth the trouble.
Your actual workflow: run script switch back to editor window navigation to erroneous line (&gt;4 keypresses? a click? moving hand from keyboard to mouse?) fix line save file switch back to terminal up arrow enter Or, you could use an editor that provides a better interface into the simplistic REPL. Emacs (for example) has an amazing python-mode. I'm sure there are also Eclipse plugins or other environments that will give you better tools for incrementally loading code.
It's the php way that is non-standard. Ruby, Perl, Java and C# de-facto standard deploy methods are doing the same as Python's. Benefits: no need to do all the imports on each request, re-parse the code and execute app initialization code; in-process memory cache is given for free. PHP tries to workaround this with various opcode cachers / php accelerators (and they often fails, e.g. Zend framework can work times faster when pre-combined in a few big php files instead of a number of small), other languages just don't have these problems. PHP is unable to handle long-lived connections, tornado or twisted are impossible in php (there are attempts to write true-fastcgi code in php, e.g. phpDaemon, but interpreter is still leaking, most if not all frameworks are not thread-safe so it is not practical now). The great thing about php's approach is that user scripts can be thread-unsafe, leak memory and have a bunch of errors, and server will work fine and clean after the script after each request.
It's not just you. Python lover here, and if I do more than two lines in the REPL I normally regret it. I do use the REPL regularly though - you can do a hell of a lot in one or two lines ;) files = [os.path.join( r, x) for r,d,f in os.walk(rootdir) for x in f if '.xls' in x] print '\n'.join( [ str(x) for x in files if os.path.getsize(x) &gt; 5000 ] ) thing is, on most machines creating a python script really is as simple as cut-n-paste your stuff into a file called "my_script.py" and then execute "my_script.py" from a prompt (cmd.exe on windows, for example). it takes about 2 seconds longer than kicking off a REPL. If that makes it easier for you to learn, you should do it ;) 
Because, as a Python programmer, you will spend a lot of time testing things out in the REPL. I often use it for two things: inspect.getfile(module) print dir(module)
I use the interpreter a lot when working on libraries I'm writing since it makes me use the API more. However, once I get a feel that the API's about right then it's time to doctest since I want to document and codify those test harnesses for later.
In Python there is a strong line&lt;=&gt;result correlation, so it makes a lot more sense to try things linewise than in other languages. It works wonders with noobs and impatient people, which are huge demographics. I agree that the REPL stage should be abandoned rather soon, though. But for a start it makes a lot of sense. I've tried teaching languages without immediate interaction and a lot of people lose interest very, very quickly. This doesn't make "business sense" on the part of the advocate.
Either one would be better than: up-up-up-up-enter up-up-up-enter up-up-enter up-enter 
My point is that fixing poor use of the REPL by removing the REPL is like curing a headache by removing the head.
Okay I thought that you could make fastcgi scripts persistent according the perl docs I had read http://perldoc.perl.org/CGI/Fast.html Also the benefit of getting a working fastcgi implementation (whether it requires a simple python library, a shell wrapper script or something more complex) is that the user is then free to get it working on most any webserver of their choice (hopefully with minimal extra configuration) and additionally depending on how the wrapper, library is setup that enables fastcgi to work with python they could potentially use different python implementations such as pypy, stackless or jython or whatever they prefer really. The stdout/stderr problem you mention I could see that being a huge issue though especially with a WSGI bridge that hasn't been extensively tested. 
I use python-mode in Emacs, but I think of it as a way to re-run (parts of) a file rather than a way to improve the interface of a REPL. Both might be true, but I definitely feel like my workflow has more in common with the pure file approach than the pure REPL one. 
Perl is different to PHP and like Python the way Perl works does allow persistence of application state across requests.
Following up here to my own post, what is missing for Python/WSGI in respect to FASTCGI is a nicely packaged up version of a FASTCGI wrapper program which would allow one to say 'FcgidWrapper /usr/local/bin/wsgi-wrapper .wsgi'. PHP setups use such a wrapper so one can just dump a .php script file in a directory and it all just works without the user needing to do anything special. For Python however you have to provide an actual FASTCGI enabled program yourself. It is the initial execution of such a program, setting up the embedded FASTCGI server, setting up Python module search paths etc that always seems to cause grief. Things would be so much simpler if there was one well implemented wsgi-wrapper which automatically attached to a Python virtual environment for your account in some defined location, executed the embedded FASTCGI server for you, and then finally for specific request, load the .wsgi script file the URL mapped to and invoked the 'application' object in it as the WSGI application. This would solve so many of the problems people have with FASTCGI so long as hosting providers installed the wrapper and enabled it, because users would just be able to install packages in their personal Python virtual environment per hosting services requirements and then just dump plain WSGI script file like mod_wsgi/uWSGI use and it should just work, without users needing to do \_\_main\_\_ crap to start the FASTCGI service themselves. The wsgi-wrapper could also if necessary for a hosting mechanism where it is required, ensure that stdin/stdout/stderr are mapped to sane things such as the latter being sent to log file in users account.
It's the quickest way to experiment with code, instant feedback. Much of my development starts in the interpreter, experimenting with a few snippets, solving some small piece of the problem, then moving the good parts into a file, importing that code back into the interpreter, and repeating that process until the program is done. Python also has some nice tools to help you develop in the interpreter: `help()` / `__doc__`, `dir()`, `reload`, the `code` module, ipython, bpython, reinteract. It's also good for figuring out how a new library / API works.
You might want to review the section titled "[Reading and Writing Files](http://docs.python.org/tutorial/inputoutput.html#reading-and-writing-files)" in the Python tutorial.
`ipython` allows you to save the session to a file. IIRC you can have it be the default behavior on exit.
Scroll down to section 7.2 http://docs.python.org/tutorial/inputoutput.html More generally just search "python file input output"
Are there alternatives? I agree this is a bit offputting. I'd like to see something that takes a little bit more "enterprise-y" tack.
Something I learned which made using the REPL much easier: _ (underbar) is a variable with the value of the last statement you ran. (I tried it on a whim since it works in PERL and was much delighted). &gt;&gt;&gt; some_function() &lt;SomeObject&gt; &gt;&gt;&gt; a = _ &gt;&gt;&gt; a &lt;SomeObject&gt;
As a person who feeds his family/pays his bills on php's back, I'd say learn python
I don't know why we teach this way, but I TA a CSci course where we teach Scheme and later on in, Python, and this always happens the first couple of weeks: Day 1: Show them some basic syntax of language (and it's Scheme sooo .. *basic*) in REPL. They follow along and try it out. Day 2: Time to actually do a lab we've put together. We give them a lab template that they basically fill in and run for us to show us they did it (by (load ..) in Scheme or exec_file(..) in Python). It never fails that I have some students just type in ALL into the interpreter, and then they can't run what they have (they scroll around to show me) or they will accidentally reset the REPL and lose all their work. I emphasize using the template and then loading it, but I think they get confused by us just typing into the REPL the first day.
So in just 2 days you have taught them to both use REPL and create a program as a stand alone file? Sounds reasonable to me.
I should specify, Day 1 of lab .. (week passes) .. Day 2 of lab "Hey guys remember how Professor so and so showed you the templates? Lets use those today here's how you .." annnd yeah.
It's funny you mention this. I recently had to write a bunch of Perl and the thing I missed most was the interpreter. In Python when I'm unsure of something, I just prototype it in the interpreter. In Perl the best I could do was debug mode, which is vastly inferior to the Python interpreter.
Unless this is an issue that plagues the students for the rest of the semester, I just don't see the problem. Some students struggle with the concept once and after that the concept becomes clear to them. Sometimes you have to type in a bunch of stuff and lose it before you realize that there is a time to use REPL and a time to use a file.
Yes, you're right, most of them that don't realize by that point do pick it up fairly quickly if not that day. I guess I just stated not very clearly that a few of them get confused by it for 2+ weeks.
It's not just you. But I've begun to see how it's not that bad after all.
o=open(name, tag) o.write(string) o.flush() name is a string as is tag. tag indicates what you want to do with the file: "r" read, "w" write, "a" append. Also, if you want to write delimited files (as in data) then numpy has good built in functions (genfromtxt and writetotxt or something like that).
It's great, you see right away the results, and are tempted to try other stuff right away, without the delay of modifying the script.
When you write a full script you should have a mental representation of the data structures at each step. This context encourages learning how to do that. However, for that kind of work I recommend [DreamPie](http://dreampie.sourceforge.net/) since writing control structures in the interactive interpreter sucks.
He surely would fit well into enterprise programming. 
Except he really is productive :)
I don't want to discourage anyone from coming here for help, but I think you could have figured this out a lot quicker if you had just typed your title into google and appended "python" on the end. To try to offset being kinda a jerk, here is another answer: http://learnpythonthehardway.org/static/LearnPythonTheHardWay.pdf Exercise 15 and 16 should get you going. I hear this is also a good book for beginning programmers.
More resources wasted on 2.7. WTG guys.
Good god man, those two lines look like they could use a little [python zen](http://www.python.org/doc/humor/#the-zen-of-python). Also, is it really needed to cast x to a string in that second line?
I agree. I don't mind the "noob" questions here once in a while, but questions like this one are at that point of "I didn't even try to figure this out on my own first".
I do a lot of mistakes. The interpreter is anything but immediate feedback for me. Also, anything that remotely touches a longer processing time will break my line of thoughts if I have to wait for the operation to end. The interpreter is great for checking out lines of code or short segments but I haven't been able to use it for anything more than that. A tutorial, by its very nature should be something that grows in complexity. A text file that "grows" is something that my mind better understands. Other people might have a different experience with this. :)