&gt; A lot of the primary concerns you see on Reddit are for people implementing things at "the boundaries" between text and Unicode, something you'll not likely be doing. It depends. It is also people who have large, well working pieces of Python 2 code that do the job fine and make money. Python 3 doesn't at the moment offer any earth shattering feature that justify risking destabilizing an existing code base, and sinking time and money into it. Also libraries. It will take just one library to not be compatible with Python 3 and well you'd either end up forking, spending time upgrading the library, testing it, or just use Python 2. Most just use Python 2 in that case. 
Am the only one bothered by the "raise Return(value)" as a flow mechanism?
The codebase issue obviously won't be affecting OP, and as a beginner programmer any library incompatibilities won't be an issue either.
Python 3 is not entirely an improvement. It introduces weird warts, like strange division, and unfriendly print statements. Just move over to stackless python 2.8. Also, the move to python 3 broke lot of shit in Arch. That was quite unnecessary.
I might just wait for python 4. Then I'll upgrade.
Library writers have an easier time giving a shit about python3 than application writers.
I'm still looking for a python2.7 replacement.
It's just completely ugly.
Take a look at https://pypi.python.org/pypi/collective.eggproxy -- it allows you to run a caching proxy on your own server, which you can point to for all your installs. Useful if you're working with a number of servers (eg. EC2 instances) that are managed somewhat automatically (eg. Puppet). If PyPI goes down, you can still serve the latest package from your cache, as long as you've requested it previously. What's also handy about this tool is that you can register your own packages in this proxy that *aren't* and *shouldn't* be available on PyPI, such as proprietary software specific to your systems.
of course you don’t *need* to. but as a script writer and sysadmin, you should definitely have advantages by using 3, as it’s unlikely that your scripts depend on unported libraries, while 3 has less boilerplate and is overall nicer: normal 2 header: #!/usr/bin/env python2 # -*- coding: utf-8 -*- from __future__ import unicode_literals, division #, ... from io import open # open as utf-8 by default normal 3 header that does the same: #!/usr/bin/env python3 so if nothing forces you to use 2, there’s no reason to use 2. --- ubuntu being “3 only” means that they won’t ship 2 in the default installation (disk image), but will of course keep it in the repos.
try asyncio aka tulip – it’ll be in the stdlib of 3.4, and has an even nicer API. unfortunately it lacks utility functions, so you need things like aiohttp on top of it.
Division and print are some of the nice things, actually. Arch set Python 3 as default. That should either never happen (like SQLite) or take much longer. They screwed up in their optimism, but it has nothing to do with Python 3 itself: it is clearly marked as breaking compatibility.
Bug fixes, not features. They refused to port SNI, which is quite sad.
We should really change Linux instead of our language, because we are morally superior. I am not entirely convinced...
I think his [analysis of the traveling salesperson problem](http://nbviewer.ipython.org/url/norvig.com/ipython/TSPv3.ipynb) was his first publicly released notebook, not long ago. We've had some great discussions about IPython where he's given us very solid and detailed feedback, and in a few months we're running together a workshop on [Teaching Computing with the IPython Notebook](https://www.openconf.org/sigcse2014/modules/request.php?module=oc_program&amp;action=summary.php&amp;id=1150&amp;OPENCONF=m7e35b85mu703fk3169roskrn7), together with Greg Wilson from [Software Carpentry](http://software-carpentry.org/blog/2013/11/sigcse-workshop.html) (and who deserves all the credit for putting the workshop together). But yes, we're obviously thrilled to see him making such good use of the tool, that's the kind of validation that no marketing can buy you.
asyncio is a big deal, but not very convenient for users. do you know libraries sitting on top of it? i’ve collected what i know [here](http://www.reddit.com/r/Python/comments/1um4vg/asyncio_libraries/)
I believe xlsxwriter is Python 3 compatible though.
grep isn't helpful when someone put "print x" inside a loop that's parsing some file contents.
Oh yeah, we certainly use the logging module now, but we did not always (before I started). Trying to make our logfiles more useful by cutting out committed debug crap is what prompted me to find this solution. We have lots of python files with some old bad habits still in them, such as this print usage and commented out code (that's what version control is for).
for my company rhel6 shipped with python 2.6.5. we have a deploy system that allows the install additional versions as needed but /usr/bin/python must always be associated for 2.6.5 due to yums dependency on it. As we upgrade so will our codebase. 
i asked in another thread somewhere and didnt get a good response, you seem more informed. Can you tell me why i should consider looking into asyncio ? I use twisted extensively in a lot of projects and its seems to do everything asyncio does and more (factory for every network protocal you can think of for example). However im not married to it, i just need a real reason to look it. 
what exactly are you missing from `bytes`’ interface that `str` has? imho, `bytes` behaves stringly enough for all intents and purposes.
asyncio is new, and meant to 1. provide an unified interface to all the event loops out there (Qt, GTK, libuv, libev, …) 2. provide facilities on top of those that can be used for event-driven programming (futures, protocols, transports, …) since it’s in the stdlib, i think it’s a good idea to base code on it, provided it can do what you want. this post is exactly about your issue: as of now, the 3rd party alternatives have more features and convenience functions, and i’m looking for libs closing the gap. i definitely like asyncio’s API better than twisted’s, and with the right lib it would be much more expressive. but ATM, the boilerplate to actually do e.g. a HTTP request with asyncio is definitely higher.
[Autobahn](https://github.com/tavendo/AutobahnPython), a websocket library. [websockets](https://github.com/aaugustin/websockets) another one.
I just don't even know where you'd get a secure copy of 2.3 for testing purposes; that is some seriously old code. In any case, props to you.
&gt; the move to python 3 broke lot of shit in Arch That was the fault of Arch
I just send you an issue using github about the filename for the save file ;)
*for my specific definition of wrong
Well, instead of "file contents", instead think of arbitrary data, such as from a client's request or from the database. Now imagine you have a python webserver with over 1000 py files, and you notice that a certain action in your browser causes seemingly arbitrary strings to print out every time. It is a non-trivial task to discover which print statement is actually causing these to occur when you're talking about heaps of code, especially when that code was inherited and you aren't the one who wrote it. For instance, say that every time you load a particular page in the browser, a seemingly arbitrary customer's phone number gets printed to the console. You can't grep the codebase for their phone number as it is obviously not in there, it's from the database.
great! seems like there isn’t much general-purpose code besides aiohttp yet.
I just wrote a blog entry about this yesterday: http://blog.startifact.com/posts/python-2-gravity.html 
Exactly
That's not true. A lot of new std library stuff in 2.7 is from the 3 series; there's ports of the builtins in the standard library; and other libraries are being backported and available separately.
For starters, templating. Regexes would be nice too.
I'm the current owner of the site. It was originally created by Brandon Hsiao. Let me know what you think either here or in the /r/robotgame subreddit. The git repo for the game engine is available here: https://github.com/WhiteHalmos/rgkit
This is one of the biggest issues. When you're running your application in a corporate datacenter with 2000+ servers its hard to get the NOC folks to upgrade (and keep upgraded) the Python installs on 50 specific app servers. We were running Python 2.4 because we had such an old version of Novell SuSE running our application up until about a year ago. As it is now, we're on a RHEL6 derivative and we too are stuck on Python 2.6.5. Trying to maintain 2 versions alongside one another was deemed as something that would take too much time by our (truly overworked) NOC Sys Admins so we're stuck on 2.6.5 for until it gets an upgrade.
Not honoring the descriptor protocol is bad form, I'd say. Frankly, I don't care about "getting the source code", but the point about descriptors seems imminently fair.
Fellow Noob here, so take my thoughts for what they are worth: I'm "learning-by-doing" aka building my app as a means of teaching myself Python. When I was starting out, I happily jumped in with both feet to use (at the time) Python 3.2. I mean, why wouldn't you want to use the newest/best version? amirite? After setting up my IDE (Eclipse) and interpreter, I ran through some basics, and began the process of importing the libraries that I would be using. It took me less than 24 hours to completely switch to 2.7. I read this debate often now through this lens. If you want to be sure you can build something easily as a beginner, and have thousands of great libs to draw from, use 2.7. If you want to be on the cutting edge, use 3.3. If you are comitted to learning, it will be VERY educational for you to try and forward-port any libs that you need? Sorry for the long rant, but I cannot begin to fully explain how frustrating, confusing and disheartening it was to go through this on my own. 
Has it finished?
I loved P-ROBOTS as a kid, but hated Pascal. Glad to see a Python version up and running. I'm looking forward to putting together a few bots. Thanks for publishing this!
Cost/benefit ratio of moving to Python3 is too damn high.
The victory conditions aren't explicitly stated in the game rules or any other page (or I'm just incredibly stupid).
Sorry, this argumentation is really a reason for me to abandon my stackless 2.8 effort. We are trying to solve a problem, not minor taste musings. How distracting. We will support people who want to make the transition, but cannot for some other reasons. Laziness or inflexibility have a negative score...
You see, you turning things around. The whole argument was why Python uses unicode for filenames. I believe I answered that - you don't want to place limits on the language, where many different filesystems actually do support unicode. Linux supports unicode as well through use of UTF-8 encoding (which works because it is backward compatible with ASCII), but it would be much more robust if it actually had the notion of character encoding.
Maybe you shouldn't be putting useless prints everywhere and should be using some sort of logging helper module instead? Uh, duh...
I just have to say thanks for this. I have been banging my head on the wall trying to get this to work and for the life of me could not figure out why it wouldn't. Even had pip and easy install installed but every time I tried to run it in cmd it refused to work. Turns out I had to type out the full path since cd wasn't redirecting me to C:\ and instead was directing to C:\users Thanks for helping a newb out. 
Filenames as unicode are an abstraction that is leaking and breaking on one of the most popular OS. Filesystems are not always well encoded and the old API accounted for that. In a magic fairy dream world, we can assume that file names are properly, but the reality is much harsher. Did you ever do any non-personal admin work? Stuff is broken. My tools need to be able to handle that.
So by decorating that function with a class you can just call the function without any arguments passed on? This works in all versions of Python? 
Upvote this for the brazenness. 
What does brazenness mean?
oh, a psion could certainly wear mail. it just gives you options for the late game so a wizard doesn't have to wear platemail and sound ridiculous XD
&gt; brazen Boldness, without shame.
OK, interesting.
* given that p=17 and g=12 assume that Alice chose a secret a=5 and Bob chose a secret b=7 what are the messages that they exchange ( x, y ) and what is their common secret in the end of the algorithm * given that p=643 and g 417 Eve eavesdropped on Bob's and Alice's communications and found that the message that Alice sent bob was x=211 and the message that Bob sent to Alice was Y=192 , help Eve find Alice's private secret ( use the function we saw in class ) and bob's and Alice's common secret * right or wrong ( explanation needed ) if we find out that P=NP then in that moment we an effective solution ( in a polynomial run) to the traveling agent problem ,explain . *^ if it finds out that the traveling agent problem in P then P=NP * in class we discussed about the decision Problem " can a graph be legally colored in K colors ? " and also the problem of " find a legal coloring of a graph in K colors , if it can be done " , which problem is harder in general ? what solution of which of the two problems is also in fact the solution for the other problem ? explain * explain the following claim - if we had the solution for the " stop for each input " ( probably a very bad translation ) we could decide if the Collatz hypothesis is right or wrong 
just did 
That graph is a relief to see.
If you have the same number of robots, it is a tie. No consideration for hp sum. :)
Glad you like it!
just 5$ if you really want it , i'd assume it will take about 10 minutes for someone that knows his way around it so i think it's fair .. 
LOLZ
It is no longer getting features. Separate packages are different.
do not spam, please. You repeated your post twice: http://www.reddit.com/r/Python/comments/1un621/i_know_this_is_a_bit_wrong_but_can_anyone_do_my/
That's a distinction without much of a difference. 
How does this play with Pandas? That's the de facto standard for dealing with timeseries in Python.
Maybe I'm stupid but I think there's an actual do my homework for me subreddit
[Wasn't me](http://www.youtube.com/watch?v=2g5Hz17C4is&amp;feature=youtu.be&amp;t=1m5s)
Here his take on this. https://groups.google.com/forum/#!msg/python-tulip/yNHO54b5vSk/5etUiVxDsI8J
The interpreter is not getting new features, like SNI support or yield from. Anything desirable that can be a module is already there.
&gt; you should definitely have advantages by using 3, Like the advantage that you have to very carefully set your environment variables, so that encodings work properly?
No absolutely not. The only thing that would accomplish is to draw out the transition phase even longer. 
I really wonder where this recent flurry of posts (with the same old arguments we had when Python 3 was first proposed, released) is coming from. Is it the 5 year anniversary since 3.0? So what's the big deal? It will take a few years more. It's not as if anyone is dying because switching to Python 3 takes a bit more time. And one other thing: look at the number of libraries that are already ported. A year or two ago almost nothing big had been ready. Now almost everything I'm using day-to-day is either already done or in the last stages of being ported.
Webfaction is known as a good and inexpensive Python friendly webhost
This is the result of a couple major changes I made to the algorithms, particularly how the combat module processes skills and also to the attributes of the Character object, in an attempt to streamline. I'm actually still propagating all the changes through to the various modules, which is taking a while since I'm also running pylint at the same time to clean up the code. I'll let you know when everything is up and running again.
A lot of people say that ruby is really fun to program in, but every time I try to pick it up I'm immediately stumped with it's weird block syntax. I might just need a better source for learning. I also heard it's really dang slow, unless they managed to improve it's speed as of late?
Nice. Similar to the now (apparantly) disfunct AI Challenge. However I find the restrictions (300ms per turn and quite a few disabled modules) a bit overbearing. IMHO with today's technologies (automatic provisioning of VMs, docker.io, etc) it's really not nessecary to be this strict.
Meh. It's portable without interpreter changes, which was my point.
Arbitrary binary strings, like URIs. Unicode does theoretically cover every character but in practice it has a number of problems and there's inconsistency between implementations that makes it problematic for some tasks. I don't want to get into flamewars because some people seem to take Unicode very personally (?!? I have no f***** idea why). Long story short I wouldn't make a Unicode implementation my one and only basic string type if I were to implement a scripting language. There should be a lower level string at the core.
I'm still not seeing the issue. Strings are sequences of characters. Using Unicode as the internal storage for those characters doesn't preclude you from using a byte array, does it? Every 'binary string' is just a series of bytes that are meaningless without the context of a specific encoding. You can try to assume you know the encoding, but that's a bad way to work. If you say that all textual data is Unicode and that to get a specific encoding you have to covert to/from byte arrays, how is that confusing at all? It seems less confusing to me. Again, we are talking about two things. Strings of characters and arrays of bytes. Just because a byte array happens to be a single-byte encoding of a character string should not make the array a string. Character string processing and byte array processing, while conceptually similar, are not equal. Thoughts like that are why text processing is so jacked up in the first place. - on a phone, please forgive any mistakes EDIT: Minor changes for clarity
BTW, I don't take Unicode personally and certainly don't care enough for a flame war on the subject. A friendly discussion I can handle. :) OTOH, I have spent a significant amount of time working with I18n and have come to appreciate Unicode on a whole new level.
I'd love to see an analyses of what it would take to port Twisted to asyncio
I work very frequently on code related to encodings and Unicode is very often a pain. Not because the spec itself, but because it's a moving target and there are many different implementations. Then there are a number of issues stemming from the different conversions to and from other encodings, that are unavoidable because Unicode is not a native binary type. It's not meant to be a vehicle to convert binary strings or anything of the sort. In these situations not having a "first class byte string" will hurt. The bigger issue with Python 3 in this respect seems to be that there isn't and won't be string formatting for bytes. That makes working on the byte level very unwieldly. Not the end of the world, there will likely be binary extensions to make up for this fact, but this is not exactly ideal.
homepage -&gt; Error when calling the metaclass bases function() argument 1 must be code, not str 
Minor taste musings? This shit is a repeated distraction that comes up everytime I need to switch between languages. Removing the unnecessary cases between each language is nice. I've dropped using R because of all the weirdness. For a language that prides itself on simplicity and convention, python seems to love introducing strange special cases. Keep in mind python is a language built on having 'beautiful code' so they were asking for users that give a shit about taste. 
Also its a good security approach to keep debug to false. letting a possible attacker to know what technologies/versions you use he may be able to pick vulnerabilities on them. 
&gt;A lot of people say that ruby is really fun to program in Programming in Python is also a lot of fun to me. I don't know Ruby, so I don't know what is "more fun" in Ruby...
I don't know enough to answer your question, but AFAICT functions are first class in Python, while objects are first class in ruby, leading to different programming styles and idioms. You can code functionally, OO, or imperatively in either language, though. Inheritance made more sense to me as a beginner in ruby compared to Python. I do use and like both, however. 
I have a few honest questions and I'm not trying to argue. :) When you say 'moving target' and 'different implementations', what do you mean exactly? I understand the assigned code points change via additions over time, but what other moving target is there? As far as implementation differences, as long as the internal storage of the characters is abstracted, what problems do you encounter? Why is dealing with a byte array not a suitable replacement for a 'binary string'? I understand that conversion from Unicode to a specific encoding can be a pain in certain cases where Unicode characters have no analog in the specific encoding or there is ambiguity about certain characters, but conversion from any encoding into Unicode should be straight forward, right? My questions stem from my understanding that transmission and storage of character data is done as an encoded byte stream while working with character data in the program is (or should be) done as Unicode characters (code points?). The internal format of the Unicode characters in memory should be irrelevant as long as your program can encode those characters to a byte stream using some specified encoding scheme. Likewise, if a byte stream is an encoded character string, then as long as you can decode the bytes to characters, you should be able to store it internally as Unicode. I guess I just don't get why people have a problem with un-encoded strings being stored in memory as Unicode characters (code points) and encoded strings being stored as bytes.
Framework after framework makes this error. This is 2014, the idea that your serious developers are building applications that are not putting private information behind authentication is so unlikely that you'd probably hit a larger audience by including Netscape Navigator support. This means that authentication needs to be required *by default*. It only takes one slip-up to forget to put a permission= or whatever and suddenly that endpoint is wide open to the world. Every single endpoint should be required to state its accessibility or be unreachable. Some things need to be public, but in that case the developer should be required to state permission=Public or whatever. Frameworks need to be protecting developers and their users from simple screwups that could betray private information. 
The overbearing pitfall with articles like these is that they fail to mention that when you are forced to mock your implementation in your tests to this level it makes the refactoring step of "red green refactor" much more difficult than if the developer had tested at a higher level. I find that having a "functionality of code that I'm integrating with is not my problem" is an immature approach that only screams to everyone that you have yet to face the pain of an integrated service suddenly changing up something on you... or worse yet... not even be available. These are great tests to have and wind up being much easier to understand than watching all sorts of web service or system calls being stubbed out into the black hole of mock. Mocks definitely have their place in software... especially in the case of an integration environment not being available and yes they are faster, but the benefit of running your test suite in 20 sec vs 2 minutes is minuscule when you are faced with a large scale refactor that fails all of your mock tests because you moved how some methods were called... rather than asserting the core functionality of the test case has remained the same.
Thank you for confirming my initial impression.
&gt; but AFAICT functions are first class in Python, while objects are first class in ruby I don't think that's true. but if you are trying to say that python likes functions where ruby likes big ass objects(1 billion methods), I can agree with that. at least as far as rails is concerned. 
I did say I inherited this codebase, right? I'll go ahead and tell my two bosses they wrote bad code, it's been a while since I reminded them why they hired me. ;)
Yeah, but I've come to some weird problems when using python. It's package manager is also kind of bordering terrible.
&gt; There are parts of Python that drive me crazy, such as… list.sort not returning a value `l.sort()` doesn't return a value because mutators in Python return `None`. If you want an unmutated list use `sorted(l)`. This is a very important Python convention to understand.
Why do you not like pip?
The problem is nobody is transitioning production code to Python 3. At least I don't know anyone willing do do so, nor do any have any plans on doing so any time soon, if at all. There are a number of libraries that are making their code compatible with both Python 2 and 3 but even these projects do almost all there development and testing on Python 2 and just make sure it works on Python 3 just to be "nice". It would likely cost 10s of $billions for all projects to convert to Python 3 and there is not a compelling reason to do so. So most projects will never make the transition. A much better approach would be to release additional version of 2.x releases that moves closer to 3.x by obsoleting some old features and implementing new features that minimize the impact of the transition. When the cost of upgrading is small most projects are willing to make the transition as we have witness for more than a decade of Python 2 releases. I'm not one that is afraid of change and just being stubborn to upgrade my projects to Python 3. I'm just being practical as are the other 98% of us that use Python today in a production environment. When Python 2 came out I made the transition as there were real benefits and Python 1.x didn't have anywhere near the ecosystem that Python 2 has today so the transition was not that painful. We all like Python, but the reality is the language is not what is really important. Python 3 as a language is clearly better than Python 2. It's much cleaner and more consistent but what is more important is the ecosystem. Python 3's ecosystem barely exists and is growing slowly with absolutely no signs of improving in the near to mid term. Even the EOL of Python 2 has had no impact on the growth of Python 3's ecosystem. It's not that Python 3 has failed but it's ecosystem has failed to flourish.
Right idea, wrong terminology. In both Python and Ruby, functions are first-class objects, meaning they can be passed in and out of other functions freely. What you're getting at is the difference between the two object models. Attributes in Ruby are hidden, and methods are the only way of communicating with an object. Attributes can be exposed by creating accessor methods for them, usual with the attr\_accessor method shorthand. The opposite is true in Python, where everything on an object is an attribute (retrieved by calling \_\_getattr__), and the question is whether to call it or not if it's a function/method. With Ruby you get Uniform Access, with Python you avoid boilerplate. Edit: was bit by Markdown
Well, now is as good a time as any, isn't it?
This post acts as a gentle introduction to the pytest fixture mechanism by describing how it can solve the problem stated like this: * multiple tests exist in a file * some use a resource, some don't * module level fixtures don't work to set up a resource, * ... since you should be able to run one test without setting up resources that the test doesn't need. 
I don't really get why you'd care, though. You shouldn't really be calling `list.sort` when `sorted` is almost always only negligibly slower. Further, `sorted` works on all iterables and is hence far better an interface to use. Also, what's wrong with `len`?
If you've ever written JavaScript, think of a block like an anonymous function you might pass to another function like Array.forEach. With Array.forEach, the function is called for each item in the array, receiving the current item as the first argument, and its index in the array as the second. A Ruby block is just some instructions which are being executed in a scope, with some values in the scope being provided by the method the block is passed to, where the names assigned to those values are in between the pipe chars. The cool thing about this is that blocks can be executed in an object's internal scope, and that object's methods are callable as if they were regular functions in the scope. It's the reason Ruby is so well known for its ability to create DSLs, since what appear to be special syntactical constructs are really just regular old Ruby methods. You can do a similar thing in JavaScript using call/apply to change a function's context, but its nowhere near as neat as Ruby does it.
guido is awesome at explaining things. 
Pip's pretty awful. It's an improvement over easy_install, but removed some useful features. It has no dependency graph, so if you tell it to install from a requirements file it won't check if some of the packages listed later in the file are required for the package currently being installed. Also, missing binary distributions for things like numpy/scipy was a mistake, because those take quite a long time to compile unless you go through your system package manager, but you'll still be screwed when you tell virtualenv to ignore the system site packages. Compared to rubygems/bundler or npm, it's a world of hurt.
Just a note, it took me way too long to realize that rgkit is supposed to contain the rg module. You might want to move the installation instructions from /kit to /rgdocs. The way its worded and structured, it seems like rgkit is a testing framework or something and its never explained where to obtain the rg module.
For why someone would care, the issue is that it's just not intuitive, so it's like stubbing your toe when you switch back to Python from another language. Not that being intuitive is an absolute must in language design, especially when it conforms to the interface better, but you miss out on things like method chaining when it returns None. Though you could just wrap the whole expression in `sorted`, I guess.
Well, Alex Gaynor blogged about it, and that set off the conversation. I had hoped I'd brought up a different perspective with my gravity metaphor, but apparently you heard it all before, oh well! I think it's important to do a Python 2/3 community health check once every while. Your scenario that things are on the right track and that in a few more years this will all resolve itself is definitely a possible one. It's also possible that we'll see a scenario with a Python 3 community where new apps are built, and another large community still maintaining Python 2.7 apps and libraries. We can wonder whether this is desirable and what to do to avoid it if not. 
You don't need to waste time supporting python 3.x, nobody uses it.
python2 libraries keep being written.
Not true. It's also the users of libraries that deal with this crap. I've never tried to write an html parser or the like, but I keep getting stung. It's any web stuff at all really.
I look forward to reading the PEP, which will probably explain the workaround for strings that have spaces.
When I want results on python 2, I search for 'python'. I never want results on python 3
&gt; miss out on things like method chaining when it returns None. I don't really see why that's so popular. I actually prefer to write queryset = People.objects.get_men() queryset = queryset.get_tall_people() if blonde_only: queryset = queryset.get_blondes() return queryset most of the time to writing a chained version.
&gt; I'd love a situation where Python 3 was osx's default interpreter, then it'd so sooooo simple to setup my stack. No. Never use a system setup for anything real - half or more of the problem we have is people stuck on a particular vendor's idea of what is current (e.g. for RHEL its got to be at least 6 years old plus have enough requests to make it into their current distro) and that's why we're stuck supporting Python 2.4 and garbage like that, when ideally 2.7 was deprecated 5 years ago. Python makes it ridiculously easy to co-support multiple interpreters and versions, and your projects can reside in a virtualenv with the correct interpreter and dependencies it requires. Leave system-supplied tools to run system applications that required them. 
While its internally stored as bytes, accepted practice is to consistently use UTF-8. So you're both right and wrong. It would also be possible where downgrade to UTF-8 is unacceptable to simply use the byte encoding of the user's character set, so e.g. if they're using UTF-32 then call fopen() etc with the byte encoding of that. Once again - at the I/O edge between text strings and bytes, .encode() and .decode() as required. Edit: er, and I have to add, Linux is my platform of choice and I have never had any problem with system calls on *any* version of Python 3. I also do a lot on OSX which has a similar Unix interface, and have similarly had no issues in dealing with files. 
This is one of the few Ruby features that I think also should've been built into Python. Nice work.
 pip install future When you find something that doesn't work (e.g. configparser) then submit a pull request fixing it (or, at least, a bug report) (future is maintained on github) I am really happy someone decided to STFU and just get on with it, rather than whiners like this Armin guy simply waffle hot air and make no discernible effort to resolving his problems. If he was that interested in a Python 2.8, he would make it happen rather than essentially hand-wave and ask someone else to maintain it for him. 
You'd have to backslash escape to get multi-line method chaining working in Python if it worked at all, so it probably isn't worth it, but it's like piping a bunch of commands together in the shell. D3.js is a good example of method chaining constraining logic affecting a set of elements to a single section of code, but it also takes advantage of multi-line lambdas/anonymous functions which Python lacks. d3.selectAll('circle') .filter(function(datum) { return datum.sex === 'm'; }) .on('mouseover', function() { d3.select(this) // `this` is the element being hovered over .transition() // method calls now affect the transition object .duration(1000) .attr('r', 100); }); vs. # Completely imaginary d3.py code def grow_radius(datum, index, element): transition = d3.select(element).transition() transition.duration = 1000 transition.attrs['r] = 100 circles = d3.selectAll('circles') circles = filter(circles, lambda x: x.sex == 'm') circles.on(mouseevents.Over, grow_radius) You could say method chaining is idiomatic to JavaScript the way certain expressions are considered Pythonic. Edit: I am bad at Reddit Markdown
and no one will at this rate.
Thanks!
&gt; I had hoped I'd brought up a different perspective with my gravity metaphor, but apparently you heard it all before, oh well! It's certainly a very apt metaphor. I just don't see how your scenario (existing projects stay mainly on 2, new things are built in 3) is a bad thing. That's how the world works. Sooner or later the old projects will die off. Just think what happened to Microsofts browser market share because they wouldn't break with backwards compatibility. They're still trying to recover from that 4 major releases later.
&gt; while looking for other languages for new projects Why would they? It's certainly more difficult and expensive to switch to an entirely new language instead of a slightly different version of one you and your team already know.
 from collections import namedtuple TIA for the reddit gold ;-) 
Sounds like you need to convince somebody to move away from RHEL to a distro that's actually supported, like Ubuntu. 
It just seems like that because its human nature to whinge loud and strong when things aren't going your way, and just STFU when they are. So people who have already moved to Python 3 are enjoying it, while the recalcitrants stuck on Python 2 for whatever reason want to whinge loud and strong and hence appear larger than they really are. Just like in emergency services, you don't need to worry about the people whinging the most - they're ok - ignore them. Also, as is common on the internet, its really easy to whinge but not so easy to actually do any work. So when it comes to porting a library, or maintaining a Python 2.8, there's significantly fewer people willing to do that than they are whingers that it hasn't been done already. Its almost embarrasing really, given that its so-called developers whinging about an open-source library so they should be smart enough as well as empowered to help rather than just whinge - but what can I say? Human nature. Nothing stops you from using either or both, so just go with whatever works for you. Python 2 is the past, Python 3 is the present and future, hope that clears things up. 
&gt; I'm wondering how painful it will be to start Python 3 and then (maybe) have to abandon and re-write either in polygot or back to Python 2 if I run into a library requirement (I've not yet foreseen) somewhere down the road! Extremely non-painful. Unless you're using python 3 only features on purpose, its very easy to write code that works on both. I'd recommend writing version-agnostic code (really, NOT HARD) and sticking with python 3 until you come across something that requires 2. If so, just switch back until you see it has been ported. 
Can you point out where encodings don't work properly in python 3 code? Or is this just more "arg, I can't confuse binary and unicode strings any more!"?
Is it just me who finds the Python version easier to read? I'll give you that it's longer. --- Additionally, I heard the upcoming "hip" style would be to use `yield from` instead of callbacks. A more faithful translation (aka. one that fit Python) would then be: circles = d3.selectAll('circles') circles = d3.select(x for x in circles if x.sex == 'm') event = yield from circles.on(mouseevents.over) d3.select(event.element).transition(duration=1000, attrs={"r": 100}) Disclosure: I don't actually know if this is accurate to `asyncio`
&gt; the issue is that it's just not intuitive, It's intuitive, but just not like the rest of languages.
&gt; The problem is nobody is transitioning production code to Python 3 Because production code almost always uses a lot of 3rd party libraries, and if every single one doesn't run 3, the version chosen will be 2. The number of 3rd party libraries at version three isn't at critical mass yet for this to happen. &gt; Python 3's ecosystem barely exists and is growing slowly with absolutely no signs of improving in the near to mid term. Ahhh, no. As of this and last year I'd say library support is growing exponentially.
I don't like Ruby, even though I know it's a very powerful language. But I found your (/u/reuvenlerner) write-up really fun, nice analogy!
If you don't know you need it, you probably don't. The idea is a library like Twisted would use asyncio rather than implement its own event loop. So as a Twisted user, you would continue to use Twisted. If you were a Twisted maintainer, though, you would consider migrating to asyncio rather than your home-grown solution. There's a ton of libraries implementing an event-driven framework, and all of them end up having to re-solve this problem (in their own way) so now, in Python 3.4, they can spend less time with that and more doing whatever their library was actually meant to do. 
this is the type of the answer i was looking for. Ever since the announcement of asyncio, people have been saying stop using gevent/twisted/your event driven choice and use this its way better. However the only defining answer ive gotten was 'it a stdlib'. If i dont care about writting an recipe or running pip.. that doesnt help me much.
have an upvote for an informative reply. 
Everyone seems to be talking as if there's some sort of time limit to transitioning to Python 3. As if, if everyone isn't running it by April the whole thing will have been for nought. This isn't Windows XP guys! There's no massive rush! We're not in a hurry, never have been! As soon as a critical mass of libraries support python 3 there will be a lot more uptake on user-side applications. Even though everyone likes to live in a world of instant-gratification where things happen fast, this process is not one of them, and you shouldn't suddenly expect to be; it was never designed to be. PHP moved from 4 -&gt; 5 in much the same gradual manner, and I've never seen any massive outcry over poor 4 users left out. Everyone was eventually happier for it.
You can also wrap Python lines in `()` instead of ending with `\`, like circles = (d3.selectAll('circles') .filter(lambda x: x.sex == 'm') .on(mouseover, grow_radius) )
I don't see the issue here... Some things you just have to learn by experience, and how to write good tests is one of them. If this article helps people write tests for code that they wouldn't be able to/wouldn't want to test by other means then I think it's a win.
Parsing web documents, like I said.
Good point! If I would have written one more paragraph in my response it would have echoed very similar sentiments.
Updated the first paragraph, let me know if it's clearer now: http://robotgame.net/kit
The disabled modules are for security reasons. Currently CPU is a bottleneck, so the turn time limits are there to ensure game complete in a reasonable amount of time and that it's fair to everyone else who's waiting to have their bot play. Unfortunately with these limits the new virtualization and deployment techniques are not of much help.
Thank you for posting this. I love this type of thing. I'm also pretty rusty at what little python I know so this should help.
Thanks for the heads up. Set debug to false, seems site is a lot faster now. :)
Right. This was my point in the posting. It's not *wrong* to have a builtin len() function, rather than a len() method on each object. It's just not what I would have expected or preferred. 
I can assure you, after having taught Python to at least two groups each month for the last four years, that most people find it rather un-intuitive.
Thanks!
Support for Python 3 is growing but it is growing at a much slower rate than Python 2. Not that this proves much but in the last 40 uploads to pypi * 34 packages only support Python 2 * 5 packages support both Python 2 &amp; 3 * 1 supports Python 3 * 97.5% support Python 2 * 15% support Python 3
I always forget this trick, thanks for reminding me.
If you're just learning, pythonanywhere is very nice.
Sometimes evolution requires changes. I don't like it at all. I change it. You can adapt yourself or your environment, it's your decision.
&gt; So people who have already moved to Python 3 are enjoying it, while the recalcitrants stuck on Python 2 for whatever reason want to whinge loud and strong and hence appear larger than they really are. This is not an accurate portrayal of the situation. Many of the "recalcitrants" on Python 2 have extremely large codebases that are in production and work, and they have new problems they need to solve every day. They can either (1) keep using the code that's already working and focus their energies on their new problems, or (2) invest a huge amount of time porting an existing, working code base, testing it for regressions, possibly helping to port a few other 3rd party libs that haven't yet made the switch to Python 3, and completely ignore their business's actual new problems of the day. Care to guess what people tend to go with? Consider: there are 3D rendering packages like Maya and Houdini that have built-in Python 2 interpreters. ALL of the scripts that graphic effects companies have built for those tools are written in Python 2. They could go and port all of those over, or they could actually go about making new movies. Another example: there are investment banks with extremely large Python 2 codebases and thousands of devs and hundreds of apps built on top of massive Python, C++, and Java codebases. Are those guys going to stop and port everything to Python 3? Why should they? Just to make people like you happy? It takes exceptionally narrow perspective to claim that the people who are staying with Python 2 are some kind of whiny minority. They are, by a very large margin, the silent majority.
This is really cool! We often backup older data to S3 as CSV or JSON files and sometimes you want to poke through it for something specific. While I don't want to seem ungrateful, the docs are a bit sparse. In lieu of that, I was curious about: 1. Is there any semblance of a query planner or even a way to hint it? IE: there is no reason to query *these* files because they are for yesterday, and I just asked for data today. 2. Can it do some really rudimentary map-reduce or threading to grab data in parallel (even something really cheap like concurrent gevent threads would be interesting)? 3. Any real world examples of things you've done with it? 4. Were you inspired by Facebook's Presto (http://prestodb.io/)? Your lib seems like it might be a faster/more lightweight way to play with the concept. I'm sure there are more interesting questions to ask, but I really dig this concept. If I had more time to give this would certainly be at the top of my list of things to contribute to!
maybe https://www.openshift.com/ is also interesting for you
&gt; Filesystems are not always well encoded and the old API accounted for that. I'm sorry, but I have to disagree. The old API (I'm assuming you're talking about Python 2) was actually responsible for causing in the first place. The new one actually respects LC_* variables and uses the encoding accordingly (my apologies for stating it is UTF-8, while that's most common it's possible to use something else). Also looks like the new behavior is what Java does (among other languages with full unicode support), and I understand that this might be not as convincing, even though no one complains about it, so another good example is that all base tools support LC_* settings. For example [here](http://superuser.com/questions/623066/how-can-i-make-ls-show-dotfiles-first-and-preserve-unicode-filenames) you can see how LC_COLLATE affects file ordering and LC_CTYPE encoding. &gt; In a magic fairy dream world, we can assume that file names are properly, but the reality is much harsher. That's why I fully support Python's decision about implementing it this way, because it makes it one less "application" that messes things up. &gt; Did you ever do any non-personal admin work? Stuff is broken. My tools need to be able to handle that. Yes, major part of my day time job involves working with Linux. I use Unix (not just Linux) for 19 years now. If I may ask, do you speak in language that contains characters that are not in ISO-8859-1 (a.k.a latin-1)? I think that could explain why you think the python 2 behavior as correct one.
Ruby gems and RVM are a whole level of pain on their own. 
It's already in the OP: &gt; if a string is a valid Python identifier, it doesn't need to be quoted I think the repercussions of this change would far outweigh the benefits, though.
Consider this a simpler alternative, that's focused on doing one thing and doing it well.
The moving targets can be classified in two big categories: - underlying implementation changes (codepoints can be represented in many ways under the hood. This is an advantage for versatility, but a problem if you rely on their representation - they are not meant for this, which is why a first class byte string is a good thing to have, for these instances when you need a "gold-standard", static binary representation - there are many uses for this, like for instance fast matching) - different representations of the same codepoints when converting to/from different encodings (like the EUC family for instance). There are many different tables and they change over time, both on their own and with the addition of more codepoints. You can check for instance the evolution of iconv tables over time, just to have a glimpse of it (and they are far from being the only ones). This leads to "fun stuff" like having the same string matching or not across a source text if they updated something at different moments. And strings looking exactly the same (same glyphs) but being binary different, in different moments. In text analytics this is a problem I come across often, it can completely mess results. Having versions and updates in an encoding is not a good thing for many uses. Most encodings stay completely static and manageable over decades. But that's a slightly tangential matter.
&gt; But given a lot of the targets are niches advocating everyone stick with Python 2 could you please explain that part? i didn’t get what you mean by “targets”…
the latter, of course. script files are per default utf-8, IO encoding is derived from the locale environment variable. if that mismatches the file’s encoding, you have to specify that. that’s pretty sane.
Thanks!
i said it in my other reply: its API is much nicer. e.g. [asyncio](https://github.com/feihong/tulip-talk/blob/master/examples/2-tulip-download.py) vs [twisted](https://github.com/feihong/tulip-talk/blob/master/examples/4-twisted-download-inline-callbacks.py). (note that asyncio doesn’t contain that http module anymore which is a shame) also the basic async building blocks (Futures, Tasks, …) are in the stdlib, so if you want to base a bigger framework on top of asyncio, you’d want to reuse those instead of rolling your own versions with slightly different, incompatible APIs.
No, if twisted were to come to python 3, it would definitely be something that could be written *on top of* asyncio, rather than trying to replace it.
The fact that people currently use workarounds using ``split()`` shows there is a problem to solve. For [example](http://nbviewer.ipython.org/url/norvig.com/ipython/xkcd1313.ipynb) consider this line: ``` boys = set('jacob mason ethan noah william liam jayden michael alexander aiden'.split()) ``` Which could be replaced by: ``` boys = ${jacob mason ethan noah william liam jayden michael alexander aiden} ``` Which is not only shorter, it's more flexible because you can have sets whose members aren't strings, e.g. ``${foo bar 2 3}`` which you can't do with the ``split()`` version.
Soooo.... what happens when I actually need to use the coding directive for what it was actually intended for? I have to choose between utf-8 and interpy?
Or consider Django, whose configuration often uses tuples of strings such as: ``` list_display = ('__unicode__', 'user', 'name', 'foo', 'bar', 'baz) ``` Which could be shortened to: ``` list_display = $(__unicode__ user name foo bar baz) ``` 
&gt; if a string is a valid Python identifier, it doesn't need to be quoted Actually, this needs modifying, because the strings ``"True"``, ``"False"``, and ``"None"`` will still need quotes.
&gt; you'll have two ways of writing the same thing Like ``"foo" 'foo' """foo""" '''foo'''`` etc? &gt; At least in my case I rather write more if that would make it more readable So would I. I think this is more readable.
.. what? I guess you could generate a singleton with namedtuple, but the behaviour isn't really adequate (comparison is too liberal, etc)
&gt; The length of a string should equal the number of characters in that string. Well, no. If the point is to work with bytes, you'd expect the number of bytes. You're literally trying to identify imaginary problems. 
&gt; The disabled modules are for security reasons. Yes thats mostly what I meant. If every match would run in, for example, a newly started docker container, or a vm with snapshotted hard disk there wouldn't be much need for disabled modules. &gt; Currently CPU is a bottleneck, so the turn time limits are there to ensure game complete in a reasonable amount of time Ok that makes sense. Have you considered asking for sponsored hardware? 
Well, I'll quote my own article: &gt; But those existing Python 2 codebases are the ones with business &gt; value to people. Those are the codebases with the bosses and &gt; customers who want new functionality, not a port to a new version &gt; of Python that involves an effort with no near-future benefits and the &gt; potential to introduce bugs. Those are the codebases with the money. If this is true, does the Python community want to risk leaving the people with the money behind? Perhaps it's okay -- perhaps the money will be there for new developments and those left on 2.x maintaining it will be happy. Perhaps not. We don't know. It's a risk that the Python community is running. Do we want to do something about mitigating that risk, or not? Your comparison with Microsoft's browser market share really mystifies me. Browsers generally strive to *preserve* backwards compatibility. HTML and JavaScript try hard to be backwards compatible. What dented MS's market share probably had more to do with usability (say, tabs), performance and the absence of *new* features. They stopped doing browser development for years after IE 6 in 2001, and then had to pick up the pieces again before they could release IE 7 in 2006. Meanwhile Firefox had come along. 
Look at this: http://bugs.python.org/issue8610 http://serverfault.com/questions/280150/python-encoding-problem http://lucumr.pocoo.org/2011/12/7/thoughts-on-python3/ http://stackoverflow.com/questions/18260859/python3-ascii-utf-8-iso-8859-1-cant-decode-byte-0xe5-swedish-characters
Look at this: http://bugs.python.org/issue8610 http://serverfault.com/questions/280150/python-encoding-problem http://lucumr.pocoo.org/2011/12/7/thoughts-on-python3/ http://stackoverflow.com/questions/18260859/python3-ascii-utf-8-iso-8859-1-cant-decode-byte-0xe5-swedish-characters
&gt; It's a problem when you know over 100 developers who are heavy users of Python who will not use Python 3 in production. Many of them follow very closely developments in Python 3 and are willing to add support for Python 3 in the libraries they maintain but refuse to take the chance when their reputation will be on the line. Well if that is your experience then I can't argue with it. However I think this is like everything else in programming, you constantly need to refine your skills, so I personally don't see switching to 3 in a "real" project as a huge leap. 
&gt; If this is true, does the Python community want to risk leaving the people with the money behind? It's certainly a risk. But the question is: Would they upgrade if 3.x were backwards compatible? Just look how many of those "money" projects are stuck on some ancient version of RHEL with Python 2.4. &gt; Your comparison with Microsoft's browser market share really mystifies me. To be honest I can't really reconstruct my internal arguments from last night when I wrote it.
Suggestion: Replace #{expr} with \\{expr}. Escape of character that are not currently defined as escape sequences is reserved for future extensions (such as this one). This way you won't break existing code that contains the valid sequence "#{". P.S. I already proposed this around 2003 (as a modification to the language, not as a source encoding hack)
I've been on plenty of long term Python projects that did upgrade to newer versions of Python, but you're right that there are enough examples of projects that don't. Those non-upgrading projects may often be the ones not being invested in so much, though, so it is often a "if it ain't broke don't fix it" situation. The ones being invested in would be the ones more risky to lose. Of course backwards compatibility means that many *libraries* may continue support for older versions for a while too.
Wonder if the flushing is not a bit too aggressive here.
This has nothing to do with refining skills but being able to recognize failure and doing something about it before its too late. I see the Python community getting splintered over this issue, productivity going down, libraries becoming increasingly less Pythonic as they try to support both Python 2 &amp; 3, and there is a lack of focus on resolving other important issues as so much energy is put into providing support for Python 3. If there were some real tangible benefits it may be worth the effort but its a lot of effort for so little gain and maybe some would even argue a step backwards. Many of us, myself included, wanted to see Python 3 become successful. Many still hold hope that it will with a little more time. But the tide is changing and many in the community who had hope are starting to realize that failure is eminent. The writing is on the wall and the sooner we all stop denying it the quicker we can move in a better direction.
Sponsored hardware?
I love how clojure/lisp people say stuff like that with a straight face. You know that 1 and 2 are in conflict with each other right? Clojure is really cool in many ways but the syntax is clearly not one of them. You have no idea what (foo bar baz) means in clojure. Which of those symbols are lookup up at the point where the code is? You have no idea without looking into the source of every form that form is nested inside... fun times. 
What do you mean comparison is too liberal? &gt;&gt;&gt; from collections import namedtuple as enum &gt;&gt;&gt; colours = enum('Colours', ('red','yellow','green','blue','purple')) &gt;&gt;&gt; colours.red == colours.yellow False &gt;&gt;&gt; colours.blue == colours.blue True &gt;&gt;&gt; 0 &lt; colours.red &lt; 65535 Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: unorderable types: int() &lt; property() &gt;&gt;&gt; nuts = enum('Nuts', ('peanut','cashew','macadamia')) &gt;&gt;&gt; nuts.peanut == colours.red False 
All, I have created a /r/multiprocessing subreddit to discuss things similar to what is being presented in this forum. Give it a try if you are interested. Lots of topics related to multiprocessing are open for discussion.
Those have a purpose that is not just writing less. 
&gt; I see the Python community getting splintered over this issue Well I don't see this at all. From my perspective it's a (very) vocal minority that is unhappy with the current state and is raising a stink about it (and in the process may be causing this very fork in the community they are so worried about). But I suspect we can argue about this until we're both blue in the face as neither seems to be able to convince the other.
Doesn't support Python 3...? EDIT: Actually it tries to hook itself up in some way that, if you try to `pip install` it on Python 3, it breaks Python altogether. If you've done this yourself you can recover with the command `find your/site-lib/path/ -name '*interpy*' | xargs rm -rf`
Still a few issues perhaps. Time to make a new character! It'll be saved under this player name. It's time to generate a character! At any of the prompts below, enter 'random' (no quotes) to use a random choice. Available races: drow, dwarf, elf, gnome, halfling, human, orc Race&gt; orc Available classes: barbarian, bard, cleric, druid, fighter, monk, paladin, psion, ranger, rogue, samurai, wizard Class&gt; fighter Available feats: ImprovedInitiative, IronWill, LightningReflexes, PowerAttack, Prodigy, StoutDefense, Toughness Feat&gt; help Help topics: Armor, Characters, Combat, Dungeon, Enemies, Equipment, Puzzles, Quests, Stats, Town, Weapons; Exit to retu rn to game. Traceback (most recent call last): File "percivalsquest.py", line 238, in &lt;module&gt; main() File "percivalsquest.py", line 222, in main rpg_instance = generate(rpg_instance) File "percivalsquest.py", line 184, in generate rpg.character.chargen(rpg.player_name) File "C:\dev\PercivalsQuest\pq_characters.py", line 70, in chargen character=self, allowed=['sheet', 'help']) File "C:\dev\PercivalsQuest\pq_utilities.py", line 52, in choose_from_list allow_help, allow_equip) File "C:\dev\PercivalsQuest\pq_utilities.py", line 80, in get_user_input pq_help() File "C:\dev\PercivalsQuest\pq_utilities.py", line 102, in pq_help topic = choose_from_list("Help&gt; ", help_topics.keys() + ["Exit"]) File "C:\dev\PercivalsQuest\pq_utilities.py", line 47, in choose_from_list allowed = [i.lower() for i in allowed] TypeError: 'NoneType' object is not iterable 
I think I fixed the help system like so: def choose_from_list(prompt, options, rand = False, character = None, \ allowed = ['help']): But I'm still reviewing the code.
You probably should add some details about races and classes in the help.
Another issue: Town&gt; questhall You head to the Questhall. Traceback (most recent call last): File "percivalsquest.py", line 238, in &lt;module&gt; main() File "percivalsquest.py", line 235, in main town(rpg_instance) File "percivalsquest.py", line 60, in town rpg.questhall() File "C:\dev\PercivalsQuest\pq_rpg.py", line 128, in questhall "You're a True Hero, " + self.character.name + "!'" + color.END TypeError: cannot concatenate 'str' and 'list' objects 
I'm not sure if I want the "entire world to look like an SQL database" or the exact opposite. Either way it's pretty awesome that we have the option.
I'm so sorry about that. I will work until this problem is solved. EDIT: I've uploaded a new version of the package on pypi and Github with full compatibility for Python 3.
I don't speak a language that contains characters that are not in latin1, but I had the pleasure to write code that needed to handle file paths in a UTF-8 filesystem that were actually latin1 encoded (or in one of those obscure ones I don't even remember). I did this in perl [2] which handled all of that pretty gracefully and allowed me to clean up this mess. What I did was, that I tried a few different encoding and guessed which probably is the correct one for this file and filepath, then I renamed the file to a UTF-8 encoded filename and fixed the references. In Python3, interfaces like os.listdir silently fall back to bytes instead of str in case of decoding errors [1]. So now, instead of handling one type, the old Python2 str, you get a mix of unicode Python3 strings and bytes. This leads to a weird situation: &gt; Since listdir() mix bytes and unicode, you are not able to manipulate easily filenames The old way of a "heavy" byte string handled this one much better. I don't want the old Python2 behavior back, but I want a proper bytes type with support for encoding, formatting, etc that is used in the proper places, like filenames. Often I can just ignore the differences between unicode strings and byte strings and I want to be able to do exactly that. So in my opinion, a richer interface for the bytes-type and using it at the right places (everywhere where something can go wrong, at the borders of my program) would fix the situation. * [1] [UnicodeDecodeError](https://wiki.python.org/moin/Python3UnicodeDecodeError) * [2] Python2 would have been fine, but Perl has awesome packages for administrative work like this
&gt; So I was thinking about something else: a system that is loose when you develop, but where you can turn a knob and tighten security and let it complain about everything not guarded by a permission. That way leaving the permission off actually has a meaning in the system: I haven't thought about permissions yet. -&gt; Exactly what I had in mind ! 
It's *way* shorter. It looks pretty great for debugging crap. I love str.format, but this saves me ~10 characters for each debug line while no being a hideous hack. Sounds pretty cool to me.
Well I've got a MySQL dump and I have PG as my main RDBMS and I'd like to avoid having a second DB in the system. So far I totally failed at creating an efficient MySQL dump parser, thus the question.
No, the point is to work with bytes. That's why we're discussing byte strings.
&gt; the last one appears (from cursory reading) to be a problem with the guys terminal And...you don't use a terminal?
Because (a) latest is not always greatest; and (b) those libraries make people's code work. That code is in 2.7. Porting is not simple or easy, and it's not cheap.
I use a sane terminal that defaults to UTF-8
&gt; They are, by a very large margin, the silent majority. Actually, even in PSF-run surveys of the python dev mailing list, most people admit that they mostly code in python 2. 
Yum will run under 2.7 just fine.
You create a "dataset" and link it to datasources through "adapters". You can also add user defined functions and views to the datasource. Here's an example, using a slightly older version of Splicer what's called "Servers" has since been renamed to "Adapters" https://github.com/mozilla/caravela/blob/master/db.py You can then issue queries to the dataset and retrieve the results. &gt;&gt;&gt; query = ds.query("select * from sometable") &gt;&gt;&gt; for rec in query: ... print rec You can access the underlying query expression tree with &gt;&gt;&gt; query.operations You can manipulate the expression tree at compile time by creating an Adapter and giving it an evaluate() method. An example of that is here: https://github.com/trivio/splicer/blob/master/splicer/adapters/dir_adapter.py This example replaces the LoadOp() with a series of User Defined Function calls and rewrites SelectionOps (where clause) to be more efficient. For ultimate control you can call dataset.set_compiler(compile_function) and pass it a function that will be called with the expression tree after it's been parsed. Then it's up to the compile function to return a function which satisfies the query.
I believe the developer went on to help with the new [PyPI](https://preview-pypi.python.org/). I may be mistaken, but it has something to do with that.
BTW, if you want to you can implement this in Python. Check this project for guidance: https://github.com/dropbox/pyxl
I think you are right: https://preview-pypi.python.org/
ok. Let me rephrase. Nick recommended using encode and decode on the edges (as you quoted), and he said that that was acceptable because the performance in Python 3.3 was better than Python 3.2. It is only that part of the encode/decode that I was referring to, as I would certainly agree with you that it is is poor practice to avoid exceptions by oscillating between encode/decode (and I doubt Armin would be doing this). In the interest of charitable interpretation, I would think that Armin is arguing that it is this 'encode/decode at the edges' recommendation that is breaking down in his real-world usage, and it is just not comprehensively possible -- which leads to inconsistent APIs as demonstrated with the urlparse() function. I think he may also be arguing that encode/decode at the edges shouldn't be *required* (forced) for byte strings, just recommended as good practice, precisely because it isn't comprehensively possible, and pretending that it is just makes the problem worse. Certainly don't want to put words in his mouth, but that was the most charitable way I could interpret the argument. &gt; These calls are unfortunately necessarily expensive, so you want to do them as few times as possible. Have heard that, but how expensive? My original post was just asking for data to clear up what the true cost really is. Because the more expensive it is, the more Armin's case would be made that the recommended solution is impractical.
I cringe every time I hear someone say that they have **the** definition for "unit test". What is a "unit test"? It's a test that tests a "unit". So, what is a "unit"? Well, that's for you to decide. Reasonable answers: * one function/method * one class * one module * one piece of functionality * one user case 
Out of curiosity, what does she want to do with it? It's not every day you come across a 55-year-old woman who wants to learn how to program!
This looks awesome. Hopefully I can set aside some time to play with this.
yes, that works nicely.
yeah i noticed that one too, but i hadn't updated the repo yet. doing so in a couple minutes.
For some reason I didn't get an oranged (more likely I just missed it) so this is a bit late. Thanks :)
For some reason I didn't get an oranged (more likely I just missed it) so this is a bit late. Ooooh, I shall, thank you very much.
Looks like levelling up causes a crash: Dungeon&gt; explore You've stumbled on an enemy! It seems to be... a goblin! You get the jump on it. Attack, Doublestrike, Run Away, or Equip? Action&gt; attack A hit! A very palpable hit! You deal 2 damage. You have defeated the goblin! You receive 1 experience. In the monster's pockets, you find: 1 gp. Traceback (most recent call last): File "percivalsquest.py", line 238, in &lt;module&gt; main() File "percivalsquest.py", line 235, in main town(rpg_instance) File "percivalsquest.py", line 78, in town dungeon(rpg) File "percivalsquest.py", line 123, in dungeon deadchar(rpg) File "percivalsquest.py", line 173, in deadchar town(rpg) File "percivalsquest.py", line 78, in town dungeon(rpg) File "percivalsquest.py", line 121, in dungeon rpg.explore() File "C:\dev\PercivalsQuest\pq_rpg.py", line 228, in explore self.combat.advance_turn() File "C:\dev\PercivalsQuest\pq_combat.py", line 258, in advance_turn self.pc_turn() File "C:\dev\PercivalsQuest\pq_combat.py", line 203, in pc_turn self.attack_enemy(self.char, self.enemy) File "C:\dev\PercivalsQuest\pq_combat.py", line 95, in attack_enemy self.be_hit(target, hit) File "C:\dev\PercivalsQuest\pq_combat.py", line 66, in be_hit self.death(target) File "C:\dev\PercivalsQuest\pq_combat.py", line 82, in death self.win_combat() File "C:\dev\PercivalsQuest\pq_combat.py", line 159, in win_combat self.char.levelup() File "C:\dev\PercivalsQuest\pq_characters.py", line 153, in levelup self.level[0] -= self.level * 10 TypeError: unsupported operand type(s) for -=: 'int' and 'list'
we got errors everywhere when i tried to update in place. we do not do non rhel repo updates ether. 
Yeah, I've checked all (most?) of my library requirements and they are all Python 3 (apart from Boto, which I can probably work around). I need to keep supervisord &amp; fabric at 2 apparently (but they are separate processes, so it means different virtualenvs for them). I'll go the P3 approach and see what happens. Thanks!
whoops, got it. fixed.
She's a professor, and has always loved learning new things. She's interested in making some simple games, so I'm debating introducing her to pygame once she's got things figured out. She's logically minded, but always loves making up kids stories so I think she wants a more logical method to creating a story than simply writing them. I think she also recognizes programming as a powerful tool, and part of learning it is eventually learning what she can do with it.
The lines remain exactly the same. The only difference is instead of this code: # coding: interpy package = "Interpy" print("Enjoy #{package}!") You would have this one: # coding: interpy package = "Interpy" print("Enjoy "+str(package)+"!")
Something fishy happened here, I went up 5 levels. Action&gt; sheet Camrod Waerorla (Player: jgritty) Orc Ranger 2 Atk 8 Def 10 Ref 4 Frt 6 Mnd 5 Skl 4; hp 8/10; sp 6/6; exp 1/20 ImprovedInitiative, PowerAttack Skills: Doublestrike; Armor: Loincloth (0); Weapon: Cleaver (0); Ring: None 4 gp; loot: None Action&gt; attack A hit! A very palpable hit! You deal 1 damage. It tries to cause you bodily harm! The attack is unsuccessful. Attack, Doublestrike, Run Away, or Equip? Action&gt; attack A hit! A very palpable hit! You deal 4 damage. You have defeated the Itagheteic! You receive 1 experience. In the monster's pockets, you find: The Valiant Volusian. You're in the dank dark dungeon. What do you want to do? Options: Explore, Backtrack Dungeon&gt; backtrack You successfully find your way back to the beginning of the level. You're in the dank dark dungeon. What do you want to do? Options: Explore, Leave Dungeon&gt; leave You head back to town. Where would you like to go? Options: Home, Questhall, Shop, Shrine, or Dungeon [Level#] (max 1) Town&gt; home You hit the sack. Once you've annoyed allthe bedbugs with your ineffectual fists, you lay down and sleep. Where would you like to go? Options: Home, Questhall, Shop, Shrine, or Dungeon [Level#] (max 1) Town&gt; questhall You head to the Questhall. Mayor Percival looks up excitedly. 'You have it! Well, thank my lucky stars. You're a True Hero, Camrod Waerorla!' You gain 5 experience and 5 gp! Percival clears his throat hesitantly. 'Since I have you here, there... have been rumors of another problem in the dungeon. Teosas is its name. This small fiendish creature lairs in marshes. It lures its prey, which includes magical beasts, medium-sized creatures, and other predators. It attacks with piercing claws, noxious fumes, and grasping tentacles. It can easily be injured with heat. They travel in bands of 4-22. The source of its power is The High Francio, A pot that gifts the capacity to cure male impotence. Will you take this quest, same terms as last time (adjusting for inflation)? Yes? Wonderful! Now get out.' Where would you like to go? Options: Home, Questhall, Shop, Shrine, or Dungeon [Level#] (max 1) Town&gt; sheet Camrod Waerorla (Player: jgritty) Orc Ranger 7 Atk 8 Def 10 Ref 4 Frt 6 Mnd 5 Skl 4; hp 10/10; sp 6/6; exp 2/70 ImprovedInitiative, PowerAttack Skills: Doublestrike; Armor: Loincloth (0); Weapon: Cleaver (0); Ring: None 9 gp; loot: None 
Well, if you just upgraded the binary without the libraries, yes that would happen to any piece of code, not just Yum.
Would I be right in saying that this is basically a way to put your freezefile in a comment in your script? Is there any reason why this has to be python 3? 
Generally speaking, I used a shebang for my scripts that points to a virtualenv I have set up for that purpose. My dotfiles set it up and add a symlink to it at `/usr/local/bin/pyscript`. I do like that your tool automated the wrapping process, but I'm not sure the time savings would be outweighed by the less precise control of dependency versions.
The latter. It's not ambiguous -- 2 isn't a valid pythonidentifier, thus isn't converted to a string.
&gt; You don't litter code with magic and unintuitive symbols in python Well Lisp's syntax is a lot simpler than Python's an it's Lisp I got the idea from. &gt; How does the syntax $(spam) suggest at all that you're going to get ("spam",)? How does the syntax in Lisp ``(spam)`` suggest the same thing? Is Lisp's syntax too complicated, IYO? 
Cool. I wasn't aware of that.
Is there a way to define a coding hook without installing a module? I'm trying to define one in the `__init__.py` of my working directory and it's not being found on import. It's also behaving strangely when I define it in an ipython notebook. I see you used the .pth file to do the import. Is this the only way, or is there an easier, more interactive way to get it to work?
Thanks for posting. I'm quite enjoying this series of blog posts. 
I made a knock off of that program back in the day, when everyone and their dog was doing it. It's cool to see someone more educated doing a smarter version of it, although I have no freaking clue how it works or what any of the explanation means.
Interested to know as well.
I get the feeling you're not asking "how do I run pip?" but rather how to package up your own packages/repository in order to use conda to install these custom packages across your environment. This is documented over [here](http://conda.pydata.org/#building-your-own-packages) 
Oh, that's exactly what I was looking for, thanks.
just saw this in r/learnpython: http://www.reddit.com/r/learnpython/comments/1uqbal/thinkful_online_course_with_mentorship_for_python/cekur0h
Armin's problem (from what I've read in various sources) is that he has multi-encoded data (namely, HTTP). So its certainly not straightforward in his case to do the numpty job of executing .decode() on the entirety of the stream at one point. The complexity of this problem, which is actually with the HTTP protocol definition, is causing him angst &amp; he's choosing to direct this at Python 3 because earlier versions of Python let him ignore the problem altogether and pretend it wasn't there - which is really the root cause of all the Unicode issues &amp; why it was fixed in Python 3 in the first place by making this ignorance fire an exception. For too long, web development was allowed to ignore and subvert the internet standards, leading to the current situation where many developers don't even know what an RFC is, let alone have any desire to abide by it. The latter is complicated even more by interest groups making some RFC's impossible to abide by entirely (you have to pick &amp; choose which way you will go, as it is too liberal in some places in order for some commercial interest to be able to claim they're standards compliant even though their implementation is not interoperable with anything else, defeating the purpose of an internet standard). And yes, an RFC isn't a standard (yet) but its on the track. So its certainly not easy for him, but I believe his anger is misplaced and is only doing harm to the Python community by empowering a vocal minority to continue to hold back innovation for their own laziness/incompetence quoting articles like this as proof of their cause. Note Armin has a special case so a "comprehensive" solution is not even warranted. It certainly is possible, its just not easy - and in an era of the "now" generation engineering a good solution is going to evidently exhaust patience long before its produced. Its really easy to bitch and moan on reddit, or a blog, or post some damning by-line to twitter where its not even possible to formulate a coherent counter-argument due to character limitations or hivemind mentality squashing any non-conformist. Not so easy is being a Thomas Edison and finding that 10,000th way that light bulbs actually work, through effort and determination. 
yep, the mysql thing is bad. There are alternative libraries that seem experimental/not tested. I dont have the expertise to deal with errors, so I stick with 2.7 wich does the job. 
Usually, this isn't the right place for this. A job board is a better place. Also, make sure you provide more information. A vague post like this is likely to turn away a lot of people. They don't want to fish for information to find out if they're even able to help or not...
I didn't want to seem like I am "advertising." I've had nothing but bad experiences with job boards. I trust redditors much more. But here's the full info: The application in question is [Wepolls](http://www.wepolls.com). Here are the enhancements: 1. Improved spam filter. 1. Polls must be categorized (tagged) upon creation. 1. Polls cannot be created by anyone with less than 150 points that have less than two options. 1. Ability to have one poll follow another poll of their own creation (like a survey) for members with over 500 points. 1. Ability for admin to make a particular poll the "next poll." 1. Redesign Feed screen. Registered members should login and see their Feed, not the front page. They need to have the ability to subscribe to their favorite topics. People who are friends or who they follow should always appear in their profile. This should work pretty much like Reddit's custom front page. 1. Currently, if someone comments on a poll that a user a voted on, it shows that comment in the poll roll. This caused us to lose a ton of members, as they don't care about the comments. Add options to see comments from only your polls, or comments of friends and followers. Further, add ability to clear the queue of comments. 1. When a link is made in blurb or comment, make it appear like on Facebook, with the title and meda data. If the link is an image, auto embed it with a width of 350px with the ability drag to enlarge. 1. Add ability to hide polls and replace all characters with a single click for admins. Also hide custom tags and comments. 1. Add ability to ban users by both username and IP address. 1. Migrate from Google hosting to anywhere else. Mess around with the site, check out the blog and YouTube videos. Definitely the blog. Get familiar with the features, and quote me a firm price. Let me know if you have questions. 
Good point. For some reason I thought instances would be involved.
Ha! found it. I'll update the repo.
y u speak like idiot?
I was going to suggest just creating an rpm/deb package, and then adding it to a custom repo, but I guess I never heard of the anaconda environment before. So, not to hijack this thread, but what's the benefit of using anaconda package manager versus just creating custom OS level packages and then distributing them accordingly?
I was hoping the `__init__.py` would be run before the module file was read, but apparently it's not executed early enough in the import process to create a coding hook. Maybe it can still be done by having `__init__.py` first load a submodule defining the hook, then a submodule using it. edit: This works. The codec can be defined in `__init__.py` and the files using the encoding must be in a subdirectory, not just a file in the module directory. The init file can import that submodule after defining or importing the codec.
&gt; quote me a firm price. Just a heads up, most freelances bill by the hour. Agreeing to an upfront cost on a set of work is taking on a lot of risk, and incentivies cutting corners.
This won't help you for diskIO tasks. 
I think what is missing from asyncio is a simple decorator to allow non-asyncio aware code to call asyncio libraries without having to know anything about asyncio. 
Going backwards? Traceback (most recent call last): File "percivalsquest.py", line 29, in &lt;module&gt; import pq_rpg as pqr File "/Users/joshg/Dev/PercivalsQuest/pq_rpg.py", line 12, in &lt;module&gt; from pq_combat import PQ_Combat File "/Users/joshg/Dev/PercivalsQuest/pq_combat.py", line 11, in &lt;module&gt; from pq_skills import pq_skill_library as pqsl File "/Users/joshg/Dev/PercivalsQuest/pq_skills.py", line 331 print targstring + " with divine impetus!" ^ 
there's lots of buzzwords in that title. such SEO
&gt;&gt; Improved spam filter. &gt; LOL. We don't have automated spam. That's been outright prevented by using a simple honey pot. The scripts detect, and fill out, some hidden fields and those fields automatically prevent registration and posting. Once in a while, however, and it's becoming almost daily, a human will sign up and manually make 20 to 50 spam posts over the course of two or three hours. These are people who are paid a few cents per spam message. Aside from banning every one with an IP address originating from India, I don't know how to handle that. Here on Reddit I mod a sub called /r/Training, and I get 3-4 such posts a day. I am not sure how to prevent someone from manually registering and then spamming. It's a much smaller website than Reddit, so using timers and points might frustrate new users. Any thoughts? 
You are a spammer. Die in a fire. 
Here's what pops out at me as I look through the project: * The whole project could use a pep8 and pylint check. Indenting is off in your templates. Keyword/non-keyword style is interspersed. Overall style is poor. * You have models defined twice, once in app.py and once in a separate module. The dedicated module doesn't seem to be used. * Views should be broken out into their own module. * You are using WTForms but aren't checking CSRF tokens consistently. * Managing sessions is a pain, use Flask-Login instead. * Robots files and the like should be static, not templates. * No license file. * No tests. * Your google analytics identifier and URL is still in your layout template. That should be in a config file. * More seriously, your cookies can be trivially forged to impersonate another user. Flask-Login can fix this. I recommend reading Miguel Grinberg's [Flask tutorial](http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world) and rebuilding this after going through it.
Looks like someone's building a new Facebook?...
this man posted every point i was going to post. 
frameworks != buzzwords
I should document this, but the dependencies you specify are actually passed to pip, so you can pin versions. You can also give each script its own virtualenv with the '-e' argument, and manipulate the envs directly in ~/.manuscripts/envs .
that's like your opinion man.
Autobahn now also supports asyncio on Python 2! https://github.com/tavendo/AutobahnPython#python-support This is made possible by Trollius, an awesome backport of asyncio: https://pypi.python.org/pypi/trollius/0.1.2 
Want to share? I have a small project and use Yeoman with grunt to develop. You meant that yeoman uses grunt for the workflow right? And currently at work we are using Fabric to deploy our python apps. I'm always curious as to see how other people do it :)
Autobahn now also supports asyncio on Python 2! https://github.com/tavendo/AutobahnPython#python-support This is made possible by Trollius, an awesome backport of asyncio: https://pypi.python.org/pypi/trollius/0.1.2 
Although in this case those words do appear gratuitous. "My Grunt workflow" would be a fine title, since the particular frameworks used in the project are irrelevant to the article. 
Actual code. Have an upvote.
Yes openshift by red hat is great, have at look at this.
This is really cool. One suggestion is that it would be nice to be able to configure to different paths with environment variables. As you might already have a ~/bin folder you would like to reuse or may want to put the files in a XDG style with ~/.config, ~/.local/share, ~/.cache
That is an excellent suggestion. Added on the todolist. XDG path should even be the default (I don't know why put it that way to begin with).
the title of the article could have been better worded to describe what it is about IMO, which is "my full stack workflow", so given that, the rest of those words are there for SEO. 
this is exactly my point. 
i don’t think i like trollius: if you use it to create a bilingual python2/3 program, you have to skip the good parts of the syntax, since they are different in asyncio and trollius: ret = yield from some_coroutine() return ret vs. ret = yield some_coroutine() raise Return(ret) so if you want to use trollius to make your asyncio-based program python 2 compatible, you’ll have to make your code worse.
what do you mean? isn’t that loop = asyncio.get_event_loop() loop.run_until_complete(my_coroutine()) this calls something asynchronous syncronously.
TL;DR | Programming is hard and takes effort. We didn't think the value proposition of proper code maintenance was worth it in the beginning and now we are stuck with a beast of a source tree. We have also become so complacent with making money that we're scared of what could happen if we try something new and it does't work out perfectly the first time. 
&gt; Yep, put a freezeline in you script, so you can have a set of scripts that are only one file each. The twist is that it doesn't modify the original script, but creates a wrapper script that uses the virtualenv. Very cool. &gt; the version it's written in doesn't matter to the user. Well, if it were compatible with both, no user would have to install a new python just to use Manuscript. With respect, you'll probably see better adoption if you make it polyglot.
Can you tell which PID controller supports python? I want to program a electromechanical device but I have no idea which controller to choose
I'm not sure about PID controllers, but you may find [MicroPython](http://micropython.org/) interesting.
Google didn't help?
Sorry if this post is a bit harsh, but I'm fed up with the "death to python 3" mentality. There are a lot of good reasons to use python 2 instead of python 3, which have been stated in the recent discussions. Thus, there are people who need to code in python 2, and it's completely reasonable. However, pushing the war against python 3 to the point of not wanting to install it, and boycotting applications that use it is not reasonable. The goal of polyglot coding is to provide libraries that work both with 2 and 3. I'm not writing a library, and I'm not constraining anyone's code, so I won't inflict myself an extra maintenance burden so that people with ideological reasons can save a few dozen megs. 
I use Python for signal analysis, and since I knew it first I can't force myself to learn matlab well enough to make it compete. What Python really gives me is the ability to put together a script using libraries I've developed for parsing files and manipulating data, then easily generalize it to work on multiple files. I can crunch gigs worth of data in just a few minutes and spew it out in excel files so my coworkers can drop it into report templates easily. It's fast, easy to write, easy to read, and reusable, whereas I've always found matlab to just be fast. That's not to say matlab isn't useful, I just have a strong preference for Python when it comes to signal analysis. 
Exactly. We know why people aren't moving yet. We don't need everyone letting us know why. This P3 vs P2 is getting old fast.
[PEP8](http://www.python.org/dev/peps/pep-0008/) tells us n = 4
Thanks. I didn't even know these existed. Appreciate it.
I'm hardly advocating a boycott. The reality is that plenty of people won't want to deal with two versions, even if out of simple laziness. If you don't want to maximise uptake of your application, that's entirely your prerogative. Indeed, at the margin that kind of attitude may help python 3 adoption. It's your choice. Separately, I do think python 3 is a combination of great new features and some design mistakes. That's a separate issue. Even if it were purely great, you'd see better adoption with a polyglot version.
I'm surprised; your experience with complex enterprise code bases must be very different than mine. Concerning Eve Online, this was originally released in 2003. It's seen a bunch of expansions that change the game. It's a MMO. It's still around today. Do you really think that this could be accomplished without seeing the value of proper code maintenance? You must've had the luck or the skill to only work with enterprise codebases that are extremely well engineered. Or to work with businesses brave enough to be okay with losing money and customers because of bugs introduced during cleanups. How do you do this? Many of us would like to know. 
&gt; We have also become so complacent with making money that we're scared of what could happen if we try something new and it does't work out perfectly the first time. This is not how businesses think for systems that are their underlying bread and butter. If they do think this way, they fail.
I think getting some feedback from enterprise users is quite valuable. I think they're often ignored in this discussion, but I'm glad this is nothing new; that must've changed then. 
I've been using Octave for signal processing for the past year, but sometimes (but not too often) run into the problem that some functions aren't yet(?) implemented. I will also use Python sometimes, when the input file is a bit more complicated to parse. Then I'll keep the data in Python and call Scipy, though also there sometimes functions are not implemented or there is a warning that it is implemented crudely (`signal.deconvolve`). But for 95% of the time, I'll avoid firing up my uni VPN if I can avoid it.
Depends. When you assign a value to a parameter in a function call, use the no space version. Example: def something(val=4): # optional parameter's default value, no space pass def main(): n = 5 # space something(val=100) # no space
there are people who only want python 2 on their PCs? wtf. i don’t think that’s easy with a huge bunch of applications depending on 2 and another huge bunch depending on 3. seriously, i doubt more than 3 people or so won’t install an application because it depends on python 3.
Well, you're a python 3 enthusiast. However, going by the numbers on PyPi downloads, and use surveys, I take the opposite view. 
there’s no senisble encoding besides utf-8, anyway.
you can btw. use format_dict: print("Foo is {foo}".format_dict(locals())) that removes the need for **
I work in engineering and the few of us that used to use Matlab have switched to either Scilab (the best free alternative IMO) or Python. Scilab is working out very well for the people I know who have gone that route. The syntax and functions are nearly identical to Matlab.
i don’t understand how you get from “x people downloaded python 2 versions” to “x people don’t want python 3 on their systems at all and care what language some non-library application is written in”
It's not that those people care about the language per se; it's that most people don't want to deal with dependencies, and installing new stuff. If most people were using python 3, and not 2, I would have the same thing about an application that requires python 2. 
Well, if that's your read of the facts, then I think your conclusion makes sense. 
How is it they are ignored?
More or less my point. Tired of the "Python 2 vs Python 3" use what you use. Write about how you have overcome some obstacle, or how you helped shape Python 3 by contributing to the PEP based on your experience with Python 2. Don't whine about why the new version of something you like no longer suites your needs. 
I suppose I stand corrected some what. https://en.wikipedia.org/wiki/Eve_Online#Subscribers Don't fix what isn't broken then eh?
This isn't specific to Trollius: Python 2 just does not have "yield from" as Python 3.3+ has.
AFAIK octave doesn't have the toolboxes which are useful in MATLAB. So it's not got much advantage over python unless you like MATLAB's syntax or need compatibility.
Thanks for acknowledging. Look at it from the business standpoint: you have something that works and people want. Sell it. However, at the same time, keep your skunkworks well funded for the next big thing. Otherwise someone else will come along and destroy you. Maybe CCP is doing this, maybe not, but they are doing right by selling what works.
Maya and Nuke are why my facility hasn't switched to 2.7 yet. Nuke 8 is now on 2.7, so I've finally started moving some of our Nuke specific python code to 2.7 and it feels great. Unfortunately I need to wrap it in try/excepts, because Nuke 7 (with Python 2.6) isn't going away anytime soon :(
I'm just starting with Python, but I managed this in one line. This is probably old hat for most Python programmers, but I was rather proud of myself. sum([x for x in range(1000) if not (x%3 and x%5)]) List comprehension is amazing! 
So, it's a different project in a different language, but with the same goals. I don't think giving it the same name is a very good practice.
I've looked at Octave and Scilab, which are more strict Matlab alternatives, but have ended up using Python more myself as I find it generally nicer to learn and code with and it is much more diverse and capable than those more narrow focused languages. 
Octave can do a lot. It still misses a number of standard functions, that I use very frequently in matlab -- eg. roipoly().
This blog is a bit disingenuous for neuroimaging analysis. Python is no where near sufficient to analyze neuroimaging data unless you are on *nix and shelling out to FSL/FS.
~~Octave is *nix only.~~ Matlab is a truly platform independent language. EDIT: Turns out i was wrong. There are windows versions of Octave that do not require mingwin/cygwin. Thanks farass.
I hope all of the Python 3 zealots eventually get jobs. The decrease in noise will be nice.
sure, but it’s a problem.
Really? I can't seem to get it to work. $ python3 -c "a = 'b'; print('a is {a}'.format_dict(locals()))" Traceback (most recent call last): File "&lt;string&gt;", line 1, in &lt;module&gt; AttributeError: 'str' object has no attribute 'format_dict'
For about 2 years I used Matlab in a quant finance setting. Recently I began switching to Python/Numpy/Pandas/etc and won't turn back. There was some upfront work (to mimic the Datafeed toolbox, for example), but beyond that Python is so much better for parsing data that, in my case, it was a no brainer. EDIT: Let me also add that Matlab tends to tout their graphing/charting capabilities. It is indeed very good. However, most of the stuff I need to plot is fairly quick and dirty (ie portfolio performance or backtesting results) and matplotlib is MORE than sufficient. If we ever need to make something really pretty for a presentation, we export the data to Excel and use that. The reason is that marketing uses Excel so they can tidy up the graphics.
There are lots of bits and pieces you can put together easily for this. There are ORMs, templating engines, ways to interact with office tools or output in various formats. There are multiple solutions in each category. No-one can tell you the best stack, because only you know your requirements. 
the only thing we can possibly get is a single function doing it all: x = run_coroutine(my_coroutine()) the problem is that when doing the following x = some_lib_method(args) x is assigned to the iterator returned by calling `some_lib_method`. how should `some_lib_method` know that you want to run its return value after calling it?
I've found that GLM analyses are easier to do in FSL, but for other analyses (e.g. inter-subject correlation) I tend to use python in the places where labmates would write custom matlab code. For cases where I use FSL, most of python's use comes from doing some basic preprocessing / automation, and some plotting. Have you seen [nipype](http://nipy.org/nipype/)? It's designed to provide a more principled approach to connecting analyses between various fMRI tools (FSL/FS/SPM etc..). 
Ok, fair response. What are some recommended templating engines?
u r right on the yeoman using grunt for workflow. Basically we use angular, so running 'yo' with angular scaffolding creates the starter app [with bootstrap 3]. This is obviously done in the beginning and then we add packages as we need it. the way our workflow is that we use docker to create our lx containers, so dev/staging/prod boxes are unified by it. any new package we need, we add it to upstream [both python &amp; front end] and then repull docker. Note that docker has limitations on number of instructions, so we run a script that will run fabric, grunt among other tasks during deploy. The script also takes into account whether its a local or prod deploy [bcoz some packages are skipped on prod]. one thing i didn't like about yeoman is the amount of packages it installs. I understand its collection of best tools to productionize your assets, but still its a lot. Anyway, i am going to write a blog post on docker/django/fabric, then followed by grunt/yeoman. follow me if you would like @agileseeker 
this should probably be in /r/learnpython
I think it's simple: pip install numpy pip install scipy The package manager, and the packages. Otherwise, Python (which I love) is just another language. It's about the way it's so easy to whip up a custom ecosystem for your workflow that's so magical about Python. As a language, it's not even my favorite. As an ecosystem, it's the best. edit: originally, I had npm instead of pip!
I think we always knew that there would be big end-user codebases sticking with Python 2 for years, if not forever. After all, there are big codebases out there still in Cobol, Fortran, etc., even though there are much more compelling reasons to move away from those than there are for Python 2.7. To my mind, the goal for Python 3 is to become the default for writing new projects. We're not there yet, but things are moving in that direction.
One of the most interesting points is when he points out the convenience of using a single language instead of the huge effort to mentally switch from one language to another (and often from one IDE to another). I use C++ for a huge multi platform project. It is great to be able to just keep using one code base and not switch gears. I would love to make the leap to Python but needless to say without the ability to push out iOS and Android apps puts an end to that idea. (I stopped using Objective-C for iOS, Java for Android, and now use C++ for the desktop and all) Another key point that he makes is that a language becomes really useful when a few lines of code can do so much. I use Crypto++ for AES encryption and even with that clean library there are a dozen or more lines of code before the binary data is ready. In Python I think it was 2 or 3. This is a mindset in Python to do as much as possible with as little typing as possible. A mindset I can really appreciate. A great example of this is to look at a hello world example for CUDA or OpenCL in Python and C++. Night and day difference. 
Was that supposed to be pip or can I use numpy in node? 
lol, a result of my other vice: Node. I fixed it, thank you! Actually, I use node as a submodule of my Python environment. So my day usually starts with activating my Python virtualenv, and then using my nodeenv to activate my node virtual environment (which is controlled by Python).
if the event loop is not running, run it and return result you could do this as a decorator Something like this https://gist.github.com/fried/8339217 ;edit for example
&gt; We have our own localization solution inside EVE and the unicode/str bugs have been worked out. Oh, the solution is a nightmare, and our string handling is often a mess, but that just means changing it would be even more difficult. Almost stopped there, but I think that summarizes it. It sounds like they've built a beast they're scared to refactor. That should be the first step before Python 3, but I doubt it's their priority to refactor. Sounds like the typical "we can't change anything or we'll break our product that has been working for years" attitude, which makes sense but is a sign of bad engineering practices overall. But the point is to make money from it, not to over engineer the product, so I don't blame them. I still use Python 2.7 because I'm familiar with it, but if I work in an environment where 3 is the norm I'll switch.
How so? I have switched from Matlab to Python about two years ago and have not found a single instance where the Python code was not faster, more readable and more general than the equivalent Matlab code. OK, except for writing out matrices by hand.
The big ones are Jinja, Cheetah, Mako, and Django. Django also includes an ORM and full web framework. I've actually made a database to pdf reporting system using Django+openoffice+cheetah, with templates defined by users in MS Word format. If your organisation would like to buy in a solution, we can talk about that too (message me if so). It's not black magic, and you can do it yourself (there are some kinks and technical tradeoffs to consider). I can also, for a low price send you the raw code and talk about the issues. What you should do in that regard depends on whether time or money is the tightest resource (and, let's be honest, whether or not this kind of project floats your boat).
&gt; No one wants to upgrade GCC for fear of breaking our codebase :( Unless you've been using `constexpr` as a variable name you don't have much to worry about. One of C++'s biggest goals is to not break old code.
Yeah. But not upgrading GCC is more of a mindset thing than an actual problem. Someone did some analysis and only like 1% of the codebase needs to be modified in someway. 
According to Octave's website, Octave can run on Windows (requires cygwin though).
Yes, i know. Are you prepared to run cygwin on your windows box? I dont consider cygwin as windows.
The issue is cyclical, people generally start new projects in 2.7 because 3.X doesn't have the library they want. 3.X doesn't have the library they want because the creators don't want to port it to 3.X since no one uses it. Until we start seeing more of the major frameworks and projects supporting 3, people aren't going to feel comfortable investing time writing in it.
At least for me, the fact that colleagues use python is my go-to reason for also using it. If we all understand the same syntax it is easier for all of us to help each other out and read code. Our job is to do science and not learn new programming languages. I'm terrible at learning syntax and still have to look things up all the time, but when others can read my code and help me or vice versa, then the language becomes much more useful.
**TL;DR** &gt; literally everything conspires against enterprise employees who want to upgrade any significant codebase. ...which applies to pretty much any platform.
Thanks for the informative response. I wanted to practice my python, I like to make life easy for people, which leads me to try making an app. Ill take a look at your videos, Ive the pong tutorials, but I might need a little more to fully understand Kivy. Perhaps I should just start with something small-ish because it is my first project? (Unity, etc) Because im really new to the creation of Apps IOS or Android. What do you think? It doesnt have to be python really, anything will help as long as it isnt that difficult. 
&gt; Perhaps I should just start with something small-ish because it is my first project? (Unity, etc) Because im really new to the creation of Apps IOS or Android. What do you think? It doesnt have to be python really, anything will help as long as it isnt that difficult. I think that's a very good idea - I look back at my first kivy app and am astounded at how bad it is in some ways because of stuff I just didn't understand or chose a bad method to implement. That's not a kivy thing, I'm sure it's true of any way you choose to make applications, and is inherently a useful/necessary learning step. For whether you choose kivy, probably it's worth thinking about your end goal. If you ultimately want to build a 3d game or similar, kivy is not likely to be a good fit for you right now - it's technically possible but 3d stuff has not been a focus much and a real solution would probably need bindings to an existing engine (again, possible but would need significant work). On the other hand, kivy could be a great fit for 2d games or for many types of standard 2d application.
Octave is great for some people (and improving continuously!) and utterly unacceptable for others. It's entirely reasonable, though, for a newcomer to learn about MATLAB inexpensively by working with Octave. For more than that, it's probably best to provide details about your specific situation.
Actually, Octave runs fine on [Windows without cygwin](http://wiki.octave.org/Octave_for_Windows)
Well, there is Kivy. That'll do same codebase for desktop, iOS, and Android. All with python.
I think this is exactly what I have been looking for. Thank you for posting. 
This is simply not true, unless you mean, you have a huge matlab codebase you want to keep using -- and then yes you need matlab. Python + scipy/numpy/matplotlib is a functional replacement; granted yes you may need to find or write a few esoteric numerical routines yourself that may have came with matlab, but you can say the same thing the other way as well. Yeah, matlab may have a nicer gui interface and may have a couple friendly features (e.g., saving figures to edit later) that you [may have to work around](http://stackoverflow.com/a/4348932/457571), but python is a much nicer, saner language that makes is easy to collaborate and share with others as well as do much more than just numerical calculations. (Unlike matlab where no one else can run your code without buying and maintaining an expensive license).
What's node in this context?
I would agree with you, except that Python has been literally, measurably, been "growing" in "usefulness". I would even go so far as to say exponentially so in the past 4 years (from my perspective...beginning of my college education and graduation). This growth is measurable in a number of areas: * **Packages**: The addition of and continued growth of: Pandas, NumPy, *Numpy2* (rumored to be in development), MatPlotLib, etc. etc. * **Tools**: Canopy, Spyder, IPython, IPython Notebooks, etc. * **Distributions**: Anacondas, Canopy, etc. I wouldn't consider my self and expert by any stretch of the imagination, but from my perspective, the Python language has very literally experienced, "growing usefulness" for the past several years.
Again with the anecdotal evidence. Until you can show some sort of support I honestly can't accept the premise that you are proposing. What would the python community at large gain from excluding corporate users?
My xtopdf toolkit can be used to make PDF reports from various kinds of data sources, including many relational databases (via either the Python DB-API or ODBC), also from MongoDB, from SQLAlchemy data, and from CSV files, TSV files, DBF, etc. This is a good overview of xtopdf - http://slid.es/vasudevram/xtopdf - with info on platforms, uses, users, features, and links about it. Packt Publishing - http://packtpub.com , The Software Freedom Law Center - http://softwarefreedom.org , ESRI NL - http://esri.nl , Yandex - http://yandex.ru (the largest Russian search engine) are some users of xtopdf. Recent post on using it to publish data from Firebird SQL (which is an RDBMS, as PostgreSQL is) to PDF: http://jugad2.blogspot.in/2014/01/by-vasudev-ram-pdf-firebird-is-cross.html That post uses fdb, a Python DB-API compliant driver for Firebird, so the code in it can be adapted for doing the same, but with PostgreSQL instead. Here are many (other) posts (on my blog) about using xtopdf programmatically to generate PDF reports: http://jugad2.blogspot.com/search/label/xtopdf That (meta-)link above also includes posts on using xtopdf to generate reports via the web, using the Flask Bottle and CherryPy web frameworks for Python (posts titled "PDF in a Flask", "PDF in a Bottle" and "PDF in a CherryPy"), and also includes post showing how xtopdf can be used at the end of a Unix or Linux command-pipeline to generate PDF, after doing all needed text munging, filtering and transformation in the preceding components of the pipeline (post titled "PDFWriter can create PDF from standard input" - http://www.reddit.com/r/Python/comments/1thbwe/xtopdf_pdfwriter_can_create_pdf_from_standard/ ) xtopdf project and source code (latest version) on Bitbucket: https://bitbucket.org/vasudevram/xtopdf Older version of xtopdf on SourceForge: http:/sourceforge.net/projects/xtopdf I'm available for consulting/contract work on and around xtopdf or related tools and technologies. Feel free to contact me via my business web site: http://www.dancingbison.com/contact.html HTH. 
This article by me on the Packt Publishing site may also be of interest:: http://www.packtpub.com/article/Using_xtopdf It shows the use of tools (written by me, that call xtopdf) to create PDF from text, DBF, CSV, TSV (TDV) and XLS input data: http://www.packtpub.com/article/Using_xtopdf Both command-line and GUI tools (using wxPython) are shown, with screenshots and usage examples. 
you are wrong on your campaign for MATLAB, once again
You can eliminate the `elif` in `prompt_sta()` by calling `lower()` on it: def prompt_sta(): prompt_0 = input('Type a Command: ').lower() That will always return a string that is lowercase. There are several other things that I think can be improved in this script, but it's hard to say without knowing a little bit more. I think /r/learnpython would be a better, more helpful, place to ask with more detail. Also you can include your code in your post by indenting with four spaces or put it up on pastebin....jpg is not very fun for the rest of us to help you with.
None of them. Your users expect native look &amp; feel. This means that you need to use Objective-C and Java respectively. Python is great for a lot of things, but mobile app development is not one of them.
I like how you showed that matlab is not platform independent.
If you're not running Redis-server in daemon mode, you're probably doing it wrong.
You actually don't want to use a list comprehension here -- [remove the braces to turn it into a generator expression](http://www.reddit.com/r/learnpython/comments/1qtjhu/weird_usage_of_sum_and_a_for_loop_how_does_it_work/cdgbn0p). 
On line 4 of prompt_sta(), you have: if promt_0 == 'Start': You mispelled your variable. You may have gotten an error on the lines of, "NameError: name 'promt_0' is not defined." It should be: if prompt_0 == 'Start':
I haven't checked it out in deep, but Qt 5.2 does have iOS and Android support, so I guess that would extnd to PyQt. 
Im thinking more on the 2D side. You seem to know a lot about this. Just one last question. How much did you struggle with Kivy on your first projects? Thing is, I know intermidiate python, so it might be more complex to me.
I wish you would have a fixed size font for the code snippets.
I think the situation is better than you're implying - a lot of the major projects and frameworks do now support Python 3. It picked up a lot in the last year. I made a list of important libraries and frameworks that do and don't support Python 3 for a talk recently, and there were many more with Python 3 support than without, and several of those without were working on it.
Too much *TNG* on the brain. I imagine it's actually Canary _Wharf_.
$10k is way to expensive for my (hobbyist) blood but I would love to go.
Hmm that's actually interesting. My expectation is that an enum remains a singleton, and I'm not sure what actually happens. I don't have the 3.4 rc handy at the moment, but in current Python: &gt;&gt;&gt; from collections import namedtuple as enum &gt;&gt;&gt; c1 = enum('Colours', ('red','green','blue')) &gt;&gt;&gt; c2 = enum('Colours', ('red','green','blue')) &gt;&gt;&gt; c1 == c2 False &gt;&gt;&gt; c1.red == c2.red False IMO this is correct behaviour, although ideally I'd like there to be only one instance of 'Colours' (the instantiation of c2 should throw an exception). It'd be interesting to see how the "real" enum behaves. 
This is terrible advice -- you are completely misusing `subprocess`. There's no need for temporary files: from subprocess import Popen, PIPE proc = Popen(['cmd', '-arg'], stdout=PIPE, stderr=PIPE) stdout, stderr = proc.communicate() print('stdout was "{}", stderr was "{}", exit status was {}'.format(stdout, stderr, proc.returncode)) 
I've worked with Python since 1998 professionally. I think I have some idea of what enterprise Python users look like by now. :) They wouldn't gain anything at all, which is what I'm trying to point out. 
Cool! I learned something new. 
Don't estimate what others need or want based on your own strengths and weaknesses. You still haven't provided evidence of how "enterprise developers" are being left out of python 3 development. 
ELI5 signal analysis, please.
I would also be very interested in this. 
There are a lot of different kinds of signal analysis. At the broadest definition, it's taking some sort of signal from a sensor versus time or position and performing some calculations to turn the raw data into useful information. Like I said, very broad. The field I work in is analyzing high speed data transmission cables. We can see speeds up to about 50 GHz on our cables, most are 20 GHz or below though. At those speeds you rarely get a nice, pretty square wave coming out the other end of the cable, it's much more smoothed and sinusoidal. Since data sent across a cable is much more than alternating 1s and 0s, this makes it even more difficult. One great technique for analyzing this data is to transform it from a voltage vs. time signal to voltage vs. frequency. The process involves performing some fast Fourier transforms (FFTs), a common tool in a signal analyst's kit, along with some arithmetic and array manipulation. Once we have the profile of a transmission lane in voltage vs. frequency, we can look at losses at different frequencies, such as insertion loss, return loss, and cross talk. We also have some products that perform active amplification and equalization, so we can't use as traditional of methods, there are many other tests that we perform on those that I won't go into here. Other fields of signal analysis range from image processing to control systems. Basically anything that uses analog or digital signals can benefit from these kinds of analysis. For example, image processing software can use FFTs to convert a 2D color image into a histogram that tells you how much of each color is present in the image. An advanced robot can use similar techniques to respond to its environment through sensors that are connected back to its motors. If the sensor says "hey, you're going too fast", the motor slows down. Obviously there's a processor in between that interprets the signal from the sensor and instructs the motor to slow down, but it uses related mathematics to do so.
2 to 3 had minor syntax changes and a few missing libraries, so you decided to rewrite into a language with completely different syntax and even fewer libraries? Huh.
https://code.google.com/p/pystatecharts/
node.js node.js, or just node, uses a handy package manager like Python does, called npm. I use them both, so originally mixed them up. node is an environment where it's easy to whip up servers (among other things).
How would you created a literal containing numeric values you wish to store as strings?
That way it's really easy to keep the config (and sensitive info) out of source control. I only put the app directory in git.
Ha. I can make jquery mobile look and feel native. Your argument is invalid.
Python with pandas + ipython is replacing R for my users. We work with economic and financial data so it's mostly stats and plots. R is falling out of favor because of ipython and notebooks. Our users really prefer the UI to R. 
You do android apps in c++?
What's wrong with the native terminals? Windows also has cygwin if you want the Unix commands, so I'm confused on what your goal is.
See http://en.wikipedia.org/wiki/Shebang_(Unix)
*A bit from linked Wikipedia article about* [***Shebang (Unix)***](http://en.wikipedia.org/wiki/Shebang_(Unix\)) : --- &gt; &gt;In computing, a **shebang** (also called a **sha-bang**, **hashbang**, **pound-bang**, **hash-exclam**, or **hash-pling**), is the character sequence consisting of the characters number sign and exclamation mark (that is, "#!") at the beginning of a script. &gt;Under Unix-like operating systems, when a script with a shebang is run as a program, the program loader parses the rest of the script's initial line as an interpreter directive; the specified interpreter program is run instead, passing to it as an argument the path that was initially used when attempting to run the script. For example, if a script is named with the path "path/to/script", and it starts with the following line: &gt;then the program loader is instructed to run the program "/bin/sh" instead (usually this is the Bourne shell or a compatible shell), passing "path/to/script" as the first argument. &gt;The shebang line is usually ignored by the interpreter because the "#" character is a comment marker in many scripting languages; some language interpreters that do not use the hash mark to begin comments (such as Scheme) still may ignore the shebang line in recognition of its purpose. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/GrahamDumpleton can reply with 'delete' if required. Also deletes if comment's score is -1 or less.)* ^| [^(commands)](http://www.reddit.com/r/autowikibot/wiki/commandlist) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=acini&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/Python/comments/1uusc1/what_is_the_meaning_of_when_trying_to_locate/celv9tf)
For many things, NumPy/SciPy/matplotlib definitely get the job done.
&gt; have not found a single instance where the Python code was not faster, Calling shenanigans on this one (and I use NumPy every day, haven't touched Matlab in years). If you're finding Python _faster_ than Matlab then you were probably not using Matlab correctly. They generally do a lot better with vectorizations and leveraging parallelism.
Yours is a good soul, OP. Thank you.
One of the finest UNIX terminal managers around is written in Python, and the source is available: http://gnometerminator.blogspot.com/p/introduction.html I used Qt (via PyQt) to build a GUI front-end to a console app -- it was easy once I figured out how. I used pexpect (under UNIX) to talk to the command-line (winpexpect on Windows). 
Sorry, not sure what you mean by a formatting tool. I use sublime text. Is there a formatting tool for that that you might happen to know? 
This looks like a REALLY good start! Ill check this out! And yes - this is exactly the style of which I was looking to do.
[Google's top result](http://stackoverflow.com/questions/1032393/python-formatter-tool), [seems legit too](https://github.com/witsch/SublimePythonTidy).
Very very cool. Thank you for this. My google foo did not turn this up the last time I looked. I am going to put this on my laptop so I can play with it the next time I am on the road. 
So I've got the frames set up the way I want, is there any chance you could direct me towards the resource you've used for talking to the command line? I haven't found anything on it that isn't super complex yet.
W***h***ether or not a program has been written in Python 2.x or Python 3.x, it's still Python code. As a Python developer, most production type code tends to be 2.6+, with older stuff being not generally older than 2.5. However, 2.7 and 3 are used with newer, fancier, dare I say "more hip" projects that the kids seem to like these days (I do like dictionary comprehensions, argparse, and some dictionary views). But you should be able to tell from looking at the code: #!/usr/bin/env python2 print 'foo' or #!/usr/bin/env python3 print('foo') ... is a dead giveaway. 
*sigh* Ok, I'll bite. http://mirror.centos.org/centos/6/os/x86_64/Packages/ What version of Python comes with the current version of the enterprise OS? 
nice. thanks
Personally, I think several of us would like _real_ feedback from these enterprise users. The link mostly describes problems of their own making (custom import system... whaat!?), which anyone with an ounce of enterprise experience could have told them were bad ideas. Here... let me outline the entire link: 1. We use python2 muchly 2. We can't use python 3 for reasons I'll go into 3. We have a "nightmare"-level solution to internationalization that would be hard to replace. (Followed with "There is a limited amount of technical debt we can clean up, and none of it has to do with string handling or any Python 3 features"... huh!?) 4. We're too busy to do engineering instead of game development 5. "We have relatively few automated tests... but there’s absolutely no way to uncover and fix Python 3 upgrade bugs easily." -- nope... none that I can think of. 5b. There is bureaucratic overhead to doing testing (serious organization dysfunction alert) 6. The Python "core team" around here is busy 7. External dependencies aren't the problem 8. We have no evidence that performance would be a problem, but that doesn't stop me from pointlessly bringing it up 9. We use Maya, and it's a microcosm of the exact same problems with testing and deployment. 10. (quoting in full) &gt; Ultimately we’ve been too sloppy and monolithic (like a large number of enterprise users, I’d imagine). Our products make money. Our developers are supposed to be working on those products and thus making money. We didn’t do a good job balancing technical and business needs, and besides our codebase is really old (EVE Online’s codebase is still an ancestor of the original codebase that EVE released with in 2001). ---- The real TL;DR here is something like the following: &gt; "We at CCP don't have anywhere near the test coverage we need, and we've so far failed to convince management that technical debt (measureable with a decent test system) is worth dealing with. Among other things, it keeps us from upgrading to python3." This is less a post about python3, and more a post about how an enterprise operation backed themselves into a "can't change anything big" corner because they didn't follow engineering practices.
This bot was cute, but now it is just annoying as fuck. 
If you are interested in node, but prefer to stay in Python, here's a great thread of node-like projects in Python: http://www.reddit.com/r/Python/comments/1e3i8a/i_dont_want_to_use_nodejs_what_are_my_python/
Just curious, what do you use that interlinks Python and Node? 
Sort of, educational software. But if you look at things like yelp, trip adviser, FB, etc. They don't look very native anymore. I can still do scrolling tables and whatnot. 
I just began learning Python like a week ago and I already created a CRUD blog! I love Python! So damn easy and fun!
Python won't be your replacement, but it will be an *incredibly* useful tool. Nothing can replace C++. I wish I was better with C++, but I'm mostly just Python and C. You can leverage awesome power by creating libraries for Python (or separate programs you fork) with the performance of a compiled language like C or C++, and use Python to glue it all together. You might consider lua instead, too. That works very well with C++ and it's very quick compared to Ruby and Python. Extremely lightweight too. Edit: i just realized you were posting that you *don't* want to switch languages/gears. I honestly think Python or Lua is the most powerful if you combine it with C or C++. It's not necessary, but you can have the best of high performance and the readability and succinctness of Python.
When the first line in a file is `#!/usr/bin/python` means "execute/parse this file using `/usr/bin/python`"
Can you tell us where in Malaysia? Guessing KL but ....
Yes it will be in Kuala Lumpur, very near to the Twin Towers
&gt; I think several of us would like real feedback from enterprise users. What a fundamentally arrogant statement. The guys at eve run a truly *massive* amount of infrastructure, and this was an open and honest discussion of why they don't use python 3. You think perhaps many 'real' enterprise developers are in a completely different situation? That they have amazing test coverage and love python 3 and are already using it? I also welcome those people to step forward and speak up. ** Tumbleweed ** Yes indeed. Here's a hint: If you don't like what many people in business using python are saying about python 3, and how they can't/won't migrate their code to it, maybe the answer *isnt* to look for other enterprise people with 'real' feedback, who have an opinion you like better, it's to *deal with the problems* that the people who are speaking are raising. 
Helpful yet very long [YouTube Video](http://www.youtube.com/watch?v=52wxGESwQSA) aboot web scraping. He goes over all sorts of web scraping, and it looks like it's being run by ESRI's ArcServer, so you might have to get to know [Something from ESRI's SDK](https://developers.arcgis.com/en/documentation/)
First off, if you are working with HTTP in Python, use Kenneth Reitz's Requests library. It makes everything a lot simpler. Not all sites will respond to ping. It is commonly disabled. I assume you can reach the site in your browser. Can you also reach it with wget or curl? Are you running your python script on your local machine or a server? Is there any kind of authentication required?
Because in console-only linux environments, the file extension doesn't mean anything. It is informative for the end user to know what it is associated with, but there is nothing stopping me from creating a script.avi file that is just a python script. As long as I chmod +x script.avi and add the shebang #!/usr/bin/python it will execute just like a python script.
Also, what kind of data are you trying to get, because if it's GIS data or parcel info or something, [sexy link with data](http://maps.co.mecklenburg.nc.us/openmapping/data.html)
&gt; What a fundamentally arrogant statement. You say, before arrogantly assuming your anecdotes are accurate for the entire python-using world. You completely missed the point. The article was about how they couldn't switch (or, honestly, make any other major change) because their test process sucks. I don't come at this from the perspective of someone in the python/academic world wanting to advertise it, but as someone in the enterprise world who doesn't understand why this rather noisy subset of the python userbase have such trouble with this change. &gt; You think perhaps many 'real' enterprise developers are in a completely different situation? That they have amazing test coverage and love python 3 and are already using it? Actually... yes? First part of any major change should include looking at your test process... pretty standard practice these days? I oversaw two changes of a similar scale last year... looking at another one this year. It's a pain, but it's better than sticking your head in the sand hoping it will go away. Do you people honestly think maintaining your own python project is less long-term trouble than porting over the next 3 years? Do you plan... at all? &gt; Here's a hint: If you don't like what many people in business using python are saying about python 3, and how they can't/won't migrate their code to it, maybe the answer isnt to look for other enterprise people with 'real' feedback, who have an opinion you like better, it's to deal with the problems that the people who are speaking are raising. And this is actually my point... "the problems that the people who are speaking are raising" in this article were "our test process isn't good enough to tell us if we can upgrade". Can you actually look at that article and tell me there's something python3 could fix? I mean, I'm not sure I would want to manage a 2.6 -&gt; 2.7 transition in that environment. ---- You have to understand, I'm not really attacking the article for saying they shouldn't upgrade. It's an adequate explanation for people who ask "Why haven't you upgraded". From my perspective... they should pretty much shove aside any talk of moving to python3, their focus needs to be on improving their test capabilities.
that depends on the dude running the program. I go motivate him to do so ;-)
yes, it is a bit like Google map except for legal records and such about a parcel of land. Like I said, I am a bit new. I work more with micro controllers. No, you don't need a password or anything if you. I am running the script on my labtop. I am just trying to automate some mindless task at my work. As far as ping goes, it works. But it just stops and doesn't give a time and doesn't return to command line. Both wget and Curl also works. wget actually gives me the index.html, I was looking for something like this! I may even be able to directly interact with it. 
You got me pinned. That is intense SFW link. But generally, I have to pull information from the source on a county by county level. Mostly it comes down to if there is a difference between the county source and that website, it opens me up to being sued for negligence. Next I have to interact with FEMA then some survey stuff. Surprisingly enough, wget gives me an index file that may allows me to search with.
If you don't like Py3 then why did you spend so much effort to try to use it?
Python's built-in generators (co-routines) make excellent state-machines in themselves. We use these extensively for scientific instrumentation.
Simple state machine with http://pythonhosted.org/ginsfsm/ 
Thanks, I didn't know you could solve it this way. The post was updated with this improvement. Note that `proc.returncode` must be called *after* `proc.communicate()`, otherwise `proc.returncode` returns `None`.
Some things are work for both.
They are also using something called dojo too. Infact I'm sure they are using quite a few things. But yah, the YouTube video was defiantly helpful for what I need to do.
Nice, I can use this. On github in the demo gif you write this: `from tqdm import *`. Well, importing everything from a module is not a good idea. Please update that part.
&gt; See, if you have a relevant point, you can make it without being nasty if you realllly try. Great work. Something you have yet to manage. &gt; How about writing a great blog about how you're not having trouble? How exciting is that? We iterated through our test failures until they're gone? It's called development, it was less unique than the desktop OS switch last summer. I'd write a blog if I had something interesting to share (and the time)... but I really don't.
Thanks. I agree you shouldn't "import *" in a source file, but I think it's a very useful feature on the interactive shell.
Nice, but [Clint](https://github.com/kennethreitz/clint) already does this (and more) pretty effectively.
There can be only one.............?
&gt; How much did you struggle with Kivy on your first projects? I don't really know how to represent this...I guess overall I'd say 'not unreasonably'. It doesn't have the breadth of different tutorials that a larger framework enjoys, but all the information was there so it was a matter of letting things sink in rather than any real difficulty even finding information.
I dont want some behemoth just to have a progress bar. This is small and simple. 
This is awesome. Thank you!
/\ this 
Ah, OK. That makes sense.
Clint is hardly a 'behemoth', and as an aside I think it's quite misguided to choose your library based on file size. Use what you like though, my intention was just to point it out (it's a very useful library) rather than to discourage either tqdm or generally reimplementing things that already exist.
Well of course not, but Clint is a great library, so worth pointing out.
In my experience, Numpy/Scipy and Matlab are usually very similar in performance. However, I find that Python offers *far* more potential for optimization. Yes, the auto-vectorization in Matlab tends to be slightly faster than Numpy. But then, Scipy often offers some other method of solving the same problem that performs better. Matlab often insists on copying data for pretty much every vector operation. A lot of that overhead can be avoided when using Numpy slices efficiently. Very similarly, iteration in Matlab always requires all the data allocated up front, whereas Python iterators typically only ever allocate and re-use the data for one step. In other cases, libraries like Pandas or Scikit-learn offer functionality that simply does not exist in Matlab at all. And all this is not even speaking about Pypy or cffi. Thus, I stand by my initial claim: I have not found a single instance where Python code was not faster, more readable and more general than the equivalent Matlab code.
if you, like i, were wondering how this code kept writing to the same line, it comes down to printing a '\r', carriage return which resets the "output column" to 0 and then the next write will proceed to (over)write from there. For example, this code sys.stdout.write("first") sys.stdout.write("\rsecond") will only leave "second" on stdout. A caveat here is, if you don't want any trace of the first write, your second write must be of &gt;= length. 
Awesome stuff! I will be pulling when I get into work and incorporating into my user shutdown script! 
You're getting a lot of undeserved flack for pointing this out. For some people here, it's either cheery, smiling mutual validation or die. Don't you dare go against the flow!
thx ! need more places.
Interesting, thanks
As far as I know, there's currently no way to create a stand-alone interactive snapshot of a plot in maplotlib. The best you can do is serialize the figure object and then re-open it within a future python session.
it seems like printing to stdout while in the loop would break it. is that correct? (although i understand that this is probably intended to be run in loops that don't have any feedback, so thats not much of a drawback)
http://readwrite.com/2014/01/08/in-demand-tech-skills-of-2013-java
&gt; A caveat here is, if you don't want any trace of the first write, your second write must be of &gt;= length. Or you can follow the first write with `sys.stdout.write("\r%s" % (" " * len(first_write_string)))`
This, however, works in IPython notebooks.
 import this &gt; There should be one-- and preferably only one --obvious way to do it.
What kind of projects are you looking for:complexity, type , you fields of interest ?
I'm just out of ideas and need inspiration. just finished to read beginning python book: http://www.amazon.com/Beginning-Python-From-Novice-Professional/dp/159059519X, and need to start doing something by my own
Really, it looks like a project which could do with a massive injection of automated tests. If you have 100% coverage of your code, porting to python anything looks 10x less scary.
Can you get the progress meter to write to stderr? I did not see an argument to the script that would change the output container.
Nice article, this is something I have wanted to learn more about and looks really powerful. 
Zen is overrated.
If you're interested in writing something to the raspberry pi and willing to mess with a bit of hardware, have a look at This : http://www.winlab.rutgers.edu/~suhas/mobihoc09.pdf I think a basic ,simplified version(much more simple than the pdf) , useful version of it could be done by some python on the raspberry PI , and some minimal code on a python server, using cosm. It also looks like something that can create a community around it and maybe even win a kickstarter. If you're interested i'll be happy to share details. 
Yeah, this won't work for me. It'll break any of my scripts where I use the output to pipe into another script.
A great python example was the other day I needed to squeeze short blocks of numbers into the smallest space possible, encrypt, and transmit them in a text stream. Compression wasn't doing it. The numbers went up to 500 so 9 bits per number was enough, so I put them into a bitstream, encrypted the bytes, and then base64'd the result. Maybe 20 lines of clean clear code in Python. Now through C++ templates I could probably get close to 20 lines but not cleanly and clearly. But where I do love C++ is that as a project get very complex and I start hitting weird problems, I don't start fighting with the limits of the language. So while C++ is slower to develop in than Python, it is faster overall for massive technically challenging projects. So when all is said and done, I suspect that I will end up using Python(5%) and C++(95%) time wise which is not perfect mentally but probably the most productive. But that 5% Python will be very productive feature wise. 
If you're using Python 3.3 or later, which implement [PEP 397](http://www.python.org/dev/peps/pep-0397/), the shebang line is interpreted on Windows as well as Unix, so long as you launch Python programs via a separate program, called pylauncher. Pylauncher (py.exe) is associated with *.py files. Its role is to interpret the shebang (#!) line and locate the appropriate version of the Python interpreter (python.exe). Best practice seems to be to use #!/usr/bin/env python2 or #!/usr/bin/env python3 as appropriate since this works across a wide range of Unix and now Windows environments. Note that this works on Windows with Pylauncher even though /usr/bin/env makes no sense in terms of the filesystem on that platform. You can even specify the Python version when launching Python via pylauncher: &gt; py.exe -3 foo.py or &gt; py.exe -2.7 foo.py 
what about learning something new ?¿? udacity.com has lot of courses about very different topics, maybe you can get inspired while learning something 
What have you worked with before and what are you looking to do? Something complex? something easy? Something practical or just for fun or to learn a new subject?
File size directly impacts load times, so I would hesitate to call it "misguided"
You can also do this with clint: https://github.com/kennethreitz/clint
I think that really refers to syntax and methodology, not the existence of a tool set. That would mean that whoever got to a project first would have exclusive Python Rights(R) to whatever it was they created!
Interesting. I'm looking at the coroutine talk/slides that seems very thorough. Seems really cool but difficult, but if you had an example it would be beneficial.
Clint's page says it detects if you are piping the output of the script, and disables features like color - if that applies to the progress bar too, that's a real win. Progress bars are great for interactive use, but terrible for piped use. Automagic is a much better way to handle this than some sort of non-interactive flag.
cargo cult much?
Wat?
The progress bar is outputted anyway. It just scrolls up whenever you output text, and a new progress bar appears at the bottom of the screen
Definitely find a practical project to work on then. Something to keep you interested over all the theory and definitions then. You could also make a reddit bot; they're often done in python. Working with the PRAW package to interact with reddit. If you don't have any ideas, pick an idea from /r/requestabot. On a similar note, praw also has [8 open issues](https://github.com/praw-dev/praw/issues) so you could always work on that and contribute to an open-source community. reddit itself is coded mostly in python and has a ton of issues, so you could find some and fix them though they're probably harder to solve than a normal issue is (due to the size of reddit). Scraping some sites or rss feeds is pretty easy to do in python as well. IRC bots are easy to make in python as are text games. Could do a combination, a text game through IRC.
You can check out past issues in [the archive](http://pycoders.com/archive.html). I was subscribed to it a while and think it's okay. Regarding the articles and videos you'll probably find everything here as well, maybe not all of the projects they list. 
It would help to know what information you wish to extract from the system, then we could advise more. But +1 to the requests library.
I occasionally pick up things there that I miss from other sources. Like this [sneaky little project](https://github.com/Katee/quietnet). I look forward to it every week.
We started this whole discussion with evidence of another organization with a large existing code base have a hard time switching to Python 3. The original article, remember? I'm saying that this matches my own experience and that CCP is not a unique case. I'm not talking about what *I* need. I'm a pretty competent Python developer. I'm self-employed. I don't have Python 2 large code bases to maintain unless people try to hire me to, and I want to. I can use Python 3 and I'd likely enjoy it. But we're in a community here. We don't appear to be exchanging thoughts here nor learning from each other. This is just a back and forth, where you will throw some challenge back at me, without evidence you've really thought about what I said very carefully. You seem to be using a rhetorical strategy that might work when dealing with anecdotal claims of the paranormal! So let's move on. Thank you for the discussion! 
Dude, all I was asking for was proof of your statements that "enterprise devs" are being left out of the decision making process of python 3. Why do you keep dodging the topic?
For social science research, python is hardly a replacement for R (or other software like SAS or SPSS) right now. For example, in my field, 80% of research is done using structural equation modelling. With R, there are packages like lavaan and openmx that can do it. There isn't anything in python. The only recommendation I've found when searching for a solution in python is to use RPy.
What decision making process of Python 3 are you talking about? I said that people with large enterprise code bases haven't featured much in the discussions in the Python community about upgrades to Python 3. If you have evidence that they have featured large, please show me the evidence. Instead I see you blaming the victim when you learn about an example, and challenging the other one for evidence for things they didn't even claim. But really, this is a fruitless discussion and I'm doing this against my better judgment. You won, I'm convinced by your arguments, thanks. 
... or you could use Enthought or Anaconda or download and install numpy+pandas, and be using the same stacks as the *rest* of the most advanced quantitative researchers in the world. :)
&gt; that is harder in Python 3 for no particular reason. That's not true at all - the reason is that Python's string implementation was changed to treat all string as Unicode unless explicitly encoded. That might not be a practical or worthwhile reason in your opinion, but to say that it was done arbitrarily is simply untrue.
I think you're kidding, but I don't believe there will *be* a Python 4. At least, not as long as Guido is alive.
* http://www.reddit.com/r/pystats/comments/1r7zv0/request_from_my_company_plots_that_they_can/cdqb0bq * http://redd.it/1ryml7#cdt1p7z
That's hard to believe. http://en.wikipedia.org/wiki/Computational_neuroscience https://wiki.python.org/moin/PythonForArtificialIntelligence http://www.scipy.org/topical-software.html#artificial-intelligence-machine-learning http://www.pymvpa.org/modref.html http://minepy.sourceforge.net http://martinos.org/mne/stable/python_reference.html https://github.com/mne-tools/mne-python https://github.com/neuropy/neuropy http://nilearn.github.io/index.html http://nipy.org/nipy/stable/documentation.html#documentation-main https://bitbucket.org/cleemesser/python-edf/ https://github.com/rays/pyedf 
*A bit from linked Wikipedia article about* [***Computational neuroscience***](http://en.wikipedia.org/wiki/Computational_neuroscience) : --- &gt;**Computational neuroscience** is the study of brain function in terms of the information processing properties of the structures that make up the nervous system. It is an interdisciplinary science that links the diverse fields of neuroscience, cognitive science, and psychology with electrical engineering, computer science, mathematics, and physics. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/westurner can reply with 'delete' if required. Also deletes if comment's score is -1 or less.)* ^| [^(commands)](http://www.reddit.com/r/autowikibot/wiki/commandlist) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=acini&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/Python/comments/1usgc3/why_python_is_steadily_eating_other_languages/cemhscp)
http://rpy.sourceforge.net/rpy2/doc-2.3/html/index.html &gt; The high-level interface in rpy2 is designed to facilitate the use of R by Python programmers. R objects are exposed as instances of Python-implemented classes, with R functions as bound methods to those objects in a number of cases. http://ipython.org/ipython-doc/dev/config/extensions/rmagic.html
the title of this project reminds me so much of high school lmao in south america (maybe just my country) "tqdm" was text-speak for "te quiero demasiado" (I love you too much/very much)
&gt; Changing the meaning of most integer formulas. That's the most minor of reasons. Besides, if you're considering upgrading to Python 3 and haven't put from __future__ import division into your code, you might want to try. I'll even let the sorting dictionaries issue slide (strings/ints as keys will cause problems when sorting) as you can make a simple common code to fix that. Binary parsing is hard.
If you mean pexpect, try this site: http://www.noah.org/wiki/pexpect or this site: http://pexpect.readthedocs.org/en/latest/ You have to google for examples (there are a few on StackExchange). It's really not that complicated, but you do have to know a thing or two about interacting with terminals.
They don't play in the same space at all. This is for SMALL web sites. If you want to play in the small arena there is Flask, Bottle and CherryPy. All older, tested, tried and good.
How was I meant to know it was shit until I had?
I've literally re-write this with every new job since I forget to keep, or version control my progress bar code. This looks great, `pip install tqdm` for REPL and simple batch utilities. Thanks
thx guys, helped alot !
This is a trick that was used even back in the DOS days, and perhaps earlier.
It's OK, but seems to get a lot of material from /r/python these days.
I love this module for the easy colored text and progress bars. Fortunately, it looks like 0.3.3 has been released; 0.3.2 had an install issue with Python3 (easily fixable if you wanted to install manually).
&gt; I dont want some behemoth just to have a progress bar. This is small and simple. 
I disagree entirely with inclemnet. For me Kivy was a nightmare. I don't know what you mean by 'intermediate' python programmer, but I have been programming python for 3 months, have a firm grasp of the language, and have developed a few small games for android using PGS4A (nothing I have felt good enough to release on the play store, but they are playable). I bought the Kivy book (there's only one), and did all of the exercises, etc. I got a decent grasp on things. The problem was that when I sat down to write my first game in kivy (not copy the pong tutorial etc...), I felt like it was just getting in the way. With Python/Pygame everythin just flowed. With Kivy, there was an added level of abstraction that sucked all of the fun out of programming. So I uninstalled all of the dependencies, and never looked back : ). I hope it works for you, and maybe I'm just retarded, But I hate Kivy.
Someone else can probably explain this better or more accurately than I can but I'll give it a shot. But before that, my background revolves around Flask (which is based on werkzeug), Twisted, uWSGI, and nginx so my answers won't cover everything you're looking for and have more to do with their use and not their definition. **WSGI** - "Web Server Gateway interface", fancy talk for "the specification your application and web server agree on using to talk to each other". **wsgiref** - The python library which implements WSGI. Unless you have a very specific reason to do so, you shouldn't use this library directly. **werkzeug** - middleware between a web application and a WSGI process. This is a library you can directly use to write a web application however I would suggest using Flask instead (btw, if you use Flask...you are using this library). Otherwise you'll end up having to do a lot of the work revolving around templating, routing, etc yourself **Twisted** - A network framework. This library can do anything that everything else on your list can. Again you can use this to write whatever you need but for a web application it's not ideal unless you're wanting a single process that not only serves a web application and just about anything else you can think of. It's performance is quite good so long as you have a good understanding of how twisted is designed to work. **uWSGI** - A WSGI server implementation that receives an incoming request, hands it off to your web application, waits for a response, then sends it back to the http server. **Gunicorn** - I have not used this myself but it's similar to uWSGI in terms of its purpose. **CherryPy/Waitress** - I am not familiar enough with these to be sure on this answer, but I *think* these are similar to Gunicorn and uWSGI. I didn't see you mention nginx, apache, cherokee, or lighttpd (regular web servers, these cannot run your application directly) but you'll likely want to research either nginx or apache to actually handle incoming requests. How you actually handle a request can make a huge difference in terms of how well your application scales. For example if you have a bunch of static content you should avoid having your application serve that at all costs. Instead you have the web server do this for you. There's a huge variation in how you can 'serve' a web application but generally it looks similar to this: web browser (chrome) -&gt; request (headers,data,encoding,etc) -&gt; web server (nginx) -&gt; wsgi server (uwsgi) -&gt; web application (flask) -&gt; unpacked request context -&gt; your application code serving an endpoint (/foo for example) More than knowing the individual technologies however you need to know what they are defining as "performance critical". Is the page static, can the page be cached, do we need to do background processing, is a database involved, any real time aspects (as in, two users doing something at the same time and seeing each other's results), what about asynchronous lookups on the page? It's my opinion that answering these questions first is more important than picking some libraries, frameworks, or servers because picking the wrong things could make things much more complicated than it needs to be.
No argument for stderr but it's just 3 lines of code to modify and only slightly more difficult to make the output stream configurable.
That will tend to happen, so if you already frequent this subreddit often or some other channel with popular Python news/updates, then it might not be so useful. For me, however, it is useful because I don't look at every post on this subreddit or Hacker News etc., so I usually find things I haven't seen when it comes along.
You don't want to put Gunicorn by itself facing towards the web. Application servers should almost always be reverse proxied behind a static web server like nginx so you don't just start dropping connections when the application server is under load. Not to mention you'll want to use the web server to serve static resources anyway
Thank you! I don't understand any of this either, and I too am not a beginner to programming.
Figured I'd give some examples of stacks I've built in the past. 4-5 years ago I might have used Apache2 with something like mod_wsgi, with Apache handling static assets ( raw HTML, css, jpg's/pngs ) and leave application logic to the WSGI. Trying to remember what else was around back then but CherryPy or pylon's were two of my goto frameworks back then. Last year I built a web array that consisted of NginX servers handling static content while uWSGI managed a pool of Django WSGI workers. I love and hate uWSGI, love it because its very configurable and allows me to do crazy things ( spawn application threads inside of a WSGI request, this is crazy, don't do this ). I hate it because uWSGI is extremely configurable and its easy to get lost in the details or perhaps have sometimes inefficient configuration. Otherwise the truth is that almost any of the mainline WSGI frameworks will meet the majority of needs. #Pylons Is dead, long live Pyramid ( haven't used Pyramid so I cannot comment ). #Django Django is a very popular framework because its a one stop shop of common components in any web application and Django code monkey's are easy to find. Pros: integrated ORM, templating language, best practice file structure, and the abundance of plugins or 3rd party apps for providing turnkey features https://www.djangopackages.com/packages/p/django-plugins/ Cons: I hate the ORM, mostly because I've worked with juggernauts like Hibernate and much lighter systems like SQLAlchemy's DAL and ORM. Django Admin's time savings in getting started go away as soon as you need to make admin views ( templated &amp; instrumented user interface ) that don't rely on a Model or do weird un-ORM like behavior ( Many to Any membership lists ). I used to hate Django's templating language but once you really understand some of its subtleties, it's not a bad choice. #CherryPy Not really a complete framework, but more of a proto-framework and a foundation for a custom framework. I was contracted as part of a team to help rebuild an "Enterprise" project that analyzed medical researchers and scientists, "Enterprise" was ~8-9 years old at this point and is probably in the top ten largest systems I've ever worked on. After a lengthy period of testing and evaluation we went with CherryPy &amp; SQLAlchemy for the application core components, while Lighttpd ( Nginx wasn't ready back then ) fronted it and handled static content. Pros: CherryPy uses an object-graph for managing logic. So http://my.server/root/user/get/123 would be "Pass 123 as the first argument of User object's get method" but its not locked into that format and you can adjust URL routing as needed along with supporting pre/post filtering ( Is the requestor authenticated, do they have access to the User object? ) CherryPy also has a light weight service bus inside of itself which can make brokering against odd external services ( message queues or Thrift based services ) slightly easier. Cons: CherryPy can be frustrating as its documentation hasn't always been that great. Additionally it can be easy to create absolutely massive object graphs that make (re)starting the system tedious. Serious non-starter issues for the majority of needs is that CherryPy has no default ORM, no concept of a user, no plugin system, and you even have to choose your own templating language... which is a project in itself and makes it harder to sell to the tech stupid people "If we went with RoR or Django we'd have something to show you on week 1, but we're still working out the kicks and will get back to you at the end of week 2... maybe" #Flask Pros: Will get shit for this, but Flask is basically CherryPy without all of the crazy features ( eg service bus ) and relies on Werkzeug which is basically a proto-framework for building WSGI frameworks. Flask is fantastic in this regard when you have good code organizational skills or you just need to make a brutally quick application and don't need a lot of fancy-dancy widgets to get in the way or have to code around. Cons: Flask is Flask and not much else, this puts more responsibility in the hands of a teamlead to ensure you're not building a gigantic ball of mud before its even shipped. Furthermore, it shares the same problems as CherryPy in that *almost* everything ( ~~templating,~~ ORM, etc ) is the responsibility of the developers. Edit - Flask does include jinja2 which is a fairly mature templating library. Italics/strikeouts show edits. #Twisted.Web Pros: Twisted is the defacto networking swiss army knife library of Python. If you need a service that interfaces with a serial connected proprietary protocol device but also has a HTTP interface for users... this is the library for you. If not and you just need a simple asynchronous web framework, Tornado maybe a better bet. Cons: Twisted.Web is a web server and not geared for rapid application development. I've got an on again/off again pet project to make a web framework on top of twisted.web here https://github.com/devdave/txWeb/tree/refactor but beyond use in my own projects, I don't have a clue how far away it is from being production grade. #Tornado Admittedly I've had little need for Tornado ( as I know Twisted ) but my limited experiences has been positive. Still, I would advice against using Tornado unless you KNOW for a fact that you're going to have thousands of concurrent requests a second and serving back near-real time stats. These are the frameworks I've used or worked with for at least 80 hours or two weeks of my life. I can't say one or the other is superior than any of the others because they're not. Only person that can figure that out is going to be you as you know your project needs best. Only real piece of advice I can give, regarding you stating "my company needs a custom framework". I've worked as a consultant or contractor in some fashion for almost ten years now and almost always a "custom framework" will generate billable hours of work but not money for the sponsoring company. In fact, ~8 years ago, myself and some other idiots almost killed a company because we drank way too deeply of the "Let's build a custom framework" kool aid.
I modified the code to handle character sets, although not fully since it doesn't replace [abde] with [a-e] if that still works. I get an improvement 1 vs. 2: 50 chars, 5.2 ratio: '[agijku]..n|[aiopv].l|a.[at]|[cjoy]e|i..o|di|sh|oo' 2 vs. 1: 56 chars, 4.3 ratio: '[irtu].$|[cdgptuw]..e|b[lr]|o[cmx]|d.n$|ss|fr|rk|cla|^ki' So for the presidents I shave just under 10% off, but for the Star Wars / Star Trek, it's over 20% off. 1 vs. 2: 7 chars, 16.1 ratio: ' [BNPT]' 2 vs. 1: 13 chars, 11.2 ratio: '[ FNU].R|Y|^N'
Some thoughts: - if you are thinking on eventually earning money out of it without the need of a CV as Seth Godin would suggest (linchpin book) then perhaps looking at what people are needing in http://www.oreillynet.com/pub/wlg/3501 or freelance sites. Elancer etc would help to prepare your portfolio. Not sure if it is possible directly but looking at kickstarter projects that failed to get launched? Maybe you can do better? - if you are more focused on finding a more innovative idea, maybe sites like quora in topics such as innovation, disruption, startups, productivity. or maybe visualization and nosql, big data (skipping the hype), games/gamification? - something in between could be looking for missing OSS or where the oss offering is poor, and help out. Google around, saw this http://www.osalt.com/ but I don't know if is good. - finally if you need something to keep you motivated and perhaps develop development skills in a team (a completely different game than lone wolf projects, the dynamics, synergies and collaboration/version control tools needed) try to find people local to you, and address an actual problem or dream you have. Warning, the result may just be loss of friendships and a s... product, but you would have learned a lot. I hope it helps 
Post-edit Only needed in extreme cases, but if more content is static based, you can put nginx on it's own server and relay application requests to uWSGI hosting a WSGI application on another server. I can't remember but I think Nginx and uWSGI are smart enough to keep a persistent connection open between the two server's which would partially negate the distance between them ( compared to being on the same server and talking via a kernel named pipe ). I've only seen something like that once and that was for a platform that handled 200-250K connections a minute, with ~25 dedicated Apache2 servers punting to ~10 application servers. This was also fronted by a fairly robust CDN.
If you're looking for 'critical performance overheads' for a web server then Python isn't the right choice. It's an order of magnitude slower than a similar solution in Java or C++. Don't get me wrong, I love Python and use it when I can, but it's not the right tool for the job in performance-critical situations.
The reason why my boss is trying to push ourselves towards a custom framework is because of the **Pylons** state. The app currently is built upon Pylons and ZODB. Since both are almost deprecated, maintaining that app by us and for client is becoming difficult. We suggested **Flask** but my boss is fearing again for its life time. 
I have to agree with the other commenters here. How dare you do something that others have done before you, and then come here and tell us about it?
This post links to OP's blog. Save your eyes and visit [the project's page](https://github.com/rcarmo/pngcanvas) instead.
But if development/support of Flask would ever stop, you could still just grab the source code and fix things yourself, as you can find the whole thing on GitHub. Of course you had to read through the code first, but I guess it's still easier than coding a whole framework by yourself.
Me too, although sometimes importing everything can be usefull. `sympy` is an example.
Thanks for such a detailed feedback. I will surely work on improving the app and going through Miguel Grinberg's tutorial.
Ah the problem is not that I am not able to read the whole code easily. I just like to comment different sections this way. If I break it into sections even then I will naturally comment it.
It looks ok and documented but what's the motivation for doing it. I think its important to mention. I mean if its "another web framework" why did you make another one, what things did you want to improve, why should i prefer it from another framework? Like others mention here one of the first things you think after hitting the homepage is "why not just go for flask or cherry py" 
You have forgotten web2py which is easy to use and very complete which might be a disadvantage.
Hi there. Start with Django, and finish with it.
Pull request sent. Now we play the waiting game. :-P 
Another serious problem of custom frameworks; the "Enterprise" project I worked on had about 3-5 people quit on the first day they actually saw the codebase. That was also a custom framework deal, if the word "Enterprise" wasn't clue enough, and I would like to imagine it had good intentions in the beginning. If you want some semblance of future safety, I'd go with the framework that has the highest level of test coverage already in place. BUT those tests would need to be maintained. Furthermore, if the current web application is below 50% test coverage and that's deemed acceptable, then it doesn't really matter what framework you choose... you guys will be back to the drawing board in 3-5 years.
You can still use Python in many of these cases by switching to PyPy instead of CPython.
&gt; Contexter is a full replacement of the contextlib_ standard library module. It comes with more features, a nicer API and full support for Python 2.5 up to 3.x from a single source file. That's the plan. This release is in a *very* early state and **not** ready for nuclear power plant cooling control software yet, obviously. I just wanted to share this and get early feedback. Look into the code, it's nothing special, but incredibly useful I think. Yes, its on PyPi already. But the rst-description is not rendered properly. Any idea why? 
Still it was awesome practice to do, don't you agree?
&gt; Pylons and ZODB. Since both are almost deprecated Pylons now has Pyramid which is generally excellent and I'm not sure what you mean about ZODB being deprecated - still very much in use with Plone and Pyramid?
It is really a small package, but it works and it is simpler than most template engines I have seen. The goal is to enforce the use of nice standards (README, MANIFEST, use of setuptools, etc.) so I you see something you don't like let me know. Now my questions to r/python: what is YOUR favorite layout ? Do you use template engines ? What repetitive task would you like to see optimized when creating a new module ? I think the next step would to initialize the docs in a way that is github-pages friendly.
&gt;Did you make this? It says who made it on the very 2nd line of the post - Rui Carmo. &gt;Don't get me wrong, I like this, but I'd love for more people to contribute to pymaging. I'm not getting you either wrong or right; I'm just not getting you at all :-) How does saying that you'd love for more people to contribute to pymaging, help it in any way? Doing something concrete would help, like contributing yourself, or if you can't contribute yourself, starting a drive for others to contribute (with good reasons given), etc. 
Do you read posts before commenting? I made a simple introductory example by modifying quite a bit, his test routine for pngcanvas, which is not that easy to understand on a casual scan of the code, whereas my example is. 
&gt;His blog theme is the worst. I like my blog theme just fine (it's not meant to be eye candy, either) - except for the stuff on the right that juts out to the left, which I need to fix. &gt;I cringe every time. Don't know about you, but me, I don't visit a site more than once if I don't like its look (i.e. cringe when I see it). Unless, that is, I think it has good content, in which case I may try to read it via a feed reader, Readability, or other such technique. Also, Google "substance over form", "form over function" (the latter meant in reverse, of course), etc. ... 
Sometimes if there is just one minor bug in your rst pypi won't render it properly. Very annoying indeed.
There is no such thing as a Python executable compiler. If you want to build an executable that includes the interpreter and your code, consider cx_Freeze.
Semver generally starts at 0.1.0
Pylons merged into pyramid. 
Have you seen d2to1. https://pypi.python.org/pypi/d2to1
thanks OP
&gt; Flask ... shares the same problems as CherryPy in that everything ( templating, ORM, etc ) is the responsibility of the developers. huh? flask ships with jinja2 templates by default but you can plug different ones in. http://flask.pocoo.org/docs/templating/
There is http://www.pyinstaller.org/ and http://www.py2exe.org/
Two codebases leads to divergence of behaviors, release schedules, and all too often where to even find the code (example: [python 2 memcached is here and at version 1.53](https://pypi.python.org/pypi/python-memcached/), [python 3 memcached is over here and only at version 1.51 - what's different? shrugs](https://pypi.python.org/pypi/python3-memcached/1.51)), making code which depends on such libraries much more difficult to port. Having to write tests that exhibit identical behavior on py2k/3k is the best way to ensure that behaviors are absolutely unmodified and having a single codebase is the best way to ensure that the userbase gets consistent releases that work on all platforms. Not to mention having to support two codebases is extremely tedious (as evidenced by the merge process detailed in this post), makes you less likely to test both versions equally, makes it difficult to refer to code and changesets in bug reports and splits your userbase into two separate camps. The point about "autogenerated" code is a straw man. Assuming this refers to code that requires 2to3 to build, don't do it that way. The post refers to usage of "six" so I'm not sure how 2to3 is involved for builds, unless they mean the initial porting process, in which case two codebases has no impact on having to deal with that anyway. The post doesn't say much specific about how 2k/3k in place code is "ugly as shit", other than complaining about symbols like "text_type", which IMO is extremely clear in that it indicates intent. Sticking points like metaclass syntax and exec() are better examples, but these constructs are very infrequent (and the compat functions like with_metaclass() look fine to me anyway - [Armin's version](http://lucumr.pocoo.org/2013/5/21/porting-to-python-3-redux/) is very clean). The usage of compatibility layers is not unique to just the Py2K/3K bridge; it occurs between Python minor versions as well (2.4, 2.5, 2.6... Ever use [collections.OrderedDict()](http://docs.python.org/2/library/collections.html?highlight=defaultdict#collections.OrderedDict) ? [functools.total_ordering()](http://docs.python.org/2/library/functools.html#functools.total_ordering)? [timedelta.total_seconds()](http://docs.python.org/2/library/datetime.html#datetime.timedelta.total_seconds)? ). As those versions become obsolete, that's when your library gets to remove any backwards-compat workarounds specific to those features. 3K is just a slightly (and for most libraries, IMO it is slight) bigger leap. Below are samples of py2k/3k in place code - please see: * [sqlalchemy](https://github.com/zzzeek/sqlalchemy) * [mako templates](https://github.com/zzzeek/mako) (supports from **2.4** through 3.3) * [alembic migrations](https://github.com/zzzeek/alembic) * [dogpile.cache](https://bitbucket.org/zzzeek/dogpile.cache/)
Have you had much luck with it? I downloaded it yesterday before leaving for the day, but didn't have time to play with it.
Your are correct, fixing that now.
Not forgetting, I stuck only to frameworks I've personally used. Web2Py is a great framework for people who need a one stop shop of everything ( full feature framework, revision control, and scaffolding ) but is generally sneered at by professionals because of these features, which is perhaps unfortunate as it can be a better resource than more closed source systems like Access ( is that even a think anymore ) or FileMaker for small businesses that can't afford a dedicated programmer but need something a bit more involved than just a bunch of excel spreadsheets.
There is one : [nuitka](http://nuitka.net). Use the standalone mode.
Try using a pickle to serialize the object and store it in some file.
&gt; If you don't like the &lt;&lt; syntax, there is a method that does the same That was a huge relief for me.
Came here just to post about this. Thank goodness. 
Honestly, it's just easier to write a script that upgrades your python code to Python 3. It's better than using the 2to3 garbage code that's more about reproducing the exact functionality rather than the intent (and doesn't really work anyways). My script. https://code.google.com/p/pynastran/source/browse/trunk/licenses/build_2to3_old.py
I'm not seeing how this improves on RQ, for example. 
*Here's a bit from linked Wikipedia article about* [***Web Server Gateway Interface***](http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface) : --- &gt; &gt;The **Web Server Gateway Interface** is a simple and universal interface between web servers and web applications or frameworks for the Python programming language. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/westurner can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| [^(**call me**: wikibot, what is something?)](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=acini&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/Python/comments/1uxv8j/difference_between_wsgi_utilities_and_web_servers/cen5r7o)
And thanks for the tip about pymaging - I'll check it out. To me, choice is good. I don't have a problem with the existence of multiple different projects (open source or not) that do the same, or roughly the same, thing. Rather, I welcome it. It gives users options, in case any one of them stops being maintained or anything else. And who the hell is anyone to tell anyone else what to do or not do, anyway, if they are not doing anything wrong? Hell, I even promote other PDF toolkits - to take an example - on my blog and my Twitter now and then, even though I'm the author of one, i.e. [xtopdf](http://google.com/search?q=xtopdf) :) 
Away from my dev console so can't test, but I wonder if `python -m picnic args` would work with the inclusion of a `__main__.py` file to adapt the normal logic? Thoughts is that this is a very convenient idea but it would be nice to just pip install it and have either an entry point setup by setuptools ( or distribute ) or make it accessible as a callable module ( same idea as python -m SimpleHTTPServer ).
Not for me. Just *having* magic methods with non-obvious behaviors is very bad, since, even if I personally don't use them, other developers will. I could end up having to maintain their code. Magic methods should only be used when they have very straightforward and intuitive semantics. This doesn't fit.
Judging from their abhorrently ignorant blog comments regarding Python 3, I would not recommend this software especially for someone looking at Python 3 specifically. 
If you have more than one app, push Python via group policy or MOM or whatever it is you have for deployment, and use a custom pip wheel repository so you can install apps via venv and pip from group policy. Otherwise you could end up with not knowing which app has which version of python embedded, making debugging that much harder than having a single python runtime for them all. A similar kind of alternative would be to use the miniconda Python distribution and likewise have a conda repository to drop your pre-built software. 
A tangential question: Is it possible to use the `with` statement in multiple lines? E.g., how would I write this in multiple lines: with open('a.in') as a_file, open('b.in') as b_file, open('c.out', 'w') as c_file: # blah blah blah 
a few people thought this was useful so i thought i'de share. feed back is welcome. edit: updated for PEP8 styling 
I'd recommend you to use the PEP8 style guide in the future when writing your code. May seem like a nitpick but more experienced programmers will react negatively otherwise. http://www.python.org/dev/peps/pep-0008/
Have you tried installing your dependencies, dropping your scripts into C:\Python33\Scripts, zipping up your Python33 directory, and then copying to another machine? I have yet to run into an issue with xcopy deploying a Python installation. This way you'd just have to unzip one file and you're good to go - no new tools necessary.
I have 7 yrs python dev experience. my issue with pep8 has always that many of pythons own libs do not/did not follow pep8 style guide. running the checker. However according to the online check it doesnt like trailing spaces(which locally i do not have) or multiple imports on the same line.. anything else ? edit: in process of fixing pep8 styling
Are these articles any good? They seem to focus on unnecessary magic.
Accepted. Thanks! badboybeyer's comment made me think that the default should actually be stderr, so I made stderr the default. Also, I changed the name of the argument to "file", which is shorter and consistent with the print function.
Cool! Didn't know that!
It worked with Python 3 from the beginning, but now I merged arkottke's patch request so now trange also works with Python 3.
We have already 2 medium sized apps built in web2py and the final result is: we are not happy because it **forced its own conventions** over us just like rails do. Its pretty annoying.
I find that I've already seen about 40%-60% of the newsletter's content already but I'm always glad for the rest.
The articles themselves? Or are you saying decorators with args are unnecessary magic? Decorator arguments are certainly useful. Consider a hypothetical auth system based on decorating web route methods: @require_authorization(group="admins") def create_page(...): ... Writing these decorators can get complicated, as shown in the article, especially if you cram lots of functionality and flexibility into them (e.g. optional args, default values/config, injecting new arguments into the decorated function, handling errors, etc.), but used sparingly and appropriately, they can create beautiful, simple to use and understand APIs, as suggested above. Further, some of the most magical/annoying stuff to me, the functools signature matching and changing to or from decorator functions and decorator classes, is often necessary. Lots of code introspects a bit too much, rather than relying on duck typing, so stuff can break without this. Debugging and using help() also breaks down if you decorate function names and signatures away. 
I've been wondering the same thing. I keep starting to read them, but then two minutes in realizing that it's mostly magic and things that are kind of against PEP 20.....or just way over my head. I have a good understanding of decorators, but according to this guy I'm doing them wrong. 
The merge process described in this blog post seems *really* complicated and my gut feeling says that it's likely to invalidate one of the pros of separate code bases mentioned, namely &gt; A codebase that supports Python 2 and Python 3 forces you to only use features that are in both versions of Python, and makes your code ugly because you can't really use an already written patch for Python 2 in your Python 3 codebase, unless they are very similar, at which point the different codebases seem more like maintenance overhead than a real benefit.
Try python setup.py check --restructuredtext Sometimes it helps (not always :/)
Reading it at the first sight, I thought the same. But reading it from the first post revealed that they do not focus on magic. They focus on real world requirements. Writing some decorator is not a big deal. But when you or other people start to use it, then problems mentioned in the article arise. The motivation of the articles is that the author wanted to use other peoples code, but could not, because of poorly implemented decorators. The author goes through these problems and offers solutions. These solutions can often only be fulfilled with magic and python bug reports. If you or your users never experienced these problems, then fine. It is of no use four you. 
requests is awesome, but is it really required for simple scripts like this? And, if the api goes down your script will crash, with maximum recursion depth exceeded error (or something along those lines) raised, in like an hour and a half. Edit, while you're at it you should also make it python 3 compatible - it wouldn't be hard to do anyway and is nice to have.
On the other hand I find all of the counter-examples far more readable and pythonic.
fantastic tool, just got done playing with it, important to note the master branch seems to include a few fixes ahead of the dev branch. https://github.com/douglarek/pgist/tree/master
I'm guessing the tutorial you are using expects that you are using IDLE, which is interactive, and would display the results
Thanks for reminder, it is OK now
Good! I'm glad this wasn't taken the wrong way! As for the text, my only suggestion would be to read something non-technical once in a while. I'm convinced that grammar is at least partially transmitted through osmosis. I don't know of any English textbooks, per se...
I'm talking about the articles and the techniques they propose. &gt; the functools signature matching and changing to or from decorator functions and decorator classes, Signature matching isn't magic, it's a builtin function. &gt; Lots of code introspects a bit too much, rather than relying on duck typing Unless I'm mistaken the author promotes this kind of introspection. I've never seen it in the wild, outside of novices posting on Stackoverflow.
Hello r/python, I just create my first package. I would really like your input about it! thanks a lot!
Nice. Been looking for something like this. FYI: your pypi info points to github.ORG not .com 
 class NDayEMA(EMA): def __init__(self, n): self.n = n if n &lt; 2: print "ATTENTION: N should probably be bigger thant 2." try: print self.n a = 2.0000/(self.n + 1) # calculate a form n as explained on Wikipedia super(NDayEMA, self).__init__(a) # init the parent class with a except ZeroDivisionError: print "ERROR: N should not be equal to 1, ZeroDivisionError." exit() I think there are a couple problems that you can easily fix in this class. 1. The conditional which prints a warning. Just use `warnings.warn("n should be greater than 2 because ...")` or `assert n &gt;= 2, "..."` noting that they'll already see `n &gt; 2` as the error and that you only have to provide the "why." 2. Don't print! This is not a top level application. Once someone finishes figuring out how to use this, they don't want to see it spewing numbers everytime it creates a moving average. Additionally, print doesn't give you a line number, so it isn't something you can really work with. Much more friendly is `log = logging.getLogger('pyma')` ... `log.debug(self.n)` 3. `self.n` isn't used except by the `__init__`. Just use `n` then. 4. Why is the try except wrapping the super call? It doesn't look like it could raise a ZeroDivisionError. 5. `except ZeroDivisionError: ... exit()` should be except ZeroDivisionError: ... raise. You don't want to kill the program surrounding your tool if your tool is used incorrectly. An exception probably will do it and will allow them to wrap the exception, log the exception, ... 6. What is the except clause doing? Logging the error and quitting, but why. If you had no except clause, the ZeroDivisionError would be raised (`self.n = -1`), which would give a nice traceback directly to the line on which it is raised and they would immediately see that `n = -1` isn't valid. 7. Your only two comments don't tell us anything. Don't describe what you are doing (especially if it is very simple). All in all, I would probably rewrite that class as: class NDayEMA(EMA): def __init__(self, n): assert n &gt;= 2, "..." # from http://www.wikipedia.com/en/... a = 2.0000/(self.n + 1) super(NDayEMA, self).__init__(a) but then again, since the class doesn't really mean anything, it might be better to have class EMA(MA): ... @classmethod def by_day(cls, n): assert n &gt;= 2, "..." # from http://www.wikipedia.com/en/... a = 2.0000/(self.n + 1) return cls(a)
&gt; *1.* Maintain 2 completely separate codebases... Cons: You have to maintain 2 codebases. &gt; ... &gt; *3.* Support both Python 2 and Python 3 in the same codebase... Cons: Your code is ugly as shit because it has to support a wide range of Python versions. Maybe it's a personal choice, but "ugly as shit" implies some aesthetic issues and boilerplate, whereas maintaining 2 codebases implies *more* than just doubling your workload, because now you have to keep them in sync as well. Furthermore, I'm not sure what's so ugly about the 2/3 combined codebases I've maintained and seen. * Having some shim provide `unicode`, `bytes` and `str` types to make it clear cross-version exactly what string-ish type you mean, isn't very ugly. * The `err = sys.exc_info()[1]` hack required for py2.5 + py3 compatibility is kinda ugly, but once you drop py2.5, you're free to use ``except Exception as value``, and it's all pretty again. * Similarly, the `b()` wrapper hack is only required for py2.5. * Similarly again, the `u()` wrapper hack is only required for py3.0-3.2. * The changing module locations and deprecated methods for some things might be a bit irritating, but that has to be done anyways for minor versions -- like when simplejson got added in to stdlib, or when py3.3 deprecated ConfigParser's readfp() method. In summary, if your project targets python 2.6+ and 3.3+ only, I can't think of any 2/3 hack that maintaining minor version compatibility wouldn't also require. And comparing that list to double-developing everything... the two codebase approach is definitely not for me.
They do actually provide a python 3 compiler though. Fuck them, right?
&gt; The descriptor protocol is not magic I don't see anyone calling it magic.
Sorry to hear that you have a problem with it. I looked at it again but don't see anything that should cause anyone discomfort, AFAICT, except a little bit (maybe) due to the text from the right edge (the post labels, etc.) jutting out to the left, as I said before. And I view my blog regularly both from my laptop and from my smartphone. Maybe the issue(s) you perceive are due to my blog appearing differently to you than it does to me, which can easily be the case, due to the variety of browsers, monitor sizes and resolutions, or mobile device hardware characteristics (such as screen size, brightness, etc.). 
nice. will checkout. doesn't coinbase just follow the bitstamp cost by a short lag time (5-15 secs)?
ive noticed pricing differences longer then that.. i think theres some weighting going on in the background. 
[In case anyone sees this and doesn't understand it.](http://xkcd.com/353/)
I'd say that installing 3rd party module, that doesn't offer any advantages in this case, for short code *is* complicating things especially since same thing could be easily done with built in modules. It's not really an issue, don't get me wrong, it's just personal preference. Edit: I don't think timeout is the right approach, just don't call `getCurrentQuote` from within `getCurrentQuote`. As far as python 3 goes, you can easily make this code work both on python 2 and 3 at the same time.
I said that it was unintuitive and magical, not unfamiliar. I meant the adjectives I used! : ) If it had been in python 1 it would still be awful syntax. I have no idea what would be good syntax in lisp as I've no experience with it. Plus, I'm not sure there *is* a good syntax for this expression. (As in a unit of meaning, not the normal programming language sense) 
gotcha. thanks for this.
Any reason this uses sets? Seems Redis lists are more appropriate, since they offer BLPOP, BRPOP etc for atomic operations on list items instead of introducing your own locking.
clearer way to do this: (stdout, stderr), return_code = proc.communicate(), proc.wait() 
&gt; I said that it was unintuitive and magical, not unfamiliar OK, but I still don't see why you think it is unintuitive and magical. I would say that the present syntax, which mixes constants and expressions, is if anything more "magical".
The main issue is that there is no consensus about how a decorator should behave, yet. It is a powerful tool, and as such, it can be used (or in some view misused) in very diverse ways. The author has his own expectations. Some expectations: * Making a help(function) call is a way of introspection, too. * Some people want to write decorators that implement some functionality, and the same decorator can be applied on a function, a method, a class method and a class. * Some people write decorators that are bona fide public objects of a library. * Some people design code that make use of chaining decorators. * Some people using it instead of metaclasses, monkey pathing the class creation. 
Hey Marin, Very cool project! I'm curious what kinds of things you're using it for. Host discovery is an obvious benefit, and stats could be pretty useful as well. I was, until recently, a developer at VMware, focusing on the Workstation, Player and WSX products. Host discovery is something I always wanted, but never quite had the time to play with. This looks like it's mostly dependent on the VIM API. Have you considered compatibility with standalone ESX servers, or Workstation Server instances? (Workstation Server is basically just hostd running on Windows/Linux, and is otherwise pretty similar to standalone ESXi instances with some small differences here and there.)
Well, nothing specific, because I just took a quick look and came away with that impression. Certainly the first article says nothing about descriptors. I believe that's only relevant to the second article.
you need a life bro...
This coming from a guy who calls himself "django nerd"...
Actually, the first article *does* mention it, and the second article is dedicated to it. UPDATE: Seriously? Somebody downvoted this? I don't really care about internet points, but its worrisome to me that people downvote easily verified factual claims that are truthful. It's easy enough to go the article, hit Ctrl-F and search for "descriptor". It's there, because I just did it (again). I submitted all the articles to the sub already, and this article links to the first in the series, but was it because I didn't include yet another link?
Check out [docopt](http://docopt.org/) for making your CLI arg implementation tons cleaner.
Your post covers a lot of ground but really doesn't go deeply into anything which is leaving me a bit confused. Why do you think Django itself needs to be architected for the "realtime" model? One of your comments mentioned uWSGI which has some async support and there are currently efforts to provide improved throughput, performance, green threads, etc. Is the argument about web sockets and other similar technologies? These are really outside of the scope of Django and there is support for these in uWSGI or even on the proxy server level. These can and are being improved. Is the argument that Django has technologies that aren't relevant to the new style of application development? You don't have to use these. Is the argument that you want something that's "universal" in terms of model handling on client-side and server? This goes against the Django mantra of being an back-end framework. Also this is frankly quite a scary idea to me that seems to be useful for prototyping and rapid development, but not necessary an production-bound approach. For the record I'm mostly focused on the backend but am currently developing a sizable SaaS platform that's built with the SPA model using AngularJS, Node and Django. Django is used for any heavy lifting and Node for the rapid-fire stuff. Would it be nice to develop using a smaller stack on the backend? Sure, but sometimes you have to use the right tools for the job. 
Hey chipx86, I'm currently using vPoller integration with Zabbix for monitoring a vSphere environment along with other systems, which require access to the vSphere API. The discovery of objects is what is being also used in Zabbix in order to create *Discovery Items* of all vSphere Objects. I'll probably soon enough publish a separate post about the integration of vPoller with Zabbix as well as soon as find more spare time :) vPoller depens on pysphere which provides access to the vSphere Web SDK and ZeroMQ for communication between the vPoller components. So basically everything that speaks the vSphere API language should work with vPoller. I've only tested it with standalone ESXi servers and vCenter and it works fine. Haven't had the chance (and time) to test with Workstation, though. Regards, Marin
Are there any good benchmarks for these persistent data structures? I know the Vector (for example) gives near O(1) access (probably logn with a large base) but it would be cool to see some actual benchmarks to see how cache locality and the additional object creation impacts performance.
These are extremely useful information. I am quite new to python, around 2 month on and off. 
Have you thought about using OAuth's authorization code flow by firing up a webbrowser to Github and running a tiny web server on the client side that catches the authorization code redirect (where Github redirects to localhost:&lt;unique_port&gt; and your application handles a single request)? That way we wouldn't have to trust you with our username and password, only Github. Just a thought - thanks for putting this together!
There is only one comment there asking why not look at pypy, and I will put it here... For stackless features that they use and if they care so much about performance this seems like a saner approach than trying to go to python3.
One of the things that always upset me is the fact that Python doesn't have a Python Runtime Environment (a reference to the JRE for Java). That is, a simple piece of software that the end user could just install and that would allow him to run any python program easily. If you want to release your software for Windows you need to rely on 3rd party tools like cx_Freeze which is nice and pretty mature now, but it wasn't on the early days of Python 3. I think that calling Python a multiplatform language it's far from truth.
Thanks! I'll get that fixed with the next release.
&gt; That's a Linux problem don't you think? I remember observing a discussion about encoding I don't remember if it was Linux or FreeBSD. It basically ended up reasoning that since the filesystem does not care about the encoding, and is case sensitive then it should be just left as it is. Of course it's non-optimal behaviour by Linux, but it's not a big problem with Python 2. It is with Python 3. It's behaviour is broken. When you call `os.listdir` or similar with a unicode path, it simply ignores filenames it can't decode. That is not acceptable behaviour. &gt; You still did not give an example. UTF-8 is an 8-bit byte set encoding of the unicode. You're missing the point. Linux filesystems don't ensure that filenames are encoded in UTF-8 (or any encoding), regardless of what variables are set. It could be Latin-1, ASCII, UTF-32 or anything else. You simply cannot be sure unless you created the file yourself and are 100% certain no other software has been at it. Python 3 expects all text to be unicode, but it isn't. The whole argument against Python 2's unicode/str handling is that it's very easy to write code that breaks when fed with non-ASCII text, i.e. you have to be careful. With Python 3's str/byte handling, we now have a situation where the code *should* throw an error, but doesn't. Problems with Python 2 could be avoided with proper testing; these particular problems with Python 3 can only be avoided by doing an excessive amount of coding. Almost all of these problems would be alleviated if Python 3's `bytes` type had kept the same methods as Python 2's `str`. And I did give you an example: ZIP files created with the filenames using an encoding different to the nominal encoding of your Linux FS will be extracted with filenames that preserve the original encoding. The FS will not complain, and now you have files that aren't in the nominally correct encoding for the FS. If Python 3 can't decode them when you call `os.listdir` or the like (with a unicode path), it will *silently ignore those files*. This is a problem I have had to deal with. Apparently, you haven't (lucky you), but it is a real problem. 
Could you use a per-tenant named queue in RQ? So all worker nodes run the same set of queues, but there are dozens (hundreds) of queues. User-A gets a queue named "A" (probably better to use a UUID, but whatever), and you have a Redis key for the user-&gt;queue name. Their jobs get sent to queue name, and their dashboard shows only their queue name. Edit: RQ also supports job metadata. You could possibly do away with the per-tenant queue, and simply keep the relevant user id in the job as metadata. 
You should consider implementing WaitForUpdatesEx in VIServer. As it is, you're doing a full traversal of all the objects and properties you want to collect rather than just polling the changes, which is extremely inefficient. Pysphere's code isn't exactly intuitive (owing to ZSI being an ancient, un-pythonic wreck of a library) but it's not to difficult to do. You might also consider using pyvmomi (VMware's first-party library). Though it's not documented well, it is quite a bit faster. It would definitely be worth the time to figure it out for the performance improvement. 
&gt; Of course it's non-optimal behaviour by Linux, but it's not a big problem with Python 2. It is with Python 3. It's behaviour is broken. When you call os.listdir or similar with a unicode path, it simply ignores filenames it can't decode. That is not acceptable behaviour. Define LANG=C or LANG=en_US.ISO8859-1 before starting python. &gt; You're missing the point. Linux filesystems don't ensure that filenames are encoded in UTF-8 (or any encoding), regardless of what variables are set. It could be Latin-1, ASCII, UTF-32 or anything else. You simply cannot be sure unless you created the file yourself and are 100% certain no other software has been at it. Python 3 expects all text to be unicode, but it isn't. That's why you use LANG and LC_* (man setlocale if you want to know more about it) to tell applications to use. The system tools already obey it, why shouldn't Python do that? &gt; Almost all of these problems would be alleviated if Python 3's bytes type had kept the same methods as Python 2's str. I strongly disagree, using bytes is going back to the problems we had in 90s and early 00s. I suspect you did not experience them yourself, it's a pain. I think Guido speaking Dutch might have some part in why Python 3 has unicode. While Dutch language was a bit lucky since [ISO8859-1](http://en.wikipedia.org/wiki/ISO/IEC_8859-1) (Latin-1) had characters used by that language, just to be able to display € symbol they had to switch to [ISO8859-15](http://en.wikipedia.org/wiki/ISO/IEC_8859-15). &gt; And I did give you an example: ZIP files created with the filenames using an encoding different to the nominal encoding of your Linux FS will be extracted with filenames that preserve the original encoding. The FS will not complain, and now you have files that aren't in the nominally correct encoding for the FS. If Python 3 can't decode them when you call os.listdir or the like (with a unicode path), it will silently ignore those files. Zip (or rather zip implementations) are broken, it causes tons of issues and people are complaining about it alone: - http://marcosc.com/2008/12/zip-files-and-encoding-i-hate-you/ - http://www.nuxeo.com/blog/development/2012/07/qa-friday-choose-zip-filenames-encoding-charset/ - http://stackoverflow.com/questions/19547990/zip-or-unzip-a-file-with-different-file-name-encoding - http://allencch.wordpress.com/2013/04/15/extracting-files-from-zip-which-contains-non-utf8-filename-in-linux/ With this change Python 3 is one less application that causes issues. The issues you are experiencing is due to other tools being broken, and breaking Python to accommodate it is a bad idea. In my opinion Linux and other Unices should either standardize encoding for filenames or keep track of the encoding used, but that is another problem. &gt; This is a problem I have had to deal with. Apparently, you haven't (lucky you), but it is a real problem. I use UTF-8 whenever it is up to me.
No need to do that; pgist is **open source**, and github3.py too. That's all.
Please **save** your file first, then run it again, are you joking us ?!!
Not in CPython at least since Minecraft is written in Java. [jython](http://jython.org), on the other hand is a different story. I have no experience with it, but you might take a look at the [jython mod](http://www.minecraftforum.net/topic/1099989-123-jython-modding-100a-can-create-mods-on-python-lang/). Not sure if the mod is up to date with the latest version of Minecraft, though. Edit: Trying to submit and edit posts from an iPad is a soul destroying experience.
I'm new to serialization. Would serialization allow others to run the python session without installing additional libraries like Matplotlib? If I want anyone to be able to run it, would it be worth creating an exe? Sorry for the dumb questions.
Using assert to check arguments is bad practice. The optimizer (python -O, creating .pyo files) strips out asserts, meaning that those lines will potentially not be run. You're better off using an if...raise construct, since that will last. Doing so also gives you the option to choose the appropriate exception type.
I'd argue it's not the goal of a framework to be comprehensive. The third party modules are *enabled* by a core framework. I'd much rather use independently developed and supported extensions for specific use cases than expect all that built into the core. Just like Python has gradually learned to forgo the "batteries included" standard lib for better 3rd party alternatives (such as `requests` vs httplib/urllib). You're correct that the error in the "outside the scope" argument, is that Django should support asynchronous or real-time flows. It will take a major undertaking to re-architect the accumulative codebase including the WSGI standard to support async. There's plenty of Django (and Rails) both eschew modularity for a tighter-coupling between components to benefit that extensibility. I can count on a Django app to have a consitent ORM, configuration and template engine (compared to say, Flask). See [DHH's Omakase](http://david.heinemeierhansson.com/2012/rails-is-omakase.html) for an argument towards the complimentary nature of this coupling. What we need is a similar best-of-breed WebSocket type library to emerge in the Python ecosystem to standardize around. The challenge is that real-time dictates persistent asynchronous connections. Upcoming frameworks like MeteorJS also have significant coupling in their components and architecture. Last I checked, MeteorJS forced MongoDB (*vomit*) as the persistence store. Other components like authentication, templating and more are dictated by the framework. Still in 2014, real-time server generate updates are still an outlier compared the traditional CRUD actions required for a common content site. The real-time examples suggested in the article are pretty obscure (real-time customer reviews?!) and if they are essential, it's probably what you're product is all about (like real-time financial data). Django continues to provide the core capabilities required from most modest to high scale web properties. 
What's the purpose of your program ? Building a desktop gui is nice and all but sometimes a simple web form built with flask or django might just be enough for you.
As already stated, the majority of plugins for Minecraft are programmed in Java. However, building tools to work with game files can be done in Python. [MCEdit](http://www.mcedit.net/) is programmed in Python.
If you're willing to shell out $25-$35 for a Raspberry Pi, Mojang provides a free version of Minecraft specifically for the Raspberry Pi that includes a Python API for interacting with the environment. There are a number of resources for starting with this: - [Learning Python using Codecademy and Raspberry Pi Minecraft](http://www.raspberrypi.org/archives/4595) - [MCPIPY](http://mcpipy.wordpress.com/) - [This r/raspberry_pi post](http://www.reddit.com/r/raspberry_pi/comments/1kz8nr/learn_python_programming_with_minecraft_pi_free/)
I'm always looking to make my code more idiomatic. I'm not an expert on the subject quite yet, but I can share some things. 1) *File I/O with context managers*. At some places in your code, you have stuff like: f = open(fname, 'w') pickle.dump(data, f) f.close() It's usually seen as more idiomatic to use Python's context managers to handle the closing of the file automatically. So the above becomes: with open(fname, 'w') as f: pickle.dump(data, f) and the open file will always be closed automatically, even if an exception occurs during the call to `pickle.dump`. 2) *Conditional list comprehensions*. I saw some code like this: def remove(item, items, sections): titles = [i.title for i in items] if item in titles: found = items[titles.index(item)] items.remove(found) ... Without looking over your code too deeply, it looks like you want to remove an item with a specific title from items. We could do that with this list comprehension: items = [x for x in item if x.title != item] Actually, I may be a little confused as to what this function is doing. Since Python is so dynamic, it's hard to know what variables represent. We have to go by context, comments, and naming. If `item` here really represents a string that is an item title, I'd change the variable name to `title`. 3) Using `index`. You have a lot of code like this: def complete(item, items, sections): titles = [i.title for i in items] if item in titles: found = items[titles.index(item)] This business of using the `index` method isn't usually needed. Like above, we could instead just do: def complete(item, items, sections): found = [x for x in items if x.title == item] if found: ...do something... else: print "Item not found." 4) You have a bunch of code at the end of your module which reads the command line arguments and so forth. In python, all of the module-level code is evaluated whenever the module is imported. So, say down the line you want to use a few functions from this module in another. Whenever you import it, lines 237 until the end of the file will also be run in the module's namespace. While this probably won't hurt anything in this case, it is also probably not want you intended. Rather, you want line 237 and onward to be executed only when the module is run as its own program. To do this, wrap all of this code in the conditional: if __name__ == "__main__": 5) Re: your command line arguments. I don't know if you use `git` at all, but I think it has a pretty nice interface. A good interface for this sort of program might look something like: todo add "This is the title" --details "Details here" where the title is required and the details are optional. You could then have another command to remove something by title: todo rm "This is the title" You can implement these "subcommands" by using [subparsers](http://docs.python.org/dev/library/argparse.html#sub-commands). Overall, it's good that you're making an effort to write idiomatic code. I don't have too much time to go through your code more deeply at this instant, but if you have any more questions, feel free to PM me. 
Most distributions of python include Tk, and it's a pretty simple way to build a GUI. What platform will you and your colleagues be using to run the GUI application? You can read more about Tk (and TkInter) here: http://docs.python.org/2/library/tkinter.html
Plugins no, but a whole lot of custom Minecraft work is done in Python, you can check out some of the clients and other documentation at http://wiki.vg
Tkinter is built into Python. I strongly recommend using it as its very simple to use and fairly robust. Plus it comes with python so no additional packages are necessary. I've just recently found it and its extremely easy to learn.
Just use a [Miniconda3](http://repo.continuum.io/miniconda/index.html) installer (which is a Python 3 based installer which contains conda, also available for Windows) and setup a [conda](http://docs.continuum.io/conda/) repository.
I wouldn't suggest Python was incorrect to include the "batteries". It's justed evolved to the point where continuing to enhance the standard library actually comes at a deficit due to the ongoing maintenance of a built-in library (like urllib and urllib2). Compared to its origins, modern package distribution eliminates many of the obstacles to externalize those defacto standard libs (like `requests`). It's the same reason that node, or ruby or whatever no longer bundles all the key libraries (contrast to say Java). pip/gem/npm all make it easy to ala carte the features and libraries your project needs. And like the Python standard lib, Django must also be conservative about what capabilities to internalize and what can be provided by third party solutions. The ecosystem and community can provide the more niche solutions as long as Django continues to supply the core framework and architecture. You're correct on the need for fresh architecture to support these real-time flows. I think "share nothing vs share something" grossly oversimplifies the impact. The single stateless request/response flow is built into Django, WSGI and down to HTTP itself which unfortunately dictates an entirely new architecture. That same introduced "shared something" connection state can greatly complicate established web patterns (authentication and caching as 2 examples). In Django's case, because of the lack of an async flow in the WSGI specification, any opinionated approach to websocket-like connections will impact hosting and run-time container support. Instead, I'd suggest a companion framework be developed focused on the real-time aspects (which the Tornado/Twisted or Celery "hacks" as you call them provide). 
Hi, Thanks for feedback! I will definetely consider your feedback for the next improvement tasks. Regards, Marin 
I just use tornado for real-time. It can hook into django's orm and your model logic just fine.
I think the easy way is build a web interface, but if you want a "desktop like" program you can use Gtk (PyGTK, GI) or Qt (PySide, PyQt). I have a small code on GitHub (https://github.com/alexandrevicenzi/GladeBuilder), I use GTK and there's some examples. :)
Lots of code there ... how much is tests?
&gt; That's why you use LANG and LC_* (man setlocale if you want to know more about it) to tell applications to use. The system tools already obey it, why shouldn't Python do that? It should. But it should also give you the ability to work with broken files created by software that doesn't. It's a matter of an ideal world vs the one we have. &gt; I strongly disagree, using bytes is going back to the problems we had in 90s and early 00s. I suspect you did not experience them yourself, it's a pain. I think Guido speaking Dutch might have some part in why Python 3 has unicode. And I speak German, so I did and still do deal with a *lot* of non-ASCII text. I am *very* familiar with the pitfalls of encodings. Once again, you're missing the point (or deliberately talking about something else). Not all text is unicode, nor can it be reasonably coerced into unicode (like ZIP files). But it's still text (not binary bytes). That the blame lies with ZIP is beside the point: it's broken, and I have to deal with it. Python 3 makes that a lot harder. &gt; With this change Python 3 is one less application that causes issues. The issues you are experiencing is due to other tools being broken, and breaking Python to accommodate it is a bad idea. Python 2 isn't broken. It just bites people who pretend that text encoding doesn't exist. Thing is, Python 3 does the same, but it just silently swallows errors instead of raising them. You *still* have to be aware of encodings. &gt; In my opinion Linux and other Unices should either standardize encoding for filenames or keep track of the encoding used, but that is another problem. I agree. I really wish they would. But unfortunately they haven't yet, and I have to deal with that. Python 3 makes that much harder than Python 2. &gt; I use UTF-8 whenever it is up to me. As do I. But once again, it isn't always up to me. And Python 3, unfortunately, makes my life that much harder. 
I will think about the __main__.py, but for the rest I don't follow. Picnic is already an executable module. When you install it (either with pip or from the setup.py) it provides the 'executable' picnic.py and anywhere you just write "picnic.py MyModule" and it works.
Where's the Python?
What does the dollar have to do with this feature? How does the dollar sign suggest that you're going to evaluate the source in this way?
Some crank will inevitably criticize it, but The Elements of Style will help you write clear prose. Just keep in mind: it's a **style** guide; it contains plenty of rules against things that might be grammatically correct, but which you probably shouldn't make a core part of your writing. If you remember that, then you've already short-circuited a big chunk of the "criticism" directed at it (a great deal of which amounts to whining about how the book is wrong, because the critic's writing style is a unique snowflake that is being crushed by the oppressive rules in the book). The rules *are* designed to be rather boring, because they're focused more on making the writing convey the information at hand, not being "good", but it's like jazz: once you understand the rules, you know where you can break them.
The author is probably *too* sensitive about introspection, since his day job involves instrumenting pretty much arbitrary code to gather performance info, but there are plenty of legitimate use cases for introspection: debugging, instrumentation (for performance, or test coverage calculations, or `$YOUR_USE_CASE`), documentation, auto-suggest for interactive shells and/or editors, and probably lots of others I didn't think of in the 2 minutes it took me to type up this comment. It's not the sort of thing you want to break if you can avoid it.
&gt; It's not the sort of thing you want to break if you can avoid it. Right, but it's not clear that making decorators invisible *isn't* breaking introspection.
The first sentence has a link to the project page where all of that is explained. 
Well the usual options are the Python bindings for Qt, Gtk, and Wx. A new kid on the block is Kivy. I don't know whether all of these run on RPi or not. My issue with PyGame has always been installation: sometimes it installs, sometimes not, and sometimes it seems to install but audio is omitted. So, I guess if you're going that route, and you want users, think about install for all platforms.
Well, I guess that depends on the decorator's purpose, but I'd argue that the intent with *most* decorators is to be transparent (otherwise, people would probably wrap them explicitly).
Unfortunately, many efforts that attempt to explain decorators don't do justice, and make things more complicated that they should be. The best explanation to me is from [wikipedia](http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators). Simply, a decorator is a function (or callable) that takes in another function f, returns a function, which is assigned to f. This act is a decoration or annotation of f. In other words, @my_deco def f(): pass is the same as: f = my_deco(f) Since a decorator is just a function (or callable), if you want to make it decorator that accept arguments, you just need to create a decorator that returns another decorator. 
*Here's the linked section [Decorators](http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators) from Wikipedia article [Python syntax and semantics](http://en.wikipedia.org/wiki/Python_syntax_and_semantics)* : --- &gt;A decorator is any callable Python object that is used to modify a function, method or class definition. A decorator is passed the original object being defined and returns a modified object, which is then bound to the name in the definition. Python decorators were inspired in part by Java annotations, and have a similar syntax; the decorator syntax is pure syntactic sugar, using @ as the keyword: &gt; &gt;is equivalent to &gt; &gt;Decorators are a form of metaprogramming; they enhance the action of the function or method they decorate. For example, in the above sample, viking_chorus might cause menu_item to be run 8 times (see Spam sketch) for each time it is called: &gt; &gt;Canonical uses of function decorators are for creating class methods or static methods, adding function attributes, tracing, setting pre- and postconditions, and synchronisation, but can be used for far more besides, including tail recursion elimination, memoization and even improving the writing of decorators. &gt;Decorators can be chained by placing several on adjacent lines: &gt; &gt;is equivalent to &gt; &gt;or, using intermediate variables &gt; &gt;In the above example, the favorite_color decorator factory takes an argument. Decorator factories must return a decorator, which is then called with the object to be decorated as its argument: &gt; &gt;This would then decorate the black_knight function such that the color, "Blue", would be printed prior to the black_knight function running. &gt;In Python prior to version 2.6, decorators apply to functions and methods, but not to classes. Decorating a (dummy) __new__ method can modify a class, however. Class decorators are supported starting with Python 2.6. &gt;Despite the name, Python decorators are not an implementation of the decorator pattern. The decorator pattern is a design pattern used in statically typed object-oriented programming languages to allow functionality to be added to objects at run time; Python decorators add functionality to functions and methods at definition time, and thus are a higher-level construct than decorator-pattern classes. The decorator pattern itself is trivially implementable in Python, because the language is duck typed, and so is not usually considered as such. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/vph can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(*how to summon*: **wikibot, what is something?**)
Everyone saying no in this post, isn't it possible with something like Jython? 
The link is here: http://www.stanford.edu/class/cs240/readings/threads-bad-usenix96.pdf. I've updated the doc. Will land on Github when I next push.
I will do some simple benchmarks for the next release.
&gt; is O(&lt;7) Also keep in mind that O(7) ~ O(1) only asymptotically, so for vectors of say millions of items you could (theoretically) be 7x slower than a normal array that doesn't need to do multiple lookups. This is in addition to any other penalty caused by the additional objects created and cache misses due to data being more spread out. &gt; I'm going to prepare benchmark after reimplementing everything as C-extension Awesome. Looking forward to it.
Apart from qt, I'll be sure to have a look at how those other ones work out. As for the installation issue, raspbian comes with pygame installed, and audio works too. The reason qt and tkinter don't appeal to me is that when I had a look into learning that stuff, it seemed very strange and not straightforward. It seems like a bit more of an advanced level thing, and I prefer to know how something works from the ground up. I'm sure qt and tkinter are great, just not for me. Thanks alot for the feedback though. :D
I think that, for what you're suggesting, pygame would be perfect. I know there are UI libs for pygame, but I've never used them. I've always "rolled my own" on pygame, and I think you might be able to come up with some really unique UI elements if you do so as well. Based on talks I've seen for Kivy, it would be pretty snazzy too.
May I ask what you mean? (It's worth noting that this is horribly optimised; the line `(p for p in primesSoFar if p &lt;= int(math.sqrt(candidate)))` is a no-op.)
Yeah all of those things are a bit tricky -- in my experience, Qt especially has too many layers of abstraction. And I guess you're saying that Pygame is a bit more down to earth? But, there is a genuine reason for the abstraction: when you're building bigger systems, the way Qt/Gtk/etc works does make more sense. I don't think you'll find any GUI toolkit that's more direct than Tkinter.
&gt;Preventing people from treating such strings of bytes as characters is like insisting that integers can not be manipulated as hex because the "proper" interpretation is decimal. No, it is not. The proper interpretation is *a number*. If people index the number to get a hex digit, a decimal digit or *any base whatsoever*, that is a grave mistake. A number is like `bytes`: it has *no* encoding. You should not be able to pretend it does. That's why you have to call `oct`, `hex`, `bin` or whatever. This is exactly the kind of thinking that is confusing people with `bytes`. `bytes` are just "lists" of integers within a capped numeric range, useful because they can represent raw data streams and map directly to storage in hardware.
Heh. Nice. That doesn't really change too much, though, because you're not formatting with "the encoded version of '%s'" but "the ASCII encoded version of '%s'", so there is no ambiguity. The reason to choose that is because it fits the `repr`, not because those bytes actually mean much. The reason this is useful is for stuff like my_protocol_bytestring % ( body.encode('encoding'), some_module.HEADER_CONSTANT_BYTES, etc ) which is useful in some things where you need to make a lot of bytestrings. It could be an auxiliary function, though, and the only reason that hasn't gained much support AFAIK is "it's not fast enough".
I use wxPython as the GUI toolkit and you can turn it into an executable with py2exe (for Windows). You can turn anything into an exe with that. If it is not very fancy, having a few widgets to adjust your parameters and show an output would be like 30 min worth of work, if that, once you are comfortable with it. If you do use it, I recommend GUI2Exe as a really nice interface to py2exe. (On Mac, there is py2app and for Linux cx_freeze...there is also PyInstaller and other "packagers") As others have said, you can do it as a web app instead, but for me that's a *hugely* larger effort if you aren't already making web applications.
or better (in case both strings together are longer than a terminal line, and your terminal doesn’t reflow): (download https://gist.github.com/jtriley/1108174) from time import sleep from terminalsize import get_terminal_size w, _ = get_terminal_size() for string in strs: assert len(string) &lt;= w fill = w - len(string) print('\r{}{}'.format(string, ' ' * fill), end='') sleep(.2) print()
from the docs: &gt; Traditional queuing solutions in Python don’t easily allow users to ensure that messages are unique; this is especially important when you’re generating a lot of time-consumptive tasks that may have overlap. Redset can help with this, among other things.
Can it list processes in a hierarchy?
I've always used xlwt for working with XL files in python.
In general, I agree. I think here my assumption is that the argument is not a user input and is something specified while writing the code, which I take to mean we can allow assert checks. Maybe better put, I don't think anyone will want to catch an AssertionError here.
I thought as much, and while I did look at wxPython for doing this kind of thing, It seems making my own simple set of modules would be good practice and a fun way to get the UI system tailored to my needs. However, I was wondering with pygame, should I base my own UI classes off of the pygame.surface class? Or just make a class with the surface as one of the attributes? Or is that a question for /r/learnpython? Edit: Minor fixes
&gt; What does the dollar have to do with this feature? I chose ``$`` because it's one of two ascii characters unused by Python (the other one is ``?``).
I have been looking for a Python library with instant and duration datatypes to implement a library for working with the [Extended Data/Time Format](http://www.loc.gov/standards/datetime/pre-submission.html), similar to what is [available in Ruby](https://github.com/inukshuk/edtf-ruby). Any thoughts if your library would lend itself to such an extension?
Exactly. The syntax's got absolutely nothing to do with the functionality. That makes it bad syntax in my opinion and hurts readability in my opinion. 
external utilities, [sure](https://pypi.python.org/pypi/nbt2yaml/). Bukkit plugins, no (I see there's a Jython loader, OK, but still, Bukkit is difficult/unstable enough without having to translate across languages - Jython itself is under-maintained and doesn't perform very well currently) . Client hacks, no way.
I finally got all the dependencies installed and got vpoller-proxy and vpoller-worker running. Had a few bumps along the way and was pleasantly surprised to find the example commands for vpoller-client worked. Pretty interesting middle-ware for vCenter monitoring, I like the way the data is returned in a consistent manner (JSON) so I'll know what to expect when implementing it.
[Kivy](http://kivy.org/) may be what you're looking for - it's a cross-platform multitouch GUI framework for Python. It uses pygame underneath, but you don't really have access to pygame from it.
Kivy was designed from the beginning for touch interfaces.
&gt;&gt;A number is like bytes: it has no encoding. &gt; &gt;Sure it does. That encoding is just at the bit level. The first bit represents a count of one things. The second bit represents a count of 2 things. The third bit represents a count of 4 things. I disagree. Numbers do not have to be encoded on to bits. They could be encoded on to tristate variables, strings or lists of enumeration members (much like `Decimal`). Python doesn't have a set "bitness" for its integers as they are infinite length and thus not encoded as single segments of memory. Heck, Lua encodes its integers as floats! &gt;&gt;bytes are just "lists" of integers within a capped numeric range &gt; &gt;Then they are misnamed and less useful than they could be. Normally the term "bytes" refers to a series of groups of 8 bits. There is normally no implied numeracy. You may be right. There is at least evidence to that claim. Further, I seem to have no ideas why one would reasonably use arithmetic on these bytes, and hence I *do* find it odd that they are numbers. An (ordered?) byte enumeration where each byte can be *indexed* seems just as reasonable to me! This is effectively what Python 2's `str` type did, if you ignore its double-usage as text. Nonetheless, languages preceding Python have made it clear that they want to use "`byte`" to mean a bounded number of the range [0, 255]. This might actually be an interesting topic to raise on the Python mailing list...
Has anyone ever used this [xmltodict](https://github.com/martinblech/xmltodict) library? I've been using lxml and its xpaths for traversing xml/html and I gotta say it's not fun and this looks simpler.
That's exactly what the python install is. Download it, install it, run python apps. What else would you need?
https://pypi.python.org/pypi/rpitemp/1.0.1 https://pypi.python.org/pypi/WMI/1.4.9
In case you don't get an answer here, try the IEP discussion group: https://groups.google.com/forum/#!forum/iep_
Already got a post there too. Edit:jk I have a post on another forum
It's telling that the author takes as given that all the scraping would be done with Python. Scraping anything with R is a time-consuming nightmare, to put it mildly. Gonna give this one to Python.
Interesting. This first test seems to be focused on ease of coding in the two languages for a relatively small and easy to understand bit of data and how simple it is to get a simple but effective visualization. I'll be interested to see whether they deal with more complex and larger data sets and the relative performance differences between the two.
How many rounds are there? 
Currently 3 total planned. More as our schedules allow.
From what I read on that SO question (yes I've seen it before posting, I did research), cputemp wasn't compatible w/ windows and for this project I'm using win7, if I could use only linux and nothing else I'd have something written up and working by now.
&gt;not sure if the WMI will provide accurate temperature data I actually just confirmed it isn't, just to be sure.
Next challenge will be up in a few hours and you might surprised how "easy" it is to scrape data from websites using the XML package in R. It was my first ever scraping, and I found it surprisingly easy despite the poor HTML structure of the website we scraped the data from. 
Webapp. Flask or Tornado are easy to get started with. GUI toolkits are a dependency nightmare by comparison.
Challenge #2 is up at: http://www.theswarmlab.com/r-vs-python-round-2/ Source code at: https://github.com/morpionZ/R-vs-Python/tree/master/Deadliest%20movies%20scrape/code
is there an R subreddit?
No problem! Glad you found the concept useful.
Actually, the curly braces are quite similar to the notation used for sets (hence the curly braces used to create sets in python 3+). It's not too difficult to imagine a dictionary as a set of tuples, so I think that syntax is pretty good. Besides, when making a new syntax, if the syntax doesn't 100% obviously suggest the functionality, you have to make a trade-off between utility and clarity. Even if you knew nothing about set notation and/or thought the link between sets and dicts were nonexistent, the clarity gained by the terseness of the syntax compared to the alternative (e.g. java's obnoxiously verbose syntax) vastly outweighs the possible unnaturalness of the syntax. The feature proposed here comes nowhere close to that point in my opinion.
 %pylab inline That's not python code. from pandas import * And you just lost every reader who knows python but not pandas. I'm somewhat familiar with pandas, but this is a shitty programming practice. I stopped reading here. 
Thanks for this!
Looking at the expressions I see that date and phone are very US-centric. Examples: &gt;&gt;&gt; date.findall("14.01.2014") # DD.MM.YYYY, used in Germany [] &gt;&gt;&gt; date.findall("14-01-2014") # DD-MM-YYYY, used in the Netherlands; works! ['14-01-2014'] &gt;&gt;&gt; date.findall("1814-01-14") # ISO 8601 (see http://xkcd.com/1179/) ['14-01-14'] &gt;&gt;&gt; phone.findall("(0 30) 25 98 - 0") # Berlin, Germany [] &gt;&gt;&gt; phone.findall("+49 89 636 00") # Munich, Germany, with international dial code [] &gt;&gt;&gt; phone.findall("+31 (0) 882882888") # The Hague, Netherlands, with international dial code [] &gt;&gt;&gt; phone.findall("+1 410 576 6700") # New York, United States, with international dial code; works somewhat, information about international dial code is lost ['1 410 576 6700']
[Image](http://imgs.xkcd.com/comics/iso_8601.png) **Title:** ISO 8601 **Title-text:** ISO 8601 was published on 06/05/88 and most recently amended on 12/01/04. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=1179#Explanation) **Stats:** This comic has been referenced 67 time(s), representing 0.77% of referenced xkcds. --- ^[Questions/Problems](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Website](http://xkcdref.info/statistics/)
I'm one of them. R has way too many quirks for me to handle. Nowadays I only use it from rpy2.
Flask will--if not already--supersede Django in popularity as the go-to python web framework.
Hi Wudan07, Happy to hear you find it useful! :) Regards, Marin
What is this pony, and how do I irresponsibly promote it? :-) 
Hello Saboot. Have you seen any open data provided in HDF5? I haven't seen anything before, but it could be great if you have an example.
Thanks! http://en.wikipedia.org/wiki/Open_format
*Here's a bit from linked Wikipedia article about* [***Open format***](http://en.wikipedia.org/wiki/Open_format) : --- &gt;An **open file format** is a published specification for storing digital data, usually maintained by a standards organization, which can therefore be used and implemented by anyone. For example, an open format can be implemented by both proprietary and free and open source software, using the typical software licenses used by each. In contrast to open formats, closed formats are considered trade secrets. Open formats are also called **free file formats** if they are not encumbered by any copyrights, patents, trademarks or other restrictions (for example, if they are in the public domain) so that anyone may use it at no monetary cost for any desired purpose. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/westurner can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**To summon**: wikibot, what is something?) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/Python/comments/1v3nak/a_python_guide_for_open_data_file_formats/cep66bk)
Which object did you use? Ive used MSAcpi_ThermalZoneTemperature before with Windows Powershell and its worked ok...
I'm not entirely sure about the point of this "shootout". There seems to be no benchmarks, or anything measurable. All that's given are a set of solutions to the problem in either language. Is the point merely to measure something subjective, such as which language provided the more elegant solution? But if that is the case, then even that discussion seems to be lacking. The solutions are merely presented without significant comment. Am I missing something?
The first date format is often used with (rather arbitrary) spaces: &gt; \14. 1. 2014 (the backslash is there to avoid auto-formatting) &gt; 14.1. 2014
Again, I want something specific to the end user. The Python install for Windows is exactly the same for development. End user install doesn't need half that crap 
The script was running in IPython, which has the magic function pylab. Also, IPython users usually run from xxx import *. 
[PEP 8](http://www.python.org/dev/peps/pep-0008/) does specify that you shouldn't do this &gt;Wildcard imports (from &lt;module&gt; import *) should be avoided, as they make it unclear which names are present in the namespace, confusing both readers and many automated tools. 
Interesting. It seems your use case is more like a classical task scheduling system, which in many ways clashes with the core principles of celery (message passing, queue as a stream, etc). Often this includes features that requires stopping and resuming the world, like reprioritization, or requires central access to , or a copy of, the original request for retrying a task in the user interface after it failed. The intention was always that this would have to be built on top of Celery, and I would like to see a standard extension for it. 
Btw, if I'm mistaken here and you only want a way to associate tasks with a specific user then it should be fairly simple to add a new task message header and use that in the flower interface to display only the tasks for a particular user.
The email one is missing some detail: http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html
Looks nice and everything, but if you don't mind some constructive criticism, talisker == Talisker, but talisker doesn't produce any results. But other then that, it looks really nice and minimalist, so good job.
* sees "from pandas import *" * closes tab
Fairly clean for a first app, good job. I'm no expert myself, but I did notice a couple things though. Look into [PEP-8](http://www.python.org/dev/peps/pep-0008/). It's a style guide for Python code. You could also look into using an IDE that has PEP-8 validation built-in. Personally, I use PyCharm 3, but there is tons of other choices. You should use abort(404) instead of redirect('/404') when you can't find a page. The "problem" with that redirect is that it doesn't throw an HTTP error code 404 as you should when you can't find a page, it just returns 200 OK. You can still have a custom error page with abort, look at [this page](http://flask.pocoo.org/docs/patterns/errorpages/) in the Flask doc. Lastly, things like: if reference == None should be: if reference is None because ***==*** is for value testing while ***is*** is a test for object identity. None is an object identity. 
Many large scale Earth Science datasets are in HDF. For example, the [full GEOSECs dataset](http://iridl.ldeo.columbia.edu/SOURCES/.GEOSECS/) (distributions of elements in the oceans) is only available as netHDF.
My mistake :)
On the upshot, this software is not designed to reject email addresses that don't match its pattern. Rather, it will have false negative matches. If the intended use case is for scraping/mining a large corpus, it might be acceptable to lose some content.
An *open format* is not the same thing as a format that *open data* is distributed in. For example, I'm writing software to analyze chromatograms (e.g. chemistry data; naturally it's in Python) and there are many different formats out there. Some are open, e.g. netCDF or mzXML, and some are proprietary to a specific instrument vendor, i.e. the specs for the format are not publically available so you can't open them without that vendor's software (which is part of what I'm working out). Even though quite a few people probably use the open netCDF format, none of their data is publically available (and thus "open"). As an opposite example, the process of creating GIF images was initially patented so at one point you could have been distributing Creative Commons data as a GIF. This would still be open data, but in a non-open format.
Nice. Comments: I would prefer the URL structure to include the name of the whisky itself, rather than an opaque ID. And the titles of matching whiskies should link to their own pages.
Please send PRs to https://github.com/morpionZ/R-vs-Python/blob/master/Deadliest%20movies/code/code.py if you think there's a better way to code it -- we're constantly updating the blog post to represent the best programming practices of each language.
I've made an app that does the exact same thing for beer! Check it out: http://brewkeep.com/brewkeep/breweries/
&gt; Making a method synchronized means it is not possible for two invocations of synchronized methods on the same object to interleave. On the same python process instance on the same machine. As a web monkey I have a similar decorator like dat, but based on DB. (Poor choice I know, but it's easy to use and very practical.) 
I prefer: if not reference
Thank you, man. Elsewhere someone already mentioned the case sensitiveness issue, and I already added it to the [issues list](https://github.com/cuducos/whiskyton/issues)! I’ll get rid of this issue as soon as I can :)
This is pretty sweet
Thanks! Sign-up! I'm working on a re-design of the site as it looks sort of ugly and dated right now. A mobile app is also in the works as that is critical for getting users.
Indeed, me too. I should've mentioned it. Thanks!
Woah! Thank you for pointing me to the right direction! Straightforward comments like this really help me to know where to focus on the next steps :)
Thanks for the advice. As silly as it could sound, I have no idea about what would be a setup.py for this project. With your comment and little googling I realize how practical it could be :) Thanks, mate! I added to my issues list and I’m working on that soon!
Alcoholics geeks united! Woah!
sounds kinda familiar 
Thanks for that catch. I'll get to work on fixing up the email regex issues.
Thanks for the catch... this needs to be fixed. Although I'm not sure it's worth it to support those more esoteric matches at the risk of including many more false positives. It's something I'll have to think on for a bit.
You're entirely right, armerthor. I've got a short sentence in the readme that mentions this, but it's something I want to eventually fix. Everything is a trade off -- fewer false negatives inevitably come at the cost of more false positives. That being said, international date at phone support is something that needs to happen, and something that I'll make a priority. Also, the xkcd reference is pretty great. Thanks for your feedback, armerthor.
I suspect the IPv6 regex will fail hilariously, and is really difficult to read. This is the one I came up with, and it has AFAICT complete unit test suite with it (check the link to Pastebin): http://stackoverflow.com/a/14452783/1999151 But thank you for putting this together!
Considered ZooKeeper?
Community Edition is free for everyone. ;)
A lot of pandas users do from pandas import * Many of the pandas tutorials show pandas imported that way. One of the reasons is because there's no agreed upon shorthand for the import. e.g. matplotlib usually is import matplotlib as mpl Personally, I import pandas as pd. It's also partly because a lot of pandas work gets done in ipython notebook which is essentially a repl where the pitfalls of 'from x import *' are less of a concern.
But is limited. No remote interpreter, deployment and a few other things I like to use. I tried out the Community version before applying for a OSS License myself. http://www.jetbrains.com/pycharm/features/editions_comparison_matrix.html
 It's great when it works, but it's worth pointing out that it isn't always synonymous with `if reference is None:`. For instance, if `reference` can be `None` or any integer, `not reference` will evaluate as `True` when `reference` is `None` or zero, while `reference is None` evaluates as `True` when `reference` is `None`, but `False` when `reference` is zero. 
Err I have run into some nasty bugs because of this. Too many different things act like True and False in python besides None. 
Will do, thanks!
I've dabbled. I was considering using ZooKeeper for distributed locks, but we already had a Redis store in the loop, and our locks aren't all that complicated, so we wound up using Redis instead.
it a quick 1 shot script to get your current balances and send/withdraw btc. cool. i would two thing - user account info should be in a config file. this make actions quicker.. 'immediate' order placement for example - the code in self.parse() and arguably self.run() should probably happen before you initialize your class in main, passing the arguments to class on init. 
Actually, not yet. /r/scotch just wants reviews, my data set has no whiskey for /r/whiskey… and I haven't though of /r/bourbon haha
Very cool app! A quick feedback: would it be possible to include the features of the whisky we researched, not just the similar ones? That way, it would be possible to understand in what they are similar, and in what they differ.
I can't find any results.. tried Jack Daniels but nothing came up.
`laphroaig` is being spelled `laphroig` - problem with your database? 
getting configuration and user input options almost always happens before class init. also for re usability reasons. If i import Manager() in its current state to just use place_an_order(), i have no choice but to call self.parse() and take arguements because you have coupled the optparse block to the init of the class. 
the [source data set](https://www.mathstat.strath.ac.uk/outreach/nessie/nessie_whisky.html) only contains 86 whiskeys :(
Nice work. I'm hoping I can get enough time and motivation to finally get my app idea up and running. Do you have a ballpark idea of how long this took you, from start to finish? I'm curious. 
The gotcha is with None, which you can avoid unless writing very generic things. When you know which kind of objects you're working with (None ruled out) there's only one sensible meaning remaining for its truthiness.
Quite nice for a first webapp! It was actually quite accurate in my taste for other whiskeys! Some stuff that can be improved has already been pointed out, both in the code and visually so you should get cracking with that. If you could either find a larger and more complete database that would be great, but you could also integrate a "contribution" system where we whiskey lovers can enter data und make your database grow organically! Im sure you have a distinct set of values for taste, smell, body, color etc etc. Really good job, once again. Keep going! 
This is literally the worst post I've ever seen in this subreddit. Not only did you ignore the sidebar, but you ignored the big red text on the submission page. Even worse, this question would easily be answered by a search. Worst of all, you expect us to do your fucking homework for you.
&gt; open data https://en.wikipedia.org/wiki/Open_data
&gt; For example, I'm writing software to analyze chromatograms https://en.wikipedia.org/wiki/Open_science
I'll leave it to you to write the code, but here is some food for thought that might help you figure out how to do it. How do you examine every item in an input string? Probably some kind of loop or iterator. When examining an item, how do you check to see that is an 'a' character? Its very simple. There's an operator for it. Check the documentation to see what I'm talking about. Finally, some advice on how to get better at programming. In general you cannot rely on people to do it for you. The nature of learning programming is learning how to do things you have not done before. This really means spending time reading technical documentation and experimenting with small sample programs. Get to work!
As far as https://en.wikipedia.org/wiki/Linked_data : * [schema.org/Dataset : Standard schema for linked data in HTML Microdata, JSON, RDF, RDFa, OWL, Turtle, CSV](http://www.reddit.com/r/semanticweb/comments/1dvakc/schemaorgdataset_standard_schema_for_linked_data/) * \` &lt;ENH: Linked Datasets (RDF)&gt; https://github.com/pydata/pandas/issues/3402 \`_ 
http://pythonhosted.org/setuptools/setuptools.html#namespace-packages
Here is my suggestions for a solution. It might need to get parallelized for larger inputs ;-) from random import shuffle, choice str1 = "faaawfijasdf" str1 = list(str1) while len(str1) &gt; 0: shuffle(str1) seperator = choice(range(len(str1))) if set(str1[0:seperator]) == set('a') and not 'a' in set(str1[seperator:]): print seperator break
Wow! Thanks, man! The crowdsourcing idea to enhance the database is awesome :)
Somebody elsewhere already asked me that, and it is indeed in [my issue list](https://github.com/cuducos/whiskyton/issues). But thanking for reinforce this visual design issue. By now what I can say is that he “reference” whisky (the one you input) is shown in all charts in gray (while the blue area/stroke are the charts of the recommended ones), ok?
Meh… Jack Daniel’s, although a great bourbon, is not a whisky… that’s why. Whisky is a kind of trademark form Scotland and anything produced elsewhere is considered whiskey (with an ‘e’). The database I’ve found looks only for whisky, and only for malt whisky (what excludes, for example, Johnnie Walker, another global brand). Anyway, if you like Jack Daniels, I’m sure you’ll like Bowmore! Give it a try haha…
For sure. Cool project, by the by. Intersection of two of my favorite things - python and whisky, that is. Godspeed in your future endeavors. :)
No problem, mostly curiosity anyway. Nice job, thanks for replying. :D
This is awesome work. I built a GTK3 app a couple of years ago and figuring out he PyGObject API was nothing but suffering.
I prefer [flake8](https://pypi.python.org/pypi/flake8) as a linter (over pyflakes, pylint, etc).
I don't like it, it's just the first thing that came to mind. What about Canadian Rye Whisky?
The only thing I have to add is look into using [Alembic](https://alembic.readthedocs.org/en/latest/) instead of Migrate. Migrate is a dead end project, while the guy who created SQLAlchemy created Alembic and it's in active development.
yes, well the page points out that there **is** no canonical regex. Personally, I'd have a smaller regex that allowed some false positives
This reminds me this post: "Of running multiple regexp at once", http://fulmicoton.com/posts/multiregexp/
Just got around to checking out that regex, frymaster, only to remember the monster that regexes can become. Definitely sticking with a few false positives for now.
In the "old days" we'd put a gui app on a network drive, which is similar. Depends on requirements.
Very nice.
That's not necessarily the only gotcha. Objects which override `__bool__` (I think it has a different name in py2) also might not behave as you'd expect in such a comparison. Although the whole idea of `__bool__` is to make such comparisons work well even in weird edge cases, but it can be misused.
Very cool! Just one note. The README can point the user on how to install the dependencies easier: pip install -r requirements.txt 
I know /r/scotch only wants reviews, but I think your app is sidebar worthy over there. If you look many posts are along the lines of "I'm a beginner, I really like this one scotch, what are some similar scotches?" which is exactly what your app does. If you're paranoid make it a self post so they don't think you're karma whoring.
I was about to say I'd like to move to where you are haha
Olde English and Colt 45 seem to be missing as well. 
Cheers, mate! 
It’s also a non-Scotch blend… so I’m afraid it’s not there either. You can take a look on [the complete database](https://www.mathstat.strath.ac.uk/outreach/nessie/nessie_whisky.html) or in [this short list with the distilleries](http://whiskyton.herokuapp.com/whiskyton.json).
Wow! Didn’t know about it! Updating it now :)
Unfortunately the [open dataset I’ve found](https://www.mathstat.strath.ac.uk/outreach/nessie/nessie_whisky.html) is not so vast…
I'd like to add to this that when using pip be sure you execute it with --egg: pip install -e . --egg There's some more info on why there's a need for this here: http://stackoverflow.com/a/13893135
Thank you very much, man! Deploying with the typo fixed now :) 
No problem! Just filling a little hole I noticed. Let me know if you have suggestions for improvements...
Usually I use `None` as a very specific, non-value. I want to test that the thing is *exactly* a non-value (it's exactly "nothing"), and then execute or reassign based upon testing this. Doing that is just always more specific and less error prone than testing if thing evaluates to False. `""` is a completely valid python string that evaluates to False. This is one major case where I want to test a value being a specific *non-value* rather than a string (and an empty string may be completely valid).
Hey iBlag, one of my goals for the near future is to add a unit test suite to the repo. I'll also check out that IPv6 regex you've linked -- if it has more complete support for IPv6, I'd be interested in migrating CommonRegex's ipv6 regex to that one. 
Can I suggest using the logging library instead of "print"?
Cool app! The website looks good and the code is pretty clean. I have a Flask related tip for you. You could change [this line](https://github.com/cuducos/whiskyton/blob/master/app/views.py#L61) @app.route('/w/&lt;whiskyID&gt;') to @app.route('w/&lt;int:whiskyID&gt;') This forces Flask to typecast the whiskyID variable to an integer, which makes [line 63](https://github.com/cuducos/whiskyton/blob/master/app/views.py#L63) unnecessary. This obviously isn't a huge deal, but it saves you a line :) Cheers!
Do you have any intent to collect data and grow the database? I think I figured out how recommendations are made (the DB contains them in advance?), but if you're interested in recommender systems stuff it might be a fun future project to incorporate something allowing you to solicit preferences and build a personalized feedback system :)
&gt; ...if I'm mistaken here and you only want a way to associate tasks with a specific user... My problem goes beyond just associating tasks with a specific user, although I believe that is what OP asked. &gt; The intention was always that this would have to be built on top of Celery, and I would like to see a standard extension for it. Do you simply mean multi-tenancy, as I described? An arbitrary number of task queues that can be rate-limited independently and respect FIFO locally? I am still relatively unfamiliar with many of the implementation details of celery, so perhaps you could elaborate on those core principles and how my use case clashes with them?
not super efficient but key = 2 myList = [1 ,2 ,3 ,4 , 3, 6, 2 , 2] for i in enumerate(myList): if i[1]==key: print i[0]
Cool thanks! Also this was just one way. If you have a better way, I'd love to hear it. 
rock the 40oz
Without something to index on (like a hash table or something) or a sorted list (which may not be acceptable, I'm pretty sure you are limited to an O(n) search like this. 
I find tuple destructuring makes this even nicer for i,e in enumerate(l): if e == x: index_list.append(i) 
What version(s) of Python are you targeting? I figured I'd ask before I start proposing changes.
 index_list = [i for i,e in enumerate(l) if e == x] or if you're not into the whole brevity thing: import itertools, operator, functools index_list = list(itertools.imap(operator.itemgetter(0), itertools.ifilter(lambda (_,e): functools.partial(operator.eq, x)(e), itertools.izip(itertools.count(), l))))
Thanks for sharing. Cudos for your first app. Looks great and as a Scotch-Lover I really loved it. But the reason I am writing is to say thanks for the mention of [The Flask Mega-Tutorial](http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world). That way I found a resource, that would help me learn flask. Thanks a lot for that. Till now I was writing scripts and little programs to make my life at work more easy. Maybe in the future I can put out some ideas, that I still have inside my head. [Edit: Typo]
Using list-comps index_list = [i for i,v in enumerate(l) if v==x]
This tutorial was very important for me! In fact, later I realized that there are a bunch of things there that are not updated (for example Migrate – instead of Alembic for db migrations). But still a very good guide for beginners though.
2.7.4 (the one I’ve seen as default in Heroku server). But I have no idea if that was a good choice. I have no basis to judge that yet hehe…
Thank you, man! The db contains the correlations in advance, at least for this first release. I’m considering how to improve it, but still have a couple of minor improvements to this simple version yet… Anyway, my mind is a dreamer and is already thinking whatever can be done in the future :) Cheers
In fact, this is a great deal for me, who is eager to learn more about Python, Flask etc. Many thanks, mate!
Copying the java "synchronized void foo() {...} == void foo() {synchronize(this) {...}" is a mistake though. It's confusing and weird.
Tk is built in and easy to get started with and create something simple with. However, once you start to get a little more complex or want something that looks pretty, it quickly falls short. Qt has been a joy to work with when it comes to Python. There's some ramp up in learning it, but it has an excellent GUI designer and the UI works pretty intuitively. Also it's pretty easy to mod your app down the down as the UI and code are kept pretty separate. For creating an executable look at pyinstaller.org. 
My last tornado project was a huge pain in the butt, and it doesn't look like they've added the one thing that I needed for anything to have changed: session handling. It's a lot more complex a problem than it appears at first glance, and rife with gotchas. Integrating existing solutions was a huge pain. I rolled my own. I later wished I didn't. Turns out the application didn't *really* need that much performance, anyway. Everything else about Tornado is awesome. The documentation is great. The APIs make sense. If you're writing a session-less web application, or you don't mind the pain and bugs of rolling your own, I can't recommend Tornado enough.
Super laggy lol
it is pure client side, so I guess you could blame github pages or your browser ;)
~~I know this is a stretch but does Tornado have any SSH capability? I'm working on a Python 3 app and want to automate some SSH work but Paramiko (SSH lib) doesn't support Python 3 yet. My SSH script is written in Bash for now, which I'm not very comfortable with.~~ EDIT: Nevermind, after more time in the docs this looks like a socket-level library.
*golf clap*
If its Flask look at [Flask-Migrate](https://github.com/miguelgrinberg/Flask-Migrate). 'Flask-Migrate is an extension that handles SQLAlchemy database migrations for Flask applications using Alembic.' Really makes migrations as simple as they could be.
The library is directly available on PyPI and is compatible with Python 2 and 3 and Django 1.3-1.6. It's also been tested in a production environment and full documentation is available on Github. I finally released 1.0 today and I am open to feedback, ideas and especially pull requests. I'm also on Freenode as jleclanche.
I found another person a little while ago doing sentiment analysis under the company name [Sentdex](http://sentdex.com/), but for stocks. He sells his software now, but has a [Youtube](http://www.youtube.com/channel/UCfzlCWGWYyIQ0aLC5w48gBQ) channel by the same name where he freely talks about his thought process and provides video tutorials about writing your own sentiment analysis software. 
Adding in a personalization component is pretty nontrivial, but with enough usage it could be pretty cool. If you end up going that route and have questions, feel free to PM me. While I haven't used one in a website before, I'm familiar with recommender technologies and strategies, and could probably point you in the right direction :)
It's likely that the library's function is implemented in C, which is fundamentally faster to run than Python when both versions are well-written.
This is interesting and useful, but i'm starting to get a bit concerned about this trend of outsourcing what's pretty much the core of your code to online APIs
are you one of the authors of webalchemy ? ive seen you pimping this around a bit recently.
Why not just backport the median function from Py3 if it works well for you? Doesn't seem to have any extra dependencies.
This isn't the case, as evident from the post.
FYI, Paramiko has a pull request with what seems like tested python 3 support.
I didn't read it right. I didn't notice that both the library and user versions were Python code. I think that it's still the Python vs. C issue, though. The call to `sorted` offloads most of the work into optimized library functions, giving a raw speed advantage that offsets the asymptotic disadvantage for a while.
Yes I am, and I love websockets, tornado and python. Lots of potential for web development!
First of all, give code that works! `target_index=None` is a default that just results in crashes. Secondly, it's going to be hard to beat `sorted`, simply because Python's sorting is extremely optimised C. Back when Steven D'Aprano proposed this, he said that he would find it interesting to have a better `median` function. I tried implementing the same sort of thing as you here, but also came away slower.
I'm on my mobile, so I haven't been able to check it out, but for me the sort of stuff this would need is; automated audio/subtitle track extraction and embedding the ability to rip full DVD images and just the feature presentation, dealing with series of video correctly, solid command line arguments, multiple sane encoding presets and ability to tweak. Being able to sort films automatically would be cool too... Think beets @ beets.radbox.org for video.. That should keep you busy for a while.
Pypy is faster in limited conditions, its definitely no magic bullet
I've yet to see a test that lists CPython as faster in well optimized code.
Well optimised for which platform? How about generic non optimised code the rest of us deal with? Pypy themselves admit that its not going to speed up for the majority of codebases because its not as mature
I used to use Komodo edit as I only use vim now, but Komodo edit can be scripted by both JavaScript and python. It also has integration for pylint, pyflakes and can check for pep8 as well. I believe the extension name is under the name "perfect python" but you'll have to have pylint and/or pyflakes installed locally. Also, you'll have to launch it from the cli if you want it to pick up your pathing for a virtualenv. But you could also set your environment variables within the editor. Also, you might want to get NST (new source tree) as it would be equivalent to tagbar for vim. Just look for the "extensions" in the drop down menu. (I'm on a mobile device so I would've provided links to everything)
Sorry, I got over-eager in removing code to make a minimal example.
Timsort is really, really, REALLY fast. You probably don't want to over-optimize just yet, unless you're working with really massive datasets.
Luckily no one has asked for it yet, but there's a median of 74*10^9 elements which is just waiting to happen.
Thanks for posting (and writing!) it. Exactly the kind of thing I needed right now :)
Pardon my ignorance, but what does "real time" mean in this context? I'm accustomed to seeing it for real hardware stuff, not web servers
Problem is that you copy all data within the pivot_partition step. Rewrite it to swap elements as needed and then to return indices into the re-arranged list (like known from quicksort). For details, research the quickselect algorithm.
Looks like NumPy's median [is O(n)](https://github.com/numpy/numpy/issues/1811).
*Here's a bit from linked Wikipedia article about* [***Reactive programming***](http://en.wikipedia.org/wiki/Reactive_programming) : --- &gt; &gt;In computing, **reactive programming** is a programming paradigm oriented around data flows and the propagation of change. This means that it should be possible to express static or dynamic data flows with ease in the programming languages used, and that the underlying execution model will automatically propagate changes through the data flow. &gt;For example, in an imperative programming setting, would mean that is being assigned the result of in the instant the expression is evaluated. Later, the values of and can be changed with no effect on the value of . &gt;In reactive programming, the value of would be automatically updated based on the new values. &gt;A modern spreadsheet program is an example of reactive programming. Spreadsheet cells can contain literal values, or formulas such as "=B1+C1" that are evaluated based on other cells. Whenever the value of the other cells change, the value of the formula is automatically updated. &gt;Another example is a hardware description lang ... `(Truncated at 1000 characters)` --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/skariel can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**To summon**: wikibot, what is something?) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/Python/comments/1v9rpj/realtime_communicating_with_frontend_using_simple/ceqcxc6)
How would the speed of this compare to gevent?
The last comment on the bug report is &gt; Awesome as it is, this has been implemented in 1.8.x. So you shouldn't need it if you have 1.8.x. 
sublime text is great. Very configurable, and there's tons of plugins etc. Plus it's mostly python code, so if you want to extend or fix a plugin or something, you're all set. Really, tons of features and free to try. You can buy a licence, which isn't cheap, but they don't make you buy one for each computer or OS or any of that nonsense. Pay once, set for life on all your stuff. The free version just pops up a reminder (and not very frequently either).
I use [Ninja IDE](http://ninja-ide.org/), some features I find particularly useful are: * highlighting of static and PEP8 errors * warnings for unused imports and variables * automatic creation of \_\_init\_\_.py files when creating folders * automatic adding of encoding pragma when creating new python files * removal of trailing whitespace Also for trying things, especially data analysis related, I use [IPython Notebook](http://ipython.org/notebook.html) more and more.
The library (as of now) is pretty low-level. It provides just basic interfaces to use greenlets in event loop + a green version of socket objects (so you can use your favourite DB drivers/libs). So it's kind of apples-to-oranges comparison right now. What really would be interesting, is benchmarking asyncio and gevent against each other.
Yes all of those things act like true or false. In my opinion they would throw exceptions if you tried to use "if" on them. if should only work on "True" or "False". Lots of other things will work to for example other numbers and collections. It would be ok if say an array always evaluated to False but it only does so if its empty. Same thing with numbers. Because python is not statically checked you have to rely on exceptions to handle type errors. But this is one case were this does not work out well. A common example is say you have some web app with a form that contains a radio button with two options that will eventually correspond to a variable being true or false in python. But due to some error that variable can easily end up always being None. However it would be easy to miss this because no exception would ever be thrown. It would silently be assumed to be False every time. These kinds of silent errors have caused me all kinds of problems. It also breaks python's goal of being explicit. if x is None: is much more explicit than if x:.
Totally agree. There are lots of plugins for ST and you can basically create your IDE stack on your needs.
I am totally in love with PyCharm and its big brother, IntelliJ IDEA. Not sure what you mean by "shift selected text left/right", if you mean the ability to indent/outdent selected lines of code then it can do that. It has all the other features you ask for and tons more, including special support for Django and Google App Engine. There's a free and a paid version. Similar to Sublime the paid version can be installed on several operating systems/computers, provided you only use one installation at the same time. Have a look: http://www.jetbrains.com/pycharm/
Hey there, thanks for the mention CinematicCheif. I actually went through the Stanford release, pretty neat stuff. You can definitely do a lot of really awesome things with various APIs, including Stanford's. Even if you want to do it yourself and not outsource like another person mentioned, it is pretty easy to get 70ish percent accuracy right out of the gate with a bag of words model and some basic testing against samples. I first started by using NLTK, then I started to branch out and write my own code entirely. I have a few sentiment analysis types of videos indeed on youtube under the username Sentdex, and also how to use the Twitter streaming API. The first bit of advice I will give you is a reminder that you are not allowed to store tweets for more than 24 hours, so you will want to do analysis as the tweets come in and not save them. Best wishes moving foward!
Oh my. This is lovely. No lag here for me, great work!
Were you ever able to resolve this? I'm running some overnight tasks and also finding they usually stop around the time the display goes to sleep. This definitely did not happen with Mountain Lion. I haven't gone to the extent to test it that you have yet, and I have noticed some inconsistency in the behavior - ie. sometimes it will continue without interruption while other times it will pause almost right away.
Vim
Admittedly, I only scanned through this post. However, couldn't you just implement a singleton pattern if you are passing the session object around? (assuming that's what you're doing)
I don't see why you say this framework is for small websites... There is nothing in the framework limiting you to scale it to larger webapps, if anything, it seems well suited for larger deployments. It tackles the configuration step neater than django, which is more on the lines of "drop this on your server".
I should port this to Flask.
Awesome! Could be a great combination with Kivy. Python for all the points.
this is a nice post, and the way the whole "get_one_or_create()" cruises happily along until the middle when....race condition! is discovered should point to why SQLAlchemy doesn't just provide some quick convenience feature to do this; because "get or create()" can't be easily generalized to any kind of concurrency approach. The author expresses hope about a Twisted-based approach but I believe he will be disappointed there as well, as while Twisted might give you better performance and nicer primitives to deal with concurrency, it still isn't *eliminating* concurrency - two different threads/twisted things/processes/whatever can get to the database at the same time on checking/inserting a row as long as the app is concurrent, and there are just lots of ways of dealing with this (locks, MERGE, SERIALIZABLE isolation, catching integrity errors/retrying, etc.). It isn't a problem with just one solution.
Yeah, I had apt-getted from ubuntu. It gave me 1.7.1. I pip'ed this time, and got 1.8.0, so I should be ok. Still curious about the why though.
The only backward incompatible change is described in "Process properties are now methods". If for some reason you want to write code which works with both versions you can do this: &gt;&gt;&gt; import psutil &gt;&gt;&gt; PSUTIL2 = psutil.version_info &gt;= (2, 0) &gt;&gt;&gt; p = psutil.Process() &gt;&gt;&gt; name = p.name() if PSUTIL2 else p.name &gt;&gt;&gt; exe = p.exe() if PSUTIL2 else p.exe ... All the other changes I introduced are less severe because the old functions are still around. I'm aware I'm gonna cause some pain but psutil is a relatively small lib and the porting consists in just renaming stuff. It's a lot easier for the user to just do that instead of sticking with an old unmaintained version.
You should! I've started playing with Flask for a [Git-powered wiki project](https://github.com/Adys/Wikt/) and I really, really like it. Let me know if you go ahead with it.
In-place partitioning is likely going to be slower than appends. However, you could micro-optimise with lt_append = lt.append eq_append = eq.append gt_append = gt.append See: &gt; python2 -m timeit -s "lst = range(100000)" "for i in xrange(100000): lst[i] = 1+lst[i]" 100 loops, best of 3: 7.06 msec per loop &gt; python2 -m timeit -s "lst = range(100000); new = []; new_append = new.append" "for e in lst: new_append(1+e)" 100 loops, best of 3: 5.16 msec per loop &gt; python2 -m timeit -s "lst = range(100000); new = []" "for e in lst: new.append(1+e)" 100 loops, best of 3: 8.41 msec per loop Note that this ignores the extra overhead you'll have from in-place changing in keeping track of the 'tail' to switch to, and the worse data locality. 
I've been programming with python on and off for a year now and can generally make programs that do what I want. I've got to the point where just using the console for input / output is becoming a burden and need a GUI toolkit. Having never done anything with GUI do you think Kivy is right for me, or should I start with something like PyQT or Tk?
Should be a TypeError. &gt;'False' case, that's a different issue altogether. If A completely separate issue resulted in the bug. But python's choice to treat non booleans like booleans makes it a silent error and there for much more dangerous error. None,1,[], ect are not truthy in any sense other than historical that I can tell. 
I'm not the original poster, but I can offer my own small insight. I'd say that kivy is a great toolkit to learn, and perfectly good for simple guis, with the fantastic advantage of running on mobile platforms. The big downside is probably that it doesn't really look (or in some cases behave) native. You can get near-native results in some contexts, but it's never going to neatly fit in with (say) lots of qt applications. If you want to make more traditional desktop apps, kivy probably isn't a good choice, though it runs perfectly well on the desktop and may be a great choice for (for example) games or simple/personal apps where you don't care about a native look and feel. If you don't have a specific goal in mind right now, I'd say it probably doesn't really matter (though I probably have some kivy bias) - learning a gui toolkit isn't a commitment, especially just to test a simple project, so probably you may as well play with more than one anyway.
This is a really nice write-up! I particularly like the app's appearance - as you say, the default widget appearance is not always amazing but there are not so many examples of different appearances. This one is very nice. Not sure if the submitter of this post is the original author, but I think there might be simple improvements/fixes for some of the problems encountered, if interested.
This is good feedback with regards to a Twisted approach, although I only meant to suggest that Twisted forces the developer into a mindset of concurrency and asynchronous operations that may have brought light to this earlier. I also agree that SQLAlchemy shouldn't provide a general approach, and don't mean to suggest this should be one. Instead, I wanted to offer my approach since the other approaches I found on Stack Overflow and such were hadn't addressed the race condition issue (or some of the other handy features that worked for me). Thanks for the feedback, and all your work on SQLAlchemy!
Sounds like any decent text editor would work. You could use gedit or SciTE or try learning Vim or Emacs.
geany
Theoretically you can make an application for any platform with kivy, but I'm agree with @inclemnet. Kivy is strongly focused on mobile environment, for instance multitouch, which is not something common for desktop applications. And of course you don't have such a diversity of widgets, layouts and strategies for creating an application in kivy as you do in Qt or gtk out-of-box
Thank you! I'm the original author :) Any opinions are welcome!
Thanks! I will take a look at it
Okay, a few questions/comments then. &gt; Compressed images look really pixelized, so be prepared to maintain all possible pixel densities by yourself. I'm not aware of any reason this has to be the case (though maybe I'm missing something), did you have mipmapping enabled? &gt; And the last thing: Button widget is really bad, as much you are going to use it almost everywhere. What problems did you have with the Button? It would be great to improve it if possible! &gt; No fancy swipes. Built-in Carousel widget is just a piece of pain. I agree that carousel has some problems, for exactly the reasons you suggest (I saw your other blog post about it). Personally I've found that just lowering the touch delay property helps a lot, the default seems unnecessarily generous. I've also wondered about ways to fix it. One (fairly easy) change would be to have a mode where the carousel behaviour is only triggered when touching a non-interactive area, so any buttons etc. are immediately pressed (but can't trigger the carousel) whereas empty areas or inert widgets like images trigger the carousel as normal. Would that kind of mode be an improvement for you?
My connection is shit and my laptop far from new. I'm using Chrome and it works smoothly!
Oh wow. That explains a long-standing issue in a former (retired) project of mine.
As much as I love python, use Powershell for this.
I was looking into how to do this just last week, thanks for releasing it!
&gt; I'm not aware of any reason this has to be the case (though maybe I'm missing something), did you have mipmapping enabled? God! You are right, thank you! I just need to use POT's. That explains much. Do you know if it's a plan to support NPOT's also? &gt; What problems did you have with the Button? It would be great to improve it if possible! It's a big story... But there two main things, which make Button widget unusable for me: 1. It supports two properties for setting background image (background_normal and background_down). I can't understand, why background image has so much priority in compare to other visual properties, such as width/length, position, background color (what if I don't want the Button to have any background image?), shape (what if I want it to be a circle?) and so on. Of course you can say this is not base functionality and it belongs to garden maybe, but Button is the most common way for user to interact with the app, so I'd like to specify more behavior for on_press. For instance it could have some dynamic properties like &lt;property_name&gt; (width) for normal state and &lt;property_name_down&gt; (width_down) for down state, and even just such a small change would make it more powerful! [Here](http://cheparev.com/kivy-colored-button/) is the example how I made it for color. 2. So, if you decided to set a background, you can't manipulate it anymore! I'd like to move, resize, rotate, allow/prohibit stretching, stick on the borders, fix one of dimensions (let's say upper bound always 100% of width, height auto, like CSS). Generally I'd like to have at least CSS background-[size|position] property features. &gt; Would that kind of mode be an improvement for you? First thing I wondered, that Widget class supports only primitive interaction events, like on_touch_[down|move|up]. I would think, that widget itself should already know if it's touched, double-touched, swiped, swiped with two fingers, spread and so on. Just the same like in winAPI double click event is not just two clicks, but a separate type of event, swipe wouldn't be on_touch_down-&gt;on_touch_move-&gt;on_touch_up, but on_swipe. So if you do so, your carousel will catch swipe events, and if I just touch it, carousel knows that it's not his deal and gives it further to children immediately. In this example you should distinguish swipe and touch somehow generally, but at the first look I'd say on_touch_down-&gt;on_touch_move=on_swipe. But! I'm pretty newbie in kivy, so maybe I just don't know something important ^^
https://github.com/Adys/django-push-notifications/blob/master/push_notifications/apns.py#L48 Oh god you are still using version 0 of APNS? Besides sending APNS/GCM is non-trivial if you have millions of devices. You need something like background workers for example Celery.
Wow ! I just discovered Webalchemy and it's awesome ! Great work :) Edit : are you asking for feedback on webalchemy or even want a contributor ? I think i would have some suggestions/ideas :)
A pipe, by defintion is a chunk of memory (buffer) in kernel with a fixed size. If you don't consume it and it's full, it will block. I've had similar problems before, not with pipes, but JSON handling. By using python's default `import json`. Some guy tried to upload 2GB size of JSON. And BOOM website hangs altogether. Even the swap is full you have very difficult time ssh to server. Should it be counted as a bug?
If you want all that and then even more (at the cost of being tough to learn) pick up [gvim](http://haridas.in/static/images/gvim.jpg) from `apt-get install vim-gtk`. And then install python-mode to get PEP8 validation, syntax error, *some* completion. Helps to be super lazy and want to optimize the crap out of the way you manipulate text.
OP, this. I do what you do. Powershell is just going to handle this better. I'd have a quick read of Powershell in a month of lunches [Here](http://www.manning.com/jones3/) 
the author seems to misunderstand it as a bug in communicate() import subprocess p = subprocess.Popen(['/bin/dd', 'if=/dev/zero', 'bs=1M', 'count=1'], stdout=subprocess.PIPE) p.communicate() seems to work as intended
&gt; God! You are right, thank you! I just need to use POT's. That explains much. Do you know if it's a plan to support NPOT's also? Kivy already supports NPOT textures, and I don't think there should be a problem with them if the graphics card supports it. If you think your card should but kivy isn't behaving right, it would probably be useful to report a bug, I don't know a lot about this part. &gt; Just the same like in winAPI double click event is not just two clicks, but a separate type of event Not sure if you know, but the touch itself already has an 'is_double_tap' property containing this information, plus some other similar stuff. Actually, after thinking about the stuff below, maybe it should have an 'is_swipe' property as well. That might make some things nicer. It doesn't avoid the fundamental delay issue though. &gt; So if you do so, your carousel will catch swipe events, and if I just touch it, carousel knows that it's not his deal and gives it further to children immediately. Doesn't this give rise to exactly the problem you already have, you can't detect a swipe (and not pass the touch through) without waiting a little while to check if the touch is moving or not. Or if the carousel passes it to the children immediately, it can't later take the touch back if it turns out to be swiping. I think this is a fundamental issue, and probably in other circumstances (e.g. browsers, normal android dev) it's likely covered up by short response times and maybe clever fake responses like ui elements appearing to respond to the initial touch but not truly changing until it's had long enough to see if it's swiping. Did you ever try tweaking the values of the touch response time, I've found it's much improved (but still detects touches) by turning it right down. One change in the next kivy version (I don't know if you already know) is abstracting the button to a ButtonBehaviour, which contains the on_press/on_release events and some other stuff. That way it can easily be combined with any other widget to make it behave like a button. The Button itself is replaced by a subclass of ButtonBehavior and Label. You could use the same principle to make a SwipeBehavior (amongst other things) that dispatches a particular event in response to a swipe. Actually, you could also make a DoubleTapBehavior etc. etc. to get what you suggested above, I might play with this and try to put an example in the kivy garden.
Why is this related to Django? Why not a standalone library? 
The author seems to be gravely mistaken about something. If `subprocess.PIPE` is not a "proper UNIX pipe" then what does he think it is? Python can't just reach into a child process and pull bytes out. I see this was written in 2008 and from the comments on the blog post I am guessing that it *was* a bug (or lack of feature) in `communicate()` that caused it to not service all of the pipes appropriately when there was more than one (stdout and stderr in this case), and may not apply to current versions. Now, that said, you still have to be careful when using pipes if you do anything other than call `communicate()`, because if you start manually writing stuff to stdin without servicing stdout you will deadlock.
The solution: instead of `.communicate()`, call `prc.stdout.read(4096)` multiple times in a `for` loop, until you get empty string, then it's done. It's ugly but that's how things work. Think this way: it's a mechanism force you to make a good habit of breaking large chunk of data into small parts, and process them iteratively.
Oops, you're right. It's only 8GB, but that takes a lot longer to process when you write it one byte at a time it seems. The author's claim of 2^16 lines is definitely wrong in any case, or at the very least is wrong Windows' python interpreter.
the docs *do* say these may deadlock if full.
I was mistaken, communicate works after all, and continues working until I run out of physical memory and start accumulating communicate() data in my page file, and finally get bored and kill the process.
When I wrote that post six years ago, they didn't.
I can't recall for sure since I wrote that post six years ago, but it was probably Python 2.4 on a 32-bit Linux system. I never investigated whether it had exactly the same behavior on other platforms and I haven't bothered checking since whether anything changed in later versions.
For sysadmin work, especially provisioning/config mgmt etc, [ansible](http://docs.ansible.com/) may be of some use to you, and the modules that come with it are pretty easy to follow. So writing ones yourself shouldnt be a big deal. Unfortunately I suspect that most of those modules assume Linux/Unix and probably are not too useful on windows. 
It looks like you just have it backwards, try: age = 2014 - dob
thank you 
:P now I get "cannot concatenate 'str' and 'int' objects" ha ha this is fun I am sure that I can fix it from here because I got an error that I can understand. I can not combine char and int this easily 
Nice module, I can definately use this for testing. I think a random "lorem ipsum" text generator would be useful. Sentences generated by picka.sentence() look badly formatted. I will submit a patch later tonight.
Wow literally just discovered this issue about 2 hours ago by pure luck. Definitely one of the biggest "gotcha's" I've had the stupidity to cause.
cast an int to a string with: str(dob) there's also string interpolation like: print '%s %s %s' % (name, space, dob) or a newer format call on string I think that I don't know the syntax to off the top of my head
got it working thanks dob = int(input("what year where you born XXXX ")) name = raw_input ('what is your last name ') space = ' ' print (name , space , dob) age = 2014 - dob age = age * 365 print (name,"you are ", age ," days old") 
woo!
&gt; string interpolation yes I like this string interpolation thank you
gvim (vim with training wheels and mouse selection basically) is the way to go if you want a do-everything editor that will work over SSH (plain vim/vi) or locally. That's what I use and Macvim on my mac. I picked up the keystrokes in the mid-90s and using anything else causes :wq to sprout up throughout my text like when I used text wrangler or when I use eclipse (java is one of those language where an IDE is essential).
Please do. Feel free to use the unit tests I wrote as well, although the original list of IPv6 addresses in the unit test script are from [Dartware](http://download.dartware.com/thirdparty/test-ipv6-regex.pl). Their license for their Perl unit test script (which I translated into Python) is: # LICENSE # # IPv6 Regex by Dartware, LLC is licensed under a # Creative Commons Attribution-ShareAlike 3.0 Unported License. # http://creativecommons.org/licenses/by-sa/3.0/ # # Please mention Dartware and provide a link back to our site # in the documentation with other attributions. It should say, # # --- # IPv6 regular expression courtesy of Dartware, LLC (http://intermapper.com) # For full details see http://intermapper.com/ipv6regex # --- Best of luck!
The problem is in the *communicate* function. It silently fails when the subprocess passes too much data through either the output or error pipes. When *communicate* stops reading from the parent end of the pipe, the pipe fills and blocks writes at the child end. Picking fixed size buffers to hold the outputs from the subprocess was a define mistake. At the very least, it should have detected that there was more output available and thrown an exception or thrown the extra output away or even killed the child process, rather than allow the child to hang. 
That's not within the realm of problems that should be dealt with by base psutil module. To say one, there's no common protocol to do that across all supported platforms. Note that all processes information can be serialized via JSON, XML, pickle etc.: &gt;&gt;&gt; import psutil, json &gt;&gt;&gt; json.dumps(psutil.Process().as_dict(attrs=["pid", "name"])) '{"pid": 7969, "name": "python"}' &gt;&gt;&gt; You just have to decide what protocol to use in order to transmit that information (HTTP/S, SSH, or whatever).
This pairs just fine with Celery. As for the APNS version, you're welcome to send pull requests.
The logic in apns.py and gcm.py is easy to implement on its own. What the django library adds is GCMDevice and APNSDevice models, which can be filtered and from which you can directly send messages. It also integrates nicely with the admin (with some test actions) and there's an optional tastypie API for those who want it.
You should not rely on any minimum size, although there is a constant PIPE underscore BUF that represents the guaranteed minimum. It's exposed in Python too.
try django
I was inspired by your reply, so I *also* submitted a pull request. Hope that's not annoying. There's a great sentence splitter in the `pyteaser` package (https://github.com/xiaoxu193/PyTeaser). I borrowed the regex to split sentences from `pyteaser.split_sentence`. Works pretty well. It seems like I get real sentences from the Sherlock text most of the time. When it doesn't work, it's because a sentence was parsed from dialog. There's a lot of dialog in Sherlock. A different source for words/sentences might yield better formed sentences. Any source with less dialog is bound to have fewer sentence fragments in it.
you mean if the pipe buffer is like 4 bytes, so this `prc.stdout.read(5)` hangs?
what's considered substantial? If you are developing a simple project or something you don’t plan to deploy in a production environment, SQLite is generally the simplest option as it doesn’t require running a separate server. However, SQLite has many differences from other databases, **so if you are working on something substantial, it’s recommended to develop with the same database as you plan on using in production**. ( https://docs.djangoproject.com/en/dev/topics/install/ )
thanks. this sounds exactly like what I need. have been using Automate 9(R) http://www.networkautomation.com/automate/9/ at work for a year. and finally hacking through Learning Python the hard way
By default, the stdout member on a Proc object is blocking. If you ask it for 5 bytes, and only 4 are produced but the pipe is still open (because the process at the other end is now doing something else like writing to its stderr), you will still block.
Maybe you could update your post or remove it, since it's no longer correct.
Looks great, I only wish it had different name - this one means "pussy" in Serbian (and surrounding languages) so it feels kinda weird using it in a code... And without license file/info from a legal standpoint I'm not sure if anyone is allowed to fork and rename it before using it in a project because if I recall correctly no license = you can't use, modify, distribute it - so look into adding a license to the repo. btw you got more upvotes in /r/Serbia http://redd.it/1vbwku
Always looking for more contributors for Watson (a Python 3 web framework - http://simoncoulton.github.io/watson/) if you're interested :)
&gt; That's not within the realm of problems that should be dealt with by base psutil module. Why is that? &gt; To say one, there's no common protocol to do that across all supported platforms. That's a technical question, not one of principles. I'm fine if psutil says it won't do it but your reasons aren't really showstoppers either.
I got curious, so downloaded and compiled Python 2.4.1 (can't find 2.4.0) on 32bit Linux, and it works perfectly fine: &gt;&gt;&gt; cmd = 'python -c "import sys\ni=0\nwhile i &lt; 1 &lt;&lt; 17:\n sys.stdout.write(chr((i%26)+97)); i += 1"' &gt;&gt;&gt; args = shlex.split(cmd) &gt;&gt;&gt; prc = Popen(args, stdout = PIPE, stderr = PIPE) &gt;&gt;&gt; out, err = prc.communicate() &gt;&gt;&gt; len(out) 131072 Are you _absolutely_ sure this was the exact kind of code that was causing you problems? Because it's extremely easy to deadlock if you also try to write something to stdin of the command, for example. Like, it starts, fills the output pipe, blocks on it, and never reads from the stdin while the parent process is waiting on it. Or you can deadlock when reading from stderr while the process is blocked on the full stdout, or vice-versa. Or you can deadlock if you call `wait()` instead of `communicate()`, as the documentation points out, or in a lot of other ways. Naturally, rewriting your code to use temporary files would automatically fix whatever deadlock you had, but it was a bug in your code then, not in `communicate()`. I guess that given how tricky avoiding deadlocks is, it's probably better to use temp files anyway, but doing that for the wrong reason just rubs me the wrong way... Please, consider adding some sort of a disclaimer to that post, saying that the bug appears to be non-reproducible on newer versions of Python or might have involved doing more complicated stuff that was all lost in the mists of time. Given how many people claim to have the same bug in the comments here, _if_ that is an unintentional misinformation, it's spreading wide, which is unfortunate.
How are these made?
If you're interested in ground-floor development, go fork [bivouac](https://github.com/coyote240/bivouac). It's got a decent base, but hasn't seen development in a while (had to shelve it because of a stupid contract I am no longer under). It would be one project where you could make a huge difference.
Can you give me a link to the second online class? (the one with the GUI teaching)
Horizon isn't a framework... it is just a control panel.
Friendly tip: Head over to /r/learnpython or /r/learnprogramming for questions like this. You'll get a much better response than in the primary language thread. As a quick semi-answer to your question, check out Google App Engine if you want to play around with web apps. It's a nice, free service, with good documentation and a helpful community. The Jinja2 template library that it uses can be used to accomplish most of the output options that you want. Heck, you could really accomplish everything with Python's builtins (for emails templates, form letters, csv, and xml). However, for excel, you need a third party library like xlwt or something. 
I had to learn Vim for a couple classes before I graduated. I will never, ever, ever, go back to anything different. I HIGHLY recommend learning it. One of my friends even imported a dictionary into it and uses Vim for writing any papers he needs to do. It's also been a huge a workflow/speed increase for me for any text manipulation.
Sure isn't. I didn't read the last part of his post. It's just an open source project that would look great on a resume. 
I would be *very* interested to see if this was faster than the simple sort-and-take-middle-element approach. The sort approach is N log N. Even for this "big" example, that adds a 9x multiplicative on to a linear approach. And, given how small the "constants out front" are for search algorithms, I would be surprised if the more complex, yet still linear, median algorithm doesn't amount to bigger "constants out front" than the 9x this example gives.
I haven't look at Horizon in 1+ years but I always felt it could have been done a lot nicer in a much lighter format, but that is off topic, and probably it's own rabbit hole.
This, particularly if you're not sure whether stdout would fill your memory. Read/write in 4k chunks (which is what the underlying OS does), and you can read/write to a process sanely, regardless of how much data you're sending. Do not use communicate() if you're unsure of the output size, otherwise you'll fill memory and crash, and you're likely to fill and block on buffers if transferring more than 4k of data. Source: experience piping a terabyte worth of stdout out of mysqldump through a python process for specialized filtering.
this looks cool but im having trouble finding a need for it (other then running in the cloud and back testing data). If you can write enough python for a bot in this sense, then you can write python to not need this platform. I personally have a weird feeling about putting my strategies online.
Very interesting concept. I have become more and more interested lately about lisps. Clojure is an obvious option but I dislike the way it works with the JVM. Even though java itself isn't the biggest problem, the slow startup times and the hassle around getting it to work doesn annoy me. If I get more free time in the future I will certainly start looking into Hy. 
I don't suppose any one knows of projects that are relatively easy to get involved in that are not frameworks? Perhaps there should be a list on a wiki somewhere or something 
That's true, but it's actually pretty hard to get the internals right. You've got to take in multiple near-realtime feeds coming off an exchange, store them somehow and play them back fast enough to test your strategy across, for example, a years worth of data. And that's just one exchange. Each has a slightly different API and set of feeds. Plus the devops stuff: uptime, latency, etc.
If you like optimizing existing code (make it faster or better in general), have a look at [bottle.py](http://bottlepy.org/). The project is small enough so you can read everything in a weekend, but also contains some very tricky parts (e.g. the template parser) you can play with and learn from. On the downside, the author (that's me) is very picky and hates pull requests that add to much code, break something or are not covered by tests. 
true every exchange has a different api. (pubnub, websocket, http get/json/sudo restless), which the user would still need knowledge of in order towrite a proper bot. your math utils and normalization will all the be the same across the board though. Also cloud executed strategies still have risk of latency and uptime (see many aws outages that broke everything including reddit). Not trying to downplay what youve got here, being able to back test in rapidly is very valuable.. not sure i would actually do more then paper trade with it though. *full disclosure i wrote a suite of risk and trading apps for a private party that work very similar to this.*
I was just venturing into vision and had heard of just opencv everywhere. This seems like a good "10000 feet" view of the current available options.
I took it on coursera.org. It is called Interactive Python
It's a shame but after scrolling through a month of bug reports I only found four projects - python itself, pitivi, openhatch and twisted - a lot of which were documentation changes.
Mailpile? https://www.mailpile.is/
Things to consider: 1. How many users will use it? 2. How many users will use it at the same time? 3. How much data will be stored in it? 4. What are your data integrity requirements? 5. How complex is your application? SQLite is fast and lightweight, at the expense of not really enforcing the kinds of integrity checks you'd get from a more traditional database. It's still plenty useful - even Apple uses it for their Mail application. For what seems [from your description] to be a small application, SQLite should fit your needs. Even if it doesn't, you shouldn't have too much trouble moving to something else.
I am happy to work with you on Zopache.com and ZTFY. It is a Through The Web Framework python development environment built on top of the Zope ToolKit. ZoPache.com is looking for volunteers. It is a Through the web framework, built on top of python. Really someone to work with me. 
Please use Powershell for this. I LOVE python. I don't really like Powershell. But, for automating AD, Exchange, etc, it is 100% the right language.
Yep, OpenCV is certainly used a lot. If you are in the academic sector and are interested in computer vision, you'll probably also see a lot of people using MATLAB, but overall, the computer vision community is slowly moving more and more to Python. This is true of other fields, such as machine learning, as well.
This is the coolest resource I've ever seen. Thank you very much /u/sittingaround! 
Remote code execution has nothing to do with what psutil intends to offer as a lib. It can certainly be integrated with other tools in order to achieve the goal you describe, but those are *different* tools which aim to solve *different* kinds of problems. There are very good reasons to have one tool which does one thing only. So yes, it is also a question of principles. Would you expect from cmdline tools such as "ps" os "free" to integrate facilities to run on a remote host natively? Of course not, because you can use SSH *in conjunction* with "ps" or "free" and get what you want. At the same time "ps" and "free" authors won't need to know anything about network programming or encryption: that is a problem which has already been solves by SSH authors and that is a good thing.
Umm, I use bottle on pretty much every project I have right now. I am a professional tester, and I have been looking for a way to contribute to the open-source community. Is there something on bottle for which I could write tests?
Damn you're harsh. Fair enough.
Thanks for followup.
+1. You're like the great white elephant of the dev community. I've heard people like you exist (like people who write exclusively py3k code), but haven't actually ever met one.
Ummm, thanks?
Really cool project! Will take a look later. Are you planing on using Tulip instead of Tornado?
That's the original plan. 
The unit test coverage is not that bad, but there is always room for improvement. You could just start with test coverage improvements and learn the framework that way. The more tests the better. The existing tests are far from perfect, too. Some are redundant, others are more complicated or slower than they need to be, others do not cover all possible permutations of input parameters and so on. There is lots of room for improvement and some really low hanging fruits. The documentation contains some code examples and there were some bugs with these examples recently. Someone could try to get doctests running and make them part of the test suite. I hacked together some magic to get better coverage measurements. Someone could fix that part or simply port everything to nose or py.test or any other testing framework that does a better job. I added an @api(min, depr, max) decorator as while ago that enables/disables test cases based on the bottle version tested, but it is not used enough. This, or some other way to improve backwards compatibility testing would be great. Oh, and the test modules are really a mess. Just as an example, test_environ.py does way to much for a single file. Someone could re-organize the tests in a more meaningful way. Pull requests that add or improve tests are *very* likely to get accepted.
Want to work on an open-source POS desktop application?
This looks fantastic. I usually use Flask as a WSGI web framework -- I'll be sure to check this out. :)
I am quite happy with the bottle community. You usually choose bottle for a reason, and not just because everyone talks about it. That results in less noise and more people that actually know what they are doing. Contributing to the core framework is actually quite hard. Bottle is more or less feature complete and very mature. It is hard to get a pull request past my nitpicking. More code is bad, most of the time. But that only affects the bottle.py file itself. Plugins, documentation, feedback and tests are always welcomed. The plugin API is actually a very good place to start. Take your favorite Flask extension, middleware or third party library, turn it into a Bottle plugin, release it and start your own little open source project. You could also adopt an existing plugin and improve that. There is always a way to contribute. Just start :)
I'm a newbie on Tornado or Tulip, just curious with all the noise about Tulip. Really eager to learn more about websockets/tulip/tornado and python so Webalchemy is really interesting for me.
I just exposed some reasons. I didn't mean to be harsh. =)
Since Hy targets the Python runtime, instead of implementing its own, it doesn't implement any of the known variants of Lisp. However, [according to the Tao of Hy][1], it's heavily influenced by Clojure and a little bit by Common Lisp. Why should you use it? I cannot say. To me it's been about having a Lisp (and an increasingly saner macro system) that comes with Python's batteries included. That also means the builtins data structures. If you're familiar with the Python runtime, you'll feel right at home. [1]: http://notes.pault.ag/hy-survival-guide/
I've got a Tornado app in production that handles 100k requests per second globally (on PyPy 2.2). Tornado is awesome.
I still continue some personnal adjustments : - moved from quik to jinja2 for templating - added support for a CLI layout - added support for unitest layout - added optparse to parse command line arguments - using sh module to initialize the repo - removed the call to sudo in the script - didn't liked it ;) - added a logger You can see these changes on [github](https://github.com/jcsaaddupuy/picnic.py/tree/dev)
&gt; Since Hy targets the Python runtime, instead of implementing its own, it doesn't implement any of the known variants of Lisp. It does not follow that because it targets the python runtime, it must implement a new language. &gt; Why should you use it? I cannot say. Well, lisp is great and all, but it's also nice to have existing code which runs. Implementing a known language (even as a subset of an "enhanced" version of the language) gives users that.
Flask is where I started. In the end, there is something truly awesome about a single file for import with no external dependencies. 
I'm starting to get comforable with understanding python, now I just need practice. The most problem I have is how, and where do I start? When I see a functional code, I dunno what needs to be fix. It is the exact same feeling as you graduate from high school, "here's your GED, congrats." Toss you into the world, and you just don't know where to start.
Cool :) It's called [Coinbox](http://www.coinboxpos.org). It's basically PySide/Qt/SQLAlchemy. We are 3 people, 2 of them devs, and some people who are supportive but aren't actively helping. Let me know if you're interested.
FYI: Didn't build on existing Ubuntu 12.04 systems (that ran 0.12 fine) without also installing Cython. Exception: Cython-generated file 'pandas/msgpack.c' not found. Cython is required to compile pandas from a development branch. Please install Cython or download a release package of pandas. See [the bug report](https://github.com/pydata/pandas/issues/5965). Should be fixed in 0.13.1.
Docs are at http://hylang.org/ It compiles to pretty darn OK Python AST/Bytecode - so that we can maintain bi-directional interop. Think of it like Python with s-expressions and more tools for handling functional programming. The interop works so well in both directions that Django apps work great. Re-implementing a runtime is fun, but I'd rather take the interop :)
It looks remarkably like Spyder. Then again, how many choices does one have for an IDE?
Hey ! I also made some substantial changes in my branch. It looks like we are taking different directions ! I really like the unittest, I will have a look at the code.
Simple, fast, powerful and python 3 from the start. I like it.
No, do not ever do that. If lots of data gets generated on stderr (or you attached a PIPE to stdin and the child tries to read it), you will hang. The `subprocess` docs specifically warn about this.
How does this compare with FLANN?
If it is open source why don't you just post the repo for people to take a look?
https://github.com/rafalp/Misago
Sorry :) It's actually multiple repos. Here's the [Github organization](https://github.com/coinbox/) and the [main repo](https://github.com/coinbox/coinbox-core). It might not be straight forward to install it though, so that's why I thought it'd be better to post the website. Because I'm actually working now on making the packaging/installation easier (and it's a pain in the ass).
Btw, my code is tested/working only on 2.7, not compatible 3.3 :/
There's also a scikits version http://scikits.appspot.com/ann which wraps this C++ library: http://www.cs.umd.edu/~mount/ANN/
Wow this is really cool. Thank you!
&gt;&gt; Since Hy targets the Python runtime, instead of implementing its own, it doesn't implement any of the known variants of Lisp. &gt;It does not follow that because it targets the python runtime, it must implement a new language. It's true that it isn't strictly necessary, however... Runtimes impose a default set of semantics. Sometimes you can emulate a alternate set of semantics, eg: the semantics of some existing Lisp, but this comes at a cost either in terms of efficiency or compatibility with code native to that runtime. For example, some Lisps, like Scheme, require tail call elimination. The Python runtime does not have this. Tail call elimination can be emulated, but you're going to have extra overhead at call sites, and functions will not have the same signature as their Python equivalents. Languages also tend to have a set of built-in datatypes as part of their definition. You can reimplement these on the Python runtime, but they will probably be slower and bigger than their "native" Python counterparts, and interoperability with Python code starts to require a lot of conversion. Or you can live with the slightly different semantics, and acknowledge the fact that you've essentially created a new language, even if it borrows heavily from the syntax of something else (Clojure, from the sounds of it).
This site looks down.
Libraries? Have you looked at [TkInter](https://wiki.python.org/moin/TkInter) yet?
Haven't looked at this in depth but an array may be better to store the tic tac toe grid instead of a ton of booleans. You obviously figured out much of this on your own, so props to you for that. As far as pygame goes, I'm not very familiar with it but I will research when I'm off mobile. Keep on pythoning!
Ah well, one of the others must still be working on it. I thought they'd be done by now.
Thanks, I'll be sure to do the array thing!
I just finished playing around with this. It was frustrating because the documentation is incomplete. In the example, the author doesn't explain what is being returned in N. Also it doesn't explain what parameters the functions use. And the vectors returned don't have an index for lookup. Finally it should explain that Redis is a required dependency and how to install Redis. Kind of frustrating. But it does work.