Does the final print show 21 objects are created? If not, then the error is in the results - they could be timing out for example, but I would expect that to give an error. Maybe wrap the threadpool in a try block? &amp;#x200B; from concurrent.furutres import TimeoutError &amp;#x200B; with ThreadPoolExecutor(max\_workers=5) as executor: \# set a timeout limit for each thread job results = executor.map(codedeploy, databases, timeout=10) database\_obj = \[\] try: for res in results: database\_obj.append(res) except TimeoutError: # gives error is timout limit was passed print("Timed out") &amp;#x200B; \# assert len(database\_obj) == len(databases) \* 3 # both should be 21?
Afaik, there is already the package named "python-gedcom" which does exactly what you need. However, it does not provide any built-in way to export data to json
that's good to know as it makes the project even easier! I certainly think that the JSON side of things is important, so that's still important.
The gallery seems like it wasn’t updated recently, while the renderings look amazing, was this library updated recently? How would it compare to say rendering via Nvidia Iray, which is also a physically biased renderer? I make games as a hobby and am learning python, anything that’s related I love learning about.
Except it is not true. simple_salesforce is a great library. I use it all the time.
Sure, you could perform statistical sampling easily in Python, and document it in a jupyter notebook.
Is this really the best troll you could come up with?
That's my opinion.
OK?
It's not a troll.. it's my very honest opinion
I've tried running the code you've sent but running into issues. From the database query plan I can see the USE DATABASE {} part happening but when it comes to creating the objects I'm running into the issues. I'd expect it to create 21 objects but it only creates about 14. No time out issues as the table creation is in milliseconds. I can also see that the later databases have all 3 objects but the middle ones have no objects. I think it seems like an issue where it groups the threads (statement x database).
OK? So? Why are you posting this?
No reason.. just to say it
You're not quite grasping what people are trying to tell you. No, this doesn't predict prices at all. Short or long term, it does not achieve what you're saying it does. Research the finance industry in general a little bit better. You are a very small fish in what is perhaps the biggest pond you could have picked to swim in.
That's not a good reason to proclaim your opinions on the internet, especially in communities of people who are likely to disagree. There's a word for it: "trolling".
No! We should say our opinions even if it is not common.. it's democracy
I appreciate the offer of further discussion. I don't know that that is necessary, I'll just clarify what I wrote as per your latest comment. I'd agree on your response points 1 and 2. Mostly on 3, and that's what I object to in her talk (or the summary of the talk). It was said by her to be a rambling rant, which in general rarely leads to good things, but rather can just poison a room. She's complained that by adding asyncio to the stdlib, people don't understand why Twisted exists. &gt;Ever since asyncio was announced she has had to explain why Twisted is still worthwhile, and now that data classes are in the standard library Hynek Schlawack must defend his attrs package. Even as standard library modules crowd out other projects, they lag behind them. According to Brown, “the standard library is where code sometimes goes to die,” because it is difficult and slow to contribute code there. I'd counter with urllib vs Requests. You can always count on urllib being on a machine. You would probably rather just use Requests. If she's having an identity crisis of "where do I fit in now?", then I'd say she needs to fit that space. It's classic "who moved my cheese" thinking. Twisted looks like it has an active release cycle compared to CPython. if she's worried about losing edge users, is that bad? Taking the quote you posted: &gt;“Python's batteries are leaking,” said Brown. She thinks that some bugs in the standard library will never be fixed. And even when bugs are fixed, PyPI libraries like Twisted cannot assume they run on the latest Python, so they must preserve their bug workarounds forever. Maybe we take that different ways. Yeah, as you said, that's life. But OTOH, they don't *have* to support Python 2.7. They don't have to support Python 3.4. Hell, 3.5 was released over 5 years ago. If you're trying to say they have to support that, I'd have to ask why. If someone is paying them to, then sure, that's the term of the contract. Maybe appreciate she's getting paid to do what she presumably enjoys. But if not, why? 3.4 has been out 5 years. 3.5 for 3.5 years, 3.6 for 2.5 years. This is where I ask who are these cases that will run a much older version of python, but wants latest Twisted, and has no ability to run a more current version of python. There are projects like pyenv that make it so anyone can run any version of python. It installs in user space, so you don't need admin rights to your server. I use it as it's the easiest way I found to put &gt;=3.6 on Debian Stretch/9.x, which has 3.5 by default. It's ok for her to tell people "no". If someone is demanding she make her stuff work on older python, she can hold out an open and and say "fill er up!" Saying that you have to preserve workarounds is a bit silly. I'd say give it a fixed period, and make it much shorter than what they're doing. No more 2.x. Easily push the 3.x to 3.5 or 3.6 minimum. If someone can't deal with that, the v18 or v17 Twisted will still work. Maybe you think that group is large, those that are running Python 3.4 and the latest pypi packages. I'd say that 3.5 certainly exists due to Debian fixing on that, but people have recourse, as I've shown in my personal experience. When I laid out a rhetorical case for that being 3 people, you said it was an ignorant statement. So I asked you for those cases where these people are handcuffed.
I played around with different AI methods, including LSTM, and I can tell you this makes no predictions whatsoever. It lags behind the actual price changes, just like a moving average. If you look at blog posts that show off some "amazing" predictive algorithm you'll find that all of them have very zoomed-out graphs for illustration, so you don't see on the graph that the prediction values are actually behind the price values. They show it off as if the model would do really good predictions but if you zoom in you see that's not true. By default you can't make predictions for something totally random, only for something that has similar repeating cycles.
OK. You're trolling. That's my opinion, it can't be changed, I said it because I wanted to say it and now you're forced to read it because "democracy".
I don't know what you're about to, but I personally use the "midi" package found on pypi, e.g. `pip install midi`. That however has some issues with relative/absolute times so I wrote some helper functions to deal with those, let me know if I can help. But it does pretty little in the way of anayzing contents if that's what you want, and the MIDI protocol being serial isn't exactly helpful in that regard.
LOL .. OK
Semicolons are valid in python you know. You can use them.
Extremely well made guide, with one comment. Unfortunately Windows uses UTF-16, so be careful when you handle file content. UTF-8 is not as pervasive as you might think, unfortunately.
That's great! Thanks for your comment.
https://simpleisbetterthancomplex.com/tutorial/2016/07/22/how-to-extend-django-user-model.html
Is there any tutorial on how to do that?
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Things go down. What’s the problem?
What did you expect to find on that page? It's basically the same content as have been at least for the [last five years](https://web.archive.org/web/20140506045436/https://pythonhosted.org/).
OK, well let's see at the end of the year whether the PSF has folded, and if not, if someone with real money decided to do something about it.
Have a look at [matplotlib](https://matplotlib.org)
I thought it’s very telling they have an old ass version of six’s documentation on the site that ranks very high in SEO but is very outdated.
It's not down. That's just how the main page is. Here's an example: https://pythonhosted.org/pickleDB/
My compression algorithm is even better: it converts files of *any* size to 1 byte! Decompression: TBD
Many people that work in machine learning have tried applying the technologies to stock market prediction. Nobody has come up with a free money making machine yet (as far as we know).
Hi there, &amp;#x200B; I just uploaded a tool that generates playlists for spotify based on a concert's setlist. If you want, give it a try! &amp;#x200B; [https://github.com/chr33z/py-spotify-setlist-generator](https://github.com/chr33z/py-spotify-setlist-generator)
And if someone has they aren't going to tell everyone!
Many packages hosted their docs on this site but they stopped accepting updates a long time ago, and it is not possible for the developer of a package to remove the old stuff from the site. It's rather silly.
Thanks for sharing
I was late in needing to use that kind of parallel processing. I had years to read blog posts about threading issues, and had already used job scheduling of thousands of (non communicating) simulation jobs at work. When it came to having to use parallelism within Python I ran from threading and went immediately for multiprocessing. My reasoning was "iy's a difficult problem. Those saying threading is easy are usually on their way to their come-uppance; I'd rather have the OS add some protection to the mix by using processes and get something running sooner" &amp;#x200B; Big-up the multiprocessing posse! Boyaka :-)
matplotlib, seaborn, plotly are all popular libraries for graphing
&gt;Some people, when confronted with a problem, think "I know, I'll use threads." Nothey w hapve robtwo lems. I laughed at that then hunted down [some more](https://nedbatchelder.com/blog/201204/two_problems.html)
It's only "random" if you don't know the features that go into it. Sure, OP is naively looking for numerical patterns in the price levels, which does absolutely nothing to elucidate the features of the data. But it's not really justified to suggest it's impossible to put together a predictive model of a stock's price, if you bring in some outside information. Not insider information. Just outside, publicly-available info that not everyone is creative enough to link together.
Difficult to answer without looking at data but using plt.subplots ( matplotlib) should do it.
At a junior level, there isn't really a big difference between the two. There are some minor syntax things that you should be aware of. But probably nothing more than that.
Okay thanks
You're right. I should have said it's not possible to make a prediction based purely on technical analysis.
This is not what they are saying. They are saying that you can make short term predictions, and if you keep making short term predictions for a long time, the amount you profit will average out to zero.
Time to become the expert, and do it yourself!
Why should I take it to heart when you are helping me so much :) Thanks a lot for your helpful comment, I've just learned new stuff and updated my repo thanks to your guidance, it's true that my code in [flash\_message.py](https://github.com/redasalmi/Python-Package-Manager/blob/master/flash_messages.py) looked ugly and repetitive but it's much cleaner now. I will read more about list comprehensions and try to follow the DRY principal. I will get better in my coding and my next project will be greater I hope ;)
One a more serious note: does anybody know how much it cost?
I just finished a chapter in [https://github.com/jrjohansson/numerical-python-book-code](https://github.com/jrjohansson/numerical-python-book-code) on Cython, and stumbled across this post while looking for more resources. Awesomeness!
I have just a few months of experience programming in python in two companies and I have to say that I have found relatively easy to automate stuff in python just looking for them on google. If your request is not insanely difficult, it is very likely that you can accomplish it without too much pain.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Why are you the way you are...
Is there anything in the "record" file, C:\\Users\\DANIEL\\AppData\\Local\\Temp\\pip-record-oulhk507\\install-record.txt? It may contain more detail regarding the error.
There are a great deal of research papers that suggest otherwise. Also, the majority of the trading firms.
&gt; By default you can't make predictions for something totally random The stock market, of course, isn't "totally random", and you can make predictions for something that doesn't have repeating cycles. Does the weather follow cycles? Yet we predict that.
&gt;The Efficient-Market hypothesis is somewhat controversial however, and it &gt;is likely that improperly priced assets do exist and can be exploited. The very existence of Warren Buffet proves this. It's weird to see all of these people here claiming it's impossible to make a profit in stocks.
&gt;Because stock prices are effectively random walks That's a bold assertion of an unproven hypothesis.
 import numpy as np import matplotlib.pyplot as plt x = np.linspace(0, 100, 1001) y0 = np.sin(x) y1 = np.sin(x) * 2 y2 = np.sin(x+np.pi) fig, (ax0, ax1, ax2) = plt.subplots(figsize=(8,6), nrows=3, ncols=1, sharex=True, sharey=True) ax0.plot(x, y0) ax1.plot(x, y1) ax2.plot(x, y2) produces https://imgur.com/xcro5dr
I love Corey Schafer. I could just tell it's his from the screenshot. I always recommend him.
Actually the weather *does* follow cycles: certain events are always followed by other events, and certain parameters like air pressure and humidity can determine how far ahead is a possible change in weather conditions. But there are so many variables and so fine details that even though we can make predictions, they are often incorrect. In terms of weather that incorrectness is insignificant but on trading it can be the difference between profit and loss, not to mention that we can't predict *when* will a change occur, even if we know that a bullish price change will be followed by a bearish one.
Also, if you know any free python for data science courses that you feel should be included.. please let me know in the comments below..
Thank you so much! I will try it tomorrow and see how it works :D
I have to admit that using DJango admin for data entry is very tempting! Nice job on replacing MS Access / Exce, and I do think at some point you should look at a full RDBMS, there is not much to setting up either one, perhaps MySQL is a little easier. &amp;#x200B; One part where I think you may be making a mistake, is to take the data as a CSV file and dropping it back into Excel. Why not look at some of the powerful libraries Python can use to munch on your data. Someone mentioned Pandas and I think that looking through some tutorials, you will find it almost unnecessary to export into Excel.
Awesome, glad to be of help :), also slight mistake I did: if not response: flash(package + option[operation]) else: flash("Sorry, but "*response + package + option[operation]) Is supposed to be only flash("Sorry, but "*response + package + option[operation]) since if the response is 0 , it will return empty string hence being successful message, it will display the "Sorry, but" otherwise if respone is True, though I'd argue that the first approach would be more readable but both ways work ( though the \*response is unnecessary in the first case )
Can a USB camera work as well?
Why is this "hardware-based"?
What? Observations on the extremes of a distribution are certainly *not* good evidence against the efficient-market hypothesis.
The hardware it runs on matters &gt; The Jetson Nano is a Raspberry Pi-style hardware device that has an embedded GPU and is specifically designed to run deep learning models efficiently.
Dude every program is hardware based.
The excel Userform already exists or you want to create it?
Yes, some USB cameras work. You'll have to Google which models the Jetson Nano supports though to double check.
A question better fit for /r/learnpython I am curious to hear the answers provided as well. I've wrestled with a similar issue in the past and ended up using openpyxl examples from "Automate the boring stuff".
Do you have a text post? Making the actual requests is easy-ish, but I cant for the life of me actually understand what I need to configure in SF to get all my auth data, and what goes where in python.
I know what the jetson family of SOCs are. I worked a lot with the Jetson TX2 doing deep learning at a startup. Still, I'm not really sure what qualifies this as "hardware-based". I could run this, albeit slower, on a raspberry pi. In any case, it's a nice article to help folks get set up using off the shelf software for a fun little project like this.
You would probably want from my colleagues way too much if you gave them jupyter and pandas for data analysis. They are ordinary folk with very basic knowledge of Excel. Even Excel is sometimes much for them. Actually, import to csv pretending its a excel file is my basic strategy for not scaring them much.
Its difficult to explain without detailing the entire project. Excel Userform has been created and works as intended. Python GUI created and works as intended. I guess Im attempting to copy the contents of a python entry box into the textbox of an excel userform.
You can bring your own laptop if it is not forbidden. :)
He talks fast, not complaining but for non english speakers better to see at 0.75 speed
I needed something exactly like this, thank you OP!
I definitely wasn’t claiming that it’s impossible to make money in the stock market. You can make a fortune if you know how to properly value a company, and investors like Buffet have proven that they do. I was giving caution against technical analysis. (i.e., looking for patterns, or behaviors from price/volume data or media sentiment).
Orrrrr you could learn opencv and do it yourself for free + personal experience?
Had you tried to use this lib? [https://www.xlwings.org/](https://www.xlwings.org/)
Even people who think that you can find inefficiencies in the market are referring to big institutional investors. Seriously. Just drop money in an ETF and walk away.
I just meant as opposed to running on your normal computer. I guess "on a stand alone hardware device" probably would have been more accurate.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I think this is more related to how much time to deliver the project you will have.
"Build a GPU-accelerated Face Recognition System for $150 with the Nvidia Jetson Nano and Python" is probably more appropriate
"Build a GPU-accelerated Face Recognition System for $150 with the Nvidia Jetson Nano and Python" is probably more apt
I have not, it may be a step in the right direction though. Will check this out.
you can try this one: [https://pypi.org/project/rssi/](https://pypi.org/project/rssi/) I have not used it before. It looks like it was built for ubuntu. I have made similar modules for my own projects by finding the command that polls the wireless card for my OS. Then I made a few subprocess class to run the command and collect the output. The output is then parsed to get the relevenat info and use it my scripts, database, etc. I did this for a web interface for a small IoT device.
By “effectively” I mean they are close to random walks, which isn’t bold nor controversial to most people in finance.
Also post this to /r/learnpython next time
Currently, it only does the build in passive scans, I plan to use this for CI environments, as we build the app, we spider it and run a passive scan, then send the results back in to jira (once vetted). Will play with the active scans in the future, but there is too much configuration to cover all of the different web stacks. The nice thing about using flask is it allows for the security team to implement logging to see when and how its being used, as well as only whitelisting the domains we want!
Traceback (most recent call last): File "reddit:/OP/is/wrong.py", line 1
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Book: https://automatetheboringstuff.com/ You could also check out the MITx course for this. It is a really good one. Idk if it runs in the summer tho.
I don't agree with you! Space is NOT better than tables and chairs.
Docs for a new language like this aren't going to be as mature as docs for a more established language like python, Java, JavaScript, and so on. I doubt many solidity programmers (do many exist?) learned it as their first language. That said, I can't tell you if python or some other language would be helpful in learning this because I've never used it before, but it would probably be easiest to learn a general purpose language (like python) before learning a domain specific language like this.
The except block is only entered when a ValueError Exception is thrown (raised). Since your print hello runs without any exception you are not getting to the error handling code within the except block.
There is nothing wrong with 'print ("Hello World")' If you want to throw a error whrn there isnt a number, code should be like this: 'Try: ind = int( input("number here:")) print ("hello") Except: print ("bye")
Right. OP, all input and output is done as strings unless otherwise specified. First wrap the `input()` call in an `int()` call. Then put that whole line in the `try` block
Your code doesn’t throw an exception at all. Also r/learnpython, and don’t post videos or photos of your code, it’s difficult if not impossible to read on many clients.
I feel silly even typing this, but I am trying to write a simple script to create a desktop shortcut and I can't figure it out. I am using spyder and can't even figure out how to import the pywin32 package like I read on an online forum. I'm not even sure I am using the right IDE for this. I am 100% lost lol
/r/learnpython is also great
[Source code here](https://github.com/JakeHuneau/BarLibrary/)
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Smh
A
a `try/except` block will always attempt to run the code in the `try` block (hence the name) and will NOT run the `except` code unless an exception occurs. For example, if you had the following code try: print(2.1 + 'a') print('hello') except TypeError: print('skipped over') you would only see `'skipped over'`printed, because `2.1` is a float, and `'a'` is a string, and you cannot "add" them in a logical way without converting the types. Normally, an error is thrown, and the program exits, but you created a try/except to handle this error. So the `except` block is entered, the custom message is shown, and you can't go back.
Im struggling to read it (on mobile.) I don’t see what’s wrong with it
...unless OP is Richard Hendricks.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Thank you!! This is exactly what I needed!
Salesforce’s APIs are accessed via https, and doing so from Python is no different than any other language. Now how to consume them easily... that’s a worthwhile article.
&gt; Someone told me very early in my career to always assume there was a reason that things are the way they are See also [Chesterton's Fence](https://en.wikipedia.org/wiki/Wikipedia:Chesterton%27s_fence). Your main points are well taken. I would have omitted the identity politics ranting, however, since it isn't relevant except to people who want to make the disagreement about that.
I've gotten a few ridiculously large ASCII files from Windows users who saved with UTF-16 file encoding.
If you say something's impossible and someone does it... repeatedly, for decades... it's good evidence. &gt;Empirical evidence has been mixed, but has generally not supported &gt;strong forms of the efficient-market hypothesis. According to Dreman and &gt;Berry, in a 1995 paper, low P/E stocks have greater returns. In an earlier &gt;paper Dreman also refuted the assertion by Ray Ball that these higher &gt;returns could be attributed to higher beta, whose research had been &gt;accepted by efficient market theorists as explaining the anomaly in neat &gt;accordance with modern portfolio theory. https://www.businessinsider.com/warren-buffett-on-efficient-market-hypothesis-2010-12 Even study of horse race betting markets show significant evidence against efficient markets.
The whole point of `socket` is to provide an interface just like the one C uses. Someone is free to imagine a "more Pythonic" interface, and for all I know 67 different PyPI publishers already have, to their ignominious posterity. What, specifically, would you have instead of `socket`?
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
It would be controversial to Goldman-Sachs, or well, anyone who makes money from the stock market. Hell, even decades of investigation into horse race betting markets show inefficiencies. Even Wikipedia will tell you: &gt;Investors, including the likes of Warren Buffett,[37] and researchers have &gt;disputed the efficient-market hypothesis both empirically and &gt;theoretically. Behavioral economists attribute the imperfections in &gt;financial markets to a combination of cognitive biases such as &gt;overconfidence, overreaction, representative bias, information bias, and &gt;various other predictable human errors in reasoning and information &gt;processing. These have been researched by psychologists such as &gt;Daniel Kahneman, Amos Tversky and Paul Slovic and economist &gt;Richard Thaler. These errors in reasoning lead most investors to avoid &gt;value stocks and buy growth stocks at expensive prices, which allow &gt;those who reason correctly to profit from bargains in neglected value &gt;stocks and the overreacted selling of growth stocks.[citation needed] &gt; &gt;Empirical evidence has been mixed, but has generally not supported &gt;strong forms of the efficient-market hypothesis[38][39][40] According to &gt;Dreman and Berry, in a 1995 paper, low P/E stocks have greater &gt;returns.[41] In an earlier paper Dreman also refuted the assertion by Ray &gt;Ball that these higher returns could be attributed to higher &gt;beta,[clarification needed][42] whose research had been accepted by &gt;efficient market theorists as explaining the anomaly[43] in neat &gt;accordance with modern portfolio theory. Stock prices aren't random; they're the result of non-random actions of individuals (or more commonly today, algorithms).
thank you bot man
These sorts of project are interesting, but there is no reason to think that it will actually work for predicting stock prices. Did you try to compare the results with a similar autoregressive model? It is unlikely that the LSTM performs better, and may actually be worse since it is so easy to overfit financial data.
You literally believe that no one out there can do better than the market average? Have you talked to Warren Buffet? &gt;I'm convinced that there is much inefficiency in the market. These &gt;Graham-and-Doddsville investors have successfully exploited gaps &gt;between price and value. When the price of a stock can be influenced by &gt;a "herd" on Wall Street with prices set at the margin by the most &gt;emotional person, or the greediest person, or the most depressed person, &gt;it is hard to argue that the market always prices rationally. In fact, market &gt;prices are frequently nonsensical." &gt;....Ships will sail around the world but the Flat Earth Society will flourish. &gt;There will continue to be wide discrepancies between price and value in &gt;the marketplace, and those who read their Graham &amp; Dodd will continue &gt;to prosper. It looks like this Python thread today is being visited by the Flat Earth Society.
So was your bot going against another in-game AI bot, or was it another player?
Hello! I'm a bot! I see someone has already suggested going to r/learnpython, a sub geared towards questions and learning more about python. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
&gt; You literally believe that no one out there can do better than the market average? Have you talked to Warren Buffet? No, I'm saying that algorithmic investing as a retail investor is absolute insanity and even if you beat the market, you will still lose in transaction fee's. Seriously if you want to do this as a hobby go for it.
It's hard to be particularly specific when you're asking me what I'd supplement a large and serious module with; but I regularly just want to be able to open a TCP connection, have some back and forth, and close it. If you want to do that from the server side, you may be able to get away with the wrappers in \`socketserver\` , but no such library exists for the client side as far as I'm aware. I don't think many people besides library maintainers should have to go down as low level as \`socket.send/recv\` -- unless you're calling localhost, you're guaranteed to have to use the implement error handling around it, and the first rule of TCP error handling is you're guaranteed to get it wrong
Hi, You might be right! I'll take a closer look at what I wrote and make the updates if needed. Thanks for bringing it to my attention
Who is saying this? To me everyone is saying it’s a *losing battle* for the average retail investor to *beat the market*, particularly with a short term trading strategy. Citing Warren Buffet as your counter argument is like citing Steph Curry that some people are good at basketball.
How did you learn to make this bot?
I don’t know but that’s pretty handy if you figure it out.
I took this class a couple years ago [https://www.edx.org/course/introduction-to-computer-science-and-programming-using-python-2](https://www.edx.org/course/introduction-to-computer-science-and-programming-using-python-2) . The version I took was based on Python 2, but this one is Python 3. &amp;#x200B; It's a good class.
I'm not sure what kind of analysis you plan to do, but the [music21](https://web.mit.edu/music21/doc/about/what.html) package is designed for musical analysis.
 import sc2 What is this library?
So I guess you're not saying that: * `socket` shouldn't exist * `socket` shouldn't have the structure and features it has * `socket` shouldn't be in the stdlib So I guess you're saying you want something like [the example in the docs](https://docs.python.org/2/howto/sockets.html#using-a-socket)? And you want that in the stdlib?
Using this library: https://github.com/Dentosal/python-sc2
I learned it in [Ohm's Law](https://www.douglaskrantz.com/ElecOhmsLaw.html) in high school physics. I'm in the USA.
That you this looks interesting. I like the 'As promised, worker rush in less than twenty lines:'
I see everyone invoking "Efficient Market Hypothesis", which means that it's impossible to beat the market, and downvoting any opinion to the contrary. This is what they are literally saying, and then when called out claim they're saying something else. Heck, quoting /u/BlueDevilStats, whom I replied to: &gt;They are saying that you are, over the long term, fighting a losing battle &gt;due to market efficiency. And I'm saying that's just wrong. &gt;I'm convinced that there is much inefficiency in the market.... When the &gt;price of a stock can be influenced by a "herd" on Wall Street with prices &gt;set at the margin by the most emotional person, or the greediest person, &gt;or the most depressed person, it is hard to argue that the market always &gt;prices rationally. In fact, market prices are frequently nonsensical. -Warren Buffet There are plenty of research papers that show neural networks or similar machine learning algorithms beating the market, so I don't know why everyone is discouraging this poster. Just a few: https://drive.google.com/open?id=1k6nDQmCdTSz5_OHreG2t79m2XDKgIHXH &gt;Citing Warren Buffet as your counter argument is like citing Steph Curry &gt;that some people are good at basketball. No, the existence of Warren Buffet proves the market is inefficient, otherwise it would be impossible for Buffet to have done what he's done. In fact, **Warren Buffet has said that the existence of Warren Buffet rebuts the Efficient Market Hypothesis**.
Try reading "automate the boring stuff with python". For websites you have Flask or Django, which are the 2 most popular frameworks(At least that I know)
Don't bother. This dude is a moron.
&gt;No, I'm saying that algorithmic investing as a retail investor is absolute &gt;insanity This is like people who say it's impossible to win at the racetrack (also an inefficient market long-studied by economists) just because they themselves can't do it. &gt; and even if you beat the market, you will still lose in transaction fee's. So you're not aware of the multiple companies today such as Robinhood and Alpaca Markets that cater to individual algorithmic investors and don't charge transaction fees? When Robert Hessler had his sentiment-predicting neural network short-term stock selector active, it beat the market 13 out of 15 years: https://web.archive.org/web/20111222124949/http://www.shortterm.com/ A short collection regarding more modern neural network (and some other ML) work on the market: https://drive.google.com/open?id=1k6nDQmCdTSz5_OHreG2t79m2XDKgIHXH Shame on people for discouraging the poster from pursuing their endeavor.
Thank-you! :)
Hey, mate! [https://edgecate.com/articles/sfdc/](https://edgecate.com/articles/sfdc/) There's a quick step-by-step of what you need to configure in SFDC, and what you put into the Python module. Let me know how you go!
The guide seemed good. What got me to finally get it was to think as follows: * all files are bytes. No matter what! (But see below) * all things you treat as text are Unicode and you must always convert from bytes to Unicode. * encoding is how to read the binary into Unicode. UTF8 is most common and very compact. But there are others. Must be **decoded** when going from bytes to Unicode. * using open in text mode should *always* be thought of as a shortcut for reading bytes and decoding. * all Unicode must be encoded into bytes. * decode ASAP and encode as late as possible. * there is probably an exception to everything I said!
I honestly just don't want people to lose their money chasing a fantasy that goes against economic principles. Seriously. The skills you learn doing this kind of stuff are useful ( I learned R back-testing trading strategies) , but do it as a hobby.
Working on an automated TV/movie metadata program
This looks really interesting. Do you have plans to support asyncio in the future?
No one is talking about the idea and are just being pedants about the 'hardware' title. Shakespeare before grammar guys. Shakespeare before grammar.
You should be careful with stepwise removal of independent variables. Even if variables are completely insignificant if you have reason to believe they matter they should remain in the model.
Nice benchmarks. Too bad it's not very pythonic.
/u/shy524
Corey Schafer is the best
I'm also about to start a side project sport sim game. Mind sharing your resources for the GUI side of things?
Did not know how much I needed this. Thank you!
$150!? Dude, spend less than $50 on a raspberry pi and camera and you can do this.......
Don't know why you're being downvoted....it's good advice. This is a Python sub, not an Nvidia sub. Why spend $150 on this when you can do it much more cheaply with Python packages and a raspberry pi + camera
this is valid criticism, fast is not the end all if your api sucks.
My wording seems a bit pretentious or arrogant, twas just a friendly reminder that python is free and open source for a reason.
lol what the fuck even is that API? People don't use requests for the speed. People don't use *python* for the speed. They use it because of its usable, intuitive, well-documented interface.
Someone has try to run this code on raspberry? Is it really so slow? I ask that for pure curiosity.
Working on a bottom -up finite element program.
Yeah, I guess I see that from the Orrrrr, but didn't seem bad enough to downvote ya over. imho
It'a not free, IIRC.
Why?
It seems faster because it does less...
What's the unit of measurement for speed?
i could install using pip install git+https://github.com/oanda/oandapy.git
Lemme at it
W3school can be of use, and if you need an interpreter I suggest going to a website like repl.it or pythonanwhere or getting a Linux Ubuntu vm as python on windows can be annoying.
A strange game. The only winning move is not to play.
Try sudo atp install python-oandapy
[NumPy for Matlab users](https://docs.scipy.org/doc/numpy/user/numpy-for-matlab-users.html) [SciPy Lectures](https://scipy-lectures.org/)
Might be a good time to remind everyone, that if you're using MySQL/MariaDB.... the `utf8_general_ci` and `utf8_unicode_ci` aren't really utf8, and you'll have odd problems if you try to store emoticons.
1. Take *free* online classes like Cousera; https://www.coursera.org/learn/python 2. Start working on your own projects to automate your own tasks, solve your own issues in the computer, build web app, do whatever interests you
Relax, there's still a place for optimizing Python code for speed.
But if you are going to output json, how do you decide the schema?
If you get desperate enough I know some nice time series functions in R, they're close to automatic. I took time series and it was hard. These functions took me like a day to figure out and they went way beyond my 10 week course from one of the best time series experts in the world. Depending on your workflow, you could do something that keeps most of your process in Python. I just checked out your profile because I thought your comment about economists was hilarious, and was curious what someone with your username might follow.
Is Requests really a problem? I recently had to pull some 800k records one at a time via a REST API. It was slow-ish, so I threaded it and ran 20 concurrently. I was able to pull the data down and run MongoDB inserts at around 50/sec. Could have gone faster but I didn't want to choke the server I was pulling from. I'm far from the best guy on this sub. But if I can do this, anyone can.
This was short and useful.
It should be fine but it would help if you have some very clear, very detailed, very specific description of the exact work and workflow.
I'm experimenting with object oriented programming by rewriting my text rpg. Now, I only have the objects and all that. I still want to make a combat system, which I already know how to make. A map, which I want to make with some tuples or lists and functions. And a story, the easiest part.
The first few paragraphs in the article go over why he didnt use a rpi. The jetson has cuda cores which enable cuda acceleration.
Numpy, Pandas, Matplotlib, Seaborn.. it's all there. Familiarize yourself with jupyter notebooks because I think that'll be a little closer to your MATLAB experience. Python kicks ass. You'll be glad you made the switch.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Note that pandassql actually creates a local sqlite database to perform the query on. As such, the dtypes of the result may not be what you expect.
this is really cool, the second link discover new drinks is very fun
The grammatical errors in this are extremely distracting, but I do want to learn about it...
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
https://medium.com/@jaynsw/run-python-flask-hello-world-on-severless-cloud-c5ec74eee782
This was the first library I learned. It's awesome.
Phyton? Must be interesting!!
If you think you are ready maybe next step is to work with different APIs in Python. Google APIs are a good start. https://console.developers.google.com/ Google Developers Console
Gigablings per week
English may or may not even be OP’s native language. Either way, I wouldn’t let grammar distract you from the content, which I found to be pretty damn insightful.
"only 800 lines of code" when all you've done is wrap the nim standard library... which has how many LoC itself? Not impressed with the lying. Im sure you can customise the ssl context and use an appropriate trusted cert bundle with this too, right?
r/learnpython
WHY ARE WE YELLING IN OUR TITLES
The fact that you managed to misspell the name of the language that you've been learning for half a year makes me doubt in your learning efficiency. Maybe you'd better learn something with an easier name: C or D for example.
First tip, learn to avoid unreasonable expectations. Second tip, the resources on the sidebar at r/learnpython.
/r/learnpython and read the sidebar.
Normally, I'd recommend sshfs, but you're on Windows, so that won't fly. And while I do think you should use a better OS, I am too old to be a dick about it. However, if that server is an actual production server, then my recommendation is to stop touching it directly RIGHT NOW. Set up the server stack you need in order to run the application locally, on your computer; put the source code in source control (these days, that means git), and write yourself a little deployment script that builds your project (even if that just means "copy the files you need into a suitable staging area and add the production configuration files" - but you can also hook things like pip, sass, JS bundling, etc., into this) and uploads it to the production server. Now you can edit to your heart's desire, test things, and deploy with a single click when you are happy (and you can also deploy an older version should things go pear-shaped, because you still have then in source control).
Can you explain what you are benchmarking? The numbers look nice but what is `speed` actually measuring? Are you timing the request to some url? These numbers are meaningless without the information on how they are calculated.
Looked into this last night, you are correct, tad disappointing. Fairly certain you can can the results im after without a cost however.
What is it about the API that you could not grok?
[Optimizing Python code for speed](https://i.imgflip.com/31hpn3.jpg)
What is pythonic or not about making web requests? It is a small detail and hopefully you have more important fish to fry.
I also find it hard to believe that the library itself would be the limiting factor, surely the internet speeds are capping harder. Most of the time at least.
I found the benchmarks in his GitHub: [https://i.imgflip.com/31hpn3.jpg](https://i.imgflip.com/31hpn3.jpg)
seems interesting, what tutorial/guide would you suggest to get started with Pyramid? If possible pls share.
Install Spyder as your editor to ease the pain. It can be setup looking like matlab (though provides much more) so that you can focus on the python parts instead of programming IDE itself.
There's a whole bundle to choce from here https://docs.pylonsproject.org/projects/pyramid-tutorials/en/latest/
Yeah but in this case the code is for specific hardware
we boob?
Is the second return True not redundant here? @staticmethod def createFolder(): try: if not _os.path.exists(f'{_os.getcwd()}\\red_media'): _os.mkdir(f'{_os.getcwd()}\\red_media') return True return True except Exception as e: print(e) return False
Cheers op
I'm not saying socket shouldn't exist, or that it shouldn't be in the stdlib. In fact I explicitly said that socket is going to be useful for library maintainers, which fairly obviously means it should stay in. &amp;#x200B; I don't see what's contentious about my point. Socket programming is needlessly painful in python. The example provided only implements a subset of the necessary error handling and only works for fixed length messages -- it's far too trivial for real programs
Yes the second True is redundant there. Thanks for pointing out. Regarding the seconding point, the best practice is to use if not sort_option I had changed it for don't know what reason. Thanks again.
I hope they might be more receptive of a in-page popup suggesting a redirection to more current information.
Not true, you should always do compares on None with `is None` From PEP8: "Comparisons to singletons like None should always be done with is or is not, never the equality operators."
'hello', its the same as ['h','e','l', 'l', 'o']
I don't really get why you rename the modules to `_module` Line 18: Never compare None with the equality Operators (See PEP8) Line 21: never build a string like this, use f-strings, implicit string concatenation or any of the other ways Line 54: why? This isn't used anywhere else Line 62: comment serves no purpose, just rename the variable; If it aren't actually images don't call it that. Call it image_links or something. Generally: `pathlib` &gt;&gt; `os`
Quite nice video. I have encountered many problems with salesforce api especially since our company plan didnt include for some reason the access to the app manager so I had to design some custom soap api python modules that were pretty painful. In fact, I wasnt even aware that such a blessing as the app thingy existed since I had to rely on the installed package page to design my api calls. &amp;#x200B; I submitted a ticket to salesforce to ask why I didnt have access to the app manager page. Let's hope I can roll out of the soap api in a few days
I'd have to create one from scratch really, as I can't find a JSON schema for Gedcom 5.5 (there does appear to be one for Gedcom X - but no one really uses that standard even though it's been around for years). The mapping should be fairly straightforward, i.e. 1:1, just need to ensure that I get the levels right really.
15 angry nvidia employees ;)
I named the modules as _modules because it terms them as protected and does not usually show in autocomplete in various editors. I read this (answer)[https://stackoverflow.com/a/21217121/9809865] Line-21: I usually use f-strings but this method looked easier and clearer. Line-54: I used the flag when I used the code for testing and it was not working somewhere. Thanks for pointing it out, missed it. Line-62: Thanks for pointing it out. Thanks for reminding me about the pathlib module. Can you suggest me something to improve my coding style? Thanks a lot for giving your valuable time here. I appreciate it a lot.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I think I got confused. Thanks!
i want to group funds which have values on the same date . My csv has more than 2000 funds and say 10 funds have values on exactly the same days in the two year time period i would like them to be grouped . once a fund is grouped it should be removed from the dataframe. i want a 100% date match as i have 2500 funds and getting a 100% accuracy would be easy. i have the value column with 1 just for easy comparison as i found dates difficult to compare
Something like [https://marketplace.visualstudio.com/items?itemName=brainfit.vscode-importmagic](https://marketplace.visualstudio.com/items?itemName=brainfit.vscode-importmagic) ?
As the answer you linked states: in Python there is no concept of private or protected - it means "yeah it may break stuff if you modify this or so weird stuff when you try reading it" (for example a value behind a property that is usually accessed with a Lock). Line 21: f-strings are highly optimized - I'd use them pretty much everywhere. If you need to build a string with a loop use Join, if you need to concat strings (for example across multiple lines) do `"a" "b"`, if you interpolate values use f-strings Honestly: PEP8 for most of the stuff; the Google Format guideline for docstrings and iirc this talk is also really great https://youtu.be/ZsHMHukIlJY
1. /r/learnpython 2. Why? 3. What does "screen refresh" have to do with this?
Thanks a lot for the insight.
1. sry i red the rules too late 2. to get a list of all possible french conventioned phone numbers (a lil project no big deal) 3. i'm used to scratch's "run without screen refresh" option on functions sry
Well how are you learning?
What are you trying to achieve, exactly? Are you trying to get a list of all possible phone numbers? Because not any combination of digits is a valid dialable phone number. Also, what are you going to do with the data next? You'll have 10^10 numbers, now what?
Have you looked into Flask or Django? If it needs to be lightweight you might like Flask, if it gets heavier Django might be for you. Hope that answers your question?
Oh my, this looks like a winner! Can't wait to give it a shot tomorrow
I'm not sure I understand the concern. These computations can't be performed directly in Excel due to their complexity. Excel is just the interface, replacing a series of .cfg files or a custom GUI. Text based config files would have been unwieldy from a user point of view and a GUI would have been a much larger effort to build.
i'll map them on a 10\^10 long list of french names genrated using this [https://www.youtube.com/watch?v=YsR7r2378j0](https://www.youtube.com/watch?v=YsR7r2378j0) method (the bideo is in french so subtitles i guess.
And then what?
and it's not made for humans.
Apparently, I looked up both of them and I can't decide which one is better for my project. for now it's a small project but it will be a big one soon . Which is better for you ?
I tend to use Flask more often than Django, but I’ve noticed that Flask experiences performance issues once the work load gets too big. Django is overkill for simple one-view projects, but at the end the data-throughput determines the workload for the server. The question is; are you planning on doing the data-processing from within the same application? Or are you going to segment it. If the only thing your webpage has to do is showing some info, a lightweight framework is good enough, that’s where you use Flask. If you are going to process the data from within the application you’ll need something that won’t slow down once the dataset gets bigger; thus Django. Could be very much possible that other people see it differently tho. I’d wait for other replies as well.
then i can use this name to phone number list in my game (random name generation is seeded with pseudos) like so : pseudo --&gt;rng with science etonante's algorythm --&gt;name --&gt; phone number the goal of the algorythm being to generate a phone number that is specific to each player.
And why do you need a list of _all possible phone numbers_ to do that?
never to run out of phone numbers.
But do you need to actually have all of them written down somewhere? Maybe it's enough to figure out what a phone number actually _is_ and then generate them randomly as needed?
the goal is to have a 2d array (list of list ye i know) that does something like that: \--name-- | --number-- \--name-- | --number-- \--name-- | --number-- \--name-- | --number-- etc...
But why do you need to pregenerate those things at all? Why not generate them _as needed_?
then when i generate a word i look for it in the array then take the right phone number
cuz i don't know how to do that
Agree with the comment bellow. The pylon ones are great. The biggest thing for me was getting my feet wet and starting a project and learning by failing.
Thank you!
How would you approach something like that? Let's say we have a way to pick a random number between some number A and some number B.
google it
then... i'd randomly pick a number seeding my rng with the generated names?
Don't worry about seeding anything for now. All you need to do is generate a random name and a random number. You don't need to worry about how it's seeded or anything like that.
No dependencies, other than nimble, whatever that is.
I did it tho, this is why i ask you
but if i dont seed anything how can i make sure i dont get the number/name multiple times
There's a _very_ small chance of having a duplicate, and you can check if the name/number is duplicate and then reroll if it ever becomes an issue.
/r/learnpython read the sidebar flask and django
so what i do is i first generate a name randomly using markov chains with the corresponding country's probability table, then generate a number randomly from 1 to 10\^9 with a 0 at the begining, then i cycle through the existing names/numbers to check if he's a dupe , then i'm good to go?
Yes.
oki thx
I really like the creativity of this not so typical Pycon talk. Do you know other examples of using Python for creating physical objects?
[removed]
Thanks for the heads up.
Agreed.
[Ultimaker Cura](https://ultimaker.com/en/products/ultimaker-cura-software), a slicer for turning 3D models into gcode for 3D printers, uses Python for user-creatable plugins and postprocessors. It's not quite what you're talking about but still relevant to Python-knowledgeable makers.
[https://github.com/search?q=photobooth](https://github.com/search?q=photobooth)
Thanks! Did not know about swiftapply.
Spent 2.5 hours this weekend watching Brandon Rhodes Pandas presentation from Pycon 2015 (recommended in a different thread). It's incredibly helpful. https://www.youtube.com/watch?v=5JnMutdy6Fw
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
\&gt; We also have no Dependencies, nor *Fundraising*. &amp;#x200B; lol
This talk is well worth watching just to see and have explained to you all the nontrivial things that have to be pulled together to make such a "simple" thing (input an image, get it back as a pattern and an auto-selected palette of thread colors that best match what was in your image to what's actually available in a crafts shop) work. And then go read any of the many Twitter threads (pun intended) and articles around the web exploring the similarities between needlework and programming. You'll learn interesting things.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
To write python idiomatically means to write it with readability and simplicity in mind. That is not an opinion, that is part of the Zen of Python. Web requests alone has nothing to do with being pythonic. How you make web requests (in Python) certainly does.
A three level lookahead minimax should be all the AI you need.
This is exactly what I wanted too but it’s not (yet?) possible
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Use a virtual machine and run an ubuntu instance on Windows. It will save you time in the long run. I'm not joking.
Libraries which make this EASY are probs the two most needed features of Python on Windows. Well, plus a nice Excel-like Pandas viewer for inline work in Jupyter.
Obviously. I was just trolling.
&gt; Am I developing this for the wrong reason? As you are learning, I'd say no. Your reason is to learn. The problem is that you are learning but you are missing feedback. &gt; Do you always develop something with other users in mind? (Excluding personal tools) Depends. When I work, yes. When I'm home, I develop for myself. One sad fact about programming is that I'd wager 95% of the code you write throughout your career will have little to no impact and it exists for little or no reason. &gt; If i want people to use things i've created, should I just make something so unique/obscure that it will at least draw in some interest. No. You join another project and code what's needed already. &gt; Should I start a project with this hook in mind? (obviously if you want people to use something it helps if its useful but I'm far from competing with whats out there) I've created tons of projects, but the reality is that project popularity is based mostly on marketing. There are plenty of very similar techs, but in the end the one that markets it better is the winner. Everybody else wasted their time. &gt; Do any of you have stories of feeling de-motivated when working on personal projects I've never felt motivated about anything I've written when they tried to be about others, also because what others do is generally shit on it. The only things I feel motivated about is if I want to do an experiment, or try something new. &gt; if you managed to over come that, what helped? Massive amounts of money when I go to work. I'm in it only for that, mostly.
Use autohotkey.
Bullet velocity of AR15 in football fields per Fahrenheit presumably.
Use a virtualbox and run an ubuntu instance.
Maybe this does belong in /r/learnpython. I really appreciate your answer regardless
Care to share your code? Sounds fun!
Been there. For something to be used regularly it should fill an unmet need or a met need in a way that provides a different experience. For example on the latter, the need of a place to sleep when traveling is well met by hotels. All hotels are essentially the same, but the experience is not. Read up on value propositions for more on that. When I pick a new module programming, it's often not what's best, technically, but what's good enough for the use case with the best experience using and/or already fits my coding style. Starbucks is another great example. Ultimately, they are selling an experience and atmosphere while drinking coffee. That's their value proposition. As for myself, now I just focus on software for self or friends. I made a buddy of mine a custom calc to help him with his work. It made me feel great and sounds to have gotten good use.
Interesting insight, i'll definitaly do some research on this and see if i can identify anything I can take advantage of in this area. Thanks!
Someone needs to make \`prettier-than-faster-than-requests\`.
That's a server application run by that app.run\_server(debug=True). Place the script somewhere where it is reachable from your views and make import like import myscript (if it's in the same folder) on top of the views. Inside a view call myscript.app.run\_server(debug=True).
[This](https://docs.python.org/3/reference/datamodel.html) should be a great place to start...
I don't really understand this complaint. The docs plainly say that socket is intended to be as thin a layer as possible over the underlying system call. You think that Python should re-document every single OS's socket implementation? It seems to me that you actually want some higher level modules to provide code for some socket programming paradigms you find useful. Socket is still necessary, and some of those higher level modules exist. I'm not sure they belong in stdlib, though.
i wants to run it with in a view function and wants to pass arguments like channel id ,results
I have a pdf example with the format, I redacted the information since it's a bit sensitive. The information however is text and decimal values. [https://drive.google.com/open?id=1STsvIqH2lmVi6OH9NLWcB7qHQ2eKzX3H](https://drive.google.com/open?id=1STsvIqH2lmVi6OH9NLWcB7qHQ2eKzX3H) This is the sample
Sadly, that only says what I already know, and doesn't offer any help :( Here's the relevant portions I'm talking about. &gt; Note This method may still be bypassed when looking up special methods as the result of implicit invocation via language syntax or built-in functions. See Special method lookup. .. &gt; 3.3.10. Special method lookup For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary. .. &gt; In addition to bypassing any instance attributes in the interest of correctness, implicit special method lookup generally also bypasses the __getattribute__() method even of the object’s metaclass .. &gt; Bypassing the __getattribute__() machinery in this fashion provides significant scope for speed optimisations within the interpreter, at the cost of some flexibility in the handling of special methods (the special method must be set on the class object itself in order to be consistently invoked by the interpreter). It doesn't really say which special methods need to be implemented for complete functioning.
Ask in r/learnpython, this is not suitable for this sub.
Does it need to be known ahead of time? You can always query your wrapped object for supported methods and then add those to your proxy instance.
What program did you use to do the sprites?
I welcome you to do all of your programming in C, where you have to worry about memory allocation and garbage collection, and everything else that comes along with C. At that rate, why stop there? Why not just do it in assembly? The point of having libraries readily available is that these sorts of problems have been solved before and there is no need for every developer to duplicate the same general code over and over. Most of the time, we’re not trying to understand the inner workings of an ML algorithm / package, but trying to produce something for a product. Furthermore, a lot of these packages have been optimized to support highly intensive computing in ways that your average dev could not replicate. Also ML packages written in Python are not the Python language...lol.
"You shouldn't use abstractions you didn't build yourself!", OP yelled on Reddit, a website built by other people, through their browser built by other people, running on an OS built by other people, communicating over networks and protocols built by other people, running on CPUs built by other people. "The only way to learn is to program everything yourself!"
Create products that provide value for your users instead of jerking off about your technology choices.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
You're not *wrong* per se, you're just an elitist asshole.
This is what I was trying to capture with my comment, but I’m half awake and couldn’t. Bless you.
But is it really "programming" if all I do is import YourReallyAwesomeLibrary and then call YourReallyAwesomeFunction()?
But is it really "programming" if all I do is `#include &lt;stdio&gt;` and then call `printf("%s", "yes, it is, you hypermanual dingus")`?
As another commenter said, whatever you are making a proxy for, you can always query what magic methods it has by \`dir(obj)\`. Use \`help(obj.method)\` to learn more about that particular method.
Of all the people in the world, I would think that a programmer would be among the first to understand that things aren't any better just because they're more complicated.
I agree, but writing a gender classifier in Python was probably the least satisfying code I've written in 2 decades. Remarkable that it's that easy? Yes. Satisfying to have "worked" on? No.
If you’re writing instructions into the computer for it to process, it’s programming. You can feel free to do everything yourself but if that’s your mindset you’re going to have an incredibly difficult time in this industry.
At least I'm not wrong. Per se.
Well. It depends on what you do with Python. You can use extensions with already trained models, or you can build your models from scratch. Saying something is "easy" is just lying to yourself. Like those types of kids back in 5th grade who said "drumming is easy" because they were able to play a 4/4 blues groove.
I’m more than a little concerned that you say you’ve been doing this for two decades and this is the sort of attitude you take on. If you don’t like writing classifiers in Python using ML libraries then don’t.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I didn't argue that complicated is better. I'm arguing that someone could do something absolutely amazing with no real idea of how it works. That's not satisfying.
Can you really call it carpentry if you use prepared wood and tools you bought in the store? Can you really call it cooking if you didn't grow your vegetables yourself? Can you really call it programming if you're using a programming language and not writing machine code directly?
What is it about the API that said to you "ah yes, this was obviously the sensible, idiomatic way to do it"?
Sounds like a classic case of [X-Y-problem](http://xyproblem.info/). I don't think asking for a comprehensive list is a good idea. Consider that this list is bound to change with upcoming versions of Python and has already undergone considerable changes in the past. You may end up maintaining varying lists of magic methods for different versions of Python. I think the goto approach here would be to just `try` to call the respective method from within a generic `__getattribute__` and react appropriately to `TypeError`. It may also be possible to analyse the proxied object's class dict (`someobject.__class__.__dict__`) to find out which dunder methods were defined on that class. Of course you may end up having to walk up the inheritance chain as well, so this is bound to get quite complicated.
Here's what I'm thinking of doing: analyzing already existing MIDI files (for example ones that I create in my DAW), and getting the pitch, onset, duration and velocity informations into seperate lists so I can work and alter these structures in the Python programme and then bounce a new MIDI file out from the altered lists of information. I have my own methods for altering and working with for example pitch information, so I only need a way of importing MIDI info and exporting MIDI info. Is that doable with "midi"?
Without a .h and a semicolon??? Definitely not....
I wish he added a section for TDD with pandas, since it may not be easy for new comer. At some point, to test my transformation on a dataset, I use a mix of `pandas.testing.assert_frame_equal` and PyHamcrest, but I have to deal with multiple workaround to layout the input and expected data as the volume or structure of the data may not be easy to setup.
This is a "*you're" level comment response. I hope you're proud of yourself.
I looked it up, and maybe it can do the job, I just couldn't easily make it out from the info on the page, since it looked like more of a score-library? Anyway, I wanna analyze existing MIDI files and get the info into separate lists; one for pitch, for onset, duration and velocity. Do you know if that's possible in music21?
I'm not arguing that everything has to be done the hard way, but I don't know how anyone can argue that classifying anything in 6 lines of code is satisfying.
Compared to the effort of writing the same thing in C, it was mindboggingly easy.
Satisfaction is subjective dude. Some of us like simple solutions to redundant problems (i.e. classification) because we would like to focus more on more difficult things in our line of work. This isn’t the sword to fall on, I really suggest stepping back and reflecting on your mindset.
I'm learning Python now, and I'm going to be testing lots of libraries. I wasn't expecting to be able to call a DoAllTheHardWork() function, though.
Come work with me. You'll change your mind quickly.
Even so.. what does "it's easy" even have to do with producing good results? It doesn't matter whether it's easy or not. If you have a goal in mind it's much better to have it done more easily. Besides, you can create your models from scratch. Especially as a scientist, working with C is just nonsense.
As the Python doc mentions, adding methods later to the proxy object doesn't work. The dunder methods must be defined on the Proxy class itself. If I were to delay it till I receive the object that needs to be proxied, I will have to create a new class every time I need to wrap an object. There must be a better way.
Hello! I'm a bot! I see someone has already suggested going to r/learnpython, a sub geared towards questions and learning more about python. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Yes, it's doable. I think that's exactly what the library was designed for.
Your first option is the case I'm dealing with. I need to be able to proxy a multitude of objects, belonging to different classes (although all those classes are derived from a Base class)
Carpentry, yes. You're assembling. Cooking, yes. Growing vegetables is gardening or even farming. Programming, yes. All I'm saying here is that Python is ridiculously easy. If I can import your library and call your function, and that's all I do, and it does something awesome, that YOU are the one did all the real work.
Let me know what you think!
Perfect. I tried pip3 install midi (and pip install midi), but there was no such thing available. I saw it was released in 2013, maybe it's not available anymore?
I tried making a joke to a hostile crowd. Try this instead: I have a 6-line gender classifier; who is going to tell me that MY code is awesome? Nobody. Who's going to argue that scikit-learn is awesome? Everybody.
So, "programming" to you is getting told your code is awesome?
https://nim-lang.org/
Odd, it shows up for me: $ pip install midi Requirement already satisfied: midi in c:\devtools\python37\lib\site-packages\midi-0.2.3-py3.7.egg (0.2.3) $ pip -V pip 19.0.3 from c:\devtools\python37\lib\site-packages\pip (python 3.7)
&gt; Sounds like a classic case of X-Y-problem. What are you trying to achieve? Good point. I'm trying to create another version of my ODB (Object Database). Basically, I need certain objects to be persisted, and loaded from disk only when they're needed. They're cached in memory, and are removed/updated from cache only when either the cache is full or when the object changes. The way I accomplish it is by using a proxy. When an attribute/method is looped up on an object (which doesn't exist in memory), the proxy intercepts the loopkup, loads the object from disk / cache, and passes the call forward to the object. -- -- &gt; I don't think trying to maintain a comprehensive list of dunder methods is a good idea. Consider that this list is bound to change with upcoming versions of Python and has already undergone considerable changes in the past. You may end up maintaining varying lists of magic methods for different versions of Python. This is for a personal project, so that's not an issue. &gt; I think the goto approach here would be to just try to call the respective method from within a generic `__getattribute__` and react appropriately to TypeError. That doesn't work, since if I call `len(x)`, and object `x` is behind a proxy, the `__len__` is looped up on the proxy object itself, and not sent to the proxy's `__getattribute__`. Which is why I need to implement `__len__` on the proxy itself and have it forward the call appropriately. &gt; It may also be possible to analyse the proxied object's class dict (someobject.__class__.__dict__) to find out which dunder methods were defined on that class. Of course you may end up having to walk up the inheritance chain as well, so this is bound to get quite complicated. The issue is that I need to proxy objects of more than one class, and the proxy needs to do some additional work (caching/loading) before passing the call forward.
My point is that no one is going to look at my code and compliment it in any way, shape, or form. Yet, the training data could be easily changed to predict something potentially extraordinary. You and I will agree that scikit-learn is the hero.
What do you do?
Just a guess, is your pipenv file in a Dropbox or other such cloud sync directory? I've heard of Dropbox locking files during compilation of unity 3D files making the compilation fail.
One thing I hated about openpyxl is that I found some code to help me out but then I run it to get a traceback error with no depreciation notes and Google search shows other people with the same error but not on the same line of code that I had. So do I install the old version of everything?
Students learn to do accounting on paper ledgers before learning to do accounting with software so that they understand what the software is doing.
It's not, but thanks for the thought! I'll look and see if there's anything else that might be causing a similar issue and try to eliminate it. This appears to be isolated to only pytest and pytest-mock as my Pipfile has other packages in it and works if I comment those two out. &amp;#x200B; I've also tried just putting a throwaway directory in /tmp and running `pipenv install pytest` there, which also appears to just run forever.
I don't need to hear/read that my code is awesome, but "programming" should involve a little more than exclusively calling someone else's functions.
That's ... not what you just said.
I work in robotics. What you say is because you haven't seen enough shit.
&gt; is Twisted, at least in some ways, being obsoleted by a built-in solution? Twisted's claim to fame is heavy parallelism / async. The language and the stdlib have added a lot of features to support parallelism out of the box. As she says, the project now has to justify its existence more than it used to. So yeah.
&gt; why wouldn't a language summit, which presumably would have core devs and the steering committee present, be recorded? For the same reasons Davos' forum of world leaders is not: so that people are not afraid to speak their mind in a frank way.
Then your best bet is just exploring each of the Hidden objects to see what magic methods actually need to be implemented. You don't need to implement the entire list in the original post, which is certainly missing some anyway, because not every Python object does. Also note that's not a complete list as I can name at least that `__missing__` is not there, likely because that is a particularly special case.
The lock-file is arch-specific. So you've just lost platform compatibility. Big no-no for most libraries and a ton of apps.
Thanks for the suggestion!
No, I made the tools, made the wooden planks and grew the vegetables. You took those things and assembled your program. Think of it more from a systems and algorithm design perspective. You have a vast library of tools at your disposal. The fact that they are easy to use helps you the engineer make useful stuff out of them.
I managed to install it! Where do I find documentation for it? For instance what's the basics of importing data and exporting data?
&gt; Socket programming is just needlessly painful in python Have you looked at asyncio?
We seriously needed this thing. Thanks a lot for developing this. I will try to work on it too. Good luck for the project!
Thanks everyone for your comments. I learned a lot from your suggestions. I have updated the code after going through the suggestions here and on r/learnpython
XP and 2003 occuply a particular role in the world's infrastructure because of historical happenstance, which justifies special treatment. Note how this has not happened for Windows 95, 98, 2000, Vista, 8... and this from a company that is very much the poster child for backward-compatibility at all costs. Sure, some companies will keep running py2 - there is still COBOL around, after all. That does not mean most people care about supporting COBOL.
That's fine, but library developers don't care about supporting py 1.5 users. In the same way, they shouldn't care about supporting 2.x going forward. If it works, good, let it run, nobody will stop you. But if you want new stuff and fixes, tough.
No, it most definitely isn't. One is a list, one is a string. This is Python, not C. You can turn a list into a string using `''.join`, but you can't do the same things to them, including reversing them. https://docs.python.org/3/library/stdtypes.html
TIL google has this thing... is it basically route 53 without costing $0.5?
Check the link in the above post, it has a short introduction. It's not the greatest but should be enough to get you going. But basically you open a file with `midi.read_midifile("test.mid")`, it returns a `Pattern` object which has a `tracks` array with `Track` objects. Track contains a list of midi events, which you can modify, add to etc. Then you write out with `midi.write_midifile("test2.mid")` Hope this helps!
What are you trying to state with that sentence? That you should be able to light a fire with stones before being allowed to use a lighter? I just said: you can do everything from scratch with Python. Of course it's important to understand what's behind your model. That's why you can e.g. create neural nets from scratch with Numpy. You can even classify male/female this way if you're smart enough. It all depends on what you want.. but it has nothing to do with "Python being an easy language". You are criticizing the programming language itself for being easy to use, basically for nothing. That's like saying "in order to calculate 5+5=10, you should be able to calculate 1+1+1+1+1+1+1+1+1+1=10". Some steps are unnecessary and already established in the programming language.
What about `but for` ? ``` but for grace_of_god: self.go() ```
For sure it helps! Thanks a ton my friend, this is just what I needed!
I disagree. Switch/break is a recipe for bugs.
How is it more prone to bugs than chained `elif`s or the janky dict method?
Hopefully building a mobile game. I'm a traitor, will do in Java/Kotlin. Also if time permits I'll work on prompt-toolkit based tool I was working for a while.
Glad to hear! Just be aware of the timing as this library only likes to work with relative times (e.g. midi ticks since last event) instead of absolute times (ticks since song start).
Oh honey...
My first library in Python
You can also take a look at: https://marketplace.visualstudio.com/items?itemName=fabioz.vscode-pydev -- that should work as it does in Eclipse/PyDev, which you linked ;)
No one is going to state that my code is awesome because I didn't do anything. The creator(s) of scikit-learn did everything.
And you use Python?
Elifs and dicts are explicitly marking branches as exclusive. Whereas a switch can easily end up with multiple branches unwittingly applied.
That is true, but also, does this actually matter? Like, what exactly is the end goal here? Are you trying to show off your awesome code, or are you trying to solve a problem?
So, scikit-learn makes this classification task look easy because I don't yet know the seriously bad-ass other stuff I could potentially do with it?
What a progress! Certainly the driver has not been Django framework, although quite a powerful framework it is. The reasons are pandas, matplotlib and numpy. https://stackoverflow.blog/2017/09/14/python-growing-quickly/ And more recently, Pytorch and Tensorflow are boosting Python, I think.
I took a stab at golfing this - https://gist.github.com/brandondube/40d9a621a610c13a352ea75ab3ee4f04 It looks like the dunders are 'protected' from setattr, so you can't do this at runtime and would need to write a proxy classdef for each thing you want to proxy.
Then dont create a list of all numbers first, use a generator to always give you the next number. that is way more efficient.
Look into Flask or Django. Also, /r/learnpython
I kind of hit a Creative dead end and am looking for a new Project
`setattr` will set it for the instance. You need to set the dunder methods for the class (as you just discovered). I updated my post with the horrible code for doing just that. :)
I'm criticizing it for being so easy that I can imagine "programmers" having no fundamental understanding of what their code is doing. It just works. My 6-line code took height, weight, and shoe size and predicted gender. How the heck did it do that?!?!? Well, I have a fairly good idea how it did it, but I'm confident I could teach a non-programmer how to use this. And, if a non-programmer can do it, is it really programming?
Yeah damn I figured. You said you had help functions for this? Just found out it might be hella difficult to change the duration and pitch of single events in the pattern, since it effects all the other events also because of the relative tick thing.
I tried to solve a problem and couldn't believe how easy the solution was.
Solid article, I'm definitely guilty of just copying over config files for use with docker using gunicorn.
no, I use a mixture of garbage that can accidentally be interpreted by a python interpreter.
That does not answer my question at all. Also, isn't that, generally, a good thing?
I suggest you finding a friend that has a small business and help him automate/create some stuff, a buddy of mine has a car washing place, my first "used" work of code was a CRUD app for him that tracks the amount of times a client washes their cars and holds a counter for a free wash.
No, I think the dunders are protected. dir(p) does not contain a __len__ but vars(p) does. Both of those methods reflect the instance, not the classdef, if I understand the builtins docs properly.
Yeah, it can be a pain for sure. What I did was to create a simple Note class for midi notes that uses absolute time and note length instead of relative note-off ticks: class Note: def __init__(self, tick, length, pitch, velocity): self.tick = tick self.length = length self.pitch = pitch self.velocity = velocity def __repr__(self): return "Note(tick: {}, len: {}, note: {}, vel: {})".format(self.tick, self.length, self.pitch, self.velocity) ...and then when I have an array of these convert them to midi.NoteOnEvents etc. def tickarray_to_relative_midi(arr): lastnote = Note(0, 0, 0, 0) track = midi.Track() for note in arr: starttick = note.tick - (lastnote.tick + lastnote.length) if starttick &lt; 0: starttick = 0 on = midi.NoteOnEvent(tick=starttick, velocity=note.velocity, pitch=note.pitch) off = midi.NoteOffEvent(tick=note.length, pitch=note.pitch) track.append(on) track.append(off) lastnote = note track.append(midi.EndOfTrackEvent(tick=1)) return track It's not particularly pretty, but Works for Me^TM :) Since I don't need to load midi files, just generate them I don't have a function to create a note array from a file, but it should be fairly straightforward to create a reverse to this function.
I'm not sure what you are doing but you can setattr on a a class with a class method. Not only the instance.
Snide remarks aside, that's good to know. I promised someone we'd build some kind of kit robot. No, it won't be anything near your level, but it would be fun to get something programmable.
No, I work in can kill people kind of robots.
I work full time as a software engineer and do typically make utility scripts/programs for stuff that can be easily automated around the office, these questions were more aimed at the open source scene
Solving problems is my answer. Easy can certainly be a good thing; but my point is still the definition of a programmer. I'm arguing that what I did shouldn't count.
I think you aren't understanding what I'm trying to say. Your 6-line code is based on a library (scikit-learn) that already contains the basic code you need. So in that case, as you said, you didn't program it by yourself. But if you wanted to, you could have created the model from scratch, all by yourself, with no help of other libraries. So it all depends on what YOU are willing to do. It's like you were saying "writing with a pen is too easy" when you are just copying what someone else did, or as you put it, simply copying the result. But you could have created it all on your own (many pages of length). This has nothing to do with the pen or the paper, or in this case, with Python.
Pocketsphinx on a Raspberry Pi. Stock language model, super small custom truncated dictionary. I did add a few "new" "words" to the dictionary-- like my daughter's name, Julianna by combining the phonetic chunks of Julie and Anna and similarly for meatbags (--Bender, Futurama). Constantly running queue processor. Constantly running listener either 1) adds to the queue or 2) kills the current task as well as clears the queue. Then child scripts to be called by the queue processor if there isn't a pre-existing program or command. So far I've hooked up an H-bridge (some call it an H-gate) to power two DC motors to four GPIOs-- tank treads fwd/fwd, fwd/rev, rev/rev, &amp; rev/fwd for forward, reverse, &amp; spinning either direction. The H-gate takes the low signal voltage/amps on two pairs of pins and lets the separately provided supply electricity flow the proper direction across the motor. Wiringpi handles turning the gpios on &amp; off. That and a led light on to show it is listening (then off for processing voice data, not listening).
That's a very good idea! I made the Note class, and now I'll try to mess around to get a converter going! Thanks again!
I hope we're on the same side, then.... judging by your English, we are.
bruh you can take this concept and apply it to anything. You could criticise C programmers for not being real programmers because all the assembly/cpu instructions are done for you. You could cristice assembly programmers for not being real programmers because all the physical computer engineering problems are done for you. Programming is just writing 'code' to solve a problem. That's it. A programmer is someone who writes code to solve problems. If someone is writing code that uses sci kit learn all day to solve real life problems, then they are by definition a programmer. There are many layers of abstractions to programming. You don't have to fully understand every layer in order to solve problems, that's the magic of programming.
&gt; Expecting lambda functions You should listen to [this talk](https://youtu.be/pkCLMl0e_0k) at PyCon. It's mostly lambda functions, and it shows how you can do Boolean logic, numbers, control flow and recursion with _only functions of one argument that return other functions_.
Actually, if you're OK with terrible hacks... generate a string that is the proxy class definition and eval it. Make a function like make_proxy that returns a handle to this synthesized classdef. Then use the ProxyFoo class that was created...
That's what I did in C first. I wanted to understand it inside out. Took a few hours. Then I did it in Python and it took a few minutes.
I would argue that he is actually wrong, since using an already existing library is still programming. What he's looking for is the science behind it all.
Which depends on individual ability
If there's some discussion you can link me to, I would be interested in reading it.
Good points. You've actually made me want to learn machine language....
I've used Pillow a little bit, and learned more about it from this talk than most other sources.
So what is the "definition of a programmer" in your understand then?
Check out [https://github.com/cdr/sshcode](https://github.com/cdr/sshcode), I've been using this to develop on remote servers
https://blog.wolfram.com/2019/05/21/launching-today-free-wolfram-engine-for-developers/
MS Paint in that one, although if I do more animation work, I use [my own tool](https://cmlsc.itch.io/px-editor).
 [https://blog.wolfram.com/2019/05/21/launching-today-free-wolfram-engine-for-developers/](https://blog.wolfram.com/2019/05/21/launching-today-free-wolfram-engine-for-developers/)
Yes, because C is ineffective with regard to these tasks. Anyways, do what you find most helpful.
Yes, at the moment I'm using that and it's better than raw socket programming (which is what I was doing before). Though in itself that is an example of something that doesn't gel with the rest of the stdlib -- you can't write \`async def\` unittest methods, for example
If urllib belongs in stdlib, TCP programming definitely does
Thank you for posting this! I'm working on moving my company's stack to k8s and this is quite salient.
I don't think it makes it look easy, I think it straight up solves one of the tasks you need to. I don't really do ML stuff (I hardly even use Python truth be told, I just hang out here because it fascinates me) so I don't know what sort of applications the classification task would have, but surely there is other stuff in there that also requires work. Maybe you need to prep your data, or use the predictions to branch into different behaviours. I don't know if there is some hidden set of bad-ass applications out there but to me "making classifier predictions" sound like a single box in an algorithm flowchart. Ultimately, I think there's a lot more to software engineering than writing code. In fact, I think writing code is the least interesting part of the job.
Just implemented a small python script used to evaluate financial turbulence after reading a nice paper on it. It’s pretty simple matrix calculations and some basic stats but it was nice practice to get used to pandas and numpy after not having used them for a while. Hopefully my coworker will find it useful :D
1990s: You aren't programming unless what you wrote has to be compiled before running it. 2000s: You aren't programming unless you're using a turing-complete language. 2010s: You aren't programming unless what you're doing is hard. 2020s: ???
Here is something [https://github.com/pypa/pypi-legacy/issues/700](https://github.com/pypa/pypi-legacy/issues/700) Seems you should be able to wipe the old documentation now (but for many packages this may be a bad idea because the pythonhosted search results are still very high ranked)
I figured this out and apparently it was just me. I'll leave this here in case anyone else runs into this issue in the future: &amp;#x200B; I went in and manually deleted my pip and pipenv caches entirely (\~/Library/Caches/pip and \~/Library/Caches/pipenv) and it worked immediately afterward.
/r/MurderedByWords
I think asm or makinig transistors by himself maybe good.
Ok, seeing your username, I guess you're much older than me, so I'm not so intimidated by all that.
Thanks, I just looked into Flask and it seems nice, but I already have a .net website up and running so I don't think I need a web framework. I will scour learnpython. Thanks!
Win32 service (client) sends data to win32 service (server) which then sends data to Django backend. Asyncio 😁😁😁
I was thinking to extract the silicon the out of the ore, then purify it himself maybe more good
I will do you one better. Why let nature make silicon. Use atomic particles to make silicon by yourself. /s &amp;#x200B; p.s: This is getting out of hand literally
You want to send the print output to a file and not the console? I believe you can change \`sys.stdout\` to a file but I'm not in front of a computer and it's been a while since I messed with it.
...You're not programming if you are a human?
"Doing something amazing with no idea how it worked" is the essence of what hooked me on programming years ago.
Yeah, it is easy to make a weather prediction bot. Just predict it will be the same today as yesterday, and you're mostly correct.
The first part was a little tough-- it isn't a trivial project to implement. DeepSpeech was harder. And I suppose doing it with less and lower power resources is where being able to tune things and try different physical parts is good for an old fart like me. The rest is well within your reach if you sat and thought about each piece for a few minutes. Two weeks ago, we maybe were the same on one thing. I recently learned about /dev/shm to improve the performance of reading my language model &amp; dict file. On boot, I copy my files to that directory and I reference them as living there in my code. [https://www.cyberciti.biz/tips/what-is-devshm-and-its-practical-usage.html](https://www.cyberciti.biz/tips/what-is-devshm-and-its-practical-usage.html) And today, you might be caught up and we are the same again. Such is life.
It's not to say the market is perfectly efficient (it most certainly is not), it's that the typical retail investor is not in a position to take advantage of market inefficiencies.
As you know, the async stuff is all pretty recent. Python has a history of nicking constructs left and right from other languages, which might look jarring for a while. Maybe get in touch with the unittest maintainers and see what they think?
Must a poet invent his own words before he can be called a poet? Being a programmer is the same. You are a programmer because you know what functions to call and what functions will work in your program.
Yeah, I'm just a new graduate going to start his first job. The only real project I've done so far is for the course and it involved just training a neural network. Plus, I'm not so familiar with Linux. So I was kinda intimidated thinking most people would understand what you wrote on first reading.
What's your take on built in sort functions? Is using the default sort also not programming?
What is this BS about “limited seat”
The reason I use numpy is that I don't know Panda works well with headers of multiple rows and the merged columns.
Accidentally or on purpose?
 def is_it_true(bool var): time_lookup = [ (datetime.datetime.now() + datetime.timedelta(seconds=0), 'No'), (datetime.datetime.now() + datetime.timedelta(seconds=1), 'No'), (datetime.datetime.now() + datetime.timedelta(seconds=2), 'No'), (datetime.datetime.now() + datetime.timedelta(seconds=3), 'No'), (datetime.datetime.now() + datetime.timedelta(seconds=4), 'No'), (datetime.datetime.now() + datetime.timedelta(seconds=5), 'Yes'), (datetime.datetime.now() + datetime.timedelta(seconds=6), 'No'), ] time.sleep(len(str(bool_var))) return time_lookup[bisect.bisect(map(itemgetter(0), time_lookup), datetime.datetime.now())][1]
The entire standard library is someone else's functions. The linker, compiler, and ide are all someone else's functions. Unless you built the computer from the dirt in your backyard, it's on the backs of others.
Brutal that there were no comments. Jinja templating feels a million miles away from WordPress (in a good way), and static-gen is really nice for simplicity and speed to serve. Have you played with keeping dynamic features by pivoting to random choice of assets or asset sub-paths? Why not something in PHP, or something like Jekyll itself?
hmm... I should add some lambdas in it
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I personally would probably handle the Teacher / User thing as groups and just have a single user type, but, there's probably some more info that isn't here that may change my mind.
Every language has a DoAllTheHardWord() function in some sort of library.
How dare you wash your clothes in a washing. You go down to the river and beat them on the rocks, as nature intended.
What interests you?
Good stuff.
I put together a quick (and dirty) tutorial on coding the Monty Hall problem. Then I automated the game play to prove that it does make sense to switch doors. [https://youtu.be/fUComz4krQE](https://youtu.be/fUComz4krQE)
Roger, got it. Can't say I disagree.
Correct answer is here.
Predicting Unreported Obesity in a Medicare population and writing a presentation about Skip Gram Models.
I'm sure stuff like that exists, but you really should get a better understanding of python before taking on a hard project like that.
Try r/learnpython
Interesting article. I do think that evens the last category is worth knowing. Maybe not mastering, but worth understanding. Also, I think they missed one of the good uses for `getattr` which is that you can set a default l!
Glad it was helpful! There's a bunch more articles on my site you may find relevant, e.g. on two-stage builds to get smaller images. I'm also working on a template for Dockerizing Python apps that includes all that and more, if you're interested.
Not sure if it's been done before, but it probably has. This should be fairly simplistic to create, depending on how you want to do it. Each social media platform should have their own API. Using their API you may be able to get a live feed of all posts, or be able to access a historical record of posts over a certain time frame. From here you should be able to filter posts by keyword, and either print them out directly, or dump them to a file.
Just joined. Thanks, mate. I agree I should learn more. I’m just so eager, I know it’s not something I could build, or even maybe understand, right now. I was just thinking if someone has an idea of what core functions could be used it could help narrow the scope of my learning. Or I’d get lucky and it already exists lol Thanks again!!
Violently coding on your mechanical keyboard in the basement for 8 hours a day for a whole month without a pause, sipping Mountain Dew and eating Doritos. Absolutely no documentation reading, integrating, meetings, testing, or any of that pussy shit whatsoever obviously
Thanks for sharing! You can also write a StarCraft 2 Bot using other languages like c++, c#, go, java, javascripts, or haskell. All of these bots are usually "scripted" AIs. If you want to make one using machine learning, you can use the library made by deepmind https://github.com/deepmind/pysc2 Feel free to join the SC2 AI discord: https://discordapp.com/invite/zXHU4wM
As a great man once said, let me blow your fucking mind. The "machine language" your CPU understands, those instructions you write in assembly, is - wait for it - an abstraction. The real silicon doesn't actually implement all the thousands of instructions in the Intel Programmer's Manual - it pretty much JITs them into other, simpler operations called micro-ops or uops, and then executes those.
Just when I needed this.
Congrats! It is a brave and still new world.
I find it hard to believe something similar hasn’t been created before. Thanks for the comment, I’ll look into the API for this. Thanks!
And your evidence to claim that the API is not readable or simple?
Poor Man's Tableau/BI software. Connect to a Mysql server, and then provide a GUI where none SQL people can query the database and build reports all by pointing and clicking columns.
Reposting top comment from the [hackernews story](https://news.ycombinator.com/item?id=19970333) I'm agreeing with this commenter as I think it is difficult to build on top of a closed-source program. &gt; &gt; Why Aren’t You Using Our Technology? &gt; It’s not open source. &gt; Even if the engine is “free”, I don’t want to build an open source product with it and hope to be granted a “free production license.” If I build something on my own time I don’t want to ask my employer to purchase a “production license” as soon as it becomes useful. &gt; Wolfram believes that mathematics software (or “computational knowledge” or whatever he calls his entire enterprise now) must be proprietary and paid-for in order to exist. Maybe it’s true; all of the successful and wildly popular computer algebra systems are closed source. (wxMaxima is rough to use, Axiom has 3 or 4 different forks, each with fewer than 10 developers, SymPy just isn’t there, Sage is absolutely wonderful but not polished or easy to deploy, ...) But that’s completely at odds with how most software engineers work these days. Most software is grounded in an open source development and deployment tool chain. There is a market for proprietary developer tools, but it had been dwindling since its prime-time in the 90s. &gt; I think Wolfram needs to think quite hard about how he wants to get his technology in the hands of developers while maintaining a business. Not that my opinion matters, but if he can manage to do it by open sourcing Wolfram Language, Wolfram Engine, or something like that, while keeping his business intact, I might again consider him to be the genius he was lauded to be in his 20s.
Nice. But "Free" as in, "For your email address". I never will understand why everyone thinks they have to have it...
Learn BeautifulSoup, requests and how to interact with social media API. And ofc if you don't have any coding skills learn how to code first.
I’m going to go out on a limb and say the person who put this list together is a web dev.
Lol. BeautifulSoup. Got it. Thank you!!
I was kind of trying to do this as an exercise in doing a basic task in python, are you recommending that I give up on using python for this and use something better suited to the task?
When it comes to my Extra Life charity donation tracker : * Creating a pyinstaller docker image that will actually work with Jenkins * Working on the GUI code * figuring out how to scale an image in QT with pixmap. (By default it has scrollbars) * finally adding the threaded code and seeing if it works &amp;#x200B; MAYBE starting work on a game engine. Probably not this week, but maybe.
Hi, &amp;#x200B; Maybe you could create a x radius scan around your player, and if there is no food, it gives you a warning or something?
I can share a thought since nothing i made is ever used by anyone except me. You either have to make someones life easier or introduce something new no one knew theyd like to use.
The only people who feel this way are those that have never actually had to build a real system to meet a deadline. If I’m working on a personal project of course I’ll try to implement as much as I can since it’s for my own personal development. But when there is a customer request or product feature which has a deadline to complete then I have to throw my personal ego out the door in the interest of developing a robust, testable, and extendable system and that generally involves using a library.
There are entire business built around this thing! For example [https://www.crowdtangle.com/](https://www.crowdtangle.com/)
I wish people posting to reddit didn't use blog spam headlines.
...the first day you picked up python.
Facebook closed their APIs so Instagram and Facebook require web scraping now.
What's worked for me is to not make another program that there are already a million of. No Tetris clones, word processors, browsers, etc. I make code that fulfills a need for me. I started making [https://github.com/djotaku/ELDonationTracker](https://github.com/djotaku/ELDonationTracker) because I'd been using someone else's code to do this and they stopped supporting it. Also, it wasn't cross-platform and I wanted something that I could use on Windows and Linux. I know I have users because people have asked me for bug fixes on the Extra Life forums and on youtube (where I had a video on how to use the program) I also made [https://github.com/djotaku/Snap-in-Time](https://github.com/djotaku/Snap-in-Time) to solve a problem I needed solved for my own use of btrfs. Both of those have given me lots of fulfillment because they solved problems I had that others weren't solving. Other code I don't have on github because I started working on it before I knew about source control and not having secret keys in your code include a program that tweets my top 3 artists scrobbled to [last.fm](https://last.fm) each Sunday night and some code I used for a few years on flickr back when I was really active on there. So the key is to find a niche that isn't already being filled by others' code. It takes a LONG time. I've been programming since the 80s and I only made useful programs in the past 10 years. For a long time I was like you - demotivated because everyone had already solved all the useful problems. But I kept learning how to code until I was able to solve my own problems with code. And now, at least in the case of the donation tracker, I've been able to help others, too.
Use Flask create an API and return the result as JSON
Writing a white paper on applications of machine learning to Finance.
Take a look at this [devops roadmap](https://roadmap.sh/devops) from roadmap.sh. It covers a lot of knowledge a decent devops should know. You can pretty much pinpoint where you are right now. From that you know what to do.
Thanks for your insight!
I'm saving about $105 - $110 USD from the $120 USD I used to pay by switching to Google Cloud DNS for my personal applications.
Solid article for anyone who has been learning python for a few weeks to a couple months.
I've thought of that, however would require first knowing the x and y positions of every food object in the gamespace. Which defeates the purpose of the code because I would still have to call every food object and check. Or am I wrong?
thanks, that was it! I just used 'sys.stdout = open('TextTester.html','w')'
Well, I coded a cellular automaton. Aside from chaning the Rules I don't know what else I could do.
If you like simulations like that, maybe try to make it graphical (if it isn't already)? Or try a more complex simulation such as this [https://softologyblog.wordpress.com/2019/05/05/primordial-particle-systems/](https://softologyblog.wordpress.com/2019/05/05/primordial-particle-systems/) ?
But can it run selenium with a chrome driver? Browser within a browser etc etc
Well, As far as graphics go I stored the values of my Computation in numpy arrays and cobverted them Into Images, is there any other way of doing it?
I am trying to optimize my pseudo 3d ray caster a bit more. The actual ray casting and intersection calculations in particular. I know that for speed I should not choose Python but it's actually not bad at all, and when using pypy it really zooms
No that is what I meant. I was thinking maybe you were just printing things to the console :)
&gt; These frameworks can be used in a variety of areas Websites *and* web apps.
Seriously cool, just finishing up a project where this would've been handy
Kotlin rocks!
This is a hard problem. If you can't find any libraries available then you might struggle.
What's going on?
Nice video. A tad bit too long perhaps. And what is a zonk? :)
Basic data structures and algorithms are essential, you will need to learn them sooner or later. They are not that hard though, maybe you got the wrong impression because you lack prerequisite knowledge? Maybe try learning them in C. Java abstracts away the pointers and it might not be immediately clear how everything works.
Thanks for your in depth reply! Do you only start a project if you've identified something people need? Did the projects you mention here start with the intention of just being for personal use and then grew? Or did you make them to fill that gap that you'd identified?
Stop being a pussy and show them this then.
How is it a spam headline? It's a statement of fact that a significant amount of programmers I work with revel in shitting complexity into systems. It's a fact that I wish they'd stop. There's no way I know of to change the title after posting, so what was it you wanted to achieve, other than being a dick using flowery, imprecise attacks?
Thanks for watching and good feedback :) A 'zonk' is a word that "Let's Make a Deal" created. Essentially it's a worthless prize
How else are they going to send you marketing emails?
lying... Could we take that down a notch, and say. "There (may be|are) details, you've omitted). Had you considered {x}?"
Hey, if I sign up to receive emails with python tips/articles like these, will I end up getting spammy enrollment/book sale ads like realpython sends? I'm looking at you, Dan Bader. Your tips aren't worth the spam.
You can't just reach for threads as a knee-jerk though. Last week one of the programmers I work with got super annoyed when I mentioned this in relation to their admission that they just spawn many processes to shorten critical path. You may have hardware constraints, you may be able to access a batch endpoint, knowing something is queued to be processed later, rather than immediately sped up may be acceptable.
Another question, do you suggest using pipenv when working with projects that get copied into docker environments?
Do you code for compliments or for doing something useful?
ive never really embraced pandas because i feel like numpy is a good enough abstraction that offers total control, which seems to be nice for the things i do. but im curious to hear from people who feel like they have mastered both... is pandas all that useful if you have a handle on numpy? im curious if pandas is really only appealing to people who are reluctant to learn numpy
Are the food objects in known positions every time -- or even better, do they form a pattern on the grid of some sort?
Your title gives me zero information about the video you're posting. It's just a clickbaity title. I don't know what I'm going into.
Thank you. I have looked at C a bit, but it seems quite daunting due to the syntax...but since it's not OOP it may *actually* be more simple...?
How many objects are we talking? Anything under 1k and I doubt the brute force method you described would cause any performance issues.
Thanks! What's your GitHub username? I can give you commit access if you like?
Haha :)
Always next time :)
This is fantastic - thank you! I'd estimate I'm somewhere in between step 5 &amp; 6, although I've only been studying programming for about 2 years. However, the majority of what I do for my job revolves around step 8: Infra/App Monitoring &amp; Logging.
X radius scan is working similar to grid with expanding search, you are only replacing pixels with grid. I think if number of food objects is relatively small, they’re static and you need precision, you can calculate distance to every object. If not - use grid, you assign every object and player to grid cell and calc distances between player’s cell and every cell with food. Number of calcs will change from N (food objects) to M (grid cells)
Only if you've programmed before. Too much on a boilerplate is discouraging. Python is seen as simple and elegant. So no, I disagree that you should learn all the built-ins right when you start. It's like learning every axioms of math before starting. It's horrendous.
curious myself
Back in 1995 a fellow student and I made a poker game, on paper. Access to computer lab was limited as was time for the project. So we would write code on paper and type it in when lab was accessible. It was Visual Basic project. And surprisingly it worked very well. 😊
A lot of data editing just slightly too complicated to script, but I'm in the preliminary steps of figuring out how to ping GPS units on my employer's vehicles (I work for a roads department), figure out when a street sweeper is operating, and track their work. The GPS vendor promised it would work with our GIS systems, the reality was... not so much. Making it talk to our GIS systems will be an Interesting Challenge that will occupy me for many weeks.
No, these food object are randomly placed in the environment. They will not move, however they may disappear due to anothe player "eating" them, at which point a new food pellet will appear at a random location on screen.
If you want your asyncio code to work better, I suggest you use queues, setup X number of workers, and have a producer. The producer fills the queue, and the workers pull off the queue. It should fix your issue. If threading is fast enough then use it. It's memory/CPU intensive compared to Asyncio, but easier. If you need better performance, or have a memory limit, Asyncio is vastly superior. Asyncio is more complex, and probably requires tweaking to get good performance, but the performance is amazing.
Exactly my thoughts as well
Try Waitress, it’s much simpler to understand and configure.
Yeah, no dependencies, other than this other programming language and its entire standard library, but hey we dont depend on urllib3
What app did you use too to make i
I have four favorite pandas functions, [eval](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.eval.html), [to_hdf](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_hdf.html), and [read_hdf](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_hdf.html), and [join](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.join.html)
There are lot of APIs but they are from companies and most of them online...
I think it's an interesting constraint. Would likely make you more conscious of syntax and the logic of your code.
There will be many food pellets, with many "Agents" searching for food nearest them. As a result the "closest pellet" will change due to another Agent earing it before I can get to it. The number will be as high as my PC can reasonably stand without a drop in performance. Hopefully many hundred (minimum)
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
 nope. We’ve tried. You can maintain one locally but we create a requirements.txt to pass to CI/CD when it builds the containers.
Imagine this as being Gold. Thanks.
Maybe Im confused on the use case here. Its awesome that you're able to do python client side but in this case you're munging data. Why not execute server side instead?
Oh yes. It certainly did. We would use hours to debug it. - write on paper - type it in the computer - compile... no go... - print the code and eventual revisions - back to paper coding Loop. 😊
The easiest thing is to fill a need you have. If you have that need, someone else does, too. We're not snowflakes - everyone who lives in the modern world has similar 1st World Problems. So if something's bothering you or there's a need, make a program. Then put it on Github. Talk about it whereever you can without getting kicked out for shilling your stuff. And someone else will use it. Or, don't care about others. If it fills a need YOU need, then it's useful and worth doing.
I defer to Hynek's research, which basically tl;drs to "use pip-tools": [https://hynek.me/articles/python-app-deps-2018/](https://hynek.me/articles/python-app-deps-2018/)
Hm. You may be stuck having to compare them all, then. But since you're looking for the smallest value, at least you can compare the distance *squared* on the grid, which will save you some significant time (calculating a square root is pretty time-intensive as calculations go).
Data can't be sent to the server. Both too large, and it's patient data, not legally allowed to leave the hospital network.
You will get an email every time I post an article, and occasionally when I launch a product you will get a bunch more emails as part of product launch. So perhaps you don't want to sign up if you're sensitive about marketing. &amp;#x200B; Instead I suggest you use the RSS/Atom feed link at the bottom of the page.
Glad to hear it! Give us a shout if you have any trouble!
Running the code clientside is a neat way to offload the processing. Also, a potential benefit is that this setup allows the client to process private data in a controlled manner without needing to use additional enduser software, thereby mostly removing consideration for the client OS.
Aha
Okay that makes more sense. I'm curious how Web workers would work in this scenario however. OP mentioned the app freezes. This wouldn't be a problem if processing was done server side where async workers can be spun up. But in this case the Python is calling is being transpiled to JS no?
No argument there. I'm more saying that if Requests is too slow for your liking, there might be other solutions at hand.
/r/learnpython
I'll keep it in mind for future, but I'm also blocking you
A side benefit is that this can run on a static hosting server like Netlify. For open source projects this comes at no cost and hypothetically is indefinitely scalable.
I'm familiar with both and feel that pandas gives you the ability to easily manipulate labelled data that would be arduous using numpy alone. If you're doing mathematical operations on arrays of numbers then numpy is great. If you're dealing with tables of data, i.e. values indexed by labelled rows and columns, then pandas will give you more flexibility for querying, manipulating, and visualising. If you have multiple similar tables of data then pandas allows you to stick it all in the same data structure and access it through multi-level row and column labels.
Pandas does so many things numpy does not, i.e. a lot of merges, applys, groupby operations. Writing all of that from scratch in numpy would be a huge pain. If all you're doing is matrix math, then yes pandas is not meant for you but if you have meaningful column names, time series data, the need to do elaborate merges, read in data from a variety of sources, then pandas is useful.
Measured time to calculate euclidian distance (L2) using numpy Map size: 10.000x10.000 Agents: 500 Food objects: 100 FPS: 60 Total number of calculations: 60 (update every frame) \* 500 (n\_agents) = 30.000 \[x100 for food objects is dropped, because numpy allow calculate distance between single object (agent) and n\_objects (food)\] Result: \~0.6sec on 7yo laptop cpu, which I believe can be improved with proper python code to drop x500 (n\_agents)
No argument here either :thumbsup:
You are suggesting I just use C^2 to determine the closest food? That's actually makes a lot of sense. Thanks friend!
And building a house should involve more than just stacking someone else's bricks up with someone else's mortar. Programming is taking provided tools, and putting them together in a way that works.
I have a lot of old raw data that could use deeper analysis but it's in .dpt and I seem to be unable to open these files with it. I read it can load Bruker proprietary files (?), so I'll have to see how to save into the supported formats next week when I take some new measurements (using a Vertex 70 for ATR-FTIR).
Very impressive, I appreciate your suggestion. I will certainly have a few options to experiment on.
that makes sense. appreciate the comment
Which set of axioms would you even choose?!
Lol why 1+1 is 2.
What is 1? What is +?
You should've known this already it's a built-in function duh /s
I appreciate your enthusiasm for sarcasm, but to become a master you mustn't use /s. *I'm a human being, and this action was performed manually.*
I guess in terms of serving the actual content. However you are still severely limited by the actual client itself and the performance issues that come with everything being done on the browser. Whereas you could indefinitely scale up workers on the cloud to process data. I think for small operations this is a viable option not to mention it's wicked cool and as web assembly matures performance will only increase. However I still doubt it's viability of something other than an experiment in an enterprise setting. Not bashing at all btw this is a wicked project just giving my two cents
&gt; But "Free" as in, "For your email address". And a production license shakedown and wallet biopsy once the thing you build is useful.... mehhhhhhhh..... If your problem is fundamentally limited by symbolic manipulation of mathematics (i.e. the domain where wolfram really excels over the competition), then this may be compelling news [1]. For literally *everything else*, why waste your brain cells and free time on something fundamentally proprietary and closed-source. ----- [1] and even then, as someone who has programmed a ton of electrodynamics simulations, the few times in my career that I've used some symbolic tool to help (e.g. Mathematica) was just to derive some final mathematical result or approximation, which I could then type into my C/CUDA/C++/Fortran/Python/whatevs program.
OP is "that guy" everyone has had the misfortune of working with at least once in their career.
!(Good bot)
According to the following link dpt is just a text format? You should be able to read it in with something like numpys's loadtxt or genfromtxt. Try just pulling the dpt file into an editor and see if you can work out the format. Otherwise, just make an issue on the hyperspy github, and provide a sample file. Someone will probably reach out. https://www.researchgate.net/post/Does_anyone_know_how_to_open_run_DPT_files_NIR_spectroscopic_data_in_The_Unscrambler_software
All the proprietary formats have been reverse engineered manually - we have rather good support for bcf, which is bruker's EDS format, and a couple of our members have spent quite a bit of time figuring those out.
Codecademy.com has a free python2 course and a paid python3 course if I remember correctly. Theres also an app called sololearn that has multiple languages and lots of resources. I believe you can access sololearn from the web too.
&gt;According to the following link dpt is just a text format? Yes pretty much as far as I know. I usually simply convert them using notepad++ and plot them using Origin.
Really good article. I should send this to every new python dev in my team
You paid $120 for just DNS? What were you using?
I thought SymPy was open source?
If you're also learning to program for the first time: /r/learnprogramming This subreddit is more appropriate than /r/Python for beginners: /r/learnpython
Exactly this. As a student major in engineering I think doing simulation with symbolic computation is usually not necessary and even makes things complicated.
 INITIAL = object() def min(iterable, default=INITIAL): … what's the use of that over `def min(iterable, default=object())`
Check out openmaptiles! https://openmaptiles.com/satellite/
C has very few features, so you can learn it pretty quickly. For a basic data structures and algorithms course you will need to learn structs, pointers, malloc and free and that is basically it. Also make sure you understand how memory works (stack, heap). When you have a general idea how stuff looks in memory things like linked lists become stupid simple.
If you upload a file somewhere (github issue or similar), I'll write you a python function to turn it into a numpy array, and then into a hyperspy signal. That will have to be tomorrow morning though, its 10pm here and I'm off to bed :)
Ok I wasn't the first dude that commented tho. But do as you please.
I had multiple domains registered and was using a managed DNS service from dyn.com
That definitely fixes the issue described at the end (and is similar to the approach taken for threading.) The coding required to use asyncio is still a lot of overhead though.
Nice article! I always enjoy revisiting standard library functions I don't use and seeing if I perhaps should be using them instead of some alternate approach! Good to revisit the basics!
I still don't understand the func(arg*, arg**) thing
I strongly disagree. /r/learnpython is "for posting questions and asking for general advice about your python code," wich is not at all what this post does. How is this spam? It's a solid article that does not attempt to sell anything.
It is open source; that was a list of open source projects that the quote is saying aren't up to snuff.
You are right - it is. The focus of this post is the "Wolfram Engine for Developers", which is closed source.
I ended up watching it all and it was a pretty good talk. I would have a less click-bait style title and I would also take the time to write a paragraph about the video and a paragraph about why you think the people you work with need to watch it. The post almost comes off as a bot posting a video it scraped to try to get karma
I dual boot and run mint. This was something I just wanted to try
Putting finishing touches on a soon-to-be-released OpenAPI v3 integration for the Pyramid Web framework: https://github.com/pylons/pyramid_openapi3 It's been a while since I've released something. Feels good!
I dislike people posting uninformative headlines to serious subreddits. When I see it, I downvote and explain so hopefully fewer people do it going forward. Realistically I was just venting minor peeve, but if I wanted to acheive anything it was being a teachable moment for you (and others who see this) to avoid posting uninformative clickbait titles to random python talks.
All good. I really appreciate the feedback :).
The plan is to combine web workers and their access to IndexedDB combined with DexieJS. Have all the Python run inside a webworker, have all data transfer happen via dexiejs-observable. I envisage there would be no user interface impeedement using that stack... But we'll see. Hopefully I'll get that side of things working in the next couple of days. It'll probably be worth a repost then.
Have you looked at sacrificing accuracy for speed?
Certainly not transpiled at all. It is running standard CPython compiled using emscripten to webassembly.
Also the subreddit r/learnpython
I think it's a pretty useful post that talks about how to improve performing operations (in both a speed and memory efficient way) for commonly used tasks. I also don't think the article is attempting to sell anything at all - it's just showing/discussing enhancements in Pandas
You are very kind...thank you!!
You also missed the inevitable "We lost your email and password. But you know that by all the new spam. Hope they were unique. Good luck with that." that follows sooner or later. Unless they don't tell you.
I'm currently experimenting with a somewhat less accurate ray intersection routine, but while it is a bit faster the overall result isn't really. The real deal will be to optimize the ray cast loop which now uses a naive approach to extend the ray a tiny step each iteration.
It's literally a guy shilling his own teaching services...
Okay, and this sub is for: &gt; News about the dynamic, interpreted, interactive, object-oriented, extensible programming language Python This is not news. It's teaching the built-ins which is like, one of the first things you're supposed to *learn*. It's useful for people that are *learning* the language. I bring up spam because it's someone posting a link to their own site, which is very clearly selling training services if you bothered to look...
Question about this: I use uWSGI for my projects (instead of Gunicorn). Is there something similar I need to adjust so that uWSGI isn't hanging? I've got a container running on my local machine, for example, that responds quickly when it first starts up but after a while, it starts to slow down (like if I put the computer to sleep and wake it back up). Great write up by the way!
Thanks. I misunderstood that line.
So I completely agree with you, but from my personal experience, if you show regular users of Excel that they can now use this hybrid of a software that will be running half in Excel and half in a black box, they get sort of reluctant to accept it because it's not there.. in front of them, like they are used to. On the other hand, if you moved away also the front end to the custom GUI, then this expectation is gone because well.. for them it's a completely different software now. &amp;#x200B; But maybe these are just my current observations and the sample is too small to judge
This might help https://python-patterns.guide/gang-of-four/decorator-pattern/
A thing that wasn't mentioned in the plotting part is [cufflinks](https://plot.ly/ipython-notebooks/cufflinks/). This thing changed the way I visualize my data on a regular coding basis.
What about using a kd-tree structure for storing the food-objects?
&gt;"You shouldn't use abstractions you didn't build yourself!", Where did they say this? I read the article, and I didn't see this insinuated. &gt;OP yelled on Reddit, a website built by other people, through their browser built by other people, running on an OS built by other people, communicating over networks and protocols built by other people, running on CPUs built by other people. Irrelevant, and twisting the original sentiment. &gt;"The only way to learn is to program everything yourself!" Where did they say this?
It depends on the goal. Python and windows is a royal PITA. If you do use Python, make sure to get it from the Windows app store, or Anaconda.
&gt;But is it really "programming" if all I do is `#include &lt;stdio&gt;` and then call `printf("%s", "yes, it is, you hypermanual dingus")`? But is the entirety of your program going to be 6 lines, or is that printf just a small component in a much larger picture?
It allows you to check if the default is unset with `if default is INITIAL` in the function. If not assigned to a variable, there is nothing that can positively compare to an unknown `object() `.
Nice. Would definitely be interested in seeing an article for configuring uWSGI for docker too.
Would your tips differ at all when using an async (ASGI) solution, such as uvicorn?
&gt;I don't need to hear/read that my code is awesome, but "programming" should involve a little more than exclusively calling someone else's functions. I get what you're saying. Maybe your goal is to specialize. If it is, I'd suggest continuing on the path you're going by writing it all yourself (within reason). If your goal is to write applications, then this library is just another component in a much larger picture. It's a good thing, but of course it has to be used appropriately. It's a balancing act: using a library for every little thing is just as bad as subscribing completely to NIH
Data analysis with pandas on various open datasets.
&gt;your program Think about what you just implied here.
Wrong. One should learn built ins and stdlib literally by heart the first thing.
&gt;Violently coding on your mechanical keyboard in the basement for 8 hours a day for a whole month without a pause, sipping Mountain Dew and eating Doritos. Absolutely no documentation reading, integrating, meetings, testing, or any of that pussy shit whatsoever obviously This is called "degenerate".
&gt;&gt;your program &gt; &gt;Think about what you just implied here. I don't play that game. You can tell me or we can stop this discussion.
uWSGI has a bunch of broken-by-default settings. E.g. it disables threads (you should enable them with \`enable-threads\`), and it forks after starting the process (disable this with \`lazy-apps\`), apparently you want to see \`wsgi-env-behavior\` to \`holy\` (that's the default in newer versions) and probably there's more things you need to do. &amp;#x200B; The defaults are broken enough that I personally don't trust it.
You're implying (by following the submitter's opinions) that it's not programming to write something that you subsequently call a program.
If 6 second startup time is a concern for this workflow, it implies this file-getter should be a long lived process (aka, daemon). I would use mutliprocess pool to distribute the work. Multiprocessing is the only way to schedule work across physical CPU cores, so if you have any compute-intensive operations after your initial get, it's the way to go.
If you start Java would the first thing you do is to understand the method declaration?
To me the large problems with asyncio is that it's harder to debug and some of the error messages are very cryptic. Even when I run the event loop in debug mode and accidentally have created something async outside of it I just get a generic exception with no indication to which object is causing the loop to crash. I also don't think that I should have to run th
First of all I wouldn’t. And secondly in python it’s a norm to do so.
&gt;You're implying (by following the submitter's opinions) that it's not programming to write something that you subsequently call a program. Right, I was thinking about this, and on the surface you're right. But there are social implications to this. If you spray paint over a stencil and the end result of that single task is something artistically pleasing, does that really make you a painter? Can you call yourself a painter?
Code Academy
Says who? It doesn't look like my professor did this. They taught some of the useful built-ins but not all. However, that class was teaching programming concepts not a full course on Python. PS: The class is CS61A UC Berkeley.
\&gt; Make an argument, you weenies. downvotes for leaving me poorer in time and not richer in anything worthwhile
This sub would be pretty empty if not for posts like this. Just look at the other posts here: this is exactly the kind of content this sub wants.
Yes, you're applying paint to a "canvas". In this Hello World example, you're still creating a program even if it's using libraries/packages that someone else has done previously. In the submitter's classifications example, the person still has to create and shape the training data in a way that will provide meaningful and accurate results. They still need to know what they're doing to provide a quality result, even if they don't know the specifics about what the Python dependencies are doing "under the hood".
Ah gotcha. I started using it with Flask when I first started learning and haven't switched over to Gunicorn yet. Sounds like I'll want to make the switch (which seems to be in my best interest at this point). Thank you for replying to my comment :)
I've never seen KISS interpreted and applied in that way. The rest of the talk was pretty good.
Not OP but less content is preferable to spammy. Same reason we have subreddits and not one page, just at a micro level.
Nim... the illegitimate child of Python and all that's wrong with Pascal, with some Perl thrown in for good measure.
Have you had it lose control of inputs yet? I did pretty quickly. One time I had to CTRL+C
[Yes, Python Is Slow, And I Don't Care](https://medium.com/pyslackers/yes-python-is-slow-and-i-dont-care-13763980b5a1)
Look at it. It was written with Nim, whose creator stood with Python on one side and Pascal on the other... **and chose lots of stuff from Pascal anyway**. Then he added some Perl-style line noise because he hadn't made Guido Van Rossum cry hard enough. That lack of good taste and common sense has bled through into this API.
Really good article!
I have, yeah, I think it is related with Tkinter not able to keep up with the input events anymore because it is too busy redrawing the image. Unfortunately if we allow it more time to process other events, the fps tanks
I found this YT vid and it seems pretty great! [https://www.youtube.com/watch?v=-CpG3oATGIs](https://www.youtube.com/watch?v=-CpG3oATGIs)
Aw man I thought OP was being sarcastic. I am disappointed in seeing him defend himself in the comments.
There's next to no python code in this project.
Hello! I'm a bot! I see someone has already suggested going to r/learnpython, a sub geared towards questions and learning more about python. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
&gt; any of that pussy shit finally someone's spitting truth out here
Maybe it was Spyder? Do you have a timestamp link for the video? It's at the very least a plugin of some sort I imagine
Better to let people make pull requests than having everyone commit directly to master.
Despite the discussion about there being no clue what the video is about, nobody has mentioned what the video is about. Anybody want to give a clue?
Assembly is for n00bs, dude. It's a high-level interface to a CPU core that does all the *real* work for you. Can you really call it "programming" if you can just write `addl (%rax, %rdi, 4), %ebx` with only one instruction? And your CPU will handle fetching the instruction from memory, decoding it into independent address calculation and memory load μops, renaming their outputs to unused physical registers, tracking their dependencies, executing them, forwarding their output to future instructions in the dependency graph, and retiring them in order? I would argue that someone else did the real programming.
I don't see anything particularly exciting in the settings, so probably just making sure you have more than 1 worker and logging to stdout (though no doubt there's some room for tuning).
Sure! Here you go. [https://github.com/Street-Captain/redditShowerThoughtBot](https://github.com/Street-Captain/redditShowerThoughtBot) &amp;#x200B; You might need to do some tweaks to get it to work on your machine. I added a readme with some tips on how you might go about doing that.
It's a video about trying to avoid complexity of solutions when using Python mostly
Where was this in the post, I missed it
Use bins, meaning divide the room into nxm bins, making sure at least a couple food object are in each bin. Since you got player cords you now only have to check the bin in which your player is. The problem about this are the edge cases and the sizing of the bins...
This second point is why the requests module is so popular. Most, if not all of its functionality, can be handled using urllib, but the experience is painful for most people. Requests essentially does the same thing, but the experience is pleasant instead of painful.
Writing code that actually does something. The code in question only runs someone else's code, and I'm arguing that that shouldn't count.
I'd like to see `assert` in that list too
It's not ineffective if it works. You probably mean "inefficient," but then you're in some ways agreeing with me. To do the same thing in C, I actually had to write code. I'm arguing that, with Python, someone else wrote the code.
Where the heck do you get the script text to scrape for something like this?
You used an smartphone to take this photo which is literally a computer. https://play.google.com/store/apps/details?id=org.qpython.qpy3&amp;hl=pl https://itunes.apple.com/us/app/pythonista-3/id1085978097?ls=1&amp;mt=8 Bruh.
https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists
This is a great development!
Did you happen to use the C standard library while you were using C? How dare you print to `stdout` using *someone else's code!* How dare you do typecasting without defining it yourself! A real programmer writes everything from the ground up. Besides, it's irrelevant. A k-means classifier is a k-means classifier; the real work isn't in configuring the classifier, but in preparing and pre-processing the data *for* the classifier.
I hope that next step after that is PEP8 cleanup of standard library. Some of those functions hurt to look at.
Is "running someone else's code" not "doing something", then? Where do you draw the line?
Yeah that's the biggest time sink usually with something like this - hoping that *somebody* out in internet-land is a big enough TV/script geek and has them available. In this case Google led me to a couple-year old blog post about analyzing GoT script data in **R**... but I wasn't about to go down *that* road, so I followed the links to see where they were scraping from and then rolled my own with urllib and BeautifulSoup
I'm going to bite, to see if I can help. Let's suppose you have a tuple that contains a coordinate in the form (x, y, z) &gt;&gt;&gt; xyz = (1, 2, 3) Now you can use something called tuple unpacking to expand this and point each value into its own variable. Like so: &gt;&gt;&gt; x, y, z = xyz &gt;&gt;&gt; x 1 &gt;&gt;&gt; y 2 Etc. This is unpacking. But you can also do packing. So, for example, if you wanted a tuple with just xy, and z to be separate, you could do: &gt;&gt;&gt; *xy, z = xyz &gt;&gt;&gt; xy [1, 2] &gt;&gt;&gt; z 3 What's happening is that python is getting more arguments on the right side of the assignment operation than on the left, so it puts all the extras into the one that has the star on it. You can do this with different things to play with. &gt;&gt;&gt; a, *b, c = (1, 2, 3, 4, 5, 6, 7) &gt;&gt;&gt; a 1 &gt;&gt;&gt; b [2, 3, 4, 5, 6] &gt;&gt;&gt; c 7 Play with it a bit and you'll understand this part well enough. Now, when you're passing arguments (not keyword arguments) to a python function, what you're really doing is passing it a tuple. And it will unpack it into the arguments. So, for example, if you have a function like: &gt;&gt;&gt; def foo(a, *b, c): ... print(a, b, c) And you pass it 1, 2, 3, 4, 5, 6, 7 &gt;&gt;&gt; foo(1, 2, 3, 4, 5, 6, 7) 1 [2, 3, 4, 5, 6] 7 So, it is doing exactly the same sort of tuple packing and unpacking that you'd expect! It doesn't matter which argument has the star - that's the one that gets all the leftovers. You could one only one argument and it will work as expected. &gt;&gt;&gt; def foo(*b): ... print(b) &gt;&gt;&gt; foo(1, 2, 3, 4, 5, 6, 7) [1, 2, 3, 4, 5, 6, 7] Except most people call it *args, out of convention. A similar thing occurs with dictionaries. Except, it uses ** as the syntax.
But doesn't that exact question apply to the thing OP described?
Good find. The possibilities are endless.
To create my first ever web page, I designed it in MS Publisher and saved it as HTML. To create my first dynamic page, I had to figure out how to accept your ZIP code as input and display for you a list of doctors in your area, in ascending order by distance, of course. I'm equating this classification task to the former; Microsoft did all the work. In contrast, I wrote code that analyzes tweets with 2 sentiment analysis libraries, generates single-sentence summaries using 4 different methods, and then uses stopwords to rank the top keywords tweeted with the given search term. Although that code has a lot of dependencies, which I concede made the task considerably easier than it otherwise would have been, I had to write quite a bit of my own code to get all these different features to play nicely together. I call that part programming. But, you could call Twitter's API and do sentiment analysis with TextBlob, and I would argue that Twitter and TextBlob are doing all the work.
Is someone a web developer if they use WordPress? I think there's a minimum standard.
I saw someone else do something amazing, and that made me want to know how it worked.
Shouldn't you be able to write a function, though? If I only call YOUR functions, what did I really do? I'm simply arguing that YOU did the work.
No, because printf on its own isn't used for any real world task that a non programmer will directly benefit from. OP's "really awesome library call" is going to literally be the program (in addition to a few lines of boilerplate) and is actually going to be *the* essential piece of information for the task. And because of this, something non programmers can use is available.
That's different, because I probably have to write code around that sort function. There is a difference between calling your function to help my code and calling your function to complete the entire task. I would argue that scikit-learn is doing all the work in my gender classifier.
There is a difference between calling your function to help me with a task and calling your function to complete the entire task. With the former, I actually have to write some additional code. That's programming. With the latter, you did all the real programming.
&gt;Yes, you're applying paint to a "canvas". &gt; &gt;In this Hello World example, you're still creating a program even if it's using libraries/packages that someone else has done previously. &gt; &gt;In the submitter's classifications example, the person still has to create and shape the training data in a way that will provide meaningful and accurate results. They still need to know what they're doing to provide a quality result, even if they don't know the specifics about what the Python dependencies are doing "under the hood". &gt; &gt;Does this mean they can make a career out of *software development*? No. But is it programming still? Yes. &gt; &gt;edit: &gt; &gt;I missed this part of your comment: &gt; &gt;&gt;Or if you write a small paper which is technically valid but essentially just parrots information without offering any substance of its own... &gt; &gt;You still compiled the information. Even copy-and-pasting is writing. Maybe so. What I will say though is that it isn't a respectable depiction of either activity. It alone isn't something worth taking pride in, and if that's all you are capable of, what good are you really? Maybe the goal isn't to be skilled - it's to get the job done. If so, yes: use that library. But if that's all you can do, to call yourself a programmer is bordering on being a fraud or a poser. I'm not saying NIH should be embraced, I'm saying it's important to be able to do the hard stuff when you have to. That ability is only attainable through wheel reinventing (obviously for work this should rarely be done, but that's beside the point).
I'd argue that a raw ML model is also not "used for any real world task a non programmer will directly benefit from", even if we do go by that definition.
If I use a washing machine, am I washing the clothes? No. I'm doing my laundry, yes, but I'm not washing the clothes.
I'm using audioop :(
I think you took this example from one of the links in this article on [unique and sentinel values](https://treyhunner.com/2019/03/unique-and-sentinel-values-in-python/). The whole article attempts to explain the use of `object()` as a sentinel value. You can think of that `INITIAL` variable sort of like `None`: it points to a specific object which we can reference outside of that one line of code.
The fact that these things work at all blows my mind. And, now, quantum computing? We (humans) can entangle electrons? I don't know adjectives strong enough for that.
Visual Studio's Python support is pretty janky. Try PyCharm or VSCode?
None of this would bother me in the slightest.
I'm not arguing that using libraries is bad. I'm arguing that there is a difference between using a library to help you do something and using a library to do all the work, as is the case in my gender classifier.
What makes it so much better? I mean, sure creating threads is heavy, but if you have a pool of workers then you’re not blowing them away and forking constantly so it’s just the context switching either controlled by python or the OS right?
But, is it really your code getting the job done if you call on one library to do all the work? I'm arguing that the library, in such a case, did all the work.
Literally only one module I've even heard of and none I've ever used.
Unfortunately I don't. I just remember seeing it in a video and remembering him going through a couple by saying out loud what it did
Using tools and adding value; I believe we agree here. My argument is that my gender classifier uses scikit-learn, and I added no value to it. That's not programming.
Could you link an example for the lazy?
There aren't plans for non-backwards compatibility again, are there? I can see removing packages, because then you just have to make sure packages you use are installed. But changing functions could make old code no longer work. Or is this just about the implementation of those functions while leaving the interface the same?
Can you share a link to your project?
&gt;There are **69** built-in functions in Python (technically only **42 o**f them are actually functions). Something about this programming language reeks of dank.
If you’re concerned about using a library to do all the work why are you hosting your site using Wordpress? Why don’t you create a barebones Flask app to serve up content as a CMS? Why don’t you make it so you have the flask app as a front end to your gender classifier? Why don’t you create visualizations of the classification data and the performance of your classifier with different training/test splits or differently tuned parameters? If you limit your world view to just a gender classifier of course it’s going to be “simple” - no matter what language you choose. Once you actually have something working then it’s about making sure that people can actually use that and that it actually solves a real problem that people have. I’m not trying to be harsh but the “real world” requires you to think about these things
Not a function.
Thanks. For the record, I generally don't write from scratch. Once I have a neural network, for example, I'm going to start there for my next neural network. I don't need to reinvent the wheel every time. But, it's worth noting that I am starting with my own code.
I'm using the cgi libs... Anyhow, I wonder how much time and effort the stdlib maintainers actually put into these modules. Quick look at cgi.py says like 8 commits or so over the last two years. I get that each thing adds up, but each removal adds up to from the longtail of python users. I understand removing modules that have other stdlib replacements (like no problem removing imp for importlib), but I think removing stuff from stdlib with no replacement cause they aren't sexy is also a poor choice. I mean, especially since I imagine that literally no telemetry or data exists as to the actual value of these modules.
The `*` and `**` operators in Python aren't trivial. They're usually one of the more confusing syntaxes for folks in my Python trainings. I [wrote an article on all the ways `*` and `**` are used in Python](https://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/). It's a reference guide of sorts, but I did my best to explain each of the syntaxes for folks newer to Python. If any of it could a bit more explanation, feel free to comment on it.
It has nothing to do with difficulty level, but whose code is doing the work.
Part of it comes with experience. Write a lot a programs and experiment with different methods of organizing code. Try to note mentally what things are difficult to change and what is making them difficult.
I've got a lot of code out there in the wild that uses cgi libs but it's all python 2, so it's not gonna care about this update. presumably when I eventually rewrite it to python 3 I'll be pushing it up to mod\_wsgi or something more modern.
Logging library using mixedCase comes to my mind... I hate it
My argument is the difference between calling a library that helps you do something, as in your example, and calling a library that accomplishes the whole task for you. In your example, you probably actually did something, which is why you want to display it. You probably did some actual programming.
Quote: &gt; In the next Windows 10 update that starts rolling out today, we (Microsoft) have added "python.exe" and "python3.exe" commands that are installed on PATH *by default* and will open the Microsoft Store at the page where we (Python core team) publish our build. &gt; This makes it a 1-2 click process to get from a clean machine to having a usable Python install ("python.exe" -&gt; opens Store -&gt; "Get it Free" -&gt; "python.exe" now works!) Thanks to Steve Dower and the Python team at Microsoft for convincing the company to support this.
Ah good point. I hadn't shown that! I just noted that and also added a link to a `hasattr` quirk. Thanks! :)
&gt;it isn't a respectable depiction of either activity (which I think is OP's real point here). OP's point was to come here and brag about himself. He wanted everyone to reply how he was amazing and anyone who thought it was fucking asinine to reimplement things when they didn't need to were somehow stupid and had no value. You're continuing to conflate a *profession* (software development) with an *act* (programming). Then, on top of all that, you're egotistical enough to denounce anyone who uses the right tool for the job at hand as unskilled frauds and posers?! Fucking /r/gatekeeping through every single comment from you and OP. I think your mindset is absolutely disgraceful and narcissistic.
Here's a sneak peek of /r/gatekeeping using the [top posts](https://np.reddit.com/r/gatekeeping/top/?sort=top&amp;t=all) of all time! \#1: [On a post about their dog dying](https://i.redd.it/yoxbfwh3nm921.png) | [1200 comments](https://np.reddit.com/r/gatekeeping/comments/aeky3m/on_a_post_about_their_dog_dying/) \#2: [Unsure if this belongs here](https://i.redd.it/aqmqzr1bxvd21.jpg) | [676 comments](https://np.reddit.com/r/gatekeeping/comments/alyba8/unsure_if_this_belongs_here/) \#3: [Anything &lt;$5 isn’t a tip](https://i.redd.it/s8ulclj18cq11.jpg) | [5550 comments](https://np.reddit.com/r/gatekeeping/comments/9lktoe/anything_5_isnt_a_tip/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
The whole stdlib? Do you really know `turtle` by heart?
I was fearing that I would not know too many, amazed that I have run into most of them and do understand the majority them to some degree. Using them efficiently though? Can't say I'm that far yet.
I'll add 2 tips to what u/meefims said: 1. Refactor- after you write the crap, go back and clean it up until you think it looks like something your tutorials would share. 2. OR as you write out some pseudo code comments, make each comment into a function. Either way, plan to write and re-write lots of code. Just be thankful it's python!😁
&gt; turtle Of course no, but I know how to use it.
I was a little surprised to see abs() so low on the list. I would have thought it’d be way more common than that!
Adding value. Look at my 6 lines of code and tell me what value I personally added. I'm arguing that I added no value whatsoever. In contrast, I have code that analyzes tweets with 2 sentiment analysis libraries (and does other stuff). I wrote code that checks that the libraries are in agreement with their analyses. If they agree, for example, that a tweet has a positive sentiment, then I classify that tweet accordingly. If they disagree, I classify that tweet differently. While I would concede that the libraries are doing the hard work, I actually wrote some code to add value. I did a little programming. And, when you factor in the other features, quite a bit of the code turns out to be mine. That's very different from doing sentiment analysis in which you call Twitter's API and call TextBlob and you're done.
That wasn't harsh; that was helpful. That first paragraph? Added to my list. I'm pretty sure that's going to require some programming.
That’s great. I’ll look over it on my computer when I can. What do you suggest to someone who wants to plan a path towards Product Management through data analysis/ python? How was your experience in skills you’ve had to develop for the challenging role?
[Good Contribution actually, added to the FAQ.](https://github.com/juancarlospaco/faster-than-requests/commit/de17159972efce2e04e776bd4dae17b5ef7f7fbd)
It was pretty interesting if not drawn out. It was about how the simpler solution is probably the best, but that complexity has its place. It talked about how when you're writing code as an engineer it's designed to solve a specific business goal and to not get caught up in doing things in a way that are intellectually challenging to yourself for the sake of learning a new skill. It also talks about the tradeoffs in terms of what's the best way to write something when you consider who the "target market" of your code is. IE if you have 100 senior engineers and 5 juniors you shouldn't dumb down your code for the sake of doing so when they will be up to speed in 6 months to a year's time.
Have to say it’s nice to have a closed form solution available dynamical instead of having to use something like Monte Carlo methods. Mathematica is incredible at purely math and symbolic problems. I can see it being very useful in some niche applications
Good bot
[Good Contribution!, added to the FAQ.](https://github.com/juancarlospaco/faster-than-requests/commit/e19cebe4762d9ea0b0c501b81effdf485fe98956)
The reason I prefer threading is that if any of your code uses asyncio, suddenly you need to write async all over the place, change how you start it up, and it poisons all downstream projects - they have to do the same thing. With threading, you can parallelise where you need to, then re-serialise with concurrent futures as_completed. It's a much more incremental change. Plus asyncio doesn't schedule the coroutine until you await it, which just defeats the point entirely. I know you can create a task which is allegedly scheduled immediately but when I tried it it still didn't actually run until I awaited it.
Do it!, pass the link when you have it.
I'd add [decimal[(https://docs.python.org/3/library/decimal.html) to the list of "overlooked by new Pythonistas".
[Thats a good Contribution, added to the FAQ.](https://github.com/juancarlospaco/faster-than-requests/commit/d8bc9f4064e91974164929de8224e5e93bcaf01c)
Ah this is an interesting one. Python's `assert` isn't a function but a statement (oddly, given how few there are). You can think of it like `del`, `return`, and Python 2's `print` (`print` is a function in Python 3 now). I sort of wish `assert` was a function because it would make teaching it easier. I also wish `del` was a statement. These are the only non-control flow statements that I encounter regularly while teaching.
This is a good example of constructive criticism, not like the "Batteries included…" debacle. That being said, I feel a couple of these modules could be kept and improved like ```imghdr```, ```sndhdr``` and maybe even ```audioop```. Cool PEP!
Thanks!
If you want your code to be Slow, good. If you want your code to be Fast, good.
I can confirm about kids liking crazy noises. I started programing with a qbasic program that made the screen turn colors while making farty noises.
So jealous right now. I'm just starting to learn python after learning Basic back in the early 80s. I'm so rusty that I've got to review every lesson twice to get some of the info to stick with me. I know that it will take a lot of practice and patience but it's good for my old brain to learn new skills.
If you think for a moment, Python is made of a lot of languages, C, C++, Cython, Fortran, etc.
If you think for a moment, Python is made of a lot of languages, C, C++, Cython, Fortran, etc.
Why?. If you chill and think for a moment, Python is made of a lot of languages, C, C++, Fortran, Cython, etc.
Ah, Basic. Yeah, I'm that vintage, too. Rest assured, Python is intended to be simple. Good luck!
Object oriented programming Never write similar code more than once.
Sure but if all you're doing is getting a classifier I would say that's pretty much just sorting an array in my mind. Writing a naive Bayes classifier or something is about as hard as writing mergesort. Even a simple neural net isn't that hard to write. Sure, the off the shelf solutions do more than the bare minimum, but so does the built in sort function. I had more trouble implementing TimSort than I did doing basic classifier stuff by hand.
`imghdr` would be very handy for basic EXIF, and similar, for an image meta data interface. It's just under developed and neglected.
Yeah, this kind of thing worries me... The 2 to 3 move was hard. I really hope we don't have to go through something like that again just for the sake of some better names. Yeah, any specific individual package isn't that hard to fix. But what about a huge company with lots of packages spread out, with the original maintainers gone? Or with projects that just aren't maintained well? With people who maintain too many projects for their own sake who just won't get to it? Sure, if you take a look at a specific one and have some tooling to help, it won't hurt, but sometimes people rely on libraries they don't even realize don't have a maintainer anymore. Sometimes you just don't realize there's something you need to fix and haven't got to yet. You can blame the internal processes of companies all you want, but it's just the unfortunate truth, and it prevents companies from upgrading python versions when it's not trivial across the company as a whole. When you don't have a company like Facebook or similar ready to accept an upgrade, there's that many less people working with the new python, that much less support. And that's just code. There's also tutorials everywhere that tell you to do something a certain way. How many python tutorials still have `print "some string"` in them, or `xrange` etc. How much documentation still references `import imp`. Support for a language is also about the documentation that exists, and you're not in great shape when suddenly you deprecate documentation that people stopped maintaining, even if it still has remained useful for years.
Try this https://www.guru99.com/
Classification is more than sorting, because the code has to first learn how to classify. For example, you might sort taller subjects as males and shorter subjects as females, but what happens when you have a short male or a tall female? You have to weigh other factors. That's why I took issue with scikit-learn making it so easy. Neural networks I've done, and I took issue with NumPy.dot, as well. I personally needed to understand what it was doing, so I worked it out the hard way.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
The PEP seems very likely to be a direct result of the "debacle" (Amber Brown's talk and subsequent discussions about it). If the PEP is useful, then it's hard to say the debacle wasn't constructive.
it's because it's a clone of the Java Logging library. I wish they'd move to {new} string formatting while they are at it.
Talk about who gives a shit
I mean classification is just like sorting in that there's a (not necessarily simple) algorithm that handles the caveats for you. Just because we don't learn classifiers in first year university doesn't mean the best algorithms are inherently more complicated than the best sorting algorithms.
Holy sh\*t one of my random side projects was mentioned in a PEP??? I guess [puremagic](https://github.com/cdgriffith/puremagic) is true to its name!
Yeah i just download vscode.
Which I guess brings us back to the old users vs. moderation debate. All the good online forums I'm aware of, Reddit subs or otherwise, are strictly moderated. There are rules for a reason and if you just allow everything people upvote, or let them dictate all the rules, you end up with... a bunch of bullshit.
https://xkcd.com/844/
Colorsys is a useful module if you are ever ingesting RGB colours and want to sort them by hue or saturation, and it's only [136 LOC](https://github.com/python/cpython/blob/2.7/Lib/colorsys.py).
In The Cuckoo's Egg by Clifford Stoll we meet a computer crime investigator who learned programming via correspondence in the 1960s. He would write his code and send it away to be coded into punch cards and run. He said it made you examine your code very carefully before you committed it to the mail. ([The Cuckoo's Egg](https://www.goodreads.com/book/show/18154.The_Cuckoo_s_Egg) is a true story of computer espionage in the 1980s, and the difficulty of getting anyone to do something about it.)
Why are you on this sub if you don't care about it?
&gt;The reason I prefer threading is that if any of your code uses asyncio, suddenly you need to write async all over the place, change how you start it up, and it poisons all downstream projects This was one of the major points I tried to make in the piece. You can't just add it one place.
This was a real frustration as I was first getting up the learning curve with asyncio.
I don't know much details about these framework but none of them seem to be production ready. Starlette is in alpha, FastAPI and Quart are in beta. (by the way, Trio is also in alpha). I would suggest to go for the safe route until you have good a reason to decide otherwise. And it's not like aiohttp is really bad either. [PyPI filtered by status/topic/framework (asyncio)](https://pypi.org/search/?q=&amp;o=-zscore&amp;c=Framework+%3A%3A+AsyncIO&amp;c=Topic+%3A%3A+Internet+%3A%3A+WWW%2FHTTP&amp;c=Development+Status+%3A%3A+5+-+Production%2FStable) [Same with trio](https://pypi.org/search/?q=&amp;o=-zscore&amp;c=Framework+%3A%3A+Trio&amp;c=Topic+%3A%3A+Internet+%3A%3A+WWW%2FHTTP&amp;c=Development+Status+%3A%3A+5+-+Production%2FStable) Early adopters usually are people\* that have enough experience to accept the risks (or they just are crazy, or rich … or both). But maybe you work on a personal project in which case you should just join the community you like the most so you can contribute on something you think is a good framework. &amp;#x200B; \**rather teams because you probably won't make such an important choice on your own, unless you are a in a very small company/startup in which case it's even clearer that you should go for a production ready framework (.*
I found the post helpful because I'm reasonably new to the language. Switching back and forth on languages from work to my hobby can be really frustrating and simple references like this are actually helpful reminders of things I read and then later forgot, or didn't realize I was missing a cool use case for. You don't have to like the post, but if you want a sub for expertlevelbreakingpythonnewsonly make one and call it that, let the normies live here in r/python
No one is allowed to commit to master. Master is a protected branch. All merges to master must come via pull request, and all CI must pass.
God, the old packages names are so ugly, these had to die at some point. "sndhdr" I don't even want to know what that is supposed to evoke, that just look like a cat walked on my keyboard.
Thanks a bunch! I'll check it out - it seems to be what I was looking for.
I did not even know `fileinput` or `getopt` exists for command line processing. Looking at those it seems understandable why some developers have objected to their removal. They do provide quick ways of processing argument for simple use cases as well as provide a familiar interface for those who're used to `getopt` in C. But existence of these does mean that there are now four different ways of doing the same thing, which is not entirely desirable. May be the solution would be to enable using `argparse` with less syntax and effort.
Which reminds me: I did a reverse sort with 1 line of Python. I didn't need to know any algorithms at all.
It's one thing to replace stuff that is irrelevant, but things like NNTP and uuencoding are still in use. And we're not going to have SMTP support either?
You don't read that as "sound header"? Once upon a time, everything in the world was limited to a name with eight characters or less.
The design of the logging library send bizarre to me, too. Things that would be really useful are marked _private (e.g., an iterable of log levels) and the public facing function for "validating" that a string the name of a valid log level returns mixed types.
To better understand classes you have to undestand namespaces. Namespaces are names used to access classes and its methods so there is no ambuigous call. Example: namespace 'A' have a class called 'Foo' and namespace 'B' also has a class called 'Foo'. So to reference one class you type A.Foo() or B.Foo(). In python, every file is a namespace, a module. (not actually sure that namespace == module in python) And classes are a way you have to either manipulate certain objects within the class (like a class to manipulate a matrix and get transpose, determinant, multiplication, etc...) or provide a set of commom functionalities (like a class to use static methods). One of the objectives is organization. You can easly lose yourself if you dont create classes and diferent namespaces. Imagine a file that have 1000 methods.
That's a good point and what I was thinking too. Instead of "kill it with fire!" I'd like to see someone suggest a **replacement** that's modern and useful. It's a lot easier to get support for killing something off if there's something better waiting to take its place.
A 1 line reverse sort is basically like saying I wrote a classifier in one line of python: ``` return height &gt; 165 ```
Or they could just bundle Python with Windows... I mean they're already going to be bundling a **Linux kernel**....
It's unsatisfying, isn't it? Sometimes the point is to just do what you gotta do, put I wouldn't call that "programming."
I'm not feeling your pain. There were times I needed to write Pascal in a notebook (I mean a literal, paper notebook). In Turbo Pascal you had to declare all of your variables at the start of a procedure/function before using them, and nested procedures/functions also had to be declared at the top. That meant on top of the problem you already have, you had to leave large blank spaces just in case you needed to go back and add a variable or a nested function later. And when I inevitably didn't leave enough space, I'd essentially create footnotes by doing things like putting a number in a circle and then writing the code corresponding to that symbol on another page. And when I finally got to a computer, I'd have to be flipping pages back and forth to follow my code and type it all in. Sorry, as Raymond Hettinger says, you can literally write Python on the back of a napkin. Languages like Java and old languages like Pascal you can't.
But that's my point; if you're using python's built-in sort, the algorithm you are using behind the scenes is something almost nobody would come up with without a ton of work. Similarly writing a good classifier is also something you probably wouldn't come up with without a fair bit of study, but both are similar in that they're largely 'solved' problems. Nobody cares if you can implement a classifier yourself, because it's not an issue. You shouldn't feel badass for hand-writing a classifier any more than you should feel badass for writing a broken sort function. It's like calling it "not programming" if you're not managing strings as `char` arrays. We've gone through it and abstracted those problems away. This boils down to basically saying that using Python *to begin with* is not programming. For reference, the original proposal for python's sort function (don't know if it's still used) is [here](https://bugs.python.org/file4451/timsort.txt). It's fucking long.
Maybe they love Python but aren't fans of the Microsoft Store?
Nah, I think I would read "Snedhader" (which I would pronounce "ce n'est d'adeur" in French). But I love to ear stories about how "grep" actually used to mean something, even if nowadays "grep" has just become a verb. I'm sure it's because it has vowels which Snedhader lacks. If they used vowels I'm sure puremagic wouldn't have killed Snedhader so easily.
You left out the best part! "We got hacked because we/some vendor we decided to blame is bad, but we're not going to be held liable! Instead, here's some fucking credit protection racket who will now *also* spam you until the universe grows fucking cold."
Or write functional programs that is modular. I think that jumping straight into OO is not the best move. Spaghetti code -&gt; functional -&gt; OO. I generally keep it functional, but sprinkle a little bit of OO for prettiness.
Is anybody a fan of the Microsoft Store on this planet? Seriously, that's a piece of crap. Only the Windows iTunes is worse than the Microsoft Store.
&gt; I'm using the cgi libs... Out of curiosity, what are you using it for?
Hey thanks for doing
Also, amazingly, if code uses numpy it seriously not too shabby today. I think the performance loss is easily made up for by the convenience it offers: https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2019/04/image1-1.png
Developers these days have don't realize that there are other application protocols besides http.
&gt;&gt;it isn't a respectable depiction of either activity (which I think is OP's real point here). &gt; &gt;OP's point was to come here and brag about himself. He wanted everyone to reply how he was amazing and anyone who thought it was fucking asinine to reimplement things when they didn't need to were somehow stupid and had no value. How? All I saw was a reflection and mild disappointment about he put in a lot of work for something that could have been accomplished in a few lines. &gt; &gt;You're continuing to conflate a *profession* (software development) with an *act* (programming). A certain level of competency is generally required of any discipline, professional or not, in order to label that discipline as a core aspect of one's identity. &gt;Then, on top of all that, you're egotistical enough to denounce anyone who uses the right tool for the job at hand as unskilled frauds and posers?! See, this is what I find irritating: I'm not actually saying this at all. You're literally applying false deductions to my words. What I'm saying is that if you *have* to use a library for every little thing, then you are at best an average developer. &gt;Fucking /r/gatekeeping through every single comment from you and OP. I think your mindset is absolutely disgraceful and narcissistic. If you actually think gatekeeping in general is bad then that's something else we can discuss. What I can tell you is that a) you're clearly emotionally attached to an ideal and b) it's affecting your capacity to have a reasonable discussion here. I believe that being a good developer requires at most an above average IQ and discipline. That's it. There's no gatekeeping or narcissism in that belief. It's perfectly reasonable.
I don't mean the quality of the software, I mean how Microsoft wants to be a walled garden like Apple. Anyway, I think that's a legit reason to not give a shit about Python being available using that platform.
&gt;I'd argue that a raw ML model is also not "used for any real world task a non programmer will directly benefit from", even if we do go by that definition. To say that is to assume only programmers can benefit from ML models. And yet what do data scientists and statiscians do?
I hope you're not like this in real life.
I disagree but I understand where you’re coming from. That is the proper progression when learning but as a project grows, functional programming turns into spaghetti easily (especially with php or js). Based on my experience, OO code can be updated easily (especially when it follows an MVC pattern) and breaks less often. Encapsulation, polymorphism, and inheritance are essential to preventing reuse and conflicts as you scale. That being said, I use functional programming if I know I’m not going to need to touch the code ever again and it’s a personal project.
Is that all you've got to say?
I'm not arguing that you can't use Python to do programming. But, I'm saying that you can use Python without programming.
You set the dict body equal to the raw message instead of the email message. Was that intentional?
So you want to do GIS work? Have you looked into QGIS?
Never having heard of it, I thought it was “Send HDR”
r/programmerscirclejerk
From the PEP: &gt; The uu codec is provided by the binascii module. For smtpd it makes sense to remove it considering asyncore is being removed for removal. I can imagine there's not much appetite for implementing an asyncio version when aiosmtpd already exists.
Better asked on r/learnpython
r/programmingcirclejerk
I wanted to only have the body of the email populated in that field. And setting the dict body to raw message also adds the to and from email fields, the date and other info I did't want.
Memorizing code stuff is a fools game. It isn't helpful when you have the whole internet at your fingertips. Also /r/learnpython
But did they have to keep coding style as well... It's probably too late now though. Maybe they could alias the function names and have both.
That's sick as fuck, good work!
I read it as 'send header'
My guess is that having a space in the key may not be an option - but that's just a guess, I never actually tried to use spaces in a key. It is very disturbing that you mix regular text with code without separating regular text with comment ( # ). I'm not sure what you mean by the other problem that is a boolean statement. Please try to explain your intentions and the problem, as well as your question, better in terms of grammar and logic. You should ask programming questions on r/learnpython instead of on r/python.
I am reigniting my fire for learning Python. I took quite a long break due to other projects, YouTube and whatnot. I am looking for some good resources that can throw me into learning the language. I've only been learning piece by piece, but not bringing it all together.
Jeez, though, wish they'd gotten an editor to look over this pep's writing before it was submitted officially
Universe growing cold will only let them overclock the servers and spam faster.
My first share on Reddit... I'll take it!
`msilib` seems odd to remove so quickly, given the number of people *not* wanting to update to Windows 10.
It's a good first step, but it's still extremely conservative. 3.8 isn't even released yet and the soonest this commits to removing these libraries is in 3.10, which likely won't release until 3 years from now.
I mentioned it because the article itself calls out that it is not exclusively discussing functions &gt; Note for pedantic Pythonistas: I will be referring to all of these built-ins as functions, even though 27 of them aren’t actually functions (as discussed in my functions and callables article).
I see a lot of buzz about click as far as less syntax goes. I definitely think a higher level wrapper around argparse would be nice and could remove the need for getopt.
Probably for escaping html or urls, which has been moved into other libraries in the standard library.
It's handy for little internal tools. Like if use volume is relatively low and there's some tolerance for latency, you can just use the built in python CGI request handler server with Python based cgis to serve up little internal forms (with like a sqlite backend). Like I totally get that its niche, but it's nice for my purposes.
Woah, you're the guy who made Box, 07 to you sir
This doesn't advocate removing colorsys I don't think
The vfx industry depends on aifc and audiooop. Deprecating it right as we're moving to Python 3 next year is a bit insulting.
Most of the post production film industry is.
The point of getopt is that it is C style. It makes it very easy to take an existing C CLI tool and rewrite it into Python while keeping the same interface. This is valuable. getopt's last commit was from 2015. It is hardly a maintenance burden. Getting rid of it is a false economy.
Do you get the same dissatisfaction when you use the requests library?
**wrapping up &amp; deploying my secret startup project which i have been working for the last two months . the project is something for the python/django community.**
I bet you could come up with better ways to perform calculations on data. That's my main gripe with Tableau
Hello! I'm a bot! I see someone has already suggested going to r/learnpython, a sub geared towards questions and learning more about python. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
I hate Tableau personally. I just like the idea of a GUI based system for non-technical people to query databases. If I end up getting to calculated fields, it'll probably work more similarly to Excel.
Maybe it would fit nicely into an article on keywords, or error-handling :) Assert is one of my favourite Python features, it's such a nice simple way to perform sanity checks.
PEP600 changing the entire language to javascript lol
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Funny I find the opposite 😂
Now you're just making me blush... (And possibly feel old, no idea what "07 to you" references lol)
Like frankly, I have a hard time with this PEP. How can you both say that its ok to remove modules from the stdlib because PyPI and pip is so easy, but then also say that they're going to keep certain crufty modules around because "However it is beneficial to keep the modules in the standard library, mostly for environments where installing a package from PyPI is not an option. This can be cooperate environments or class rooms where external code is not permitted without legal approval." Further, the idea we should remove modules from the stdlib because then the community libraries have to provide a compelling reason to use them instead of the stdlib is I feel kinda asinine. I also believe that minimized Python distributions should go ahead and feel confident that they can rip out stdlib modules. For example MicroPython is already incompatible with CPython at a built-ins and stdlib level already. Rant over. In the end, I just want them to make a considered decision, and not just act off some hot drama.
As long as it gives me the correct results, it gets the job done.
that seems like more work than just installing it
Yeah I'm just putting my two cents in. I'm sure if it had been taken out, anyone who needed it would find the functionality by googling "python rgb to hsv" and finding the code posted on Stack Overflow.
I think it's an ASCII-art salute, but I might be wrong, I'm old too.
Totally see it now! reddit font doesn't translate it well.
Extremely conservative and half this thread is people saying how vital it is to keep this or that ancient module.
Snead Hader
&gt; I often think Python is too easy &gt; It has nothing to do with difficulty level uhh
Great advice. Take a small step. Identify a process and the associated code that is employed to ‘solve‘ the problem. Understand the syntax. What is done. Repeat. Build on that foundation. After decades of programming, I find the internet to be a godsend.
Vim buffers are incredibly powerful but the fact that you cant copy or paste into anything outside of vim just makes them so impractical for real world usecases.
Anyone know how a person can send comments in on a PEP?
&gt; It's a good first step, but it's still extremely conservative. 3.8 isn't even released yet and the soonest this commits to removing these libraries is in 3.10, which likely won't release until 3 years from now. It's API breaking. I'm surprised this is even being considered for a 3x release
Actually, it was 6. I mean long long time ago.
Then why does urllib urlib2 and whatever the other garbage lib is called still exist. Why does FTP still persist. People are lazy and incompetent they will cut and paste whatever someone else did and never upgrade. Until forced to.
Next year!? Wtf. Py2 is end of life THIS year and you've had like 3-5 years to move already. You're the reason we can't have nice things.
Yeah neither threads or asyncio seem to make a lot of sense here. The multiprocessing module behaves like multithreading but without GIL issues. It also might just be a job for something like GNU `parallel` reading from a FIFO.
Then your issue should be distinctly and solely with the authors of SciKit-Learn, for ostensibly creating functions that do too much at once.
Nothing is being replaced. Moving things from one place to another. People are reacting like pypi doesn't exist and there is no python libs other than what comes in stdlib.
Works better with a lower case O. As in: o7 CMDR.
The core software our company uses still uses Python2 as its scripting interface. I'll be using Python2 for a long time to come.
I'm sorry that Python 2 is working as is, and we have 10s of millions of lines of code written in it, as well as built in interpreters in most of our applications. Moving to Python 3 has been a huge coordinated effort within the industry as we had to get all of our software vendors onboard, as well as make clear to all of our companies that Python 2 deprecation was happening, and that the expense of converting all of our pipelines to Python 3 needed to occur as soon as we could do it. This took years, and a lot of effort on the part of many busy developers went into it. There's not a lot of cost benefit. In the end, Python 2 not getting security updates was what finally got the ball rolling.
They missed that boat with python3. They choose to limit change to minimal set and still developers bitched, never updated their code, etc. We ended up having to endure whiners to this day (and I'm sure for few years yet) AND we still got stuck with (parts thereof) clunky ads stdlib.
As I understand it these libs won't go fully away and will just move out of the jurisdiction of core developers. So hopefully you will still be able to use it just with the caveat of installing them first.
I know I'm an outlier these days, but I always find it so bizarre to read these articles. I've been using [gevent](http://www.gevent.org/) for years now to do stuff like this. It's like asyncio, but faster and without all the crud. You also write it much like you would with threads (i.e. "wrapped around synchronous code without much concern for the internals"), but it runs asynchronously. And it works with all the existing libraries you know and love. There is a learning curve to asynchronous programming. No way around that. Some people say asyncio gives you a leg up, because it's explicit. But things like this article tell me that the rest of the asyncio API likely just make it even harder to understand.
No, they are obviously real programmers. My argument is that one is not programming unless one is actually programming. Calling their function and doing nothing else is not programming.
Are they? Last I checked it was an optional download. Windows 10 is already bloated enough. It shouldn't take 15 GB for a minimal install for my VMs.
EoL of 8 and 8.1 has already happened. By the time 3.10 hits the internet Windows 7 will have been EoL for almost two years already.
I was an eLearning developer for 3 years. Used articulate, photoshop, illustrator, and MS Word. Threw in a little bit of css and html here and there, and published courses in a proprietary LMS built entirely by a different department. What I did was 100% development, even though my entire job consisted of using software made by other people that automated a lot of little tasks for me. I had tools at my disposal which freed me up to focus on more abstract/subjective parts of the development process. So I would argue, yea, someone who uses WordPress can be considered a developer, depending on the degree of complexity and level of design choices and where it fits into their overall toolbox. WordPress and the maintenance thereof can be fairly sophisticated depending on how you wield it and how customized you get with it. Ultimately, it's just another tool. That "minimum standard" is not about the tools, it's about how they're used.
It's an opt in currently, but I'm not sure what their upcoming version will include. Personally, I'm thinking it's good how it is now. Grab it if you want, takes like 2 seconds, or don't grab it because you install a shit ton of VM. Win win
That's what I use cgi for. They propose keeping that part. It's also a 1-liner.
Well, I lied last Sunday. There were some snags with documentation. Finishing off the new release of my FEA open source project. It's uploaded to PyPi, docs are building, CI is going, website is updated, tag is made, but I need to announce it. Probably tomorrow... I get to kill support for Python 2 :)
r/learnpython
Aliasing (as was done with threading) works well and avoids unnecessary breakages.
If we're following this metaphor: Doing the laundry has more value in the end than simply washing the clothes. Why wash the clothes by hand when you can use a machine to do it and use that saved time to also do the dishes while you're waiting for the cycle to finish? Manage a household, don't do chores the hard way just to jerk off about knowing how surfactants get grime off polyester blends. Learn how it works and what detergents to use and be able to do the wash by hand if necessary, but utilizing equipment to manage several chores more efficiently at a higher level is not some kind of cheap mindless shortcut. Tedium isn't inherently valuable. Having a working, clean solution is though.
What is this NNTP? Why is it better than Google News? /s
Nope. "The Python core team will not publish or maintain the packages." So if you want to install them per pip, you will have to publish to PyPI and maintain them there first.
Telling you it would be better if you had contributed to open source is pretty BS feedback don't let it get to you. For a long time I attempted to contribute to projects and one of the things that you run into is that your contributions are often not accepted by the community. "Contributions" is really code for "Show Serious Interest In" find a python project and don't worry about contributing, just become very well read about the project its issues and where it is going. If that isn't enough to show you are a self starter then the company you are talking to isn't worth your time. \--for the record I spent most of my career trying to contribute to projects and failing until ultimately becoming a founding member of an Apache project
The first thing their linked reference from Microsoft says is literally "MSI isn’t going to go away".
No, by your logic, while *they* are real programmers, anyone using their library is *not*.
Does it support any kind of authentication? Cookies?
why not just run the library with existing python libs designed to evaluate javascript? [https://pypi.org/project/PyExecJS/](https://pypi.org/project/PyExecJS/)
The author states "Instead of having a pair of functions with a lot of arguments that you should provide to make it work, we have tiny functions with very few arguments that do one thing and do it as fast as possible" Seems like a good alternative to me.
That was the best word I could think of at the time, specifically because the omissions seem definitely intended. "Look, magic, faster requests!" explaining that you got somewhere by magic (and not that you conveniently wrapped a lower level language/library) tends to do the *opposite* of resonate with seasoned programmers.
It's mainly the fact that you practically nowhere explained that this is basically a convenience wrapper around nim's HTTP client. If you did that, and then showed how much faster it was, I would be mildly impressed, because probably no-one has thought to do that before. It could also help explain the very unpythonic interface and maybe even help get people onboard trying to come to a comprimise and improve it, if possible.
They should've done that at the 3.0 change, unfortunately :/
As someone who has spent a good amount of time reading the urllib.urlopen documentation, "Pythonic" ain't everything it is cracked up to be, You seem to like labels.
You can't replace SMTP support without replacing it with something else. Every other language with a standard library has SMTP support; every Internet protocol library for languages that don't has SMTP support. Otherwise, the logo has to go from "Batteries included" to "Some assembly required".
What comes in stdlib should be useful and comprehensive. It shouldn't have holes or gaps that competing languages don't. &gt;Nothing is being replaced. And unless and until this PEP is approved, nothing's being removed either.
A full, real Linux kernel is coming! https://www.theverge.com/2019/5/6/18534687/microsoft-windows-10-linux-kernel-feature
Hell has frozen over... a real Linux kernel will ship with Windows 10 in the future.... https://www.theverge.com/2019/5/6/18534687/microsoft-windows-10-linux-kernel-feature It probably has to do with the latest Stack Overflow survey showing that only 45% of professional developers do their development work on Windows, and this figure has declined every year over the last few years.
There are 3 use cases for Pyodide. Web sites, particularly educational institutions, which cannot afford a compute server for all of their users. Privacy, where you are not allowed to transfer the data to the server, and big data, where the client is large enough to process the files, but there is too much data to transfer to the server.
But, it's still not programming. I can make coffee with a push of a button, but you won't find that "skill" on my resume. And, I can do laundry with slightly more than the push of a button, but that doesn't exactly require 4 years at a university. You can do amazing things with Python despite having no programming skill whatsoever.
If you are interested in learning more about Pyodide, here are 16 related links.
It's been done before. For example, `xreadlines` was added and removed all within python 2, and there was surely a lot more code using that then these ancient libraries dealing with 80's file formats.
FWIW it's a bit odd that `iter()` is listed lower than `next()` when almost every `next()` callsite should be paired with an `iter()`: `next()` does not work on itera*bles*, `iter` returns an itera*tor* from an itera*ble*. Furthermore the second form of `iter` can create an iterator out of a callable, which is quite neat. Also not unlike `getattr`, `next()` can take a default value which it will yield (instead of raising `StopIteration`) when reaching the end of an iterator.
I've only been programming for 3 months so I must forewarn you that my code is absolutely awful but here is my final project: [https://github.com/ParkerShamblin/checkers-pygame/blob/master/checkers.py](https://github.com/ParkerShamblin/checkers-pygame/blob/master/checkers.py)
But they use Py2 right?
I seriously love when it when people make claims and they just get pissed and downvote out of spite. git gud
The majority of Python programmers rarely use C or don’t know it at all, so it’d make more sense to ask this on a C related subreddit. And when you do either format the code example correctly in your post or put it on pastebin or gist and link to it.
I don't get it. You want someone to code your assignment for you? Why do you learn C if you don't care to actually learn it?
Interesting. I would probably use Flask for something that, but I can see the advantage of not relying on any external libraries.
But this means that the user is prompted to install Python rather than it just failing if they attempted to call python.exe or python3.exe when Python is not installed.
This. I'm pretty sure there's a good rationale not to provide a module which makes unittest code PEP-8-friendly, but I've never heard it.
It's not end of the world though. If those modules are needed you or someone else can take them out of python and publish on pypi. Perhaps even can also include bugfixes. BTW: this is still a draft, you can contact the author about your concerns. Seems like some people convinced him to exclude some packages from the list.
Smtpd is not an SMTP _client_, but an SMTP _server_. Having an SMTP server in the standard library is relatively unusual (I know of no other language with an SMTP server in its standard library), although it's still something I've sometimes found useful - being able to instantly spin up an SMTP server for testing purposes is very useful. Their recommendation, for people who need this, is to use https://aiosmtpd.readthedocs.io/en/latest/, which is more modern. This is probably for the best. smtpd is a pain to extend.
Right, but did you read the README where they basically admit to not knowing why it's faster and a whole heap of things? It's fine to ask the question. It's fine to give an answer to the question about what the secret sauce in their sandwich is, but it's not very cool to shout "Liar" and run off.
Yay the 2 to 3 backwards compatibility breaking has reared its ugly head again!
And in some (or many, depending on how you look at it) cases trying to get packages installed from PyPI is like bashing your head against a brick wall. Especially in virus phobic enterprises. TLDR not everyone can use PyPI
AFAIK it was done this way (store+link vs bundled) to avoid being stuck with the same release schedule of the OS, i.e. people wouldn't be stuck with whatever old version was available at the time things were built. If there's a new CPython release, it could be built and pushed right away. See also macOS, which still ships Python 2.7 and a pretty old version of Ruby, such that everyone has to go get it via homebrew for something reasonable.
The PEP originally did actually advocate for removing colorsys, but that was changed once people pointed out how it’s still useful.
I'm running insider builds of windows and got hit by this the other day when installing python on a new machine. I spent a good half hour trying to work out why instead of running my installed copy of python, the Microsoft store opens. Im all for this, in concept. But, at least in the last build, the implimentation is annoying af
But that requires effort...
https://en.m.wikibooks.org/wiki/Python_Programming Good free tutorial for getting started.
`assert` as a statement does provide some advantages, as this [answer](https://stackoverflow.com/a/13390646/9809094) points out: it prevents shadowing and allows the second argument to only be executed when the assertion fails. I'd add one more advantage: making assert a statement allows the interpreter to skip execution of the statement altogether. Some people in the Stack Overflow question above suggest that could be special-cased, but I suspect that would make for a messy interpretation.
Gevent is a perfect way to use asynchronous I/O in Python. I cannot comprehend why it is not more popular. For some reason people insist that writing asynchronous I/O code should be an explicit chore. Golang and gevent got it right.
I read the readme and the code itself to find out how it was faster, because it certainly wasn't explained anywhere.
The package itself is awesome, but that database of file type header itself is super useful! Did you compile it yourself?
I definitely agree these probably shouldn't be stdlib, but I'm curious, will they be moved to PyPI? I guess nothing stops anyone from re-uploading them manually to 3rd party (maybe licenses), but it's strange that a lot of these have no replacement. Should they not just become normal external packages you can install?
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I guess it's really a cost vs reward thing. Yes, installing from pip is easy, but it definitely isn't as easy as having it already included. Every single package you include increases the size of every single Python installation out there, which for smaller embedded devices can be an issue. So really, I think the best way to evaluate all stdlibs would be to maybe do a measure of `{how often they are used}/{how big the library is}`. With a big enough repo sample (github for example), it should be easy to calculate that for every stdlib.
Just this morning I used imghdr in some brand new code. &amp;#x200B; Batteries were included for a purpose, and they should be replaced when needed, not removed. &amp;#x200B; IMO any breaking changes must be kept for Python 4.
Ahh, ballot stuffing... glad to see they’re still teaching political science and basic psychology these days.
This is very related to python /s
I appreciate your enthusiasm for sarcasm, but to become a master you mustn't use /s. *I'm a human being, and this action was performed manually.*
Thank you bot, you are very helpful.
&gt; * if someone had manually modified their own PATH, they *may* see some interference (but we [Microsoft] decided this was an acceptable risk) Oh god. Plenty of **noobs** out there have been shown how to do this for their python install after they didn't tick "add me to Path" in the installer. Fuck them, I guess.
Wedging a Vue.js dev env to serve from a Pyramid dev env. &amp;#x200B; So mostly writing JavaScript, but I've got a hierarchical model in Pyramid that uses URL Traversal and I'm looking at shipping sub-trees of that model to a SPA. Had a look around at URL Traversal routing in JavaScript land and it looks like there is only [angular-traversal](https://www.npmjs.com/package/angular-traversal?activeTab=dependencies) that does URL Traversal, so I'm going to take a stab at porting something similar to pyramid.traversal to a vue.js router. I've got [this vue.js router tutorial](https://vueschool.io/articles/vuejs-tutorials/creating-your-own-router/) that should walk me through the vue-side, but I have to think about how to have a registry on the JavaScript side ... likely just bake the Python Interface dotted names of an object as an attribute in the JSON export of the model and have a simple hard-coded look-up from interface name to Vue component? &amp;#x200B; Just starting to learn Vue so I'll see how it goes ...
Ignore that comment. It would be "better" because it would make it more convenient for them to read some of your code - but that also means they aren't really willing to put much effort into their hiring. There's also this myth that the number of open source contributions is strongly correlated with proficiency or quality. But it's not, and an employer buying into it would actually make me doubt a little whether I would want to work there (though it is of course possible that they are looking for active open source developers for other reasons, e.g. because their operation has close ties with the open source world, or maybe their entire business revolves around building open source software). In most cases, "open source contributions" is an attempt at short-cutting the process of judging a candidate's skills and qualities - "open source → check!". It doesn't work, and employers using this often suck at hiring. A portfolio is a good thing to have, and you should have nontrivial code samples ready, so if the criticism you get is that you're not coming across as someone who has a lot of experience writing code because you didn't show any, then that would be valid. Anyway, if you're looking for something to "contribute" to, the go-to answer is always "make something that solves a problem that *you* have". This can be a patch or bugfix for an existing application, but it can also be an improvement to a library you use in one of your projects, it can be something you built from scratch, etc. In other words, don't contribute for the sake of contributing; make stuff because it makes your life better, or at least teaches you something new. In fact, avoid the word "contribute" entirely; it signals misunderstanding of open source economics. People don't "contribute" to open source projects, really; they use them, they adapt them to their needs, sometimes they share their adaptations with the public, and if those adaptations are useful to the general public, others will merge them into their forks (including a de-facto "upstream"). Open source is not a philanthropist activity, it is just as selfish as proprietary development - people make stuff because it benefits them (or because it benefits someone who pays them for it); the choice between sharing or limiting is mainly based on whether you are more interested in free labor (open source) or in exerting power over users through restrictive licensing (proprietary). And often, the motivation is often just "I don't really care either way, and it's not like I'm interested in suing anyone over this anyway, so might as well slap an MIT license on it and call it a day". The latter is what 95% of my own open source activity amounts to.
If you want Linux on the desktop, let Microsoft take care of it.
None of these removals bother me all that much, but the crypto one is a little annoying. I get it that there's obnoxious notification requirement issues involved with even using a crypto library (Sigh), but it would be nice to see a standard API for ciphers like there is for hashes, and at the very least the common AES modes and libsodium included. Probably too much trouble though.
Can confirm. Am noob.
Ikr How can I add views count to the website?
You can use the new string format in &gt;3.2, but you have to define the style=‘}’ which is awkward
I am not that good in programming so no need to grant me commit access. I would rather send pull requests each time I do something. Thanks anyways :)
I remember creating a "curry" decorator, which would let you instead of writing something like `f(x,y,z)` write `f(x)(y)(z)()`. Obviously I never needed that, but it was fun nonetheless.
&gt; &gt; did you read the README where they basically admit to not knowing why it's faster and a whole heap of things? &gt; I read the readme and the code itself to find out how it was faster, because it certainly wasn't explained anywhere. OMG THE POINT IS THEY DON'T KNOW WHY IT'S FASTER
IMHO it would be easier to just post the link to that website here on Reddit
I'm not sure if what I'm going to say makes sense, but I think those libraries should be published separately, and a final step before total deprecation should be showing a message: """This modules has been removed from python standard library. It is now available using \`pip install xxx\`"""" This would make the transition extremely easy. And most of the parties would be happy. I want to make emphasis on the message shown, that would make everyone's life easy right?
Thanks for the reply, and I appreciate the advice. &amp;#x200B; However, I think they said this just to show the ability to understand code written by others, and to make changes that don't break other parts of the code. I have a few smaller programs I have written in python on my portfolio, and they said they really like the way I have structured and organized the code, and it is well written, but they would like to see examples of larger projects. &amp;#x200B; I regularly write programs that solve my own problems, I just very rarely use python for this. I love python, however I mainly use it for web scraping, and I don't see much point of putting that code on my github, because I think it would only be useful to myself. For other small scripts, I usually use sh, because of portability on Linux OS's, and for larger programs I try to use the language that best fits the problem (which is often concurrent networking, so I tend to use a lot of go). &amp;#x200B; Thanks for the advice, I guess I can just try to write something new that solves a problem I have.
Backwards compatibility can also hurt a language, e.g. Java vs C#, with the latter not being backwards compatible. If Java made a non compatible release, getting rid of stuff like type erasure in generics, it could be a lot better. So breaking changes shouldn't be made for purely aesthetic reasons, but one should not shy away from them when it concerns bad design decisions or things that keep the language back. For example, if they could get rid of the GIL, but only with breaking changes, that'd trump backward compatibility in my eyes. TL;DR: try to be as compatible as possible but don't shy away from breaking things that are necessary for compatibility only
They didn't want to do that because they don't want to maintain them. They will be available to fork for those that do.
Using electricity made by someone else, on computers made by someone else, in factories made by someone else, ........... Using fire stolen by someone else. BUILD EVERYTHING YOURSELF
It encourages people to use pytest rather unittest. That's an unintended consequence, but a terrific one.
hell yes!
That depends on how your friend’s teacher is measuring view counts. If it’s a dumb count of hits then you can use **requests.get** and a **while** loop to make as many hits as you want. Unless your teacher is particularly ill-informed about the ethical viewpoint of the young, though, they’ll be ignoring multiple hits from the same IP address as a minimum filter on such cheating. If they’re reasonable savvy they’ll be docking any student for whom such activity appears.
/r/learnpython and read the sidebar.
Wow, that was quick. `imghdr` is the only one is am using in running code. Will it just be a matter of reinstalling it with pip?
Okay, so requests.get does make a view count. I will ask how savvy the teacher is
Very cool, there were many things I did not know!
Any robot worth a dime can kill people. If it can't kill people it is mostly a toy. Maybe a very smart toy. But still a toy. Robots are made of metal and metal is heavy
What about my english
How can I change the ip to not suspect the teacher or the website?
i mean it was more work for Microsoft to implement this instead of shipping windows with python
Yes. Specifically logging and unittest.
I'm glad it's useful for you. How is the numerical python book? Would you recommend it?
kk :)
Where are your links?
I did this course several years ago and it was very good: [An Introduction to Interactive Programming in Python](https://www.coursera.org/learn/interactive-python-1)
That's honestly not too much trouble, you can still fork the original packages.
and when python 4's out, people will say "any breaking changes must be kept for python 5"
That's not my argument. I've got code that does classification despite adding no value whatsoever to the library. That's not programming. It potentially solves a problem, yes. But, I did no programming. You COULD do programming with the assistance of this library, but look at what you can do without actually programming.
I disagree that optparse should be kept. It's only really used today to keep compatibility with Python 2.6; which is only a really problem here if you are trying to support the latest python 3, whilst still supporting 2.6 argparse superscedes this, is far easier to use, and for the most part can have the same interface; the parts where it can be written multiple ways, the new way is clearer. This is targeting 3.8 aimed just before 2.7 EOL, with warnings in 3.9 and removal in 3.10; thus will continue working up to 3.10. I cannot see a valid reason to have a code base aiming to be compatible with both 3.10 and 2.6 Good news is if they are wanting to support 3.10 and 2.7, (again, why?) argparse will work with minimal changes. If they are using a specific python version due to OS and/distribution they have nothing at all to worry about. It will still work until they update to 3.10. Please add this obsolete module to the deprecation list.
Would be nice to see the pro/con between gunicorn/ngnix.
i'm scared. i started learning programing 2 weeks ago and I don't know how I installed python. But at least, thanks to this post, I'll know where to look if I run into issues.
The problem I had was that last time I tried, the solution was contagious. If there was other libs that use the %s format, those would break.
It was posted 14 hours earlier... [https://www.reddit.com/r/Python/comments/brbzv5/python\_builtins\_worth\_learning/](https://www.reddit.com/r/Python/comments/brbzv5/python_builtins_worth_learning/)
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Use a VPN, hire a botnet, buy an ISP... If cheating on this project were easy, it would be easy to game Google Analytics, which is most likely what the teacher is using... it is not easy to do so.
What do you mean by cheating the google analytics?
At this point I’ve got to direct you to a search engine or Wikipedia... GA is the service your teacher is likely using to gather the metrics on the site. It works very hard to ignore unscrupulous attempts to game those metrics, so odds are you’re not going to succeed in doing so. Instead you and your friend should focus on adhering to the spirit of the exercise, rather than hamdistedly trying to game the outcome.
Too easy for what? Why would you want to make something more difficult than necessary? If you want to learn to make compilers, then obviously downloading and running a compiler isn't gonna teach you much. If you just want to compile some C code, writing your own C compiler would be a tremendous waste of time.
As much as I'd like to keep using pydev, it's the Java requirement that's killing it for me
[removed]
At this point, it’s just my interest in coding this. I would like to understand how to do this
Yes, but when I got home. I didn't had smartphone at that moment. Bro.
Actually, reason I posted this is because my pen stopped working. At my school they still write code on a paper....
may be a jupyter config. it doesn't seem to know about your venv
The point is you can’t using a single machine. You need multiple IP addresses working in parallel, behaving like organic human traffic. The easiest way to do that is to pay or otherwise incentivize organic humans with machines elsewhere to browse to the site for you. The _best_ way to do this is to have engaging content on your site. The second best is to manipulate them with clickbait and social sharing, the third is to pay them. Another alternative is to get their machines to do it without their knowledge or consent. At this point you’ve probably broken some laws. Finally there’s renting a large number of machines and scripting them to pretend to be organic humans. This is neither cheap or easy, and isvery hard to do without revealing the artificial nature of the views.
hello everyone, i don't attend to programming school, but I remember some of my friends use some graphs to break down project into small parts, could somebody provide me a some help how to use it and find it ? please ;)
Mm okay
I'm interested to know why the status classifier carries so much weight, for example Flask was in [Beta until February](https://github.com/pallets/flask/commit/af32ea0b9449a2f4aeb858f546cdfea7254342fb) last year, yet it was heavily used in production. Wouldn't it be better to judge the production readiness based on the project, code and usage rather than the classifier? In Quart I've left it in beta as I may change the API, and I don't want to give the wrong expectations. It is used in production in my systems, and others I've heard about though, so I'd consider it production ready.
This isn't sarcasm, it's just a test to test a bot /s
Ah I see. Yeah I agree, would have been good to make it shipped by default.
This guy gets it
That's for sure making me want to watch the video ...
You sure can: [https://www.plugin-dev.com/project/bashsupport/](https://www.plugin-dev.com/project/bashsupport/)
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Yes, you can. Just install the BashSupport plugin.
It depends on what you're looking for. I strongly recommend it, because it gets into several domains where I wanted to refresh my knowledge (calculus, differential equations &amp; signal processing, for starters). The code is straightforward &amp; error-free. I bought the original edition a few years ago, for comparison. The illustrations are very useful - the author uses both matplotlib &amp; seaborn. The only downside is my inability, thus far, to install the FEniCS library that the book uses to demo some partial differential equation techniques.