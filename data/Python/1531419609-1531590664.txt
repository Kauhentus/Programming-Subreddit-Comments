If he had listned to the community python would be a clusterfuck. His vision and guidance has brought us here, and could definitely have brought us through the next decade. There is absolutely nothing broken about python with assignment expressions. 
Arguments like mine *won't die* because the proposal as accepted is just not good, and a large number of people agree with me. You don't seem to understand that people don't just drop an opinion because someone they disagree with "addressed it". I disagree that we can't resolve these issues, and I disagree that the PEP properly addressed them. This whole thing is so toxic because folks like you don't seem to understand that a lot of people genuinely and strongly dislike this syntax, both in form and scope. You cannot expect us to change our opinion just because you disagree. We have tried to offer compromises, and they were rejected. At that point, we are not the ones arguing in bad faith.
Because whatever the resolution, it's a new rule that we all need to understand.
I also appreciated their argument for `as` can look like `and`, and so not very careful reading of `if f(x) as y` can lead someone to parse it as `if f(x) and y`
Yup, not editable. Just thought I might be able to head off some of the arguments at the pass.
Those two, bit shifting, depending on how it is used, indicing / slicing, and basically every mathematical operator that is overridden on non builtin objects, because of the "right hand side" method possibility. As in you could be doing `NoAddingType() + RightAddingType()` and it's actually `RightAddingType() + NoAddingType()` and the lack of adding is suddenly silenced. The first is used in a lot of mathematical libraries, depending on what you do with them. The second is done all over the place really, how common it is to indice / slice with complex expressions is another question, and the third is done in a lot of math libraries and libraries meant to extend functionality of other libraries which couldn't get pushed upstream.
Everything is an object in Python.
I don't get this mindset. Languages change. New words, new syntax, new libraries, all of it changes version to version. How is this literally any different than when "yield" was introduced, or when await/async was introduced? It's like y'all hate that new versions come out.
Very true. But it could be adjusted if it was an object and the pattern would still work.
Okay. I think that's a little beyond my understanding.
I also would have loved to use as, but why it couldn't be done has been beaten like a dead horse.
Can you elaborate on what you mean by "just objects" then?
Yup still works. It's not great at live data, it's smallest increment is 1min but for historical data and backtesting it works great. 
Check out this stakeoverflow. It looks like your best solution is just to use nodemon. https://stackoverflow.com/questions/49355010/how-do-i-watch-python-source-code-files-and-restart-when-i-save
I guess I meant as in what an Object is in Javascript. With key-value pairs assigned to it. But now I feel like maybe I am mistaken there as well?
I thoroughly disagree about it making it more difficult to reason about the code. Maybe for the first week, sure, but then we'll all be used to seeing it. We already have lots of things with hidden side effects like `with open(...) as foo`. If you weren't familiar with that syntax, and with `open()`'s semantics in particular, would you have guessed that there's a `finally: close()` in there afterward? To me it appears like just another way to write `foo = open(...)`, when that's not it at all. You can't tell that at a glance, though. And yet, we all love `with open()` and use it idiomatically because context managers are wonderful things, non-local side effects and all. I don't think PEP 572 makes code any less readable than context managers have. To the contrary, I think they both do a great job of letting us concisely express _intent_, which is a good thing, and I think we'll all come to love assignment expressions.
JavaScript objects are basically just key-value mappings. Python objects are a bit more complicated than that. In a sense, Python dictionaries are similar to JavaScript objects, but Python draws a more defined line between the dictionary data structure, that is, a key-value mapping, and an object, that is, a combination of data and code that operates on it.
Okay I’ll have to do more research on that. Thanks so much for helping.
Disagree. It's an opinion, but `if this != None` is not more readable than `if something := this`.
But the only reason that they said it could not be done is because they had such an over-broad scope. If they had instead of allowing it globally *just* allowed it in if, while, and ternaries, then it would have been fine.
The reason why async confused me in Python is because * you have to manage the event loop, which I got over because with this it allows me to have multiple event loops across OS threads/processes * coroutine objects aren't Tasks/Futures. In nearly every other language I know, a coroutine function returns a task/future (or in JS, named a Promise, in JQuery, named a Defferred/Promise). This allows a mix of asynchonous coding styles (async/await, callback, chaining across scope), but in Python the second is nuetered (you can make tasks out of coroutine objects, but you have to await on the object, and any callback result is literally lost), and the third just can't be mixed at all. That puts extremely arbitrary limits on code use. Honestly, I think an extremely thin wrapper around asyncio would solve this problem, and fuck it I'm setting out to make it.
&gt;It adds side effects to otherwise side effect free expressions. You have to explicitly add the side effect. It is not like expressiosn which didn't have side effects before suddenly gets them. What you are saying seems to me like saying the print function is bad because it adds side effects to otherwise side effect free expressions. It does, but that is also the entire point of it.
First of all, it should be `if this is not None`. Second, you need additional context to know if `if something := this` makes sense, and regardless, `if this as something` would have been more consistent with the rest of the language.
Because you don't like async stuff at all or because you don't like the implementation? Implementation I can understand. But at all-- asynchronous code is a necessary thing to learn in many cases.
I am sticking that quote to my office door. Thanks.
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I would not think that indexing is necessarily a right-to-left operation, nor would I think bit-shifting is. That might be because I am used to it though. I would think of these as "from x, grab y" and "shift x by y". The former seems a bit shaky to me though. The mathematical operators is definitely true, though. So thanks for that one. So the list that I would agree with are: 1. ternary 2. conditional in comprehension 3. right-side operators 4. maybe indexing/slicing
From PEP 572. Current: if self._is_special: ans = self._check_nans(context=context) if ans: return ans "Improved": if self._is_special and (ans := self._check_nans(context=context)): return ans For me the issue was with the PEP, not the functionality. If you have to lie or delude yourself in order to promote an idea it's probably a bad idea.
That's the only thing mentioned in the PEP, but the discussion on as has lasted *years*, since the initial proposal. As I mentioned in another comment, &gt; They considered as but it was &gt; * potentially confusing in some cases (context managers and exceptions) &gt; * hard to parse in those cases &gt; * hard to decide precedence in those case &gt; * if they all said "okay, remove those cases", it introduces arbitrary limitations on that syntax. If you call all of those non-problems, someone would have been very quick to make an implementation-example fork, like Guido did with `:=`. But I haven't seen such anywhere.
1 min is fine for my live trading purposes for now, are you live trading with it? I'm attempting to backtest with zipline and trade through IB with zipline live. I'm trying to make it such that any algorithms I write are as compatible as possible between the two. I appreciate all the guidance you can give me. 
A sign of bad design is that it has to be propped up with lots of documentation. Sounds like documentation can't even salvage ````asyncio````.
It is necessary and I am huge coroutines, however as it is now it's just a disaster. Coroutines are tacked on to generators which is a hack. Once you use async it ripples through entire codebase if not being careful. This makes using async properly very hard. Greenlet nailed it making python simpler. Asyncio made python more complex. By the way pep mentioned in mailing list also adds complexity. I love python for it's simple and readable syntax but they are working hard to change that. It's as if lang designers forgot all about zen of python.
It definitely is "from x grab y", but I've seen my fair share code that is "from x, grab &lt;extremely complicated expression&gt;, then grab &lt;other extremely complicated expression&gt;", which is rtl, then go one step out, in another place, rtl, one step out, ltr. Which is what assignment expressions do, as I mentioned on the PyLint issue you made. Sure utilizing that won't be common everywhere, but I can already think of at least 7 places in one of my projects where not only would it make more sense (because of complicated assignment chaining), but because a faster opcode is used it would even be just that slight amount more optimized.
&gt;You have to explicitly add the side effect. It is not like expressiosn which didn't have side effects before suddenly gets them. It's exactly like that if you work on large, old codebases which have had many developers working on them. &gt;What you are saying seems to me like saying the print function is bad because it adds side effects No, I'm saying it comes at a high and usually underestimated cost. Actually on a lot of large code bases the print statement specifically has caused issues for me. I don't want it gone from the language but I have eliminated it from many projects I've worked on.
If I may ask how does greenlet do it? I'm only familiar with gevent, twisted, tornado (albeit that's limited to web, mostly), and of course asyncio (dabbling in some of the wrappers like trio). But other than that, I [definitely agree](https://www.reddit.com/r/python/comments/8yapie/_/e29qwjz)
I read the PEP, and in that part, unless I misunderstand, they said that in the context of making a *global* `as` operator. I am talking about only allowing it in if, while, and ternary.
&gt; _gaps. When this function is called it will have two objects passed to it. While I'm executing this function, whatever the first object was will be referred to with the name my_word, and the second object will be referred to with the n I have been taking the MIT online class and spent lots of time on this. I understand the user functions enough to build them myself and I have built the program on my own to do everything other than the hints function. However, when I looked at a solution online with the hints part it confuses me because I do not see where the computer knows what "my_word" or "other_word" is in something like below. possible_matches = '' for word in wordlist: if match_with_gaps(my_word, word): possible_matches += word + " "
Just look at how it turned out for perl6! 😢😢😢
After two years of fiddling with Python off and on I finally made my first script that actually does anything productive. I am in the market to buy a house with an attached apartment that will allow a child or parent to live in it. The house manufacturer that sells these where I am has an absolutely terrible website to navigate. I used the Requests library to pull the specs for all of their houses, and I sorted/filtered/exported the information with Pandas. I feel very accomplished.
Making a GUI program for my chemistry research using Tkinter! I'm not too experienced with Python, but having a C++ background helps. 
Maybe it's senility or an attempt to justify one's own existence by attempting to solve problems that don't exist.
&gt; First, ensure that you have checked in a requirements.txt or Pipfile.lock file inside of repositories that have Python code. So no PyProject.toml / setup.cfg / setup.py parsing? All of the above can also be parsed for vulnerabilities. The latter of course would require mocking every import / function call (and maybe using the ast parser, rarely), but lots of projects use the three I mentioned rather than Pipfiles or requirements.txt s.
I have nothing against `%`, but I like there being only one way to do such a common operation, and `format()` seems superior to me. But then `logging` still uses the `%s` syntax, making it impossible to use `format` consistently in my code.
But what about for loops? What about comprehensions? What about these or ternaries in context managers / exception handling? Point being, I can't think of any operator in Python other than assignment operators that can't be used globally (minus in import statements). If you do it your way, people will see it as an arbitrary limitation and then bug them to make it global, which, they can't do for as, because of the things I mentioned.
All async people are crazy, they write a new library every year and abandon the old one expecting different outcomes.
I think that’s quite subjective. 
 if self._is_special and (ans := self._check_nans(context=context)): return ans Or maybe he's going senile?
But you *can* use the `format` syntax in logging, as of Py3.2. &gt; logging.Formatter.__init__(fmt=None, datefmt=None, style='%')¶ If there is no message format string, the default is to use the raw message. If there is no date format string, the default date format is: &gt; %Y-%m-%d %H:%M:%S &gt; with the milliseconds tacked on at the end. The style is one of %, ‘{‘ or ‘$’. If one of these is not specified, then ‘%’ will be used. If the style is ‘%’, the message format string uses %(&lt;dictionary key&gt;)s styled string substitution; the possible keys are documented in LogRecord attributes. If the style is ‘{‘, the message format string is assumed to be compatible with str.format() (using keyword arguments), while if the style is ‘$’ then the message format string should conform to what is expected by string.Template.substitute(). &gt; *Changed in version 3.2*: Added the styleparameter.
I’ve been using Python daily for three years, and previously spent a lot of time working with `Thread`s and `Task`s in C#, but I cannot for the life of me make sense of asyncio. It should be deprecated and replaced, accepting that it’s another failed attempt in Python’s pursuit of asynchronicity.
It's not two lines into one, check out this bad boy: if self._is_special and (ans := self._check_nans(context=context)): return ans That's not a contrived example to make it look bad, that's from the PEP.
But it isn't a lie/delusion to everyone. People have opinions on whether or not is is improved. Some think the latter is an improvement, others don't. I don't, but I do think other examples are improvements (also listed in the PEP). But some people do.
PEP 572 [addresses this and other alternatives directly](https://www.python.org/dev/peps/pep-0572/#alternative-spellings) under "Rejected alternative proposals".
Yeah, I think we'll find that it's mostly only used in a few scenarios that could have been supported with a clearer and simpler syntax and that supporting assignment expressions everywhere wasn't all that useful.
FWIW I don't think you should change your opinion. But I also don't think you should force it / be against it in other people's projects who do like the syntax.
Yeah, the one use case I see coming up a lot was the regex matching in a large group of `if` blocks, where assignment in the expression actually does make the code more readable, but that could have been easily solved by using `as` just for `if` and `while`. 
Why not add semicolons and curly braces instead? That way any code can easily be written on one line, not just `if` statements.
Already posted, not stepping down, "permanent vacation" (indefinite). https://www.reddit.com/r/python/comments/8yapie/_/
Archer's input
Wow thank you
Wow thank you so much! Didn't know that Nodemon was so easy for python
It's different because (a) yield/await/async doesn't change the rules of other constructs (b) yield allowed something new to be done (coroutines). Languages do change, but a huge part of the attraction of python is that it's a simple language that historically was very conservative about adding features. Python 3 has been an accelerating ride of dubious new features. The developers treat it like a research language. 
"I would like to remove myself entirely from the decision process." That's stepping down. Why not call it what it is?
I don't like `format()` because it can't do this: &gt;&gt;&gt; message = "invalid number: %d" &gt;&gt;&gt; message %= 123 &gt;&gt;&gt; message 'invalid number: 123' With format it's uglier: &gt;&gt;&gt; message = "invalid number: {}" &gt;&gt;&gt; message = message.format(123) &gt;&gt;&gt; message 'invalid number: 123'
Yeah, I still don't think it's a good argument though. We already use `as` in import statements and exception statements, so `as` *already* has different meaning in the language depending on context. import foo as bar try: pass except Exception as e: pass You can even have them on the same line except Exception as e: import foo as bar If the only argument is that it might be confusing in `with` statements, that seems far superior than having it be confusing *everywhere* with the current syntax. And there aren't really any use cases where using it in a `with` statement would be preferable anyway. 
&gt; Note that there's still the CoC -- if you don't like that document your only option might be to leave this group voluntarily. Perhaps there are issues to decide like when should someone be kicked out (this could be banning people from python-dev or python-ideas too, since those are also covered by the CoC). &gt; &gt; Was there drama around the Code of Conduct?
Modern day equivalent of moving to Florida... or Tuscany. 😉
Guido is the "Benevolent Dictator For Life". Some people are saying that you can't actually step down from that. I don't know why, but this distinction actually matters to some people; I was asked to remobe this due to it being inaccurate. I obviously didn't remove it, but I thought a clarification from the link would fix the issue.
You can do sweet stuff like map("thing {}".format, range(5)) though
did Guido also work on Perl core?
You must have not followed python-dev or any of the other mailing lists. People have been arguing about this for months.
Its saved in a json but yes when it's imported it's in a python list that contains dictionaries. I'm looking up filter, map, and reduce now and it seems like what I was initially looking for. The others might be right eventually though. I should probably turn it into an actual database.
I don't think it is a case of 'live and let live' simply because you will come across other people who will use it, potentially to your own distaste. 
I tend to write it much too modular, with too many layers of functions calling each other, making refactoring a PITA later on. Definitely loving TDD though, I expect to be slower for a while as I get used to it but combined with linting I'm writing much better code. 
&gt; It's not just two lines into one, check out this bad boy: Right, but why is : if self._is_special and (ans := self._check_nans(context=context)): return ans better than : if self._is_special: ans=self._check_nans(context=context) if ans: return ans Which is 2 lines longer, the same number of keystrokes (~80 characters), and is arguably cognitively simpler since you can just read it unambiguously top to bottom instead of unpacking a (mandatory) set of parenthesis for determining precedence! (i.e. hmm, is this short circuiting? ok, so the first thing that happens on this line is that the bit in the middle gets assigned to a variable), etc. I mean if you are impressed by this example, then why not just add a semi-colon so that people can smash even more lines together? If we try really hard, we can make the entire language look like an obfuscated C contest. Again, this is an entirely brand NEW OPERATOR in the base language, so the scope of this change is huge. Whereas the purported benefits put forth by proponents have all been trivial, resulting in minimal savings in line count (mostly just by mashing things into one line and typically making the flow harder to read).
&gt;Now that PEP 572 is done, I don't ever want to have to fight so hard for a PEP and find that so many people despise my decisions. "PEP 572 was the last thing worth fighting for" -Guido van Rossum
In Python, a['b'] and a.b are clearly separated. JS mixes them up. If, for example, a is a dictionary, a['keys'] is the entry indexed by the string 'keys' (which may or may not exist) while a.keys is a dictionary method that returns all the keys in the dictionary. Most python object types just do not support the [] indexing operator. The list object uses it for numeric indexing only.
&gt;We already have lots of things with hidden side effects like with open(...) as foo The whole point of context managers is to *minimize* and *isolate* necessary side effects to an indented block. Before you had to explicitly open and close a file and it was very easy to not see that an opened file had not been closed (i.e. that you had caused an unwanted side effect). With a context manager it's literally impossible not to close the file. PEP 572 munges side effect free code (that is often complicated enough) with code that has side effects. It won't always cause a problem, but it often will, especially when you have complex expressions.
I love this library! This combined with Jupyter makes engineering calculations fun!
I still can't get over indentation using spaces.
Maybe you should see [Trio](https://trio.readthedocs.org) instead of reinventing stuff on top of asyncio's broken stack.
Maybe you should try [Trio](https://trio.readthedocs.org) - it is significantly easier to understand than asyncio.
Someone will need to take over, will it be Raymond?
This is literally semantics. Your cases are ugly but they're still semantically correct if you wanted the operator to use `as`. Linters exist to enforce clean code.
That's how I feel about using `/` as a path-joiner. Makes literally no sense to me, but I see it in code occasionally. 
You can't be BDFL if you don't take the Linus approach.
What part of "Dictator" did he miss?
I've followed python for around 20 years now. It hasn't been consistently my main language, but I've always had a tremendous respect for both the language and the excellent community of developers built around it. I hope that everyone realizes what a tremendous boon has been the gentle and wise guidance of Guido at the helm. The language has developed artfully and productively, and the community has both grown and kept it's character. There are very few open source projects with processes as excellent or product as clean and useful. The style of python is a product of Guido's aesthetic sense and his ability to communicate straightforwardly, knowledgeably, and artfully, with a large and diverse community. Guido has done an excellent job. I appreciate his work deeply. I hope and expect that others will pick up where he left off. I also hope and expect that the culture he had a big hand in developing is maintained and cherished. Python is one of the great open source projects and we owe a lot of that to Guido. Thank you, Guido. Thank you.
I find the first piece of code not very self-explanatory because I expect it to be remainder, not formatting. The second one is longer, but it's crystal clear what is happening.
I wish Guido well, even though its sad to see him step down. I feel his main problem (and also why he is awesome) is that he cares too much. He is more of the B in BDFL, than the D. I know many times i feel he should use the D, and yet the tries to be B.... Linus wont have this issue, cause he is more of a D than a B.. but it brings less issues in decision making
 from __future__ import barry_as_FLUFL
Esentially what it means is 'python dicts are objects but dict *keys* are not *properties*'
&gt; Strongly disagree, static typing (strong typing is not static typing) in Python has been on Guido's mind for a over a decade. Just because it has been on Guido's mind does not in-and-of-itself make it immediately a good idea (e.g. see the PEP 572 train wreck). &gt; It's disingenuous to claim static typing isn't Pythonic. Huh? It's fundamentally a duck-typed language. One of the PRIMARY reasons to use python over alternatives is because this flexibility increases readability, conciseness (i.e. reduces boilerplate associated with typing, rigid interfaces, etc.) allows you to right code faster, etc. at the potential cost of catching type-errors at runtime. Everything in life is about tradeoffs, and the trick is always picking the correct tool for the job given those tradeoffs. So if you are sitting there thinking *"but gee, my project could really benefit from strong typing"*, then python is likely the wrong tool for that job. Similarly, if you are sitting there thinking *"gee this boilerplate is tedious and annoying, I just want to throw together a quick script without all this bullshit formalism"*, then Java is probably the wrong tool for the job, etc. etc. Sure you can jerry-rig typing, or finals, or whatever your heart desires back into the language, but then you've added ALL of that complexity without many of the base-benefits that come with choosing a language designed around that feature-set from the ground up, where it is mandatory (e.g. the standard libraries probably don't adhere to the typing, inheritance, whatever philosophy you have invented... and even if it was standardized, the option to duck-type is still there, right?) &gt; So please stop gate keeping on how to use Python's flexibility. What? I'm not the gatekeeper of anything. Stop confusing criticism with gatekeeping. Other people *are* allowed to point out why your idea is shit.
Check out /r/learnpython if you haven't already. Python's `dict` is more closely related to JS [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), in that you can use other types than strings as keys, and there is no namespace pollution. Sometimes you do want to use a `dict` where you would use an`object` in JavaScript, but other times you'll want to write a class instead. As a simple rule of thumb while you are learning, if it ever makes sense to do `in_js_this_was_an_object[a_variable]`, you probably want to use a `dict`, and otherwise you probably want to write a class or use another datastructure.
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I don't use it for live trading per se. So if I add a symbol to my algorithm at 1200, I need those previous 2.5 hours of data. So I use Google to get that. Then I use my brokerage's API for the live data for the rest of the day that appennds to the Dataframe. 
There are steady improvements being made to it along with a revamp of docs for 3.8 along with performance improvements.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. [Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
I predict a Python Version 3.Lancaster splitting off from a Version 3.York, followed by years of PEP disputes.
There was a PR to convert stdlib to use PEP 572 which is a good case study : https://github.com/python/cpython/pull/8122
Guess its time to learn GO :(
That's (unfortunately) just talking about the format string, IIRC - log messages still have to use the `%`-style syntax.
Well, now it's just a cute nickname :)
I have added a short section on the traceback. When I have time I will see if I can improve it to be more focused into always catching specific errors.
But print was just an example. Every single function defined in python can potentially do side effects. I love functional programming, and I try to write pure functions. But when programming in python the language already gives you zero help in keeping track of side effects. So adding assignment expressions isn't taking away anything you had before. 
Do you mean in comparison to using os.path.join()? Because I can think of a couple at least semi-valid arguments. But my biggest would probably be "because that's what's already in the codebase." I don't see a huge benefit to using '/' or os.path.join, but I hate seeing them mixed.
I mean, one could argue in that case that you shouldn't be including expressions in f-strings to begin with. While it's technically valid, I agree it's not that readable, especially once the expression gets even a little bit complex. But if the expression has reached that stage, you're better off, from a readability standpoint anyway, shoving the expressions result into a well-named temp variable for use in either an f-string or .format(). The whole reason I love f-strings is that I don't have to jump from format placeholder to the end of the string over and over as I'm reading the string if I want to know what variable goes where. Being able to see the variable exactly where it's going to be in the string makes it flow much nicer for my eyes.
The problem is 'as' is already used in other places, so there'd be a lot of muddying the waters to resolve the syntactic issues because of that. Which sucks, because I agree, 'as' is definitely the most pythonic choice.
Did you mean to write I==0?
&gt; indentation using spaces. Amen brother
I'm confused, what are *you* referring to?
What are the issues? Or if you can point me to an article explaing them? I've been using ayncio for over a year now and didn't have many issues. The main problem I have is that I can't just sprinkle it here and there. Not a mayor problem in my peoject, but there are some other projects we have where I'd like to use it but I can't because of that ... Is that the main issue?
At this point his arguments are reminiscent of those saying Python3 never should have happened because it was backwards incompatible way back when. Some people can't accept that there are valid reasons for a change just because it doesn't pop up in the work that they do, and they get adamant that their way is the only valid way to do something.
Hi! I'm the new software engineer at Wallaroo Labs and I built an XMPP streaming analytics app with Python. If you have any questions about how it works or how it could be integrated with any other chat system, let me know :)
Hopefully not Redmond...
&gt; there's still that bus lurking around the corner, and I'm not getting younger... (I'll spare you the list of medical issues.) :(
No. Perl had it's own Guido though. Larry Wall was the benevolent dictator of Perl back in the early days when Perl/CGI ran the web. When it came time to develop Perl6, he wanted "the community" to control it's direction. Ever use Perl6? Me either.
Ah, ok. Thanks!
wonderful advice - what brokerage do you use? are you using any python frameworks or platforms such as zipline, quantopian, quantrocket, etc..?
Yeah, true.
This week I'm taking my first steps into actually learning python! I currently only use it to activate another program like pyxrf, so my goal is to start practicing while having r/python &amp; r/learnpython open constantly.
Super nice! Well done :)
I cannot fathom why anyone would think overloading `/` to join file system paths was a good idea.
My usual reply is don't check out /r/learnpyython as the advice there is often poor if not downright wrong.
&gt;But if the expression has reached that stage, you're better off, from a readability standpoint anyway, shoving the expressions result into a well-named temp variable for use in either an f-string or .format(). The point is that with .format you can drop the temp variable and it's still crystal clear what's going on. E.g.: "There are {} chickens named {}".format( len(half_the_number_of_chickens) * 2, ', '.join(list_of_chicken_names), ) With f strings you either have to use the temporary variable name (which IMHO it is better to avoid) or munge those expressions in with the string, which would look horrible.
What's a remainder of a string? Line length matters when you're raising an exception from multiple indentations deep which is when that code is usually used. Your preference doesn't work in real world applications but you're entitled to think so if you wish.
It's more than that-- he can change his mind at any time before death and people will allow him to. He also gets to appoint his successor / new processes, because this email is not anything of an official capacity. I hate the analogy because of the stigma related to it, but it's like pornstars saying they don't want to do porn anymore but then returning within a few months / a year with softcore shit on the side. He wants to be a benevolent monarch instead of a benevolent dictator.
There's drama over every single CoC I've seen implemented ever, so probably.
A small suggestion as for what to do next with PEPs could be what is done in PHP: RFCs are put to a vote and core contributors (and some people with significant userland packages) can vote on them. Currently there are 2 options: 2/3 majority for language changes and 50&amp;#37;+1 for others(process, etc..). Notably though, there is currently a discussion to make all votes 2/3, which makes sense for me. Either there is a large consensus on a feature or not, approving something with a very narrow difference will always feel wrong.
Okay, you'll have to elaborate on this metaphor.
Oh sorry, I thought you meant via string concatenation. Overloading the / operator seems a bit over the top. Maybe in a strictly typed language where it's more clear that the variables around the operator are definitely strings, but not python. But doing: fullPath = myPartialPath + "/" + theRestofThePath seems fine to me vs fullPath = os.path.join(myPartialPath, theRestofThePath) If for no other reason than it avoids potential cross-platform issues since on windows you get escaped backslashes from path.join, which some tools might more easily choke on (Looking at you...RenderMan.....)
I'm reminded of the editor of the Hitchhikers Guide to the Galaxy. "Out to lunch, presumed fed."
So you're complaining about the lack of a format operator?
That website is using web sockets to get data hence it can't be scraped as html efficiently. You could add a delay: import requests from bs4 import BeautifulSoup def soup(): url = 'https://www.wallstreet-online.de/devisen/euro-us-dollar-eur-usd-kurs/realtime' while True: page = requests.get(url) soup = BeautifulSoup(page.content, 'html.parser') quote_div = soup.find('div', class_ = 'quoteValue') print(quote_div.text); time.sleep(30) soup() or use something like Selenium.
&gt; Your preference doesn't work in real world applications but you're entitled to think so if you wish. \* according to you. I've seen plenty of real world applications where his preference works. It's a fucking preference, not a supernova.
Heh. I guess it's a matter of preference, because your example is *exactly* the type of thing I was referring to when I said once the expressions start getting complex you should pull it out. "There are {} chickens named {}".format( len(half_the_number_of_chickens) * 2, ', '.join(list_of_chicken_names), ) vs num_chickens = half_the_number_of_chickens * 2 chicken_names = ', '.join(list_of_chicken_names) f"There are {num_chickens} chickens named {chicken_names}" The second looks a million times cleaner to me. YMMV, I suppose.
So you're not entitled to your own opinion? My mistake, sorry.
Oooooooooh! 
Oooooh okay
Isn't it incredible, ask a question rather than use a search engine. I would not search reddit as it's crap.
Yeah, every single function can do that, and that undeniably cause issues. Hence why when they introduced features that allow you isolate side effects (like context managers) it *really* helped. I'm not saying that python should become like haskell in terms of obsessive side effect purity but it would help if they shifted a bit more in that direction. This is more of a move towards perl, where you could do all manner of crazy shit in one single line. You know how that story ended right?
The main issue for me is that coroutine objects aren't tasks / futures, whereas Python is the only language I know like this. It limits the capability of mixing async coding styles arbitrarily, as I mentioned in a comment above.
 logger.warn("Foo is %s, but should really be %s", foo_actual, foo_wanted) It's of course entirely possible to just format the string with one of the other methods, but then the overhead of formatting will always be incurred. With %/formatting like this, the format is only done when levels are set to actually emit the log.
Pfft. I could never understand Perl so well as I stopped using it at 16. I have however seen some beautiful Perl code that was very readable.
This has been discussed so many times over the 18 years that I've been using Python that I see no added value so why waste people's time?
Your example is 25% more verbose and not any clearer, which sort of demonstrates my point. The point of f strings that they were supposed to be less verbose. Even the PEP said that.
I think I have .format() in logs. 
&gt;What's a remainder of a string? If I'm scanning over a large amount of code, I don't necessarily remember the type of every variable. If someone wrote: &gt;&gt;&gt; var %= 123 then my first thought will be integer remainder, not string substitution. I've literally never seen anyone use &amp;#37;= on strings. Sure I can figure out what it means, but it's far too clever. If 15 characters on an already short line is problematic, maybe it's time to refactor to not have 10+ levels of nesting.
They added the matrix multiplication operator. Payoff wasnt huge at all. Fuck, no builtin type even supports it that I know of. If you call assignment as an expression in C obfuscation, I've got some news for you-- its common practice in nearly every language that allows it. C, C++, Java, JS, and many, many more. Also, the benefits in that example are minimal (some performance because of logical short circuiting and use of DUP_TOP instead of SET\_NAME). But there are benefits in plenty of other examples.
If you want Python to shift torwards a direction with less side effects, you will need a time machine.
This doesn't change the rules of other constructs at all, and new things can be done-- simpler and slightly faster validation-esque code.
He wants to be the benevolent monarch, not the benevolent dictator.
Reposting my comment from the r/programming post: I think one of the unsaid things in his exit letter is this: python 3 has finally taken. If he had left before then, it might have been deemed a failure, and might not have finally overtaken python 2. But now that 3 has achieved escape velocity, he can safely walk away without the future of the project (and ultimately the language as a whole) being jeopardized.
...you do know this is being added into 3.8, right?
I am, and so are you. But you can't force your opinion on me, nor can I force mine on you.
looks like it works \`In \[5\]: class A(object): ...: def \_\_init\_\_(self, x): ...: self.x = x ...: def \_\_eq\_\_(self, other): ...: return self.x == other.x ...: In \[6\]: l = \[A(\_) for \_ in range(10)\] In \[7\]: obj = A(4) In \[8\]: obj == l\[5\] Out\[8\]: False In \[9\]: obj == l\[4\] Out\[9\]: True In \[10\]: obj in l Out\[10\]: True \`
Right, but from what I can understand you can do this with the format string syntax by setting a handler has a formatter set to the "{" style, then have your logger use that handler.
I think another important thing that people miss at first is that errors are desirable. You *want* the computer to tell you when something goes wrong with your code instead of ignoring it. Otherwise, it's a really common mistake for the following to appear: try: some_code() except: pass
In this case pythonic is in the eye of the beholder. I prefer `name := value` over `value as name` because it looks similar to regular assignment which I find clear and visually distinct. I think it will allow the side-effect producing construct to pop out more visually in the middle of a longer expression like a list comprehension. 
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I feel a bit sad
It's a joke...
&gt; By character count, your f string example is 25% more verbose. Come on, now. That's such an arbitrary measurement as to be next to meaningless on its own. And again, the readability side is subjective. And I'll concede that you're right in that the format call forces the code to stay together, but I still don't agree that the risk of the variables floating away justifies the loss of readability. f"There are {num_chickens} chickens named {chicken_names}" It literally reads like a sentence. At a glance I instantly know that this string is formatted with variable values being inserted, what variables they are, and because of intelligent name choices, I can almost read the sentence outloud and have it be coherent. You don't get any of that from .format(), imo. It may be trivial enough for the examples we have here with only two variables, but the more you add, the more mental strain it takes to parse the string and figure out which variable is going to which formatting location. At the *very* least, I would want to use the optional index values to explicitly number each formatted location.
Even with the /s, it seemed like a double /s. My bad.
That's too bad, it really ought to be the place where you could go with a question like OP's and get a straightforward and correct answer.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
[Not really](https://docs.python.org/3/howto/logging-cookbook.html#using-particular-formatting-styles-throughout-your-application). But reading further on make me think it's not entirely impossible. 
AFAIK, that style only refers to the formatting of the output log after the message has been built. ie the "{date} - {levelName} - {loggerName} - {message}" bit not the `logger.warn("there's a %s in my %s", "snake", "boot")` formatting.
time to get do-while loops in python!
&gt;Come on, now. That's such an arbitrary measurement as to be next to meaningless on its own. It is not meaningless at all. Shorter code is, all other things being equal, easier to maintain and easier to read. It's a mixture of things like this that caused Java code to be, on average, about 100% longer than python code. Java is not a readable language as a result. Of course, brevity isn't everything and if clarity is sacrificed then it's often not worth it. Here there is no clarity sacrificed though. &gt;It literally reads like a sentence. I do use variable names when I have 4-6 variables in my string. For 1-3 I don't think it's worth it - it's obvious enough what is what simply from location. For 7+ variables I start to think about using jinja2 instead of str.format. This isn't about f strings though coz you can do 'There are {num_chickens}' with str.format.
Semantically, import-statement, with-statement and except-statement are doing an assignment. In the case of the with-statement, yes, it's doing an extra call with `.__enter__()`, but that's more a property of the with keyword. You can see it as `with fp = open():`. Therefore, semantically it doesn't confuse users. Yes implementation-wise it'll be a bit tricky, but you simply have to put an edge case for it. As for the except-statement, again, yes, it'll need special code to handle that, but why would you want to ever re-assign the exception class? Hardcoding also solves that one, and I don't think it'll be confusing to users. As for the order, I think most of python is very readable, not only the ternary. You have `[for value in items if value == 5]`, you have `if value is not None and my_bool is True`. All of these are fairly plain english. Having some brand new operator not only makes python more complicated, it also confuses new users.
payoff for data science folks has been great; and frankly; why would any default data structure use it, it's "a matrix multiplication operator" and matrices are not a default data structure... being able to do A @ B instead of [A.dot](https://A.dot)(B) for my numpy code has been really handy...especially when I start getting a ton of multiplications, code is far more readable.
Sucks and yeah, because this &gt; There would no changing this while preserving backward compatibility, since all logging calls which are out there in existing code will be using %-format strings. Doesn't make sense-- can't you choose the way you format based on the style paramter (internally in the formatter).
Both of those reasons don't make sense to me. Just see if you're immediately inside a with-block or except-block, then call `.__enter__()`. Honestly it's more a property of the with-statement than the as-statement anyways. I don't think it's confusing either, because the "as" is still assigning the value to another name, the only difference is that in those cases it those a little extra stuff. But again, those are properties of the block statement, not the "as".
Here is the source code for list (I'm pretty sure) https://github.com/python/cpython/blob/a5552f023e1d8cbafee1e51d316cc581deb2295f/Objects/listobject.c#L398 I'm not 100% is it's calling equal, but it looks like it is cmp = PyObject_RichCompareBool(el, PyList_GET_ITEM(a, i), Py_EQ); I'm basing this off of "Py_EQ"
Yes, it has-- but just for data science people, just in the libraries that support it. Python lists (and arrays from other modules, and other types) do not support it at all. Python is used for a lot more than just data science.
Generally with only one value to fill in one line is sufficient. Normally I have 2~6 to fill in to create a meaningful exception message. The code that raises exceptions is typically the deepest code, if this weren't the case then it would mean there's deep code that doesn't handle errors very well.
Invalid syntax. 
That sucks, because it can't be hard to make that option exist on the logging methods as well. Maybe time for a first issue / patch on the python tracker.
That's a good point. After mulling over this a bit more and reading through python-dev, I agree that something that since `:=` looks closer to the assignment operator may be more pythonic, especially in light of alternate uses of `as` already in python. That said, now I wonder why the approach wasn't to extend the capability of `=`. Other languages that I have worked with that allow assignment in expressions use the same operator in statements and in expressions. "Because people sometimes create bugs when they mix up `=` and `==`" seems like a weak reason to me.
You're not coming from the perspective of the actual people who have to write the parser. Guido wrote a reference implementation near immediately for `:=`, if you think it is such a non issue and all the core devs said if can't be done for no reason-- go ahead and prove them wrong. Fork 3.7 and implement what Guido did, but with a keyword instesd.
&gt; They added the matrix multiplication operator. Which is practically limited in scope to numerical modules. Nobody is using the matrix operator (nor should it be defined) outside of numeric classes. &gt; Payoff wasnt huge at all. Payoff for that one IS huge if you ever actually multiply matrices together (or try to read code where someone is doing the same). This is a non-negligible percentage of people using python on a daily basis today (numerical computing, simulation, data science, image processing, AI, etc.) Any line of code using the matrix operator notation is FAR more readable than a similar line using a functional form of that same operation. The point is that it ALWAYS makes mathematical notation simpler, shouldn't be used outside of math, and is logically consistent with the rationale for having other mathematical infix operators (e.g. +,-,/,*) defined. So the upside is clear, and the downside of adding a new language feature is mitigated by the fact that is' limited in scope to numerical operations. In other words, the same exact argument for the utility of having + instead of just add() applies to the @ operator as well. &gt; If you call assignment as an expression in C obfuscation, I've got some news for you-- its common practice in nearly every language that allows it. C, C++, Java, JS, and many, many more. The question isn't whether or not we can add arbitrary language features at this point. We can. The question is *should* we in situations where the payoff really isn't clear, or worse, in situations where it will generally make the language more obtusely terse. I've been programming in C++ for well over 2 decades now. I still find perfectly valid C++17 code on a weekly basis where my first reaction is "WTF is this shit doing", and not "yeah, this is totally obvious." A large part of that is the decades of "good ideas", feature creep, syntactic sugar, backwards compatibility, and little corner-case nonstandard bullshit tricks people have come up with in an attempt to be clever. There IS a real usability cost to packing features in like a clown car, so IMHO the justification has to be bulletproof. &gt; Also, the benefits in that example are minimal But that is the example OP gave for this feature while exclaiming "look at this bad boy" &gt; But there are benefits in plenty of other examples. It was the same shit on the python dev mailing list. Someone would go "Well yeah, but how will this new operator ever make things better," someone else would post some trivial example which would get picked apart, and OP would then herp derp and go "but yeah, trust me, there totally ARE real examples where this makes everything so much better" So post those! Even the examples chosen for the PEP (which is where you should probably try to make your strongest case) are nothing more than trivial simplifications.
Doesn't it? Comprehensions until now couldn't change variables external to them. Can they now? Either way, there's the scope for confusion. 
If the PEP has to specify the construct should be used sparingly, then there's no compelling case to add the construct. 
Yes they could. Hell, in Python2 they could *so much* that it was actually a bug and the temporary variable would always leak out of the expression. In Py3 that specifc part of it was changed to do so only if it was preinitialized.
Let the power games begin. At least with a single leader, there was the possibility of resolution by fiat. With "community" leadership, the likelihood of fracturing and forking increases significantly.
Lancaster vs York was the origin of the War of the Roses, which was a war between two noble houses in England. I think it had something to do with one of the Henrys, but we've had so many Henrys as kings that it's very easy to forget... Interestingly, it's one of the historical events that George R. R. Martin based his "A Song of Ice and Fire" books off.
There are numerical stdlib modules where the operator is not defined. Yeah, it's huge only in third parties, only in mathematical code. Just like payoff of assignment expressions is huge in regex and web field validation code. You can't claim we shouldn't add this commonly understood feature in other languages just because *you* can't understand it. But it is also clear, that you can. I'm not defending the OP or even a lot of the PEP examples. There was a guy who made a "do not merge" PR to the stdlib and it showed quite a lot of different chunks of code that benefited, and when I bump my web projects to 3.8 I will be able to replace a lot of "match = func(data); if match: else err" code with this, which is both more comprehensive (personally to me) and actually just slightly, slightly more optimized, which will reduce my company's costs significantly. And sure you can scream premature optimization, but there was a guy I knew at facebook that saw these two related columns in a database, did a small amount of math to merge them into one, and in that super small change he saved the company enough to cover his salary for multiple lifetimes.
You're asseting against points I haven't made. So im just going to leave with the long held notion in he Python Dev community there should be a high bar for new core syntax, that's why it took multiple releases before accepting the await and async keywords.
Features that will live on for possibly decades on thousands of projects shouldn't be decided on based on whether they would take 1 day or 2 months to implement. There's no rush. 
&gt;Honestly, I think an extremely thin wrapper around asyncio would solve this problem, and fuck it I'm setting out to make it. That wrapper is Trio, and it's absolutely wonderful. 
asyncio is more or less low level. Try the Trio library which leverages asyncio to make concurrent code that is easy to reason about. 
The last time I saw trio, while it is a wrapper and does cool things, it doesn't make coroutines and Tasks one and the same, and intermixing of styles is still therefore not allowed. Unless this has changed. Can you show me an example?
Try opening your editor's settings.
Yes. Except the as discussion has been going on for at least 3 years, never being done. If the feature takes a decade to implement, when with a simple change of syntax it can be implemented in a week, then it does matter.
It took *one* release for * f strings * matrix multiplication * basic async / await, complex editions were done in the next, as known, because of provisionality * type hinting * and more I also don't like the fact that these things are added so quicky. They should be added with a future statement. But you're drawing at straws, hell, at straws that don't exist.
Unfortunately from your commit history we cannot see which changes you made to implement the new keyword. Your second commit just includes the complete Python source code plus the changes.
When you appoint yourself as the decision maker, you become the person that everyone feels they have to convince and the target of all animosity for decisions that people disagree with. So it's pointless to be a BDFL if you are trying to also run a psuedo democratic organization. If you are a dictator you dictate, if you are a representative you represent, and if you are an arbitrator you arbitrate. Seems like he wanted to be an arbitrator but never established or communicated any framework under which his decisions would be made. So he was an arbitrary arbiter? All in all, he defined his role, and he defined it badly, and he is ultimately responsible for the negative reactions that resulted. 
Which is what happens async so hard to understand. People don't agree on what level of abstraction async is on. So the level of expections for what it should be is different and what kind of support it needs. Maybe trio would be like requests. The standard library version is dated and that library in "de facto standard" status.
Like the answer to all great questions, it depends! ``` &gt;&gt;&gt; class A: ... def __init__(self, value): ... self.value = value ... def __hash__(self): ... return hash(self.value) # Don't do this, hash's should never change, but self.value is mutable ... def __eq__(self, other): ... print(id(self), id(other)) ... return self.value == other.value ... &gt;&gt;&gt; &gt;&gt;&gt; y = A(1) &gt;&gt;&gt; id(y) 4432550544 &gt;&gt;&gt; y in [A(i) for i in range(10)] 4432550544 4432550488 4432550544 4432550432 True &gt;&gt;&gt; y = A(8) &gt;&gt;&gt; id(y) 4432550376 &gt;&gt;&gt; y in [A(i) for i in range(10)] 4432550376 4432550544 4432550376 4432550488 4432550376 4432550432 4432550376 4432550264 4432550376 4432549760 4432550376 4432550208 4432550376 4432550096 4432550376 4432549648 4432550376 4432548640 True ``` So it seems for a list, `__eq__` is indeed invoked on every element until a match is found. However, lists are not the long collections. What about a `set`? ``` &gt;&gt;&gt; y in {A(i) for i in range(10)} 4432548640 4432550376 True &gt;&gt;&gt; y in {A(i) for i in range(10, 20)} False ``` Huzzah! Only one call, and only if the element is in the set.
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
&gt; so they can access non API classes/methods you want to test I don't think this has any meaning in python. You can access whatever you want so long as the package is installed. I use tox almost exclusively for unit tests - it's vital to be able to throw the whole suite through the whole build matrix.
&gt; Python lists (and arrays from other modules, and other types) do not support it at all. You can implement your own method easily enough with `__matmul__`. Again, no sense in Python supporting `@` for generic lists, as the operator only makes sense for a specific data structure with very specific types &gt; Python is used for a lot more than just data science. Sure, but you won't see Data Science folks complaining about async because because "python is used for a lot more than web based frameworks",...there are components of the language that are useful to different fields. Regardless, multiplication and matrix multiplication are different operators, only makes sense to have a matrix operator too.
Sorry, i somewhat misread your point. It solves the problem of managing the event loop, but does not give you more flexibility with tasks/futures, but I actually like that. Trio essentially introduces a new way of thinking about concurrency that I think is great. It does that by further limiting what concurrent code can do, which seems bad at first but it return you get a new set of guarantees that can really simplify things.
&gt;Except the as discussion has been going on for at least 3 years But the discussion wasn't about how long it would take to implement, it was about other consequences.
I'm stealing this phrase.
Yes, you can. But it's not already there. It isn't readily available. On the other hand, async is both readily available and has infinite uses-- it's a method of programming, not a subset of use of programming to solve a problem.
Async in Python is pretty easy to use once you get used to it. I actually really like writing Async python code now particularly when I get to use aiohttp. Worth taking the time to understand how it works. 
Game of Thrones, I think.
I think it is entirely reasonable to object to a feature that allows `[x+y+z for x:=y in range(z) for z:=x in range(y) for y:=z in range(x)]` workout knowing exactly how the source handles it. No matter how this gets resolved, it's going to be a bitch to understand and internalize. Prior to this I would have said that a great thing about python is that you don't have to study a complex specification in order to understand anything written in the language. That is not true with these assignment expressions.
In fairness, \`map("thing &amp;#37;d".\_\_mod\_\_, range(5))\`
Why not...?
Don't get me wrong-- I like the new way of thinking, it just doesn't *solve* the problems I addressed in regards to Tasks and coroutines being too separate. Management of the event loop is indeed made much easier with trio-- you can open nurserys and run async code directly from sync code. But, asyncio solved the former with gather (which works well enough for me not to complain about it, the nursery construct just seems like you're reordering your logic to occur inbetween gathering rather than before, and that's personal preference). And, asyncio added an equivalent to `trio.run` to, albeit slightly less featured with keyword arguments. Mainly my issue is with the coroutine/Task rift, as I mentioned.
You're treating it as if the two issues aren't related, but they very heavily are.
Do you even use Python? &gt;&gt;&gt; x = [4] &gt;&gt;&gt; def f(y): ... y[0] = 100 ... &gt;&gt;&gt; [f(x) for _ in range (2)] [None, None] &gt;&gt;&gt; x [100] 
I don't see how. Most people were actually complaining about `:=`, which is faster to implement as you said. 
[Wars of the Roses](https://en.wikipedia.org/wiki/Wars_of_the_Roses)
I wouldn't say linus was in the kdbus side. What he did was to delegate the decision to the relevant maintainer after asking that maintainer to look once again at the case for inclusion. All in all that was a fairly negative assessment. It amounted to saying "I suspect you are wrong here, but you are the expert do I would do it if you tell me to." Definitely not an endorsement.
OK, fork in the road. Does python now focus on the features that the vast majority of users want, or the features that a few insiders who love blowing their own horns at tech conferences want? Years ago I read a great story about the creation of MS Visual Studio. They had done their market research and found that people wanted complex templates and a slew of extremely (at the time) esoteric features. Then a new guy took over the failing project and discovered that their market research had only sampled really hard core insiders and academics. So the guy asked "real" users of C++ and they all wanted the same thing. "Help us make windows programs" and the template (as in a template of usable code) wizard was born and all the esoteric features were put on hold. MS went from around 1% market share to around 97% market share in under 2 years they basically ended Borland C++. I feel that Python has been asking the hardcore insiders and academics for guidance for a little too long. 
https://github.com/spotify/snakebite/network Lots of companies still use Py2 or have heavy Py2 links, so they see no reason to upgrade because it only costs them more.
I built my own framework and backtesting suite using PyQt which is able to switch between Robinhood and Interactive Brokers. Never really understood Quantopian so I never tried it. 
&gt; i abruptly stopped my otherwise intense work on Konsent, a FLOSS consensus decision-making platform designed for online communities, due to internal disputes between myself and the community that was using Konsent Well isn't that fucking ironic?
Is there a units conversion module that does something like this but based off strings. For example, you could have a function like: &gt;&gt;&gt; convert('10 feet in meters') 3.048 Something similar to, say, the way google will do these conversions if you type "10 feet in meters" into the search box.
There's an example given in the documentation of how to do this. On Unix, you could also probably rig it up from the `units` command.
They were complaining about using it because of the syntax. But the actual core devs were complaining about as because of the implementation. So the compromise was made-- make it similar to other languages (:= instead of =) and it also reduces the difficulty of implementation. But now people are complaining about := because they don't like that syntax either. You can't ever make everyone happy.
The PEP, and the examples in it, are mostly there to describe the feature, not sell it. If you want to read the arguments for and against, that's what the python-dev archive is for.
Is this the one that you have to pay license fees to commercialize? 
&gt; I like there being only one way to do such a common operation, This attitude always completely perplexes me. Why is having options bad? There are subtle differences among options (otherwise they would be identical and indistinguishable). Those differences sometimes matter.
Is it possible to make full-fledged apps iOS apps with kivy? I only tested out kivy for desktop related GUI but I started learning swift/Xcode because I wanted to create a full-fledged deep-learning related app. 
Counterproposal: only contributors' votes count. Maybe even just core contributors, because someone who contributed a one-line bug fix doesn't deserve the same authority as someone who's spent thousands of hours improving Python. Letting just anyone vote is a bad idea because you don't know how many of them are just casual users, or even sock puppets.
ITT: people demonstrating why Guido decided to quit
I mean if you just want a pure language that is very strict on keeping unnecessary features/syntax out, there is Haskell for that. The matrix multiplication operator hasn't gotten in anyone's way that doesn't use it, as you pointed out none of the default data structures support it, but to those of us doing math/science, it's been great to have and a very welcome addition.
the free version is gpl, you can still sell gpl software.
Yeah-- and thats the exact point I'm making with assignment expressions. It won't get in the way of people who don't want to use it, and those who dox it will be a welcome addition.
&gt; That said, now I wonder why the approach wasn't to extend the capability of `=`. Two reasons. You mentioned the first: "Because people sometimes create bugs when they mix up `=` and `==`." It's a strong reason because it's easy to type and hard to debug. If someone types if arg = value: do_something() else: handle_rare_case() when they meant if arg == value: do_something() else: handle_rare_case() Their code will run merrily along with no syntax error. When they do realize they have a bug it's easy for the eye to slide over the typo (assuming they're even looking at the right code). Today we're protected from this by a syntax error. Making assignment expressions use `:=` instead of `=` means this bug is much harder to accidentally type and quite a bit easier to spot. (Note: I make this typo whenever I return to Python after spending a few unpleasant days using v script.) The second reason is that assignment expressions really are different then regular assignment. They don't do tuple-unpacking. They don't combine with other operators (no `+:=`). They don't assign to an attribute (no `foo.x := 1`). They don't assign to an item (no `d[k] := v`). Basically no version of assignment that uses a `__dunder_method__` is allowed in assignment expressions. Because assignment expressions are so much more limited than regular assignment it makes sense to have a spelling that says "this is similar, but different." If it were spelled `=` it would be inconsistent that `d[k] = v` is legal, but `if d[k] = v:` is not. 
For lists, yes. But other container objects can (and in the case of things like sets or dicts, *do*) override the `__contains__` method to do something different. For sets/dicts, they'll just do an O(1) lookup in the hashtable, so will only need to call `__eq__` on the one matching object (plus potentially anything with a hash collision with it, which should be a small constant number at most)
You can't exactly *intermix* them - the whole point of Trio is that you get useful structure and scoping for concurrency, including timeouts and cancellation. [You *can* use asyncio and Trio togther though](https://github.com/python-trio/trio-asyncio) :-)
&gt; define how they interact with each other Easy answer. They don't. PERIOD end of discussion. "as" can be used in `if/while` ONLY, and it solves loop and a half AND NOTHING ELSE. It isn't an expression, you can't put it anywhere you want. You can only put it in if/while.
I could've told you this was going to happen. I just started finding enough time to really focus on properly learning Python, cleaning up my hack scripts from the last 3yrs, and using proper repo structuring in my gitlab. Only makes sense that the wheels would start to come off now. See you guys in 3 more years when Python has been usurped by another.
He has specifically not appointed anyone... probably knowing that if he does not appoint anyone, there can be no next BDFL. 
Kind of like the British monarchy. The parliament does the real governing, but the monarchy is still technically there.
Interesting - Im building off of Zipline (Quantopians framework) and it's pretty great so far. Interactive brokers, plotting with matplotlib, good backtesting. I put together a Git repository for what I have done with it so far, with a pseudo walkthrough if you're interested.
By intermixing styles I meant callbacks and scope mixing done in Tasks that can't be done in asyncio. Can't be done in Trio. Can't be done in trio-asyncio either.
Agreed. I think its also important to say that labels matter. Guido choose the label "dictator", can can't then complain when people say he is acting dictatorially. Of course people throw shit at the dictator, they are the dictator! If he didn't want to face a firing squad he should have come up with a different way of expressing his roll. If he wants to be an arbitator, then he could establish the principles that would guide his arbitration decisions. If he wanted to be a representative, then he could declare who he represents. ...
No, not if you can work within the LGPL: https://wiki.qt.io/Qt_for_Python_GettingStarted Even GPL doesn't stop you from charging for software. It just requires you to provide the source with it.
&gt; TDD Hey, it sounds like you might want to explore classes/OOP. I started out doing similar stuff with the functions... they aren't always the best way to go about doing things.
You seem to have picked the least impressive example from the PEP... all the others show a better use of the functionality. For example while True: line = fp.readline() if not line: break m = define_rx.match(line) if m: n, v = m.group(1, 2) try: v = int(v) except ValueError: pass vars[n] = v else: m = undef_rx.match(line) if m: vars[m.group(1)] = 0 becomes while line := fp.readline(): if m := define_rx.match(line): n, v = m.group(1, 2) try: v = int(v) except ValueError: pass vars[n] = v elif m := undef_rx.match(line): vars[m.group(1)] = 0
This really bad but honestly you can't go much farther with Python before it looses all appeal as a scripting language. If people have any senses at all they will slow down the development process considerably and make sure that new ideas going forward fit into the "ideal" or Python. Beyond that I can see the day when something like Swift starts to displace Python. Swift is almost as clean as Python for scripts and has far more capability when compiled into fast code. 
It was the responsibility of whoever wrote the PEP to provide convincing examples, it's not my fault if they did a shit job. I'm glad the ranks are being shuffled after that embarrassment of a trainwreck.
I'm out of the loop, what's wrong with Raymond? I know him by his talks only. 
&gt;I wish Guido all the best with his well-deserved break. It's a shame that there was so much bile thrown about regarding PEP 572. While I'm not a proponent of adding assignment expressions to Python, it won't affect my existing code, and it's certainly not anything to get butthurt over. totally agree with all this. I think though that Python starts to steer a bit too much into the feature-bloat direction. I think overall everything goes into the right direction. For the persons help with steering the community efforts, I hope that they don't say "yes" too easily to too much new fluff. I know, adding features is more fun than removing them, but I really hope for a standardlib spring cleaning some time
Nice! I also wrote a Brainfuck related thing in Python, a Brainfuck compiler that outputs Python! https://github.com/jamieluckett/bf2py
Not everyone has been using Python for 18 years, is that so hard to understand?
The palace coup I posted about has been successful! You're welcome. Guido will now be able to go on a "long vacation" in exchange for publicly abdicating. Incidentally, for those looking to overthrow Larry Wall: https://www.amazon.com/Coup-d%C3%89tat-Practical-Handbook-Revised/dp/0674737261/ref=sr_1_2?ie=UTF8&amp;qid=1531442530&amp;sr=8-2&amp;keywords=coup+d%27etat&amp;dpID=51TBZUcKA1L&amp;preST=_SY291_BO1,204,203,200_QL40_&amp;dpSrc=srch For those looking to become the new Guido: https://www.amazon.com/dp/B008NAWQBK/ref=sspa_dk_detail_6?psc=1
Oh yeah I know about OOP, thanks though. My problem was being figuring out how to test functions in a clean and obvious way when they depended on the state of the object, so I have a main class that's instantiated when the program runs. That needs to do some transformations on data (joining) and compute some new vectors based on that data. So my issue was I ended up writing * stateless worker functions that required me to setup the complicated state of the data on the testing side. These are @staticmethod so I can call them directly from the test without instantiating the class. * worker methods that take the state in the object and pass it into the stateless workers. I tested them by asserting they gave the same results as the stateless workers, which were now tested known-good. These required me to instantiate the class with data constructed on the test side, because I hadn't written the data setup logic for the class yet. * A method for setting up the state of the object, given some raw inputdata. Tested it by assert the self.data attribute being the same as my data joined on the test side. Basically I think I started from the wrong end. If I'd began with testing that the class could set up it's own state correctly I could have used that state in the other tests. Now I ended up writing the entire app twice because I had to write so much of the state logic for the worker tests to even run. It comes down to practice I suppose. 
 while True: I never liked the above. It felt like the code was *lying*. 
That is because I uploaded it after changing..I made changes to grammar, Parser/python.asdl, Python/ast.c, Python/compile.c..I'll mention those in readme..
&gt; A small suggestion as for what to do next ... could be what is done in PHP That may have been the first time that sentence was ever written! ;-) 
I think it's actually useful to allow (some) non-committers to vote. Not everyone that has the skillset to implement a change in a language make use of that language daily. Or respond to issues of popular packages, etc... Hence the usefulness of their vote.
But 99.99% of the language ARE casual users! We got into the recent mess because of a small handful of loud users; I don't think we want just those few to decide everything. If I pay $50 for a piece of software the developers want to know what I think and what will make me happy. It seems strange that Python wouldn't care what I think unless I write half the CPython interpreter. 
We'll see what happens now. 
what if there's a hash collision?
I'm making a recommendation system a la IMDB. Only using a small data set of 100 users and 50 movies though. 
you're welcome
There was too much rush to stick something in there that wasn't really done (same with static type hinting). Some people don't realize that this isn't just about the new assignment operator; like you said it's been something building since at least the async stuff if not a little before. 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
It will still be added. It was accepted. Guido even said he wants to be the one to implement it in a september code sprint.
I knew when I saw a post from Guido basically dismissing the Zen Of Python and mocking those who revere it that something had gone tragically wrong in Python-land. :-(
You? I left Pascal/Delphi after 20 years and now they want to put in a Pascal assignment statement := to really confuse me!
How can you possibly compare things like turning print into a function to Perl6, whose own developers say is a new language?
But did it address it *successfully*?
&gt;You're not coming from the perspective of the actual people who have to &gt;write the parser. We don't care about the people who have to write the parser. They exist to make the language easy to use; it's not users' jobs to write longer or more esoteric code to make parser or compiler authors happy. I come from using an expensive ($1400+), niche language and it's that very attitude that's infuriating - the company often making the simplest decision for *them* that results in more work or more problems for the end users. We can do better than that.
When we kill the PEP, we'll make everyone happy. 
Except it is supposed to be very high level. So thats a bit of mismatch.
That's the thing - it shouldn't have been added until a lot of this stuff had been worked out. It's like releasing a program and then "patching it into shape" later on. 
DAVID BEASLEY tweeted about trying to get his head around it! That should have been the canary in the coal mine!
We shouldn't have to get used to it. It should be simple and intuitive like the rest of Python.
Except you won't. Following my comments around just being salty over 572 won't solve anything either.
If you don't care about the people making the language, you don't deserve to use that language. You deserve to write your own and use that exclusively.
But... Guido's been putting bad ideas into the language for a few years now. :-( This is just the straw that broke the Python's back. The worst part was him not being willing to listen to anyone else. 
Guido USED to do that in the past, didn't he? Even withdrawing one of his own PEPs once because of the initial negative reaction? Not anymore though. 
Now that it's protector, Guido, has been overthrown, there's no guarantee it's getting into Python 3.8. 
There is something broken about *Guido*... he lost his mojo several years ago. His heart's not in it anymore. I blame Dropbox still using Python 2 for driving him insane. Now he's just shoveling anything into Python 3 because he never gets to use it himself. :-(
I'm not qualified or knowledgeable enough to make that call. I'm just providing a reference for people who are interested in reading the PEP authors' rationale for rejecting the `EXPR as NAME:` spelling.
I think this is a super silly thing for there to be this much fighting against, it's nothing compared to our many bad ways of string formatting for example. 
!RemindMe 6.5 months "Overthrown"? Really? We are doing this now? I think a good time to remind would be alpha 1, so, remind me is set.
I will be messaging you on [**2019-01-28 13:27:01 UTC**](http://www.wolframalpha.com/input/?i=2019-01-28 13:27:01 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/Python/comments/8yapie/transfer_of_power_guido_stepping_down_as_bdfl/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/Python/comments/8yapie/transfer_of_power_guido_stepping_down_as_bdfl/]%0A%0ARemindMe! 6.5 months) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
&gt;I don't get this mindset. I once saw a feature get shot down on the Python mailing list because "It would just be another feature to learn". See what's going on? Something's *changed*, and it's a change within Guido. It's different because it doesn't make things better but does make things more confusing. Python doesn't change for the sake of change (despite what Python 2 diehards may claim). I left another language after 20+ years for Python for, among other reasons; many of the remaining users' resistance to change. I embrace Python 3 too. But I don't embrace this assignment operator, and neither do people who really know about and care about the syntax of the language, such as Raymond Hettinger. 
!RemindMe 6.55 months Guess off by a day :/
Just looked up PEP 572 and he should show himself out, that's UGLY. I can see some utility but there has got to be a better way than something that, short of the simple `if`case, is bound to be trouble. 
When I see x = "program files" / "app" I assume it's going to do something completely different from what it's actually doing, and I just feel wierd when standard operators don't do standard things. Kindof like how js does 1 + 1 + "2" == "22"
This checks your python dependencies. They should all be in requirements.txt or in Pipfile.lock. setup.cfg is your own code, while it should be checked I can understand why they don't.
It does an assignment in an if statement, which everyone who's ever used C knows is inherently bad and evil and leads to all sorts of bugs. 
True. The *reason* you can't intermix them is that Trio is **not a wrapper**. It's an entirely separate design and concept for concurrency! It's entirely possible - and IMO desirable, via Trio - to use async functions without using the asyncio module or event loop.
/u/Brian already mentioned it, but examples are always good, so lets have some of those. We start similarly to the previous example, except we engineer the `__hash__` function to produce collisions. ``` &gt;&gt;&gt; class A: ... def __init__(self, value): ... self.value = value ... def __hash__(self): ... return self.value if self.value &lt; 10 else 10 ... def __eq__(self, other): ... print(id(self), id(other)) ... return self.value == other.value ... &gt;&gt;&gt; y = A(8) &gt;&gt;&gt; id(y) 2882974960 ``` Verify that the universe still works how we expect, no collisions should be here, so should work the same as before. ``` &gt;&gt;&gt; y in {A(i) for i in range(10)} 2882975440 2882974960 ``` :+1: Now lets try it with a set where there are some collisions. ``` &gt;&gt;&gt; y = A(11) &gt;&gt;&gt; id(y) 2882975312 &gt;&gt;&gt; x = {A(i) for i in range(8, 13)} 2882975536 2882975184 2882975536 2882975216 2882975184 2882975216 &gt;&gt;&gt; y in x 2882975536 2882975312 2882975184 2882975312 True &gt;&gt;&gt; y = A(12) &gt;&gt;&gt; id(y) 2882975344 &gt;&gt;&gt; y in x 2882975536 2882975344 2882975184 2882975344 2882975216 2882975344 True ``` Elements `A(10)`, `A(11)`, and `A(12)` in `x` all have the same hash, so we expect something interesting to happen, and we see that the behavior is exactly that of when we were using lists, it goes through them sequentially until it finds a match. The word "sequentially" raises an interesting question, as a sequence implies order and `set`s are unordered collections. This goes back to how these hash based collections are implemented. I haven't actually looked at the source to confirm, but it behaves as if each entry in the set is actually an array (or linked list, or some other sequence) of elements that hash to that value. When there is only 1 the behavior is simple, just get it. However when there are collisions the sequence must be searched to find the real match. ``` &gt;&gt;&gt; x = set() &gt;&gt;&gt; x.add(A(12)) &gt;&gt;&gt; x.add(A(11)) 2882975504 2882975216 &gt;&gt;&gt; x.add(A(10)) 2882975504 2882975184 2882975216 2882975184 &gt;&gt;&gt; A(12) in x 2882975504 2882975536 True &gt;&gt;&gt; A(10) in x 2882975504 2882975536 2882975216 2882975536 2882975184 2882975536 True ``` You can see above that it's behavior is to search for the entry from the beginning of the internal sequence at that hash, in the order that the items with that hash were added. This is why you need to implement `__hash__` *and* `__eq__` to be able to store objects in a hash-based collection - in case of collisions. 
No, they shouldn't be. All the formats I mentioned also declare dependencies, independent of one another. Not everyone has used a requirements.txt, and not everyone will use a Pipfile. There's not even a way to use Pipfiles without pipenv, which is completely third-party from something like pip. Requirements files are at times unnecessary. They are also outdated. Whereas Pipfiles are a broken replacdment because pip doesn't support them. If that's not irony I don't know what is. Plenty of people still use the three methods I mentioned as a result.
I was inspired to finish this when I saw the Mathologer's video!
No offense, but I don't understand how you are contributing to the discussion. "I have problem X. Fuck it, I will solve problem X" "Trio is great" "It sure is, but it doesn't solve my problem" "Trio is...great!" "....."
pipenv isn't 3rd party. It's the new official recommendation from PSF What the technical reason for breaking with standard practise and not puttin gyour python dependencies in requirements or pipenv?
In your example how do you handle: with some_class() as x: Does `x` get assigned to be an instance of `some_class` to be consistent with the new assignment expression syntax or does it get assigned to the value of `some_class().__enter__()` to maintain backwards compatbility? 
More like stepping down because he recognizes PEP 572 was a bad decision after all.
&gt; How can you possibly compare things like turning print into a function to Perl6, whose own developers say is a new language? How can you think that all those breaking changes that make Python3 a de-facto new language can be reduced to "print" being a function? Start reading: http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html
The solution is to slap anyone who writes that.
Please show me where this is? Because there was so much controversy over pipenv, it ended with PyPA saying "pipenv is not official, it is just a recommendation for beginners". This isn't breaking standard practice at all. Standard practice is doing *at least* one of * Pipfile * requirements.txt * setup.py directly * setup.cfg * pyproject.toml Funnily enough all of these except Pipfiles are supported by pip.
Yeah man shoot me what you've been working on. I'd love to take a look. I'd throw mine to you I've been swamped with training so it's upkeep has been... a bit lagging. 
What would you recommend I use if not Django?
for smile in good_moments: print("thank you, Guido")
I get that it's odd in python, seeing it's a symbol rather than a word. But as someone who did a compilers class once: parsing an overloaded "as" operator would be a pain and end up as a buggy inconsistent mess. Aliasing it as "becomes" would have been nice but it would break existing code that uses the word as a variable name, so it'd need to be behind a __future__ import, and good luck explaining that to people 
Shouldn’t matter. python has to evaluate both function calls before it evaluates +. The only way it could matter is if f1 and f2 each depend on some global state, which is REALLY bad program design for just this reason, that the answer could vary depending on execution sequence.
greenlet is what gevent (and eventlet and others) use under the hood. A gevent Greenlet, is a greenlet subclass with some future-style helper methods.
I've seen decorators being used to handle all sorts of exceptions. Is this good practice? I can see the benefit of writing a general decorator and applying it to several functions instead of writing a ton of try/excepts. I know it won't handle very specifics tasks but for data munging or general quick scripting it may be helpful. I'd love to hear your thoughts.
https://packaging.python.org/tutorials/managing-dependencies/#managing-dependencies &gt; While pip alone is often sufficient for personal use, Pipenv is recommended for collaborative projects as it’s a higher-level tool that simplifies dependency management for common use cases. That's an official recommendation for non-toy projects. Pinning version numbers in setup.py is bad for a number of technical reasons. Requirements.txt was designed for this and is also the official recommendation. Python packaging has been a mess for a while, but it finally got itself sorted out in the last few years. Github's complying with the current PSF idiom, so I understand why they didn't feel the need to add more. They probably will, later on, to support legacy code.
Yeah, I guess I'm torn. On one hand, I didn't really like PEP 572. On the other hand, I've witnessed before that when you have something designed by a committee or by consensus, it tends to fall apart. It's really better to have someone whose vision is the guiding force behind something (unless the person is awful, but that was never the case here). 
Correct. It depends on the + operator. All arithmetic operators evaluate first the left operand, except ,**, the exponential operator. 
Anyhow, Python is deeply deterministic and has a well defined order of evaluation of operands.
Actually, data science is one of the biggest uses of Python, period. The joke at PyCons is "Every person you meet here is either a data scientist or a web developer". 
For me it isn't about good code vs bad code. Its easy enough to ban problematic constructs and there are companies which have preemptively banned assignment expressions in their code (before the relevant python version has even been released). So it isn't that I expect to have to deal with a terrible construct like the above. Rather it is that prior to the introduction of this PEP I never even had to worry about a construct like that. Python was very clean syntactically. Things like `a,b = b,a` are syntactically a bit of a mess (because of the implicit packing and unpacking into tuples), but it does exactly what you would naively think it should. Not everything is perfect. There are lots of odd and confusing things in the standard library. I often stumble over the various mutating and non-mutating variants of operators on things like lists, but its not a syntactic thing, its just a matter of forgetting semantics of a library. I no longer feel that I can say that python is syntactically clean and easy to understand. That seems a big loss. I would ultimately echo Hettinger's concerns about both readability and ease of access for new developers. You can't fix that by simply saying don't write bad code, all you can really do is say "don't use the feature" in which case we might as well not have it.
I thought this referred to Redmond - Microsoft headquarters - subtle dig at Github maybe?
Oh I didn't even realize he said Redmond.
How's it coming along?
What package are you using to edit pdf's? Is it reading the data well?
It is *one* of many uses of Python. Saying "period" doesn't make your bullshit true.
The comment about /r/learnpython advice being "poor if not downright wrong" is unsurprising, as [Sturgeon's Law](http://www.catb.org/jargon/html/S/Sturgeons-Law.html) applies to reddit as well. You just separate the good from the bad. There appears to be no better place than /r/learnpython for beginners. If anyone knows of a better place, or wants to create one, I'd like to hear about it.
PyPA members continue to claim that that is not an official recommendation, and also PyPA is not the PSF. It is perfectly fine to use pinning in setup.py directly for small projects. Requirements.txt is indeed the official recommendation and a Python standard. Setup.cfg is also an official recommendation and a Python standard Python packaging is still a horrendous mess, and now has two new competing standards, Pipfiles and PyProject.toml, the former of which *isn't even supported by pip*. Github is not complying with any idiom-- they just arbitrarily chose two out of five standards.
Here's a sneak peek of /r/learnpython using the [top posts](https://np.reddit.com/r/learnpython/top/?sort=top&amp;t=year) of the year! \#1: [My new book, "Cracking Codes with Python" is now available and free to read online!](https://np.reddit.com/r/learnpython/comments/7sigre/my_new_book_cracking_codes_with_python_is_now/) \#2: [I'm releasing a free code for the "Automate the Boring Stuff with Python" Udemy course](https://np.reddit.com/r/learnpython/comments/7fxork/im_releasing_a_free_code_for_the_automate_the/) \#3: [I made a python cheat sheet](https://np.reddit.com/r/learnpython/comments/82t191/i_made_a_python_cheat_sheet/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
call me a psychotic masochist, but I actually like PEP572 so there I said it. `from bdfl import Barry`ALL HAIL BARRY!!!
Hi thanks for the response. So just to clarify, if I have the following simple program: def fib(n, memo={}): If n == 0 or n == 1: return 1 try: Return memo[n] except: result = fib(n-1, memo) + fib(n-2, memo) memo[n] = result return result On the line result = fib(n-1, memo) + fib(n-2, memo) does this mean python will first execute the fib(n-1, memo) part storing results to memo and then proceed to execute the fib(n-2, memo) term using any results that have already been stored in memo?
This post is better suited for r/learnpython 
graphviz did the trick. I originally tried using pygraphviz without installing graphviz, as the error messages were not clear on what exactly was missing. I ended up uninstalling all pygraphviz packages, installed graphviz then installed pygraphviz by downloading a wheel (dont have link right now) and using pip on that .whl file. I also have to add the path towards C:/... / graphviz/bin/ to python using os. Program worked like a champ.
i'd be down with that. He has written some of my favourite modules
Not my cup of tea but that's an awesome readme! :cheers:
Go repost it there then big shot. 
Do. Or do not. There is no try.
&gt; shit job &gt; embarrassment of a trainwreck &gt; nutjobs wow... so much anger. My man... you should relax a little. It really is not that bad. &gt; It was the responsibility of whoever wrote the PEP to provide convincing examples And yes... they did - they are present in the PEP. They also gave not so great examples. Also, this is subjective... if you think there are 4 great examples and 1 not so great, it is still a win. Any functionality can be abused to write code you don't like... you should not use it that way. There are useful and beautiful ways to use this functionality and those are documented in the PEP. You seem to be in a nitpicky mood... so even if the PEP authors had given convincing examples that you liked, I think you would have found something else to complain about. Because I doubt your beef is with the mediocre example. 
So most of the websites I write anymore (interactive ones anyway) are a combination of VueJS and Falcon (python API framework). For backend stuff, I normally use Mongo. Flask is a decent alternative, although I prefer the performance of Falcon. I have seen nice sites created in Pyramid and Tornado, I'm just not as familiar with those frameworks. Are you doing any of this in the cloud or is this strictly an on-prem solution?
No backwards compatibility is needed, because it would be a new construct. It would basically be syntactic sugar to fix the "loop and a half" problem. So `while foo() as x` would be equivalent to x = foo() while x: stuff x = foo() Similarly, `if foo() as x ... elif bar() as x:` would be x = foo() if x: stuff else: x = bar() if x: other stuff
ironic considering part of the reason guido resigned the way he did was due to all the shit slinging and anger from the community while the PEP was being formulated
&gt; But 99.99% of the language ARE casual users! 99.99% of car users aren't mechanical engineers but that doesnt mean the average user has any idea how a car should be designed
So it's kind of like, multiple programs altogether? I see you can run spyder, idle, jupyter notebooks...There's really nothing to compare it to, is there?
I'm for everyone having the ability to vote too, but with all the bots online how would you make sure the vote isn't hijacked? Maybe there could be a open poll not as a binding resolution but just as a tool to survey the opinions of the casual users?
Yes. A nice example of a code where the order of evaluation makes a difference, even if it's only in performance. Typo: return with lower case r
Where is that post?
As mention above. I have the initial list which contains every item from the subprocess call (very bottom). I would like to create a list that just the IPs as separate items. Any help is greatly appreciated! This is brain melting me and I don't know why ..
I shrugged my shoulder when I glanced over the PEP, and thought I would never use it. Then, I was like “well , can I use a list and this expression chaining mechanism to make some multi-line lambda functions...” Not sure yet. I personally like the strictness and clear defined boundaries of Python, but occasionally I miss some quick but messy tools in like JS when I’m in a rush. 
Language semantics matter. Any argument over a programming language is just semantics.
Thanks for the help, I appreciate it. 
 &gt;I think though that Python starts to steer a bit too much into the feature-bloat direction. Agreed. I really don't think any outcome of PEP572 makes the language fundamentally better. (Or the code written in it for that matter). So definitely not worth losing Guido over.
this would be blocking to some degree, not in the async'd aspect, but in terms of waiting for something... Would slow down the app alot. 
Gevent is greenlets.
I am surprised that the community are suddenly such language design experts and feel they know so much better than the guy who gave them Python. The only 2 correct responses to Python's design decisions... its good, or lets wait and watch.
The two most common, I'd expect.
Corey Schaefer hands down. Sentdex also has quite a few videos worth checking out. They're both professionals and take the time to explain every single last detail of what they're doing (unless they're explaining something like a library, which would assume that you already know python, or whatever language they're teaching in the video) 
Pipfile can in no way be more common that setup.cfg/direct setup.py use. It is far too new and without direct support. And again, Pipfiles are not supported by pip. In comparison to pyproject.toml, which is used more is a tossup but I'd say that Pipfiles are used more than pyproject.tomls. But in no way can it be larger than setup.cfg/setup.py.
This is what I don't understand. Since Python maintenance will stop [in roughly 1,5 years](https://pythonclock.org), they should start porting their stuff to Python 3. Don't you agree?
Probably indentation. Move `f.close()` outside of for loop. This works: from urllib.request import urlopen as uReq from bs4 import BeautifulSoup as soup myurl = 'https://www.newegg.com/Desktop-Memory/SubCategory/ID-147?cm_sp=CAT_Memory_1--VisNav-_-Desktop-Memory' uClient = uReq(myurl) page_html = uClient.read() uClient.close() page_soup = soup(page_html, "html.parser") containers = page_soup.findAll("div",{"class":"item-container"}) filename= "products.csv" f = open (filename,"w") headers= "brand, product_name, shipping\n" f.write(headers) for container in containers: brand = container.div.div.a.img['title'] title_container = container.findAll('a',{'class':'item-title'}) product_name=title_container[0].text shipping_container = container.findAll('li',{'class':'price-ship'}) shipping = shipping_container[0].text.strip() print('brand: ' + brand) print('product_name: ' + product_name) print('shipping: ' + shipping) f.write(brand + "," + product_name.replace(",","|") + "," + shipping + "\n") f.close() 
I know a bit of R but mainly work with Python. R is a fantastic language for data manipulation but python also can be just as powerful. I would learn whichever you’re more interested in first. After you understand it well, then look into the other. I’d recommend python as it has tons of libraries and modules that can be fun to play around with such as matplotlib, numpy, pandas and much more.
Do you use async? No? Ok, so let people who do actually be able to do async well. They're feeling their way through a new syntax. They don't have 80 years to stand on. The people that complained about the matrix operator @ don't use it. It's very helpful. Get over it and move on.
Assigning to a variable is not always considered a side effect. Modifying an existing variable is a side effect, but defining a new variable arguably isn't: for example, a single-assignment language would be considered pure regardless of its assignment syntax. I feel the bulk of use cases for this feature would assign to new variables, so on the aggregate I don't think this would make it any harder to reason about code. 
I don't believe I've ever seen dependencies specified in setup.cfg. Could you point me to a project that does that? I also just ran through a sample of github results for `install_requires`, and while by no means all, a surprising number were "read in requirements.txt". That said, you're right that setup.py is more common, but for exactly that reason it cannot be parsed in general.
Thank you so much!!! Just so im clear on whats going on I have to indent everything in the for loop for it to work? When I was working on it I remember getting some indentation errors but I wasnt sure how that affected everything.
I'm pretty sure you want cupholder, good milage, safety, cheap, long lasting, power, etc. I don't care about rims, but there are companies dedicated to rims. The hybrid/electric car introduction totally failed because nobody really cares about good mileage and people didn't like what manufacturers made. Would you take 10 more MPG for 10% less horsepower for the same everything else? It's an easy question for me.
Indentation is part of Python. In other languages like C, curly brackets are used to indicate which lines of code belong to an if-clause or for-loop. Python uses the indentation level to decide which lines of code belong to what block. E.g. def somefunction() //everything inside //someFunction() goes here - for i in range(1, 10): //this section of code to be //repeated by the for loop.
Dan Bader also, his videos are pretty dope. 
In that case, maybe a 50% required core vote to vote to put it out for a public vote? i.e. they recognize something is like a 'cupholder' and want to ask the masses, but for most 'engineering decisions' it stays internal 2/3
Recursion Demystified! https://medium.freecodecamp.org/recursion-demystified-99a2105cb871
Okay that makes everything so much clearer. I come from R where you just use curly brackets for loops and you don’t have to indent anything to make something work. Thank you again for the help. 
&gt;Do you use async? No? Ok, so let people who do actually be able to do async well. They're feeling their way through a new syntax. They don't have 80 years to stand on. They've been creating and abandoning async libraries for years, no one other than the nutjobs think that embedding it into Python would produce different results and now the rest of us have to deal with bloat for the rest of Python's life. &gt;The people that complained about the matrix operator @ don't use it. It's very helpful. Get over it and move on. The people who complain about semicolons and curly brackets wouldn't use them, so why not add them?
Well, this is really a big topic of debate. I'll give my personal opinion at the end of all the context, which I warn you, will be large. Python 3 is objectively lower on startup times (however rumor has it 3.8 will bring us to Py2.7 startup speeds, negating that argument). So if the product spends more action starting up than executing, like mercurial, you get fucked. Of course if it's not the case, except for a few super niche benchmarks, Py3 is always faster. There's also the theory of what is taught at educational institutions. Anybody who isn't a computer science major will probably be taught Py2-- they just don't need to upgrade and every algorthm can be written in Py2 as they can in Py3. Even in CS majors, many times they don't care to update. When I visted my college recently, I noticed the CS labs were running Ubuntu 12, Python 2.6/7 depending on the machine set, and the Java course was taught using Java 7, but they switched to Java 8 a week or so in. Java 10 is the current release, Java 11 will be the current release in September, 12 will come ~6 months later. Many companies using Java stay on Java 5-7, you'll be lucky if using 6+. Some companies also have to use tools like Webpack to make ES6+ JS turn into ES3 JS. *ES3*. Not ES5. I mean, if not ES3 than it would be ES5 which is the majority. The same goes for Python-- take a look at the site you are on. It was originally written in Py2.6 or earlier, evidenced by conditional code redefining some stdlib functions if not found, which were introduced in 2.7. *New* site services are being written in Py3, and when things need to be majorly refactored, they take out that service from r2 (main reddit app) and rewrite into Py3. But thats really on a "do on mini doomaday" scenario. Going back to the education thing-- lots of libraries are Py2 only. The ones public on PyPI alone are over 500. And that's the ones that are clearly labeled as Py2 only, not the ones not labeled at all. And that's on PyPI alone, there are plenty of other distribution networks as well. These are libraries that just work and their maintenance has stopped, or they depend on something of that nature. No need to change the tires when they have at least another couple thousand miles in them. This is more common in education than in business, but it exists in both worlds. In business, it gets worse-- because many times Python is used as glue. Glue to stick together a variety of things, whether it be build scripts, web servers, data pipelines, and more. Glue is generally a one time apply kind of thing. You don't use a fancy new glue unless you need to change something about the things being glued together. Because the glue just-- well, it fucking just works, and lasts a long, long time. It would cost more to update your glue than to just add a little more here and there when the edges start peeling. And then when you start glueing a new thing, you find that the fancy glue and the older glue don't mix well, so you use the older glue. Because it works. I'll give you two egrigous example-- React needs Py2 to build. Grumpy only works with Py2. As do many of the millions of lines of Python code at Google. Why? Because it will always cost more to upgrade. The points against this are as follows: * zero day attack * lack of new features * internal C bugs And the strong rebuttals are as follows: * either sand/black box or company takes the responsibility to patch the VM * company or third party patches the VM. A Py2 port called Tauthon already has a lot of Py3 syntax ported to Py2 * Py2 is more mature than Py3, if anything, time has shown Py3 has more of these rare bugs and segfaults than Py2. And again, company can patch it. The patch it thing goes back to the glue/screwdriver analogies-- why use a new version, on all of crafts, when you can make a minor change to your old version or not at all and it works? And this all started because of Py3 and how it was handled. Py2 had great backward compatibility and greater forward compatibility. Py3.0 threw this not out the window, but into the sun. The unicode debacle was horrible. 3.0, 3.1, 3.2, and 3.3, are widely regarded as Py3.0 beta, and Py3.4 being the actual Py3.0. And even then the debacle remains. Even worse, they have great backwards compatibility for 3.4-3.7 (maybe even 3.8, god willing), but horrible for forward compatibility through it, which has really given library maintainers a piece of hard as rock shit in a box and telling them to shove it back up their ass. I can elaborate on this if you'd like me to, but I won't here because it is mostly irrelevant. The point being, given all of the above, is it still so cut and dry to you? If you say yes, you arent putting yourself in the perspective of those users, and only care about yourself. Which is fine. But don't expect people to give a shit about you or your projects then. --- Now on to me. I am a Py3 evangelist. I write everything new that I need so it will work in Py3.4, and rarely say fuck it and make it work in 3.5-3.8 only. Hell, I'm even giving Pylons the port to Python3.4 that it was going to but never got, because I am a huge supporter of Pylons' model over all other Python web frameworks. Call me old fashioned. And if you do, fuck you, I'm old and grumpy. But this port won't be for public consumption, it'll be for little old me. I am not going to provide major support unless I care about the individual issue, because I am one man, and Pylons was managed by a gigantic team that decided to give up. If what I write, whatever the app, is written in such a way that it can be used in 3.4, I will also guarantee support for Py2 until at least 2025, and I know I will be writing Py2 until the day I die. Because EOL/EOS means nothing in the software world. "End of common use" does. And common is subjective to a number of factors. I'm a Py3 evangelist. Yet, ***I concede the fact that:*** ####***Py2*** ###***will*** ##***never*** #***die.***
&gt;wow... so much anger. Wow... so sensitive. This isn't a hugbox, if the words I use hurt your feelings that's your problem, if you want to cope by whinging in public go right ahead. &gt;if you think there are 4 great examples and 1 not so great, it is still a win. Why not just leave out the 1 bad example? Lack of foresight? Lack of proof readers? In these cases it begs the question of why is someone who is so demonstrably incompetent being responsible for the future of the language. &gt;They also gave not so great examples. They were presented as great examples, literally touted as "Improved". This PEP that wasn't even proof-read was implemented without requiring an import from future to gauge a real-world response to it. It was implemented without concern of feedback, don't take my word for it, look at what Guido said: &gt;I don't ever want to have to fight so hard for a PEP and find that so many people despise my decisions. It seems like the only reason why he asked for feedback was to boost his own ego, and now that that well seems to be drying up he goes on a "permanent vacation" without a succession plan. Why even bother defending this?
There's more than two responses, there's a "let try this as a temporary feature and see how the users like it" response too. Nah, let's just slap that shit on and go on permanent vacation without a succession plan when people get pissy that you only asked for feedback to boost your own ego and got the wrong response.
I'll point you to some uses of setup.cfg in the morning, but as for the setup.py thing-- you can easily parse them using `ast` and `mock`. Determine if it is directly passed into `setup()` or dynamically genersted. If the first, you are done. If not use `ast` to find as many potential inserts into the list held by that variable as possible. Also still no reason *not* to parse setup.cfg / pyproject.toml. they are just as easy if not easier to parse than Pipfiles.
If differences are subtle, then they are not important and probably even harmful. Making devs think about something which has no relevant benefit just slows down work for no reason. "There should be one-- and preferably only one --obvious way to do it."
I think that's true. I've been following the PEP 572 debate for a while, and I kept getting a sense that something unusual was going on. Normally there's a syntax squabble which culminates in a widely-accepted solution everybody pretty much likes, but this was very divisive and different. Too bad.
/r/learnpython
&gt;Ever use Perl6? Yes! There's *dozens* of us 😄 Honestly, it's a pretty nice language with plenty of interesting ideas.
Well, the easiest way is probably this: from string import digits for digit in digits: if digit in password: break else: # Yes, this is correctly indented print("Password needs to contain a digit") On the other hand, limiting users for their password choices (excluding a minimum length) actually make it easier for a cracker to guess/bruteforce the password, so I'd suggest NOT adding these constraints if at all possible. 
A string method can be found in the [manual](https://docs.python.org/3/library/stdtypes.html#string-methods). Also, you want r/learnpython.
You're working too hard.
If the structure of the query is always going to be the same (i.e. [number unit to/in unit]) you can very easily do it yourself, and pint already has all the conversion tables you need. 
r/learnpython
What I've found many programmer forget about asyncio is that it's still old blocking code, and that your goal is to block as short as possible or give back the execution to the event loop. The loop will not switch tasks between Python statements unless you `await` on something. When you're inside an async function and you do some maths, iterate over a list or whatever the whole function blocks but for how long, like 100us? The event loop will still have plenty of time to schedule other things before the IO will be ready. Even if asyncio is in debug mode it will only emit a warning if your function blocks more than 100ms (thats 100.000us) (see: https://github.com/python/cpython/blob/master/Lib/asyncio/base_events.py#L362). So don't be afraid of using `itertools.cycle`. It is pretty fast. However what I'm not sure about is that if Sanic workers are built on the top of `multiprocessing` it might not be obvious to share that generator object.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [python/cpython/.../**base_events.py#L362** (master → d6345de)](https://github.com/python/cpython/blob/d6345def68d3a0227253da26213dadb247f786db/Lib/asyncio/base_events.py#L362) ---- 
PyPDF2. It's reading as binary, but if you're looking to read as text, I believe there are ways for that as well. I only needed to edit by adding some data (using canvas).
&gt; Wow... so sensitive. This isn't a hugbox, if the words I use hurt your feelings that's your problem, if you want to cope by whinging in public go right ahead. You are confusing pity with whining. To clarify, I was pitying you that you are carrying so much anger around and spewing it arbitrarily on the internet. Having read some of your messages, you don't have the ability to hurt my feelings... and its sad see you try. No no... don't take my word for it. Try your best. &gt; Why not just leave out the 1 bad example? Lack of foresight? Lack of proof readers? In these cases it begs the question of why is someone who is so demonstrably incompetent being responsible for the future of the language. Because the author wanted to show all kinds of new use that is possible... not just the best. The mediocre ones too. Also, they even documented some possible bad uses and warned against its 'misuse' which could produce worse code (which is true for any feature). People who want to present an all round picture don't just show the best examples... they try to show the whole picture. It is honesty that makes them keep the mediocre examples in the PEP. &gt; I don't ever want to have to fight so hard for a PEP and find that so many people despise my decisions. An unfortunate side effect of a popular language... even a tiny vocal minority can seem like a lot of people. &gt; It seems like the only reason why he asked for feedback was to boost his own ego Lol... GvR boosting his ego. You come up with the most interesting reasons to defend your viewpoint. &gt; Why even bother defending this? Because I have respect for the BDFL and his decisions. There is a reason he is the BDFL - he has the right to do what he did - including making mistakes or taking unpopular decisions. I plan to wait and watch to see how the feature plays out before making up my mind on it. If I don't like it, I won't use it and will discourage its use via good use of words. Also, you seem to think the PEP was proposed by GvR (or mostly authored by him)... it wasn't. It was proposed and majorly authored by Chris Angelico. GvR supported it and added some suggestions and modifications, and thus his name got added to the PEP authors (as the 3rd author). 
I think that this is even clearer: def get_rv(): reductor = dispatch_table.get(cls) if reductor: return reductor(x) reductor = getattr(x, "__reduce_ex__", None) if reductor: return reductor(4) reductor = getattr(x, "__reduce__", None) if reductor: return reductor() raise Error("un(shallow)copyable object of type %s" % cls) ... rv = get_rv() 
What kind of support is needed for NSFW images?
&gt; "let try this as a temporary feature and see how the users like it" That is an design decision option that the implementors have... its not a response to a design decision. Again... the only 2 correct **responses** to Python's design decisions are stated above.
Remember that even if you have a camera without the IR filter, the CCD itself has filters for each color (Red, Green and Blue). Color images are normally stored as NxMx3 matrix, where the third dimension tells you how much of every color there is at every pixel. Since you want to look at the near-infrared, most of the information is going to be stored in the red channel of the image. However, you have no more spectral information that that. The proper way of achieving what you want is to add a filter, [like this](https://publiclab.myshopify.com/products/infragram-diy-filter-pack?variant=1058088684), which will basically block visible red light and will allow only NIR light to go through to the red detector. 
 any(map(str.isdigit, 'Password1'))
I understand that some people have this preference, but is it not simply inertia from C-like languages? You still do indent your code, right? I mean this would be a more valid argument if we were using plain windows notepad for writing code, then curlies are indeed helpful. But nowdays with rich editors and even notepad++ supportint indentation guides this is less of a problem than ever. Dont you agree?
Yeah, it depends on the perspective. It's a very high-level feature overall, yes, but it works best as the foundation for libraries and frameworks instead of being used directly. 
https://realpython.com/python-youtube-channels/
Sentdex has some awesome tutorials. 
[removed]
As others pointed out you already know the answer. Ill elaborate a bit for other readers. Greenlets are basically stackful coroutines. This means that we 1. do not need to litter entire API with async/await keywords, 2. we can call greenlets (async functions) from sync code and vice versa and 3. we can yield from non-async function provided greenlet is parent of this callstack (if that makes sense). This makes code so much more simpler. However tooling around greenlet is not as solid as we would like it to be because of lack of adoption in CPython.
A little more context (because you don't seem to have it). Here is the email from GvR about the PEP --------------------------------------------------- A lot has been said about PEP 572. I am planning to accept it soon, hopefully within a week. I realize I should have posted the draft from May 22 (when Tim and I were added as authors and it was significantly updated -- see https://github.com/python/peps/pull/654). For this I apologize. Since then we've been diligently updating various details, tightening the spec without really changing the intended design. I know it is inevitable that there will be replies attempting to convince us that a different syntax is better or that we shouldn't do this at all. Please save your breath. Iv'e seen every possible such response before, and they haven't convinced me. At this point we're just looking for feedback on the text of the document, e.g. pointing out ambiguities or requests for more clarity in some part of the spec, *not* for alternative designs or passionate appeals to PEP 20. Below is the latest draft. All three authors are happy with it. You can also read the PEP online at https://www.python.org/dev/peps/pep-0572/. We strongly prefer feedback in the form of Pull Requests to the peps repo (the file is at https://github.com/python/peps/blob/master/pep-0572.rst). ------------------------------------------------ GvR didn't actively ask for feedback to stroke his ego. He got feedback as part of the PEP process. He thought about the feedback and found it unconvincing. If you have something to back your assertions, I would like to see it.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [python/peps/.../**pep-0572.rst** (master → 8846efd)](https://github.com/python/peps/blob/8846efd623531c0c50ff417800235ce92dc1d51c/pep-0572.rst) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e2b0tgt.)
&gt;You are confusing pity with whining. The words I used disturbed you enough to mention it, it really looks more like whining but if try to spin it go ahead, I won't play along though. &gt;To clarify, I was pitying you that you are carrying so much anger around and spewing it arbitrarily on the internet. Having read some of your messages, you don't have the ability to hurt my feelings... You've already exposed yourself as being sensitive to strong words. No one believes you're some kind of internet badass and even if they did such a title would be an embarrassment. &gt;No no... don't take my word for it. Try your best (I doubt you need any prodding for it - seems to be your natural response). I already succeeded without even trying, you're multiple comments in and you still can't let it go. &gt;Because the author wanted to show all kinds of new use that is possible... not just the best. The mediocre ones too. Also, they even documented some possible bad uses and warned against its 'misuse' which could produce worse code (which is true for any feature). &gt;People who want to present an all round picture don't just show the best examples... they try to show the whole picture. It is honesty that makes them keep the mediocre examples in the PEP. It's literally titled "Improved", not "Here is an example of what not to do". Did you not read it? &gt;&gt;I don't ever want to have to fight so hard for a PEP and find that so many people despise my decisions. &gt;An unfortunate side effect of a popular language... even a tiny vocal minority can seem like a lot of people. Guido references this PEP specifically and not a general hostility towards his decisions. If the language is used by many people as you've said then it would be irresponsible to not have a succession plan in place as potentially many people would be negatively impacted by one person's laziness. &gt;&gt;It seems like the only reason why he asked for feedback was to boost his own ego &gt;Lol... GvR boosting his ego. You come up with the most interesting reasons to defend your viewpoint. What's your explanation for Guido being so pissed that the general population rejected the badly written proposal that he abandoned his position? &gt;&gt;Why even bother defending this? &gt;Because I have respect for the BDFL and his decisions. There is a reason he is the BDFL - he has the right to do what he did - including making mistakes or taking unpopular decisions. I never said he didn't have that right. He has the right to do whatever he wants with the language including making drastic changes without asking. I have the right to criticize someone who pretends to take on feedback when his mind was already made up and expected other people to agree with him then running off while complaining about the response he got. &gt; I plan to wait and watch to see how the feature plays out before making up my mind on it. If I don't like it, I won't use it and will discourage its use via good use of words. So then why not wait until it has seen action before ratifying it as an eternally persistent part of the language? You said yourself you haven't even formed an opinion on it yet so why are you defending someone else's assumption that you'd approve of it? &gt;Also, you seem to think the PEP was proposed by GvR (or mostly authored by him)... it wasn't. It was proposed and majorly authored by Chris Angelico. It wasn't rejected for being demonstrably flawed, it was hastily ratified, naysayers be damned. It's ultimately up to Guido whether or not a PEP that wasn't even proof-read has a permanent effect on the language regardless of feedback. &gt;GvR supported it and added some suggestions and modifications, and thus his name got added to the PEP authors (as the 3rd author). So not only was Guido aware of the contents but he also was capable of making changes.
import re aaa = 'qweasdzxc' bbb = 'qwe1asd' m = re.search(r'\d', aaa) # Here m must be None as no digit found m = re.search(r'\d', bbb) m.group(0) # prints '1'
In C it's bad because the notation is unclear if you meant to do a single or double equal sign. C's notation is what lead to the yoda style of if statements. 
&gt; I know it is inevitable that there will be replies attempting to convince us that a different syntax is better or that we shouldn't do this at all. Please save your breath. Iv'e seen every possible such response before, and they haven't convinced me. There's only two possible cases here. A) Guido is aware of suggestions to make it a `future`-style import to see how the users respond but didn't mention these suggestions because it would make him look bad. B) Guido is not aware of such requests, indicating he hasn't seen much feedback despite his claims to the contrary. 
&gt; I already succeeded without even trying, you're multiple comments in and you still can't let it go. Atta boy... now you are using less cheap words and showing improvement. That was a much better reply indeed. You have potential... Let me just say this... you have the right to not like the feature and speak about it. I just thought your language was too crude and cheap while talking about GvR, and I think you should mind your tongue. Also, given that we are on such friendly terms, I see that I am probably not going to convince you to change your stance / opinion on anything... and similarly, you are not going to charm my socks off. So... long and thanks for not a lot.
I like f-strings too, I just wish we didn't have 3 other ways to do the exact same thing.
Going back to Perl.
&gt; but didn't mention these suggestions because it would make him look bad. GvR has had enough of his own PEPs rejected or modified (without him using his BDFL powers), that this reason just does not make sense. Again... this was not his PEP. The reason I go with is that he really liked the idea and was very sure that it is the right decision for the language.
Design by committee is not the best (or even good)... but I guess, without a BDFL figure, its the next best option. 
&gt;This really bad but honestly you can't go much farther with Python before it looses all appeal as a scripting language. Isn't part of the problem that people think of it as 'a scripting language' when the intention is that it is simply a programming language? To be honest it's not even that well suited to scripting considering how badly it integrates into other processes and how clunky the binding interfaces have always been.
Hmmm. This should have benn posted to the r/Python Official Job Board
I think the anyone voting thing should be more of a straw poll in the early days. At the end of the days these features affect us, as python Devs and we should have some say in its growth and changes. I do like the idea of having people with significant package usage such as the mupy Dev team, Kenneth Reitz etc have a say since they're hyper aware of what's out there.
I don't find videos very effective as a learning resource for programming. Maybe it's a personal thing but I learn a lot more (and faster) by reading. And of course applying it immediately, but you should be doing that either way.
if &lt;any expression here&gt;: Is not side effect free. Nor are any of the looping or other statements that have expressions in them. Expressions can be arbitrarily complex and do anything like open shell and run rm -rf * There is also all the Dunder methods that various statements call. 
Pep 572 is trash. Just a quick glance shows it's one of those backwards clones of phpisms and jsisms like ternary operator and closures with a retarded syntax of Ada? Or is that just full on Goism?
Asynio Et al is far from understandable. Meta class and import machinery aren’t super complex but you have to read spec to understand. Packaging is a clustrfuck mess. There’s lots of junk in python. OTOH Assignment expression “x := value”’s complex explanation is x will be assigned value!?
Some of those examples in the PEP are objectively bad Python. The total calculating list comprehension for example - I would kick one of my developers arses if I found that during a code review, but there it is, in a PEP, as an example. 
If you could have successfully addressed what I said you would have instead of desperately trying to go off-topic.
&gt;GvR has had enough of his own PEPs rejected or modified (without him using his BDFL powers), that this reason just does not make sense. People change, he implied medical issues, maybe he just doesn't give a fuck anymore. I can't blame him for that but I can blame him for being irresponsible about it, if he thinks he's unfit to lead then he should have focused his efforts on a succession plan instead of storming off like a child. &gt;The reason I go with is that he really liked the idea and was very sure that it is the right decision for the language. He was so sure that it wasn't even trialed despite widespread criticism and calls to do just that.
Completely agree. Go for PyQt!
I have addressed many of your points, without you budging or acknowledging even a single bit. I know when to stop banging against a brick wall.
I think this is common to all languages and is inherent to the process. If you're a casual user, you are just grateful to be productive, think in terms of "how can I X?" rather than "why can't I X?", probably won't be so opinionated. Advanced users often know the language well enough to be happy with additions, know other languages well enough to occasionally be envious of their features, and are connected enough with the ecosystem to know how to propose changes and influence their adoption. You gave a good example of MS Visual C++ over 20 years ago but we still see this in C++ today. What most developers would probably want from the language is, say, a usable text class which handles UTF-8 properly. What they got was a new set of object creation semantics and a need to understand the previously obscure notions of lvalues and rvalues, extra syntax for initialising objects, and various new template magic things that are important to people bumping up against the limits of previous template magic things.
Yes. Gives much more consistency: with blah() as x: except SomeException as e: if blah() as x: while blah() as x: That would have been enough. 572 is too fundamental in it's changes IMHO. I worry that Guido's last few features that he championed are going to be viewed as mistakes in the long run. Async, typing, and assignment expressions seem to be changing the spirit of Python, the latter two particularly. I hope I'm proved wrong.
The one-liner is much easier to read!
If that is true then you should have no issue referencing where you addressed the following: &gt;&gt;Because the author wanted to show all kinds of new use that is possible... not just the best. The mediocre ones too. Also, they even documented some possible bad uses and warned against its 'misuse' which could produce worse code (which is true for any feature). &gt;&gt;People who want to present an all round picture don't just show the best examples... they try to show the whole picture. It is honesty that makes them keep the mediocre examples in the PEP. &gt;It's literally titled "Improved", not "Here is an example of what not to do". &gt;Did you not read it?
Ocaml, fsharp, rust, es6 all have the type after the name. Its just conventions.
It has the option to view images from a set of predefined NSFW subreddits sorted into categories. IMO it's a bit weird to include this in the package itself. If the OP wants that functionality and to show this as a project that's not obviously for porn then this stuff should just be configurable with a json or something.
I am personally in favor of PEP 572 and am sad that the negative response is the reason for Guido's retirement. I never thought to put forth my positive opinion because it was a done deal. I wonder how many others may be in favor of it but didn't respond for the same reason. The nay-sayers are loud but are they in the majority?
That's an absolutely terrible idea. Comprehensions/generator expressions are among the best use cases for inline assignments.
An example (which is reported in the PEP as well) is to avoid repeating expensive computations in list comprehensions, which has been a sore point forever. Example: def f(x): # simulate expensive computation time.sleep(5) return 1 # takes 15 seconds stuff = [ (x, f(x), 2*f(x) ) for x in something if f(x) &gt; 0] # takes 5 seconds stuff = [ (x, y := f(x), 2*y) for x in something if y &gt; 0 ] This IMHO is the casus belli that started everything. People were asking for a solution for this problem and that originated the PEP, that sought a more general solution instead of solving solely this.
Recursion Demystified! https://medium.freecodecamp.org/recursion-demystified-99a2105cb871
I guess your style of commenting is part of the reason he doesn't want to do it any more. No arguments, a lot of opinion and buzzwording combined with zero respect for other persons and their work.
I will not stop using Python due this, but I will not use this construct.
Hello! I'm a bot! I see someone has already suggested going to r/learnpython, a sub geared towards questions and learning more about python. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
"Perfection is not achieved when there's nothing more to add, but when there's nothing more to take away."
lmao
Don't start from scratch. An equivalent project still exist even if the creator announced recently that he leaves it: [https://github.com/push-things/django-th](https://github.com/push-things/django-th)
The requirement.txt has no bearing on this, really ... if it includes the optional dependencies they'll be there (though they're not really optional then), if it doesn't they won't be installed. In the setup.py (assuming there is one) optional dependencies are declared with `extras_requires`: extras_require={ 'feature': ['some_package&gt;=0.2'] } And if you want to enable *feature* you do: pip install this_package[feature] And the optional dependencies for it will be installed. I don't believe there's any way to discover the optional items without looking in the setup.py.
Are you sure that learning programming by watching is the best learning way **for you**?
&gt; maybe it's a personal thing it is and it's especially true for fast readers indeed. you can't watch a video at 10x speed 
So what's the problem with this? Just the syntax and making the code less readable? Is that the argument? I'm not involved or keeping up at all with the core development so I missed the 'drama' and I'm trying to understand the counter arguments to learn. Inline assignment was one of the things I missed in python and I like your example much more then how it was, but that's just taste 
Thanks, I'm aware of `extras_require`, but does that install those packages first, then maybe the main package has a `try import` in its `setup.py`
&gt; you don’t have to indent anything the fact that you don't have to doesn't mean that you don't need to sure for software like compilers or interpreters indentation doesn't matter much, as long as it's not part of syntax like in python's case, but humans read well indented (and syntax highlighted) code much better
It's really weird how every single time PEP 572 is mentioned in passing, people just \*have\* to comment on how much they hate it/not hate it. I've never seen this with any other PEPs. Even PEP 484 (optional static typing) wasn't that bad in that regard, and that's a way bigger change.
Github is already becoming a nightmare under Microsoft, like 1 out of 3 browsing attempts over tor browser don't work anymore :(
blocking != slow. And if you're worried about starving the worker threads you can just set maxsize to a constant &gt; the number of worker threads, so the feeder thread will only block after all the workers are busy.
Yes I completely agree with you. I just meant to get the code to work. 
Does this mean the version after 3.9 can be 3.10 instead of 4.0 now? Other than that I think I've been in favour of all his decisions.
don't get me wrong, website scraping is not the most trivial programming task if you're a Python beginner, I suggest starting with simpler things, like the official python tutorial
Sure, what argument can you provide for a BDFL who thinks we need more syntax issues? Python was meant to be (https://en.wikipedia.org/wiki/Python_(programming_language), https://docs.python.org/3/faq/general.html) a clear and concise language, how does PEP 572 help with that? Have you read about that PEP? I wholesomely respect Guido van Rossum and his decisions up until Python 3k (though he wasn't majorly involved in that). I already wrote numerous posts about issues with Py3 choice for replacing string with utf8 by default and all the encoding mumbojumbo ensued. The difficulty of conversions from one to ascii and backwards for not obvious reasons. Sure there were much better options which would be also backwards compatible like leaving str alone and implementing a short unicode string syntax with, say, a u"" in front of definition. For me the final nail in the coffin of Py3 was implementation of await and asyncdef... Sure some people will say it is rising in popularity, but I will skip to 4, will see what it brings. No multicore support (when I'm running a pack of modest 96 core rigs) in 2020? No more Python for me. I've waited enough and used enough kludges. I'm pretty sure a lot of people here would agree with me. I might sound bitter or angry, for that I ask forgiveness as I did not sleep this day well and I have already wrote all of this in a clear and concise way a few times. - Native speed Multiprocessing and multithreading. - Rename asyncdef to adef to retain some logic - Add tdef and pdef to easily specify processes and threads without any modules - this should be a part of JIT - Remove the current ternary operator or replace it with something clear and concise like Condition then True else False Which you can easily find in code by "keyword" and follows similar logic like in other languages. I've literally never encountered Python ternaries in any active project because they simply suck ass. - Assigning in the while loop statement? Pretty useful in PHP and clear and concise. - Switch statement? Nim case statements look delicious, I'm sure similar syntax is possible. Maybe implementing the aforementioned **then** - Maybe fix the encoding mumbojumbo? I mean the default case for most of work with strings is bytes, changing a default type to which majority of the programmers are accustomed was a really bad decision. This might be fixed backwards compatibly by providing ability to overload default string encoding and thus finally... - Implement all native type classes as overloadable objects? - Create portable compilers for the code? So you can actually deploy the software without all the craze of virtenvs and non-monolithic structures? Sure there are third-party implementations but wouldn't it be useful to write code once and compile for all OSs straight from same place ready to deliver and be paid for work? Like many other languages already do?
I actually don't think it's a good idea to include shared library in a wheel. I did this when creating MS Windows wheels because generally MS Windows users wouldn't have a way and knowledge of how to install shared libraries. So, I just put it in `package_data` and then used `ctypes.DllLoad` to pre-load it. But, on Linux I wouldn't want this to happen. I'd rather use a shared library installed in the system. The reason for this is that if people install the program as users (as opposed to installing it as developers), they'll be installing it together with Python and all of its packages in some place like /usr/lib, /usr/local/lib, /usr/share/lib etc. and they would be probably installing it with something like `apt-get`, `dnf`, `pacman` etc, where the package maintainer will have to take care of shared library and compatibility issues. But, if they are installing it as developers, and they want a version different from the one that's already on their computers, they will have to play the role of package maintainer and arrange for that different version of the library to play nice with other things it needs. I cannot really do this for them because, in this case, I know nothing about their environment and all bets are off. If I try to put it in some particular place, I may just make matters worse for them.
&gt; Making devs think about something... WTF? Isn't that what they are paid to do?
The obvious answer: def stuff_gen(): for x in something: y = f(x) if y &gt; 0: yield (x, y, 2*y) stuff = list(stuff_gen())
His twitter profile was quickly updated to say "emeritus BDFL"
a \`\_\_init\_\_.py\` file \*
That's a change of tone then
working on a car license plate recognition system for android
1. r/learnpython 2. Use str.split()on what you get. For example: \# Presumed input; you can change spaces to \\n if you have that, but it should work b = "(192.168.254.43) (192.168.254.254) (224.0.0.251) ([239.255.255.250](https://239.255.255.250))" \# First split on ) to separate individual adresses, then use split on ( to clean it up ip\_adresses = \[x.split("(")\[-1\] for x in b.split(")")\[:-1\]\] 3. r/learnpython
I would also classify asyncio as one of guidos mistakes, but the issues are more around semantics than syntax. Similarly decorators, metaclasses, etc... the semantics are very complex, and trying to learn how to do these things is hard. But syntactically they are clean. A function that returns a function of returns a class it the like. Anyone who reads this stuff with understand what is going on but not why you need to do thins this way. 
Doesn't ensure_future fix this?
Can't you just call ensure_future to turn a coroutinr into a future?
Can you write this code elegantly without the := operator? `if x &gt; 0 and (ans := calculate(x)):` `foo(ans)` `elif y &gt; 0:` `foo(y)`
Why should we respect dictators? If guido is uncomfortable with this kind of direct criticism, it would have been a good idea to take a different label. Establish a set of ground rules that would constrain his actions while also establishing what other people could do to push the language in the direction they wanted.
If you're using Python3, you should look into the \`concurrent.futures\` module. It has a \`ProcessPoolExecutor\`, basically a very nice interface to multiprocessing. One potential problem I see in your code is that it starts a new process for every URL, and since the number of URLs isn't known you could end up starting a lot more processes than is healthy on your system. (Of course, depending on your situation this may be a non-issue.) In any case, \`concurrent.futures\` gives you a really nice way of starting a defined number of worker processes (or threads, if you want to do multithreading instead of multiprocessing) and feeding any number of tasks into the worker pool. It handles all the queueing of work behind the scenes, so you can just create a \`concurrent.futures.ProcessPoolExecutor\` with 5 workers, feed it tens or hundreds of tasks, and the five workers will just keep plowing through all the work to be done until they're finished. They also provide a nice interface to collect the results of finished tasks whilst unfinished tasks are still running. Check it out! 
2to3 may work. But if you have a lot of code it's likely you've just been lucky about bytes versus strings.
No, I am paid to create features. I want tools that make this as easy as possible. 
No, they are paid to solve problems. Everything not serving this goal is a waste of ressources.
No, daddy, noooo… \*starts crying\*
I mean it's in print on python.org and it's what you'll hear at pycon. Everything works - but apart from "support legacy code" do you have a technical reason for doing something different? 
This will be of some relevance to you https://docs.python.org/3/howto/pyporting.html
Dropping the mic after turning the volume to max.
Well that's a bit drastic. Just because the ship lost its captain doesn't mean you should try tp use a shark as a boat.
I hereby declare my candidacy for future BDFL. Here's a list of qualifications: * Dude, I got this
:(
The thumbnail is Einstein? The old Einstein quote "spooky action at a distance" (from when he tried very hard and failed to refute quantum mechanics) made me think about which programming language he'd use: raw C pointers would certainly be examples of spooky action at a distance.
Trying to bind a Django project with Vue and DRF.
If it's performance you want, you [should consider](https://stackoverflow.com/questions/18671528/processpoolexecutor-from-concurrent-futures-way-slower-than-multiprocessing-pool) using `multiprocessing.Pool` rather than `concurrent.futures...`. Also when your tasks are IO bound (like downloading things) rather than CPU bound, you can just use threads. In that case, the overhead of creating multiple processes is unnecessary.
It's happening in every language unfortunately.
This video is so good, I didn't even know that for loops had else statements or that try except also has else and finally
Yet the majority of python's libraries are written in C
Virtualization and path replacement isn’t really new, but this very well done
You shouldn't need python libs at install time, maybe just something like gcc. Setup.py is just for python stuff.
Good point about limiting threads, Thanks you for noticing that. It is top item in my todo list. Currently we are using python 2.7 so will have to use multiprocessing or threading.
[six](https://six.readthedocs.io/) is also useful for this
Yes. I agree with you. Currently it is hitting local package server twice to get best match egg. I am working on a technique to avoid it. It needs some extra processing power. So I chose multiprocess. But you are very right.
Regardless of one's POV, the result is still sad. It's making it easier to fork Python.
I liked the idea at first but I find it very limiting to only add assignment expressions for `if` and `while` and frustrating that you know have 3 types of `as`, the one used in `with` statements, the one used in `try-except` blocks, and then the ones used in `while` loops and `if` statements and they all do subitly different things. Further it doesn't solve using them in comprehensions as was a big motivation, nor terinaries which seem logical if you're going to allow them in `if` statements. That aside how do you handle order of operations, for example: if bar(x) + foo(x) as baz: Is `baz` assigned to `foo(x)` or `bar(x) + foo(x)`, both seem like plausible solutions but `:=` is unambigious. It gets worse, what about: if bar(x) or foo(x) as baz: In this case if `bar(x)` is True so `foo(x)` isn't executed does the assignment to `baz` occur at all? It's totally possible to come up with a logical set of rules for `as` but looking at such examples it seems you have to make some arbitrary choices which you don't have to do with `:=` .
People don't understand what "benevolent dictator" means. Dictators don't have to fight for a PEP. They just do it and vanish or block dissenters. Benevolent Dictator makes rules that benefit the state, rather than hoard all the money and priviledges. They're still dictators.
It's not dead. It's resting.
There is support for (1) NSFW subreddits (these are read from a YAML file that can be edited), (2) images on an NSFW gallery usually follow a pattern and thus they can packed into a sequence URL (e.g. http://host/gallery/img[01-20].jpg), and (3) you can extract all images from an arbitrary webpage. Of course, you can use JiVE for SFW content too but these three points above facilitate NSFW surfing.
I would much rather read a text than sit through 25 minutes of a video. Just saying.
The message is written in such a devastating way like he has been burned out. :(
They can add exclusions to the ATP whitelist by navigating to: Menu &gt; Policy &gt; Policy Catalog &gt; Select "Product: Endpoint Security Adaptive Threat Protection" &gt; Select the appropriate policy &gt; Click "Show Advanced" &gt; Exclusions From here they can whitelist based upon Name, File Path, MD5 hash, and/or Signer.
Same. Can someone do a tl;dw? 
&gt;\Not shipping all your packages with curated porn in 2018. Clearly Django and Flask have a thing or two to learn from here.
Repost
This post is better suited for r/learnpython 
This post is better suited for r/learnpython 
This post is better suited for r/learnpython 
Jesus Christ, no wonder software engineering is in such a terrible state. "Understanding the difference between a sledgehammer and a claw hammer is a waste of resources. I'll just use a book to pound a wood screw through 3 inch steel plate. I'm paid to solve problems!"
No. What he says is that the difference between three different ways of doing the same thing make you waste more time determining the ideal solution insteas of going with something that works adequately well for a topic that is mostly not relevant in the grand scheme of things.
I don't know anyone that would describe the difference between a claw hammer and a sledge hammer as "subtle"
&gt; I don't think this has any meaning in python. I guess your right. Though sometimes it feels a bit hacky to access things you not suppose to? I rarely seen tests in `project_name\package_name\tests`, so I'm guessing most of the community do as you mentioned - testing thing on the package level. 
I actually did substantially the same test with python 3, which is the language affected by this pep. 
Pytesseract can help u I think, Try it.
Right, so now people using `:=` in a comprehension are probably going to be surprised. 
Is this? I'm sorry, I hadn't seen it yet in this sub...could you link the original post so I can watch the comments?
Cool stuff Thank you
Putting into something queryable using sql would make this pretty simple.
So you're like, a piece of shit, right? Is that your thing?
He is also popularly quoted for "Everything should be as simple as possible, but not simpler". Depending on what you want to achieve, C does not fit that profile ;)
The worst decision they made, IMO, is writing a new language but naming it Perl 6. 
Not sure what you're asking here, why would setup.py need to import them? Though I haven't really looked under the hood, I believe that pip call installs the package (if it wasn't installed already) and all it's *install_requires* dependencies, plus those listed in the *extra_requires* for the feature you're enabling. I don't believe it *just* installs the optional dependencies, but rather adds them to the list as if they'd been in *install_requires* all along. The package itself probably does do a try...import, but I can't think of an obvious reason why the setup.py would need to.
https://medium.com/@winston.smith.spb/python-ocr-for-pdf-or-compare-textract-pytesseract-and-pyocr-acb19122f38c
These types of videos really need to have timestmaps in the description that you can click to jump to each of the 7 'simple tricks'.
That why I said "(some)". I wouldn't make it open to the world. Only committers and others that created an account to vote which was manually approved by someone following some well-defined procedure.
a career will require much more than knowing python. Unless you are becoming a web developer, you should probably learn the basics of computer science - data structures and algorithms, those are by far more important. If you are really just getting started Code academy has a bunch of interactive free tutorials that I do think are helpful because they show you the nuances of the python language from the start. That way when you try to apply it to other things like data structures or algorithms you should already have an inkling of how to do it the "pythonic" way. 
Wow that's some very bad music in the video.
Try r/learnpython.
Well, you're supposed to use `create_task` now. And no. This is what I'm talking about the rift. If I create a Task, then I can't await on it, there's no way to "execute now if you haven't already", and if you add callbacks to Tasks, you are fucked. Exceptions aren't properly passed through-- and any results of callbacks are lost. When adding a callback, a new Task representing the combined object should be returned but it isn't.
There's an blog linked in this sub recently about for:else and how you really should not use them because of insanely confusing they are.
It's going well and working properly. Not sure what I can do w/ the data, but it's interesting to have access to it.
Please see my other comment responding to you https://www.reddit.com/r/python/comments/8yapie/_/e2bggzz
How is it confusing? It just executes everything that's part of the else statement if the for loop didn't have an outcome
Then you could easily skip most of the video, which I suspect some of the authors do not want.
lol :)
Hi everyone: I have just finished a new subproject in my github repo [https://github.com/neozhaoliang/pywonderland](https://github.com/neozhaoliang/pywonderland), it draws various kinds of 3d and 4d polytopes. You can see more examples in the website for this repo at [http://pywonderland.com/polytopes/](http://pywonderland.com/polytopes/) Hope you enjoy it! This repo was motivated by the famous math movie "dimensions" at [http://www.dimensions-math.org/](http://www.dimensions-math.org/), I firstly saw the movie about 10 years ago and was fascinated by it, but it was not until this year that I got the full understanding of all details that how it's rendered. The program is written in pure python: only numpy is used. sympy/sage/mathematica are all not required. It computes the data of the polytope and export to POV-Ray for rendering. The code is not complicated, it's only hundreds lines long, but the math is a bit involved. If you have any questions, do ask me here.
But I think in general the author should realize that a 25 minute run time is an instant turn off for many(many) people. If their goal is for their content to be consumed/useful they should keep that in mind.
Please show me where python.org has this info. The packaging subdomain is handled by a separate team. Yes, the technical reason is the methods I state are not only not legacy, and in no way deprecated, pyproject.toml is also an official format supported by the Python core team, and is actually newer than Pipfiles. Setup.cfg and the use of setup.py are in no way deprecated. Once they are, sure, don't give a fuck about them. But they aren't.
How? It's a *new* operator. New operators bring new behavior. It isn't changing an old one.
I'd disagree. I've intentionally used % formatting over format before because of a subtle difference: it's faster in certain cases. Specifically, if you have to do a lot of formatting (such as for a specific file format where all the values are numbers), it can be significantly faster to use %. I hate using it in regular code, but it's a handy trick to have around. I didn't discover it on my own, though, I definitely stole it from how numpy does csv files. The case I had was an almost-csv file, and getting an extra 100ms per file written was definitely a big deal in that case. 
Thanks a lot for this practical information! I’ll check it out ☺️
Hi everyone: I have just finished a new subproject in my github repo [https://github.com/neozhaoliang/pywonderland](https://github.com/neozhaoliang/pywonderland), it draws various kinds of 3d and 4d polytopes. You can see more examples in the website for this repo at [http://pywonderland.com/polytopes/](http://pywonderland.com/polytopes/) Hope you enjoy it! This repo was motivated by the famous math movie "dimensions" at [http://www.dimensions-math.org/](http://www.dimensions-math.org/), I firstly saw the movie about 10 years ago and was fascinated by it, but it was not until this year that I got the full understanding of all details that how it's rendered. The program is written in pure python: only numpy is used. sympy/sage/mathematica are all not required. It computes the data of the polytope and export to POV-Ray for rendering. The code is not complicated, it's only hundreds lines long, but the math is a bit involved. If you have any questions, do ask me.
C++ is somewhat getting this. On the usability end it just keeps getting better and better. On the arrogant showoff end it gets worse and worse. I literally see people starting to use "modern" symantecs as the "recommended" way to handle and initialize things like an int. The funny thing is that things like the new for iterator is only 100 kinds of awesome, yet I see the fancy-pants idiots clinging to .begin() .end() usage like it is the only thing supplying them with oxygen. For instance (see what I did there) openmp doesn't support the modern for iterator and I think this is to keep it as incomprehensible as possible so that openmp remains the domain of academics. The same with many of the algorithm features in C++17 not using it either. 
youtube?! #ಠ_ಠ
Dude... This is the top post right now in r/python and has been for 22 hours.
I think, like all widely used projects, python is a lot of different things to different people. The scripting side of things has always been the standard library support afaict. 
print("Goodnight, sweet prince.")
See the discussion here: https://www.reddit.com/r/Python/comments/8fkbem/the_forgotten_optional_else_in_python_loops/
It's on their site so it's there with their approval. I'm ok with pyproject.toml except that's no-one's using it, which means poor tooling support. This may change in future. I'm not saying GitHub should not add it, just why they haven't currently got it yet.
You dont have to do that here either. Just treat it as an expression to be evaluated
Feel the same way. Even running these things at 1.5x speed they tend to be too long.
Just go to the official docs of Python Django
I don't follow, how does that solve order of operations? Or the fact that `as` now has 3 different meanings depending where you use it? Also how would you implement motivating examples like: while (line := f.readline()) and line != 'ENDDATA': # code logic 
[Here are (at least) over 8000 cases](https://github.com/search?utf8=✓&amp;q=filename%3Asetup.cfg+requires&amp;type=Code) (assuming Github search isn't absolute shit and adds ) where dependencies are defined in setup.cfg. Of course I didn't specify stable/dev/test/extra/PyVersion dependencies, but, well, they all are dependencies. For stable end user dependencies specificallt alone, theres at least [1160](https://github.com/search?l=INI&amp;q=filename%3Asetup.cfg+install_requires&amp;type=Code) of them, and you have to keep in mind that unfortunately the more specific of a variable name you search for in github the more likely you are to have a result unintentionally skipped. On the other hand, over [800k projects use requirements.txt](https://github.com/search?utf8=✓&amp;q=filename%3Arequirements.txt&amp;type=Code). [15k projects use Pipfiles](https://github.com/search?p=3&amp;q=filename%3APipfile.lock&amp;type=Code&amp;utf8=✓). [1k projects use pyproject.toml](https://github.com/search?utf8=✓&amp;q=filename%3Apyproject.toml&amp;type=Code), and you have to consider it is newer than Pipfiles, marketed for with less oomph than PyPA and Kenneth marketed pipenv all over the place, and also is mainly for a different purpose altogether-- less dependency management and more dependency declaration and general build information-- basically being the all in one solution for being able to do basically everything of the other four formats I mentioned. There's no good way to measure "just setup.py" use, but a decent estimate is existence of an install clause in that file and no requirements.txt, and I can't do that with github search because it searches for files, not groups of files. But, [140k people declare dependencies in setup.py](https://github.com/search?utf8=✓&amp;q=filename%3Asetup.py+require&amp;type=Code) I can understand that functionality on setup.py would be more difficult to guarantee, but it is still possible experimentally. 150k people (and growing, because these formats are still standard, and should be used depending on the project) should not be left in the dark! Especially since covering some of them is no harder than covering the rest.
Neither of these "tricks" were anything new, \*\*\*if\*\*\* you learnt python from a textbook.
* enumerate * zip * assign two values at once. x, y = y, x swaps x and y without a tmp. * use .get on dicts when you don't know if they contain the key, you can specify a default. * else can be used with for, else is executed if no break occurs in the for * with open(filename) as fh: . I'd be surprised if people didn't know this * try, except, finally, else. Else is used if except doesn't happen. Finally is executed after any of the other things, its always last. Nothing anyone really cares about. 
Didn't Dropbox already do that with type hinting? Always gave me the feeling of the feature being implemented and welcomed so quickly by Guido because of his employment at Dropbox.
They have to have a 25 minute runtime in order to monetize. People that are able to monetize are unusual making something entertaining that advertisers want to place their ad on (making the video come out to 30 minutes like a traditional tv show. This guy however probably isn’t going to attract even a hint of that kind of viewership and should make this into a blogpost or something. Python is neat, but it does not lend itself to content creation on YouTube haha.
I think the standard arguments are “what is it, Fortran from the 70s” and “can’t take my oneliners from me!”. Both are bogus. Now we have the same drama over := that you don’t even have to use. People probably think that potential of misuse of := will make some Python code unreadable. After seeing some truly horrible code I came to conclusion it doesn’t matter what features a language has. People will find creative ways to write truly awful stuff.
Forget pyproject.toml for a moment here-- what about the other two formats I mentioned, rhat according to github, 150k people use? Specifically ~10k use setup.cfg. in comparison ~15k use Pipfiles. The other 140k are setup.py users. I disagree about the technical merit bit. Pyproject.toml is *newer* than Pipfiles. Even PyPA admitted the reason why less people use it is because Kenneth and PyPA admitted shoving pipenv through marketing like all hell. The PSF is extremely hands off from PyPA, and from any subdomains python.org not directly owned by them. I highly doubt they would, say, approve of Kenneth defacing the pipenv project for a few days, (which he did) if the PSF gave a shit. But they don't, they are hands off. PyPA are hands on, but enabled him.
&gt; If there is some value in a list comprehension that you'll need afterwards... then you probably shouldn't be using a list comprehension. If you need to operate on a value multiple times before returning it, then you should be using a function instead of a lambda. This is useful even with simple list comprehensions. For example, see the following. [complicated(i) for i in array if complicated(i) != idk] It's much more performant to write it as the following. [result := complicated(i) for i in array if result != idk]
I would not worry about docker, kubernetes, etc until you are ready to scale. I would build backend first
Very nicely done. And, your code is just as nice to look at... threading and all! +1
If you don't need backwards compatibility, use py2to3. If you need your code to work in both py2 and py3, check out future http://python-future.org/ Specifically it comes with a command line tool called futurize that will translate code for you to be compatible across versions. If you want something more manual but lighter weight, there is also six but you'll need to manually convert your code to use it.
Programming is a social activity. For/else is obscure and you're likely to trip someone up (most likely yourself in 6 months) who is tasked to use/modify your code.
Once you watch a few seconds YouTube counts it as a view 
Thanks, you da real mvp! 
Unless you use comments..
3. To read the rules use the incredibly valuable recently introduced "old" keyword. (As in old.reddit.com/r/python)
Because suddenly it's either going to be possible to change external variables, or it's not going to be, and they'll be surprised by that. 
One of the benefits of tox is that it can give you a clean installation of your package every time you run it. It can be important to test that the installation works (and all the `import` rooting and so on) as well as the actual functionality of the code, even if it's only implicitly. Keeping the tests outside of the package means you also don't need to bundle them up when you're creating a distribution (strictly speaking you can avoid this wherever they are but it's easier if they're out of the package). For doing quick runs of single tests you can still use an editable install in your development environment, with `pip install -e .` (note the dot). 
oh, i missed the some. Yeah, I suppose if you locked the account creation behind google's recaptcha it would be pretty hard to bot into.
thanks for the compliment\~\~ the code for this subproject is just finished and there centainly has a lot of room to improve. all suggesions are welcomed!
I think it's a combination of 1) people think it's not "pythonic" 2) it would be really useful to have 3) it *will* become part of the core language that everyone encounters daily Type hints for example are very rare in my experience
But it isn't something of generstors. You could easily do this with functions and closures and comprehensions already.
Python is overkill for that, what's do you mean by a "list", a text file? $ printf "%s\n" BC-{000..100} BC-000 BC-001 BC-002 BC-003 BC-004 BC-005 BC-006 BC-007 BC-008 BC-009 BC-010 BC-011 BC-012 BC-013 BC-014 ...
CPython may be, but can you make that statement for any Python implementation? Are you sure that [PyPy](http://pypy.org/)'s JIT won't reorder things if it sees an optimization?
Not exactly,but it helps to get an intuition more quickly and then reading books
Well interpreted, scripting or whatever you call it, I was always under the impression that Python is or was designed to be an easy to use language. It never has had the ability to take on large and complicated programming projects, at least not in my mind. So if any of this is true why the struggle to turn python into a far more complicated language thus leaving behind the niche it was designed to fill?
Pretty much all of these were in "Effective Python", along with a bunch of other best practices. 
Throw a `&gt; bclist.txt` on the end of that to get a text file out of the deal.
This is what I meant, a list of BC-###. Thank you so much. I would also like to know if it were possible to incorporate the " atmospheric noise" random string generator's output onto each line? ([https://www.random.org/strings/?num=100&amp;len=5&amp;digits=on&amp;upperalpha=on&amp;loweralpha=on&amp;unique=on&amp;format=plain&amp;rnd=new](https://www.random.org/strings/?num=100&amp;len=5&amp;digits=on&amp;upperalpha=on&amp;loweralpha=on&amp;unique=on&amp;format=plain&amp;rnd=new)) (I.E) BC-001\_\[string output 1\] BC-002\_\[string output 2\] ... BC-100\_\[string output 100\] (Every time you click on the link, it will give you 100 different numbers)
I honestly didn't remember with open('file') as f: until I watched the video
That's just bullshit, MS hasn't even had enough time to do anything. Github is still running the exact same. Maybe you can be afraid of future fuckery and/or privacy/centralization issues but "not working right now" is not msft's fault rofl
&gt;Unless you use comments.. Hilarious.
this is like recommending python2.7 to new users
I'm not surprised that using setup.cfg is so common. I've used it myself, a lot. But it's not really fair to talk about users of one type rather than the other. Traditionally there were 2 sets of dependencies: for the user in setup, and for the package developer in requirements, so packages would use both. Security scanning dependencies is for the developers benefit so logical they would include requirements over setup for initial release. I've said before, I am sure the others will get added later. It's sad that were arguing about the authenticity of information on python.org. I mean PSF is ultimately responsible for that domain and what it chooses to allow as a subdomain. 
Why are you breaking out an obscure feature if you need to use comments to clarify why you're using it and how it works? You could save everyone the headache and just use colloquial for-loops and save yourself the lines of comments.
I don't get why the others (at least except setup.py) weren't added now. It's not like parsing is actually in any way *more difficult*. I'm not arguing authenticity. I'm arguing support. They are hands off from the PyPA, who had been gifted that subdomain.
Unless you needed the else clause
Nobody needs the else-clause is the whole point. Colloquial programming idioms can achieve the same thing.
Why is it a feature then, I'm sure it has its implementations
If you're asking this kind of question, for a website of the scale of Shopify, on this list, and expecting an in-depth answer, I'll have to disappoint. Engineering something of that scale (mind you, the question is a bit vague) is an effort of days, weeks, years, whatever. Requires extensive profiling of both human (dev ability, hireability in your area, etc.) and technical (mean/median perf, components perf and reliability, etc.) and so on. Engineering isn't some slap-and-dash exercise.
you could try writing your own conversion script? another thing to keep in mind while transitioning is that it's possible not all packages you're using have been updated to support python3 - i've hit this issue recently
I got it working with python 3 internally, there's not a _huge_ amount of stuff to be done (there's a couple of forks that have a large amount of work done already) to get it working at a basic level. We've moved off using HDFS so have never pushed it back out anywhere (and the effort of getting that approved through work isn't worth the effort). The effort required to upgrade is about a weeks work from what I remember, the biggest blocker at the time was sorting the protobuf classes AFAIK.
I never really got the point of finally. Doesn't just putting code after the whole thing accomplish the same thing as using the finally statement?
&gt; This allows a mix of asynchonous coding styles (async/await, callback, chaining across scope), but in Python the second is nuetered (you can make tasks out of coroutine objects, but you have to await on the object, and any callback result is literally lost), and the third just can't be mixed at all. I don't think that is true. When you make a task out of a started coroutine - as simple as calling `loop.create_task(async_function())` - you don't need to await it. If you do nothing, it will keep running in "background", comparable to starting a thread. You _can_ await it inside a coroutine, but you definitely don't _have_ to. Also, if you have created a task (or someone else has created it for you), you can easily attach a callback to be executed once it is done using `task.add_done_callback(my_function)`. This is a consequence of tasks being derived from futures, which have a well-defined callback API. All this allows you to easily mix coroutines and callbacks. I'm not sure what you mean by "the third just can't be mixed at all", but as far as I can tell Python's futures are exactly equivalent to Deferred/Promise. `asyncio` may have its rough edges, especially when it comes to the internals (transports and protocols, which is what Dave Beazley was getting at), but the API is very flexible and nice to use.
i personally find the best way to learn is by doing, so I'm a big fan of using hackerrank. you can choose a language and a level, and work your way up from there. they're not courses, but it forces you to do research on how to solve the problems and learn from that - which is honestly what you're going to be doing a lot as a software engineer. they also provide the solutions and there's a thread where you can discuss alternative ways to solve/the process you went through with other users also I BELIEVE some companies can use hackerrank profiles for recruiting purposes
&gt; But 99.99% of the language ARE casual users! Yes, and 99% of people would support action agains the evil dihydrogen monoxide that can kill you on exposure! I am a casual programmer, but self aware enough to realize that I have no place deciding on such issues just because "it looks neater" or something. Case in point: I also like gotos because they are so nice, and global variables safe so much hassle!
For/else makes code better? Ninja please...
So in you example, popular vote would make Prius II a F150 clone, after all its the most sold vehicle in the US!
Code in the `finally` block is run whether or not an exception is caught. From the python docs: &gt;In real world applications, the finally clause is useful for releasing external resources (such as files or network connections), regardless of whether the use of the resource was successful.
I liked very much what Guido brought to Python over many years. That is the reason why I programmed in Python over the last few years. I learned several programming languages but found Python easier to understand than other languages. However in the last few additions they are changing Python to make it more and more like C code which I don't agree because it will add to the complexity of the language. I never liked to program in C code because I found hard to understand why they were doing things in some way which didn't make sense. That is the reason why I drop C language in the first place. They should keep the Python language as simple as possible for new users with examples explaining the functionalities. 
Okay, but it's not pretty and doesn't work on macs: $ paste -d'_' &lt;(printf "%s\n" BC-{000..100}) &lt;(curl -s 'https://www.random.org/strings/?num=101&amp;len=5&amp;digits=on&amp;upperalpha=on&amp;loweralpha=on&amp;unique=on&amp;format=plain&amp;rnd=new') BC-000_uee5g BC-001_Jm4vJ BC-002_kWOjH BC-003_UUq9h BC-004_qdCtX BC-005_q8qwP BC-006_9UZmT BC-007_Ynt80 BC-008_dYwGS BC-009_qxn2J
"A finally clause is always executed before leaving the try statement, whether an exception has occurred or not. When an exception has occurred in the try clause and has not been handled by an except clause (or it has occurred in an except or else clause), it is re-raised after the finally clause has been executed. The finally clause is also executed “on the way out” when any other clause of the try statement is left via a break, continue or return statement." Basically, finally gets called even if the except clause would exit out of the rest of your code, unlike if you just put the statement after the try block.
Alternatively, curl -s 'https://www.random.org/strings/?num=100&amp;len=5&amp;digits=on&amp;upperalpha=on&amp;loweralpha=on&amp;unique=on&amp;format=plain&amp;rnd=new' | perl -ne 'printf("BC-%03d_%s", $., $_);' (I'm sorry)
So odd, yet very human, that his first greatest accomplishment was creating a new language, and his second greatest accomplishment was dragging everyone kicking and screaming to the new and improved version of his language.
are you claiming that I'm spreading FUD here?
&gt; Doesn't just putting code after the whole thing accomplish the same thing as using the finally statement? Yes, *unless* an exception occurred inside the `try..except` block - in which case the code "after the whole thing" doesn't get executed.
That is a powerful idiom for anything that needs closing or explicit saving after the operation. File, database, network connection. It is not so much useful for first draft, as it is safe for future modifications of code. 
I learnt python from tutorial on [python.org](https://python.org), and it is all there. 
Hello! I'm a bot! I see someone has already suggested going to r/learnpython, a sub geared towards questions and learning more about python. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
When does he try to come back like nothing happens like Daniel Robbins tried to do with Gentoo?!
Yeah, holy shit. I just found out about the PEP and while I don't like everything about it, it seems generally reasonable and well-argued. I just cannot comprehend how such a minor thing evolved into such a shitstorm.
Me, an intellectual: while True: # do stuff here if &lt;condition&gt;: True = False
Python is hugely capable of running large sites at scale. I mean ... youtube and dropbox right? The problem is really the hyperbole involved here. . "The struggle to turn python into a far more complicated language"? That doesn't even begin to ring true. If you want to code in bash go do that but Python is still a dead simple language even if you poor bastards have to learn one more operator to get a typical feature from other languages.
So what do you use instead of HDFS? 
It can be useful. for foo in bar: if condition(foo): break else: return This returns if no such foo was found. Without else you'd have to introduce a boolean.
If that's all there is, it over promised, under delivered.
Yes, it can be useful but the keyword should really have been something different than 'else', that's my hangup.
/r/learnpython
&gt;else can be used with for, else is executed if no break occurs in the for This one seems like a bad idea. I mean, the idea is good but the syntax. \`for...else\`??
&gt;Else is used if except doesn't happen Can anyone elaborate on this? Is this like a general exception handler if the except is for a specific type of error?
Shit. We don' fucked up! Come back Guido!
Make it optional.
There is nothing to worry about. Python is alive and well. The language will go on uninterrupted. Python's BDFL (Benevolent Dictator For Life) is simply taking a well-deserved holiday from his duties, and leaving the community to decide how to fill the gap. The community is robust. The core developers are currently discussing possible decision-making structures for future development. I have been using Python for 20 years now, and I am confident that all will be well going forward.
Do what? A generator isn't the same as a comprehension. My point is not that I'm against changing variables - my point is that this pep introduces a new rule to know about scoping, and there's no obvious reason why the rule has to be one way or the other. 
The problem with tasks in Python is they execute on the next available execution tick, but there is no way to force them to execute "now". Say I have a coroutine and I make a task out of it-- that then gets scheduled to run in the event loop as soon as possible. However, that could be 4 seconds from now, it could be 10, it could he 76. Or it could be after your entire program is over. There is no way to await it-- that is, pause the currently executing coroutine, jump to the task, have it execute now, and descehedule it from occuring when available. This is a common thing to do in async programming, especially in JS with web requests. You set a request to occur when available, and you really don't care when it happens, but at some point in your code you need to make sure it is done before continuing. You can await the coroutine object itself if you keep it in direct reference, but that's both clunky, and causes unexpected behavior on the Task, because awaiting the coroutine doesn't update the Task's state properly. Furthermore, any callbacks added to the Task are lost. There is no way to use them except as event emitters, but in other languages, adding a callback is equivalent to creating a new Task representive of the previous Task and "then" (which is why the method name to add a callback is usually then, such as in JS, or in C#, it is ContinueWith, Ruby has a more complex system that you can choose from) the callback, and this new Task should be awaitable too. This practice can also occur with other code, namely things like animations triggered by logic, that while internally something is disabled immediately, visually it takes a second to fade in. Related to this, you can't easily mix the variables in your synchronous scope and your asynchronous one, even though one would think you should be able to. And you'd be right, but the reason why you can't is because by default the event loop is created and managed in the same thread. This blocks the thread, but also causes friction when interacting with the rest of your sync code. Other languages solve this by either having only one event loop, that exists in a separate thread (or in the case of JS, exists in a "microtask queue", whatever the hell that means) or a *default* one that is smartly closed when not in use, also living in a separate thread. In Python, while the ability to submit events to loops in other threads exist, there is no clarity that this is how you make your async code *separate* from your sync code. The goal here is your async code is asynchronous from your other async code, *and* your synchronous code. But this isn't a default in Python, and your async code acts as though it is a tangled ball of yarn within your sync code that needs to be gotten through. These are the problems I intend to solve, and solveable they are, with an extremely thin wrapper around the coroutine type and the task class. Furthermore, I love asyncio. But it's rough edges arent rough-- they are jagged spikes detracting many users from the subset.
I bet you only read the first four words.
If only anything to do with youtube was that simple.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. [Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
The Python documentation (https://docs.python.org/2/reference/expressions.html#operator-precedence) states: &gt; Operators in the same box group left to right (except for comparisons, including tests, which all have the same precedence and chain from left to right — see section Comparisons — and exponentiation, which groups from right to left). Pypy and others may (?) defer from that standard. But than it's not standard Python.
Comprehensions internally are generators...they are just executed on the spot. You can keep a comprehension as a generator without execution by using parentheses instead of list/set/dict literals. I can easily alter out of scope variables as follows: def g(): global a a = 1 [g() for i in range(5)] This PEP explicitly reminds it makes no changes about scoping-- the assignment expression is a equivalent to assign and return. It inteoduces new behavior, but it is not new behavior of generation nor comprehension. It is new behavior of the new operator. If you are complaining it's new to learn, you don't have the right to any other new features either.
You lost me on the py3 rant : this was a tough decision, but as someone whose language is not fully covered by ASCII, I welcome the fact UTF-8 is now default on Python. It makes learning Python much easier for non English speaking people as it solves a lot of hurdle you typically encounter. And yes I know about the Unicode dance (encode/decode), but when you begin, this is far from being trivial, and it makes Python much harder to learn than Java for instance. I'm seriously getting tired of native English speakers or seasoned Dev telling the world switching to default Unicode was not needed. That's a huge case of "I don't need it so I don't see why anyone else should get it"
https://www.youtube.com/playlist?list=PLJsotIV0ZEQDpIIKhT-33qU1WEefRRrBL
s3/gcs. We were only tied to HDFS for HBase, since we've moved to Cassandra.
Didn't watch the video but TIL from the comments for/else is "confusing" and "obscure". ... it's in the [The Python Tutorial](https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops) with `break` and `continue` clauses.
People that think cramming as much code into one line is a good thing are very wrong. And yes we do not have to use it. Until we get to interact with code written by someone else who did use it all over. And then we get to deal with all the good and bad stuff that comes with these features. People do find ways to write bad code. Does not mean we have to go out of our way to help them.
The simple answer, No, absolutely not. It's been a decade or more since `guido + bus == del python` ... The more complicated answer: Guido has always been a very *good* BDFL... reading through archives you get get the sense he's opinionated but measured, open to change, and willing to be convinced he's wrong (except when maybe he isn't), and generally has been more soft-touched, mindful, and respectful than others in similar positions (cough Torvalds cough). Does his stepping away run the risk of other, less B-centric more D-focused autocrats coming onboard and screwing things up so bad it all ends in tears and death? Well, yeah ... but thankfully so far there's no sign of any Russian interference and not a single MPGA hat to be seen.
Well, python 3 actually improved some things. The new layout on the other hand...
Maybe one of the positives of losing Guido for a while could be an informal freeze of the language specification. Core devs could dedicate themselves 100% to stdlib and thorny side-issues (GIL...) until Guido comes back from his “holiday”. This would help the wider ecosystem tremendously btw, giving Jython, PyPy and other implementations a lot of time to catch up; and would help move to 3.x all those companies stuck in the 2.x quicksands. Dataclasses and f-strings were great additions, but now we could do with some quiet time to “digest” all the goodies, avoiding controversial “changes for changes’ sake”.
&gt; Comprehensions internally are generators...they are just executed on the spot. True but completely irrelevant to the point at hand. 
Mh, to me his letter reads more like “I spent 10 years arguing never-ending issues (py3, the GIL...). I’ve now realized this PEP will be another permanent flame... I’ve had enough.”
1. I'm not a native speaker. 2. The exact reason of problems with Py3 utf8 by default is it's literally the only thing preventing Py2 to Py3 conversion **string == ascii** is the default in the industry. Nobody cares about English, what is really important is the bytes on the network and the ease of debugging those without issues. Also reading default in any OS inputs and outputs which are ascii streams in like 99% of application - logs, system files, interprocess operations, kernel you name it... What we got in exchange is severely limited bytes and bytearray and the mumbo jumbo with encoding everytime you need to work with ascii. I'm not even talking about vulnerabilities of utf8.
"New thing to comprehensions" "Nothing new is added to generators" "We're talking about comprehensions, not generators" "...comprehensions literally are one line generators" "True but irrelevant" "????????????"
Ahh, the day when "self-contained executable" was redefined as "executable that's self-contained so long as you have this esoteric FUSE driver and a helper script installed". That said, interesting entry into the space, and I've got some strong ideas for how this could be really big for enterprise applications.
1 Simple Trick to Make Better Youtube Videos: \+ Make a 25-minute video in 5 minutes.
The one that was new for me was using `else` in the for loop. Pretty handy if you're trying to find a matching item in a collection and want to know whether one was set or not! Up until now I've used a pattern like: result = None for record in records: if is_what_i_want(record): result = record break if result is None: action_when_no_result() Which apparently can all be rewritten as: for record in records: if is_what_i_want(record): result = record break else: action_when_no_result() Pretty useful actually.
It's a feature. `exec` does not run in the same context as the calling code. &gt; In all cases, the code that’s executed is expected to be valid as file input (see the section “File input” in the Reference Manual). Be aware that the return and yield statements may not be used outside of function definitions even within the context of code passed to the exec() function. \- [Docs](https://docs.python.org/3/library/functions.html#exec) &gt; All input read from non-interactive files has the same form: &gt; `file_input ::= (NEWLINE | statement)*` &gt; This syntax is used in the following situations: &gt; * when parsing a complete Python program (from a file or from a string); &gt; * when parsing a module; &gt; * when parsing a string passed to the exec() function; \- [Again, docs](https://docs.python.org/3/reference/toplevel_components.html#file-input)
I'm sure I'm not always consistent on this, but I like to be explicit and always set the file mode: with open('file', 'r') as f: that way it becomes very clear when I've done something wrong, like trying to write to a file that is in read mode. Also, while I'm typing out the file mode I might be reminded, "oh yeah, this is going to have binary data" and use 'rb' instead.
So foot fetishes and Sonic porn
Thanks! You must be Dutch. Is the enumerate function faster than the iterator? Readability of iterator is not so bad right?
I've heard good things about VueJS. I'll be googling the rest of this quite a bit. How much better is it to go with an API and just have a JS front end? I'm nervous about moving away from django since its really the only framework I've used, and I want to see this project successfully deployed. This is going to be in the cloud. I would like to have a service that does all the requirements for https for me. Last time I setup a box it looked a bit more complicated than I was willing to do at the time.
Thank you for this sentiment and advice. I want this to be successful, and they are paying me $25 an hour. I do feel I am new to building websites (4 months of experience at the coding bootcamp). I'll do my best and learn as much as I can from them.
Me too, I don't understand why people prefer to spend 60 min watching a lesson on something you could just learn by spending 10min reading a text. Laziness has its price...
Thanks for the advice. Knowing that time frame has made a big difference for me. Once I told them it would take me the full internship they were skeptical. Sounds like one of the members did some research and is now in support of that being the case.
5 min is my upper bound on YouTube videos' length.
nice!
Type hints are rare unless you make them part of your development process and then they are everywhere.
I'm not familiar with testing so I'll need to get the hang of this quickly it sounds like. Thanks!
I'll let them know this. Thank you.
If this is a small change, for example if you only need to change a path, then you can use something like this: import argparse import pathlib import re def main(): parser = argparse.ArgumentParser() parser.add_argument('old', type=pathlib.Path, help="path to old templates") parser.add_argument('new', type=pathlib.Path, help="path to new templates") args = parser.parse_args() pattern = re.compile(r'(prefix)(old)(suffix)', re.IGNORECASE) for template in args.old.rglob('*.html'): content = pattern.sub(r'\1new\3', template.read_text()) destination = args.new / template.relative_to(args.old) destination.parent.mkdir(parents=True, exists_ok=True) destination.write_text(content) if __name__ == "__main__": main() Modify `(prefix)(old)(suffix)` and `\1new\3` parts.
The point is syntax, and the opportunities for confusion, not the underlying object. 
Thanks!
Have seen this video before, it's OK. It reminded me of Raymond Hettingers talk in the same vain: https://youtu.be/OSGv2VnC0go It's a longer talk, but I like Raymond's enthusiasm and expertise.
Users could vote by donating some amount of money for features they want. But core developers would have final say and they could reject well funded feature in this case, donations would be used for bug fixing, for example.
For the 5th, you can always use `in` or if you need a function; &gt;&gt;&gt; i = [1,2,3,4] &gt;&gt;&gt; func = lambda x:x==1 &gt;&gt;&gt; any(map(func,i)) 
I'd love to see kind of a "What situations should I use celery in" sort of post. When is celery better than say, multiprocessing? Or perhaps some sort of async library?
SOLVED: Appreciate the help @randomJ6, that str.split() comprehension was crucial Input------------------------ a = """ (192.168.254.43) (192.168.254.254) (224.0.0.251) (239.255.255.250) """ code --------------------------------------- # 1. create empty string b = [] # 2. if/else list comprehension to replace '\n' with ' ' z = [b.append(' ') if x == '\n' else b.append(x) for x in a] # 3. convert newly created list to string c = ''.join(b) # 4. strip comprehention on newly created string to seperate at spaces ips = [x.split("(")[-1] for x in c.split(")")[:-1]] print(ips) output ------------------------------------- ['192.168.254.43', '192.168.254.254', '224.0.0.251', '239.255.255.250'] 
There are oppurtunities for comfusion in every new feature ever added. If that's your point, then you don't deserve any new features.
I've just finished my Python course in SoloLearn, an app that is available in Google Play (Not sure about iOS and Win/Linux). It has a lot of languages to choose from, an active QA forum, Community made guides for Machine Learning, the libraries, Neural Networks and more. Everything in there except OOP was well explained. Remember that it is meant for absolute beginners, so advanced stuff isnt accounted for. And I was NOT paid to write this. 
Re: the first example, it is incorrect to claim that by using enumerate you avoid creating a counter variable. The counter is right there, except that it's being set for you automatically. It also remains after you leave the loop, since Python doesn't have block scope.
Hello! I'm a bot! I see someone has already suggested going to r/learnpython, a sub geared towards questions and learning more about python. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
First of all, I've clearly stated that I preferred it when Guido and the community were very conservative about new features. Secondly, some new features add more utility and clarity than confusion - I like those. Most new features don't pass that test, though. 
Should not be 'much' faster. The enumerate can easily be a wrapper around an iterator in this fashion: &gt;&gt;&gt; def enumerate(iterable): ... i = 0 ... for x in iterable: ... yield i, x ... i+=1 Though it's probably implemented as iterator and not as a generator. 
thanks for the help and actually giving me a solution instead of just point me to another sub. It worked and I appreciated it!
Ahhhhh. I found another povray user!!! I’ll go crazy!!!! 😀
Some nice quick tips!
"Adding more utility and clarity than confusion" is extremely opinionated. You can't state your opinion and then expect literally everyone to agree.
Guido himself said if he had to do it over again, he would leave the for ... else feature out: https://mail.python.org/pipermail/python-ideas/2009-October/006157.html
My understanding is that you should use ensure_future unless it is inside a custom event loop
Firstly, PEP572 was divisive enough to drive away probably the single person on the planet most invested in python. Whether or not you like the idea, a decision has been made. Re-litigating the exact same issue for months more isn't going to help the community. I think this email is trying to do too much. Suggesting changes to the way PEP572 is handled, and suggesting how PEPs are handled in future, and suggesting a change to a more functional API, and suggesting changes to how communication happens, and throwing Cython into the mix - just way too much. Keep it tight; one point per message. There are good reasons that Cython is not in the standard library. Primarily, Python the language spec is not CPython the implementation. There are lots of python implementations besides CPython which would get much more complicated if they had to support Cython too - pypy, jython, brython, ironpython, and so on.
C language has this feature (assignment being an expression), yet it is never because of *only this feature* that I would say some code is bad. I doubt := in python will be a threshold for an OK code to morph into bad code.
Also, oops did not realize I was responding to the same person teice :P 
Yes, I agree it covers quite a few points. I'll try to trim it some. I know that PEP 572 was divisive. That's why removing it now is the best solution to tame down emotions. This PEP is not an emergency. 
As you already mentioned Beautiful Soup, combining that with [requests](http://docs.python-requests.org/en/master/) will give you basically endless possibilities for scraping related projects. If you add [selenium](http://selenium-python.readthedocs.io/) to the mix, you'll be able to include some browser automation related projects. Perhaps [InstaPy](https://github.com/timgrossmann/InstaPy) project could give some inspiration. I'd also recommend checking out [Automate the Boring Stuff with Python](https://automatetheboringstuff.com/). Depending on the background and other studies of the students, excel related automation might be interesting. For that, see [openpyxl](https://openpyxl.readthedocs.io/en/stable/).
At work we have switched hard to AMD CPU/GPU and have not had significant problems either way. ML on AMD GPU is still a bit iffy here/there, but works. Cant speak more to ML on GPU, since we use our own toolkits, and ours isn't much of "ML" anyways. CPU is CPU, and AMD let us have more cores (we can't use i9/xeon workstations for &lt;reasons&gt;, but 1800x/2700x OK'd). The number of cores, real PCIe lanes to spare, and price point let us spend $ on more memory/larger SSDs etc for the same budget.
I always recommend context managers if you *have* to ensure that something is torn down after use. You can't rely on people remembering to close off resources or catch possible exceptions. 
For example, one potential project: * Scrape data from some data source with Request + Beautiful Soup * Process data with pandas * Spit out some reports as excel files with openpyxl 
I'm pretty sure old.reddit.com will cease to exist some time in the future. Don't get me wrong, I prefer the old style too, but Reddit didn't spent all the man hours in a new design just to have to maintain two versions of the site. Like it or not, old.reddit.com will cease to exist some day.
Yeah, that already exists and in a much clearer way that shows you'll be calling `complicated()` for each element of the array. [i for i in map(complicated, array) if i != idk]
https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future &gt; **Note** create_task() (added in Python 3.7) is the preferable way for spawning new tasks. Tasks are a subclass of futures with a small amount more functionality.
I was under the impression that google explicitly wrote Go and has been moving away from Python in favor of Go because it couldn't operate at scale. I don't currently know what Dropbox is doing though, but from people I used to know there it also has problems at scale mostly in python coded projects. 
I'm working on add CI to run automated unit tests for a load testing tool that runs on AWS Lambda https://github.com/edmunds/shadowreader
there is no audio, and the explanation is in the video description
Like everything, threadpoolexecutor/futures as completed is way better than what you did. I'd even go further: it's all I/O... Go async ! Check aiohttp doc
I agree with your post/reasoning, just wanted to drop [this](https://www.reddit.com/r/beta/comments/8lv96l/feedback_please_dont_ever_remove_oldredditcom/dziwf1p/) so you know at the very least it won't go away soon. But you're still right; it will go away at some point. Can't stand the redesign personally but looks like we won't have too much of a choice aside from using `old.reddit.com` for now.
Thanks! I had not seen that. I am coming from twisted, so I am generally used to those analogues (ensureDeferred). I'll keep this in mind going forward
Hi! I work on this team. We do support setup.py, but it's flaky cos… we didn't have time to mock every import / function call, etc. For that reason we chose to de-emphasize it, but you'll still see it [in our docs](https://help.github.com/articles/listing-the-packages-that-a-repository-depends-on/). In the future, the best way to reach us is [by contacting support.](https://github.com/contact) Our support team members are very good at finding the right team! Cheers,
Yeah but a bad retention ratio is a bad sign for YouTube, for example. Views count isn't the only factor nor the most relevant.
Because indentation is important and you're adding indentation in a place where it's not supposed to be.
Running on Python 3.6 I got syntax error on line 152 'except as err:' Changed it to 'except Exception as err:' and it ran.
Yeah, fully understandable-- just glad to know there is flaky experimental support. Is there a reason the other two formats (setup.cfg and pyproject.toml) aren't supported? The first isn't new and has a decent size amount of people using it. The latter is newer than Pipfiles, but isn't as caught on because it is more for applications and projects rather than libraries, mixed with a lack of marketing. (Assuming you don't see this within a few days I'll just copypasta this to support).
The indentation is incorrect on the one that doesn’t work. [See #3](https://www2.cs.arizona.edu/people/mccann/errors-python) 
"Python enforces it (indentation) with an iron fist." Ah I see. Never coded in a language where indentation mattered. Thanks link is useful, I'm definitely bookmarking it
Indentation in python is equivalent to braces in other languages. Your code basically has an extra opening brace in it. 
Yup those are all pretty much on my planner. Pandas and numpy all day every day.
No. First, Python 2.7 does not have numerous features that Python 3.5+ has. Where as, old.reddit.com has functional features that www.reddit.com no longer has - like the ability to read the rules of the subreddit. Second, my recommendation is not to new users, but to reddit to *fix* the thing so that users and moderators don't have to guess. 
From where you read that Rust is compiled to C? Rust compiler is based on LLVM doesn't mean that Rust is compiled to C. Rust compiler is just on the same level to Clang, a LLVM-based compiler for C.
CSDojo has beginner and advanced lessons on data and algorithms and python , its good for starting and its how i did
Reddit without "old" is practically unusable. The hue and cry will be interesting to see.
From what I understand the inner workings of the LLVM convert to C an a hidden intermediary step-- which is why you can directly call C functions from Rust without some compatibility layer
I read _as_ as a way to infer type rather than setting a variable.
If Python's existence depended solely on one person (even the creator) being alive or cooperating, Python would not be around today.
Most languages are designed to be easy to use, for some sort of application, and for some group of people. Python absolutely is able to take on large and complicated projects, and is used in that way by many people. Some might argue it's not the best language for that, but that's a long way from saying it's just a 'scripting' language.
If by clearer you mean more lines and more verbose just to meet # of lines coded per day, sure. It's also creating a function for a single if/else chain. If you created a function for every if statement you'd almost have too much encapsulation that it'd be harder to read.
Throw a `setup.py` in there so people can `pip install --user` it and it'll be much more useful! Minor bone to pick: &gt; This project makes use of PEP8 code style No it doesn't. `camelCase` all over the place.
what sort of methods were used to do this? i want to pull data from the web and use it with formulas i make. im just learning python so im starting a project to push me along.
Posted a day ago: https://www.reddit.com/r/Python/comments/8yapie/transfer_of_power_guido_stepping_down_as_bdfl/
videos never have the information density of written documentation. it's not a reader vs watcher learning thing - it's a can you read technical documentation o not thing.
Unless I set it up wrong, you should be able to see all the code on my github link by clicking the .py file
So go use assembly. Did you read the PEP and complaints for the @ operator? It's super useful to some and not to others. Yours is not the only use case.
Useful until you remember that nobody reading your code is going to understand it. `for...else` is much-maligned in Python because it's so opaque. Some people have suggested changing that particular use case to use a `nobreak` keyword.
Can you give me one virtue?
Why not add assembly to Python? Those who complain about assembly wouldn't use them, so why not add them?
I think that's unnecessary and would be a mistake. Take the @ operator. It's super useful in math and science, but not for web development. If python is used by 60% web devs, the proposal would probably fail.
&gt; XARs are single, highly compressed files containing all necessary executable dependencies. They execute with the same speed as natively installed applications Not sure how that's supposed to be true. Looks like a cool project though!
Yeah, for iterator else logic in 'tip 5' is no more useful than an if iterator else statement.
Description from readme for anyone as lazy as me: "Print out regular status reports while looping over items This package provides a function that simply prints out information about the progress of a loop that iterates over an iterable. So, say you have a 10k elements that you are iterating over and each one takes a second. Wouldn't it be nice to get a little output after every 1% of the items are processed?" This sounds great, I'll give it a try! 
I’m not sure if this is a dig at da or povray
I used it today... seems pretty clean to me, for attempt in range(RETRY_ATTEMPTS): # grab everything that's missing or invalid self.logger.info('attempt %d of %d, need %d pieces', attempt+1, RETRY_ATTEMPTS, len(manifest)) success, failures = _download_from_manifest(manifest, root, path, self.set_status) if not success: self.logger.warning('downloading %d files failed', failures) else: break if attempt + 1 &lt; RETRY_ATTEMPTS: # don't recalculate the manifest on our last attempt, if the last # attempt failed. self.set_status('Validating manfiest') manifest = _determine_progress(manifest, path) else: # if we exhaust our RETRY_ATTEMPTS without success self.__failed('downloading xdelta shards failed')
Their goal is probably to entertain and there's lots of lazy people who just LOVE to watch videos instead of picking a book, reading documentation or whatever. Because uh, that would require effort. Or they just don't know better.
&gt;Is there a reason No reason in particular. We looked around and figured we'd captured _most users_ and it was time to ship the rest of the feature. There's no formal plan to do this yet, but I think what we _might_ do is extract our parsers into a public library and let people submit PRs to add support for whatever package system they use. Have a good one,
Don't know how it works (or whether it works) in this case, but traditionally for HDD drivers compression made code faster since the latency of disk read of uncompressed data is higher than the latency of disk read of compressed data + extraction. Can't see how this might be exploited in this case though since RAM (or even SSD) is probably fast enough that extraction algorithm will bottleneck.
Their problem is that they find the concept unintuitive, not that they didn't know.
You already understand the idiom, and you used clear variable names and helpful comments. Clear naming and helpful comments can go a long way towards understanding confusing language features, but this doesn't mean the language features are good per se. 
TIL try: print('try') except: print('exception') finally: print('finally') `try finally` try: print('try') 1 / 0 except: print('exception') finally: print('finally') `try exception finally` try: 1 / 0 print('try') except: print('exception') finally: print('finally') `exception finally`
like a god, or a king in a crowned republic.
I got a response from Guido: &gt; Please don't propose to reconsider PEP 572. Nobody wants more discussion. I replied: If you truly want to prevent further discussion, shipping is the worst thing to do. Once it is out there, people will be forced to talk about it more. In fact, the talking would just be beginning. 99% of Python programmers don't even know of this feature yet. 
Thank you for the information. Extracting these parsers out would be a wonder.
Fewer lines of code does not automatically make your code clearer. If you have that amount of code dedicated to calculating the value of `rv` then that algorithm deserves a name and a separate function. I was unable to give it a good name because I lack context. One of the reasons I prefer my refactoring is that that algorithm isn't the same as an if/else chain. An if/else chain would communicate an algorithm where you have a certain number of independent cases and you want to select from those cases based on some state, sort of like how a switch statement works in other languages. But that's not what's going on here. In this code you actually have a procedure that tries several different possibilities one after the other and uses the first one that is valid. It's pretty much the definition of an early-return algorithm. Expressing this code as an if/else chain obscures its meaning, as well as forcing that extra indentation on you. The original (non-`:=`) code was poor, and that's why `:=` comes off looking better. The true comparison here is between my previous version and this: def get_rv(): if reductor := dispatch_table.get(cls): return reductor(x) if reductor := getattr(x, "__reduce_ex__", None): return reductor(4) if reductor := getattr(x, "__reduce__", None): return reductor() raise Error("un(shallow)copyable object of type %s" % cls) ... rv = get_rv() That's at best only a minor improvement over what I originally wrote. I find that in real (fair) examples `:=`'s only advantage is that it saves a single line of code, and yet it adds an extra layer of complexity to the language. I don't think that trade-off is worth it.
There are so many ways to answer this correctly that you might end up confused. For example you didn't seem to consider APU style chips but ML can often leverage the GPU so a cheap but effective workstation can be had with AMD chips. Lets face if for simple Python development it doesn't take much in the way of CPU performance. The biggest problem under Linux is stable and effective drivers to do ML (GPU Computations), but that literally improves about every two weeks now. If you move away from APU style chips I'm still not convinced that your best bet is to stock upon as many cores as possible. AT least with CPU cores. You may be better off focusing on some of the more advanced GPU's out there. Frankly your timing may be a bit off here as AMD is expected to debute a GPU with enhancements for ML/AI very soon. To put it another way I'm not sure which approach gives you the best bang for the buck. Obviously if money is no object you can buy both a thread ripper and a high performance GPU. As for Intel vs AMD, I'm not sure whom has the faster cores any more. Many benchmarks seem to indicate a toss up, often the details make a difference. Libraries, compilers and other tools make a difference here. Frankly this is an issue of budgets to me, that how much are you willing to spend. AT the low end I'd lean towards an AMD APU based machine with at least one high performance GPU socket. You do need to be mindful that the software you want to use will actually run on that APU's GPU. Ad the compute module when you hit an unacceptable performance point. Beyond that a freer budget allows for just about anything. In every case though it is more than just the CPU chip that makes for a workstation, you need the RAM, SSD storage and other things to bring forth a decent workstation.
I agree. But if syntax highlighters got smart enough (jupyter/spyder for me) to make the embedded expressions easier to see, then I might be more ok with it.
&gt; Say I have a coroutine and I make a task out of it-- that then gets scheduled to run in the event loop as soon as possible. However, that could be 4 seconds from now, it could be 10, it could he 76. Or it could be after your entire program is over. That sounds like something is seriously wrong with that program's use of asyncio. If it takes too long to get to a scheduled task, someone is hogging the event loop - either doing CPU work in the event loop thread (instead of using `loop.run_in_executor` or equivalent), or doing blocking IO. If the program finishes before `await some_task` completes, maybe awaiting it wasn't all that important? Don't get me wrong: I can imagine that there are valid use cases where one is using asyncio correctly and still needs to resume a task right away. But that sounds like expert territory. The presented use case doesn't go in the details why the task would need to be continued right away: &gt; This is a common thing to do in async programming, especially in JS with web requests. You set a request to occur when available, and you really don't care when it happens, but at some point in your code you need to make sure it is done before continuing. The above is a perfect description of `await`. Sure, other callbacks and tasks can run before getting to the task you're actually interested in, but that is a consequence of the cooperative multi-tasking system. Like when you `join()` a thread, you have no guarantee that other threads won't run before the OS schedules the thread you're interested in. As you said, "you really don't care when it happens". I would like to understand the "continue the task right away" requirement, especially one that is not in the context of incorrect use of asyncio. &gt; Furthermore, any callbacks added to the Task are lost. [...] Yup, I would love it if `loop.call_soon` and `loop.call_later` returned something awaitable. On the other hand, that is about the API ergonomy and not an architectural limitation of asyncio. It is almost trivial to get the needed functionality with the appropriate wrappers (e.g. use `create_task` instead of `call_soon` or `create_task` combined with `asyncio.sleep` instead of `call_later`). That kind of thing is what I meant by rough edges. &gt; In Python, while the ability to submit events to loops in other threads exist, there is no clarity that this is how you make your async code separate from your sync code I actually like asyncio's primitives that convert between functions and the different futures: `run_in_executor`, `wrap_future`, and `run_coroutine_thredsafe`. They allow very elegant bridging between asyncio and thread-based futures, yet they are totally underrated. Despite being important building blocks for integrating asyncio into an existing program, they are omitted from introductory texts. All asyncio tutorials I've seen simply assume that you are either writing an application from scratch or that you have the resources to convert your whole code base to asyncio at once, perhaps allowing for a `run_in_executor` here or there. Needless to say, that is far from realistic for anything except toy programs or short scripts. &gt; These are the problems I intend to solve, and solveable they are, with an extremely thin wrapper around the coroutine type and the task class. I look forward to your wrapper. Will it be on top of asyncio, or a completely different library like trio?
To reiterate, don't cheap out on RAM or SSDs if you're deciding between CPUs that cost more than $100 apart. Even some of the cheapest AMD CPUs can do NVMe Raid0 if you're running into an IO bottleneck. My last ML challenge was analysing and compressing ~200gb of logs a day, not a ton of data but lots of little pieces. Part of that was setting up tiered access: RAM -&gt; RAM Disk -&gt; Raid0 -&gt; SSD -&gt; HDD
Seriously. When `old.reddit.com` doesn't work, I'll be migrating to new `old-reddit-dot-com.com` mirror.
All due respect, as much as I like 572, yeah you can. if x &gt; 0: ans = calculate(x) if ans: foo(ans) elif y &gt; 0: foo(y) If you call a single greater line *less* elegant, then you just want to meet your code gold quota.
Howso? By having opinions?
The enumerate is "much" faster in cpython, in that it is handled completely in C. Now, you're not gaining a whole lot, since you're just avoiding a single python statement.
I though 3.10 was going to be the version after 3.9 as it was.
&gt;I actually don't think it's a good idea to include shared library in a wheel. It's pretty much standard procedure. Binary wheels make things just work. The point is I do know nothing about their environment, except in the case of Linux that they are almost certainly manylinux1 compatible, so I ship them a .so built against manylinux1 and it just works. Sure, they will get certain advantages if they do a source build (if they can manage that) or use a system package (if one exists).
&gt; The main problem I have is that I can't just sprinkle it here and there. Not a mayor problem in my peoject, but there are some other projects we have where I'd like to use it but I can't because of that ... This can be solved by spawning the asyncio event loop in a background thread and using `asyncio.run_coroutine_threadsafe` to give it things to do. You get back a concurrent `Future` which can be used in regular blocking code to wait for the result to be complete, or to poll whether it's done, and so on.
From the computer's point of view they are the same. Use whatever makes the programmer feel good. --- If you have more questions like this it's better to post them on /r/learnpython. Be sure to [format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) or use a site like pastebin. Also, include which version of python and what OS you are using. 
F strings are faster
By an insignificant margin. 
I always add the commend `# nobreak` after the else clause for this purpose.
F-strings are more readable and faster, but .format is backwards compatible with earlier python versions
I guess you could argue that it’s a matter of preference, and when dealing with a large codebase there’s an argument for consistency, but I think the new f-strings look much nicer. Here’s a nice article which describes the differences: https://realpython.com/python-f-strings/
By rehashing all the arguments about PEP 572. I haven't even been following the main discussion, just what leaks onto Reddit, and it's pretty obvious just from that that everything that needs to be said has been said many times already. You either accept the arguments for it, or you don't, and nobody's mind is being changed at this point.
videos aren't easy to search for particular bits of knowledge either (maybe AI will change that someday), just like paper printed books
Just read \[Effective Python\]([https://www.amazon.com/Effective-Python-Specific-Software-Development/dp/0134034287](https://www.amazon.com/Effective-Python-Specific-Software-Development/dp/0134034287))
That code is wrong. If x=1, ans=0 and y=2 then foo(y) won't be called as it should be. You failed to understand the abstraction the operator grants.
Sorry, two extra lines, not three. And thank you for showing me another use of the operator, that can come in handy. if x &gt; 0: ans = calculate(x) if ans: foo(ans) elif y &gt; 0: foo(y) elif y &gt; 0: foo(y) This isn't "less elegant" -- if anything according to PEP20 it is more elegant because it is more explicit.
Bless you
It's far less elegant because you've copied code. Imagine that the there were more elifs after that -- you'd have to copy them all. If code is changed, it must be changed in multiple places or possibly introduce new bugs. This is the general pattern to achieve the same result: in_elif = True if x &gt; 0: ans = calculate(x) if ans: n_elif = False foo(ans) elif in_elif and y &gt; 0: foo(y)
Just starting to learn python and doing fun projects for practice. Would like to know as well OP 
Here is a good read up on them https://realpython.com/python-f-strings/
I think the reason I started using tox, was because `-e .` was not enough - because while the code ran on my PC. I missed couple of files when it being packed because there were not in `setup.py`. So I actually prefer Tox I think. Thanks for clearing it up :-)
At the point of that many more elifs, I'd just use a dict as a switch instead-- even using the operator would become tedious.
No.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
SquashFUSE will decompress pages on demand, and then store the decompressed pages in the page cache. Once all the pages are decompressed it will be just as fast as a native installation. Until then you incrementally pay the decompression cost for the block you are reading. Using zstd, squashfs decompression runs at 500 MB/s+, so it generally isn't the bottleneck.
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
f-strings only work with string constants. If you're loading the formatted strings from a configuration file or something like that, you have no choice except to use `str.format`.
It's clean-- except the name doesn't make much sense. I mean if, else, elif, pretty standard. Break "out of the loop". Continue "to the next cycle". But else in loops-- the actual word doesn't fit the context. It reads like "do code on all these things, but for some reason you can't, do the else statement", when in reality it just is "execute when iteration fully exhausted". It's also common practice to *not* like break and continue statements-- my Java professor from years ago was adamant about teaching them but saying "use sparingly, loops should only have one exit point". Not that I agree with that sentiment, I think it stupid, but it is a common one. And then with that, the else statements in loops encourage going against the sentiment.
You can't necessarily. Not all chains of elifs can be rewritten as a dict dispatch. For example these can't: elif y &gt; 0: elif z%3 == 0: elif bar(y+z): dict dispatches only really work if you have something like: elif y == 0: elif y == 1: elif y == 2: And even then you have to be careful that y is a key in the dict.
It's "self contained" from the PoV of an application deployment platform, not end-user distribution. Just two different problem spaces :)
No, it is functionally equivalent to try: a = MightRaise() except: print("error") do_stuff(a) But it is useful in rare cases, especially when having nested try clauses (usually through different methods). It's also useful in the following, try: a = MightRaise() except: do_err_cleanup() a = defaultValue else: prepare_unknown_a(a) act_upon_a(a)
In this example, we shouldn't be reusing the expression in the first place. There are several ways to check for a key's presence in a dictionary, but the best one is the `in` operator. result = apples['fuji'].color if 'fuji' in apples else None
Why can't I use a dict dispatch in that case? { bar(y+z): meth3(), z % 3 == 0: meth2(), y &gt; 0: meth1() }.get(True, (lambda: None))() Because identical keys by hash are rewritten in dicts, if the last statement is true, it will do the corresponding action. If not, it will see which of the rest are true. If its the one right before it, then it will execute that way. If not, then it would be the last statement being True. Of course this wouldn't work if bar has some side effect on z or y, but thats a bigger problem of bad code style due to sneaky side effects.
Upfront, you're not going to convince me that your method is in any way better as I find it abstracting for the sake of abstractions for no real gain other than how _you_ perceive the language constructs. Don't create a strawman just to prove your point either. Of course less lines doesn't equal cleaner code, no one is arguing that and you're just pulling BS to _win_ a fruitless argument. I'd argue that your original is worse as now you have to pass the references of the dispatch_table, unless you're just defining a function to be able to use _return_, which even then is bad programming because you're requiring a parent state. I shouldn't have to understand the whole function to be able to refactor out an internal function. You could be creating unintended side effects with the function if you're not passing the values it requires. If you're implying you're creating a function every time the parent function is being executed and I'd say that's even messier than just having an if/else chain with :=. What you're trying to _avoid_ is line complexity, but it's a shitty argument because the overall line isn't complex. Just because it's different from what you're _used_ to doesn't make it complex but different. If you're against changing and learning things then grow up and learn that languages change. Don't use it if you don't want to but people who embrace language features to reduce unnecessary abstractions. There is no issue having variables scoped to blocks and if you find that immensely complex to comprehend while reading then that's on you.
no need for fanciful thinking.. he's plain tired.
Why do you want use Python directly to connect to HDFS? /serious Why not just use pyhive/pyspark so that heavy lifting is offloading to hive/spark?
I want to inspect single files on HDFS occasionally. Spark might be a good alternative for this, good point...
Why would people be downvoting this? I'm so confused
Then pyspark is perfect, it comes with a handy console for adhoc inspection or analysis of data.
Neither. You can pry my %s printf style formatting out of my cold dead hands.
I always assume Saint Helena when I hear exile.
You implied that I was making the code longer to satisfy some lines-of-code-written metric. Like I mentioned, I don't have the context to know what parts should be parameters and which parts should be pulled from the global scope. `dispatch_table`, `cls`, and `x` are all objects that may need to be parameters, or they may not. No, the function would be defined once and used where needed, the way you would normally use functions. I'm not sure what you're talking about with "variables scoped to blocks". Could you elaborate? I don't know what to say here. I know that languages change and there have been many changes to python over the years that have made it better. I just don't think this one does that. I'm trying to communicate why I think that. But I'm failing, I guess.
If neither offers a performance or technical advantage in your case, how about IDE support? Backwards compatibility? Readability? Does consistency matter to you or could you just use both? For me the biggest downside to f-strings is sometimes forgetting the f. Not realizing it until I’m staring at a useless message with a variable name in it. 
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. [Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Yeah, that sounds like the best possible outcome. 
It tells you common mistakes and their effects but not how to avoid them in the Gotchas section...
I'm assuming you mean use-cases. It's use case is saving a line of code if you're using a for-loop to search for a value and break. Not using the feature means you write one extra line of code and save your co-workers a headache because you felt like being clever.
Requests http://docs.python-requests.org/en/master/ Influxdb https://github.com/influxdata/influxdb-python That should get you started
Or a 5 minute video. 25 minutes is a large chunk of my day - nearly 3% of the hours that I'm awake tbh.
It became a necessity to learn it as part of one of my previous jobs, so no previous knowledge, just had to learn it on the spot. Thankfully Python is one of the easiest languages to learn, especially if you have prior experience with other languages.
For loops have else clauses, which only executes if no break statement is encountered. The example searched a list and broke when a value was found. Try blocks have an else clause that execute when no exceptions occur. Dict has a get(a, b) method. 'b' is the default value if 'a' isn't found. The example he used replaced conditional blocks. zip() combines two iterables into one iterable - order is significant. He used it to loop over two lists at the same time. Format strings Use a 'with' block to open resources, because they're automatically closed afterwards.
It depends. For a programming video yes, unless it's covering an advanced topic. 
Upvoted just because you mentioned (and used!) Povray. Hadn't seen the word since like 1997!
Actually no. Both have advantages. Video and audio leverage cognitive abilities that have evolved over millions of years - the cognitive abstraction that covers sight and sound. Your brain is very astute at reasoning about visual and audible information - think of it like hardware acceleration. The problem is that the information comes at a snail's pace. Text can be scanned very quickly, but difficult concepts are difficult because building, or conveying, the appropriate mental model (understanding) is not an easy task through text. Text is essentially 1 dimensional, whereas vision and audio can leverage more vectors, to convey more information. Text also has a layer of complexity that can't leverage cognitive systems that are as refined - the decoding of symbols into abstract reasoning. That's essentially software rendered gfx. The best solution is both. Using both leverages speed and the cognitive leverage that vision and audio provides. I almost like pluralsights approach (not a plug), but it's not perfect. Text is tagged, and by clicking on it, the video will scrub to the appropriate place to cover that concept. It's easy to find what you need, and locate to the right place. If only the notes were presented for me, and I didn't have to waste time writing them. 
Surprised they didn’t mention decorators...
but muh print statement
I see more downvotes on this sub than any other I visit, not sure why
&gt; but you will never write code where it matters I know what my next project is.
Thanks
You can wrap your f-string in a lambda and use it as a template. With some eval/exec black magic you can even make this lambda/template from a config file. It adds an extra function call so the speed advantage of f-strings will be partially lost though.
Yeah, but like you said it is a dumb sentiment. If you don't plan to take advantage of the breaks you may as well not use a loop at all.
I wouldn’t say 2-3x is insignificant. See this: https://stackoverflow.com/questions/40714555/python-string-formatting-is-more-efficient-than-format-function In case you are just printing a couple of strings here and there, sure it is insignificant. However, if you are generating thousands or millions of strings, it is quite significant.
The entire advantage of f-strings is to have the calculation that produces the data in line with the formatting that displays it. If you're going to jump through hoops like that, just use `str.format`.
This way you have a very biased sample. Just because someone is a good programmer, doesn't mean he will be able to steer the project in the right direction.
Very impressive. You should share this with /r/finance as well. They would love it.
No. Both C (compiled by Clang) and Rust are compiled to a LLVM-specific low-level code. Rust is compiled language without a VM like C, so it is normal that it can call C functions, while from an interpreted language like Python, it need cffi library to call C. But from Rust to call to C, programmer still need to create an intermediary function, which is marked "extern C" to inform Rust compiler to compile it to follow C's ABI, and the programmer has to convert data type of Rust to C. This conversion is painful because many Rust data types don't have C equivalent, so programmer has to use a lot of pointer, which is very prone to bug.
Agreed. I am not saying the above technique should be used in general, I was just trying to say it’s technically possible ;)
How does this differ from AppImages? I've been looking at it, and I don't really see any major advantages over some wrappers over appimagetool or something... (Flatpaks FTW though!)
From the [tutorial](https://pint.readthedocs.io/en/latest/tutorial.html): ``` **&gt;&gt;&gt;** user\_input = '2.54 \* centimeter to inch' **&gt;&gt;&gt;** src, dst = user\_input.split(' to ') **&gt;&gt;&gt;** Q\_(src).to(dst) &lt;Quantity(1.0, 'inch')&gt; ```
I'd suggest the Python for Everybody course offered by Coursera. [http://developpython.com/index.php/2018/07/05/resources/](http://developpython.com/index.php/2018/07/05/resources/)
Unless I'm missing something the second one doesn't seem to try to achieve the same thing. In one the line is stripped before being compared, in the second it wouldn't be.
So.. Now instead of bundling my Python program using pyinstaller, I have to bundle it with FUSE and the generated XAR? 
So....maybe make it 7 minutes next time, eh? Or how about 7 seconds?
Thanks, I think I will :)
Any particular reason for choosing XLS over CSV for output?
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
f"{}" strings can also contain expressions, like function calls, and attributes: f"{socket.gethostname()} is the hostname and {os.environ\['PATH'\]} is the PATH environment variable" will substitute those out and evaluate them, replacing them with the output, which i find really handy. that said, it can also pose potential security leaks, if using it on any sort of input.
In other words, they tried to shoot themselves in the foot. And missed.
I just assumed people would prefer the Excel format would appeal to the masses more. Also never exported to an Excel before so wanted to try
I guess it all depends on the target audience. Personally, I try to avoid it as much as I can and for data like this I try to use CSV. I also think that it would appeal to a much larger audience as those who want to use Excel can still import it easily. If you ever intend on adding new features I would suggest an option to export to CSV.
Thanks I'll probably add that next. I'll just have 2 scripts you can run. One for Excel, one for csv
After the first time you see it, you will learn it. If you think about how a for loop works (i.e. you write one without a loop construct, using goto statements) it's also obvious. My only real objection is that they should have used a different word instead of else.
Thanks! POV-Ray is still actively used by many people. you may have a look at bugman123.com http://www.josleys.com/ http://roice3.org/ These are all fan of POV-Ray. 
Programming is 60 percent copy and paste. YouTube does not lend well to that.
r/learnpython
I wonder why that is. Why down vote peoples side projects
A lot of that single point of exit "crap" (for loops, and for functions) has somehow become embedded in the various standards (and therefore laws, which require certain standards) that govern safety critical systems e.g. IEC61509 The regs come from years ago before we knew what we were doing. :-(
If it was a 25 minute video of 7 Python tricks by someone highly respected like Raymond Hettinger, I would watch through it all.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. [Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
I liked seeing this post. You didn't give up on it, kept coming back and finally nailed something practical. Great job.
Are you doing the training on your system or are you just debugging? If you aren't training then get the AMD. If you are, get the Intel. 
It's stuff like this that makes me want to get better at math. Awesome job!
You don’t have to do anything. You could, however, switch to XARs and supposedly reap the benefits of smaller executable size and faster execution time. 
As a beginner I like the idea of an easier to program GUI, and your doc is actually readable by a mere human. Nice work Mike.
Thanks for educating me. I'll remember this thing before posting anything on /r/Python
&gt; Engineering isn't some slap-and-dash exercise. I know Engineering isn't slap-and-dash. See as I'm newbie to professional IT practices and like any engineer, I also want my software is also as perfect as I can in all kinds using every resources that I have for getting knowledge of all kinds of things before starting project. As I have experience from previous projects, if I miss single point then that will affect on complete production. Suppose I developed project in PHP and at deployment stage I came to know that client's server is Windows based and he doesn't want to deploy project on other platform then at that time it'd become completely frustrating complete stressful and you start from basic, now how can I deploy site on Windows? Just because of this reason I want complete technical specification before going for development.
Absolutely! But it is still unfortunately taught now. Not agreeing, just giving a reason why some people dislike it.
Absolutely! But it is still unfortunately taught now. Not agreeing, just giving a reason why some people dislike it.
This is what exactly this repo is for! Show the beauty of math to people without a strong math background with code :P. Glad you like it , and there will be more interesting stuff to come.
May I ask why it matters? Just flip a coin. 
Thanks for the feedback!
It depends on what you are doing and if you are getting GPU as well. If you're doing neural networks using a major framework with an Nvidia GPU, you probably won't see a huge difference between the two unless you have to do a lot of CPU-based processing. If you're doing other stuff or not using a GPU, Intel will probably serve you better because library optimizations are going to have a bigger impact than more threads.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Oh nice, I'm going to try this out. My biggest issue with Python GUIs is that the included library for them is just a wrapper, so you have to know or guess what kwargs you need for this or that, everything is stored as strings not objects, etc. It feels very un-pythonic.
Pybee seems to be promising.
 ~$ python3 Python 3.6.5 (default, Apr 1 2018, 05:46:30) [GCC 7.3.0] on linux Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; from __future__ import braces File "&lt;stdin&gt;", line 1 SyntaxError: not a chance &gt;&gt;&gt; 
Thanks, feedback appreciated!
Some people just suck, either way you got my upboat. Your project is real interesting. Maybe next add something where it asks you for specific list of stock symbols, and if you don't give it some then it just pulls everything down? Idk...
Just like an ocr??
I know. I'm not a big fan of building mobile apps without there native build tools. Haven't found a good noon native toolkit yet that works good. So I try to use native tools for mobile and a cross platform toolkit for desktop systems which works better.
Not alone. Bad code comes by a thousand cuts and they are adding yet another knife.
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Each annual PyCon video channel has a wide variety of talks at all ranges from beginner to expert. [PyCon 2018](https://www.youtube.com/channel/UCsX05-2sVSH7Nx3zuk3NYuQ) [PyCon 2017](https://www.youtube.com/channel/UCrJhliKNQ8g0qoE_zvL8eVg) [PyCon 2016](https://www.youtube.com/channel/UCwTD5zJbsQGJN75MwbykYNw) etc.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Yes there's lots of backwards incompatible changes moving from python2 to python3. [Here's a short list](https://docs.python.org/3.1/library/2to3.html#fixers). In regard to the print function, in python3 `print()` became a function so you need to call it like one: print("hello u silly buggers") --- If you have more questions like this it's better to post them on /r/learnpython. 
Another way to do this you might like is this: result = next((r for r in records if is_what_i_want(r)), None) if result is None: action_when_no_result()
You're my hero
Errors are fixed. Thanks guys for feedback!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
thanks, next time i post in the appropriate receptacle. I had no idea there was another subreddit for people learning python. But also thanks for a very concise answer, cheers and happy coding! 
Can you please suggest me a guide which will show how to properly publish a python package?
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I had the same gripe, but made it through pretty quickly setting YouTube app to 1.25x playback speed and double tapping screen to jump forward a few 10's of seconds at a time. Personally, I really like the presentation style and explanations, but agree it could be trimmed down quite a bit.
Eww.
assuming that you only need reductor to call it once: reductor = dispatcher_table.get(cls) if reductor: rv= reductor(x) elif hasattr(x, "__reduce_ex__"): rv = x.__reduce_ex__(4) elif hasattr(x, "__reduce__"): rv = x.__reduce__() else: ... is only a single line longer but does not need the new syntax
Are you trying to get behind Pizzagate?
What the fuck is wrong with the lower case 'd' in that font?
Just to make sure, we are talking about a third-party shared library, not a purposefully written extension, that was compiled as a shared library, right? Eg. an extension wants to do some networking stuff, but doesn't want to suffer from restrictions of running in a single thread, so it links with libcurl. Then, what you are saying that it would be a standard practice for Python package used to distribute this extension to include libcurl in it? This sounds new to me...
&gt; Type hints for example are very rare in my experience Because they are very optional and people won't normally use them unless enforced by coding guidelines. In the project that enforces type hints in the coding guidelines, every function will have them. But for the assignment expression, it is very useful in places where it can be used (without abusing it)... and we should see it being used without extra prodding from coding guidelines.
For the last few years, I feel more and more that people generally seem to have more unshakable opinions. I don't see anyone really having their opinion changed often enough... they just seem to come up with more and varied reason why their opinions are the correct. Just find out more and novel ways to dig their heels in. I think this is something we as humans need to learn to guard against, else, we are not going to get anywhere with debates, and that I think is a huge loss.
Huh, very good point. 
The "as" was not a catastrophic failure, but a failure for the specified reasons. Those reasons convinced some and failed to convince some others. When it is not a clear cut choice, it comes down to a decision on one or other based on personal taste of the person making the decision. Guide and the authors decided that not using "as" is the way to to. That is precisely one of the roles of Guido as BDFL... to make such decisions when there is no clear cut winner.
&gt; When we kill the PEP That's now how it works.
Do you happen to have a Java background? Because those CamelCase variable names in Python are eww... unusual :D
I'm sure I remember some speech of his advocating 4.0 just being the version after 3.9 but I can only find [this](https://twitter.com/gvanrossum/status/501172370690699265?s=19) which is both old and has been updated since. I might try and find the talk when I have time.
I agree in a way... if there exists a library like Trio or something else that makes it really easy and intuitive to use, then that what we expected he original Python implementation to be like.
If you need to do HTML parsing in Python, have a look at BeautifulSoup/lxml/pyquery &gt; have never used python If you have a bit of programming experience in any other language, reading through the official Python tutorial at docs.python.org shouldn't take you more than one day. Read that then do some simpler things first, like writing a script that accepts a few command line arguments, opening a file and reading content from it. These smaller trivial tasks will serve as foundation for the end script that needs to do the job.
Yes, very interesting point. The largest issue we're concern about is delay. We're purely optimizing for speed, losing .005 for an action throughout the day adds up a lot. 
If your tasks are I/O bound rather than CPU bound, then threading is probably enough for you. You're right in your assumption that I/O bound tasks are well suited to threading. To really understand the behaviours of the GIL in Python when it comes to threading and general concurrency, I highly recommend David Beazley's [Python Concurrency From the Ground Up](https://www.youtube.com/watch?v=MCs5OvhV9S4) talk. Worth the watch. I once wrote a basic example of threading in Flask routes on StackOverflow, if you're looking for *very simplistic* code examples: [https://stackoverflow.com/questions/45363505/python-flask-returning-a-html-page-while-simultaneously-performing-a-function/45383965#45383965](https://stackoverflow.com/questions/45363505/python-flask-returning-a-html-page-while-simultaneously-performing-a-function/45383965#45383965) However I would suggest looking into better methods than the above for production code, especially if you don't know how many people could be calling these endpoints and spinning up arbitrary threads. If each call of a route spins up a thread, you could end up with hundreds of threads running. If however this is in a safe environment where you have zero danger of malicious actors, then that's not as much of a concern. Also, FYI these sorts of questions are better suited to r/learnpython
If we are to learn anything from the history of programming, we should ask to remove `f-strings` from the language as soon as possible. Every language that had interpolation for a while, had realized in retrospect how bad the "feature" was and tried to reduce its use up to completely eliminating it. The reasons against using string interpolation are the separation of concerns, in particular, the separation of information representation and the code that generates the information. The classic examples of misuse of this feature are SQL injections caused by bad assumptions that led to generation of invalid / vulnerable queries, leaking information into HTML pages based on the same bad assumptions. Why does this happen more with string interpolation as opposed to formatting? -- To humans, it feels more natural to prepare and to refine the data before feeding it into string formatting procedures, while it also feels natural to do data processing inside templates with string interpolation. Humans feel as if solving a sudoku puzzle, a kind of a brain-teaser when they see a possibility to squeeze even more calculation into a template as soon as they learn that it is possible. While, on the other hand, automatic tools struggle to identify such cases and to warn programmers against them.
Why don't they want that? Advanced users would like to skip the usual stuff to check out the meat and see if there is something worth listening to. I actually did that... used forward and backward to jump to places in the video to see if they code looked novel or useful. If I was familiar with the trick it, I moved on... if not, I stayed and listened. 
Quite some time. But if I win the argument it'll be worth it!
If it feels more natural to humans, isn't that a good reason to use it? Since we write code for humans first, computers second, it feel to me like we should use more human readable code.
I don't remember seeing the format strings. Maybe that's from some other video you watched. The video had... - enumerate - zip - swap x,y = y, x - dict.get(a, default) - for: else: where else is substitute for 'nobreak' - with open(filename) as fl: for line in fl: print(line) - try: except: else: finally:
Sometimes it's not a bad thing. Just look at php - Facebook and Co dragged it to 20th century already, few more decades of this and who know maybe it will become a real programing language 🤔
So, your "solution" to people being such assholes that they contributed to the BDFL deciding to quit... is to give in to the assholes. And to email the BDFL to basically tell him "it's your fault, if you hadn't made this decision we dislike, we wouldn't have had to be such assholes to you". How about instead of that, you go very far away and never do that ever again?
A look at your code reminded me why electron is a thing. Don't get me wrong, we still need lightweight python apps written in tkinter, but man, Bootstrap + electron would had made the whole job so much easier and prettier.
Requirements files/Pipfile/Pipfile.lock are for describing a specific environment you want to reproduce, and ideally pin the exact versions of all software you want in that environment. The `install_requires` argument in `setup.py` is for generally stating dependencies, including the range of compatible versions when applicable.
I'm sure I've encountered a package that trys to compile part of itself using cython if its installed, so its a matter of reading documentation on prerequisites, something that can easily be missed. For example, I know numpy will install from source without blas/lapack and operate in slow mode. If you didn't the documentation you could easily miss this
Perfect timing, I've been looking for something to help distributing a django app. Will this help with code obsufication in any way, or is it trivial to extract?
Yeah I know what it's used for, that's why I'm confused as to why people are putting it down. If people get headaches from it they should learn python better
Where's the list, buddy? 
This is amazing ! Thanks for the work, if I ever need to, I'll definitely use it 😍
As long as you block shorter than the callbacks execute those delays will not add up. Consider this snippet: # coding: utf-8 import asyncio from time import sleep, time def slow_function(): start = time() sleep(0.9) print(f"I'm a slow function, it took me {time() - start:.2f} to finish") async def slow_async_function(): start = time() await asyncio.sleep(1) print(f"I'm a slow async function, it took me {time() - start:.2f} to finish") async def main(): task = asyncio.ensure_future(slow_async_function()) await asyncio.sleep(0) # Let the loop arrange the task above slow_function() await task if __name__ == '__main__': start = time() loop = asyncio.get_event_loop() loop.run_until_complete(main()) loop.stop() loop.close() print(f'The whole stuff finished in {time() - start:.2f}') Even though I've invoked a function which blocked the event loop for 0.9s, the async function still got executed after exactly 1 second. You see, the event loop had time to catch up.
i think I'm gonna steal your idea, thanks
I thought he combined them both, no?
It's not just Java. I always try to use snake_case but most of C++ wrapper libraries still use camelCase and mixing them in one code looks even worse than using exclusively one of them.
ok if that's your thing. but the lost productivity - this is where the management stories of having to babysit engineers come from. :-)
unity engine is ok for cross platform apps that need graphics or a complex ui. but it's not python.
Ahh, sorry I see, I thought you were talking about optional *runtime* features, not optional *build* features. That's more of a chicken/egg problem. The usual solution is to have a requirements.txt.dev (or similar), and pip install that before building from source. Both pipenv and poetry have a nicer way of doing this via dev dependencies.
I'm a total newbie at gui and python, and googling this now. Is it a good idea to start with electron + bootstrap? Got any good resources (walk-throughs) for it? 
Not everyone who disagreed with BDFL was a-holes. Many people complained for valid reasons. The thing you are missing is that shipping the controversial PEP doesn't make the dispute go away, nor does it end the discussion. Only reverting it and setting it aside for a year or 2 does that. 
Performance and side effects. Also you haven't shown how to manage the conditional assignment of ans. The point isn't so much that you can't use other techniques (Python is Turing complete after all), it's that there's no *good* alternative for this kind of thing.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. [Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
It's PascalCase.
Yeah but that's really just for games.
Not sure if you are looking for feedback, but you should definitely modularize your code. Having everything in 1 file is very confusing. Also it's always nice to adhere to standards for docstrings whenever there are some. There is this [PEP](https://www.python.org/dev/peps/pep-0257/)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://www.python.org/dev/peps/pep-0257/) - Previous text "PEP" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
+= 1
 'cheese'.count('e')
csv can be opened in excel
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
stdlib solution: https://docs.python.org/3/library/pdb.html i personally use and prefer the debugger in pycharm
I don't get you
Electron is basically wrapping JS/HTML5 et al as a desktop application yeah? I've always dreamed of something combining python in a similar manner.
I don't understand why you would want the second case? It's also very unnatural, as we know that the \`if\` has to be evaluated first. List comprehensions also have their own scope (x doesn't leak). But yea, mostly the "if is being evaluated first" makes the second one just simply wrong.
This function is a built-in method on strings. Don't recreate things that already exist. Use /r/learnpython for beginner questions.
Here's a sneak peek of /r/learnpython using the [top posts](https://np.reddit.com/r/learnpython/top/?sort=top&amp;t=year) of the year! \#1: [My new book, "Cracking Codes with Python" is now available and free to read online!](https://np.reddit.com/r/learnpython/comments/7sigre/my_new_book_cracking_codes_with_python_is_now/) \#2: [I'm releasing a free code for the "Automate the Boring Stuff with Python" Udemy course](https://np.reddit.com/r/learnpython/comments/7fxork/im_releasing_a_free_code_for_the_automate_the/) \#3: [I made a python cheat sheet](https://np.reddit.com/r/learnpython/comments/82t191/i_made_a_python_cheat_sheet/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
&gt;easier and prettier Easy and pretty are nice, but performance matters. Electron is **horrible**. Its overhead is off the charts, and Electron apps are always sluggish and painful to use (looking at you Skype and Slack). [PLEASE don't use Electron.](https://medium.com/@caspervonb/electron-is-cancer-b066108e6c32) Just use QT if you have to go with non-native.
I was searching for something similar this morning and this is how I landed here I came across this link http://safehammad.com/downloads/python-idioms-2014-01-16.pdf I am wondering if there is any book completely on this topic 
Don't use Electron, use QT. Electron is a nasty disease and it needs to be eliminated.
3d visualisation, AR apps, etc. Not just games. Anything that uses a lot of 3d graphics and a custom UI.
This was great, keep it up! :)
Thanks for the link, indeed, seems to be similar examples as in my materials. I think you can find quite a lot of similar content by googling. My motivation was to have a set of snippets which is as comprehensive as possible. Basically a complete list of examples that I would have wanted to see myself when I switched from C/C++ to Python. I also tried to have a "fresh touch" in the examples instead of copying from other sources. About books, there seems to be at least [this](https://jeffknupp.com/writing-idiomatic-python-ebook/) by Jeff Knupp. Although I haven't read it so I don't know the quality or how up-to-date it is with modern Python.
Thanks! I'll keep it up, the backlog is basically endless :)
This is Python. If you're *that* worried abkut performance use another language or a Enum Switch. As for side effects, that would be some of the smelliest code you could inagine. All do respect you're grasping at straws. I don't disagree that the operstor is good. But your specific case is *not* made any more elegant by it.
I guess using snake_case in a language called Python makes sense.
Yes, I see your point, we just need to create some test and some basic print statements to see how it works out. Figure out how it really works, but thanks for your direction on this matter. I'll try to report back to you. Sidenote: Why would anyone down vote a post? such a dumb action. ( not you @[slapec](https://www.reddit.com/user/slapec)) 
I had a friend tell me the same thing, but I believe i thought of the process to be more complex than in reality it really is... Without even trying it out with print statements first. Thanks
Yes. I would prefer it if Guido and the community were as conservative on this point as they had been up until python 3. 
Yes, days ago
Is there anything this subreddit will agree on?
What is there to say... Your first solution involves code duplication. Your second "solution" doesn't even solve the original problem (even ignoring side effects or performance).
I think most people will agree on a few things: - Since Electron just uses HTML and CSS, it's very easy to create GUIs that look awesome. - Also, since it uses HTML and CSS, it burns a hole in your CPU and RAM unless you're incredibly careful (spoiler alert: most people don't realize this). 
Sometimes I feel like this is also because of familiarity. Like, I've gotten enough used to GTK+ that I can code up an app that looks like what I want faster than trying to fiddle with HTML+CSS, but the latter also has a *huge* community of frameworks, styles, and tools to make it easier. 
Hmm this could be pushed up a bit with a nice GUI no?
He was tired of being benevolent. He is now going to be "Tyrannical despot for life".
If you already have selenium tests, you might consider using Selenium to control navigation and Beautiful Soup to scrape the pages. Also you should consider asking the folks at /r/QualityAssurance/
Yeah it is. As others have mentioned, it makes designing apps easier, but also eats up your RAM
This is for my first major open source Python app, Disappeer: https://github.com/disappeerlabs/disappeer The repo also has a quick start link to a Debian virtual machine with a pre-configured Tor service, and the app already installed, as shown in the video below. Disappeer is a pure Python GUI desktop app that provides an interface to GPG functionality (key creation and deletion, encryption and decryption, signing and verification), as well as a platform for P2P, GPG-encrypted messaging over Tor. It was developed and tested for use on Debian. I have also tested it on Ubuntu. Here is a video demo showing how it can be used for messaging over Tor: https://www.youtube.com/watch?v=54M7kRrBSJU 
Are you familiar with html and CSS? If you are, start looking into creating web sites with python backend. It adds some complexity related to all the web stuff, but overall might be an easier starting point due to tons of great tutorials out there such as this one: https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world If you haven't encountered html/CSS yet, look into them for a bit and then come back to Flask. You don't need to know much beyond the basics to get started. Starting directly from desktop electron might be hard because of lack of tutorials and overall less than ideal python support.
I should have written playlist..
On the top right (on my screen) there's a playlist button. However, some are duplicates (the a-holes at Coding Tech ~~steal~~ appropriate other people's content and promote them as their own). That said I've learned something new from almost every one of Powell's videos.
It's incredibly inefficient and resources hungry, I agree. But since I am not a designer, CSS frameworks like Bootstrap or Foundation are my only hope of creating something pretty fast. Also, have you tried animating stuff in tkinter? After awhile you start valuing your own sanity over someone's RAM.
His resignation letter didn't do anything to change my opinion of him. I suspect there'll be less gnashing of teeth over this than he hopes for.
Just commenting on the design side. It needs serious polishing. If you can keep the enthusiasm then I suggest to team up with a designer to help you pick up a nice color scheme, font sizes, paddings, layouts, visual rhythm and stuff like that. 
Thank you, for more details I’m writing a python http layer which also immediately calls several gRPC clients and aggregates these responses into a single Json message. Obviously performance would increase if I could do those calls concurrently. The number of threads would always match the number of GRPC calls that need to occur within the handler. It does sound like a DOS (malicious or unintentional) could bloat the threads and cause some issues. I will have to consider this. Thanks! 
Hm. Lots of questions. First, how are you collecting user input? Is this say text field input? .js?
This will not work because after a single iteration of finding the input letter, you'll stay on the same index forever. Stuck in an infinite loop. Example of why it happens: assume the string is abba, and the letter is b: On the first iteration .find will get you the index 1, and your trimmed string would be bba. From now on, .find will always return 0, because b is on the 0 index, and your slicing includes the index of the letter you find. To fix this, simply slice to index+1.
Tyrannical despot in exile for life.
One approach to take is to create a single, global thread pool and feed work into it as needed. The `concurrent.futures` module has a`ThreadPoolExecutor` that does this. You can create an executor, specify a max number of worker threads and your routes can feed it work as needed, and you’ll never use more threads than you’ve specified. If there are more jobs than threads, the work will just be queued up until a worker thread is free. 
Okay, just bear in mind that some people (like me) will opt not to use your program. If you're fine with that, then by all means, stick with electron.
It's odd that this isn't already a top story on /r/python given how big this news is
`breakpoint()` in python 3.7
https://www.reddit.com/r/Python/comments/8yapie/transfer_of_power_guido_stepping_down_as_bdfl/
Is there Windows support for XAR planned? I would love to have a faster executable than pyinstaller
yes, but i'm pretty sure he did the driving part with machine learning . and stuff detection with CV
Odd, I wasn't see that before when I looked at the top for the week but now I do. Going to chalk that up to Reddit mobile, thanks for the link.
I'm still annoyed over the goatfuck that was the 2.7 -&gt; 3 transition's lack of any attempt at backwards compatibility.
I'm always a little wary of teaching newcomers I'm helping this trick. If you don't quite understand what the operator is doing, it's really easy to do "=+1" instead, and have no idea why your code isn't working.
Cool stuff! Though you may want to edit your post, you’re showing how to install PyInstaller, not your package. 
What do you mean by that? If you adhered to newer concepts in 2.7 you could pretty easily upgrade. There's also the 2to3 tool. I suppose the third party libs sucked for a while but that's not Guido's fault
Maybe I'm just spoiled by other, better-maintained languages like FORTRAN that actually try to not break everything on version-change. Not everyone is able to upgrade, and it's really annoying when you're forced to make a choice between using legacy code for an older, outdated version of a language and attempting to find *another* project that does the same thing.
Isnt electron a very heavy package for deployment though? I'm looking forward to getting familiar with Qt for Python which seems to be an LGPL and Python 3 binding for Qt 5. [https://wiki.qt.io/PySide2](https://wiki.qt.io/PySide2)
Saved
User provides with an image to analyze. Then I download it to my server and do the processing. Why would this be important? 
Guido, say it ain’t so!!
Yeah but your argument falls flat because 2.7 has been supported for something like a decade now. You can't fault the language developer for others dragging their feet. I certainly don't blame Python for companies' decisions to avoid a push to upgrade, which has been my context in the past
Mostly curious - Just making sure the model makes sense. There are a couple of ways to do this. It also depends on the language of choice. Go? Php? Python? etc. (Is it Python end to end?) There are system-level ways to accomplish this as well (cgroups, process gates) etc. Redis could be a nice fast option. How are you doing message queueing now? Also, is this on a single VPS?
Isn't that how the whole 572 stuff went down anyway? 
Cool project and I'm glad you are using new requests-html library. Will use it to try to learn something, thanks for sharing. Btw, csv is native to spreadsheets so Excel (or free equivalent LibreOffice) can easy load it. 
These aren't hacks-- such things aren't meant for Python, not to mention definitely not performance.
Minor typo: To ~~us~~ use in your code, simply import.... 
Shots fired
Definitely going to play around with that. Thanks a ton! 
The latest PEP was wildly unpopular, and Guido got a lot of grief and criticism for pushing it through. Guido is a decent fellow, but he wrong just as often as the rest of us.
I think he was generally right on everything until the last few years, and then he kind of just allowed anyone to add stuff to the language. 
I set up a script to browse my entire states computer gigs section on craigslist, iterate through the list and find any that have to do with building a website. After that it clicks through, emails the person a personalized message from me and then emails me letting me know that I've contacted someone about a side job. This saves my time so that I can spend more of it looking for side work elsewhere, being broke sucks :(
Yeah, I'm a big fan of Guido's. But I admit I don't like this latest PEP, or the direction it implies for Python. And that specific direction was Guido's vision.
there is no program which every people will opt to use.
Yeah, the trick is drowning whoever wrote it
For now it is on a single VPS, but the configuration may change in the future if needed. It is Python all the way, yes. Right now it's all synchronous, no message queuing, the threading is only handled by Gunicorn workers. Not sure I'm open to the idea of asynchronous Django anyway, but maybe there's an elegant option, I don't know. 
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I'm not sure it was his vision. The PEP was submitted by someone else who argued about it on pthon-dev for a few months. I think they just chose the wrong syntax -- the `as` version was better, and all the arguments against it weren't very compelling. They were all contrived examples to make it look confusing, whereas the chosen syntax was even more ugly and confusing IMO.
i meant i liked the article
great idea. I've added it to the list, thanks!
It's really not that bad. If you use snake case for python methods, it's easy to see at a glance what is a call into a C library and what isn't.
Here's, a brief write-up on how to run Celery using the file system as a message broker: https://www.python-celery.com/2018/07/03/simple-celery-setup/ Thanks again for the idea!
Are these not just userspace flatpacks or snaps?
Options are good, when they are different enough. Here you get (hopefully) simpler syntax, but the same capabilities. Consider logging or translation modules, I have to use whatever they use, meaning I really have to learn both ways and use the right one every time. Those are not option, they are fragmentation.
Amazing job dude. Keep it up.
Imma snag this for some good code to read. This turned out very nice! 
Q: Does it print a multiple of 111 surrounded by * characters?
[`.ix`](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.ix.html) is now deprecated. 
What did you expect and why? What are the results and why do they puzzle you?
Your post was removed for violating Rule #1. You may have better luck posting this in our sister sub, /r/learnpython.
GUI Interface 
What's the IDE he is using?
lol, AARRRRH! Good catch. Does not bode well for stupid code errors ;) 
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Perhaps this should be a candidate for a RAP Phrase ;) http://www.nanday.com/rap/
I hope nothing too bad too. Maybe Guido thought it was safer to be a bit pessimistic. https://en.wikipedia.org/wiki/Bus_factor