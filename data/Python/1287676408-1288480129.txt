Just smart people.
I don't run linux.... Oh.
I'm sorry if this distracts from the thread, but it seems like he got his answer. I've never used assert before, but is the only difference between it and using the doctest.testmod() (I'm working through how to think like a computer scientist online book right now which uses this a lot) function is that the assert raises an exception while the doctest does not?
FYI: Arch users can get python-nltk and nltk-data off the AUR. Had a pretty funny experience at University last year where we needed to install some corpora, nltk's downloader put them all in application data (windows). This ended up filling our disk quotas which stopped us logging in. The sysadmin wasn't happy. Serves them right imo, Python dev on windows = :(
The doctest module is much more full-featured than assert alone. I would only use assert for the most basic of examples like this. For any serious project, or even semi-serious, I would use a test framework like unittest, doctest, nose, etc. They provide a lot more features that you would end up writing yourself if you stuck to plain old assert.
Sometimes the language's facilities do too much for you and hamper learning.
What's wrong with "if x !=0:" ??
We've got a whole repo of it at work if you need some inspiration...here...for your viewing pleasure: exec_str = "html, subject = email_renders.%s(subscription, include_web_link=False)" % (render_method) html = "" try: exec exec_str # @todo Danger Will Robinson! except: logging.info(sys.exc_value)
It looks like I misinterpreted how this works. Eventlet uses the zmq_poll() function to watch all file descriptors (both zmq and regular sockets). This currently uses the standard poll() function internally, which could be a problem if you want to have a really enormous number of simultaneous connections. An alternate approach would be to get the file descriptors for the zmq sockets and feed those into an existing reactor using epoll, kqueue, or something like that. This is what's being done in the (still very immature) zmq bindings for node.js, and it's theoretically the better approach, but not yet well supported by zmq.
FYI `range(1, 51)` starts the range at 1 instead of 0, making `if vid &gt; 0` unnecessary. Also, `str.format` is the preferred way to format strings in new code as the old `%` format operation is deprecated in 3.0. Happy coding!
Just for fun: try: f = getattr(email_renders, render_method) html, subject = f(subscription, include_web_link=False) except AttributeError as e: # log error 
D'oh, that use of `range()` should have been obvious, but I didn't know about moving away from the `%` operation, thanks!
I would like to make a comment on a section of your problem 2 solution if thelist == x: print "True" else: print "False" This is a very common pattern and you can use print str(thelist == x) This is a lot more concise and clear. You can frequently see this pattern as if thelist == x: return True else: return False similarly you can use return thelist == x 
Is this part of a bigger Python reputation that I'm unaware of due to my bubble (working with it and generally consuming positive information)? I'm hoping not.
To be fair, we can't even agree on how to use the most recent version of Python as a web language.
that doesn't uselessly eat *all* exceptions like the original, though. including ctrl-c and MemoryError!
are you saying 2.x vs 3.x?
Python is awesome, and its great on the web, but I can see where that statement is coming from. * Python doesn't fit in in the enterprise world. The enterprise doesn't care about whether a language is innovative or fun to use. It's about being taken seriously (and often, about being used and backed by large corporations). Python still sits at the little kids table, compared to Java and .NET. * WSGI in Python 3 is still not ready, and it's been making very slow progress. Python 3 is essentially non-web ready until PEP 3333 is finished. * Compared to the old giants like PHP, Python doesn't have anything close to the "server-hours" (if you will) of experience. Many people see it as a shiny toy (and they see things like the Google App Engine as just a nifty experiment). It's hard to change people's perceptions.
Yeah, or more specifically the drama around how WSGI should be updated to handle Python 3. I'm not disparaging Python as a web language, I'm just frustrated that we haven't made Graham Dumpleton "Assistant-BDFL for Web Programming" yet, especially since web stuff seems to get less direction from Guido than other areas.
"Enterprise" developers with a stick up their ass are just as annoying as wannabe-rockstar Rails developers. It's all quite tedious. Use what works. Markus/Notch seems to be one of those odd ducks who know one language, probably don't code very well, and are unwilling to learn anything new. I don't understand it at all. They sometimes make [great games](http://spidweb.com/), though.
You know that Python is fully implemented within .Net, right? Edit: Ironpython, for those who don't know, is a full implementation of the Python language in .NET. If you have .NET, Python is in it, and has access to all of .NET. Visual studio even has a built in IronPython interpreter, which I've used before as a scratch space for designing C++ code.
Compared to java, and thinking with your pointy-haired-hat in terms of decade-long development cycles, yes, python still is a little kid. But you could tell the same from agile dev, any kind of innovative db engine or any kind of non mainstream lib or piece of software. In places where decisions are taken by computer-illiterate (not an insult, just a fact) people, that kind of paradigm will always prevail. They want the most traveled route. Makes developing, recruiting and maintenance easier without any drawbacks for them (since they don't understand the technique). The real drawbacks will be handled by the techies but happy manager will be happy.
Does Python have anything as elegant and simple as Sinatra http://www.sinatrarb.com ? Is WSGI as standardized and sophisticated as Rack http://rack.rubyforge.org/ , which allows diverse apps written in any framework to be plugged together like legos on any application server? I switch hit with ruby and python depending on the project, but I'm not aware of python being nearly as mature with respect to web development specifically. 
It looks good, and certainly more pleasant to work with than PHP. I currently manage five WordPress sites and two PHP-based forum sites; I'm looking forward to a dead-simple Python alternative.
awesome! I'm needing this for a project right now, you just saved me the research :) kudos! btw I've already reused the FilteredSelecctMultiple used in the admin for the ManyToMany relationships, I can provide an example if you're interested.
&gt; Compared to java, and thinking with your pointy-haired-hat in terms of decade-long development cycles, yes, python still is a little kid. For reference: Java appeared in 1995 and started becoming popular with Java2 in '99. Python appeared in 1991 and became a major open-source language in 2000 with 2.0, climbing steadily in popularity after that. I tend to think of them as similarly mature although used for different ends.
Compare Hibernate with django's orm, or JMS vs any vendor-created messaging client in python. While the python language isn't a kids game, the supporting libraries really are. Tooling is also much more mature -- I'd take JUnit, Solar, Hudson, etc any day over what python has to offer. Maven and ant are killer build tools. Deployment of wars into any of the multiple servlet containers (grizzly, tomcat, jboss, etc) is a cinch, and you get a highly scalable, efficient system out of it. The fact of the matter is, when you go by the number of development hours put into each language and their toolsets/libraries, java blows python out of the water. The man-hour age of java vs the man-hour age of python is just too large -- there's no way python could keep up. I'm not saying python is bad either, I use it every day, but that's the logic behind it (and it makes sense).
All you've managed to prove with your assertions is that the advertising dollars being spent to promote Java and .Net were well used, despite clearly being FUD.
&gt; Python doesn't fit in in the enterprise world. The enterprise doesn't care about whether a language is innovative or fun to use. It's about being taken seriously (and often, about being used and backed by large corporations). Python still sits at the little kids table, compared to Java and .NET. I work in this "enterprise" you speak of, and I've been writing Python code at said "enterprise" for almost 5 years now. I originally chose it not for innovation or fun, but because I could solve problems quickly and efficiently. With Python I could get my work done, and the work of others, and it all worked wonderfully. We made more progress thanks to Python than doing the same things in C++. It's currently a significant part of this company's technology due entirely to the success we've had with it. I also know of two companies orders of magnitude larger than my current employer, one I previously worked at and one a family member currently works at, both making use not only of CPython but also of IronPython. These are both investment banks using Python in a number of areas *instead* of Java, C++, and C#. Yes, Python *does* fit in the enterprise world.
Well to be fair, the transition from Python 2 to Python 3 is kind of a chaotic one. One of the biggest advantages to languages like Java or PHP is that the language is practically unchangeable. Python is just a different sort of beast than those other languages, in my opinion. It's young for sure, but it's more than ready. 
I'm not sure whether I want to up vote you or down vote you. While Python hasn't quite logged the 'server-hours' that Java has, the same thing could be said about nearly _any_ language, ie. PHP hasn't logged the number of 'server-hours' as Perl has. Does that make it less viable? Of course not. However, your other point on enterprise has some merit, though only with a grain of salt. There are no lack for examples of giant corporations creating high powered software in Python for proprietary systems, less so as nicely wrapped software to sell to others. Honestly, I imagine the lack of Python and other scripting languages in 'enterprise' software is more a problem that you can't package Python in a way that obfuscates its source code rather than popularity or technical considerations. I can't speak for WSGI in Python 3 since my experience is strictly 2.X at this point.
If you want something Sinatra-like in Python, you're looking for web.py. You know, the framework that this site was originally written in. :) In fact, when people talk about those sort of simple frameworks, they're sometimes referred to as "Sinatra/web.py style frameworks". 
Hm, well seems to require about two lines of python code for one line of ruby, providing the same functionality, but it's still in the right ballpark for "lightweight" web apps. So how about this: can I take, say, any web.py app and any django app and stick them together on the same server the way you could with any "rack"-able appserver in rubyland?
Guess that means I can finally rid myself of my socket.recv(zmq.NOBLOCK) hackery
Not sure why you're downvoted, unless it's because you didn't clarify that IronPython is.
This bottom line, programmer productivity, is the oft-overlooked one. Python's biggest advantage is the ability to crank out a full prototype in 20 minutes once a programmer is adept enough. Adding features and maintaining existing code is significantly less painful than in other environments. My time on planet Earth is finite, and I'd rather get more things accomplished in that time. It works out to be more cost-effective for an employer, as well.
As an aside, the attitude on Sinatra's site bugs me. Sadly, it's things like that which affect perception of the Ruby community from the outside. (Unless I'm the only one that thinks *put our software in your pipe and smoke it* is a bit arrogant.)
Its older than Java... 
I think for the most part 3rd party Python development has had the most success in the scientific computing world. I think its a fair call to say Python is immature on the web, but it does seem to be changing. Anyway look into the professionalism and quality of libraries like Numpy and Scipy and you see that its not all a kids game in Python land.
&gt; two lines of python code for one line of ruby I'd rather read two chapters of Hemingway than one chapter of Cosmo.
It'll get sorted out eventually. *Everything* is in transition anyway. I didn't expect the transition to last until 3.2, though.
Python and AMQP get along well, but AMQP is pain. I've never used JMS to compare it against, but I have heard people say they prefer AMQP. I think the biggest thing with third-party development is that Python glues things together. I've written C extension modules for a specific purpose, then never really been motivated to release them publicly. Compounding that is the differing methods for distributing modules and the lack of a real way to query what is installed in an app. There are PEPs to address this, but I feel like far too late. Two of my biggest gripes with Python are the organization of the standard library and distutils/distribute/setuptools or whatever the flavor of the minor release is. You touch on that here, I think, and it's fair. I did upvote you even though you spoke negatively of Python, because you contributed to the discussion.
I wouldn't say that. PHP 4 to PHP 5 was a huge adventure, and PHP 6 is shaping up to be a killer too.
Sinatra is more readable. Put down the fanboiism for a second and learn something.
All I know is that it's working pretty well for them at Google. Those guys do web stuff, right?
I quite enjoy the fun style of the Sinatra homepage, and don't find it to be at all offensive. Do you have a chip on your shoulder or something? 
How about [Tornado](http://www.tornadoweb.org/)?
In the enterprise, instead of "Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo", they say "Factory factory factory factory factory factory factory factory".
My software engineering teacher recently informed me that Python is not a *production level* language for web development. On my internship out of said college I was told by my IT that they wouldn't install Python on the server, and told me to use Powershell instead. Everyone I have met academically or professionally has never used or Python or see it useful outside of small shell scripts. I really hope I've only experienced some small and horribly skewed sample population. 
I'd love to see what you've done with FilteredSelectMultiple. :)
Graham Dumpleton is god. The amount and quality of work he does with WSGI is truly stunning.
By ruby standards it's polite and acquiescent. Almost without exception it's an *awful* community.
Just as a countering anecdote, my class this semester switched to Python due to it being a "great general purpose language". So, it's not bad everywhere.
On your last point, I'd add that PHP also has the advantage of being dirt simple to deploy. Pick anything in the first 100 pages of the Google results for "web host" and I bet you can just upload a .php file and have it work the way you'd expect. While many of them probably also support Python, it's not usually as simple as being able to upload a single .py file. I think the way WSGI works encourages more maintainable and better written web sites, but we should acknowledge that setting up a new web application is (at least initially) easier in other languages.
Sounds like the same kind of people who think PHP is only used/useful for small web pages and simple scripts.
depends on your circles. Since big scripting is traditionally a unix thing I haven't heard many people using powershell over perl/python/ruby. Python is also pre-installed on OS X and many linuxes. Python is used for all sorts of things. EVE Online is written in python. Lots of games and applications(like blender) are scripted with python. Several desktop application are written primarily on python like calibre (an ebook reader/organizer), Piviti(video editor). Ubuntu uses it for a bunch of system utilities both with an w/out guis. Of course everyone has heard of google, but apparently Youtube is written in python.
I did just find a [blog](http://jace.zaiki.in/tag/mwclient) with several informative entries. Still .... what's the best way to get started with this sort of vaguely-documented API?
They needed a long time to release something after 0.2. That killed them. 
`u` is for Unicode. [Python Documentation: Introduction: Unicode Strings](http://docs.python.org/tutorial/introduction.html#unicode-strings) says: &gt; The small '`u`' in front of the quote indicates that a Unicode string is supposed to be created. [...] As for `mwclient`, did you look at `REFERENCE.txt`? It looks like a good introduction, though I've not used `mwclient`. 
Sinatra is often compared with http://flask.pocoo.org/
That is indeed similar. It seems a lot cleaner than web.py.
LOC means nothing.
Actually, this site was originally written in Common Lisp. They had deployment hassles and moved to Python with web.py, and later replaced it with something else.
&gt; (Unless I'm the only one that thinks put our software in your pipe and smoke it is a bit arrogant.) You could also interpret it as a joke, like a guy talking about how he caught a fish "thiiiis big!!!1 ;-)". If you read it that way, it doesn't sound particularly arrogant. Maybe I'm just viewing the world through tact-tinted glasses. Maybe not, though.
No, but useless lines mean something.
Reddit is written in python too.
I almost shit myself until I saw "Powershell."
Rack is based on some of WSGI ideas, to quote the author when he [first announced it](http://chneukirchen.org/blog/archive/2007/02/introducing-rack.html): &gt; If you are into Python, you’ll notice a lot of similarities between Rack and [WSGI](http://wsgi.org/wsgi/) and [Paste](http://pythonpaste.org/). That’s fully intended, as I think WSGI helped the Python web landscape really a lot. 
I second this. He gives some of the quickest and most detailed responses on stackoverflow and mailing list regarding WSGI issues.
Anyone got them mirrored somewhere? The link above results in a 404 atm...
But they didn't/aren't changing something as basic as the print statement.
The fancy_pantser responds to the pointy-haired-hatster.
And this is how I became a redditor.
i think web2py moves a lot to the CMS direction although we use it for sophisticated web app
The context here is python as a web language in big companies. And in this context, python acceptance/usage and maturity are still in the early stages, contrary to java.
The man-hour age of java vs the man-hour age of python is just too large... Very likely due to the fact that if it takes you three months to do in Java, it'll take a week in python. Off the top of my head, the built in unittest module is based on JUnit providing basically the same functionality. Never heard of Solar, but google hasn't either so I'm guessing its something I'd never find if I ever needed it. Maven does pretty much the same thing as pip and virtualenv, Scons the same as ant. I'm not sure the servlet containers are a selling point, prob lack of experience with them but they seem to take up a lot of memory and give little speed, anyways there's gunicorn and tornado. Hibernate has nothing on SqlAlchemy. Deployment of wars and hudson I'll give you. 
Yes, the new zeromq hub for eventlet works in a very similar way to the poll hub. I hope to have some load tests and benchmarks done in the next few days. The docs for zmq_poll say: "The zmq_poll() function may be implemented or emulated using operating system interfaces other than poll(), and as such may be subject to the limits of those interfaces in ways not defined in this documentation." The approach you mention might be tricky to implement given that a zmq socket could be wrapping any number of real sockets.
Maybe relevant that this text is read by incoming frosh at MIT.
Hibernate compares more favourably and in terms of design with SQLAlchemy. Not knocking Django ORM, but it has a narrower focus and a more user-friendly bent. Hudson as a testing tool can be used with any platform. Whether such a tool is written in Java, C or Python is irrelevant. Maven and ant, like too much of the Java ecosystem, are verbose pieces of shit. Give me buildout, virtualenv and distribute any day (or for that matter, their equivalents in Perl and Ruby). Deployment of a WSGI application to Apache is a cinch, and you get a highly scalable, efficient system out of it. Apache is hardly immature and I'd trust it over any memory-hogging servlet container any day.
Reading through the comments and your replies to said comments, it occurs to me that what you are doing is more copy pasting and form filling/manipulation than any python coding per se, which is fine, maybe, if that's all you are going to do. But unless you sit down and read an introduction or take a 101 course, it's going to be tough going and you'll be doing things in a wrong-headed and haphazard way, just because you don't know any better. So my advice is to pick up a beginners text, like [How to Think Like a Computer Scientist](http://openbookproject.net/thinkcs/python/english2e/) or the like. It will be worth it, you'll be less frustrated, learn more, and thus have a helluva lot more fun. Head over to /r/learnprogramming, as well, people there are very helpful.
Certainly.
http://www.python.org/dev/peps/pep-3333/
Is there a date to confirm when this posting was published?
jizuz is that you ? can you do both for me... i know that humans strieve for the sky but that would be just too kind of one single individual.
Or maybe it's because they don't have time to learn the ins and outs of a new language and to stick with something they themselves can maintain?
... Depending on how you define "useless". On one side, you have Java. On the other side, you have the code obfuscation contest. At what point exactly does a line become useless?
Arguably it's better to force a simple change like that, so you know you have something incompatible. Stuff from PHP4 would break in PHP5 where you least expected. Before that, you had strict mode forced in PHP4 and then you had libraries like mySQL coming and going from the standard distribution. PHP is and was always a mess, but people put up because it's been the Plain Jane of web development for a decade.
Last time I checked, it was [Pylons](http://pylonshq.com/).
(http://www.python.org/dev/peps/pep-0444/)
I like being able to refer to past responses as _1, _2 etc.
Is [a link](http://blogs.msdn.com/b/jasonz/archive/2010/10/21/new-components-and-contributors-for-ironpython-and-ironruby.aspx) to an article published yesterday enough? 
I hope you got through school on scholarships and only wasted your time instead of your own money so that you could be trained in misinformation by people with the same sort of stupid opinions that can be found on internet message boards for free.
He emailed this to the IronPython mailing list yesterday.
Err, this was supposed to be in response to yaginuma. Stupid phone...
The "so fast it's free" claims could use some actual numbers. Can you show the run times of three versions (no logging/stdlib/twiggy) of the same sample application?
I'm using this: http://learnpythonthehardway.org/static/LearnPythonTheHardWay.pdf One of the exercises about halfway through is to write your own choose your own adventure thing with what you've learned thus far. I'll look into the info you posted as well, I just got the book above from another post in the python section. I'll look at r/learnprogramming too, didn't know it existed. Thanks.
Ah, I'm sorry, I misunderstood your situation. I've indeed heard good things about LPH and wasn't aware you were even using a book. As long as the one you are working through seems fruitful, trudge on! Didn't at all mean to suggest otherwise, I just thought for some reason you were lost in the wilderness, so to speak. 
haha, yea that's understandable. I kind of got myself lost in the wilderness by going beyond the constraints of the exercise. The poison and keys and whatnot was a bit above the level of material I was supposed to be using for it. I just got distracted and carried away with making the little game. No worries. :D
well, I introduced Python as main development language at our place and it's used for tons of production stuff since about 1999. And that's a dev team of about 15 people in a 250 people company ... so I guess it highly depends on the place you work at, even the mother company that is mainly a Java shop started to use Python a few years ago for production stuff.
That sounds refreshingly sincere. Not often would you read from someone leaving company A for company B, that actually products x, y and z from company A are currently superior.
I had a co-op job interview last year where I mentioned that I knew Python, and that I had used it extensively over the previous year. The interviewer said, "Yes, but do you know any serious language? Python's a learning language, not something to be used day-to-day." Luckily, I got a nice university job where I've made some Python web services with Pylons and Flask :)
That was an improvement, in my opinion. A lot of PHP 5 wasn't.
This is depressing. Reading through this thread makes me think we as Python developers need to step up advocacy quite a bit.
ok, here's something from my code that I'm using with a ForeignKey relationship (it's a ManyToMany with extra data), here's the part on forms.py from django.forms import * from django.forms.models import ModelMultipleChoiceField from django.contrib.admin.widgets import FilteredSelectMultiple class ExportacionForm(ModelForm): pallets = ModelMultipleChoiceField(queryset=pallets_q, widget=FilteredSelectMultiple(verbose_name='pallets', is_stacked=False, choices=pallets_q)) the `is_stacked` kwarg is for the widget to render vertically or horizontally. on the template add the following to the `&lt;head&gt;` &lt;link rel="stylesheet" type="text/css" href="/media/css/widgets.css" /&gt; &lt;script type="text/javascript" src="/admin/jsi18n/"&gt;&lt;/script&gt; {{ exportacion_form.media }} then render the form. I'll add some variables for the paths from your example later but I'm not sure how to get the admin's location, I guess it'll require a new setting.
Sounds like a chainsaw Perl script to me...
&gt;Status: Draft
Whoops, typo. I meant sonar.
Here's his Youtube channel with all the videos: http://www.youtube.com/watch?v=_XpD71zR6kI
Well that's just crazy talk. How was php 5 not a ridiculously massive improvement? 
I'd say the *marketing* of Python as a web language is in its infant stages. The company I work for once had a client, a small bank, who was paying their parent company around $6000 per month to host their tiny (~15 pages) website in their WebSphere/Oracle environment and the only dynamic portion of the site was 3 interest rate charts that they updated daily. We tried to tell them that even a dedicated server would only cost $200/month, they just flat out didn't believe that anything could be that cheap *and* be secure and fully functional. And built on an open-source platform? Forget it. Nevermind that the CIA, as well as many financial institutions, use Plone. Nevermind that Sourceforge and Reddit use Pylons. There are countless other institutions that have used Python and Python based products successfully, in production, and for years. Some businesses have just been sold so well on the idea that to get something functional *at all*, they have to pay a ridiculous sum for it.
Working at a creative agency rather than a ISV, I find Python still takes some evangelism. Everyone knows what PHP is, most people in this space have at least heard of Ruby on Rails. If you try to sell a client on a technology that they have never heard of, then it must be risky, right? ...and it is true that the number of people that say they "know PHP" is much higher than the number of people that advertise Python skills. At the moment though, I find that the devs that have spent time with Python and Ruby are better.
I don't have Python on hand at the moment, but `some_lame_utility.__module__` should tell you the module. I agree, though, that a slew of star imports is confusing and foolish. 
Giving up the built-in template tags and filters sucks, but I like using Mako with Django.
This is a clear example. web.py is not more readable, but does require more lines, to do the exact same thing.
Howdy, glad you guys are digging on the podcast. The story of the unreliability of the iTunes rss feed - and why they are not downloading now is a bit long. How about I seed a torrent this weekend with all the episodes? That would probably be more reliable than my ability to keep a server up :)
Because I haven't found the time to write it, yet.
i like mako best, where jinja2 comes close 2nd
How far are you willing to take that argument? Should the OP write the sort function? Besides, the OP's solution already uses `.sort`. The version by cname just cleans it up.
please do!
&gt; The approach you mention might be tricky to implement given that a zmq socket could be wrapping any number of real sockets. You'd expect it to be tricky, but in the more recent versions of zmq, you can get a file descriptor from a zmq socket with zmq_getsockopt(socket, ZMQ_FD, &amp;fd, &amp;zmq_fd_size); where zmq\_fd\_size is a variable containing sizeof(fd\_t). zmq\_fd\_size will not be modified; we just need to it support the weird calling convention of zmq\_getsockopt. Once you have this file descriptor fd, then you can poll it in the usual ways, like poll() and select(), or epoll, or kqueue, or whatever you like. Check out the implementation of zmq\_poll [in zmq.cpp](http://github.com/zeromq/zeromq2/blob/master/src/zmq.cpp), and you'll see that it does exactly this internally. To integrate this into an existing asynchronous reactor, what you can do is just use zmq\_getsockopt with the as-yet-undocumented ZMQ\_FD option, and feed that file descriptor to the reactor. When the reactor says that fd is ready for reading, then you do a read from its corresponding zmq socket using the usual zmq\_recv(). According to discussions on the zmq mailing lists, they plan on making ZMQ\_FD a documented part of the API, precisely to support plugging zmq into existing reactors. They're just waiting for the code to stabilize. Anyway, kudos on getting zeromq to work with eventlet. I love both, and they're even better together.
It all depends on what their instructor is looking for. I have no idea what that is.
I used PyX in the past, which is quite nice. I don't know ggplot2 but I suspect you'll find PyX lacking in the same ways as matplotlib. Have you looked at using ggplot2 via RPy?
I use Jinja2. I want to use HAML-like templating engine in Python, but there seems no templating engine that satisfies my criteria.
The tutorial in the RPy 2.x (I'd recommend 2.1.x as it's much better than the 2.0.x series) docs explicitly uses ggplot2 for some examples, also.
tl;dr: PyPy backend targetting .NET bytecode (secondary tracing JIT layer above the CLR or mono JIT). Claims to be up to 40 times faster than IronPython in some cases (but slower in others; apparently PyPy is not so good with Old-style classes, string processing and regular expressions yet).
Yeah, that sentence for me was "what? WHAT? oh, Windows."
While I'm aware of Unladen Swallow, I'd like to know what they use it for. I wish GvR could elaborate some on where Python is in use at Google, and what it powers. Ah, [here's some info, if a bit dated](http://panela.blog-city.com/python_at_google_greg_stein__sdforum.htm).
i also use jinja2. i like django template engine's philosophy of separating logic from presentation. jinja2 goes too far, but you know the separation of code and logic is still blurry... and also have you checked http://github.com/jessemiller/HamlPy ? 
Mako is what I use. Very fast.
Have you ever tried matplotlib?
http://matt-welsh.blogspot.com/2010/10/computing-at-scale-or-how-google-has.html
and you didn't even mention fabric yet.
Glad you told them to do one. What a ridiculous thing to say; would you say this: "Yes, but do you know any serious language? Java's a learning language, not something to be used day-to-day."? If anything, Java is used more in academia.
TAL, because the syntax works within the existing confines of HTML, and so is less obtrusive. Best implementation is [Chameleon](http://pypi.python.org/pypi/Chameleon) because it's smokin' fast. 
Maybe because mod_python is outdated and no longer supported.
Because there are better ways of doing python on the web.
Then I guess a better question is, why is there no *supported* python alternative to PHP? It is pretty clear that people love templating, though I have never understood why. I like my code separate from my templates. 
Because indentation's a bitch.
I think because people want to prevent PHP-ish programming in Python. Mostly out of personal preference. Personally, I feel WSGI matches the way I like designing my web applications perfectly and I don't have a _need_ for PHP-ish integration.
Have you ever heard of web2py, Django, Flask, Pylons, etc.? The web2py template language is very similar to PSP but uses pass to close blocks so {{for i in range(10:}}&lt;h1&gt;Hello&lt;/h1&gt;{{pass}} Pure python otherwise and solves the indentation problem. It supports blocks and you can extend and import other templates. You can also define html functions: {{def f(x):}}&lt;a href="{{=x}}"&gt;{{=x}}&lt;/a&gt;{{return}} &lt;html&gt;&lt;body&gt;{{f('http://web2py.com')}}&lt;/body&gt;&lt;/html&gt; 
You may want to look into web2py's template language and it's helpers. For example these are equivalent and interchangeable: &lt;ul&gt; {{for i in range(3):}} &lt;li&gt;&lt;span class="a"&gt;b&lt;/span&gt;&lt;/li&gt; {{pass}} &lt;/ul&gt; &lt;ul&gt; {{for i in range(3):}}{{=LI(SPAN('b',_class="a"))}}{{pass}} &lt;/ul&gt; {{=UL(*[LI(SPAN('b',_class="a")) for i in range(3)])}} It supports full python + blocks + extend + include.
"final solution" might be be the best phrasing... 
The [network effect](http://en.wikipedia.org/wiki/Network_effect). PHP is entrenched. It's available everywhere with zero setup and everyone (sadly) knows how to use it. PSP is some obscure, obsolete hack that never gained any traction.
People don't use PHP today because they prefer its programming model. They use it for the same reason they use Windows and shop at Wal-Mart and eat at McDonald's. It's cheap and ubiquitous and is a relatively *safe* choice, even though it is nowhere near an *excellent* choice.
mod-python is dead. It never worked well. If there's something to learn about PHP, it's how to make something unmaintainable. No one who knows anything wants to mimic that. I know probably 30 web programmers, and only 5-10 of those use PHP regularly. Almost all the remaining ~70% are split between Rails and Django.
&gt; I know probably 30 web programmers, and only 5-10 of those use PHP regularly. Almost all the remaining ~70% are split between Rails and Django. I'm confused as to what your point is with this statement. PHP is still far more widespread than either Rails or Django.
\_\_all__ = None Better :-) (import * then fails altogether)
Hate the programmer, not the language
I hope you're not making one of those "no language is perfect, therefore no language should be criticized" arguments...
Hate the company that decided on PHP, not the programmer.
Agreed. I'm currently looking for a job, and it makes me rage how many more PHP jobs there are vs. python. 
Can't hate the company, they just want to make money. It's the duty of the programmer to find the best solution for the company. After all, they don't care how pretty your code looks - they just want to get shit done.
Nope, all languages are tools for different purposes.
&gt;It's the duty of the programmer to find the best solution for the company. We try -- and then management decides we can't sell a solution based on Hadoop/Hbase because it's "too unproven", or that it would be too hard to find qualified Python programmers. That's why it gets written in MySQL/PHP.
Sure, but some of them are still *bad* tools.
Django's templating engine! :D
Well, it really depends on the context of the problem :)
Hi Sarah - that's very interesting! Do you know how to use IRC? If so, you could come to the #fluiddb channel on irc.freenode.net and you'd find plenty of real-time help, including from the authors of the FluidDB python libraries. We'd love to help get you going, guide you, etc. That can include or supplement you learning more about Python. Terry 
Without taking sides in the PHP war, some tools are not good for any problem, or they would be OK if there weren't a clearly superior alternative. In other cases, a tool might have some little advantage but overall not be worth whatever trouble it brings. So it's not always true that it depends on the context of the problem.
I know I am just kneejerking, but that is so damned nasty looking
Well, I've [proposed that he take the reins for WSGI 1.1](http://mail.python.org/pipermail/web-sig/2010-September/004693.html), at least. ;-)
PEP 333 was actually still in "Draft" status until the day 3333 was released, at which point it became "Final". So this is less of a problem than it may appear. ;-)
It is just "{{python here}}html here..." what is nasty? The Python part, the html part, or perhaps the example I provided?
Also check out similar library: [gevent](http://gevent.org) ([Comparison to eventlet](http://blog.gevent.org/2010/02/27/why-gevent/), [Benchmark](http://nichol.as/asynchronous-servers-in-python))
 __all__ = None Oh! That *is* nice!
The indentation example made me *cringe.*
Language snobbery is stupid. It's a matter of the right tool for the right job. For example, I wouldn't write a device driver in Java or C#/.NET, nor would I write a web application in C/C++. My personal site (resume, projects, blog, photo gallery) is in PHP because it was quick and easy to create something that did what I want it to do. It's small, so there's relatively little maintenance cost or complexity. There are plenty of mature, pre-existing solutions like WordPress, ZenPhoto, etc that I can deploy with a single-digit number of clicks, and then easily customize to my liking. It's also really easy to find cheap hosting. I'm also working on a couple of projects for fun right now. Both use Python. This is because I prefer the programming model, can do more of what I want without the same clunkiness, and can host prototypes using something like Google AppEngine.
He's right, that looks terrible. I guessing cause of all three. 
&gt; Language snobbery is stupid. I don't think I'm a snob. PHP is really the only language that I would call flat-out bad. Others have quirks or whatever, but I can respect them for doing what they do well. PHP doesn't even do what it does well. It just scrapes by. &gt; For example, I wouldn't write a device driver in Java or C#/.NET, nor would I write a web application in C/C++. Sure, no argument there... &gt; My personal site (resume, projects, blog, photo gallery) is in PHP because it was quick and easy to create something that did what I want it to do. It's small, so there's relatively little maintenance cost or complexity. That's cool, and I can relate, as I've done the same type of thing in the past. The problem is that people use PHP for *real* code that supports businesses who consequently become heavily tied to the language, and as they grow and their code grows, it becomes impossible to abandon the language. So now you're stuck with a *big* application written in PHP, and the language is sabotaging you left and right, preventing you from writing a decent quality application. Sure, you can potentially overcome PHP's pitfalls with enough diligence, but you'll do that *in spite* of the language, not *thanks* to it. &gt; There are plenty of mature, pre-existing solutions like WordPress, ZenPhoto, etc that I can deploy with a single-digit number of clicks, and then easily customize to my liking. It's also really easy to find cheap hosting. Again, no argument there. It's the lowest common denominator on the web, and is ridiculously widespread. It's the high fructose corn syrup of programming. (C is the flour... maybe rice) &gt; I'm also working on a couple of projects for fun right now. Both use Python. This is because I prefer the programming model, can do more of what I want without the same clunkiness, and can host prototypes using something like Google AppEngine. Right on. It amazes me that you can appreciate the pleasantness of Python and not be absolutely enraged at PHP. Maybe you don't have to use PHP professionally. I bet if you did, you'd resent it a lot more. I do, and I do.
&gt;I don't think I'm a snob. I wasn't speaking against you - this was intended to be more of a general statement. I agree with most of your other points. &gt;It amazes me that you can appreciate the pleasantness of Python and not be absolutely enraged at PHP. Maybe you don't have to use PHP professionally I've used PHP for projects that I've done for others (small side stuff when I was in college - nothing major), and the only time I've absolutely hated PHP is when I had to modify/maintain someone else's code. I feel that the problem with PHP is that it is designed in a way that *allows* bad code to be written in such quantity. You can write elegant, maintainable code in almost any language (except for Whitespace, Brainfuck, and maybe LISP/Scheme). The difference is that PHP seems to be set up to bring out the worst in certain types of coders. A lot of the hatred for PHP seems to come from folks who have to maintain and work with others' code. This can't be coincidence. My view that PHP isn't necessarily bad might also stem from the fact that I've had to maintain legacy VB code in the past. After the horrors of that crap, almost anything seems bad by comparison.
Because everyone already has a DS instead.
People who do serious PHP work tend to structure their code to clearly separate logic and presentation. WSGI frameworks usually do this by default.
Now for some genshi! &lt;h1 py:for="i in range(10)"&gt;Hello&lt;/h1&gt; &lt;a py:def="f(x)" href="$x"&gt;$x&lt;/a&gt; &lt;html&gt;&lt;body&gt;${f('http://genshi.edgewall.org/')}&lt;/body&gt;&lt;/html&gt;
Another fun way to do problem 1 is to use sets. It kind of misses the point of working through the details in an intro course, but you already got some good answers. def problem1(a): return len(a) != len(set(a))
Pretty much, most of the smaller websites on the internet run on a few control panels (cpanel, plesk), these control panels offer a specific set of functionality (as driven by market demand). mod_wsgi is not included within this standard set of functionality, there for you have *alot* of businesses that are growing on a basic LAMP platform and paying the bills as such.
I use [Mako](http://makotemplates.org/). It's very flexible and its syntax is very beautiful. reddit uses Mako as well.
On the bright side, you could get more money for a python job since there's less supply.
Try Pylons.
Because embedding scripting languages directly in HTML code is one of the reasons PHP is so disliked.
The reason that this is such a bad answer is that after it finds the first element, _you_ already know enough to not be interested in searching further. count(&lt;element&gt;) does not know this and will scan the whole list to find every one. If the in operator doesn't suffice for some reason, you could do not any(item == x for item in a) This is still over complicating it but at least short circuits when it finds the first duplicate. Also, pedantic but worth noting, Python has lists, not arrays. (not quite true, but true enough until you learn the difference)
If you want the ability to mix arbitrary code with your templates, PHP style: http://www.makotemplates.org/ Just beware that Jesus kills a kitten every time you do that sort of thing.
One good way to approach problem two is with a generator expression def is_sorted(seq): return not any(seq[i] &gt; seq[i+1] for i in xrange(len(seq) - 1)) This has the advantage of breaking early if there is an out of order element. Without a generator expression (which should generally be favored if possible, it's def is_sorted(seq): for i in xrange(len(seq) - 1): if seq[i] &gt; seq[i+1]: return False return True This explicitly uses an index which is normally not advisable but in this case works very nicely.
Point: It's possible to avoid the horseshit and use something good.
Guido might be my hero but: "vim forever!"
Fuck you! When will people realize that Emacs is the true editor?
I use a fork of jinja2 that's modified to provide the entire context to context funcs and filters. (Jinja2's compiler normally emits some vars purely as locals without adding them to the context object.)
Yeah! Fuck you both! 
I would like to say that pycharm is much faster to learn than emacs. Its preferences do have a search. Emacs just feels better after getting into it though, whereas Pycharm makes you happy about the code you are writing itself.
Genshi for HTML/XML (with chameleon as engine), Mako for text
For the record: I held that talk at ua.pycon today.
Well done! Your changes shall be committed on Monday.
Have you seen locals? If you are doing this in a function you get exactly what you want # Copy and paste-able example def my_scope(): a = 1 b = '2' print(locals()) my_scope()
How is the data dictionary used after this? Are you just condensing the several variables into one thing you can pass around? I think clarifying the use would go a long way to understanding your problem. It honestly seems like a silly thing to do.
*outside Emacs I expect Cmd-Z for undo, not whatever it is in Emacs (I don't actually know the keys, only my fingers do...).*
It can be whatever you want in emacs, including Cmd-Z.
Passing variables to XML-RPC for example.
I question your motivation for such a pattern but in addition to the 'locals' builtin you might also take a look at [namedtuple](http://docs.python.org/dev/library/collections.html#collections.namedtuple). It's useful when you just need in-place objects with a couple of fields, and converting back and forth between dictionaries and namedtuples is a snap. EDIT: Alterantively, in your given example, you could do something more terse like: return dict( name = 'spam', food = eggs.some_horribly_long_method("blah").lower().replace("a", "b"), thing = True, ) 
That does exactly what I need! Many thanks! :)
Do you really need the variables for anything other than populating the dictionary? data = { 'name': 'spam', 'food': eggs.some_horribly_long_method("blah").lower().replace("a", "b") 'thing': True }
While I agree, in essence, with doing things the way you just expressed, there are way too many cases in my code where this results in a huge, ugly dictionary that's a bit hard to read at times.
Careful though, locals doesn't always behave like you expect and can include keys you didn't want such as ``self``. Better: dict(i for i in locals().iteritems() if i[0] in ('a', 'b')) I wish dict had this as a method, but you can make a function for it. def subdict(mapping, keys): return dict(i for i in mapping.iteritems() if i[0] in keys) Just for kicks, here's the expression in Python 3: {k: v for k, v in locals().items() if k in {'a', 'b'}}
I do this all the time. I think it looks great, it's just as explicit as the original, and more explicit than the locals() trick.
I was just going to say the same thing. Metaprogramming is fun, but it can result in unpredictable behavior and very hard to read code. Trivial example: for l in locals(): print l results in a RuntimeError, because after you start iterating through locals(), you create a new variable l, which gets added to locals(). Use this power wisely.
Ok, seeding this torrent file now. It contains all of the mp4 files for every screencast. Enjoy! http://muppethouse.com/osmosis.tar.torrent
Yeah, I'm generally of the opinion that you need a pretty strong justification for calling locals(). It's usually indicative that you're doing something wonky and there's probably a better way to do it.
How had I never come across chameleon before?
The Windows API example seems *very* pointless. * Having the struct size in the struct is not a real problem and enables the Windows API to extend the API later. * *No defaults at all* is a programming language restriction. * Why is it a huge security problem? Why is your example better? * *Platform Specific*: Really? I mean, this is a platform API... Thinking about your `ShellExecuteAndWait` proposal: * Ugly. * Where is all the functionality the Windows API provides? (Simple example: You cannot specify whether you want to show the other application). * Not modular. You would need two different functions for waiting/not waiting for the return. The Windows API is simpler: Run the application via `ShellExecuteEx` and optionally wait for it via `WaitForSingleObject`.
ShellExecute[Ex] is only implemented on Windows XP and later. If you want to support Windows 2000, you need to use [CreateProcess](http://msdn.microsoft.com/en-us/library/ms682425\(VS.85\).aspx), which is even more hideous.
Eric4 is free and awsome, written in python uses pyqt4 which now days is very easy to install. Threaded debugger, starts up quickly. I use vim as my main editor. I do small changes in eric when I am debugging. I just leave the 2 editors open and the opposite editor ask me to reload the file. One tip, Eric will have every button bar enabled. I just disable all and add the ones I want. http://eric-ide.python-projects.org/
Should work with ``.iter*`` though, yea?
Eric4 is pretty intimidating. I wish there was a "lite" version.
I agree. I use emacs, but there are features in vim that I absolutely love, and to implement them in emacs would be hell (I can't stand the braces!, I am very OCD). My emacs config directory is already at 130mb, I am seriously thinking of rolling my own custom editor.
So you basically assign locals() to a variable beforehand?
Amusingly, that line will work if you try to execute it a second time, because l is already in locals() then.
was not aware of this, awesome
&gt; My emacs config directory is already at 130mb, I am seriously thinking of seeking a mental health professional. Dude. I love emacs as much as possible. Daily user for 10+ years. But man, 130 mb in config files? 
Yep. Org-mode from git, as well as a bunch of other scripts. Also, I do not need mental health counseling anymore. That is behind me now.
 # Without extreme and intensive testing, I cannot verify how proven the # following function will work in all cases. Please, try to break it. import inspect def dictify(*args): """ Capture the variable names passed in as keys to the values a part of the args parameter. &gt;&gt;&gt; x, y, z = 10, 20, 30 &gt;&gt;&gt; dictify(x, y, z) &gt;&gt;&gt; {'y': 20, 'x': 10, 'z': 30} """ frame_1 = inspect.currentframe(1) x = inspect.getargvalues(frame_1) y = x.locals.copy() for key, val in x.locals.iteritems(): if val not in args: y.pop(key) return y x, y, z = 10, 20, 30 print dictify(x, y, z) # -&gt; {'y': 20, 'x': 10, 'z': 30}
Tornado has a templating engine that is very close to raw Python. I enjoy that. &lt;html&gt; &lt;head&gt; &lt;title&gt;{{ title }}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; {% for item in items %} &lt;li&gt;{{ escape(item) }}&lt;/li&gt; {% end %} &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 
I just realized that if you pass in say 30 (not the variable, but the real int 30), z would be a part of your dictionary. No real amount of checking goes into this but as a basis it does what you want. Maybe you could build off of it. You can also try to id values here and make sure they're really pointing at the correct variables. A lot to build on but I'd say being explicit is the right way to go and the above function was just for fun.
I think this would fail if you have several variables with the same value in locals() and you need a specific name.
You're right. That's where rules come into play. A proxy function might work here where it sort of filters on the exact names you're working with. It makes sense in my head but I am about to kill some zombies.
what about this? class data: name = 'spam' food = 'food' thing = True data = data.__dict__ or, if you want some syntactic sugar, you can wrap the logic inside a class decorator or a metaclass, thus being able to write things like: @dictify class data: foo = 'bar' class data(dictify): foo = 'bar' and have the dictionary directly in 'data', without need to fish it through __dict__
The decorator would also have to remove __doc__ and __module__ from the dictionary, but yeah, this is probably the best solution. Thanks!
I'm of two minds about locals. I use it for templating strings, eg template = '{foo},{bar}:{baz},{spam}:{eggs}' template.format(**locals()) rather than template.format(foo=foo, bar=bar, baz=baz, spam=spam, eggs=eggs) which strikes me as a duplication of effort (and also brittle since if you're altering your template string a lot for development). OTOH, locals is less explicit and causes pyflakes to bitch about the first code but not the second.
For use with Django: Jinja2, for sure. It's not necessarily my first choice elsewhere (though there's nothing wrong with it), but it's a capable and fast templating language, it has some similarities with Django templates, there is specific support code for it (Jingo), and you'll find lots of Django developers who are familiar with Jinja2 and can help you when you have problems.
I don't think I understand what you are asking. You say 'Create a class for each of my objects' But I think maybe you mean, create an object for each string in a list? In your example, what is 'a'...is that the name of the movie? maybe you want: class Movie(object): def __init__(self, name, id): self.name = name self.id = id movie_names = ['movie1', 'movie2', 'movie3'] for name in movie_names: new_movie = Movie(movie_name, generate_id()) Although, like I say, It is fairly impossible to guess what you are tryin to do...just a random stab.
Sorry for my lack of clarity...I'm not a programmer by nature - just learning so my naivety may have made my explanation convoluted. I think what you have created is essentially what I want to do. Yes I want a list that I can add / detract entries from. Then I want to turn the strings in this list into classes so that they can be given attributes. So if I have, as you do above, movies_names = ['movie1', 'movie2', 'movie3'] Then I want to run a loop that each of these movies becomes a class of its own that I can assign attributes to... so after the loop is run I will be able to do the following: movie1.id = 12345 movie1.name = "Movie Name" Sorry again for my lack of clarity but this is what I'm trying to accomplish.
I would say that's a fairly tame and probably justifiable use of locals(). The result doesn't escape the scope, it's explicit enough, the chance of error is low, and it's reducing boiler-plate. 
What I want to see is: * Changed the license from GPL to LGPL. Please? I love the library, by the way. No other GUI library comes even close.
I upvoted you for not caring!
&gt; except for Whitespace, Brainfuck, and maybe LISP/Scheme Wow. I can understand dislike for Lisp/Scheme, and I dislike them myself. But to think they are in the same category as Whitespace and Brainfuck? Seriously? 
You do know you can reformat that one pair per line and it will only be slightly longer than what you're doing now?: data = { 'name': 'spam', 'food': eggs.somehorriblylong_method('blah').lower().replace('a', 'b'), 'thing': True, }
I know, but when 'food' is actually several lines, it needs to be split off anyway. So I'd rather just define everything up above as variables, then collect them together in a dict.
More than just a GUI library
I read though this and other stuff about web3 and pep 3333 and quite frankly this stuff needs to get fixed soon. I just wish I could use python 3 for web dev. I wonder how much longer this is going to take.
Yeah. But no other GUI library comes even close.
This. The instance of a class is usually called an object. The only issue with what semarj is saying is that on each iteration of the for ... loop the name "new_movie" will be re-pointed to a newly-created Movie object, and the prior one will be abandoned and garbage collected. You may want a new list created from the name list, and list comprehensions are a concise way of doing this: new_movie_list = [ Movie(m, generate_id()) for m in movie_names] That results in the movies being a usable list of objects. However, referencing these may be messy, so you may want to make that into a list: new_movie_dict = dict([ m, Movie(m, generate_id()) for m in movie_names]) Now you can access these objects by name by doing this: new_movie_dict['movie1'].length = '60 minutes' When you want to make a global change to them, you can iterate through them each by using the same for ... loop construct as before: for m in new_movie_dict.values(): m.new_thing = "something new's default value" That may be a bit difficult to understand at first, but if you play with it you may see how useful it can be quickly. 
Then you might want to reply to michaelgruenewald's comment.
??? When `food` is several lines long... it's several lines long. Makes no difference. I don't see why you'd need to split it off. data = { 'name': 'spam', 'food': (eggs.somehorriblylong_method('blah') .more_methods().an_attribute.woot() .stop(datetime.now(), HammarFactoryFactoryFactory().automate()) .hit_rock().GiveUssssAHug().lower().replace('a', 'b')), 'thing': True, }
Well, the OP **did** say that he/she has tried matplotlib, so I'd suspect the answer is *yes*. However, I'm interested in what's missing from matplotlib? I've been pretty happy with it, but maybe I just don't know what I'm missing in R and ggplot2. I looked at the [ggplot2 website](http://had.co.nz/ggplot2/), and it seems like many/most of the plots in the reference manual can be done with matplotlib. Can the OP elaborate on what he/she finds superior in ggplot2?
What's wrong with PySide?
`vars(x)` is a bit less ugly than `x.__dict__`.
What if you need to use intermediate variables to define 'food'?
&gt; * Changed the license from GPL to LGPL. Don't see it happening TBH. Phil Thompson needs the revenue in order to eat. Moving to LGPL would affect that. I think, however, the PySide bindings are going to hurt him in much the same way anyway. Best result for him may have been Nokia buying him out, but I don't know the circumstances around any moves there, if any. Very well implemented toolkit, however.
&gt;As of 2010-10-12, PySide is maturizing rapidly and is approaching the 1.0 release. We consider the stability to be pretty good already, and starting development on PySide should be pretty safe now. However, since individual quality expectations may vary, testing is recommended. - http://www.pyside.org/faq/ Just a guess, maybe some people don't like the fact that it is "pretty" stable? I don't do any thing where stability is *that* important, so I wouldn't know.
Why would you need intermediate variables? And even assuming you do, you just define them outside the dictionary. `food` itself should stay inside. I think perhaps you're trying to cram your code together too much.
Can I use QML with PyQt?
class Movie(object): pass (not "movies")
It could be the most terrible thing to ever walk the lines of a monitor but I sure had fun coming up with it. What's the point of programming if not for exploring ideas and expressing the possible? If it sucks a thousand bloody monkey anuses, I'm cool with that.
I'm a big critic of Win32 API, but in this case I have to agree. For OS APIs, you want functions which are general and powerful, "ShellExecuteAndWait" is too specific, it should be a helper function and would be unnecessary clutter in an OS API (not that Win32 isn't cluttered anyway...)
I've read a few of your slideshows posted on Scribd in the past but they always leave me wanting a transcript or something else to provide more complete details. Was the talk recorded?
Do you mean something like what this function does? http://docs.python.org/library/functions.html#setattr If you are trying to store a list of movies with information about each movie, you'd probably want to do something more like this comment's suggestion: http://www.reddit.com/r/Python/comments/dvfxe/help_creating_classes_from_a_tuple/c137p16
&gt; completed a large-scale financial system in Python can you describe the architecture a bit ? is it a GUI app or backend/server based app ?
probably mostly scripts(elisp plugins)
Why 4.8? why not synchronize with qt version numbers?
I assume you've seen Joshua Bloch's excellent 'How to Design a good API and why it matters' http://research.google.com/pubs/archive/32713.pdf edit: ah whoops, didn't read the small print on the last slide, I thought they looked familiar. anyway, the link is useful enough :D 
I disagree completely. The OS-level functions ought to be small, compact, and do only one thing and do it well. If you want ShellExecuteAndWait, write it yourself by making use of 2 or 3 specific OS functions. It seems like talks like this assume that once an API is written, it can no longer be improved. The OS should focus on having a very solid and small set of functionality and have an extra layer of API to make programming on the OS programmer-friendly. 
It would be cool if he tried eclipse/pydev and did a comparison.
I too wonder what you miss in matplotlib. I can't see anything that makes ggplot clearly better, although I like their default frame style of white axes with a grey frame background. Something matplotlib does well is interactivity (pan / zoom etc.). You should take a look at Chaco (http://code.enthought.com/projects/chaco/). There seems to me to be some similar concepts to ggplot e.g. the ggplot "geom" objects become "renderers" in chaco-speak. You compose renderers to make your final plot. However, Chaco is mostly oriented to building plotting applications, rather than one-line plot commands. Chaco is (even more so than matplotlib) geared towards interactive applications where the user explores their data by pan/zoom/select and other parameters. It full utilises the Traits "reactive programming" framework. As far as Chaco vs matplotlib goes, they have complementary aims: Chaco for building applcations, matplotlib for command-line or script-based plotting.
You're the man. Great videos from what I've seen so far!
Oh, noes! I use % for formatting strings ALL the time.... Guess I'd better start retraining my fingers.
&gt; Having the struct size in the struct is not a real problem and enables the Windows API to extend the API later. You can also just have a second function ShellExecuteEx2 that operates on a separate struct. &gt; No defaults at all is a programming language restriction. I did point that out in my actual talk. &gt; Why is it a huge security problem? Why is your example better? I also pointed that out in my talk. I was referring to the fact that it relays on quoting all parameters by hand and putting them into one string. This is especially hard to do in C. &gt; Platform Specific: Really? I mean, this is a platform API... I was referring to things like `SW_NORMAL` which does not make sense if you are running on a windows version with a different window manager like windows for phones. &gt; Where is all the functionality the Windows API provides? (Simple example: You cannot specify whether you want to show the other application). You can still have the `ShellExecuteEx` function for more advanced invocations. The point of this example was to make common use cases simple. Maybe I should have gone with `CreateWindow` instead which takes something around 10 arguments.
When I have a link to the recordings I will add them there.
I'd like to see a good QML tutorial, particularly one that also uses Python.
 [Genshi](http://genshi.edgewall.org/) In my company we have been using genshi.builder for 3 years in 100kloc+ projects and I am really in love with it. However, for the few small django projects we did we just used the builtin template language because we didn't want to figure out how to replace the templating in a django install. Genshi is a great templating engine in itself, but we are not using that very much. Instead we are using genshi.builder which is something of an un-templating enigne. I believe that html templates are trying to do two jobs at once which are fundamentally different: * Separate logic and layout * providing a simple language to make small site changes for non-programmers. The thing is: in our company we don't have any non-programmers. And as for separating code and logic: at some point template logic also becomes a maintainance nightmare. Especially because the tool chain (parsers, syntax highlighting, emacs support) is lacking. Instead we figured: XML is a tree, DOM is a tree, templates should also be a tree. Genshi.builder gives you that: an [Abstract Syntax Tree](http://en.wikipedia.org/wiki/Abstract_syntax_tree) of your XML/HTML with all nodes as first class citizens (regular python objects). We use it like this: def mktable(bird,load): t = tag.table(tag.tr(tag.td(bird), tag.td(load))) return t def page(): p = tag.html(tag.body(tag.p('birds'), mktable('affrican swallow','coconut'))) As you see: * fragments are objects that can be returned from functions, stored in containers and used just like you would any other value * it looks a bit verbose with all the tag.X but you save chars on closing tags. * only one syntax domain! (python). No more mixing of code and html * Isolation is great: just put all the layout in a sepparate module or package * Since you not crossing any syntax domains the risk of malicious code injections (XSS) is greatly reduced. At the lowest level genshi accepts unicode as content for a tag and handles escaping. E.g: tag.p('&lt;script&gt;') -&gt; &lt;p&gt;&amp;ltscript&amp;gt&lt;/p&gt;. It is just like binding variables to sql statements in code that is sql injection safe. * generated xml syntax is always correct Bonus: The ASTs can be manipulated with filters: We are using one that gives all forms a CSRF token, another one that gives all inputs a class that matches their type, a filter that zebrastripes tables and a filter that converts relative paths to absolute paths. 
Genshi: Clean and terse templates, swappable rendering methods, transformable template streams...
You could preprocess Genshi templates with something like SHPAML.
I use something similar for backup - a standalone version of the `githubsync.py` script that is part of [py-github](http://github.com/dustin/py-github): http://gist.github.com/643408 It lives in my Dropbox folder, next to a shell script that runs just `python githubbackup.py myghusername`
the link at the end of the pep gives two enlightening examples. http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/yield_from.html
I think this one is pretty clear: http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/yf_current/Examples/binary_tree.py It basically saves having to loop over a sub-iterator.
Small world, I'm taking a python course at that university(from the link).
Thanks, I read the example and realize that it shortens the code a bit. Is there any other underlying advantage aside from that?
It probably has something to do with coroutines, which is something that hurts my brain. def G(): for x in [1,2,3]: print '--&gt;', repr((yield x)) So far, so good... &gt;&gt;&gt; g=G() &gt;&gt;&gt; print repr(g.next()) --&gt; 1 &gt;&gt;&gt; print repr(g.next()) None --&gt; 2 &gt;&gt;&gt; print repr(g.send('xyz')) 'xyz' --&gt; 3 &gt;&gt;&gt; print repr(g.next()) None Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; StopIteration The way the execution jumps from the arguments to the print statements to what I call in the REPL is what's hurting my brain...
While I'm no Guido, I got a few points. I've been writing Java in Eclipse for a living for +10 years and feel very much at home in Eclipse. For the last year I've been working on a number of appengine Python projects in my spare time and naturally started out using Eclipse/Pydev. Still it only took one try of the Pycharm IDE to make me jump ship - much to the amusement of my Java coworkers in the IDEA camp.
... and slow as hell: http://paste.pocoo.org/show/276778/ (according to tenjin benchmark)
 &gt;&gt;&gt; def G(): ... for x in [1,2,3]: ... print '--&gt;', repr((yield x)) ... &gt;&gt;&gt; &gt;&gt;&gt; g= G() &gt;&gt;&gt; g.next() --&gt; 1 &gt;&gt;&gt; g.next() None --&gt; 2 &gt;&gt;&gt; g.next() None --&gt; 3 Wow that's some complicated and confusing code you wrote there. It works as expected. Your code seems to try to print what is returned by the yield statement (None). I don't see your point at all.
I'll grant you that it's confusing, but I don't see how this code could be any less complex. After the time when I call `g.send('xyz')` instead of `g.next()`, the yield statement returns 'xyz' instead of None. What I'm not entirely sure about, is what happens at which time. And of course, what is it good for? Coroutines and metaclasses are probably the weirdest parts of Python... Edit: to be precise, yield is now an expression, not a statement.
As far as I know Nokia did approach him and they could not agree on a deal. So Nokia stated to fund PySide I see a slow death for PyQt in the near future. 
Omg, I didn't know *yield* can have a value. This sounds like it can go crazy complex! To debug a function I would have to break my brains out back and forth. I apologize - I just never saw the method "send" before. Though I still don't understand the added value of "yield from". Do you mean to say that "yield from" could allow "send" to reach sub generators?
There also used to be WinExec I think which should be there for older Windows versions. But that that point nobody cares about those anymore anyways :)
Yes, I think that's the idea; nobody would even dare to file a PEP that introduces new syntax if all it did was get rid of a for loop in specific cases. Passing through .send and .throw would probably be useful, if you'd know what to use it for. ;-)
&gt; As I leave Microsoft, I'm incredibly excited to be going to work for Google. Title should have somehow hinted at this interesting little fact.
Um, I think we actually agree... I said I agreed with the comment, not the slides.
In case you hadn't checked back here, the author set up a reddit account and posted a torrent: http://www.reddit.com/r/Python/comments/dtxxz/go_on_fellow_aspiring_pythonistas_fire_up/c136zp1
Are you writing apps where templating can be a bottleneck? I'm not. Also: Chameleon. Edit: downvotes? Come on, grow up people. Genshi is about twice as fast as Django's templates itself, and about twenty times as fast with Chameleon. [Linky](http://blog.penzilla.net/2010/02/python-template-language-performance.html). People run Django on heavy-load production sites and manage to scale that. Edit: OK looking at your benchmarks, Genshi is much slower than Django there. I guess the lesson we learn is that benchmarks don't really say much. Anyway, chameleon is supposed to be a real speed boost. Edit: I realize I might have sounded smug, but the original comment was an honest question/statement. Genshi is well fast enough for my [current] needs, and probably so for a lot of uses. If it really is a bottleneck in your application, well, I obviously can't argue that (but again, look at Chameleon).
One liner to convert a ConfigParser instance to a dictionary: &gt;&gt;&gt; {s: {k: parser.get(s, k) for k in parser.options(s)} for s in parser.sections()} {'oingo': {'boingo': '2'}, 'section': {'item': '1'}} Clearly only works in recent Pythons with dictionary comprehensions.
Nice web2py app...
If I want to save some configurations for a simple python app for Android like a list of email/contacts and a message string, which would be better? A .ini style file or a .xml one? .xml seems more versatile, specially if I want to parse long strings. No?
You rock! Sorry for hitting your servers so hard!
uh missing link or so?
I think you accidentally the link. 
In case that is referring to my pycon.pl presentation, here are the slides: http://www.scribd.com/doc/39946630/Python-Idioms I however have to recommend Raymond Hettinger's talks here at europython. I think it was called "Python Tricks" or something. He had some really interesting things you totally should not miss if you are looking for general Python idioms. My talk was only covering a selected set of tricks for newer Python versions I personally found interesting.
You can, but you can't make your own subclasses to interface with QML, because QML only is aware of classes created at compile time. The PyQt4 reference docs mention this problem.
json (included in python since 2.6+), no idea what/how python version support on android is like.
Once you clean up the clutter that is in the toolbars it's very powerful.
They're trying to make Python generators act more like full-fledged co-routines. A generator cannot `return` anything (except `None`). As soon as it "returns", it actually raises `StopIteration`. In contrast, a co-routine is like a regular function, except that it can pause, pass something somewhere, receive something back, and resume; in the end, it can return a value to its caller. A generator is just a single function; a co-routine is the function plus everything that it calls. I love co-routines, but in my opinion Python is the wrong language for them. (Lua has true co-routines, e.g.) Generators serve a very specific purpose: They help us to write iterators. (See [Coroutines and Generators](http://wikipedia.atpedia.com/en/articles/c/o/r/Coroutine.html#Comparison_with_subroutines).) Normally, an iterator needs to save state somewhere. Generators save state in the function-call stack, so you don't have to think about it. Python's `contextlib` decorator uses a generator as a co-routine successfully only because it does not need any return value; the main benefit, again, is in preserving state conveniently.
According to the EuroPython timetable, Raymond Hettinger's talks were called "Idiomatic Python" and "Idiomatic Python: The Final Chapter." It seems that on the EuroPython videos on Blip.tv ([europythonvideos.blip.tv](http://europythonvideos.blip.tv/)) they are called "Python Tips and Tricks," and they are at [EuroPython Videos: "Python Tips and Tricks": Part 1](http://europythonvideos.blip.tv/file/4000758/) and [EuroPython Videos: "Python Tips and Tricks": Part 2](http://europythonvideos.blip.tv/file/4000752/). 
someone upload slides. my eyes are too old for this...
Don't switch. You have it right. We are all a bunch of fools. We are not onto something, no, no. Nothing to see here. Continue as you were.
I'm not a PHP fanboy, I'm looking for legitimate reasons from seasoned Python pros. I hear a lot about how much PHP sucks, but I want to know why Python is better.
python isnt better. php is designed as an html preprocessor. python is a general use language. you shouldnt be designing general apps in php, and python wasnt aimed at making web apps. use the right tool for the job.
Good stuff! The reminder about class decorators made me realize I could significantly improve my little plugin framework.
Python is a general purpose language yes, but happens to suit web programming rather well. And frankly programming in a MVC structure is far better than a programming-templating mashup which PHP was designed for (although not limited to). It really just depends on what you find easier to develop in, personally I find python much easier to develop in.
that is it, a poor man's virtualenv? apache?! apache reloading?! The "perfect" Django setup
It depends what you want to do. I used to work in simple shared-hosting type websites and for that I found PHP was far far better. Then I wrote an app for a [game I run](http://woarl.com). I was most familiar with PHP and so used that for it, simply put I found it soon devolved into a mass of unmaintainable code so I re-wrote it in Python. I found Python was far better at designing a larger application and better for the command-line functions I was trying to add (previously it was 100% browser based). Ultimately I find Python to be a more powerful language but it's far from being a silver bullet that'll make your apps better.
What do you use?
PyCon Ukraine was cool! Thank you for your talk!
Downloading at 1.7mb/s. I only get that high when I'm downloading from What. Very impressed.
http://teng.sourceforge.net/
I've got My PHP experience is limited, but I switched from Perl-based CGI to Python. Here's why I like Python better than either/both. 1) PHP syntax and function names seem arbitrary and inconsistent. I have to look up way fewer things in Python. 2) Python has stronger "bones". To organize my projects, I can use not just functions but classes, too, and so I find that my bigger projects are less fragile. Just my $0.02. 
well, I switched because looking at a page of PHP code made me want to stab my eyeballs out with a rusty spoon, while a reading python code is more like riding a Pegasus through the clouds toward the end of a double rainbow. More concretely, though: * python's more consistent standard library (PHP's is a bloody hydra, seriously) * nicer syntax (I don't like sigils. Also, significant indentation is a godsend) * features like iterators, generators, context managers, comprehensions, none of which PHP had when I was using it (don't know if it got any of them recently)
I do not quite like your approach to be honest, but that's a personal thing and probably anyone that runs a website has his own preference :) What i would like to point out is that the blog post to me seemed a bit messy , unclear and unfriendly for a newbie to read. Since you are explaining way common things for anyone familiar with web development &amp; hosting, only those with way little experience could get something out of it, however you should probably explain more in depth and in detail how to go about it ... *example: 1)Lets install nginx "in detail explanation on how to download &amp; configure nginx" 2)step 2 .... etc* you might want to rewrite the article. Geia sou patrida .. :) 
Here's a great example of why: [What's your preferred style of writing PHP?](http://www.reddit.com/r/PHP/comments/dvo6d/whats_your_preferred_style_of_writing_php/). In Python there is one well thought out answer that everybody uses universally, you can pick up anybody's code and it will usually look a lot like yours, [PEP8](http://www.python.org/dev/peps/pep-0008/).
I also find Python much easier to manage large code bases.
Some (not at all comprehensive) reasons why php sucks: {, }, ;, =&gt;, $ A comprehensive example of why python is awesome: list_of_win = [f(x.blah) for x in something if x.foo &lt; 5]
You should mention what is meant to be installed in the virtualenv and what not (e.g. ipython makes more sense installed site-wide, but on the other hand, it's maybe like the virtualenv's python and should be installed therein?!).
a normal virtualenv with virtualenvwrapper gunicorn + nginx and, even if we use apache, we don't reload it and touch .wsgi file instead
Exactly, let them use PHP with all the outsourcers and fresh out of school cowboys. We will continue making more powerful projects with half the effort and upkeep.
First of all, don't take the advice of anyone that offers it without asking you any questions. Especially since you've not given nearly enough information on why you even think you need to switch. Secondly, why do you think it's all or nothing, why not just think of adding Python to your arsenal. Thirdly, there is ultimately no-one who can answer your question but you, so start by asking yourself this: Which of my projects is a good one to try using Python on? And then go for it.
Hard to give reasons without knowing what you want to do with it, but sticking strictly to non-aesthetic and non language-design facts, Python has [libraries](http://www.sqlalchemy.org/) [PHP](http://numpy.scipy.org/) [can](http://twistedmatrix.com/trac/) [only](http://feedparser.org/) [dream](http://www.pyside.org/) [of](http://code.google.com/p/keyczar/), gives you access to Google App Engine, is faster, and is a general purpose language.
Let me preface this with: thank you for making your podcast available like this, and for having your podcast in the first place. I'm not really in a position to complain, but I'm going to anyways. The torrent protocol already supports and multiple files. *Everyone, please stop putting multiple files into archives.* It has very dubious bandwidth advantages (since entropy for encoded video is already very high). It comes at the cost of making everyone download every file, which not everyone wants to (so you actually waste more bandwidth forcing everyone to download the whole thing!). I want to see what episodes you have, and pick and choose, heck, if you let people download individual files I can prioritize files so that I can preview each episode before downloading the whole thing. EDIT: It also means you require the size of the archive + the size of the desired videos on people's hard drives if they actually want to seed while watching the videos...
Wow, you people are really welcoming. Way to look like assholes!
They're 100 times more welcoming than the ruby douches.
Because you've been thinking the PHP way too long and it's time for a different perspective. Hell, maybe you should switch your focus to Lisp or Haskell for a little while! Even if you end up going back to PHP because that's what pays the bills, some time spent seriously wrapping your head around a new language *will* give you some new ways to approach problems. Ooh, here's one: I don't think I've ever seen PHP in any context outside of web servers, but I see Python examples for both web stuff and for standalone stuff. I've seen full-fledged *games* written largely in Python.
Ela re patrida :) The purpose wasn't so much to explain things in detail as to familiarise people with some things they might be missing. Someone might not be using Varnish, for example, or someone else might not know about South. That's why it's not written in the form of a tutorial, mostly.
You're right about that, but I generally like to use --no-site-packages, which is implied when pip creates the virtualenv, so, as far as the app is concerned, the system doesn't exist. If you don't install ipython, "manage.py shell" just won't find it, with this approach. It does save you a bit of mess in the long run, though.
So your objections to the article is that I didn't use a wrapper (that doesn't even make much difference) and that I used a different server from yours? Apache has a ton of modules to do anything you want, and there's plenty of literature for anything you need. I don't see how that's a bad choice. The reloading command is because the system in question used fcgi (legacy), feel free to change it.
Please don't be scared away. Their answers are annoying because your question is annoying. It gets asked a lot, and answered a lot. Once you decide to ask an actual programming question, everyone here on reddit will happily answer your simple questions, most without being douches. #python is arguably a better place for "how do I do x" type of questions, though.
shhhhh! nobody must know about what. ;)
I need stuff like this to remind me that I really don't know python as well as I think.
I make the argument in the web2py book, chapter 1: http://www.web2py.com/book/default/chapter/01?search=php Of course the argument is against barebone PHP and not against PHP frameworks, for example cakephp. 
TIL
the matter is not why Python is better, it is why PHP sucks: http://tinyurl.com/38twg6r
The perfect Django setup: Mako is a must. /onemansopinion
buildout + chef + git flow == awesome. Also django-sentry is a must at this point for production systems.
Comprehensive. I geddit! Ha ha ha!
I was a PHP developer for nearly 8 years, and I felt pretty comfortable with it. After spending a month with Python, I felt just as capable with Python as I was with PHP. I noticed that just about everything I ported from my PHP work was cleaner, smaller, faster, and easier to maintain in Python. I haven't looked back to PHP since the day I was able to translate a ~365-line PHP script into a ~60 line Python script (that was a lot more reliable thanks to the standard library's datetime utilities). I wrote an article about my reasoning for focusing on Python a while back: http://www.codekoala.com/blog/2008/why-i-python/
Because PHP started to develop its libraries around HTML handling and then forgot about programming principles some where along the way. Just evolved into a mess. Python started as a solid programming language and then has recently started to develop a more solid base for HTML. It is made to be simple first and foremost and when it comes to web development why would you want anything else with all the other crap you have to deal with. Web Development is in itself a maintenance job. You can't go one day without having to tweek something. So why deal with code that just worsens the clutter and confusion. Finally PHP was made for the web. Python was made to do work. But once Python caught up to PHP (now) then it is no question that it will outpace it in the future for scalability. Stick with how the web is developing towards Python and away from PHP. Be the future. Be a Pythoniast. Come join us man and leave the PHP losers behind. It might be scary at first but we will hold you hand if you need. 
You come into a Python subreddit to ask a vague non-question you put no effort into, it borders on being flamebait, it's a topic widely covered and then call everyone assholes for mocking you. Stay with PHP.
For fun, I spent this evening making a class that dictifies variables. It was for fun and was a great exercise. It needs extreme cleaning, testing and documentation to make more sense out the gate but I'll post my second draft solution to a non-problem. Have fun breaking it :) Now... about those zombies! import inspect import tokenize import StringIO class dictify(dict): linenos = {} def __init__(self, *args): cls = self.__class__ f1 = inspect.currentframe(1) self.code_context = inspect.getframeinfo(f1).code_context[0] self.lineno = inspect.getframeinfo(f1).lineno if self.lineno not in cls.linenos: cls_lineno = cls.linenos[self.lineno] = [] code_context = StringIO.StringIO(self.code_context) tokens = tokenize.generate_tokens(code_context.readline) f1_locals = inspect.getargvalues(f1).locals ## Clean up for i, info in enumerate(tokens): tt, ts, _,_,_ = info if tt == 1 and f1_locals.get(ts, 0) is cls: cls_lineno.append([(tt, ts)]) elif cls_lineno: cls_lineno[-1].append((tt, ts)) if len(cls_lineno[-1]) == 2 and cls_lineno[-1][1][1] != '(': cls_lineno[-2].extend(cls_lineno.pop()) ## Clean up end block = cls.linenos[self.lineno].pop(0) for tt, ts in reversed(block): endmark = (51, ')') if endmark in block and block.count(endmark) == 1 and ts == ')': block = [ts for (tt, ts) in block[2:-1] if tt == 1] break block.pop() if len(block) == len(args): for key, val in zip(block, args): self[key] = val else: raise KeyError("Cannot dictify expressions!") x, y, z = 10, 20, 30 a, b, c = 10, 20, 30 d, e, f = 10, 20, 30 g, h, i = 10, 20, 30 e, f = dictify(x,a,d) , dictify(g,y,b) # comment rabbit = dictify menace = dictify g, j = rabbit(e,h,z,menace), menace(rabbit,c,f,i) print e # {'a': 10, 'x': 10, 'd': 10} print f # {'y': 20, 'b': 20, 'g': 10} print g # {'h': 20, 'z': 30, 'e': {'a': 10, 'x': 10, 'd': 10}, 'menace': &lt;class '__main__.dictify'&gt;} print j # {'i': 30, 'c': 30, 'rabbit': &lt;class '__main__.dictify'&gt;, 'f': {'y': 20, 'b': 20, 'g': 10}}
This is maybe the 3rd Scribd doc I've been referred to recently and I have to say, they are just awful to look at. Nothing to do with the content, which I'm sure is terrific (why I followed the link in the first place after all). The Scribd display is horribly slow, the text crawls onto the page barely faster than moss growing on a branch, and when it gets there it is coarse and pixilated. About the 3rd slide I'm sayin "tee ell dee are" and out. Scribd has gone to a whole lot of trouble to reinvent the display of simple text and done it so very badly. Can't see why anyone uses it.
It wasn't a question. It was a request for opinions on why Python is better than PHP. Also, only a couple people, like you, responded in a dickish way. If I came here to "flamebait" where's the flame? I responded to snarky comments by saying that they are not helpful. Thanks to those of you who took this seriously.
Thanks.
pip -E env -r everything\_you\_need.txt
/me is a uWSGI + Nginx nerd.
sounds good to me:)
The reasons you cite certainly do not make Apache sound like a "perfect" choice to me. I'm actually in the process of getting *off* Apache as much as possible, in fact, because there are better options available. Also, anything listing FCGI and "perfect" in the same article is just wrong by definition...
don't use xml.
I agree - I really hate it. They have also started trying to charge to download normal versions of the documents - although for now you can get around it by signing up and uploading any document to get a 'credit'. It's clear there looking to monetise though so everyone one who's uploaded stuff can look forward to others have to pay to download it or eventually watch a long ad before they download it. As you say the interface is terrible, and I can't see that it performs any useful service. In fact I can't think of any occasion where it offers any advantage over a simple hosted pdf file.
It's always nice to see how others do it but you did lose me at bazaar ;)
Could you explain what you mean by "with block can catch down exceptions" on page 46? 
A good example can be found in logbook: http://github.com/mitsuhiko/logbook/blob/master/logbook/base.py#L120 There you can do this: with logger.catch_exceptions(): 1/0 Will not raise an exception but send the traceback directly to the log: &gt;&gt;&gt; from logbook import Logger &gt;&gt;&gt; with Logger('Foo').catch_exceptions(): ... 1/0 ... [2010-10-25 08:17] ERROR: Foo: Uncaught exception occurred Traceback (most recent call last): File "&lt;stdin&gt;", line 2, in &lt;module&gt; ZeroDivisionError: integer division or modulo by zero Even if it does not look that way, that all went directly to the logging system and then to stderr :)
You can download the original PDFs from scribd. On the right side there is a download button. I don't know why some people have troubles with scribd, personally I prefer it over PDFs a whole lot.
Wow sweet! That should make things a lot easier! My pleasure - it's been a fun little project :-)
&gt; You can also just have a second function ShellExecuteEx2 that operates on a separate struct. And what happens after a couple of years? We will have ShellExecuteEx3, 4 ... That really doesn't seem like a viable option.
If you have to change your execution functions that often you must be doing something terribly wrong.
Raymond's talks were fantastic, he's a fantastic personality on stage with loads of infectious enthusiasm. I highly recommend the talks he gave at EuroPython.
Do you have an example that would use this feature of being able to send/throw to subgenerators or coroutines?
They make you pay/sign up to download the PDFs. Last time to avoid paying I had to upload something (just did a blank page with a swear on it about scribd)... but how long will that last? (Also it wasn't clear at first to do that - they are obviously gearing up towards getting people to pay). What advantages does it have over pdf? (genuine question - I'm amazed its become so successful, to me it seems like the worst kind of useless web 2.0 spam junk) 
&gt; Last time to avoid paying I had to upload something Did not know that's the case, will consider providing PDF links additionally for all talks. &gt; What advantages does it have over pdf? It opens right in my browser what PDFs don't do on my browser of choice. Also I don't have to download the whole PDF upfront and can step through the first few pages and then decide if I want to continue reading. Last but not least it does not require the Adobe plugin to display all uploaded presentations, stumbled upon a few that did not render correctly on Apple's PDF Thing and alternative PDF readers on other operating systems.
What this do?
Civ IV surprised me when the loading screen said something like "initializing Python". Later I stumbled upon a quote by Firaxis (Civ IV's developers) on Python's quotes page. Seems like Python is being used for "real games", too.
Psheah. All you'll ever need is in PEAR. Also, 64 KB are enough for everyone.
Ah, so your issue is with the title, I see.
No way, bazaar is great!
It is a tar file, not a zip, gz, bz2. There are zero bandwidth advantages. This may even increase the size of the download by tens of bytes. For pick-and-choose you can use the youtube channel - otherwise you'd have no idea what you are picking and choosing (unless episode 32 means something to you). The videos are also available via showmedo. I am just in a server transition state right now, but normally all the videos are available for direct download.
Saw that! Great service :) 
It Hangulizes!
It transcribes a loanword to the Korean alphabet. For example, "gloria" in Italian is to be "글로리아"(/geul-ro-ri-a/): &gt;&gt;&gt; print `hangulize('gloria', 'it')` 글로리아
To Romanize means to take a language that does not normally use Latin(Roman) alphabet and transcribe it in Latin(Roman) alphabet. For example: &gt; さようなら -&gt; sayonara &gt; (Hiragana) -&gt; (Latin/Roman Alphabet) So to hangulize means to take a language and transcribe it in Hangul alphabet. For example: &gt; przyjaciół - &gt; 프시야치우 &gt; (Polish alphabet) -&gt; (Hangul)
thanks!
He probably attached the link, but then adding text turns it into a `self` post and loses the link.
Claiming that your preferred setup is "perfect" is really asking for criticism, don't you think? Especially when your post is written in a stream-of-consciousness style instead of a more organized style. One size certainly doesn't fit all.
Is there a particular tutorial that these are following along with? Is there a table of contents of some sort? This is fantastic, thank you!
Given that a lot of people seem to disagree on what setup is best, I find the title to be overblown at best, but more likely ignorant and smug. 
The key is the colon: l[-1:] is a list slice, while l[-1] is just the last element. &gt;&gt;&gt; m = [1, 2] &gt;&gt;&gt; m[1:] = [] &gt;&gt;&gt; m [1]
 &gt;&gt;&gt; l = [1, []] &gt;&gt;&gt; l[-1:] [[]] Then it makes sense. (it's called a slice)
Also, I just made these available via Google's Storage for Developers. If you want to grab them all as direct downloads you can just change up the urllib script in this thread. Here is an example link... http://commondatastorage.googleapis.com/osmosis/episode1.mp4
m[1] refers to the element at position 1. l[1:] returns an iterable (in this case a list). If you try l[1:] = 1, you'll notice that it can't be done as 1 is not iterable. so assignment l[1:] = [nnn] means that Python iterates through the list [nnn] and extends/replaces the values it contains starting from the position -1 of the list l, and when it has iterated to the end of the list that's assigned to l (in your case the empty list []), it deletes the rest of the list l. e.g. &gt;&gt;&gt; l = [1,2,3,4,5,6,7,8,9,10] &gt;&gt;&gt; l[-5:] = [1,2] &gt;&gt;&gt; l [1, 2, 3, 4, 5, 1, 2] 
 &gt;&gt;&gt; l=[1,2] &gt;&gt;&gt; l[-1]=[] &gt;&gt;&gt; l [1, []] 
"The reloading command is because the system in question used fcgi (legacy), feel free to change it." cool. even only this means that your setup is not perfect. really
Thanks!
Ok, got python.sourcequench.org roughly working. Now you can go to that page and grab individual podcasts.
TL;DR: Recursion kills you for generators unless you have this language feature. The problem is that generators which yield values from generators incur a hit (think: extra yield statements at least), especially when they become deeply nested. Imagine you want to write a generator which yields values from a binary tree. If we were writing ordinary functions to return a list, you would just do recursive calls where each could simply append to a result list (a cheap operation). Generators are cool though since they don't even need to build the list, you can just return one element to be processed at a time. This is great if you don't need the list and you have a lot of elements - it means you don't have to allocate lots of memory for the list. However, if you're inside a recursive generator (imagine being three layers or more deep into a binary tree), then in order to yield a value, the two generator calls above you must looping over the elements yielded from here. So instead of one small piece of work ('add a value to a list'), the deeper you get, the more loops must occur to get the value from you (inside a deeply nested generator call) back to the original call site. This is a very bad property and makes deeply nested generator calls impractical in python at the moment. If instead there was a way to defer the looping, then this could be cheaper (of order 'append a value to a list'), but it needs a language enhancement to be efficient. Instead of writing this to recurse over a generator: for elem in recursive_call(args): yield elem One could write: yield from recursive_call(args) This would have the effect of entirely removing the for loop, which would become somewhat significant once you're greater than a few levels deep. (Think of all the yield statements which would never have to be run by the interpreter, since the deepest call would yield directly to the original caller. This is a big improvement on each layer deeper you go adding another level of indirection..)
Also see that: &gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &gt;&gt;&gt; a[3:7] = [200,] &gt;&gt;&gt; a [0, 1, 2, 200, 7, 8, 9]
Yeah, it's not, which is why I wrote this article. What the hell?
http://code.google.com/p/simplejson/ "simplejson is the externally maintained development version of the json library included with Python 2.6 and Python 3.0, but maintains backwards compatibility with Python 2.5."
I don't understand the cgi.parse_qs critique: "Depending on the (user controlled input) you get different types back." &gt;&gt;&gt; cgi.parse_qs('a&amp;b=b&amp;c=c1&amp;c=c2&amp;=d', True) {'a': [''], '': ['d'], 'c': ['c1', 'c2'], 'b': ['b']} Is there any case where you get a value which is /not/ a list of strings? Or a key which is not a string? Or a return value which is not a dict? Please explain.
pdb is great. I use it all the time when debugging Django applications. Just insert the pdb.set_trace() at the point you wish to debug, run the django server (manage.py runserver), and when your code gets to that point in its execution, the terminal running that process will drop into debug mode. Very handy. 
So this is a performance optimization? I didn't know for-loops were so heavy with generators.
Between pdb, django-sentry, and django-extensions for werkzeug integration I rarely have a problem in django I can't find and fix quickly.
It's not necessarily often, and not necessarily due to doing something wrong. Technical advancing will need to be covered by the API as long as Microsoft wants to sell newer versions of windows.
When you add text to a link, it automatically becomes a self post. Meaning we didn't get the link. Recommended course of action is to add the link to the description if you need to editorialize. In your case, the description is editable, so that's what I would suggest.
for the love of god, don't use lower-case L .. especially when 1 and l are important components of your example!
They key is that the first does slice assignment, accepting a list (in this case, an empty one), and the second does item assignment, accepting any object.
They aren't "so heavy" _per se_. The problem is the "deeply-nested" part. Imagine you have a tree 8-levels deep. That means that for every yield at the lowest level of the tree, you must do ~8 yields. Instead of one. You just made your algorithm 8 times more expensive (or more) by moving to generators.
So while we're at slicing lists take a look at these: &gt;&gt;&gt; r = range(10) &gt;&gt;&gt; r [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &gt;&gt;&gt; r[::2] [0, 2, 4, 6, 8] &gt;&gt;&gt; r[1::2] [1, 3, 5, 7, 9] &gt;&gt;&gt; r[-1::-1] [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] &gt;&gt;&gt; r[-1:0:-1] [9, 8, 7, 6, 5, 4, 3, 2, 1] Have fun.
Not his fault you're using a shitty font.
Slices create new lists. my_list = [1,2,3] my_list[-1:] = [] The second line will create a new list and replace it with and empty list. my_list = [1,2,3] my_list[1] = [5,6,7] Indexing will replace the value at the index with whatever.
Still doesn't make it a good idea.
Never said it was. But really, if you're looking at any sort of code in a browser and you're using Courier New, it's your own fault.
what font do you use? i never really thought about that and left it as the default.. also your username - dune!
Just using a .py file (you can read .py files by `execfile` built-in function) can be an alternative way to configure. It is useful when highly programmable configuration is needed. Of course, .ini format is easy and acceptable in most cases. Plus, though it can seem Rubyish or Perlish, there is YAML also.
nosetests --pdb ... that is basically the reason I wrote nose.
Just for the record, in the third example, you don't need to state where the slice starts; i.e. r[-1::-1] == r[::-1]
I can distinguish the two characters using my current font. That's not the issue. The issue is that a) it's just bad style - see PEP 8 and b) readability counts .. if it takes me a half second longer for my brain to parse the code, it is detracting from the readability. Brain cycles should be used understanding the logic, not keeping track of poorly named variables.
Oh, I'm not familiar with django-sentry ... what does that do for you? (Yes, I could Google it - and I probably will - just looking for some personal thought, conversation, on the matter)
&gt; l[-1:] = [] This means "exchange this range (which contains 2) with this other range (which contains nothing)" &gt; m[1] = [] This means "exchange this item (2) with this other item (an empty list)"
What about it do you like in particular? Could you comment on any parts you prefer to Hg/Git/Other? 
Ah, thanks, I thought maybe you'd discovered something crazy with generator.throw() or something.
It logs all exceptions and stores stack trace, variable values, etc and provides the information in a very nice interface to quickly check out what errors your users have ran into and easily figure out how to fix them. Its basically a pretty interface on top of your logs but its really nice.
One more thing: &gt;&gt;&gt; m = [1, 2] &gt;&gt;&gt; m[-1] = [] &gt;&gt;&gt; m [1, []] 
Consolas. But any mono-space font other than Courier New will do nicely.
Agreed on all counts, but that doesn't detract from my statement. This was a simple example with only one variable. It shouldn't take any extra brain cycles to process a single variable.
Yeah I got burned too :(
Fully aware of that, wanted some symmetry between my last two.
Jinja2 lacks a good way to be extended and add custom functionality. I'm talking about django's templates tags and filters wich are trivial to make. No other template language gives you that kind of facilities. My rule of thumbs: If you use django, use django templates. If you don't, just hate the fact that you are not using it.
Rephrasing: This isn't a helpful answer. What if the OP already knows about slices? Answering "it's a slice" doesn't explain why being a slice is relevant. The OP's question isn't "what's that colon syntax?" It's "why does assigning to a slice like this have the shown behavior?". The correct and informative answer was [given by **neug**](http://www.reddit.com/r/Python/comments/dw2jy/question_about_python_lists/c13csfm). Original post: &gt;Ugh, why does this have so many upvotes? His question isn't "what's that colon syntax?" It's "why does assigning to a slice like this have the shown behavior?". The correct and informative answer was given by **neug**. &gt;EDIT: Downvotes, huh? I stand by what I said. [Read my elaboration here](http://www.reddit.com/r/Python/comments/dw2jy/question_about_python_lists/c13e6av).
Uhm, Java is HUGE in Enterprise domains...
Nice! Thank you! I will test it soon!
Twisted's inlineCallbacks are my favorite non-trivial use of generators as coroutines. It handles callback creation by allowing the user to yield a Deferred. The value from the callback is then sent into the coroutine via generator.send(value). It can save a ton of callback writing.
Point taken. That does make sense. :)
That's what she said.
&gt; Ugh, why does this have so many upvotes? Because it is a correct and concise answer. &gt; His question isn't "what's that colon syntax?" Clearly. The OP typed "m[1] = []" and asked why that's not the same as "l[-1:] = []". micha2305 pointed out that it's a slice. QED. Should he also have included a link? Here's one that explains it (5th sentence in the section): http://docs.python.org/tutorial/introduction.html#lists
Compared to git, I like how much simpler the interface is. The three systems are similar enough (and interoperable enough) that in the end it will just be a matter of preference, but I found bzr solid and dependable, while still having all the features I need. Compared to hg, I think they're pretty much the same thing. I haven't used hg enough beyond the basics, but I have used it enough to know that bzr isn't a dealbreaker by any stretch. At most, it warrants a "that's not what I use, but still a good tool"-type reaction.
You don't need a trailing comma in a one-element list literal, only in one-element tuple literals.
I should rephrase, "Java is used more in academia than Python". In the UK at least.
Thank you. I really don't understand why this isn't this most upvoted comment.
&gt; Assignment to slices is also possible, and this can even change the size of the list or clear it entirely. This is helpful.
http://infoworld.com/print/141620 is better. spoiler: Python, Ruby, Matlab, JavaScript, R, Erlang, Cobol, CUDA Extensions.
for/else and while/else (example from [python documentation](http://docs.python.org/tutorial/controlflow.html)) : for n in range(2, 10): for x in range(2, n): if n % x == 0: print n, 'equals', x, '*', n/x break else: # loop fell through without finding a factor print n, 'is a prime number'
This seems like a seriously uninformed article, weirdly so. Red flags so far: 1. The general surprise at Python being used by anyone and being the first language on google app engine, as if Python came from nowhere all of a sudden. And then this: "Python has the kind of structure that makes it easy to scale in the cloud, one of the biggest challenges for enterprise-grade computing" 2. Confusing Rails and Ruby, my favorite quote: "The secret to Ruby's success is its use of "convention over configuration," wherein naming a variable foo causes the corresponding column in the database to automatically be named foo as well." 4. On Javascript: "If anything, it may be the most compiled language on Earth, if only because every browser downloads the code and recompiles it every time someone loads a Web page". The use of compiled here seems weird to me, but maybe that's just explaining things to Java people. 5. R being on the list at all. I love R but isn't the only opinion about R that's "on the rise" that it's not up to the task of dealing with new large datasets and it's starting to show it's age? I don't know enough to really evaluate the premise of this opinion but it's out there. 6. Defining functional programming as "no side effects" ... I know it's a common misconception but just read *one* wikipedia page while writing your article 7. COBOL making the list. You can make an interesting and valid point about the amount of COBOL code out there and it's importance even after all this time but calling it a "language on the rise" is ridiculous. The research that went into this article was pathetic, and I can't believe that they couldn't have found someone a bit more in touch and with a broader field of experience to write an interesting article on this subject.
2005 texted. They want their blog post back.
The only thing rising about COBOL is fumes from its deteriorating corpse. I'm more a Perl and PHP guy (yeah yeah I know, but I write good, modern PHP) and a Python neophyte (again and again, it seems), but to say Python is on the rise seems to me to be ignoring its already ubiquitous nature.
that's just stupid I've read all python docs (but not all stdlib docs) and a lot of PEPs (the interesting ones) and I recommend you to read them too before screaming about sudden discoveries of features. yeah, docs are cool. posts such as yours aren't
&gt;Clearly. The OP typed "m[1] = []" and asked why that's not the same as "l[-1:] = []". micha2305 pointed out that it's a slice. QED. "It's a slice" is not a complete or helpful answer. It doesn't explain why being a slice matters. I knew it was a slice but didn't fully understand the behavior. Here's the main confusion: for the examples given, m[1] and l[-1:] *represent the same sections of the list*. Let me rephrase what I believe to be the OPs question: "Give that I'm assigning a value to the same sections of the list, why does one result in the sub-list being assigned (as I expect) and the other result in the sub-list being removed?". neug's answer concisely addresses this AND the slice point. It's a better answer in every dimension and actually helps the reader understand what's going on. I still believe micha2305's answer is lacking, which is why I called it out and pointed to neug's. 
Thank you for calling that out. EDIT: Removed some whining.
No wonder the author didn't get the message, he hasn't even heard of texting yet! Send him an electronic mail.
There are also set and dictionary comprehensions, misuse of which can lead to comprehension apprehension.
Cool!
Just have fun doing what you doing. Defy the impossible and learn as you go. If every programmer that ever existed had to get the program right the first time or die, programming wouldn't even exist as a thought today. Your code is always garbage, it's always wrong, it can always be done better, smarter and quicker. Your code is amatuered, flawed and pathetic out the gate. It just plain sucks and is always WTF. And this always applies to the other guy. Heh. Good luck!
Excellent, thanks for sharing
But Jinja2 gives you Python expressions, at which point you don't need to do special template tags.
You're asking the wrong person. I don't think that magically propagated send/throw is all that important unless the generator can return a value when it's done. From the PEP: &gt; Furthermore, when the iterator is another generator, the subgenerator is allowed to execute a return statement with a value, and that value becomes the value of the yield from expression. To me, that's the big change.
What do you get when you append a list to itself? &gt;&gt;&gt; l = [] &gt;&gt;&gt; l.append(l) &gt;&gt;&gt; l [[...]] 
ipdb is even better - integration with the IPython shell. pip install ipdb import ipdb; ipdb.set_trace()
Still some work to do... But thanks for the little puzzle. From : &gt;&gt;&gt; pprint.pprint(l) [&lt;Recursion on list with id=31182080&gt;] and &gt;&gt;&gt; l[0] [[...]] I'm guessing that [...] is a reference to the list itself. 
you got downboats!! Is reddit broken again or sth?
&gt; Here's the main confusion: for the examples given, m[1] and l[-1:] represent the same sections of the list. While it's true that the fact that those two expressions as rvalues evaluate to the same value adds a layer of confusion, it doesn't change the fact that using a colon makes it a slice, and therefore it has slice semantics, whatever those may be. It seems to me that if you know about a language construct but are not sure why it's doing what you'd expect, then reading the fine manual is a good place to start. The link I posted is from the python.org tutorial's section on lists. The fact that slice assignment is the *fifth* sentence in that section, and not a deeply buried footnote, is relevant. I assumed, as did micha2305, that the reason this behavior was surprising to the OP was because he was not aware of the fact that this is a slice. If he was, then surely he would have done a little research into slices. Even a cursory googling would reveal the link I posted. Of course, there are no stupid questions, and I am glad that neug took the time to re-post the information that's in the language tutorial.
Ohhh I'm very much looking forward to trying this... I expect epicness.
Also, this description of Python: The former helped create the language by building a version of Perl... Python is a version of Perl?
You weren't downvoted for pointing at neug's more complete answer. You were downvoted for your incivility in attacking micha2305's response, which was perfectly accurate (though possibly not sufficient for a Python beginner). Maybe next time you can just say, "If you still don't understand what's happening here, [neug's answer](http://www.reddit.com/r/Python/comments/dw2jy/question_about_python_lists/c13csfm) gives more detail". Then everyone will be happy.
Whoa. I had no idea you could do that. Upvote!
it's an easier to read version, maybe not worth an upvote but still useful
I believe they are called generator expressions. Also, get used to it. Python is multi paradigm hot sex of a language.
So true :)
Not many seem to have heard of it which I always bang on about it! Enjoy.
What's funny is it'll probably address the few issues I'm currently having with PDB. I fired it up (ipdb) on an old project to test it out. I'll explore it more tomorrow on current projects I'm working on. Thanks for letting me (and others here) know about it!
I understand your perspective and genuinely appreciate your civility. &gt;It seems to me that if you know about a language construct but are not sure why it's doing what you'd expect, then reading the fine manual is a good place to start That is **a** good place to start, but it's a bad place to assume others started. People often give quicker, more-comprehensive answers/examples than documentation. That said, pointing somebody to documentation is sometimes an appropriate answer (as you, but not micha2305, did). &gt;Even a cursory googling would reveal the link I posted. You found the link because you already knew what you were looking for. It's quite possible the OP didn't know what to search for (or gave up in frustration). Google is good for bringing up pages related to keyword data. It's not good at answering questions like "why are these two things different", which was how he thought to phrase the question. Maybe he didn't think about the problem like you do or know how to rephrase it. When trying to give helpful answers, it's often counter-productive to assume the inquirer thinks and acts like you do. EDIT: Formatting
Ok, thanks. I'll rephrase it. EDIT: micha2305's response was accurate but not helpful. Imagine if you went into a thread titled "Why is 1+1=2 but 1-1=0?" and the top-voted answer was "addition and subtraction are different". In my opinion, it's helpful like that, which is why I reacted strongly.
I wouldn't normally ask such a question. The reason I did is because I was extremely surprised. I did read the tutorial and I didn't remember it mentioning what happens when a slice is on the left side of an assignment. I guess that I may be learning too fast... I'm probably overconfident because Python is a well thought out language and the docs are great... I would have been very happy with : "It's a slice, you're an idiot. Go read the tutorial. " 
It works great when passing functions to generators because you don't need extra brackets: all(x%2==0 for x in a) 
These slides by David Beazley changed the way I code: [Generator Tricks for Systems Programmers](http://www.dabeaz.com/generators-uk/)
I added support for FilteredMultipleSelect into tekextensions: http://github.com/sontek/django-tekextensions
I consider this to be a python "wart" :\ all kinds of languages have "for" and "else" language keywords, but python is the only one that I know of that gives them these semantics.
Ah, OK, they follow right along with the Python tutorial, perfect... http://docs.python.org/tutorial/ 
It all depends on whether you use proper, descriptive variable-names. Then you can pick up a COBOL program that you haven't seen for 20 years and still understand it clearly. Mind you, the important part is the use of very descriptive variable-names ( instead of stuff like 'int31', 'inv-num-inc', etc) but this really applies everywhere, no matter what language you are using. Side-note: At one time, I was bouncing back and forth between C and COBOL. The difference in word-joiner characters ( '-' and '_' ) used to drive me nuts.
Yeah, I actually use ipython/ipdb and not just pdb but I wanted to cover pdb before I started covering all the power of ipython. 
I know it was very influenced by Perl so I let that go as one of the "less wrong" things in the article, but I agree, it's still not something that should be in an article by a technical author.
Really? I don't see it, I always thought Python was a C derivative which had syntax and behaviour which matched Van Rossum's personal idea of the 'ideal' programming language. It seems Wikipedia has nothing to say about Perl, and Python is apparently [a spiritual successor to the ABC programming language](http://en.wikipedia.org/wiki/Python_(programming_language). I always though Ruby was the Perl derivative. Edit: screw you, reddit formatting... Sorry but I can't figure out the link.
If you haven't been to PyCon before, go this year! If you're going but haven't written a talk before, do it this year! If you wrote a talk but haven't submitted it, submit it!
Because a set can check membership ("i in master") in O(1), whereas lists do linear search at O(n). 
&gt; Imagine if you went into a thread titled "Why is 1+1=2 but 1-1=0?" and the top-voted answer was "addition and subtraction are different". Well, I think that response is quite helpful. It's accurate and it ensures that the person who asked has the vocabulary they need to do further research, maybe Google "addition" and "subtraction". It's not the best answer, but it's a good answer. 
If other languages combined `for` and `else` in a different way so that this was confusing, I could see your point. But this just gives you another tool that happens to address some fairly common situations, so I'm all for it. Languages wouldn't ever get anywhere if they were limited to doing what previous languages did.
And when passing generators to functions, like in your example! :)
What is going on internally that allows this?
a set is kinda like a dictionary with no values. the things put it in to it are hashed, so you can very quickly find if a particular value is in it. checking if foo is in a list requires scanning the entire list.
d'oh
Python uses an unsorted hash table to implement set. This means to find if something is in the set, it just has to run a hash function and look at one element. It can do this because sets don't guarantee order and they don't contain duplicates. Wikipedia has a good [introduction to hash tables](http://en.wikipedia.org/wiki/Hash_table).
Relatedly, sets are one of those things that once you discover them, you can't stop using them (at least for me).
Which is also why a set cannot have duplicate entries, in case someone reading this doesn't know.
Now it is… :)
Thank you. I think I need to start using lower level languages more often to learn about all the data structures I just take for granted.
What everyone else said is absolutely right but just to give a concrete example - the following will have similar performance to using a set: master = dict((p,None) for p in primes)
For kicks, just try l=range(10) for ll in l: print ll,
I loves the for/else loop. Also the try/except/else.
You might also just want to start reading up on data structures, algorithms, and complexity analysis.
Feeling palindromic, aren’t we? :)
A set works at on the theoretical side by having an list of say 1000 lists When you store an item it hashes it (converts it to a arbitrary int) then stores it in list[hash % 1000] To test if an item is in the set (membership) you only need to test the items in that sub-list (1000) as many. Python automatically re-sizes the underlying list of lists and restores all items in the new indexes. In other programming languages you can choose the size of the set. so it takes a constant amount of time to Add, Remove, Test membership on a set. Corrected for comment by cname and brain.
I agree with icedpulleys that what's really needed to understand this better is to read about the concepts. Here are some starting points: Everything up to the table of contents here: http://en.wikipedia.org/wiki/Big_O_notation And this table of common time complexities: http://en.wikipedia.org/wiki/Time_complexity#Table_of_common_time_complexities Note that the first one in that table, and the best performing (at least when your problem set grows large), is O(1). And hash tables (which is what a set is) allow lookup of a key in O(1) time (also known as *constant* time), which sort of corroborates your experience here, where they out-performed lists. The [hash table](http://en.wikipedia.org/wiki/Hash_table) uses a neat trick (hashing) to calculate where to find a given value in the hash table in roughly the same amount of time no matter how big the hash table gets. On the other hand, a list does not use hashing in any way, so to find a certain value in it, it must scan through and check each item in the list in a comparatively dumb manner. The complexity is O(n) where n is the size of the list -- also known as *linear* time. In other words, if a 5 million item list takes 5 seconds to search, then a 10 million item list will probably take around 10 seconds. The run time scales linearly with respect to the input size. When dealing with large lists and lots of lookup operations, this can really slow things down. But linear time isn't exactly the worst either. Some algorithms run in exponential time and factorial time which are some of the worst; these get so slow as your input size increases that you generally have to find heuristic alternate solutions that find "good enough" solutions to a problem, instead of the absolute most correct solution. A simple example is the [bin packing problem](http://en.wikipedia.org/wiki/Bin_packing_problem). Say you're UPS and want to pack boxes into your trucks in the most space-efficient manner. Well, it turns out that there are so many possible arrangements of boxes (and the number of possible arrangements grows rapidly with each added box) that you might not be able to calculate it at all. You might need to use a better performing algorithm that will just find an approximately good packing arrangement and settle for that.
It's the other way around - it's a set *because* it cannot contain duplicate entries. :)
You don't need to use low level languages to learn about such things, the python sets module is available [here](http://svn.python.org/projects/python/trunk/Lib/sets.py)
&gt; checking if foo is in a list requires scanning the entire list. ...in the worst case (such as whenever foo is *not* in the list). (pedant) :)
If I remember right it was an ideal "teaching" language, although maybe that was ABC? Maybe that's what python carried forward from ABC. I might be wrong about the influence of Perl, maybe I assumed it because Perl was the king of dynamic scripting languages at the time (although I just looked that up and Perl was developed in '87 and Python in '89 so that might be wrong as well). Yeah, I definitely didn't mean it was a derivative like Ruby (which is openly based on Perl), more that it was a reaction in a "that's a good niche to fill but Perl is doing it the wrong way". Seems that when I look at the dates that might be a misconception. Interesting.
You don't need lower-level languages to learn about data structures at all. Quite the opposite in fact, I would say, low-level languages are going to bog you down with implementation details and cache effects.
Quick tip: Any time you are tempted to write range(len(... consider using enumerate() instead.
From everything I've read, everything about Python is the antithesis of Perl, and I can't find any reference to any Perl influence in the Python language. Anyway, as you already pointed out thats one of the less wrong things about the article. I can't believe the author was able to write so much with so little research.
I feel ashamed for not knowing this
pdb has several annoying bugs I fixed in a fork I made: https://code.launchpad.net/xpdb
I'm honestly not trying to be a jerk, but: Really? If you asked a question like that you'd be happy with "because they're different"? I feel like you're arguing a technicality with me so you can feel right. Let's break this down: &gt;It's accurate Yes, it's accurate. But you can also answer any "why" question with a literal "because that's the way it is". That is also accurate. I don't consider that to be a good answer at all. &gt;it ensures that the person who asked has the vocabulary they need to do further research Your stance assumes that they haven't done any research and don't already know the vocabulary. This particular thread is actually a really good example because I was already familiar with list slices in Python and still didn't understand the behavior. In my quest to understand, I even Googled and re-read some slice documentation before posting in the thread. I didn't come across an explanation of assigning to a slice, even though I knew all the terms. &gt;It's not the best answer, but it's a good answer. The one piece of information I was missing was that assigning to a slice requires the RHS to be iterable (which was covered in neug's post). And I didn't learn that from the response everybody was upvoting. I really don't think it was a good answer. It was only good if you already knew it. The last sentence here is the crux of my point. Upvoting incomplete answers to questions you already understand is not helpful. If anything, I found it more confusing. When evaluating the goodness of an answer, it is important to consider the viewpoint of somebody who doesn't know everything you do.
Yes, they are called generator expressions and they create *iterables* not generators http://www.markus-gattol.name/ws/python.html#generator_expression
hmm... &gt;&gt;&gt; def gen(): ... yield 1 ... yield 2 ... return 3 ... File "&lt;stdin&gt;", line 4 SyntaxError: 'return' with argument inside generator So this would become legal syntax? edit - btw, you could yield a value and then return without an argument. So I don't get it still..
using metaclass I created an extented struct allow the following: class Spam(Model): foo = UIntProperty() spam = ArrayProperty(StringProperty()) print (Spam( foo=0xaabbccdd, spam=['foo', 'haha']).tostring()).encode('hex') # ddccbbaa0200000003000000666f6f0400000068616861 
But python as a whole gives a feeling that a lot of thought, design and care was taken when making its syntax. This "for-else" idiom is the most misleading one I know in python. For example many people don't realize it's not useful when you don't have a "break" in the for loop. A lot of bickering concerning for..else: http://mail.python.org/pipermail/python-ideas/2009-October/thread.html
Actually python is not that bad to learn about good algorithms and data structures, because you don't have to worry about low-level details. Of course if at one point you need to start *implementing* those efficiently, you will of course need to move to a low-level language.
And even if you like reaching for the metal, use `zip(itertools.count(), …)` or `itertools.izip(itertools.count(), …)`
Struct is the most basic thing you can get. Nobody stops you from creating or using a binary parser or descriptor on top of it. 
Why not just use Hachoir?
That is a very succinct description, so if you don't mind a more or less unrelated question: what is the purpose of tuples as opposed to lists? Is it merely that they are immutable or are they also somehow cheaper in terms of resources?
Would you mind if I used this to show students, to demonstrate the benefits of a hash table?
You can have a multiset that has a hashed backing (just use the count as a satellite data) and still have O(1) expected runtimes on most set-like operations.
&gt; I would say, low-level languages are going to bog you down with implementation details and cache effects. But that's where the fun is :).
To be fair, it *is* random in the sense of being arbitrary. Further, the same properties you look for in a (uniform) random number generator are the ones you look for in a hash function: you want there to be an equal probability that an arbitrary input will be put in each possible bucket.
That actually was a mistake on my side I just found it. I remembered that interface returning either lists or strings, but I suppose I mixed that up. Will try to find the function I had in mind when I wrote that.
~~http://goo.gl/K7Tn~~ link in reply (set at wikipedia)
Also known as a *bag*.
So can dicts, no?
Thanks for mentioning it, I don't know that. Maybe because writing one is easier than finding one and learning how to use it. BTW, I don't like the syntax: class Header(FieldSet): def createFields(self): yield UInt32(self, "width") yield UInt32(self, "height") yield UInt32(self, "flags") yield UInt32(self, "extra_header")
&gt; This means to find if something is in the set, it just has to run a hash &gt; function and look at one element. Uhm, no. Because of hash table collisions it may have to look at more elements. Edit: Okay, so tell me this: if the hash table has 10 cells and contains two keys, what are the chances that the two keys will collide? The same as the odds of hash(key1) % 10 == hash(key2) % 10. Ie: 10%. Look at some actual hashtable implementations. The one in the Sun JDK (java.util.HashMap) uses linked lists in each hashtable cell to deal with collisions. I personally wrote a hash set implementation that's faster than java.util.HashSet because it uses closed hashing instead.
Well Hachoir was made to be suitable for parsing binary streams, not just flat structures, so you might not have the whole stream yet by the time you start parsing it, hence the parsing has to be streaming as well.
The only difference is field-definition-syntax. The underlaying stream handling could be the same. 
I didn't know any of these things - haven't gotten around to sets yet - so thanks all of you!
&gt; you'd be happy with "because they're different"? Of course not, but that's not what ffrinch said, neither you did, originally: &gt; "addition and subtraction are different" The key being that the answer mentions the specific topics/concepts that the original answer failed to address, as in: "Mmm, you ask why 1+1=2 *but* 1-1=0... clearly you miss addition and subtraction concepts, so I'll mention them to you". I understand your lack of appreciation for "because that's how it is" kind of answers, but really, micha2305's one was not one of those (at least for plenty of us). &gt; it is important to consider the viewpoint of somebody who doesn't know everything you do I'm affraid to say: that task might prove to be impossible: how does one knows what is that the other does not knows?
A more realistic example is someone asking why "a = b" isn't the same as "a == b"; I would certainly be satisfied with the answer that one is assignment and one is comparison. &gt; Your stance assumes that they haven't done any research and don't already know the vocabulary. There was no evidence in the question that they had done any research. If they had said that they understood the obvious answer and wanted more explanation, they would've gotten it.
It's O( log_2 n ), no?
This is a great question and exposes a really important part of writing programs: understanding behavior of basic data structures. It might seem like a dry subject, but once you understand things like arrays, linked lists, hash tables, and trees, you will be on your way to doing _way_ more interesting stuff with a computer.
If you had given the actual link, you wouldn't have needed the parenthetical, you wouldn't have to look up the goog link, and it would have been only marginally longer, and you wouldn't be giving Our Googly Overlords even more information about our browsing habits: The actual link is: http://en.wikipedia.org/wiki/Set_\(mathematics\)
Nevermind, I am quite wrong. It's usually O(n), with the highly improbable worst-case of O(n).
&gt; the obvious answer This should end the discussion. Giving the obvious answer : "it's the colon" was not helpful.
How did you submit that? I tried it as simple paste and also with reddit formatting. Both ruinded the link. I even tried to find url escape characters, but didn't find any for parentheses. That's why I used the url shortener.
Backslash escapes parentheses.
You have to escape the ( using \\( before each one.
And now I wonder how I didn't thought of that :) Thanks (to both of you who replied).
Depends if you're a programmer or a mathematician first ;-)
Possibly the ugliest name for a data structure, after heap.
C is a good language to learn how to implement data structures (but awful for actually making data structures easy to re-use - hence the proliferation of dynamic scripting languages written in C). A basic hash table in C is not that hard to write if you know what you're doing - just think of it as an array which you index by a hash instead of an index. There's chaining or other collision strategies to think about... and resizing can be a pain too. Python's hash table is incredibly well tuned and the code is well documented. It has to be - every field access and method call does a dictionary look-up! Another alternative implementation of sets is balanced trees, like red-black trees, AVL trees, etc. and a much simpler (but specialized) way is just an array of bits, if you have a small finite set of known possible members.
While we're tossing out links: http://mathworld.wolfram.com/topics/ComputerScience.html
As others have pointed out, you backslash the parentheses, but you can also URL-escape any character by using the two-digit hex code for that character. So if the hex code for 'S' is 0x53, you can get to wikipedia at the url http://wikipedia.org/wiki/%53et_\(mathematics\) Also, the hex codes for ( and ) are 0x28 and 0x29 respectively.
I worked through this presentation last night with some code I have been hacking on. The presentation is really good and I definitely learned a lot.
When you start to criticise another project in your blog or in your documentation, you need to be careful about making sure that your knowledge is up-to-date. Plus, your FAQ and blog sounds like you ideas were not welcome in the distutils2 effort, which is completely false. So it's not a problem of a disagreement whatsoever, but rather the fact that you partially justify your work because you decided that our current work/effort sucks. You even answered to the email where I proposed to enhance the configure command, and other attempts we made to work with you, I am sorry if you can't recall that. You even said clearly in your FAQ (you edited since then because I cannot find that anymore) that all attempts to improve distutils sucked and that your ideas were rejected. So I don't give you any malicious attempts, I just think that you just want to work on your tool on your side, which is absolutely fine. But stop saying that we did not want your help, please. This is just really annoying. The FAQ is much cleaner now, congrats on the editing and good luck on your project. 
Sets in Python are internally represented via dicts. 
I tried to google these % characters, but found only set which didn't contain ( or ). Didn't know it was just ascii code. Thanks.
Whoops, sorry for the late reply. The system I'm referring to is a Django back end paired with a Javascript client (run in web browsers, of course). Granted, it's not the highest traffic system in the world, but it's regularly serving 5,000+ rows of json data to dynamic tables to around 30 users without a hiccup. By regularly, I mean 10-20 times per minute. Now, that's nothing compared to certain sites, but it's a lot more data than most people shove around in their programs. Bear in mind, the main reason the company hired me to write this is that other reporting tools were too slow. They also wanted reports that remain updated in real-time. Meaning, if someone changes the source data (an invoice or whatever) in the system, they want the dynamic reports to update immediately without needing any form of reload. So we have a serious need for speed. My reports have to feel as responsive as native apps like excel. For the back end, we have a MySQL database being managed by the Django ORM. Django is a web framework written in pure python that provides an ORM, a template language, and a few other tools. (I don't even use the template language any more, as almost all of my data gets encoded to json and passed async to the javascript client.) So we have what amounts to a very "naive" stack. Python on MySQL, shoving data to the browsers. What were the major optimizations I've had to make to get my native-like speeds? - Client-side, I've had to optimize my javascript's DOM interaction. However, just loading and parsing the data works great even in its simplest implementation. I've learned that most slowdown in Javascript comes from interacting with the DOM in a suboptimal manner. - Server-side, I haven't had to resort to C modules *at all*. All python-level optimizations have come from writing more efficient *python*. - Database-side, I've had to implement some automated table denormalizing, effectively creating 2 layers of caching on top of the source data. The real kicker: the database table denormalizing was hands-down our biggest performance gain. To manage that denormalizing, I run a background daemon on the server written in pure python. This daemon ensures the proper structure of the denormalized tables, populates it, and updates the data as the sources change. All in real time, all in python. So using our example, I haven't had to leave python a single time to keep this system running fast. The people using it complain about the startup time of Adobe Acrobat, but never complain about the speed of my real-time reports. Trust me, in most cases, python will not be your bottle neck. ;)
No not at all. That is awesome.
``global``, non-PEP8-conformant, old-style-classes. Wouldn't recommend anyone to use this as example for enything but "how to do it wrong". The call to ``model()`` is probably the worst of it all.
Thank you very much. Definitely will start reading through this.
The comments are perhaps the most hilarious part of this, #import flask modules from flask import Flask, request, render_template #Import DAL from gluon.sql import DAL, Field, Table #Import Markmin to format the pages from gluon.contrib.markmin import markmin2html # new Flask app app = Flask(__name__) :D
He was just sleeping during the “new math” classes… :)
thanks for the info ! very educational to me the report users must love ya so much they want to rape you :)
I'm pretty sure TheSausageKing was simplifying the situation for pedagogical purposes. Obviously anyone who studies how hash tables work is going to be aware of collisions.
You don't like it because you're uncomfortable with generators, or you'd rather declare your fields in a different fashion, or ... ?
Where do you teach?
If there was _any_ form of randomness to it, it would be completely unusable as a, well, hashing function. A hash by definition must _always_ produce the same output when given the same input. What you are thinking of is that the hashes of _almost_ identical input can differ widely in output, but that is not random.
 a = b b = a + b Look at that for a sec. Since a=b, b = a+b is equivalent to b = b * 2, which is clearly not right. Your simple translation doesn't work because when doing multiple assignments, they are performed *in parallel*, not sequentially.
`a, b = b, a + b` uses the old value of `a` to calculate `a + b` Your code uses the new value of `a` to calculate `a + b`, so what you're really calculating is `b + b` or `2b`.
Chalmers Univ. of Technology in Gothenburg, Sweden. I'm a PhD student there and 20% of my time is TAing, including a course on Data Structures where hashtables are covered.
If you break it into more than one statement you'll have to add a third variable to temporarily hold one of the values like this: temp = b b = a + b a = temp
The argument that getLogger is the only/best way to do this seems bogus to me. If a library wants external code to be able to configure its logger, why not just expose the object in its namespace? 
Hi, this example is meant to be used in a presentation, just to show how the DAL works on non-web2py projects. As I was presenting to people of different technical levels, and even some people who have never heard about web2py or Flask. I used comments as a way of showing more didactic what was happening. (even my english being so bad, I tried to translate before publishing) Do not take that as a technical example, but as a didactic example, focused on Database Access, not a "Pythonic" project.
&gt;"Mmm, you ask why 1+1=2 but 1-1=0... clearly you miss addition and subtraction concepts, so I'll mention them to you". Sorry, this was a bad example because it didn't convey my point to you. I meant to imply that the inquirer knows the vocabulary of addition and subtraction (plus and minus) but does not understand what they mean. So saying "they're different" isn't helpful. So, in my mind, it was the same as the later example I gave. I'll give a better example in response to ffrinch. &gt;micha2305's one was not one of those (at least for plenty of us). Yeah, I see that. But I think that was the case because most of you already knew the subject matter. &gt;I'm affraid to say: that task might prove to be impossible: how does one knows what is that the other does not knows? Honestly, I think this is part of being a good teacher. Obviously, nobody's omniscient, so you can't always know the best way to answer. But giving a good answer requires us to think critically about why the question was asked and to consider what they may or may not know. This usually leads to several possible answers. Giving the most-basic "example a is x and example b is y, so they're treated differently" is the least-helpful of the factually-correct answers. I would not consider it a good answer in any context I can think of. In this case (and in every case I can think of), *why* they're treated differently is critical to fostering understanding of the subject. That's why I was so surprised that a lot of people liked micha's answer.
thank you :-/ I didn't know how was parallel assignment actually worked. so: c = a a = b b = c + b 
We must first look at the context before you start playing hostile comments. This example, which was done in minutes, to be used in a presentation to an audience that had some non-programmers. I had no intention of following any rule or Pythonic regulation, there wasn't really concerned about syntax or PEP-8. Repeating: didactic example, focused on showing how to access the database using the DAL, then the important thing here, for those who were watching was to understand how to insert, update, remove, and other database operations. Simple example, made in minutes, should not be concerned to follow any thing more than (CRUD on database) (But I expected this kind of trolling here)
To be fair, if you were looking at the output of a good hash function and a random sequence, you shouldn't be able to tell them apart; and we don't have a definition of randomness that's much better than that. But it's certainly a very deterministic sort of randomness.
Sounds like you an FFT library, not a sound analyzer. Basically, there's nothing magic about sound waves... any sort of general frequency analysis library will work.
An even better example might be in javascript, where "a == b" is different than "a === b". Now, if you say "the second one is identity comparison", you may have given the inquirer an extra vocabulary word, but I don't think you've really helped them. Searching for "javascript" + "identity comparison", "triple equals", or "three equals" all yield explanations of this difference and the extra vocabulary word probably doesn't enable any more research. Still, the question was asked for a reason and if we want to answer it helpfully, I think it's appropriate to explain what makes identity comparison different. Now, if what you're really saying in your reply is "go read about it", then you can say that. But I don't think it's helpful to give essentially-redundant information.
The use of global and the call for model() is just a workaround, because I had no time to do it in other way. But since you are considered as a perfectly "Pythonic" coder, could suggest a better way to solve? I will be happy to update the code for this to be a better example to be used. And so, instead of posting hostile comments, could share information and suggestions. "Who more complains and criticize, is who less contributes!" 
I'm late to the party, but I thought this might be helpful to someone. The multiple assignments creates a tuple and then unpacks it. This is why you can do a swap with: a,b = b,a This is basically the same as: t = (b, a) a = t[0] b = t[1] The correctly translated fib function: def fib(n): t = (0, 1) a = t[0] b = t[1] while b &lt; n: yield b t = (b, a + b) a = t[0] b = t[1] 
I know I have not to feed the Trolls, but What is hilarious on the comments?
The quality of the code isn't my point. It's that COBOL isn't on the rise, it's on the decline. More and more COBOL code is being retired every year as it either becomes redundant or pointless, and it's not being replaced with *new* COBOL code. I took a couple of COBOL classes in the mid-90's expecting to need them for Y2K changeovers. Never did, not once. Other than to make PIC jokes with geeky friends.
I found these: http://pyaudiere.org/ and http://people.csail.mit.edu/hubert/pyaudio/ I have never used either of these but it might be a good starting point.
I don't know why you think it's bogus. If a library exposes its logger objects in its namespace, then they're effectively module-level singletons anyway (even if exposed via a function), so not different in kind from the shared state in the logging package. The approach you suggest would require additional work for library developers which would not be perhaps foremost in their minds. Perhaps it's not expecting much from them, but there's no guarantee they would do it for all loggers, and not miss one (for any number of reasons). The approach I've used sort of guides them in the direction I'd like them to take, without making it hard to get hold of a logger. You also don't address the problem of how to let non-coders affect the configuration; with logger shared state being in the logging package rather than spread all over the modules used by an application, it's somewhat easier in logging for non-coders to set the configuration to a known state. I'll be interested to see how you propose to solve that in twiggy (and I'm not being sarcastic when I say that). I didn't say anywhere that my approach was the best or only way: I just gave the reason for shared state in the logging package. It still seems the most direct/straightforward way to me, which is why I did it like that. Also note my second, related point - about the logger hierarchy. Library developers don't necessarily have to instantiate all the loggers implied by "foo.bar.baz" - they just use *logging.getLogger(\_\_name\_\_)* in their leaf modules (that need to log), and the hierarchy is completely mapped automatically to the software's structure. Application developers who want to configure at levels "foo" or "foo.bar" can do that, with no additional work required by the library developer.
For the FFT library, numpy or whatever thing will do. However, I have no idea how I can get the raw data out of the soundcard, and how I can fiddle the various settings (sampling rate, 8/16/24 bits, left/right channel, etc)
I have nothing to contribute, but I'm saving this thread for later. 
Note, that you don't really need to use a set of primes for primality testing, since in you've already implemented a O(1) primality test for all numbers `&lt; n` in the function `list_of_primes(n)`. See [Sieve of Eratosthenes](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes). You could change the list called `n_factors` into a list of boolean values, ie the values `True` and `False`, where `n_factors[i] = True` iff `i` is prime, then return that list instead of the actual primes, and build the list of primes directly in the function `main`. For example (note: untested code): is_prime = [True] * n is_prime[0], is_prime[1] = False, False for i in xrange(2, int(sqrt(n))+1): if is_prime[i]: for j in xrange(i+i, n, i): is_prime[j] = False and then define primes = [ p for p in xrange(0,n) if is_prime[p] ] Then you can change `if p in primes` into `if is_prime[p]`.
Where the hell has that function *been* all my life? Forever amateur...
If you're on *nix, it's fairly simple if an OSS-compatible (including ALSA with OSS emulation), you can pretty much just open /dev/dsp for reading and get bytes if you're lucky. 
pyaudio looks promising. 
 uptime() = time psutil.Process(2360).get_memory_percent() = Mem For one, those are backwards. You want to do `time = uptime()`, etc. A few other pointers: 1) Don't return an error message as text; if an error occurs in a function, you should raise an exception. This way, the calling function doesn't need to check the return value for an error message, it only needs to check for exceptions. In your case, there is no need to manually raise an exception. Remove the try/except block and just let any `IOError` from `open(...)` be passed up. 2) `psutil.Process(2360).get_memory_percent()` is a bad idea. I'm not sure which process you want, but there is no guarantee it will always have the same ID. Try and find a way to dynamically find the PID for the process you want. 3) Break down uptime(). Having a few small functions instead of one large one can make code easier to read and maintain. For example, have one function `get_uptime_seconds()` def get_uptime_seconds(): with file("/proc/uptime") as uptime_file: contents = uptime_file.read() return float(contents.split()[0]) Have another method called `get_duration_string(s)` or similar that converts a time in seconds (s) into a pretty string ("N months, X days, Y hours").
What is the output when you run this? Based on the "uptime() = time" I'm guessing it is a syntax error. (Assignment is directional, you probably want "time = uptime()" which says take the value returned from the uptime function and bind it to the variable time.) In general, you need to be more specific about what problems you are having so the people helping can isolate what is going on.
logging config is appropriate as a singleton because its an application wide configuration. There's only one app running.
And I believe you need to pass your message to api.update_status(). so, api.update_status(mem) api.update_status(time) Looks like you're passing nothing to that function.
OK, removed the global vars, no more calling model(). But, what did you mean "old-style-classes"? That code has just one class, and that class is writen in right way.
Unless you are using Python 3, you should be inheriting from object.
I don't see anything wrong. look the 2.7 tutorial on classes: http://docs.python.org/tutorial/classes.html What is different on MyVirtualFields class? 
&gt; (I think that the most natural looking parser for a binary protocol would be a recursive descent parser with no backtracking, but the parser code would not map well to the actual structure of the messages. I agree with this assessment. I would love to see a tool that compiles some sort of structure descriptor (python or otherwise) into highly-optimized serializers and deserializers in python with associated classes for passing the data around. It could also target python extensions and other languages (vanilla C or C++, etc.). This type of thing is already done for XML (generateDS for example), as well as probably more generic parsers, but one targeted to binary protocols would be sweet.
http://docs.python.org/reference/datamodel.html#newstyle You need "class MyClass(object):" to have a correct new-style class in Python 2.x.
Old-style classes are deprecated but opt-out in 2.x. So better inherit from object. The difference is that one is an actual Python heap type, the other is a hack on the old and deprecated class system which has some weird behaviour you should not rely on.
OK, I Fixed that! Thank for everyone who helps! &amp; FYSMOTHWTD for everyone who just want to create a stupid flamewar here!
FIXED!
The Python web world (and therefore the hivemind here) has a lot of political and aesthetic issues with web2py. It isn't anything against you specifically, we just don't much care for the framework and it serves as a lightning rod for "non-standard" design choices.
I understand and agree on some pieces, but I think it is better to approach for help (as you did). than the approach of hostile criticism. It is a big mistake this disagreement about the web2py. Instead of helping the community, just prejudice, we could share experiences and even functionality between the frameworks (such as is proposed in this code).
Aaand, now I learnt something. Thanks.
you may want to view this page (which you've already imported): http://docs.python.org/library/subprocess.html and use something like this: output = Popen(["uptime"], stdout=PIPE).communicate()[0] this uses the utility built in to linux to get the uptime info... although not exactly in the format you want, it's more human readable than proc files
I've used pyaudio to make a spectrum analyzer. It is ok, but I don't believe that it's regularly maintained.
..confused. "Python is the only one that offers this functionality therefore.... wart"?
Ah, I was definitely counting "wanting to be the antithesis of Perl" as Perl influence but it looks like that might not even be true since they were both developed around the same time. Syntactically it's definitely intentionally different from Perl, but antithesis is too strong I think. They are both still very similar; dynamic, interpreted, open-source languages with core types being scalar variables, lists and dictionaries. I probably just moved them closer together because of my personal movement from perl to python for the same use cases. I have definitely noticed that the type of thinking that's in the article is very prevalent in the "Enterprise Java" world (just started doing some consulting work for a company that is in that realm). The amount of ignorance about anything that doesn't compile from Eclipse in this community is pretty astounding for people who feel like they are *more* professional than those "scripting language people".
Yeah your right. I actually had the primes function in an external module and just reuse it. But I could have done that for sure.
You can save some yourself some work with the [datetime](http://docs.python.org/library/datetime.html) module. The following will return a string like this: `14908 days, 20:40:25.904201` which might be good enough for you. If not, you can get the days and seconds from the [datetime.timedelta](http://docs.python.org/library/datetime.html#datetime.timedelta) object and do a little math for the rest. You should also look into better string formatting than just concatenating everything. import datetime #---------------------------------------- # Gives a human-readable uptime string def uptime(): ## get seconds from file path = '/proc/uptime' try: # the with statement is helpful with open(path) as f: contents = f.read().split() except IOError, ee: # you should raise the exception (it will have useful info in it) raise IOError('Cannot open uptime file: %s \n (reason: %s)' % (path, ee)) total_seconds = float(contents[0]) delta = datetime.timedelta(seconds=total_seconds) return str(delta)
s/offers this functionality/changes widely-accepted semantics of bog-standard language keywords/ it's a bad thing (IMHO)
Have some code somewhere ? I had a go, but my code could probably be better.
The bitter old programmer inside of me insists that I say: never underestimate the ability of the end users to be dissatisfied. :-P
This is completely untrue, the set implementation is separate, and while it's algorithm is the same, it does not use a dict for backing.
def sjoin(lst,sep=''): 
Awesome, this is great :D Works like a charm and it looks nice too!
And interestingly, Eclipse is my favourite Python IDE :D
https://svn.enthought.com/enthought/browser/Chaco/trunk/examples/advanced/spectrum.py
It was at one point. From the code: "Greg V. Wilson wrote the first version, using a different approach to the mutable/immutable problem, and inheriting from dict." 
There's a *big* difference between general purpose hash functions and cryptographic hashes.
Construct is a great library for binary encoding/decoding in python: http://construct.wikispaces.com/ 
How are you doing it? def f(x): x[0] = x[0] + 1 return x x = [0, 0, 0] f(x) output =&gt; [1, 0, 0] f(x) output =&gt; [2, 0, 0] f(x) output =&gt; [3, 0, 0]
 #!/usr/bin/env python def incr(lst): for idx, x in enumerate(lst): if x != 9: lst[idx] += 1 return lst else: lst[idx] = 0 return lst if __name__ == "__main__": lst=[0,0,0] for _ in range(1000): print incr(lst) 
 aList = [0,0,0] for i in range((10 ** len(aList)) - 1): index = 0 while index &lt; len(aList): aList[index] += 1 if aList[index] &gt; 9: aList[index] = 0 index += 1 else: break print aList Not sure if that is optimal (it almost certainly isn't), you would need to profile the code to work on that
huh.. thought I replied to this.. oh well... This can lead to unexpected results.. I wrote a library that used the logging module and it worked fine until I used it in a pylons app, and then it hosed the pylons logging... I'm sure I was doing something wrong, but I had somewhat expected the two logging setups to be self contained.
Because you can't modify the list being iterated over, you have to approach this a little differently. For a list 'a', the line: for x in a: essentially slices the n-th element out of the list, and lets you operate on it using the name 'x'. To modify the list itself, you need to iterate over something else. The following bit of code will do what you ask, and will accommodate changes in the length of the list automatically (there are probably more pythonic ways of doing this, but it works). a = [0, 0, 0] while True: print a for i in range(-len(a), 0): a[i] += 1 if a[i] &gt; 9: a[i] = 0 else: break else: break **EDIT:** Removed extraneous code for clarity
Any particular reason why this has to be in a list? It just sounds like your just counting in base 10. Also, this sounds like a homework assignment. for i in range(1000): print [int(s) for s in str(i)][::-1]
Sure, if you look at the `sets.py` that existed in Python 2.3 that's true, as well as the C implementation in Python 2.4. However since Python 2.5 (i.e. 4 years ago) it has not used a `dict` internally. 
Gotta love reddit! That's awesome that some college students halfway around the world will see my code.
 a = [0,0,0,0,0,0] d = int(''.join(map(lambda x: str(x), a))[::-1]) for i in range(999999): d+=1 b = map(lambda x: int(x), str(d)[::-1]) print repr(b) Just kidding. :) Try this though: a = [0,0,0,0,0,0] p = 0 while True: if p == len(a): break else: if a[p]&lt;9: a[p]+=1 else: print a p+=1 print repr(a) 
 def f(x, i): if(i &gt;= len(x)): print x return for(i in range(10)): x[i]+=1 x[i]%=10 f(x, i+1) 
yah I tried to use it, did kinda suck balls.
then just have if x[0] = 10: x[0] = 0 x[1:] = f(x[1:]) before the return in f(). I think that would work.
There is special datatype for that, it's called "integer" x = 0 # 00000 x += 1 # 00001 x += 1 # 00002 ... # 00009 x += 1 # 00010 What you need is a function to convert to/from an integer an a n-sized list of each of its digit, in reverse. def to_rdigits(num, count): ls = [] for di in range(count): ls.append(num % 10) num = num // 10 return ls def from_rdigits(rdigits): # convert to number, leave to the reader. ADDED: Oh, scratch that, this is more optimal, just make interface to underlying implementation, and use integer as storage. class RDigits(object): def __init__(self, value): self.value = value def __getitem__(self, index): return (self.value // (10**index)) % 10 def inc(self): self.value += 1 def as_list(self): # leave to the reader.
I love generators, however it gives no valuable information here. so many nonsense yield self stuff and quotation marks hurt my eyes.
Ok, that's a little more bad ass than I expected.
Most guides to commenting code use examples like this as how not to do it. The traditional "worst" way to comment is things like: #Increment x by 1. x += 1 #Initialize the widget. initialize_the_widget() etc., where the "comments" are literally just reciting the same information that's already clearly in the code.
&gt; This example, which was done in minutes, to be used in a presentation to an audience that had some non-programmers. In any presentation, but *especially* one to people who are not well-versed in your subject matter, you should go out of your way to ensure you're following best practices. Getting people hooked by teaching them bad ways to do things, in the name of "easy" and "fast", is how PHP got its reputation.
I think this is a great idea. I can envision a snappy UI build around such a py library. Perhaps leading to an open source variant to begin to enter the arenas of say MATLAB or Maple
Sorry for the formatting, this is my first post on reddit
This line, if char == "O" or "Q": should be, if char == "O" or char == "Q": Your version could be rewritten with parentheses as, if (char == "O") or "Q": and you will see clearly now that the condition as a whole is always True because the value Q is always equivalent to True. 
Awesome! Don't know why I couldn't see that, guess I need some caffeine. =) 
OK, the templates are simple enough I should be able to make a RSS2 feed with media elements. Woot.
In these situations I find myself using this a lot: if char in ["O", "Q"]:
I've never really seen the advantage of using Sage over just installing NumPy and Matplotlib (and SciPy or whatever other libraries you need). It just seems bloated to me, and doesn't even run in Windows. Most people won't use 90% of the included packages and they're probably outdated by the time they make it into Sage.
&gt; I don't know why you think it's bogus. If a library exposes its logger objects in its namespace, then they're effectively module-level singletons anyway That is not correct. For instance you could expose loggers on objects created from a local function. For instance your public loggers could be on an object returned from a factory function.
 if (char == "O") or "Q": wouldn't that just return true every time because Q evaluates to True [not None] ?
Or (sorry to suggest it) sleep.
Yep. That's why norwegianwood said "the condition as a whole is always True" and that's why the output words in the first test all had 'u' inserted.
&gt;but that is not random. Like I said, random in the sense of being *arbitrary* - the hash has no meaningful relation with the hashee, and is equally probable to reach any bucket. There's more than one meaning to the [word](http://www.answers.com/main/ntquery?s=random&amp;gwp=13). Indeed, randomness in the sense you mean can actually be tricky to define. Eg. we'd normally describe things like "who will win the next hand of poker", or "what will the flipped (but covered) coin show" as being random, but in reality these are already fully determined at that point (and even before the flip/shuffle to some degree, barring quantum randomness). They're *epistemically* random however, because that information isn't available. In the same way, while also being entirely deterministic, hashing is ideally random over unknown input: you should offer even odds that it'll go into any given bucket.
What does your code look like ?
&gt; It has to be - every field access and method call does a dictionary look-up! Same with referring to a variable. Basically, almost any time that you refer to something by name, there's a hash table lookup.
(...) is better because tuples creation is lighter than list creation. It's not a big deal by any means, but still...
☺
Local variable accesses are optimized to indexing the call stack. But I think that's the only case where runtime lookup is avoided.
My point wasn't about the _mechanics_ of how you get the library's loggers, it was that if you get hold of a logger to e.g. set its level from outside the library, and later when the library logs it uses that same logger with the level you set, how is that *not* shared state? Presumably the logger you set the level on persists between when you set the level and when it actually gets used? If it doesn't, then how do you get to control the verbosity of individual libraries in a consistent way? Peter Fein's suggestion - that libraries can expose public loggers, which they would presumably do in arbitrary ways - doesn't allow for a _consistent_ configuration mechanism at the app level. Or perhaps it does, and I will just have to wait and see what twiggy and logbook do to provide this functionality. Perhaps they already do, and I've missed seeing it? That's why I used the words "effectively" and "(even if exposed via a function)" in my reply - I wasn't meaning that they're _literally_ module-level singletons. &gt; an object returned from a factory function. Of course, *logging.getLogger(name)* is a factory function which returns loggers :-)
&gt; I'm sure I was doing something wrong, but I had somewhat expected the two logging setups to be self contained. They typically aren't completely self-contained, because handlers, levels and filters are supposed to be determined at the *application* level. (When wearing my application developer hat, *I* want to determine how verbose logging is and where the logs go to, as *I* know the audience/market for my application.) Why things went wrong for you can only be determined with more information from you about the details. (Feel free to post those details on comp.lang.python and I'll see if I can suggest anything.) There are some (documented) things that library developers have to be careful to do when using logging: * Add a NullHandler to their top-level logger (to avoid a misconfiguration message when their library is used in an app which doesn't configure logging). * Don't add any other handlers automatically in their code, as that's the application developer's responsibility. (It's OK to provide a well-documented API which adds handlers, for your library user's convenience, which the app developer using your library can choose to call, or not call.) And, not documented but should be obvious - make sure there are no logger name clashes between your library loggers and loggers in other code. This shouldn't happen if you use the recommended approach of doing *logger=logging.getLogger(\_\_name\_\_)* at module level for each module where you use logging.
It's possible to "hack" Sage to be used as a Python Library on Linux: You need to set up the environment. In BASH: export CUR="`pwd`" export SAGE_ROOT=/home/user/sage . $SAGE_ROOT/local/bin/sage-env # 1&gt;/dev/null 2&gt;/dev/null IPYTHONDIR="$DOT_SAGE/ipython" &amp;&amp; export IPYTHONDIR IPYTHONRC="ipythonrc" &amp;&amp; export IPYTHONRC Set SAGE_ROOT to the correct location Fire up Python and type in: from sage.all import * Unfortunately, you'll need to use the Python provided by SAGE. 
the primary reason is because sage offers symbolic manipulation, group theory, graph theory, etc.
Sage offers an excellent symbolic algebra system. Matlab and Mathematica are bloated, and most people won't use 90% of its included packages either.
you might want to check out sympy. it's not really close to mathematica/maple in capability yet, but it can do a fair deal of calculus and algebra symbolically.
Believe it or not, I've got SAGE working with IDLE.
I hope you understand that there is a fundamental difference between loggers stored in a dictionary and loggers available somehow from a graph of Python objects. I do understand your motivation for a central registry, but please recognize that some people do not like that. You can always easily put a registry of loggers on a system without such a registry if absolutely necessary.
How about strings? Is if char in 'OQ': better or worse?
Might be faster (haven't tested it), but ugly and could cause confusion.
Can somebody explain me the benefits of this when compared to the Universal Feed Parser (http://www.feedparser.org/)?
Will I be able to use the embedded %cython syntax?
&gt; there is a fundamental difference between loggers stored in a dictionary and loggers available somehow from a graph of Python objects Sorry, I don't see any *fundamental* difference. A dictionary is an object, and nodes in graphs of Python objects often hold connected nodes in dictionaries conventionally named \_\_dict\_\_. (I do know about \_\_slots\_\_ but hopefully I've made the point.) In any case, stdlib loggers are exactly like that: Logger class -&gt; Manager instance -&gt; loggerDict dictionary -&gt; individual logger instances which seems like an object graph to me. That's why I don't get your point. &gt; I do understand your motivation for a central registry, but please recognize that some people do not like that. It's not about likes and dislikes. I put in a central registry for the reasons given in my post, which seem valid for a package which needs to cater for a wide range of scenarios, some of which you perhaps won't come across. You mention "if absolutely necessary", to which I respond that in my judgement it *is* absolutely necessary (and for the reasons given). BTW Armin: you regularly comment publicly about stdlib logging in the context of "bad design" because of "global state", and people might think that because of the good work you've undoubtedly done, somehow your point of view is the only valid one. You want me to recognise that some people do not like a central registry - which I absolutely do, I don't go around saying other people's designs are bad because they *don't* contain a central registry ;-) - and yet you don't seem to want to acknowledge that other people can have points of view which are *different from yours, and yet valid*. Perhaps you don't recognise the scenario in my post as a valid one for you - that doesn't mean it's not valid for others. For those people, what's your specific suggestion about how to control library logging at application level without shared state, which is as easy to use as stdlib logging?
Sorry for offtopic, but I was just reading starcraft 2 stuff and I read your post as "mutaling lists in a for-loop"
&gt; This example, which was done in minutes, to be used in a presentation to an audience that had some non-programmers. If you don't have time to do a proper example, just don't. I mean, example code is for learning and I wouldn't want people to learn from your code. I try to write code properly from the the beginning, saves time overall.
&gt; But since you are considered as a perfectly "Pythonic" coder, could suggest a better way to solve? The usual way to encapsulate state in Python are objects if you want to have shared global state, or return values if you want to keep it clean. I didn't say that I am a prefect coder (I know a lot of way better programmers, like the author of Flask for a not too far fetched example), but I do realize when I see code. That said, thumbs up for making the code better.
Yeah, the tutorial could be adjusted; good point. Though I wonder whether it still makes sense, with Python 3.2 soon (which does use new-style-classes by default).
It's probably faster because in ("O", "Q") creates two strings, creates a tuple, uses \_\_contains\_\_ on the tuple, and uses \_\_eq\_\_ on both of the strings. in 'OQ' creates the string, then uses \_\_contains\_\_ on the string. The actual algorithm that implements \_\_contains\_\_ is ultra fast so no worries there. That said, don't worry about the difference. The difference is usually tiny compared to the rest of the program.
This would be really awesome. Not being able to use sage with a standard python is/was a huge negative point.
&gt; It just seems bloated to me Making is modular will help make it a lot less bloated. That's what he is talking about here.
[this](http://jtauber.com/blog/2006/04/15/python_tuples_are_not_just_constant_lists/).
For a more effective sieve generation, see: http://www.daniweb.com/code/snippet217082.html
Count, stringify, cut, listify? &gt;&gt;&gt; from itertools import islice, count &gt;&gt;&gt; def roll(pos=4): f = '{{0:0{0:d}d}}'.format(pos) for v in count(0): yield list(reversed(list(islice(f.format(v), pos)))) &gt;&gt;&gt; list(islice(roll(2), 10)) [['0', '0'], ['1', '0'], ['2', '0'], ['3', '0'], ['4', '0'], ['5', '0'], ['6', '0'], ['7', '0'], ['8', '0'], ['9', '0'], ['0', '1'], ['1', '1']]
&gt; BTW Armin: you regularly comment publicly about stdlib logging in the context of "bad design" because of "global state", and people might think that because of the good work you've undoubtedly done, somehow your point of view is the only valid one. Didn't you start the discussion again with your blog post? Can't remember that I brought up that topic again.
&gt; Didn't you start the discussion again with your blog post? Can't remember that I brought up that topic again. No? I'll try to refresh your memory. Wasn't logging mentioned on one of your slides in your presentation about good API design? The slide entitled "Bad Examples"? Wasn't this presented by you at a recent conference in Kiev? By recent, I mean a few days ago. The topic was also mentioned on other slides in your presentation, e.g. "Other Practical Advice: Do away with the global state." Coupled with "Global state in Python: any kind of singleton -&gt; global state", it seems pretty clear that you *have* brought the topic up recently, and *before* my blog post. I wasn't at the talk so I don't know what you actually said, but lots of other people will also be just looking at those slides and not getting any context or qualification you may have mentioned in your actual talk. Oh, and I don't have any problems about having the discussion. That needs multiple sides, though: you can't really have a one-sided discussion. So, I just presented *my* point of view about why Python logging has shared state. I did that without disparaging logbook or twiggy (or even mentioning any specific library), though of course I compared and contrasted the use of loggers. I tend to be pragmatic rather than dogmatic, and logging's shared state is a pragmatic solution to a real-world problem (that of control of library logging verbosity from an application level). I don't disagree with you that misuse of shared state can lead to a lot of maintainability problems, but then I don't tar *every* use as a misuse. I have yet to see from you a *specific, practical* problem which you have encountered because of this aspect of stdlib logging's design, i.e. other than any offence caused to your aesthetic sensibilities. If you have such a problem, please state it: I will try and help to solve it, as I have done before in the context of logging set up for web applications. I repeat: &gt; what's your specific suggestion about how to control library logging at application level without shared state, which is as easy to use as stdlib logging?
It's better to write output, err = when using communicate. Don't toss out the error code! 
Don't say if len(string) &gt; 0. Just say if string. Then again, use a better name than string. ;-)
Resembles the [werkzeug url-routing language](http://werkzeug.pocoo.org/documentation/0.6.2/routing.html), which I would prefer.
&gt; I'll try to refresh your memory. Wasn't logging mentioned on one of your slides in your presentation about good API design? There was *one* slide in the context of global state. And I did mention there in my actual talk that this is one of the examples where it's incredible hard to come up with alternatives. You might have also figured that from the slides where in the same bullet sys.modules was mentioned which is obviously a necessity. I feel a little bit stalked that whenever I have the slightest mention of logging somewhere that a few hours afterwards there will be a post on your blog about it. Of a 45 minute talk, that was maybe a 5 second mention. Can we please finally settle that discussion and move on?
I wouldn't say it's ugly; I mean, conceptually, in python a string is just a sequence of characters. So it fits the purpose perfectly. Also I just ran a quick benchmark (strings vs tuples) and the difference is there, but fairly negligible.
What I don't understand about the whole issue is why can't we have to coexisting logging libraries and at the same time not hate each other? I tend to keep a very close relationship with other framework authors as well and we usually don't have heated discussions (besides my weird relationship with mdp from web2py which I am not too happy about either).
&gt; There was one slide in the context of global state. The *three* slides I mentioned about global state were from the slides posted on Scribd. As I said in my earlier reply, I wasn't at the actual talk, and acknowledged that you might have qualified the comments in your speech. &gt; I feel a little bit stalked Gosh: nothing could be further from my intention. Perhaps I should also be feeling harassed that you seem to keep picking on stdlib logging as an example of bad API design? ;-) Seriously: I obviously follow Reddit, and your recent presentations have been posted here. I have a lot of respect for your abilities and generally look through your slides because you have things to say which I find useful and interesting (and no, I'm not being sarcastic. I speak as a happy Werkzeug and Jinja user). Obviously when I see something about stdlib logging in a slide entitled "Bad Examples" it grates a bit, and I'm sure you'd feel the same if it was your work being dissed. As to the 5 secs/45 mins: remember most people can't be at talks, so they have to go by the slides and infer your intent and meaning from what the slides say. Anyway, I wasn't having a go at you, was I? That's my first post specifically about the topic of shared state in logging. Surely I'm entitled to get my ideas out there too?
A more pythonic way of doing it would be: if char in ("O","Q"): Writing: if char in "OQ": would work but isn't very readable.
Hey Armin, as I said in another reply on another thread: I don't hate anybody. I'd happily buy you a beer. I'm not hostile to logbook or twiggy: may a thousand flowers bloom. But if you characterise stdlib logging as the weed in the flowerbed, don't expect me not to try and rebut any comments you make about it, which I disagree with, or for which I want to give specific context. That isn't hatred, it's just a different perspective. As for "heated" discussions, it's my observation that it's your comments that have tended to raise the temperature. Indeed I would say that the discussions from my viewpoint are no more than "spirited" :-)
&gt; As to the 5 secs/45 mins: remember most people can't be at talks, so they have to go by the slides and infer your intent and meaning from what the slides say. That is indeed something I missed when designing the slides which is why I will be careful with the slide design next time. My intention with the slides was to raise some (partially provoking) points and then paddle back a bit in my actual talk. I figured that was a way to keep people interested. I hate nothing more than a talk where the speaker just reads from the slides or where the slides give away everything. At least I will next time link to the slides + recording once both are online in case the presentation has a similar concept. &gt; Anyway, I wasn't having a go at you, was I? No, that was perfectly fine. I was just replying to the claim that a logger exposed somewhere was the same thing as a registry which I think are (slightly) different things. The advantage of the central registry is the ability to have a central configuration, the advantage of loggers being reachable (if at all) from a Python object graph would be easier cleaning up in tests and similar things. Obviously logbooks and loggings design are vastly different when it comes to dispatching log records and I am very confident that my approach has its weaknesses as well. These slides explicitly only mentioned the downsides of having global (or let's say implicit) state and why a library (in my opinion) should try to avoid it.
You probably will get a better answer/explanation/guidance if you post this in stackoverflow.com
If it's for matching URLs, shouldn't the default match `[^/]*` instead of `.*`?
Sage uses Sympy, what's the value-add of using the Sage bundle instead of the constituent packages that interoperate properly with the rest of your system?
&gt; etc., where the "comments" are literally just reciting the same information that's already clearly in the code. Clearly for who? I said we had non-programmers on audience. Why do you care a lot of this? that's not important, the important thing here is the purpose of the project. Can you do it better? Good!
good point, although I've never seen update give an error, it's probably a good habit to have
This is not a "How to write Pythonic code" this is just "Dal can work well with other frameworks". If somebody could do a better or different or more "Pythonic" code for this. I think this example can help with some directions.
Good for you! I achieved my goal with the presentation, if my concern was different, maybe I had not reached my goal in time.
Just for the record... web2py itself does not use global, the source is PEP8 complaint (except for validators/helpers and the reason is explained in the book) and does not use old style classes.
I believe that's a feature provided by IPython. If you run IPython, as provided by Sage, then yes. At that point, you might as well have run ./sage 
It doesn't matter. When using it with `in` a list whose members are all constants (at the bytecode level) is turned into a tuple.
Sage is in an awkward transition point right now. Originally, it was bundled so that its many packages would operate properly together. Sure it wasn't the "best" decision, but it got the ball rolling for development. Now it can go down the route of un-bundling the packages, and relying on what is provided by the Linux distribution. Can someone verify if the all popular Linux distros have all the packages upon which Sage relies, and that version conflicts wouldn't be a problem? Here in lies the problem.
&gt; why I will be careful with the slide design next time Fair enough. &gt; I hate nothing more than a talk where the speaker just reads from the slides or where the slides give away everything. I see where you're coming from, but "shock headlines" is a tabloid newspaper tactic. &gt; just replying to the claim that a logger exposed somewhere was the same thing as a registry which I think are (slightly) different things And I was making the point that my approach is not *ad hoc* as Peter Fein's suggestion might lead to, and so allows for a uniform configuration approach, which is a definite benefit, neh? And I also pointed out in my replies that stdlib loggers are returned from a factory function and maintained in an internal graph of objects, which seems to be the same thing you're advocating as being OK. Or at least, the distinction, if there is one, is a little too fine for me to grasp. As far as support for unit-testing is concerned, I believe I addressed that in an earlier post about unit testing and logging. If you feel some particular functionality is missing, then you only have to discuss it with me, I'm fairly open to suggestions. For example Mike Bayer pointed out there was no public API for seeing if a logger had any handlers, and it seemed a reasonable request as he gave a specific use case for it. I've now provided for that via the Logger.hasHandlers() API which will appear in Python 3.2. There's also the logutils project which provides most features added to logging recently, for Pythons 2.4+. This is released via PyPI/Google Code though I haven't especially publicised it as I'm still working on a couple of things with it. &gt; explicitly only mentioned the downsides of having global (or let's say implicit) state and why a library (in my opinion) should try to avoid it. Of course, and I in turn am making the balancing case that although your point may have merit as a general principle, there's a good reason why stdlib logging does not adhere to that principle dogmatically. Notice that in my post I did not disagree with the general sentiment of your point: but I also keep in mind what Ralph Waldo Emerson said about consistency.
By the way, there is even an IETF draft for such a thing and Google's reference implementation: [url-templates](http://code.google.com/p/uri-templates/)
have you tried? in set(('O', 'Q')) For small sets it might be around the same, but for bigger ones it should make a big performance difference.
They are different tools: interssection creates new feeds from existing ones and feedparser retrieves information from them.
This is easy. Take your original list and say original_list[:] = [9] * len(original_list) Otherwise, I have no idea what the exact end results you're looking for are :/
You can modify a list you're iterating over as long as you do it 1 for 1. When you start popping or adding items to the list you're iterating over can you run into problems. 
"Here's an example of how to do it, except don't ever do it this way and people who are experienced at programming will yell at you if you do" is not the disclaimer you want at the start of your presentation. "I taught you a completely wrong way originally, so now you have to forget that and re-learn" is not what people will want to hear after they see your presentation.
Non-programmers don't know what comments are or how they work. So the non-programmers get no real help, and the programmers get the painful experience of seeing this. I care about this because I care about teaching people how to do things. Specifically, I care about teaching them to do things well, and I don't think "I was rushed" or "they're non-programmers" are good excuses for teaching people to do things badly.
I think you've hit upon the important issue. In my opinion, there are two basic ways to approach numerical computing in python: 1) as a programmer calling a library to make your life easier, 2) as a user who wants a single program they can learn to use. NumPy, Matplotlib, etc are targeted to the first approach. Sage binds them all together into a single UI to appeal to the second approach. While I generally side with you and just use the libraries, if a colleague asks me for a free Matlab/Maple replacement, I'm going to say "Try Sage" instead of "Learn Python and use NumPy/Sympy". The real question isn't "can Sage be turned into a Python library" but " *should* Sage be turned into a Python library." PETSc is a good example of a project which wraps a bunch of other libraries, adds some functionality and a consistent API, and becomes extremely useful. On the other hand, SciPy already does a great job of having an easy to use API. In summary, unless Sage can provide a compelling feature which makes it better than the constituent libraries, it shouldn't try to be a library as well as a UI.
OK, maybe you're right on some points, I changed a the code a little in accordance with what they are saying here. so I think now have nothing to be changed,and in addition to everything "It works!"
This may be more a matter of opinion rather than the rule. Sometimes it is necessary to include obvious comments, especially when teaching something.
If anyone is interested in doing this with Japanese kana in python, there's a python port of the ruby package `romkan` available, although it uses EUCjp. I ported it to convert to/from UTF-8, but stupidly [only ever released a patch](http://dev.jmoiron.net/svn/rom-seimei/python-romkan-utf8.patch). It seems to work fairly well, though, as it's being [used by a Japanese chap](http://github.com/gimite/kanjy-wave/blob/master/uromkan.py) in some social web IME API called `kanjy-wave`. EDIT: Actually, I haven't used it in a long time, but I think it just romanizes kana. So it's somewhat different; the equivalent would kana-ize romaji, which is actually not very straightforward.
Thanks, silly me! That's so strange. I've been using feedparser extensively, and I always thought that it includes the functionality to create raw feeds from its data structures after the feed has been successfully parsed. ...so now I have to go and code it.
looks pretty cool, I'm not sure if I would use it as an external dependency. it would be great if it were part of the core.
There's also (for WSGI) [Selector](http://lukearno.com/projects/selector/) and (shameless plug) my port for django [django-selector](http://packages.python.org/django-selector/). It'd be nice to standardize, though.
add four spaces before each line of code and it'll print like this there's some cheatsheets on the help/faq
I thought it was faster though
i have heard a lot about sage, but i have been using scipy and is there much of an advantage to importing the sage libraries over using scipy. i think i read somewhere that sage already uses scipy. also i can understand using sage(or octave for that matter) instead of matlab say as a computational ide but if you are using it for old fashioned numerical programming, scipy+gnuplot say.
At the moment the only supported output format is Atom 1.0 and it includes only the most basic elements. Supporting more formats and tags wouldn't be that much of a problem--thanks to feedparser usage--but it would require lots of tests and I wanted to release v0.1 early.
&amp; is the bitwise AND operator. It returns a number C formed by the "1" bits of a number A that are also in another number B. (A &amp; B = C) pow(2,i) returns the powers of two, which in binary, reads: 1, 10, 100, 1000, 10000, 10000. Think of this as a 1-bit "mask" or "filter." So say you have a character whose 7-bit ASCII number is 65 ("A"). In binary, that is: 1000001. Now say i = 3. That gives you pow(2,3) = 2^3 = 8 = 1000 in binary. Now let's see how the AND operator works: 0001000 (8) 1000001 (65) 0000000 (8 &amp; 65 = 0) This value is equal to zero, so your code appends 0 to the string that represents the binary form of the character. This means that there are no powers of eight in the binary form of the ASCII number that represents the character. But let's pick i = 6, which gives: 2^6 = 64 1000000 (64) 1000001 (65) 1000000 (64 &amp; 65 = 64) ^ As you can see, the leftmost bit is 1 in both numbers, so the result of the AND operator has that bit set to 1, which gives you the result 64 (the original power of two mask). This value is different than zero, so your code appends 1 to the string that represents the binary form of the character.
http://docs.python.org/library/stdtypes.html#bit-string-operations-on-integer-types
The for loop iterates over each bit by setting every bit except the i'th bit to 0, then comparing the result to 0. -- Let's say the binary value of acharacter is 01010101. Then first iteration of loop: if (01010101 &amp; 00000001 == 0) Second iteration: if (01010101 &amp; 00000010 == 0) Etc. This is what the &amp; does: 01010101 00000001 &amp; ------------ 00000001 01010101 00000010 &amp; ------------ 00000000 If the result of the [bitwise AND](http://en.wikipedia.org/wiki/Bitwise_operation#AND) equals zero the i'th bit is 0, otherwise it's 1.
O wow, I over looked the &amp; without really thinking about it. This now makes perfect sense. It doesn't 'create' a binary number, its use the &amp; operation to compare the (2,i) against the characters ascii number and then it will either come out as 0 or as you show 64. Genius! Thank you so much. 
Well, it'll either come out as zero or the power of two you are comparing. Not necessarily 64, or 1. :) Cheers!
It _is_ very readable.
Python includes a `bin` function that will give you the binary representation of a number, also. Understanding bitwise operations is a skill you need as a programmer, so don't use `bin` to get around that, but you can use it to check your math or for convenience once you understand how the bitwise stuff works.
The other thing is that it's a good use of tuple unpacking, which noobs tend to forget about when programming Python. 
[PyODBC](http://code.google.com/p/pyodbc/) if you want relatively low-level access, or [SQLAlchemy](http://www.sqlalchemy.org/) if you want something a bit higher-level (ORM, programmatic SQL builders, etc)
I use pyodbc 
NOT SLEEP NOOOOOOOOOOOOOOOOOOOOOOO!!!! well maybe.... =)
I am interested in building some small geo apps in SF, do you have experience in python?
def uptime(): uptime_cmd = "cat /proc/uptime" up_seconds = string.split((string.split(commands.getoutput(uptime_cmd), " ")[0]), ".")[0] return str(datetime.timedelta(seconds=int(up_seconds))) 
What are you migrating to ? I'm considering either gunicorn or uwsgi for work as replacement for Apache/mod_wsgi - we already use nginx for load balancing/caching/SSL/static content anyway, so Apache seems more and more overkill for just serving WSGI apps (if you need to use Apache then mod_wsgi is fine IMHO). Gunicorn is easier to deploy - uswgi requires recompiling nginx which we're not keen on doing to a working setup. However uwsgi performance looks pretty good. 
To the lake.
Ive currently been doing a lot of bitwise, I feel like I have a fairly decent grasp of it since im doing a lot of solutions to questions by hand. I just couldn't figure out how the program worked. As soon as the other guy pointed out the &amp; operation I got it instantly. Thanks for the advice though :)
I was using the 64 for an example, I understand how the (2, i) works. It was my brain not working properly :S But you helped out a lot, ive made good progress since.
Wow, that looks incredible! I will have to try it later. There's a nice example in the eventlet code base for doing realtime websocket suff over zmq. Would be cool to hook them up: http://bitbucket.org/which_linden/eventlet/src/tip/examples/distributed_websocket_chat.py
What are the benefits of ZMQ over the various AMQP implementations? think lots of folks love interoperability, so there must be something really attractive about ZMQ to make folks willing to go there.
Fair enough, I just didn't want someone who had no bitwise experience to just use the `bin` function to avoid it. Good question, btw, since bit twiddling isn't something included in most Python lessons.
as it is a constant, frozenset(['O','Q']) should be preferred
in addition to that: as Python is using dicts EVERYWHERE, dicts (and inheriting from their codepool sets) are within the best optimized and most robust datastructure in Python. If you can use dicts (or sets) for your problem, do it. 
iPython underrecognised? I thought everyone and their dog used it? It's awesome.
0MQ, a much younger effort than AMQP, is a lower level protocol, deliberately designed to work like "sockets", while AMQP is full on competitive middleware. Sort like SCTP vs SMTP (greatly simplifying the difference). 0MQ is a diy sort of deal, and that's why it fits so well with common "RPC" or distributed/high perf apps. It's attractive because its very lean, easy to understand and fits extremely well into the UNIX way. AMQP, otoh, is easier to reach for when you need (an emerging) standard protocol for interop, typically over the internet, or an enterprise bus. If you're building a mongrel2, high performance RPC or distributed logging, grab 0MQ immediately. If you're integrating w/customers, making an internet-wide sensor or datapoint feed, or a large enterprise systems with multiple vendors, you probably want to start at AMQP. AMQP is great, because it gives you a "standard" enterprise choice that doesn't suck and offers valuable tools - like persistence, routing and broker management. 0MQ is great, because it stays out of your way and lets you build your app on your terms, when you need it. 
I was going to say the same about 0MQ as well. I don't get what is being underrecognized here at all.
Someone please help me to explain why integrating ZMQ and ipython is a feat. I read over this explanation a bunch of times and I don't get what this accomplishes? Is it art?
A lot of people use iPython, because it's a prettier and immediately slightly more functional than the standard python shell, but don't know a tenth of its features or capabilities, if that. I am one of these people. )-:
[Ride the Snake](http://www.youtube.com/watch?v=DQYVRr0EYBA).
You know you have a closed-form expression for Fibonacci, right ?
One of the more interesting ones I've ran into is having to re-implement string.atoi. I think its basic enough that most engineers should be able to solve it but interesting enough that it does make them think. Here is a basic solution to it: http://sontek.net/convert-a-string-to-an-integer-in-python
recite by heart result of "import this", of course
I think that's a terrible solution. Well it's good if you don't need error checking, but other than that it's terrible.
*This* is a terrible solution. def atoi(s,b=10): return (1,-1)[s.strip()[0]=='-']*reduce(lambda v,n:v*b+("0123456789abcdefghijklmnopqrstuvwxyz"[:b].index(n.lower())),(s.strip(),s.strip()[1:])[s.strip()[0] == '-'],0)
&gt; import this The Zen of Python, by Tim Peters * Beautiful is better than ugly. * Explicit is better than implicit. * Simple is better than complex. * Complex is better than complicated. * Flat is better than nested. * Sparse is better than dense. * Readability counts. * Special cases aren't special enough to break the rules. * Although practicality beats purity. * Errors should never pass silently. * Unless explicitly silenced. * In the face of ambiguity, refuse the temptation to guess. * There should be one-- and preferably only one --obvious way to do it. * Although that way may not be obvious at first unless you're Dutch. * Now is better than never. * Although never is often better than *right* now. * If the implementation is hard to explain, it's a bad idea. * If the implementation is easy to explain, it may be a good idea. * Namespaces are one honking great idea -- let's do more of those!
I think its a good solution to the answer to the question in an interview, usually I don't want them spending hours creating a solution for me in an interview.
You forgot about negatives.
Good point! :)
I still think I'd hire someone if they could come up with that solution... I'd just keep an eye on their code to make sure all their solutions aren't created in 1 line ;)
Suppose you have a list whose contents don't matter. Show me three different ways of fetching every third item in the list. for loop: every_third = [] for index, item in enumerate(items, 1): if index % 3 == 0: every_third.append(item) list comprehension: every_third = [item for index, item in enumerate(items, 1) if index % 3 == 0] list slicing: every_third = items[2::3] What I really like about this question is how it can lead to deeper discussions: what if the list is actually an iterator (list slicing won't work)? What if it's unbounded eg. an iterator that produces the Fibonacci sequence (the for loop and list comprehension will crash after eating up all available memory)? What if it's bounded but too large for even every third item (same as unbounded)? Is this fixable (yes, turn the for loop into a generator function and the list comprehension into a generator comprehension)? Where might you encounter such a situation (results of a database query, log file processing, etc.)? The real question you're trying to ask is: how good is this candidate at solving problems with Python without creating new ones? By this point in the interview you've probably got a feel for how familiar they are with the language and also whether they've encountered this problem before but more importantly how they'd solve it.
I really like this question, solutions, and had no idea that you could do items[2::3]! Thanks
 your_string_reversed = your_string[::-1] 
 from itertools import islice every_third = islice(items, 2, None, 3) I might be overly fond of generators... 
"Why is python your favorite language?"
I typically qualify my question with "without using the standard library", but if I forget (like I did above), I can always ask what if I wanted every third and fifth item without using the standard library? xs = (item for index, item in enumerate(items, 1) if 0 in (index % 3, index % 5)) Not that there's anything wrong with using the standard library -- I use itertools all the time! But for interview questions, I'm trying to drill down into a candidate's problem-solving skills, and it's been my experience that restricting him or her to the language and built-ins is the best way to do that quickly.
At least it supports other bases.
I optimized it: atoi = eval
Simple is better? def atoi(string): if string.isdigit(): return eval(string) raise ValueError, "invalid literal for atoi() with base 10: %s" % repr(string) (Yeah, I know, I'm cheating really, but use the tools you're given eh? Also the usual objections to eval are moot, since we know the string is safe.)
That's a terrible question, unless you are specifically fishing for the fact that having a favorite language is like having a favorite finger - it all depends on what you need to do with it.
I'm confused too but I think this is what's happening: This doesn't affect the normal IPython shell that most of us are used to. IPy also has a new web-based notebook interface similar to Mathematica: you enter some code, it's sent to one or more Ipython kernels and their results (text, images, html??) are shown on the web notebook. Integrating ZMQ using a Comet pattern would allow the kernels to update the results on the notebook in near real-time. So, maybe you have a plot that shows the results of some long-running analysis and with ZMQ, the plot can be updated as the kernels return intermediate results every few iterations. 
I often just look for the fact that they have thought about the differences between languages. Someone who is enthusiastic about the question is definitely someone who relishes programming.
Except now atoi does a lot more than just convert string digits to integers.
Yes. Slicing (list or itertools) and if-test in for-loop are two ways. Here is a third, completely different: every_third = list() it = iter(nomatter) try: while True: x, y, z = it.next(), it.next(), it.next() every_third.append(z) except StopIteration: pass which depends on [this knowledge](http://docs.python.org/reference/expressions.html#evaluation-order).
Legal? Only if `gen()` were called somewhere under `yield from ...`. Don't waste time understanding this PEP. It's a bit deep. If you are curious about co-routines, look at [Lua](http://www.lua.org/pil/9.1.html). See also [reddit discussions/links.](http://www.reddit.com/r/programming/comments/8x0go/lua_coroutines_vs_python_generators/) And if you *really* want to learn something, read [this paper by Lua's author.](http://www.jucs.org/jucs_10_7/coroutines_in_lua/de_Moura_A_L.html)
From the documentation: atoi(s, base=10) atoi(s [,base]) -&gt; int Return the integer represented by the string s in the given base, which defaults to 10. The string s must consist of one or more digits, possibly preceded by a sign. If base is 0, it is chosen from the leading characters of s, 0 for octal, 0x or 0X for hexadecimal. If base is 16, a preceding 0x or 0X is accepted. You're forgetting the `base` argument, which exists *at least* since Python 2.3.
No base argument.
Explain how Python allocates integers (arenas, pools, etc)
You can take this further by adding "why do you *hate* Python?" A true master should know both the virtues and the flaws of his art.
 i = iter(items) every_third = [c for a,b,c in zip(i,i,i)]
Who is your favorite Python? And why? (If we're gonna be working together better make sure we can function as a team!).
"What don't you like about Python?"
go on
I think this is an excellent question. Familiarity breeds contempt, anyone who has done any significant python work should have a decent answer to this.
I usually ask this one. Also ask them to compare Python to another language they claim to know and tell me the pros and cons of each, which they would use for a project and why, etc.
A decent answer or twelve :-P My personal complaint? It's too goddamned slow.
Youtube is written in Python. If it is good enough there ... 
Do [PyPy](http://codespeak.net/pypy/dist/pypy/doc/) and [Shedskin](http://code.google.com/p/shedskin/) not suffice?
And we write our performance-sensitive code in C++.
Neither are production ready. Even if they have the speed (and they don't) no one sane would really use them in production.
Is "white space" a good answer?
No more than "white skin" is a reason not to like a person.
This is my backup question to "What don't you like about the Django ORM?" if they have no Django experience.
I like asking Unicode questions. It's a broad topic -- you can start very broad with "What is Unicode?" down to the low-level code of handling Unicode safely. Community involvement -- do they read blogs, mailing lists, or participate at all? Leads into the topic of where they would look for help if they had a question.
Wow, if that is what it is, I think I want it...but please let me know when the code is ready for normal users.
What's the use case for this? Seems like a more verbose syntax if you're just creating static rules, and I can't really imagine a reason for wanting dynamically generated rules. I run iptables and haven't touched the rules in a loong time. It's been a long day, so I'm probably just not being very creative. Maybe an example of something more [than just setting a static rule](http://github.com/ldx/python-iptables/blob/master/doc/examples.rst) would make this more interesting?
It's a perfectly valid answer as a personal preference, but indicates the interviewee choose be trying to find work in another language. Apparently, it wasn't a very funny suggestion considering the downvotes!
You need to check out %help, I love the profiling especially.
Gah, having spent all day inside the Django ORM I think I could go on for about 4 hours on that right now.
Bonus points if they can answer it for strings too.
No type checking. 
I would normally use, for x in xrange(2, len(items), 3): every_third.append(items[x]) I just did some performance testing using a item list 10000000 long Method | Time ------------------|------ zip | 8.62 enumerate | 2.51 comprehension | 2.29 xrange | 0.72 slice | 0.03 
&gt;what if I wanted every third and fifth item without using the standard library? xs = (item for index, item in enumerate(items, 1) if 0 in (index % 3, index % 5)) Oooh, I like it! And you just simplified my [project euler #01](http://projecteuler.net/index.php?section=problems&amp;id=1) solution. :) Before: from itertools import chain a = xrange(3,1000,3) b = xrange(5,1000,5) print sum(set(chain(a,b))) After: print sum(i for i in xrange(1,1000) if 0 in (i % 3, i % 5)) 
follow the atoi of book: The C Programming Language， maybe sign(‘-’ or '+') and spaces(' ', '\t',...etc) should be handled too. I post mine here: [http://gist.github.com/652769](http://gist.github.com/652769)
* explicit "self" parameter in class method but implicit in invokation. * No standard "length" or "size" on collection objects that have length or size - unless you count a double underscore method standard - preferring instead to use the special case builtin *len*.
what about replace "if 0 in (index % 3, index % 5)" to "if any((not index % 3, not index % 5))" to take the advantage of short-circuit
&gt; if that is what it is [there is a sketch map]( http://article.gmane.org/gmane.comp.python.ipython.devel/5663) &gt; please let me know when the code is ready for normal users. [maybe this year:](http://article.gmane.org/gmane.comp.python.ipython.devel/5752) as the last paragraph said.
Gah! All those pesky exceptions. Just do something, I don't really care what as long as the program doesn't have any errors or bugs. EDIT: Wow, pyddit. F'reals? Did you think I was serious? C'mon. I was satiring the perl-lovers out there.
How is `len()` not standard? Do you have a prejudice against using underscores for special magical standard functions?
What would an acceptable answer be for you?
&gt; The real question you're trying to ask is: how good is this candidate at solving problems with Python without creating new ones? Or what I find just as common: the ones who create complex solutions to theoretical problems that nobody needs solved.
Just start every answer with "i know what you are trying to do, and i like it"
Right middle finger all the way. Seriously though. If you enjoy programming, I think there is absolutely nothing wrong with having a favorite or least favorite language. Indeed, I'd be a bit worried if it was the other way around. If you don't have a favorite programming language, are you really a passionate programmer? Do you take pride in your work? Certainly you shouldn't blindly use your favorite programming language everywhere without knowing where a different language obviously suites the problem better, but I have a hard time believing someone who loves the craft doesn't find some tools just fit your mind better than others.
The first is more obvious/readable, especially with the explicit use of 0.
There have been many a time when I wish Python had optional type checking. Duck typing is fine most of the time, but sometimes I want that extra little check.
&gt; I can't really imagine a reason for wanting dynamically generated rules. Port knocking. I use dynamic iptables rules for that.
make a decorator, @accepts('int','list','witches')
You're doing it wrong.
Wow, I was not expecting list comprehension to suck compared to an explicit for loop. Can you try list comprehension with xrange instead of enumerate?
Monty
&gt; How is len() It is a built-in function that performs a very special case which already must be done by the object. Length is a property of the object - so put it there. &gt; Do you have a prejudice against using underscores for special magical standard functions? For starters, pretty much every other object oriented programming language recognizes the need to have an obvious method for access to a length attribute on a collection. Python differs in that it uses a built-in. Any language that supports a notion of operator overloading has a special mechanism for expressing such - so double underscores for things like \_\_getitem\_\_ I have no issue with. Also double underscores for things that really are intended for you to think carefully before using (i.e. \_\_import\_\_) are perfectly valid. Double underscore for the size of an underlying collection is silly (but it is double underscored because you are not intended to call it directly, you are intended to use *len*).
Which is a bit nicer looking just using `reversed(your_string)` if you don't need it to be indexable...
I have minimal Django experience and the ORM honestly seems pretty cool. What am I missing?
What are arenas and pools?
Assignments and function declarations aren't expressions.
Decorators, my friend.
&gt; Also the usual objections to eval are moot, since we know the string is safe.) Uh, what? No we don't. class A(str): def isdigit(self): return True &gt;&gt;&gt; a = A("__import__('os')") &gt;&gt;&gt; atoi(a) Whoops! &gt; Simple is better? No. Really no. And for an interview question nonetheless :D?
If you have honestly worked through learning Python and have become proficient enough to work with it, and you still dislike white space - then yes, it's a good answer because the asker requested your opinion and you gave it on the basis of your experience. In my experience, just about everyone (myself included) complains about whitespace at first. Also, in my experience, everyone that gives Python a fair shot quickly gets over it. Still, that doesn't mean your opinion is invalid.
http://paste.pocoo.org/show/282978/
This is one of the things I like about python, how it uses exceptions. You can both communicate what your code expects, and optimize for the 90% case. Assume there is a list of dictionaries, dictList. Consider: for item in dictList: try: print item['relevantKey'] except KeyError: pass Vs: for item in dictList: if item.has_key('relevantKey'): print item['relevantKey'] If you are expecting the key 'relevantKey' to be in the dictionary most the time, the try/except example avoids making the has_key test most the time. Over a large list this could save a lot of time.
"Where do you see yourself in ten years?"
No code blocks or fully featured anonymous functions. I know why they're not there and why they're not really necessary, but I want them, dammit.
Hell, if the contents don't matter, how about every_third = ['irrelevant']*len(l)/3 :)
There's no one correct answer. Just like the applicant should actually like Python but have enough experience to make complaints about it, the same applies to the Django ORM. Some examples could be lack of built-in schema migrations, makes it too easy to generate unnecessary and suboptimal SQL, you could complain about the weird __ syntax for related fields, etc.
What is the air-speed velocity of an unladen swallow? I asked this at about 5 or 6 interviews I was conducting. It was actually able to draw a wide range of data from this question, depending on how it was answered. At its worst, it's fun to ask and generally breaks any tension the interviewee might have. As for a "real" question that tests an interviewees python knowledge, I'd ask them what their favorite standard library module was. I wanted people who had strong opinions about programming. I don't like actual "programming" questions; generally I feel I can tell if someone has programmed a lot or not by how they answer questions about programming.
Is that part of a standard library? I can't find it in 2.6.5
i wish that i could express the love i have for cython. if anyone who works on cython reads this i'd like to give my infinite thanks.
Not necessarily less popular, but I think it deserves far more credit that it currently does. It has, for instance, the same number of lines of code as django.
Hmm. I wouldn't really have expected the ORM to manage schema migrations - is that the ORM's job in other frameworks? I'm also curious what the alternatives to the __ related field syntax might be - I'm totally fine with it, but maybe that's just because I haven't seen better alternatives. I have no idea what the generated SQL looks like (isn't that the whole point of having an ORM?) but if it doesn't do good query optimization then I'd agree for sure that that's a flaw.
 every_third = [c for a, b, c in zip(*[iter(items)]*3)] One-lined that for you
ahmen.
A built-in function that calls a magic method is a very common pattern in Python, not just with len. See: hash, int, str, repr, unicode, reversed, bool, format, and iter. Python 3 adds next. Thank of it this way: Functionality that is used by the core language uses magic methods. It doesn't matter if that is in syntax or in a built-in function.
I was asking if it was a good answer as a joke, and have no problem with white space. It is a valid opinion, but if you're interviewing at a shop that has chosen Python they should ask why you have chosen Python if you don't like the format. However, what I *really* can't stand are the degenerates who use emacs/vi instead of vi/emacs. I can't believe anyone would ever hire them.
Btw, did you try pdb++? http://codespeak.net/svn/user/antocuni/hack/pdb.py
Apart from [endtime's request](http://www.reddit.com/r/Python/comments/dxvtv/favorite_python_interview_question/c13sczb) for more expressions just the little pitfalls that I have to explain to every new programmer: - Do not use mutable objects as default arguments. - Do not use mutable objects in class variables. - How to avoid cyclical imports without having to resort to imports in functions. - import * - The subtle differences between Python versions. - etc.
I know it *can* be done with decorators. It's just not as clean and there's no standard way to do it.
&gt; But obviously I think everyone should **just** upgrade to Python 3.2 when it comes out instead of worrying about keeping Python 2.7 alive past its prime. Not just. If it was only Python I had to update it wouldn't be so bad, but there are many many projects which are simply not going to work with Py3k (yet, or maybe never because they are no longer maintained). As the main developer of the Enthought Python Distribution (EPD), which contains about 100 packages, I can not even foresee when a Python 3 based EPD will be available, which has all the functionality of the current (Python 2 based) EPD.
PHP is not fun an easy. It's inconsistent and ugly. In Python you usually get smaller, simpler, nicer code. (PHP dev for many years here, changed into Python 2 years ago, more than happy with the change).
But that's like a carpenter whose favorite tool is the saw. Of course some tools are more useful than others, and fit the way you do things, but ultimately it is about understanding the problems at hand and being creative in solving them.
Just like the solution in the link.
Believe it or not, I was joking :)
Why did I not know this before?
It's hard to tell on the internet. :P I've seen people be serious about dumber things than that.
In my opinion it is harder to refactor than most statically typed languages. When you refactor something in a statically typed language you usually get automatic alarms everywhere that code touched and the tools to help you refactor are quite good. Automatic tests can help but it's not the same.
I was under the impression that try/except is less efficient than check/action. Or did I misread something somewhere?
Interesting. As a Python newbie I'd really enjoy some more details about how to do it right! :-) Thanks.
For instance, we have a project where applications can provide hints to a policy manager running on a multihomed router about their communication requirements. The policy manager then sets up a path for them using separate routing tables and iptables marks. The policies are fully dynamic and can change any time as network interfaces go up and down.
Good question, and I admit I don't know much about efficiency in this case, someone care to elaborate?
I agree with the first sentence, but I'm not sure about the second. Django is a huge framework with support for many things, I would expect ipython to have fewer lines (and be made by Apple, I only now realise the name suggests).
Like Poromenus said, `%help`, but also `%magic` and `%quickref`.
Try is cheap, except is not. But how many times are you going to raise an exception? Depends on your data.
is that important in knowing how good a programmer is? I had to read the python source code for some reason, and I've stumbled upon this, but I don't think this makes me a better python programmer. But I'd like to hear your explanation 
Man, talk about finicky. I've got legitimate complaints for Python (no lightweight syntax for anonymous function values, unicode brokeness for most of 2.x series, explicit self parameter, and Python 3 function annotation syntax), but this definitely isn't one of them. &gt;&gt;&gt; class LengthMixIn(object): &gt;&gt;&gt; @property &gt;&gt;&gt; def length(self): &gt;&gt;&gt; return len(self) &gt;&gt;&gt; class FinickyList(list, LengthMixIn): &gt;&gt;&gt; pass &gt;&gt;&gt; a = FinickyList() &gt;&gt;&gt; a.append("item") &gt;&gt;&gt; a.length 1 &gt;&gt;&gt; class FinickyDict(dict, LengthMixIn): &gt;&gt;&gt; pass &gt;&gt;&gt; b = FinickyDict() &gt;&gt;&gt; b["key"] = "value" &gt;&gt;&gt; b.length 1 
While I prefer Python to PHP any day, nicer code is more a result of good programming practices than language.
Ok, a security through obscurity layer. I can see that, that's cool.
Neat. Yea I can imagine this might be useful for user admin type tools. I wasn't thinking very clearly last night ;)
Fortunately, my assertion is not an opinion, is verifyable and your opinion is wrong. ;)
try import antigravity in one of the more recent versions
OK, ok, touché. Figured we were assuming we were getting a string. But point taken. def atoi(string): if type(string) is str and string.isdigit(): return eval(string) raise ValueError, "invalid literal for atoi() with base 10: %s" % repr(string) EDIT: Besides, if someone can create their own class definition, why would they ever need to inject raw python into atoi!?
Funny -- most of the gripes I had with python have become less of an issue as I've understood their purpose; explicit self, join as a string method, etc.
There is an interesting piece of code for the inverse situation: &gt;&gt;&gt; b = 2 &gt;&gt;&gt; c = `b` &gt;&gt;&gt; type(b) &lt;type 'int'&gt; &gt;&gt;&gt; type(c) &lt;type 'str'&gt; 
as someone who's seen php, Nicer code is a result of python :D. Seriously its like wc3 barfed all over java and shoved it up somethings ass.
Assuming he wants the lists to be padded with zeroes, the line inside the `for` loop may be altered to print [int(s) for s in '%03d' % i][::-1]
Thanks to xkcd I did know that one. Is there a list of import easter eggs somewhere? *edit*: My google-fu also pulls up from __future__ import braces But nothing looking like an exhaustive list.
Those are the only 2 I know of.
As bloodearnest suggests, the 'asking for forgiveness' version (with exceptions) is faster when there's no exception, whereas the 'asking for permission' version (without exceptions) is faster when there is an exception. In other words, if you expect that many of the looped-over items will yield exceptions, check/action is more efficient; otherwise try/except might very well be. I think the general consensus in the Python community is the motto "it's Easier to Ask for Forgiveness than Permission" (or EAFP), signalling that try/except would usually be the preferred solution. Of course there may very well be exceptions to this, as per the above reasoning.
It would have been nice to have a comparison with competing projects like ShedSkin or pypy. Not only in terms of performance, but also in terms of philosophy, design...
Since working together as a team, maintaining each other's code, is of high importance, "What is PEP 8?"
You have somehow managed to make that even worse... Now you're type-checking too, so you've now even broken some functionality that your function is actually *supposed* to provide? Here's a rule: never use `eval`. *Ever*. Being prudent about using `type` is pretty smart too.
And then you go another step further and write: if char in charsFollowedByU:
Thanks, that picture tells the 1000 words I needed to get some context. I look forward to trying this out.
 foo = "modulators" q = db(db[foo].id&gt;0).select() or foo = "modulators" q = db(db[foo]).select() or foo = "modulators" q = db().select(db[foo].ALL) Please ask this kind of questions on the web2py mailing list. You will get a more prompt reply. 
&gt; Which is why the concept of a Python 2.8 coming from python-dev will never happen. Going backwards to insert an in-development version at this point between Python 2.7 and 3.2 is ludicrous and goes against our development process/policy. Yes, for a time we had 2.6/2.7/3.0/3.1 under development at once (and it was a horrendous pain in our collective ass to manage all of that), but that time has passed. I like how he calls this whole concept "ludicrous", then notes that, yes, this ludicrous thing is exactly what we've been doing up until now. The previous three paragraphs are incoherent when viewed in the context of the past two years, which have seen 2.x and 3.x both release new major versions in parallel. I have no desire for a Python 2.8. But it's a really silly argument, except for that one parenthetical statement which explains that maintaining both was a pain in the ass.
You know it's illegal to not ask every single candidate for that position that same question. If you left one person out, you could be sued. Just an FYI =)
It's bloody useful. If some user has the same password on another, compromised website, then at least the attacker won't be able to log in via SSH without knowing the right website to access on our web server that will then whitelist port 22.
[Dupe](http://www.reddit.com/r/Python/comments/dy2ja/viewing_python_32_as_the_successor_to_python_27/)
It's marginally faster if no exception is raised, and 15x slower if one is. Best case: python -mtimeit -s 'stuff=dict.fromkeys(range(50))' 'for x in range(50):' ' if x in stuff: stuff[x]' 100000 loops, best of 3: 7.78 usec per loop python -mtimeit -s 'stuff=dict.fromkeys(range(50))' 'for x in range(50):' ' try: stuff[x]' ' except KeyError: pass' 100000 loops, best of 3: 5.97 usec per loop Worst case: python -mtimeit -s 'stuff=dict.fromkeys(range(50))' 'for x in range(50, 100):' ' if x in stuff: stuff[x]' 100000 loops, best of 3: 4.84 usec per loop python -mtimeit -s 'stuff=dict.fromkeys(range(50))' 'for x in range(50, 100):' ' try: stuff[x]' ' except KeyError: pass' 10000 loops, best of 3: 76.2 usec per loop But that's not important really. Make it work, make it right, make it fast -- in that order, and don't make it fast unless it needs to be.
I'd love to know more about how Cython interacts with Python's memory management.
I've written quite a few extension modules and rooted around in the guts of the interpreter, but I've never even heard of "arenas". I would probably explain that I think there is a cache of small integers and that I assume there is nothing more to it than that. Hopefully this would not disqualify me, because frankly it is not important for anyone who is not hacking on CPython itself. I am, however, interested and I might go read the source now.
- don't say plowing your wife don't say plowing your wife don't say plowing your wife... "plowing your... son?"
PyPy is not a competing project to cython (not more competing than to say gcc). PyPy is a python interpreter, cython is a compiler of a language that somehow resembles python.
Doesn't pypy contain an RPython compiler?
Nice presentation. Can you tell me if cython is a good fit for this application: * data warehouse ETL software 100% written in python * processes 100 million events a day through multiple processes that run in parallel on a 8 core (64-bit intel xeon) server * I'd like to speed up the process by converting some selected bits to compiled c. Could cython be used just for modules that are called by cpython?
While this seems to be a popular argument in PHP's defense, I'd say that writing _nice_ PHP code is still harder than writing _nice_ Python code. Writing nice PHP code is mostly about writing defensively (against the language, too).
Agreed, but as a platform it feels more approachable because it's so widely available and relatively straightforward to use (of course its intuitive programming style will fall apart when you write more complex/abstract code -- e.g. redirecting every request via Apache mod_rewrite to a single PHP file instead of mapping URLs to scripts directly). EDIT: Because I'm getting downvoted for this (presumably for the bit in parentheses), let me elaborate: The intuitive style of writing PHP is writing HTML with PHP in it, like using a really powerful template language. This is what many tutorials are showing newbies to do and this _works_ as long as you're working with a few scripts rather than a cohesive "web application". The _right_ style of writing PHP is writing plain PHP files, starting with the opening PHP tag, with no closing PHP tag at the end (because doing so can lead to "headers already sent" whitespace-induced problems), putting your config files outside your web root and either using a template language like Smarty or creating PHP-based templates using an ascetic subset of PHP (e.g. no database calls). An even _righter_ style of writing PHP would be to use a framework like CodeIgniter and thus benefit from a MVC architecture with an ORM for data persistence. Of course many people who really prefer this style switch to languages which make this more intuitive (e.g. Python, Ruby). Either way, chances are you'll want a single entry point and have your logic take over from there, which is where mod_rewrite comes into play (because as a PHP user, you'll probably be using a LAMP back-end). The alternative to this is usually a) writing really ugly "library" files (read: assorted functions in a file with a descriptive name like `common.lib.php`) or b) creating PHP files for every URL and trying to force them to behave as if they were related (e.g. by including the common logic from separate files or by duplicating code). As for being relatively straightforward to use: the _platform_ PHP is really easy to use simply _because_ it is widely available. Most shared $1/month hosting will include PHP. All you need to write PHP is to create a file ending in ".php" in your web root and fill it with code. It'll behave just like any other file you can access with your web browser, except it does some magic to produce its output. That's how most beginners learn to use PHP and it's what most tutorials (and entry courses) teach. It's the equivalent of Python's interactive shell, except people try to write real code with it.
Mr Cleese of course.
It doesn't at all depend on 'what i need to do with it' - there are plenty of languages that could occupy the same niche as Python - Perl, Ruby, maybe Go, whatever. That's a separate issue from why one prefers Python over competitors in its use space.
Doesn't change that if Python was faster its range of applicability would increase, and that would mean we could use it more places, and that would be just lovely.
&gt; Man, talk about finicky. I've got legitimate complaints for Python (no lightweight syntax for anonymous function values, unicode brokeness for most of 2.x series, explicit self parameter, and Python 3 function annotation syntax), but this definitely isn't one of them. This is getting tiring. Your mixin added a layer of complexity and created something which doesn't cleanly integrate with the rest of the collection system. But, hey, you seem to think that since this doesn't line up with your opinions on Python's warts it isn't valid. Fuck you.
Show me three different ways ... I don't think this is a good question at all. You should just ask for one. and if they don't give [::3] then that should lead to discussions. I also note that because you did not clearly state the initial fetched item, you end up having to enumerate from 1 and also use [2::3] instead of plain [::3], to be consistent with your for-loop example.
Yes of course. This is the primary goal of cython.
You can use cpython or c libraries from cython. You can use nogil in cython c code (and run in multiple processes). Cython is great for make cpython compatible modules (wrapping c code or making a fast one extending python with types).
why the long irrelevant intro paragraph?
I didn't doubt that it has the same number of lines as django, I doubt that it's a good thing.
It basically writes a Python C extension for you, and puts INCREFs and DECREFs in the right places.
&gt; cython is a compiler of a language that somehow resembles python. Yes, but is not the primary motivation to simplify writing python extensions? &gt; PyPy is not a competing project to cython Depends on definition of "competing". They are definitely aiming to solve the same problem: allowing python programs to run faster... If pypy provides Java-like performance, the need for cython will shrink dramatically. So, they are competing.
How many people didn't realize that you had to use arrow keys to advance the presentation? 
http://github.com/Dav3xor/Python-CheckArgs Now you don't have to make your own decorator.. :) It's still a little primitive, but it works pretty well.
Sorry - stupid FeedBurner links get me every time if I haven't had enough coffee.
&gt;I'd like to speed up the process by converting some selected bits to compiled c. Could cython be used just for modules that are called by cpython? Yes, but it sounds like you won't escape the need for hand-tuned C entirely, so a Cython and C hybrid might give you the best of both worlds. In terms of performance optimization, Cython lacks a certain *je ne sai quoi* that C, Fortran or assembly offers. If you're just looking to build shared libraries (.so files), there are very few complications if you keep Cython and C modules separate. On the other hand, if you're looking to do tighter integration, you'll probably want to bundle the whole thing into a custom Python interpreter with the libraries linked in. I've done this with a reasonably degree of success by basing the backbone on C/Python bindings and compiling the auto-generated .c files from Cython like any other source file. I know of other projects that have gone the other way around, i.e. wrapping a C API in Cython, but there are a couple of drawbacks in terms of flexibility.
Same problem: There's no ultra clean way to do it. Most of it is a fundamental problem with Python. Python is too dynamic to have static type checking. Don't get me wrong, I love Python, but it's nice to have languages that can check that types are correct at (bytecode) compile-time. That said, I would love to have two decorators in the standard library. Python function calls are already slow, so they should be written in C. * 1) @accepts(*args, **kwargs) * 2) @returns(*returntype) returntype allows multiple values so that it can check multiple returns via tuple. None should be usable to indicate that a value is duck typed. Unfortunately, none of this will ever allow the clean &amp; *static* type checking of def int foo(int index, str value)
I've got a little bit of skill in c on my team, but few people have developed much with it in quite a few years - so I'd like to minimize how much expertise we need in c. With that in mind, what do you all think?
You can click on it as well. Though I didn't realize you could use the arrow keys: I used backspace instead. Which took me to the first page, ugh.
Yes, but RPython and Cython serve different purposes. RPython is good for low level programming of a Python interpreter. Cython is mainly good for extension modules that are performance critical and/or need to connect with C. RPython has the trade off of being difficult to write. Cython has the trade offs of needing compiling and being limited to the CPython interpreter (PyPy support is in the works, IIRC). Cython also doesn't implement every Python feature, but the wonderful Cython devs are busy working on expanding support.
I couldn't get past the first slide with a click. Lag?
I was thinking the same thing. Phoenix must be the most overloaded name ever.
I'll leave this here: http://evanjones.ca/memoryallocator/
That's why you use something like: eval("__import__('os')", {'__builtins__': None}, {}) Of course `__builtins__` should be a dictionary of actual working builtins you want to work when evaling the statement :)
Sticking to Cython is probably the safest bet then, although I'm not away how well it goes together with threading. Does anyone on your team have Cython expertise?
but...but... that has Ada style bounds checking, and...and... :)
No cython experience yet. However, no threading is required for our parallelism - for the sake of speed &amp; simplicity we split incoming data sets into separate files, and have no daemon run per core. Each then picks up its own file.
No, don't do that either. Seriously, this is just a bad solution. *Especially* being that you have `ast.literal_eval` if you really want to do things like this.
I like this question.
I'm pretty sure I wouldn't hire them. Senseless one-liners are the hobgoblin of small minds.
`ast.literal_eval` is indeed great for evaluating simple expressions. But what's wrong with sandboxing via defining your own builtins?
The discussion of what version numbers mean, and the lack of agreement between different projects on version numbering policy, suggests that maybe overloading *numbers* with semantics having to do with release cycles is not serving developers and users well. If you want to call something a maintenance release, why not call it a maintenance release, and so forth? The development cycle goes like this. Foobar n development release 1 Foobar n development release 2 ... Foobar n development release m Foobar n+1 Foobar n+1 maintenance release 1 Foobar n+1 maintenance release 2 ... Foobar n+1 maintenance release m ... concurrently with the maintenance releases Foobar n+2 development release 1 Foobar n+2 development release 2 ... etc. Why? Because "." doesn't mean anything specific.
That's implementation-dependent. 
&gt; If it was only Python I had to update it wouldn't be so bad, but there are many many projects which are simply not going to work with Py3k (yet, or maybe never because they are no longer maintained) That's the kind of attitude that breeds IE6
Gouda? Edam? Venezuelan Beaver Cheese?
I don't see the link with IE6. The issue is not about upgrading, but about the cost/benefit ratio. Python 3.x broke a lot of things, which are sometimes hard to detect, especially since python is dynamically typed. Very few (none ?) packages has 100 % coverage, so it is almost certain you will introduce new bugs. What does python 3 give you in exchange ? If you look at http://sayspy.blogspot.com/2010/08/what-will-forever-be-exclusive-to.html, not that much, although it is debatable I guess. But most of those things could have been done in a backward-compatible way. Now, I think complaining about this is useless: it is clear that python-dev is steered toward the current direction, and people won't change their mind.
I just write my shit in pure C and use ctypes. It is quick, easy, and very fast.
Also good to know if you want to roll your own firewall: * **[python-netfilter](http://opensource.bolloretelecom.eu/projects/python-netfilter/)** * **[python-nfqueue](http://software.inl.fr//trac/wiki/nfqueue-bindings)** (personal fav) It all depends just how far down the rabbit hole you want to go. ( There's also Scapy that I suspect must use netfilter as well, but I haven't used it before ) 
py3k will always be a minor blip on most people's radar until its included in RHEL. 
I haven't really spent time making it cleaner, but the basics are there. If I feel like it I might add HTML mail previews and a DjDT plugin.
Jinja2, Pocoo rocks! I hate XML based templating languages because I use the templating for so, so much more.
Nice!
If you're wondering, this is why the trick-or-treaters are confused, rather than scared when they come to your door.
I hope you're running the latest pumpkin patch.
this. is. awesome.
What a long winded way of phrasing the question to elicit the response they want. He could have kept it shorter by saying: 'I love everything about Flask, but what if that guy gets hit by a bus? Please reassure me.'
PumpkinPy.
 &gt;&gt;&gt; import re &gt;&gt;&gt;re.split(r'[*#^]', 'some*multiple^separator#string') ['some', 'multiple', 'separator', 'string'] or &gt;&gt;&gt; def split_miltiple(text, separators): ... for separator in separators: ... text = text.replace(separator, separators[-1]) ... return text.split(separators[-1]) ... &gt;&gt;&gt; split_miltiple('some*multiple^separator#string', ['*', '^', '#']) ['some', 'multiple', 'separator', 'string'] 
Not more than gcc is a competitor to pypy.
Gonna say it: looks like a swastika. Its a fair representation of the python logo, but your audience may not know what that is. 
Can't you just run some replaces on the string first, replacing all the separators in the string with, say, the first separator in the list, and then do your split?
from pympkinpy import carve if __name__ == "__main__": carve()
Django is the "clear" web framework winner? I always had the impression that while Django had a pretty decent share, Pylons, web.py and the others were generally regarded as good runner ups. I can imagine PHP frameworks being less dominant (simply because so much PHP is written without a framework), but generally Pythonistas seem to at least _pretend_ the major frameworks are equally good (though that may have to do with the Zen) and encourage newbies to experiment. It's definitely nowhere near Rails, which is (at least outside Rubyland) so dominant many people feel tempted to refer to the _language_ as "Ruby on Rails".
&gt; if the value's don't fit anymore into regular 30 or 32 byte integers. How does this happen? orz 32 byte integers!
Hm there seems to be something strange going on. With the code as is in the gist I get a recursion depth exceeded exception. Did you increase your recursionlimit? This is Python 2.6.1 on Mac OS X 10.6.4
ah. Wait. outdated code. Iterative version [over here](http://gist.github.com/655311)
pympkinpy is awesome!
Look up regular expressions (regex), and [virhilo's answer](http://www.reddit.com/r/Python/comments/dyml8/splitting_a_text_on_multiple_separators/c13wkfa)
Maybe the problem is related to the function lambda x: x * math.log(x, 10) returning a floating point number? If I eval this (Python 2.6): import math x = 3600 * 10**100000 f = lambda x: x * math.log(x, 10) f(x) I get: Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 1, in &lt;lambda&gt; OverflowError: long int too large to convert to float It's odd that running your code nothing like that happened. **EDIT**: Got it! Changing *find_biggest_input()* to this: def find_biggest_input(function, output_limit): lower, upper = find_initial_range(function, output_limit) return upper, function(upper) returns this: (559936185544451052639360570142111069530411374308662383724997275240947967795040236345219373317901778944L, 5.6972464577214663e+103) (702223880805592151456759840151962786569522257399338504974336254522393264865238137237142489540654437582500444843247630303354647534431314931612685275935445798350655833690880801860555545317367555154113605281582053784524026102900245630757473088050106395169337932361665227499793929447186391815763110662594625536L, inf) (702223880805592151456759840151962786569522257399338504974336254522393264865238137237142489540654437582500444843247630303354647534431314931612685275935445798350655833690880801860555545317367555154113605281582053784524026102900245630757473088050106395169337932361665227499793929447186391815763110662594625536L, inf) (702223880805592151456759840151962786569522257399338504974336254522393264865238137237142489540654437582500444843247630303354647534431314931612685275935445798350655833690880801860555545317367555154113605281582053784524026102900245630757473088050106395169337932361665227499793929447186391815763110662594625536L, inf) That is, the values are being rounded to inf. 
Aaah, this makes sense, yes. Thank you :)
 def msplit(text, seps): pieces = [text] for sep in seps: pieces = sum((p.split(sep) for p in pieces), []) return [p for p in pieces if p] But that's only if you really want to do it with split and lists.
I didn't feel like the Django docs did a very good job explaining what was required to do this so I wrote up how I got it done. Do you guys have any tips on how you do this?
This would be a great time for anyone looking to get involved in Python development to do so. Plenty of people will be in IRC to help get patches committed, help brainstorm solutions, and welcome anyone who wants to lend a hand to the project.
or Pympkin
There's also the 'how do I figure out to do X in the ORM'-factor. Only to find out that it doesn't exist or is painfully slow.
This is simply the geekiest thing I've ever seen!
Hmm, I didn't know about AUTH_PROFILE_MODULE. But wouldn't it be more efficient to add a related_name to the foreign key, so that you can call select_related('profile') when you know you'll want the profile and thereby avoid an extra DB hit?
 import pympkinpy, time, kids, candy from select import select from random import random if __name__ == "__main__": pumpkins = [] if time.strftime("%m-%d") != "10-31": pumpkin = pympkinpy.pumpkin() pumpkin.carve() pumpkins.append(pumpkin) else: for pumpkin in pumpkins: pumpkin.make_glow() while True: kids_wanting_candy, walking_away, NO_MORE_CANDY = select(*kids.on_the_porch()) if NO_MORE_CANDY: RAGEQUIT(kids_wanting_candy) break for kid in kids_wanting_candy: data = kid.recvfrom(1024) [kid.send(pumpkin.scare_kid_away()) for pumpkin in pumpkins] [pumpkin.fail_miserably for pumpkin in pumpkins] kid.send(candy.piece_of_candy() or None)
For the majority of people, thinking hurts. Confusion leads to thinking, so the very image of this pumpkin will cause them pain. Then the owner of the pumpkin will try to explain, and they'll have to think even more, which causes them still more pain, leading to the branding of OPs house as a nexus of torment, year round.
So first off you really should have a unique=True constraint on the FK to User. Second, Django automatically cascades delete through related objects so the post_delete signal is kind of useless. The post_save one is also not that useful, since you handle the creation yourself a few lines down. Third, as for the property at the end, User.get_profile() does cache in the same way as normal related managers, so using that is probably a better bet.
get_profile() is there to be a generic equivalent to a related name, since a generic app wouldn't know what your profile model is named.
That makes sense. In the case, though, where one isn't worried about interop with other people's code, am I right about the db efficiency issue?
I suppose that might come up, but usually you only need the profile data in a very limited number of places. You could probably build some code that would do the select_related dynamically based on the value of AUTH_PROFILE_MODULE.
what a waste of a good pumpkin. Just kidding! no really...
If the separators are known to be distinct then you don't need the ''join(set(...)) &gt;&gt;&gt; def mulsplit(s, seps): first, *rest = ''.join(set(seps)) for ch in rest: s = s.replace(ch, first) return s.split(first) &gt;&gt;&gt; mulsplit('some*multiple^separator#string', '*^#') ['some', 'multiple', 'separator', 'string'] Python 3.1 
As well, here's Alex Martelli endorsing [Flask](http://stackoverflow.com/questions/2665313/python-framework-for-small-website/2665345#2665345) on Stack Overflow. I'd definitely recommend Flask -- especially for small projects -- over Django.
And lo, they reassured him. Which is nice :)
As my wife (PhD candidate) said, "Wait, you mean when you're critical, people actually make things better?" I love open source.
Interesting that he calls Django 'highly magical'
Without importing other modules?
Try this: http://learnpythonthehardway.org/index
asyncore has never impressed me.
try showmedo, i didn't learn from it, bit i use it to learn new parts of python.
Thanks for the tips, I will update the code and update the post to describe what you've said!
Has programming tests, provides solutions, and has video and articles explaining each section: http://code.google.com/edu/languages/google-python-class/
Learning RoR and Python are completely different things... If you are looking to learn a web framework developed in Python (Such as learning Rails, a web framework developed in Ruby) you can check out the [Django Tutorial](http://docs.djangoproject.com/en/dev/intro/tutorial01/), [Django Book](http://www.djangobook.com/), [Web2Py Book](http://web2py.com/book), or [Flask Documentation](http://flask.pocoo.org/docs/)
There is also all the other times someone has asked this: http://www.reddit.com/r/Python/search?q=learning+python