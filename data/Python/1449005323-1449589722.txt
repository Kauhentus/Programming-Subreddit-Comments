I do this at my current setup at work. It's really easy to setup I run and test my code on the dev server. I haven't had any problems using that settup. You can also use putty, VI, winscp if you just want to make quick edits without starting up a full ide. 
Roger that. If a module is insecure/harmful it will be insercure/harmful no matter if virtuenv is used or not. Makes sense.
No problem 
Vagrant is a tool built explicitly to solve the problem you are encountering. I use it at work also, though in my case the host machine is running OSX rather than Windows, but its the same problem. All my development is done locally in the Vagrant managed virtual machine mounted on an NFS mount to my local filesystem where I keep the source code. 
You're obviously going to find a lot of sympathy here if that's your aim. However, to actually answer the question, it would probably help to have an idea of what your coworkers are using now to suggest alternatives on Windows. For instance if they want to develop on the server, but aren't comfortable with vi, then there are things like the [Ace editor](https://ace.c9.io/#nav=about), a roll your own Cloud 9. The just-announced [Eclipse Che](https://eclipse.org/che/) is essentially Codenvy with possibly more code introspection. I haven't done much with Windows in years, but I still feel like PyCharm, a headless VirtualBox server, git etc would combine to make it not very different from what they are likely using now. What am I missing?
&gt; License violations and support issues shouldn't be a problem if the people installing the software are computer literate, as your developers should be. Unless they are also lawyers *and* aware of all relevant agreements others in the organisation have entered into, you cannot possibly know that. All it takes is *one person* who doesn't know the intimate differences between a couple of popular OSS licences to compromise your organisation. And that's probably the easiest case to consider.
Of course it's not. Now you have multiple systems to support, and one fool running the latest shiny Linux version of your source control client (complete with the data loss bug in yesterday's beta channel update) can screw things up for everyone, even though everyone else using the officially supported version of the source control client would have been fine.
What data loss bug? What beta channel update are you referring to?
Absolutely. I was only pointing out that, if they give you Python, you can have most any modules you want, admin access or not.
Using cmder or conemu (same thing, cmder Is a bit prettier) is way better than fucking putty- it has an ssh client built in and is actually a nice terminal emulator. Something about putty bugs the shit out of me.
&gt;The poor folks out there still using Windows just don't know better. I prefer linux over windows, by a fairly substantial margin, but you really sound like douche when you put it like this. First of all, your pretension is showing. Second, and most importantly, I know a number of devs who are more experienced developers than I am, and have been going between linux and windows for years, who still prefer to develop on windows. I think they're wrong, and I have a laundry list of reasons to support this, but good grief these kinds of comments are what make me reluctant to advertise that my daily driver is a linux machine.
Atom is the future. It isn't nearly as buggy as some would have you believe (I don't find it to be buggy at all tbh), and it has a huge passionate community around it. Notepad++ might have been great a while ago, but look forward and I don't think you'll see Notepad++ anywhere. 
I pronounce `sudo` as "pseudo", rather than "Sue do" as I have heard a lot of people say.
It's simple, really: Developing Windows applications on Windows makes perfect sense! What I was talking about (and the OP) is developing *Linux* applications. Windows is a *terrible* OS for developing Linux applications!
RUN!!! NOOOOOOOO!!! DO NOT USE THE ELEVATOR!!!
I know a couple people that pronounce NumPy like "numb-pee", rather than how I've always heard it "numb-pie", and every time it throws me for a loop but I was able to figure it out on my own. But I think if someone called SciPy "skippy" I would just look at them funny.
Your question is effectively identical to https://www.reddit.com/r/Python/comments/3v1men/list_of_empty_list_favorite_way/
Allow me to address your points, as they are clearly worded and I appreciate you taking the time to call me out for being a pretentious douche. First, yes my pretension is showing because I've decided to let it out for the evening. It gets cramped sometimes and needs to stretch. Second, and most importantly, I'm sorry that you rate your own development skills below those of your windows using peers. You should work on that self esteem issue. You are correct, they are wrong. Sorry you feel shame for being so right all the time. All the best!
I suspect it's how python evaluates the [] but I don't know the internals well enough. If you break it up across multiple lines it might behave differently. I managed to use the following to generate a grid like you are trying too dimension = 3 new_grid = [[None for x in xrange(dimension)] for x in xrange(dimension)]
Just left a crappy job where they dictated Windows for everyone. No admin rights on your computer. Not for anyone. Day before I started my new job I got an email asking what I wanted: Dell laptop with Windows, Dell laptop with Linux, or Macbook Pro. It's AWESOME here. Find a new job.
Hey, my company is looking for good Python developers, most of our code is written for Linux, though we do have Mac and Windows client software. If you're interested in a new job in the Boston area at a place that will respect your choice of a development environment (and even do so if you prefer a Mac or Windows workstation, you can run the server software in a VM and do just fine), give me a PM. However, if you're dedicated to staying at your current job, here are some thoughts: 1. Just run Linux in a VM; VirtualBox is free and works fairly well, VMWare costs money and also works well, I've never used HyperV so I can't say much about it. 2. The last time I had to use Windows on a day to day basis for work, I coped by installing PuTTY for SSH (and set up Pageant for use as an SSH agent, set it up to auto-launch on login so I could enter my password once and not worry about it, and then use plink as your SSH command; thought now that I think about it, for tools that I could use in Cygwin I just used Cygwin's SSH agent and [Keychain](http://www.funtoo.org/Keychain) to manage it, Pageant/plink were only necessary for some tools that were outside of Cygwin), used msysgit, used Cygwin for a shell and command line tools, and used ntemacs (yeah, I'm an emacs user not a vi user, so can't help you there). It takes a little fiddling to get everything to play nicely with each other; have the same PATH and HOME set up in each environment so your tools all work together. 3. These days, I hear that [msys2](https://msys2.github.io/) may be the way to go rather than Cygwin, and that appears to be what the new [Git for Windows](https://git-for-windows.github.io/) uses as well. So, you might want to start out by trying that out.
/r/learnpython
If they lack the resources to vet and support multiple operating systems, then where are they getting the resources to pay extra for developers to be able to put up with this? As demonstrated by you ("I would hate to work in a place like it"), and many others in this thread, this kind of policy can be a deal-breaker for developers, so you're probably going to have to pay more to retain good developers, or get by on developers who aren't good enough or don't care enough to leave, so by cheaping out on IT, you're making development that much more expensive. Especially given that it's clear that the software the developers are working on is for Linux. They clearly already run Linux on their servers, so hopefully that is "vetted" as well as the software they're running on their workstations. Why not allow their developers to run the desktop version of whichever distro they are running on their server?
google.com
Polish up your resume and start job hunting. Seriously, tech skills are in high demand, and there are tons of Linux-friendly companies that would pay you well. There's no excuse to deal with a shitty company who's CTO is stuck in the late 90s. Demanding Windows on all computers is like a hospital demanding that their doctors don't wash their hands. GTFO of there.
Can you answer the question? I'm curious.
I don't know where you guys work that you consider switching company just because of a tool you don't like, but for many people that's a far stretch. There are so many other considerations for choosing a company, and not only personal obligations. Maybe his company is the best option for working on the projects that interest him most; maybe that large group is one of the few options to follow the career path he wants… He just asks for advice on how to cope with it. Quitting isn't the topic there.
&gt;if something goes wrong, it won't be the developer who really bears the brunt of it, it will be the business as a whole that takes the hit and the IT staff who have to clean up the mess; and The business as a whole takes a hit by taking a working system that already has selected preferred tools and moving it especially without user buy-in. You're making the business take a hit by trying to prevent a potential hit in the future. IT should do it's job and manage a standardized distro for the devs if the IT director is so inclined on risk management. It is also unlikely that IT is ensuring the productivity of developers via automated setups for development tools anyway. They're probably ghosting the same damn image that Accounting gets and installing the python interpreter on it.
That would require him to install an unauthorized OS on a company computer, and probably even reverse-engineer its connections to be able to connect to the network as if it was a company Windows installation. I would get in a lot of trouble if I were to do that. Depends on the business of course, but not always an option. Probably having his own laptop not connected to the company network would be easier to let slide, but that's not really convenient.
&gt; Place that doesn't allow you to select your tools? Brush up that resume, and find a better job. An employer who doesn't understand basic software development economics is going to make for a shitty employment experience sooner or later. So this. The Python market isn't one where you're stuck with places like this. 
To elaborate a bit -- the `*` operator doesn't do anything different than any other binary operator -- the operands on either side are evaluated *once*, even if one of them happens to be a list. So an expression like `[ x ] * 3` only evaluates the `x` once and then the result is three references *to the same object* it evaluates to. If the object in question is immutable, like a string or tuple or number, that doesn't make a difference,. But if it's a list, dictionary, or some other mutable object, you get the behavior you see here. Everything in Python is a reference, even if it doesn't look like one...
Install a Linux VM on your Windows workstation. Next question.
/r/learnpython
When you install Python make sure to install the documentation. Using Python's window help file is actually great. It is a lot easier and faster to use vs the Python web site. 
Thank you. Why does no one seem to do this? Its always so painful when you go to update packages and someone has pip installed things system wide and noe your package manager barfs on files existing where they shouldn't
Is jupyter notebook not good enough? I only use jupyter notebook. I like being able to run the code in separate cells. Should I look into Pycharm or something 
Most developers here develop on their windows desktop.. The workflow is basically.. * Develop with Anaconda and PyCharm on their desk * Package to an egg or conda package when ready for UAT * DevOps team creates conda env on target server for the app * DevOps team installs package+dependencies to the conda env on said server Rinse and repeat. It's got it's pros+cons, but it's certainly workable. Most of our devs aren't very linux savy, and it makes their life easier, albeit creating some headaches for devops. 
&gt; There's simply no way to replicate the ease of testing locally on a system that's identical to your target environment. Since 3.5 and pip supporting wheels, I feel this is a bit silly. The only major non-multi-platform issue was resolved at that point. python 3.5 is built on VS 2015 and should be forwards compatible from there, and with most major packages being distributed as wheels now, that doesn't even matter, so now everyone can easily have the C python modules automatically compiled with little stress.
&gt; No OSS licenses restrict the use of the software. A clear example of obligations arising just from use would be running AGPLv3 software behind a public web service. As I said, all it takes is one person who doesn't know.
&gt; IT should do it's job and manage a standardized distro for the devs if the IT director is so inclined on risk management. It sounds like they *are* offering a standardised platform for the devs, it just isn't a Linux one. But every extra variation you offer in this context is another system that needs to be supported and maintained. There is probably a sweet spot where reasonably clued up developers have more flexibility than Joe from Accounts who opens every attachment he gets in his inbox, but things are still going to work better if that flexibility is used collaboratively instead of a developer simply deciding unilaterally that they know best and the rules don't apply to them. &gt; It is also unlikely that IT is ensuring the productivity of developers via automated setups for development tools anyway. That depends entirely on the organisation. There's a whole range from clearly separate development and operations teams through to almost total overlap in a DevOps arrangement, and towards the separate end of the spectrum it's probably IT who are responsible for the operations aspects.
Again, that doesn't apply to what you run on your workstation, only what you deploy to customers. You're right, that does technically contradict the statement that I made, but it still doesn't apply in this circumstance, and it applies just as strongly if the workstation is running Windows as it is if running Linux. No OSS license restricts what you are running on your workstation. In fact, most of the software here that people are recommending running on Windows is open source software under a variety of licenses, including just running Linux in a VM. If these suggestions are going to help the OP at all, they are going to have to be able to install the same software under the same licenses they would have been running on Linux, other than the kernel and other systems software. Otherwise, if the OP can't even choose what to run on their workstation themself, then the answer is "whatever your IT department will allow you to run, you should ask them not us."
&gt; Again, that doesn't apply to what you run on your workstation, only what you deploy to customers. This is getting awfully specific now. The original point was that letting individuals choose what software to run without IT's involvement increased the risk of licence violations. We're now at the point of talking about what developers run on their own personal workstations as long as it's OSS and has no interaction with the outside world possibly not being a risk in that respect. Do you really think the numerous commenters in this discussion who are advocating openly ignoring or circumventing company policy would qualify their comments so they only apply in that specific context but they think everyone should follow IT's rules when it comes to other software licences or shared machines? &gt; ...it applies just as strongly if the workstation is running Windows as it is if running Linux. Not if the machines are locked down, it doesn't. That's the point. The question is how much developers can be trusted not to abuse having unlocked machines if the normal company policy wouldn't allow it. And based on the overwhelming preference shown in comments within this Reddit discussion, the answer is not a healthy one in most cases.
Right, because Windows and Linux paths, multiprocessing, forking, and command line interfaces are like, totally the same! Code on Windows and it'll be *exactly* like Linux! Yeah right! Haha. You've obviously never had to live in that kind of hell. The fact that you think having the latest version of python available *is even a possibility* tells me you've never had to write a python script on Windows that *must work* on the different versions of Linux.
TIL
I'm just a hobby coder doing web development type stuff, but I don't have any problems using win7x64. I edit with Geany (which allows you to set the line endings and indent type+width). I use the regular cmd window when required, ie if I want to test out some syntax, or work in a `pdb.set_trace()`. I create virtualenvs, and they are rather easy to use. A `Script` folder is created in the top folder, and this contains some exe's/batch-files such as `activate.bat` (for activating the virtualenv in a cmd window) and `python.exe`. Other packages create scripts in here too, such as Pyramid which creates a `pserve.exe`. I've not had any problems when using these scripts. Installing packages with C-extensions was a major headache the first time I tried it, but I eventually got it sussed, and now it just works. Check out: http://stackoverflow.com/questions/2817869/error-unable-to-find-vcvarsall-bat/27033824#27033824
I'm late to the party, and this is probably the last thing you want to hear, but: consider emacs. The *evil* keybindings supports everything you know from vim and more, and it is ridiculously powerful/productive once you get the hang of it. I use [spacemacs](https://github.com/syl20bnr/spacemacs) (not on Windows though).
where'd you all get the money?
&gt;Quitting isn't the topic there. This reminds me of the [parable of the carpenter](http://weblogs.asp.net/alex_papadimoulis/408925). The short version is, if a carpenter comes to you and tells you that they're trying to decide between using a shoe and a glass bottle to drive a nail, do you a) discuss the merits of the various solutions, i.e. saying that a glass bottle is better for small nails and a shoe is better for big nails and hard surfaces or do you b) tell him that he's doing it wrong and that he should use a hammer? In this case, OP's employer is telling him, in effect, that he has to use a glass bottle to drive nails. You're saying that we should tell OP "how to cope", (e.g. wrap the bottle in duct tape so that when it breaks, you don't get cut by the glass). I'm saying that OP should quit and get a job that allows him to use proper tools.
I'm not getting awfully specific; I'm sticking to the topic brought up by the OP. He mentioned that he is being forced to migrate his workstation to Windows despite deploying to Linux servers, and wondering how to cope with that. I agree you want to apply much more care in licensing for any software that enters production, whether running on your own servers, being shipped to customers, or even any build dependencies for such software. But there's pretty much no good reason, licensing-wise, to restrict the software that developers can run on their own workstation. Now, that's not to say that there's aren't other concerns you could have, like security, ease of management, etc. But I was just replying to the one you were discussing, licensing, which really doesn't apply to a developer workstation; and a developer workstation is the only thing this entire thread has ever been about.
A Foolish Consistency is the Hobgoblin of Little Minds
YES! Su-Doh, like Pee-Doh or Re-Poh. We don't say "sure, you can find that in the apt repoo", right?!
Pathlib was made for a reason, multiprocessing documents the differences clearly, and you can even run curses on windows if you need to. &gt; The fact that you think having the latest version of python available is even a possibility it is. Yes I know package managers lag by a couple of years/centuries, but the concept of freezing/packing exists for this reason. But its besides the point, you can develop in 3.5 and distribute throughout 3.3 to 3.5
OK, but even in the context of workstations, we're only talking about OSS here. Just because Linux and most things you'd install via most distros' own package manager are in practice OSS, that doesn't mean everything you might install on a Linux workstation is. And with most Linux distros, the tools for auditing what is actually installed and managing dependencies once you step outside the distro's own managed packages mostly belong in an era when dinosaurs still roamed the earth, while the business-facing versions of Windows have been dealing with this issue for decades.
It's funny that you mention freezing packages because you can't freeze a Linux python package on Windows!
This is silly. I've been a unix guy for 20 years but MS provides a great suite of tools for development. Visual Studio has always been a great environment to work in and their debugger is *awesome*. Doing Webdev on windows can be a little bit painful because the LAMP stack that's standardized out there (or LNMJ [Linux, Node, Mongo, Javascript] or whatever people are running today) means that you can't replicate a production environment on your dev machine. But otherwise, Windows is just fine, and has lots of great tools... 
In the face of ambiguity, refuse the temptation to guess.
I use PyCharm and have it setup entirely for remote deployment/execution. My Windows box doesn't even have Python installed. I'm fortunate that all of our work occurs on client controlled hardware so this is a viable solution. I live entirely in PyCharm in full screen on monitor 1 and putty windows tiled on another. To the vasual passerby you can't even tell I'm running Windows. All of those crying for managerial heads to roll, insisting you quit immediately, saying it is a sure sign of horrible business practices and work environments... they are just a tiny bit emo. Hell of an overblown knee jerk reaction.
You bring up good points, however I have to chime in as an IT director at a primarily windows centric environment that *also* leans extremely heavily on python (Django is our bread and butter) for automation, analysis, reporting, etc., with the blunt statement that forcing our devs to use Windows only would be the height of pointy haired boss stupidity. We would lose major productivity, which means money.
I'm assuming this would be against the "windows only" edict but if it's not then this the way to go. I spend my working life on a Windows 7 machine using PuTTY to ssh onto a Linux VM running on the same machine. I use vim within the VM for what it's worth but I could equally use some sort of graphical editor.
The official tutorial worked well for me.
&gt;It sounds like they are offering a standardised platform for the devs, it just isn't a Linux one. No they're offering a standardized platform for everyone in the company, the dev platform is an afterthought. &gt;But every extra variation you offer in this context is another system that needs to be supported and maintained. There is probably a sweet spot where reasonably clued up developers have more flexibility than Joe from Accounts who opens every attachment he gets in his inbox, but things are still going to work better if that flexibility is used collaboratively instead of a developer simply deciding unilaterally that they know best and the rules don't apply to them. No one cares, you're "fixing" what isn't broken for an entire department that is the lifeblood of company revenue most likely. Nobody cares that IT's job is easier when you've retooled SE workflow because you needed to be able to administer the machines better. Do you job. Support users, don't bitch that it's hard, don't bitch that everyone is being a primadonna. Support users. If the dev team needs linux to do their job effectively they need linux to do their job effectively, they aren't going to do that same job with the same effectiveness if you give them Windows. &gt;That depends entirely on the organisation. There's a whole range from clearly separate development and operations teams through to almost total overlap in a DevOps arrangement, and towards the separate end of the spectrum it's probably IT who are responsible for the operations aspects. No it doesn't that's a bullshit copout answer. The system was in homeostatsis of performance, you changed the system without caring about performance, people now have to retool because of you, certain workflows no longer work, certain workflows will never work anymore, and certain things will take longer now. You have altered the software development process. You kill the software development process of the company you kill the goose that lays the golden eggs. That's great that you can still do DevOps, I'm glad for you but you turned around the entire dev team gave them new arbitrary tools that you picked and still expect them to preform the same? That's bullshit pure and simple. You can't give a man a claw hammer and tell him to cut a 2x4, because you can use the back of a claw hammer as an impromptu axe. Speaking as a person that's been on both sides of the equation, IT doesn't care cause it doesn't affect them in a negative way. If the SE team had picked out machines and software configuration for the IT team and forced a workflow on them that the SE team chose the IT team would react in the exact same way. I understand the need to manage backups, ensure productivity, and protect company data. I do. But doing it this way is entirely box checking bullshit that will slowly kill your dev culture, will lead to lower productivity, and will lead to worse hires. You either ask the development team what they want, and come up with a compromise and work towards that, or you do your corperate bullshit and watch the good team members leave after you've given them whatever the fuck you thought was good enough for them.
A four man IT team can handle Windows, Linux, Mac OSX, FreeBSD and OpenBSD. I know this from experience. This is just laziness. It takes maybe two or three weeks to set up a good puppet config for all of your Linux boxes, get it tested, and get it running in a server. This is just asinine. Just like assuming that anyone using Linux can install whatever that want is asinine. 
I would guess IT *is* operations in this scenario, and frankly if you have a development team who's primary focus is python, forcing them to use Windows for development is the height of stupidity unless you at least give them VM capability of some sort. My devs have a standardized Ubuntu 14.04 image with virt-manager baked in and home directory on NFS. They are *much* easier on our IT resources then, say, the finance department with 7.
&gt;who's testing all of that software first to be sure it is secure and isn't conflicting with anything else used at the company? Bitch please. These people have virtually unfettered access to your production environment. Does the IT Team do Audits of the SE's work? Do they make sure that the SE team isn't putting a netcat like endpoint in the production code protected by an admin api key? Stop worrying about their machines for a second and realize how silly you're sounding. You implicitly trust whatever software they write on your mission critical systems but you don't allow them to select software of their choosing.
I replied to your survey.
I use winscp to keep the remote (linux) directory up to date. Every change I make in windows gets pushed over and compiled.
Visual Studio *is* pretty fringe for python.
I had no idea, this is awesome. Have my upvote!
Out of curiosity, which did you pick? I'd have gone with a Macbook, after using the 2010 one for my studies I've gotten used to it.
No. Like the web framework.
It still sucks compared to Linux but you can use Pycharm with remote server. you code on windows and your program run on the remote server. 
I may be a weirdo but I find map and filter to be way more readable. I use the list comprehensions because they are pythonic but it makes my code a little more hard to grok when I'm sharing it with beginners.
&gt; I think it is fairly obvious, but so many people are still getting it wrong. Including the developers... but luckily OP is here to set them straight :) "SciPy (pronounced “Sigh Pie”) is open-source software for mathematics, science, and engineering." - http://docs.scipy.org/doc/scipy/reference/
Virtualenv is not a security measure in theory, but it is in practice. A package you install in virtualenv, as your user, will have the security attributes of your user, which is how unix security is designed. You will be able read files, have access to the network, etc according to your permissions. As others pointed out, installing python packages system-wide is a bad idea unless you really know what you are doing.
I don't think you're going to learn much from this survey. There aren't many questions and the answers from which to pick are too limited... &gt; I do not care if you do it for hobby or professionally You're missing open source contributors. And missing a survey question about what sort of coding is being done: hobby, open source, profession. You might not care about the type of coding, but the coders care, and it's going to be reflected in how and why they comment / document. &gt; Your comment style Missing "docstrings" and "machine-readable documentation" a la doxygen. Also missing "my code is its own documentation". &gt; Do you have any distinctive documentation habits Documentation != commenting. There's requirements docs, architecture docs, design docs, etc. 
This looks like it could really enhance my workflow, thanks!
A piece of python software in a venv is a singular, existential thing, that exists on one person's computer / VM / vps / etc. You may *recreate* a copy of that venv using a requirements.txt (at least in regards to the python environment). A python *application* is a nebulous piece of software, that anyone can install. It probably exists in PyPI, but it doesn't have to. And the requirements it lists in `install_requires` are the things it needs to be able to run. Sometimes, these two concepts are very very similar, almost indistinguishable. Sometimes, they're quite different, and you can notice the difference. An existential venv might be used for running a production web application on a particular VPS. That is a single instance of python web software. However a python application, like pygments, is an application anyone might want to install. It isn't a venv, users won't normally want to know anything about a requirements.txt for it, they just want to install it and have a binary to run the application.
Here's how you know: the ID of each nested list is the same. &gt;&gt;&gt; foo = [ [None] *3 ] *3 &gt;&gt;&gt; foo [[None, None, None], [None, None, None], [None, None, None]] &gt;&gt;&gt; [id(bar) for bar in foo] [140677445287448, 140677445287448, 140677445287448] 
Pycharm and remote interpreter to linux virtual machine 
 grid = [[None for c in range(3)] for r in range (3)]
Yeah, went with the MacBook. That's what I am most used to. 
&gt; Including the developers... Quite so. But they have done very good work otherwise, so I am not going to hold that one mistake against them. Are you?
Nah, I'm going to continue to assume you're talking about something other than the Python package. They're talking about pronouncing 'SciPy,' while your post is about pronouncing 'scipy.'
You should be testing it yourself, especially if you're not going to be posting the source here. Should let people review it at least before asking random people to actually try it. Code review may highlight problems... like problems that would alert SW to the fact that a program is doing the check in, rather than a person, which is against the rules.
Thanks. I just wanted to show how powerful [ripozo](https://github.com/vertical-knowledge/ripozo) can be. Which, quite honestly, is a shameless plug.
The best part of this is the point that you can insert line breaks to make a comprehension more readable: doubled_odds = [ n * 2 for n in numbers if n % 2 == 1 ] Imagonna do that all the time now. 
&gt; It's not that hard if images are standard. Sure, but it's probably still several times harder with five possible images than it is with only one. Whether that extra cost would be justified obviously depends on how much marginal benefit the users get from each additional option and how much extra risk each option introduces.
raw_input() just returns a string; no evaluation of its meaning takes place. It is safe ... unless there is something like a length limit which might trigger a buffer overflow, but I have never heard of such a thing for it.
Use a virtual machine running linux on the windows host they give you.
Do you have a link to the bug report?
Special cases aren't special enough to break the rules.
The targeting Linux but being forced to develop on Windows is the strangest policy one could have. Testing you apps or web services on Windows is one thing but being forced to develop for Linux on Widows is asinine. If the company was targeting Windows this would be a different conversation. As for developer quality that will suffer if this policy is well known to possible new hires. Some things just rub rational people the wrong way. 
This is great.
emacs works fine on windows, and as a python dev environment. Also, show your management this thread and point out to them how self-destructive they're being
Use cases like that are why click has context locals
I probably wrap them when they comprehension itself gets to 30 or 40 characters. I'm assuming I tend to wrap list comprehensions a little more liberally than most though.
what's so hard about using notepad++ to develop code, and using git to push it for testing? What am I missing? Or using VMWare on your desktop? You're being melodramatic. 
Thanks, I may look for the second edition :) Or is python 2 better than python 3 ? I see that a lot of tutorials etc are for python 2
Interesting. I'm fond of `map` and `filter` in OO functional programming (like `array.map(...).filter(...)` in JavaScript). But I find the order of the words in the non-OO functional style a little counter-intuitive personally (`map(..., filter(..., array))` doesn't work well with my head for some reason).
I saw it but didn't think it was this great, I'll see :)
Although practicality beats purity.
Yeah, between standard permissions and selinux, I'm very skeptical of the dangers of rpm, deb, or pip installed modules. At least those from the standard repos, rhel, centos, fedora, epel, etc
Seriously, tell everyone you know. Sydadmins will rejoice everywhere.
Nope. Plenty of ways for smart dev to spill IP. Never heard of a dev do a risk assessment, ever.
I have done both. Sorry you are talking utter rubbish and practising some sort of advanced snobbery. Install something like cmder, the GNU tools, make sure you have the right compiler and libs, install git, install your favourite editor and you are done.
Definitely Anaconda makes it easy to install Python libraries that have other (non-python) dependencies on Windows. And even though the full Anaconda distribution comes with lots of packages, you can use Miniconda to just install the ones you need.
Oh I know, my company gives us only Windows with no administration rights and a filtered Internet. I'm not a developer but an engineer though, I code for data manipulation mostly. It's a pain in the ass, but I can cope. I use Anaconda (no admin rights necessary) and my phone's data tether when I want full Internet access (but then I lose company ressources so it's not often). Most of the time it's fine, but really it's not the reason I work there. Still, there are very good reasons, and I'm not going to quit just for some tools. Also, one of the reasons companies filter the Internet is to avoid employees uploading company data to any third party (even for innocent reasons, it can happen). There's no reason for them to trust more their developers than others. 
And I'm saying that if you choose your company only based on the tools they use you don't have a really good career view. 
Ok get it. Have a good one buddy !!!
Depends where you live, job ads in Norway (Oslo area) with Python even mentioned? about 5-8 Ads that are specifically for a python dev? I've seen one in the past 8 months. ( And I almost got that one with basically no experience aside from a month of home stuff) So yeah Python is very much a thing in areas with lots of startups, not so much elsewhere. (or so it seems)
Simple solution: don't run the latest shiny version. Run a long-term support release. You wouldn't run Windows 10 Beta in the office. 
Of course. I just wanted to counter the impression that it is normal behaviour.
I'm not a Django user but, damn, their release notes are an example for every project out there. Stunning.
Just took a few screenshots: http://imgur.com/a/jE6Uk
Can you show a plot explaining what this generates?
That's how it should be. Sadly, it's often not.
I've used pycharm and vagrant before. It worked ok, but I had few issues, mostly with Mercurial. 1. I needed this extension: https://www.mercurial-scm.org/wiki/Win32LongFileNamesExtension 2. We had 2 files with the same name, but different case. Hg failed to clone as a result. 3. Compiling certain python modules isn't intuitive in Windows. I needed to use easy install instead of pip, or something like that, to get around it.
Oh wow. This is nice!
/r/learnpython
:D
&gt; Some people reading this are probably thinking right now that they are the exception. I wonder how many of them would be willing to bet me the cost of a day of downtime for their whole department that they've never done something potentially risky at work People do risky stuff at work in Windows environments too. I would even wager that the average Windows-bound employee does *more* risky stuff, after all corporate IT has their back. Also, even with full root access to your local machine, causing a full day of company-wide downtime on a properly secured network is still an impressive feat. &gt; like say downloading a package from an insecure source and running it without checking the hash against a trusted source first Whenever possible, I install from Debian repos, which apt automatically verifies against a web of trust bootstrapped from keys found on the install media, which in turn I verified against checksums obtained from the official Debian website, over HTTPS. Unfortunately, when it comes to programming, this isn't always an option, but when it's not, the same applies to Windows, so the fact that I don't run Windows changes absolutely nothing here. I try to be as diligent as possible when that happens: I avoid installing as root (installing into a single-user sandbox instead), anything that looks somewhat experimental goes into a VM (in fact, much of my development happens in virtual machines), those VM's have *two* virtual network adapters each, one host-only for inbound connections, and one NAT for outbound, properly firewalled off so that the world cannot talk to my VM, I enable TLS and signature checks for all package managers that support it, I prefer ones that do, and I do at least a quick review of much of the code I install from source. Installing from source, btw., always almost means that I'm using git over HTTPS or SSH, which is not as good as signed packages, but at least prevents the most common and most obvious attacks. It is of course entirely possible for github or whatever hosting service they're using to be compromised, or for someone to register a legitimate-looking account on github to circulate compromised code, but the risk, I believe, isn't overly large as long as you cross-check the git URLs against the project's official website (served over HTTPS), at least if it's a somewhat mainstream project. And, again, if I were to develop on a Windows machine, the situation would be *exactly the same*. &gt; or running an installation process for a cool new tool they just found on a totally legitimate-looking website somewhere that involved the characters sudo or | sh without carefully analysing it first and checking third party sources to verify legitimacy `curl something | sh`? Never. I actually got into mild trouble at a previous job for refusing to install PHP's `composer` tool that way. &gt; or using a personal device or VPN to bypass the usual corporate firewalls and security checks. I never use personal devices on work networks without sign-off, and when I do, I subject them to the same policies that are in place for work machines. Simply because when shit hits the fan, I want my ass covered. &gt; I'm guessing every single person reading this would lose that bet. Did I lose the bet? &gt; There is a balance to be had between giving developers who are generally technically competent the ability to choose good tools and giving IT people who are responsible for the security of the whole organisation the ability to choose good tools. "Carpenters, from now on you will use foam rubber hammers instead of nailguns. Nailguns are dangerous, we cannot allow them." Yes? Or maybe this: "Carpenters, nailguns are dangerous, so from now on, you need to take a mandatory nailgun security course before touching them." In other words, yes, it's a balance, but IT should not get to pick the tools. IT gets to set (and, where possible, enforce) policies, veto stuff that is positively problematic, and otherwise give people what they need. A situation where IT has unreasonable policies in place is exactly where and when people will starting looking for "workarounds", and those workarounds are usually a lot worse than giving them what they need in the first place.
You can use a linux virtual machine on your windows.
Not that I know of. It's been on my mind.
Can WinSCP be set up to monitor files and keep them in sync? How does it handle files with restrictive permissions (for example `rw-------`)?
&gt; and this is probably the last thing you want to hear not quite. I *have* been considering giving emacs a go. I don't know anything about it, and I should not dismiss it as a viable choice. I can only decide this for myself once I tried it. How about editing remote code? I know vim can do this, but in my experience it's not quite the same thing as the vim environment is still local, so you don't get good access to ctags, shell environment and so on.
My primary concern is actually that on Windows everything is very GUI heavy. I'm way more productive on the console. And PuTTY has been - in my experience - one of the worst console experiences I ever had. It fusses about with function keys (IIRC, F1-F5 are fixed to PuTTY), so I can't use those for bindings in my editor, it does not properly set the terminal environment, has some problems with special characters because of that, getting 256 colour support running inside tmux also has been painful. All-in-all, my best terminal experience in Windows has been so far by installing Cygwin/X and running a local xterm.
This and the fact that they are so good at handling deprecated features is why I love Django. It really makes a difference and puts a lot of other projects to shame. 
But would I be able to connect to the proxy server? It's not whitelisted. Also https is broken by the filters anyway, they replace by their own cervicate.
I realized that you are right I should have been more specific. What I meant was for the front end html to be able to call a python script based on a user's input.
Thank you very much for the Celery suggestion. I will have to look at it.
Learn 3 first then 2 if you *must*
Ok thanks
Unfortunately, the market around here is less Linux friendly. Especially if I'm aiming for something that pays similarly well as my current job.
OK, I put up a link everyone :) https://drive.google.com/open?id=0B8o9KLgYlKGwem00c1U0X1NsNDQ
The main reason is that they want to have a homogeneous base for the managed PCs. That way, the central IT team - as they are badly understaffed as well - only have to deal with one specific setup, and don't need to keep up-to-date with security issues and whatnot for different platforms. I can understand that, and I support this decision to some degree. Especially when dealing with your run-of-the-mill John-Doe-Random-User. What I have more trouble with is that they don't even have limited support for other platforms, as long as the end-user is computer-literate enough.
You've got my vote, but unfortunately it's not me you have to convince, it's every developer in your organisation who has the ability to install whatever they want. As my American friends like to say, good luck with that!
Wut sorcery is this?
I've had a quick glance at msys2, and what this fails to mention is "what" it is. Is it a unix-shell like Cygwin? And, does it have an X11 server? I think I'll give it a try, but I'm not quite sure what it is ;)
thanks a lot, I saw plenty of such programs in codewars.. my solution was several lines and top answers were 2-5!
&gt; The just-announced Eclipse Che is essentially Codenvy This looks really nice. I will look into that. Thanks for the suggestions. &gt;a headless VirtualBox server I did not think about that. That's a great idea!
Why downvoting? You answered the question! I will note this down. It is however a bit suboptimal as the production servers are running Linux. So the dev environment would become very different from prod. I like to work remotely on a development Linux box. But quite frankly, there is no good terminal emulator on Windows (haven't tested cmder yet though). So I have to find a workable alternative.
Yes, it is a distribution of Unix utilities, including a shell and various other tools, that run on Windows, much like Cygwin. The advantages of msys2 over Cygwin is that Cygwin does things via a POSIX compatibility layer that is fairly heavyweight, so some tools in Cygwin can be significantly slower than the one ones in msys2. msys2 is a fork of msys, which uses MinGW, the "minimalist GNU for Windows" project, that provides a much more minimalist approach to porting GNU tools to Windows, using native APIs when possible rather than emulating POSIX APIs. The other advantage that is unique to msys2 is that it uses Pacman as its package manager, rather than the graphical installer that Cygwin uses or the custom mingw-get used by msys. msys2 is more minimalist than Cygwin however, so it doesn't include an X server. For that, you could grab [xming](http://www.straightrunning.com/XmingNotes/). Basically, Cygwin provides a wider variety of software (it has its own X11, it has editors like Emacs and vim) via a POSIX emulation API, but it can be somewhat slow sometimes and also sometimes interact a little bit oddly due to this emulation. msys2 is more minimalist, only provides a smaller number of command line packages, but is faster and (I hope, haven't used it enough to say) fewer compatibility headaches, and you can supplement that with other native ports of packages like xming.
Thanks for the suggestions, I will certainly give PyCharm another go. I've done so in the past, but there were just too many things nagging me compared to vim. I'll try to touch on your last paragraph: To me, vim is not an IDE, but a text-editor. A damn good one. And in the end, all I do is edit text. One of the most missed features in other editors/IDEs is the way I can navigate through source-code without using the mouse. In just a few key-presses (usually less than 5) I am in a completely other file or even project. And usually right where I want to be (thanks to ctags and CtrlP). It really feels like teleporting through code. Most people, when using vim completely miss out on the many navigation shortcuts. They seem useless at the beginning, but they are - to me - what make vim so great. If using the right shortcuts, the "back button" (CTRL-O) becomes impressively useful, and you fly through your code. This is very important to me, as I can keep my mind focussed. Vim allows me to move as fast as I think. I can't say the same about other editors. Most IDEs/Editors have a good deal of the features of vim, but qre quite simply no on-par. It's either slower, less powerful or more difficult to access. Some of those are: * on-the-fly macro creation/execution. And also being able to later edit those macros if need be. * quick wrangling of multiple lines using `:norm` (nearly impossible to explain until you used it...) * Window/Buffer management (including splits and tabs). * custom mappings (in vim you can do crazy magic with that). * mappings which shell-out to a terminal and do even crazier things. * filtering files through external commands. * consistent behaviour. * editing modes. This literally explodes the amount of shortcuts you have at hand. In normal-mode, every key becomes a powerhouse. * Undo tree. * repeating common edit operations (`.`). * on-line help
Check out [Python Anywhere](https://www.pythonanywhere.com/)
thank you!!
there are a lot of django apps that redesign admin interface and although it is nice, people who wanted a nicer interface are already using third-party apps 
https://xkcd.com/353/
[Image](http://imgs.xkcd.com/comics/python.png) **Title:** Python **Title-text:** I wrote 20 short programs in Python yesterday. It was wonderful. Perl, I'm leaving you. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/353#Explanation) **Stats:** This comic has been referenced 193 times, representing 0.2133% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cxkdif8)
&gt;I wouldn't stand for this, if they value their developers then you should be able to escalate this matter. Aww you devs, such special snowflakes! So much better than the other stupid-head drones, eh?
 If you are about to ask a question, please consider r/learnpython. Homework-style questions will be removed, and you'll be encouraged to post there instead.
&gt; If you really are that careful, then I admire your diligence and I hope any sensible IT department would also recognise it and act accordingly. Should be the norm, but sadly, it's not. Luckily, I'm also good enough at programming to get to pick my employer... &gt; I think it is also fair to say that you are exceptional, and I'm guessing you are not the kind of person who would unilaterally decide to ignore IT's policies rather than trying to work with them constructively. It goes hand in hand, but if IT were to make my life impossible, I'd escalate, and, worst case, find a better place to work. I would most certainly not go rogue, that'd just be too likely to backfire. It's not even work ethics or anything (though I have a good deal of that too), just me not actively trying to get fired.
Thank you for the extensive reply. I've installed it earlier today and I really like that is has pacman. It's a bit unfortunate though that it does not have an X11 server. I have worked with xming, but have switched over to Cygwin. Cygwin has *much* better font rendering, and other things work much better as well. Some coworkers are running xfce4-panel for example and Cygwin does a much better job at detecting multiple monitors. In general I have no problems with Cygwin. The speed never annoyed me. msys2 looks nicer, and pacman is really cool too (especially as I'm already familiar with it). But no X11 is a bit of a show-stopper. I will continue using it though for a couple of days to give it a fair evaluation.
I don't get it. I googled "REPL" and found an online interpreter, so that's cool. I tried import antigravity in the Python 3 interpreter, and it complained about Traceback (most recent call last): File "python", line 1, in &lt;module&gt; ImportError: No module named 'webbrowser' I feel like I'm missing out on something awesome!
About time I would say that py2 support is dropped.
It boils down to two application types: * back-end REST services. This, I can see developing local on Windows * SNMP clients. This I can't...
&gt; Provide arguments for the use of Linux as primary OS and see if they can make an exception I'm currently working on that.
There are some essential parts of microservice architecture: 1. is that you cannot avoid proper versioning anymore, which leads to the need to have proper deployment scripts, to have the knowledge about which service version is compatible with other services, and so on, and 2. is that you must make your apps configurable. Right now you've showed how to write a couple of flask-based applications and how to run them on a single server, without proper daemonizing (i.e. without proper sysV/systemd/upstart service scripts), without "configurability". More than that, you didn't even separate them as packages, you cannot install one service without installing others. Sorry, but this is really bad example. Everybody who find this attractive, please, don't write your applications like that.
It feels like incorrect English when read on a single line, but if you start inserting newlines it makes them consistent with regular loops: [(x,y) for x in [1,2] for y in [10,20]] for x in [1,2]: for y in [10,20]]: (x, y) I almost always insert newlines in comprehensions with multiple loops for that reason.
Most places don't just let developers to go buck wild with unfettered access to production. That's where the devops/sysadmin team comes in.
You still don't understand. What are you as a devop/sysadmin doing about code that I may be introducing to the product that allows me to esclate my priviledges on the machine? More than likely you aren't doing anything. Let me repeat once again: you implicitly trust whatever software they write on your mission critical systems but you don't allow them to select software of their choosing.
History: https://hg.python.org/cpython/rev/3ff7bb830519 http://svn.python.org/view/python/trunk/Lib/antigravity.py?view=markup&amp;pathrev=66902
I think my permissions are already OK. I realize this is quickly getting off-topic, but I appreciate your input. I'm a long time linux user, but not much of an admin... john@colfax-ESC1000-G2:~/Documents/software/nuke$ ls -la total 3049848 drwxrwxr-x 2 john john 4096 Nov 30 21:39 . drwxrwxr-x 11 john john 4096 Nov 16 18:17 .. 
I bet you were written in python.
Js heavy sites are even easier to parse than server-rendered ones, just open up the debug tools and copy the requests that js I'd making. Then you don't even have to scrape. Or am I missing something? 
The difference between threads and processes is very important. Here is some info on that: http://stackoverflow.com/questions/1762418/process-vs-thread Edit: also your gevent link is broken.
Do not run python as root.
I'm in a process of migrating 1.4 to 1.8. Release notes are indeed very good, better than most out there.
... ... ... Well that's a new kind of special...
Yes. I never think of list comprehensions of being line-wrappable, but this is a much cleaner way to break them down to make sense or show someone else. Definitely going to start doing this...
direct link to the github [repo](https://github.com/gboeing/cp255-materials/tree/master/Examples-and-Demos/census-rents-2014)
My work environment is like this and I don't mind it at all. I use emacs as my primary editor, so just having ssh to linux dev virtual boxes is good enough for me. I used sublimetext for a while, and yes, xforwarding makes it worthless. We solved this by having file shares which were mounted into our home directories in our dev environment -- local sublimetext editing shared files which were executable in our "remote" dev environments. It was pretty painless (and this is coming from a huge linux fanboy). If they take away your linux dev boxes, fuck that shit
D:
&gt; You're missing open source contributors. I took it... Really, the big issue is I want to give multiple answers for many of the questions. It depends.
Only started using Python and Django lately. Very happy with how easy upgrades are!! ☺
ok sorry haven't used docker with windows... it has a slightly strange syntax. `docker run -v /c/Users/&lt;path&gt;:/&lt;container path&gt; ...` http://docs.docker.com/engine/userguide/dockervolumes/ I think that should share that directory with windows and the docker container I like docker. It's like a virtual machine with a bunch of productivity stuff on top that gives you fun easy linux.
No problem, Enjoy :-) 
&gt; I took it... This isn't about you. It's about the question missing from the survey.
[](/sbstalkthread)My pleasure
&gt;&gt; The C++11 hash tables (std::unordered_map, etc.) do not specify implementations, but the interfaces are clearly written with open hashing in mind. &gt; How so? There is an interface for examining a single bucket. You can get iterators to the beginning and end of a bucket, get the number of keys stored in a bucket, etc. (See [std::unordered_map on cppreference.com](http://en.cppreference.com/w/cpp/container/unordered_map), and go down to "Bucket interface".) None of this makes much sense if closed hashing is used. (EDIT. I suppose it does not *preclude* closed hashing, but it does suggest that the committee was thinking of open hashing when they wrote the interface). &gt; Looking at other languages/implementations, Google's hash table implementations for C++ use closed hashing. .NET generic dictionaries too (while older non-generic Dictionary used open hashing like Java). Ah, I didn't know that. Thanks for the info.
Good find. I didn't know the CPython source included justifications for design decisions. So apparently one important reason is that Python hash tables are often very *small*.
&gt; import this Is also a nice gem.
&gt; Cache-line performance is the primary reason. Python's dictionaries are some of the fastest hash tables in the interpreted language business. Okay, but this (and the similar info from /u/fullstack_dev) raises another question: why do Perl and Ruby and C++ use open hashing?
Probably because closed hashing performs poorly in certain edge cases. If your webserver starts resizing an array it's going to be unresponsive for that moment or worse will lead to thrashing. If you already know the size of your data or care more about throughput than latency(e.g scientific data crunching) then this won't matter much to you.
As with everything, what you use is highly dependent on what you want to do. So what do you want to do? If you just want to learn, then use them all. Write a wrapper that abstracts away the library, then try each one in turn on some parallel operations. Find out what you can and can't do with each of these: can you share data? Pass messages? Signals? Throw some instrumentation in there and see how much overhead is incurred by each. Write some racy code and see how easy it is to induce race conditions. If you have a specific use case, out with it already! In quick summary: because of the GIL, there is no true threading in Python. Hence, thread and gevent offer roughly the same functionality, though gevent is much more lightweight (one can spin up greenlets much more quickly than threads). One should prefer threads / greenlets over multiprocessing when her code is largely I/O bound. Multiprocessing is even more heavyweight than threading, but it offers true parallelism.
It is swings and roundabouts on either platform tbh. The one I really dislike dealing with is the JDK on Windows because it installs all the other crap that Oracle like to bundle where on Linux you can use the OpenJDK. Most of the other cross platform stuff is simply just fucking googling it. It pisses me off how people are more into whining than actually solving problems. Also if you are having problems with windows with a particular language or project that is open source ... shock horror .. you can report it and make life better for everyone.
Suck it up and grow a pair!
That's the thing; we didn't. Although, some say they can. That's why I used a Windows box with my actual work machine in a VirtualBox. I just use NAT to connect the VirtualBox to the network provided by Windows which is connected to Pulse. 
You may like Babun. Cygwin but better. [Babun](http://babun.github.io/)
Not tried visual studio code, but I have tried community. Personally, I like it. But I always have liked Microsoft IDEs. However, I do have a license for pycharm, and prefer Linux for development, so I don't use it everyday. If I was forced to use windows for development, I'd certainly consider it.
&gt; Probably because closed hashing performs poorly in certain edge cases. Right. The C++ culture certainly attaches greater importance to worst-case performance than Python does. (Not sure about Perl &amp; Ruby.) Thus my quotable saying: "Don't program a pacemaker in Python."
&gt; gem What is this, /r/Ruby?
[yes](https://github.com/JeremySimpson/redditbot)
Decision trees are probably the weakest machine learning tool in the sklearn library. But they are just about the only tool that you can actually visualize. It would be impossible to visualize a support vector machine in 500 dimensions. Although I wish you could. Cool tool. I'll try it out tonight.
Quantiacs is a marketplace for user generated quantitative trading algos. We connect them to capital from institutional investors. At the moment we work with a few selected investors with whom we have business relations. We will open up to external investors early next year. TIP: If you are interested it would be a good time to submit your now. Here is why: Investors are looking for live track records of systems. Means, trading systems simulated on live trading data for min 3 to 6 months. They don't care too much about your backtest results. So to offer an attractive system to investors, you need to include the time to build this live track record. I guess, I ran off the track a little.
https://aws.amazon.com/free/ 
I don't mind the rudimentary aspect at the moment and I am hoping it will get a linter, intellisense and some other tools eventually for Python. As far as indenting, when I upgraded to VS Code 0.10.1/2/3, the auto indenting went away. Do you, Meefims, have an issue with that using those beta releases? Thanks.
Thanks! *runs off to play*
Can someone ELI5 why the transition to Python 3 turned out the way it did? Why did the big popular packages take so long to upgrade?
I think your issue here is the line "order += choice". A string is an array of characters. What that line seems to be doing is concatenating the list of characters onto the end of the current list. The 'append' function is what you want to use because that will add the entire object to the end of the list rather than concatenating it. Hope that helps.
don't run anything at root if possible.
First, you should format code for Reddit by putting 4 spaces in front of every line - it is very hard to read your code otherwise. The problem in your code is "order += choice" - this interprets the string on the right as a list, and appends each element, which is probably what you would want if you were combining two lists ("blue" + "yellow", or [1,2] + [3,4]). Here you probably want to be doing "order.append(choice)".
Because it wasn't backwards compatible. The syntax changed and behavior changed, requiring huge amounts of testing. It was also a chicken and egg problem. Many people weren't moving to python 3 because the library support wasn't there and there was no real benefit in converting existing non-library code, and python 3 still isn't anywhere near a standard install yet. No user push, no reason to spend massive amounts of dev time. Even today, if you want to cover the highest install base, you'll write python 2.x compatible code (library or application), which means you can't take advantage of any of the 3 features. :-\ For any of your greybeards out there, has there ever been a not-at-all-backwards-compatible language update of this magnitude before, without calling it something different (like c to c++)?
The biggest hurdle seemed to be the transition to Unicode as the internal format for strings. I'm only a light hobbyist myself, so I don't know all the gritty details.
Exactly. I've found CPython source very instructive and quite easy to read, it helps understanding what's done under the hood. Since then, I tend to see Python as nothing but a big C wrapper (which might be wrong). Different topic, but you might be interested in knowing why they chose their hash function to be very regular ([link](https://github.com/python/cpython/blob/master/Objects/dictobject.c#L89)).
Maybe I misunderstand what we're looking at, but there are python 3 ports on Github: https://github.com/davispuh/MySQL-for-Python-3 
What are people planning to do with larger company projects? Stay on the 1.8 LTS or move to the new hotnes which is 1.9?
C++ is ~~entirely~~ backwards compatible. Functions are different, and most have c++ alternatives, but any valid c call works in c++ (to my knowledge). EDIT: I was wrong! Thanks for all the replies! 
I started grad school in 2009 and got into Python around that time for the same reason (also, because I got badly burnt writing my master thesis scripts in Perl). I might be mistaken, but I'm under the impression that, while back then the computer-nerds in the lab were using Python, now everybody at the lab is using Python. So it might be that there has been huge progress, but we were already there before.
&gt; We've learned our lesson (though we're in much better shape than Perl :-) Can some Perl people explain this?
Thanks for the tip Sir_not_sir, however, I have that installed but it does not handle auto-tabbing. Actually I am not sure at this point of what MagicPython does. 
Yeah, I'm poking around the web trying to learn a little more about the problem. Someone posted a solution: sudo chown -R john /home/john ...but I'd like to know a little more about how/why my system is screwed up before applying that fix.
Or you can use the official MySQL driver for Python: https://pypi.python.org/pypi/mysql-connector-python (I've reported bugs for it so thats how I know it) 
Indenting is working great for me.
Perl 6 was first announced in 2000. They not only decided to break backwards compatibility with Perl 5, but also to re-design and re-implement the whole language. After endless bikeshedding, several incomplete implementations of compilers and VMs, promises of releases that were not met, and the stagnation of Perl 5 development, the community started loosing faith in Perl and many of them abandoned the language. Some of the remaining users decided to continue Perl 5 development and started to release new features and improvements for Perl 5 instead. The community broke in two. Now after 15 years, the first version of Perl 6 is going to be released finally. However, the Perl community is not only much smaller than 15 years ago, but it's also split between those willing to continue with Perl 5 and those wanted to push Perl 6. They don't call it the next version of the language, but rather a new "sister" language. They even have different web sites for each language.
malloc() has vastly different behavior in assignment between C and C++. In C you can assign the resulting pointer from a malloc to any type and it won't give it a second thought, but ``char * myStr = malloc(200)`` will throw a compile error due to a type mismatch, you would need to do ``char * myStr = static_cast&lt;char*&gt;(malloc(200))``. While a lot of C code *can* be valid C++, the compiler is a lot stricter about typing (whereas types in C are mere suggestions a lot of the time...). When people talk about using C "code" in C++ most of the time they are just compiling it using a standard C compiler and then linking it in, because C++ can link against C without any issues, but compiling C is a different story.
This is not true. Most real-world C code does not compile as C++ anymore. The main cause is the return type of `malloc`, which is `void *`. In C, this can be converted automatically to any pointer-to-object type (and omitting the cast is common). In C++, you have to specify the cast, or you get a compile-time error. There are many more obscure differences, too, not just the additional keywords. And on non-Microsoft platforms, you have modern C code with VLAs and designated initializers (the latter aren't even supported in GNU C++ as an extension). Even the upgrade from C++98 to C++11 is not entirely seamless. Some constructs changed semantics in subtle ways. Too much C++ code does `using namespace std;` somewhere (the equivalent of `from std import *`), and this means that most additions to the standard library are not entirely backwards-compatible in practice.
https://en.wikipedia.org/wiki/Perl_6
As someone doing bioinformatics with a lot of ascii-based formats, unicode is at best irrelevant and often inconvenient. Fortunately they moved towards parity in the functions bytes and str expose. I think only .format is lacking for bytes now.
You'd be using new/delete instead of malloc/free anyway...
The trouble with setup.py: if either restricts requirements, or is too unrestricted. Example: 'django==1.8.7' means that if you distribute, you'll miss the bug/ security fixes from django 1.8.7+ If you ask for 'django&gt;=1.8.7' then some future version of django might break backwards compatibility. You will NEVER know when stuff in the future breaks your code. If you ask for 'django&gt;=1.7,&lt;1.9' maybe you're fine, but maybe your code WILL work with django 1.9, so again, you're excluding the goodies. And also, maybe 1.7.2 breaks your app (because of a regression) - this is less likely though. I saw a nice pattern where you provide a requires.txt with every dependency pinned (using '==') BUT ALSO specifying the `install_requires` key in setup.py BUT with no version specified for anything (maybe only '&gt;="). This way, you can allow your users to upgrade/downgrade the requirements, if necessary. This also allows them to install the reccomended requirements, from requirements.txt - those are supposed to be some requirements versions you're highly confident will work.
C++11 and C++14 have some significant breaking changes over earlier versions of C++ and won't build. In addition, you can't trust C compiled under C++. Even if it builds (which it probably won't for a non-trivial program) the behaviour can be different. For example the size of some types (char constants?) is different so what can work in C will just segfault or corrupt data in C++. `sizeof(char)` would be 1 in each, but `sizeof('a')` is either 1 byte or `int` depending.
We're talking about how a C++ compiler views C code, and there is no new/delete in C code.
I can only say *anecdotally* that I, and my colleagues, have only just started to make the transition away from Matlab and to Python. But this is super, super anecdotal! I am looking at a very small sample size that is also not really independent of each other. I will say though, I regret not doing it sooner. I still find myself loading up Matlab even though I have ported a good number of stuff. In many ways, I am just faster there. Most of it is experience, some of it is the language and documentation itself. Actually, a good bit of it is simply that I am faster with Matlab's plotting than with MatPlotLib. But that too, will change with time.
Sounds like a disaster. Not a Perl user myself, I haven't even heard of Perl 6. 
SQLAlchemy has the [Automap](http://docs.sqlalchemy.org/en/rel_1_0/orm/extensions/automap.html) extension which may suit your needs. I haven't used it extensively. It was for a project that was being redone, from PHP/mysql to Python/Flask. I auto-mapped the old database in order to port data to the new models/schema. Seemed to work fine.
Perl syntax doesn't really seem easy. I haven't ever had to use it myself but I've heard Perl is very powerful when it comes to text processing. So the other answer to my comment draws a rather sad picture. However, can anyone tell me about some problems that are solved in Perl much better (more efficiently or easier) than in Python or other languages?
You missed my point. How does not caring why you program affect the people you survey?
The number of things I've used that break with Unicode would beg to differ with "just fine".
[MassiveJS](https://massive-js.readthedocs.org/en/latest/) «Massive is a PostgreSQL-specific data access tool. The goal of Massive is to make it easier for you to use PostgreSQL's amazing features, not to hide them under a load of abstraction. Massive is not an ORM. It loads your schema at runtime, creating an object instance that allows you to query tables, functions, and stored SQL files as if they were first-order methods.» 
Perl is really good for Unix scripts. You can forget about bash, awk, sed, etc. Perl is awesome for quick and dirty scripts. Also Perl regular expression support is superb, anything processing text is nice to write in Perl. For anything else I prefer Python. Now Perl 6 is another story, and it actually has some very cool features like gradual typing, good parallelism and concurrency primitives and a very nice object system. Only problem is that adoption is very low (because it has not been even released yet) and therefore there are not many libraries or frameworks out there.
There was a transition to Python 3?
It wasn't backwards compatible and generally required manual porting, despite the attempts to build tools to port automatically. There's *tons* of old code (think 15- or 20-year-old code) written in older versions of Python that works just fine that no one wanted to port. On top of that, there wasn't really a compelling reason to switch to Python 3 at first anyway.
I agree. Transitioning my entire code base from 2 to 3 was a fair bit of work, but in the process massively reduced any ambiguity between unicode and bytestreams. Python3 gets these things right, to the extent that I now hate working in any language that doesn't have such a clear distinction.
Voldemort SQL Niger GIF Nike Ra's al Ghul Dubai Moet Subaru Hyundai Chances are you pronounced these words in your head differently to how the creators/locals do in theirs. The creators have a say, but not the final word.
Thanks. I was taught to always cast malloc, so I never ran into that issue. I learned a lot by making this comment! 
I've always pronounced Qt as "queue tee", when it's apparently supposed to be pronounced "cute". I'm not going to pronounce it "cute".
Different project. OP is talking about https://github.com/farcepest/MySQLdb1
Why would you want a Python 4 anyway? It is the same problem as the Linux kernel and any software that *cannot* make breaking changes - you increment minor version forever because the major version can never justifiably be incremented. Especially in programming languages, events like the Python 2 -&gt; 3 transition are rare to unheard of, because you are effectively pushing a new language once you break the traditional grammar to the extent Python 3 did. If the major version - which traditionally means breaking changes - is meaningless, then don't have one. Python 2.0 was mainly numbered as such because it reworked the GC to be much more efficient, and it added in some features that are common today. It didn't break backwards code compatibility at all, so it was a misuse of major versioning if Python 3 was to be considered the standard for Python versioning. If you make breaking grammatical changes to a programming language, you are making a new language, a dialect of the old one. Software for one might be understood in the other but its like two versions of English where different words mean different things (chips vs fries, color vs colour) and it can be more dangerous to conflate the two than to make a clean separation. Its probably why the C++ versioning makes sense. Its just based on the year of the standard update, since to change the grammar of C++ would be to make it no longer C++. C++ and C aren't even compatible anymore since C++98/C99, which is like how Python 2 and 3 interact - C++ is a dialect of C with a ton of extra features and functionality, but it isn't interchangeable, whereas Objective C is just an extension of C literally, and works with all C features still. If you wanted to use version numbering with the C family, C would be 0.1, Objective C 0.2, and C++ 1.0, and D would be a fork or something. C# would be unrelated. Analogy collapsing. Case in point, unless you *do* break backwards compatibiity again - either simply by removing depreciated library functionality or by changing the language syntax again - there should not be a 4.0. Arbitrarily incrementing the major version is just annoying to us who have to package software because our clients will see a X.0 and think its an unstable unusable breaking nightmare. I'm dealing with those kinds of debacles right now with Linux 4.0 -&gt; 4.2 because Linus just increments the version number off the opinion of G+ pollsters. 
This looks interesting - thanks! I took a brief look at SQLAlchemy (well, I was looking at Python ORMs in general) and everything I saw about it was "build your model in code, then generate your tables like this", nobody mentioned Automap.
6 had some great ideas, it came about when things like xml were really popular and it was hard to process them with tools like perl which were primarily line based instead of understanding a hierarchical tag structure. These days parsers for xml are a lot better and xml is also less popular. I doubt people see much use in many of the concepts that made 6 look like such a great idea. [That and everyone and their mother had a virtual machine implementation, but there was a time back before fire was discovered when interpreted languages were exactly that, and not compile to intermediate form and immediately execute.]
Ladies and Gentlemen! Let me introduce, The Oneders!
My scientific computing class (back in 2005) used Python. It was a required part of my physics major. 
Wait, people have actually *transitioned* to python 3? I thought it was one of those things that people just sort of talk about, like finally getting your closet organized or learning mandarin. No one actually *does* those things, but it makes us feel productive and forward thinking to plan on doing them.
Worked sorta-fine for me, opened up the page in w3m. Obviously not exactly ideal for viewing xkcd, but still...
Nice work! You should loop through your entire directory and populate this into a database so you have it all organized!
Since others have already answered the question I will make a general comment. I see 2.7. If you're starting a new project or learning the language, I recommend using the version 3 of Python. 
Why would their production machines run on Linux but they're forcing you to develop on windows? Shouldn't they want their dev machines to be as similar to production as possible?
I'd venture that Python 3 already has more adoption than Perl 6! :)
http://py3readiness.org/ - even Twisted is now available for Py3, and they said they weren't going to bother...
Wow. I'm not a Perl user, but that's really sad.
How could the transition have been done better? I'm asking as someone who is genuinely curious, not trying to pick a fight or anything like that.
The last plot I saw showed accelerated transitioning. Also, there was some Linux distro someone posted about recently that has python3 as the default. I plan on using it for my next project.
Yeah, while it would break the convention of major/minor versions, I think this psychological reason of demonstrating progress is worth it. 
&gt; don't look back Except we have to because Python 2.7 is becoming standard in astronomy and lots of projects don't work on 3.x.
Short answer: * Python runtime bound: use multiprocessing * IO bound: use gevent * Don't want to fight gevent gotchas: use threading. Disclaimer: the following is not to dissuade anyone but for educational purposes. Gevent is great but there are a lot of little gotchas that may or may not hang you up depending on your use case. Such as SSL sockets, WSGI handler, gunicorn, AMQP (use [haigha](https://github.com/agoragames/haigha) as it plays nice), and other issues with monkey patching sockets. Gevent is limited to a single process, so it won't use any cores other than the number of processes you spawn. Gevent isn't [known to play nice with multiprocessing](http://sdiehl.github.io/gevent-tutorial/#subprocess) either so if you think about using threading or multiprocessing to spin a reactor per core... you are in for a fun time. In my experiences multiple instances of the gevent reactor are spread over multiple cores using an external queue(s) such as rabbit, kafka, or redis and spawned externally using something like [supervisor](http://supervisord.org/) or [rq](http://python-rq.org/). In *all* cases most python is also blocking within a context, so unless you are using iterators (naturally cooperative), your loops will be blocking. Instead, have a function yield results into pool.imap so both your returns and your calls are cooperative. Something like this. from multiprocessing import Pool # from multiprocessing import Pool # from gevent.pool import Pool def generate_work(): """wrapper around a work feeder (queue, DB query, inotify...)""" # invoke DB/socket connection, read for a queue... # perform queries result_cursor = [1, 2, 3] for result in result_cursor: # possible manipulations to the data here yield result # yielding switches contexts back to the caller def main(): p = Pool(5) # or ThreadPool p.imap(work, generate_work()) p.join() def work(item): if isinstance(item, list) and len(item) &gt; 1: p = Pool(2) p.imap(_process, item) else: # it would be unnecessary to spawn() here # as we are already in a new context if isinstance(item, list): item = item.pop() _process(item) def _process(item): """dummy proccessor for IO bound work""" # I'm sure this should be doing some IO bound work return str(item).upper() 
Gently introducing u'text' and b'001F' as "hints to the interpreter" and gradually make the distinction more public, with deprecation warnings, etc.. Not sure if that would have been possible. but the introduction/retirement/reintroduction of u'strings' was plain dumb. Also, "string" interpolation for binary data IS a thing. Neglecting that was also dumb.
It's a javascript rendering issue right? Seems like that could be fixed in the future...
&gt; Especially the language syntax looks unbelievably cryptic and unfriendly to my eyes, that it just makes me not want to learn anything about it. And that's how you know you're sane. Congrats for passing the test!
Great blog! I was planning on reading up on how to use python for GIS and demographic analysis and this article meshes well with that. 
...Too bad they're not following semver fully, where the entire point is that 4 WOULD consist of backwards-incompatible changes.
No. Its an ensemble method where the split decisions are made randomly among dozens of trees.
A random forest is an ensemble of decision trees.
Django can generate models file from existing database tables. https://docs.djangoproject.com/en/1.8/howto/legacy-databases/
This happened because the first gnome app you ran was run with `sudo`, so it created this directory as `root`. Stop running apps with `sudo`!
I've definitely built complete Python projects in python3. Once Django, Postgres and Redis were switched over there wasn't much left to wait on. Now, on the other hand, waiting for Twisted to get their shit together has been a real slog. 
&gt; Why are you still using Python 2?? too busy adding business value and getting paid than to play with new toys. have fun #kidz
The point is the conversion is now done! Now you have a modern code base and similarly a modern language. 
Semantic versioning. I didn't know how I felt about it at first, but it does make sense. Why not 3.10, 3.50, etc? But to each their own. As long as we don't repeat the *transition* from 2 to 3, then who cares what they call it.
I have never like Perl and frankly i believe it attracts the type of people that would never work together to deliver something useful. The development of Perl 6 highlights the nature of the Perl community. 
Both Fedora and Arch do, and I wouldn't be surprised if gentoo did either.
&gt; Sounds like a disaster. Its a metaphor for programming in Perl.
&gt; Interesting. I have the ~/.gnome2 directory, but it looks like my user does not have write permissions there. You probably once ran something as root or with "sudo" in the past that you shouldn't have. When some gnome thing tried to make some normal directories, it was running as root rather than as your user, so all that stuff got created as belonging to root but in your home directory. Then when something later needed to fiddle around in there (like a fun xkcd joke) it belonged to root and your user couldn't do anything about it. So, in general, don't run GUI apps as root or with sudo. Unless there's a really specific reason to, and you feel like you either understand the implications or are willing to fix the result. :)
Actually many of us switched very early to Python 3. It is well worth the minor time investment required and allows one to ignore the luddites out there that can't adApt. The early transition has proven to be a very smart move as the really interesting stuff coming out is Python 3 based. 
I'm surprised anybody would ask such a question in a technical forum. There is much that can be added to or improved in Python justifying a Python 4. That doesn't mean breaking backward compatibility though. 
I started playing with Python 3 right out of the gate! By Python 3.3 was actually using it in daily scripts. Very nice and I've been happy with the transition. 
I haven't tried arrow but I use datetime a lot with pandas. That's what they have in their documentation. Is arrow a lot better? 
This is really cool, but it does bother me that `print` in the comic is a statement and not a function.
That's my point. If it were a true superset (like ObjC) you new/delete wouldn't be reserved keywords and malloc would behave the same. And I don't think you can link C++ and C together without marking the C++ as extern "C" or compiling the C as C++ (and hoping it actually compiles). Edit: Clarification. 
Things are certainly getting better for 3. When I first saw the wall of shame a couple of years ago it was about half red and now only a few red packages remain. [python 3 wall of shame](https://python3wos.appspot.com/)
PyQt5 is for Python 3, and can be compiled for Python 2. PyQt4 and PySide are Python 2
Or Ramses.
My first write up! Feedback much appreciated.
Make sure all your downstream can handle unicode as well. It is truly a different beast. 
One skill that comes with learning to code is to recognize (and read) errors. As reported, you have an extra intent. The second print statement is indented a layer too much. As a side note, learning questions are better suited for /r/learnpython
 If name == "doug": print "hey doug" print "how are you?" else: print "how are you?" 
I run it as root when I need to do serial communication over I2C. It doesn't connect otherwise. I did change sudoers to give that particular command permission, but others in the lab could not do anything about that, so I reverted.
I agree. That's a dumb versioning scheme.
Maybe I'm just really tired and have been looking at too much code today. But why? Is it the ==? That should compare value.
if you find some time, plz go through this post: http://mattupstate.com/python/2013/06/26/how-i-structure-my-flask-applications.html it should blow your mind about Flask's maturity.
its for a router , it switches when there are too many connections , only has a web interface so I am tired of logging in and going to menu and pressing a button to reboot. Should be easy.
...Hasenfeffer incorporated. We're gonna do it! Give us any chance, we'll take it. Give us any rule, we'll break it.... No wait, you're all too young to get that one.... :-(
Python 3 overtook Python 2 some time ago... 2013 actually.... http://ianozsvald.com/2013/04/15/more-python-3-3-downloads-than-python-2-7-for-past-3-months/
Because it will be stupid when people are using Python 3.894. Might as well just not bother with x.y version at all and give everything a single integer number. The idea that the 'major' version number should indicate braking changes is totally arbitrary. Not everything needs to follow semver. Even better would be to decouple the release version from the api version.
&gt; sudo python LOL
Guido should be in the NBA for that DUNK on Perl. 
You would be repeating yourself.
Just treat the number as a string and check each digit.
&gt;Why would you want a Python 4 anyway? Because technical debt accrues in everything, including programming languages. You pay it now or later, and as the Zen Of Python says, now is better than never. :-) &gt; It is the same problem as the Linux kernel and any software that cannot make &gt;breaking changes - you increment minor version forever because the major version &gt;can never justifiably be incremented. Everything can break backward compatibility if the cost/benefit ratio is right. As Guido likes to say, "All the lines of Python ever written pale in comparison to all the lines of Python yet to be written". You can't doom people for all eternity to spare a little bit of comfort to those of today. I remember reading about the C operator precedence problem and how changing it was considered but there were "almost one million lines of code written" or something and thus the breaking change was ruled out. :-) Obviously vastly more lines of C would be written in the decades ahead and all of those developers were saddled with an annoying precedence because no one was able to see far enough down the line. Even Ritchie wrote that in hindsight he'd have made the change. &gt; Especially in programming languages, events like the Python 2 -&gt; 3 transition are &gt;rare to unheard of, because you are effectively pushing a new language once you &gt;break the traditional grammar to the extent Python 3 did. Python 3 is hardly a new language! You tweaking the print statement to make it a function, dithered with division, changed the unicode, deprecated old style classes... nothing fundamental was changed in the language. Actually, the opposite of what you said is really true. A biologist once said, "That which is not growing is dying." And at a talk about the next 20 years of Python, it was asked of the audience when the last time was they'd heard of something cool being done in Smalltalk or Tcl. The speaker said they are both fine languages but somewhere along the line they stopped growing and thus stopped being relevant. I came to Python from Delphi, which is essentially Pascal. Now Pascal became Turbo Pascal became Delphi, kept growing and gaining new capabilities, and reached its height in the late 1990s. But after then the language stopped growing, diehard curmudgeons who still run WIndows XP and denounce everything younger than C++ as "a fad" (seriously, one wrote a post on Google+ this week about the benefits of declaring all of your variables at the start of a procedure or function) fought any change, and the language stagnated. Features would be added in 5-6 years after everything else got them but nothing really new was done. Nothing was deprecated, so now the language has 5 or 6 string types and a similar number of ways to open a file. Not only did the remaining user base successfully rally against moving to one string type, they fought zero-based arrays and many even reject Unicode entirely! Long story slightly less long, now Delphi is a tiny niche. Lots of features have been proposed, but no one wants to break anything to get them. No one wants to rewrite the desktop version of the compiler (over one million lines of uncommented ANSI C code and no formal language grammar exists; "if it compiles it's valid Delphi"). In short, the language is collapsing in on itself due to the weight of technical debt. What you're talking about would do the same thing to Python, and I never want to see that happen. I've already had Delphi become as useful on my resume as "candle maker". &gt;It didn't break backwards code compatibility at all Are you sure about that? Actually it did have some breaking changes: https://docs.python.org/3/whatsnew/2.0.html#porting-to-2-0 It also introduced unicode, list comprehensions, argument packing, etc. Those are some serious changes. &gt;If you make breaking grammatical changes to a programming language, you are &gt;making a new language, a dialect of the old one. Software for one might be &gt;understood in the other but its like two versions of English where different words &gt;mean different things (chips vs fries, color vs colour) and it can be more dangerous &gt;to conflate the two than to make a clean separation. I can't remotely agree that a breaking change to a language creates a new language. To go back to biology again, that's like saying one mutation makes a new species. 
uh yeah that should be pretty easy...things get annoying when you have to deal with some local government agency's f--ed up implementation of .NET, or OAuth. (or Google. It's just one search box and a button but they are quite canny at stopping automated scrapers even after just a couple of attempts)
Ameriica elected its first black president, too. You missed a lot during the coma you've been in for 7 years!
Very interesting approach!
Speaking as a Rubyist and a just-recently Python-focused developer...this claim sounds completely reasonable. Ruby had its own massive schism when moving from 1.8 to 1.9... I was too shit a developer to really care about why everything I had was breaking...but from what I understand, much of it also had to do with unicode. All I know is that since 1.9.3...it is *uncanny* how things never seem to break. I have multiple computers that I don't even bother to maintain disciplined dev environment on (e.g. with rvm/rbenv) and yet I can turn on a laptop that I haven't turned on for months, run `bundle install` to update dependencies on a given project...and things just work...and I don't even have to check what version of Ruby I'm actually on. In the past 5 years, everytime I've heard someone rant about how they quit Ruby because of backwards-compatibility issues, it has always been developers who lived through the 1.8 to 1.9 months. And the 1.8 to 1.9 break, as painful as it was, was over relatively quick...there was never, ever the sense that it was going to be a protracted conflict like 2.x and 3.x in Python. But there's major differences beyond leadership and language-specifics. For one thing, Ruby was highly focused around Rails. [Once Rails got the migration show going](http://yehudakatz.com/2010/05/05/ruby-1-9-encodings-a-primer-and-the-solution-for-rails/)...you'd be a fool of a Ruby developer to not also make the jump. There doesn't seem to be any such monolithic ultimatum for Python...which is not at all inherently a bad thing. But just like how being opinionated made Rails as popular as it is today...not having a massive-opinion-maker-of-a-project will make it easier for devs to hold-off on 3.x...especially if many of those devs are more science-programming focused, as opposed to the software-engineering-focused programmers in the Ruby community. That said, I've been mostly blissfully using Python 3.x for a year now. I have lots of incompatibility issues but I've put in very little effort to maintain engineering discipline (including learning Python's testing frameworks) as I'm using Python mostly for data exploration...so I get into painful situations all the time but it's not so painful when I *know* I deserve it :). And the claim that most of Python's important libraries have moved to 3.x is true enough...but I constantly run into major exceptions...such as [Google's Cloud SDK](https://cloud.google.com/sdk/?hl=en) and Mechanize. It's frankly not a big deal because Python has so many other libraries that Ruby will likely never have (pandas, scikit, etc)...but it's hard to imagine a major shop putting out an interface that would only work with Ruby 1.8.x. Or even just 2.0.x
Yeah, this article reads like the author was just feeling his way around blindly with the @ operator. On the same topic, I found this blog post to be incredibly helpful, and much more well-written: http://y.tsutsumi.io/dry-principles-through-python-decorators.html I ended up following those examples to create a similar idiom myself. Basically, writing an API in which every method had the same error handling, response schema, etc. I found my self copy-pasting code, then extracting the common code into wrapper functions, then I realized, hey, I'm writing a decorator! Really the only trick to using a decorator, as OP's blogger discovers after much machination, is to use a wrapper function inside the decorator function. Once you understand that, sky's the limit for what you want to do with it...
Eh, most of us learned Linux by ourselves, just the way you experimented with sudo.
People are saying that the main reason is incompatibility. I say the main reason is that they supported python2 for too long (nearly 8 years) after first python 3 was released, often backporting features from python 3 which further reduced desire to upgrade. The python 2.7 still will be supported until 2020. Nearly languages break compatibility, some even in minor version and no one complains because they know that if they don't update their code they'll have hard time running it in the future.
If it's a small db for a local app, you can just pop em in sqlite, which sounds like what would be ideal for you. If you decide sql is the way to go and you want backend-agnosticism, look into sqlalchemy.
Wow yeah DRY. Okay I'm going to bed. 
&gt;though we're in much better shape than Perl [OOOOOOOH!](http://i.imgur.com/SnCcn5m.gif)
It comes down to don't repeat yourself DRY. So the biggest problem is that there are two code strings that are the exact same right next to each other. 
It's totally arbitrary in the same way our spelling of 'arbitrary' is arbitrary. I could spell it "glebglork" and if we all agreed it meant 'arbitrary', things would continue to operate smoothly. Semantic versioning is what the industry landed on. It's not better, it's just standard. There is value in using the same vocabulary as everyone else. What you're saying is just your own little concoction of versioning that no one's ever heard of or has followed before. A new dev on your team would have to go to you to get an explanation, or read something you've written, and what that new dev learns from your system won't be transferable to any other work he does except the work on your system.
| Its a metaphor for *reading* Perl FTFY
&gt; you're all too young to get that one.... :-( I got it... :(
assert ?
what's the point of having multiple decision trees?
The comic is several years old, not really worth going back and updating it to suit Python 3.
Yes, I have used Visual Studio Code quite extensively for Python and I wrote about it on this reddit a while back. It works well on a variety of platforms, is quite serviceable, and doesn't pose the problems for large enterprises that both Sublime and Atom do. We're getting a lot of use from it in a lot of contexts. Older post can be found here, though version 0.10.0 changes some of this advice: https://www.reddit.com/r/Python/comments/34yvcm/using_visual_studio_code_with_python/ 
Anyone who says C is terrible has never written assembly.
I had the same experience and I have mixed feelings about it. The standard series at Cornell goes Python -&gt; Java -&gt; OCaml. As a result, some students think of Python as a beginners language for programmers that aren't experienced enough to deal with type systems and complicated syntax. It would be nice to see Python being used in advanced CS courses. I'm obsessive, so I spent the time to unlearn all the bad habits I learned as a freshman, following blogs etc. to learn to write idiomatic Python. But when I look at some of my peers' python code... dear god, it looks like java without braces.
Coming from the scientific computing community, it seems to me that 3 is heavily dominant.
&gt; Why are you still using Python 2?? Python 3 isn't a default install and my users are dumb. :(
An ensemble of trees allows an exploration of many split combinations to see what provides the best model for the data.
&gt; xml is also less popular Being replaced with what?
True; it seems there's just a number of Python libraries that do not support Python 3 which slows down the adoption.
 &gt;&gt;&gt; bool([a for a in str(101101) if a.isdigit() and int(a) &gt; 1]) False &gt;&gt;&gt; bool([a for a in str(101201) if a.isdigit() and int(a) &gt; 1]) True 
JSON
JSON? Hopefully it gets replaced with YAML for human-readable stuff and MessagePack for machine-readable stuff. People will look back on editing JSON-based configuration files and either laugh or facepalm.
And from what I've heard, Python is starting to replace PHP.
&gt; you would need to do char * myStr = static_cast&lt;char*&gt;(malloc(200)). I'm a little rough when it comes to casting in C/C++, but is there a reason you couldn't just do `char * myStr = (char*) malloc(200);`? Why does it have to explicitly be static_cast?
Because it's a lot slower than mysql-python.
 from __future__ import barry_as_FLUFL will make this a syntax error: foo != bar As you get this operator instead: foo &lt;&gt; bar
`.write_payload` works when you pass it a list. You're passing it a string, `"txt.read"`. Why? I suspect that you want `list(txt.read())`, but make sure there's no newline at the end of your file.
 any(n &gt; '1' for n in str(number))
I've seen first hand people like you replaced because they were so hung up on "if the old stuff works, then why bother with anything new". 
Python 3 port is [in progress](http://wiki.wxpython.org/ProjectPhoenix). No idea how long it's got to go though.
Python is a tool of scientists, but I'm a scientist still using mostly Python 2. Sorry.... I know I should switch, and that dealing with any leftover issues (old libraries, old code) is worthwhile, I just don't have time to deal with those issues right now. And I think this is a very common position for scientists :( I don't think Python's scientific success has much to do with Python 3. If anything some people I know are unhappy because performance was reduced. Most people don't care a lot about this - scientists do!!
I hope it's true.
But in which way is JSON better than XML? [I was just recently asking](https://www.reddit.com/r/flask/comments/3s7gqk/good_way_to_validate_json_post_data/cwvptsu) about whether there is a standard schema definition way for JSON and it seems there isn't.
&gt; I've never understood how anybody likes Perl. I don't like Perl now, but I did like it once. I loved it once, in fact. When I first used it, in 1994, it was *mind-blowing*. So much simpler than anything I'd seen before, particularly at text-processing. This was just when the web was exploding into the public consciousness, and people were starting to do interesting things with CGI ("you mean web pages don't just have to be static? wow!"). For that kind of work (remember: HTML is text), Perl was so much better than the alternatives (e.g. C). And just having a high level language where arrays could grow easily and you didn't need to declare your types, was really liberating. The "write once read never" thing was true though, and working on someone else's code was a nightmare. A few of years later I found python and never wrote another line of Perl again.
I feel, that even with parsers, parsing XML is cumbersome.
&gt;Python 3 overtook Python 2 some time ago... 2013 actually.... If you look at pypi download stats from 2014 you'll see that 3.x accounted for less than 3% of ~2 million downloads. https://alexgaynor.net/2014/jan/03/pypi-download-statistics/
&gt; Are you sure about that? Actually it did have some breaking changes: &gt; &gt; https://docs.python.org/3/whatsnew/2.0.html#porting-to-2-0 Thanks for digging that up, that's interesting. I started using Python before 2.0 but I knew very little about the details of the language at the time, and I've found myself wondering what the 2.0 transition was like.
For validating data integrity.
&gt; I did this in jupyter notebook manually. Manually? You know you can pass a dictionary to the rename method, right?
As someone who only very occasionally uses Ruby, I'd wondered how the 1.8 to 1.9 transition went. It seemed a lot more low-key than Python's transition, yeah, even though it seemed like the same magnitude of transition. I think Python hit some bad timing where 2.6 and 2.7 became hugely popular in lines of work where updating code just isn't a thing you do. I wonder if the *style* of the Unicode transition had something to do with it, actually. It looks to me like if you have bad Unicode hygiene, Ruby 1.9 would just happily output garbage, while Python 3.x would crash immediately while telling you how much you suck. So Ruby had happier developers, but I think my [corrupted-Unicode-fixing library, "ftfy"](https://github.com/LuminosoInsight/python-ftfy) gets to deal with output from some of the badly ported Ruby code. Even though Django isn't as hugely dominant in Python development as Rails is in Ruby, I would say there *is* an ultimatum looming, just a much slower one: Django 2.0 (roadmapped for December 2017) is going to drop Python 2 support.
I know that's what their entire purpose is, but what I mean is, how does that help? What kinds of failures are being caught by XML schemas in real life that you wouldn't have caught otherwise? I've never seen anyone actually use schemas. There was a brief time when people would wave in the general direction of schemas to document their data format, but they didn't make very good documentation anyway. To answer your question: JSON is better than XML because it doesn't have ambiguity about whether whitespace is meaningful text, and its data structures are more useful.
I never came across that myself, perhaps because the C code I worked with tended to explicitly cast void pointers as a stylistic thing anyway.
This is a question only you can answer. What do you want to do?
I think you're doomed. At best, build a library of bash functions that you can select among to construct bash files. Take bash comments to read what sections/functions are in such a file and what params were used to make the file. Never allow manual editing of the files.
I'm not savvy enough to give you a good answer, but I'm currently using a schema in a project that has to do with extracting data from arbitrary texts. Validating the extraction results against the schema gives me confidence about whether or not my program has extracted the right piece of text and whether or not a resulting XML element is complete. Also, I think the schema would make it easier for me to use the same data format in another program I might write -- I would simply have to reference the schema and the program would know what the data is like.
It's automatically generated from the 200 most popular packages on PyPi. If a package is not there, it's either because it's less popular, or because it's not on PyPi. In my eyes, not supporting py3 is a warning sign that a project is abandoned. 
&gt; *Why are you still using Python 2??* I'll bite. - already know py2 - tend to use pypy for speed - some py3 changes - spite py3 lovers
Benchmarks with rapidjson as winner (not completely unbiased, though, take with a grain of salt as usual): * https://github.com/sontek/python_json_benchmarks * https://github.com/miloyip/nativejson-benchmark
&gt; pip install --no-cache-dir --download pip 7.1.2 here, trying to install flask in a new virtualenv. `pip install flask --no-cache-dir --download flask` fails. What am I doing wrong?
no idea, error output?
Selenium with PhantomJS as the browser. Its by far the most powerful solution for scraping, when you have any sort of interactivity you need to do. Otherwise, BeautifulSoup or the like is lighter weight option.
its more of a correct highlighter, since a lot of editors don't highlight python3's new syntax features completely correctly 
I think the best advice I can give new programmers is "embrace the challenge". If Google Apps Engine is not comprehensible to you, throw yourself fully at it and learn it. Or spin up an AWS free Micro instance. Every programmer has to be a mini-sysadmin in order to be the most effective. You have to know how to set up an environment and deploy your code.
I get the impression that neither GvR nor Larry Wall miss an opportunity to pick on the other language's failure to introduce a new major version. Obviously, both strategies did not work too well, so they could just move on...
anecdotes matter, I've seen people like you replaced for making assumptions like dumb asses. dont pretend like you know me motherfucker.
Python 2.7 end-of-life is in 2020. It's almost 2016. Unless those astronomers are giving a lot of money to Red Hat, they really should be looking at Python 3.
Thanks for your article, will certainly study the issue more.
You don't use NumPy? Then you get your matrices back! 
\&gt;using python \&gt;complaining about speed I mean I know it's a meme, but come on. I use connector _in production_ at work, and it's absolutely fine. Sure you're not gonna use it for c10k, but you're not gonna use Python for that either.
&gt; The religious belief that all of what seems to be a string should be handled as Unicode Not quite. The belief is more along the lines of "you are now required to think about boundaries, because trying to implicitly fix them for you created even bigger messes than the ones you'll complain about now that you have to think about them". In other words, it's now your job (well, maybe not you personally -- more likely, "you" meaning "the authors of the libraries you use") to, when pulling string data from outside sources, figure out how that data was encoded/transmitted, decode it to Unicode, and then encode it back when you want to store/transmit/whatever after your manipulations are done. Which is what a lot of libraries/frameworks already had to do in Python 2 since any other approach would lead, sooner or later, to mysterious `UnicodeDecodeError`s. The only domain I know of where the Python 2 approach even kinda-sorta worked is Unix filesystem encoding, and 99% of the complaints I read about Python 3's string handling are people coming from that world who suddenly get to know what the entire rest of the Python world was already having to deal with. What's more, the rest of the world had to deal with more of it than strictly necessary on Python 2, largely so that people whose domain is doing operations with files on Unix could have their magical happy land of "it just works for me!"
Check out [the answers here](http://stackoverflow.com/questions/15598878/posix-sh-ebnf-grammar). Bash has a bunch of important extensions ([heredocs](https://en.wikipedia.org/wiki/Here_document#Unix_shells) for example, I looked at the mentioned POSIX standard and didn't see anything like that), but that's a place to start.
&gt; It's not better, it's just standard. I disagree. I think there's real value in being able to look at the version number and approximate the scale of the changes involved. I would rather go to Python 3.894 than not be able to tell whether X+1 is going to be incompatible with X. 
READ THE SIDEBAR /r/learnpython
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. Cheers &amp; best of luck with Python!
Massive speed loss if reading files in text mode. When using bytes, round trip conversion to use .format or % (until 3.5, which beyond my control is not deployed everywhere I need to run).
This. Its not unique, at any business of scale there is someone in the rollout process that only cares about version numbers. Which *should* be fine, since the version numbers are supposed to be informative on what releases do what to a system, right?
did you create the folder named flask before running that?
&gt; Everything can break backward compatibility if the cost/benefit ratio is right. I speak of the claim "Python 4 won't be like Python 3" which implies the backwards breaking would be less severe or nonexistent. If its less severe, thats fine. If its not existent, you break the versioning scheme and make my job harder for literally no reason. &gt; o go back to biology again, that's like saying one mutation makes a new species. Python 3.5 was an evolutionary mutation of Python 3.4. Python 3 was a fork in the evolutionary road from Python 2, and Python 2 kept getting support updates in parallel to Python 3 development. Of course Python 3 overtook it, it was designed to. But remember the talk two to three years ago about how some people wanted to fork Python 2 and continue *its* development rather than switch to 3? Having to port code from Python 2 to 3 is in the same class of problems as porting my Python 2 code to Ruby - the later is of insanely greater scope because Ruby is a much more divergent language, but Python 3 is still a *different syntax* from Python 2 and thus a different language. Same way Perl up to 5 and everything since then is a different language that has taken 15 years to come out. I vaguely remember the 2.0 era, but I guess you are right, which actually only supports my position - they cannot release a 4.0 unless it forks the language again with backwards incompatible changes, because their versioning system up until now has always been that major version increments break backwards compatibility. 
&gt; has there ever been a not-at-all-backwards-compatible language update of this magnitude before? A successful one? As far as I know Python3 is the first.
Haskell removes stuff and changes existing things all the time. The trick is to have a type system that allows the compiler to point out where the problems are. If you don't have that info around then there is no sane way to make sure the semantics of your code hasn't changed.
And anyone who conflates low-level with terrible is missing the point.
Nope, it was a new folder and a new virtualenv. Never mind, just found that `pip wheel .` is what I need.
2to3 is entirely useless and six isn't helpful for porting to 3, just for porting to 2-and-3-polyglot-for-libraries. The reason that the vast majority of actively-developed Python application code hasn't been ported is that there is not enough net benefit to bother with the work.
That is disappointing.
It will be stupid. Stupid that language has enforced no breaking changes rule for so long.
Really? Is all the numpy support there?
&gt; C++ is entirely backwards compatible. "Backwards" isn't the right word here because C isn't the older version of C++, it's a different language. There are releases of C that are newer than some releases of C++ and vice versa. A lot of people get hung up on how C++ isn't a strict superset of C, which is true. But they neglect to point out that there is a *lot* of overlap and it's pretty easy to write code that fits inside that subset and is both valid C and C++. The differences are real, but are easily avoided if that's a priority.
Slightly more exhaustive list -&gt; https://github.com/realpython/list-of-python-api-wrappers
The only useful information I get from this blog post is that 2.7.1 and 2.7.3 ran about 11% faster than the rest of the versions which may have been a result of bugs that were fixed in 2.7.2 and 2.7.4. With the exception of 2.7.1 and 2.7.3 the minor versions of 2.7 run approximately at the same speed and approximately 10% faster than the 2.7.0 release. 
My company is still using Python 2.6 and django 1.6.11..... :(
Mhm
I highly recommend setting up an ipython notebook (now called jupyter) server for her to use for her learning process. It is much simpler to get into than most IDEs and being able to see the code evaluated right in the same space is really nice. Plus there are a lot of really inspiring notebook examples where people are quickly generating graphs or images or doing audio manipulation right in the notebook. Finally, it also means she doesn't have to setup anything on her own computer and can just dive right into coding no matter what computer she's working on. You can test it out here: https://try.jupyter.org/
Sure, but python3 completely ignores that there are other encodings out there. Many times you cannot afford letting non latin1(for example) characters be part of certain string. Ever. In python3 there is no easy way to enforce a string to be latin1 and get exceptions when someone tries to add non latin1 characters to it. And that sucks.
If you think recursion is one of the basics, you're going to have a hard time with this. Knowing how to program doesn't mean you know how to *teach* programming. Python is a great language to start with, for a number of reasons. * Learning to program isn't about learning a language. It's about learning how to think algorithmically. But pure algorithmic thinking isn't very rewarding (it's math, basically) so you need some sort of language to illustrate the ideas with. It's pretty easy to convert algorithms into code in Python (especially 3) so it's a less painful language than many. * Python has a massive standard library, so once you get the basics down, you can move on to many styles of programming without importing anything. Tk is annoying but it's pretty easy and built-in, so if she wants to do a GUI, she can. Same with databases, web scraping, server-side programming, and much more. * You don't need much computer to work with Python. It's a quick install, and you can choose any ide (or none at all) Idle is perfectly fine for beginners and it's packaged with most installations 
Omg integrate with torrent site for download link :)
You'll need a nested loop. Here's some pseudoish code to get you started for x in range (1, 16): for y in range (1,16): print(x*y)
One of the challenges experienced programmers face is that they underestimate how confusing things they consider simple can be for beginners. One approach that has been shown to work with a lot of beginners is the "Karel the robot" approach, where you teach a robot how to accomplish simple tasks, learning programming concepts along the way. Many years ago, I wrote a Python desktop version (RUR-PLE), that included a basic tutorial, and which has been used by many complete beginners to learn Python. A few years ago, I focused on creating a web version, which also includes a tutorial. (The desktop version is now obsolete.) I am in the middle of rewriting that tutorial (for the fourth time), with each new version focused on ensuring a smoother learning path than before. This new tutorial (not complete, but it should be a good starting point) even includes some notes intended for people like you who are mentoring someone else. Everything I create is freely available; no ads, no login required. Have a look at the tutorial (http://reeborg.ca/docs/en/index.html) and the programming environment itself (http://reeborg.ca/world.html) and feel free to contact me directly (my email address is on the site) with any questions you might have.
I've seen your post before but I actually kind of disagree with your suggestion to use `from pylab import *`. Don't get me wrong, I understand *why* you suggest this. It will make the move to Python easier. But, I think it is a step in the wrong direction. You are throwing away one of the major advantages of Python code: scoping and self-commented syntax. I think it is better to teach a new Matlab to Python user to do it right. Or at least closer to the right. I did see you included the line: &gt; Of course, I still use `from pylab import *` because it’s so darn convenient. I use it during development and you probably will too. &gt; &gt; Better practice would be explicitly define where each function is from, like below: This is a recognition of my argument but I still think it is better to always do it right. Or at least better. Actually, the Matlab-like vs "real" python debate is one of the biggest problems I am having with the move to plotting with matplotlib. So many guides give you the way to do it with `pyplot` but I want to use the object-oriented plotting. And sometimes the commands are not the same. Sure, I could just use `pyplot` and not worry any more about it but I think that may cripple me later. Of course, this is all personal preference.
It technically doesn't in this case, a C-style cast works in C++ but the behavior can vary between static_cast and reinterpret_cast, so it's better to be explicit with a static_cast to guarantee the same behavior.
Seconded. I primarily develop (GUI stuff) in Py2 but often double check that my code also works in 3. I use PyQt4 and haven't had an issue with py3 yet
you can use curl for connecting to https websites and login?
Because there's a bunch of different casts that do different things: http://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used
I've been on the mailing list. The next version of VTK will be Python 2 only. The version after that will probably include Python 3.
Is there a simple way to generate trusted LetsEncrypt certs without the whole automatic server configuration shebang?
What does end-of-life mean?
"End-of-life" is the date past which the developers no longer provide support (in the form of fixing bugs) for that version.
https://letsencrypt.readthedocs.org/en/latest/using.html#webroot This required the least configuration on my part. It basically generates all the files you need in your existing webroot folder. You don't even need to stop your server while it requests the certificate 
letsencrypt certonly -a webroot --webroot-path /var/www or whatever
good luck "cythonizing some loops" in say django. The problem is that you choose python for doing stuff and then your stuff gets big (e.g. instagram or youtube) and your assumption about what is python good for does not hold any more. Additionally, python is a good language, why it can't be fast?
I'm not complaining about Python 3 abolishing implicit conversion between `str` and `unicode`, which I think is an improvement. What I'm complaining about is the removal of bytestring (`str` in Python 2). As I wrote in my previous comment, this disastrous change came from the false belief that there's no such thing as "bytestring". In the belief, every string should be handled as Unicode and that's why Guido removed the bytestring type. But in practice, strings that shouldn't be treated as Unicode are everywhere. Text-base network protocols are a typical example. Suppose generating an HTTP request in Python 2. You can just use `str.format()` because Python 2 has a bytestring type `str`: request = '{method} {path} HTTP/1.1\r\nHost: {host}\r\n...'.format(method='GET', path='/', host='example.com') And in C, which also has a bytestring type `char []`, you can just call `sprintf()`: char buffer[SIZE]; sprintf(buffer, "%s %s HTTP/1.1\r\nHost: %s\r\n...", "GET", "/", "example.com"); In Python 3, which lacks a bytestring type, you need to write this cumbersome code: request = u'{method} {path} HTTP/1.1\r\nHost: {host}\r\n...'.format(method=u'GET', path=u'/', host=u'example.com').encode('ascii') You have to have a template in Unicode, format it, and encode it into ascii. The reason why you have to do this way is, according to [the Python 3.0 document](https://docs.python.org/3.0/library/stdtypes.html#bytes-and-byte-array-methods), it "[does] not make sense" for `bytes` to have `.format()`. (But to have `.capitalize()` does!) But it doesn't make any sense to me to call the `.format()` method of the Unicode type `str` to generate an HTTP request header because the RFC that defines the HTTP specifies how bytes should be arranged in the protocol, not how Unicode characters should be arranged. Guido should just have renamed `str` to `bytes` and `unicode` to `str`. If that had been the case, string handling in Python 3 would not be broken. Instead of just renaming `str` to `bytes`, Guido removed the bytestring type (`str` in Python 2) and added the immutable bytearray type called `bytes`, which resulted in the disaster. 
&gt; Text-base network protocols are a typical example. Except the best practice for those is to convert incoming string data to Unicode, then convert to the desired encoding for transmitting back out. When you consider that "text-based network protocols" involve things like MIME and encoding-declaration headers and such, you'll see why this is really the only policy that makes sense.
[Warning](https://letsencrypt.readthedocs.org/en/latest/using.html#from-source): &gt; Please do not use python setup.py install or python pip install .. Please do not attempt the installation commands as superuser/root and/or without virtual environment, e.g. sudo python setup.py install, sudo pip install, sudo ./venv/bin/.... These modes of operation might corrupt your operating system and are not supported by the Let’s Encrypt team!
Already answered, but it could be distilled a bit. That's what the `certonly` operation does. It does authentication and grabs the certificates, but doesn't touch the server configuration. I highly recommend it if you wish to remain sane.
Is it possible to use Pygame, Pyglet or other game frameworks with PyPy?
You mean like Oysttyer (the successor to ttytter): https://github.com/oysttyer/oysttyer
I reiterate, if one is concerned about scaling and speed then python is not the way to go, it is excellent at small tasks. Obviously this is not always the case but should be assumed. Furthermore, as an interpreted language python will always suffer from speed problems. That and the inherent GIL design currently implemented. And by cythonization I meant to use it for scripts if optimization is REALLY needed. 
&gt; There are several math solutions but they tend to rely on loops/recursion or div/remainder operations. Like this: http://stackoverflow.com/questions/14939953/sum-the-digits-of-a-number-python
&gt; Just parse ... Just parse that long single line of javascript that uses document.write()? I agree though, if returning some sort of structured data, just parse that.
Interesting, thanks! It'll be a few days before I get a chance to play around with this, so I might be dropping another comment in then :)
If you looking for something with a little intelligence try pycharm, It is fairly simple to use but has some really nice feature that help programming in python. Also if you decide to learn vim the vim support is great.
So we can have as many certs as we need for domains right? I've got some mail.blah.com domains using self signed certs that make mail clients cry havoc.
You can register a max of 5 certs per domain per 7 days, up to a total of 100 certs.
You are in the wrong subreddit. But to answer your question anyway, it really depends on what you mean. If you want to run that code on every page everywhere, then you'd probably want to write a browser plugin to do that for you. If you want to do that on your personal webpage, then just insert the script into each page.
ah that's perfect really Looking forward to getting this implemented.
Using multiple random trees reduces overfitting, improving generalization on new feature vectors. See, e.g., the [random forest](https://en.wikipedia.org/wiki/Random_forest) Wikipedia page.
I use [Tweepy](http://tweepy.readthedocs.org/en/v3.5.0/), for my [twitter bot](https://twitter.com/Keith_Event) and I really like it. There are a few things you should note. Posting to twitter every X seconds can be viewed as spamming, and if you use it too much, twitter will deny access to you. For the Tweepy API, this is the RateLimitError which falls under the TweepError. If you're tweeting, you cannot tweet the same text 2 times in a row. URL spambots accidentally get around this, because twitter automatically alters the url, generating a random address to reduce character usage. As long as you're not building a spambot, you shouldn't need to worry about this one, but it did throw an error for me the first time my bot got repetitive and it took me a while to figure out what happened. Hopefully you won't hit the same issue. I'm not the best with api's, so it took me a while to figure out how to do what I wanted using tweepy, but the documentation is good, and there are plenty of stackoverflow pages that helped as well. Best of luck!
it wont, you've gotta buy one. 
I'd uninstall Python 2 tomorrow if pdfminer were ported. I use pdfquery quite a bit, which relies on pdfminer. Everything I write that doesn't involve pdfminer is 3 at this point though, no problems.
I'm actually researching the same thing and have not been able to get any further with it. If I do find anything in my troubleshooting I will let you know. 
I actually agree but I'm just saying they're different things. C is an excellent assembler, basically. But for some very few niche things, assembler remains superior.
It's "coming". `invoke` is Python3 ready and once thats complete `fabric` will begin it's migration process. The author opted for a re-design instead of a straight port from 2&gt;3 which is why it's taken a significant amount of time.
Not mine sadly, a friends :)
try IFTTT
That's the home page of the distelli service, not an article.
If you are just interested in creating a C extension, I strongly recommend looking at [cython](http://cython.org/). If you want to write one to learn about how CPython works under the hood, [here's one that helped me back in the day](http://starship.python.net/crew/mwh/toext/toext.html)
Nested for loops are sometimes unavoidable; however there are some tricks to avoiding it. * for x, y in zip(list1, list2): #This will output the variables from both lists at the same time. * Any of the itertools in itertools https://docs.python.org/2/library/itertools.html * Manage your data with an OrderedDictionary instead. * And finally, you're probably just retrieving or formatting the data incorrectly. Instead of lists use a sets or dictionaries. Make more specific queries. etc 
It it slow because of the language or just because its exponentially more execution paths? If you need to search everything or do something on every element there's really no other choice right?
That sounds nice, except that not all byte sequences can be conveniently represented in unicode strings. I've used a number of (shitty) text-based protocols that have things like 0xFF as markers. It turns out representing the single byte 0xFF in unicode is a pain in the ass, you have to use stupid hacks like encoding arbitrary strings as Latin1, or even worse using b''.join(...) with huge sequences of all the bytes vs unicode+formatted text you actually want. I prefer the latter because it's at least explicit, but it's a huge glaring regression from Python 2.x - possibly the only one. I say this as a huge Python 3 fan who constantly annoys everyone at work about their code not being Python 3 compatible. You can tell it was a super bad idea because in 3.5 they finally re-added some limited form of byte string formatting, via the "%" operator... that's right, the deprecated string formatting operator. Because format() implies unicode strings for whatever reason. But whatever, I'm not even going to fight it because at least now I can finally implement my damn wire protocols sanely in 3.x.
No wildcard support. Very disappointing.
One should just simply follow the instructions on their github page. Whole process appears to have gone very smoothly, and fast to boot for me. 
I'm dumb about ssl. so this may be a dumb question. will this let me install a trusted ssl cert for free? as in people see the green lock icon in their browser and everything is all hunky dory? I thought you had to pay for this 
&gt; Mypy will not enforce types. Python will not enforce types. There are no plans for anything to enforce types or use types in optimizing anything. I'm aware. But it will at least provide a lint that will help with some errors. It's certainly not ideal, it's not even good, but it's a hell of a lot better than nothing. &gt; But this is like a fish trying to breath air, it's not what python was built to do. True and it may not be any better, but I am curious to try. I just think there must be a better way to implement this.
&gt;Why are you still using Python 2?? Lots of libraries I use are only supporting Python 2 at the moment.
I don't think your impression that there are few good materials out there is an unusual one. When I wrote my [first one](https://github.com/atheriel/accessibility/blob/master/accessibility.c) (shameless plug), I couldn't find anything really useful beyond the basic templates. Making your own classes, etc in pure C are particularly hard to find resources on. Got quite a few segfaults until I got the hang of it. My potentially useful advice: I learned the most by reading CPython's source code (for such interesting insights as "why does everything in my C extension have to be a static global variable?"), and the source code of some other open-source C extensions. It's just so easy these days to search GitHub for this stuff. In-repo code search for certain symbols (and `#define` for them) is a godsend. The link above will also give you an idea of what a C extension that supports both Python 2 and 3 looks like. I also disagree with the other comments somewhat -- C isn't *so* scary a language to write directly that you need to use cython, and CFFI is really only useful if you are just wrapping an external library. Particularly if you want to do anything on the OS level, C extensions are still an attractive choice. On the flipside, C extensions tie you to the CPython implementation of Python, which is not the only one out there these days.
Selenium works by injecting javascript to control the browser. Don't know if you can inject your own, but you can definately run a python function on every new page easy.
Turtle!
Use numpy. You'll get nearly C speeds without C work for simple problems. For things like matrix solves or searches, you'll get better than anything you'll implement because you probably don't care about the algorithm's complexity.
If you have that many customers, then you can afford to purchase a wildcard cert...
Correct. Note that this is a scripted attempt to install upstream numpy, PyPy has a fork of numpy that is usable (and includes a cffi version of the linalg Lapack wrappers) at https://bitbucket.org/pypy/numpy 
Post what you have and the problem you need help with.
It looks like you should take a look at the python docs. I'd check out section 7.2.1 here ... https://docs.python.org/2/tutorial/inputoutput.html#reading-and-writing-files
&gt; I know that's what their entire purpose is, but what I mean is, how does that help? What kinds of failures are being caught by XML schemas in real life that you wouldn't have caught otherwise? That's a bit like asking what a type checker is for: it catches type errors. That's something no application has to care about, once handled statically. &gt; I've never seen anyone actually use schemas. Take a look at [JAXB](https://de.wikipedia.org/wiki/Java_Architecture_for_XML_Binding) or PyXB which is inspired by the former if you are more interested in dynamic languages. It is not that the application performs the validation but the framework handles this for the application. The JAXB class tree is generated by the schema, which also defines a clear workflow for XML development. I found that very useful and would never handle XML different anymore.
1) i dont really understand what you mean. 2) pysdl, pygame, pyglet, pysfml... pyopengl?
Ok just throw the string inside document.write in a python dom library. dont emulate a whole browser with javascript to get the same data you can get with a http request.
That's one perspective. It is still a major limitation of their offering. I'm not in the business of spending money I don't have to.
Our product does not require high security in any respect. We don't deal with sensitive or financial data. It's a benefit to the user and a comfort thing and Google gives some boost. The SSL industry is somewhat shady and they sell a very very simple service at very very jacked up prices. Even the inexpensive ones. The use case for SSL has evolved so much, but the pricing hasn't evolved as much as it could. I don't know if free is the only option, but SSL is ripe to be disrupted.
I agree one can't blindly rely on Python and blame it for the speed issues, but I must say it'd be awesome if it was a bit faster so that I can do more on it before being obligated to delve into a lower level language/cythonizing/numba just because it's slow... PyPy is another great solution, my only gripe with it is that usually I can't use it because I'm working with PyQt/VTK/library with boost::python bindings/windows 64 bits -- so, crossing my fingers to have http://lostinjit.blogspot.com.br/2015/11/python-c-api-pypy-and-road-into-future.html find support -- and maybe later have a windows 64 version ;) Also, I'm not sure how much of the speed loss is really needed due to the bug fixing, I think it's more because no one tracked it nor paid attention that it got slower... also, note that the 13% slower is overall, if you really look at individual benchmarks, it can be much worse (for instance, spitfire_cstringio got 47% slower and bm_mako 38%, so, it's possible that templating languages actually got MUCH slower, which may be something which affects web-services much more if they're based on templating).
There is also PhantomJS that renders nicely the JavaScript stuff.
we made this a couple of months ago, works fine for us : https://bitbucket.org/conceptive/python-pkcs11
Look for Kivy ;)
Stop by the pyglet-users group on Google Groups if you start with pyglet!
Don't use pickle for file formats. It prevents you from ever using another language to inspect the file, the on disk footprint is high, and it's slow to load. Just dump it out in csv or hdf5 (both of which Pandas can do). Better yet, chuck it over to [Arctic](https://github.com/manahl/arctic).
`itertools.product` is the [Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product), whereas `zip` is [convolution](https://en.wikipedia.org/wiki/Convolution_(computer_science\)). In [1]: list1 = ['a', 'b', 'c'] In [2]: list2 = [1, 2, 3] In [3]: [(x,y) for x, y in zip(list1, list2)] Out[3]: [('a', 1), ('b', 2), ('c', 3)] In [4]: [(x,y) for x, y in itertools.product(list1, list2)] Out[4]: [('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2), ('b', 3), ('c', 1), ('c', 2), ('c', 3)]
What. Where did this come from? Who though it was a good idea?
&gt; so that you don't have to go through the normal nasty game of converting to non-unicode Is it that hard to call `.encode()`?
Oh, totally - macroing the NLE to do the processes for me and automating certain tasks is definitely a more user-friendly approach but really I'm trying to figure out a way of learning Python and I know myself well enough to know that unless I'm using it to try and solve a specific problem that's relevant to me that I'll struggle with it. Bit of a silly way to try and learn something as complicated as a programming language I suppose, but it's definitely the way that I know I'll engage with it on a deeper level.
The difference between gathering all system functions at compile time versus run time is when you notice if some are obviously defective. One could say a buggy function never called is no bug just like not knowing about having cancer is the same as being healthy.
Hey. I'm Christoph, one of the co-founders. Glad you like it :) You might wanna have a look here: https://www.quantifiedcode.com/research. And yeah, you can get involved. Either, by applying for a job ;) or by contributing to our community related content: - The Little Book of Python Anti Patterns: http://docs.quantifiedcode.com/python-code-patterns/ - Python Knowledge Base: https://www.quantifiedcode.com/knowledge-base You can also go ahead and create your own code checks and share it to the community: http://docs.quantifiedcode.com/patterns/language/index.html
This is a Github issue, but how do I block QC from seeing my private projects?
Our sign-up procedure makes sure we have only access to public repos. You explicitly have to grant access to private repos. If you already did, you can revoke them here: https://www.quantifiedcode.com/app/settings
DOM libraries don't run a javascript runtime.....
I have a couple project on [GitHub] (https://github.com/evitalis) that I am looking for contributions to. Nothing huge yet but are things I am starting on. It helps to pick an idea you have and are interested in to start, that way you don't get bored of it.
Thank you very much for your reply. I will definitely take a look.
Thanks for your feedback, the refactorings that we have implemented so far are pretty simple, but there's more coming! Also, many people don't use an IDE with refactoring support, having a centralized tool that keeps your code clean by applying the same standards to everyone in your team is therefore super useful we think! We always try to make our service better, so if you have any ideas or suggesions for new/improved features please let us know, we'll be happy to build them (the refactoring support was a user request for example).
Thanks, please let us know what you think :) Currently you still have to manually trigger each refactoring by clicking on the "fix automatically" butten near each issue group, in the future we'll give you an option to to this automatically as well.
We actually offer an on-premise version of our software and we are also building an integration with Gitlab! If you sign up for our newsletter / an account we'll keep you posted on when we're ready with that.
Hey Mishkan, please drop me a message. We do have an Enterprise version (on-premise): https://www.quantifiedcode.com/contact
I've been coming around to that view... I've edited my blog post to include my edit of what I think now. It does provide a interface very similar to Matlab, and it's pretty convenient for short scripts. That's really nice and I still use it during short numerical type scripts. You're correct on *why* I include it: to allow a smooth painless transition. It's often the small stuff that stops people (i.e., stuff like "sqrt doesn't work on arrays!"), and I included to help with that issue.
I've successfully used it with ACOS smart cards. What is your specific question?
Which would be the right subreddit? And i want the program to run in the background and run a js script on every page the user visits. I run the program and everytime i visit a page i want to automatically run a js script on that page. Is that possible? 
wow, how did that happen...?
&gt; `itertools.product` Cool! This is just another example of where I find the standard library already does something I used to do manually. I have a code that I used to use in Matlab to make something like this for unrolling loops (I didn't know ahead of time the number of loops). I made a similar one in Python but it was really not made for this. It was made for multi-indices and I would shoe-horn it into doing this. Now I see that this is just so much faster! Thanks for sharing this tip! As an additional note, if your program/data structures can do it, loop unwrapping makes it work well for using `multiprocessing.map` to really get some speed.
Hi, tried to follow the admin link in your message to find out what's wrong. Can you please reach out to solve this. Not aware which rule I violated. Just answered questions to the post here. Thanks
Yea, that's broken. https://imgur.com/ruj9LuY Pycharm's missed the default value not matching the hinted type.
What do you mean by the type checker doesn't have a problem with it ? Do you mean that the interpreter does not print an error ?
if so: I must admit I never used type annotation before. I read https://www.python.org/dev/peps/pep-3107/ It seems that the type annotation is only informative and not constraining which mean that while you can specify the type, python will not enforce it. (i.e it will not print an error if the types are different) import numpy as np import pandas as pd def function(a: pd.DataFrame, b :np.array) -&gt; np.array: return a + b function(1, 1) # will output 2
&gt; Also, None as a default value changes the type declaration to Optional[int] even though the programmer clearly wrote int. If I'm understanding you correctly, this totally makes sense to me as kwargs are technically optional. 
Yeah I found out. Must be an issue with Pycharm's type checker
&gt; It seems that the type annotation is only informative and not constraining which mean that while you can specify the type, python will not enforce it. (i.e it will not print an error if the types are different) Yes, it definitely will throw an error: Python 3.5.0 (v3.5.0:374f501f4567, Sep 13 2015, 02:16:59) [MSC v.1900 32 bit (Intel)] on win32 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; from typing import List &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; def greeting(names: List[str]) -&gt; str: ... return 'Hello, {}'.format(', '.join(names)) ... &gt;&gt;&gt; &gt;&gt;&gt; greeting(['jane', 'john', 'judy']) 'Hello, jane, john, judy' &gt;&gt;&gt; greeting([1, 2, 3]) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in greeting TypeError: sequence item 0: expected str instance, int found &gt;&gt;&gt; Interestingly enough PyCharm only generates a warning and not an error.
IPython does not complain at all ...
Actually, that's a runtime error in the join method when it tried to concatenate a str to an int. This error would be thrown even without hints and in older versions of python. What Setepenre meant was that it doesn't throw a compile time error. You need a tool like Pycharm or mypy to do compile time type checking.
If you haven't posted a lot, posting a blacklisted link or having a link flagged as spam can cause an instaban. It is to stop bots but seems to catch many real users too. I see about one per month in my small subs.
What is this, a bug tracker?
With the new Github permissions model you can choose to which organizations you give us access, by default we can only see your personal code. 
As I understand you your situation is the following: You have some raw material. You have an application (NLE) which performs some actions and then outputs an AS11 file (the end product). This needs a long time. Now you want to make small changes to your AS11 file and also record which actions your NLE needs to perform to produce the exact same changes. To do this you would need to implement several steps: * Transform a small part of your AS11 file into something editable * Change that part * Merge that part back into your AS11 file * Also tell your NLE which action corresponds to the change you made Each of these steps is relatively complex. * You need information about the AS11 file format. If you are lucky, it's easy, but most film/audio formats are pretty complex. * You need information on how to change what you want to change. If this is something easy as cutting a single frame it might be easy, but can be arbitrary complex. * You then need to transform this back to AS11 format and merge your changes. Wikipedia says AS11 does no inter frame coding, which means you might get away with only changing small amounts of the file. On the other hand AS11 seems to be a complex format. You might well be that you need to write your own encoder. * You need to tell your NLE application how to do the changes you just did on it own. If there is no support for that (plugin friendly or even offers a library for the stuff it can do) you'll probably have to implement lots of stuff it already does for you. If you did all this you pretty much programmed your own editing software. You might have a change if your application gives you some possibilities to extend it and has already most of the parts you need.
Yeah :) I didn't know either so I thought I'd check. Pretty interesting to see and I wonder why it is. Optimisation? C code? Different algorithm? Interestingly, the product documentation describes it as essentially being a nested for loop, so it's funny that it comes out faster.
In a setting like an RPC implementation, it's just another useless data conversion you need to go through that hurts performance for no gain. Especially for transports like ZMQ that are designed for decent performance and want something that works like a buffer I'd really rather now blow a bunch of CPU cycles and do an extra unnecessary allocation of memory just converting from Unicode. The best thing here would just be to do it right and implement zero copy though.
I use msgpack internally for a lot of my applications and it is awesome (along with Thrift and Capn'Proto), but unfortunately a lot of the services I often interface directly out of my purview utilize things like JSON-RPC and again having a performant JSON library especially in Python 3 would be really helpful.
"Here, let us break your code for you!"
Very interesting, I'll check it out!
waves OR pretty lights hot sh!t remixes
What does it do for lines = ['hello', 'word'] for x in range(len(lines)): print "line " + str(x) + " is " + lines[x] if lines[x] == 'hello' or 'world': print 'Awesome' limit = eval(input("Enter in the speed limit: ")) 
Wish I could upvote this more. I find Python a good language on its own, but doesn't seem to help develop good programming practice and discipline. Pascal (as a first language) really shone in that regard.
Trance is life
Look, I'm just pointing something out. I'm excited about this project. I think it's a cool idea. It lacks a feature that makes it even usable by me. My apologies if pointing that out seems to have offended some people's sensitivities. I didn't say they sucked. I just said it lacked a common useful feature. One that has been talked about over and over and over on their forums where I have been contributing as you asked. My main contribution was "add wildcard certs" unfortunately.
I think the easiest way to do that would be to do a few things: 1. Convert your existing code over to a web API that runs on localhost or something. 2. Write a chrome extension that injects the javascript you want into the page, possibly making an API call to your local webserver to fill in the data it needs.
Probably automated due to the fact that he's posted a half dozen times and linked to the same website each time. Very much looks like your typical spammer.
I find a "house music" playlist on youtube when I'm working.
What do you care about? I've started multiple aircraft design programs. They always die after a few months. Then I started a parser for a horrific file format that is very popular in engineering. It's such a bad format that even the commercial parsers parse it incorrectly. If you don't want to pay $20k/year in maintenance, you lose your license and can't get the new versions unless you pay back maintenance. So 10 years later, you're using a version of the GUI that can't use more than 2 GB of RAM. I wrote my parser just to interface with the data in a programmatic way rather than driving a GUI. I didn't care about speed or the RAM issue at the time. That was 4 years ago. It's still in development and the GUI I wrote will make your system cry in terms of IO, but it'll load in huge models and be semi-functional once you get it in. Go grab a cup of coffee. What keeps me going is the puzzle. It's 200k lines of code and easy to manage. Working on huge projects really teaches you good habits.
No worries. Your original post just came off sounding a bit entitled, that's all. No doubt that's the reason for the downvotes. I get that wildcard certs would be slick, but they were very upfront about LetsEncrypt not being a replacement for enterprise and fringe cases, and that it's really just to lower the bar (at least for now) for those personal sites or small businesses that don't encrypt because of cost or complexity. I'm sure they'll add features when they get the resources. It's all good. Have a nice day dude. 
My coding playlist today is all Stone Temple Pilots / Velvet Revolver. Generally, I listen to a bunch of different kinds of music; I used to try to figure out what made me the most productive, but I think it's generally mostly the same. Currently the most frequent band in rotation is Tool; that's just because they're my favourite band.
Fran Drescher and Rosie Perez arguing.
Do you use any GPL or AGPL licensed modules to run your service? If so, I'd be interested in the sources.
* [Lazerhawk](https://www.youtube.com/watch?v=QpDn4-Na5co) * [Kavinsky](https://www.youtube.com/watch?v=MV_3Dpw-BRY&amp;list=PLriYE9INvlUQTWPFIhC4Aa9LYKNoFNvTK) * [Angerfist](https://www.youtube.com/watch?v=csMGq6AGLNU) * [Tesla Boy](https://www.youtube.com/playlist?list=PLr8patWu93SM3og9TdZraNxV4HJ6JSPY8) * [Miami Nights 1984](https://www.youtube.com/watch?v=J52rN0aNfYI) * [Nujabes](https://www.youtube.com/watch?v=WrO9PTpuSSs) * [Air Gear OST](https://www.youtube.com/watch?v=D1qAA9BjMjc) Edit: Air Gear OST link.
goth metal
For YAML, the example shown is the tip of the iceberg while for TOML, that is a reasonable chunk of the syntax
thanks!
Hi. Can you detail what you mean with 'lacking website'? We decided to raise the secret key issue as we saw a lot of repos that published them accidentally. You can turn on all code checks in your project settings or by ignoring specific files. In our docs you can find how to exclude files via a .checkignore file ( works similar to .gitignore). As stated below, we are not aiming to build an IDE replacement. Happy to hear what kind of refactoring a you'd like to see so we can add them to out roadmap.
Normally trance or chilling genres like New disco. However if you need some creativity, I highly advise kpop/jpop. I dunno what's up with them, but they often got the 'it' to crack me up.
You wish. Also irrelevant. Go pack bits if you value simplicity and speed over usability.
In my trial period a while back, the website felt unresponsive. It took a while to load a simple web page. The website 'finished loading', but then started loading via Javascript (why?). I have also posted a screenshot of an error I got quite a few times and now also get when visiting the website linked in this post and then clicking on a link. Excluding files using checkignore is not what I was referring to. I want to ignore certain errors, not whole files. I still want you to run a PEP8 check on my Django settings file, but ignore the secret key. I'm sorry for my negativity towards your product, keep it going anyway. Guess I'm just not the one you're targeting.
Why hello there half username buddy.
by visually, you mean "with code examples". so explained the normal way. 
would you mind sharing your approach?
This pretty cool, I think there should be a service like this for most mainstream languages.
Agreed 100% - there was a point in time when Perl was an amazing alternative to the other options we had. I dont' think it's fair to bash it using today's standards for languages that fill the role it had. 
There's a few apps that can help you build binaries that'll package up all the dependencies (including python itself) and put an EXE wrapper on it. Look into [cx_Freeze](http://cx-freeze.sourceforge.net/), [py2exe](http://www.py2exe.org/), [py2app](https://pythonhosted.org/py2app/), and [PyInstaller](http://www.pyinstaller.org/). I'm sure there's man more I don't know about. The field is a bit of a mess, with a lot of duplicated effort and weird conflicts. You'll just have to research the options and see which ones work for you. 
What is the purpose of this script? Couple of thoughts, in no particular order. (hopefully positive critique) * Use argparse instead of optparse * typo on line 24: os.system not s.system * consider using subprocess if you really have to use shell. * [requests](http://docs.python-requests.org/en/latest/) or urllib would be better 
That's not a fair observation. Windows is certainly the most-used OS, and if you are a Windows developer, chances are good that you will use Windows for most of your development, often without any real choice if you work in a large company. When I was a Windows developer, I used Cygwin at work, and Linux at home for my personal system. I was certainly not alone in this. Most of my coworkers used Cygwin, and Vim as their main editor, using Visual Studio mainly for debugging and compiling. But what does Python have to do with it? First of all, it works on both platforms, and second, it isn't used exclusively for Linux development - there are many other languages, not the least of which is C/C++.
In my 20+ years of software development, I've found that programmers are often the least likely to try new systems voluntarily. Most of the ones I've known prefer to spend time coding, not trying out something new or even learning tricks of the OS they use. Whatever works for their immediate goals are good enough. Notice I said most that I've known; I don't pretend to know what goes on outside that subset, only that it does exist. Personally, learning new things is part of what kept me from burning out too early. But still, I tried and abandoned Linux many times before it finally stuck, and now I can't stand to use Windows. So, I understand the context of what RedKrieg is saying; to me (and I guess him), it *is* painful (to us, not necessarily to them), but to most, it is less painful than learning something totally new that doesn't "just work", something Linux has never been accused of doing.
Slow rich electronic: * Jon Hopkins * Andy Stott * Tim Hecker * Oneohtrix Point Never * Four Tet 
Wtf does that code do?
And why
Who said it did anything? I want to know what their tool says when given that as input.
\#1: Go to /r/learnpython \#2: I'm certain that there are tutorials online, the game you're looking for sounds to me like [asteroids](http://www.freeasteroids.org/)
Just add it to a repo an give it a try ...
yeah really enjoy four tet already - will check these out thanks. also tend to hit up boiler room sets on youtube.
If you're interested in machine learning and algorithms I have a [project on Github](http://github.com/lmcinnes/hdbscan) that does clustering in python via a new algorithm called HDBSCAN. Any contributions are appreciated. In particular if you can get access the the [recent (2015) paper on the algorithm](http://dl.acm.org/citation.cfm?doid=2808688.2733381) they discuss various visualisation tools; we're pretty slow at getting tho those -- we have some basic plotting (see hdbscan/plots.py), but would certainly welcome any work on that front. If you want to really dig in a lot of the code is in Cython, so you're C skills would not go to waste either.
&gt; many people don't use an IDE with refactoring support What's your source for this statistic? Stats aside, if someone isn't going to use an IDE with such support, why would they use this tool instead?
Doesn't PyCharm already do most of these types of refactoring?
Indeed. I add to this some heavier stuff like isis, pelican etc. All good stuff Thanks.
Yes it does. If I manually pass it None it works. Hence the type you accept is optional 
Thanks! And so close! http://games144.com/game/35988-meteor-shower-game.php Except my turret is on the bottom not the top of the screen
Slayer, lots of Slayer.
Thanks for pointing this out. We'll verify this. If you like, just change the pattern yourself. Public patterns can be edited by our users. Would be awesome, if we could include a performance comparison :)
Hey, did you knew vim/emacs and other editors have support for plugins? Yea! Python doesn't require a full-featured IDE. A text editor with code completion, syntax highlighting, fuzzy file matching, ctags and syntax checkers is all you need. And you can have all that with vim (the one I use), emacs and I believe any others.
Well, at least we can blame someone else if it doesn't work!
I've listened to over 400 hours of Metallica between now and May. They're pretty good 
Very nice! It still does not fully respect PEP8, but otherwise impressive.
Yes, it works even if you've specified the argument as a plain int. It shouldn't work. If the programmer has explicitly defined as int, it should remain an int, not automatically infer the type as Optional[int]. The assignment of the variable to None in the function definition should is a type error. You shouldn't be allowed to pass None to a function that takes an int. If you need to represent lack of a value, use the type Optional[int].
The difference is that we can specify the type of an optional argument (as opposed to arbitrary kwargs whose types you cant specify in code). If you know the type of a variable at compile time, why not check it and save yourselves from nasty bugs. EDIT: This is the exact bit I'm talking about in case it's not clear def f(a : int = None): ... Every time f is called without an argument, basically, you're gonna do "a = None". Here's where the error is. I can understand people's skepticism towards compile time null checking but in the following case, the behavior is totally unacceptable. def f(a : int = "asdf"): ... a : int = "asdf" # This is an oxymoron.
Or if it's an app rather than a system tool you can isolate it even further using containers or vms.
Is merging existing files easy? Then you could split up the pre-postprocessing version into 20 segments. Rerender the ones you want to change from scratch, then merge the segments together for the final. 
List comprehensions the movie was pretty fun though.
Nope. Language is a social construct. Words have pronunciations, even meanings, because we have a consensus on what they are. The consensus here is 'sigh pie', just like every other python package that ends in 'py'. If you want to get pedantic, the word list you posted consists mostly words that end in 'p' that have been modified to take the -y suffix. [Educate yourself about this suffix.](https://en.wiktionary.org/wiki/-y#English) As there is no English suffix '-py', python is entitled to set its own rules. Since the social consensus is that this suffix is pronounced 'pie', you would be better served using it, since it allows you to communicate and be understood. You correctly pointed out the word 'spy', which rhymes with 'pie'. In this case the y is not a suffix, but rather a primary vowel. This is also true of 'copy', which rhymes with 'pee'. So here, once again, we have a social consensus on the pronunciation - one that is inconsistent. So I recommend you go around asking people if they 'spee' with their little eye... gotta make it consistent, you know, and the language is wrong! 
Power metal and female operatic metal. Dragonforce, hammerfall, iced earth, Nightwish, edenbridge, delain... If I'm in a "no lyrics" mood, usually hindustani classical - Nikhil banerjee and ustad vilayat khan on sitar are my go tos
Movie soundtracks can be pretty good. [This](https://www.youtube.com/watch?v=yydZbVoCbn0) for example.
Ditto on using something like HDF5. It's great with PyTables, and you can easily turn your datasets into NumPy arrays. Thanks for the link about Arctic, looks interesting.
[S.U.N. Project](https://www.youtube.com/watch?v=5y9IspygEJw)
I suspect your problem is not with python or with docker, but with your shell. Every example I've found quotes the A=B section of the environment parameter to docker. e..g.. docker run -e "IP_AD='1.2.3.4'"... Your python looks fine and your docker command looks otherwise fine so I guess your shell is parsing the assignment. You can test python code that deals with environment variables outside docker by running e.g. `A=B python someapp.py` Which I highly suggest you do as it seems you are trying to learn python and docker at once.
Touhou fan music. There is literally terabytes of this available for free on the internet and covers pretty much all types or styles of music.
I like white noise like a fan or rain. Not exactly music but possibly the effect you're looking for. 
I write my code in notepad++ and run the script from a shell. 
I think that is clarified in his next line. Specifically, he wants to remove `from foo import *`.
It's one thing if you rely on an IDE and have no idea how it works and another when you use a tool to make your life easier (but understand it)... That said, no need to jump to IDLE in your Python (or other) programs, look at the build systems for sublime.
Even if it's in Spanish it would still be useful to me
Jazz music is great look up some relaxing jazz playlists..
import imp foo = imp.load_source('module.name', '/path/to/file.py') foo.MyClass()
"teammates"
I use jupyter notebook but I mainly just deal with data analysis, reading a d writing files etc 
OK, how's that going to fix the legacy code base? It's easy to play "armchair manager" but there's a lot of legacy code that may stink, but is making money. You don't fuck with legacy code just for the sake of fucking with it... even with shitty code, there's a lot of value in putting code through qa, and soaking it in a production environment. You can't just flush value down the toilet, especially when it's going to cost even more to refactor said code, send that code through QA, etc.
Interesting. Is it easy to append to artic? I'm normally writing to csv but my biggest challenge is that dtypes aren't stored. I have to append new data everyday (the previous days data). I used hdf5 but I had difficulty storing categories, I tried to convert all of my string data into categories but there were errors when I would append. I also want to connect tableau to the final output which only connects to csvs or databases 
Is it even an anti-pattern though? I mean, as opposed to a gotcha that beginners face.
Ooh, awesome, and thank you.
I used to exclusively use sublime with anaconda for python completion etc.. Recently I've started using pycharm and man is it awesome. It's not as quick to open as sublime and doesn't support as many languages out of the box, but editing is such a pleasure in it. Want to rename a variable? It finds all uses and renames it. Want to edit sql statements or regex? You can drop into that language for just that part of your code. With regex there's even a regex tester you can feed data and it tests against your regex. Autocomplete is great and it even completes imports for you. Eg if I type pprint it offers to import the module for me and also shows me other places I can import from. Seriously, if you do a lot of python work, check it out. Commit a day or two to it but it's really a productivity booster. 
This might be a little premature, but I'm working on a blogging platform (written entirely in Python, natch) that has a friendly WordPress-like front end, but will eventually include a CLI: https://github.com/syegulalp/MeTal I say "premature" only because while I have it running, and in fact use it to run the blog for the project itself, it isn't quite yet in a state where I feel comfortable letting other people install it and run it. I'm hoping to have something that can be publicly alpha-/beta-tested this coming spring or so. (Screenshot of editor interface: http://metal.genjipress.com/2015/11/look-at-that-interface.html)
You should use /r/learnpython instead. But, just do `sorted(json_data["entries"], key=lambda d: d["leaguePoints"])`
I suspect that your docker container is not running an interactive shell, where is the env var set?
Interesting. I wonder if people have used any more advanced mathematical functions with this feature.
One would need to write a Python program to possibly find some common uniting theme in that set.
Vim style navigation is wonderful. I use Sublime Text with the vintage plugin (vim), Anaconda, and SublimeREPL.
The imp module is deprecated. spec = importlib.util.spec_from_file_location(name, file_path) module = spec.loader.load_module() module.MyClass() I would love for someone to show me a better way to do this using importlib.
 print(*(number for number in the_list if number &gt; n))
from x import y?
that... Murcof,Deru,Bola, Autechre and soma.fm 
C# is pretty decent as well in this regard.
This is his solution for shortening calls to functions under the restriction that only modules could be imported. Personally, I think this bit is overkill. It's rare in Python that I've had to dig too deep for where a function was called from. I make a effort to only import modules in my own code. Sometimes I'll do something like `import sqlalchemy as sql` if I intend to use several functions from a module. But even `from foo import *` has a reasonable use case for me. For example, wrapping a utility module with additional utility functions.
Hrm. Reddittor for one year - 33 karma. In conclusion, you're trolling. Been a slice.
I actually submitted something like this here and got downvoted to hell (https://www.reddit.com/r/Python/comments/2v2ata/import_path/). But, I accept that it was justified. It is somewhat of a corner case, and it is something that is possible with some sys.path magic. Readability trumps convenience in this case.
Grow a sense of humor, jackie.
Yes, that's exactly what you're supposed to do. 
Thanks, I'll have to take a look at that. The screenshot looks pretty nice! What is there left to do before you'd consider it ready for beta testing?
As of 3.4. 
When you write a declaration like this: def spam(arg:int=None): there is a conflict between the type declaration and the default value. You can't say that arg must be an int *and* that it has a default of None at the same time, so there's a conflict between them. You want this to be an error, but Guido believes that this example is common enough to deserve making it a special case. Using None as a default is so common that the type checker should infer that you meant "None or an int" rather than just an int. I believe that if you use some other default value, you will get the error you want: def spam(arg:int="hello world"): ... should detect a mismatch between the declared type and the default value. However I haven't tested this, and besides it will depend on which type-checker you use.
This is no shorter, but maybe clearer: loader = importlib.machinery.SourceFileLoader(name, file_path) module = loader.load_module() module.MyClass() Tested in 3.4. I don't know which snippet would be considered the better way to do it.
Yeah the idea would be to prepare the raw data (coming in so many different formats from various external partners) and load it into databases. Right now I'm the only person in the company with a tableau license but everyone was impressed with some of the output so we are piloting a server for one of our bigger accounts. And as I mentioned they are authoring me to hire people and purchase software. Tableau is cool and great and has a lot of advantages over excel, but very few people understand the work being done before tableau. The primary keys, the merging, and concatenating of separate files, the remapping and string manipulation etc which is all being done in python. They basically want me to take what I have done and apply it everywhere. Everything I know is basically from watching pydata YouTube videos and then when I run into a specific problem with real world data I search stackoverflow.com. I'm lacking a lot of the basics ( the other day I was reading this subreddit about how people would resign if they had to use Windows and a lot of the comments made me realize how little I know about the basics and how inefficient I probably am). 
Good luck with that.
Looks nice, but when I see this: &gt;&gt;&gt; 1 &gt; 2 True &gt;&gt;&gt; 'abc' &gt; 'abd' True I start to wonder what other silly mistakes are still in there. First make it right, then make it pretty and all that. (http://pycubator.com/02-variables-and-simple-data-types.html#/1/7)
PE8 issue is fixed
Send me your email in a pm and I'll share the document with you. 
I figured out that would be a way. But i'm looking if it's possible sort of like an MITM attack with a filter in ettercap but then a program only running on the users computer. I thought maybe that's possible with a python script. 
https://gist.github.com/rtt/f0e45a1caf061937acdf something like this, and tidied it up a bit for you
I can't find any options that give a pull request.
I'm using Vim, I've started with Vim a couple months ago, and it's great! In the beginning it's hard, but the shortcuts are amazing. I can't live without them. It's also nice when you want to run a script. You can directly run it from Vim in the shell. :!python script.py and you're running it! You have a lot of plugins to make the life of a Vim user even more productive. Different auto completion plugins, different code linters or syntax checkers. Vim also runs on about any Unix based OS nowadays. 
The SQL was shitty though. (see what I did there!?) 
&gt; but they made clear that they had no intention of entirely taking out the market Did he say why? If this is going where I think it is you will more or less be required to serve over https instead of http in the near? future. To be forced to pay for certificates when they are required isn't anything positive as I see it, the companies selling them has an unfair advantage towards the customers and I don't mind seeing them go out of business. I must add that I don't know why wildcard certificates differs from non-wildcard ones, if there is an additional cost for the CA when it comes to wildcard certificates.
You are right, will fix... Still, I can grantee there are more mistakes, and that's part of the reason I am open sourcing it, so the community of Python teachers can work together to improve it (it's hard to find your mistakes alone)...
There are 2 caveats. But before I start, I'm no Bokeh expert so bare with me if what I'm saying doesn't apply. 1) ignore colors, use geometry. I mean: different curves must be identified with different lines ( continuous, dotted, line-dot, etc). Filled areas mid have different fillings (empty, hatched, dotted, slashed etc). That's because usually publishing houses send the off preview to peer reviewers in black and white. Also, color printing of you paper is usually more ( I mean, much more ) expensive. Not all journals offers color printing. So, basically, take care that you paper is pretty darn clear in bw. 2) LaTeX supports a lot of formats, from bitmapped to vectorial. You can simply export a long from your plot or find a way ( I have no idea how feasible it is in Bokeh) to save an eps, ps or svg. There are jpg and png packages to import those files. Also, note that you usually sign a copyright transfer authorization when submitting a paper. Preparing an html version with interactive plotting, although amazing, to post on your blog, will result in a copyright infringement ( yes, even if you are the paper author) Edit: autocorrect fantasy 
Thanks for the help inclemnet!
Last time I dug into the source, importlib was still calling the imp module... just with a lot of shims. So no arguments here.
 import data_processing_module as dpm dpm.process_data(..) Isn't a good compromise?
 &gt; 2) LaTeX supports a lot of formats, from bitmapped to vectorial. You can simply export a long from your plot or find a way ( I have no idea how feasible it is in Bokeh) to save an eps, ps or svg. There are jpg and png packages to import those files. The problem here seems to be that headless (whatever that means) static generation of svg or png [isn't supported yet](https://github.com/bokeh/bokeh/issues/538). Seems to be coming in 0.10 though. &gt; Also, note that you usually sign a copyright transfer authorization when submitting a paper. Preparing an html version with interactive plotting, although amazing, to post on your blog, will result in a copyright infringement ( yes, even if you are the paper author) Luckily enough, I work in a field where Open Access has been the norm for the past five years so no worries there. 
install pygojbect using your distribution package manager (if on linux) or using the windows installers here http://sourceforge.net/projects/pygobjectwin32/
This has incredible potential.
do your own homework
You can output matplotlib figures to svg. This makes it better than nothing. That way you can maintain your matplotlib plots that you like and slowly migrate to other stuff. No reason to do it all at once if it's going to keep you from doing science.
The copyright point while true is really journal specific so it's better to ask than to assume you can't.
&gt; Python 2.7 is not supported Nice, Zed Shaw can suck it.
Yes, they are trying to keep things as simple as possible. I think in the future, they may actually wind up overtaking the other auths, but then I am not sure this is actually ideal to have only one authority. They also need the other authorities for the certs IIRC, so they probably also just don't want to sound threatening. As for the wildcard question, whether or not there is additional cost, I am not sure. Clearly there is for subdomains in general, each seems to be a cert. Right now, Letsencrypt is limiting how many subdomains you can tack on to your registration to a pretty low number, so maybe it's just all about getting through the initial bulk of registrations. After that, maybe they will open the flood gates. I think their intention is to not let things break.
I use sublime text and have to admit I'm getting tired of the license request pop ups. These threads are click bait for me but they're so interesting. for a little while now I've pondered moving to vim and I think it's time. I'm already a keyboard shortcut only Obsessive. I've used PyCharm as well and do enjoy the multitude of features it offers. But I'm not sure it's heavy nature is worth the benefits. I go back-and-forth. 
Though I would suggest you to find a problem which you really want to solve and try to do a project on it. But if you're unsure of it right now, then I have a couple of Open Source Projects on my [Github](https://github.com/CuriousLearner/). Feel free to contribute if you find any of them interesting. Also feel free to ping me.
There's already dishwashers you can control from your phone, so translate that into Python code...
This reminds me of `apropos`, which searches man pages to find a useful program.
!remindme 5 days
Messaging you on [**2015-12-10 15:56:09 UTC**](http://www.wolframalpha.com/input/?i=2015-12-10 15:56:09 UTC To Local Time) to remind you of [**this.**](https://www.reddit.com/r/Python/comments/3vhojc/pydata_nyc_2015_videos_are_up_so_many_good_talks/cxo3r4m) [**CLICK THIS LINK**](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/Python/comments/3vhojc/pydata_nyc_2015_videos_are_up_so_many_good_talks/cxo3r4m]%0A%0ARemindMe! 5 days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! cxo3rjm) _____ |[^([FAQs])](http://www.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^([Custom])](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^([Your Reminders])](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^([Feedback])](http://www.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^([Code])](https://github.com/SIlver--/remindmebot-reddit) |-|-|-|-|-|
Python 3
This could be cool if it had just indexed full-text search of documentation for pypi modules, classes, and functions or could even just index the modules/classes/functions of the modules installed in your python environment and made it easy to import them. For example, I always waste time finding where `gcd` is (in `fractions`) or `comb` (in `scipy.misc`) or try to find where to import something in django. But as it is, it seems pretty useless. There are by my count 17 currently "answers" which are functions that could be found. Almost all of these are one liner functions that are trivial to write in python. Also when questions are specified like: import funcfinder def how_to_check_if_number_is_even(func): assert func(2) assert not func(3) assert func(4) funcfinder.ask(how_to_check_if_number_is_even) There are an infinity of functions that solve that unit test. It's incredibly underspecified. (`is_even`, `is_power_of_two`, `is_not_divisible_by_3`, `is_not_3`, `odd_number_of_bits_set_in_binary`, `less_than_6_degrees_to_1_via_collatz`, etc.). It would be a fool's errand to try and specify a function like `x % 2 == 0` via a series of assertions of that form. Further, if you need some complicated real-world function it would be even more difficult to use. How would you specify tests for say the django [`annotate`](https://docs.djangoproject.com/en/1.8/ref/models/querysets/#annotate) or a [JsonResponse](https://docs.djangoproject.com/en/1.8/ref/request-response/#jsonresponse-objects) or a [`send_mass_mail`](https://docs.djangoproject.com/en/1.8/topics/email/#send-mass-mail)?
This idea doesn't belong as a gitrepo. It belongs in an augmented version of Stack Overflow.
It's still extremely frustrating because it requires that the module you do it in knows that it's a part of a package, which modules that you just run obviously don't (unless you utilize truly terrible hacks), which leads to great bother when running tests etc.
Anyone else found the interface confusing? I ended up wondering what arrow I should click to get more content about the current subject, or if there even was more, or if all the arrows would just take me back or on to other subjects. 
I need a python function that automatically solves problems of the form "I need a python function that automatically solves problems of the form 'I need a python function that automatically solves problems of the form "I need a python function that automatically solves problems of the form STACK OVERFLOW
About the problem u r trying to solve: Most of this routers has a ssh or telnet interface where u can login and do some CLI commands, like reset. Maybe a script using this interface is easier than Web scrapping 
Try it on your Computer. Site has some issues on mobile devices.
Anaconda + WingIDE (since I like the stackviewer and other debugger functions better in Wing than others.)
The attitude of a piece of shit. You think you're some kind of prince? Get the fuck out of here bitch and do your own homework.
I'm worried I'll find out my dirty dishes are immutable, and that I'll have to wait for the garbage collector to remove them from the heap.
Import dishwasher dishwasher.dishes(load="full") 
nope, its a new one that has no way of getting to shell. It has a command line menu with no menu to reboot or reset and clear logs. The only way is to login and press a button to login, the press another button to clear logs . I can login using beautifulsoup and a number of other ways, so I need a skeleton code to see how to press a button. Something that can record my strokes would be ideal
Absolutely. As I said at the beginning: &gt; This repository is a basic implementation of this idea providing the most essential features. It's an experiment to see if people are interested and willing to contribute questions and answers. If so, it may be turned into a complete website, which could ultimately mean answers appearing directly in Google searches. Imagine having all of the above, with no installation effort, a fancy frontend, maybe even integration with Stack Overflow.
I've created something similar: https://github.com/Bystroushaak/normalize_cz_unicode
I need a function that realizes potential. (also makes me rich, gets the girl, etc)
 def control_dishwasher_from_phone(dishwasher_function): if not planned_obsolescence(): contact_manufacturer(login,password,zip,age,salary,dishwasher_function)
Not even sure what either of those are...but I will absolutely look them up. I still have to do some of the more demanding stuff like setting up a new server , working on our time clock system, etc. Hopefully can run it by my boss and make sure he's cool that I take some time to convert all existing code to 3.x Can python 3 still use PIP? That thing is a lifesaver. I'm guessing i'll have to re-install any modules i've installed on 2.7.x? 
Thanks. I don't think math is particularly going to be a big issue for me. I will look into it.
From what I could find online, it looks like this feature is not used very often. Possibly this is because setting up a virtual table can be quite cumbersome. Math and analytical functions are a great fit, though. Hopefully we will see some open source libraries start to show up!
Glad to hear you're liking peewee! Thanks for reading and for the kind words.
This function returns a collection of dishes from the `load` identified by the string `"full"`, right? And the target dishwasher is selected automatically based on environment variables. When run in larger scale operations with multiple dishwashers is it a round-robin selection or am I expected to deploy them behind a load balancer anyway? Thanks for your help, this is a great project
Pip is still there in python 3 :) But yes, you will have to install all packages. Keep in mind that not everything has been ported to Python 3. 
What advantage have over [importlib.util.LazyLoader](https://docs.python.org/3/library/importlib.html#importlib.util.LazyLoader)?
wait, so I don't understand. What's the difference between this and doing a google search? I mean, sure, the code might be exactly what you need, but if it isn't, then there is literally no difference between this and a google search. And, AFAIK, it's practically impossible to make a complete set of all code needs, hence the reason why SO or Google hasn't done that already. Is there something especially achievable about this goal that I'm not recognizing? Don't get me wrong, you have my upvote and star, but it just seems like another one hit wonder repo
I couldn't because some columns were astype category. Got errors when I tried to append new categories. The other thing is that I wanted to connect tableau to the end result. So my choices are databases or csv files. If I could connect to hdf5 then that would be great. 
My personal hated quirk is how `import os.path` silently puts `os` into your namespace. I understand why that's necessary, you couldn't refer to `os.path` otherwise, but it's still weird. For example, import os from os import path as os_path is not weird in the same sense, you have an explicit import, two even. I don't know, just something that bothers me.
I think it's easy to append to arctic since that's one of the main use cases. It uses mongo as a back end so, there's that.
Let me introduce you to my friend recursion : ^ )
Dubstep.
`import dishwasher` `import maid`
I agree with you, but geez, no need to be rude about it.
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. Cheers &amp; best of luck with Python!
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. Cheers &amp; best of luck with Python!
I think the thing is he wants to not allow importing individual functions. 
My bad my bad! They should be identical to blocks [8] and [9], I'm sorry, I'll fix it now. Guh. It's because I was manually copying it out of the terminal.
PyCharm is the nicest Python editing environment. The sentiment that you don't want to get used to an editing environment is silly. Tool use is what separates us from monkeys, and being **really** proficient with a powerful editor is one of the hallmarks of a great programmer.
The vast majority of journals I have submitted to only copyright their published version; meaning the version that has their formatting and markup. Nearly all journals will allow you to share the work, word for word, outside of the journal (which is why sites like arxiv exist as long as its in your own format (and not republished with a competitor). 
Don't think I fully understand what you're trying to do...can you explain more? Are you talking about saving ARP/RARP requests? 
Any links to the work of the brilliant Haskell guru? I'd love to see what that's all about.
Video: http://begriffs.com/posts/2015-10-16-internet-of-code.html Blog: http://www.haskellforall.com/2015/05/the-internet-of-code.html There's been many discussions of the topic over at /r/haskell. The guru in question is /u/tekmo.
yes, with the date and time of the request with gps coordinates. 
I can't speak on how to handle this live using sockets or whatever but my recommendation is to look into a packet capture package or repo. https://github.com/KimiNewt/pyshark - haven't used this but looks somewhat promising Or just generate a pcap file in another way from a regular shell and loop thru the requests and save what you want. I'm unsure how GPS related to this though
Ah I see..something I found online... "Kismet keeps log files, usually in the same directory you run kismet in, but it's configurable. The one ending in .dump is a pcap file" Write a python program that will open that file and loop thru the requests for what you desire then append that info into file or save in database. Unless you configure kismet to only output the ARP/RARP info you want, then your problem is solved.
built-in unit and performance testing for one. it would be great if SO could integrate this and make it very easy to submit questions/answers that conform.
Ok.
Instead of doing i=i.strip("avi") i=i.strip("mkv") you should do i=os.path.splitext(i)[0] By doing so, you won't have to update your script if you ever end up with different file formats. You also don't need to write if(len(s_result)&gt;0)): you can simply write if s_result: I would recommend using tools like [pep8](https://pypi.python.org/pypi/pep8) to help you write better Python code.
I fell in love with Python's import system. I come from Delphi. In Delphi you do this: Uses System, Collections, Whatever; You can only import whole units but it also puts all the individual items in the namespace! So if system has a function "compute" you can just reference "compute" (which is what everyone does". You have no way of knowing where the function was imported from. No one finds this a problem. Worse, if you "Collections" above also has a function "compute", it now not only overrides the "System" one but it doesn't even issue a warning! One of the most prominent voices in the Delphi community insists that this is a *feature* and that as such there should never be a warning. Sigh.... Everything about the import system is bass-ackwards. A library itself has to be defined as such; you can't just import from regular code. What the library exports is defined *in the library*... the user of the library simply has to take whatever's exported and can't get at anything else. Want to rename a function? Bizarrely, this can only be done in the export section of the library itself, not in the code importing it! Why a library author would call a function X but want it exported as Y rather than just calling it Y from the outset I'm not sure. Python's import system is simple and clean and clear and beautiful. Python users should appreciate what they have. No include files, no namespace pollution.
What was the point? To show how inefficient pygame is? The title should be "Pong, a game once so optimized that it ran on 128 Bytes of RAM, now re-created with a runtime only second to Java in bloat, using the maximum amount of Memory available to the process"
This wasn't about getting it to run on ancient hardware and to be the most memory efficient. Not the point of this.
To show what its like building something end to end. I found it insightful. 
Cool stuff! I've done something similar using a raspberry pi and some rf hardware. If you like home automation you may be interested in investing in some of this stuff, its much cheaper than hue and the likes! http://rememberhacks.com/rfcontrol
I've been trying to explain this to a colleague but he insists that isn't true. 
I'm not familiar with Pygame, and maybe the answer is in there... but I don't see any way to control the 'opponent'. Nor do I see any 'ai' for competing against the computer. The source code [here](https://github.com/Max00355/Pong/blob/master/pong.py) doesn't answer the question that I can see. In fact, I don't even see a way to control your own player. Can anyone explain?
My tutorial series is for programming beginners with very little to no experience. It's divided into short specific videos so that it's also easily searchable. As far as what makes it completely unique? Well, that'd be me! Also, I do plan to make other sort of tutorials after I'm done with this series. This is just to get me started with this type of content.
That can be found in the updateOpponent method. It's just a couple of if statements for the "AI"
Sorry for the delay and thanks for the tip. I'll check it out.
Videos are probably the worst way to learn anything other than a high production value show like Nova or something. Videos * aren't searchable * lack the interactive component of an actual in person lecture * lack any sort of text functionality (e.g. copy and paste) * often the spoken words are less thought out than actual text and if you find a mistake are really difficult to fix compared to text Videos are a poor substitute to written documents outside of very specific use cases. So make a blog instead.
GPL 2.0 only massively criples who can use that
There's no tutorial for PyQt5 on youtube. You must create video tutorials in latest version of PyQt5. I only see PyQt4 tutorial on youtube. 
This could *really* use a screenshot with each example.
Each example is a program that can run on its own. It should be a hands on learn-by-doing (and later used as a reference) so I encourage everyone to run each example and see how it works. That is the best way to learn. You can actually copy and paste them right in to the interactive interpreter (except for the couple that need sys.argv[1]). Edit: I have since added screenshots for most examples.
And then write a article how you approached writing the above application. 
Gotta learn the semantics, after that it's explicit enough.
You're welcome to your opinion.
Lost me at &gt;[Tk] *used* to be ugly Ran some examples and no, it's still ugly. 
Oh god, PLEASE tell me it plays "Sex Room" by Ludacris when you hit the bttn... Awesome.
It will be greate if you can cover the content http://magizbox.com/index.php/code/
Write a program that writes both the programs and the articles about the programs. For bonus points, have it write progressively more advanced versions of itself.
It needed to be done, otherwise he'll think he's clever to try to make other more mature and experienced developers do his work while he sits his ass in front of the console and plays CoD. He insulted us and our intelligence, he doesn't deserve a different reply. He didn't ask for help, he asked US to do his homework, and not even in a gentle and polite way. So fuck this little bitch.
Actually the first track is "Let's Get It On" by Marvin Gaye. I'm still tweaking the playlist, it's mostly been for testing purposes. The Sexy Time mode is mostly a (hopefully amusing) ice-breaker for somebody with my sense of humour. I should figure out ways of switching bttn endpoints quickly :)
This would effectively reduce the power of Python. Python is not just used for traditionnal programming. it's also use in penetration testing, one-off scripting and exploratory programming, using either a shell (the python shell, ipython, the notebook ptpython, etc) or a quick and dirty strict. In these areas, the import system is exactly what needed. When you are using the shell to analyse a one time batch of csv data, you don't want to do itertools.stuff all the time. When you are under pressure to beat a security system in a short time, you do want "from x import *". Please, please... These days, I see way too often people advocating to change deeply Python to suite THEIR way of using it (FP, async everywere...), forgetting Python is not just for (scratch the one you don't need) Web programming/sys admin/big backends/data analysis/small scripts. It's an incredibly versatile tools, and is used in many, many ways. That's one of its strength, and why it beats the hell out of JS/PHP/Perl/Ruby that specialize too much.
Here's another one about optimizing DRF. https://ses4j.github.io/2015/11/23/optimizing-slow-django-rest-framework-performance/#
Depending on how you'd like to implement it, I'd check out libpurple https://developer.pidgin.im/wiki/PythonHowTo or xmpp http://xmpppy.sourceforge.net/
Oh I see. So if I got this right, you use Windows as a *guest* on a Linux *host*? And then NAT the traffic so you can do all your work from the host directly? That's actually a fairly good idea.
Thanks! I'll look into it!
You could always switch it for one of my favourite violent femmes tracks, would definitely test the sense of humour... https://m.youtube.com/watch?v=rDEQY4Qliag 
Because some of us don't want to (or can't) use the GPL license for our free software.
I don't know if it will be a problem but my available model isn't in RoboDK library. I assume that I will need to add new robot in my case :D
This.
Thanks for the idea! I'll add it to the list :)
Kivy is really good.
Would you mind elaborating on this? Does this mean your main program logic must reside in a web server? Or are you using a built in web server provided by flask or something? 
There is a button called "Fix automatically". You'll see it on issues we can already fix. You might not have any of those though. Checkout our "How it works" page or add our quantifiedcode/demo repo from GitHub, to check things out.
Would these examples show up in an IPython Notebook? If so, how about showing the code examples in a notebook? Also, how about sharing this material on GitHub so people can contribute (e.g. by adding screenshots)?
I am not sure if it will work in the IPython Notebook but I have a feeling it will not. I don't have a separate repository for these Tkinter code snippets but they do live in my cookbook/reference repository: Cookbook: https://github.com/NanoDano/cookbook Cookbook-&gt;Python-&gt;Tk: https://github.com/NanoDano/cookbook/tree/master/python/tk 
Christ why all the downvotes, what he's saying is a perfectly legitimate reply
People still use tk?
Just checked and they don't show up in the notebook.
Yes. Version 8.5 has come a long way and improved the look and added new widgets to choose from. It is also packaged with Python itself so users on Windows/Mac OSX don't have to install any other dependencies. On top of that it is simple. I find it very useful and convenient for writing and sharing tools. The only reason I _wouldn't_ use Tk is if there were special needs that the existing widgets did not cover, or if it was an application meant to be marketed to customers where the aesthetics would matter more. The last tool I wrote was a Linux server monitor. It would list all my remote servers and color code them based on their status. I could click on a server and open a new window with more details to get a quick idea of how much memory is being used, disk space, who is logged in, view logs, etc. Don't really care how pretty it is, but it is very useful to me and easy to share and did not take many lines of code. No, it is not the newest and shiniest or have all the latest features, but it does serve a purpose (especially quick and dirty GUI stuff). I have used other GUI libraries and they are more work to set up and more complicated to understand. Tk is one of the easiest to use IMHO.
Yes.. you can use PIP in Python 3. A lot more improvement and amazing modules/features in Python 3. Python 3 is the future. Python 2 is used when maintaining old codebases or your desired 3rd party library is not supported the python 3 then you use Python 2. Almost all new project are on the Python 3.
Hmm...haven't been able to test on a Red Hat box. Do you remember how many/which packages did you have to install to get it working? And I'm curious when you say build a Qt app, do you just mean getting the dependencies installed so you can run one, or actually developing the application?
Fuck python 2. UP THE ~~RA~~ PYTHON 3!
I love how you are the author and still get negative downvotes for not agreeing with you...
Thanks! 
Keeping in mind that I am n00b I installed python 3 and then got pip setup (not sure why it didn't by default) Seemed like it grabbed paramiko and fabric (two i care about most) completely fine. If pip grabs a module when you tell it to install does that mean it is supported by 3?
if pip installs a package then does that mean its supported/ I isntalled python 3 then used pip to get paramiko and fabric
when i tried to learn python the first time it seemed like the community was torn , i stuck w/2.x. On my second (current) attempt to learn I just defaulted back to 2.7
i don't use mysql stuff often, is pillow a module that interacts with mysql as well? Most of my work is setting up utilities that run on windows hosts to connect to a linux based machine and do ssh/sftp commands
&gt;the Python 3 crowd oh, you mean the *real* python crowd? BOOM!
Curious why you went with the Hue? I keep thinking about taking the plunge into some home automation stuff, but the proprietary standards make me leery that I am going to buy into one that gets discontinued in a year.
Thanks, I didn't know about LazyLoader. It's not directly clear to me how to use it though. Furthermore, it's only in Python 3.5.
So you're GUI is a custom built web site? I considered this many years ago with Django, but the thing is I don't really like CSS and JavaScript. Did you find a way around that (i.e. does Flask have "GUI apps" that are simple plug and run)?
I think the main benefit for this is that many people know HTML/CSS and would rather not learn some new GUI toolkit's layout system and peculiarities. Also, there are so many tools available to make websites look modern.
Because LGPL means I can use one library for both stuff I do at work and stuff I do on my own time.
i agree with the cap, BSD or MIT for maximum freedom IANAL, else i could comment on whether LGPL would be suitable enoug
I made one a couple of weeks ago using Socket-library and pdcurses. No prior experience whatsoever, but it was rather simple. Took me less than 6 hours I think.
&gt; I'm quite new to programming A chat client is going to require learning about a few things besides programming, because programming is just a tool to do a job: you need to know what you want to build before you worry about how to build it. For one, you're going to need to know about computer networking, to get chat data from A to B. Specifically, TCP and/or UDP protocol (check out both), and implementing said protocols using sockets (the code isn't too different for both, but the behavior is). Once you understand how to move your data, you might want to look in to how you package your data, what else you include in said package, and how you prepare said package for your socket. This concept is called "serialization" or "marshalling". There are python libraries that can do this for you, but I'll leave the exercise to you to discover them. You might look at formats like JSON, YAML or XML. They're easier to serialize/deserialize, and have python libraries, but they can be a bit trickier to work with, your mileage may vary. Now that you have the tools you need to move data, you should decide what data to send. Taking a look at other projects like libpurple or xmpp may give you some inspiration, or it may not. Give it a try, at least. Decide what data structure you want to use and how to represent it in Python... ...are you studying OO programming at all? Using objects to represent your data will make life easier down the road. This is quite a deep topic, though, so I'll hold off for a beginner coder. Highly recommended though. Hope this is enough to get you started. As I said, programming is just a tool, you need to have a full toolbox *and a blueprint* of what you want to build in order to make something that works to your liking...
Yes, you right. Also is true that LazyLoader have an ugly api.
Yes, please! Do not encourage people to use `import *`, as it is a [bad](https://stackoverflow.com/questions/2386714/why-is-import-bad) [practice](https://stackoverflow.com/questions/29454878/is-it-bad-practice-to-use-the-import-method-with-tkinter) [overall](https://pythonconquerstheuniverse.wordpress.com/2011/03/28/why-import-star-is-a-bad-idea/).
interesting, thanks!
We *are* users of this article, though. Later we will stop reading the article and start writing our own code but right now, dear writer you seem to have forgotten to include your example screenshots. We do want to know how it works and this article is meant to show us. Edit: On a side note, respect users more. Programs aren't just fun puzzles. They're meant to be used. Users are why we do it.
That is a good argument I hadn't considered. 
I had no idea telegram had this functionality! Awesome!
It's not 3
&gt;All examples are in Python 3. God bless you.
If you've any experience with Qt, then using PyQt/PySide will be a dream come true. The best part is being able to connect signals to arbitrary python functions. And the availability of Qt classes for things like dates or colors and etc. that you've always wished the std libs did better.
I... What? How would that work, exactly?
These are superficial similarities. The philosophy and design of both languages are extremly different. Philosophy : - Python values lisibility. No brackets, forced indentation, no multiligne lambdas... They are core values of the language and reasons it is loved by its fan. JS has not been created for lisibility at all. Actually zero thought has been made for this except to fight the callback hell after failing miserably at building big projects during the 2000'. - Python like explicit. JS has implicit global variables and this rebinding. It's such a problem they introduced new keywords and syntaxes to deal with it. But without deprecating the old ways. - Python doesn't like to guess. JS is making weird type casting, insert ";" when it think it's right and doesn't check function parameters. Just for fun. - Python like consistency. JS implementations are very inconsistents, and even commutativity is thrown out of the windows. - Python si battery included, JS has a minimal stdlib. Implementation - In Python, no implicit event loop is a feature. Not being async by default is a feature. Async is good when you need it. But in a lot of case, you don't. And Python shine in many places, not just the web. - Python has a very clean object implementation. JS has some mix between hash maps and objects. It used prototyping which nobody gets and now tries to implement classes but with no mutiple inheritence. - Python comes with supports of many encodings out of the box. JS doesn't. - Python has operator overloading and hooks to intercept special syntaxes such as [], properties, context manage... JS doesn't. You use verbose methods and callbacks. - Python has a clear, strong typing system. typeof NaN returns number in JS. In summary : one is a hack that we have to use because it's the only language available on the browsers since 2 decades. The other one is because people liked it. Nobody is forced to use Python, its adoption is purely love driven. On the other end, genius people from big companies like Google had to make the best of JS. They had to as a business constraint. So they invested years of research and millions of dollars to create the V8 engine. And now JS it is competitive. No because they wanted too. Because they had no choice. So no, JS and Python won't merge. JS is pourly design legacy tech popularised by it's unfair dominant position turned into a decent product by very smart people and layers of fixes. But has nothing to do with Python: it's nowhere as clean and mixing them would remove the elegant charm of the original language. You can't merge both just like you can't make a human and a fish copulate to create a mermaid. But you may, one day, be able to run Python on webassembly.
I want to spend 30 seconds to determine if It's a worth while tutorial not 10 minutes.
Hum, not a bad idea when you're not using django.orm/sqlalchemy and need to test. In all honesty i hope this picks up enough for you to maintain it otherwise by the time i actually go and use it the project has been abandoned and... i get sad, my life is full of disappointment.
It is kind of nice not to have a massive article to scroll through.
nice
Not supporting it would break the code of the many companies (including Dropbox, where Guido works) that still use Python 2.
[removed]
Yup... Please use the contact form in our website
Still, after 2 (3?) years of python 3, everyone should have ported their code by now. Keeping the support of an old version doesn't push to use the newer (better) one.
Why? 3 is nicer, but not nice enough to justify rewriting your entire codebase. 
You should really use :param syntax. It's a standard.
Is rewriting code to another or updated language be commercially viable, takes time and time is money. I like py3 better but generally still use py2 working with older applications, if I write something new I use py3, py2 will fade slowly so use ya patience and keep writing everything new to py3. Also programmers use old languages all the time, "had" a friend who bought a punch card machine just for fun. People still use c instead of c++ or c#, it could be preference or for comfort like that saftey blanket or teddy bear they can't give up. 
The comparison to c and c++ is not relevant, C++ is object oriented but C is a tiny bit faster. Those are extremely different. Py2 and py3 however are basically the same language, except that py3 is faster and has better optimization ( bye bye raw_input !). It is just silly to keep maintaining an outdated language. Atm there shouldn't be any reason to keep Py2 around. It is slowly fading away but by the time it will be gone completely, py4 will already be out. Come on...
I would really just wish they would merge 2 into 3 and just allow both versions to run side-by-side using one interpreter. They could add python 3 syntax like: from python2 import ... And in python 2.x code, they could do the opposite to use stuff that supports python3: from python3 import ... That way, we could all just install one interpreter, all our old stuff still works without re-writing it. Library writers can focus on targeting just 3.x because they won't be cutting off 2.x users anymore Everyone will be happy. 
Check out [Tkrad](https://github.com/tarball69/tkRAD) to make your life simpler with tkinter
The Python 3 interpreter had a lot of internal changes, so I doubt it'd be easy to merge them.
It's easy to stand up REST endpoints. Took me about 30 minutes to get it installed and up and running.
&gt; Still, after 2 (3?) years of python 3 More than [seven years](https://en.wikipedia.org/wiki/History_of_Python#Timeline_and_compatibility), now. I agree it's too slow, but there are still some legitimate reasons to use Py2 - just not for new development.
How often do you build anything with a GUI, and how large is your organization? Aspiring data scientist here, and the closest thing I've seen so far are more of interactive visualizations. 
&gt; There should be one-- and preferably only one-- obvious way to do it 
It's always been my opinion that the card game war was meant to teach kids how to cheat and get away with it.
Developers had tons of warning, because they actually did THIS EXACT THING. It's called `__future__`.
Now, make it STRATEGIC war, and find a way to not drop all the cards when you're looking for one, and it'll get slightly more interesting.
For people interested in Tk, [TkDocs](http://www.tkdocs.com/) is an interesting source of information as well. It provides source code examples in many different languages as well as some good tutorials.
That's an extremely low bar as to what constitutes "bashing".
Nice.
I don't know if there are any. For whatever reason, they don't seem to have put together an Alexa Skills Kit in Python, just Java and Javascript (which is odd, because Python is completely supported by Lambda). That said, I've seen [this](https://github.com/anjishnu/ask-alexa-pykit), but I haven't tried it yet.
its reverse proxy.. try: elite.proxies.online
[removed]
You want help pirating an ebook? [ok then, this one seems fine](http://file.allitebooks.com/20150707/Data%20Science%20from%20Scratch-%20First%20Principles%20with%20Python.pdf). It does have a watermark of the site that ripped it baked into it though. It's possible your PDF reader just isn't very good.
It's o'reilly, you can get a drm-free epub, and then run it through calibre. Or run it through calibre to convert to html then run that through `wkhtmltopdf` or whatever. [o'reilly link](http://shop.oreilly.com/product/0636920033400.do)
Thank you. Indeed, 7 years is too long. Too bad you and I are getting downvoted into oblivion by those 2.7 fanboyz
Nice! The Windows installer seems to remove the py launcher when upgrading though. Had to run it again to click *Customise* and select the launcher.
wew
The stuff I build is generally along those lines. Here's an example of something I'm building right now (just for fun, not for work). * Python module collects tweets from the stream API and calculates statistics on the fly * Flask communicates scores to the front end (website) * javascript (d3) queries the server (flask) at regular short intervals and then updates a table and line graph to present real-time statistics and updates I'm still implementing this last bit, but users will be able to login with their twitter account and control parameters that will affect which tweets are collected and how scores are calculated, giving users a fair amount of autonomy in the function of the app with respect to their specific session. It's a bit more than what would typically be considered an interactive data visualization, but it's basically an interactive data visualization.
Don't understand what you mean by this. My site is written with Ruby on Rails. I just posted this because I have some guides on my site teaching others about Python 
I switched last week and it was a pain but I'm glad I did.. Now all of my code is updated and I get to use new features 
But also no sane errors for cyclical import problems unfortunately.
&gt; * Can't be bothered to learn some minor syntax changes &gt; * Not aware PyPy3 has been available for nearly 18 months &gt; * Scared of change &gt; * Cuts off nose to spite face. FTFY 
Fair enough. 
Ugh.
A *rapidly declining* number of *relatively minor* libraries that are often abandoned / frozen... This "missing libs" meme has to stop, it's simply not true anymore in the overwhelming majority of situations.
&gt; the vast majority of actively-developed Python application code hasn't been ported [citation needed]
GvR had already announced this a long time ago, but now it's even more compelling because: * it moves on from the damaged Py3 "brand" and increases pressure on legacy developers. There won't be any more debates on whether to use 2 or 3, because 4 sounds intuitively so much newer than 2 (which it is) that there is no real choice left. * It will make it clear how the Py3 compatibility break has largely been reabsorbed in later releases with legacy-friendly features, something a lot of people still don't know. * It will make it easier for libraries to state compatibility. It always looked a bit silly to have stuff like "works with 2.7 and 3.2+, but not 3.0 or 3.1". That can simply become "works with 2.7 and 4+".
That was what I meant (I think), it moves two expensive parts of the process out of the main loop.
I'm looking at this project to run on a Pi https://home-assistant.io/ They already support a wide range of hardware. Others can be added using IFTTT. I have an old system by Comfort that controls lights using X10. I want to replace that eventually.
On a completely different note: PyBelfast is actually happening again in January
What? Type "install opencv" into a search engine of your choice...
I certainly hope that no one wasted time publishing on the matter. If we are interested in personal conversation citations, Brett Canon (the core dev and tireless Python 3 advocate) recently told me as such. Anyone remotely in touch with the professional Python community knows as much.
Merci.
Don't you want to teach your users how to attach a new string on their bow ?
just used 2to3 and was hoping it'd be a painless jump over. I wish i'd just started with 3 :( http://imgur.com/a/FK3Vi
trying to switch now, used 2to3, hopegully this iwll be easy syntax fixes http://imgur.com/a/FK3Vi
If I recall correctly, Patreon uses Flask.
Relevant XKCD once again (well, the [git repo ](https://gkoberger.github.io/stacksort/), anyways) . Execute stackoverflow answers until the list is sorted. 
https://en.wikipedia.org/wiki/Hat-trick
Yes. We still make bug fixes and security fixes for older versions, for users who aren't able (or are unwilling) to upgrade to the latest release.
awesome!
Thanks for the bug report! It's a brand-new installer for the Windows version and sadly there are still a few bugs. We may quietly update the Windows installers just to fix this.
It's perfectly reasonable to provide bugfixes and security patches for older versions of software.
Yeah, we maintain several old 3.x versions. 3.4 is currently in "bug fix" mode, but will shift to "security fixes only" mode after 3.4.4 ships. 3.3 is already in "security fixes only" mode. 3.2 and earlier versions have been retired.
I see. That's a whole lot of branching support. Keep at it! &lt;3
Because minor releases deserve RCs too.
I hope you use py3 fpr the next projects ;) Also, looking at your code forces me to recommend you further reading into this topics to beautify your code: `first class objects`, `tuple unpacking`, `enumerate`, `comprehensions(for lists, sets, generators and dictionaries` and of course `format`. Here is a little showcase example how and why to use this techniques: &gt;&gt;&gt; import operator &gt;&gt;&gt; op_list = [operator.add, operator.sub, operator.mul] &gt;&gt;&gt; op_dict = {"[{}]".format(index): op for index, op in enumerate(op_list)} &gt;&gt;&gt; def use_ops_for(n1, n2): for key, op in op_dict.items(): print("{}: ({}), {}, {} =&gt; {}".format(key, op.__name__, n1, n2, op(n1, n2))) &gt;&gt;&gt; use_ops_for(2, 2) [0]: (add), 2, 2 =&gt; 4 [1]: (sub), 2, 2 =&gt; 0 [2]: (mul), 2, 2 =&gt; 4 Adding new functionality is also easy: &gt;&gt;&gt; def power(x, y): return x**y &gt;&gt;&gt; op_list.append(power) &gt;&gt;&gt; op_dict = {"[{}]".format(index): op for index, op in enumerate(op_list)} &gt;&gt;&gt; use_ops_for(2, 2) [0]: (add), 2, 2 =&gt; 4 [1]: (sub), 2, 2 =&gt; 0 [3]: (power), 2, 2 =&gt; 4 [2]: (mul), 2, 2 =&gt; 4 Of course you can also sort the `dict.items` but I am too lazy here ;) This is all py3 code. I hope you'll see how to beautify and automate the code for your menu tree ;)
Alright, I guess my question boils down to: Why is 3.4 still getting releases? Are 3.3, 3.2, 3.1, 2.6, 2.5 etc. under active development too?
I hit enter too soon and likely sounded rud.e Thank you fo rtaking the time out of your day to give me some info to read up on and learn. I don't really understand that too well but I will absolutely read up on it
I really like the new installer but it seems to dissociate the file extensions when upgrading and does not reassociate them, even with the option selected. Neither does running the installer again and selecting *Repair* help with the issue. I had to use [FileTypeMan](http://www.nirsoft.net/utils/file_types_manager.html) to get them to reassociate with the py launcher. 
Thanks for putting this together. I had my own work-around where I converted small notebooks into html, but this looks nicer and cleaner. I'm fairly unfamiliar with js though, how do you call the plotlyjs script along with the html? I'm not using Data Spyre, just my own simple server setup. 
oh, yea, that makes sense. I didn't realize it was a TDD type of thing. But at the same time, you're going to have to write a metric crap ton of unit tests to rigorously define a hash table that resolves collisions by double hashing and chaining with hash tables.
Legibility is the same word for English. 
~~I mean that python 3.5 adds new features to the 3.x series - it didn't break any backwards compat with the major series afaik. Python 2.6 and 2.7 are a different story, and I'm not at all an expert on the differences between the 2.x versions. It probably sounded like I was saying that 3.5 is just an update but I should have qualified it with "to py3k".~~ Nvm! I see your point, sometimes there are backwards incompatible changes on minor versions. which is actually the case from 3.4-&gt;3.5, I stand corrected on both accounts. 
Thanks for the advice. For some reason, I'm not able to get the plotly.js working as a standalone script, but I can get plots draw by injecting it directly into the html output from your code snippet.
See [this closed issue](https://bugs.python.org/issue25112) and make sure that you are on 3.5.1, not 3.5.0. So far I don't see any problem in 3.5.1 on Windows.
I can't say I've tried it on any server setup other than Spyre, so I can't help too much. That tutorial and the one I have on pygal/bokeh in Spyre are the extent of my web dev experience. Good luck getting it going!
http://stackoverflow.com/questions/4700614/how-to-put-the-legend-out-of-the-plot
This will work on the pie chart, too?
I am a physicist but much of what I do in terms of analysis can be considered data science. I learned to write a GUI for my data analysis primarily as a way to learn python better. However, I also figured, if I ever need to explain my code and my data analysis routines to anyone, it would be easier to have ti wrapped in a GUI seeing as most of my colleagues/coworkers are not fluent in python. So rather than having to explain to them how to download my code, install the proper python packages, make sure the code is in the correct folder (which moves from time to time depending on what data set they want to look at) - I decided to write a GUI that lets the USER load specific data sets, export whatever plots they want as images, export certain curves and data sets as text files, etc... These are all things I originally just did through the command line with a large volume fo small python scripts but now its available for anyone in my group/research field to use/adapt as a more well rounded package which is easier to use if you aren' as computer savvy.
Where does he say or imply that?
http://article.gmane.org/gmane.comp.python.devel/153401
Performance improvements: http://article.gmane.org/gmane.comp.python.devel/153401
There is a semantic difference between readability and legibility. See this [explanation](http://michalisavraam.org/2009/05/readability-vs-legibility/).
Wow, thanks!!! I'll absolutely be watching these during lunch or dinner :) I don't use linux a ton , but at work the small machines I write this utility fo rare linux based. I figured out where part of my problem is happening def GetVersion(): # I don't know why i have to declare as global here, seems to have not worked hwne i did it at beginning global Version_App, Version_System # You can likely follow this block cmd = "ipkg list_installed | grep application" stdin, stdout, stderr = ssh.exec_command(cmd) Version = stdout.read().strip() #I used this bottom line to find a specific string in file...i think i need to tell python that Version_App is in bytes? Version_App = Version[Version.find("application - ")+20:Version.find(" - Application")] later on I print these out PrintBox('Application version is :' + Version_App + '\n \ System version is : ' + Version_System) PrintBox just puts them out in a neatly formatted box.
Oh, oh, oh... so much to diskuss ;) At first: Don't use globals here, try to never use them! It brings only headaches! Your `getVersion` function should just return the version. def get_version(): return "version_app", version_system # insert the result of your calculations for your version here later on: PrintBox('Application version is :' + get_version()[0] + '\n \ System version is : ' + get_version()[1]) There is more... This `Version_App = Version[Version.find("application - ")+20:Version.find(" - Application")]` is in general crap, not that your skills are shitty, no this is plain bad style. Use regex here, this is the first time it will be really intense but regex is the best tool to find something in strings. &gt;&gt;&gt; sample = "kigsadiasghdaisdho897987897324jklnkjlbhkjlaswd" &gt;&gt;&gt; import re &gt;&gt;&gt; re.findall(r'([0-9]+)', sample) ['897987897324'] &gt;&gt;&gt; sample2 = "kjahsklagh76832kbhaksjlhklash98890934nlknkljahs9.92" &gt;&gt;&gt; re.findall(r'([0-9\.]+)', sample2) ['76832', '98890934', '9.92'] Please send me what you get with `stdout.read()` in that function and what you need from that string, and I will help you to create a good regex pattern for you. Also, try to learn and understand how `str.format()` works, so you never write something like this `s = "hello" + some_thing + "world"` again! ;) Just browse thru that [site](https://pyformat.info/) and see with your own eyes how powerful and neat format() is.
You're mistaken. You're leaning on us. Why is it our responsibility to help you when you don't even want to help yourself?
Look in these two places question="""Name this movie: \nWhat movie stars Matthew McConaughey as an ex Nasa pilot whom goes on very distant journey to save humanity?""", **answer = "2",** options=["Inception", "Interstellar", "Gone Girl", "The Journey"]), AND response = **int**(sys.stdin.readline().strip()) # answers are integers 
we will not do your homework /r/learnpython
What use case are you envisioning? As with any language feature, it can be used to great effect or as a terrible anti-pattern. Help us help you, give an example of what you want to do... I've been using decorators for a couple years, though not the proper package. One of the things I do in a decorator is add exception handling to a wrapped function, so whatever "backtrace problem" you're talking about is mitigated. The only use I've found for functools.wraps is the preservation of docstrings, which, sadly, don't exist in some of my projects. Dunno what else to say...
Very nice! Feel free to send me a message/email if you have any other questions on how LBPs can be used in relation to your project.
[Description of how it works](http://blog.zerodb.io/a-peek-under-the-hood/). Basically a B-tree traversal by the client of encrypted buckets on the server. Sounds slow.
First, note that the link does not demonstrate that the usual regex implementation methods (search &amp; backtracking) are slow, it shows a worst case of these methods (which triggers a backtracking explosion) to advocate for an alternative. As for why not, the article hints at the answer: there are features expected of an stdlib's regex engine which DFA (and Thompson NFA) can't provide like backreferences (which is the very reason why Spencer went with backtracking) or generalised assertions (the article asserts the latter is encodable in an NFA without providing evidence) and the solution it advertises (internally switching implementation) strikes me as a possibly risky bet (making regex performance an even darker art than it is already, though I think Tcl 8's regex engine does exactly that using a DFA if it can). An alternative would be to provide multiple regex implementations with different limitations but most standard libraries are loathe to do that (I believe GHC used to do it, not sure if it still does). See http://lambda-the-ultimate.org/node/2064 for a more extensive discussion of the article.
The question could be "what can't you use Python for?" We've got Python doing everything from automated sysadmin tasks to running production-grade microservices and even as apps on embedded systems (though not recommended). It's all throughout our ops (build in cloud, deploy to cloud), all our QA is automated in Python (unit test, integration test, perf and scale test), even many of our production services are Python (internal APIs, job servers, service discovery, configuration fan-out, messaging, etc.) Fact is, Python has many, many libraries, and tons more developed by 3rd parties. As swiss army knives go, it is incredibly versatile. To your specific example: https://github.com/vmware/pyvmomi Instead of asking "how and why", don't bother with those questions and just forge ahead with Python for everything. It's a rare case where you'll "hit the wall" and find yourself without a solution.
I make robots do my bidding. www.ROS.org
When B-Tree parameters are optimal, that is all right, depending on types of your load. But we probably should publish benchmarks next week since many people request that. Also I should say that caching the top of the tree really helps :-)
I saw some benchmarks that Python 2.7.11rc1 was actually a couple of percent slower than other 2.7.x releases. I haven't heard anything about these speedups since June and I would not be surprised if they didn't make it into Python 2.7.11. UPDATE: I checked the official [changelog] (https://hg.python.org/cpython/raw-file/53d30ab403f1/Misc/NEWS) and these speedup DID make it into 2.7.11. See "Issue #4573" therein.
First piece of advice: re-think Learn Python the Hard Way. Its entire premise is that code should be learned through educational techniques that the actual education industry has been eschewing for decades. It also has way more errors and outdated materials than any paid learning resource should have. I got through a basic syntax course, like Codecademy.com, and then picked up "Automate the Boring Stuff with Python," which breaks down many real-world use cases, and provides the libraries needed to do them.
We're currently using python for our cloud/web services. We may be making a switch to nodejs though, since we're a small team, and don't really have dedicated front/backend people, and we all end up doing a bit of everything, and context switching is a bitch, and the next project we're taking on will be all web(unless the P.O changes his mind). Just have to weigh the pros and cons. But python is fantastic for cloud and web, if you either have a bigger team, or don't mind context switching. Other than that, python is used everywhere. Everything from hardcore scientific research at Cern, to making a script to auto save your files, and create a backup history of every save. You can use it as the main programming language for whatever you're doing, as the "glue", you can use it to allow admins to put in hooks, etc, etc... Python is basically a swiss army knife. If you can think of something programmers program, python is probably used in it.
I couldn't find any decent programs to do this for me, so I decided to do it myself. It's still pretty rough around the edges, but it works.
Well, here's a question for you: Why are you restarting services? Couldn't you write a Python program to monitor services and restart them for you? Heck, get fancy, and make it send a notification when it does. 
he seeks to make a profit off of keeping people off the latest version at any means so he doesn't have to update his horribly outdated semi condescending "book" if you're trying to learn python i would honestly suggest any other source, including codecademy 
Tableau extracts right now. Also cleaning up shitty data.
I needed to get rid of the quotations. I knew it was a little mistake. Thank you so much
But, do you understand why it was incorrect?
Not only that, you can assign via keywords arguments, that is pretty cool, and it prevent you from repeatation. &gt;&gt;&gt; d = {"name": "Alice", "age": 23} &gt;&gt;&gt; "My name is {name}, and I am {age} years old.".format(name=d["name"], age=d["age"]) 'My name is Alice, and I am 23 years old.' &gt;&gt;&gt;# Wait for it...: &gt;&gt;&gt; "My name is {name}, and I am {age} years old.".format(**d) 'My name is Alice, and I am 23 years old.' `**d` unpacks the keys and values of a dictionary and as you see they fill out automatically the keys set between the braces. And now you can build templates! Imaging you have a long list of dictionaries with alot of data, you only need specify the key in the string between the braces and not as an argument in the call of format or with string interpolarisation. The new-style format offers many good stuff and is so polular under the devs that they will eventually implement a new string type for this in on of the next python version, this will eventually looks like this: `f"My name is {name}, and I am {age} years old."(**d)` Then we have a shortcut for `format()`.
I don't really know it, but when I found out he tells the reader to just cold memorize the Boolean tables (e.g., True and False is False) instead of understanding them logically, it turned me way off.
Are you asking for a library to help you? I suggest turtle. https://docs.python.org/2/library/turtle.html http://interactivepython.org/runestone/static/IntroPythonTurtles/CreatingGeometricShapes/geomShapes.html
I'd be very interesting in learning about your rpg scripts!
&gt; that is prevented by not exposing the entire database and rather a subset of database operations Actually, when we have multiple users, they can have their own "sub-databases" which don't overlap (currently the case right now). But of course, there could (and will!) be common data. For that, we're going to use proxy re-encryption or something along the similar lines (delta-keys which Mylar uses). The server can limit what exactly to give to the client and in which quantities + stores transformation keys. We will be describing that in a whitepaper before putting in the code though. Network traffic - true, didn't think about DDOS attacks. Of course, all this traffic is cryptographically authenticated, so you can do some quotas per user.. But it's not there yet!
It follows the same line of logic of making people actually write down notes of a lecture. It helps with retainment, and - in part - through repitition. EDIT: The idea behind it is basically the programming equivalent of: don't play with euphemisms and turns of phrase when you lack the basic fluency to construct basic grammatical sentences or know simple words to describe common things. Slog through the basics first, then get creative. For those with the self-discipline and diligence to actually sit down and think through the exercises/lectures/samples and replicate them of their own, "the hard way" may not be the best way, but it still works. More importantly, all it asks you to bring the table is due diligence and a basic familiarity with computing, and it fills in the rest, so long as you're willing to stick to the script. It's a launching off point, for those who have otherwise struggled but are trying. For the vast majority of people (let's be honest here) that just skim through it writing at best maybe 1 in 10 lines of code that the text suggests, the "hard way" (if adhered to) actually engages them and is a check against ego and just skimming. There's also the whole if they make a typo and don't realize it, and then get an error, they're suddenly in debug phase, which forces them to think critically about what's going on. Sometimes they'll catch the typo, sometimes they'll say fuck it, but assuming they don't quit, they'll then actually reread the text and their work and think critically about what's going on, trying to ascertain what is happening, what is meant to happen, and where the issue is. At the end of the day, it's usually a typo. But that happens in the real world quite often as well, and is a big part of debugging. TL;DR It's a bait and switch mechanic to get people who would otherwise bail or not retain the lecture to actually engage and participate and learn by doing, all the while holding their hand in the process. It's not perfect, but it does work. There are certainly times where such a process has helped me - admittedly I felt like a dumbass after the realization of how simple the solution was, and for total beginners, having the answer staring you in the face is often a good thing. 
What I was trying to articulate is a use-case where you need to use Excel to build something interactive. For instance, python is great for manipulating data and putting it in a spreadsheet. However, if you want to allow the user to enter values and see how it changes the output - Excel is going to be better than building some sort of custom python UI. Does that make more sense?
The thing his book has going for it which not all the other books do, is that it teaches design philosophy and methodology. Not that I always agree with it on these points, but I think forcing the student to think about design early on is a good move. But yeah, It's so outdated that I'd never recommend it to anyone.
I'm not really sure what you're asking, but I'll give my personal career anecdote about python. The company I worked at recently for about 4 years used python (with tornado and django) for pretty much everything. Our python services eventually got to be serving billions of http requests per day. Figuring out how to do that was probably the best learning experience of my career. 
I had already assumed that all/most data for this sort of model would be separated out on a per user basis. What I'm more concerned with is that all user information is pretty much wide open if the client is compromised in anyway. This sort of model makes it really hard to put in stop gap methods of data leak prevention. In a more traditional architecture, you can do a lot more to control exactly what data the client has access to. It is easier to control and secure user experience when the list of things the user can do is controlled and limited. I'm just not sure how much this sort of a setup buys you over a DB on an encrypted FS and accessed over an encrypted protocol from the server (with encrypted data columns for really sensitive data).
For work I unfortunately don't use Python at all, I love the language but I'm on a team working on a web frontend so I'm working in JavaScript all day. That said though, my employer is a Python shop through and through, our backend is in Python and our main project (Salt) is Python as well.
Thanks for the answer. Actually, apart from the preservation of signature, I like the decorator package because it makes me write: @decorator.decorator def times_two(fn, *args, **kwargs): return 2.0 * fn(*args, **kwargs) Instead of: def times_two(fn): def wrapped(*args, **kwargs): return 2.0 * fn(*args, **kwargs) return wrapped I feel like the former is a bit more readable. Would you suggest against using it for cases where call signatures are not really important?
As long as there are people who love controversial statements that lack nuance, Zed Shaw will always have a job.
Isn't that true of all learning resources? I have had to stop and debug myself in every course I worked through. It's also passive aggressive and atrogant to know that 90% of your readers don't have the patience for your course, and rather than re-think the course itself, expect readers to get tripped up and cope.
I do a bunch of silly things with it at work. I'm a sys-admin so I've got scripts to do things like parsing data into JSON, mapping out networks, I've got one to dump data into ElasticSearch for testing, and now I'm writing one that does port scans. I tend to use Bash for most things. I'm gonna try writing some Ansible modules which use Python. 
&gt; Autocoding to c++. Interesting! Newbie here. Curious as to how do you do this? Is there one for say, Java or other languages? Are there alternatives instead (ie: such as Jython but for C++)?
As a SysAdmin you should look into using the fantastic [Fabric](http://www.fabfile.org/) project. It is basically system orchestration via Python code, very similar to some other projects like capistrano, but much more mature and it has great documentation. As someone who has dabbled in just about every scripting language out there over his career it's tools like Fabric that get me writing Python nearly every day which makes it my go to language when I need to write some other utility as well.
Thanks. I appreciate the feedback.
"Encrypted FS" is the baseline (which somewhat works though). We add caching and invalidation requests to that. Then, we're going to roll out some server-side stuff (proxy re-encryption, set unions/intersections to make proper joins possible, maybe ORAMs). One thing - we can use proxy re-encryption and quickly remove transformation key if we believe that user was compromised (w/o the need to re-encrypt all the data). But that's a different sort of threat than what you mention. So, thanks for giving information to think of :-)
I avoid it.
I got as far as "we use a method called instruction here." Which... 1. Direct Instruction is a method primarily used to teach grade schoolers. 2. It has been the dominant teaching style for the entire lifetime of everyone reading these words, so I don't know why we receive such a patronizing explanation. 3. It is also single handedly why everyone hates school, as it's the "sit quietly until I'm done talking" teaching style. 4. Teachers have understandably been trying to move past it for a long time, trying exploration or project based learning. It baffles me that LPTHW gets away with presenting themselves as a leading resource. You know the one question I ask everyone who goes through the course? "Did you start coding apps when you finished?" Haven't heard a yes yet.
I develop *unspecified* security applications using Python at work. I also handle a lot of continuous integration with Python scripts. Since you mentioned VMware, I use a library called `vixpy` to interact with and control VMs using VMware's VIX API. You can copy files to and from VMs, take snapshots and screenshots, work with the file system, and run commands within the VMs. I imagine this could be useful to you as a sysadmin, whether for applying updates or deploying programs to VMs. On my own, I have an army of web scrapers constantly at work. I stack gold/silver so many scrapers are monitoring for product availability and pricing. I also regularly use small `flask` web apps to create various services for myself. If it were available in my state, I would use a bot to buy/sell on the Coinbase Exchange for me. If you need to write APIs, `flask-restful` is a great library that I use fairly regularly. If you need an automated process for monitoring logs, you can create bots to watch your logs and notify you via email or even text when an event occurs. I find all of this is easier in Python than in other languages. However, I have been exclusively using Python for the past 3 years so my opinion is biased.
I designed a sophisticated distributed task/test runner and resource manager in Python for work (gets jobs from another server, builds up execution environments, manages task execution, pumps tons of logs from task execution back to a large distributed database), as well as several other distributed systems. ZeroMQ is really really helpful in that domain, and Python has a really excellent FFI and good thread support, which helps a lot. We also use Python (Fabric) to manage deployments for our CI/CD system. While Python isn't the correct tool for a lot of the ecosystem (our high performance stuff is in Scala and C++), it's pretty useful.
I was probably not specific enough so it sounds better than it is. We don't convert our algorithms from python to c++, we just have Python output .cpp and .h files from a database for us so we don't have to write a couple tens of thousands of classes and their various methods manually.
Very Poorly :/ I am working with a group to algorithmically desegregate school attendance zones.
I should probably get my progress out onto github soon. Right now I'm working on a sector generator for the tabletop RPG [Stars Without Number](http://www.drivethrurpg.com/product/86467/Stars-Without-Number-Free-Edition). Someone has made a web-based generator already, but I wanted to make some improvements and also thought it would be a fun side project. I also wanted to get the okay from the author before I make it public. I'm working on a python module with various features such as dice rolling, star generation, world generation, etc. to fill in all the rolls that you normally have to manually make when GMing the game. It'll set a random number generator seed which allows repeatable functionality. It'll also save the sector information in plaintext form so the GM can make any changes they want after generation or load already created sectors to take advantage of the map image generator I'm working on as well. [Here's what the map image generator can do so far](http://i.imgur.com/tf93SYw.jpg). Most of the image manipulation and creation was done using PIL. The last part is to tie the generator together to a GUI (I'm using Qt) to allow real-time manipulation of the sector info instead of editing text files and to show the sector image as the data is being edited. 
Ah, ok! Thanks for the clarification.
I met the guy in Miami a few years ago, he wasnt crazy, really nice guy. He just one of these people whose head travels at 100mph; we burned through a lot of topics.. quick. As to your question, no clue. Sorry.
...and then the C++ coder shows me how his 2x length code is 15x faster.
Flask for our backend and for our QA automation
Please, it's going to be at least 4x length and 20x faster. ;D
I agree with you. After I "learned" Python, I wrote my learning experience here as a post, and LPTHW was one of the least helpful sources for me and many others. I don't know why it is so high up in that list. Python for Informatics is probably the easiest access to Python for people like me who has absolutely no background.
I'm a data librarian. I use Python to scrape in data and metadata for analysis. Work with other APIs to extract goodies repositories. Play in XML and JSON all day. Write utility scripts to process reports/metrics/logs/etc as it comes in. Help researchers on my campus wrangle their data and get their projects going. Teach workshops. Lots of stuff. Utility scripts are where it's at for me.
We run jobs on both linux and windows machines. It seems that the built in functions to our software are limited, or just suck. So we created agnostic functions. Filewatcher, copy, multi-range time checking...
I've used it to write HiveQL code before.
I have built a GUI with Flask before and am pulling it out of one of my projects and making it its own project. I _just_ setup the repo so it's empty but check it out this weekend. It should be ready. It's really simple to use and I would continue to use it in my future projects as well. https://github.com/Andrew-Shay/Neuron
Great work! I am really interested in 3D visualization. Could you please suggest me where and how I can start learning it?
I'm gonna link to my previous comment above. I think you will be interested. https://www.reddit.com/r/Python/comments/3vmaot/gui_programming_with_python/cxr403x
Hmm... perhaps I was being a little optimistic with regex. Because you need to track indentation, you can't do it with a finite automaton (like regex). Here's a python function that will do it: https://gist.github.com/fredcallaway/eb5d996749ed7e23978f
Why? Because: - high readability, therefore less costly to maintain - promotes fast development/prototyping (batteries included, etc.) - runs on multiple platforms - large community (audience, help, etc.) But above all, it makes doing practically anything seam easy, and it's fun that way. 
Not pedantic, if anything super helpful. We're working on a paper which will attempt to address many of these questions. And point taken that we should make the "honest-but-curious" threat model of the server more explicit until we've implemented ORAM.
Can I PM you regarding the embedded programming you do. Just curious as I am starting to learn some embedded stuff. 
Well, it depends 
&gt; ...then you make a comment about how execution speed doesn't matter, it's developer speed that matter Until you have to start worrying about scaling costs. 
The best kind of correct. 
Start with some simple task that is boring to do and can be automated. For example parsing a bunch of input by using regular expressions (import re) and spitting out a configuration file that can be pasted into a CLI. Then expand it out, by having the script configure the device via a API or CLI based on your parsed input. Start small, don't make it so difficult that you get frustrated and give up. 
His book has some pretty clearly-defined exit criteria for Python 2 so honestly I would be pretty surprised if he really didn't ever update it.
our job mainly uses python to code as it does a lot of analytic stuff. When we need to implement it for actual usage (i.e. API or whatever), we translate it into C
He must surely believe what he is saying because it's got to be costing him money to not be teaching the latest version. He is with cash backing his belief that no-one uses Python 3. Python 3 has a powerful momentum behind it now. There's no solid argument against it. It's a puzzle why a beginner would learn an old version.
I used to work with java, and python wasn't much use for prototyping because we were mainly just interfacing with a proprietary C library with java bindings. However, generating test cases was often a case of manually typing out a bunch of coordinates after working out what they should be on some graph paper: instead I wrote a couple of scripts to generate them using `turtle`, which saved a lot of hassle. We also had to manually edit XML files and check them for changes etc.: I had ElementTree doing that for me.
I work as a sysadmin for a large Python system that is developed in-house, so I sometimes tinker with it a little too (DevOps, whoo). So I actually work with Python as a Python sysadmin. 
Have you looked at Cygwin? Link -&gt; https://www.cygwin.com/ 
What is Anaconda exactly and how do I use it?
The argument is pretty much a lie, making a correct interoperable 2 3 mix interpreter is pretty much in the realm of incomprehensible hard Making interoperable python code is utterly easy on the other hand
Nah, the civilized world just uses systemd. It does all this and more.
All languages can solve any machine solvable problem. Don't bother hopping around languages for every specific task.
I'm using diango+bokeh+pandas to create some supposedly incredibly useful websites used for reporting important business readouts. I'm trying to figure out why anyone thinks it's cool but my boss will occasionally give me a hearty pat on the back. And a paycheck.
Yea seriously, that's great. Recently my girlfriend agreed to let me teach her some HTML, hopefully that works out too. Hooray for co-op mode learning! Edit: sounded wrongly sarcastic, edited to sound more genuine Edit 2: fixed typo
Well, usually you wouldn't add booleans. And even if, `bool(True + True) == True` is still valid.
I'm constantly surprised as to the power of Python for scientific work. Numpy and Scipy are good of course. But Python is pretty good for parsing, which means that I can take some massive ugly matlab parsers and compress them down into a simple Python parser. And there are libraries for reading every type of common input. And the FFI bindings work really well so you can drop down into C for a single method without too much difficulty. Not to mention Cython (which lets you compile Python-as-C). And you can cannot your code straight to PyCUDA or PyOpenCL if you want to do GPU stuff... And I got a little carried away there. Python is nice.
*come* tee-hee.
Fixed! Thanks lol
In answer to your question. My boss recently asked if there was any way to allow certain authorised internet proxy users the ability to add a required website to the squid whitelist from a web form. I used Pyrhon/Flask/jquery for the site. In python I was able to use ldap to check user credential, DNS to check validity of the website and win32 to restart squid then log everything as well as change the whitelist. Once working I fronted the whole thing with Apache &amp; SSL then linked the whole thing into the squid Access Denied page as a pop-up. This took approx 2 full days of dev time and most of that was messing about with html page layout &amp; jquery and making it look good. The python stuff was done in a couple of hours. Was Python the ideal choice for this? prossably not but it was for me the easiest and fastest choice. I could have done this in C# but I hate the .net web dev libraries with a passion rarely seen outside of a jihadist mosque.
awesome thank you for the suggestions, i will definitely give these a go! already liking the looks of the scipy lecture
or if you want to stay within windows environment as opposed to posix-ish: http://getgnuwin32.sourceforge.net/
Apart from day to day coding a django project, I've also written a script to take an excel file and convert it to an isobel 6 XML file.
What Python-dev actually [says](https://wiki.python.org/moin/Python2orPython3): &gt; Which version you ought to use is mostly dependent on what you want to get done. If you can do exactly what you want with Python 3.x, great! There are a few minor downsides, such as slightly worse library support1 and the fact that most current Linux distributions and Macs are still using 2.x as default, but as a language Python 3.x is definitely ready. In a former life one would have claimed that they fail to aggressively market their new language version using revolutionary bullshit rhetorics, but today such meek, technical prose with its use case distinction attitude goes as a propaganda lie. Interesting. 
If you can't see the value found in Zed's series then you're stuck in semantics rather than learning higher level skills. While I understand why Python 3.x is *finally* worthwhile to learn (i.e library support and growing of community,) I fail to understand how this is even an argument. LPTHW emphasizes learning through trial and error as well as study versus copy and pasting code. 
well, that's not limited to numbers and fully intentional: bool([]) == bool({}) == bool(set()) == bool(0) == False It's something you have to know if you work with python.
copying code is great for explaining how to create the outline of say a django or flask project but once you have that there is really no need at all. So all these books were you copy code are mostly crap and you can learn much faster by looking at tutorials for the library/framework you want to use.
me too.....generating scripts for different days and buckets.
In my department, we maintain the legacy codebase, that's written in plain C. Gradually, we've had to interface more and more with the newer products that uses whizbang features such as XML, REST and CRUD-interfaces. Handling such interfaces in plain C is a painfull experience. In order to get some sanity into the latest interface we had to bolt onto the C-code, we went the route of Python, where we could use a few tens of lines of Python code to support dynamic query strings, rather than have to create several thousand lines of C code to do the same. As an offshot of this new interface, we've also gained the ability to start writing test suites for large part of the code base, which helps a lot with regression testing.
Zed Shaw explained why you should write it instead of copy pasting or just reading. [Right in the Introduction.](http://learnpythonthehardway.org/book/intro.html)
Even though I was blocked from guy's twitter some time ago, I would agree with him on this one. There are numerous reports that 3 is slightly slower, it has some arguable ideas (every string is Unicode, really?) and doesn't seem to be worth the hassle. I've changed several commercial gigs in the last couple of years - 3 was not even an option. It is mostly popular among FOSS hobbyists and zealots (those guys who would persuade their corp spend days of precious time on migrating the codebase with unclear business benefits). There were some talks of porting the interpreter (even if it won't be called Python anymore) on this very subreddit, so I guess we have a problem, some people just prefer not to see that. **Update**: Also no `supervisor` ~~or `uWSGI`~~ support. Meh.
I'm using to automate webmethods deployments. 
You should post the code that you made it with!
have a look at: Code/Inspect Code
I do 90% of my data acquisition and analysis in Python (I work in quantum optics). The remaining 10% I do in C++ with Python for the glue code and "UI" (I'm bad at UI). Also, I often reach for a Python prompt instead of a calculator these days.
My god, it was a revelation when I added the "cygwin/bin" folder to my Windows PATH. No more typing "ls" into a command prompt 5 times until I realise why it's not working :D
True is an instance of type bool which is a subclass of int, and the addition operator requires that it be cast as int. &gt;&gt;&gt; type(True) &lt;class 'bool'&gt; &gt;&gt;&gt; type(True + True) &lt;class 'int'&gt; &gt;&gt;&gt; isinstance(True, bool) True &gt;&gt;&gt; isinstance(True, int) # true if instance or subclass True &gt;&gt;&gt; issubclass(bool,int) True 
The last project I did was the engine for a "choose your own adventure" type game for a major movie studio. It ran through an email interface, and when mailgun blocked us for "sending out spam" (even though we followed allll the best practices for email sending there are, we didn't even track our users) moving to mandrill took like 2 hours. The incoming email was handled through webhooks that were handled by a Flask backend connected to a Postgres DB. The outgoing email was sent out once a minute, using APScheduler and a Python-base daemon. We handled 100k emails in two weeks on a $5 VPS without breaking as sweat. It was a neat project to be involved in.
On one job, I used Python to script DB connections to run identical queries over multiple Databases to collect and consolidate data. On another, Python was the backbone of our core in-house software. Python code was used to define and manipulate our data using a DSL to translate that into a stream processor that ran in a queue.
- glue between different models/programs for data reformatting - statistical analyses of the data, usually with iPython Notebook for easy sharing with colleagues by [nbviewer](http://nbviewer.ipython.org/) - and moving the data to a postgresql database This way I usually get a good understanding of the data and also have great reproducability and automation, which saves a lot of time if you have to redo stuff with different input data. (I work in science)
Useful to squeeze all those VM cycles...
Definitely, fire away
https://xkcd.com/1475/
[Image](http://imgs.xkcd.com/comics/technically.png) **Title:** Technically **Title-text:** "Technically that sentence started with 'well', so--" "Ooh, a rock with a fossil in it!" [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1475#Explanation) **Stats:** This comic has been referenced 306 times, representing 0.3353% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cxrezuz)
Keep in mind that the machine must have the python interpreter installed to run a python script.
[Here](http://www.linuxjournal.com/content/python-scripts-replacement-bash-utility-scripts?page=0,0)'s an article on LinuxJournal on using Python to replace Bash. They have good explanations of why, and tend to have good conventions, and explain things well. There are packages out there that allow you to run commands as functions, and stuff that make it really easy to parse command line arguments (`docopt` or `click`). `subprocess` and `argparse` are in the standard library so you don't need anything else. edit: Also, use Python 3 instead of Python 2. You can write your scripts to be compatible with both, if any of your machines don't have Python 3, but still.
More detail on the crew training simulation please!
I noticed that they are near the scrollbar, and I suppose that this shortcut kind of does the job, but the split was a visual indication and constant reminder that I did something wrong and should fix it. And I need that to keep my code clean on the fly, otherwise I will check it for errors when it's all done and will have to fix tons of them.
What would be different about rendering a page? He is literally opening a browser and parsing the data, what would be a different use case for "Scrapping a javascript rendered page"?
Is there any room in your area for people with good numpy, OK maths and a beginner exposure to machine learning? Or is a full understanding of stats a must.
Dynamically generating classes or business logic. Probably works better in runtime if you just generate byte code 
Data analysis. Pandas, numpy, scipy hit the sweet spot between syntax overload of java (my day job) and incidental complexity of excel.
To be able to keep track of your incredible progress.
Probably 10x longer. It's stupid how fast an experienced Python coder can hack things together.
Automation. Log file parsing. Data analysis. 
Used it at an internship years ago while I was first learning it to automate moving certain files to specific locations. I worked at a television network and videos had to be encoded in multiple formats prior to upload. Editors would place the edited videos in a start folder on our server and the script I wrote copied all the videos every evening and sent them to the correct location to be batch processed by the encoding script. Before I used that script they were moving the video files by hand. Python can be used anywhere and everywhere. Just look at everything you do everyday and ask, "Can I automate this"?
&gt; does Python really fall short of Excel's advanced features? I have no doubt that Python could replicate all of Excel's advanced functions and likely already has. From my perspective, some of us have spent many years with Excel and for some exploratory tasks still default to it. It may be that it's still easier for some people to clean and partition a dataset in pandas and then spit it out to Excel for 'tinkering' and visualization than run the entire workflow through Python, especially if they're new to the language. Even for experienced python analysts, there are lots of times when people ask me for an excel sheet of my data so they can mess around with it; if I sent them a python notebook or sqlite db or--heaven forbid--a csv file they'd get rather annoyed at me. 
I've written Python code that generates some code and then generates human-readable Python code from that. It's twisted, but useful.
"just"?
Yeah Google byte buddy 
I raise you Python code that writes Python code which writes JavaScript. I was writing a module to convert Python to Javascript and came to the realization that it would be faster to write a script which wrote the Python code which translated to Javascript. ^^I have no life
Can confirm, I feel like a god whenever I write a complex RegEx. It also looks like the most complicated jargon to people who don't know it: (^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,32}$)?(^(?=.*\d)(?=.*[a-z])(?=.*[@#$%^&amp;+=]).{8,32}$)?(^(?=.*\d)(?=.*[A-Z])(?=.*[@#$%^&amp;+=]).{8,32}$)?(^(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&amp;+=]).{8,32}$)? Edit: overly complicated regex example taken from [stackexchange](http://stackoverflow.com/questions/3466850/complex-password-regular-expression)
This is the first time I hear of git hooks. They sound interesting, but what kind of stuff can you do with them?
I use Python to do my job as a quality assurance engineer. I build automated checks to save the manual testers time. 
Cool if so. It is red at [the wall](https://python3wos.appspot.com/) though. Don't get me wrong, I personally have nothing against 3. But I'm tired of guys, who have written a couple of things on GitHub and now think "How hard could migrating enterprise to 3 be?". Enterprise is mainly concerned with business value, which is not in favor of this migration. And from what I've seen, enterprise (big scale web, internal services/infrastructure and stuff like that) guys are reluctant about this change. It's a bummer since it's they who breathe life into any language, not the hobbyists.
&gt; In fact it was so annoying that I would fix all the errors, just to get rid of the split, thus resulting with pep8 compliant code If all you want to do is PEP-8, then look at Code&gt;Reformat (hit Ctrl+Alt+L on *nix - but I had to rebind this on Ubuntu) and it will auto-format your code to PEP-8. There might be a plugin that does it on save or push, but saving is kind of hard to remember now. In common with cloud stuff, Pycharm saves automatically almost every time you type a character so I've forgotten the need to save when working in older programs. The issue here with auto-formatting on save is that if the files are changed out from under Pycharm by some 3rd party tool, it takes a few moments up update, and this could result in a either lag or rollback if you're typing fast.
Android app development and scripting. But truth of the matter is we're looking into other options for the former. Performance has become a concern.
Thank you very much, this is exactly what I was looking for! 
My buddy is one of them. A PhD in computer science and he swears by Python for anything that doesn't need low-level optimization. I've sat and watched him hack together working programs in like 15 minutes flat. I'm a hobby programmer and it just stuns me every time, he's always like:"oh, there's a python module that's perfect for what you're doing, I'll send you an email with the links and some sample code!" 
Here's a link to one chapter http://learnpythonthehardway.org/book/ex43.html Notice the emphasis on design - this would not be out of place in a Java book but it's rare in Python books. Notice the study questions, some of which I have reproduced below: * I have a bug in this code. Why is the door lock guessing 11 times? * Explain how returning the next room works. The questions make the student study the code and reason about it. Most books generally just make the student copy the code, then the book explains what it does. I personally don't recommend learning Python 2 but the book is a good book if and only if the student is smart and willing to do actual work. If not, they are going to have a bad time.
If you're using it for sysadmin type duties, than you can use Python for many things. I would recommend checking out the fabric project as it's quite useful for doing remote sysadmin activities: http://www.fabfile.org/. If you need to configure a lot of machines, then you might want to look at Ansible or Salt. At my old job, we used Python for login scripts, installing other programs, configuring other programs, creating websites and web apps (plone/zope, TurboGears), creating desktop user interfaces, working with databases and much more. 
&gt; Cool if so. It is red at the wall[1] though. Ah yes, I suspect that's because it doesn't specify a Python version. In any case, uWSGI operates by managing Python processes, so the extent of its support would depend on the interpreter and its invocation, rather than language features or syntax.
I have to agree. I have almost always been able to accomplish whatever I needed to do using Python.
No, not really. I just make sure python is in my path, so if I'm in the cmd window, I can type program.py or program and it will execute my program. I also make sure that any python programs I want to run anywhere are also in my path.
I created a bat member in my bin that's in my path called ls.bat. That bat file contains one line &gt; dir %* That way I can type `ls` and it will actually execute `dir` in the cmd.
I write aerospace systems analysis and optimization models, making heavy use of numpy, scipy, matplotlib, petsc, among other things.
Usually coding different scripts or smaller apps in order to process large data. (nuclear physicist working in nuclear fusion)
1. Not related to Python. Actually, it says absolutely nothing about python in the summary. 2. "soul purpose" LOL
My company does medical and pharmacological modeling. So we use all the normal data mining and numerical/scientific libraries. On top of that, I have automated a few of my more boring managerial tasks using it too. For example, any time an issue comes in or is flagged for a certain system, I want to be aware of what it is, when it came in, and when it was closed out. If I see the same issue coming in on a pattern, it is worth my attention. If I see certain older systems have repeated issues, it is worth my attention. This helps us keep on top of what systems need upgrading or replacement. It also helps keep a fresh pair of eyes out for repeated issues. Instead of having to log into the issue management system, I have Python jobs running to email me a summary once a day/week. I could use something else, but I stick with the lingua franca so in the hopes that if someone else ever needs it, it won't be foreign.
You can run shell commands with the `os.system()`, or even better is `subprocess.Popen()`. Like so: import os os.system('uname -a') or: import subprocess subprocess.Popen(['uname', '-a']) subprocess.Popen is generally preferred, here's a [StackOverflow post where that point is discussed](http://stackoverflow.com/questions/4813238/difference-between-subprocess-popen-and-os-system).