&gt; What I took away from the article wasn't that Pythons garbage collection was inherently broken, but that the CoW mechanism on Linux systems combined with touching the reference count on reading an object effectively lead to Copy-on-Read, which used up more memory than it should have. Yeah, it duplicated memory it "should not" have effectively privatising pages which were previously shared between multiple processes. And the copy is page-wise, even if objects are much smaller than pages.
You shouldn't. All else being equal, hashing the two inputs will always be slower than directly comparing them. A hash function necessarily has to touch every byte of your input. You need to hash both bits of text, so that means you need to touch every byte of each input. Assuming your hash function has performance linear on the input size (O(n)), then that is the *same* asymptotic complexity as simply comparing the two inputs directly (also O(n)), and is actually worse for two inputs with different lengths because the hash functions need to process both of each pieces of text. The only reason using the hashes would be faster is because they are almost certainly written in either C or assembler. So in that circumstance, using a hash function might help. But if you're really that performance sensitive, then you should probably just write a comparison function in C (or Rust!) and call it from your Python code directly.
You say that you want to check whether pieces of text are similar, which implies not-exact matching, but then you say that using a hash, even small changes may break a match and this is okay. So which is it? If you want to get a similarity measure, use `difflib` as /u/atlbeer suggests. If you want to check for exact equality, I think you should just use the builtin `hash`, as that is what Python itself uses when checking equality with dictionaries keys and so on.
lol, you don't even understand what I'm telling you lol lol you've not read your own link lol. lol. lol. md5 hash lol. answer. lol. lol. lol. lol lol lol lol lol, lol? lol. 
You seem to be talking about comparing one text to another. I think the OP is talking about comparing a number (say, M) of texts all to each other, so O(M^2 ) comparisons. If for each comparison, we use either direct direct comparison or computing and then comparing hashes, that is an O(N) operation as you say, and the full operation becomes O(M^2 N). However, let's say that comparing two precomputed hashes is O(1) (since the size of the hash is fixed with regard to M and N). Then if we first compute and store all hashes this is O(MN), and then comparing all hashes to each other is O(M^2 ). So the total operation becomes O(MN+M^2 ) = O(M^2 ), which is faster than the original idea. Does that seem correct?
btw it's well known trick, especially in Java world. It has different purpose though - decrease overall latency.
Yes but as I understood it, Python changes the reference count of objects even if they are just read, which in combination of CoW on Linux leads to an _effective_ CoR.
i've updated my question. you're partially correct. what's incorrect is that I'd have also to decide whether or not I should insert a new text into a database. And I'd need to do that regularly. thus I'd need to calculate hash of a new text only and then compare it aganst ones in the database. Apparently, that should be faster then comparing the whole textes each time.
I am confident that some of those are still ok.. in nine years.
There's a library for `ffmpeg` i use to read the live camera stream from my usb webcam, which i use for motion detection, but i forgot the name and can't look it up now. I think it takes some digging. Ffmpeg is fast and reliable. That might work.
Am I making a correct conclusion from this article? "If I do not use circular references I can disable GC in Cpython, because it will still do reference counting, and all gc does is break cycles in references?" 
That's R, not Python.
Making `from __future__ import braces` actually work. 
They are real threads, whereas multiprocess means multiple processes. The first means shared memory, the second doesn't, so there's significant overhead to serialize objects when communicating with the other processes. The only thing coming into play that really prevents threads from being really fast is the GIL, but that doesn't matter in an IO bound situation. Edit: gevent and others have the concept of greenlet threads, which they monkey patch into the python interpreter at run time, were you thinking of that? 
I'm not sure why Pillow would install fine globally but not in a virtualenv, unless it came preinstalled or you removed the headers after installing it. Anaconda is a different beast I haven't played with much, so I can't say for sure what's going on there other than I know it does way more than pip. 
Sure, that's how everything worked before the cycle breaker was introduced.
Introduce JSX (React) syntax for embedding HTML elements into Python code.
How would that be diferent from python implemented in python?
Excellent read. &gt; At Instagram, we do [...] small but hacky changes [...] then shipped that [...] to one of our production servers. I love it.
You just have to pick up hashing function that is unlikely make collisions. If you'll decide what hashing function to use than yours algorithm should go something like this: 1. Srap data 2. If hash of that data already exist than ignore it 3. Otherwise put that data to your db You don't have to associate data with it's hash, because you only have to check if hash exists (knowledge about which data this hash was from is irrelevant)
I'm putting in some solid hours on Project DAWP.* ^^^\* ^^^Dicking ^^^About ^^^With ^^^Python
In some cases you might not care about circular references, you can just restart long running process.
It most likely is just aesthetics and doesn't affect anything. With that being said, different interpreters can have different features that can make big differences in how you code (for example, Jupiter notebooks look and behave similar to the default python interpreter, but has a lot more features). In any case, if you're following an online class, then the instructor would have (more than likely) showed you how to install anything necessary, so I wouldn't worry about it unless you skipped any lessons or the professor springs some stuff on you. 
"My fascination for the subway takes autistic proportions" 🤔
Is'nt pypy exactly this ? Well it's written in rpython, but rpython is a subset of python. So technically rpython code is also python code. Or maybe you were just saying that pypy is a crazy idea ?
 This is a fantastic vision, thank you. 
At work i used a mix of https://github.com/seatgeek/fuzzywuzzy , Sequence matcher and some self made string similarities. If you need an exact match though, without any similarity, just text.split(" ") and compare both lists. It will be faster imho.
My life just changed.
Be sure to check out /r/learnpython for all your beginner questions. People are really friendly over there :)
Until you reach turtles, of course.
it was a test. u fail it. lol
lol thats a pretty stupid shortcut considering hash collisions exist
Indeed this is the closest thing to what I'm looking for, but I was thinking was a 2-3 pager with all the most used features, a bit like [clojure does here](https://clojure.org/api/cheatsheet). Since there's probably less to mention for pytest, it might have the space to show very concise synthax examples along with it, or a quick mention of the parameters of each function.
No. testing if a hash is present is average O(1), so the total is just the hash computation time O(MN).
Sometimes did something similar in my projects. Good to know about stable solution.
lol no. you're wrong. 
Depending on what you mean by "automatic discovery"... Numba itself will not be involved in doing any kind of shape or schema discovery, if that's what you're asking. What Travis means here is that Numba will be able to understand the structure and schema of a dataset, as expressed via datashape, in the same what that it understands numpy's dtype and shape concepts. This is a big deal because datashape/ndtypes is a much more general expression of the kinds of structured and semi-structured data that people encounter in real life.
lolol go do your work noob
no what?
not talking to u lol. but checking for duplicate hashes is not O(M^2) it's O(M).
Use Python to program a [microcontroller](https://micropython.org/).
This is completely false. Check out [this case](https://petewarden.com/2010/04/05/how-i-got-sued-by-facebook/) and [this case](http://betanews.com/2016/08/16/linkedin-sues-data-scrapers/). While it's true that most companies probably won't sue you, some others will, especially those having something to lose.
Given the complexities of these objects (and the way many inherit from each other) properties aren't necessarily better. How many properties might a chart have... well it is basically a collapsed box model heirarchy into a single placeholder object. So we have properties for: 1. Two primary dimensions (2 properties) 2. Centering directives on both axes (2 properties) 3. Padding along all four exterior dimensions. (4 properties) Then we have the chart axes lines which have: 4. Two axes styles directives (2-4 properties) 5. Two axes limits min and max limits (4 properties) 6. Two axes tick frequencies (2 properties) 7. Two axes colors (2 properties) 8. Grid style (1-2 properties) 9. Grid color (1-2 properties) I've not even gotten to the thing I'm actually plotting and I'm already up to 12-16 properties. I also haven't considered the title or axes labels and their impact on the layout (that is another dozen properties or so). The simplest answer is to say "This object is too complex" and while I agree with that, exposing the entire layout hierarchy is also not what I want, because I don't want to navigate a hierarchy to change my plot title. Having setters at least makes clear that "this is a method on an object (maybe the axes object or the title object) that changes it" and has been mixed into the primary chart handle. Properties which don't really give that impression. Whose xlim am I messing with? What is it expecting to receive? 
Sure, the language writes. But its COR from the POV of the programmer. You're *technically* correct.
Porting all gnu coreutils to python with NO missing features. 
**TL;DR: Thing = code linting app for Python, Price = free, Feedback = appreciated.** Hi everyone. I have a little side project I recently released called [Lintly](https://lintly.com). It is a continuous Python code linting service for GitHub. One of the things it missed when I released it was support for Python 3 (I know, complete heresy). So I've worked on adding that over the last couple of weeks and now it's finished! Lintly is totally free for open source repos and doesn't support private repos. It might at some point, who knows. For now I just want to hack on it because it's fun. And besides, everyone needs a side project. So if you'd like to try it out, go to [lintly.com](https://lintly.com) and activate some of your GitHub repos. It will lint them every time you push or create a PR. I'd love to get some feedback about what works and what sucks about it. So tweet at me [@gmcconnaughey](https://twitter.com/gmcconnaughey) or the account I made for Lintly, [@LintlyCI](https://twitter.com/LintlyCI). Or go [here](https://github.com/LintlyCI/Lintly-Issues/issues). If you've made it this far then thanks for reading! I hope you like Lintly. Grant
I suppose I should have been more clear. By instructor, I meant whoever has written the online course. Even if you don't have direct contact with them, setting up a proper programming environment is crucial, especially with online courses. Essentially, what I'm saying is that if the web page you're learning from hasn't mentioned why it's software looks different from yours, then it shouldn't be important to learning from that specific course. If the instructor(s) needed you to install a specific piece of software, they would have mentioned it (if this isn't the case, then advise finding another course. It's crucial that everyone is on the same page when it comes to this kind of stuff, so if the writers goofed and forgot to mention it, then they wouldn't be very effective instructors). And as /u/cripcate pointed out, /r/learnpython is a more suitable subreddit for these kind of questions. But I could imagine this situation would be confusing if you aren't familiar with programming and/or online courses. 
lol. I'm your boss, you've forgotten? lol, very lol
Or maybe just add UNIQUE constraint to your column with data, if you're using SQL DB :D
&gt; I also prefer not passing ORM models to templates. I was going to react to that, but I follow this convention with more "extensible" apps anyway. Depends on the application. For my blog, the ORM objects go into the templates. For a more extensible "work" app, I use Pyramid where we are constructing view structures for every template anyway - which has the nice side effect they can go into a client side template or a web service frontend just as nicely.
I have been doing some scraping for only about a month so I am still very new to this but I thought this was an interesting approach using pandas for 'tidying' the data. I generally just grab data and put it in a csv to use elsewhere but now I'm going to try using pandas. However, I copied and pasted your script and there were some errors. I use 2.7 so I had to use urllib2 which I caught before running. The errors/typos are in variable names. I changed them and got it working. Don't know if this was intentional or not because it looks like you went back and rewrote the script using the original script as a guide. Still really helpful though, so thanks.
&gt; DynamoDB At that point you're spending more hosting on AWS than you would be hosting a couple of cheap VPSs.
XDG_CONFIG_HOME is suitable. XDG_CACHE_HOME should not be used because the expectation of the cache directory is that it can be deleted at any time at only the cost of slower loading / calculations / download. no data that can't be restored automatically must be lost when using cache home.
What's the advantage of this, over say Jinja2 with macros for modularity?
Releasing Python 2.8. Or even crazier: Python 3 rolling back it's incompatible changes in the next version. Edit: Hey downvoters... the thread is named *crazy ideas*... not good ideas. Get it? 
Firing Guido, implementing those awesome libs that we now need to DL first.
If you find this interesting, look into attribs and tri.struct too. 
A bit late to the party, here's my question: Where do you think Python is still weak, vis-a-vis data science, when compared to languages like Java / R? Where do we need to improve / put more effort in? PS: Great work on Anaconda!
Because either they hate breaking changes in Py3, or there's not enough libraries ported.
No problem. I'd also recommend checking out the other capabilities that it offers, it's great at automating your system administration tasks for Windows, Linux, and MacOS.
That being said, these days I use nothing but python3 as the wall of shame is no more. https://python3wos.appspot.com/
That's it. Sync code doesn't care about this when you're writing this, async code does since you have to do IO with await and await can only exist in async functions (I suppose there's also yield from and the coroutine decorator if you're supporting 3.3/3.4, I chose not to for my personal projects)
In context, though, it seems like they did this in a very controlled manner for testing this issue. And then they made the real fix in a better way and deployed that globally.
Definitely not the only gigantic company that does this. I can't believe how companies like this have no testing or staging environments and just mess up the app for 5% of servers/people until they realize they have to rollback...
Support for robust exception handling within comprehension syntax. 
Guess they should've used the GC after all! /s
The question is: how do you know whether any part of your codebase creates cycles?
XDG is a fairly recent standard in UNIX terms, and the onus of supporting it generally falls on the apps, not the operating system. I wouldn't hold that against Apple. By the way I don't think it's prudent to force your users to use virtual environments. There's no guarantee that any directory in the Python path is writeable, unless of course you make one and add it at runtime (but in that case, why not just use the XDG directories).
no kidding. that's why you associate hashes to documents so you can do an actual equality test before you throw away data.
I've never even heard of the libraries still in red.
Rolling back the improvements? I'll pass, thanks. Hey, I've got a GREAT idea, why don't you fork Python and release 2.8 yourself?
Post the actual question in /r/learnpython.
Wouldn't it have been easier to use a lower-level language?
pretty sure that's already being done.
They might be too big to build a realistic test environment. Netflix did some presentation on this (look up 'netflix chaos monkey'). Because they are 1/3rd of US bandwidth at peak time they can't simulate their system in any kind of lab, and have to test in production.
Haha - great to hear!
Turn it off and see if it breaks.
Firing Guido and hiring someone thrown out of business school for academic dishonesty. Also known as the Trump maneuver.
dot notation for dictionaries
My needs have changed now.... tree = ET.parse(fullname) root = tree.getroot() terms = root.iter() for E in terms: print(E.text) But I want to specifically search for something in terms. for E in terms: if E == "Something": print(E.text) does not work!
Scrapes the articles, summarizes them, and if there's a surge in news for a particular stock, sends an email with the recent stats, summaries, links, and post dates.
Release the kraken! 
Python's advantages and disadvantages compared to R are very different than those compared to Java. Mostly b/c when compared against R, we can look at the "pydata &amp; scipy" bits of Python and compare against R, and then we can tack on the Python advantages of being a more general-purpose language, that is in its own right ascending in popularity compared to other general purpose languages. So, it's somewhat imbalanced, but at least in the data &amp; scientific part of the comparison, we can see how they mostly go toe-to-toe in terms of features. When comparing Python vs. Java, we have to separate their traits again into two piles, but the comparison is much more imbalanced. There is no question that Python is more suited for data analysis and numerical and technical computing. And, its capabilities there are improving faster than Java is improving for those purposes - mostly because 99% of people who use Java are software developers (not data scientists or engineers), and there isn't a "numerical computing" ecosystem around Java at anywhere near the scale or momentum of the same one around Python. However, in Java's favor, it is by far the more commonly deployed programming language and ecosystem within "standard" businesses. So IT operators and managers all know how to deal with Java as a production-ready technology. Whereas Python is still somewhat of an unknown entity. I do see that you asked specifically about data science. In that regard, I think that Python's core weakness relative to Java is that people still have to jump through hoops to get resilient, production-ready distributed systems ready. The challenge isn't actually technological, because I think the tools are all there, and Python itself is clearly up to the job - certainly as much as Java is. The challenge is that there is a whole ecosystem of enterprise tooling for deploying, managing, monitoring, a whole pile of JARs. Nothing similar really exists for "a whole pile of PYCs" - even though of course our Anaconda Enterprise platform does some of that for data science workloads. In the data science square off relative to R, I think that Python is very much catching up, on many fronts, and within a year or two, most of the major gaps will be mostly ameliorated. It would be really fantastic if more of the core libraries like matplotlib, statsmodels, pandas, and even newer ones like PySpark could actually get full-time employed maintainers. We're trying to encourage companies to contribute to such effort via NumFOCUS, but it's slow going - even though SO many companies rely on the work coming out of those teams. Some firms like Two Sigma are doing the world a favor by e.g. employing maintainers like Wes, and of course generous grants from foundations also really help. But I think that if the commercial/enterprise user community banded together and pushed the funding of "core" pydata/scipy projects up to the $2mil/yr mark, that would make a HUGE difference. That might sound like a lot of money, but I know there are small groups within big companies that pay that much each year for their SAS license renewal, so it's actually not a huge ask. :-) Answering your question differently, however: with the emergence of JupyterLab and the momentum behind Jupyter and its kernel protocols, if we are successful with datashape and projects like feather/Arrow achieve cross-language persistence, then you may not have to choose languages at all for a great number of tasks! :-)
The [GILectomy talk](https://www.youtube.com/watch?v=P3AyI_u66Bw) is truly one of the crazy things I've seen.
Nope, not really. Though some software constraints, it did allow for "good enough" performance (performance wasn't the problem, memory constraint was) and python had a lot better speed of development, iteration and deployment than other languages did at the time. The only real contender was C, and frankly, C brings with it a whole nest of issues.
I used to use qpid, but now I'm using pika at my current company.
sure, but only idiots base opinions/decisions on first glances?
not the same type of GC and thus not same effects.
I had plenty of assertions in a testing harness I developed at my current company. In time they were transformed into normal exceptions, in part because pytest stopped wrapping them nicely and suddenly we got very little info out of them. The only place we now have asserts is the actual test code, not the harness.
There's a better write up IMHO here [When to use assert ](https://mail.python.org/pipermail/python-list/2013-November/660568.html).
[XCXSound](http://refi64.com/proj/xcxsound.html): A tool that lets you make music swaps/mods for the (awesome) Wii U game Xenoblade Chronicles X. Written in Python 3 + PySide.
Why should I use this over the linter plugin in atom?
I have to chuckle when I read that the moz... libraries are "supported" by the Mozilla Automation and Tools team.
Python 4: break moar stuff
Oi, hold on a minute. You can write custom decoders? Edit: [This changes everything](https://github.com/dropbox/pyxl#parsing)
Thanks. I thought it was the ssh library. Not as relevant as I thought. 
For those who may be wondering: this is licensed under a 3-Clause BSD license with no separate Facebook Patents license. So you might not have to worry about facebook's bullshit. You might have the other organizations involved to thank.
What I'd go for: $XDG_CONFIG_HOME/your_app_name/ if it's set, otherwise ~/.config/your_app_name/ if ~/.config exists, otherwise ~/.your_app_name/. Keep stuff in ~/.config and $XDG_CONFIG_HOME inside a folder named after your app, but if you only need one config file then feel free to just dump a single config file in the home directory rather creating than a whole folder.
Amazing &gt; PyQt5 / QML. PyQt's has no surprises and is amazingly well polished. Separation of logic and presentation i use conda 
X-Post referenced from [/r/datascience](http://np.reddit.com/r/datascience) by /u/crazylikeajellyfish [Collaborative Platform: Unlock practical lessons in NLP techniques by labeling data for active researchers at edX. Like FoldIt and Captchas, but with text samples and tutorials. (x-post r/MachineLearning)](http://np.reddit.com/r/datascience/comments/5os11j/collaborative_platform_unlock_practical_lessons/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
It's so commercialised and I trust the PyPA and python.org way more. I don't use virtualenv I stick with `python3 -m venv`
I used to go through this all the time. I find that if I am going to build a tool or script or whatever it is I will try and make sure that I am going to be doing it frequently enough that the tools makes sense. Like if the task is redundant and repetitive I will create a quick script. If the task is bigger or I need to give the tool to another person that is a different beast in deed. It's fine for me not to validate input if I am the one who wrote the tool and I know what will break it. I'm getting off point. What I mean to say is that gauge your time and your audience. Find the problem and solve it. Don't try to plug a solution on a problem. 
I love Anaconda. It has made working on multiple projects so much easier. 
Nagare does this. As does Timothy Crowley's webbot among others.
Good question! Linter plugins for an editor like Atom or Sublime Text are great for local development. And if you have a project where you're the only collaborator then Lintly probably won't do much for you. Lintly is more for bigger projects where there are several collaborators and you want to ensure that the project's code quality stays high. Lintly will complain about issues introduced in pull requests, which is a good way to ensure that other people aren't introducing ugly code into your code base. It'll also track code quality over time. That's handy for big projects that have lots of code quality violations and need to see if they are improving or getting worse.
The primary reason is that the `apply_discount()` will be used somewhere else in your code. You probably call it with something like: try: final_price = apply_discount(product, discount) except ValueError as err: log_error(err) final_price = product['price'] # default to no discount Where you are catching a very specific error, and handling it. If you use assert, you're not being explicit about which error occurred. This is important if more than one kind of error is possible or expected, and you want to deal with their side effects gracefully.
I do not have an answer, but I can point you to two relevant XKCDs: * [Automation (#1319)](https://xkcd.com/1319/) * [Is It Worth the Time? (#1205)](https://xkcd.com/1205/) 
###[Irrelevant xkcd](http://xkcd.com/781/) ********** I'm a bot bleep, bloop
Agreed... the professor is in a better position to help, than anyone out here. Unless, of course, you were never in the hospital.
 PROMPT = '&gt; ' while True: try: cmd_in = input(PROMPT) if cmd_in == 'quit': exit(0) # do something except (EOFError, KeyboardInterrupt): exit(0) The exception `EOFError` will fire if the user enters an EOF at the prompt (CTRL-D in *nix, CTRL-Z in Win). `KeyboardInterrupt` will fire if the user pressed CTRL-BREAK/CTRL-C.
Ok. Thanks. That makes sense
Might be better to do this with a context manager than risk the confusion between `if foo == bar` being typoed as `if foo = bar`. You would need an `else` for `with` (perhaps if the context managers `__enter__` raises an exception?) And then re.match could be a context manager that returns the matching value or raises an exception if no match is found. with re.match(string) as x: print(x) else with ... 
Agree, in the tutorials, it looks super elegant. If there's not a huge disadvantage performance-wise, I'd seriously consider this as my go-to library :). I am really excited about this!
Given your updated question, I think you should just use a set to check for containment. Sets use hashes and are meant for exactly this purpose. 
Good stuff. Any chance of adding fstrings to python3.4 :)
Made with BigQuery https://github.com/anvaka/common-words/blob/master/data-extract/sql/extract_words.sql :)
Hello! Wrote my first test because of your suggestion! Although the code looks repetitive, its something 😁 , How Do you think I can improve my tests Have a look at the repository Once more, I completed all that was planned including Continuous integration and made it into a command line application 😁 And the only pending thing is that adapter class you talked about, how do I Learn adapter classes in python
Well, there's raw counts on the side.
Yeah, I've tried to write a CFFI interface for a C++ database and it gets a bit awkward, having to write constructors... There's also cppyy (http://doc.pypy.org/en/latest/cppyy.html), haven't tried that one yet.
MUST BE MY BIRTHDAY
CUDA only, no plans to support OpenCL. :(
Yes, If I had a startup I'd be pretty confident that I'd be legally able to defend it here in Europe. You can't copyright public data - that's like copy the text displayed on public, government-owned sources. This especially becoming more true and true with every step that is taken to classify internet access as human right and such. To further the argument, there's a good answer on quora regarding web-crawling [here](https://www.quora.com/What-is-the-legality-of-web-scraping) which concludes that in general web-scraping is pretty legal. But yeah, like you said yourself, it can still be all about how much you are willing to risk. Though you certainly shouldn't hold yourself back if you're scraping for educational purposes or something non-profit. And even if you are doing it for profit, the lawsuit cases are so rare and there are so many mixed reports that it's highly unlikely that you'd get in trouble. 
I think that's one of the advantages of being a big software company with non-critical user objectives. Your users (using your essentially free service?) can test all cases, and all cases that should never have been, in 5 minutes.
Yeah, it's pretty...but it tells you nothing interesting (the point of a visualization). Surprise, surprise, "the" is a common word in comments, or if you struck them that keywords are extremely common in any language, or if you struck those that builtins/stdlib are extremely common, or `i`...
… Just about everything? :D I write programs to solve problems that I encounter while writing programs, *ad infinitum* …
None whatsoever!
pika is python 3 ready, and https://github.com/jbg/rabbit is available with C bindings (though the maintainer suggests it could be improved).
XKCD is the best
It's the articles like this that really give me imposter syndrome.
Most problems can be solved faster manually than programmatically. It's just when you want to do that one problem at scale that programming shows its value.
this seems like a nice api... kudos facebook for the open source contributions!
This is quite an elegant use of it IMHO: https://github.com/jonathanslenders/pymux/blob/master/pymux/client.py#L62 For boundary code (e.g. the API exposed by libraries) it means that when you use it you get a clear error quickly rather than a head scratcher. I've also seen it used in production code to make it fail faster which allowed us to track down the root cause of the problem more quickly rather than allowing the problem to fester and explode at a more inconvenient time.
The former has the benefit of being terser while the latter fails with a clearer message and more relevant exception. I don't think either one is intrinsically better, it just depends which code quality you value most. It's not like anybody would see a stack trace for the former code and get confused, either.
&gt;the fact that pendulum does not recognize the string and fallbacks on the dateutil parser which produces these results. That's pretty terrible behavior IMHO. Pendulum should raise exceptions if it encounters ambiguous strings. This is actually something that bugs me about dateutil too.
This ol' flamewar again. If there really are that many people that hate the decisions made in Python 3, they should just fork it, change the name, create their own mailing lists, and go their own way.
Creating a FB group chat bot. If you can't bring your friends to IRC (or discord for the hip crowd), you bring IRC to your friends. Soon will post final code. Started Python 6 days ago. That xkcd comic did not lie. Python is amazing.
It's a shame that OpenCL is getting sidelined as much as it is
Have to chime in on how fucking worthless word clouds are as a data visualization.
Funny thing, I was considering using "&lt;&lt;" to append nodes like Nagare. I have never seen this framework until now. I cannot find any html related frameworks with the name webbot. If you can provide a link I'd like to take a look.
Having developed in CUDA and looked at OpenCL, I'd never want to spend time on OpenCL.
Oh, guess I don't know what a "top level function" is. I though it was functions at the top of the calling heirarchy. Ie, http://stackoverflow.com/questions/633617/i-want-to-know-the-difference-between-low-level-functions-top-level-functions
&gt; It's not only unusual, it also violates a bunch of very reasonable expectations. I won't argue there. &gt; And the addition operator, +, same story: it's not supposed to modify its operands, only inspect them, add them, and return the sum. This is assuming integers. Strings concatenate, and non primitive classes can decide what it would do (timedelta for example). Other non-math example would be the pathlib module that uses the divisor syntax for path traversal. There is a side effect and strictly speaking, it isn't *not* Pythonic to have side effects. Though I understand the repulsion to it also returning. Under the hood it's foo = some_tag.__add__(Tag('child_tag')) Which is (effectively) foo = some_tag._append(Tag('child_tag')) With that said, again, I still understand the aversion.
This is neat. I might not have worked on this if I knew about Dominate sooner. Thanks for the link.
They are only useful for domain experts to quickly check against their priors.
Use `gc.set_debug(gc.DEBUG_STATS)` https://docs.python.org/3/library/gc.html#gc.DEBUG_STATS It shows how many objects circular GC collects.
... That's Javascript. http://stackoverflow.com/questions/18138166/what-is-a-top-level-statement-in-python &gt; It's not just variable declarations (and there aren't any variable declarations anyway). It's pretty much anything that starts at indentation level 0.
What was it with Cpython?
How so? I mean, in comparison to just having a list of terms with their corresponding frequencies? The reason why I think word clouds are worthless as a data visualization is because their layout is mostly non-deterministic. Not only is it hard to do any kind of direct comparison between terms, you may not even notice terms based on their color, orientation, and position.
Paste a URL to the problem. I'm interested in seeing an assignment that is meant to be 45% of the grade.
Here's the [referenced tracking bug with a list of all the things yet to be done](https://code.djangoproject.com/ticket/23919). 
A bar chart would be much more useful. Comparing 8 digit numbers is annoying.
Anyone can post anything on pypi. No review process and no accountability == no quality expectation.
is there any specific reason why you don't want to work with OpenCL?
Good
And mine too 😻
english-latin translation tool for my latin homework
Someone tried that and Guido told them to change the name (rightfully so).
Being curious, what is the advantage over: class DottedMixin: def __getattr__(self, key): return super().__getitem__(key) def __setattr__(self, key, attr): return super().__setitem__(key, value) And then reuse for any dict like object you need? class DottedDefaultDict(DottedMixin, defaultdict): pass def Tree(): return DottedDefaultDict(Tree) a = Tree() a.b.c.d.e.f = '...x.y.z'
You can do all sorts of stuff with them. Dave Beazley gave a talk (tutorial, actually) a few years ago where he ends up importing XML files as Python code. Hylang is built using an import hook to load and process lisp into Python. 
The major cause of Python's broken GIL is its broken GC.
Genuinely curious, what is the blocker for 3.x for you? Libraries? Actually getting an interpreter installed? Legacy code?
Word clouds try and hack our brains natural tendency to find patterns. Specifically, our brain's pattern matching distinguishing between thing and not thing from a background of things. Domain experts will have grokked the words relating to their domain and have a baked-in estimate of the relative importance of each word. Our brains work big to small. When we look at word clouds we notice the biggest representations first, regardless of the colour or orientation (excluding upside-down of course). When you are primed for what the word cloud represents, you will naturally compare your ordered list with the order in which you notice the items in the word cloud. So if you look at a word cloud and nothing really stands out to you, then that is because your ordered list (prior) is a good representation of the domain. (Or at least, it represents the domain in the same way as the word cloud implies.) Alternatively, it will be quite obvious when those two ordered lists are in disagreement. Consider if the word cloud shown at the link had the word 'java' in big letters. It would feel as if it was the first thing you consciously noticed. Your eyes would be drawn to it. The thing is, the word 'java' could be quite small, and you are still likely to consciously _notice it_ first if everything larger more or less coincides with your prior expectation. That word might be overlooked in a table of several hundred words, but stand out like a sore thumb in a word cloud. EDIT: Think of the word cloud as a python set and the list of terms as a python list. Word Cloud is O(1) while Word List is O(n)
First venture into python for the past few days. Just trying to figure out the best way to manipulate strings coming in from an arduino to be able to control a set of servos and LEDs.
I'd be okay with this under a few circumstances, one being removing the GIL. I want my n-core interpreter, damnit!
Makes sense. You go through all the trouble of porting your application to a new language, why would you support the old one.
They get memleaks (but not too huge) and solve them by restarting the workers. Which is quite a performant solution when you use forking to create the new workers (uwsgi). 
Good news. I hop Django will support type hints.
Until that one django app that's vital to your project gets ignored and remains at 2.7 forever, with noone carrying enough to update it. Hopefully not too many of these exist anymore, however.
These days its quite likely than a newer package that you need, didn't support python2 to begin with. So Python3 is safer, i'd argue.
Will 2.0 include channels (ie websockets)?
I thin `six` package could actually release a decoder layer for 2to3.
They can't use async and await as they are still using uwsgi, which is incompatible with async. You need to use something like aiohttp/curio/waspy that is build on an event loop. 
I know aiohttp and curio but what is waspy ?
This isn't related to python at all. 
The plan is to move to a three-release cycle: X.0, X.1, X.2, then (X+1).0, etc. So 2.0 followed by 2.1 and 2.2, then 3.0, 3.1, 3.2, 4.0, and so on. The compatibility policy will be: 1. Each X.2 release is an LTS. 2. If your code runs on version X.2 without raising any deprecation warnings, it will also run (but may raise new deprecation warnings) on version (X+1).2. So suppose you've got an app running on Django 2.2 (when it comes out). You make sure you're not raising any deprecation warnings, and you can just upgrade direct to Django 3.2 (when it comes out). Clear any deprecation warnings you see now, and you're ready to go for 4.2 when *that* lands.
TIL Strings are not made of Bytes. No wonder people dislike Py3k fanboys...
Creating a script that parses excel files (layout doesnt work well with csv) and creates sql statements so that we can import the data in our new work report tool.
&gt; 0 down vote favorite Fucking LOL /r/learnpython
But sometimes doing things manually is error prone, writing a script ensures you don't make critical mistakes due to repetition.
Don't know, just a wild guess. Do you know which is the best performance wise?
Woop Woop! Congrats !! Partay !!
Take a look at [Modules and Imports](https://pymotw.com/3/sys/imports.html).
"Django 2.0 (now on master) will not support legacy Python" (using the Talk Python To Me terminology)
If you are actually interested in something like this look at the MUCH more mature and capable mochi: Lambdascript looks like an early proof of concept at best. And the name is terrible: google for it and there are lots of projects with the same name!
A year ago I wanted to use a django plugin that was py2 only. Without knowing anything about it's code, updating it so that it supported 2.7+3.x seamlessly was quite straightforward and took ~2 hours. If something non-huge is vital for your project, it doesn't matter if it's unmaintained, moving it on to Python 3 is trivial, it's *not* like it's a different language, but just a few tweaks.
This is amazing news. Django &lt;3
&gt; This is assuming integers. Strings concatenate, and non primitive classes can decide what it would do (timedelta for example). Other non-math example would be the pathlib module that uses the divisor syntax for path traversal. No, I wasn't assuming integers; I was assuming a very broad definition of "sum" and "add". Maybe I should have used more precise language: The monoidal concatenation operator, +, is not supposed to modify its operands, only inspect them, monoidally concatenate them, and return the monoidal sum. Then again, it's not even a monoid, but more like a [torsor](http://math.ucr.edu/home/baez/torsors.html), because the operands do not have to be of the same type (e.g., you can add time deltas to timestamps, but not timestamps to timestamps). Anyway, the point is that having a `+` operator that isn't even referentially transparent is really really bad, and it makes your DSL look like you don't really know what you're doing.
Attempting to make all the APIs symmetrical here would be nice https://coderwall.com/p/sa9lbg/symmetry-in-apis
Maybe once Pypy-STM is working - then we could have a 4 that could really make use of this (ie change all the APIs to make this work better).
&gt; If all you want to do is exit, then just let the error do it's job. I wrote the example so that it will be clear what happens in every case, like you'd do in pseudocode.
Wait, if it's a database just put a unique constraint on the column, if it's already in there it won't insert, if it isn't it will. If you're taking about doing this in python, just put the strings in a set(), duplicates won't insert into a set and it can check for membership in O(1) average time. 
interesting concept, first time to hear about, but surely i will keep it in mind, thanks !
&gt;I'm curious what you consider best practices for manipulating large and varied data sets in Python? What's the best way to feed them into and out of functions that process and use them? What minimizes memory and computational time? What's your application and your approach? I'm not sure it's possible for anyone to answer these questions for you other than by responding with "it depends on the situation." You are looking for some sort of silver bullet solution to a vague problem. You will likely get more and higher quality responses if you share your code.
Sorry, but this is inaccurate. - Django itself is WSGI compliant and supports a ton of application servers, not just uWSGI. - uWSGI supports (various) async approaches, and is *very* good at that. - You can absolutely do async in a WSGI-based framework like Flask or Django, but doing so will make it incompatible with most WSGI servers, since that is not part of the standard. I.e. you're likely binding yourself to a specific WSGI server, eg. uWSGI. Other than that there is no real problem. But the benefits are usually kinda small, unless there are some specific instances (eg. hot views that spend a lot of query time -- then it can improve throughput by using an asynchronous DB driver, but it's a finicky business to get that working properly with the ORM -- but it *is* possible). - One can also use that to do WebSockets and regular Django in the same worker processes. Using uWSGI's support for this it isn't much code, quite simple and works nicely for some cases (obviously all coros are blocked during Django request processing, as one would expect). - You can absolutely mix async ("pseudo WSGI") and sync WSGI apps. A sync app is the same thing as an async app that does not yield within a request. Do realize, though, that async would not mean asyncio here, or async/await keywords. I think it would be technically possible to do it by grabbing the loop instance and injecting your stuff in there, but you probably can't wait for completion properly. The whole "don't just enable async and expect better performance" warning boxes in all the docs are mainly there because some charlatans claimed that and it *can* cause problems. It's an advanced topic, and requires some understanding of how async works and interacts.
&gt;The Building ID is common for both files and the rows need to reflect that. Only entries that are common can be dropped in. If Building ID does not match it should remain blank. Make a list of the rows in document A, and the same for B. I would use tuples. Then: for row in A: if row in B: # insert row into document C &gt;The second problem is deciding which library to use. Why do you need a library for this? Python can parse text files and write CSV files without importing anything.
I'm designing/writing a micro-framework a la Flask that uses type annotations for it's views. So you could do something like: @get('users/&lt;u&gt;') def get_user(u: User): return {'name': u.name, 'age': u.age} @get('mul/&lt;x&gt;/&lt;y&gt;') def multiply(x: int, y: int): return str(x * y)
well there's definitely a higher quality expecation than gtihub. 
That's a really nice release policy! Will updates be released on a fixed schedule, or 'when they're ready'?
I'm not so much looking for a silver bullet, as trying to start a conversation that's broader than my application. This isn't a learn programming subreddit, after all. I see very little written about planning out, diagraming, and designing larger software projects. (And my application hardly counts as large). Maybe that's because so much writing about programming on the web is aimed at novices, maybe it's because I don't know the right terms to search for, I'm not sure. At any rate, as you plan out any substantial project, you end up with series of nested functions, or other "structures" which require passing data around. There must be better and worse ways to handle this. Further seems like best practice will be language dependent, or at least be influenced by whether you language is object oriented or not, compiled or interpreted, etc. I'm happy to post code or a sudo-code example if you think that will focus the discussion. That will have to wait until I get home. 
Then stop using it.
&gt;you end up with series of nested functions Aside from a closure or decorator, I've never been in this situation. &gt;which require passing data around It's important to mention that data is never passed around. Once it is placed in memory, it isn't moved to another position in memory when you use it in different function. Your reference to that data might be altered, or the data in memory may be altered, copied, etc, but it is never "moved" from function to function. &gt;There must be better and worse ways to handle this. You're exactly right. Using an improper data structure is a worse way. Using a set when you need an ordered set, using a list of tuples when you need a dict, using a `for` loop when you can use `map()` or `filter()`, etc. are all poor decisions. Which data structure and syntax to use is completely dependent on the situation though. I think the biggest issue with this particular question is that it isn't properly explained, or maybe I'm just completely missing your point. It really does seem as though you are looking for a silver bullet though. There is no "best" practice that applies to all situations. Novices write large projects as well. Large != advanced. Honestly, I fail to see how a large project is any different than a small project. Both are susceptible to poor design, bad decisions, inefficient syntax, improper data structures, etc. If anything, a large project is just multiple small projects packaged and working together. 
Why not if foo as bar: ? No need for a context manager then and it fits with other constructs like exceptions and imports 
Why You Need A New Website * Looks like 1991. No offense, could'nt help myself, do not think the text has much value.
Only concern would be how as interacts with or: `if f1() as foo or f2() as bar:`? If the first call returns a true-ish is the symbol bar defined? Is it none? But yeah otherwise I agree as could be used in if. For that matter as could be used anywhere: `(f1() as x)/(1+x)` 
Sounds like you enjoyed writing the script much more than you would have enjoyed generating latex solution sheets manually. There's something to be said about that :)
LOL, it's a shame she'll never get to appreciate how much effort you put into that text
We had a task where you took data from one system, put it in email, waited for it to show up in another system, confirm it, add comment and submit. Nothing hard, didn't took long (15min a week maybe?) but boy was it boring! So we wrote some scripts, setup a web page where you got the data, added comments and it sent the email, and - in background - submitted it. Management liked it so much - only after we left, mind you - that some poor soul has to maintain it. ;)
The author has a few fundamental misunderstandings, specifically the "private" concept: * `_foo`: this is "protected", and it acts the way it does for exactly the reason the author shows as a problem - the extending class can take it over * `__foo`: this is "private" and actually gets "name mangled". It effectively namespaces the item to the owning class. For [reference](https://docs.python.org/2/tutorial/classes.html#tut-private) &gt; Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of the form \_\_spam (at least two leading underscores, at most one trailing underscore) is textually replaced with \_classname\_\_spam, where classname is the current class name with leading underscore(s) stripped. Regarding lambdas, another language operating desire is to maintain readability. Multi line lambda doesn't usually read as well as just making a locally scoped `def`. Imo decorators are a huge reason why I love Python. It's effectively a form of aspect oriented programming (but a bit more obvious than something like Java AOP). It allows functions to focus on their single duty and something else handles the fiddle bits (for the flask example, wiring it up to a URL handler and processing the result value). That's not to suggest you cant access them when you know the convention. Not that I think Python is perfect, but the language operates under a few assumptions that not everyone wants to subscribe to, which is ok :)
but those are a big chunks of text, would "set" be able to hangle them? 
I think that it should be defined as None due to the short circuit nature of or, otherwise it would raise an UnboundLocalError, and I think that in general a False-y value is better than any other object. It kinda goes against the Zen of Python in that way, as explicit is better than implicit, so that's a little rough. The other issue that I had thought of is the scoping. if f1() == 4 as foo: pass elif foo == 3: # Would or should this be valid? pass
Oh she did, it told her it was a bot and what I did for half a day. Made it an even nicer surprise. :D
No problem :) I've had a lot of success with monolithic projects because spliting off a project into multiple segments---especially at the start---causes a lot of friction since you'll be modifying each segment individually to make them work together as a whole. Once you've got a mature project, its much easier to split out parts and use them elsewhere---say to jump start other projects.
This is the first thing I checked, and was pretty surprised and happy to see that there was no Facebook patent thing.
Perfect question for /r/learnpython. /r/python is more suitable for Python news or information relevant for the community at large. Thanks!
That's a pretty wild guess. Can you think of what the computer has to do to actually execute the two options?
&gt; it is more a problem of integrating CPython on Linux it's specifically about using multiprocessing for parallelism, which on Linux uses 'fork'. The issue is more that linux wasn't able to provide the optimisation that they would have expected. Naively, if you use multiprocessing you expect each process you create to be a copy of the original one and to take up as much memory, i.e. 4 processes = 4x the memory. But Linux is smarter - it knows that if you haven't written to a bit of memory, that memory hasn't changed so it doesn't need to make an actual copy yet, only that it should make a copy if you do try to change it (Copy-on-write). So initially the memory use doesn't increase i.e. 4 processes = 1x the memory, and this should only increase when variables start being modified (but not when they are simply being read). The issue they ran into was that the Garbage Collector (GC) was effectively modify python objects at a low level, so even though their programming wasn't modifying data, the GC was. This made it impossible for Linux to be clever and avoid making copies of all those variables - you are back to the naive case. They were able to simply disable the GC for a couple of reasons. First, Python mostly manages memory through reference counting and the GC is mostly to catch special cases (like cycles). Secondly, their infrastructure is designed so that an exernal program manages their python processes. This program can kill and restart an app that starts to use too much memory. Since they save memory overall they can run more processes in parallel. Note that this is useless and even dangerous for many workloads - in effect you are allowing your python to have memory leaks which could lead it to eat up all your system memory. If for example you wrote a desktop app in python and disabled GC in this way, that app could easily slow the users computer to a crawl by eating up all their RAM.
I may not be understanding your question fully because I just woke up but if you're trying to remove white space in a string of text you can play around with the strip() method. If I had a simple string: simple_string = ' Simplestring' And I wanted to remove the white space at the beginning of the string, before the actual text, I could effectively do that with the strip() method. print( simple_string.strip() ) &gt;&gt;Simplestring If you just wanted to remove the white space on the left or right of the text you would use lstrip() or rstrip() respectively. But just using strip() will remove all white space. It's primarily used to clean up user input. Hope that helps a little.
The 1.11 release which will be coming out soon will be the last LTS release before 2.0. 1.11 will be supported until end of life of 2.7 in 2020. https://www.djangoproject.com/weblog/2015/jun/25/roadmap/
Yeah, you're going to need to recreate them. Even if you fixed the interpreter binary, any modules installed in the virtual environment that had compiled C extensions would be broken, because major versions are not ABI compatible.
There is no objective expectation of quality. *You* expect higher quality, but I don't know why. On github, you can check how long has the project been active, what open issues does it have, how effective has the project been at closing issues, how well is it documented, etc. When I search for a library, if I find it on pypi, I'm definitely going to checkout the github before installing. If they don't have a public repo, I'll keep looking for other libraries.
&gt; Regarding lambdas, another language operating desire is to maintain readability. Multi line lambda doesn't usually read as well as just making a locally scoped def. That is of course utter bullshit; the absence of a syntactic option does not make it easier to write readable code - best case, that option is not required to make the code readable, and then you just don't use it; worst case, it *would* make the code more readable, but you don't have the feature, so you can't use it. And this from a language that touts the Consenting Adults idea.
That site has a refreshing lack of bling-bling. Seems to take the motherfuckingwebsite.com advice to heart. I like that.
Yes you are right, for text == text_2: %timeit list_compare(text, text_2) gives 13.8 µs per loop %timeit string_compare(text, text_2) gives 181 ns per loop Now if text_3 is longer than text: %timeit list_compare(text, text_3) gives 12.8 µs per loop %timeit string_compare(text, text_3) gives 144 ns per loop That's pretty neat. Actually comparing stuff directly is way faster. I have no clue what's going on under the hood. Would be cool to know. 
ah, i understand. have gotten used to the term "adoption" in the context of switch to py3 everywhere :)
Used pyautogui and left web whatsap open in firefox. 
All of OP's points can be just by writing (good) tests. Don't wait for typos or human erros, expect them. Expect them like you expect jesus to come back #Django
It screws with the width of the page though. 
10,000 words isn't really big. What matters is how many different chunks of text you need to check uniqueness against, because you'd need to hold them all in RAM *at once*. So my guess would be the approach using fixed-length hashes stored in the database is probably the right one. Which hash? I don't think it really matters, you don't need it to be cryptographically secure, all you need is a low likelihood of collisions. MD5 should be Ok.
wow, that was fast
Hate it. Python 2.7 always in my heart and my working life
Thanks for sharing :)
Except my whole idea was to use my python skills to help with my latin knowledge! Oi. Edit: my worst hack was using my code to align Latin text with English translation so I could use it in class if I didn't have time to do it myself. There were always less than 15 of us in the classes at UT.
oh nice! looking forward to trying this out!
Next step: Write a kernel in python. 
"Well, bob left the company 4 years ago and nobody else has had time to look at it." We also don't have any extra time this year, so maybe next year we will look at upgrading. Or maybe the next.
I think that particular example with the short circuiting is what kills it, which is rough. Ah well, it was a decent thought experiment for a second there. 
Yeah, I moved off conda this year when I realized that wheels are now widespread enough that conda really isn't needed any more as a distribution mechanism for packages. It is still useful for installing different versions of Python, and environments, though.
&gt; The first would not be allowed to be committed. The second example (what you wrongly call "more pythonic" is appropriate when the product and discount come from a source outside of your control. You don't know what values they are, so you can't control the value of price, and need to raise an exception if it is out of bounds. Great! That is good code. But the first case, the one you would reject, is good too. It just applies in a different set of circumstances: you do control the product and discount, and know that they will always be within the right bounds to ensure the invariant `0 &lt;= price &lt;= product['price']`. This is a form of Design By Contract. It's not appropriate when the values are coming from outside of your control, but it absolutely is appropriate, and Pythonic, when your assertions are contracts. I said "you know that they will always be within the right bounds", but of course you don't *absolutely* know. If you did, you wouldn't need the assertion. But mistakes happen, bugs slip in, and the assertion warns you as close as possible to the source of the problem that you've introduced a bug. And if you run lots of tests and are pretty sure that there are no bugs, then you can run the application with assertions disabled in production. (I wish Python had better support for DBC -- it is a powerful technique for reducing bugs. But I'll take what I can get, and `assert` is a good start.) 
https://www.reddit.com/r/Python/comments/5oqahm/pythons_assert_statement_is_underappreciated/dcljalh/
Pytest... is that the test suite that lets you write tests like: assert Foo.method() == bar instead of unittest style `self.assertEqual(Foo.method(), bar)`? If so, how do you test that your application still works when run under `python -O`?
&gt; 10,000 words around 1000 up to 5000 pieces
Does Django 2.0 support easy serialization of it's ORM objects to JSON strings yet? 
They supported both for years, but at some point it has to stop. 1.11 is a LTS release so it will be some years before people finally have to switch. 
No cross-platform way that I know of pre-packaged as a library. Also, it's actually surprisingly difficult to tell what type a removable storage device is on some systems.
[removed]
The script is actually tied into a TKinter program that i have running on a Windows embedded system. It does not actually exit the program, it just stop "watching" for the files in the directory. I would have to click the button in the gui to start the script again. Im reading a couple of things, and the only things that are making sense to me so far are the memory allocation possibility (because I do assign a variable after each cycle), or some sort of network interruption that may have stopped the script. I'm trying to get logging set up to be more robust as well, so that these type of things do not happen in the future.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
NO.
That's a bigger question than you might realize!! The program does requirements analysis, FMECA, handbook reliability prediction, survival (Weibull) analysis, reliability growth test planning and assessment, software reliability analysis. It includes FRACA and DVP&amp;R modules (I call them "lite" versions) too. There's a lot it does.
It rewrites the assert statements in test directories http://doc.pytest.org/en/latest/faq.html#what-s-this-magic-with-pytest-historic-notes &gt; It also means, that you can use Python’s -O optimization without losing assertions in test modules.
[This](https://www.reddit.com/r/learnpython/comments/5ovu4k/bot_for_mmorpg_for_learning/) is pretty interesting since it's not for Runescape.
"Funkybomb" does not seem like a very accurate name :)
Pyusb may be what you are looking for if you approach it the other way around: "list all usb devices in use an filter which ones are storage devices". https://github.com/walac/pyusb/blob/master/docs/tutorial.rst
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Sure. Buy the bottleneck in any code that you'd use numba to accelerate is going to be the numerics. Once you've optimized that small portion of your code, there isn't likely much left that PyPy could help improve. So why not stick with tried-and-true CPython for that?
That is a dream come true when it comes to patches, thanks for all the effort.
They do not enable names on things, "force" is the right word. More powerful lambda syntax does not prevent things from being named, it just gives the programmer the option to not name them. So in a nutshell, in order to make the worst possible code less likely to be written, the language makes the best possible code impossible to write; that's a fair tradeoff when you're aiming for mediocrisy (a.k.a. "good enough", a.k.a. "getting shit done"), but when your goal is "as close to perfect as we can get before it gets silly", then this kind of shenanigans is not something I want to deal with. Oh, and on a side note, I don't even think the "one expression per lambda" rule is the real problem here; the real problem is that Python expressions themselves are somewhat crippled, that is, the expression sublanguage was not designed such that an entire program could be written as one expression, like you could in, say, Lisp. It can be done, with enough effort, but it's neither idiomatic, pretty, nor fun; just weird and uncomfortable.
Why not just run a shell command and analyze its output? Under Windows you'll have to install the [Windows Driver Kit](https://developer.microsoft.com/en-us/windows/hardware/windows-driver-kit) and run [devcon.exe](https://msdn.microsoft.com/windows/hardware/drivers/devtest/devcon).
I'm really not interested in working with the kind of colleagues who need to be restrained in order to not write lousy code. Especially not when it's at the expense of the more competent programmers on the team. If you can't understand a piece of code, then the solution is one of: - Write better code - Write better documentation - Study the relevant concepts and theory you're missing But not: - Use a language that doesn't have the expressive power to do that thing you don't understand, so that the programmer is forced to dumb it down for you.
It is perfectly possible to live without decorators and with statement, but the author misses the point of improving readability. Also, there nothing forcing him to use them.
* Eliminate `range()` Isn't that pretty much the case in Python 3 already?
They're asking for crazy ideas, not good ones.
You did it correctly. I imagine you want to convert that 8-byte value to a number, and you can use the `struct` module for that. If you have more questions like this it's better to post them on /r/learnpython. 
Just making a simple calculator (that i'm having issues coding) to get me started in python.
I just want to say thank you. I've watched a bunch of your youtube videos and have learned a ton. Thank you very much.
https://docs.djangoproject.com/en/1.10/topics/serialization/
This may be right because I know that it works on some urls but not others (on heroku, that is; all urls seem to work on flask). I'm not sure why you mean by the bogus user agent - is that something I can fix?
Try /r/learnpython Make sure to include what OS and version of python you are using, and what you want to change the window to. 
We are starting on a new smallish project and one of my colleagues is determined to use django as the framework, even though we're a microsoft shop first and foremost. Is there any benefits to django compared to the full microsoft stack, i.e. ASP.NET MVC/WebApi? I read the basic summary, but have no experience with Python to be able to evaluate the framework.
And the similar [yattag](https://github.com/leforestier/yattag).
I had to deal with this red/blue problem at work. We are using tornado due to some legacy reasons that I won't go into. We are not using it entirely correctly, but it works, too much stuff relies on it and it would be too much work to build everything again. Recently I had to use the built it websocket client, but from synchronous code, without knowing anything about coroutines. Holy crap was that difficult. Let's call this strange thing, got a Future object... what the hell is that? how do I get the connection out of it... what do you mean it's not created yet? OK, let's wait for it... deadlock. what do you mean it's not in a thread? Let's make a thread then... 2 io loops at once don't like each other? I have no idea what I'm doing... In the end I managed to get it onto the running ioloop and wait for the future to give me the connection. The code looks horrible, is probably wrong in all kinds of ways, but it works. And I still have no idea how to do this thing correctly. Oh and we're still stuck in 2.7 land...
Huh, interesting. I threw it into my code but didn't fix it :(
&gt; Uh, why is it better to link against the system Python libraries? You are pretty much asking why shared/dynamic libraries are a good idea. There are probably thousands of sources on this, so please google for all of the benefits. However, the primary ones in my mind today are security and compatibility (speed, memory usage, etc. being secondary on modern hardware). The first is security/updates. If you have a library that a bunch of other stuff uses (e.g. OpenSSL), and everything on your system links against that same exact, single copy, then you only have that one thing to keep track of, and only have to fix bugs in one place... better yet, someone (e.g. your distro maintainers) are already doing that for you! If that code is replicated in a bajillion places (statically or because every successive genius packaged their own copy of that library repeatedly), who knows. It's the reason why, when Heartbleed hit, some vendors were frantically shitting down both pant legs while others were like "it's all good fam, upstream patched that one last week". The other is compatibility/uniformity. With open source software, everyone *can* link against the same exact shared system library. If I link the code in my module against the copy of the headers/library in /usr while your module links against some similar, yet, different library in /home/Deto/anaconda/lib/whatever then shit can go bad really fast if the two ever try to interact using something defined in that "shared" library. Maybe it all works. Maybe it all fails outright. Maybe it sometimes works depending on the environment (e.g. library load order). Or maybe it only messes up in subtle, corner-case, hard-to-detect ways. Whenever I develop on a system with Anaconda, I have to be extra careful to link only to the libraries I actually intended to use (because it does drag alone its own copies of all the external dependencies needed). On windows the benefits of this maybe outweight the costs (in fact, I believe they do because I've personally used anaconda on windows). On linux and OSX there simply is no practical downside to just doing things right, IMHO.
- base all rational number types on `Fraction` - rename/alias `lambda` as `given` - rename official lib methods and classes to fit pep8 capitalization guidelines
That is already in your code. I copied it from your pastebin. You need a not fake agent.
You will need to recreate the virtual environments. Primarily because any binaries in the venv's site-packages are no longer compatible with the updated python shared library. As someone else pointed out, the major versions of python are not ABI compatible. There is no way around this (short of making your own PKGBUILD's of the the python modules you need and managing them through the distros package manager instead of pip). Then you *could* just use --system-site-packages and bump the version number in the PKGBUILD every time a new version of python is released. AFAIK this is how the arch package maintainers handle this. Once you've done this, you could presumably successfully do a python -m venv --upgrade on your virtualenv's. But again, all of that is much more tedious then just updating the virtual environments once every year or so, and probably not worth the effort unless it's a popular python package with a complicated build and you want to share it with others through AUR.
Awesome, thanks for being helpful!
Part of me remembers trying this but django couldn't serialized to json properly At some point I had to download that DjangoRestFramework packages just to do sane serialization in a past project (still didn't end up liking that one either) Everything else, django was aces. But trying to use it for a json API backend drove me to drink 
LPTHW was [removed from the sidebar](https://www.reddit.com/r/Python/comments/40s6dm/meta_can_we_take_learn_python_the_hard_way_off/) because it really has a lot of flaws. /r/learnpython has a [wiki](https://www.reddit.com/r/learnpython/wiki/index) with good resources. BTW, you should have asked in /r/learnpython not /r/python since this is the sub for news.
&gt; then you just don't use it This goes against the zen of python. There should be one obvious way to do things, and a locally-scoped def is already it. &gt; the absence of a syntactic option does not make it easier to write readable code Could you write readable code in C++17? Of course. Is most C++17 code anywhere near as readable as python? Not even close! One of the major advantages of python is that the core syntax is so simple that you have to actually try to make obtuse code. Almost anyone can open up almost any third-party library and start to make sense of it. If you start throwing the syntactical kitchen sink into the standard every time someone has a new "need" and simultaneously want to maintain backwards compatibility, you'll end up with a situation that looks a lot like C++17 in a few years.
Of a company can't spend a week to upgrade its critical infrastructure then it's in serious trouble. 
This totally makes sense. Literally all of you know more than me since im fairly new to this, so ill definitely take that advice. Do you have any book suggestions to start with? Im in an intro to computer science class that's stupid basic, so i could just make the best of my time by reading! 
Everything about this post hurt me in so many ways. 
I mean, the task description says that the list is not going to be empty, that there is an odd amount of elements, and that 1 always is on the list just once, that's why the error seems so strange to me
Oh right, I didn't account for that case, my bad. Thanks! Now it works: if v % 2 is not 0:
Don't use `is`. That checks for identity, not equality. It will work under CPython but only by accident, as it interns small integers. Use `!=`. And don't delete your thread. 
https://www.youtube.com/watch?v=DsUxuz_Rt8g
&gt;[**Chelsea Voss - Oneliner-izer: An Exercise in Constrained Coding - PyCon 2016 [28:49]**](http://youtu.be/DsUxuz_Rt8g) &gt;&gt;Speaker: Chelsea Voss &gt; [*^PyCon ^2016*](https://www.youtube.com/channel/UCwTD5zJbsQGJN75MwbykYNw) ^in ^People ^&amp; ^Blogs &gt;*^4,920 ^views ^since ^Jun ^2016* [^bot ^info](/r/youtubefactsbot/wiki/index)
What about beautifulsoup??
Yeah, brew was definitely sooner than arch. That's a typical release for arch. You can get stuff earlier by subbing to the testing channels, but for most people that's a bad idea.
A few reasons that I can think of: 1. Out of curiosity, to see how difficult it would be to do (less than I expected!). 2. PyPy has become my "daily driver" Python implementation because it's much quicker for my typical uses now - I often find myself writing code analysis tools to simplify/guide the work of compiler development, which are optimised quite well by PyPy, but Numba is not much help with. However, I felt it would be nice to have access to Numba without having to switch back to CPython. 3. What joshadel said - to get the best of both worlds. Supposing you do optimise the numerical portion of a code well using Numba: then, the non-numerical portion occupies a much larger fraction of the runtime, so reducing its runtime by running on PyPy has a larger impact (in terms of % reduction of runtime) than before it was optimised with Numba. 4. Stan Seibert has some ideas for more tightly coupling Numba and PyPy, which require Numba running on PyPy as a preliminary: https://groups.google.com/a/continuum.io/d/msg/numba-users/NJpha2duXTo/P4fU1P5QAAAJ 5. To end all "Numba or PyPy" debates, by allowing both to be used at once :-)
Thanks for the posts. One thing I'm not sure I understood, so one can have hdf5 (my case) installed through pip? I'm running the standard numpy/pandas along with blaze ecosystem with hdf5 and assumed conda was basically required to maintain sanity on windows. I would *really* like to switch off anaconda on my windows box as it, compared to pip, breaks some emacs virtual environment integration. Also I'm impatient to get python 3.6 and want some more recent versions of some libraries.
Well, for direct comparison, python iterates over the two strings, comparing each letter. If they are all the same, then the strings are the same. For splitting and comparing, python creates two list objects. Then it iterates over each string and when it gets to a space it creates a new smaller string and appends that to the list. Then it iterates over the two lists. For each pair of elements, it needs to figure out what function to use to compare them. Since they are both strings, it does a string comparison like I described above. So, the direct comparison traverses each string once. The split method traverses each string twice, once to find the spaces and a second time to do the comparisons. Plus, it has to build two lists, and for every space it has to create a new string and modify the list (appending), and it has to traverse each list. This is not the most accurate description, but it gets the point across. I'll bet the split is the most expensive part, because it does all of the object creation (which is somewhat expensive). Timing these things and thinking about them is a great way to learn what is going on under the hood. Keep it up!
&gt; what is needed to run Numba in a Python implementation? At the moment, the Python implementation needs to provide support for the CPython C API (and also emulate some of its internal state, or have Numba modified to remove the dependency on CPython internals, as I had to do to get it to run on PyPy). This is not a particularly easy thing to achieve - without the effort that has gone into making cpyext (PyPy's emulation of the CPython C API) work so well, the task of getting Numba to work on PyPy would have been much more onerous.
It was decided that it would be better to keep it separate so it can be updated and improved more frequently than Django itself.
With ZipHandler you have reimplemented the pkg_resources feature that packs data files into python egg or wheel files. Include the keyword `include_package_data` in your setup.py file and use the `from pkg_resources import resource_string` in your code to access the data files that will be zipped up into the wheel (or egg) file.
I know the TI-84 calculator has a function that turns fractions into decimals...but it's kind of a cop out: it the decimal gets too nasty, it stops trying and instead simply returns the decimal over some large power of 10...how boring. &amp;nbsp; So I tried writing one myself, to see if some more "interesting" fractions could be made...and I quickly found that the core mechanism for my program doesn't work... &amp;nbsp; print("F", end=/n) while True: print("U", end=/n)
If your program touches floats with a 10 foot pole, don't use equality, check for absolute difference less than some tiny value. Not all decimals can be represented exactly in binary, so you will occasionally see very small errors, which will trip up programs that expect floats to act like regular reals.
As other users have commented, most useful input here is going to come from looking at the code. It sounds like your current code is fairly imperative (loops, conditions); perhaps this would be better rolled into objects? Maybe with so many function around a more functional approach is appropriate? Hard to say without seeing the code or knowing the specific problem. Maybe you just need more judicious use of data structures like dictionaries, named tuples or dataframes? 
And your boss doesn't know your blog right?
How hard would it be to build the face recognition model with only a video, and no other sources? What approach would have to be taken to make this work?
Start a new Twitter meme, "Dicts out for Hettinger!"
I've always wondered why they don't store the reference count to an object separate from the object. You'd have to split up the current C structures and have one of the two pieces reference the other one. Normally I might think that the best thing for speed is for an object to point to its reference count, but the fact is that python increases reference counts all the time internally so it might be that going the other way is better (or they might just be the same). I see two main drawbacks. The first is that the accessing of objects would not introduce an extra reference hop (due to caching this might not be too terrible though). The second is that small objects might ballon in size significantly. Now you'd basically need to allocate a separate object for the reference count which could be significant especially for things like ints (though maybe having a pooled allocator devoted to these counts would make it not too bad). I definitely don't know how feasible this would be, but I've always been pretty curious about it. It seems like it would be a nice option for situations such as these where forking is required, but you still want cow.
It's a record... or a struct. "SimpleNamespace" carries on the Python tradition of taking something that has one or two obvious potential names... and giving it a completely oddball one instead, such as Python 3.6's "fold" attribute for datetime. Talk about "Although that way may not be obvious at first unless you're Dutch."....
Check out pyinotify. It should be able to do everything you want in a couple of lines. 
&gt; cross-plathorm 
I want SD-card devices, does it allow that?
It's not the violin; learning how to code at any age doesn't preclude you from any achievement or attaining any skill level. I've seen 10 year olds learn Python, and I've seen 80 year old emeritus professors learn it.
Why use train_test_split twice? X_train, X_test, y_train, y_test = train_test_split(images, labels, test_size=0.3, random_state=random.randint(0, 100)) X_valid, X_test, y_valid, y_test = train_test_split(images, labels, test_size=0.5, random_state=random.randint(0, 100)) There is an argument to define both train_size and test size.
https://docs.python.org/3.6/library/math.html#math.isclose
It would really suck if one day your boss came from the other direction...
I think it depends entirely on your approach to learning. If you block off an hour a day (and more on the weekends) where you can focus on learning Python with zero distractions, and you have a very structured and rigorous way of going through the material and find ways to apply what you're learning, I think it's safe to say you could become employable in under a year. The further you deviate from effective learning habits, the longer it will take. It's really all up to you.
I started learning Python on my 30's. My son is 7 and I've started teaching him Python this year. Now is the right time to learn Python!
How about with this service as a web app using django or flask?
My one objection would be that you can still use threads in Python. You can even use a join method to make them synchronize. Otherwise this is a fascinating article. Edit: also, a fork of the Python promise library will do everything above for you. It runs the code in a new thread and allows you to wait for it in a synchronous function. async_promises, if you were curious. 
this will look great in your portfolio. i suggest making it the primary focus
My guess would be Heroku disables outbound http connections per a security policy.
[scrapping](http://www.joc.com/sites/default/files/field_feature_image/maxresdefault_1-700x394.jpg) [scraping](http://www.quertime.com/wp-content/uploads/2016/05/best-web-scraping-services-tools.jpg) 
Inspired by some of the shenanigans going on at http://www.99-bottles-of-beer.net/.
Found the code as well: import pywinauto moz = pywinauto.Application().connect(title_re = ".*- Mozilla Firefox") wpp = moz.window_(title_re = ".*- Mozilla Firefox") wpp.TypeKeys('Test', with_spaces= True) wpp.TypeKeys('~')
Looks like it's pretty much the stdlib's HTTP server and a janky reimplementation of [pex](https://github.com/pantsbuild/pex) to bundle it into an "executable". So to answer your questions, I'd say "no" to security, and "yes" to standalone.
You should post to /r/learnpython There are some problems here. First is that your "list" isn't a list, it's a string. You are checking if a string is inside another string, not if a string is in a list of strings. So for example "om" exists within "Tom" but that's probably not what you want! A list is like: ["Tom", "Harry"] To put it in a label in a GUI you probably. Red to convert the Boolean to a string: bool(foo in bar)
Why grow emotionally attached to a *version* of a tool. I understand becoming fond of a tool (e.g. your hammer, or Python), but why some specific, obsolete version?
This tool packages all the HTML/CSS files in a single executable file, so that you don't need to have the files on the local filesystem. You can grab the generate 'zerve' file and send it over email to someone you want to show the site, for instance.
Correct me if I'm wrong, but `pkg_resources`is not part of the standard library (but of the `setuptools` package). My point was to realize a completely self-contained executable (requiring nothing but a plain vanilla Python installation). Beside this, my "re-implementation" amounts to three lines of code, so I'd rather include such lines that a dependency (to a quite large and complex package).
Local only at this time.
6
Just finished [httpwatcher](https://github.com/thanethomson/httpwatcher): a simple HTTP server for serving static files with live reload capabilities. Had to replace `livereload` in one of my other projects due to a variety of reasons, so I thought I'd roll my own (apart from unit tests, I needed a live reload server that could, out of the box, serve content from a non-root URL, e.g. http://localhost:8000/some-subpath/).
You can tell em anything at any day but you are just a ranty random internet person. Why is this now about node being better and sequiturs? Are you still arguing to me or are you just pushing your preferences for some personal reason or because I mentioned Node.js?
I like it, it put me in a good mood for programming.
Oh ok thx
It's harder because video is normally lower quality than still pictures (especially when talking consumer grade products). But it's not impossible especially if you have high quality video it just probably increases your chance of false positives.
/r/learnpython and at least post your error.
This. To get the best chance of help, you have to make it as easy as possible for others to help. Posting the commandline used to start the app along with the error is the minimum. For graphical programmes with obvious glitches a screenshot is always good, and sometimes capturing a quick video can be handy too. Sometimes the extra time and effort it takes to get good info for a bug report, can mean you fix the problem yourself which is the best outcome.
Thanks for the reply, Paste bin of error located [here](http://pastebin.com/3QxqfZqL) I'll start reading /r/learnpython now! Thanks.
Not any more; its public now and acts as prior art.
Just finished reading the book. Now it's time to apply the new knowledge to some datasets on Kaggle....
There are lot of interval tree implementations it looks like from googling. Have you tried them?
I did something similar, but very simple and less technical, a few years ago using YAWCAM, the open source cam software. Using motion detection to alert me of motion in a certain area...my boss was very tall, more than a foot taller than anyone in the office. I set YAWCAM to alert me when it detected motion in the hallway at a certain height....saved me more than once. 
Did you install the twilio module? pip install twilio
I'm glad someone got something positive out of this haha.
Hmm, but it works fine for some URLs, it seems :/
Will try and report back. Thanks!
You don't figure out what it is. You set it to whatever you want. Even with a valid, known Agent your request is still coming from Heroku. Their network is probably blacklisted out right in a lot of places to cut down on bot traffic. A better test would be to try other domains and to look at the actual errors returned as suggested by the other reply.
There is a 1 year grace period in the United States for disclosure by an inventor. See 35 USC 102. Happy to discuss more if you have questions.
Why not have two desktops. One with fun stuff one with programming stuff. Then just switch. So you can at least do work if he's behind you, rather than show an image. What if he asks what you're working on and the image is completely irrelevant to the project you're working on? Or he asks for a demo?
There are people that show up to day 1 of a Computer Science course in college having never programmed in their life, and still end up in a cushy engineering gig at Google or Facebook. There are people who have virtually no knowledge of programming whatsoever that fake their way past screening interviews for smaller data science or tech companies. I'm answering this way because your question doesn't have an answer. There is no "level" you need to be at, and there is no standard amount of "work" you need to put in. You're sort of asking us, "If I start learning how to use a hammer and saw today, will I be able to build my own house by the time I retire?" If **programming** is interesting to you (there's absolutely no reason to limit yourself to Python if you're generically interested in a career in programming), then learn about it. Do some tutorials online. Take an online course. If your High School offers a class, take that. Study for the AP Computer Science test. If it's still interesting and fun to you by the time you get to college, consider majoring in something where you'll get to do a lot of it (and really, almost any STEM field will require a lot of programming these days, not just CS, and may widely diversify your career opportunities). By the time you're actually on the market for a job, you either will or won't have a sufficient skill set for any given job. That's not a bad thing in the slightest - it means there's always going to be something new to learn, and if programming ends up being interesting to you, you're going to learn it anyway, right?
Any ideas?
the most surprising thing is that some library call gc.enable()
Former PHP dev, python dev now not looking back... PHP is still great for web development and still has an amazing platform and development workflow....BUT...just this... Python has a greater ecosystem for nearly everything apart 3D gaming. It's more or less a de facto language for scientific computing. It's great for command line tools mainly because of what I think is a great module packaging system. It's great for web development as well, many high quality frameworks. Also same algorithms in python tend to have more elegant solutions due to internal language features. What I kinda of miss in python is the feature set of symfony...but its fine :P
perhaps it should be as part of the if syntax instead of as an expression? `if &lt;expression&gt; [as &lt;identifier&gt;]:` upon encountering, expression is evaluated and stored as `&lt;identifier&gt;`, then the expression is checked for truthyness, and goes on as normal mainly for the sake of if match() as m: # a hypothetical match elif match() is not None: # a hypothetical empty match else: # the match result is None This also makes more sense considering python's leaky scoping imo. This won't allow things like "`func() == 4`, okay what about `sameresult == 5`" logic, but I don't believe Perl et al allow that either (without doing things a specific way to achieve it) 
Will here after an hour, for that moment expect to have at least 5 answers. Thanks a lot :* 
beautifulsoup uses lxml parser internally
Not being PHP is also high on the list...
&gt; Python promise library which one?
Here's (from my memory) a fun task I did when I was learning about neuroevolution: In a finite 2D grid world there is one agent, several food items, and several poison items. The agent can move around the world by turning to the left, turning to the right, or moving forward one cell. The agent will eat any food or poison it finds itself sharing a cell with. The agent can see the contents of the cell to the right, in front and to the left of itself. The task is to get the agent to move around the world to eat all the food while avoiding all the poison. The brain of this agent can be expressed as a neural network with 3 inputs (the cells it can see) and 3 outputs (decisions about how to move). You'll also probably want a bias neuron. The task can be solved by deciding on a NN topology yourself and just evolving the weights of the connections. If you want a more advanced challenge, you can try evolving the topology using [NEAT](https://github.com/CodeReclaimers/neat-python/).
If you want cross-platform native widgets, consider [wxPython](https://wxpython.org). It's even pip installable as of [wxPython Phoenix](https://wxpython.org/Phoenix/docs/html/index.html), with no extra dependencies. Licensing is also open (wxWidgets license) so there are no commercial restrictions. I have personally used it for my cross-platform open source project [dicompyler](http://www.dicompyler.com/), and found it to be quite easy to use, even with threading and non-blocking gui.
The CEO answers to the board of directors. If you want to impress him/her, it's going to need to recognize each of them. Everyone has a boss. If you're lucky, you only have one.
I copied and pasted your code in [repl.it](https://repl.it/languages/python3). There's a syntax error somewhere apparently, so it doesn't run at all. You should check it out.
My bad!
f-strings are [new in Python 3.6](https://docs.python.org/3.6/whatsnew/3.6.html#whatsnew36-pep498) , repl.it runs Python 3.5
https://codecombat.com/ You play a game with python. &gt; it doesn't explain much about the syntax itself. What do you want explained? Do you want to learn how to use a hammer on the physics behind how a hammer works? (The latter is a CS degree). &gt; im a hands on learner So figure out a project you want to do and do it googling for how to do something as you go.
there are many solutions - we use http://www.reportlab.com/ and it produces very beautiful PDF. There are also a handful of HTML to PDF libraries but pagination is never perfect.
You are probably right. But still… we are talking about three lines of (straightforward) code: why should one introduce a dependency?
Apart from that, Python is getting a lot of love in the info-sec industry. A lot of proof of concepts are written out in Python, a lot of tools are Python, vulnerability writeups often use Python to demo the vuln, etc. Python is pretty popular in sysadmin circles because it's included in a lot of distros by default and it's easier to manage than perl. Just wanted to add those two because they seem to be left out pretty often and people focus on science/web-dev.
Could you expand on what you like about symphony?
It's more amazing that python 3 is that old..
Geez. Those poor suckers on 1.5. Isn't it time they migrated?
Time for Python 4?
26
PIL (or pillow) will let you look at image pixels. With that finding red rectangle is simple.
I'm not sure that our entire practices are out-dated, as I said, the make command runs another command that reads from a larger ec2 config file which handles deployment/scaling, as well as a CI suite that can prevent the build if tests don't pass. As for the SMTP, i've been unclear, it's simply the API key to the service we use for sending mail, and the port specification, the rest is handled by django's mail module. The question I asked was less about deployment practices, and more about command line executors that might be better able to handle logic
I'd say that bunch of management commands may do better job than Makefiles, but that really is not a big issue. Running anything deployment-related from developers machine is asking for trouble.
Changelog: * Bytes objects now distinct from Bits objects * Strings encoded in Shift-JIS by default * Print is a keyword again ^^^just ^^^kidding ^^^i ^^^love ^^^python ^^^3
Ah the Winamp approach to versioning.
I don't have specific experience with this yet but [stitch](https://pystitch.github.io/) looks interesting
It will be maintained after 2020.
2011 still being 5 years ago. yeesh edit: 6. fuck.
I'm in the same boat! I checked those out, as well, and decide that json-path-rw looked the most promising, as it tried to use a known spec, and worked with simple data structures. I haven't used it extensively yet, though. I'm also concerned about the lack of activity.
Up to date stock info for **$GE** (General Electric Company Common): ----------------------------------------------------------------------------------------- **Price:** $30.62 **Open:** $30.76 **Change:** -0.59 (-1.89%) **Volume:** 36,824,436.00 **Mkt Cap:** 270.88B **Average (50 day):** 31.58 **Exchange:** NYQ ----------------------------------------------------------------------------------------- Don't abuse me, robots have feelings too! | [Source Code](https://github.com/Logicmn/Reddit-Stock-Bot) | [Report Bug](https://www.reddit.com/message/compose/?to=Pick-a-Stock) | [Suggest Feature](https://www.reddit.com/message/compose/?to=Pick-a-Stock)
&gt; Or one might simply say python is dynamically typed. Which is very common, but kind of useless, because Python (pre-type-annotation support) doesn't have types. Any variable and any argument can hold any value at any time; values are *tagged*, but the tag isn't a type, it's just a part of the value itself. Python calls them "types", which is a bit unfortunate, because, again, they do not behave like the "type" concept in information theory at all. In this light, it is better to think of Python as *unityped*, that is, as a language that has exactly one type, which is inhabited by all values. Anyway, yeah, "dynamically typed" is a popular name for this kind of type system. &gt; Obviously this isn't a 100% perfect metric In fact, it is a completely useless metric. Number of reserved words is only tangentially related to syntactic or semantic complexity. For example, Python uses only two reserved characters (parentheses) to express function calls, tuples, expression grouping, comprehensions, and class inheritance, that is, two reserved "words" to express five different things. Also note that of the languages *I* listed, only one (JavaScript) is worse than Python by this metric. However, if we compare Python's semantic building blocks to the JavaScript equivalents, it should be fairly clear that JavaScript covers with just functions, objects, properties, and variables a problem space that takes Python a lot more semantic concepts, including classes, modules, inheritance, decorators, context managers, generators, comprehensions, etc. etc. That doesn't make JavaScript necessarily *better*, just simpler (in fact, I think JavaScript is in many ways *too* simple). &gt; Javascript's callback hell is because they use (arbitrarily nested) anonymous functions as arguments as the preferred way for handling async issues. You're wrong. If you pull out those anonymous functions, bind them to variables to name them, and then nest them to implement asynchronous stuff, you're still in exactly the same hell. Naming things doesn't make this any better, not a bit. Callback Hell has two root causes: one, being forced into writing things that are conceptually sequential in a nested fashion; and two, the fact that the flavor of CPS favored in JavaScript has insufficient error handling capabilities. We want to say "send an ajax request to this URL here, read the result, call this function here on it, then send it in another ajax request to this other URL here, read the result, and display a message to the user informing them of the result". That is, "sendRequest; readResult; callFunction; sendOtherRequest; readResult; displayMessage". But instead we have to write "sendRequest(readResult(callFunction(sendOtherRequest(readResult(displayMessage)))))", or "sendRequest.then(readResult).then(callFunction).then(sendOtherRequest).then(readResult).then(displayMessage)", which is only marginally better. Either way, being forced to pull all the steps apart and name them individually does absolutely nothing to get us out of this mess. &gt; Unfortunately I'm not aware of a good comparison to something in python (since it doesn't really support channels which is what I think you're dealing with here?) There are no channels here, I'm just spawning a (green) thread and run an infinite loop in it. There's no async/await there, the runtime transparently handles that for us, using either cooperative concurrency (when using the single-threaded runtime) or dynamically dispatching green threads onto OS threads (when using the threaded runtime). Anyway, totally not the point. &gt; async def forever(*actions: List[FunctionType]): &gt; while True: &gt; await (x() for x in actions) &gt; forever(vacuum_sessions, partial(thread_delay, vacuum_delay)) That's cheating, and it's not really an equivalent. Haskell's `forever` takes exactly one argument, which can be *any* IO action. I can put any expression in there, as long as its type is `IO ()`, so I could, for example, write this: forever $ vacuumSessions &gt;&gt;= \numCleaned -&gt; if numCleaned == 0 then threadDelay vacuumDelay else return () Or even a full-blown `do` block, which is really just another expression: forever $ do numCleaned &lt;- vacuumSessions if numCleaned &gt; 0 then printf "Cleaned up %d sessions" numCleaned else threadDelay vacuumDelay Which your `forever` doesn't support, because it can only take a variable-arguments list of actions to execute sequentially and unconditionally. You could of course extend your `forever` function to replicate the interesting parts of Python's control flow syntax, but then you would in fact be implementing your own DSL. If you have to write `forever` as `def forever(action):`, then you need either a better lambda syntax, or a way to bundle multiple statements into a single expression, or a way to express anything you could possibly want to express as expressions, getting rid of statements entirely. In a way, you could say that Haskell does all three of these (by virtue of just not having statements in the first place), and Python does neither. It is actually possible to write an equivalent of the last example in Python, but it requires writing a little helper function: def bind(a, f): def bound(): return f(a(*inner_args), *outer_args) return bound def forever(a): while True: a() forever(bind(vacuum_sessions, lambda num_cleaned: print("Cleaned up {0} sessions".format(num_cleaned)) if num_cleaned &gt; 0 else thread_delay(vacuum_delay))) Actually, I think I'll revise my opinion; it can be done in Python just fine, it's just that it looks ugly and nobody does it because it's terribly unreadable. And if it were more readable, the whole statement business would be unnecessary, and we could just write our programs using plain old expressions.
If any of us are still alive...Holy crap that's only three years away.
In this specific case it might be because Python 3 is *still* barely edging out 2.
Man, divide those by 365. I don't wanna have to do math while reading! Hell... Make Python do the math!
&gt; still alive Afraid of what Trump is gonna do?
I have never read LPTHW nor do I know Python, but I've always been able to see from the name of the book the author must be some stuck up, smug bloke.
Good article. I've just starting using Python scripting in Blender to visualize simulations, and I love it!
The name of the book is honest, unlike most programming materials. His opinions on py2 vs py3 notwithstanding, he's helped me and countless others learn to program for free and he did it well.
Can you pastebin a sample (a few hundred lines maybe) from your file? I don't quite understand what you mean. You can almost certainly achieve this with a combination of filtering on the column, then melting or unstacking.
Python3 came out in 2008, but wasn't worth considering for anything serious until around python3.3 in 2012, and didn't *really* have any killer features until python3.5 in 2015.
Thanks...it seems someone else already wrote this program...
bits objects are actually ints, so that one's already true.
2.7 came out in 2011.
Thanks for the info. I would have assumed this would be a largely solved problem, and maybe it is since complex data objects haven't really had many changes over time (e.g. lists and dicts have existed forever), so it may not be much of a worry that there is not a lot of activity on these repo's. I guess I will keep searching/testing and see what else I find. 
Or 6 which is 2*3
`zipapp` the module is not, but Zipapp the file format has been supported since 2.6. It would be fairly easy to construct a Zipapp using `zipfile` and clean, reusable Python code instead of requiring Bash. 
Because of the implication
the point of having those concepts in haskell comes from the fact that categories kinda relate to typeclasses, and membership can be statically checked, so you can reason in terms of categories. Since python is duck typed, you don't need a library defining the concepts, they are just a way of thinking about relationships. 
Of course. I thought you were suggesting to use `zipapp`, not `zipfile` from your comment. Of course the `bash` requirement can (and should) be dropped — even considering Windows compatibility (at build time). When I'm in a hurry, I tend to use the easier (for me) route. But you are right… hope to have the time to follow your suggestion.
&gt; many high quality frameworks Currently I'm doing distributed systems and devops. I'm using flask and web2py. They are both amazing on what they were designed to offer. 
I haven't touched symfony for 1.5 year now but I used to love the developer tools(command line and the web debugger), the way configuration was working including the service container, the documentation and the community.
I wasn't aware of Shaw but I just [read his current reasons for not switching](https://learnpythonthehardway.org/book/nopython3.html) and they are so ridiculously asinine.
* Formatting is now done with the simple-to-use .format_my_string_please_and_use_these_tokens_as_the_arguments() function. * PEP8 line length recommendation now mandatory.
[Here's a post](https://www.reddit.com/r/Python/comments/5ep5fe/a_reasonable_rebuttal_to_zed_shaws_case_against/) from this sub from a month ago discussing a rebuttal to his article.
Is that clientId and Secret real, and can someone use it to impersonate you? You're not using praw to do anything you couldn't do by directly requesting json from Reddit; no authentication is needed to get top posts and URLs. What's the benefit of this dependency? Why are you using wget here? It looks like someone could construct a URL which matches the rules but which your application would execute, like `http://i.imgur.whatever.example.com/foo.png;scary command` Are you familiar with http://docs.python-requests.org/ ?
Or 8 which is 2^3
&gt; half Well, if they were coming out at a constant rate, that's exactly what you'd expect, isn't it? :P
Does twice as old translate to twice as stable?
Python2-specific code: * `print` statement * `reduce` (which now lives in the functools module, so you have to change that to `functools.reduce` or do `from functools import reduce`). * C-style division, which works based on the type of the operands. * Code that translates bytes-to-unicode-encodings or relies on strings being byte-arrays and not unicode strings. It's actually pretty weird for this to be the case, can happen though. Pretty much nothing else. Anecdotical info about the new divison: it works 2 to 4x faster (and you can get in Python 2 with `from __future__ import division` if for some reason python-land divisions have become the bottleneck in your code).
Mmmm... along this lines there were some Python Markdown implementations\*, or he could always make an .md file and render it to PDF with Pandoc (assuming he gets to install Pandoc). Just another $0.02. \* I was pretty sure some offered PDF output but I can't find it right now...
Pretty much that, and some stuff about bytes and strings and encoding shit. 
Or 9 which is 3^2, 3 being the base of python 9. 
This gets posted in every programming related subreddit weekly. 
Is [this](https://learnpythonthehardway.org/book/nopython3.html) what you read? That was a painful read.
Welcome to the real world, it happens all the time - any team &gt;4 you'll see it happen. It could be accidental, because of opinion, or just ignorance - but you will eventually be on a team that this happens. I hope you realize the "developer reign" won't last forever and, regardless, at some point, if you don't have something opinionated, any two excellent programmers may well disagree on a "best" practice.
there's `'string'.islower()`
Not only convert, but first learn all the minor differences.
And yet people still use 2.
It amazes me but there are a lot of valid reasons to stick with 2.7
:)
Oooh well la di da
Plenty of .Net 2.0 stuff out there still, or 3.5; note that 4.0 was shipped in 2009. Same for Java 6 and 7 -- hell, there are still loads of Java 4 apps out there. Companies are slow to move, that's always been the case.
Depends on what exactly you are trying to do. I'd highlight three main points: * Your custom parsing code is almost certainly more buggy than argparse (or click, docopt...). The more complex and mutable your command line is, the more of a problem this will be. Standard GNU-style command lines are pretty mutable. Argparse also takes care of making your help look sensible in the current terminal. As /u/cheesess says, there are a lot of little complexities to juggle here when you roll your own. * You don't have to use 'argparse all the way down'. For example, you can tell argparse that 'my subcommand X just receives a big blob of arguments'. and process those arguments in an individual way. But only if you really need to. * argparse is like a standard, recognized protocol. You can be pretty sure that someone can understand the structure of your commandline, by reading argparse-based code. For non-'standard' code, you'll need to make a concerted effort to reach the same standard of clarity. Argparse does offer a number of cool things (eg. the def parse_args(): -&gt; single-mutable-object-with-all-options pattern is humble but very helpful IMO). It's not the most agile (compare docopt, click), but it's complete, clear, and flexible. More than anything, it's simply solid and reliable, and that is why I would argue it is a good choice for most uses. 
Maybe this is a sufficiently computer-science-y problem that people use things like the visitor pattern to solve it, and don't publish something more general.
!stock TSLA
!stock TSLA EDIT: Huh, not sure why your comment didn't trigger a response.
Up to date stock info for **$TSLA** (Tesla Motors, Inc.): ----------------------------------------------------------------------------------------- **Price:** $244.41 **Open:** $245.46 **Change:** 0.65 (+0.27%) **Volume:** 3,022,982.00 **Mkt Cap:** 36.63B **Average (50 day):** 211.74 **Exchange:** NMS ----------------------------------------------------------------------------------------- Don't abuse me, robots have feelings too! | [Source Code](https://github.com/Logicmn/Reddit-Stock-Bot) | [Report Bug](https://www.reddit.com/message/compose/?to=Pick-a-Stock) | [Suggest Feature](https://www.reddit.com/message/compose/?to=Pick-a-Stock)
ooh I misread the intent. There's `str(i).isdigit()` or you could just `isinstance(i, int)`
I didn't even think of `isinstance`.. oops.
5 and 3 weeks... January 2011 was 6
Use mode 'wb' when opening a binary file for write
newfile = file("test.hex","wb")
Yep, we have a huge codebase of Python2.7 for some embedded networking equipment. Going to management and saying "it's old" as a reason to port it to 3 simply won't happen. 
⊕ ΔT
In my case it about SteamID's where u never search for only half the part of the sting... Do u think it would be possible?
&gt; I initially set up my virtualenv in the virtualenv/flaskenv folder. I was under the impression that when I want to use a virtualenv I would need to navigate to that folder and activate it (source flaskenv/bin/activate.fish), and then navigate to my flask projects folder in order to properly run them. If you ran the `activate` script *before* installing Flask and the others, they would have been installed inside the virtualenv's own `site-packages` directory, thereby not "polluting" the global one. That's what `virtualenv` is for.
At least it's old Python and not old javascript ; )
I think I understand that, I just don't know how to check to see if I installed them both inside and outside the virtualenv. 
This makes sense. Thanks.
run pip list (or pip freeze) then activate the virtualenv and repeat the command You can even do a diff (e.g. pip list &gt; 1.txt, activate the venv, pip list &gt; 2.txt and then diff 1.txt 2.txt)
Outside of a legacy codebase and/or a legacy system Python installation, there really aren't many valid reasons to stick with 2.7 these days. So really there's just two valid reasons.
FYI, one of my favorites is [begins](https://pypi.python.org/pypi/begins/0.9) for quick scripts. Argparse for anything more complicated 
To expand on that, the microscope program likely creates the box out of one color (i.e. r,g,b value). To find the top edge of the rectangle you want the *first row* with several consecutive *columns* of that color. To find the right edge of the rectangle you want the *last column* with several consecutive *rows* containing that color. etc. Once you have all the edges of the rectangle you can use the appropriate PIL function to cut that portion out. 
Thanks for sharing it! If you think it's already hugely awesome, you're going to be amazed with the rest of it! 
Wouldn't the better question be "are there any real advantages to py3 over py2 which justify investment/migrating old code?". A lot of people don't seem to understand that "because Guido and the PSF said so" isn't a concrete advantage, and others such as py3's Unicode handling aren't cut and dried, especially when they come at the cost of performance.
&gt; Shipping 2.6 for the base system is fine. No, it's not. 2.6 does not receive any support from core developers, no security fixes, nothing, it's EOL software. You are fully reliant on RedHat (or Apple...) and [the goodwill of library developers](https://alexgaynor.net/2015/mar/30/red-hat-open-source-community/). I believe 2.6 even has the broken SSLv3 protocol support enabled by default. I also use different versions and never touch the system python, but that's not the point: you are not supposed to ship old EOLed and insecure software. God, I'm *so* looking forward to 2020.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Ah, I could've been more clear. I knew it wasn't `SimpleHTTPServer`, but I was referring to the stdlib's `BaseHTTPServer`, which your code uses (also used by SimpleHTTPServer, as far as I know). I've got mixed feelings about `pex`. Most of that is negative experience with pants, which was used to build the pexes. That said, `pex` is more complete support for generating "executables" than I personally {could, would bother to} implement. As you've discovered, it takes some effort to code safely as a zipped module, but `pex` does Just Work™ with `pkg_resources`.
In the HBase world, I still have to code support for Java 7, even though that's been EOL by Oracle since 2015. At least even Python 2 still gets security updates!
Yeah, I think you just have to point to OS installatons of python2 for why so many people are still using python2. There will be a relatively tiny number of people with technical reasons preventing them from upgrading, but you have to remember most people will stick to "is python there? Is it already installed? That's the end of this conversation".
ptpython or pudb might do it for command line debugging. Web debugging I'd use a real debugger like pycharm has. Django has excellent documentation. 
You should still use a list of strings. Or maybe a set. For performance and for code clarity 
Or 1, which is 4^(0).
Click might suit better for that case, since it's [designed with composability in mind](http://click.pocoo.org/5/why/). I really have no example of a program that fits both the 'loads of subparsers' and 'uses argparse' criteria, but suspect that you would have to get tricky to get enough speed there, no matter what system you were using. Personally if I was designing such a program I would probably want to factor it in such a way that I could write the master dispatcher (analogous to 'git') in C, and the subcommands (analogous to 'git add|rm|gc.' etc) in Python. But this is really just based on my experience with Mercurial[1] being too slow to use :) [1] Mercurial has its own, fairly minimal, option parser. I haven't tested to see what is actually responsible for slow start here -- loading of extensions is another likely candidate.
argparse should be part of the standard library, so if portability is needed, I would use that. 
My flask project or python project. Flask prject --/ env --/ application --/ manage.py .env -- for autoenv to auto activate/run ./env/bin/activate. Now, I use ```python -m venv env``` to create virtual env in flask project floder. And use ```autoenv``` to run activate script. 
Sheesh, all those people not worshipping Dear Leader! Sinners! (that's what the sub feels like)
working on linear regression algorithms this week, like finding a best fit polyline for 3-5k pipeline points within a target corridor one snag I didnt expect was determining the endpoints for a random point set (start point unknown) when you look at the points as a person you just see the endpoints and the path immediately, but codifying that was challenging at first
When Python 2 was as old as Python 3 is now it has had a child version. Python 3, what are you doing with your life?
Try testing with a fresh Reddit account. It looks like it only works for you right now. EDIT: Maybe not.
Up to date stock info for **$AMZN** (Amazon.com, Inc.): ----------------------------------------------------------------------------------------- **Price:** $808.33 **Open:** $815.28 **Change:** -0.71 (-0.09%) **Volume:** 3,376,196.00 **Mkt Cap:** 384.09B **Average (50 day):** 775.70 **Exchange:** NMS ----------------------------------------------------------------------------------------- Don't abuse me, robots have feelings too! | [Source Code](https://github.com/Logicmn/Reddit-Stock-Bot) | [Report Bug](https://www.reddit.com/message/compose/?to=Pick-a-Stock) | [Suggest Feature](https://www.reddit.com/message/compose/?to=Pick-a-Stock)
What about scrapy 😂😂
There was IE 6 at one point. Not sure we can call that a "software platform" though
2.7 does; 2.6 doesn't- and it's *still* shipped by RedHat and Apple.
Pypy has a working 3.x version, AFAIK.
Use YouTube's API. It's built for cases like these.
For modest values of "working". They're working to bring it into sync with 3.5 and make it as fast and stable as PyPy for 2.7, but the PyPy team currently label it as an alpha release
Or 16 which is 2↑↑3 (2^2^2) Or 65536 which is 2↑↑↑3 (2↑↑(2↑↑2))
I just realized the names part could still be enforced with multiple line lambdas.
I have a hard time seeing how PyPy doesn't fall under either legacy codebase or a legacy system.
Despite what Zed Shaw keeps going on and on about, I can't help but think that bytes-based string implementations are a pretty goddamn terrible idea nowadays.
python 2 has the advantage that you can more easily write code that handles ASCII text interleaved with non-text bytes without *really* handling the format (i.e. just for peeking and searching a badly specified data slurry) but as soon as you need to find bugs or, yeah, really encode or decode text, python 3 is the uncontested champion among the two
That's awesome. Do you have a github or anything I can view it?
Because we subconsciously realize we're getting closer to death.
and still kicking ass.
I never knew that livestreamer is forked to other active project. Thanks for pointing that out. It should be compatible with current API.
Why not both with pandas?
He does talk down to the reader, a lot, though.
But then it wouldn't be backwards compatible with py3...
Moore's law??
python 2?
This guy gets it: "Disclaimer: Only do this if you hate yourself and the rest of the world."
To phrase it differently, then: Python 2.7 is 5 to 10 times faster than Python 3.
I feel your pain, I have to work with the crappy jython **2.2** that Oracle uses with Weblogic. But I expect it from Oracle, or IBM or SAP: they don't give a shit about developers and the community. RedHat should know better, though.
I think it all depends on what you're doing. Personally, I find that it is much easier for me to use basic SQL to get the data into python, then do my complex manipulations using pandas. These [two](https://blog.modeanalytics.com/learning-python-sql/) [articles](https://blog.modeanalytics.com/how-to-make-box-and-whisker-plot-sql/) have some nice comparison of SQL vs. Python and might be helpful.
I can actually see this being useful, we use json and yaml for config quite a bit, and usually keep default configs in the package. However, it's only a few lines of code to use pkg_resources, so not that big of a deal.
Jim's first law: "Any date-based math will end depressingly."
thanks very much, ill try my best and i just posted it on learnpython :D 
You definitely couldn't. None of it is novel, as for CV / ML tasks are concerned it's very straightforward.
&gt; Afraid of what Trump is gonna do? Not at all as [Childproof lock added to White House nuclear launch button](http://newsthump.com/2016/12/23/childproof-lock-added-to-white-house-nuclear-launch-button/). 
!stock BBY.L
Up to date stock info for **$BBY.L** (BALFOUR BEATTY PLC ORD 50P): ----------------------------------------------------------------------------------------- **Price:** $261.80 **Open:** $265.60 **Change:** -3.20 (-1.21%) **Volume:** 1,464,338.00 **Mkt Cap:** 1.78B **Average (50 day):** 269.55 **Exchange:** LSE ----------------------------------------------------------------------------------------- Don't abuse me, robots have feelings too! | [Source Code](https://github.com/Logicmn/Reddit-Stock-Bot) | [Report Bug](https://www.reddit.com/message/compose/?to=Pick-a-Stock) | [Suggest Feature](https://www.reddit.com/message/compose/?to=Pick-a-Stock)
Right, .L are LSE (London, UK) and are priced in pence, so the Price should read.. Price: 261.80p or perhaps.. Price (exchange_currency_unit_str): 261.80
I put all mine in ~/.virtualenvs with python3 -m venv
Make a new issue here https://github.com/mandeman/RIPeat9/issues/new
I had enough trouble convincing people to upgrade to Fortran 90...
Bokeh looks really great! Thanks! 
I do not get this.
As above, don't try and learn anything because you think it's a must. You will soon understand what problems you need to solve and what modules can help you solve them.
i'm literally waiting with bated breath.
I believe that's the same argument made for keeping Java 7 support — it's shipped with RHEL, so Red Hat have taken on the responsibility for providing security updates.
That's the same reason for sticking with COBOL, Visual Basic 6, C# 2.0, Java 6... any language version reaching a certain amount of popularity will produce huge swaths of technical debt that can become economically unfeasible to migrate with even minor changes. That's just how thing is, nothing to argue there. However, you cannot let this hold back progress. Java 8 is a big step forward. .Net 3+ adds a ton of functionality. VB6 was just *bad* in so many ways that couldn't be fixed. Similarly, Python 2 was broken in ways that couldn't be fixed without the changes that turned it into 3. You are free to keep your legacy codebases running, and Python core devs are free to tell you that the language has moved on and you are on your own - like all COBOL and VB6 programmers who are still out there. That's just how technology moves.
Make Python 2 Great Again!
Raymond Hettinger did a talk on this subject, and it's really on point. If you think this article is interesting or maybe hard to grok, try this: https://www.youtube.com/watch?v=EiOglTERPEo
Well, neat.
I'm testing it out and it's very neat but it doesn't have the full functionality of what I described in my plugin, so I'm going to give it a whirl. Seems like it is more suited to linking to resources outside of the project rather than between files within the project.
It's a text editor, not a full IDE. The things I look for in my editor to make every day easy is included: * Coloring / AutoFill / AutoDocs / Reference Finding * Built-in refactoring (for renaming items) * Terminal * Python Console * REST Interface * Venv and package management * Debugging with breakpoints * GIT integration * Web preview * DB Integration If I have to leave my editor for anything, it's a mark against it. PyCharm does most of those really well (no included web preview) so I have been using that for years. A fancy text editor, like Atom, Notepad++ or VI just doesn't cut it for enterprise level code IMO. 
The author is fully aware of this and even mentions it early in the readme: &gt; This abomination allows you to write... The first time he posted it here he mentioned it was just a proof of concept.
Open command prompt as an administrator and type: pip install "library name"
A similar idea (i.e. more 'pythonish*' JSON traversal): https://github.com/skorokithakis/jsane \* Yes, pythonish, not pythonic
&gt;i really like it, but it doesnt seem as popular on the web as other ides/editors... Because of its performance. Atom is eye-candy with some really nifty features, however its memory footprint is insane and it can become unstable very quickly. I wouldn't recommend it for anything very big. Id suggest PyCharm for the reasons /u/cantremembermypasswd stated.
Alright, but how do I determine that? The placeholders are the improper URLs and that is what I have been doing. I just don't know how to determine that.
please format your code so it's readable. also, what problem are you having?
It's a matter of preference. But if you're not using PyCharm/IntelliJ then your preference is wrong.
 BEDMAS applies to a single mathematical equation or expression. Here you have two mathematically separate expressions. 2.34 + 1.24 is an expression, that will be evaluated and passed as the first argument. abs(5-10) is a completely unrelated expression, which will be evaluated completely independently. BODMAS doesn't come into play here. If you like, think of it as (2.34 +1.24), (abs(5-10)). But the comma already does that separation, because it divides the expressions. 
abs is a function call and for any function to be called, its arguments (in this case 5-10) needs to be computed first then passed to the function (so all abs sees is -5).
I can see that but I think that the urllib.parse is the best option. I am already cutting down the time with multithreading so I think I can allow some time to go past me. I can easily split the list up in 2 or three and multithread those as well. Who knows. Thanks, though. I'll definitely be using urllib.parse now and later.
What I meant by saying doing abs (5-10) is exactly as you said. So IRL, 5- 10 first, then abs (-5). so to confirm, you are saying python will do 2.34 + 1.24 first, and then 5-10, then abs (-5)? 
Define "stuck". I just ran it and it loops forever. Best guess is that you want to remove the "else:" so the calculation and display code gets run every time round the loop.
First of all, BEDMAS doesn't apply to programming. It's not some universal truth, it is one convention for mathematical notation. But a programming language can have an entirely different set of conventions. Usually, they tend to mirror those used in mathematics to some degree, but it does not have to be exact. And programming languages have many more operators to deal with. If you want to know the order that an expression is evaluated, always look at [the table of operator precedence in the documentation](https://docs.python.org/3/reference/expressions.html#operator-precedence). Again, there is no universal truth here. One language could have division with higher precedence than addition, while another could have it with lower precedence. Also, the same symbol can mean different things in different contexts, and therefor have different precedence. The parentheses in your example are the function call operator, not the grouping parentheses, which have higher precedence. And you must evaluate the arguments to a function before calling it, by definition. 
Yeah, I re-read and realised that - see my edit. What you have is some_function(arg1, arg2, arg3, ... argn) Each argument is (generally) totally independent and will be evaluated independently. Because they are unrelated, a multiplication in one argument has no effect on any other, so you don't need BODMAS across arguments. Where the arguments are more complex math, you'll need bodmas to evaluate the argument. But the comma between arguments is the ultimate set of brackets. It says "this argument is entirely standalone". 
Yeah, it's a shame. LPTHW is the best book on learning python. But it's hard to even tell people to just ignore the one part about not using python 2, since the book itself warns you from people like you :( I mean, as a vim user I'm happy that he warns people to use Vim or emacs too, but that's a different thing.
Exactly this, delete the "else:" statement and fix the identation
I just don't understand why you call this an abuse of forking mechanics. On any system which provides copy on write optimizations, you want to try to acquire as many read only resources as possible prior to forking. Python's memory management can sabotage this, but with slight modifications in coding style, you can take advantage of them once more. If this is abuse or hacking than I'd call sequential data access abuse and hacking since it's just taking advantage of some (most) processors' optimizations of sequential data access. You're just intelligently taking advantage of your system. And yeah I did move to using threads and not forking when I went to using C++. The overall program is more than just mathematical computations and so cython never really made sense (I tried it). There is easily enough complexity that having a completely usable C++ library (which is then wrapped to expose it to Python) made much more sense than anything else.
I just started adding code to github recently, I have the interactive (human) version up there currently that uses pygame for display and user events will be adding code there throughout the year https://github.com/enderprime 
Maybe, in the spirit of open source, you should submit a pull against that plugin. 
I mean, software written by pretty much everyone had this bug... It's only reasonable that Microsoft would find this out first. 
Hey, I use luigi for next generation sequencing pipelines, but I'm having a bit of trouble understanding your dilemma. I think you're asking how to run the pipeline on many inputs in parallel? If so, a luigi.WrapperTask that yields each run of your pipeline for each instance is probably what you're looking for. If instead you're having trouble creating pipelines with tasks that generate more than one output dynamically and then aggregate those outputs in a following step, there are a few patterns, but that's trickier to explain. I'd first take a look at posts on "dynamic requires". I hope that helps!
Your timing couldn't be better. I was just tasked with moving our company forms online to simplify storage into the cms and making them more print and email friendly. Flask being my first choice, but I haven't even looked into where I was starting. This seems like it might fit the bill perfectly as a base. Thanks for sharing! 
&gt; Each argument is (generally) totally independent and will be evaluated independently. Because they are unrelated, a multiplication in one argument has no effect on any other, so you don't need BODMAS across arguments. This is not strictly true. The left to right thing is important in case you had outer_func(inner1(arg), arg2, inner2(arg3)) Where `inner1` and `inner2` both have side effects that modify some shared external state. Then `inner1` is evaluated first.
This is good. I was thinking of throwing a slug of code that had all the "stuff" I needed assembled to build a SaaS front-end over the wall, and this is 80%+ of that, and done more nicely. +1!
What does 5000 pieces mean? 5000 strings?
&gt; First of all, BEDMAS doesn't apply to programming. Yes it does, but how do you evaluate `|-5|`? The answer is 5 regardless of whether you're using Python `abs(-5)` or doing it by hand. PEMDAS or BEDMAS or whatever you call it doesn't consider that. It's too simple, but when it applies, it's followed.
[Floating Point Numbers - Computerphile](https://www.youtube.com/watch?v=PZRI1IfStY0) https://docs.python.org/3/tutorial/floatingpoint.html /r/learnpython is for questions.
This belongs in /r/learnpython.
So in a program suppose I have added two variables containing 1.1 and 2.2 and I wanted to compare to the third variable which has a value of 3.3. Now how do I check for equality in python
Numbers are usually stored as floats. You should read up on them, but basically, they are a binary representation for numbers which sacrifice exact precision for greater efficiency at storing a huge dynamic range. When you type 1.1, python may store 1.0999999997 or something. If you absolutely need the precision, use Decimal('1.1'). This is not an issue related to python; every common language uses float mathematics.
As someone finishing their own flask blog with a public section and a registerd user private section I almost wish I didn't just look through this code :/ Various things I could have done differently. That said this is really instructive and clear! I'm at the 90% done mark on my site, must resist urge to redo some of it like my registration/user update tokens lest I never actually launch it. Great contribution!
Thanks, I appreciate it. 
python has a lot of power to add to analyses. the regex capability alone is a strong point for python. the fact that python is a fully featured is another strong point, e.g. if you need to parse some data that's on a website instead of in a database, there are multiple tools to get that data into python. python also has several graphics libraries for making beautiful graphs of data. i haven't done too much reshaping of data in sql aside from doing a pivot once or twice, so i can't say how much better python is there, but i know it does have powerful reshaping abilities. on the other hand, sql is amazing for joins. i don't believe pandas will let you join on functions, or do joins like 'on a.whatever &lt; b.whatever' (although you could obviously filter it afterwards), and they're ridiculously optimized in all the major engines.
&gt; why you call this an abuse of forking mechanics Because it is using forking where the best solution is threads. &gt; which is then wrapped to expose it to Python Cython is often the most convenient way to do the wrapping (and many libraries do that) and smaller optimizations (compiled functions that are not relevant to some larger library).
[removed]
Kivy seems to be the only way. I am not sure I understand your post since I don't see the diversity you are talking about. I actually would love having too many options. 
Your welcome and no payment required, donate it a charity if you want?
Man, you are doing it wrong. 
Then python will be a great addition to your toolbelt. Django will help your imagination as it has many different approaches to common problems. Yes it's an mvc web framework with active record like orm but the ideas matter most. 
`setup.py` line 28: keywords='please don\'t use this library for anything', 
Post questions in /r/learnpython. Also, post the full error message. Also, why are you running stuff with `python_d.exe`, and why is it installed in `C:\da python`?
Any more info before checking it out? With who?
 with open('testHTMLcodeForBStestCase2.html') as html: soup = BeautifulSoup(html, "html.parser") video_ids = soup.find_all(attrs={"data-video-id": True}) You now have a list of video ids: for id in video_ids: print(id['data-video-id'])
Two little corrections: * Conda will also downgrade and potentially break previously installed packages where necessary when you update. This problem can be solved by using a separate conda env for things with problematic dependencies. * `pip install` ignores the contents of requirements.txt, it gets the dependencies directly from setup.py.
&gt; much more performant Oh, with such unspecified performance differences who can possibly say no. I've always hated "performant".
No recompiling should be necessary. Just make sure that the youtube-dl module you have installed is up to date. How you do that depends on how you installed it. If with pip, use pip's upgrade mechanism. If with your distro's package manager, use its own upgrade mechanism. If, as the readme says, with youtube-dl's own instructions, use its own built-in upgrade mechanism.
Is CKEditor any better than TinyMCE? Haven't tried CKE so wondering how good it is.
Although, hopefully people doing technical/engineering work know enough to divide numbers properly.
I don't know whether to laugh or cry.
Oh, thanks. I didn't think this really posted.. it came with an error, if I posted the same thing like 20 times.. sorry lol
Thank you 
[removed]
You are welcome.
I was adamant at blocking this decision, but now I feel Django could be fun to try out. Thanks for your input.
https://repl.it/FQaa/7 you can do something like this
https://www.futurelearn.com/courses/learn-to-code data analysis using pandas module, not a bad course for beginners
Is it the same as or similar to reddit tldr bot?
No setup.py? Try starting with the Python Packaging Authority sample project. https://github.com/pypa/sampleproject Other than that, good job. I've done a similar thing for our internal teams at work.
Prompt the user to input an answer then use an if statement to check what their response was and execute the code from there. Something along these lines yesNo = input('Want to play the game [yes/no] ') if yesNo == 'yes': .....start game code goes here elif yesNo == 'no': print('See you next time!') else: print('Please choose either yes or no')
A few things to note here: * assigning a value to `_` simply creates a variable with the name `_`, it doesn't actually ignore the value * two leading underscores uses name mangling for a very specific reason, it allows a class to protect against subclasses overriding that name. The point isn't to make it private, but rather to allow a class to use a value that is specific to the class it was defined in. * I find its use as an alias for gettext problematic, due to its common use as a throw away variable, it's easy to overwrite. We use `_t` internally, since it's still short, has the mnemonic of "t for translate", and is far less likely to have conflicts.
https://redd.it/5o4o1n Repost
Thank you
Well, if your only issue is the integer division: python2 &gt;&gt;&gt; 2970.0 / 365.0 8.136986301369863 That's before you get into the floating point representation issues, so we come back to knowing enough to divide numbers properly if you're building a bridge.
&gt; assigning a value to `_` simply creates a variable with the name `_`, it doesn't actually ignore the value Correct. It's conventionally used to ignore that way but doesn't have any specific semantics as it has in e.g. Erlang or Haskell or Rust. FWIW Ruby uses `_` the same way Python does (including the REPL assignment). &gt; two leading underscores uses name mangling for a very specific reason, it allows a class to protect against subclasses overriding that name. The point isn't to make it private, but rather to allow a class to use a value that is specific to the class it was defined in. More specifically name mangling is used to mitigate risks of unintentional collisions/conflicts between a class (crafted for inheritance) and its subclasses.
I think you're moving the goalposts here. &gt; Integer divides make Python2 a non-starter for any technical / engineering work ___ &gt; And how would you have done that before \_\_future\_\_ import division? ___ &gt; You have to account for who is using a tool when designing it.
Ok, you have a good day now
Using openpyxl with decent success so far. Mostly just checking cell content and applying sql statements to a textfile based on cell content.
The proxy dictionary is keyed by the scheme of `url`. That means if your url begins with `https://`, then you won't use the proxy. Try changing your proxy dictionary to: proxyDict = { "http": http_proxy, "https": http_proxy, } 
I know there were many changes, but as far as I'm aware the only one which was so fundamental I couldn't be done with out breaking compatibility was Unicode.
There is a lot in the third party channels, but the default conda channels are actually quite limited. Because anyone can a make a channel and add what ever they please with what ever title, i prefer pypi over random third party channels (I do use channels that are tied to certain projects, but these are not random). For the niche stuff, i halfway agree, except i install it using: pip install git+ssh://....... The really neat thing, Conda will pick these up correctly when I need to duplicate an environment or create an environment requirements file
Some of the handful ones I'm able to recall are: * The _ name refers to the result of the last executed statement in an interactive interpreter session. * It can let you replace the counter variable in a loop. x = 10 for _ in range(x): print _ * It is often used as an alias for the function doing internationalization and localization. * A single underscore before a name symbolizes it as a private variable. Though, it’s merely a convention. * Using two underscore side by side and prefixing them in front of a method name makes Python mangle it to avoid name clashes.
Thanks so much! I finally figured that out last night about 3 AM, but you are 100% correct. That was the issue. I was using a url that was https and a proxy set with http. I didn't know proxy in the request was tied to the url.
What about civ v?
If you mean the article, I didn't write it ...
TL;DR: Python isn't restrictive so if you're a bad programmer you'll be able to write bad code.
Yeah I use double-underscore most of the time, to avoid the gettext problem.
Amazon has an API for getting product info and someone has probably made a python module for it already https://affiliate-program.amazon.com/gp/advertising/api/detail/main.html https://docs.aws.amazon.com/AWSECommerceService/latest/DG/CHAP_ApiReference.html https://python-amazon-product-api.readthedocs.io/en/latest/
I'm not familiar with the Scrapy library; I was just suggesting a possibly easier way to solve the problem. 
I am not familiar with the bot you are talking about. Can you provide more info please?
Lol. Suggests C++ for large applications. 
Well I am completely new to programming, so it is interesting to me, making a program and like 90% of it working is a great deal for me.
I never had a problem writing really bad C++ code.
I used pip to update, and it said the update was successful, but I still receive the same "update needed" error message from before. Maybe the software isn't pointing to the new version of YouTube-DL? I wonder what other info I can give you. 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Listened to the whole thing, worth it
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Any notable fixes regarding twitch streaming?
The creator of the Pythonista app has a template on github for running python2 apps on ios. https://github.com/omz/PythonistaAppTemplate I've used it to run my python projects on an iphone6. If you want a ui he has wrapped uikit in python within the pythonista app. Pretty cool stuff. Pythonista 3 by omz:software https://appsto.re/us/XxRUab.i
'for line in f' is introduced without explanation on the page. I would not recommend this for that reason. 
Double underscore is a private variable, and it gets name mangled. Single underscore signifies an implementation detail that users should not rely on.
Although I think the article is pretty bad, I'm not sure why your tl;dr is being downvoted.
Use Flask. Don't go into any complicated stuff, just learn how to create some webpages based on jinja templates. If your users only need to view information and it does not change often, consider making a static html website. Flask has a Frozen Flask extension for that. Also, check out [this tutorial](https://nicolas.perriault.net/code/2012/dead-easy-yet-powerful-static-website-generator-with-flask/).
&gt; 1. For storing the value of last expression in interpreter. I love this one. Did not know about it. FYI, it works in Jupyter notebooks as well.
If you didn't use pip to install youtube-dl to begin with then you most likely have multiple versions floating around now. How does your software detect a version change?
&gt;1000 minutes what does that mean? minutes of monitoring for speech? minutes of me actually speaking?
Thanks. as for the minutes per month -- what is it monitoring for, just the speech input? my goal is to have my application always at the ready, like for "ok google" or "hey siri".
Right, I forgot about magic numbers! Letting the user configure those variables through argument parsing is a good thing, thanks for the suggestion! And by explaining rate limits do you mean in the code, blog post, or both?
the author is clearly not a great programmer, e.g. I love the "my program crashes after running for an hour because of typos" and "I installed a ton of libraries and now my computer is a mess" I think the article should be titled "why I should show my code to other people" edit: also be hilarious to see their github account 
Yeah, speech input. You could use an offline library for the initial detection, and train it well to your keyword, then switch to Google's API after. Just a thought!
It looks like you're trying to run a C++ program. Adjust accordingly.
I'll look for it and let you know. Thanks for the help so far
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
You need to tell whatever utility you're using the create the executable to include the json module in the zip file. These tools can't always detect the complete set of used modules, because sometimes modules are loaded dynamically. You have to guide them. 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
that's a really good idea! thanks 
So you could probably double the speed on most things and it'd still be able to parse.
I miss being able to ignore several values in a tuple in Python the same way you can do in Haskell. For example, for _, _, x, _ in thing: print(x) Isn't valid Python, and you end up having to use `__` and `___` as variable names.
&gt; for _, _, x, _ in thing: Actually, that is perfectly cromulent Python. Works just like you think it would (`_` ends up containing the last item of `thing` on each iteration). There is no requirement that each of the variables used to unpack a tuple have a unique name.
Yeah, definitely thinking about it. Main issue is looking through the source code &amp; I can't exactly pinpoint where they're parsing out the content of the page. I haven't even figured out how they determine where links are supposed to point to… it's not anywhere in the source itself that I can determine. It must be in content in the plugin that isn't included in the repo…
Are you using 2.x or 3.x? New to Python myself, but I think I can help out you with that one. In Python 3.x (maybe also in 2.x, not sure) you can compare if a letter is "&gt;" or "&lt;" than another just as you do with numbers. The syntax is the same for both. Good news is it also works with words! If you try that it will return True or False. Example: print("a" &lt; "b") Returns: True It is as if the letter is further in to alphabet, the greater its value. Same thing happens to words. So to code your lines you'll have to add the ifs and prints to make it work nicely. Now the second one is even easier. print("a" in "random") Returns: True Again, code in the ifs and prints as you wish. Hope that helps!
You can use ARG instruction in Dockerfile to make environment variable(s) exist only in build-time. Can't confirm for now if pip accept username/password through environment.
It seems to me one thing to consider is that there can't already be 4 in a row before this move (or else this move wouldn't have happened). So you only have to check if this one move got 4 in a row.
Why post it here ? Are you trying to make us feel jealous ?
sorry but i don't see how's that helping... what do you mean? i know the arguments must be a tuple, but.. i only have one argument, the issue is that is an array..
&gt; If you use a private docker repo, you could bundle it into a base that's shared. I have something like this - shared python library is in the "base" docker image re-used by projects. Now one of images requires a long build, so it gets annoying when I want to change a small thing in the shared library. 
What book is it? What is the exact question? Dictionaries should be treated as unordered unless you are specifically using an OrderedDict (dicts are ordered in Python 3.6 onward, I think, but don't rely on it). So, I don't exactly know what you mean by if one word appears earlier.
Do I understand this right that this is to help to speed up things and automatically find/activate venvs? I don't use virtual environments because I found it simply too long to create folders, active them and so on. I don't know the commands (yet) so... Well, beginner here. Would this tool go around this?
I haven't watched the video yet, but you're right, I just skipped the whole part of the concept, I just jumped in without really understand what I'm doing. As you and some other users suggested, I'll be going with flask. Thank you. 
not unusual, just short: for x in range(1,101):print('Fizz'*(x%3==0)+'Buzz'*(x%5==0)or x)
This may or may not be of any value, but I think it's worth throwing out there: http://www.dataschool.io/talkpython/ Talk Python To Me (https://talkpython.fm/) is an awesome podcast that hosts a variety of python developers, each sharing a unique story behind his/her implementation of Python in their fields of study. I highly recommend it!
It's pip+virtualenv+??? wrapper #437
Similarly `list(map(lambda x: 'Fizz'*(x % 3 == 0) + 'Buzz'*(x % 5 == 0) or x, range(1, 100))) `
It's better than that. - It automatically creates the virtualenvenv in your project. - It automatically install dependancies inside the closest virtualenv. No need to activate if you don't want to bother. - It automatically save installed dependancies in a config files. - It generates a lock file so that you also have a list of dependancies with hard versions. It's basically pip + virtualenv + an alternativ to one of the virtualenvwrapper + pipfreeze . In one simple automated command. It's great.
or a cleaner list comprehension: [(x%3==0)*'Fizz' + (x%5==0)*'Buzz' or x for x in range(1, 101)]
Any thoughts on supporting pyenv instead of just venv?
Yeah we'd definitely be open to looking at PRs from the community 
We really need something like this. Add "test" that runs tox or pytest and it's getting close to being something similar to leiningen. Then it's just the problem of making all projects use it so we can rely on a standard for all/most projects. Probably needs a better name though :P
There's a surprising amount of JavaScript in your examples considering "pure Python" in the title :(
Requests and beautiful soup are some really nice, widely used libraries for this sort of thing.
Came up with a simple solution: https://gist.github.com/ojii/97cca8835771f00b4fc27395990edb9d Uses Python 3.6. Run `python fizzbuzz.py generator 12345` and `python fizzbuzz.py fizzbuzzer 54321`, then use `python fizzbuzz.py client localhost:12345 localhost:54321 100`. Of course you can use different ports for and hosts, use `--help` for more info.
This is really great
For you it's not. It's justs one less thing to learn for beginers. With pipenv you don't have to think about the virtualenv. You just pipenv stuff and it works. You don't need to create the env, activate it or remember you have one. It's really just about lowering the barrier of entry to your project. Of course, the fact it save the installed package in the Pipfile automatically and generate the lock file for you is a bonus. Another bonus is that it's a Kenneth's project. So you can be sure in 2 months it will be very improved.
What do you mean by stream? Show two webcams in two windows? If it is that you can use this code from [the docs](http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_gui/py_video_display/py_video_display.html): import numpy as np import cv2 cap = cv2.VideoCapture(0) while(True): # Capture frame-by-frame ret, frame = cap.read() # Our operations on the frame come here gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # Display the resulting frame cv2.imshow('frame',gray) if cv2.waitKey(1) &amp; 0xFF == ord('q'): break # When everything done, release the capture cap.release() cv2.destroyAllWindows() To note that that 0 in VideoCapture is the index of the webcam, if you have two you might have two indexs available (0 and 1). You can do this twice and get your both webcams to display.
/r/learnpython
Yours, but without dependency fb = list(range(0, 101)) fb[::3] = ['Fizz']*len(fb[::3]) fb[::5] = ['Buzz']*len(fb[::5]) fb[::15] = ['FizzBuzz']*len(fb[::15]) print(*fb[1:], sep='\n') 
Seems like this would be what I want, thanks. I'll get bck to you once I actually try it out. I tried many methdods I don't even know what all. print(soup.findAll ('tr', {'class' : 'data-video-id'}, limit=None)) here is one that I tried that produced an empty list.
Why call the file Pipfile.lock when it's not a lock file?
Working on creating a pest forecast system using meteorological model output. Of course using all python for the post processing. 
Ah right - well yeah that's because the `class` is not `data-video-id` on the `tr` tags.
The mixing is a side effect of making the example short and self contained for the purpose of the blog post... Even the template code is inside a Python string itself to avoid shifting too much the focus on the web framework. It's pretty obvious that in a real project there would be a specific separation of concerns. The post aims at showcasing how WebAssets can replace WebPack and DukPy can replace NodeJS. Not to showcase best practices on how to structure your application code.
Solve the problem for a single row. In other words, write a function which can tell you if [0, 1, 1, 1, 1, 2, 2, 2] has a row of 4 or not. Then write a function that can give you the list of numbers in a column and diagonal, and use your checking function on each of those lists
https://github.com/JellyWX/SpaceInvaders Mini pygame project WIP
Why 3 is hacky ? The docker image is meant to run production services, right ? So anything in the image should be be pre-buillt already, rather than being pulled from some remote location - this should be done in build step, not deploy.
What is a lock file?
I actually just went through this same page yesterday on my arch linux setup, youCompleteMe was a bitch and a half to get working, but I think it is all good now 
Mind sharing?
https://en.wikipedia.org/wiki/File_locking#Lock_files
Yep. PHP's [Composer also follows this model](https://getcomposer.org/doc/01-basic-usage.md#composer-lock-the-lock-file).
 for i in range(1, 101): print(("FizzBuzz", ("Buzz", ("Fizz", i)[not not(i%3)])[not not(i%5)])[not not(i%15)])
works for me on linux
As another poster said, this is better for /r/learnpython but, to the best of my knowledge (which is limited), what you're thinking of is importing modules. In some compiled languages, you link the library so that a program can call functions from that library. That is what imports do. It gives you access to the functions and classes (and variables, etc) in that library.
This looks cool, but I'm curious about what would make me want to use this instead of, say, pandas.
If you insist: https://gist.github.com/bastibe/c0950e463ffdfdfada7adf149ae77c6f I use the fish shell. But the code is simple enough that you can probably whip up the equivalent code for your favorite shell.
Thanks.
In my experience, when debugging, it is often necessary to read the code your dependencies. That's easier if they're saved in the same folder, although I suppose you could still open the files wherever they're stored.
This is a rather different tool than those, no?
Why not combine the best of both worlds? Postgres let's you use python to write your own SQL functions and triggers. It supports even more procedual languages, you can find more informations about it if you search for `PL/Python`, it supports py2 and py3. Otherwise pandas and sqlalchemy is also a good combination. Create a connection to your sql database with sqlalchemy (postgres, mysql, sqlite,... is supported) and load the selected data into the dataframe, it is good to preselect and the heavy stuff can happend in the dataframe. The main advantage is that you can do everything more programatically, like only select columns that end with 'Date' or match with a special regex and so, something you can't do with normal sql. For example, you have a table with 100 columns and you want to have an overview about each column with pandas you can do something like this: for column in df.columns: print(column) print(df[column].max()) print(df[column].min()) print(len(df[column].unique())) In SQL you need to select every column by hand and perform the functions on it. Just as toy example. 
Right now I'm using virtualenv-wrapper, so this seems like a good replacement for that.
And I'm asking what the differences are, there is no direct comparison so that's why I'm asking. You cannot expect me to switch in a snap.
Thank you very much this is exactly what I needed to know. I appreciate it
Can you create tables with customizable bullets, spacing, and spacers through pd? 
If Python isn't compiled what does the built-in [compile](https://docs.python.org/3/library/functions.html#compile) function do?
&gt; Downgrading can happen e.g. if you update everything and then install a new package which does not support the newest numpy version yet Sure, if packages don't pin their dependency requirements, this can happen. But if a certain version of a dependency is required for an installed package *and that version is specified in its requirements*, then conda will halt installation rather than break those dependencies. From [conda's documentation](http://conda.pydata.org/docs/commands/conda-install.html): &gt; conda - conda install &gt; &gt; ... &gt; &gt; This command accepts a list of package specifications (e.g, bitarray=0.8) and installs a set of packages consistent with those specifications and compatible with the underlying environment. If full compatibility cannot be assured, an error is reported and the environment is not changed. To my knowledge, pip has no such feature.
Magical Ponies is a derogatory term. I'm a unicorn and damn proud of it
It's the capital letters. You convert the input to lowercase, so it will never match something with capital letters in it. Try this: 'Science Fiction' : ['sci-fi &amp; fantasy'], Also your check could be a lot cleaner: if equiv_genre in fb_genre.lower(): If you have more questions like this it's better to post them on /r/learnpython 
Just write a wrapper around pipenv+pyenv, and you'll be ready for next month's python-devtools-wrapper-of-the-month :)
Is this something a Windows user that's new to Python should attempt to install/use? 
that was the original name :)
[WAV files](https://en.wikipedia.org/wiki/WAV) store the data into "chunks". Metadata is also stored in chunks, but with a different chunk type. The [scipy.io.wavfile.read() source](https://github.com/scipy/scipy/blob/v0.18.1/scipy/io/wavfile.py#L180-L275) reads the file chunk-by-chunk. Only a few chunk types are handled ("data" and "fmt ") and others are skipped. And still others are unknown by the code, which is why that warning hits at line 266. The warning is probably safe to ignore, but it's probably worth knowing what chunk type exactly is so unknown to scipy. You could use [pdb](https://docs.python.org/3/library/pdb.html) or similar to set a breakpoint in the `wavfile.read()` code where the warning is raised and then print the chunk type. It's possible you have an exotic (or corrupt) WAV file.
Being part of the standard library does not mean that `json` is not a module. Look under `Lib` and you'll see lots of modules that are part of the standard library, including a `json` directory that contains the files for the `json` module. Those files need to be added to the zip file. 
Are you new to programming in general? If your goal is just to learn Python (especially as a first language), I might not bother with this, and maybe instead try to set up an IDE like Pycharm. I would definitely recommend learning Vim just for the sake of the sake of learning Vim, but it might be a distraction if you're only trying to get a foothold in Python for now. 
Vim makes a lot of sense for someone who spends a lot of time using the terminal anyway. I use tmux and vim on linux, and it's a great combination. But on Windows, that's less of an advantage. There are other good editors and IDEs available for Windows that are probably much easier to install and configure.
Cool man! Have fun, and my advice is keep it simple as much as you can when starting out. You'll know when you need to the more advanced stuff with web-app development.
Well. Having old, unchanging packages is entirely the point of using a LTS distro like CentOS. If there's a security fix, they backport it themselves (that kind of support is what they get paid for!). RHEL 6 was released in 2010. Providing newer versions as SCL is a perfect solution. What do you expect them do do? They cannot upgrade the base system since they have to guarantee API/ABI compatibility. RHEL 7 has Python 2.7.5. 
Ok, I'll be that guy. Why use this instead of Jupyter?
Yeah, `pipfile`'s github page says: &gt; WARNING: This project is under active design and development. Nothing is set in stone at this point of time. So far I'm enjoying `pip-tools` and a few shortcuts: alias i="ipython" alias i2="ipython2" alias spip="sudo pip" alias spip2="sudo pip2" envin () { touch requirements.txt requirements.in [[ -d ./venv ]] || python -m venv venv . ./venv/bin/activate pip install -U pip-tools pip-sync || pip install -r requirements.txt } envin2 () { touch requirements.txt requirements.in [[ -d ./venv2 ]] || virtualenv2 venv2 . ./venv2/bin/activate pip install -U pip-tools pip-sync || pip install -r requirements.txt } pimp () { pip install -U pip ipython plumbum requests pip-tools structlog } envout () { deactivate } freeze () { pip freeze | egrep -i "$@" &gt;&gt; requirements.in nano requirements.in } 
Are there plugins yet to 1. determine if all used functions and vars exist / are imported 2. Have project wide name refactoring Those are the biggest reasons the others on my team were asked to stop using it due to constant issues easily caught with an IDE. If there are good options to fix that you guys know of I'd like to give them their prefered editor back. 
no terminal colors are produced when a TTY isn't present. 
Handles the unicode spec fine, every other language that uses ~~UTF-8~~ Unicode will do this too. Since they *are* individual ~~UTF-8~~ Unicode characters.
This looks a lot more like: "Dealing with unicode the way you do with ASCII is still kind of a pain". There are a lot of problems unicode addressed when it came to things like representing languges with a huge set of diacritics or a large collection of runes/symbols or whatever, but all that came at the cost of the simplicity of 1 byte = 1 character and all characters aren't really context sensitive. The inherent complexity of languages makes answering a question like: "How long is this string?" more involved, and if you need to answer questions like that you just have to hunker down and read up on all the unicode terms like codepoint vs. glyph.
I think it's better to use standard \_\_init\_\_ in tutorial examples, or at least explain what attrs.s is and what it's doing
I used PyCharm briefly a year or so back. At the minute, I'm using Atom. Is there something extra good for Python in PyCharm that I'm missing? 
Yes, functions are different... if you don't need an argument, you wouldn't pass it in to begin with, and if you do need it, you need an unambiguous name for it.
The library is often working as its developer intended but not as you expected. 
atom is an editor? not compareable at all
I think beaker is a reference to the science part of data science
Great blog post!. Always great to see more people playing around with automata, and this makes it extremely accessible to people new to python to start up messing around with these simple yet complex beasts. If others want to play round with other rules here's a quick function to generate other rules just from the number without needing to write them all out: def make_rule(num): return {key:value for key, value in zip((bin(8 + n)[3:] for n in range(8)), reversed(bin(2**8+num)[3:]))} So rather than writing out the rule you just set rule= make_rule(30). There's all sorts of fun random stuff you can do just by changing up rules and initial conditions and making fancy ways to visualise their evolution. 
Questions like this are more suited to /r/learnpython. Make sure you [format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) or use a site like pastebin. Your code is hard to read and test otherwise. However, the problem here is that you forgot the 'self.' in front of the variable name. It should be if self.entrance == 1:
get this politics shit out of here
He installs SimpylFold... That plugin slows vim to a crawl if your Python file is just a few thousand lines.
Probably an edge case, but would it be worthwhile supporting specifying the location of the python executable you'd like to use for your virtualenv? Maybe something like `pipenv --bin 3.6`? Currently I'm using pyenv in my dev environment, so to get around this I've just been symlinking `ln -s ~/.pyenv/versions/&lt;venv&gt; .venv`.
Tons of code inspection done for you, type checking and the like 
Emacs is good at everything but writing code :)
I'm sure it wouldn't be too complicated to make plugins that do that, but at that point, why not just use an IDE?
Fair point.
Paging /u/spot who I believe is one of the Beaker Notebook devs...
I strongly suggest you don't use PyGUI. It hasn't had an update since 2011. I guess I'm impressed though. They still support Python 2.3. At that point, we should bring back the FoxToolkit. It's at least listed on the Python GUI page, unlike PyGUI. Seriously though, don't use it or Fox. The only GUIs you should use are found here and even then... https://docs.python.org/2/faq/gui.html
/r/learnpython can Also, what's your actual question? I think those statements are fairly straightforward.
I don't see why I'd use this over PyCharm. For less money, I can purchase an industry leading IDE that supports robust remote development. 
I was inspired to write [a script](https://gist.github.com/zyocum/fae359eb9803f0b26abedae8c4fbf0cd) to generate all possible rules and print out the first 30 generations for each. There are some [Sierpinski triangles](https://en.wikipedia.org/wiki/Sierpinski_triangle) in there: rule #73: {'000': '0', '001': '1', '010': '0', '011': '0', '100': '1', '101': '0', '110': '0', '111': '0'} 000000000000000000000000000000000000000010000000000000000000000000000000000000000 000000000000000000000000000000000000000101000000000000000000000000000000000000000 000000000000000000000000000000000000001000100000000000000000000000000000000000000 000000000000000000000000000000000000010101010000000000000000000000000000000000000 000000000000000000000000000000000000100000001000000000000000000000000000000000000 000000000000000000000000000000000001010000010100000000000000000000000000000000000 000000000000000000000000000000000010001000100010000000000000000000000000000000000 000000000000000000000000000000000101010101010101000000000000000000000000000000000 000000000000000000000000000000001000000000000000100000000000000000000000000000000 000000000000000000000000000000010100000000000001010000000000000000000000000000000 000000000000000000000000000000100010000000000010001000000000000000000000000000000 000000000000000000000000000001010101000000000101010100000000000000000000000000000 000000000000000000000000000010000000100000001000000010000000000000000000000000000 000000000000000000000000000101000001010000010100000101000000000000000000000000000 000000000000000000000000001000100010001000100010001000100000000000000000000000000 000000000000000000000000010101010101010101010101010101010000000000000000000000000 000000000000000000000000100000000000000000000000000000001000000000000000000000000 000000000000000000000001010000000000000000000000000000010100000000000000000000000 000000000000000000000010001000000000000000000000000000100010000000000000000000000 000000000000000000000101010100000000000000000000000001010101000000000000000000000 000000000000000000001000000010000000000000000000000010000000100000000000000000000 000000000000000000010100000101000000000000000000000101000001010000000000000000000 000000000000000000100010001000100000000000000000001000100010001000000000000000000 000000000000000001010101010101010000000000000000010101010101010100000000000000000 000000000000000010000000000000001000000000000000100000000000000010000000000000000 000000000000000101000000000000010100000000000001010000000000000101000000000000000 000000000000001000100000000000100010000000000010001000000000001000100000000000000 000000000000010101010000000001010101000000000101010100000000010101010000000000000 000000000000100000001000000010000000100000001000000010000000100000001000000000000 000000000001010000010100000101000001010000010100000101000001010000010100000000000
Why are your Python modules thousands of lines? O_o
Chicago (the city, not suburbs). 
syntastic and jedi-vim will give you a lot of functionality in terms of Python integration with Vim. I use pytest plugins to run flake8 and pylint as a part of the units tests as well.
"And Jesus said, 'Truly I tell you, unless you change and become like little children, you will never enter the kingdom of heaven.'"
1) [python-mode](https://github.com/python-mode/python-mode) 2) sed 
Was listening to a podcast about python 2 vs 3 and a core developer made the point that if you depend on an open source project and you're not contributing, either monetarily or with developer hours, you're taking a very big risk that the project will not go in the direction that you need it to.
I will pass python-mode along, thanks!
Look into `autoenv`, which is a tool that does that generally.
Very simple indeed.
Okay, given i have Python installed as well as all the necessary files of *Shreddit* taken from Github, all i need to do is run the "pip install -U shreddit" command in IDLE?
Shortest! $ pip install pyfizzbuzz $ fizzbuzz 100
The return value is a generator. It's an infinite stream. You can iterate over it as many times as you want and it'll always give you another value. It's like an infinite series. And since the recursion is happening within the yield statement it's not limited by the stack size.
Where would get this kind of data?
Upon further review. I can see the shell script is in fact attempting to run. However, it looks like it is only issuing the first of the shell commands and then exiting? Still works fine when i run as a direct executable from the terminal... any reason why python would exit too early or not allow the script to finish?
Python is not daunting, but programming in general can, especially in the learning phase. Think programming as just a very specific way of giving orders to your faithful servant. You need to be precise, you need to be unambiguous. There are many books for a good understanding on programming with Python language. My favorite one is - Learning Python the hard way. Don't worry stick with us (programming community), and get the ball rolling. And yes, welcome to programming! 
Updating the reply as I've actually tested stuff out, and it took me some time to figure out what was actually happening. You seem to have hit some special circumstance which confuses things. So, in the DataType constructor you have a loop for an array of objects defined by the embeds property. The first clause in the if-case checks for the embeds endpoint attribute. Now, in the records property on the Game class you initialise a list of LeaderBoards based on data returned. These LeaderBoards have the Player class as an embed. *The Player class does not set the endpoint attribute.* This causes an AttributeError to be thrown. Now, under normal circumstances you'd simply get that Exception and you'd figure out the problem in a second. But, the part that threw me off was that the @property decorator seems to catch AttributeError and in turn calls \_\_getattr__ on the class. As you haven't yet assigned data['records'] it will in turn throw AttributeError again, but not really for the correct reason. I can understand why @property does this, but it gets really weird in circumstances like this. :) To fix things you could either add a hasattr check for 'endpoint', or catch the AttributeError exception on the if-clause.
I use vdebug. https://github.com/joonty/vdebug/blob/master/README.md
Emacs, "a great operating system, lacking only a decent editor"
cool, stared.
http://www.raspberrypi-spy.co.uk/wp-content/uploads/2014/07/Raspberry-Pi-GPIO-Layout-Model-B-Plus.png
Thx mate 
Thank you. 
tried, awesome.
Yeah Idle is pretty good to get started with. Once you've started writing more than a couple classes get PyCharm. It's free and it's really good to develop python in. Start off with even less than that. Just do movement, inventory and agents ( Users, Monsters, NPC, ect...)
&gt; The following code will successfully print the days and then the months It's a bit nasty to take this quiz on a phone. I didn't realize the line break on this question was in the source and not a soft line break in the display. Many of the questions are more "gotcha"-style than really testing your knowledge of Python too. 
How are you configuring Celery? I'd look into [worker_prefetch_multiplier](http://docs.celeryproject.org/en/latest/userguide/configuration.html#worker-prefetch-multiplier), [worker_max_tasks_per_child](http://docs.celeryproject.org/en/latest/userguide/configuration.html#worker-max-tasks-per-child) Also, can you be sure that the first task never hits the queue? I'd suggest adding the [rabbitmq management plugin](https://www.rabbitmq.com/management.html) and monitoring the queue. Finally, with your tasks, you can set [signals](http://docs.celeryproject.org/en/latest/userguide/signals.html) to write to log files at various points of a task cycle (pre-run, post-run, success, failure, revoked, etc) 
&gt; The following code will successfully print the days and then the months Thanks for your comment, we will remove this kind of questions
&gt; (even in UTF-32) The encoding has nothing to do with this, by the way. UTF-8/UTF-16/UTF-32 is just a way of writing down a series of numbers in a space efficient way. Unicode is the standard that assigns unique code points to specific characters. 
Well said!
Where did you see this and can you provide a URL? I'm not sure if I've ever heard the term used with Python.
Great job, especially on the documentation part. One thing though, when you try, catch the right exception. If you don't know which exception it would raise, test a little bit more. :3
I'm rolling my own crypto! Now, it's just a toy project idea I had for making a sort of eBook version of a book cipher. The main idea is to randomly split a given text into "pages" to coordinize the text and thus encode/decode a given message. The randomization creates enough of a combinatorial explosion in the possible coordinizations that it shouldn't be possible to brute force an encrypted message. Turns out that it's brutally simple to do this in Python; I wrote the first version of the program while waiting for a guy to repair the boiler in my house: https://github.com/gunnihinn/cyber
Not sure what's the issue here, but as an alternative you can configure celery to use a redis instance as the broker. In my experience, it's very easy to setup and harder to get wrong compared to rabbitmq setup, although it has less features (which you probably don't use for this project). Or, you can use [ZeroMQ](http://zeromq.org/) to build a simple queue server to replace your rabbitmq/celery queue system. The python binding is actually pretty nice, and combined with the built-in python Queues class, you can whip up a simple queue system pretty quick.
Because sometimes they need to be, and there is no sense in splitting them into more files just because? A quick view from the standard library (py3.4): * argparse.py: 2375 lines * datetime.py: 2136 lines * decimal.py: 6406 lines * difflib.py: 2039 lines * doctest.py: 2793 lines * inspect.py: 2755 lines * ipaddress.py: 2183 lines * mailbox.py: 2136 lines * pydoc.py: 2618 lines 
Can you specify total number of questions? I got tired after 50. Also, questions with string slice are pretty annoying, I was putting some random answers just because I was too lazy to count characters in a string.
I'm sorry the author had a bad experience, but the entire thing sounds a little spastic. Lots of giving up the minute he/she hit an issue, and very little information about how certain tools _didn't_ work. The statement about 2to3 not doing _anything_ sounds especially fishy. Also, the first page of a verbose "porting python 2 code to python 3" Google query turns up oodles of guides and blog posts. Were none useful? There might be an argument to be made about hosting one on Python.org, however.
I superliked Vim but sadly, it didn't match at all. 
I am using amqp as the backend aswell as the broker, but as this is only starting a task and not need to return any information I probably dont need to do this. However I have just got redis working so I am going to see if I get the same issues with this Many Thanks for your help
I thought you were a Labradoodle?
Cheers!
Thanks for liking the project. I knew about the try/catch issue, but python is making me lazy programmer, since it takes care of all the extra things. I was just lazy to test for right error exception, since it did not interfered with the working of the programme. But I will keep that in mind and will try testing more; since it is not good programming habit to not catch exception in a proper way. 
It makes development easier. If you catch just the one type of error, then something unexpected breaks inside of your try statement, you get that exception bubbling up and telling you what's wrong, instead of being suppressed by your catch-all.
I was going to add a README tonight (tried from my iPhone, but not easy). It is an application similar to PTC's Windchill Quality or the Reliasoft line of products. The Reliability ToolKit (RTK) currently has modules for requirements elicitation and analysis, functional decomposition and analysis, hardware reliability predictions using various methods, hazards analysis, FMECA, reliability growth planning and assessment, survival data (a.k.a. Weibull or warranty) analysis. It also includes a mini DVP&amp;R and mini FRACA.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Why have a different file for 3 variables set in the dates.py?
continuing work on [PAWS](https://github.com/xevrem/paws) streamlining things. Fixing things here and there while also using PAWS as the foundation in my cryptographic messenging experiment [CSDM](https://github.com/xevrem/csdm). Its a total mess concept atm, but the old ZMQ framework "works" and the PAWS rewrite is coming along well so far. May use PAWS to write a simple from scratch REST key-value store for fun, but we'll see....
Clean Code could be a good choice. https://www.amazon.com.br/Clean-Code-Handbook-Software-Craftsmanship-ebook/dp/B001GSTOAM/ref=tmm_kin_swatch_0?_encoding=UTF8&amp;qid=&amp;sr=
Looks nice. Django debug toolbar isn't as nice I think and isn't built in. 
From PEP-440: &gt; The "Major.Minor.Patch" (described in this PEP as "major.minor.micro") aspects of semantic versioning (clauses 1-9 in the 2.0.0-rc-1 specification) are fully compatible with the version scheme defined in this PEP, and abiding by these aspects is encouraged.
Ah, I misunderstood what you meant. I fully agree with you, was a bad move. I totally understand *why* they did not ship 2.7, but I don't like it.
Four major ways, but according to OP only three of them should be used ... no love for % formatting, then?
I accept that it makes development easier. But during development of the project, I observed that there are pieces of code which are not high priority code of the programme. It means, they are part of the programme, but not essential parts. For example, in this application user can fetch posters and metadata from anywhere on the internet using qtwebengine, if something happens in this piece of code and app crashes, then it will be unnecessary headache for user. In such cases, I felt that application should not crash and create nuisance for the user, because of some unknown exception raised in that piece of code which is not essential part of the programme. Hence, whenever such design problems came into the project, I decided to catch-all exception and print such exceptions on terminal, since I debug mainly using terminal. While printing such errors, normally I print line number along with it, if it's severity is of moderate level, to have idea about where exception occured so that I can quickly navigate to that line. I think instead of printing to terminal, logging them to the file would have been much better idea. And I found this approach much more suitable for the project, even though it feels somewhat unconventional. I think trying to catch every kind of error, depends on severity of the code for the application, and should be applied on case by case basis. But at the same time, I accept that sometimes I was just lazy not to catch the error, since I knew what kind of exception it will raise. Such laziness I'll certainly try to avoid.
I'm not talking about linting. I'm talking about type checking by reading docstrings, and there's tons of code inspection as well that pylint and flake doesn't give you, and I'm nearly positive you couldn't get in a plugin 
Cool, sounds valid to me.
Why do you say that?
oh, what a quick reply! Thanks for the compliment. It's good to have nice little discussion.
Now does "pip" normally come with the Python download- as an integrated feature-, or am i supposed to manuely install "pip" myself? Thanks again for your responses.
You ever wonder why we're so goddamn fluffy? It's magic
Some semblance of error checking, and helping engineers read code they're unfamiliar with. In general i'm a huge fan of static typing, and so are other engineers on the team. I've not ever used typing in python tho, so I don't know if it fully gets us there.
I don't use typing, since it looks ugly.
...creating a new Django based site for monitoring hosts and network devices. Will be using Celery for the first time so it should be fun. 
https://www.python.org/dev/peps/pep-0484/#rationale-and-goals I don't think you will get much in the way of error checking with out doing the heavy lifting yourself if I am reading that correctly. I could see it bringing added context. Often I just tackle that though by making sure parameter and return types are documented in comments, variable name consistency (like naming something books for a list of books and book for the single instance which could just be a dictionary), and very liberal uses of the debugger and break points (see pudb for a console based debugger that kicks ass). Maybe Python isn't the right tool if the majority of the team prefers static types? I have never used it either, I don't see myself needing it though either. IMO if you can't easily figure out what type a variable is supposed to be in a Python method, the code isn't well documented, organized, and or utilizing PEP 8. Just my opinion though, I am sure there are plenty of other valid ways of approaching the situation. 
* send notifications via mail, twitter, whatsapp, sms, ... * read and write XML, JSON and other common file formats * work with LDAP
I find that I'm using %-formatting a lot due to muscle memory. So I definitely don't want it to feel *not* loved... On the other hand there's a note in the Python docs that calls %-formatting deprecated. Therefore the more future proof choice is to go with f-strings or `str.format`. I hope that explains my reasoning a little better. Thanks for your comment. I'll probably update the article with a little note.
Hey Steven, thanks for sharing your thoughts. Good point calling out the distinction between f-strings and the other string formatting options. I found them very enjoyable to work with. But if backwards compat is important then they're not going to fly. Just curious, are you worried at all about %-formatting being technically flagged as "deprecated"?
I am sorry but.... wtf is this? The repo is close to empty.
&gt;I don't mean to be rude, but have you used python with a team and in a large application? I don't think you are being rude, you are trying to gain additional context for my comments and perspective right? define large and team lol I mostly work on projects by myself due to lack of additional labor, were not a development company were a research institution so my work is tangent to the main goals of the company. Support staff if you will. Sometimes my boss may help, or Ill force a DBA to help me debug a query but hardly do I get the privileged of actually sharing a workload on a project. I do however volunteer for the local Code for America chapter where at least I get to work with one or two people on a single code base. So I see what you are getting at and asking, because I do have much less XP working in groups/teams of developers. That said, I often have to also take projects over from our consultants, or pick up code bases I have not touched in over a year so everything looks "brand new" to me (I try to write code assuming the next time I read it I will have fully forgotten about it and how it works) and ill often spend more time in the "discovery" phase than the "implementation phase." I also have to deal with some language switches since our consultants insist on doing everything in either Groovy or Java, and I am a "full stack dev" so javascript gets thrown in there often. &gt;Everything you said works, but is really hard to enforce as the application and/or team grows. I'd make the same decisions as you if I was developing a library, or if I wrote the entire thing from scratch and knew most of it. Which is often what I am personally doing so that's cool to hear someone else would do it similar to me (yay validation from random internet strangers!) IDK if any of that was helpful or just a tangent ramblings from my pre lunch break mind. 
Selling drugs with Django! 
I've used it heavily in a single project to try it out. Stopped doing it halfway through as it really didn't add anything, and as it was a late add-on to the Python language it feels jenky to use. I haven't seen any good leassons learned from an entire team switching to it. Please let us know, if you do use it, how it works out!
Cute writeup. I had a similar problem trying to make a scrolled frame for tkinter that behaved like an actual widget (could be used as a child or master). [I used something similar to pass a command to the inner or outer frame](https://github.com/novel-yet-trivial/XMLEdit/blob/master/XMLEdit.pyw#L133]). 
The target group would be primarily Reliability Engineers. Safety Engineers, Quality Engineers, and Systems Engineers (the old fashioned kind, not the IT kind) would be a secondary target groups at the moment.
Primarily hardware reliability for some of the modules, but DVP&amp;R, FRACA, requirements, and some other functionality isn't hardware specific. FYI.... FRACA = Failure reporting, Analysis, and corrective action DVP&amp;R = design verification planning &amp; reporting Ideally, there'd be a couple of REs that were great programmers and wanted to help. It's just that the size of the project has grown beyond my ability to deal with alone. I'm not a hacker, when it comes to programming I'm a hack (like a MD is a hack). I suspect someone who knew what they were doing could get my 80k LOC down to 3 or 4 LOC ;)
I'm using typing with Python3 and along with the enforce library to enforce the types. It's working well in most cases. It makes the function definitions a bit more verbose, but you get accustomed to it quickly, and it doesn't feel like a big issue in most cases. 
I feel like comments for the sake of having comments are bad practice, especially in a language as concise as Python. [This](https://github.com/pallets/flask/blob/master/flask/_compat.py#L67) is an example of a great comment in an open source project.
This is where naming becomes very important. With correctly named variables, functions, objects, and methods, the code becomes self documenting.
I think they're fantastic for documentation and refactoring - but not that good for checking errors.
I use pycharm regularly (the python specific version of intellij) and don't need types to get fantastic code hints. Intellij handles Groovy well also, which is optionally typed. Also their support for JavaScript, and HTML code completion is p fantastic since it works both at the same time in one file. Also throw something like a supported template language (Jinja2 for example) and they give you code completion for all 3 in one file. I think they put a lot of love into their code completion engine, it's one of my favorite parts of using the intellij tools. 
PyCharm! Thats another reason i'm excited about it.
I used typing in all projects which were more than just a couple of dozen script lines. And I have to say, I really like it. I switched to PyCharm a while ago, so I'm not sure how useful it actually is during a project in an editor like Atom/vim. But in PyCharm it works well. There are some hiccups here and there but it gets better with every version. I just switched a project to the 3.6 typing which supports typing annotations for variables, I didn't really like it. Unless you have large functions, you shouldn't really need this. I also think it's easier/faster to write than the corresponding docstring version. By now I find myself just adding the type annotations without thinking about it. But I rarely add docstrings at the point where I write the function. It also helps people understand the function a little faster. A lot of people just look at the function signatures and try to figure out what type to put in. Or, if they're using something like IntelliJ it will tell them whether it's the correct type. I used the 'enforce' library in one project. I didn't like it. It feels too much out of place (IMO) for python and it broke one function completely and I have never figured out why. Edit: Why not to use it: Variable typing: You are only supporting python3.6. (This is especially important if you write a library) I don't really see another reason why one shouldn't use it. It introduces a bit of overhead and you may have to split a line (if you use the PEP8 guideline).
Nah, its decent, sensible design that makes the difference. The code I am maintaining just now has reasonable function names, but far too many of them. Its doing simple stuff in a complex manner. Decent function and variable names help, but when there are fundamental design flaws or too much complexity, then not so much. 
"invalid syntax" often means you forgot to close a parenthesis on the previous line. In your case, your error message and your code don't match, so I'd guess the first problem is that you forgot to push 'save' in your editor. If you have more questions like this it's better to post them on /r/learnpython. Be sure to [format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) or use a site like pastebin. Your code is hard to read and test otherwise. Also, include which version of python and what OS you are using. 
Not when you're using the method on an instance of that object in another file. Depending on the scenario PyCharm sometimes has difficulty.
I work at the Virginia Tech Transportation Institute. So we study _all kinds_ of transportation related safety with a focus on cars, trucks, buses, motorcycles and now increasingly automated vehicles. Much of our work is/was naturalistic driving studies however we are starting to pivot to different areas as we see automation taking over. 
You shouldn't comment the 'what', but only the 'why'. # increment our counter num_people += 1 Anyone with a basic understanding of Python syntax knows whats going on with the above code. It doesn't need a comment. # python 3.3 doesn't support multiple parameter expansion # combine our two dicts to maintain backwards compat params.update(kwargs) request_session(**params) In this example we comment why we are doing something a specific way. In this case, supporting backwards compatibility. Its a reminder to future devs touching this code. Also as others in the thread have pointed out, good docstrings that explain what the method does pretty much eliminates any need for inline comments. 
It can be awesome at times. I got to test a lane tracking autopilot system from an un-named vendor and meet the Project Wing pilots and fly drones with them when they did the Aphabet/Chipotle burrio-by-drone project. 
A good docstring goes a long way indeed.
% formatting cannot go away because it would break the logging class, and since that is part of the standard library and since logging is something everyone should be doing... its never going away. Its a total shit-show. They keep introducing formatting methods without establishing any clear path to deprecate the old ones so its just one more standard.
I think you don't see many comments because of the common use of docstrings. I rarely leave comments in my code as I generally try to follow the guideline of giving every function, class, and module a descriptive docstring. If the code is well factored into simple functions, there is usually no need for any commentary beyond what is stated in the docstring. I'll generally leave a comment only if I'm forced to do something surprising or hacky for whatever reason. Docstrings have a number of advantages. I find them easier to read and understand then comments peppered through a function, and tools like sphinx can automatically convert them into documentation.
&gt; The solution to this is to make sure that your version of pip is up todate, either by upgrading it system wide (assuming there's a package for it) or by using a virtualenv and running pip install --upgrade pip Well pip regularly recommends updating itself, so this shouldn't be a big issue.
That's the problem with late add-ons, they don't affect the design choices at the beginning I find it's the same with unit tests If they get strapped on later, it feels like extra work for nothing If it is included at the start, I find my functions are shaped very differently, and the ability to debug my code is much more straightforward
And like real english, context can be a bitch and being explicit about what you actually mean is better. Just because 2 different data types are iterables doesn't mean that you should be able to use them interchangibly. Like a list vs a string (When you're meant to pass in a iterable of strings, and you accidentally pass in a string, it silently "works"). 
I recommend this Youtube channel for all things Python: https://www.youtube.com/user/sentdex
The logging package uses %-formatting because it existed before `str.format` - and lots of code "out there" relies on it. There is no point in, nor practical mechanism for, changing all this working code. There is [support in logging](https://docs.python.org/3/howto/logging-cookbook.html#use-of-alternative-formatting-styles) for both `string.Template` and `str.format` for those situations which demand them. I think %-formatting has its place, for now at least. For a long while (not sure about now) it was faster that `str.format` (I believe f-formatting may be faster). But the thing that keeps %-formatting around is not just `logging`, it's the enormous amount of working code which pre-dates `str.format`and so uses %-formatting.
At the time when JavaScript went through the same with TypeScript I found code to become more formal as well, like more Java-esque. Using types slowly gravitates towards using more classes and inheritance and classic OO typey stuff. Maybe it is just me.
I agree with this. I think docblocks are usually ample information especially if business logic is encapsulated. My quandary is finding a way to encourage it and defining best practices. And I wanted to learn more about the mentality in the culture. 
I thought someone might say this. That is a fault of mine. Not spending the proper time in code reviews and requesting comment updates. Sometimes I see a big glob of code in a pile and skip it for the sake of time, but those are the places where it prob needs it most. 
Feature request: from __future__ import barry_as_FLUFL
[Core IPython/Jupyter dev here] The non-polyglot env assetion is untrue. It is fairly easy[1] to write cross language in Jupyter using the IPython kernel, see link where I use Python, R, C, Cython, Rust, Fortran and Julia in the same notebook and not only send data structure back and forth but share memory (with the julia example). I abstain to use other but you can add, JS, SQL, etc... That's not saying that Beaker does not do it. Indeed Beaker does do it, it even can look a little more seamless by using (IIUC) a Json BUS. Which is extremely convenient. Though the Json BUS has it's own drawback. In particular you need to serialize/deserialize things, which is many case is a no-no when you have a dataset of tens of GB. ALso there will be some object that can't be serialized a json (like a function) Though beaker is great, we had back and forth with the author, and having project going in slightly different direction is a good thing. I wish I had more time to write interoperability layers between the two. 1: http://carreau.github.io/posts/23-Cross-Language-Integration.html 
With Python, the beautiful syntax makes up a lot for lack or lower number of comments: __author__ = "John Doe" __copyright__ = "Copyright 2017, John Doe" __credits__ = ["John Doe"] __license__ = "MIT" __version__ = "1.0.1" __maintainer__ = "John Doe" __email__ = "JohnDoe@example.com" __status__ = "Production" #Development, Prototype If this were Java or C++, the entire header would have been wrapped inside a comment: /* * @author John Doe * @copyright "Copyright 2017, John Doe" * @license "MIT" * @version "1.0.1" * @status Production */
Another developer was trying to explain the relationship between calling a class and running `__init__` I butted in and mentioned `__new__` and `__call__` but wasn't sure how it was all tied together. Google sent me to this wonderful write-up
It was discussed here [Status regarding Old vs. Advanced String Formating](https://lists.gt.net/python/dev/969817).
It seems to me like when people say python "doesn't require documentation" they're referring to *external* documentation, they're not counting docstrings. None of my projects have "documentation" but in my "this is what I write when I'm taking it seriously" example project each docstring is *at least* two paragraphs long (one to describe what the function does and why you'd want that, a second one to describe what the arguments represent and any potential pitfalls/edge cases/known bugs etc....)
I may look into how py2p does things, but I wish it to sit on-top of PAWS, so i can take advantage of its asynchronous and parallel architecture. That said, their protocol documentation would be an ideal build target. 
In python it's very easy to see what is going on. Most of the time I simply don't need comments to know what is what.
Disclaimer, I'm the author of py2p/js2p Unfortunately, since compatibility was my chief goal in design, py2p uses a daemon thread to get things going. It has a thread which watches all its sockets for incoming information. That almost certainly needs to be rewritten at some point, though, because I can't find a websocket library which supports that style cleanly. That means the python implementation currently can't talk to the browser one. That said, no matter what the front-facing API won't end up changing over it. The only other major change would be if I end up doing more serialization. Right now it'll only do strings/bytes. I'm looking at doing lists and integers as well. That *might* not end up happening though, if I can't manage to make a clean C API out of it.
I'm looking at doing list/string/bytes/int serialization in a way that works well with other languages, and *isn't* JSON.
Code reviews are where you encourage or enforce this kind of behavior. If you want to enforce this behavior, you also need a style guide that your team agrees to (or is mandated...depending on your situation). If you want to enforce things in code review, they should be in your style guide. 
This is so evil.
A really bad way to do it in `pandas` (I'm procrastinating): import pandas df = pandas.DataFrame(index=range(1, 101)) df['Fizz'] = df.index % 3 == 0 df['Buzz'] = df.index % 5 == 0 for row in df.itertuples(): if row.Fizz or row.Buzz: print('Fizz' * row.Fizz + 'Buzz' * row.Buzz) continue print(row.Index)
Speaking of style guide... do you have a recommendation? Yeah I am at fault for not pushing code review in the past. These comments really illuminate that. 
[pep8](https://www.python.org/dev/peps/pep-0008/) is the defacto standard. Most projects though I skip enforcing style entirely and instead integrate the pep8 command and pylint into the build (which must pass for every commit).
Ideally -- and I'm not saying I meet my own standard -- I like to see comments/docstrings at the variable / function / method / class level that cover all of the following: * What this does * Why it does it * What it is used by * When it is used * Known weaknesses / limits * What it returns, if anything ...comments at the statement level, other than in relatively long chunks of code, I'd really rather not see. At that point I'm _reading_ the code, and that lets me look into what it does without assuming the comments -- which remember are a description, not functional -- are telling the truth. Many times I have seen comments that no longer reflect what the code actually does. People hurry, and that happens. But the code does what it does, so that's where I focus. 
&gt; Its a reminder to future devs touching this code. So, future me, for all intents and purposes.
Well if you wanted it to be subtle, at least name it something *other* than **destruction**
Thankfully this was fixed in python 3. Python 3.5.2 (default, Sep 14 2016, 11:28:32) [GCC 6.2.1 20160901 (Red Hat 6.2.1-1)] on linux Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; False = True File "&lt;stdin&gt;", line 1 SyntaxError: can't assign to keyword 
Ha! I can break ANY python program with a simple import statement! Jokes on you!!!
&gt;% formatting cannot go away because it would break the logging class Nothing about % formatting going away would break logging. Logging **uses** % style formatting, but the whole point of it accepting format strings is to **avoid** the user using % formatting directly (and so paying the performance cost etc for things not being logged). You'd need to change the *implementation* of logging if it went away, but there'd be no backwards incompatibility or breakage required. Admittedly, it'd be odd for it to use a form of formatting not available elsewhere, but not much moreso than now. Now, it's true that % formatting is unlikely to go away, but not for this reason - logging is relatively trivial to change, since it's part of the standard library (and probably easier to deprecate to get rid of that API too). A much bigger issue is third party code that's using the formatting directly.
If it's for code clarity did you consider enforcing coding standards that specify commenting functions and parameters? I'm a fan of the [Google](https://google.github.io/styleguide/pyguide.html#Comments) guidelines, an actual description of every parameter gives more context than just the datatype.
Yes I use pyzabbix but there is also py-zabbix. The zabbix API is itself is a JSON API and easy to use and quite well documented.
&gt; Just curious, are you worried at all about %-formatting being technically flagged as "deprecated"? % formatting is **not** flagged as deprecated. Some of the Python core developers prefer to discourage it, and PEP 8 makes requires `.format()` for new code to the standard library (but PEP 8 also allows exceptions), but it isn't deprecated.
Hey, that's a pretty similar path to what I took, but with java thrown between CSS and Python. Python to me is so neat because of a few different things: * The code is close enough to pseudocode that it's absurdly easy to pick up * As you'll learn with CSS/JavaScript, there can be a lot of inconsistencies within programming languages, python is really consistent * Much of the 'boring stuff' is done for you in python. What takes three or four lines in other languages takes one in python. * While not quite as universal or powerful as Java, it's still incredibly easy to use with anything, for anything As for limitations... I haven't found any. (Note: I'm not a professional programmer, and I'm not the best python programmer either. But I've dipped my toes in a lot of languages and haven't found a language I love nearly as much as python.)
Atom is better.. fight me. 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
No its a huge issue. All the uses of logger.debug or error where the message is "something something %format" have to be converted to a potentially different "something something {:format}". A lot of those are on error paths and as such are seldom tested and add to that the fact that they might be conditionally executed depending on log level. It's not like you can just change thousands of those lines across all packages without some serious risk of breaking the code. Now instead of logging helpful debug information in an exception handle you are dumping the stack because the logging message was misconverted to str.format.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
This is not related to Python
It's amazing what you forget when you go back to code you haven't touched in a few weeks/months.
My advice would be to only use it if you're using the type linters/checkers etc. At the same time, I'd advice doing that stuff from the beginning, but I *wouldn't* advice just adding type annotations on the possibility that you might start using a linter in the future.
I would look into using numpy for that, it's designed for ~~matrixi~~ ~~matrixes~~ ... dealing with one matrix or more. [Example 1](http://stackoverflow.com/questions/15638650/is-there-a-standard-solution-for-gauss-elimination-in-python) [Example 2](https://gist.github.com/mikofski/11192605)
Actually I also felt that way about documentation. But whenever, I try to write documentation, I try to write in as detail as possible so that non-technical people also can follow,and understand what exactly going on, with minimal knowledge. Thanks for suggestion though, i'll try to put it on readthedocs or something once i'll get some spare time. Making stream like radio required transcoding, which is not implemented in the application. But there is some alternate way I've added to play it like some channel. Once we keep in media server url in loop in external player, the player will automatically play everything which is being played in kawaii-player. Only downside of using such approach is that, client won't get any metadata about stream, and it won't be in exact sync with server. There can be few seconds of delay between client and server. 
When you work on large projects with several other people it saves quite a bit of time in the end. It also codifies the standards too which keeps it more consistent and reduces bike-shedding... That said, I do get called names but I'm open to changing it so long as: * They make the change. If it's important to them they can take the time to make the * The change does not reduce the overall quality or make the code less consistent. * It's improve the workflow for everyone. Removing something so local development is faster great but not if it makes something else slow or more unreliable (code reviews, release process, deployment, etc)
https://twitter.com/sos_jr/status/761348984245919744 "code as if the person who will maintain your code is a violent psychopath..."
...
Was it inspired by [StackSort](https://xkcd.com/1185/)?
Anyone have pylint working with python 3.6 variable annotations? I installed the master branch 2.0 which handles fstrings but it still breaks on annotations. Specifically, there is no node in Astroid implementing the new AnnAssign node in the ast.
You mean you downloaded a whole separate copy of python and installed it to `/usr/local` or `/opt`? If yes then that's probably fine, but your system's version of pip is still broken and you ought to fix it. As a general rule, you should never make any changes to any file or directory in `/usr/lib` except by using your system's package manager (not pip) or else you will break your system.
I fixed that. Thanks for pointing :D 
Good place to start, but there's a few things that bug me. Like no tabs.
That's disgusting *Upvotes*
it would be really evil to flip True and False with a 0.05% probability ... 
thx for the address btw. I didn't learn tuple stuff.. only know some list, while, for loop
List of lists then :) [['cat', 44], ['bird',2]]. You can then look into the built-ins 'sort' and 'sum' to figure out how to do the next steps. (think of tuples as just unchangable lists, you make them and store as is.)
Change the order of operations (precedence).
I'm not sure they actively resist. They just don't put themselves in the right mindset to come up with good comments in the first place. You have to read your code from the perspective of someone not knowing your code. That's the whole trick. If you do this then your comments will become valuable without any additional effort.
That's fine. I'm just trying to help without spoon feeding so you can get it to *click* (or else the next one will be twice as hard). I'm saying you got two lists there to hold your things. And you for loop over the first list to populate the second list. What would happen if that second list has both name and age in it then you can do stuff like sort it and find average easily. But to make it even simpler, why not create a few extra variables. Like oldest_age, youngest_age and do a check every iteration of the loop to see if there is a new older or younger age, and update it if there is (could have corresponding oldest_name as well). Gtg to sleep, good luck!
your suggestions are really helpful. Guess I gotta try it few more times. Gnite :)
I work at western digital on a very specific piece of testing equipment. I'm about to finish a program that finds the latest result csv file and pulls relevant parameters, writes them into an excel file that opens onto the screen, and looks to see if the file gets new results and adds them to this file. Basically making a quick result summary on excel while people test so they can make sure things are working and reasonable. Using xlwings for the excel parts.
A* pathfinding
It's a waste of space
After you wrote the code it's very good to read it again and add comments in parts where you think there might be problems in someone's understanding of what is happening.
I'd never forget I'm a shortsighted dimwit who's too clever for his own good.
No, they don't. You can remove % formatting from the *language* without doing that at all. There's absolutely nothing stopping you just reimplementing it in logging as a function or similar. All you have to change is the *implementation*, not the API: "`logger.debug('%s')`" will continue to work without % formatting needing to exist. And like I said, even if you *did* do that, it'd still pale into insignificance compared to all the **non** logging cases where it's used, and you could deal with it in a similar way (ie. provide an alternative (there already is one, but it's not good for this purpose), encourage that new API, and then deprecate the old one later, just as you'd have to do for % formatting in general. It'd certainly be a pain, but *less* of one compared to everything else, since there's likely way more logging code, and it's way less structured.
The important part of the error is error: failed to commit transaction (conflicting files) python-setuptools: /usr/bin/easy_install exists in filesystem python-setuptools: /usr/bin/easy_install-3.6 exists in filesystem python-pip: /usr/bin/pip exists in filesystem python-pip: /usr/bin/pip3 exists in filesystem python-pip: /usr/bin/pip3.6 exists in filesystem The files already exist, probably because you installed it through some way other than your systems package manager. This is bad and can break your system with the wrong packages. Only ever use your systems package manager for this thing. A simple `sudo pacman -S --force python-pip python` should properly install it, overwriting those wrongly placed files. I'd recommend installing both python and python-pip that way, because if one of them is screwed up, the other one is likely as well.
It is not Pythonic. It seems well thought out. I enjoyed the read :-) 
I'll give it a shot. Formatted string literals are a Python parser feature that converts f-strings into a series of string constants and expressions. They then get joined up to build the final string. Imagine we had the following `greet()` function that contains an f-string: &gt;&gt;&gt; def greet(name, question): ... return f"Hello, {name}! How's it {question}?" ... &gt;&gt;&gt; greet('Bob', 'going') "Hello, Bob! How's it going?" When we disassemble the function and inspect what's going on behind the scenes we can see that the f-string in the function gets transformed into something similar to the following: &gt;&gt;&gt; def greet(name, question): ... return "Hello, " + name + "! How's it " + question + "?" The real implementation is slightly faster than that because it uses the [`BUILD_STRING` opcode as an optimization](https://bugs.python.org/issue27078). But functionally they're the same: &gt;&gt;&gt; import dis &gt;&gt;&gt; dis.dis(greet) 2 0 LOAD_CONST 1 ('Hello, ') 2 LOAD_FAST 0 (name) 4 FORMAT_VALUE 0 6 LOAD_CONST 2 ("! How's it ") 8 LOAD_FAST 1 (question) 10 FORMAT_VALUE 0 12 LOAD_CONST 3 ('?') 14 BUILD_STRING 5 16 RETURN_VALUE Hope this helps you out :)
Python 3.6 is already available in Anaconda. It is just not the default yet on new installs. You have to explicitly install python=3.6.
You can run selenium headless afaik. 
I was about to pip install this to have a go but then I realised I don't want it anywhere on my machine.
does it execute javascript headless?
https://amoffat.github.io/sh/ to replace shell scripting
It's funny how over time a piece of uncommented code will change from neat and self documented, into a spaghetti mess that no-one even knows how to run, without a single line being edited.
And I suspect the people who say their code is self documenting have with lots of variables called 'a' and 'list', and functions called 'run_now'.
[removed]
The comment to which you replied is deleted. Would you indulge me and tell me what it said?
It's so wrong yet it's so right. It'd be cool to see this kind of extension of Python used as a usable replacement for a Bash shell.
PyQt.
You should have a continuous integration server yes. Just like with any other tests. 
I primarly suggest Kivy.org lightweight powerful. Furthermore look at this https://github.com/dddomodossola/remi Pure python! Portable and remotable. Compatible with everything
Thanks for pointing that out! I'm getting used to linking scripts to other scripts. The main reason was I was learning datetime and experimenting in that file of how to do it properly. I ended up just linking to the file once I got the hang of it. 
This is mainly for our offices use. In our 30+ years we've never had someone with more then one spouse. It's illegal where I live so it's safe to assume. 
What's your thought overall on the structure of the code? 
 &gt;&gt;&gt; from __future__ import braces :)
Just to be explicit, py3.6 is available through continuum's default channel, but there isn't an Anaconda distribution based on 3.6 yet. The next version of Anaconda is due soon I think, and I'm guessing there will be a version of it for 3.6 at that time.
MEEEE! I just started learning too. Ill email you laters. @ work atm 
Seems like the seeds for a new language
And now we've come full circle back to perl.
What was the prank? :) Inquiring minds want to know.
I love it. I'd not use it in production, but I love seeing this kind of stuff. It's a lovely reminder that Python can do a lot of the things you see in Ruby libs... its just not commonly done.
[Xonsh](http://xonsh.org/) Have been meaning to try it, so no idea how well it works in practice.
No you don't. It was a joke in very poor taste.
Why not just use perl?
&gt; you can have it auto-open the browser to the UI when it starts How do you do that?
&gt; because typing doesn't affect the runtime Is there a way of making it do so, i.e. have it so all types are checked a runtime to help ensure the code is correct?
&gt; \# Python's nasty range() is right-exclusive. This is right-inclusive. My god, this is going to ruin some days. *I love it.*
reminds me this another approach https://github.com/jsbueno/stackfull
&gt; pep8 One note: pep8, the command line tool, is now [pycodestyle](https://github.com/PyCQA/pycodestyle) as [PEP 8](https://www.python.org/dev/peps/pep-0008/) is a living document and because the tool defaulted to slightly different things than the PEP. For me and my team, we use [yapf](https://github.com/google/yapf), customized to fit our style. It's simple, it can make the changes in-line, and it's a little more comprehensive I find than pycodestyle.
I would highly recommend nightwatch with docker. I would suggest this over python. I have been doing webdriver testing for a longtime now and to be successful you have to an environment that supports web testing. The most critical piece is the ability to setup and tear down a known set of data. 
Given the examples why does pandas insist on overriding `__getitem__` for indexing? It puts a lot of restrictions on what you can do. It made sense when you had `df.ix[rows, cols]` because it was a bit like indexing into a matrix, but with the `loc`/`iloc` examples it loses that convenience. I never name my rows, I always name my columns, so I'm perpetually stuck in the awkward halfway house of: `df.iloc[[0, 2], df.columns.get_loc('A')]`. Which is fugly, confusing and has a dangerous repetition of df. Why would I ever want to `df1.iloc[[0, 2], df2.columns.get_loc('A')]`? How about making it a proper function with some keyword args. Then you could call it as: `df.iloc([0,2], None, col_names=['A'])` or `df.loc(None, 'A', row_idx=[0,2])`? Or just more generally have a `df.ix` function with only keyword args. I would love to `df.ix(rows=[0,2], col_names=["foo", "bar"])` 
Like a train wreck full of clowns, there is something simultaneously beautiful and horrifying about this.
That does sound a bit involved! If you're dealing with NSIS anyway, you may want to have a look at Pynsist; it is a convenience layer on top of NSIS, so you lose some flexibility, but if you're happy with what it does, it simplifies what you need to write.
If you have more questions like this it's better to post them on /r/learnpython. Be sure to [format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) or use a site like pastebin. Also, include which version of python and what OS you are using. 
It feels so wrong, it feels so right, I'm gonna write code with this toniiight.
That's disgusting.
That seems very alien to me. How is it used in practice?
This looks like the ugly baby of Python and OCaml.
Another limitation is that the source code of your application is available when you install the application. 
Is there an appropriate time in a development career to get into unit testing? With my current project, I don't know what the overall structure will end up looking like, and lots of pieces go through several iterations before I get them right. I don't know what to test, and I haven't been programming in Python that long, so a lot of my coding-work is intermingled with my design-work - I don't know enough to know what something ought to look like until I've finished it, and I'm almost guaranteed to know better in a month or three.
&gt; This will slow down your code This is often not a problem when running a test suite. &gt; python will typically crash at runtime when you use wrong types anyway Yes but it might well crash in a different place, away from the source of the problem.
Start unit testing as soon as you're confident with the language, enough so that you're making tools for yourself or libraries for others to use. If you're changing code structure etc around, it's all the more reason to unit test. You know what your code is meant to do in the grand scheme, so test the big picture stuff first. If you make big code changes, your code should still have similar results and if it doesn't it makes you more aware of your changes. Either your code is broken or you need to update your tests but either way you can be more confident about the result than just hoping it worked. Then as you start solidifying parts of your code base, start testing them. It's fine to change the code but it ensures you're not breaking things that other parts of your code may need. If you work big to small in unit tests and start from the very beginning of a project, you'll get maximum coverage and still retain flexibility
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
string.ascii_lowercase will return a string of lower case letters in alphabetical order. You can map each char in s to its index in the alphabet and then check for sequence where each char is index + 1 from previous letter. 
The biggest complaint I've heard, though, of people trying to use pandas is that there are too many indexing methods and its confusing. Simplifying this just a bit might promote more widespread adoption of the library.
I would be interested. I'm currently doing the MITx course and would love somebody to bounce ideas off of. 
/perl/ocaml/
I happen to have just done this yesterday. I followed these instructions: http://www.pyimagesearch.com/2016/04/18/install-guide-raspberry-pi-3-raspbian-jessie-opencv-3/
As /u/brombaer3000 mentioned it isn't the default for the root environment yet. Continuum releases Anaconda quarterly, so `conda` isn't yet on Python 3.6, but I'd imagine that it's a very simple update from 3.5. Once the next release of Anaconda comes out it will almost certainly be on 3.6. You can still create environments with Python 3.6 (and I did the first week it was out).
While using this for anything but fun is obviously bound for disaster, it's a testament to the flexibility of python that you can hack it's syntax so much. 
Yeah, I never liked that the [] was a shorthand for just columns. I think that comes from replicating how things are done in R maybe. I would have preferred that [] just work like either loc or iloc (replacing one of them). I do use pandas nearly daily, so these things become second nature, but I agree that it's definitely not intuitive. However, in your case, what does your row index end up looking like? Usually, if you don't set an index, an index is just created (every dataframe has row labels) with integers 0, 1, 2, ...etc. So if your row index is integers, then you actually could use the loc indexing: df.loc[[0, 1], 'A'] Though, this might depend how you build your dataframe. If you just read it from a file, that's fine. But if you cobble it together from other dataframes, then the row index might now be in order.
Python support multiple brace styles already. C-style: for i in range(10): #{ print(i) #} Ruby-style: for i in range(10): #do print(i) #end Mixed-style for i in range(10): #{ print(i) #end 
Wouldn't overwriting the pipe operator interfere with regular pandas usage?
&gt; However, in your case, what does your row index end up looking like? I have no f-ing idea. Whats an index? (Rhetorical question, I understand the concept). I think that is the question that causes most casual users of Pandas to throw up their hands and walk away, and it is why I have exclusively used `.ix` because I don't care about these different indexing schemes. I just want Pandas to give me the "foo" column of all rows where the "bar" column is greater than 5. I haven't named my rows, I just imported them with `pandas.read_table.` `.ix` worked just fine for all my use cases. I never had a problem with it, in part because I don't do stuff like "name columns as numbers" or "name rows ever." The documentation is super confusing. I thought the whole point of `.loc` was that you couldn't pass an integer in as an argument. It has this long comment about sending `.loc` integers: &gt; A single label, e.g. 5 or 'a', (note that 5 is interpreted as a label of the index. This use is not an integer position along the index) 
Thanks fore the positive feedback! Glad people dig it.
I think those people have different problems than using emacs. It's not easy to mix tabs and spaces in recent versions.
Having an alternate indexing mode isn't a bad idea! As long as it's just a change in high-level syntax and doesn't require the developers to maintain separate branches under the hood, it wouldn't be all that hard to implement. Heck, someone could probably write a wrapper on a pandas dataframe that just changed the indexing model.
Have an upvote for mixed style, you sick fuck.
But `df ["a"]` gives you a series. Do `[` and `[[` give different behaviors... that's confusing. 
No it's not. If you request a single column, you get a single column as a series. If you request multiple columns by using a list, you get back multiple columns as a dataframe. 
I have no clue what you guys are talking about. Care to explain? I know it kills the joke, but for science.