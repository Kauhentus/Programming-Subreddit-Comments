For the first part, yes you can, provided you have a mechanism to tell the appserver where to look for apps. But basically the cherrypyquickstart(app, '/', config) in the example is equivalent to: cherrypy.tree.mount(app, '/', config) cherrypy.engine.start() cherrypy.engine.block() You can mount apps whenever you want even after the engine (which is responsible for the whole process) was started, even when it's running. For your latter question, CherryPy doesn't deal with such thing so I'd say no but it wouldn't come into your way if you wanted to do so either.
I'm fairly sure that's not the case for Django, although I have only a cursory familiarity with it. Django distinguishes between an application and a project, and a project can contain multiple applications.
That seems neat indeed :p
I disagree with the assessment that Bottle "would probably not be a good idea to start a bigger project on". If anything, big projects give you time to spend customizing your framework to work exactly the way you want, which is a win for Bottle. I have used other frameworks (Django, Pylons), and in my experience, I end up having to rewrite many plugins anyway. Also, the Bottle code isn't that hard to read for someone who programs for a living, but I guess it might be more difficult for people who are new to Python or WSGI, or are primarily web-designers, not programmers. 
Perhaps we ought to move to the metric: Lines of Tested Code (by coverage). It's the only line-count related metric which might be useful to measure, after all.
&gt; I have used other frameworks (Django, Pylons), and in my experience, I end up having to rewrite many plugins anyway. I guess you're better off just re-inventing the wheel every time without even trying the third party plugin. Of course, if you just fork the plugin, fix it, then submit a pull request the next guy doesn't have that problem.
Lines Of Code is a horrible metric to judge a piece of software on.
What django calls a project I call an application. My bad. Can you take any two projects created by distinct people (each with its own database and its own modules) and run them under one Django instance? Can you add projects without restarting?
Only one client. Writable. Minimal security. That shouldn't be a problem because I'll be the only one using it. I don't understand the rest of what you ask besides the updating part. I would like it to be automatic.
&gt; but I was just mentioning the JVM and LLVM as a kind of universal bytecode I understand. &gt;I notice the existing JVM and CL[IR] backends are only RPython translation targets, not JIT targets. even if JVM/LLVM were supported by pypy jit, you would still get a much worse performance than the native code on the same platform: as JVM/LLVM would still be interpreting your program.. 
When you create a Django project, the manage.py script is one of the files created, and that's what you run to instantiate the server. So no, you couldn't really run two projects simultaneously under one Django instance, unless you ran the second on a different port. However, why would you want to do this? The Django server is there purely for development purposes, and is most definitely not suitable for use in a production environment. If you've built a web app using Django, you should be deploying it using other means (I understand mod_wsgi and Apache is the recommended method), in which case this simply isn't an issue. If you're in the process of developing something, there isn't likely to be all that much call for running two projects at once on your local machine. The way Django is set up encourages developers to create reusable applications, and a Django project can be seen as a collection of applications. Some of these will be the ones shipping with Django, such as flatpages and the admin interfaces, and aren't present in the project folder itself - you enable them by editing settings.py. If Django doesn't have an application to do what you want, you can use an application from a third party, or you can write your own. If you want to be able to share functionality, that should be as an application, not as a project. Say, for example, you had a project where you wanted two things on the website, a blogging engine to handle the blog posts, and a simple CMS to handle the flat pages. You could quite easily create these as two separate applications within the same project, and these could easily be distributed separately, so you could take the blogging engine and reuse it elsewhere, without relying on the CMS being there. If you add a new application to a Django project, you do have to sync the databases first, and then restart the web server. However, the Django web server is small and simple enough that this isn't really much of an issue - just Ctrl-C, python manage.py syncdb, then python manage.py runserver. I'm not entirely sure what exactly your issue with these frameworks is, but I'm guessing you're referring to the fact that if the framework did not provide its own web server and instead relied on a full web server like Apache, then it would be trivial to have multiple applications running at the same time on one development machine. I can't deny that this is true - at work I've been using the PHP framework CodeIgniter, and as that doesn't include any kind of web server, I use it in conjunction with a full WAMP stack, and if I did have two projects on the go at once (although I consider this very unlikely), I could do so more easily than with Django. However, using Django also eliminates a lot of other steps that a framework like CodeIgniter wouldn't do. For one thing, Django's built in ORM system means I wouldn't have to create all the database tables I needed manually, and in my experience Django's development server causes a lot less grief than I've had from trying to get Apache working on Windows. So I would consider that trade-off more than worthwhile - I don't see too much likelihood of having to run two Django projects on a development machine concurrently, while it saves a lot of hassle in other ways. And in production, you're using a proper web server anyway, not Django's development server, so the end result is the same.
Why? It seems like there is a better way to deal with this situation. Judging all the frameworks on one edge case doesn't make sense.
y u no review turbogears2?
If it's not a good metric for you, then you're free to not judge based on it.
Perhaps import [colorama](http://pypi.python.org/pypi/colorama) at the start of the program? It handles the ANSI escape sequences on Windows and converts them to the equivalent.
http://webapp-improved.appspot.com/ webapp2 is an "improved" version of the web framework used on Google App Engine (and its improvements have actually been folded back into the Python 2.7 GAE), but it also works as a standalone framework outside of GAE. Here's a quick rundown of its improvements over the original GAE webapp: http://webapp-improved.appspot.com/features.html I have not personally used it outside of GAE but I have been happy enough using it within GAE that I'd certainly recommend giving it a look.
Not sure where you got the fact that reddit was written in web.py, but I do know Reddit is based on pylons. The code structure very much points that way. Before you think I'm accusing you of pulling facts out of your arse (you are), here's a source on Reddit being written on Pylons: http://www.reddit.com/help/faq#NerdTalk
I want to believe that whenever you go on this kind of shitposting sprees, it's a pint of whiskey talking. The utter inability to grasp the canvas of the discussion and the way you seek approval with your "do you know who I am?" certainly fit. But if you do this shit sober, then please accept my condolences.
&gt;These are the main Python web frameworks people usually talk about. ... &gt;** There or many others Zope, Pylons, Pyramid - I have left them out as I have no personal experience with them. &amp;#3232;\_&amp;#3232;
My issue I have is that they do not separate enough the web framework from the web applications. In order to understand each other we need to solve a semantic difference. Django uses the term "application" to indicate a part of a project. I call that a plugin. Something designed to be reusable therefore reusable by definition. I use the term "web application" to refer to what you call a project. Something created by a group of people with a specific web site in mind and not caring about reusability. I'll agree to use your semantics. I want to be able to run multiple projects on the same machine. This is very important to me. I want to be able to pay for one small VPS and runs many of web sites with each using a different database, different authorization permissions, different users and different domain names, different logging, using different (possibly conflicting) modules. Why? Because I want to save memory, money, and time. I do not want to write one line or code nor one line of configuration to setup a new web site. I just want to press a button. Not sure why some people call this a corner case. I think it is the other way around. Everybody here seems to be concerned with one project and millions of users. I think that is a corner case. Running many small applications and sharing resources as much as possible is the more typical use case in my experience.
As I argued in my post above, I do not think this is a corner case. I have been using some of those frameworks and the most time consuming part for me has never been developing the apps (they are all excellent at that) but managing them, moving them around, and getting different apps to coexist. This is why we made web2py and why it has a completely different design than the other frameworks. With its pros and cons, it solves this problem for me and other users. I am not judging them because of this. Actually I judge all of them to be excellent frameworks and I do use them some time. I just think that they have something in common that I do not like. I believe the framework should execute the apps and not the apps import the web server and run it as the code example in the article show.
Django dev here. A moderate size Django project runs in about 40mb. I run multiple Django instances on shared hosting accounts and VPS's. They all run on different ports but with one front-end webserver handling the static media and routing to each Django (app/project depending on your terminology). Does that not suit your needs?
The cited behaviour is true when `shell=False` (the default), but I don't prevent setting `shell=True`. That will invoke the shell (through the normal `subprocess.Popen` logic), with its concomitant dangers - and that's when you might need the shell formatting and quoting functionality.
Dropbox is more or less Unison with a GUI. Rsync really just syncs things in one direction. If you have changes in both your local and remote directories, Unison will bring both up to date. To do that with rsync, you'd have to be very careful.
Yup..that did it...thomas emailed me after I filed the bug report. Thanks for the help! :)
Well, more that this entire area is unreasonably difficult. Should I have to download/install XCode, MacPorts, Fink (not a trivial install. took me an evening), JPEG, PORTMIDI, smpeg, three SLD libraries, and more, just to be able to even use some Python packages that are intended to be 'end-user ready'? Not to my mind.
XCode is like a magic drug for Mac programs. I don't know why either. It's probably because Apple Inc. wants to be a stand-alone empire, so of course they need their Mac-specialized EVERYTHING, including things that don't really need to be...makes it nearly impossible to get the system to talk to anything not with the holy Apple stamp on it.
I didn't even read that far, I didn't see pylons or pyramid on the list and so I knew it wouldn't be a good article.
Fair enough but I'm getting where "corner case" comments might be coming from.
I'm not asking why you shouldn't, or why it's bad, etc. I understood that roughly (although I understand it better now and I'll give you an upvote as a way of saying thank you), I was just wondering how one could ... 'force' it just out of base curiosity. Thanks again!
Thanks! I've just [added](https://bitbucket.org/takluyver/cx-freeze/changeset/ece066ff4a8d) a cxfreeze-quickstart script, which prompts the user for some information to create a setup.py script. That's probably the simplest part of the code to dive into. Apart from that, you can watch the repository and join the [mailing list](https://lists.sourceforge.net/lists/listinfo/cx-freeze-users). That will help you understand what's happening, what problems people have with it, and so on.
This reminds me of certain dark places in Usenet, years ago -- places where intelligent conversations were impossible, for lack of any intelligence in the regulars.
Yay Pyramid! I was sad when I didn't see it listed.
PyPy has raised $41329 of $60000 towards NumPy support, and are getting along quite well with it. As for the others, I assume matplotlib will be the next thing ported after NumPy, and SciPy and NTLK will be ported in due course with demand; possibly by the original writers, possibly a reimplementation by the community. PyGame is a fairly thin wrapper around SDL, and would probably be better to rewrite in pure Python + ctypes; this could probably mostly be done over a weekend with the aid of the original PyGame source. What you seem to forget is that PyPy has only been usable at all for a very short period of time, and there's not been enough time to port the larger C modules. It'll happen eventually, as PyPy gets more and more stable and more and more people look to it as a potential solution.
How about something like this: http://www.python-camelot.com/ Works with SQLAlchemy.
I'm not really sure why one would want to torture themselves like that.
I would suggest to get involved in Python Mentors program, http://pythonmentors.com/
 cat &gt;~/bin/sync &lt;&lt;EOF #!/usr/bin/env sh rsync -au myserver:shareddocs/ ~/shareddocs rsync -au ~/shareddocs/ myserver:shareddocs EOF chmod u+x ~/bin/sync echo "~/bin/sync" &gt;&gt;~/.profile &gt;&gt;~/.bash_logout (No-one should actually use this without understanding it; it makes a lot of assumptions about the system) I know that this suggestion doesn't use any python so it's not any good for helping you learn the language, but one of the most important lessons to learn about programming is that you should reuse other people's hard work as often as possible. Also, use the right tool for the job.
 rsync -u
Please teach me something then. :-)
I have been debating codeToGo, but i also own an ipad so I would probably never use it on my phone if I didnt have to. My only hesitation is that you need web access to actually compile.
Inspired by http://yieldthought.com/post/12239282034/swapped-my-macbook-for-an-ipad, I decided to learn Vim and just connect to a home Linux machine using screen. It's been great, and as an added bonus I am much more comfortable in vi/vim, which is on pretty much any Linux machine.
vi is supposed to be on any Unix machine, and most Linux distributions attempt to emulate Unix. vim is in no way guaranteed to be on any machine, although many distributions include a very stripped down vim by default, which they label as vi so that it starts in vi-compatible mode. I'm not sure how pressing extra keys works on iDevices though. On my Android phone I use the Hacker's Keyboard, which includes most of the keys like Esc and symbols that I'd need.
I have a VPS running web2py. I can use the web2py admin to edit file using the browser and I can use the web based web2py shell. I can also use the web2py mobile admin (based on jquery mobile) to manage all my python apps in the could. I say "I can". In practice I use emacs.
The font display is ugly, but have you tried the Vim in the App Store? http://itunes.apple.com/us/app/vim/id492668168?mt=8 It's free. I use vim at a desktop, but only every now and again. Being a regular user I'm curious what your opinion is of it.
Do you want to remove all character beyond the limit or ask the user to type the input again if it's over 160?
I would like to ask the user to type the input again if it exceeds 160.
 while 1: s = raw_input("your prompt here&gt; ") if len(s) &gt; 160: print "error: input longer than 160 characters" else: break
You can't just dictate Python using Siri?
Yup, got Prompt, definitely love it :) The Medium size font they just added in the update is awesome. But I'm looking more for an iOS text editor that caters a bit to coders. I'm getting pretty decent at typing in landscape mode :) 
Thank you, thats very helpful!
Once I wrote an entire regression analysis during a flight using pure ASE python. Never again. 
Telephone? Programming? I have a netbook, it serves almost every computing need I have. The only problem is that web applications are often too large to view in one window without scrolling.... EDIT: And I use GNU Emacs! Let the flaming begin!
Kudos on figuring out a solution that suits your lifestyle.
Geany
[Python Dev Guide](http://docs.python.org/devguide/) is a good place to start.
I use PyCharm for big projects, but when it comes down to it nothing beats Vim for most tasks.
WingIDE is really powerful. And PyCharm in my experience is somewhat bloated.
Of course. Pywikipediabot - a framework to edit mediawiki wikis. I haven't tested that much yet, but the basic functionality (getting/putting pages) work.
&gt; Use “while 1″ for the infinite loop I didn't know that, could anyone confirm it? &gt; Use xrange() for a very long sequence (...) As opposed to range() I thought this was not true anymore, at least in newer versions of Python. &gt; Learn itertools module Hell yes. Learn it and abuse it. 
Vim with Python mode (https://github.com/klen/python-mode) and pylint. Sure a bunch of other plugins but those 2 are mainly for Python; As well for IDE like exp - NERDtree (file browser) and Tagbar; Autocompletition is build in so you need only ctags to generate tag file. Oh there is PEP8 plugin as well - http://www.vim.org/scripts/script.php?script_id=2914 Well... That's the beauty of Vim - there is crap loads of plugins for any language, you just need to dig in. Same in emacs I think.
A few additions: Section 6: Don't go overboard with lazy importing inside of function calls. Importing many times can get expensive. Imports that aren't at the top also severely reduce readability. It can be tough to debug code where an import is tucked away somewhere in the body of the file. Section 7: In Python 3, True is a keyword, not a built-in. That means the byte code compiler can put in a cheap simple jump instead of an expensive global lookup. In Python 2, True could be changed, so a global lookup was required as a check. 1 is a constant, so the bytecode compiler can depend on it. Basically: while 1 in Python 2, while True in Python 3. Section 13: Internally, the Python deque implementation uses a doubly linked list of blocks. Each block has space for 62 objects, plus 1 left pointer and 1 right pointer (64 pointers). That gives the time efficiency of a linked list with the space efficiency of an array. For those learning C, I suggest looking at the Modules/collectionsmodule.c. For a list type with fast insertion, take a look at blist (search on PyPi). Section 17: Don't use threads to manage forked processes. They only provide additional overhead in memory and thinking ability. Use the multiprocessing module. Section 18: Absolutely absolutely absolutely. The Python source code is an excellent place to get examples. Part of my introduction to C was reading through bits and pieces of implementation code.
Great list. Found and reminded myself of some gems that I as a novice often forget about and would find useful.
Thanks! Its too bad that it's not possible to have multiple calls because now I have to pass along all arguments :(
Remain confused, it's easier than knowing the truth.
There is a plugin API for bottle (if I'm not mistaken)... I wonder where could one find plugins (except those two listed at the page).
I've used Komodo-Edit for quickies, it works well, but I've found the code completion to be dodgy.
Damn, I thought range acted as a generator as well from 2.7. Thanks. 
Use PyPy :) Seriously, I tried it for fun on a small scipt I made to do monte-carlo simulations of a card game: more than 10x speed up, for the cost of typing pypy script.py instead of python script.py
Regarding 15. I don't think the author knows about the 'key' argument to 'sort'.
The Memoization example is wrong (and therefore broken). The author has written if arg not in cache: cache['arg'] = f(*arg) return cache['arg'] where they mean if arg not in cache: cache[arg] = f(*arg) return cache[arg] :)
ad 7: Also it's True (as you wrote it) and not true as is in article.
&gt; Importing many times can get expensive. Surely once a module is imported, a second import will simply be a cheap lookup of the sys.modules dict?
my rule of thumb for 6: import as soon as you know you’ll need it.
I've never heard of "Schwartzian transform" before, but doesn't sort() already perform this optimization if you use the key parameter?
Most of this is good advice, but there are a lot of errors and typos. &gt;Python is faster retrieving a local variable than retrieving a global variable. That is, avoid the “global” keyword. The global keyword isn't the only way you'll be dealing with global variables - you'll can access global variables even without it specified, it' only changes the behaviour of **setting** global variables. the_value = 42 def foo(): return the_value is still using global variables, despite the complete absense of any `global` keyword. &gt;To check membership in general, use the “in” keyword This is indeed good practice, and generally faster than things like dict.has_key(). However, the example he gave is a for loop, which is nothing to do with checking membership, and where "`in`" has an entirely different meaning (it's just part of the `for` syntax). (Also, careful of the datatype you're using `x in somelist` does a linear scan to check membership, so this can be very slow compared to a dict or set) &gt;Learn biset module I assume this is meant to be bise**c**t, but it's spelt wrong in every location. &gt;It is fast because deque in Python is implemented as double-linked list No it isn't. It's implemented as a vector which overallocates at both ends (for amortised constant time appending/prepending). It has the same complexity of operations as the list, except that prepending is O(1) instead of O(n) &gt;Use sort() with Schwartzian Transform This is very outdated. You can let sort do the transform for you just by passing the `key` parameter. 
I quite like using KDevelop for Python. The support is getting better and better as shown in these posts: * [Basic List content type support in KDevelop-Python](http://scummos.blogspot.com/2011/06/basic-list-content-type-support-in.html) * [Argument type guessing, advanced list content type support and more](http://scummos.blogspot.com/2011/09/kdev-python-argument-type-guessing.html) * [About Python 3 support in kdev_python](http://scummos.blogspot.com/2011/12/about-python-3-support-in-kdevpython.html) and is [actively developed](https://projects.kde.org/projects/playground/devtools/plugins/kdev-python/activity).
 2. &gt;&gt;&gt; #This is good to glue a large number of strings &gt;&gt;&gt; for chunk in input(): &gt;&gt;&gt; my_string.join(chunk) W-what? Was the person who wrote the example thinking that `join` works like `append`? Bonus WTF points for using `input()`. By the way, CPython includes a specific optimisation for the case where a string being `+=`-assigned is not referenced from anywhere else. I mean, you should still always use `join` or `cStringIO`, but if you see someone else's code that appends stuff like that -- don't freak out. 5. To check membership in general, use the “in” keyword. It is clean and fast. &gt;&gt;&gt; for key in sequence: &gt;&gt;&gt; print “found” WHAT 12. Learn biset module for keeping a list in sorted order: It is a free binary search implementation and a fast insertion tool for sorted sequence. That is, you can use: &gt;&gt;&gt; import biset &gt;&gt;&gt; biset.insort(list, element) "biset"? Really? Also, he used lowercase `true` earlier. The blind leading the blind, that entire post. Apparently, the author collected bits and pieces of advice from somewhere and pasted them together not bothering neither to run the code nor to understand what's actually going on. Pig disgusting.
Here's a project that ported OpenJDK's VM to more platforms (with ARM and PowerPC gaining a JIT): [Zero and Shark](http://icedtea.classpath.org/wiki/ZeroSharkFaq). Here the LLVM JIT (actually a more fine-grained compiler) is used after optimisation passes done in hotspot; LLVM just converts to machine code. 
I have an eee 9" and recently decided to play with different resolutions. I have discovered that as long as I keep the vertical resolution native, I find a wider horizontal resolution actually useful. I move my mouse to the right edge of the screen and reveal more screen. as long as I don't maximize my windows, I use this extra screen real estate for either a buddy list or a tall notepad window. Maybe you can expand your vertical resolution beyond the visible screen to overcome scrolling issues? 
Use the SublimeLinter, SublimeCodeIntel and Djaneiro plugins for code completion etc. If you can't write code without an integrated debugger, stick to PyCharm.
If you're stuck in meetings such that you can play on your iPhone, it's no less rude to just walk out of the room. I know it's what I do.
PyCharm by far
Vim and only vim so help me vim: config - https://github.com/mitechie/pyvim
which ones would be slower in PyPy?
Wouldn't it be better to do this kind of thing with try/except? 
i've found it often much clearer to read throug hthe source for modules and libraries i use rather than fudge through the official documentation. 30 minutes spent reading code (usually) better written than mine saves 1h+ worth of googling.
sed.
Well the topic is Python performance tips, and this one can be a performance impact. Normally it isn't, but it can be and is easy to avoid.
Installing XCode is similar to doing "aptitude install build-essentials" on a Debian based machine. If you are going to compile anything you're gonna need it. I don't think it has anything to do with being a stand alone empire (not that they aren't trying) but more to do with providing a unified development environment. You could build up your own toolchain for making OSX stuff, but that would be a serious pain in the ass.
Yes, although the advantage is slim when the problem does not lend itself to memo-ization (i.e. majority of the inputs are unique). Here's [a test comparing the two strategies][1]. And results on Python 2.7 on my machine: Memo-ization friendly test LBYL [0.07406497001647949, 0.07364988327026367, 0.0758662223815918] EAFP [0.055359840393066406, 0.05534100532531738, 0.05528402328491211] Memo-ization un-friendly test LBYL [0.06378912925720215, 0.05985212326049805, 0.05981802940368652] EAFP [0.04666304588317871, 0.04614996910095215, 0.04834580421447754] I wonder if things change when the container is not a dictionary and lookups are more expensive, or if the dictionary grows over a certain size, or if... [1]: https://gist.github.com/1827083
Oh! Having actually run the tests and looked at the numbers, I see I'm wrong about there being a smaller advantage when you get a lot of KeyError exceptions. ~~In fact, using `try` / `except` is even better than testing for membership when there's a lot of misses.~~
Obviously I have a flaw in my mental model of what's going on. I would guess that calling itertools.ifilter gives me a new object of the type 'generator' and that it does not care about the type of object nor about the method that was used to generate that object, that is given to it as a parameter. The problem is, in vanilla python, my mental model seems to match the reality. Why doesn't it match in pypy? Or more plainly: why do I get a RuntimeError in pypy but not in python when the recursion limit is set to the same value in both?
You are awesome. I really appreciate this.
so virtualenv is kind of like a jail or chroot just for python? That's pretty cool. I can't remember the number of times that I've ran into issues with .NET's global assembly cache and miss-signed packages... looking forward to trying this.
imo, it depends the most on the kind of application you write. eg. in a webapp, that starts once and runs forever, i'd import as much as possible on the initial load and not later when a function is called.
You just *know* she's going to school you with Flying Circus references...
Coding on a tablet? What. The same apps you would use on a desktop, and only if you have a keyboard.
vim Command not found. apt-get install vim installing... vim
Tip Uno: Learn speak the English.
Didn't you hear? PyPy just implemented a Jacquard loom backend for their JIT. It's all the rage.
I think for number 5, the line should be "if key in sequence" rather than "for key in sequence".
This happens because PyPy and CPython have different way of counting the depth. PyPy's count looks at the actual C stack depth, so it includes the frames of things written in C or RPython. CPython's does not. As a result if you run this script under CPython, it segfaults, because there are no Python frames to trigger the counter, but under PyPy it gives a RecursionError: http://paste.pocoo.org/show/550876/
http://stackoverflow.com/questions/3815359/while-1-vs-for-whiletrue-why-is-there-a-difference
CPython is buggy. If you run the CPython one high enough, it will crash.
I use TextMate.
In general, on Linux you've got everything you need for a basic python environment. With a distribution like Linux Mint, you don't actually have to use pip/easy_install very often most libraries are packaged and provided by the distro. Something as simple as sudo apt-get &lt;your library&gt; works in most cases. In terms of a coding environment, I use eclipse + pydev. Once you've got the IDE and plugin installed, you just point it at your distro's interpreter and you will be up and running with code formatting, highlighting, and intellisense (not nearly as good as what VS gives you though). This combination gives you something very close to the solution -&gt; project paradigm you're used to. 
&gt; In general, on Linux you've got everything you need for a basic python environment. With a distribution like Linux mint, you don't actually have to use pip/easy_install very often most libraries are packaged and provided by the distro. Something as simple as sudo apt-get &lt;your library&gt; works in most cases. I think that I will go with virtualenv+pip for portability's sake. &gt; In terms of a coding environment, I use eclipse + pydev. Once you've got the IDE and plugin installed, you just point it at your distro's interpreter and you will be up and running with code formatting, highlighting, and intellisense (not nearly as good as what VS gives you though). This combination gives you something very close to the solution -&gt; project paradigm you're used to. Currently, I have my eye on ninja-ide. Partly out of spite for eclipse, partly because it has integrated virtualenv support. http://ninja-ide.org/features/ It also has code completion and refactoring, in addition to project file support. Can anybody speak to the effectiveness of ninja-ide? (I'm at work right now :p)
Have you tried python tools for visual studio? http://pytools.codeplex.com/
Me too. Perhaps my test is wrong?
Real question: Why the spite for eclipse? I find that there's a lot of hate for it and I'm not sure where it comes from because it's always treated me really well. That said, Ninja IDE does look really neat.
I'm not sure exactly, but it could be clarified by minifying kingkilr's paste. It seems to create ifilter generators, apparently those are associated with interpreter stack frames. Edit: calling x.next() seems to call the generators recursively. The stack frames don't exist outside of a next call.
your test is wrong, you need to invalidate the cache in between each call inside of the timeit. Every one of the timeit inner runs except the first has a fully filled cache.
Because my brain is wired for Visual Studio :( I actually prefer net-beans to eclipse when working on Java projects. It also has it's own way of doing everything, and I feel like it's intensely resource heavy for no reason at all.
No, I'm wrong about being wrong. Not certain that makes me right though. My test was not flushing the cache between the first and the second data sets, so the supposedly memo-ization un-friendly test was in fact using a nice warm cache every time. With that fixed, try/except is indeed noticeably slower than if/in when there are mostly cache misses. 
The key benefit from Amon is that you can push errors from your webapps to it. However, you'll loose the ability to log everything you're currently logging in munin. And you can't log a lot of webapps without paying for the upgrade. If you're running a lot of webapps that require exception logging you've probably already centralised the logging of exceptions, so it's probably not worth it. Initially interested but I'll be sticking with munin+monit+supervisord+superlance for a while yet.
I found the "while True" vs "while 1" both interesting and improbable, so I ran a quick test (code is here: https://gist.github.com/1828270). Turns out that the author is right -- while True is always slower -- but in Python 3, the difference is minor enough to be negligible, and in PyPy it's all so fast it doesn't matter. Results: while True while 1 pypy 1.7.0: 0.0733 0.0201 cpython 2.7.1 0.146 0.109 cpython 3.2.2 2.79 2.72 Edit: I see now that pingveno posted an explanation of why this is true (heh) in [his comment below](http://www.reddit.com/r/Python/comments/pou99/python_performance_tips_part_1/c3r2dj2)
[My results conflict with your results.](http://www.reddit.com/r/Python/comments/pou99/python_performance_tips_part_1/c3r5ot1)
No. It's just another python install with a glorified $PATH alteration script (activate shell script) that you can also use. On the plus side you can change your environment variables in different virtualenvs inside the activate script. For instance I can have one for testing which has credentials for a test database. This is very useful for developing with services like Heroku which encourage and automate environment variables for third party services.
As long as posting every article you come across puts little internet points in your bank, people will do it.
1) You shouldn't ... 2.7 is more than enough for learning 2) I don't think you need virtualenv no either ... you won't use different versions of libraries and similar weird stuff which happens when developing professionally 3) setup.py is what you want to learn and only when you need to publish on PyPI 5) without flaming anybody C#/Java/C++ are more heavy than Python (it might be good sometimes) so basically whole building part (Makefile, scons, etc.) is not needed at all
Not that this excuses the original posts, but sometimes the thread as a whole can be informative and worthy of upvotes. For example, I intend to read the comments on the performance thread because of reading this. I usually read the comments from the hive before the blog itself anyway. :)
&gt; Depending on the size of each project, different abstractions and separations are needed. In a small project a config can be a simple global variable. In a medium size project it might be an ini file, and in a large project it might be a database entity. Here you have that choice and can follow a specific convention or not. There is a huge penalty in maintainability to removing context out into separate files. There is a huge penalty in terms of using any other paradigm when a particular one is forced on you. I really really don't mean to be rude, I just feel like I'm being handled with kid gloves, when I've been writing software for over 10 years now. In large projects, being able to break up the code into multiple files does several things. 1) Separation of concern. The biggest example is probably with any model view controller pattern. Each concern should get it's own package, each class should get it's own file. 2) Separation of responsibility. Working cooperatively with multiple people means sharing code and planning out the project to a degree. Most VCS's will let you lock only files, not specific methods. A problem might arise when you have multiple classes in a single file that are completely unrelated. You need to make changes to one method, your friend needs to change another, and when you try to merge the changes, it breaks because your lines merge into one another. Yikes!
[Eric](http://eric-ide.python-projects.org/). 
Upvotes for useful discussion...thanks to r/python, not the bloggers.
[IdleX](http://idlex.sourceforge.net) - it offers extensions that are useful for interactive computing, notably the ability to execute select parts of code from the editor. This is useful for prototyping scripts. 
Looks like a young John Lydon. I approve.
There's a slight difference, but it is indeed dwarfed by anything else. I was able to measure some difference with this code: def while1(): i = 0 a = 0 while 1: a = 4 i += 1 if i &gt; 100000: break For while True, I simply replaced 1 with True. The results in IPython were %timeit -r200 -n2 whileTrue() 2 loops, best of 200: 13.2 ms per loop %timeit -r200 -n2 while1() 2 loops, best of 200: 9.33 ms per loop Conclusion: The difference could only be vaguely significant in extreme conditions. If you run into one of those conditions, just rewrite in Cython.
Well the twisted [bug](http://twistedmatrix.com/trac/ticket/3014) is opened for more than 4 years. More than 2 years ago, I asked about IPv6 support on the IRC channel, I've been told something like "who cares about IPv6"
Clearly not you, since you apparently didn't fix the bug! :)
Well, it's more than I don't care that much about twisted :p
&gt; Well the twisted [1] bug is opened for more than 4 years. This doesn't mean all that much. Without code from the reporter or a person interested in writing the code, a bug report is just another entry in a database. It's an important entry, don't get me wrong, but without effort tied to it they can sit there forever and that's just business. In CPython there is a patch for a function `which` (to be added to `shutil`) on an issue that has been open for 10 years with a patch throughout that entire time. Unfortunately the patch slipped through the cracks, missed release deadlines, went untouched for a while, then it recently gained more activity. Hopefully it's ready and in a quality state for 3.3. If not, maybe 3.4 will be the time.
And why does this produce C stack frames?
I would expect it to have something to do with True and False being assignable globals in Python 2.x where as 1 isn't, hence the extra overhead of a lookup. I would wager both cases would run at much closer speeds in Python 3. Also it really shouldn't matter in the real world. &gt;&gt;&gt; True = False &gt;&gt;&gt; 1 = 2 File "&lt;stdin&gt;", line 1 SyntaxError: can't assign to literal
"while 1:" requires an implicit conversion of a numeric type to a boolean type before evaluating the while expression. Keep in mind that if you're running in an interprative mode (i.e. not compiled and/or optimized) it must perform this evaluation every iteration. Even if it only took a single additional machine instruction to make the conversion (it clearly takes more than that) the extra sliver of time will add up over a long enough period of time.
What's wrong with it?
Can someone explain to me what the point of PyPy is? I understand that a JIT compiler is supposed to be more performant than just interpreting (a la CPython), but isn't PyPy generally slower than CPython?
That is ridiculously fast. And cool. And thanks!
If you don't mind paying (in the end), you can try out [Pycharm](http://www.jetbrains.com/pycharm/), by the same people who created Resharper.
&gt; How would you explain that performance difference? Not worth thinking about, but anyway, as Rhomboid mentions it's not a valid test.
Oh, way cool. It blows my mind that such a thing is even possible. I'd love to see PyPy in py3k, I'll make a donation when I get home :)
It replaces stuff like "more performant" with "faster".
&gt; http://ninja-ide.org/features/ &gt; It also has code completion and refactoring, in addition to project file support. I really wonder if I should bother checking it out. I'm somewhat past the point of using anything but emacs and packages for that ;/
Constant time algorithms are often 'simple' rather than 'fast.' Not that there is no interesting constant time code, most stuff is constant time in the grand scheme of things, but think: get_first_item_in_list(foo) is O(1) because you always do the same amount of work to read the first item from an array. get_max_item_in_list(foo) is O(n) beacuse you need to check each item in the list and then perform an O(1) comparison to see if it is larger than your current maximum. Sorting lists is &gt; than O(n) because one glance at each item isn't enough to know where it belongs relative to each other item in the list. The exciting part is finding ways to lower the complexity of something. For example, finding the max element in a sorted list is O(1) not O(n) because you know that it is the first/last element. 
In the default view, if a thread gets downvoted a lot, people don't see it.
I feel like this isn't adding a new type, this is just adding a new name to the builtin module dict.
Yeah... good luck making git work behind a restricting, HTTPS inspecting, somewhat mismanaged firewall. Actually, if you *could* make it work, I could sure use your help... :(
Agreed. If changing `while 1` to `while True` could possibly make a significant impact on the execution time of your program, you shouldn't have been writing it in Python to begin with. Style-wise, `while 1` is faster to type and more "old school" (originally, Python didn't have `bool`s, just 0 and 1). `while True` is more modern and clearer to people aren't used to Python conventions. I lean towards `while True`.
You shouldn't be chatting up PyPI in packages. Any dependency resolution should be taken care of by the distro-specific package management tool. Distro specific packaging is definitely the way to go. Setup a local mirror on the network or through VPN to install the package. Add your repo to the sources.lst. Have the necessary dependencies wget'd on the repo as well. Though now you'll be targetting a specific install, in which case you can distribute binaries for any compiled code. Intranet repos are common. Updating later is a breeze, as is dealing with dependencies. The only issue now is that if you're dealing with different distros or releases is that you'll have to create different packages, and host different repos. This approach also guarantees consistency in which version of the dependencies the client installs. If it is over the Internet you can let the standard repos hand out the deps. You can package the dependencies together with the script. If you're going to make use of a library in some code you distribute, you might consider just how necessary that library is and if it is actively updated. Releasing code to the public and scripting for personal little tasks are two entirely different ballgames. As someone dealing in system administration you probably know this.
Thanks for your reply. We do have package repositories for various operating systems that mirror the official repositories. The trouble that I have with this approach is that I cannot have an isolated virtualenv play together with system packages, and a lot of modules simply aren't available for the operating systems that I'm targeting (e.g. Solaris), so this would require a lot of custom packaging. Although I can see the value of your arguments, I think I'll experiment with setting up a local PyPI mirror and rely on operating system packages whenever binary packages are needed (to get around compiling at install time).
Ok, I got it ! Thank you very much :)
From the title, I imagined the post to be much more... dramatic!
If it wasn't an heterogenous environment, I'd recommend something like stdeb (Debian &amp; derivatives) to mass-build native packages.
Good stuff there, thanks.
[this is a good link](http://m.youtube.com/index?desktop_uri=%2F&amp;gl=US#/watch?v=YW8jtSOTRAU)
Just run your script file? That's what I do, and frankly I don't quite understand what's the point of REPL. Running the script is the same thing except that you don't risk having stale data/definitions, and using a proper editor means that you can change anything anywhere, undo stuff, copy-paste and block-comment stuff, etc. If the script begins to take more than a fraction of a second to run then using `pickle` is stupid easy and also forces me to make my stuff more modular and testable (also, explicitly marks the points where data/code can get stale).
Write tests. REPL is for experimentation, not testing real code.
Copy + Paste from source code to the console is a bad (matlab) habit. Everyone does this from time to time, but there are more issue than indentation. Better make your few lines a function. Then, you can call the same function from a test program and your real program. (Test program here may mean simple script that does nothing but call said function or unit test.)
 def set_pdb_hook(): def info(type, value, tb): import traceback, pdb traceback.print_exception(type, value, tb) pdb.pm() sys.excepthook = info 
I either run that iteration with everything else commented out or a strategically placed `sys.exit()`, or copy it into a tab with `test.py` open and run it there. I don't quite understand where the interpreter might come in. Does your editor not support executing the current file with a single keypress?
Thanks for the feedback. Maybe I'll write my own spec and post it for public opinion. &gt; I think your initial commas are ugly and inconsistent. Trailing commas make all the items look identical, which aids maintenance. I thought so too at first, but it was convention on some tiling WM I was using in Linux at the time. Then I started doing it in SQL and it helped a lot... and it stuck.
I'm really only replying so I can check out tagbar and pep8 plugin later, so thanks for the pointers :)
Although this doesn't help the virtualenv situation out at all, installing from MacPorts worked perfectly fine for me on a new Lion install. "sudo port install py27-game" gave me a working pygame 1.9.1 i agree about the pip installation method for pygame, it is quite bothersome. I've managed to get it working through pip if I already have all the development headers needed for pygame to compile installed, for the most part this is SDL.
You also don't care about security and resilience, which I think most people care about.
In general, the linked list data structure (which is applicable to any programming language) is extremely efficient for insertion and traversal; however, the overhead for defining node objects would likely outweigh the penalty of combining the three strings together.
My guess is that you should translate the strings into lists, then call `insert` on the lists. You should be able to do this pretty quickly: a = list(a) # creates a list out of a string a.insert(2, 'a') # inserts into the list a = ''.join(a) # joins the list together again It's not perfect, and it's probably not fast, but it'll do. Of course, you could just keep the string in list form normally, and translate it to a string ONLY when it's needed for display somewhere. It shocks me that `insert` can't be called on a string. I don't get that. Does anyone know why they're immutable?
You might want to take a look at [ropes](http://en.wikipedia.org/wiki/Rope_(computer_science\)). I think it fits your use case very well.
I don't think that will be very fast. Python lists are actually stored as arrays, so inserting an item forces every item after it to move one position.
Thanks! It kinda occurred to me, but then there are times when you just need to test a few extra lines of code, and running the entire function seems inefficient. In octave, I would save the state up-to which code was tested, and load it each time I wanted to test some new extra lines.
When IT security blocks my business processes I make heads roll. Stand up or run out. The movers and shakers are the ones that move up.
Thanks! But that's a lot more keystrokes. With selecting the entire line, its just Shift-V (from any point within the line), and j's. With Ctrl-V, you have to move to the start of the code on the line, hit Ctrl-V, $, and j's. If you know a faster method, let me know.
I believe it's an array of pointers - the actual members won't be moved around, but the pointers stored in the list will be.
Everything is indirected like this (`PyObject*`) - it's necessary for heterogeneity to work.
[IdleX](http://idlex.sourceforge.net) handles this case. You might also be interested in SubCodes which allows you to execute pieces of your code from the editor with Ctrl+Enter or you can highlight code and press F9 to run it. 
I would love to do a complete comparison of puppet, chef, bcfg2. I think it is a huge task because understanding each would require setting up test servers. And since most of these run in client server mode, that is a fair amount of work. I would also add [blueprint](http://devstructure.github.com/blueprint/) to the comparison. In fact, that's partly the point of this. I want a document that catalogues my policy today in english such that any change in configuration management should make these tests pass. Any day to day work with the config management system should not change the tests to failing. Some people have been doing something [very similar to this with puppet](http://holmwood.id.au/~lindsay/2009/11/09/behaviour-driven-infrastructure-through-cucumber/). But I actually have an organisation with existing fabric scripts, so I wanted to test out whether I could hook into them using lettuce. 
Saying that linked lists are "extremely efficient" for random insertion like the OP needs isn't really true, it's O(n) for insertion. Something like a skiplist or a tree is better at that. sushibowl nailed with ropes.
String concatenation, from what I've heard.
This is quite possibly the best introduction to big O notation I've seen, Thanks.
Everything that you mention is more or less the same trouble. Whe one needs to test a specific iteration of a loop it's often because the loop crashes right there, so one needs to set up some conditions. Starting a new interpreter session from the editor every time is usually not the best solution because of the overhead involved. For instance, I may have loaded a million lines file in a variable, I don't want to load that again every time, no matter how many keys I have to press. 
Before pasting, type if True: and then paste, which results in &gt;&gt;&gt; if True: ... &lt;your indented, pasted code&gt; ... &lt;next line&gt; Because of the if-block, the indentation is expected and the code will work as you expect it to. It's not /very/ convenient, but it works.
Actually, I didn't know about the __ nonzero__ method, so thanks for that. This means my reasoning isn't quite spot on. I still think there's got to be some sort of extra instructions going on somewhere at the bytecode implementation level, and could simply be an order of operations thing that looks something like this in order to short-circuit when possible: if (arg = True or arg.__ nonzero__() = True) doTrue(); else doFalse(); Again, it'd all be dependent upon the specific bytecode implementation, but short-circuiting a function call in this way *may* account for the marginal yet consistent results that OP is seeing.
Thanks for the suggestion - IdleX is new to me so I'll definitely check it out!
I don't think I've ever seen a ropes implementation as a proper extension module (implementing it in pure Python is pointless, as it would suck against using plain strings until you get to tens if not hundreds of thousands of characters). If you want a list with efficient random insertion, take a look at [blist](http://pypi.python.org/pypi/blist/). It's basically a rope, but also implemented with respect to realities of modern hardware (inserting an item in the middle of an 128 byte long array is MUCH faster than jumping all around the memory rebalancing your tree). But there's a huge problem with storing characters in a blist: instead of taking one byte per character, each character takes 16 bytes in the heap and 4 bytes in the blist (on x64 it's even worse). 20x increase in memory pressure is not something you should take on lightly. This fully applies to storing characters in usual arrays as well, of course. So I would guess that the wisest approach to your problem is to store a list of lines, as strings. Assuming that most lines are short enough, you'll have quite a nice problem-oriented data structure with that. Using `array` module for your strings can speed up things even further -- no need for creating extra copies for each insertion, at the least. And moving data in memory is fast.
So they do - I stand corrected. I'd thought they preserved the O(1) internal access of python lists, but I must be mixing them up with something else.
 from collections import OrderedDict def sorted_dict(source): l = sorted(source.items(), key = lambda item: item[1]['name']) return OrderedDict(l) 
You want to use the `key` parameter of the sort function, like this: &gt;&gt;&gt; foo = { '22': {'name': 'aaa', 'version': '1.1', 'date': '2012-02-15'}, ... '65': {'name': 'bbb', 'version': '1.4', 'date': '2012-02-15'}, ... '23': {'name': 'ccc', 'version': '2.0', 'date': '2012-02-15'}, ... '81': {'name': 'ddd', 'version': '1.3.2', 'date': '2012-02-15'}, ... '19': {'name': 'eee', 'version': '1.2', 'date': '2012-02-15'} } &gt;&gt;&gt; for id,data in ((y,foo[y]) for y in sorted(foo, key=lambda x: foo[x]['name'])): ... print "name: %s, version %s, ID %s" % (data['name'], data['version'], id) ... name: aaa, version 1.1, ID 22 name: bbb, version 1.4, ID 65 name: ccc, version 2.0, ID 23 name: ddd, version 1.3.2, ID 81 name: eee, version 1.2, ID 19 There's probably a slightly more efficient method to do that.
You're welcome, I'm glad it helped! Big O notation is one way to measure the relationship between the size of the input to an algorithm and how long it takes to run. Specifically the 'O' means this function specifies the upper bound on how long something will take, i.e. "f(n) is no slower than O(something)". There is also notation for "no faster than Ω(something)" and "no slower than or faster than θ(something)." All of this stuff is collectively referred to as Time Complexity. You can also measure the Space Complexity and Computability (i.e. 'How simple of a system can compute the answer to a given question?'). All of this stuff collectively forms what I'd call the basics of theoretical computer science: it's just the bare bones theory needed to describe different problems, how easy or hard they are to solve, and what resources are needed to solve them. I highly recommend digging into this, possibily difficult, subject matter. When I finally got this stuff through my head, it permanently changed the way I understand programming, computers, and a lot of seemingly unrelated stuff like card games or a city full of people trying to take a cab somewhere. That said, it takes some scholarly dilligence to soak up all the information needed to understand this stuff: http://www.youtube.com/watch?v=pe250F4ttmE This is part of a series, and you can pretty much follow Related Videos and search for Time Complexity or Big O Notation on youtube to your heart's content. For these MIT links see the lecture notes and look for slides on Complexity theory/Complexity if you want to get directly to the Big O Notation bits. Since they're offering lecture slides here, I'd go back and forth between these two course on each topic you want to read since combined they might be a little clearer. http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-080-great-ideas-in-theoretical-computer-science-spring-2008/ http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-045j-automata-computability-and-complexity-spring-2011/ The only books I've ever read on the topic are text books, and you can pretty much just pick your favorite computer science school, and take the book recommended in the syllabus of their Computability &amp; Complexity course. They'll all be pretty expensive, so you might do better searching for a cheaper book on your own than looking for whichever text I happened to use in grad school. 
...but it is, and it is perhaps *the* defining feature of the language, and it has been like that for over 20 years. If this is that big of a deal then maybe Python is not a good match for you.
That depends on the developer.
Ah, you are a fellow Vim user! First of all consider [ipython-vim](https://github.com/ivanov/vim-ipython)! It does everything you want, and much more! Second, I personally never used that, because I discovered the joys of `makeprg`. [This is the most relevant part of my .vimrc](https://bitbucket.org/fj_/configs/src/e55b09e1df60/_vimrc#cl-186). You'd also want to compile [this](https://bitbucket.org/fj_/configs/src/e55b09e1df60/filter_python_exceptions.cpp) and put it into `~/bin` or something. What it does: Vim doesn't have a proper built-in console, so running external programs sucks hard. _Unless_ you run 'em via `:make`, using a custom `makeprg`, then the output is directed to the quickfix window, which is a proper Vim window, with all the pleasant consequences. It's works not only for Python, but for shell scripts etc. My C++ thingie also parses the output and converts parts of it that look like tracebacks into something that Vim understands, so you can jump through the locations! Except it seems that I forgot to push the latest version where I also recognize exception messages as printed by doctest, so if the IPython integration doesn't work for you and you are interested in this hack, let me know and I'll PM you after I push it tomorrow.
I don't get what defaultdict is doing for you here. Did you mean [`OrderedDict`][1]? [1]: http://docs.python.org/library/collections.html#collections.OrderedDict
Thanks guys. I'm going to try this. Lambda functions - the syntax I never remember.
Too many keystrokes?! Map 'em! You could do \\1 and \\2: :map &lt;leader&gt;1 V}&lt; :map &lt;leader&gt;2 V}&gt; EDIT: plus your clipboard needs, like `V}"+y` or whatever
Good question! [Rope](http://rope.sourceforge.net/ropevim.html). Though I have to say; I've not needed to do much refactoring in my Python coding. At the same time, Resharper is a godsend for my dayjob ;)
In about a week, you'll pause, exhale and sigh. Happily. If you have any familiarity with the C family, you'll have no problem with the syntax. The only kool-aid you'll have to swallow (coming from Perl) is the mandatory indenting. It shouldn't piss you off too bad. You got the same data structures (dict/hash, list/array, etc.) and similar ways of operating on them (list comprehensions are fun) Not being from C++/Java you shouldn't have to get over the whole Classes everywhere thing and just write some script. Python modules work a lot like Perl modules - namespaces and all that. Regex's aren't ubiquitous but they're in there if you need them for chewing on data. My suggestion is take a small thing you've done in Perl and transliterate it. Perl and Python really aren't all that different. Other than not looking like each other. Welcome to a better way. 
To emphasize the regexp thing: every time you reach for regexp, stop and look at the string methods first, just to see. One of the biggest habits to break for us was that `if $foo ~= /.jpg$/` did *not* translate to `if re.match(r".jpg$", foo)` but instead, more simply and idiomatically, to `if foo.endswith(".jpg")`. Also, semicolons at the end of the line - harmless, but everyone will see them and say "you were a perl programmer, weren't you" :-) (`pylint` will remind you of this with `[W] Unnecessary semicolon`.) One unexpected thing: when stuff fails, you'll (typically) get an exception, instead of `undef`. After we got past basic syntax, that was the Best Thing Ever from the perspective of porting a large perl+shell codebase...
Exquisite. I actually started hacking together something just like this a year ago and wound up not having enough time to finish it so I just used CouchDB running on localhost. I especially love how tiny the code is... Kudos.
I didn't know, or forgot, that. Thanks.
You are wrong. I do care about security and resilience above all. 
&gt; Indentation / whitespace should not be the deciding factor in a language. I was like you for the longest time having come from the world of C++/Java; until recently. Lately I have grown fond of the indentation. It is a wonderful encoding for regions where otherwise you have those lossy '{' -- you will indent code there too for clarity -- and that's the sole purpose of those braces. As far as files messing up in transit, it is no longer a big issue with modern computers with most systems and editors dealing with it automatically -- many common editors even fix up the indentation. A nice side-effect is that it compels you to keep your code short and clean --- and I suspect that is the real pythonic motivation there. Keep it simple, self-readable, and succinct. It works! Give it an unprejudiced try sometime!
Sit back and enjoy a better world.
Yeah, I live in Greece, so there aren't that many jobs... :(
This, is precisely the problem I face. I'll look into pickle.
I am a sysadmin, and made the same switch a while back. I am happier for it. My advice, read Pep8 early and follow it as best you can. Here is some code I would have killed for early on: In perl interacting with the shell is easy, in python it's like pulling teeth (imo). perl: @var = system 'ls -la' foreach $line (@var) { print $line; } python: import subprocess cmd = '/bin/ls -la' p = subprocess.Popen(cmd.split(), shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) p.wait() for line in p.stdout: print line Have fun with python.
I would highly suggest reading and working through [Learn Python the Hard Way](http://learnpythonthehardway.org/) by Zed Shaw. It forces you to actually learn Python and I found it was a great way to get people up to speed in Python (I taught my girlfriend with it).
You need to change your `lambda` to match. sorted_dict = sorted(foo.items(), key=lambda (k, v): v['name'])
Not the same thing. os.system's return value is the exit status of the process, not the output of the executed process.
 The docs may mention `easy_install` as your path to PyCPAN, that is incorrect, use `pip`. Threading in Python is .... questionable. Where possible, use `multiprocessing`, yes it invokes another Python interpreter, but it's straight forward, search for Global Interpreter Lock (or GIL) to see why threading is chock full of obscure gotchas that will bite you on the home straight of your project. Want to `popen()` something? Use `subprocess`. It's not perfect, but there are soooo many dragons hiding in popen, popen2, popen3, popen4.... I'm not even joking about the 4 popens. Python and Perl are both in the C family of languages, and amusingly, they're both about as far outside of the usual territory as it can get, in opposite directions. Regardless, it's all rather straight forward. You can use semicolons in Python, they have the same meaning as in every other C language, but don't, we will hunt you down. Code like you're `use`ing `strict;` and you'll be fine. Actually, on that note, many guides will say you can... print "this is some text" Please do this instead.. print("this is some text") It'll help for Python3, which unlike Perl6 actually is here, although you wouldn't really notice it. Last but not least, `virtualenv` is good for having multiple versions of things side by side. In a perfect world, we'd all be running current stuff, but we all know that will never happen in reality. To the folks hating on Perl, **STOP IT**. The Perl folks know their shit. Guido is an artist, he knows pretty. Larry Wall is a programmer, he knows performance, and other beardy shit like that. Perl may be one of the uglier languages out there, but it's got every modern paradigm, usually a decade before it gets popular. Feel free to hate on the Ruby folks, but the Perl folks are good. We want them on our side.
Looks like that's a bit more heavyweight than goatfish, plus it seems to be written in C and python bindings are an extra package. Goatfish is written in pure Python in 88 SLOC (!), so it's a lot more lightweight and can easily be embedded in your app. But then, I don't know how they compare performance-wise. Goatfish just looks a lot easier to deploy.
Prepare to fall in love
Turn back now. Nah, just kidding. I'm using more and more python these days and enjoying it. However, most people with a strong grasp of perl aren't as "yay!" about Python as some of the people in this thread. It's a strict language. A little harder to fire a machinegun at your foot, but there's a lot fewer machinegun controls all around. Kinda good balance between the raw rulebreaking power of Perl, and the strictness of a .NET. The best thing I can suggest is not to touch any other language until you consider yourself proficient at python.
You're making it harder than it needs to be. Try [check_output](http://docs.python.org/library/subprocess#subprocess.check_output): stdout = subprocess.check_output("ls -la", shell=True)
In Perl, you could just use open() to open a pipe to/from a process. The system() example you give doesn't do what you think it does. Or you can use \`backticks\` but that's scary.
It is five years since I left my Perl job, and I still find myself typing "return x if...", or "unless ..." But that's mainly because the languages are so similar. 
Learn iterators, generators, and list comprehensions. As a Perl developer, these are the things I miss from Python. On the other hand, the things I miss from Perl when writing Python are too numerous to note :) You will find urllib and urllib2 extremely lacking compared to LWP, btw. That and Java-inspired unit testing are the most difficult things for me to go back to in Python after switching to Perl (I started as a Python dev, then got a job as a Perl dev). 
Subprocesses are indeed a pain point in python. Luckily there are some nice libraries that make it way easier. My favorite is Envoy: https://github.com/kennethreitz/envoy
Assuming you used Perl for misc Unix tasks, this should get you to parity quickly: learn to use the standard types (str/unicode, list, dict, set…); thanks to object-orientation, you can learn most of their features from [IPython](http://ipython.org/)'s tab-completion and ?-documentation. Learn to use important modules like [subprocess](http://docs.python.org/library/subprocess), [argparse](http://docs.python.org/library/argparse), [re](http://docs.python.org/library/re), [tempfile](http://docs.python.org/library/tempfile)… Other things you need are available either in the [standard library](http://docs.python.org/library/) or on [PyPI](https://pypi.python.org/pypi). The most established modules are already in your distribution, to go beyond those use [pip](http://pip-installer.org/) and virtualenv. pep8 and pyflakes are useful tools to learn good style. Use /r/learnpython or [stackoverflow](http://stackoverflow.com/) for asking questions.
I think the best example of how switched on the Perl folks are, is that Perl was in web development before "web development" was a term. There's a lot to be learnt from them.
`return 'a' if False else 'b'` works just fine in Python ... or am I misunderstanding you? I guess further testing shows it does require an `else` clause, but how else would it be done (assuming good practice)? Admittedly I never learned/got into Perl.
If there is a good reply on Stack Overflow, that is usually in the Google response. I find simple function name and usage search will pop up more Python docs. When the query is longer or stranger, I get a higher ranked Stack return.
Full Disclosure: I wrote this book I was in the same boat as you 12 years ago, and moved from Perl To Python and haven't looked back. There are lots of options, Google, SO, books, etc. My book [Treading on Python](http://hairysun.com/books/tread) is meant to give people who know how to program a quick introduction to the basics of Python while illustrating tips, best practices and warts along the way. It is meant to get you there quickly and is based on my experience teaching Python to co-workers, and tutorial sessions at PyCON and OSCON. If you have Amazon Prime it is currently on the Kindle Select program so you can get it free. Sadly, this limits digital distribution to Amazon platforms (yes they have a web-based Kindle reader). I'm working on getting a dead tree version up soon, because there have been a few requests. 
Python's isn't really an if statement there, it's a ternary construct. x if condition else y Is the equivalent of condition ? x : y in languages like C and Perl. It's an expression, not a statement, and you can only combine expressions with it (in Python).
&gt; One unexpected thing: when stuff fails, you'll (typically) get an exception, instead of undef. After we got past basic syntax, that was the Best Thing Ever from the perspective of porting a large perl+shell codebase... Hey, perl has [autodie](http://search.cpan.org/perldoc?autodie) now! (for supported stdlib modules)
Makes more sense now, thanks for the clarification.
Proceed with all due alacrity.
Oh.... sorry I always assume America where jobs are plenty &gt;.&lt;
&gt; In about a week, you'll pause, exhale and sigh. Happily. It's been seven months and I haven't sighed happily yet. Probably mostly due to python 2.5, there was a solid month where I found something in python 3 that was nice...
Yes, I definitely agree that these features belong being taught together. In combination they're a really useful tool. For generator expressions, I heartily recommend [Generator Tricks for Systems Programmers](http://www.dabeaz.com/generators/) by Dave Beazley. At least the first half should be useful for anyone programming in Python.
I made the jump about a decade ago. python syntax will frustrate you for a couple of days, then you'll never notice it. Get your editor of choice to handle the indention for you and you will rarely think of white space. Check out the [python_koans](https://bitbucket.org/gregmalcolm/python_koans/wiki/Home) project. Really great way for a seasoned programmer to learn a new language. Spend a few days on them and you'll have seen much of what qualifies as a idiomatic python. 
Celebrate!
PythonTidy exists. I haven't used it in a while, though, so I don't know if it has every option you want yet.
Write to be clear and obvious, not clever. Learn the builtin functions by heart. This is not as hard as it sounds. Learn the builtin modules in passing; know that they're there and where to look for docs.
This is correct.
Judging by your name, I'm guessing you work at Udacity? Is this course intended for the absolute beginner? If so, how much time will be spent on the basics of programming, as opposed to the building of the search engine? I really loved the AI-Class by Sebastian Thrun, but I'm not sure if the same approach will work with those that haven't programmed before.
This worked great! I don't think I gained much speed for using it, but t is definitely easier to read now. I ended up with a list of namedtuples, and then had sorted based on the key. It did what I needed, so I'm pleased.
&gt;It'll help for Python3, which unlike Perl6 actually is here, although you wouldn't really notice it. That's pretty funny. . . I haven't even tried Python3 yet.
I'm using pandas - it's a really excellent tool for working with tabular data. At present, R still beats Python on statistical stuff. There's [scikits.statsmodels](http://pypi.python.org/pypi/scikits.statsmodels), but it's not yet easy enough to use.
... that's almost cool. Almost, because "autodie has lexical scope" and a big benefit of exceptions is that they bubble up everywhere...
That may be, but it's been the default version in Arch for [a year and a half](http://www.archlinux.org/news/python-is-now-python-3/), and others have been following. It's a slow progression, sure, but it's a progression that's happening.
I have read it, in fact I have a copy right next to me :). List comprehensions are essentially identical to map: my @result = map { foo($_) } @bar; Is equivalent to: result = [foo(x) for x in bar] Generators are basically syntactic sugar for a lazily evaluated list expression. Taking the example above: result = (foo(x) for x in bar) ...would cause foo(x) to only be evaluated as each element in the "list" is accessed. You can also do this from a function: def generate(): for x in bar: yield foo(x) The yield keyword causes the function to act as a generator, which can be called in a loop to access foo(x) in bar over and over: gen = generator() for item in gen(): do_stuff_with(item)
Personally, I recommend using virtualenv for everything because it makes life much easier. When you get virtualenv installed, you get pip for free. I don't install any packages in my global python packages and just keep everything in a "main" virtualenv. 
Have you seen [Cuisine](https://github.com/sebastien/cuisine)? It's a Chef inspired module that sits on top of fabric.
Excellent package: I use it all the time, contributed a few patches even. The only downsides are in its main page, which is full of FUD: you can use R all much you want in commercial entities, you cannot *modify* R (or libR) without complying the GPL.
I'm completely aware of that. I was just trying to make a better version.
How is your version better? It wastes time doing unnecessary splitting and stripping. That's worse.
You can close-source R code that runs on the R interpreter (because the interpreter itself just... interprets). So you would be able to create routines in R... the problem is when you link to libR. P.S.: Also other statements in that page are over the top, like calling C++ "low productivity language", a subjective term.
I said 'trying' for a reason :) I was trying to make it handle commas and words containing 'pypy' correctly, but I now realise you'll never see words containing 'pypy' other than PyPy, and hence the commas thing is also redundant.
so, honest question, is [Revolution R](http://www.revolutionanalytics.com/products/revolution-enterprise.php) open source, or how do they get around that?
I pointed it out because I couldn't think of any inputs where your version would make a difference.
&gt;PyPy is definitely faster than any language remotely like python. And the toolchain behind PyPy can be used to implement all of those languages too.
`append()` appends an item, like Perl `push()`. `extend()` appends several items in a list; I'm going to guess that Perl's `push()` does either according to scalar/list context. There is no equivalent to `unshift()` because that's an inefficient operation that isn't how lists should normally be used. If you need that sort of thing, check out `collections.deque`. `slice()`'s utility is achieved by actually slicing the list with indices. Nice and simple. Although really, most of the time you should be trying to take a more FP approach to processing your lists.
I feel like I'm in some backwards dimension here. Perl is a bletcherous mess that I abandoned for Python years and years ago, never once tempted to look back. Ruby looks like a perfectly sane language and a viable alternative to Python.
http://www.reddit.com/r/Python/comments/psd0x/pypy_py3k_status_update/c3ryvb
But that division between applications and statistics packages is partly because statistics is often done with specific tools - like R or matlab - that you can't easily integrate into an application. Doing it in Python makes it possible to hook it up to wider code. Wes - the primary author of pandas - has a background in quantitative finance. I can easily imagine there are people in that world willing to pay for code that does specialised data crunching.
adding another resource to the pile: [MIT introduction to algorithms]( http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/)
Thank you..one of the tutorials I used at the beginning was actually an MIT class back in the day..so this is right up my ally. I love actually having a lecture. OCW fucking rocks.
FYI I'm the sole downvoter since this contributed nothing and kicked off the disaster below.
I think the "disaster" was actually a good learning experience. 
Can you go into a bit more specifics about how you're using it in your reporting? I'm a heavy SQL user, but have been looking for reasons and ways to incorporate Python in my work.
I wrote a Python gap buffer class that can be used for strings: http://code.google.com/p/gapbuffer/ Gap buffers are explained at https://en.wikipedia.org/wiki/Gap_buffer The project hasn't been updated for a while so may not work with current releases of Python.
[What is wrong with Python threading?](http://lmgtfy.com/?q=What+is+wrong+with+Python+threading%3F) &gt; About 7,460,000 results
I'm developing for the original XO laptop, so I'm stuck on 2.5 anyway :)
While lmgtfy is cute, the search results were pretty off target and your post wasn't overly helpful. I was asking what specific problems you had with threading. I'm not implying anything is wrong with multiprocessing, as I haven't used it yet nor found a need to. Have you run into specific issues in specific situations? Most of what I find when I do searches seems to be repeated things read in other places. For my purposes, which are nearly always network based, threading works perfectly and multiprocessing would be wasteful. So a catchall statement saying to always use it isn't exactly fair, no? Why would I want multiple interpreters running when DNS or host response time is my bottleneck? There is of course no magic tool for every job. If you are doing intense number crunching that was truly hampered by threading, I would wonder why you were using Python at all to begin with, where C or Java would be the better tool. And for this reason, I'm asking for real world examples and not hypothetical ones. 
Lets just pretend we won't get downvoted into oblivion for this discussion, could you please tell me some reasons why you feel that? Actually no ignore that, this is really several questions. What do you think the philosophies are of Perl, Python and Ruby? From what I can gather, the "official" philosophies are... Perl: There's more than one way to do it. Python: There should be one obvious way to do it. Ruby: Simple, Natural elegance. (conflicting terms if ever there were). Although I am not qualified to speak for Ruby.
I think pillow works on PyPy, but it's relatively hard to judge from the project docs.
&gt; But since Python strings are immutable, every time I want to insert &gt; something, I have to create multiple strings. This doesn't seem &gt; particularly efficient to me. Not sure what you mean by "efficient" here. If you mean time-wise then it seems that your quoted code is about 3 times faster than inserting a char list into a char list (line[at:at] = insert_text). So I would just go with the string insert approach. Though I would consider keeping multi-line text in a list of strings, one element for each line. That way you wouldn't have to insert into the entire text every time. Keep your application simple to begin with and only worry about efficiency when testing shows some problem.
Is it compatible with PyPy?
That's not true either. It's gpl and s long as the API you might link against is permissive there is no issue here. Modifying the core platform would be an issue... But almost no one is going to do that
The exceptions bubble up, but autodie has to be opted-in at the place it is used. It's like a `from __future__ import` in that way.
The problem is redistribution, and, as is often said in the Python community, "import is binding". Therefore, if you have a closed source library in which you "import X" and you _distribute_ GPL-licensed library X with your product (without releasing your source code), you are in violation of the GPL. This is the important distinction between GPL and LGPL: LGPL permits redistribution (linking / use as a library) as long as you are not producing a derivative work. 
Just tested it (PyPy 1.8 and Pillow master), one of the selftests fails, probably without effects on core functionality: File "./selftest.py", line 63, in selftest.testimage Failed example: type(im.im) Expected: &lt;type 'ImagingCore'&gt; Got: &lt;type 'PIL.Image.ImagingCore'&gt; 
I wish more people understood this. Guido laid out a 5 year plan to migrate to P3. We aren't even there yet. Things are starting to break loose now too. The plan was good.
Documentation on RTD is awesome. Even better is proper installation with pip. Thanks Pillow folks.
I suspect that your .txt file is UTF-8 encoded. UTF-8 encoded files, start with a BOM character so when you actually think that the first line is only "google.com", it's actually "(BOM Character)google.com". Add some lines to the .txt file and test for a match in lines other than the first one to be sure
If you print whitelist you should see the issue: ['google.com\n', 'foobar.com\n'] Then: &gt;&gt;&gt; "google.com" in ['google.com\n', 'foobar.com\n'] False &gt;&gt;&gt; "google.com\n" in ['google.com\n', 'foobar.com\n'] True 
You're welcome :-). Thanks for using Pillow! The interesting news here is I finally got around to [pandoc-i-fying](http://johnmacfarlane.net/pandoc/) the old documentation and uploading to RTD. Thanks RTD and Pandoc folks.
Have a look at rtmplite: http://code.google.com/p/rtmplite/
Does Pillow support Python 3?
Patches accepted
No but if you want it to, please discuss on image-sig.
I broke it with: def my_gen(limit): laffo = xrange for x in laffo(limit): yield x print list(my_gen(5)) It's a fun tool though, I love these kind of things.
The problem with condition and x or y is that if x happens to be a false value itself, you'll get y instead. Which is why the old trick was to write it as (condition and (x,) or (y,))[0] Since the tuple (x,) is always true. But as lookitsmarc pointed out, there is a Python version of the conditional operator nowadays.
Except when you go to maintain someone else's code - and run into 24 new &amp; different, and often unmaintained dependencies.
It took me a week, but I got the site up and a post out there with an issue I just got over. Here's a link: http://pythonaut.com/dont-be-afraid-of-commitment-sqlalchemy-staledataerror/ The blog is ugly, because I've not had time to mess with it other than to write the post. I'll pretty it up later. Let me know if this sort of thing is helpful to you, though.
Just to be contrary... def flip_odd_numbers(l): return [n-n*(n&amp;1)*2 for n in l]
Since Rhomboid already gave the proper straight answer, here's a silly way to do it with generators: #A generator is just a function that has a yield statement def alternate(): i = 1 while True: yield i i *= -1 alternator = alternate() #Good style says we should pass in the generator, but this keeps to xApple's signature and also gets you thinking about closures ;) def flip_odd_numbers(r): return [i * alternator.next() for i in r] flip_odd_numbers(range(10)) #prints: [0, -1, 2, -3, 4, -5, 6, -7, 8, -9] 
It's very nice, but it doesn't work fully with recursive functions, with [quicksort](http://pastebin.com/CtKquuAK) it just shows one execution of the routine. 
Or using powers of -1: def flip_odd_numbers(l): return [ x*pow(-1,x) for x in l ] 
Or `(y, x)[bool(condition)]`. If we are into this kind of "clever" code.
I really hope the development of this continues to the point where it works with any valid code within the python standard library. An obvious application would be including a button in IDLE that can do this for beginners. (Do beginners use IDLE?) I'm already dreaming about a vim window opening up and displaying an ascii art version of this as a debugger.
But that's different, that evaluates both x and y, and they could both be function calls with side effects, or take a long time to compute.
Thank you! :D
You forgot to call your qsort recursively XD It should be `return qsort(smaller) + [pivot] + qsort(larger)`. Also, beware: calling _that_ a quicksort might get you a well-deserved rage of an algorithmic purist. The entire point of qsort is that it works inplace.
It performs even worse on this list: flip_odd_numbers([1, 2, 3, 5, 7, 8, 9, 7, 1]) prints: [1, -2, 3, -5, 7, -8, 9, -7, 1]
Isn't it called the 'ternary' operator?
That's much better, thanks for the rephrasing. Although I don't think Python uses BSD, it's another license AFAIK?
It's much prettier: with open('domain.whitelist.txt') as fd: lines = [ line.strip() for line in fd.readlines() ]
Because Python is Python, bitwise operators offer very little speed boost. Using timeit and a global variable holding range(20) as the list, I get 4.8997 s vs 4.6487 s for 1000000 loops.
Right, it's distributed under the Python license. Corrected - thanks!
Well, there's only an advantage until we properly optimize `bool(n % 2)` (which is slightly harder than it should be, for dumb reasons).
That's really cool. My SB project at MIT was a visual evaluator for a language called Boxer, under Hal Abelson and Andy diSessa (who moved to UCB during the work). http://klotz.me/thesis.pdf I also wrote a set of LaTex macros for laying out the displays in the thesis...they ran pretty fast too. 
You can use a non empty list as well, just anything that doesn't have a false value. Dive into python has a really good write up on using and/or http://www.diveintopython.net/power_of_introspection/and_or.html#d0e9975
if you want to use generators, why not this? also lambda &gt;&gt;&gt; flip_odd_numbers = lambda n: (x % 2 and -x or x for x in n) &gt;&gt;&gt; flip_odd_numbers(xrange(10)) &lt;generator object &lt;genexpr&gt; at 0x102794eb0&gt; &gt;&gt;&gt; list(flip_odd_numbers(xrange(10))) [0, -1, 2, -3, 4, -5, 6, -7, 8, -9] 
The first solution to pop into my head was this... print [x * (-1) ** x for x in range(10)] 
I am new to posting on reddit. Why the down vote? Is it bad to post one's own blog posts?
 def flip_odd_numbers(series): newseries=[(element % 2 == 0) and element or -element for element in series] return(newseries)
Is there a reason for not changing requests itself so that pickle works and creating a pull request?
Okay, I got pickling to work. Not sure if the best implementation though. I'll add this to the post :) Thanks.
Assuming whitelist fits in RAM, a set will give better performance if you have more than a few tstrings to check: whitelist = set([x.strip() for x in open("domain.whitelist.txt").readlines()]) for tstring in list_of_tstrings: if tstring in whitelist: print 'Match on ' + tstring else: print 'No Match on ' + tstring 
flip_odd_numbers(iterator): return [ item % 2 and -item or item for item in iterator ]
Done.
Oh, you're right `__get{init,new}args__` can only be used in addition to `__{get,set}state__`, TIL.
Im not saying you are wrong, but for me, min/max values on a IntegerField isnt a part of the model as that doesnt model to anything in the database. Django of course has min_value and max_value, but they are in the forms.IntegerField which is the layer where you normally validate your data in django. 
i love it :) class A(object): pass A.brr = 2 a = A() a.brr = 7 print a.brr 
1.8 still isn't included on that page
&gt; If you can't you shouldn't be trying to learn a computer programming language. I want to call you out on this. I think this 'leave it to the experts' attitude is very damaging. Basic programming is *really not hard*, but many people think it's some black art that they could never understand. Making it dead simple to get started is a massive help with that. Also, I agree with slix00. Newcomers don't benefit from a massive IDE with hundreds of options they don't understand. If they start doing more serious programming, they might want an IDE, but they needn't start out with one.
&gt; I would probably recommend something even simpler: a simple notepad with syntax highlighting and Python indentation and a run code in console button This strikes me as a good description of IDLE itself ;-). Besides that, I agree with what you're saying.
I use this in tandem with rpy2, by using a small function to convert data.frames to pandas's own DataFrame. Which I should probably try to push upstream sooner or later...
"but they needn't start out with one" with a cluttered one, you mean, I suppose. There are really good simple IDEs with code completion and doc hints (SPE, spyder, pyscripter...) that are perfect for learning, in my experience better than simple editors (notepad, geany) or guru's tools (vim, emacs) and far away from the heaviness of things like pydev.
It models to a check constraint on the row in a database, which is something even Django uses when it creates a ``PositiveIntegerField`` for example. Consider the model: class Test(models.Model): spi = models.PositiveSmallIntegerField() Dumping the SQL for Postgres yields: CREATE TABLE "t_test" ( "id" serial NOT NULL PRIMARY KEY, "spi" smallint CHECK ("spi" &gt;= 0) NOT NULL ) ; So you can see they are generating a CHECK constraint on the row. If the idea is that validation should be in the app layer they are violating that here. If we should put as much validation into the database engine as possible, then they should add them for things like ``BooleanField``
look at openhatch.org . 
You need to learn about scaling of algorithms, aka big-O notation. Searching a list like that is O(n), which means if the size of the list doubles, so does the search time. A balanced tree is O(log(n)) which is way nicer, and on average, a hash is O(1) which means it takes the same amount of time no matter how long the list is (A dict and set in python is implemented as a hash table). This is all first-order, in real life other things influence scaling besides algorithm complexity. I don't have a good link to read about this stuff, the Wiki page is a bit technical for a beginner, perhaps someone else can offer a link.
Hey, I saw that one but it s not based on twisted and I wanted to use it. I ll check the architecture to get ideas though. Thanks
Okay great idea that quiz, but it should be done by someone who actually knows how to rock python.
Of course some people will never be good at working with computers. But artificial barriers - *don't bother trying programming unless you can install Eclipse* - just dissuade people who might turn out to be decent programmers. I'm not saying that it's a ploy, which would imply intent, but it definitely has that effect. And it's not about whether you're able, it's about whether you will get scared off. Eclipse is a particularly bad example. The Eclipse home page has a nice download button, but then you get a list of [Eclipse for foo Developers](http://www.eclipse.org/downloads/), and none of the foos are Python. In fact you need [Pydev](http://pydev.org/index.html) (as opposed to [PyEclipse](https://sourceforge.net/projects/pyeclipse/)). But that's a plugin, so you'll need Eclipse installed first. Which version should you install? Eclipse Classic, maybe? Or is that an older version? I've been programming Python for maybe four years. A couple of times, I've considered using Eclipse+PyDev, but each time I've looked into it, I've given it up as a bad job. In your scheme, I wouldn't be a programmer at all.
Say you're developing an app for the Pentagon that uses a web service to launch nuclear missiles. When testing, you might create a "mock" version of the web service client class that behaves as if it were connecting to the real web service, but avoids the undesired side effects of doing so. A mocking library is some code to help you prevent your unit tests from destroying the world.
Most of the time just vim on my linux vm. But recently I've also been going back and forth between http://chocolatapp.com and http://c9.io/ (online ide) while working on a Flask app at work.
Yes, as long as your expectations of a universe are fairly unambitious.
With git your workflow should almost never be "commit &amp;&amp; push". Your workflow should be "commit; commit; look at commits; fix-commit; fix-commit; rebase -i; push". And in an environment where commit=deploy this should be followed by "test; push test-server; test on test-server; (commit...; push test-server); push deploy".
So the problem is that it is easy to push? If this is a problem in your environment, then have "push" go to a test server (or an environment running locally) where it can be reviewed and require a second push to go into production.
&gt; Recently, I have been using this library for a few of my company's internal projects and at a point I needed to serialize and save Session objects for later. What problem are you trying to solve?
I don't think that's the problem he's pointing out. As I read it: Push-to-deploy encourages commit+push in order to test. The author prefers to commit after testing, so his source history doesn't accumulate lots of trivial 'fix typo' commits. So he wrote `git-sync`, which simply copies the working directory to a separate repository, commits it there and pushes to deploy. TL;DR: It makes it easy to deploy without committing your changes in your source repository.
came here to say this. Also realize that there is nothing wrong with creating multiple "test" commits, deploy then rebase ... SO LONG as you're doing this on your own branch. 
Stop reporting this as spam.
 bool(1) == True True == True No need for conversion? That would be my guess.
Yeah, in the sense that there are unary, binary, ternary, quaternary (etc.) operators. In `-1`, the `-` operator is unary (one operand) In `0-1`, the `-` operator is binary (two operands) In `condition ? true : false` the `?:` operator is ternary (three operands)
Yes, rebase definitely resolves this, but it makes the default a messy history and then you put in extra effort to clean it up. With git-sync the default is a normal/clean history. Also this lets you do some portion of the build process locally (e.g. compressing resources), and you can sync the results, but you'd never want those derivative resources committed to your regular repository. (Of course with enough hooks on the deployment server it's not a problem, but then your server has to be smart)
Your history is still ugly unless you rebase.
How would you set up a test server to test Heroku-specific things? You can test the app, but unless you clone Heroku, you can't be sure you have it configured correctly.
It's very easy to replicate Heroku, buy second instance, call it test, and deploy there first... At least that's similar to what we do at my work, we have a dedicated physical machine. Of course it all depends on how critical your application is.
The pk name is something I am just very used to. When I see a bare loads or dumps, I can't immediately tell if its from json/yaml/pickle etc. More than anything it is just an old habit now :) (The name req is another cue as requests looks close to request, which I import from flask)
We need some more detail. I just tested your import line and it works fine here, so we need to see the context in which this error takes place -- a few more lines of code. And your platform. 
i'm a member of "general public" and only virtualenv rings a bell at all.
Haskell, for one, also supports arbitrary-length integers.
Have you got a urillib.py or urllib.pyc in your project?
 $: python Python 2.7.1 (r271:86832, Jan 28 2011, 20:55:04) [GCC 4.2.1 (Apple Inc. build 5664)] on darwin &gt;&gt;&gt; 1E308 1e+308 &gt;&gt;&gt; 1E309 inf
Open a python shell, do import urllib, then print urllib and paste the results here, you probably have a urllib.py somewhere on your path.
No pip?
Title is only true for Python 3 ... and then only for ints.
I messed up. Are there performance benefits in from pickle import loads over import pickle?
I like to use slice notation wherever possible. Is there any downside to using slices instead of append() or extend()?
picture in picture? nope.
PyDev is an Eclipse Plugin that brings Python-specific features to Eclipse (which actually is a Java-IDE). Python27 is the interpreter, so yeah.. it does the work ;)
And if he wants to develop something with no dependencies so he can install one thing instead of two or more, what should he do then? Bake that excellent resource into his project? I agree that Reitz's requests package is fantastic but at the same time, dependencies can turn off a lot of people.
Its not horseshit.. Its something taught in the prestigious in INDIA.. If you knw more than please come n teach.
Correct. And he should be using randrange(0,len(deck)) rather than randrange(0,len(deck)-1) randrange(start,stop,step) is equivalent to choice(range(start,stop,step)), and for i in range(0,x): print(i) gives 0 1 ... x-1 
Also, they never increment count, so the while loop will continue endlessly. Eventually yourhand will contain all of the cards from the deck.
What those guys said. Also your loop is infinite?
If i do cardpick=random.randrange(0,len(deck)) then i get ValueError: empty range for randrange() (0,0, 0) EDIT: Wait nevermind it worked :P
&gt; edit: Oh, and no omnicomplete for vim. I have to use some other plugin that looks at the current open buffers to suggest completion. This is wrong; vim (if compiled with Python support) comes with Python omnicompletion.
http://pypi.python.org/pypi/pip
You might want to take a look at [Spyder](http://packages.python.org/spyder/), which could be a more relevant environment for your purposes.
It seems your correctness problem is fixed, but here are a few other things to note: * input() returns a string, so it should be "if gametype=='1':" and similar. * You probably want "elif gametype=='2':", otherwise singleplayer will also trigger the invalid choice option. As for dealing a hand of cards, it's much easier with list comprehensions. There's a a function in random, shuffle(), which shuffles elements of an array in place. Thus you can do something like this for your deck: import random class Deck: def __init__(self): """Create a new deck and shuffle it""" self.deck = list(range(52)) random.shuffle(self.deck) def deal(self, n=7): """Remove n cards from the deck and return them""" hand = self.deck[:n] self.deck = self.deck[n:] return hand # Example, create a deck and deal it out deck = Deck() while(deck.deck): print(deck.deal()) 
This is off topic, but: I'm learning python myself, and was just wondered if you ever thought about creating the list of cards with a function that creates a list based off of: ['Clubs', 'Diamonds', 'Spades', 'Hearts'] ['Ace', 'King', 'Queen', 'Jack', 'Ten', 'Nine', ...etc..] I don't know if it's even practical, but it'd definitely be less characters in the end.
But editing commits and force-pushing to deployment seem like bad habits to get into. This aims to make getting it right simple.
That would definitely work, but I have no idea how I would pair them together.
Not really a coding error, but you spelled "Spades" incorrectly. 
Hmm, very interesting. I'll look into that right now... Thanks for the tip!
This is great. I had been doing: suits = ['spades', 'diamonds', 'clubs', 'hearts'] cards = ['1','2','3','4','5','6','7','8','9','10','J','Q','K','A'] deck = [] for s in suits: for c in cards: deck += c + ' of ' + s So, thanks. 
No
&gt; If something collides with "pickle", I believe the problem is the thing that collides with it, not pickle, a standard library, I think. Well yeah. It's just an example. If you have "open" in the asdaysman module, you either access it via asdaysman.open or import open as "a_open" or something.
If your wanting to learn Python then I suggest Zed A Shaw's Learn Python The Hard Way. Its where I started and I think that its one of the best language introduction books that I've read 
 yourhand = deck[0:14:2] botshand = deck[1:14:2] deck = deck[14:]
I would do this, but I have a tendency to be too clever. hand = random.sample( deck, 7) map(lambda x: deck.remove(x), hand) to return 7 random cards from the deck.
Python all the way especially if you are comfortable in Linux. Also you are never too old to start programming. Building a portfolio can't hurt though. Make a github account and start a few easy projects. 
I can't speak to the "how old is too old" Personally, I'm 23 and still and undergrad, so... I also started out making web-pages in middle-school with fancy "DHTML" &amp; Javascript (oh how the buzzwords have changed). My understanding of the Job Market is that age doesn't matter nearly as much as competence. There's some "agism" with respect to programming but it mostly refers to those over 40. If you can show proficiency &amp; work ethic, you should be fine. Python will be easier to start out with, but Java is more employable. Learning Python first then Java will take longer, but you will be more proficient at both in the end. There are also a growing number of jobs that are in Python, but Java's pretty dominant in the "Enterprise" sector. Starting with Python reduces your chances of being scared away from programming (which can be daunting). There are a number of very good "gentle introduction" books such as Zed Shaw's ironically named "Learn Python The Hard Way" (it's free). I'd stick with "Regular" CPython v 2.7 since that will have the most resources available to you. Eventually the world will wake up and realize Python 3.3 is better in all ways, and maybe everyone will use PyPy because it's fast, but as a learner, Python 2.7 is fine.
Though Python is my favorite language, I feel like Java is a better choice for someone learning to program for effectively the first time. Python's typing system is amazing, but kind of makes you lazy (you basically don't have to worry about types at all in Python, unlike in most languages). Python is also multiparadigm (you can use it as a procedural, functional, or object-oriented language) while Java is purely object-oriented, which is arguably the most important one today. That said, once you have a handle on Java, Python is definitely worth checking out, and experience with another language will help you better appreciate how easy it makes everything. Since Python 3.x is the future of Python, I would recommend starting on it.
I did not know you could do nested list comprehensions...
Pydev helps you to create Python projects, modules/classes/etc. from templates, and does the much needed syntax highlighting. In a nutshell, acts as an additional layer above eclipse (that is originally a java development environment, as mentioned by senft). Tbh, when you start development, eclipse is probably much more than what you need. There is a pre-packed, lightweight, but quite capable editor coming with Python, called IDLE, which you can use to start python development with. Later, when you can recognize what is lacking is when you can look for a more powerful IDE. I use eclipse/pydev because I came from the Java world and because I do a lot of GAE development lately. 
If you're interested in game development, I'd look into ActionScript, JavaScript, Lua, or C. ActionScript is the language of Flash. It used to be fairly popular on the web overall, but Adobe got itself into a pissing match with both Apple and the open-or-die neckbeards and lost on both fronts. (Their entire PR division should be fired.) It's still popular for gaming though. You can create games for a web browser or mobile app stores with Flash. JavaScript is the language of the web browser, so it's the most portable choice. You can build games for the web or for mobile devices with JavaScript. It's an easy-to-learn and very flexible language, but may be a bit immature for complex games. Lua is an up-and-coming choice for high-level (like Python) compiled game development. Many mobile games are created in Corona, which helps you use Lua on smartphones. When the aforementioned pissing match led to the banishment of non-C titles from the App Store, the biggest cry came from game developers who were relying on Lua. (Like all the other once-banned languages, Lua is again allowed on the App Store.) C is the traditional language of game development, because it is an old language that has been optimized for performance, so you can do big, complicated things with it. iOS games are primarily written in Objective-C and Android added a Native Development Kit to allow C games to target Android devices. If you're looking to do things like fancy 3D, you may want to consider C, but it's going to be harder to learn and less portable. If you want a more visual approach, try ActionScript. (You get to draw your visual components in symbols and then write programs to interact with those symbols.) If you're interested in web development, learn JavaScript. Finally, if you want performance closer to C but readability more like Python, give Lua a peek. I know there's a Python library called pygame that you will probably use if you choose Python, but I don't know of many game developers who choose Python as their primary language. It's great for more general purpose things like server-side web development, but neither the web browser nor the app stores let you deploy Python games easily. Java is the language of Android, and is still popular for backend server apps. It's famous for being really verbose to write. As the original one-size-fits-all language, Java apps can be really awkward to run unless you're on a platform tuned to them like Android. My background: I'm a web developer and occasional game developer. My strongest languages are ActionScript and JavaScript. When I need a server-side component to a web app, I use Python. I have no practical experience in Lua, C, or Java.
Oh yes, the prestigious India, how could I ever have questioned. $ perl -Mbigint -E 'say 2**256' 115792089237316195423570985008687907853269984665640564039457584007913129639936 
If you're trying to decide with Python or Java why not just go with Jython? You'll have the simplicity of Python and the ability to use Java classes.
Run through this: http://learnpythonthehardway.org/book/ see if any of it sticks. 
hey i'm having trouble using this free axe! somebody help. Hey guy, there's a free chainsaw right over there might be more appropriate for what you're doing! moron: he did not help him axe!! downboat!!
I have mixed feelings about this, but honestly, I'd say start with Java. If you get so fed up you want to quit, then start with Python. I say this because Java is a much different language, and in a lot of ways 'harder'. That is, Python makes a lot of things simple that in Java require some thinking or research. Having spent so long with Python before going to Java, I kept getting frustrated with how such easy tasks were now really a pain in the ass(opening a file, creating a dictionary, etc). You'll likely need to know both. Java is everywhere, and is good for 'employment'. Python is good for making things quickly. They really don't serve the same purpose - you can use java for number crunching and python for web serving - for example. The best way to learn, in my opinion...is to write something in one language, then rewrite it in another.
having electricity is a dependency. People will manage
I think I am going to start using this as my standard advice. learn C so you know how computers and programs work on a very low level. learn C# to get a strong handle on object-oriented concepts. learn Python so you can be productive and see how these concepts fit together. bonus points: learn Lisp to try a new paradigm/make yourself smarter. learn C++ to actually get paid.
No need to apologise, I'm just confused.
This seems like bad advice for a newbie. Jython is okay for integrating Java and Python libraries, but isn't ideal for tasks that could easily be done in cPython or Java. Additionally, if someone doesn't know much about either language, Jython would conflate which features come from Java and which features come from Python. Since there isn't much demand for professional Jython programmers, I think it would be best to have a clear understanding of each before trying to combine them. 
I do suggest Python, to start, because it's easy and it's fun. You may have trouble translating some of what you learn into other languages, but that's because they're *other languages*. Some languages use similar concepts to Python, so you're basically choosing between two groups, not "Python or everything else." If you're uncorrupted by any experience, choose Python 3. I'm a Python 2 programmer, and have been putting it off....it's not a good situation. Just learn the new version. As for schools, I don't think you need to worry about being seen as too old (especially considering that it's illegal for companies to hire based on age), and I don't think you need to worry about the piece of paper. Maybe do some part-time school on the side, to get some degree, but I think a B.S. in computer science is starting to lose its value somewhat, as companies realize that the kids who have the degree are just as useless as the kids who don't. Of course, this is my perception as a senior at University, and my school is awful for CS. I may be wrong on the last bit about the degree, but I definitely think that companies would hire you if you knew their language.
So why do you recommend Python 3 if Python 2 offers a much better experience to the developer (i.e. the breath of libraries)? Python 3 offers some relatively small improvements to the language itself, but does that really outweigh a ton of libraries (and documentation) for a beginner? 
27 and just finishing my undergrad -- you are not too old. Age is absolutely irrelevant in any professional field so long as you have a true passion and eagerness to continue learning. As far as which language to choose: I'd go with Java. It's cross platform, mature, and has a massive library. It's closer to C/++ than Python is, so picking up the C family will be that much easier in the long run. Also, Java is the application-making language of choice for many companies (as well as C++). However, do not neglect Python. I use Python for just about everything at my job and I use it as much as I can at school (my faculty is kicking the Python idea around for replacing Java in out 101/2 classes). It is also mature and extremely robust. The bottom line is just start with whatever and go from there. Programming is programming is programming. Once you understand the concepts and theory, language becomes less relevant.
I think you misinterpreted what I was saying. My advice isn't about web development at all, but game development. Python has a fantastic standard library, which helps make it a great go-to language for many things (including, but not at all limited to, server-side web development). However, I don't know of any widespread ways to deploy a Python game to a mobile device or web browser, where most indie game development has been happening lately. So, if the OP is interested in indie game development, I'd recommend using a tool that has a large audience of both developers and players: Lua, ActionScript, C or JavaScript.
There is a reason you've been putting off learning Python 2, presumably. Does that reason apply to beginners as well? I'm curious. But do you really want beginners to explore a language that many experienced developers are not using yet? I'd argue those *already* experienced stand the best chance to make adopting Python 3 a success, not beginners who need all the guidance from others they can get, and will feel much more rewarded by clever use of existing libraries too. 
Is your standard advice for people to *start* learning C? I'd recommend against that; string manipulation alone is way more complicated than it should be and hard to get right, let alone the rest of memory management. Learn C sometime later after you already know what programming is all about. Though of course it's perfectly *possible* to learn programming by learning C first, it doesn't sound optimal. P.S. It's perfectly possible to get actuallly paid by doing, say, Python (I've been doing that for more than a decade now). 
* Python * Python 2.7 * Dead is too old to begin a career in programming. I believe you're not dead yet so you should be fine. For the long answer, come and pay me a beer and we could talk.
&gt; It's great for more general purpose things like server-side web development, I know it was in a larger context, but the meaning is preserved. Web development is definitely *not* a general purpose :) As for games, I'm not sure what you mean by deploying a Python game to a mobile/web environment. You wouldn't write a Python app if you wanted to deploy to anything but Android, presumably, and web development for a game can happen in *any* language on the backend (no, seriously, any language).
That's really cool! From what I can tell, it evaluates the python code on the server and returns some kind of trace (made by pdb, according to the README) that the javascript then renders. [Oooh it is on github!](https://github.com/pgbovine/OnlinePythonTutor/)
So you're saying a beginner who doesn't know programming yet should learn the *harder* language? Don't you think a beginner should learn the basics and get productive and a sense of reward first, instead being distracted by boilerplate? If you, experienced developer, already have such problems, how much worse for a beginner... By the way, I don't think the languages are so difficult in their applicability: there is a LOT of overlap. You can for instance use Python for number crunching too; lots of scientists do so using tools like NumPy. Lots of folks write web applications with Java. I haven't needed to know both to make money myself, but your mileage may differ... 
I moved from HTML to C/Visual C++ 6 at an early age and it wasn't terrible. I think starting with a strict and "verbose" language is the best way to go. Like dpitch40 said, you'll really appreciate python more when you realize how much work python hides away/handles on its own.
It's true that there's a lot more libraries out there, my suggestion is based on an assumption that someone new to the language is going to be spending most of their time learning the language and standard library rather than third-party modules. It's certainly debatable heh.
My frustration is that my entire post has been discredited for a badly-worded aside that has little bearing on the main point, which we both seem to agree on. Python is a great choice for many things that don't have particular platform requirements. However, if you want to make games, there are other tools that are better suited to the task, in part, because they can be more easily deployed to the devices your audience is likely to be using.
Im going to be honest with you... Python is a bad language to start with. Here is my reason: Python is great! Its easy to pick up and it has a simple and flexible syntax. You'll start doing pretty complex stuff quickly. Downside: I hate to say it but you're still a beginner and the most difficult part of being a programmer comes when you make the jump from beginner to intermediate. As an intermediate programmer, you will start picking up more and more languages and at first you will be relying heavily on what you learned in your first programming language. Keep in mind that as an intermediate programmer, every programming language you learn, you will compare to the first language that you learned. If you did a shitty job learning your "mother language" then you will have a difficult time moving from one language to another at this stage. This is going to get you... particularly because at this point you will be getting paid and people will be expecting results from you. Take the time while you have it to learn a programming language with lots of strict rules like C, Java or C++ early on and the intermediate phase will be a breeze. I guess my point is... Its really easy to write REALLY crappy python code but not as easy to write crappy Java code. Anyways... Thats my take... Haters going to hate. 
This depends quite a bit on what you're doing. If you're looking at web development, it's still mostly a Python 2 world. For GUIs running locally, the tools for Python 3 are already pretty good. The library support for Python 3 has also improved quite a bit over the past year - most of the basic Python tools like nose and virtualenv are now in place.
I think you're right that Python is the best (perhaps the only) language to span from scientific computing to web development and mobile apps. I don't think there are many examples that cover all of those, but I can think of [Zunzun.com](http://zunzun.com/), which combines scientific/numerical code with a web frontend. A couple of comments on your tools: web2py is one of many Python web frameworks. The best known is Django, which is an all-batteries-included style framework, and there are a range of microframeworks like Flask, Bottle or Tornado. SL4A is, as far as I know, good for running Python scripts yourself. If you want to develop apps, look at [Kivy](http://kivy.org/#home). But then, I don't have a smartphone, so I haven't tried either.
There's a big difference, but you seem unreceptive, so why waste my time?
Pyramid 1.3.X (on PyPI) is also Python 3 compatible, FWIW.
It doesn't really matter what language you start with, since Java and Python are quite similar. If you want to develop games there are libraries for both of them: Pygame for python and LWJGL for Java. Pygame might be easier, it seems to be better documented than lwjgl.
No, no, no. I didn't discredit your entire post. I specifically said I wasn't going to address everything. I'm sorry if it came across any other way. I think, though, that we have yet to reach the stage where PC users are the minority. Everyone has a smartphone, maybe, but they *also* have a PC on the side. In fact, my experience has been that Python is the primary language for GNU/Linux games. I've seen many just starting, in particular, that are in Python.
What's so compelling about web development in java ? Is there any decent web framework in java (comparable to django in terms of productivity) ? And the "employment" argument doesn't stick - unless the OP wants to work for a bank. I think there are plenty of employment opportunities for python. Performance-sensitive problems are not solved with languages - they are solved with adequate techniques. If java is right for your perfomance-sensitive app then use it - but don't hold it as the panacea for all performance problems.
Start with Django. It has the largest community and that is critical for beginners (easy to find answers and solutions to your problems). 
My opinion (as an old fart of 37) is start with Python. Start with Python version 2.7.2 as it has the most supporting libraries. Don't be afraid to mess with python 3, but I find most of the time, I need a library or two that are only supported in Python 2. Sure, there are differences, but once you are a Python 2 expert, they will be pretty easy to deal with. This is just one blog on python 3 compatibility I found, but there are and will be many more: http://lucumr.pocoo.org/2011/1/22/forwards-compatible-python/
Spyder includes ipython
Django is where you should start if you're a beginner. You do not need Python 3 compatibility. There are many frameworks because there are many different opinionated people who were not satisfied with what they were offered with. Once you get experienced with web development, you might find out that you do not need scaffolding, object-relational mapper, internationalization, templating, any feature that comes with Django or that you need something different for your specific project. You might find that these features are actually getting in your way instead of helping you out. Once you get there, you might want to start with something small, like [Flask](http://flask.pocoo.org/), that offers things you know you will need and build on top of it. I hope this help.
Decent book. I went through it. Did the exercises. Cleverly written and novel approach to teaching. Free. However it's not really for someone who has ever done any programming. I can't properly evaluate it because I was already familiar with python and have been a pro for years. It was clearly for someone who is completely unfamiliar with even the concept of coding not just unfamiliar with python. It could definitely be good for the OP but it depends on where he sees himself on the continuum between noob and guru. This is a book for people on the far left of that scale. It should only take a week to get through it though so it's worth a try anyway. I did it and thought it was kind of fun. I think if I were just starting out this is the book I would have liked someone to give me.
There is a beginner book from O'Reilly (Learning Python, I believe) that teaches how to program in Python and when there are differences between 2.x and 3.x, it points out the differences so that you can understand both. 
[Free Intro Programming course](http://www.udacity.com/cs#101) starts on 2/20. Will teach you to create search engine like Google in seven weeks using Python.
You're coming to /r/python asking whether you should pick python over another language. Surely you don't expect an unbiased answer...
You won't be able to get this functionality without extras. The [colorama](http://pypi.python.org/pypi/colorama) package works great - you could just include it along with whatever code of yours which needs to work on the student machines.
i.e. Beat yourself up now so that things seem better by comparison later? Rubbish. Learn an easy language first, have some fun, and find out what's possible. There's an increasing number of jobs for Python developers, but if you need to learn another language later, grin and bear it.
I appreciate the effort you've put in there, but you've provided an answer to a different question.
Thanks for the headsup but I'm just wondering if anyone is aware of any major difference between editions
Colored text is relatively easy on Linux/UNIX. On Windows, not so much. Sorry, there's really no way of getting around it. You don't have to actually install the module. Like \_\_slots\_\_ suggested, you can include it in the program directory if it's simple enough and it should work just as if it was installed. Although to be honest, the windows versions of modules created with wininst_bdist are trivially easy to install. It's just an .exe file, run it, click next next next, done.
I do not use OS X, but I think that the process may be not different (I use Linux): - Follow instructions found at https://github.com/tweepy/tweepy/INSTALL. You need to be root or use some alternatives like virtualenv or configure PYTHONPATH. - Eclipse &gt; Window &gt; Preferences &gt; PyDev &gt; Interpreter - Python: Try to remove any configurated interpreter and use Auto Config. 
Here's a wx solution similar to my other post: import wx class MainWindow(wx.Frame): def __init__(self, *args, **kwargs): super(MainWindow, self).__init__(*args, **kwargs) vbox = wx.BoxSizer(wx.VERTICAL) self.panel = wx.Panel(self) self.panel.SetSizer(vbox) for i in range(10): button = wx.CheckBox(self.panel, label="Item {}".format(i)) vbox.Add(button) submit = wx.Button(self.panel, label="Submit") submit.Bind(wx.EVT_BUTTON, self.submit) vbox.Add(submit) self.Show(True) def submit(self, event): print [i.GetValue() for i in self.panel.Children if isinstance(i, wx.CheckBox)] app = wx.App() win = MainWindow(None) app.MainLoop()
I starte learning programming from scratch about a year ago. Am currently a full time django developer. In the middle of teaching myself iOS development too. I'm 29 this year. 
Since we're being clever, we can even spare the lambda. map(deck.remove, hand) 
Thank you for your help! I will take a look at these two solutions and check out PyQt as well. Much appreciated.
[blessings](http://pythonpackages.com/info/blessings) FTW
Speaking as a person who has programmed in Python for a while now, I would definitely recommend *not* going with Java as I find it emphasizes the wrong points for new programmers. Java mandates a lot of things (OO programming, inheritance, strict typing, interfaces, etc.) that CAN be powerful tools but can also lead novice users terribly astray. It also forces new users to spend, in my opinion, far too much time worrying about silly things like array bounds checking and pass-by-value vs pass-by-reference semantics. Python would be my preferred choice of the two for a new programmer (and happens to be my preferred choice in general, I have a strong dislike of Java for those and other reasons). However: Have you considered Javascript? It's easy to install [node.js](http://nodejs.org/), which is a command-line interpreter for Javascript. Javascript is extremely useful for designing web pages and is rapidly becoming more and more 'hot' for resumes, new technologies, and all sorts of cool things. It's still burdened with a strange syntax that was forced on it when the Netscape marketing people decided that it 'had to be more like Java', but each update makes it more and more like any functional programming language (with the benefit of supporting an imperative [c-like] syntax). I personally have begun recommending Javascript as the perfect 'first language' for those reasons. I think it makes better programmers and it *definitely* teaches a marketable skill.
Any tips on how to move into this career without a real CS degree backing you up? I've been a hobbyist for years, and am currently working on a couple projects with the intention of padding a resume with real examples.. but beyond that.. any pointers? Having no paid experience seems like it's a quick route to getting your resume ignored.
I started teaching myself Python a while back, very slowly. Easy to pick up, not mind bombing concepts to get things started. However if you are interested in software design, programming with application to your basic needs, i suggest Java. I transitioned to Java now because basically i want to make Android apps, and make Object orientated software which is where its at with the games, especially the nice looking games (but i think C# or C++ is best for games) 
Um, what answer do you expect from **r/python**?
If you feel like you're a novice python programmer who has reached his limit with python, read the itertools page. It will allow you to basically just write collections logic in raw idiom. Greatest library ever?
I ran your code (with the extra line to create a new Foo object) and I got no errors. The only thing I can recommend is that you should check your indentation to make sure your implementation of "add" isn't within the class body of Foo.
Step 1: Make sure you've got the skills. Develop those skills working on Open Source (public) projects. Step 2: Network. The adage, "It's not what you know, it's who you know," is absolutely true. Attend local user groups and events and contribute on local mailing lists. I'll probably get some flak for this one, but hang out on twitter as well. Find local developers and development houses and watch their accounts. They'll often tweet about jobs before advertising them.
25 is not too early to start a programming career. Some employers can be goofy about this but many aren't. If you want to start a true programming career, you'll need more than one language anyway. A few mainstream languages like C++, Java or C# (sigh) are almost always necessary. Add in a "2nd-tier" "LAMP" language like Python or Ruby makes you more well-rounded. It's shocking how many resumes I've seen with only one language. That doesn't disqualify you immediately but you better be reeeaaally good in that single language (and they rarely are...). I would suggest starting off with Python. It's pretty easy to get started with and not nearly as restrictive as Java. I've always thought of Python as a sort of mix of C++ and Java. Once you start appreciating the differences between languages, you're on your way! Good luck.
If you are concerned about the licensing of PyQT, (which is GPL), then you might want to check out [PySide](http://www.pyside.org/), which is a python qt toolkit that is LGPL licensed and almost completely compatible with PyQTs API (i.e. you can use documentation *almost* interchangeably.) I used it for a project recently and it was pretty awesome to use. I got the UI with Qt Designer and then plugged it into the app. Got the whole UI done in about 3 days (for a semster long project).
In this case, the function `add` isn't actually called until `Foo.__init__` gets called, but otherwise yes you do.
23 - just started recently. This wouldn't seem that discouraging... except for the fact that the one programmer everyone knows founded Facebook at 19...
I'm really new to python... what do you mean by python 2.X having a lot of libraries? What are libraries in the programming sense?
&gt; A lot of companies use it for non-mission-critical SW. And some for mission-critical SW. * My argument here is really that it would be tough for me to hire a python guru over (for example) a java developer if my product or service was primarily developed using something else (for example: c++ or java). No doubt there is heavy use of python in companies today. &gt; This is not my experience. [...] Python devs were hard to come by. In these cases, Python knowledge was a huge boon. * I'm confused by this statement. My experience has been that python developers who have had experience developing a mission critical product/service using python as the main development language are quite rare. I also want to mention: Python is my absolute favorite language. And given the choice, I'd turn down well paying c, c++, and java jobs to work with python.
They need to put the "forward" buttons etc up at the top. When I gave it more than 20 LOC, I have to scroll back and forth to step it and then see the results. Also, when there's significant setup code (class defs e.g.) it would be nice to have a breakpoint ability -- run to here and stop. But that way lies a full debugger I suppose.
At an old job I just built a wrapper by hand using the C API. Another team in the company got into Boost.Python for a similar project and liked it, but I was already pretty comfortable with the C API and wanted to get going immediately. It worked and continues to work great, but looking back I probably should have looked into something like SWIG or anything else that generates the wrapper since I wasn't actually *doing* anything in my wrapper. It was as dumb as could be, simply converting parameters from Python to C++, calling a function, then converting from C++ back to Python.
I am the project leader for web2py. I am very much interested in what you suggest. In fact I am writing a book on scientific computing with python and I have a pure python port of many numerical algorithms so that I do not need to install numpy, scipy, etc. (it is slower but way more portable and they run under SL4A). I am told web2py also runs under SL4A but I have not tried. Feel free to contact me personally if you want to talk more about this. Warning: Many people on reddit will try to talk you out of using web2py. I agree with them you should try other frameworks and that will convince you even more that you have made the right choice. You sound like a scientist. I am a physicist. I am all for experimentation.
I'm curious about your book - what sorts of topics will you be covering? How does it differ from some of the other books already on the market, e.g. http://amzn.com/3642024742 ? 
Thanks for the feedback. My main reason for staying away from the external wrapper generators is just that the C++ program is pretty small and simple, and I'd like to keep the external dependencies to a minimum; plus it seems like this represents a good opportunity to learn how this stuff works in a smallish sandbox. If it gets bigger (inevitably it will...) I'll start thinking about boost or swig.
&gt;ACSI That'd be ASCII.
Learn both, and when you're done, learn another one, and repeat ... that's what you'll probably end doing if you work as a developer
Cool, I look forward to it!
You should look into Cython: http://docs.cython.org/ Wrapping C++ with Cython: http://docs.cython.org/src/userguide/wrapping_CPlusPlus.html Writing to the Python C API is a tedious and error-prone process, as you have to manually deal with reference counting issues and whatnot. Ctypes will also work, but it's more at a function level, whereas Cython will actually make it feel like you have a Python version of your C++ class.
by the same argument we should all use php. hopefully new users are more risk takers than conservatives.
It's only a partial Jacquard loom. It'll do brocade and damask, but there's no matelasse support.
I assume GAE is not your sole target for web2py so why discouraging people from using py3k?
Dive Into Python 3. I think it's better than the original (Dive Into Python), and once you've learned Python 3, it's not too difficult to switch to Python 2 if needed.
As dynamically typed, I think Python is not best choice for everything. I prefer compiler errors to random runtime errors. Some background: http://en.wikipedia.org/wiki/Type_system#Static_and_dynamic_type_checking_in_practice But for the original question, learn both and few more :) 
/r/learnpython
ctypes with c++ won't really work, see http://stackoverflow.com/questions/1615813/how-to-use-c-classes-with-ctypes
I only read the second edition so Im not too sure sorry
Basically, but it's a pretty different system. They developed tools like shiboken to automatically generate bindings from XML and so forth. They also didn't support python 3.x last time I checked.
You'd probably do better with SIP over SWIG. Just sayin. 
How fast do you want to see some results? Python and Java are simple languages at their core, so you should be able to pick up the basics quickly enough. PyGame is a powerful framework, you could get a basic game running just by following a tutorial and without a lot of code involved. I don't know of equivalent Java game frameworks, but they may exist. 
Cool, many thanks for the detailed response. I will take a closer look at Shiboken as well.
was searching some python tutorial, found this. made my day :D
If you're working in Python 3 (which is possible, using Pygame), cx_Freeze is the only option, as far as I'm aware. I'm working on [better documentation](http://readthedocs.org/docs/cx_freeze/en/latest/) for it.
I'm a fan of Python but I think there's more money in Java? 
But we're not talking about a beginner in 3 years, we're talking about a beginner today. If in 3 years the beginner will find an excellent Python 3 landscape, recommend it to the beginner *then*. I think you're underestimating the long tail of libraries Python users use (focusing on a few "important ones"), but I might be wrong myself. 
PySide does now support Python 3.
Agreed, learn an easy language first, you'll learn a lot about what's important in programming and you don't be too distracted by boilerplate. Then learn whatever else you'll need later. 
I enjoy the mischaracterization of C as a language with "lots of strict rules". :) C doesn't have a lot of strict rules, which is what helps make C powerful for system-level programming. C doesn't even have array bounds checking, and its type checking is um, not very advanced and easily circumvented. C isn't also a complicated language with a lot of semantic rules if you were talking about that. C lets you get away with lots of stuff and that can be useful if you know what you're doing and you're doing systems level programming. But for most programming tasks that's not so great as it invites mistakes that make your program leak memory or just plain crash with a segmentation fault, or even worse, some security weakness. You can compensate for the lack of safety net by employing a lot of strict rules of your own, a lot of discipline, and some good libraries, but you'll end up writing more verbose code than with a good higher level language. Only in the sense of the needed discipline by the developer is C a language with lots of strict rules. Anyway, the characterization of a programmer's education having an "intermediate stage" where they need to be exposed to a strict language with frustrating rules is one that needs to be backed up. I myself felt a lot more creative when I moved from C++ to Python back in '98 and while I was intermediate back then, now I'm an expert. 
That is true. But on the other hand, a beginner will need to get a good grasp of the language and standard library first, so wide library support is perhaps not essential initially, as long as there are at least *some* libraries available for what you need. Regarding the "less important" libraries, I guess my assumption is that smaller libraries (because, for the most part, unless it's popular a library won't grow to the size/complexity of e.g. django) tend to be easier to port if they are actively maintained. But you're right, it's not really as clear a choice to go with Python 3 at this point. Perhaps learning 2.7 and reading up on the changes to 3 once the beginner has a good grasp on the language is a safer option for now. I sincerely hope that a couple years from now it will be possible to recommend 3 to beginners without hesitation.
Might be, but depends on what kind of industry you're looking into for work.
I remember stumbling upon Reinteract once and thinking "wow, this looks cool, i need to check it out when its more mature". But then it looked dead in the water for 2 years. Nice to see they've made a comeback.
Django wouldn't be the obvious place *just* because it's the most popular one. It's also decent enough to encourage reasonable development patterns, powerful enough to solve many development tasks, and has beginner-friendly culture and documentation. It isn't my tool of choice, but it's a decent tool and a decent tool for a beginner, indeed. 
There's also more competition, and a lot of veterans.
I didn't know about this. The amount of options is actually overwhelming... I wish the community came up with some sort of agreement in best practices like we do with packaging alternatives. For this topic there seems to be a lot more work done than discussion.
You are never too old to start programming. If you're just doing it to try and gain employment I would rethink it though. Higher level programming jobs tend to be great, but you should choose a career you want to have a love affair with. Python is easier to pick up, but play a little with both and see what you like. I'd spend 2-3 months working in one then switch. If you choose python, it doesn't matter that much, but 2.x is probably best just to avoid any issues with library incompatibility or unicode encoding. If you decide you prefer python and want to continue down that road, look at what sorts of problems you want to solve and see if the libraries in that area are 3.x compatible. If so, I'd move forward with 3. Otherwise, look into 2 but play with 3 occasionally just to understand the differences. Overall, do it for love and view yourself as an artist. If you take that viewpoint you will be happy. 
Oh, I see! That makes a lot of sense, too. Though I imagine, for a beginner, they won't need as many resources to get things done. Printing to STDOUT and reading from STDIN is a pretty simple thing to get working....
Does it work on Windows?
I'll recommend other free books too: http://cs.simpson.edu/cmsc150/ http://inventwithpython.com/chapters/ http://inventwithpython.com/pygame/chapters/
We need more info: what sort of data do you want to push? Is it relational or just semi-structured blobs? Do you just want to use the website to push data back and forth, or do you have other things in mind? Do you just want to use R, or are you interested in doing something in particular for which we might be able to suggest better option? 
awesome find!
It would be good to post this on /r/learnpython 
It's good, but needs more documentation.
You can use it in the same circumstances as in the aliasing tutorial. But this tutorial isn't meant to say "hey look, aliasing is this really cool thing!". I believe it's meant to teach "hey look, with aliasing really strange things can happen to you. If you ever experience such strange effects, this is why."
I love it when people do stuff like this.
Thanks!
The examples don't look very complicated to me -- I don't know C++ but the last time I had to wrap a C++ lib in Python I fumbled my way through it well enough using SIP. The reason I've never liked SWIG is segfaults -- I've had libs built with SWIG segfault on me more than I care to remember. Probably not SWIG's fault, but still, it leaves an impression. 
Start with learn python the hard way, read a book called how to think like a computer scientist with python and then watch mit intro to comp science course which teaches python. After all this you are ready for getting your hands dirty with django
&gt;After all this you are ready for getting your hands dirty with django assuming the OP actually wants to do web development. not everybody does, and there's plenty of other reasons to use python besides web development. But web development is the only reason to use django. when all you have is a hammer... :)
I shall look at learn python the hard way! but other people say to use think like a computer scientist. So what should I do? Also web development seems like an exciting field and does interest me but what else can python be used for? I shall have a look at what you have suggested and then I shall get my hands dirty with python! Thanks, Tiptopgolfy
I don't know how to download it, but amazon offers a free kindle app, Windows only though I think. http://www.amazon.com/gp/feature.html/ref=kcp_pc_mkt_lnd?docId=1000426311
If you run into problems with PyInstaller, this guide may help: [Simple Guide to Using PyInstaller](http://bytes.com/topic/python/insights/579554-simple-guide-using-pyinstaller)
The app works on Linux as well, and I guess it should work on OSX. I really wanted access to the file, oh well :)
Pygame works fine and seems like it's exactly what you need.
Do you know if you actually need a full multimedia library? You might be able to get away with a GUI framework's canvas if you're not doing anything very complicated. Otherwise I would just use pygame or pyglet. 
If you have a kindle you can use calibre and some plugins to convert the azw into an unDRMed mobi. I think you can also use the Kindle desktop client, but when I tried last year I couldn't get it to work.
There is a [free Kindle app](https://market.android.com/details?id=com.amazon.kindle&amp;hl=en) in the Android Market, so you can read this on your Android smartphone or tablet.
Worry not. The last few startups I've been, I'm consistently the only guy with CS degree. A lot of people in the industry care more about how well you can code.
Surely decorators aren't especially complex? I mean, once you know that: @my_decorator def my_function(): pass is equivalent to def my_function(): pass my_function = my_decorator(my_function) The rest is just base principles, right?
You can do more with it though, which I think is the point. You can pass more than the single parameter to the decorator. I haven't read the book so I'm not entirely sure. And decorators always seemed a little like magic to me.
Well, yeah, you can pass a parameter to a decorator if you define it that way, but it's the same equivalence: @my_decorator(arg) def my_function(): pass = def my_function(): pass my_function = my_decorator(arg)(my_function)
A beginner might like to see pretty graphics on the screen or doing a web page instead of doing boring stdout and stdin stuff. 
Concerning performance: * if you're writing pure algorithmic code and you're using the same algorithms, Java's faster than Python. Caveat: PyPy. Cython. * if you're writing pure algorithmic code and you're using a different algorithm in Python because it's just a lot easier to do that in Python, your Python program may end up an order of magnitude faster. * if you're using an external C or C++ library binding to do your work in Python, Python might end up being a lot faster too. Numpy. lxml. * if you really need fast algorithms neither pure Java or pure Python are ideal solutions. Investigate other languages. But: Python does bind more easily to fast algorithm libraries in C or Fortran than Java does. * you're right, many applications don't need pure algorithmic speed. There are definitely tradeoffs that make Java a better choice in a performance conscious scenario. There are also tradeoffs that make Python a better choice. Performance is difficult. 
hey! thanks for turning me towards dash, this is really an awesome program! It says on the dash website that python documentation is included with dash. Is that the docset that you created here and it will be included with a future release? (cause i just installed it and i do not have a python docset included by default) Also, the directory it says to install to was not created by default, don't know if that is normal or not. 
ah ok, thanks =) will the docsets for both versions of python be inclided? or just 2.7?
he responded below, python2 is probably most widely used, but im sure your blog post will be one of the top hits in a couple of days for 'python 3 docset dash" so it shouldn't matter too much
As a side note, this was incredibly un-obvious when I was trying to figure out how to make decorators take in arguments.
Yeah, you have to download with an old version of Kindle for Windows. register that copy with your kindle account. login to your kindle account via a browser and "send" the book to your kindle for windows device. Then you need to run `unswindle` to get a DRM-free .mobi instead of a .azw. I do this in a Windows VM, but someone said something about calibre plugins. I'll have to look into that (be a lot less clicks).
I wasn't arguing it. I'm just saying, it isn't entirely obvious.
There has been a lot of work on [Kivy](http://kivy.org/) lately - it has a nice widget system, integrates OpenGL ES 2, and has flexible back-ends for various aspects of graphics - see 'kivy_options' on [this page](http://kivy.org/docs/api-kivy.html). To get an idea of what people are doing with it check out some of the [first Kivy contest entrants](http://kivy.org/#contest). Edit: one more thing, it is REALLY easy to get Kivy running on Linux, Mac, and Win - there is a single package installer.
Generating log text is easy, generating log messages that help in debugging is tough.
Wouldn't the obvious solution be to just catch the exception, i.e. install a top-level `try` block? Then you can do whatever you want with the exception. 
Thanks for the suggestion. I will give this a try. My only concern is that such global handling of an error won't yield a traceback, which makes debugging much harder. Still, a good idea...
I recommend looking at these free on-line books: http://cs.simpson.edu/cmsc150/index.php http://learnpythonthehardway.org/ http://inventwithpython.com/chapters/ http://inventwithpython.com/pygame/chapters/ 
And if you want even simpler and use one logger for everything: http://blog.zioup.org/2011/0918/how_to_change_logging.basicConfig_configuration/
I would recommend using a logger to add the exception to a log file. Loggers can be complicated, but I recommend learning a logging framework and using it all over your app (debug statements, etc.). Just a quick search of the built in logging framework show some exception handeling. http://docs.python.org/library/logging.html
The stack trace is available to the exception handler as the third element of the tuple returned by `sys.exc_info()`. The [`traceback`](http://docs.python.org/library/traceback.html) module provides a variety of functions for formatting and printing the information. 
Doing decorators with arguments as nested functions instead of classes makes my head feel explode-y. Use classes people!
No, it's not easy if you're using log4j. 
reversed is a built in function, hth
Kivy looks interesting for this but it appears geared towards games. I'm sure with enough reverse engineering and widget- and library-building it would work great for business apps. 
[Invent Your Own Computer Games with Python](http://www.amazon.com/Invent-Your-Computer-Games-Python/dp/0982106017/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1329800521&amp;sr=1-2)
Depends on how you want to do it, but this works: string = "hello" for i in range(len(string)-1, -1, -1): print(string[i],end="") 
Instead of "&gt;" use four spaces to show your code. I assume you've got the reversing part of the code working. If that's the case, then an **if** statement is probably what you're after.
Python does exist on Android as SL4A and python-for-android as Rhomboid pointed out. Java is a much better choice for Android development because it is well-documented and well-supported and has much better development tools (Eclipse, etc.) and integration. Java is also compiled and a good deal faster than Python. This is especially important on the Android where speed is important. Android also tries to use multiple cores and the current trend is Android phones seems to be dual core and quad core phones are being announced soon. Java on Android is well adapted for this and Dalvik is designed for this. Python is not. Java is not a bad language (although I *prefer* Python on computers) and computers and mobile platforms are very, very different with very different design goals and requirements. Use the tool that's best for the job.
(I'm a long time Pythoner and an Android developer.) The native API to Android is Java (actually [Dalvik](http://en.wikipedia.org/wiki/Dalvik_\(software\))). If Python was also first class on Android then it would require a large amount of duplication. It would also require a new Python implementation since CPython can't be used (the GIL) nor can Jython (generates bytecode). However you do not need to implement your entire app in Java. Use each language for what it is best at. For several of my apps, the "outside" of the app is indeed implemented in Java, but the UI is a [WebView](http://developer.android.com/reference/android/webkit/WebView.html) and then a lot of the code is in Javascript [calling into the Java](http://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface\(java.lang.Object, java.lang.String\)). Phonegap and similar projects work in a mostly similar way. But if you do everything in Javascript then performance will suck. In another app of mine, the majority is in Java but there is also a [Java Mini Python](http://code.google.com/p/java-mini-python/) inside that allows for changing some behaviour without having to touch the Java, and letting other developers write in Python for the non-performance sensitive parts of the app and respond rapidly to changing requirements. Other apps like to use Lua. For example Angry Birds has much of its scripting in Lua with a native code based game engine. Yet others use Unity/Mono for cross platform code and engine. The lesson is that you are not restricted to the entirety of the app being in one language on Android - you can mix and match them according to their strengths and your needs. While Google has released [Python for Android](http://code.google.com/p/python-for-android/), what they actually did is port CPython and then make another Java process with the CPython code then doing calls to the Java process to access the Android API. This is suboptimal in many ways.
I will give you that they are good and that I enjoy programming in Java (usually) and many of my friends enjoy C#, and I'm sure plenty of people enjoy Objective-C. But "excellent"? I'm not sure about that one.
Thank you. My eyes are happy. 
If you don't care about modern rendering techniques, pygame is good enough for you. Otherwise, you're out of luck because pygame uses OLD tech (from the 90s, the last I checked) and you'll be limited in terms of rendering speed, especially on rotations, alpha/translucency, and scaling. If you do care about modern rendering, pyglet is your best bet. It has a few idiosyncrasies but the library is fairly small (unlike SDL) and more of it is in Python so you're more likely to be able to twist it to your needs. I also seem to recall it did a better job of audio and video than pygame. SFML is a great library in C++ so that is definitely one to look out for, but if the Python bindings aren't ready, you're better off sticking with one of the alternatives. Personally I would choose pygame, but I don't tend to do multimedia apps with Python any more because the community as a whole just doesn't care about it. (Look at some of the relatively useless stuff in the stdlib and compare with the lack of decent multimedia support and you see it's an uphill battle. If you leave a language too long with certain support missing then eventually the community ossifies into mostly just people who don't need that stuff.)
LPTHW is a great resource ( http://learnpythonthehardway.org ). Even if you *know* the stuff make sure and go over the tedious parts. It's a great way to get your brain in the mode of programming. You don't really copy code either. The exercises have you copy a sample script and then modify it, fix it, or explain why it's working. If you learn well by example then this will be a great resource.
The idea is that from the Zen of Python: Errors should never pass silently. Unless explicitly silenced. GUI applications on Windows don't have a terminal to display the error in, so cx_Freeze puts it in a message box instead. If you don't want to see it, you can either catch exceptions explicitly, or replace [sys.excepthook](http://docs.python.org/library/sys#sys.excepthook) to do something else. As karlw00t suggests, one option is to log it. By the way, I'm working on [improved documentation](http://readthedocs.org/docs/cx_freeze/en/latest/) for cx_Freeze. If you want to help, you can fork [the repository](https://bitbucket.org/takluyver/cx-freeze) on Bitbucket.
That's useful info, but it's about something a bit different: avoiding errors when you try to `print` and there's no stdout/stderr to print to. The OP wants to suppress the message box that appears when an error occurs (for whatever reason).
It's not because we made a game contest that Kivy is made for Games. Interesting that before the contest, the inverse was said too. I'm using Kivy for professionnal products (more classic), i should produce some screenshots and publish them. Check the gallery to see that Kivy is not made only for games :)
Just a short recursive one: def reverse_string(s): if len(s) &lt;=1: return s else: return reverse_string(s[1:]) + s[0] 
&gt;Cython is a pleasure to use but to wrap C++ you need to make a stub function manually which could be tedious for large libraries. Cython has decent support for C++. You only need to write wrappers for special cases.
Java is annoying when you come from a scripted language. It does require much more code to accomplish the same task.
Yeah, wihile I agree with johnmudd to a point, the part about Java needing more docs than other languages does not correlate with my experience. Quite the contrary, the obtuse, wordy and redundant syntax of Java make most libraries underpowered and self explanatory, where a more powerful language will often lead to more versatile and powerful libraries that need more documentation to fully define their limitations and possibilities.
* Support for closures, first class functions and functional programming in general is either non-existing or obtuse and clumsy. * While reflection exists and is mostly feature complete, it is far too limited to allow real meta-programming such as e.g. meta-classes in Python, not to mention anything like LISP-style macros. * Static typing is a fine idea, but when it isn't coupled with any type inference, it becomes a time wasting chore. * Primitive data types like int, char and arrays, that have completely different semantics from regular objects. **Ugh** * No continuations. * For various reasons, all of these languages force you to write major chunks of boiler plate. I believe the word you're looking for is not excellent, it's tolerable.
It'd be great to be able to see the source of some dull-as-rocks data collection application written in Kivy that you might otherwise write in something like jQuery Mobile + phonegap or so.
I can code in Java without an IDE, but what's the point of doing that ? What is wrong with having an application that helps you handle the complexity of the architecture you use (handle debugging, multiple servers...) ?
I haven't used it much (I don't have an android device of my own) but [PySide will run on android](http://thp.io/2011/pyside-android/). Right now I'm just writing stuff in PySide/Python to run on Linux/Win/Maemo/Meego/Mac.
thanks, I will check it out, but this is what I am talking about! Why doesnt Google put money towards this type of stuff? This is all strategic bullshit they are doing for control and money and not making a quality product. 
I don't have a website.
Absolutely. When I do Android development, even the simplest of apps requires an insane amount of code, and a crazy hierarchy. The examples provided are usually so syntactically dense that it's difficult to do anything without finding someone who's done it before you. I will bear a child for the person who makes it possible to develop Python for an Android app. 
Sorry promotion was just for President's Day
&gt;Java, Objective-C, and C# are all excellent languages Beauty is the eye of the beholder. Not saying that the OP is necessarily right and I'm definitely not saying Python is the best language for every need. But I too wish Python API's were natively available on iOS and Android. That would be awesome. Hell, I wish Python were the default client side language used in all browsers instead of Javascript. 
Thanks for the feedback. I'm trying to figure out a nice way to tie descriptors into the picture to deal with static|classmethod. WRT wraps, I'm not sure how to be more emphatic about it... I recommend using it or updating the corresponding dunder attributes it updates.
I am not surprised, Pyramid is *very* fast. Not always faster but they both play in the same league. The difference is so small that it is hard to say *why* one is faster than the other. The most noticeable difference: Bottle uses threading.local() while Pyramid passes the request&amp;response objects explicitly. It depends on the scenario (gevent or not?) which solution is faster.
In addition to that, I've started to write a JavaScript library for the Slicer server (not mentioned in the blog post). I am just starting with JS, so pardon my style. The sources can be found here: https://github.com/Stiivi/cubes.js No examples yet, however the goal is to be able to browse aggregated data directly from JS and transform them into tables/charts. Concerning backends: I have not much time to write other backends, however, if anyone is interested in helping me with them, just drop me a line. I would like to have at least nicer star-schema browser and perhaps the mongo DB backend.
Not to mention good static analysis from tools besides the compiler and lots of help from a decent IDE. Java (and other statically typed languages) are nice in that regard. Both are definitely worth having in your pocket.
Depends. I know a few python programmers that make plenty of money. I don't think python has the stigma of, say, identifying one's self as a VB programmer or PHP programmer has, but that is just my opinion. Plenty of VB and PHP programmers make a good salary as well, I'm sure.
For the curious among us, is there any documentation you can point to in reference to the reasoning behind the choice of thread locals/explicit passing?
No. It changes depending on if the decorator is passed arguments or not. What a confusing pain: @deco def fn(argument): pass @deco(dargument) def fn1(argument): pass is equivalent to deco(fn) deco(dargument)(fn1) without the function definitions. I get around it like this for functions that do both: def decorator(fn=None, kwarg=default, kwarg1=default): def wrapper(fn): ... return fn if fn: return wrapper(fn) Also, as mentionned by another redditor, **use functools.wraps** and take a look at functools.partial :)
&gt; As I said, I'm new to Python so, if I say anything stupid, please be gentle... For what I know pydoc and epydoc areused to generate documentation from docstrings. Absolutely correct. &gt; This script and Dash are used to browse through Python's documentation quickly. Hmm, all right. But does your script/Dash end up using docstrings anyway? Or does it actually pull all the extra stuff in the online Python documentation? As a reference point, consider the documentation associated with 'csv.reader'. With pydoc, I get: &gt; csv.reader = reader(...) &gt; csv_reader = reader(iterable [, dialect='excel'] [optional keyword args]) for row in csv_reader: process(row) &gt; The "iterable" argument can be any object that returns a line of input for each iteration, such as a file object or a list. The optional "dialect" parameter is discussed below. The function also accepts optional keyword arguments which override settings provided by the dialect. &gt; The returned object is an iterator. Each iteration returns a row of the CSV file (which can span multiple input lines): And two final questions: 1. Can your script handle documentation other than the official online Python docs? 2. Can I use your script in a Linux environment? Thanks! (And I wasn't trying to be harsh---just wanted to know if your script can be helpful to me!)
Interesting. A big problem with the OLAP field is that entrenched players are massive, so you're up against tools that can already do everything any user could think about, sold by laser-focused sales team. Still, with a simple GUI, it could have a very good market in small-to-medium companies.
I wonder if you have seen the [Python on a Chip](http://code.google.com/p/python-on-a-chip/) project and their [PyMite VM](http://wiki.python.org/moin/PyMite). It's not the same thing you're talking about, but it might be interesting reading.
I know! Where's the Fibonacci web service?
Yeah i know, thats why I tried it with an incr and 2000 char get from redis. Not perfect.
Sure. I was keep track of my learning journey so I wrote some blog posts here www.pragmaticstartup.wordpress.com Hope it helps!
Awesome, checking it out... thanks! Finance major here as well and worked for one of the ibanks in New York. Former coworkers/friends think I am crazy..... they just don't understand!
Well, Python's [the easiest](http://www.python.org/dev/peps/pep-0020/). Shall we take a look at the three using this framework? *Beautiful is better than ugly.* Perl: no. Ruby: yes. *Explicit is better than implicit.* Perl: no. Ruby: no. *Simple is better than complex.* Perl: no. Ruby: no. *Complex is better than complicated.* Perl: ?. Ruby: ?. *Flat is better than nested.* Perl: ?. Ruby: ?. *Sparse is better than dense.* Perl: no. Ruby: no. *Readability counts.* Perl: no. Ruby: debatable. *Special cases aren't special enough to break the rules.* Perl: no. Ruby: no. *Although practicality beats purity.* Perl: yes. Ruby: yes. *Errors should never pass silently.* Perl: no. Ruby: yes. *Unless explicitly silenced.* Perl: yes. Ruby: yes. *In the face of ambiguity, refuse the temptation to guess.* Perl: no. Ruby: ? *There should be one-- and preferably only one --obvious way to do it.* Perl: no. Ruby: no. *Although that way may not be obvious at first unless you're Dutch.* Perl: no. Ruby: no. *Now is better than never.* Perl: ?. Ruby: ?. *Although never is often better than *right* now.* Perl: ?. Ruby: ?. *If the implementation is hard to explain, it's a bad idea.* Perl: ?. Ruby: ?. *If the implementation is easy to explain, it may be a good idea.* Perl: ?. Ruby: ?. *Namespaces are one honking great idea -- let's do more of those!* Perl: ?. Ruby: ?. ---- There are some things that I don't know enough about the language designs to say anything about, but you'll notice that Perl disagrees with Python on just about everything, and Ruby disagrees on most things, although not as many as Perl. Now, this doesn't really say anything about Ruby and Perl agreeing with each other, but merely that they have a tendency to disagree with Python. Ruby was created because Matz wanted "a scripting language that was more powerful than Perl, and more object-oriented than Python. That's why I decided to design my own language." In my experience, that results in a language that feels like Perl combined with Smalltalk's object model, but I admittedly have only brief experience with Smalltalk and limited Perl hackery skills. Anyways, Ruby has most definitely inherited Perl's TMTOWTDI philosophy; many functions have a number of different aliases, and often one function can be used to do the same thing as another. I guess, when it comes down to me, I notice Ruby's regex syntax, the short-circuiting, the backtick-execing, the optional terse syntax of blocks, and it reminds me of Perl.
"in" what? what exactly do you hope to accomplish?
It's not accurate. I'd be surprised if the equation was anything other than time since the beginning of the countdown multiplied by some constant. Although I would love some way of doing that with any other framework.
The javascript behind it appears to base it upon the current number of downloads and a linear estimation of the rate of downloads over an unspecified period of time.
Most of numpy and scipy is native C code with a very thin wrapper to python. Python optimized hardware would like be of little benefit to them. On the other hand, a GIL-less python with a nice stable ABI would be great.
Image you're driving a car. Python interpreter is the engine, Eclipse is the car, and PyDev is the eletric system, wheel, brake...everything that enable you to control your car
You can never be crazy chasing your passion :D Actually, let me take it back. We are all being crazy, as judged by general societal standards but that's also precisely why crazy people make a difference in the world today.
[SLOCCount](http://www.dwheeler.com/sloccount/) does a very good job of basic source code analysis for many languages, including Python, and [PyMetrics](http://sourceforge.net/projects/pymetrics/) performs more sophisticated Python-specific analysis. I don't want to discourage you from attempting a project that could be interesting, but if you're going to solicit funds you'll want to be aware of your "competition."
Throwing http://cloc.sourceforge.net and pylint / pyflakes onto the pile. Contributing to these projects is much more worthwile, and you learn a lot more by doing that. And if you want to do a unskewed market research, you should choose a market that is NOT already saturated plenty.
where web2py ?!
I have a few small projects I'd love to have tiny, cheap hardware to run Python on. One is a [Boodler](http://boodler.org/)-running hardware device that could be sold for really cheap to allow people to design and listen to their own soundscapes on (I get a lot of compliments/interest on my own “stormy weather” soundscape, which I sleep to every night). Another is a box for doing remote control over serial cable of my television, amp, and blu-ray player (I have implemented all of these interfaces from scratch based on the manufacturer's documentation for their devices; sadly there doesn't seem to be a popular open-source market for this stuff as having an actual computer control these devices was probably always considered too expensive). Currently I'm using a [TrimSlice](http://trimslice.com/web/) box for doing this, but it's still overkill as I only need one USB port (for my 4-port USB-to-Serial breakout box), no audio/video out, and have no need for so much RAM or CPU power. I think if these boxes suddenly cost &lt;$100, there would be a lot more market uptake as serial control is becoming increasingly standard on home theatre devices, and is superior to infrared control in almost every respect (although mainly because of the presence of bi-directional communication). The consumer market alternatives right now, like the Logitech Harmony product line, are completely awful. I think the [Raspberry Pi](http://www.raspberrypi.org/)—if it turns out to be as good as it looks (and hopefully we'll find out soon)—is going to scratch both itches, though, without having to be specifically “Python-optimized” at all; that price is just amazing for something that has Python installed straight out-of-the-box and can also play full 1080p mkv videos (it wouldn't surprise me in the least if it becomes a popular budget-HTPC option). In fact, one of the early adopters has already written a bunch of [Python Tutorials](http://www.youtube.com/user/RaspberryPiTutorials) specifically for users of the device; I'm pretty excited to check some of those out and see what it can do. 
[You *can* write JS/HTML apps that can access the Android API.](http://phonegap.com/)
I'm quite sure that a lot of people would join you—Your $100 might cover the hardware, but any vendor that provided a "plug and play" software solution would have to charge several times that much just to cover operating expenses. The problem is the protocol to talk to the devices; they're very time consuming to create because you have to implement an entire protocol and handle responses instead of just blasting commands unidirectionally, and the closest you get to a "standard" is that the devices accept a serial connection at all. For example, two of my three devices use a so-called "null modem" cable, which is usually for two computers to talk to one another over a serial cable, where pins 2 &amp; 3 (Tx/Rx) are reversed—But the third device uses a straight cable like a serial accessory (e.g. a mouse) would do. Another example is that my amp and blu-ray player are both made by Cambridge Audio, and the TV is by Sony. But none of them have anything approaching the same protocols; even when manufactured by the same vendor. While Sony's protocol is way more standardized between devices, it is the most nightmarish to implement as all of the commands are documented in hexadecimal, each command requires a length argument, a checksum, and must be binary-encoded—And its responses are virtually non-existent (OK, or one of several classes of exception); there are no query commands, which is lame. Another incredibly annoying point is that some vendors, like Sony, seem to go out of their way to prevent the device protocols from being freely available to the public, making it very difficult for amateurs like me to implement their protocols. At least Cambridge Audio does an excellent job of documenting and publishing APIs for each individual device; it would be impossible to create them without it. I think the fundamental problem here is that in order for the price to be as low as you want for the hardware *and* the software, a company would have to be selling hundreds of thousands of units to pay for all the software development required to implement the protocols of as many devices as they can, as is the case with Harmony—But a serial-controlled solution would almost certainly be too much of a challenge for many consumers to wire up themselves, and would (I think) necessitate locking consumers out of the device lest they just steal the software and put it on their own cheaper hardware (without paying for the software component by buying the package deal). So until the day when all devices implement a standard protocol—and probably using a higher-level interface, like Bluetooth or USB or something—it's going to remain the domain of amateurs like me, and well-to-do folk that hire companies to make custom AV integrations for their home, business, church, school, or whatever. In case anyone is interested, my stack looks like this: * low-level API interfaces that implement the device protocols directly (using pySerial); * a mid-level API that provides some nicer interfaces to common tasks (like turning on the hardware, setting a desired input, and setting the volume); * a high-level API that combines all of the devices into activities (e.g. "watch TV", "play a game", etc.); The latter is only partially written thus far but handles all of my most common tasks from a Python command-line interpreter. Still to do: * a RESTful web service that provides access to the mid- and high-level APIs via JSON; and * a "veneer" HTML 5 web application that implements the RESTful web service for running on a tablet. For a while I considered writing something in Kivy, and that's still a possibility—But HTML 5 looks like it will run on more devices with very little effort, and I'm very comfortable with HTML/JavaScript development as it's what I do all day already.
&gt; What do you think would be good project to fundraise for. You're doing the work, so I can't answer what you'll do for money. &gt; Is there a place where this could discussed that has more python users as well as python companies. Well there are 27,977 readers here. I have no idea of its size, but the only other large community I know of where you could ask this question would be [python-list](http://mail.python.org/mailman/listinfo/python-list). However, I don't think any of them are qualified to determine what you'll do for money either.
I think it's great that people are noticing this and investigating, because it's fun to look into these things, but I hope people aren't going through all of their code and changing every `while True:` to `while 1:` after these recent posts.
It doesn't make sense at all in normal circumstances to only use integer instead of boolean. As mcilrain said, readability is a big factor, but knowing this issue maybe helps if it comes to the last % of performance. And there are people who care about performance. I like to write fast programs, if necessary, and still don't want to write C.
Two key things wrong: `calories_burned = int(3.9)` - int means integer (a whole number). 3.9 isn't an integer, so it will be rounded down to 3. Your input comes in as the text "10", not the number 10. 3 times "10" is "101010". You need to work out how to convert the text into a number. You already know the function you need to use. ;-)
If you care about performance, why not test it in pypy too? Would pypy have the same problem with True?
Please use the correct highlighting when you pastebin something. You don't need to import math or operator. calories_per_min = 3.9 print "Recording Calories while running on a treadmill" time_spent = raw_input("Please enter the time spent running on a treadmill you wish calculated into calories burned.") try: time_spent = float(time_spent) except ValueError: raise Exception("Please enter only a number of minutes.") print "Total calories burned are %.2f over %.2f minutes" % (time_spent * calories_per_min, time_spent) 
True and False in pypy are also globals. But the globals look up in pypy is way way faster than in CPython. I will update my post and add this informations, I never looked into pypy, is pretty damn fast. Timings: boolean: [0.16, 0.14, 0.14] integer: [0.16, 0.14, 0.16]
You're right - I was thrown off by the "localize" function that they promote use of (over using them as tzinfo objects).
You should trim those insignificant digits.
When helping new programmers, I think it's more useful to give specific comments, so they can fix their own program. Simply showing a complete working solution isn't as much good for learning.
Amazon will give you a year of hosting on a micro Linux instance for free with reasonable traffic. After that, it's like $8 / month I think for that VM to run continuously. I'm in the process of moving 40 or so Wordpress sites onto it, and expect to pay about $20 / month with all the bells and whistles I want. Here's a [link](http://aws.amazon.com). Also, since I'm a shameless capitalist and an affiliate marketer, here's an [affiliate link](http://aws.amazon.com/?tag=lsforum-20) that might make me a couple bucks if you click it and then buy something :) ETA: I like the app, too. I don't have a direct use for it, but I would probably steal some of your CSS if there were a clearer license. Your only requirement seems to be that the copyright notice be there - does that mean that your LLC is claiming copyright over all derivative works based on this code?
Use a framework. http://wiki.python.org/moin/WebFrameworks
new to python but "wrote a lot of python programs..."
Django is almost certainly the most popular because of its “batteries-included” approach; it includes just about everything you need to build an application, including built-in model abstraction to multiple different database platforms (e.g. SQLite, MySQL, PostgreSQL, others). Its documentation is excellent. Its community is very active and releases drop frequently. Disclosure: I've been developing with Django as a hobby for about 5 years now, and have used it to write several commercial web applications in production. Reasons not to like Django are the fact that it is fairly rigid (despite claims otherwise) and probably includes a whole lot of stuff you don't need. It also rather imposes its paradigm on you, which might be a bit more than you want to bite off if you just want to cobble together a simple little web site/app using Python to get your sea legs. If you want to learn more about Python, you might choosing something lower-level and building more of the pieces yourself. Unfortunately my experience in low-level frameworks is limited to CherryPy, which is quite bare-bones and somewhat dated. I can't say I'd recommend it at this point, but YMMV. I'll defer to others' superior judgement in the matter of which framework to choose because I honestly just haven't had the time to play with them all and know which is best. I know and like Django, so I'm sticking with it for the forseeable future.
There is also [Panda3d](http://www.panda3d.org/) which just had their 1.8 release, but it is probably overkill for your needs.
My first thought: Awesome! A project for my son this summer! *click* Oh. A full sized car. That may be a less than prudent project for the ten year old. (Looks awesome, though!)
Look, I'm a big believer in open source and high quality code. I'm just trying to find a way to have it be self-funded. There has to be a more efficient way to "clear the market" as it were so that open source code is more routinely than some being employed at companies who get to write open source code and everyone else having to donate free time to it. Now, maybe, python is pretty much complete or saturated, and another domain should be followed. It wouldn't hurt to give advice. Maybe you or others have 100 different ideas that you think should be implemented, but you only have time to pursue 10 of them in the next years.
Django + alwaysdata.com as provider ? No configuration except your django application and the database.
How did you hire your sys admin? If I could get one part time or something that could really be the way to go, the 'managed' guys at Wiredtree aren't even really that knowledgeable, even about their own system.
you are right, my bad. 
Hire? Heh. I'm marrying him :) Anyway, I do most of my sys admin work myself. This is scary stuff, but I've found it's gone a long way to making me more secure with what I can do with my little servers. I know Amazon hires 'freelance' sys admins who can help you diagnose what's wrong with your system. That can be spendy, though, and you have to be pretty high up the AWS chain. You might try going to some local tech meet-ups. You might find a sys admin or two there that wouldn't mind some pick-up work.
Those are both great suggestions. Would you mind opening tickets on the repo with those feature requests? As a community tool, we'd like to mirror the functionality of Desk.com or whatever, but of course, with the ability to actually do stuff server side as you see fit.
sure, i'll submit a bug report... where? using openmpi on an SGE cluster
Hey, nice post, I'm going to take a closer look for some side projects that I'm working on. I'd be interested to hear how a nosql backend like mongo would handle olap. When I've looked at them in the past they've appeared uniformly unsuited to that - unlike a relational database with range &amp; hash partitioning, automatic use of most appropriate summary tables, easy adhoc access, etc. 
so, there’s this thing in html called a &lt;pre&gt; element, if you put your code in that, it might actually be readable… (the only way I can see to read this properly is to copy the source, and replace &lt;br /&gt; with \n, which I shouldn’t need to do)
I live in Utah. I used to work for Cisco systems. We're 20 min away from Oracle. We kinda love Oracle here. 
Absolutely. I'll make a note to do that (working toward a deadline at the moment). I maintain a code review webapp called Review Board (http://reviewboard.org) and a hosting service for it called RBCommons (http://rbcommons.com), and have been using e-mail + FAQs for support and knowledge base. As our users grow, and the same questions get repeatedly asked, a help desk application has felt more inevitable, so I'm looking forward to giving this a try once I have time :)
Yes, it's the 2 AM stuff that worries. I'm not a n00b, I can get some stuff done on my linux server but it's not where I choose to specialize. I have been going to tech meetups in my city (Vancouver, BC) and I will continue to go to more, there's actually a Django meetup which I should check out!
Cool, I will check these guys out, thank you.
If you actually have code where this kind of minor detail is the bottleneck you'd likely gain more from just rewriting that portion in C, Cython, or something else.
I've been seeing `while 1:` in code that was apparently written with readability in mind for a long time. It makes me feel sick. Other languages really do induce brain damage.
I think [Heroku](http://heroku.com) is a very nice solution. It's very easy to deploy and to add features on top of it. It might not be the most cost effective though. But I'd recommend you check it out.
You might wanna try posting on /r/DSP.
That's nothing. One time I managed to merge quantum mechanics and relativity but I wrote it all in ancient Aramaic. 
You print 'yourhand' before you alter it. Is that the problem? Also, you shouldn't set turn back to 0 when the computer gets it right. On a side note, do you have any interest in help cleaning this up some?
That is awesome! If you need a hand, let me know. Plus, when you get it live let me know as well and we'll feature you on the repo/docs as an example install.
How is the code a mess? I would like to know, also, how could printing before i alter it be a problem, i just print it so the user knows what cards they have Edit: OMFG I am an idiot
Probably just a lot of coding. Experience is key. Make sure you understand types and how they are treated in Python. I also used exception handling and string formatting to make it a bit nicer. Read the **entire** [Python tutorial](http://docs.python.org/tutorial/index.html) and you will have a much better handle on it all.
It's not a mess, but it could be more legible. All I mean is making it more Pythonic. That is, this could be more legible and more easily modified if you used classes. And then there are little things like inefficiencies (it's Python, who cares?) and doing deck=numscanask*4 and things like this. It's a side note because it doesn't really matter. On to the important thing. Here's what your prints do. First you ask what card they want. *After* they answer you show them what cards they had *before* asking for that card. Then you give them the card. Thus you do not get to see the effects of getting the card until you ask again, even though the card is in fact there. **Note:** (I'm referring to the prints you have inside your loop, not outside.)
&gt; See, Python threads are very nearly useless So, as it happens I'm porting a Cocoa application to GNU/Linux with Python. When it comes to replicating the functionality of Cocoa's NSNotificationCenter, NSRunLoop, and other GUI-centric uses of asynchronous process control, Python threads are not "useless". The application I'm porting makes use of asynchronous HTTP requestors, IO-bound processes which nevertheless can't be allowed to hang up the UI. The context-switching overhead of these threads is next to nothing. I appreciate the history lesson but your point about Javadocs is not correct. Take any particular piece of the Platform's docs and compare it to the Python equivalent: Platform Javadocs are long and windy and still don't adequately cover the material. The Platform is a windy-ass API with poor bang-for-the-buck.
Check out [/r/learnpython](/r/learnpython)!
No worries - I just mention it to make sure beginners asking questions are aware of it.
... Have you tried talking to your professor? I would *guess* that "write only program level comments" means "write comments only at the top level (i.e. not indented)".
Let's see what code you have so far.
I do like to say that the language doesn't influence your salary as long as you know your shit (well at least amongst popular lagnuages) but I feel there's a certain industry-fuck-im-a-senior-developer-and-youre-rich-so-pay-me atmosphere around Java that just bumps your salary through the roof. Python has more of a open-source-poor-startup-hack-this-eat-noodles-and-shutup atmosphere. I know I know, terrible generalisation but just wanted to get the meaning across.
To answer your question: Yes, subprocess is indeed the right module to use for your purpose. The API is slightly too complex for total beginners, but in exchange it has enough functionality to allow some pretty advanced stuff. I don't know any resources, but I guess you should be able to find some examples on stackoverflow. 
What do you mean by "giving it input commands"? If this is about letting the user type into the subprocess, it will work by default.
Thread locals add a level of indirection (the thread-&gt;locals association) if they are implemented without the help of the interpreter.
Once upon a time, there was a C stdio function called popen. It could give you the output of a forked shell command. Python wrapped this function with `os.popen`. In the early days of python, before this was deprecated, people would just do `output = os.popen('ls -l').read()` but this was deemed dangerous and unruly. The command executed in a sub-shell, so it could invoke unwanted side-effects. The alternatives, `os.exec*` and `os.spawn*` were deemed too complex, or unsuitable for the variety of circumstances under which people might want to launch a subprocess, optionally capturing its output. The subprocess module was born. Subprocess will make more sense if you experiment with what came before.
why not environment branches, i usually do something like merge, fix, commit, merge, rebase, I also use fabric to pull changes into different environments test/staging/prod etc &amp; run any other things that need to happen like db migrations
Simple answer: min() There might be some odd situation (like, if the list is already mostly sorted) when sorting would be faster, but it seems fairly unlikely. min() also makes it obvious what you're trying to do, which is valuable.
Hmm. That is true. And he does have an insane number of RC cars gathering dust...
I disagree. They have a great admin, but their support has gone way down hill. I'm moving all of my sites away from them.
Subprocess is a bit complex if you're new to programming but you are welcome to ask questions here, although someone may complain and send you over to [r/Python](http://www.reddit.com/r/learnpython), which is not necessarily a bad thing. Stackoverflow is another excellent resource to use and one of the best resources for module tutorials is Doug Hellman's site, here's his page on [subprocess](http://www.doughellmann.com/PyMOTW/subprocess/index.html). Doug is a Python legend in my book. In a perfect world, he would rewrite all of the doc on python.org. Anyway, this type of question has been asked a lot here. . . you'll probably do well by reading Dive into Python and Learn Python the Hard Way too, when you have the time.
How does favouring has-a instead of is-a relationship work in practice? If you want to make sure a class has some functions maybe a mixin is one way ? - think I'm misunderstanding has-a vs is-a ?
Not necessarily - you're not taking space into consideration. Sorting modifies the array, which is certainly not something you want min() to do. So a sort based implementation would have to first copy the array, taking a significant amount of extra space. Even if for some bizarre reason this was faster than a simple min calculation, the extra space might deter you from wanting this as the naive implementation.
I've just tried this with a dummy process ["ls", "-l"] and works fine, but when I try it with the process I'm actually trying to use I get an error message: At line 135 of file ../src/userio.f (unit = 5, file = 'stdin') Fortran runtime error: End of file How exactly does python send the input from subprocess.communicate() to the process it opens? Is there a way to send it as just a line of text into the terminal where the process accepts input?
I tend to use subprocess when i simply have to run a command and get its output and return value. If I end up having to send it anything I prefer to use [pexpect](http://www.noah.org/wiki/pexpect).
probably not a good idea :) sorry did not notice the 2-year-old stamp.
Can you suggest any improvements?
Added for you: not great under high concurrency as a server.
Why would you sort it? The most naive solution would be to loop through the list once and capture the smallest value. That way you touch each value once. minval = valuelist[0] for n in valuelist[1:] if n &lt; minval: minval = n I suppose the built-ins like sort may have an advantage from being written in C? Using ctypes to tighten up this loop would be fairly trivial if benchmarking called for it. 
Depends on how you're using your list. If you need the list later, and are already keeping it sorted, then we can ignore the cost overhead of sort (), giving us O(1). However, if you're throwing away the list, then sort() is O(n*log(n)) whereas min() is O(n).
You're better off having two scripts. One to process the files and write its status to a database or file, the other to display the results of the first. I don't know if flask has them, but pylons has the concept of worker threads. I would investigate something along those lines to run the long-running process.
More examples. More than just a few lines from the interpreter's interactive mode. Yes, we have StackOverflow and a bunch of other decent online resources, I just think the core doc could have more (and better) examples. I love Python, I just get frustrated at times when playing around with a new module. Doug Hellman's module of the week is fantastic, I'd love to see more core doc like his series.
uhm, i think some benchmarks are wrong, because l.sort() is inplace whereas sorted(l) creates the new array. in any case, convert whatever you do to numpy array and call the array.min() method. import numpy as np import random In [12]: l = [random.random() for _ in range(1000000)] In [13]: %timeit sorted(l) 1 loops, best of 3: 1.41 s per loop In [14]: %timeit min(l) 10 loops, best of 3: 112 ms per loop In [15]: l_np = np.array(l) In [16]: %timeit l_np.min() 100 loops, best of 3: 2.38 ms per loop
Can you access the zxing barcode module from Kivy? 
I'm using a database ([postgres](http://www.postgresql.org/)) and [psycopg2](http://initd.org/psycopg/) to keep track of my script's status. I use python's [logging.Handler](http://docs.python.org/library/logging.html) to populate a log table and have another small table with current status information. I've got a second script which emails me anytime there is a critical error. Right now I'm just using SQL queries (Navicat Light) to monitor things, but I like your idea of a lightweight web frontend.
Note that this means if you need more than log(n) accesses to the minimum (or, the maximum too) on the same, unchanged list and min/max don't cache, then sorting and accessing will be faster, as for K accesses on an unchanged list, sort+access will have a runtime along the lines O(n\*log n + K), while min/max has O(K\*n). 
+1 for celery: http://celeryproject.org
Not sure if this helps, but scikits.learn has some signal decomposition code: http://scikit-learn.org/0.10/modules/decomposition.html http://scikit-learn.org/0.10/auto_examples/decomposition/plot_sparse_coding.html
That's not really comparable: heap sort may be quite efficient in some cases but you are still sorting the entire data set in order to extract a few elements. Heap insert is O(logN) and popping each element is O(logN) - compare that to filling an `std::vector` which is O(1) for insert, and then using `std::partition` to get the values you want is O(N).
Use a messaging queue and a non-blocking server. I've been doing similar things to log important system events across a network of servers using kombu, tornado &amp; rabbitmq. The tornado application runs a periodic task which consumes a rabbitmq queue every 300 milliseconds, rendering the each event to html, caching it and emitting it to the client via a websocket connection. The long running scripts on each server have a logging handler that send messages via kombu to the queue. You could do something similar, then add a handler to tornado that executes your task via subprocess and you should be all set.
[heapq.nsmallest](http://docs.python.org/library/heapq.html#heapq.nsmallest) doesn't require pre-heapifying the data set. In fact gcc's implementation of `partial_sort` uses the exact same algorithm -- pushing input data through a heap-based priority queue of size n. I don't see how `partition` fits here at all. Python's kind-of-equivalent to `partition` is `filter`.
list.sort performs an in place sort
Adding '\n' to the end of the input doesn't change the error. I'm guessing the problem lies in the program and how it accepts inputs.
&gt; I don't see how partition fits here at all. You're totally right; I was getting it mixed up with `std::nth_element`. My general point remains though, in that nth_element runs in roughly linear time and is more efficient than partial_sort or heapq.nsmallest if that is equivalent.
That's what ic was saying. That list.sort works in place means that min could never use it as an implementation, unless it made some copy first. If list.sort could ever be as faster than min, min still couldn't be a thin wrapper around it.
huey is also nice
Take a look at WinPDB (http://winpdb.org/) for remote debugging.
One other thing that might be worth trying is to leave the input stream open. Does the following act any differently? proc.stdin.write("input value\n") proc.stdin.flush() for line in proc.stdout: print line (It may just block waiting for more input at some stage, but it may get further at least.)
Why does it have to be one script to do everything? Why can the long running script insert it's stats into a database and the flask script reads the data from the database? That would be dead easy to write.
Since nobody said it: use the simpler way. If and only if your program is running slow, learn to profile and find the bottle necks. Minding such things like these is the textbook example of [premature optimization](http://c2.com/cgi/wiki?PrematureOptimization). If you are genuinely just curious what goes on under the hood, learn to do real analysis with modules profile, timeit, and dis.
I had the same problem, before Celery existed. The hardest problem was, in my view, the fact that Python's built in HTTP daemon does not support authentication (HTTP digest), so if you want your web server to communicate with a daemon on another machine, it's not quite as simple as using HTTPDaemon and a pool of subprocesses. My HTTP/digest enabled HTTP daemon is [here](https://github.com/knipknap/exscript/blob/master/src/Exscript/servers/HTTPd.py). To be used like so: from Exscript.servers import HTTPd, RequestHandler class MyHandler(RequestHandler): def handle_GET(self): if self.path == 'start': # Start subprocess here. self.send_response(200) self.end_headers() self.wfile.write('Script started!') elif self.path == 'status': # Status request goes here. self.send_response(200) self.end_headers() self.wfile.write('50%') else: self.send_response(404) self.end_headers() server = HTTPd(('', 8080), MyHandler) server.add_account('testuser', 'testpassword') print 'started httpserver...' server.serve_forever() 
web2py has a [built-in scheduler](http://web2py.com/books/default/chapter/29/4?search=scheduler) which you can configure from the web-based administrative interface. You start the web app and the workers separately. The workers wait and pick up tasks from the task queue. You queue tasks by inserting a record in the database. There is a web2py-celery project too (a port of Django-celery) but nobody uses it because usually the time consuming part is the execution of the task, not their distribution, therefore celery does not buy you much. 
Interesting read but the writing is just bad and it really detracts from the quality of the piece. 
Stack overflow may be a better place for this question. I suggest using a logging system (see logbook) and then create a flask app to read your log. Run the python script as a separate daemon process. If you need hooks to do something (like a halt or a restart) you can always create those as a signal or some other scheme and plug those features into flask.
Just curious: why do you use RequestHandler instead of WSGI? If you use WSGI, you can protect any WSGI app with basic auth in just one line of code: app = BasicAuth(app, users=[('user1', 'pass1')]) #or... app = HtpasswdBasicAuth(app, "/path/to/htpasswd") This is using the [barrel](http://pypi.python.org/pypi/barrel/) middleware. There are others like authkit that have different features.
Wouldn't heaps be better than sorts when list sizes get larger? Sorts grow as `O(N log N)` while heap creation and querying grows as `O(N + k log N)`, where `k` is the number of items you're taking off the top.
this. Connect your webapp with any MQ available and get a consumer to do the tasks and report status through database for example. Webapp is reading thi status.
Check out python xmlrpc. It's one of the methods we use to communicate between web apps and long-running processes.
Here's your follow up: [Implementation of a Process-Based Job Management System in C](http://www.bryceboe.com/2012/02/23/implementation-of-a-process-based-job-management-system-in-c/)
It will as I've given it above (though you should have got the first few lines printed until it did block.) You can however read a few lines, then write a few if this is more interactive than just reading a single value. (Though for more complex such situations, where you need to deal with lots of waiting for prompts and sending appropriate data, using something like [expect](http://www.noah.org/wiki/pexpect) might be better) Try stepping through it interactively and not what it's expecting at each stage, just to see if there's anything it's expecting to receive that you're not sending.
Go even gets a mention in the article and comment threads there
Have a look at [Cobra](http://cobra-language.com/) ... the language , not the implementation... ;)
Yes, yes... strong vs. weak and static vs. dynamic with the possible 4 permutations of those: http://en.wikipedia.org/wiki/Strong_typing http://en.wikipedia.org/wiki/Dynamic_typing#Static_typing 
Well I've made it runtime errors, but I really think you're over-parsing :) I've added a few more lines of waffle to give the nit-pickers something to focus on ;) I meant boxing as in what you get when things are dynamic and you don't know what they are until runtime, so you have to put them in little boxes and extra indirection.
my dream language letting you do dynamic only when you say so (as does, say, Haxe's Dynamic type) is my personal preference. My dream language is implicitly typed, meaning there isn't type specifiers on everything, yet its statically typed too so you're only allowed to defer things to runtime if you tell the compiler you are prepared to pay the runtime cost and risk the errors then. That's my thinking. Its my style thing.
&gt; My dream language is implicitly typed, meaning there isn't type specifiers on everything, yet its statically typed too so you're only allowed to defer things to runtime if you tell the compiler you are prepared to pay the runtime cost and risk the errors then. Thank you. This clears up my confusion. I fully support that.
&gt; Clojure and Go are two languages that have really peeked my interest. No, they have **piqued** your interest. 
What's wrong with explicit threading? How else would you split computations? As for nullability, what you really want is a type system that supports ad-hoc type unions. Then when you say Foo you always get a Foo, but when you say Foo | NullType, then you can have a null (a shorthand syntax might be "Foo?"). Although adding that to the type system can make some things harder, like type inference. I find Python-style indentation to be too limited. It makes it impossible to have multi-line lambdas for example. There are ways you can use indentation that work similarly but don't suffer from Python's restrictions, at the small cost of having begin/end tokens for indented blocks for disambiguation. For example, a simple rule could be that the first line of a block establishes the baseline indentation level, lines that are indented further become part of the lines above them, and lines that have the same or less indentation become new lines.
&gt; yet dynamic when you explicitly say so (perhaps via prefix on the variable name) Why do people need that? It seems to me that overwhelming majority of uses of dynamism in Python is about dynamically _creating_ code (classes, functions, etc), not dynamically _modifying_ code. You don't monkeypatch something in the middle of execution of your program, only before it's even really started. So maybe this kind of common problems should be addressed explicitly, rather than with a super-general possibility of unrestricted dynamism? Maybe I should be allowed to create whatever class I want, then "freeze" it and have it completely statically checked against any interfaces I want to pass it to at this particular point?
&gt; Considering that no language can (yet) magically translate the perfect idea in your head into machine code, all of them exist on a scale of badness - they all limit you more than your own thoughts or the hardware does. I don't have perfect ideas in my head. I would say that the fuzzy hairballs of intuitions and semi-digested models that are my ideas are pretty fucking horrible. They are not usually limited by the language, they are limited by the fact that you can't have contradictions IRL, while some of my worse ideas seemed to consist of nothing but contradictions. When I look at it like that, I don't see a lot of hard "limitations", like, here's something I can do, and here's something I just can't do, at all. In Python, I mean. Usually it's more about irrelevant details or awkward syntax instead of limitations, and about the opposite of limitations -- about the way the language lends me structural elements against which I crucify the amorphous blob of an "idea" to get something real. So there's a scale of goodness as well. But yes, there are true limitations in Python as well, the lack of proper coroutines for example.
So, why is this in [/r/Python](/r/Python) ?
For Python, language fragmentation (2.x/3.x and alternative implementations that are not 3.x), co-routine support, GIL in any domain where it's a problem, a PIL alternative is missing, execution speed in any domain where that is a problem, and also external factors - like a lack of skilled Python developers. For Lisp, speed and availability of supporting libraries are the biggest problems, I believe; Clojure alleviates some of this and is nice, but it is (I believe, at least) still dependent on the Java ecosystem, and it forces one single way of working on you whether you want it or not. Also, memory hungry. Edit: for both, cannot manually manage memory layout in any way.
There's no harm in learning a new language. I wanted to do Android development, so I learned Java. What I learned: - I hate Java so, so, so very much - Code organization is important, and so much more important when it's a language you hate - Coding for readability isn't a part of every culture I did notice that I was better about documentation and structure after doing a few Android projects. Sure, bad structure won't kill a Python project, but it sure helps. When I learned Lisp, I found myself thinking about solving things in a different way, since Lisp certainly has a different way of solving problems. Next, I'll be picking up C, since I want to do some Arduino development. Already, I'm coming to a deeper understanding of the logic behind the data structures that I use without thinking about them.
[APL](http://en.wikipedia.org/wiki/APL_%28programming_language%29) all over again!
concurrency sucks in python. also lack of anonymous closures.
useless
Aptana is focused on web development, and a lot of the extra frameworks it includes will make eclipse sluggish and consume much more memory.
Ease the pain. ==&gt; Check out Derek Wyatt's VIM tutorials. http://www.derekwyatt.org/vim/vim-tutorial-videos/ 
Maybe OP didn't know or didn't bother to do the basic asymptotic analysis? I guess the only thing sort() has going for it is when you might want a certain number of minimum values, because making multiple O(n) passes may or may not be more expensive...although in that case, what you can do instead of sorting the whole list is to have a maxheap initialized to contain the first x values (assuming you want x minimum values). Then you can just iterate through the rest of the list, ignoring values that are greater than the max of the heap, and if a value is smaller than the max value of the heap, then you simply remove the max value and insert your smaller value. This way you maintain the size of the heap to be x and eventually populate it with the x smallest numbers. Runtime here would be nlog(x), which is better than nx for making x passes through the list.
gevent isn't useful here unless the long running script is IO bound. If it isn't, it might never yield control to the gevent web app. Threads have preemptive multitasking- I would suggest threads.
Have you tried Scala? It ticks a lot of those boxes. 
I'd also like to take a minute to rant on how it was so much harder to install than it should have been. I could do it again in 5 minutes, but the first time took MUCH longer. I downloaded eclipse.zip, moved enclosed eclipse directory to c: and run - FAILS. Eventually I figure out that you can't use WinXP's built in zip functionality, you have to use something like 7-zip. Try again and I've got eclipse running. On the PyDev page, the install button says drag to eclipse workspace. I have tried dragging it everywhere, and nothing does anything. So I click on the Install button... This takes me to the "Introducing the Eclipse marketplace Client" page which tells me to use Help --&gt; Eclipse marketplace... fine except unlike the helpful picture on the page, my just-installed eclipse has no such menu item. Finally after some searchng, I found a long walkthrough at [http://pydev.org/manual_101_install.html](http://pydev.org/manual_101_install.html) Sorry for that.
 I doubt that any remote file system solution will better with the large latency involved in my connection than my current use of sftp. &gt;The project can't really be run locally because it involves a lot of very specific IO hardware (motor controller, sensors, instrumentation, etc.) The code **has** to run on the remote machine. Editing the code locally is not a problem, but it just won't run unless there is some specific hardware installed. At least I'm not using a packet switched modem at 4800 baud on this one.
Do it for haskell then
Yes, but this will let you edit the file on your machine, but have it saved to the remote machine. It says you from having to manually sftp the file over every time you save it. If you turn ssh compression on transfer time shouldn't be too bad. You'd actually run the code however you run it now. My typical workflow for doing dev this way is editor on one screen (I just use Sublime Text, I don't need an IDE), and an ssh session on the remote machine on the other. Save file in editor, then run on the remote console. **Edit: Also, if transfer speeds is a concern (or even proper engineering practice) why is this whole thing one 8k-line file? Modularize man...**
Thanks! I'll try installing Python 2, unless you know of a quick fix for the syntax to make it work for P3? Edit: whoops! Looks like Autoplectic already helped solve the print syntax. Thanks again.
Thanks! I revised all of the print errors, but now I have this error: c:\Users\Raphael\Downloads&gt;python imgur_downloader.py Traceback (most recent call last): File "imgur_downloader.py", line 7, in module myurl = raw_input("http://imgur.com/a/ahZOF") NameError: name 'raw_input' is not defined Am I defining raw_input the wrong way?
I meant that all the code is 8000k, but no single file exceeds about 2k lines (still to long). I mostly meant that it's getting to big to keep all in my head. It's not so much that the connection is terribly slow, but that it can take a while to be established. Once going, it's not too bad. I still don't have a debugger, and have to resort to lots of prints or logger.debug() messages. If I have a file with three syntax errors, I upload it. notice the crash, fix the first error, upload again, fix the second error, etc... If I have runtime errors, The program takes about 30 sec to get up and going before it gets to the part where crashes become likely. You can see how this could become tedious. 
This is a great point. I love python, but I know it is an imperfect tool for every problem. I have been programming in Javascript (mostly via coffeescript) a lot lately and have grown quite fond of closures and anonymous functions. Python's lack of ~~these features~~ anonymous functions make certain tasks more clumsy and prevents development of certain types of APIs. 
Expandrive keeps the connection alive. it's as fast as it's going to get.
I've been using Komodo for a bit now and like it quite a lot. And although I have not tried it myself, I do believe it has a remote debugging feature which may or may not work for you. It's not free, but it's worth the price. Also, I think they have a free license for open source and educational initiatives if I'm not mistaken.
It looks like my options are: 4. Use RSE to transparently edit remote files or 5. Use the RSE EFS Provider I don't think the first option lets me run the files remotely, only edit them. I'm not exactly sure what an EFS provider is but I suspect it is something that runs on the remote machine? Searching through the provided links mostly leads to old blog posts fill of dead links. A Google search of pydev and RSE leads me no tutorials or documentation, only lots of people complaining that they can't get it working.
The script works just fine for Python 2, but I'd still like to get it working with Python 3. If anyone is bored and feels like helping, here are some more syntax errors: c:\Users\Raphael\Downloads&gt;python imgur_downloader.py images/ input imgur gallery/subdomain/album address:http://imgur.com/a/ahZOF Traceback (most recent call last): File "imgur_downloader.py", line 151, in module&gt; parsePage(myurl) File "imgur_downloader.py", line 104, in parsePage page = urllib.urlopen(url).read() AttributeError: 'module' object has no attribute 'urlopen'
urllib.request.urlopen
Python has both closures and anonymous functions.
&gt; For Lisp, speed and availability of supporting libraries are the biggest problems, I believe tried the FFI interface in your favorite Lisp, or, say, [Racket](http://www.racket-lang.org)? the racket FFI is, I believe, based on the same library which underlies ctypes, and is about as painless as such a thing can be. i prefer playing with a new C library by writing an FFI interface to it, and poking around from within racket. &gt; Edit: for both, cannot manually manage memory layout in any way. ...what would it even look like to manually manage memory in python? edited to add: also, i'll just [leave this here](http://planet.racket-lang.org/display.ss?package=infix.plt&amp;owner=soegaard)
https://github.com/Twinside/vim-haskellConceal/blob/master/after/syntax/haskell.vim
Yeah, it's having to find them from proportional-width fonts and squeeze them in D:
&gt;cute but difficult to read That's math for ya.
This would piss me off SO MUCH.
The [original post](http://www.bryceboe.com/2010/08/26/python-multiprocessing-and-keyboardinterrupt/) (written over a year ago) was when I was doing a lot of data processing. I desired to take advantage of my machine's 8 cores as well as support pausing and resuming of the process. The recent spark in interest was purely academic and stemmed from the conversation with my colleague who also had some past experiences using multiprocessing in python.
.i .e'u zo'o ja'o ro ko cusku bau la lojban.
I'm curious if you would dislike C# too.
&gt; Edit: you edited your comment and now my comment makes no sense... sorry, I think I might have edited it for typos right after I posted - tiny screen on my phone, I often have to - but I definitely didn't change the gist of it at all sorry for any confusion. fwiw openmp etc is an interesting angle; again I'd prefer smarter compilers rather than explicit developer annotations. However, having used CUDA etc, I understand the role of annotations and such; perhaps my dream 'systems' language is a little too safe to be doing the very highest-performance programming in.
Some middle school kid who does not know anything about programming might find this amazing.
Right, I used this library this week, although the documentation is not the best, it's not really complicated. And I also want to use python at my day job.
I wish you good luck! I had to go to a startup that frankly hasn't been doing great under another architect's leadership after a good ~5 years of Java development. Since taking over the reins and using Python for development, though, things are looking up!
Linode if you are a confident sysadmin. Webfaction are pretty dandy if not. 
IDLE (which comes with Python) is a decent platform for learning - it's not a professional tool, but it benefits from being simple and convenient.
As an ex APL programmer i gotta say this is awesome and long overdue! - To people complaining that it might be less readable I say - try it first! You don't know what you're missing.
Nope - much easier to read!
Inconsolata maybe?
Try PyScripter, I found it amazing.
have a look at bpython http://www.markus-gattol.name/ws/python.html#bpython
I like using this because ctrl+b runs your code in the editor. Also, because it is an otherwise amazing program that I will be buying a license for soon.
for effbot's console module, have your tried [Unofficial Windows Binaries for Python Extension Packages](http://www.lfd.uci.edu/~gohlke/pythonlibs/)? the Base distribution includes console-1.1a1-20011229. it should work thought I didn't test it yet. 
I'm a big fan of pydev plugin for Eclipse: http://pydev.org/ lots of nice features, and it is easy to setup multiple python interpreters for different versions of python. Pretty good debugging (and remote debugging) options with the builtin debugger, and nice support for unittests and other goodies. 
You might check out my talk from DjangoCon where I cover issues with wrapping static|classmethod and the need to use class objects to implement decorators. http://www.slideshare.net/GrahamDumpleton/djangocon-us-2011-monkeying-around-at-new-relic
Dreampie amd IDLEx are my favorites.
&gt;**Posting code to this subreddit** &gt;Add 4 extra spaces before each line of code
Great concept, but very disappointed to learn that they aren't even planning on expanding their service outside the US at some point. Still, seems to be quite developer friendly... I just hope they change their minds soon enough, or else services like Stripe might beat them to the punch.
Thanks for all of the help, buddy! I'll try to work out the rest of the errors.
Great link! I'll play around with it. That's what she said.
Been using it for a while. The only annoying (and inevitable) thing about it is that line length changes when you move to the line containing the symbol, making [this](http://i.imgur.com/TzC3v.png) happen. It's still worth it for me.
For all the brain humping awesomeness of J, I think it was a bad move to go back to ascii. I demand overstrikes!
Sublime text is awesome; also its a cross platform now :)
I have this exact issue, but I'm using sqlite3 as my DB which only allows one process active at a time. Which is the best db to move to that can let multiple python programs access without blocking?
There's also Geany: http://www.geany.org/Documentation/Screenshots It's not as complete as other solutions posted in the comments, but it's good enough for a basic user experience.
iOS as in Apple and not Cisco :(
thank you, I see it on the side now, my bad ... :) 
It's true that ideas in ones head are sometimes not very consistent or not very formal, usually both. The question is - how many questions you need to answer in order to make them consistent and formal enough. Make a comparison - how much time you spend explaining the idea to a fellow human and how much explaining it to the computer. It's true that humans might buy your contradictions while they should not, but hey, when was the last time you wrote a program that end up not working for a lot of cases? As far as I can see, Python is definitely not ideal. I can imagine that a lot of boilerplate can be avoided, like making sure you pass all the right parameters everywhere etc. by explaining what you actually *mean* in terms of names concepts and objects. But hey, I don't know how such a language would look like (a Q&amp;A?)
Python really suits my needs pretty well as a scientific programmer. I can go from ode modeling to gui to web design. Granted R is better for stats, Python is still pretty good.
How exactly has this passed the reviews? App Store has explicitly stated that any software used to execute non-approved code is a big no. Python interpreter would fall well into this definition.
This has been approved and updated past a silly bug with the keyboard. Works great now!
That rule died a while back.
If you pass a unicode string to os.walk then it will give you unicode strings back. os.walk(u'/some/path') os.walk(os.getcwdu()) # walk current directory (getcwdu = unicode version) That might help because then at least you don't need to worry about the original encodings. This link has an excellent summary of related unicode issues: http://stackoverflow.com/questions/2392732/sqlite-python-unicode-and-non-utf-data 
have you tried setting the text_factory as they suggest? my_con.text_factory = str by default, sqlite makes it unicode, so it tries to transform the strings you stored to unicode, but you didn't store unicode, so it fails. 
Post this to stackoverflow.com and you'll have an answer in &lt; 1 hour.
Sorry about that: Traceback (most recent call last): File "C:\Python27\Lib\site-packages\pythonwin\pywin\framework\scriptutils.py", line 323, in RunScript debugger.run(codeObject, __main__.__dict__, start_stepping=0) File "C:\Python27\Lib\site-packages\pythonwin\pywin\debugger\__init__.py", line 60, in run _GetCurrentDebugger().run(cmd, globals,locals, start_stepping) File "C:\Python27\Lib\site-packages\pythonwin\pywin\debugger\debugger.py", line 655, in run exec cmd in globals, locals File "C:\Users\Zack\Documents\Scripto.py", line 1, in &lt;module&gt; from bs4 import BeautifulSoup File "C:\Python27\lib\re.py", line 142, in search return _compile(pattern, flags).search(string) TypeError: expected string or buffer
Okay, it looks like there are quite possibly several things wrong with this script. I don't know beautiful soup well so I just quickly looked at the docs, but first off soup.p will be the first paragraph node in the page. This is not a string, and therefore you cannot use a regular expression on it. It looks like you're just looking for the text of the page, so to just get a dump of all the page text you can use soup.renderContents() to get the internal text of all the page nodes. Now, your regex looks a bit off if you're looking to pull out prices. If you just want to pull out any number after a dollar sign, you'll want to do m = re.search(r"(\$[\d,]+)", souped) m.group(0) If you want to pull out the number without the $, you want to just wrap the [\d,] in parentheses instead of the whole regex. 
So emulators are allowed now?
Indent with four spaces: Like this. Or use a pastebin like http://paste.pocoo.org/ or https://gist.github.com/
Have there been any cases of this attack being used in the wild?
I *think* the rules still forbid running code that was downloaded or transferred onto the device. This one runs code that the user has typed in. But take that with a pinch of salt, because I don't even own an iDevice.
&gt; when was the last time you wrote a program that end up not working for a lot of cases? A couple of weeks ago I discovered that Python's regex engine doesn't support more than 100 capturing groups. So my function that combines lots of individual regex+replacement pairs into one replacer, using a single regex and dispatching to the correct replacer, had to be fixed to split into several such combined replacers as necessary. So I got _an idea_. There must be a combinator for that! I mean, it's not an unusual problem, suppose you are formatting a paragraph of text into actual lines -- you add words to the current line until it goes over the margin, then you emit the line as it was and start again, starting from the last word that was given to you. And that's how I want to write it -- a function gets words from somewhere, then returns the accumulated value and gets restarted on the remainder of the list, by something that looks like `groupby` and `reduce` rolled together. As opposed to manually resetting all my variables to initial values and processing the current word again. Sounds simple enough, eh? Well, if you have a free hour, try to write this `group_reduce` combinator. One problem is that the idea as stated itself is a typical amorphous blob missing a lot of complications. In particular, the first item of each run is special, you are supposed to return it anyway even if it's too long, and it would be nice to have an API that makes it explicit. Also, the API has to avoid calling the function when there are no items in the iterator. Plus, I don't know, preventing a return before the first item is consumed, forcing a return after the last item, stuff like that. So maybe it would be better to split the entire thing into a function that says where to split, and the function that actually reduces each run. Then, Python. You want to _send_ stuff to that function in your `group_reduce` implementation, but using `yield` expression in iterators to emulate coroutines is beyond butt-ugly, it's atrocious. So instead I had to write a weird iterator class that allows one "unget" and also informs me of it being exhausted, and is butt-ugly as well. And the result still encourages all kinds of errors in the client code. Maybe it would be easier in a language like Haskell, where a function can take a list as it is or as `first:rest`, transparently for the caller, and where you can use tail recursion. I don't know, try this problem yourself, maybe I'm missing something.
Try your intuition on this variation: There are 1 million doors with a prize behind only one. The contestant chooses one door. Monty then opens 999,998 (leaving the door the contestant chose and one other door closed), revealing no prizes. Should the contestant stick with his original selection or switch?
A security fix that's disabled by default? I know you're trying to balance compatibility against security, but the programs that this would break are already broken and you'd just be doing their authors a service telling them so. 
leads to; UnicodeDecodeError: 'ascii' codec can't decode byte 0xf6 in position 31: ordinal not in range(128) again. printing fs_encoding tells me it is 'ANSI_X3.4-1968', which wikipedia tells me is just another name for 'ascii'.
Well, that's why nothing is working. Python has no way of knowing what encoding to treat filenames that the OS returns. It needs that information from the locale -- if you set locale to C that means you can only read pure ASCII filenames. Having to support mixed encodings sounds like a real pain. UTF-8 is the only sane encoding for filenames on Linux. How about converting all the non-UTF-8 ones to UTF-8 and then setting the locale to UTF-8? Edit: alternatively, I suppose you could dynamically change the locale setting before reading a directory if you know that directory contains files of a certain encoding. But that will only work if you have that sort of foreknowledge, and it will only work if the mixed encodings are sequestered to completely separate paths. There is no way to walk a directory that contains files named with e.g. UTF-8 and CP1252 intermixed. 
Time to some adderall and read about regex :D
&gt;There's no harm in learning a new language Only if you don't value your time at all. At some point, learning becomes less important than doing something with what you have already learned.
I don't think just changing the column type is enough. You have to explicitly use [`sqlite.Binary()`](http://eli.thegreenplace.net/2009/05/29/storing-blobs-in-a-sqlite-db-with-pythonpysqlite/) to represent each value, not strings. What python 3 does when the locale is set to C and it encounters non-ascii filenames is to transcode each non-ASCII byte into the [Unicode low surrogates range](http://www.fileformat.info/info/unicode/block/low_surrogates/index.htm), U+DC00 - U+DCFF. This gives a string that is nominally Unicode but actually represents some arbitrary binary. I suppose you could try this approach, either manually or by switching to python 3. 
Given the constraints of a Cisco device you'd want to conserve the CPU cycles of your IOS units anyway. Jumphost + `clogin` FTW.
I wish this wasn't necessary, but translating WSGI to Python 3 seems impossible without it.
I think it's justified for a bugfix release. People should be confident that they can apply a bugfix update without breaking anything that currently works, even if it only works in a really stupid way. Remember that the person who suddenly finds code broken may not be the author of that code. Fixing it may take some time.
I saw this idea come up in a previous reddit [thread](http://www.reddit.com/r/Python/comments/n3q7q/thoughts_on_python_3_armin_ronachers_thoughts_and/c361krh) a few months ago. I went so far as to work up a quick [patch](https://gist.github.com/1452842) that adds u'' literals back to py3. Redditor mcdonc (who proposed the idea in that thread) subsequently brought it up on python-dev, and I believe the dev group decided against it. That said, I'd love to see it come back, it would make life much simpler (assume one omitted 3.0-3.2 support). edit: [here](https://groups.google.com/d/topic/dev-python/vRqDHlbYGRA/discussion) is the old python-dev thread debating the idea. 
&gt; Python 3 is a major new revision of the language, and it was decided very early on that breaking backwards compatibility was part of the design [...] people are now attempting to find ways to make the same source work in both Python 2.x and Python 3.x, with varying levels of success. I suggest a modest proposal: 1. all changes in 3.x that break backwards compatibility be removed. 2. Python 3.3 be renamed 2.8
&gt; Python 3 was supposed to be a big leap from Python 2, that would be hard to swallow at first but that would ultimately result in a better language and better practices. Are there really any super duper new features in 3 that require that its semantics be such as to break compatibility with 2? I'm not aware of any.
`from __past__ import unicode_literals`
On the contrary, it's essential that codebases can support Python 2 and Python 3, if there's going to be any transition at all. Maintaining two codebases is a pain, and dropping Python 2 support is not yet an option for 99% of libraries. I don't think this makes it too much more confusing. In fact, it may make it simpler, because you can explicitly differentiate byte strings from unicode strings. Then you only need to know that for Python 3, `'foo' == u'foo'`, and for Python 2, `'foo' == b'foo'`. It's somewhat less beautiful, but I think I'm persuaded that practicality should beat purity on this.
Not sure if serious...
I intentionally left it for the reader to figure out. Btw, your description is not complete: if there are no #'s in the string, it is returned untouched. In other words, it strips python-style comments from the string. I was quite surprised how smoothly it was expressed.
Thanks a bunch. Unicurses seems to fit the bill for what I'm looking for at the moment. Also, it seems that most ncurses/pdcurses commands are identical in this library which is useful since I can use their documentation for the most part.
Does want a kindlefire edition!! 
That's an interesting approach. I've done some Python 3 ports, both with 2to3 and without it, but I didn't think of using unicode_literals with a specific 'native string' marker.
Right - the number of places in a codebase where you *have* to have native strings is not that great, so `n('xxx')` doesn't pollute the code to the same extent as `u('xxx')` would.
good catch
Why not just use SLA?
You did recognize the author of the PEP, right? His head is so far up the ass of WSGI that I trust he's tried many things and this is his best idea. 
Well, can you just figure out what encoding the filenames are using? If it displays in your system's GUI file manager app, it can't just be random.
If I run into any road blocks with Unicurses I'll probably look into that as a next step. Thanks.
It might not be exactly what you want, but the author of [this game](http://www.pyweek.org/e/Cursed/) implemented a subset of the Curses commands in Pygame. It was later used by [these guys](http://www.pyweek.org/e/RegExExpress/) for another game. They might have updated it somewhat, I don't remember. I wouldn't call it "up to date", but given the small code size, I'm sure it's trivial to fix any errors.
I'll give you a couple tips, some unrelated to the issue at hand: * you can just do for elm in list: if elm != ' ': instead of using the index. Will help save keystrokes in the longrun, might as well make use of pythons nice high-level features. * using vars() is generally not advised outside of debugging. While the metaprogramming aspect of it may seem intriguing, it isn't really a source of maintainable code, and could produce very unusual bugs if you weren't careful. * .split() splits on any whitespace, rather than just spaces. In this case it might be a good idea to use regex, considering you're trying to extract strings delineated by whitespace.
I thought it would be worse, but it doesn't seem much worse than what I do to get pylons going. It would be very strange if it actually needs sys.path *and* PYTHONPATH though, perhaps the author should try taking out the os.environ part.
I would think you would want just `row[1]`. If this is a `buffer` type as the article suggests then it should be usable in most contexts that expect a string. If not then create a string explicitly from it, i.e. `str(row[1])`. I doubt you want it in hexidecimal, I think the point of that was to format it for display to show that it had been round-tripped correctly. 
I am doing this for years now and it works fine. I have a local and a remote copy of the entire project, and [**WinSCP**](http://winscp.net/eng/download.php) is **keeping the** [**remote copy up to date**](http://winscp.net/eng/docs/task_keep_up_to_date). Every time I change a local file, WinSCP uploads it to the remote server. The remote application is configured to reload automatically. Every time I save a file on my local copy, it is uploaded to the remote server and the application restarts. Now, the most interesting part: I'm using [**Wing IDE**](http://wingware.com/) as IDE, and one of the most useful features is [**remote debugging**](http://wingware.com/doc/debug/remote-debugging). The remote application loads the Wing debugging module and connects to my local machine. When the remote application crashes, Wing shows me the error location exactly as if it was my local copy. I can even run interactive commands on the remote copy, so I can debug it on the production server. After fixing the code, the script reloads automatically.
Regex is a magic, cryptic form of language... don't worry.
Meh, id rather just use python on my jailbroken device. Just wish it supported pygame. 
&gt;there is not one single encoding for all the files They originate from various sources so there is no reason they should match the fs-encoding. &gt;The simplest solution is to switch your encoding to utf-8 like the rest of us who haven't pulled our hair out. My requirements were not the same as yours, then, because i wasn't doing it 'the hard way' just for fun. Anyway, largely solved by using a BLOB column and encoding the filename string with sqlite3.Binary().
It's not the best way to do it. Not that speed is particularly important, but you probably want to limit it to just finding the first `#` in the string, not all of them. I would probably write line, _, comment = s.partition("#")
I find it is best to let Django handle this for me. Wrap your code in a manage.py command. That way you don't have to worry about any of the environment nonsense.
[pygcurse](http://inventwithpython.com/pygcurse/) is a cross platform curses-like library built on top of pygame.
This is your answer: http://docs.python.org/release/3.0.1/whatsnew/3.0.html People didn't respond because you're sarcastic and complaining about change. The reason it was 3.0 and not 2.8 is because it allowed them to break backwards compatibility. That was the whole point.
I must say that I don't fully understand what you´re trying to do, but here is my stab at it, http://pastebin.com/49jbxiwu p.s.: you are creating local variables. Are you by any chance splitting the words inside a function? 
mod_python has been unsupported for at least 2 years. Mod_wsgi is the way to go.
asksol, you're a machine! Keep up the great work. You keep finding way to make Celery more awesome. :)
Interesting! I didn't realize you could iterate through a string like that. Yea, I'm noticing that vars() is acting weird already. Also, I was told not to use .split(), .join() or anything similar. I'm supposed to just use regular string and list commands to make this work. 
You can buy Python 2.7 in the App Store. You can also get Python in one of the default Cydia repos, but if you honestly don't know how to search in Cydia or can't be arsed to it, you shouldn't be doing it in the base OS anyway. 
You need to share the assignment specs in greater detail if you want more help. 
It's a DOS vulnerability, not something that can really compromise most systems.
The PEP does not (for example) consider the possibility of leaving literals as they are and using a `n('xxx')` callable for native strings. Since there are very few places where native strings are needed, this approach is potentially less obtrusive than either `u'xxx'` or `u('xxx')`.
You're right to some degree, but a little artificial challenge here and there can help. Dreaming up unnecessary constraints seems to be pretty human, and it may in fact help us in certain ways that a purely practical approach can not. Some balance, as always, is required.
Just that it totally would not work because compile time exports cannot be trapped. It would mean that you would have to ship a dummy `__past__` module on PyPI for Python 2.x
It also has the fix for subprocesses! Hoorah!!
This is something new programmers often try - making variables with dynamic names - but it's almost never a good idea. Even if it works, what about when you want to know how many words you've got? You have to count up until a name doesn't exist. That's daft. You should try to put the results into a list, so that they're words[0], words[1], etc. I'm not sure how you're supposed to do that, though, without using `append()` (you say in another comment that you're not allowed to use it). Are you allowed to put the words in a dict, perhaps?
You won't ever use this specific code, but that doesn't mean it's a useless exercise for learning. It helps you get familiar with concepts like lists, iterating and indexing. Artificial problems are a key part of education.
Don't. These are advanced features, and I very much doubt you're expected to use them.
[Spyder](http://code.google.com/p/spyderlib/) is very good if you are into scientific computing
Use a dictionary. Seriously, this is what they're there for. You never need to generate variable names programmatically, names only exist for humans.
This works for me: from django.core.management import setup_environ import settings setup_environ(settings) from myapp.models import Object for o in Object.objects.all(): print o
I agree that it's not insoluble, I'm just stuck. Also, this happens to be the extra credit for the assignment which I had already completed. 
I have found **kodos** invaluable in creating and debugging regular expressions. http://kodos.sourceforge.net/ It's available via apt-get or pip.
I believe those same concepts can be taught in a way that makes sense and leaves you with a general idea of how to approach a similar problem in the future (a problem you may actually have). what bothers me here is that you're asked a question that can be a real problem but you're explicitly asked *not* to solve it as you would but instead create a home-made hack that shows you the wrong approach. if you're teaching iterators then use actual iterators, want to teach how to iterate a string? put a problem that counts the letters in the string instead. you should always let people use the full extent of the tools they have because that's how it's done in real life, if you put artificial constraints on your problems it's because you didn't bother to think a problem that actually shows what you want. another example: you want to teach about parsing, tokenizing and such? use a stream as input, one without newlines will force you to process the input in chunks and recognize the whitespace, after that you can use .split() and it'll be ok. the key is to think in terms of *problems* not *exercises*.
I would like to create a pivot table of x vs y as a weighted measure of frequency. I was trying to use pure Python code but I will look into SQLite and PyTables thank you both!
That's an interesting restriction. I feel like (read: wish) it could be bypassed legally then. 
You need to use different key names, yes, but that's easier than using variable names. Just use `mydict[k]`. If you use a list or a dict, you can easily see how many items are in the collection with `len(words)`. It has lots of other advantages - like you can easily pass all the words to a function, or return them from a function. Using separate variable names is much more awkward.
[pandas](http://pandas.pydata.org/) also has some strong support for pivot tables.
Have you tried with query parameters? They avoid all the quoting issues. cur.execute('SELECT id FROM table WHERE path=?', (sqlite.Binary(file),)) # or cur.execute('SELECT id FROM table WHERE path=:path', { 'path': sqlite.Binary(file) }) You should be doing this anyway, BTW. Creating queries by using string concatenation is just seriously bad, and leads to all kinds of problems. 
Please start by describing what you are trying to accomplish.
In general, you are correct. I was trying to say that Python's *lambda* construct is not a "true" lambdas in the sense that they more limited semantics than named functions. Guido has made it clear that he dislikes anonymous functions, arguing that they hurt readability and complicate debugging.
Always always always use `in` or `not in` if you just want to see if a substring is in a string or if an element is in a sequence. If you need the index, then use `.index()` or `.find()`
too much magic!
&gt; if you're learning programming concepts you don't need a language, it's theory. Seriously? Stop and read that back to yourself. You would teach people programming concepts like iteration and strings without getting them to write any code? A problem doesn't care how it gets solved, but *solving the problem is not the real aim*. The aim is for the student to learn about what's going on. To that end, it's perfectly normal to set constraints on what students can use to solve a problem. And this isn't peculiar to programming: it's common in subjects like maths where you can very easily get the answer from a computer, but you don't learn much by doing so.
Yeah, there's the _real_ question: `index` or `find`? There was a debate on Python ideas a couple of months back where the Python devs basically admitted that it was a mistake for both `index` and `find` to be string methods, and that if they were doing things over again, they'd probably just have one method that returned `None` if it couldn't find the substring.
&gt;Ok so my goal here is to split a list into it's individual words Lists don't have "individual words". I assume you mean you have a string, since that's what you're apparently working with. &gt;My issue is that I can't for my life create a variable name that changes with each iteration. A list, however, is exactly what you should be putting the resulting words into. You've been told not to use `.split()` presumably because you're already familiar with it. So you should know what it returns: a list. Do the same. By the way, `for i in list(range(len(original_list))):` is ugly in many ways. First off, `range` returns a list, so the outer `list` call is completely redundant. Second, there is no point in iterating like this. You're creating this separate thing that contains a sequence of numbers, so that you can iterate over that, so that you can use the results to grab the characters that you want to iterate over. That's silly. Just iterate over the characters, since that's what you want to do. for c in original_string: # do something with 'c' to assemble words # append assembled words to a list Also, try /r/learnpython.
Note for emacs users: the [rectangle editing](http://www.gnu.org/software/emacs/manual/html_node/emacs/Rectangles.html) commands (especially C-x r t) are very helpful for this sort of thing.
What are the situations where you need native strings?
Oooh nice! 
Check out the built-in [ConfigParser](http://docs.python.org/library/configparser.html).
&gt;Python's regex engine doesn't support more than 100 capturing groups . . . &gt;it's not an unusual problem. . . I'm no Python guru (or any other type of guru) but that's sounds unusual to me. 
This doesn't appear to require "native" strings. Under Python 2.6, from __future__ import unicode_literals raise Exception("you made a mistake") works as expected. So the `n` helper function wouldn't be needed here.
Simply see if a substring exists in a string.
It is a very small django app, used internally by maybe 500 people. Speed is of no concern, functionality is all.
Well, maybe, but it depends on the data. rfind looks from the end of the string, so if the substring you're looking for is frequently at the end, rfind might be faster than in, even if it isn't in the general case.
Thank you everyone for the overwhelming response. Greatly appreciated! 
Code looks nice! Any unit or functional tests hanging around?
We're working on getting tests written, but there's nothing really for the moment. We're about a week away from our 1.0 release, assuming nothing goes wrong, and we'll be making a Reddit post then (the user who posted this one deleted it upon learning that 1.0 is so close to release).
I use eclipse, but another simple thing to do is to map linux drives as a windows drive. Try ExpandDrive and you can work remotely run locally then run remotely. I use Pyscripter this way if its a simple program.
Speed is a concern. Speed may never affect your application, but speed points toward implementation problems which affect maintainability. This is especially true in python—verbose, procedural python usually outperforms clever python.
Good luck.
Yup. They're not going anywhere for at least a decade…
These magic tricks are deeply wicked. Implicit self? Burn it at the stake!
Also, 'in' works with any iterable. So it can be used to search for charachters and substring in strings, as well as elements in lists and keys in dictionaries.
Nice work! Thanks!
See the PEP :-)
You have to be very careful in such situations. Anything but ASCII will cause an exception in that situation. It merely works because something calls str() on it implicitly and that works for some cases. Python 2.6 requires you to use a native string for `strftime` on datetime objects for instance and there is no way around that. The filesystem functions by default are native string etc.
Because in all honesty, because string wrappers make a codebase horrible to work with. I will have to continue maintaining 2.x versions for at least another four or five years. The idea if having to use string wrappers for that long makes me puke.
Note that there are situations where rfind *could* be dramatically faster, which is if your string is very long, and also very likely to contain the needle at the right edge rather than the left. For example: s=("a" * 100000) + " needle" %timeit "needle" in s 10000 loops, best of 3: 21.1 us per loop %timeit s.rfind("needle") != -1 1000000 loops, best of 3: 258 ns per loop So under this contrived case, rfind is 100 times faster, because it can bail out nearly immediately, but `in` or `.find`, as they start from the left, must scan the whole string. The advantage of `in` that it avoids an extra function call opcode, which is generally a fixed cost, so will be most important on short strings. As such, this'll depend on how long the string is, and it does require a very specific pattern of data, but given that they've chosen `rfind`, rather than find, it's *possible* that there's a reason.
There are approaches that can solve this, or at least make it much harder. I think the approach they've taken is to randomize an element of the hash on startup, so your values will hash differently in every process. Technically, for a long running process you could perhaps work it out with enough effort (ie try every permuatation and time the effect), but it's much more difficult (and defeatable just be restarting the process).
Different from what the url might suggest, this is Armin Ronachers talk from europython 20**11**.
They're like Bond villains: not something you ever want to meet in real life, but amusing to watch/read about. Although I'll admit to being quite tempted by the use of AST to define macros. I can envisage context managers on steroids.
Not really - '' appears in that string immediately at position 0, and between every letter - if you start at 0, and count forward 0 bytes (the length of the string you're searching for), you'll find no mismatch. You're essentially asking if the empty string is a substring of "test", and it is - indeed, it's a substring of *every* string, and even "`'' in ''`" returns true.
Thanks you've both given the same answer and I understand it know
Is there a link to a video of the talk anywhere?
What does it mean that x.find(y) == i? For i unequal to -1, it means that the substring of x that starts at index i and has the same length as y, is equal to y: x.find(y) == i means x[i:i+len(y)] == y And since "test"[0:0+len('')] == "test"[0:0] == '' is True, find should answer 0. 
http://lucumr.pocoo.org/talks/
http://stackoverflow.com/a/1732454
 string = """ I would take a parsing approach. Basically you iterate over all the characters. If you find a character, and you haven't yet set the word starting index, you've got your first character. To find the last character, you do it the other way around. If you find a whitespace and word starting index is set, you've found the first character after your word. You add the word to your list, reset the word starting index to None and go on. """ words = [] word_start_index = None last_index = len(string) - 1 i = 0 while i &lt; last_index: if string[i].isalnum(): #We have found a character if not word_start_index: #We are at the beginning of a word word_start_index = i else: #We have found a whitespace or break line if word_start_index: #We have found the end of a word words.append(string[word_start_index:i]) #The last character is the position before the one we are in word_start_index = None else: #Our string starts with some whitespaces pass i += 1 print words
Aren't anonymous closures redundant when one can define functions inside functions? (Plus, you could use a lambda to define an anonymous closure too.)
When would you use anonymous functions when inline functions are not suitable?
There's Python magic, and then there's python sorcery. This is definitely the latter.
Class level attributes should be quite a bit easier to define/use: class Fft_types: hanning = 1&lt;&lt;1 hamming=1&lt;&lt;2 set_fft_type( Fft_types.hamming)
Can you recommend a good Celery tutorial? I'm not quite sure what it does?
Good point, although obviously it was not intended to parse actual python. The one hypothetical point of application (which is not really important, because I posted it for it's beauty, not practicality) could be to parse some simple half-assed config format (although I know there are dedicated solutions to parse configs).
couldnt you [slice](http://docs.python.org/library/functions.html#slice)... for example: textfile = readlines() for line in textfile: for i, letter in enumerate(line): if (letter == ' '): a[ii] = i ii+=1 b[iii] = a iii+=1 //now you know where to slice... for row in b: for s in row: c = line[s:s+1] print c please post example list of words if possible
Macros, case insensitive namespaces, monkey patching \_\_builtin\_\_.\_\_import\_\_ to do stuff with \_getstate_... Have to hide this from my colleagues.
True, but you can also do stuff like: ```if typ in FFT_TYPES: ...``` ```for typ in FFT_TYPES: ...``` ```FFT_TYPE.keys()``` etc.
is this going to pollute my newbie level of python knowledge ?
Okay, you definitely don't want to make dynamic variable names. Can you copy and paste the text of the assignment here? Is the result supposed to be a list of words? Maybe this will help? &gt;&gt;&gt; words = [] &gt;&gt;&gt; word = "hello" &gt;&gt;&gt; words += [word] &gt;&gt;&gt; words ['hello']
Anonymous functions are never strictly required, but they make certain API's more elegant in my opinion. In general, I find anonymous functions helpful when writing callback heavy code, like working with jquery ajax calls and promises. Basically anytime a function exists only to be passed to another function, anonymous functions are helpful. Another example I was working with recently is spec programming for Behavior Driven Development, which is basically TDD with human readable test descriptions. In Javascript, using JSSpec, tests look like this. describe( 'Observable Array', { 'should be observable': function { //test code }, 'should initialize to an empty array': function { //other test code } }); In python, this type of API would look something like this. def testIsObservable: #test code def testInitializesToEmpty: #other test code describe( 'Observable Array', { 'should be observable': testIsObservable, 'should initialize to an empty array': testInitializesToEmpty }) Now imagine if you had 30 or so tests to write; having to define functions separately from their use is cumbersome and hurts readability. Someone reading your spec would need to jump back and forth between the behavior description and the function definitions. There are others ways to implement BDD in python, such as pulling the description from the function name (def should_be_observable) or using docstrings (def isObservable: \n '''should be observable'''), but these are not as elegant in my opinion. 
Here's another use: * Start and stop a timer that benchmarks the code inside the With block. I've also had a less traditional situation where I have a class that tracks several consistency constraints, which may be temporarily violated during a series of update operations. I turned the class into a context manager, arranging it so that the consistency checking is suspended anytime it code is inside one or more With blocks. Upon leaving the last With block, the constraints are checked again.
Good points. I agree that it's more cumbersome in your case. I think I thought you were trying to say that Python was less powerful without anonymous functions. Now I understand that you're making a stylistic point. (A perfectly legitimate one.)
That only allows basic scripting and prompts. You can't do any graphical applications with it.
Often known as [fitness proportional selection](http://en.wikipedia.org/wiki/Fitness_proportionate_selection).
No, it's that in Python 3.0, 3.1 and 3.2, `u'xxx'` will raise a syntax error. In 3.3, `u'xxx'` will be exactly the same as `'xxx'`. The purpose of allowing the new syntax is to make porting from 2.x to 3.x easier for some people, who think it's too/unnecessarily hard to do the porting without that support.
There was some console output library that used them for indentation. Forgot the name. It worked a bit like: with indent(4): echo("Hello!") with indent(2): echo("Hi!") Edit: It's [clint](https://github.com/kennethreitz/clint), thanks umbrae!
No, it doesn't mean that. Here is the background. If you want a unicode string literal, in python 2.x you have to write `u"string"` (as the default native string type is a byte string) whereas in python 3.x you just write `"string"` as the default type is a unicode string. This presents a problem if you have a codebase where you need unicode string literals and you want it to work in both 2.x and 3.x. The original solution to this was a feature added to 2.6 where you could write from __future__ import unicode_literals ...and now in python 2.x you can write just `"string"` and it would be unicode, thus allowing for a portable solution. Unfortunately, this backfired because it makes it impossible to specify a "native" string type in a way that works on both 2.x and 3.x: if you wanted a byte string on 2.x you'd have to write `b"string"`, but that forces a byte string on 3.x too. The WSGI protocol specifies three different types of strings: unicode strings, byte strings, and native strings, so this is an example of a case where you need to specify a native string. So while `unicode_literals` fixed one problem it just created a new one. Thus they want to introduce `u"string"` to 3.x. It won't do anything, because `"string"` already gave you a unicode string there. But it finally allows the proper orthogonality: - if you want always a unicode string, no matter the version, you write `u"string"` - if you want always a byte string, no matter the version, you write `b"string"` - if you want a native string (bytes in 2.x and unicode in 3.x) you write `"string"` In essence, instead of trying to force the 3.x way onto 2.x by changing the 2.x default for literals (but not the default for the rest of the python interpreter internals), you instead allow the 2.x way to work on 3.x, by prefixing strings with `u`. 
&gt; be able to run an old system and new system concurrently You won't necessarily be able to do that - e.g. if your code contains other incompatibilities. However, this particular item will no longer lead to syntax errors.
That's [clint](https://github.com/kennethreitz/clint) by Kenneth Reitz.
&gt; Unfortunately, this backfired I'm not convinced about that. `str('xxx')` or other alternatives are there for specifying native strings. The downside of this approach is that it extends the life of `u'xxx'`, which bothers some people. Plus, of course, it's not mandatory to use the u'syntax', so in 3.3 code both 'xxx' and u'xxx' will mean the same thing.
[/r/learnpython](/r/learnpython) would be a good place to start with Python itself, but I'm not sure I've seen anything around here dealing with that Chronos watch.
for people like me who got confused, you can define a context manager in a class by defining the __enter__ and __exit__ methods , but you can also use @contextlib.contextmanager and use the style that is in this article
Lua. It's the only other one I've tried that I go back to and try to learn more.
It doesn't break backward compatibility of the 3.x series. `u"foo"` was not valid syntax - now it is. If you have a valid 3.2 program it's still a valid 3.3 program. It's a relatively minor thing, indeed, but it allows the same codebase to work in 2.x and 3.x without `2to3`, which is actually a major plus.
&gt; Well, it will be fun to break the compatibility of the previous 3.X series Not at all if you read the PEP. For Python 3.2 and 3.1 there will be an on-installation hook that strips the u prefixes similar to how currently 2to3 is invoked. It just makes it easier to have a shared codebase for newer 3.x versions.
mind widened, ty
Go, It's like a static, compiled version of Python with type based interface and channel
+1 for javascript, although i guess i prefer the coffescript syntax, i like how light the language is. I also find the node.js project interesting, still not sure how much of it is shiny-new-toy hype though.
any of the books on the right are a good start too. 
No, there are closures but they aren't exactly anonymous (not sure if this is the right nomenclature). Basically you can create a function inline, you have to start a new statement, give it a name, and then pass the name around. No, lambda's only support a single statement. They're for the most part completely useless in Python.
Exactly why you should use `partition`: &gt;&gt;&gt; s = "Hello Dolly!" &gt;&gt;&gt; line, _, comment = s.partition("#") &gt;&gt;&gt; line, _, comment ('Hello Dolly!', '', '') 
u"Make it so."
Haskell - it's just mind blowing... I still don't think I fully understand it, but I feel like some kind of wizard when I write code in it that just works first time. When I first felt like I basically understood the laziness and how the type system worked, it was like that scene from the matrix: "all I see now is blonde, brunette, red-head..." 
what framework are you using? I know PyCharm 2.0 supports multiprocessing. I had some trouble getting a Flask app running, I just had to adjust some parameters. i wrote a blog post about it [here](http://sullerton.com/2012/02/debugging-a-flask-app-inside-pycharm/) i've never had a problem with pycharm and django
Unicode porn will finally be supported in 3.3!?!?!?!?
+1 for CoffeeScript. I like my code like I like my women: small, easy to read, and without braces.
I feel like I'm cheating when I use Haskell to solve ProjectEuler problems.
i've used PloneSoftwareCenter: * http://plone.org/products/plonesoftwarecenter and this guide: * http://tarekziade.wordpress.com/2008/03/20/how-to-run-your-own-private-pypi-cheeseshop-server/ to make own pypi server on debian
http://reggyapp.com/ helps me 
http://pyx.sourceforge.net
I am interested in [Atomo][1] though it isn’t usable in the real world yet. [1]: http://atomo-lang.org/
Python blows most languages out of the water when it comes to readability. It's hard to definitively say why, but it makes working in Python great. C was the first language I learned and it's still one of my favorites because I'm used to it. Lisp dialects are also fun to play with and I've been learning Haskell (which is pretty incredible). Java is pretty useful (if a bit verbose) and the JVM is good platform for languages like Clojure. JavaScript is nice too. C++ is okay as long as you (and your teammates) have discipline and only use the saner features. Lua is a cool language too and I love the ability to interface with C and the exciting LuaJIT stuff. I don't really have a favorite language anymore. Python is just great for getting things done, but I'm pretty language agnostic nowadays. That said, I prefer using things written in Python and C.
I'm really enjoying experimenting with [Go](http://www.golang.org/) right now. It's clean, orthogonal, powerful, fast and expressive, has good libraries and tools. And a cool mascot! But I frequently wish I had an opportunity to do something with [OCaml](http://caml.inria.fr/ocaml). It is a curious blend of functional purity and goodness, mixed up with a big dose of classes and objects. I guess I've always had a thing for functional languages, and would love to have some more time to play with the likes of Haskell, Common Lisp and Scheme/Racket. 
I've also found the with keyword useful when dealing with opening and closing sound files, database connections, for writing a quick and dirty testing system (it used with for startup, tear down, and timing). It's pretty nifty.
What's the advantage of knowing both? It seems like they're so similar, you don't get much new from them. I suppose Lua is better if you need to do an embedded interpreter thing, like in a game, but otherwise, why learn it?
Use back ticks when talking about Python `__methods__`.
Cheers, have an upvote.
One more vote for Clojure. Really, get over parentheses. For "very interesting, but not yet usable" I recommend [Julia](http://julialang.org/).
Well, to be fair, running the script will still require additional work, it just doesn't have to be *compiled*. The python interpreter will convert the text file into python bytecode and then run this through the python virtual machine, which is similar to how compiled binary is ran through the CPU.
C. It's simply beautiful and it nicely complements Python.
It often equals to typed/non-typed. 
&gt; what framework are you using? Bear in mind that it might not be a web app at all - Python has many uses besides web programming.
apropos, this is a great essay on the subject: http://www.perl.com/pub/2007/12/06/soto-11.html
What this means, is that most Python 2 code that is ported to Python 3 will not be able to run on Python 3.0-3.2. An odd situation indeed...
Prolog.
I was looking for doing this in Python myself and came across: http://plastex.sourceforge.net/ I can't say anything about it, but would happily hear if it's any good before I use it :-)
No work on the part of the user. You can run a script you just wrote without thinking about source vs build products.
Scripting is mostly a use case. A language that is good at scripting is a language that has little overhead for the programmer: there is no minimum boilerplate (a script can be just one line), it can be used interactively, it can be run immediately, it is already installed, and it doesn't require special tools beyond a standard editor and a single command.
Yeah, that's the kind of thing I meant.
This is how 2to3 is officially supposed to be invoked.
C used to be my favorite before Go came around :)
if you really want compatibility with 3.0/2, you simply do not use "u" and deal with the porting pain exactly like it was before this PEP. So nothing is lost, really.
It's not ideal, but it should mean developers can test on 2.7/3.3, then add the installation hook to make it work on (some of) 3.0-3.2.
C++. It's powerful, fast and fun to use, especially with C++11. Not as fun as Python though :)
There's a classic definition of a scripting language as a language used to control the execution of some other [normally machine language] program. In that sense, a scripting language is a language used to *script* the runtime behavior of a program. An early, common use for such languages was to allocate datasets¹, invoke the system's program loader, and begin execution. At one time, this "obvious, easy" task was a manual process, so little script languages were created to automate the work. That's where the "used for system administration" bit comes from. The interpreters for these script languages evolved into interactive session programs (shells, "the command line"), and the languages grew lots of features, becoming quite powerful. The benefits of writing whole "programs" (as opposed to just a subset of programs that might be called "control programs" or "scripts") in these scripting languages became widely evident, so scripting languages informally divorced themselves from program loaders, and eventually grew up into general purpose languages. # ¹· Files.
Came here to say that. It was written with Perl in mind, but applies to Python just as well.
Ada. 
Yup. Or escape the underscores, like this: `\_\_enter\_\_`.
When many of the frameworks and libraries you code in are written in Java, yes.
I dont like it but R is pretty good. 
I love C# because its a perfect combination between C, C++ and Python
&gt; It is literally impossible for 99% of people in a community to misuse an idiom. A counterexample immediately comes to mind -- science. Most people think science means knowledge. Also, not a case of 99%, but there's "literally", which most people think always meant according to fact, without exaggeration. [But the second definition for "literally" is... figuratively.](http://www.merriam-webster.com/dictionary/literally)
[Ursala](http://www.basis.netii.net/ursala/)
yep. great great language. 
I thought that was Perl ;) TIMTOWTDI
Go is pure joy to code in!
Really interesting stuff! Thanks for the link.
https://en.wikipedia.org/wiki/Scripting_language
It's not about having types or not, it's about being _loosely_ typed (such as PHP) or _strongly_ typed (such as Python). Plus, you're just describing dynamic languages, where types are not known until runtime.
There are a lot of times where jQuery isn't a convenient option. For example let's say you're developing a bookmarklet that scrapes a page to find the largest image. You have no way of knowing beforehand if the page they run the bookmarklet on already includes jQuery, or what version, or some other library that conflicts with jQuery. There are some tricks you can employ to still embed it in this case but by then its probably overkill to include all of jQuery just for a use case like this. TLDR: Not all DOM based javascript programming happens on a website under the developer's control.
Technically speaking, Python has a form of compilation, but your definition seems like the one who is the most widely accepted.
I picked up some lua to configure luakit, and I did like the syntax. I may have to go back when I've time. I'm being forced to learn Java at the moment. I miss real reflection. How does lua do on this front?
Dynamically typed, yes. I should probably stop now :)
Is the host doing anything else? If so, then additional processes will "steal" CPU time that might otherwise been appropriated to the competing processes.
This may not work for you, but here is a rough rule-of-thumb I use to start with: num_processes = num_cores + %iowait * num_cores * 10 when running with just one thread. Eg: If I am using a two-core box, I run the script using only one thread. I see using "top" that box is running at about 80% user/system and 20% iowait. I will then try to run it with 2 + (.20 * 2 * 10) = 2 + 4 = 6 process pools and do further testing. 
uhh english?
Yea I agree, I have a background in perl but figured I should branch out a bit :) Took the CS101 class to get an understanding of python. The 1st lesson is a little slow since it really goes from knowing nothing at all about programming, but its not unbearable and goes by pretty quick.
Definitely E (http://erights.org/). It's Python-like in its simplicity and adds a much better understanding of concurrency.
Java is compiled/translated if you will to bytecode which is then executed through the use of the java virtual machine. 
Exactly like Python, a numerous ""scripting"" languages.
I've always used 1.5xN for making sure things stay busy. I guess that, like you say, it depends on what you're doing. Things that wait on IO a lot (that aren't asynchronous) can have 3xN or more.
Seriously? I would rather run 2to3, switch to a new branch for python3 and start cleaning the code an fixing the problems that arose, rather than having to know what 2to3 will do, code, and distribute it with 2to3 in the install script. I guess this depend on what you focus on, python3-specific code, or shared codebase.
I'm pretty sure this question and the word bytecode live in different universes. You can only get so pedantic when someone says "what is X?" To be fair, the entire body of compiler and interpreter design theory could be barfed up in response to this simple question and shouldn't be.
I shouldn't have _exactly like Python_, but I'm pretty sure CPython compile the .py files to bytecode (as said [here](http://docs.python.org/devguide/compiler.html)). I probably didn't understand correctly what you tried to tell me, but I don't think Python is being run straight (unless you're talking about the REPL).
Don't make me dig through hundreds of comments to find out what you're talking about.
this is great- thanks