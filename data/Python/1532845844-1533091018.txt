The slides got a bit mangled due to the first laptop not working in the room where this was given, so [here are the slides as they're supposed to look](http://media.b-list.org/presentations/2018/pycon/bytecode.pdf). If you prefer this in article format, [opensource.com published an article version of it](https://opensource.com/article/18/4/introduction-python-bytecode).
Do tell more. I have been learning python for about a month now. This was the original reason I wanted to start learning it. Turns out I like it so much that I am going for a career change and masters degree in CS.
Ok Will try that this morning, hope it's gonna be same github page? Thanks!
Thank you for the links. By the way, were you present in the PyCon session?
I was there, yes.
&gt; because the compiler won't allow it. ...and will raise an `IndentationError`.
I taught myself python while working as an EE at a consumer hardware company (maybe the biggest producer of data storage products that exists if you can guess the company). I worked running a testing lab and had several technicians and many many millions worth of equipment. I wrote a lot of Python scripts to speed up things that were inefficient or write new test modules. But there was another group that did coding for this test equipment and they would always get upset that I didn’t use their crappy matlab framework. In my new job (same company) during the interview process they kept saying my python knowledge would be really useful. I created a way to control the IC we work on with Python after my boss told me to. Then he basically said it wasn’t really necessary since we already have a tool to control the IC in TCL. Everyone knows and uses TCL in my current position and I’m encouraged not to use python since it’s not what people are used to. I’ve tried to use Python to advance my career but so far I’ve just gotten unlucky and all the groups I’ve worked in have used other languages and gotten mad when I used python. I wish I had gotten this job at Google that I interviewed for since it was an EE position that revolves around Python.
&gt;&gt; &gt;you are saying a lot, but backing it up with no case studies or code samples. &gt; &gt;&gt; Well, they are asking us whether their impression is correct or not, and whether anybody here has experience to confirm/discomfirm that impression. I don't think it's necessary to provide case studies or code samples. If anyone should do that, it would be us. What's the point of a forum like this if you can't ask questions without having excessively researched the topic you are interested in? 
Is it just me or does OP have a bit of a suspicious posting pattern?
When I read about assignment expressions (https://www.python.org/dev/peps/pep-0572/) my first wonder was if it effected Hy.
Yes it is.
How so? 
As an applied physicist specialized on numerical algorithms, I have used Numerical Python a lot since I picked it up about 19 years ago. However, I learned Clojure some time ago. One of the promises of Clojure is better support of concurrency by stressing immutable data structures - think of the principle that a string can be used as a dictionary key in Python, because it is immutable, and that principle extended to all standard data structures. With this approach, accidental data race conditions in different threads are much harder to produce. and it works. I think this aspect of Clojure is hard to reproduce on the Python platform, it is just not designed for concurrency, and it is hard to get around the GIL. In many cases, especially for scripting, this is not that important either. But apart from that, the functional programming style is really great for writing scientific algorithms. This is not a mere claim. Look at the Numpy vector library documenation - the huge majority of routines do not modify their input arguments, but return a new array with the result, and leave the input untouched. That makes it much easier to write sane, testable code. This is not only an opinion of me, it is also what an expert and early developer of Numerical Python, like Konrad Hinsen, [says here](https://khinsen.wordpress.com/2014/05/10/exploring-racket/). Hinsen specifically mentions Lisps and Clojure, and the reason is that Lisps map really good to a functional, side-effect free style of programming. Clojure is still a minority thing but quite successsful in the realm of web applications. One reason for its success is that it is hosted on the Java platform, which makes all of Java's libraries available - similar to the "Batteries included" approach of Python. However, Clojure has disadvantages for doing high-performance numerical computing in an interactive environment. So far, Numerical Python seems like a better fit for that. One of the reasons is that it is easier to call into C implementations of numerical algorithms - setting up JNI calls is quite some overhead. Actually, Lisps can do it better, for example in Racket it is even easier to call into C, than from Python. 
I use [Atom](https://atom.io/) with [Hydrogen](https://github.com/nteract/hydrogen) for interactive executing, [MagicPython](https://github.com/MagicStack/MagicPython) and [python-tools ](https://github.com/MichaelAquilina/python-tools) plugins. VSCode is just as IDE as Atom. Both are text editors based on Electron and web technology where IDE functionality can be added via plugins. Pycharm is an IDE out of the box, but its indexing was hellish slow in my setup and the interactive executing was (which is crucial for me) was nowhere compared to Hydrogen when I last checked.
&gt; Doable with standard Python already. I think that constructs like list comprehensions and generator expressions sneaked into the language, yes, but that was not because Python's BDFL liked functional programming. In contrary, he has said quite openly that he hates it. On the other hand, libraries like Numerical Python have quite a strong functional foundation, and I think that at least some of the early contributors like Konrad Hinsen knew and liked Lisp.
But in his vision, the argument list for the method would not need `self` as the first parameter in order to access "this".
Well, this posting seems a bit like an ad. OP has a generic stock photo profile picture. Six month old account with hyper-generic AskReddit posts until enough karma is accumulated to start dropping links to Python learning material for sale. Then, the first response from torvel seems a little bit like someone had a writing assignment, with an account less than 1 month old, whose only other post is on a Serbian sub which earned him the tag "amerikanac", i.e. American, i.e. the posting was probaby the result of machine translation.
Made an **[updated version](https://imgur.com/WnUETHP)**. Some people might not like it.
you may be confusing pypi &amp; pypy. Gevent/asyncio is low level stuff. You don't need to get down there.
No, you're confusing. I have no idea what you're trying to say with your second sentence, but it's clearly way over your head. Good luck with your abstractions. Damn that is a terrible comment. Wow.
Well I mean... I use 2.7.
Funny :)
Should replace Python 2.7 with Electron.
AHHH!!
That's not funny. That's cruel and unusual punishment.
I really like pipenv, especially in conjunction with Docker it's super useful. :)
&gt; [AAAAHHHHHH!](https://imgur.com/nd1kEwj) FTFY
Would be even cooler if it used Trio instead of asyncio.
Friends don't let friends use Python 2.7
There once was a Python-alike .net language called Boo. I was confused a bit at first.
Unless you work with thousands and thousands of lines of 2.7 code. Then replace the last panel with "January 1st, 2020".
Unless you work with thousands and thousands of lines of 2.7 code. Then replace the last panel with "January 1st, 2020".
What's wrong with 2.7?
Oh hey it's my post :D Glad it got traction haha! Didn't expect it to blow up like it did. Anyone wanting to use the blank template: /u/Gurdel
Last thing I remember using it was Unity. 
Are you using pipenv inside Docker container?
We do this, works great
What did you do with Python+Cisco? What are you using for create documentation? When I was into networking I create a couple of scripts that automatically check the configuration of ports according to descriptions. It was a very useful tool to find some misconfigurations or just a mistake. But the tool that I was more proud was a script that update BGP filtering and policy automatically. You create the peering relationship from the web interface and he update the configuration and create filters according to RIPE. P. S. For configuration management we use Rancid that is based on SVN. it's not git, but it's still version control
https://pythonclock.org
Why? Is it bad? I thought it's a legit way to write desktop apps using a web dev toolkit
Just because PF won't do it doesn't mean no one will. There are millions of dollars in contracts promising secure python 2.7 well beyond 2020. Don't worry about it unless you plan to actively develop in 2.7 at that time.
the apocalypse
Depending on your needs, mediawiki could also be an overkill.
I would be curious as well... especially something which don't force camel case on wiki entry names, since ThatIsTerriblyUgly.
I'm not sure why you're asking, but just in case, installing packages system-wide with pip can still fuck up your OS, container or not.
Very bad. Why on earth for each desktop app, I have to bring a whole bundle of a web browser and a NodeJS installation? 10 apps mean 10 bundles of those. If, for example, you write desktop app with Python+GTK, your app just shares the same GTK+ lib with your desktop environment and other apps, your app just reuse the Python interpreter already come with the distro. Not to mention that, in Electron, each access to the desktop feature requires to go through more intermediate layers: Your JS in browser cannot directly access, it have to send messages to the NodeJS backend, the NodeJS then do the required job and send back response to your JS in browser. For native desktop app, there is no waste of time and CPU cycles like that. So, it is better when you use a desktop dev toolkit to write desktop app. Use the right tool for the right job.
Why do you have to create a virtual environment inside the container, when your app is the only Python app in that container, no clash with any other one?
Pip is not what I concern, pipenv with additional virtual environment is.
Hum, I was half right. It's realtime and ideally shouldn't be in Python :) (Battery life and the fact that it affects the performance of every other app on the system by continually running demands that this be highly optimised).
Bring `print "hello" ` back... It was literally the only reason I was using Python 2.7 for so long :(
Got it, thanks.
I thought about using a cron job or something similar but that seems less flexible as I’d have to check if everything is alright at every run, synchronize and then change the wallpapers. The goal was to make it fool proof and “seemless”. The refresh rate I use is 5 seconds which shouldn’t really impact batter/performance. Iirc, on Linux systems there is a system call that signals that time has changed by some software other than the clock. Perhaps a future version will be interfacing with C and use that.
I dont get why you don't just sleep, then check the time when you wake up, and calculate the wallpaper state from the clock time?
Programing novice/idiot here - why is Electron so badly optimised. Is there no way to go around this?
Look very cool! Good job
You could be running multiple python apps in the same container (e.g. if you split containers based on services and your service consists of more than one python apps)
Yes because it is a lot easier to keep dependencies in sync using pipenv due to lock-files than with pip using requirements.txt. It might be the only Python app running in the container, but it's certainly not the only app I'm working on. 😀
That's something I'm quite positive about because it's another _good_ tool in their lineup. I'm not against Microsoft per se, I just don't like their .NET environment. :)
It’s not badly optimized its just like using a dump truck to go get groceries. Sure it works but is it the best tool for the job?
pypi is the python package repository (dont confuse this with suppository now). pypy is one of the python interpreters implemented without CPython and the GIL Hope that clears it up for you. But I may be wrong about that last part.
Because if the user for whatever reason decides to change the time back 8 hours during the sleep and the wallpaper will be wrong. The solution to that is to have a range of times for which each wallpaper will be set in. Then the issue that arises is that some person may want their wallpapers to be spread around 48 hours. Or, the wallpapers may not be allotted the same screen time.
From what I heard, it's main strength is that, since it's made with Javascript and HTML+CSS, and every consumer device (mobiles, PC's, tablets, etc.) with all 3 OS's (Linux, Mac and Windows) can understand it, you can just build the app once and it will work on any device/platform. According to their logic, today's devices are so strong that is offsets javascript's slower speed. Did I miss anything?
Well, Maya and many other CG apps use 2.7 for scripting and plugins. So I'm stuck with it.
There is no way around this. electron is just a browser without an Adress bar with a few switches to fit the application at hand. It is an awful solution for lazy companies (like Slack, WhatsApp) to offer a "desktop application" and users generally don't care.
It's not about optimization, it's about bad design and architecture. 
So? Python's best feature is the almost free FFI. Also, https://apenwarr.ca/diary/2011-10-pycodeconf-apenwarr.pdf
Electron will not run on mobile devices, as it runs atop Chromium and Node.js.
I believe the mac implementation calculates which wallpaper to use from the position of the sun according to your computer's clock, so their code is going to basically be: sleep, wake, check time, calculate image. I could be wrong on that. Anyway, you do have a nice library.
Their implementation is limited/not flexible ;). Thanks.
... pypy usually has GIL, the non-GIL-pypy is ~slower. I wrote PYPY ??? And I meant that if no PYPY support, it sucks for performance reasons, since your whole app will be in cpython. What part of my comment implied I was talking about pypi ?
seems like a nice project
I liked that, it's a bit of a shame it didn't get more traction.
If you specify concretely the version of the packages inside requirement.txt, it is just the lock file you want, with leaner environment (you don't have to install additional package, which is pipenv and its dependencies). You are working on more than 1 Python apps, but they are running on your PC, not your container. It is reasonable that you have multiple virtual env on your PC, because it has many Python apps, but when coming to single-Python-app container, a virtual environment is just redundant.
The hy compiler lifts out setv expressions out of expressions and into statements. (defn sometest [] (while (not (setv r (input))) (print r))) With assignment expressions, the equivalent python would be def sometest(): while not (r := input()): print(r) The hy compiler produces this: def sometest(): _hy_anon_var_1 = 1 while _hy_anon_var_1: r = input() _hy_anon_var_1 = not not not None print(r) if _hy_anon_var_1 else None
Could you give example of an service consisting of many Python apps? I've only seen service, which comprises of a stack of softwares of different tech (like, it has Python server app + Redis + Nginx).
In Docker Swarm mode and Kubernetes you can actually run multiple containers per service.
Doesn't mean you will necessarily be able to get support though. For example, AWS Lambda will stop letting you create new functions with the old runtime or update existing ones: [https://docs.aws.amazon.com/lambda/latest/dg/runtime-support-policy.html](https://docs.aws.amazon.com/lambda/latest/dg/runtime-support-policy.html) This will cause problems if you want to redeploy your stack.
That's not a very good reason to use old language versions.
We use our containers for a terraform pipeline which allows us to have the users run their builds locally to see the plan, for this we have aliased commands that call pipenv runxxxx and use a number of packaged tools. The docker container then contains an exact replica of what the users will run and we use the same aliased commands (to keep things easy) So replicating userland in a docker container makes sense, then we just ensure that deployment only occurs in the pipeline context. 
I didn't run any benchmarks to look into performance differences between running a straight pip container vs a container using pipenv for managing dependencies. That's definitely something I should look into, especially in scenarios where Kubernetes and cloud billing is involved. But for me it's a lot easier to develop using pipenv, let it handle the lock-file and let the Docker container grab the source code from GitHub:E. This way I don't have to care about the requirements.txt, which in itself is just another source of human errors. :) I'm thankful for your insights nonetheless!
RedHat will continue to patch 2.7 through the lifespan of EL8 which runs through 2024. All because they could not update their system management binaries to be compatible with 3.
Hmm, maybe whitenoise (\`--pre\`) does the trick: [http://whitenoise.evans.io/en/latest/changelog.html#range-header-support-byte-serving](http://whitenoise.evans.io/en/latest/changelog.html#range-header-support-byte-serving)
Electron is basically a web browser, not just JS/HTML/CSS, so every electron app is in itself a new browser and at least from experience the few electron apps that I've seen none of them seemed to use any of it's used resources effeciently. Today's hardware is usually strong enough to offset the slower speeds, yes, but electron seems to eat away at that offset quite a bit, and bad JS code won't help either.
Native desktop GUI toolkits like Qt, GTK, WxWidget are already cross-platform, it can run on 3 major OSs. If you don't want to code in difficult languages like C/C++, you can use their binding in Python, which is already cross-platform, can run on 3 OSs, and with the benefit of leaner stack as I analysed above. And note that, your app is easier to be cross-platform, if its feature is limited, it doesn't depend too tight on OS-specific feature, like D-Bus on Linux. Coming to cross-platform, native desktop toolkits even have longer history than Electron. Today devices are stronger than before, but it still not as strong as Electron developers think. That is why many users like me and someone who agree with me, are frustrated with Electron apps.
You can make DFs from CSV easily, and save them to JSON just as easily. The following: import sys, pandas pandas.read_csv(str(sys.argv[1])).to_json(str(sys.argv[1])+'.json') allows you to do the conversion in just two lines and two imports, provided your inputs have the headers set, but no explicit indexing, otherwise you might need a little extra work. This is a minimalistic example, not something I would use in live code, mind you, but it's a good demo.
It's kind of ironic that the python community likes to be actively malevolent to the business that employs them.
Every benefit you assigned to pipenv are just the same to _pip + requirements.txt_. 1. Grab the source code from GitHub: Actually, pipenv calls pip to find the source, download the source. So in both case, the result are just the same. 2. requirements.txt is source of human errors: Then don't let human to write that file. Just use `pip freeze` to generate it, and the result already a lock file (with specific version of each package).
Yup. Jython being 2.7 = writing all 2.7 Python code
Would like to see this give me the heads up when you have done it please. Scraping JS sites is a pain in the butt.
Ah, I'm sorry to didn't communicate that clearly: I meant letting _Docker_ grab the source from GH:E, not pipenv. :) Regarding the requirements.txt: I know about `pip freeze`; what I meant by human errors is forgetting to do it and thus missing out new packages installed by git. I know that this is something you could handle by git hooks, but then again, you have to do the extra work. So besides having to generate that additional pipenv-layer in your Docker image, what's the downside of pipenv? In my opinion (and with the amount of computing power etc), the pros regarding usability outweigh the cons of the additional layer.
2.6. :(
I'd imagine people using 2.7 don't have lambdas. PaaS can be an issue of course. More classical way of running things won't be as bad as people make it out to be every time 2.7 is mentioned.
\&gt; I'd imagine people using 2.7 don't have lambdas. I've seen new scripts written in 2018 to run on Lambda using the python2.7 runtime, and I would be very surprised if I were the only one.
I'm always arguing it's not easy to switch for old, large codebases, for financial reasons mostly, but to use 2 for new things now? Some certification issue? Or a weird dependency?
What is that date? 
Thank you!
Dunno, I think in the cases I've seen probably just people who didn't really know Python that well being shoved in at the deep end with old examples. Or maybe people who came from an environment in which Python 2 was the only option.
I'm assuming you meant el7 since 8 isnt out yet and they for 10 year support at redhat. 8 will definitely have python3 as the standard. https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/7.5_release_notes/chap-red_hat_enterprise_linux-7.5_release_notes-deprecated_functionality
It's an ease of development issue. Devs can make a good looking desktop app, in a language they know, that runs on their target machine (high end first world computer). No doubt election is bloated trash, but don't ignore the reasons someone would choose it.
I feel golang might appreciate this, with the final panel being "generics".
Thanks! These pointers help.
That's considered bad practice.
I'm not keen in electron either but for most desktop apps, Python+GTK will be slower than Electron. Electron will take up a lot more memory though. Unless you are doing some kind of calculation you can push into C with numpy etc, then JS is just going to be quicker and the browser's GUI is fast enough that it isn't going to be the bottleneck. It's acually fast enough that some AAA games are using webtech for their in-game GUIs. We shit on Atom a lot for its slow speed, but I do not see Python+GTK building a faster editor than Atom.
2.6 Out with improved examples in the GitHub. Easy to change the look and feel with a single function call. System default [https://user-images.githubusercontent.com/13696193/43366713-37f8f074-9310-11e8-915b-3da26f0fc013.jpg](https://user-images.githubusercontent.com/13696193/43366713-37f8f074-9310-11e8-915b-3da26f0fc013.jpg) Changing the colors: [https://user-images.githubusercontent.com/13696193/43366714-38162b9e-9310-11e8-9749-a9b904f844d5.jpg](https://user-images.githubusercontent.com/13696193/43366714-38162b9e-9310-11e8-9749-a9b904f844d5.jpg) [https://user-images.githubusercontent.com/13696193/43366715-3837c416-9310-11e8-806a-f4bd24fd5d46.jpg](https://user-images.githubusercontent.com/13696193/43366715-3837c416-9310-11e8-806a-f4bd24fd5d46.jpg) [https://user-images.githubusercontent.com/13696193/43366716-38559d1a-9310-11e8-8540-9098656f7372.jpg](https://user-images.githubusercontent.com/13696193/43366716-38559d1a-9310-11e8-8540-9098656f7372.jpg)
VFX platform is planning for transition. It'll be some years however.
End of life for Python 2.7.
1st panel: &gt;&gt;&gt;'boo' 'boo' 2nd panel &gt;&gt;&gt;print boo boo 3rd panel &gt;&gt;&gt;def boo(): ... return 'boo' ... &gt;&gt;&gt;boo() 'boo' 4th panel &gt;&gt;&gt;import sys &gt;&gt;&gt;print sys.version 2.7.13 (default, Jan 19 2017, 14:48:08) [GCC 6.3.0 20170124] #AAAAAAAHHH
Id argue thats a bit of a generalisation, the docker documentation outlines when it makes sense and when it should be avoided. https://docs.docker.com/config/containers/multi-service_container/
You made me laugh. Thank you
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
So your problem is less sharing the script, than it is getting a proper python setup on their machine? A docker image is probably your easiest option.
create a quick gui, then turn it to a single exe with pyinstaller
It's like 10 years old. 
Actually I am interested in hearing other solutions as to how I can quickly allow my colleague to use my script, but with limited web dev required.
How does this compare to [Quart](https://gitlab.com/pgjones/quart)? From the (very little) code shown on the website, they seem to be very similar.
How can I create a gui? 
I would normally suggest throwing flask in front of it...but since you're not great at webdev, probably go for docker
Just googled python gui, looks interesting! I didnt realize I could make a gui with python! Looks like I have a fun Sunday project on my hands.. 
I nominally had a class last year in Python 2.7. Managed to get away with using 3.6 for most of it because of the way the Prof ran the class🙏
[Pick one](https://docs.python.org/3/faq/gui.html#what-platform-independent-gui-toolkits-exist-for-python) Being real though, this is the way I do it at work. Not having to worry about do you have x y z installed and telling people "press magic exe" is easy. 
I was just looking at that site.. which do You recommend I use? 
Having worked with several interpreters of similar languages, I'll say that `self` in method signatures in Python simply reflects the way it is implemented in interpreter. Python interpreter distinguishes between self and other arguments to a function call (when it is called as a method). In other interpreters it may be done differently, for instance, the context may be stored on the stack and pushed or popped when the execution enters / exits the method (several JavaScript interpreter implementations work this way). I'm guessing that whoever wrote Python the way it is now did it simply by copying the underlying interpreter implementation, there wasn't much thought put into the question of *should* it be this way or another way.
I've got at least one dependancy for 2.7 that I use in lambdas. In other news does anyone know of a pyforce alternative with similar methods that works in 3.x?
I'll be surprised if they don't include 2.7 as a compatibility option though, even if the system itself doesn't use it.
vibora uses [uvloop](https://github.com/MagicStack/uvloop). I don't know if that's something you notice when you use it.
This question is better suited to /r/learnpython You will get much better help there.
Which desktop apps and Electron that you compared to go to conclusion that "most 
Hey thanks for the lead there, didn’t realize that was there, I will delete and repost there, thanks!
Dies anyone use 2.7? I have no idea why it's still a thing
Version with f-strings and `:=`. 
Of course I know that many developers choose it for the reason you mentioned. But to be easier in development is for what, if at the end your product get rejected by users
Bah. I just wrote my first from-scratch, for production Python 3 code last week. Yes yes, I actually meant print(“Jesus.”) TYVM.
The differences between 2 and 3 were always overstated. There is minimal difference for a programmer that wires a new program. The issue is that Python 2 was less strict and allowed to write a buggy code, which Python 3 refused to run. So everyone who has a large codebase will require significant amount of work to fix their code. Things are exponentially harder, because Python is a dynamic language, so in a static language you would get a compile error, once your code compiles you made all necessary changes and you are don't. In Python on the other hand you also need to run all of that code to be sure (good test cases). This is why mypy (when correctly used) can help a lot. 
Wrote a regex evaluator that tells me contextual and duplication problems in product descriptions. It has been an awesome journey so far into Python - three months ago I didn't know anything, and now I wrote something that has a significant positive impact! My job is on the business side, not in engineering, but it's nice to not have to put a ticket in front of them for little things - let them focus on the important / hard stuff. 
Sure. def messy(): if booleanA: if booleanB: doA() else: doB() else: doC() can be refactored into def neat(): if booleanA: subroutine() else: doC() def subroutine(): if booleanB: doA() else: doB()
I'm just getting started with python ecosystem but can anyone explain this to me? I thought `pipenv` was a good thing. What happened?
Because most users don't reject the apps. Slack desktop, Twitch desktop, and Discord desktop have very high installation bases by end users who don't know any different and don't care.
shiv is worth a look https://github.com/linkedin/shiv
Thank you so much for the code example, much appreciated!
Pyinstaller— all the way
I'll answer with an analogy. What's wrong with Windows 98?
The additional layer is the issue. I assume that you use Docker container to run the production system, which is required to be stable. And to guarantee the stability, the system must be as minimal as possible. Because when an error occurs, you have to spot where the bug is. If the system only has 1 component, you only have to check 1 place. If it has 3, you have to check 
This looks fantastic— can’t wait to check this out. 
[y tho](https://i.imgur.com/p3Q0lFx.jpg)?
&gt;`&gt;&gt;&gt;print boo` `boo` AHHHH!!!
Your example is just because, user cannot change author mind and there is no alternative. User has to suffer. And, let's just see how many votes I have, to see how many users get frustrated with Electron app, even more frustrated when the developers never listen feedback from their users!
amazing
Friends help their slow friends run their code through [2to3.py](https://docs.python.org/3.0/library/2to3.html)
A virtual environment like Anaconda makes even more sense on Linux because the system actually uses Python so now you a modifying something essential to the function of your OS. That being said adding to path is very basic and requires just modifying your users rc script. I’m going to assume you are using bash since it is default: https://stackoverflow.com/questions/7360889/adding-a-directory-to-path-in-ubuntu#7360945 
Just because the user doesn't care doesn't mean they shouldn't and won't eventually realize it.
I tried virtualenv now and when I tried to install Flask, I got the same thing! Could not install packages due to an EnvironmentError: [Errno 13] Permission denied: '/usr/local/lib/python3.5/dist-packages/click-6.7.dist-info' Consider using the `--user` option or check the permissions.
No problem. I edited it to put the subroutine definition before its call, which isn't always necessary depending on whether the source file is parsed before neat() gets called, but is almost always more readable with real production code.
I swear I had that correctly, idk where it went.
If as many people who write and use Jython contributed to a port to 3 it would be done already. 
It sounds like you're using NTLM authentication. Try this: https://github.com/requests/requests-ntlm
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
This sub won't give you an remotely accurate idea of user attitude towards Electron given that the vast majority of the users aren't going to be in a Python programming subreddit let alone on Reddit much at all. Remember that Slack is the #1 group chat app for business from small shops all the way up to some large enterprises. There's more than 6 million daily users.
Usually in institutions (workplaces, universities, etc) where there's a lot of code in Python 2.7 and it's non-trivial to switch to Python 3.
Did you mean trivial?
They should, but they won't. As a passionate computer enthusiast, it's not fair to project your idea of what's good on regular users. Often what we think is ignored by the populace at large. Look at the use of Facebook and Windows. Look at all the users who install malicious programs despite all the warnings from friends and in the press. The sad truth is that the most basic users aren't interested in anything more than getting done what they want to get done and sometimes being fashionable while they do it. That's not to say that we should give up on steering them towards better solutions, but just telling them that they are dumb or wrong isn't how you do that.
It is a good thing. We’ve converted all our work projects to use it because it’s really nice. Especially if you’re getting started: use pipenv until/unless you have a specific reason not to.
Some eventually do realize. And I'm not disagreeing with you, just adding commentary.
hello
Have you initialized the virtual environment correctly? https://askubuntu.com/questions/244641/how-to-set-up-and-use-a-virtual-python-environment-in-ubuntu#244642
Yep! All done! 
If you’re basing the container on something like Ubuntu/Debian, the system packages (eg. for pip) can lead to breakage: https://hynek.me/articles/virtualenv-lives/
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I recently learned python 2.7, I don’t understand this.
[https://engineersjourney.wordpress.com/](https://engineersjourney.wordpress.com/) Look at this blog, the dude writes a bunch about Hy (and Haskell and some more), some of those post are real nice. 
Boo()
No, non-trivial. You underestimate how easy it is for some institutions to switch. At my workplace, we have a large proprietary Python codebase. Proprietary tools built on top of Python make up the core platform, plus the systems developed from that platform, make up millions of lines of Python code. It is **non-trivial** to switch a platform like that from Python 2 to 3. It takes time and costs a lot of money to do.
Totally agree. I just started using it (and python, for that matter) in the past few months. Hoping to start digging into jython's internals and see what I can contribute. :)
For simple apps the user won't notice the difference. But just try to implement VSCode or Atom in Python. I don't see how Python matches JS when python doesn't JIT and V8 has many engineers working on browser optimisation. GUI speed difference between GTK and Electron really won't be noticed if you're making a regular desktop UI.
We have a huge codebase at my work in 2.7. This product has been in the works for many years. Switching to 3 would be an enormous task, but might be necessary nonetheless.
That's a very good point, I'll keep it in mind in the future. Thank you. :)
Huh. Didn't realize there were multiple libs by the same name. Its the Salesforce lib https://github.com/alanjcastonguay/pyforce
Automate The Boring Stuff has a good and simple tutorial about CSVs. https://automatetheboringstuff.com/chapter14/
Thank you I will see what I can do with that
Looks like someone made a Python 3 fork - see [https://github.com/alanjcastonguay/pyforce/issues/33](https://github.com/alanjcastonguay/pyforce/issues/33)
Looks great! I see that it is only compatible with Windows and MacOS. Is there some specific reason why it doesn't work in Linux? 
As a developer using an asyncio web framework, you largely don’t have to care about the details of asyncio at all. Mostly you’ll just use async/await, and perhaps loop.create_task and asyncio.sleep. That’s about it. Yes, the low level stuff in asyncio is a large sprawling interface, but most folks shouldn’t need to delve into that. Perhaps as the landscape matures some aspects might even gradually become private API. There’s a valid criticsm that asnycio is complex, but most folks ought to be to just stay within the happy zone of “asyncio, the good parts”
&gt; Programing novice/idiot here - why is Electron so badly optimised. Is there no way to go around this? You're not going to get a solid, honest comparison in this sub, but I'll add a few things. When shops use electron, they don't have to worry as much about packaging, installation, and support across platforms. They also get to use the engineering talent they already have in-house. They also get *much* nicer UI's. The big downside is resource usage. It's a trade. 
You are limiting your use of asyncio to an ASGI web framework, whereas truthfully asynchronous code has far more capacity and capabilities, from parallelized mathematical computation across N dimensions to complex event reaction systems to animation systens. The usability of asyncio suffers in all of these prospects because tasks and coroutines are not the same thing, and there is no "default" task queue on a separate thread. Which is why I'm writing a minimal wrapper to work around this stuff, just unfortunately work is currently getting in the way.
Building my own website using Django ;)
Would love to help but am not going to spend the time making that code readable. Lookup reddit markdown and use it to format your code.
&gt; No PYPY, but isn't the framework a small part of the whole app ? So you kinda need pypy ? Not really since the bottleneck in webapps tends to be the network. Once those bytes get into the application, the bottleneck would be your database connection (aka the network). Speeding up your processing won't do much good no matter how much it saves if you're just waiting on bytes from the wire. 
import pandas as pd df = pd.read_csv(‘/path/to/file.csv’) df[‘name_of_column’].count() I think that should do it. Take a look at pandas. Check out /learnpython sub. It’s more appropriate for these kinds of questions. It’s not that this sub is hostile to newbies (per se), but read the sidebar for /r/python intent. 
Point being: asyncio can be refined over time. It’s a set of building block primitives at the moment - we can rarify that, either with abstractions such as ASGI, or graceful usability focused libraries, or as the language evolves.
Main points: * Quart aims for ~Flask API equivalence, and uses ASGI as the server/framework interface. Supports either PyPy or uvloop. * Vibora is a “cythonised basically everywhere” asyncio framework.
What happens if more than one function has the same keyword argument name as another in the same namespace? Are they differentiated in the config or no?
What? No one said it can't be fixed. But a broken pile of shit has been pushed upon people provisionally and now in 3.7.
Very true, hence I spend my personal time out of work learning and implementing new design paradigms and frameworks. I think the most enticing thing though is that they give me 2 months of paid vacation every year, which I have yet don't anywhere else thusfar. I've even contemplated working as an intern during my time off. 
Garbage critique, with a garbage attitude.
Just being curious, wouldn't changing to Python 3 be worth all the effort?
That's your opinion, and some share your while others share mine. Deal with it.
For similar argument, Slack users chose it because of its features (channels, user mention etc) and its big user base, not because of Electron.
Has no one forked 2.7 yet? I will be shocked if no one does. It's doubt it's going away. It's probably less work to support 2.7 than it is to update some projects.
&gt; You underestimate how easy I guess you meant difficult? 
What's wrong with it is that soon you'll be in the situation where most libraries don't support it anymore and they won't bother to fix it if you ask, and everyone's going to be on their side. One reason python is amazing is all the third party libraries, and you're going to lose that at some point. There's not *that* much wrong with the version of the language. It was a very good version and that's why a lot of people still use it. What's more of a pain in the ass is how hard it can be to port some projects to 3.x. Byte/string errors everywhere, people doing `print 'string'` by default, things being generators when they one returned a list like `range`... Honestly I think it was kind of brash to change a lot of what they did due to how much it broke, but the language does feel cleaner now. I'm just not sure it was worth it because we wouldn't have been in this situation now if there were less breaking changes. 2.7 was great, but you're missing out on some good features of 3 and you'll be missing a lot of 3rd party libraries. I think it makes more sense to use 2.7 on a linux distro that doesn't start with 3.x now, but they are few now. Still, there are some. CENTOS 6 I believe was on python 2.6, and I think a lot of people still use it.
The presence of JIT is what I recognize that JS is quicker than Python in benchmark. But I also remind that the result in benchmark game is not necessary the same in real-life application, because there are more factors to come. Just an example, if it comes to a high computing application, JS cannot par with Python because the lack of specialized libraries which Python has (NumPy, SciPy etc.). When you say that GUI speed difference won't be noticed for simple apps, you are indirectly accept that for more sophisticated apps, the native desktop app will ha
Cool part of PICO8 is that it exports to HTML5... I guess Pyxel doesn't, which would be great! Does it, or is it in the milestones?
&gt;You underestimate how easy it is for some institutions to switch you mean overestimate? Yeah, I've had to port two medium/large codebases to 3 and it's such a pain in the ass. What I hate most are fixing all the string/byte issues, figuring out where to `decode` and `encode('utf8')`, from network data to hashing. And it's missing some stuff that was super easy at the time. You could just take a big string of data and do `data.encode('zlib').encode('base64')` and bam, you have compressed data base64 encoded. Sooo easy. The equivalent isn't too bad, but it's irritating to go around and fix all this shit and it's not as easy as it used to be to do the same thing. I've finally gotten used to unicode/utf8 issues but treating strings as raw data was nice and easy. I understand why they changed it, but I feel like there might've been a better way that would've broke less code. And removing print as a statement makes sense, but honestly I think they should've lived with their bad decision and still supported it as a statement. And keeping range/xrange really wouldn't have been the end of the world. I like what python 3 turned into but honestly I think it would've been better to live with some bad decisions and kept a lot the same because then we wouldn't be where we are, with people avoiding the upgrade. People make a big deal about people still using 2.7 but I hardly think it's their fault. It wasn't made easy for anyone.
You can add a lot of bugs that wouldn't be obvious with the port. It took me two weeks to port a somewhat large codebase, and there were some bugs in it for a good month that we caught over time. For a larger codebase it could be such a pain in the ass. But really, why is it worth the effort if the 2.7 version works as intended? I don't think this is so much "why not" as much as "why". Unless you know a python 3 lib that you really want or some library you use has a lot of bugs fixed and stopped supporting 2.7, there's not much point other than to say you have a modern codebase. A lot of people still know 2.7 and people who learned starting at 3 can pretty easily work with 2.7 without breaking a sweat. Starting a new project in 2.7 wouldn't make much sense, but supporting an existing codebase using 2.7 can make more sense than porting it.
Cool. I dug around and found [this](https://www.reddit.com/r/Python/comments/8jd6aq/why_is_pipenv_the_recommended_packaging_tool_by) and finally get OP's comic now. 
Oh I haven't heard of it before, I'll check it out
It is 2018 now and you still believe in an article of 4 years ago? Or do you still use Debian/Ubuntu and pip of 2014? I deployed my IoT app on embedded computer running Debian, install all 
Yes, I do. While Debian/Ubuntu might not be doing it *today*, there is nothing that prevents it from happening again. It’s possible that you would get conflicts if any apt packages were installed. Virtualenvs don’t have any downsides and they can prevent any issues similar to those.
Nope, when you're talking "making python fast, or python vs xxlang, etc", you mean cpu-wise and you are past network-time. 
Python 2 was released in October of 2000
Totally! I spent more time than I care to admit trying to figure out how to utilize timezones efficiently with the datetime library before I found pendulum, and now I've never looked back.
When I mention the years, I imply that the issue is just the design error of either Debian maintainer a
Except if it doesn't matter if you optimize something that isn't your bottleneck. In webapps, the network is almost always your bottleneck. Python, pypy or otherwise, waits for network traffic just as fast as anything else. If you profile and find that the network isn't your bottleneck and instead it's inside your app, then that's when you start contemplating switching to pypy.
I'll have to take a deeper look at this. I'd have hoped to keep backward compatibility with py2 to smooth the transition. Thanks.
Agreed. But in arguments over semantics where either side has valid argument for their usage, I will argue against the person trying to correct someone's (valid, but not unique) usage.
More like 1990
I'm a bit late answering, but as someone who waited 10 years, the answer is libraries. When people say most libraries support Python 3, what they fail to realize is that for established code, most isn't good enough: every library dependency has to support Python 3. Additionally, as you said there are only slight differences in syntax. Even with libraries supporting Python 3, is it worth weeks upgrading when it doesn't give you much? Additionally to that, Python is very dynamic, so many issues introduced in the upgrade would not be noticed until you run the erroneous piece of code. So unless you have an automated testing suite, upgrading is a high risk, low reward operation. In my case, I had half a dozen pieces of software use a GUI library named wxPython. Python does not have first party GUI support, so you have to choose between three or four third party libraries. I invested hundreds of hours years ago that I don't have anymore to learn a new framework, so changing GUI frameworks was out of the question. wxPython did not support Python 3 until January 2018. I've been spending the last week upgrading to Python 3, but I fully support anyone who decides to stay on 2.
No, they are not. This makes it possible to share config settings between functions. If you want to have the same keyword argument in multiple functions, but assigned different config values to them, you can have different config file sections. `@cfy` `def function1(value=13):` `pass` `@cfy(section='section2)` `def function2(value=13):` `pass` `@cfy(section='section3)` `def function3(value=13):` `pass` In the config file you can than have something like `[global]` `# Value used by function1` `value = 23` `[section2]` `# Value used by function2` `value = 42` `[section3]` `# Value used by function3` `value = 89`
Komodo's fast because it's using Scintilla C++ to do all the heavy-weight text editing. Atom does that slowly, but it's still faster than doing that in pure Python. Vscode is significantly faster than atom. You can call C++ from electron, too. For GUI, I actually think the situation is a bit complex. When you are doing complex graphics, GTK becomes troublesome. As a game dev myself, if the budget was low, I would just use Unity or HTML 5 if I needed rich graphics in a cross-platform app. Neither electron or python would be ideal here, and neither also work properly on mobile, unlike Unity, which will build for desktop and mobile. 
funny enough, python3 is available in lambdas only since apr 2017. So far less time than python2 is.
Python 2.7 is as old as Bernie Sanders.
I know I'm a bit late, but as someone who is just porting over Python 3, the big library issue for me was wxPython. It's a very complex GUI library that would have taken me hundreds of hours to replace. They became Python 3 compatibly January of 2018. Keep in mind that even if most libraries are compatible with 3, all it takes is a single non-compatible library that is hard enough to replace to stop an upgrade to 3 dead in its tracks.
Lots of things are enormous and expensive; that doesn't mean you don't do them. We had an underground oil tank leak; cleaning it up was an enormous and expensive task (tearing up half the front lawn, shoring up the house, removing contaminated soil, etc.). We didn't just say - well, it hasn't leached into the groundwater yet so let's just not do it. You're going to have to switch some time, and the longer you wait, the bigger and more expensive the task will be. 
&gt; But really, why is it worth the effort if the 2.7 version works as intended? Is no programmer familiar with the concept of [technical debt](https://en.wikipedia.org/wiki/Technical_debt) anymore? &gt;Technical debt... is a concept in software development that reflects the &gt;implied cost of additional rework caused by choosing an easy solution &gt;now instead of using a better approach that would take longer. &gt; &gt;Technical debt can be compared to monetary debt. If technical debt is &gt;not repaid, it can accumulate 'interest', making it harder to implement &gt;changes later on. Unaddressed technical debt increases software entropy. &gt;. A lot of people still know 2.7 and people who learned starting at 3 can &gt;pretty easily work with 2.7 without breaking a sweat. You don't understand... there will soon be no more 2.7 support. Major libraries are already ending 2.7 support ahead of schedule. Want the newest version of a web framework, of Pandas, etc.? Sorry, they've already said there will be no more versions for 2.7. Want to take advantage of a new OS feature? Sorry, libraries won't be updated anymore. A bug in Python? Sorry, no one's going to fix it. Then like the people who kept using Windows XP, you're going to find your hardware or Windows 23 won't run Python 2.7 anymore and you'll scream and cry and wail "But I never had time to port it!!!" You had 73 years; you just didn't bother. You kept writing more and more 2.7 code, making the eventual INEVITABLE porting even harder. 
There is no IDE which uses pure Python for text editing, based on which clue that you claim "Atom is faster than doing in pure Python"? Ability to use well-established Scintilla from Python is another example of my point: real-life application is not the same as benchmark games, because of many factors. Having fast library is one of those. VS Code is faster than Atom 
&gt; . At my workplace, we have a large proprietary Python codebase. &gt;Proprietary tools built on top of Python make up the core platform, plus &gt;the systems developed from that platform, make up millions of lines of &gt;Python code. It is non-trivial to switch a platform like that from Python 2 &gt;to 3. It takes time and costs a lot of money to do. Do you have unit tests? Also, everything takes time and money. You budget the time and money because everyone who works in software development knows it's a fact of life that you have to update software... all software. There's a term for it - bitrot. Eventually, SOMETHING changes - hardware, OS, other software - that kills your program. You can't just leave code suspended in amber and expect it to work forever. The more you put off updating your code and writing more 2.7 code, the BIGGER the inevitable job is. Welcome to "technical debt", which compounds like unpaid credit card interest. Any competent IT manager would have begun the task from the first day Python 3.0 was released; you'd have been finished years ago and future-proofed. Now you've written lots more outdated code and each day that goes by the task gets harder and harder. 
Have you tried powershell lol
yes i have, it's pretty alright, but I find it a bit beyond me honestly :)
&gt; It wasn't made easy for anyone. WHAT?!?!?!? From the 2to3 library to a feature freeze in 3.x for a time to constantly extending the deadline to BACKPORTING 3.x FEATURES to adding deprecated features back unto Python 3 to make porting easier to the advent of libraries like six that made it possible to easily maintain two codebases, Python did everything but personally send Guido to each Python 2 user and have him port their code himself. You know what happened when Delphi introduced unicode? ABSOLUTELY NOTHING. No deprecation warning, no extended support of old versions, no library to help you convert code, nothing. New version out, support for old version automatically ends, good luck, good day sir. I think they may have issued a white paper; that was the extent of the assistance. Python users got their behinds kissed and many of them still whined about it. If you haven't gotten around to porting in A DECADE; that's no one's fault but your own. 
Ask yourself "What's wrong with Windows 98"? The answer is: "Nothing, if it were 1998". Depending on how you measure it, it's 8-10 years out of date.
Dang; I didn't read down and just wrote the same thing! :-)
There is an IDE which does editing in pure Python. It's IDLE. It's very slow but some of that is due to Tkinter. I don't think you know the architecture of this software. VSCode is electron, and uses MS Monaco for editing instead of Atom. Are you confusing Atom and Electron as the same thing?
No one has forked it because for all the people crying that the Python devs should keep developing the 2.x line, they realize it's a daunting task and they can't do it themselves. Also, no one wants it. &gt;You don’t need permission. You don’t need to argue with anybody. Just do &gt;it! It’s not that hard. I’m just some guy on the internet, and I maintain a &gt;surprising number of forks of various FOSS projects. I fork more often than &gt;once a week. &gt; &gt;It’s not even that hard to backport major Python 3 features to Python 2. &gt;The work is already done in some cases, like Trollius and six. The fact &gt;that nobody has even bothered to take ten minutes to merge Trollius into &gt;their Python 2.8 fork is “case closed” level evidence that the demand for &gt;Python 2.8 is zero. &gt; &gt;Blog posts aren’t demand. Demand is people willing to develop. Demand &gt;is people willing to fund development. I’d even settle for a $15 themeforest &gt;splash page that lists one corporate sponsor and one developer’s bio. How &gt;is it that Python is somehow in grave danger of forking and nobody will &gt;even buy a domain name for the fork? People literally do that for a &gt;weekend hack project. This is a tempest in a teacup if I’ve ever seen one. Drew Crawford, https://sealedabstract.com/rants/python-3-is-fine/ 
How are you ploting the curves? Plotfly? Mathplotlib?
For all those asking why switch to Python 3, let me refer you to a great article by Drew Crawford, https://sealedabstract.com/rants/python-3-is-fine/ Specifically scroll down to "Nothing was gained". You'll discover that in that section he's compiled the change logs for Python 3.x only up to the date of the essay, 2014. Nevertheless, the document runs for **192 pages** and when printed out weighs **two pounds**. Check and mate (the entire essay is a good read too). Also.... How to pitch Python 3 to management: https://snarky.ca/how-to-pitch-python-3-to-management/ And an entire online book to help you port to 3 or support both codebases: http://python3porting.com/ And a nice slide presentation of ten things you can do with Python 3 but not Python 2 (hit page down to advance the slides): https://www.asmeurer.com/python3-presentation/slides.html#1 
Ok. I had mistake with Monaco. I was mistaken that it is written in some compiled language. But anyway, there is still no pure Python IDE to support your claim. Looking in IDLE, it is just like some example of how to make GUI application with Python, and like a quick introduction for Windows users who are not used to the Terminal yet, not a serious IDE.
Interpolate the curves at common x values, and then multiply the resulting arrays. 
I really don’t get the joke :( 
Which is fucking stupid and why python will always be a meme language
It sounds like you want to use a proper OpenGL visualisation toolkit, such as [Mayavi](https://docs.enthought.com/mayavi/mayavi/mlab.html). These will deal properly and efficiently with a 3D scene.
Oh! "Alive" as in finally targeting the version of python released a decade ago? Oh. No, not that. 
matplotlib
Clickbait title, clickbait code, clickbait everything, total bullshit.
One note, you're just providing the method signature in the error, not the annotations themselves. It just so happens that the reason you decided to do this is your method signatures include type annotations, and therefore they are included in the signature and therefore your modified error message.
You seem to be arguing against something I never said. I agree with you (mostly), it's important to eventually upgrade to Python 3, even for a codebase as large as the one I described. My workplace agrees as well. They've started a plan to upgrade the codebase to Python 3. It will take multiple years and multiple millions of dollars, but it will be done. The only argument I was making was against the person who seemed to think it was a trivial thing to do. Which it isn't. It's non-trivial. However, I must disagree with you that the upgrade should have been done as soon as Python 3.0 came out, for multiple reasons. Firstly, because the first few versions of Python 3.0 were "trial" versions of Python. Secondly, because Python 2 was being updated two years after Python 3 was released, with features backported from 3 into 2.7. Thirdly, waiting means that you can jump to a newer version of Python 3. Upgrading this year means being able to go straight from Python 2.7 to 3.7. Upgrading at launch would have meant being stuck on Python 3.0. This is a significant deal for large codebases, where even a .1 upgrade takes a long time to do completely. And finally, because it's foolhardy to rush into such upgrades immediately. What if the community had rejected Python 3, and there had been a split? What if Guido went back on his words and released Python 2.8? With so much time and money required for these migrations, you want to be damn sure that Python 3 is the future.
Reading and learning and ultimately doing nothing because I can’t think of a project that even remotely excites me. Maybe it’s the depression.
Have you complained about that? Not to him but someone superior?
[@cfy's latest tweet](https://i.imgur.com/rrFi2kE.jpg) [@cfy on Twitter](https://twitter.com/cfy) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Hmm, awesome. Wil have a look at that! Have a feeling it'll be a bit heavy on the Raspberry Pi but hopefully it works
Yo. “trio has a nicer interface, and a tighter set of constraints” would be a very reasonable point. “I think gevent’s implicit context switching is a better set of trade-offs” would be an arguable, tho debatable, position. “asyncio is a broken pile of shit” is just mouthing off without adding anything of any value to the conversation.
Just do it for forks sakes
2.7 came out later 
My claim is that it's too slow to make a good IDE in pure python+GTK and this is supported by the lack of an example. 
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
This is awesome! Here's what came of me messing around with it for a bit: https://github.com/vesche/snippets/tree/master/pyxel_test
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [vesche/snippets/.../**pyxel_test** (master → 28a1d8c)](https://github.com/vesche/snippets/tree/28a1d8c233b422c3d50344560bd7bce6d8950a0e/pyxel_test) ---- 
I have previously and even in this thread explained why it is a pile of shit usability wise, namely the fact that couroutines are not tasks and there is no default event loop on a separate thread. There is no current alternative that provides the solution to the problem I just mentioned, and I am personally working on a wrapper. If you consider I myself not even contributing just because no alternative currently exists, even though I am working on an alternative in the form of a wrapper, then you are being defensive of criticism that is completely well placed.
Weird dependency is why one last service in our system is still in py2.7... (looking at you, kapacitor-udf)
The visualisation should actually run fine on the rpi, its opengl acceleration is more than enough to do this kind of thing. I don't know if mayavi might have some problems there (to do with dependencies that you might have to compile for the rpi, which could be slow), but it probably can work. There are also alternatives such as the pure Python [Vispy](http://vispy.org/), which I'm pretty sure should work fine, but might be a bit harder to get started with.
The argument still stands. It sounds like you're trying to judge sentiment based on what you read on reddit. The reality is the vast majority of electron apps are accepted and widely used by the general public. 
That's not a similar argument, and it makes me wonder if you even understand what the comment is saying. The vast majority of the general public doesn't know or care about electron. Slack, Spotify, Discord, VS Code, and plenty of other apps are popular and loved by the userbase. It's like you're forming your opinion on Electron based on what you read on reddit alone. In reality people are fine using Electron apps.
&gt; I consider that the reason of "easy" is just show that the developer is lazy, and the reason of "language I used to" is just show that developer doesn't have ability to learn and improve himself. Such a developer shouldn't be counted on. This is insane. Ease of development and speed of delivery is a huge plus and should not be glossed over. You're thinking too much like a programmer and not enough like a person responsible for solving technical problems. Just look at your original post. Your argument revolves around elegance and cleanliness of the backend implementation. Who does this matter to? As a programmer, I see your view point. But imagine your tech lead/manager/etc wants to use this. They point out that you can share code between multiple platforms, which gives you a head start and can reduce development time. They point out that the talent pool either overlaps since it's the same tech stack. They acknowledge that while execution speed isn't as fast as a native app, you're probably not going to notice since most applications aren't cpu or memory bound. To bring the argument home, they point out that Electron is used successfully by many major companies who have huge user bases. How would you respond to this? The types of arguments you're laying down won't cut it. I'm not saying you're wrong. I'm not even saying Electron is a good choice. I think it's janky, too. I'm saying that the touted benefits make a lot of sense.
even Zope2 is running on python3 [1] now [1] https://github.com/zopefoundation/Zope/blob/master/tox.ini#L2
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [zopefoundation/Zope/.../**tox.ini#L2** (master → 61e6903)](https://github.com/zopefoundation/Zope/blob/61e690357983d831f3c0e3becd3faa418b3c5452/tox.ini#L2) ---- 
Lmao dudes a relics, however I’m concerned about my scripts?
Ace :)
That does read csv and emit json, but skips over generating the graph that OP wanted.
thanks!
Genuine honest-to-goodness regular expressions [strictly *can't* handle nested](https://stackoverflow.com/a/133684/392743) - you need extensions (which exist in PCRE, say, but add even more complexity/noise/stuff to go wrong in a compact space). I don't actually know if python stdlib regexes have this or not though, because... My advice is that as soon as you're dealing with nesting, that's a sign that you might want to reach for an actual parser. There are [plenty to choose from in python](https://tomassetti.me/parsing-in-python/), e.g. parso, parimonious, etc. If that's beyond your current level of expertise, this is an excellent opportunity to level up - proper parsers are a tool that will set you in good stead.
I learned this. from C#
Why wouldn't it be? The newspaper doesn't get to dictate what browser you use to view their PDFs, and Python is just a browser in this sense.
That's not a python-specific question. Not really a programming-specific question either, but you'll probably get a lot more exposure to others who have encountered the same issues in r/programming. I don't know a subreddit related to legal matters.
Look pretty good. Going to test it out when I have some time.
I find VBA very easy but it was also the first language I learned so it may not be very easy for people coming from a different perspective.
You could also contact the site owners themselves.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Zope probably has more developers than my company though (which has 3).
It runs fine on Linux, I submitted a [pull request](https://github.com/kitao/pyxel/pull/2) with Linux install instructions.
If you are just doing this for your own amusement, you won't have a problem. If you re-publish or make it available to others you'll be in violation of the terms of your subscription. 
That is unfortunate... I almost got everything I needed. This was the last step. I think I will just handle that part myself in python code. I've written parsers before, but I don't think my application needs to go that far. Appreciate the input.
check whether the website has a /robots.txt file
The learning curve isn't too steep once you realize that the functions (cmdlets) are verb-noun pairs describing what they're doing. Additionally, you can use Get-Alias to get the list of aliases for powershell functions which match up to cmd commands.
The legality of it depends a lot on what country you live in. The best thing to do would be to talk to a lawyer, which of courses isn't always practical. Short of that, I'd recommend reading https://en.wikipedia.org/wiki/Web_scraping#Legal_issues. Hopefully that can shed some light on the matter. Sadly scrapping is a very legally tenuous position in many countries. I would also suggest contacting the newspaper and politely asking for permission. If they provide the PDF, hopefully they would be reasonable about allowing you to automate something you will do anyway :)
That's fair I guess. 
I don't know why you would call this click bait at all. The first tutorial was interesting and informative. This one is much the same.
This isn't anything of quantum entanglement at all. It is a local simulation of quantum properties. Get this to work on two computers across the world, then come back and say it is real.
Sorry, I really don't understand. It's an emulation. It's for training and understanding qubits and how they operate using a python emulator. I really don't see the problem at all. The OP made a good post.
This looks interesting =). I will try to play around with it this week. It seems everything is written in Python? Pretty Cool.
In the astronomy world python is very much king. There's an open source python package now for analyzing gravitational wave mergers! The code is here: [https://github.com/gwastro/pycbc](https://github.com/gwastro/pycbc) There is also an associated release of their results as hdf files and some jupyter notebooks on how to read them. [https://github.com/gwastro/pycbc-inference-paper](https://github.com/gwastro/pycbc-inference-paper)
Looks the notebook goes through regenerating some of the figures which show the measured masses and spins of some of the LIGO detected binary black hole mergers. [https://github.com/gwastro/pycbc-inference-paper/blob/master/data\_release\_pycbc\_inference\_paper\_companion.ipynb](https://github.com/gwastro/pycbc-inference-paper/blob/master/data_release_pycbc_inference_paper_companion.ipynb)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [gwastro/pycbc-inference-paper/.../**data_release_pycbc_inference_paper_companion.ipynb** (master → 0bdb28b)](https://github.com/gwastro/pycbc-inference-paper/blob/0bdb28b009ea250f7a8e677b7ba431a22cc7d093/data_release_pycbc_inference_paper_companion.ipynb) ---- 
It looked like it for us as well two years ago. Then we set up our CI/CD systems properly, broke the task into manageable chunks/libraries/repositories and made a policy every refactor and change must be Python3. Things got sorted out pretty quick, because everyone _wanted_ to do it 
First you make a functional design document where you define your goals. From there on you start making a technical design document which tells the architecture on abstract level. That's a good start.
&gt; This tutorial walks through the steps to program a simple quantum computer to teleport a text message using quantum teleportation. No, it's shittily emulating properties of quantum entanglement without actually providing a meaningful emulation whatsoever. Understanding qubits is one thing, but not this utter lie.
Simple x^2 graph: import matplotlib.pyplot as plt plt.plot([1,2,3,4], [1,4,9,16], 'ro') Your problem: d = {1: 1, 2: 4, 3: 9, 4: 16} arr_x, arr_y = list(zip(*sorted(d.items()))) plt.plot(arr_x, arr_y, 'ro') d.items() returns a generator that generates (1, 1), (2, 4) sorted ensures that it's sorted, and the first item is x so that works out. `zip(*something)` is a cool way of transposing a matrix. in this case, it turns `[(1, 1), (2, 4)]` into `[(1, 2), (1, 4)]` ... but it generates it. I wrap it in list to expand that into a full list, and I unpacked it into `arr_x` and `arr_y` since I know it returns a list of two tuples of x values and y values. 
Thanks. That is what i needed.
no problem!
Or just start by writing tests that describe the functionality
Dude, your entire history is arguments. What's the deal? Give it a rest.
I agree that it probably wouldn't be feasible to integrate gevent or something like it into the language, but with the current situation, I pretty much have no reason to ever use asyncio over gevent.
out of loop, what happens in 2020?
I think you misunderstood everything the poster said. Also, neither gevent nor asyncio are low-level. Also, core PyPy still uses the GIL, and probably won't be getting rid of it anytime soon.
Another solution would be: x = list(d.keys()) y = list(d.values()) sorted() isn't needed in Python 3.7 since dict preserves the insertion order.
Every company I've worked at, tech and otherwise, develops new projects with Python 2.7 instead of Python 3. Including within the past 6 months. I'm not even sure there are any Python 3 codebases to speak of at those companies, whereas there are large numbers of Python 2.7 codebases. I don't think Python 2.7 will be going away anytime soon.
Because it greatly speeds up development time and extensibility. And so far, it seems to be succeeding in that area. VS Code launches quickly and runs smoothly on my &gt; 2014 Macbooks. I really don't even notice a difference between it and a native app like Sublime Text anymore.
With python 2.7 the time format only goes to 1/1/20 so when that day happens most of pythons programs running 2.7 will break unless they have been updated with a new time structure. It’s kind of like how 1/1/1970 crashes unix systems And also similar to how everyone though the world was going to end when it turned 1/1/2000 because some people thought the switch would break everything I’m not 100% sure about the 2000 one because I was only 7 months old
To me Python's biggest appeal is that it's approachable. A beginner might accomplish a lot in Python knowing just the basics. IMHO, Ruby does a better job in being approachable, in the sense the language is more flexible, but it lacks a lot of the libraries that make learning Python a better investment for people without a formal education in computing.
People are fine using them, but that doesn't mean it's not wasteful, and it doesn't mean we have to like it 
its the python equivalent of Y2K then, neat!
\&gt; using CSV or pickle files in hierarchies of directories based around different hyper-parameters, training sessions, etc, which works for the most part I suggest you take a look at HDF5.
It says 2020
Anybody still running Python 2 will apparently be cast down into the Pit of Despair.
My "entire history" isn't arguments. Don't selectively take pieces of my post history and treat it as the over arching picture.
Y2K was somewhat genuine as a lot of older systems ran on the date system DD/MM/YY or MM/DD/YY incase you live in a backwards country, so the problems arose well before the beginning of 2000 as some systems instead of going onto 00 as in 2000 they went to 1900 causing obvious issues as the computer was smart enough to know that 1900 is before 2000. Also a new problem needs to be dealt with for somtime in 2030 when i may be wrong but 32bit systems clock like resets or somthing its strange and actually a big issue google it and youll see.
It absolutely is, but calling it "Python" is a lie. That link does nothing but *prove* my point.
4-5 years ago, I finally got a green light to upgrade almost all of the python base to python 3. I failed to get the green light to upgrade several simple scripts on a few old servers. Eg: an ETL script that consolidates files in a single FTP server. The Python version on that FTP server is 2.4 (or 2.2?), not a mission critical server, not exposed to the internet, etc etc and work perfectly fine. The management can't accept why my team must spent 1-2 hours to upgrade 'that thing' but didn't give any new advantage to the business. Yes today we still have 2.2-2.6 Python in several production server. 
Yup, no angry arguing there.
There's plenty of arguments. There's also plenty of helpful comments, discussion, jokes, commentary, and more. To claim my "entire history" is arguments is like claiming 100% of my body is nothing but calcium. And I only debate when warranted, and I back my shit up and elaborate. If you have something *personal* with/against me, take it up with my middle finger that doesn't give a shit.
It depends. I have certain scripts that only run on 2.7 and I don't feel like going through to fix to make them work on 3.6. Most of my new shit is 3.6 though.
Perfect, this is exactly what I was failing to describe. Thanks!
I really, really hope this is a joke, because it is 100% wrong. Jan 1 2020 is the EOL of Python as set by the core dev team.
Use visual studio code with the vim extension. Have no complaints. 
https://www.reddit.com/r/python/comments/92zezn/_/e39qvvg?context=3 Businesses and educational institutions won't upgrade though, unfortunately.
poetry + pyenv is so nice
&gt;visual studio code with the vim extension :O never heard of this before 
ADS-B mandate.
Kind of the response I would expect. Please dude, relax your life. You'll be happier.
I am very relaxed. But I will not tolerate baseless accusations against me.
2020 is the beginning of the end of Python in our organisation - stuff will be progressively re-implemented in Visual Basic, simply because we don't have the Python dev resources to do otherwise.
Seriously dude
You could use **mxDateTime** lib to avoid this bug though, if you are not able to update to Python 3. But since most programs use the standard library DateTime, this will be a nightmare. A lot of IoT stuff that uses Python will break on this day. Make sure to check your smart fridge will be updated ;)
I dont personally use Windows, but I fancy VIM over a lot of full blown IDE's.
Actually, Python 2.7's own `datetime` handles these dates perfectly well: &gt;&gt;&gt; from datetime import datetime, timedelta &gt;&gt;&gt; datetime(2019, 12, 31) + timedelta(days=1) datetime.datetime(2020, 1, 1, 0, 0) The issue here is not technical in nature; Python 2.7's end-of-life is set for January 1st, 2020, which means no more further resources will be devoted to maintaining that code base, even if critical security vulnerabilities or severe bugs are discovered. (Although I'm sure that in reality, the Python community would figure out ways of patching such critical vulnerabilities, if they really warranted it.)
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Building web scrapers. Want to scrape several websites, like Twitter, Craigslist and Indeed. I’m sure there are APIs, but I can use the practice. 
On windows, I switch between 4k displays and have fiddly font issues with vim. My later projects are aided by the visualisations I can do by supporting ipythons display() command so I used mainly Spyder and Jupyter.
But you do have a crack team of Visual Basic programmers?!? 
he can't even follow something like [this](https://pythonprogramming.net/reading-csv-files-python-3/) and here you come along and tell about panda.....
I was unable to make sense of the following: -------------- No PYPY, but isn't the framework a small part of the whole app ? So you kinda need pypy ? ------------= It made sense to me if you replace pypy with pypi. 
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Functionally, the problem is that there are infinitely many integers that are not representable as floats, and thus also operations that are valid for integers but not floats (and vice-versa). I'm pragmatic enough to be glad that `float` is a subtype of Real, but IMO it should be an isolated branch and Rational (fractions.Fraction) -&gt; Integral (int) on the other branch.
Yes. Welcome to the enterprise.
Definitely the better answer. Always prioritize readability. Clear and readable 2 liner &gt; Slightly more complicated 1 liner 
And Python got self from Modula-3, which is even older.
&gt; The newspaper doesn't get to dictate what browser you use to view their PDFs Technically they do. Not saying any websites would actually do it but they could easily say something like "If you access this webpage using anything other than Internet Explorer 6 you subscription will be voided." in their terms of service or whatever. Of course that wouldn't make it illegal tho.
Like other users have suggested, Selenium +Chrome-Dev-Tool looks like the best combination. If you have not been able to solve your problem still, pm me. I can help you.
Ha. You pros who started on python 2 now kneel and plead to your new n00b overlords who started on python 3, and just learned about while statements. 
Yes because running your scripts through the 2to3 script takes massive amount of resources, more then rewriting in Visual Basic
I tried teaching myself Python 2 and a month later Python 3 came out and I was annoyed and gave up LOL.... Dunno why I'm in this sub tbh
To answer your question about `?R` - that's a so-called recursive group: https://www.regular-expressions.info/recurse.html here's some info. Python actually does implement this feature, so, in principle, your task is doable with regex (though it's a stretch to call it regex). I've to run to work now, but I might come back later and try offer you some way around your problem with regex.
Won't it be simpler to re-implement in Python 3?
2to3 doesn't work. It's widely admitted to be the wrong way to upgrade your code to python 3. Six and future are so much better. What does 2to3 even do? Replace print x with print(x) and put list around a few things (generally doing it wrong)? Just running python 3 directly will find most of that stuff for you. The only change in python 3 worth discussing is unicode and 2to3 does nothing to fix those problems.
&gt; I really, really hope this is a joke The name Python is based on Monty Python... it would be a disservice if you didn't joke about stuff.
It meant to be used as strating point. And it does chage __str__ to __bytes__ and __unicode__ to __str__. Also how can you give me an example of “wrong” lists? Usually, unless you have some half-assed codebaee 2to3 does the job 
You and your logic, of course it is less work to re-implement the code in a very different language than just fix existing. 
It changes something that was trying to represent text to something that now bytes. It's a similar type, but the intention is almost always lost. The typical pattern for doing range loops in python 2 will use range vs xrange or similarly keys()/iterkeys() and items()/iteritems() and values/itervalues() for dictionaries. 2to3 doesn't look ahead to see if data is modified invalidating iterators and instead just puts list around things. 99% of the time though, that list is unnecessary. 2to3 tries to make your code work the same, not work well. It assumes you wrote your unicode/iterators right in the first place, which was the whole reason python 3 changed things in the first place.
This sub predicts the future and the future is python XD
Mods, can we ban this shit already?
&gt; just fix existing code to work with Python 3 You are making it to sound easier than it actually is. My friend works on one big Linux distro company, and part of his job is to port 2 to 3. There is so much code, that the project already runs for several years, and is still not finished.
maybe but then it would be a toy with very little interop with existing asyncio libraries 
Well, I'm not saying you _can't_ do it with a regex (provided it has the right extensions, and it may well be that the library you're using does) - just that in general (in future?) a parser is a better tool when nesting is involved. Could be that [r/crabbone's comment](https://www.reddit.com/r/Python/comments/92y51a/python_regex_problem_trying_to_parse_nested/e39yziv/) can get you where you need to be now though... Good luck!
Except if my bottleneck was on network time I wouldn't be in this thread at all.
That's Python 2's official End-Of-Life date
Python 3 was only really worth learning a couple years after it came out
This is exactly what I'm using too
Hello. I usually work with images. I convert them to one big SQL file (one for train, one for test and one for validate) with columns: image ID, image (nd array) and other columns. How do I use it: I get list of all IDs, shuffle then, and execute SQL query to get needed image by ID. The database file is around hundred Gbytes. I found it very efficient during training.
I guess this silence answers "nothing"
I've written some stuff up, its at https://www.reddit.com/r/Python/comments/9326gt/apache_kafka_meets_protobuf_my_first_blog_post_on/
Porting to 3 is not that difficult. You can largely automate it and then update your tests by hand to see if everything still works then just patch as needed... Isn't Visual Basic basically dead already? Isn't it all about .Net now?
No. 99% of systems used Unix time so nothing ever happened. Even Microsoft didn't have that internal flaw. That's what people who didn't know anything said. A few dumb programmers did implement their own datetime libraries but nobody working on a critical system ever does. 
This is so wrong that if you believe it you probably shouldn't be on this sub. 
bookmarked.. will read from home..
Just build the prototype and don't worry about best practices until you're sure you won't toss it away.
Is it the same big linux distro company that promised to keep python 2 patched to at least 2024?
FYI I posted the question \[here\]([https://groups.google.com/forum/#!topic/sympy/X3h38SqQBCo](https://groups.google.com/forum/#!topic/sympy/X3h38SqQBCo)) 
The people selling extended Python support aren't obliged to make those updates open source. They aren't allowed (by trademark law) to distribute those updates *as Python* either. Even if you find an open source version to live ever-after, you'll have to change *something* at some point to move onto this extended support track. And if your project is so hard to port that you're not bothering, consider what your day's going to be like if and when the bomb drops and you're left with a runtime with a big security hole in the side of it? There definitely are *limited* deployment situations where it's not a priority to upgrade, but you're nowhere near able to just suggest people not worry about it.
While it is cool since it is not python related no one gives feedback but i think it is cool and you should post it on r/vscode 
[BOO!](https://github.com/naftaliharris/tauthon/)
FWIW the `list()` call isn't even necessary, unpacking works with any iterable so the result of `zip` can be unpacked just fine.
How to break up a module always gets me as well. Often it cut I try to keep similar functions in one file. For example all financial calculations one file, all crypto graphic stuff in another, outgoing API connection in a different file. 
Actually there's a book on webscraping with python. I'm going to read that first.
Not to be rude, but I get the impression you've not dealt with an old complex code-base... 8-) Enterprise code-bases are embarrassingly horrible - they've been through dozens of hands and the original devs are invariably long gone, there's rarely time to do it right, tests and documentation are out of date and inadequate (if they exist at all), and the dependencies are sprawling (eg: "SOAP library X works with datasource A, but fails on datasource B. Parser Y works with B and C, but fails on A and D. Parser Z works only on D"). I've been using Python for more than 20 years. I have code in the core of CPython, and I maintain open source projects, but most of my time is spent on commercial python work. I can assure you, naive conversion of python 2 code to python 3 results in subtle (and not so subtle) breakage - and in this context, you break it, you own it. All of it. As for Visual Basic - nope, sadly still very much alive, in the form of VB.NET.
seconded. a linear regression isn't a good predictive model for real-world values that depend on time. besides an overall trend, you have periodic trends (how the value fluctuates over different time scales - seasonally, weekly, monthly, yearly, etc.) and random fluctuations you have to account for. in a time series analysis, time series data is generally correlated with itself over different time lags (the AR of ARIMA is autoregression - i.e. self-regression), so the predictive power arises from how well past values align with present/future values. you have to sort of know what you are looking for and apply corrections to your data based on several statistics, and even then you may completely miss the mark. i believe the statsmodels library has an arima model component which pairs nicely with pandas. a less rigorous way to model a time series would be through a simple rolling mean or a weighted rolling mean scheme. 
Wish I had started with Python 3, so I wouldn't've seen a problem with it.
Do you really think Trio is just a toy? I think it is by far the best async event loop right now. Asyncio is so littered with problems and unfortunate design, it is a wonder there is even an ecosystem for it at all.
Well, if you don't have the resources of re-writing the whole code in Python 3, "working the same" instead of "well" is still better than "not working", I guess
Python is wonderful. Don't worry about the stupid 2-&gt;3 thing. It is just some small changes for you as a coder... As an early beginner you will have to use print("blah blah") instead of print "blah blah" and then a little bit later you will use range instead of xrange and input instead of raw_input. You will probably prefer working with unicode instead of ascii anyway and will not notice that difference in default so much, at least not until you are starting to get pretty used to Python. 
If Guido ever pulls off this kind of shit again I will abandon Python and convert all the scripts to Assembler! ;-)
Thank you, mr Picard
Oh, wow. Thanks. I will try that when I get home.
&gt;they could easily say something like [...] This would be British tory "make encryption illegal" level of ignorance.
/r/legaladvice
&gt; Of course that wouldn't make it illegal tho. Yes, that's what OP was asking. It might violate their TOS, but (at least in the USA, CA, and EU, terms of service are not remotely legally binding, and violating them are in no way illegal. At worst, it *might* be able to be used as a small amount of leverage in a civil suit, but even that is unlikely since clicking "ok" is not a signature.
Guess so. 
This isn't really web scraping tho. It's more using Chrome vs Firefox, except in this case Chrome is actually Selenium, or Beautiful Soup. OP isn't going to a website and scraping it, he's going to a website to download a specific file, which he is a paying customer to have download rights to do so.
Joke is one thing, making a joke that can seem reasonable but is a full lie is stupid.
404 man
Nice try, you ain't tricking me into believing that there are people out there who write Visual Basic for a living in 2018, and are actively employed. 
If i upgrade to a paid account , will it help ? I am too facing the same issue. 
I was mostly responding to your parenthetical question if you can load .csvs to Pandas, not the OP directly.
_Captain_ Picard!
Sorry
Sorry it was not working last time I don't know why. This is my first project.
As a dev who early on in his career was working in VB.NET and then moved away, I won't disagree that VB.NET is alive and well, but I've found the overlap between it and Python to be minimal. I would have expected to be C# you're saying it'll be moved to.
Ah; then fair enough. I was asking whether _OP_ could, not whether _I_ (or anyone) could. But that wasn't clear. 
I saw he wanted to do frequency counting and that’s easy to do in pandas, although there is no one way to do it. Looks like you included a good tutorial and I didn’t format my code so it was probably not helpful at all. 
On a related note, is there a fork of shedskin for py3? The official repo hasn't had a commit in a while https://github.com/shedskin/shedskin
So essentially python3 except strings suck
It amazes me too.
no
Visual studio Code is very good.
&gt;sorted() isn't needed in Python 3.7 since dict preserves the insertion order. That all depends on how the dict was generated, which may not be the case here. And even if it was, I'd say relying on insertion order being ascending is a pretty bad assumption to bake in to the solution - makes it really fragile if the dict generation process changes.
Shrug - it's what they've always used, nothing to do with good taste... at least it's not diabolical Excel macros (we have those too)... LOL
Guido won’t be pulling anything while on his BDFL permanent vacation ;)
there is a way to change theme into dark ?
Yes, a paid account should work fine -- you'd have direct access to the Internet, no proxy, so the bug in the Python bindings wouldn't affect you.
Absolutely. There are a ton of themes.
How you gonna code when you're high on crack, Rhonda?
It really isn’t that hard to start using python 3. I started on 2 and just realized that 3 was “correct” with how to represent strings in a modern day language. I just moved on with life after that point. All the stuff people complain about 3 really does make sense we you come to grips with the fact that that a string does not imply ASCII and bytes are just bytes until you subscribe meaning to them. Plus they fixed a lot of the broken stuff like list comprehensions. 
Do it you won't Also, if you didn't know, [that's a pretty safe bet.](https://mail.python.org/pipermail/python-committers/2018-July/005664.html)
You just _know_ the Enterprise runs Windows by how often they had to reboot, and how often they got locked out. I'm only surprised they never had to reinstall. Or did I miss the episode where they spent an hour searching for the CD key?
Thanks @Gnonpi for taking the time and reviewing this work. Regarding your question, no, it's not the same as pytest's `monkeypatch` fixture. I haven't used `monkeypatch` before, however, after a quick look, I find it to be more intuitive. What would you recommend, `monkeypatch` or `unittest.mock`?
That was ... sad :(
while what ?
&gt; So essentially python3 except strings suck Python3 except breaking backwards compatibility.
Yeah I had been using seaborn to do scatter plots with lmplot or regplot with fit_reg=false or ci=None if I didn't want the regression features. This sounds even better though! I look forward to playing with it!
I only debug and fix it, is not that hard... aaaaaand i only have 1 year and 6 months of Python and i am not even a coder. Network engineer. So your method is for me the best one yet.
This is my IDE of choice. Check out the python extensions and keyboard shortcuts. It's really nice.
VS code is great!
i suggest pycharm 
Where did you last left off? If you left off at mathematical part of it, I strongly advise to read **Introduction to statistical learning**. If you are more python side of the ML, you can check **Datacamp**. I have completed their courses last year when they were not that rich as today. 
that one is scary account with scary photos :D
As someone who was never able to learn programming languages from educational institutions, I think this is extremely bad. One of the worst things about learning Python in the beginning is all the conflicting information between versions. Since most of your research is done through google, you can constantly get fed incorrect information if you don't know how to narrow down your search, and in the beginning you usually aren't even aware that you need to narrow it down. 
LOL! Are you me but like 5 years ago? Because we had excel macros everywhere too and they were awful. Department head (DH) for something related to sales wanders by my cube. DH: hey my macro isn't working. Can you fix it please? Sure, let's ignore help desk and go straight over to me to try get help on a thing. Me: I don't think we made that. DH: no X smart person did before leaving. Me: Ok....well, we don't support software we didn't create. Department head: oh, I see. Next day I get a support ticket from my supervisor's supervisor saying that we're going to start supporting internal macros.... Me: **SIGH**
&gt; Python's best feature is the almost free FFI. Let me wrap the whole thing in a shell script and call it "a [very fast] Bash Web Framework/Server" ;-)
atom+hydrogen or sublime text work great as well :) 
statements
Django is dropping python 2 support. So is numpy. Both huge and quite complex code bases. And those are just two, of many. There might be millions of dollars in contracts to maintain python 2.7 support, but it also might cost about the same the pay a team to backport features and bug fixes to python 2 versions of a couple hundred libraries. Perhaps selling python 2 to 3 migration consulting would be cheaper both to the seller and to the buyer.
If it supported async/await syntax through goroutines, that would be really cool
Wrote a simple tutorial that explains how to [create charts using matplotlib](https://datatofish.com/scatter-line-bar-charts-using-matplotlib/).
Building a image is a greate idea, it worked wll in many cases . I considered docker image before I decided compile python. But containers has its limitness in my situation. For example, we need to submit pyspark application. It can't be done before spark 2.3, as our spark version is spark 2.2. And container haven't be our main techniques.
Sublime is great and just works and fast. Python from what I have worked on has never needed anything too fancy that you can't just plugin on sublime
VB? Just go all the way bro and embrace COBOL
Crap phone-full-screen unexitable registration popup mafia.
Not until 2020.... biatch. /s
https://github.com/pypa/pip/issues/5599 official issue on your problem with solutions.
&gt;Web scraping, web harvesting, or web data extraction is data scraping used for extracting data from websites. Web scraping software may access the World Wide Web directly using the Hypertext Transfer Protocol, or through a web browser. While web scraping can be done manually by a software user, the term typically refers to automated processes implemented using a bot or web crawler. It is a form of copying, in which specific data is gathered and copied from the web, typically into a central local database or spreadsheet, for later retrieval or analysis. [source](https://en.wikipedia.org/wiki/Web_scraping) Sounds like web scraping to me.
There's lots of good answers on this thread already, but one thing that no one has mentioned is writing to multiple .db files. Without knowing more about your problem, it's hard to say if this is a possible fit, but it's an option.
Author should burn in hell with his crappy site together. Don't waste your time following the link.
10 tricks to get people to never click on anything your post ever again!
So when a package which provides an executable like pip is installed, it generates a platform native binary, which calls a script to call the main entry point for the program. Pip used to have a public facing `main` module. This was made internal in pip 10. So heres the problem. You executed `pip install --upgrade pip`. This will cause the old pip 8 script to have an open handle (as it is being used to upgrade pip...), which means it cannot be removed so it cannot update itself. Catch-22, right? The correct way to upgrade pip is to execute `python -m pip install...`, which will only open a handle to the python executable, so that the interpreter instance will be able to delete the entry point and do the full upgrade. Anyway, none of that background really helps you now except to say: editing the script is likely the easiest thing to do. You could try to do `python -m pip uninstall pip` then use `get-pip.py`, but that could very well break things even more. It seems you are on Linux, so an additional option is to uninstall pip then re-install it via your package manager.
Oh really? Thanks oh great arbiter of all that is humorous in the world. Please enlighten us with your almighty words of spendor and grandeur so that we may chuckle once more.
Good documentation and enabling dependency injection and/or subclassing to override behavior will also reduce the need to reverse engineer it.
Might trick me once, I won't let you trick me twice . 
while True:
This could be a solution but I would rather work with excel or text files and then write a script to concatenate the results It will not work for a recurring script which needs the results of the previous runs for the next run but it is something that I might try 
I'm not arguing it's beneficial to them, or anyone, don't get me wrong. I'm just stating a fact that for example Red Hat is under obligation to support python 2 shipped with its OS to at least 2024 (maybe longer, not sure what the plan is for RHEL 7). I wouldn't be surprised if they are not the only one that shipped an LTS with python 2 that will be supported longer than PSF's python 2.
I worked at a 500+ person company, publically traded, that still maintains its flagship product in Python 2.4. The realities of business do not match the expectations of most developers.
2to3 just works in a lot of cases. The one case that didn't work so well for me was attempting to convert the tftpy module over to python 3. Unittests failed until I made a few manual edits because it used a ton of packing and conversions to and from the bytes object. But all in all, a very smooth process that took me an hour or two. All of the fear of upgrading is so overblown. It's not that difficult unless you're sitting on millions of lines of legacy code. And if that's the case, it's only a problem because you put it off for a decade.
Dude, I bet they make a decent salary, too. You'd be surprised how much a company is willing to pay somebody to just "maintain" their legacy software in effectively dead languages.
Sounds like a poorly run organization from a tech standpoint if this is really the solution.
If you're running Python 2 and missing out on all the Python 3 goodies, aren't you already \*IN\* the Pit of Despair?
and these kind of companies are exactly the reason why we can't have nice things. Always stuck in a limbo of choosing between what to learn. I wouldn't really blame them because their systems are running, they are making money and everyone is happy. No one cares about spending extra cash to keep it up to date.
Couldn't agree any more, I second that.
Do you know that reads are non-blocking, btw? You can have as many threads as you want reading from a single db, it's only the writes that cause problems.
`So you kinda need pypi` made sense to you ?
I don't understand how or why this works.
Cash, opportunity cost (literally shutting down feature production of any significance for 3-12 months can be a realistic cost), and the sheer risk factor of what might break, in a way that can burn money and customers. Nobody cares how cool python 3 is when you've just caused a massive outage and lost data for your biggest customer because your test harnesses didnt catch all the production nonsense that factors in.
stuff like this slowly brings yhe quality of content down to generic subreddits.. ah well 
Also, the years of maintainence and proof testing went into the legacy platform. You can never get that level stability by a product merely developed in a couple of months. But one thing I'd like to highlight, no one will ever "shut down" for the time they are developing it on a newer platform. I believe they will always develop and test it in parallel by pushing small chunks of it in production, unless its fully baked and ready to be used. 
Great answer! I would have left off the "but please don't" part, if you're programming alone feel free to call it anything you like. (Calling it "Bob" amuses me for some reason.)
You certainly seek to do it that way, yeah. The analysis paralysis of breaking that down and committing to the path can lead to months and months talking about it which is functionally equivalent to not doing it.
That is why we stick to Python 2.4. 
Pretty sure VisualAlgo and that big o thing from that floridia university are good
Can I have a link to the University one you’re referring to?
Cant find it but its like visualalgo for USF also http://bigocheatsheet.com
Just to clarify, it's almost certainly true that OP won't have any problems if he's just doing it for himself, but it *is* still potentially in violation of their terms of service. If someone noticed and cared, and the terms of service forbid scraping they could void his subscription, and potentially even sue for damages. None of that is likely to happen because no one will notice, if anyone does notice, he won't care, and there aren't likely to be real damages worth suing for, but it's still could *technically* be against the terms of service.
Great article 
The discussion can be interesting (see the original post of this image), but there are other, better ways to start such discussion. With no restrictions in place people will start to post content from ProgrammingHumor or some other horrid place.
I'm willing to bet some money that red hat's support covers python only, and no libs. As such, it's not that useful to any real world applications. I mean, great, we get security and bug fixes for python, but don't get them for Django. Which one is more likely to compromise my client's data? That's sort of my point. Support to the interpreter + stdlib alone is not that useful. Support to major libs might be too expensive. So the market you spoke of might not be **that** big.
Again, other than some parentheses on print, 2to3 almost always makes the wrong choice. If you have a str, just leave it as str. If you hsve range, leave it as range. For the most part, it will still work. Make the user throw flags to get more.
Sounds very promising. I'm excited to try this out.
I see what you mean. And yeah, that's a good point.
That’s why Guido’s stepping down, he has to prepare for the day of reckoning, when he will personally cast them into the pit. 
Good point. I was going to mention that he should be very careful not to let his script run wild and DOS the server. 
Only if you need those goodies.
Thanks! Yes, everything is written in python. If you find any bugs/crashes, it would be great if you could tell me :) thanks!
Screw that; do it I’m Algol. 
ouch, that's a mistake for future employees.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
If you count VB*A* then there are quite a few of us sad folk. Not the same I know. It’s doubly sad because I’m having a bitch of a time transitioning into ‘actual’ dev work (read c#/java) because 1) nobody that doesn’t use vba knows what it is, 2) it’s not *real, professional* experience, or 3) all I do is hit the macro recorder. 
"Automate the boring stuff" is probably the most practical tutorial out there. http://automatetheboringstuff.com/
If you're sure you're the only one who is ever going to read it, go for it. The moment someone else has to work out what's going on, you're making it much harder for everyone.
Thanks for the quick response, I'll look into it!
r/learnpython
Should just be an auto mod reply. 
Things I've written so far: Home: - podcast downloader - Packtpub.com webscraper for free books - rato calculator for splitting bills based on income - weather alerts Dev: - Django stuffs DevOps: - saltstack: AWS Elastic File System state (wip) - saltstack: selinux modules
True, I didn't though about it. I'm sorry for posting this on the wrong sub. 
IRCbot, also i have a script that uses psutil that gets cpu usage, ram usage, the current time and date, will implement disk usage and some more stuff later. It just prints all the stuff and i3s status_command function calls in in a while loop every second
No worries. It happens. 
agreed, thata why some subreddits go above and beyond to uphold to some standars that are unreasonably strict
Use a rainbow table. https://en.m.wikipedia.org/wiki/Rainbow_table
Great, so I've got less than 2 years to read the book I bought and learn how to use python 2.x 😩
Look up thenewboston on YouTube, corey Shaffer (don't if I spelled it right) also has some good tutorials, also use pycharm instead of launching it from cmd. sentdex has good tutorials but they get quite complicated on episode 45 perhaps. Hope this will help. 😊
&gt;5 Reasons to Learn Python – A Deep Dive into Python Career Opportunities! I wouldn't call anything ~500 words a "deep dive"
I don't know your friend's project, but years doesn't sound quite right, unless his job is to convert all packages on PyPi by himself. Anyway I was talking about fixing existing code vs wiring from scratch in another language. BTW: the biggest issue with 2 to 3 conversation is Unicode and that Python 2 makes it hard to use it correctly. One can fix those issues with adding types and using mypy to find issues. The remaining changes are mostly mechanical.
Install this thing called the Internet on your computer and check on there.
I also find `monkeypatch` more intuitive. I started using it after spending too much time trying to solve a problem with `mock` and `flask` that was easily solved with monkeypatch. I think that if you commit to use pytest in your project, it's better to use monkeypatch everywhere.
I'm not an expert but I'm pretty sure you can't install the internet on a computer. If you're referring to a web browser and use a search engine to find what I'm looking for, that's what I did and so far I've found plenty of tutorials on how to code in python but not much on how to use python like import libraries or change directory without opening a new cmd window.
I haven’t used python that much but I’m somewhat familiar, what’s the main difference between 2 and 3?
Thank you and it sure did!
Personally, I didn't know about Pyton 2's EOL until I saw this comic. Thanks OP!
There’s some great resources out there, which I won’t try to replicate. I’ll just explain what’s happening syntactically. Functions are objects, so you can build functions that take functions as arguments and return modified arguments. Modifying a function is a bit clunky though, so the @ syntax was created as a shortcut. @decorator def func() pass Is equivalent to def func() pass processed_func = decorator(func) func = processed_func Try replacing decorator based code in Django with the above and see if it works. 
it also handles division, and turns `except Exception, e`into `except Exception as e`. I've forgotten most of the differences between 2 and 3 anyways. Aside from print, divisions, exceptions, there's not much differences between the two anyways.
[removed]
&gt; full lie That was the hint that its a joke. April fool jokes often work like that. See Gmail Paper or many other such jokes. For future, if someone is telling a blatant and ludicrous lie, and is not Trump, you can assume that they are joking (sarcasm also works like that)... unless they explicitly say that its not a joke, or you see very good reason to believe that they are being serious.
I've got your back: from flask import Flask, views app = Flask(__name__) class MonteCarloView(views.MethodView): from random import random from statistics import mean @staticmethod def monte_carlo_result(): total = 0 for i, r in enumerate(iter(random, None), 1): total += r if total &gt;= 1.0: return i def get(*args, **kwargs): return self.monte_carlo_result() def post/put/patch/delete(...): return "I think this is going a bit too far..." 
Oh cool, are you by chance using a graph DB for that? Seems like an obvious match, and I'm curious since I'm planning to play around with them myself.
r/learnpython 
How would you build a classifier that would create an auto reply? What kinds of flags would you add in to make sure someone looking for a tutorial gets a auto response, but someone sharing a tutorial doesn't? I'm working on u/pythonHelperBot and it should comment here in between 35 to 50 minutes from now, but I'd love to get insight on how you'd trigger an automod reply 
Decorators are [closures](https://kids.kiddle.co/Closure_\(computer_science\)). The simplest decorator will build a function within another function and then return the function, not its result. So: def decorator(func_to_decorate): def func_wrapper(*args, **kwds): nonlocal func_to_decorate result = func_to_decorate(*args, **kwds) return result return func_wrapper ... @decorate def some_decorated_func(name): print(f'Hello, {name}') some_decorated_func('GTHell') This is equivalent to chaining... some_decorated_func = decorator(some_original_func) # some_decorated_func == func_wrapper 
I know that Bed Bath and Beyond was using Visual Basic as its internal development language as of 2005, but they intended to switch to VB.NET.
Decorators change the function. Consider: &gt;&gt;&gt;def add(a,b): return a+b &gt;&gt;&gt;add(2,2) 4 &gt;&gt;&gt;def deco(func): def to_pass(): print "Sum of func:" func() return to_pass &gt;&gt;&gt; newfunc = deco(add) &gt;&gt;&gt; newfunc(2,2) Sum of func: 4 &gt;&gt;&gt; add = newfunc &gt;&gt;&gt; add(2,2) Sum of func: 4 Is the same as: &gt;&gt;&gt;def deco(func): def to_pass(): print "Sum of func:" func() return to_pass &gt;&gt;&gt;@deco &gt;&gt;&gt;def add(a,b): return a+b &gt;&gt;&gt; add(2,2) Sum of func: 4 Also, I don't want to sound rude but please direct all Python related questions to /r/learnpython -- It's in the sidebar.
We included actual code snippets for us to try out custom back-testers as well as sample strategy implementation.
I did. It still didn't work. I thought it would be fun to play with it but since it is not Mac compatible, I won't. You might want to mention that your tutorial only works on Linux. 
I definitely don’t see any foolproof way to do it. Obviously the simplest is keywords. Best way to do that would be to harvest word counts from all threads like this and see which are use the most. Then classify based on the actual content of the post. Similar to that AutoTLDR bot. It is an interesting problem for sure. I’d love to see what your solution is once it’s up and running. 
In my opinion, an intuitive place to start is to think about the effort of timing the execution of a function. We can clearly do that a number of different ways, but one way is using decorators. Imagine just prior to executing the function, we start a clock or timer, and furthermore, that after execution is done, we stop the clock or timer and compute the difference. If I wish to do this for all functions in my code, I should be able to reuse the logic with the timer I described above, rather than replicating it all over my functions. Decorators allow me to "wrap" or "decorate" the execution of any given function with the additional timer logic, given that I have defined the decorator code in one place. You can see [this short blog post](https://medium.com/pythonhive/python-decorator-to-measure-the-execution-time-of-methods-fa04cb6bb36d) for details on this use of decorators. There are of course additional use-cases of decorators. I think the timing example is helpful in that it illustrates a case where I would like to add (simple) code execution before and after several functions, each potentially very different in nature. The choice of word, "decorator", is easier to understand then. Then Python uses the syntactic sugar to encode this, which at least for me was initially very confusing when reading code, but once you understand the concept, it becomes convenient.
Hi everyone! I'm a software dev at Plotly -- I worked on the Ocean Optics app [here](https://www.dashdaq.io/control-an-ocean-optics-spectrometer-in-python). Feel free to ask me any questions you have! :) 
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
It shocks me the sheer reliance upon Python 2 and the burden of updating to Python 3, I guess Python is completely rejecting the idea of Python 4 until every one is updated to Python 3.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
All hail data classes!!!
There a quite a lot, for starting print is now a function. So you use print(variable) instead of print variable. Also in 3.6 they added f strings, which is a nice new way to format your strings. Where we use to use "this is a {}".format(string). We now can do f"this is a {string}". So that is also nice !!!. I believe in 3.7 they added dataclasses which are a nice way to automate boilerplate code for classes which store multiple properties. This is just some of the changes I know of.
Why would you want to put them on pypi? If you want to run a specific pypi server you can do so on your own network. Pypi will most likely reject your packages if they don't meet their specifications. Here is an an idea of what they will accept: https://pypi.org/help/#packages
Hello! I'm a bot! I see someone has already suggested going to r/learnpython, a sub geared towards questions and learning more about python. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
[From a few years ago, an explanation people seemed to like](https://www.reddit.com/r/Python/comments/2lrhp5/could_someone_give_me_an_eli5_for_decorators/clxgkce/).
https://gist.github.com/Zearin/2f40b7b9cfc51132851a
It's just a function that wraps another function.
Regarding division, that's incredibly easy to fix thanks to for loops not accepting floats. Also, most people have been bit by the `1/2` bug, so they started doing `1./x` or `float(x)/y to compensate. That makes it very easy to understand the intention. In 12 years of Python 2.x, I think I used `except Exception, e` only a handful of times, so no biggie. Also, it's a syntax error, so it's easy to catch. 2to3 is a suggestion, but you still have to look at the the results. You need to understand what changed and why regardless. Running your program a few times, with some greps will find most things. It's been ~10 years since Python 3.x came out. For large codebases, many people have snuck some 3.x syntax in there already regardless of company policy, so things like division, print, exceptions, but generally not unicode.
I don’t see why your example wouldn’t work perfectly well with a traditional RDBS—I use one for storing our ML-related data. For your particular example, I’d use three tables: TrainingInstance: - TrainingInstanceId - ModelId — FK to Model table - CreatedDateTime - (Other metadata columns) TrainingInstanceParameter - TrainingInstanceParameterId - TrainingInstanceId - ParameterCode — FK to Parameter table TrainingInstanceParameterValue - TrainingInstanceParameterId - ParameterDateTime - ParameterValue Obviously you’d have to adapt this to your needs, and it depends how much data you’re looking to store, but it’ll be fine up to the hundreds of gigabytes. If you take the DB approach, I highly recommend using sqlalchemy to interface between Python and the DB. We even store model instances in the DB, using `joblib` and `BytesIO` to convert the models to `LargeBinary` columns in sqlalchemy.
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I didnt do that much, I went through youtube videos of Andrew Ng, did some statistics, read 1 book "Hands on Scikit learn and tensorflow" practiced some examples. Actually I learned from many resources, so its hard to have all of them back Btw thanks for your guidance,
I think I'm going to end up using something similar, but trained on stack overflow's data first. Right now the bot uses a basic classifier that checks if the post is using a key phrase or not. If it is, it replies. If not it waits to see if the post is performing poorly enough after 2 hours, and if the post is asking a question. If those conditions are met, the bot decides to comment. It's a cheap solution, and it'd be nicer if the bot was allowed to comment earlier, but while I'm developing it I want to avoid spamming. This at least keeps the false positive rate low (at the cost of false negatives) until I get a better classifier. 
Python decorators are a powerful concept that allow you to "wrap" a function with another function. The idea of a decorator is to abstract away something that you want a function or class to do, besides its normal responsibility. [Here](https://timber.io/blog/decorators-in-python/) is a blog post we wrote that shows you how you can use them.
That was a really clear and concise explanation. Thank
One big breaking change in 3 is that strings are unicode by default. So instead of having `"byte string"` `u"unicöde string"`, you have `b"byte string"` `"unicöde string"`.
Interesting solution. I like the idea of commenting anyway on poorly performing posts. More likely to hit that way. Although, you may also comment incorrectly on some. I’d assume the former is more likely though. 
Hells yeah, let’s kick it up a notch to Malbolge
Oooooh boy! I’m ready!
This isn't April 1st.
Guy asked a question, he should get an actual answer.
Oh thank you oh great mystic being of what should and shouldn't be done. What have we done without you for all this time?
&gt; This isn't April 1st. Thanks Captain Obvious. I didn't say "Only April fools jokes work like that". I also added that sarcasm jokes work like that. Additionally KenM jokes are in the same boat. You might find them hilarious... but not with your current attitude.
Not sure why you're getting downvoted. Visual Studio Code has made leaps and bounds and has improved vastly since a year ago. I really like it, I've ditched Atom + plugins in the span of a week.
Me too.
Marginally better for code verification but in no way obscuficates your source. Running python -mpdb mycode.pyce will let you print out the source of mycode.py
The Tauthon project might continue to support 2.7 beyond the official expiration date. https://github.com/naftaliharris/tauthon
Stylistically, I would suggest having all of your imports at the top of your script instead of adding them in as you need them. You could check out PEP8 guidelines for more information about how your code should look. The script is maybe a little convoluted for what you're trying to do. For example, this part: def toLose(coinTosses): exponent = 0 # 2^0 equals 1. Our first lose. Whenever we #double it,it will be 2^1, after that 2^2 and so on. This is #why it is named as exponent totalLose= 0 for i in coinTosses: totalLose += power(2, exponent) if(i == 'H'): exponent += 1 return totalLose You are iterating through the entire string. Python has a built-in `count` method. You could instead say exponent = coinTosses.count('H') Then to compute totalLose: for i in range(exponent): totalLose += power(2, exponent) Unlike some other languages (I see that you're familiar with C), you don't need to initialize variables in Python. Instead of X, Y = list(zip(*sorted(probability.items()))) You can directly do xvals = k for key in probability yvals = probability[x] for x in xvals PLT.plot(xvals, yvals) You can look more into list comprehensions, too. I think they will help. 
Hi, why is this almost $2000? I'm guessing it's a hyper-specialised use-case with few users (probably universities by looking at it). I'm guessing there's nothing of interest here to general users?
Thanks for your question! :) You’re correct; this is a component suite made especially with research labs in mind.
Great, thanks. The UI design is particularly clean and pleasant to look at. How do you implement a proprietary software license for a python package?
KenM jokes are funny :/
The requirement that the post must contain a sentence with a question helps prevent most of the incorrect comments thankfully. Though any future speculative post ("Where will python be in the next 5 years?") destroys the bot. 
You okay there buddy? I just wanted to make sure both the original asker and the answerer werent confused.
Don't be like me. Don't waste your click. Your click matters.
We're glad you appreciate the UI. Companies usually have their legal teams write their own proprietary software license which can be included with the software. They’re also often called “end user license agreements.”
Glad to hear. Maybe you have noticed that many of his jokes are based on blatant lies... "Potato is Latin for King of Peanuts" "Church group reading scriptures to monkeys" "Grandson used to eat snausages" "There is no gravity in space" "You can replace water with juice during droughts" http://www.collegehumor.com/post/7040984/16-times-ken-m-solidified-himself-as-king-of-the-internet-trolls 
No problem, I would have appreciated it back when I was doing my physics research :). Sorry, I wasn't clear with my question. How do you provide a python package and prevent non-licensed users using it? Presumably you provide the source code for users to play around with so there's nothing stopping a user copying the modules for others (probably quite a large incentive to do that for such expensive software). Does it 'call home' to check credentials every time you import it for example? Or whenever you make a call to a module function / class? I suppose I'm really asking about how DRM works with python packages.
That's pretty nice, do you interpret the code or do you exec/eval the code?
Excellent, thank you! Yes, my implementation won't be huge or production-grade or anything, so I think a normal RDB setup wouldn't see any issues related to size. And yeah, I was definitely planning on using SQLAlchemy to interface everything, which I figured would make the whole thing a little easier to interact with anyways. I was considering a way to store the model in the database, but figured that wasn't feasible. So hearing that you've done so is interesting, to say the least. In terms of speed, do you see any big issues with this approach? Ideally, I'd write data to the table during every iteration, but I feel that could really bog things down. Do you update the table in batches? Or at the end of a session? Or something else? Looking at numbers, a complete run of the training for the example I gave would have a little less than 2 millions iterations in a given training session. Ideally, every iteration would store data. Would that mean that the TrainingInstanceParameterValue would have (2 mil) x (number of instances) rows in it? That seems like a lot, even for an RDB. Am I understanding your setup correctly? Originally, I was thinking about splitting up the data into different databases/tables, which seems counter to how I would normally use an RDB. Basically having one master database that contains metadata on every instance, and each instance getting there own DB/table where I'd fill in the resulting values. Does something like that make sense?
probably something on their end
Great! I'll learn about it and update this project appropriately. Thanks!
There are a number of ways that you can implement DRM for a Python package (such as the strategies you mentioned). DRM is never perfect even in highly evolved products such as LabVIEW and MATLAB. While we’ll continue to invest in sensible DRM strategies on the engineering side, the website is clear about the product’s commercial nature, so individuals or companies who don’t respect this would obviously be taking a legal risk. This is also a way for companies who enjoy our open-source products to work more closely with the company and support our work. I hope that answered your question! 
I'm a beginner in python. Took some classes and know the basics, and I made a metronome! It was a great way to put all my knowledge about functions, operators, and modules to use :)
i think in five years we will have something like python 3.9.9.9.2 because quite frankly i don't think there's going to be something like python 4 in the near future it wouldn't be a good think for the language to break backwards-compatibility _again_.
It's a function (a callable, really) that takes a function (or method or class) and returns a different function (or method or class). When that function is used with the @ syntax before a function or method, the decorator is invoked and replaces the original function or method. Why would you want to do such thing? Separation of concerns. For example, you could have a decorator to log the messages passed to the original function and the value returned, or a decorator to check for permissions, or to memoize the results, or to profile the time spend in that function. With decorators, you write that functionality once, and you don't need to repeat that code in every decorated function.
Firstly, this probably belongs in the learnpython subreddit. What have you tried so far? Openpyxl is a great library for this. [Here](https://github.com/timbledum/tmscraper/blob/master/tmexcel.py) is a solution that I've scraped together for this kind of thing. The sheet.append() method is really nice.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [timbledum/tmscraper/.../**tmexcel.py** (master → 99e740c)](https://github.com/timbledum/tmscraper/blob/99e740cc6cf805df8a3f9a5e003b9c1eb76605c5/tmexcel.py) ---- 
at my company, apparently anybody who has a copy of Office installed might get pressed into service as a VBA developer, sort of like jury duty. "it's Jenkins's turn to update that ETL function today!"
`concurrency.futures` is also a big thing. The PY2 backport has a semi-broken ProcessPoolWorker to boot, so for certain workloads (i.e. advanced python scheduler or celery) it can be painful not being able to manage per-core workers if you're trying to avoid GIL in an in-process batch work management system)).
the real problem is that when you wrangle unicode properly in PY2 (keep it as bytes, then use `codecs` when needed for UI or textual operations), it becomes a pain to port it over to 3 if you've been using `unicode.encode` or `unicode.decode` syntactic sugar at all.
in python 2.6+ you're supposed to have been using `as e` anyway. If there was any "new" code catching exceptions since like 2014 or so, you should have been using `as e`.
it's more alive in the form of Office macros that float around all over the office. "Ooh I need a data input menu with validation in Excel" -&gt; VBA. "We didn't know you could install postgresql without admin rights so we spun up this Access DB to do a bunch of stuff" -&gt; VBA
I wish I was still programming, because dataclasses seem awesome. 
Just dump it to a csv and open it in excel
Via summoning the zen of python, you are pitching on the wrong grass ;)
Super cool!
data\_returned = df stuff data\_returned.to\_csv(output\_filename, index=False) Simple way if you want to just throw it in a csv. 
You probably are meaning to post this in the learn python sub. 
1) I am writing a multi-agent system simulator of a self configuring wireless network. The final goal is to compare different strategies and agent architectures in order to find the most energy efficient and robust configuration. Once it works I’ll bring it to ESP8266 modules using micro python. 2) another simulator of wi-fi nodes with a custom protocol for efficient communication between drones
Opened this thread to laugh at 2.7 users. Left wondering how I never discovered f-strings before! Who is the noob now? Me.
No I did not know but my scripts are writing more than they read. 
Both in a way. The code is interpreted by JavaScript which turns it into actions that are executed in a sandbox without access to the context of the site itself.
Don't even think about trying to escape.
Print as a function was introduced in 2.6. Division was introduced in Python 2.2. None of this is particularly new. That doesn't fix unicode (unicode_literals doesn't fix unicode at all in Python 2), but nothing breaks that worked before other than binary file IO. Thankfully, that's pretty rare. Unicode though, is the only major difference in Python 3. Everything else is noise.
There is no intention to stop when reached full Python 2 support. The missing parts will be needed to Python 3 support too. On the roadmap, Python 2 is just planed _before_ Python 3. For exemple, `import sockets` is still missing and will be needed for Python 3 too. **(disclaimer: I am a member of grumpyhome)**
Versioning doesn't work like that ^^ 3.7 3.8 3.8 3.9 3.10 3.11 3.12
Decorators do things to a function's parameters, and/or return value(s). If you have lots of functions that need the same thing done to them, decorators are good.
Run this code and observe how similar the output is in some cases. #!python from pprint import pprint def decorate(func): def decorated(*args, **kwargs) : print("Calling function {0} -- params:".format(func.__name__)) print("-- args:") pprint(args) print("-- kwargs:") pprint(kwargs) func(*args, **kwargs) print("Function {0} returned.".format(func.__name__)) return decorated def greet(name, var="val"): print("Ciao, " + str(name)) @decorate def greet2(name, var="val"): print("Hello, " + str(name)) greet3 = decorate(greet) greet("znpy", var="somevalue") print("----------") greet2("znpy", var="somevalye") print("----------") greet3("znpy", var="somevalue") Note in particular that there is little difference between writing greet3 = decorate(greet) and using @decorate (that is, doing the greet3 = decorate(greet) on the fly). I mean: it's all a shorthand.
I am actually trying to make `grumpy -m pip` work before trying to support async/await ;) But yes, it will be really cool.
Have you found a strategy that performs better than random guessing?
I have never actually seen those ones, but they're funny. Lies are not funny when answering a legitimate question on a forum where the expectation is a legitimate answer, before the legitimate answer was provided.
it really depends on what you're using python for. I use the builtin abstract syntax tree a lot for code generation; so that code requires patching as well as I mentioned above, a lot of concurrency and Futures. The new async implementation is really nice. I have a particular use case of process pool workers that is broken in the `futures` backport which is my main driver for switching to PY 3. Also, it's possible people are using old-style classes if the majority of their code was from 2.4. I never really got the unicode issue, since all of my actual code doesn't use non-ascii literals, and everything else I actually handle as bytes and use `codecs` where needed. Now, if people used syntactic sugar like `unicode(bytes, codec)` or `str.encode()` then yes, there will probably be issues. 
We just upgraded to python 3 throughout all of our production systems (quite a few different repos) and it took waaaaay longer than we were anticipating. So many runtime issues related to strings and bytes. Just beware if you are thinking of doing the same thing...
&lt;3
&gt;In 2014, we changed the bylaws to make the PSF an open membership organization, so that everyone who uses and supports Python can join. 
Congrats on wasted money pal! /s (but sorta not that much /s you should bump your literature too!)
Gosh, I hope it didn't come across as me promoting this as a style.
I understand, believe me! I taught myself Python on the fly at a tech company. Things to know: Redis is, in fact, in-memory, but part of the configuration is regular dumps to permanent storage, including on server restarts. It’s a highly performant option for caching data. I would recommend making use of it! The Python redis client is very intuitive and it feels very much like working with a native Python dictionary. Any task which accesses an external service should be wrapped in *some sort* of try/except clause. Your script should always complete (within reason). If there are certain exceptions which you see occurring frequently, you should try to catch and log them rather than allowing your script to break in the middle of its work. Why do you need writes immediately? Are there other consumers relying on up-to-the-second data that you need to refresh, or are you worried about losing everything if your script crashes? You should work to write your script in a way that you trust its execution. If you have a way to share what you’ve written, I’ll be happy to help you derive a solution for your problem!
Imagine a function/class (this is the decorator) It takes a single argument, that argument being another function/class. It returns something else, usually, yet another function/an object of decorator's type if the decorator is a class, which does *something* before or after or both each time the original function/class argument is called/instantiated. Now just know that the "@" symbol, when used before a function/class, tells Python to call it with the next immediately defined function/class. @decorator def funcname(signature): # implementation Is fundamentally equivalent to def funcname(signature): # implementation funcname = decorator(funcname)
1 listy blogspam article for more annoying blogspam
Huh. Is there any benefit / drawback to joining then or is it just a fun thing to tell people?
Numpy (and libraries that follow its conventions) implement `__array_unfunc__` which allows the library to override the output. An ndarray will usually be created as an intermediate, and then the library that is wrapping numpy (as is usually the case) will clone the input object, adjust library related attributes on it, and set its attribute backed by the ndarray to the output.
Based on the code, it seems like it's all "logic and algorithms" all the way down. As in either no, or too complicated and not worth it to publish. There's a reason people don't just download trading bots and have them make millions.
f strings are beautiful:) I use them quite a lot !!! They look a lot nicer and more readable in my mind.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lcfp] [Can you explain what decorator is like I’m 5?](https://www.reddit.com/r/LCfP/comments/9399hv/can_you_explain_what_decorator_is_like_im_5/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
It has... issues, but I'm not going to force a code review on you unless you want me to.
PEP 572 - The Perlification of Python
Kind of? I can tell you how I used one in a small project. Basically, the idea is that I had a series of functions that did various things to a SQLite DB. Because a few things could be touching the DB at once, I had to put in the effort to close the thing before anyone else tried to use it. So I had a bunch of functions of the form: def zazzle(kerjigger): open_db_if_free() # actual function code here close_db() Instead of putting the open/close stuff in *every* function, I made a decorator that worked like this: @DB_touching def zazzle(kerjigger): # actual function code here 
The most visible benefit of being a member of the PSF is in voting. There are yearly elections for the directors, and occasional changes to the bylaws which also require a vote.
Yes I needed the writes because I was afraid of losing data You have to keep in mind that is is slow because the execution is serialized. Waiting till the last minute to write the data could be fatal. It runs on my laptop..sometimes I need to be able to stop the script and to resume next day . Next day I run a query and I see what hosts have been scanned and if host not in scanned: do something Yes I am using try/except but I have some older code where I did not have that approach and I need to revisit it... Changing the DB will require me to change a module that I wrote so I can hide the complicated sqlite calls that I was fighting with 
It's nicely done, hope you get a good grade for that. You deserve it.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
What about breaking out different aspects of the flagship into separate daemons and passing the data between them, that would allow for incrementally upgrade to python 3
My first Python project I built last year with Pyramid is NFLPool - probably not quite the Pick 'em Pool you're thinking, but similar. Rules: https://nflpool.xyz/home/rules Code: https://github.com/prcutler/nflpool 
A function that takes a function and returns a function. It's useful if you want something to be done before or after a function is executed and you also want to apply this to a lot of functions.
Now I want a thread to discuss what skills sets we use every day that we're mixing with Python. 
I guess what I meant was there's nothing really different with Python 2 vs. 3 outside of a few new features. The core language is exactly the same and it's easy to support both with the same code base. 2to3 was a tool that was built assuming people would upgrade in one go. They chose not to and much prefer using a tool like six/future to swap out Python 2 for 3 and see that their code works exactly the same without changing anything. I specifically exclude async because it's a new feature. I also couldn't care less about async because I'm not issuing simultaneous server/database/etc. requests. If it helped with IO of many files, then I'd care. The mypy annotation syntax is cool, but works in Python 2.7. The matrix multiply operator is nice, but not essential. The updated dictionaries speed up my code by 30%, but it's still a dictionary. I really hope people aren't still coding without object (unless it doesn't matter). That's so ancient. If someone isn't, then they learned python wrong.
wow you're right so embarrassing haha i'm definitely going to remember that! 
Great to hear it's on the road map, thanks! 
This is pretty cool, thanks! 
You put the data in a list/numpy array. Just multiply that data. Also, you need to define what the product of two curves means. Do you leave the x-axis alone, but modify the y-axis? When they multiply, is it a rotation about an axis resulting in a 3 dimensional result? You might need to interpolate, but that's the easy part.
Isn’t compiled python (via numba) the only way to really make it a PITA to decompile to source (maybe a few other things to further obfuscate too)
This is a way to protect the python scripts. For more detail, you can look this [answer](https://stackoverflow.com/a/51586299/989634)
This looks extremely useful, thank you. Commenting so I can comeback when this is relevant in a couple weeks.
Unless you plan on contributing to the Python project it is more or less a user group that will ask for money occasionally. 
I think it’s really cool, and I would much rather use something like this over LabView (which is such a pain in the ass). But the price to entry is steep for university labs like where I work. Something I will keep an eye on to see how it develops. What is the road map for the future development? Are you working to add features or add built-ins for common devices?
In no particular order: * Substantially less broken text model (Unicode strings instead of byte "strings"). * \`asyncio\` * f-strings * \`range\` is more efficient * \`urllib\` cleanup (instead of \`urllib\` and \`urllib2\`) * dataclasses * Better performance There's actually a TON more, but those are the ones I thought of while I was listening to a podcast.
What sort of data are you writing? Is it easily serializable strings or json? You can store your data in any way you see fit, but SQLite is not really compatible with concurrency. You could make it work by implementing a lock on the SQLite connection, but then your multiple processes/threads will only have synchronous writes. I think Redis really is the way to go — especially since you’ve already abstracted out the handling of your storage into a separate client. It may be the least amount of effort for the greatest gain.
Probably pycharm, the community edition is more than enough tools for a beginner, and if you have access the educational edition is very good as well, I started with just an eclipse plugin and it was good enough for me.
Microsoft vscode
I think they want to append to an excel worksheet every time time the program updates. Your solution just creates a new data frame and outputs it to csv. Also, you can use this derivative of your suggestion to go directly to excel: with pd.ExcelWriter(“foo.xlsx”) as writer: df.to_excel(writer, “Sheet Name”, index=False)
vim? WTF is this 1992?
But you don't have a custom interpreter, so it's got to have regular bytecode in memory.
&gt; regular bytecode in memory after decryption. Oh yes, that's true. But reading bytecode in memory is much harder than reading pyc files :)
vi
This question gets asked very often. A quick and simple search of this subreddit and/or r/learnpython will yield a number of results.
This sounds like where I work. I also work in insurance (health insurance)
Oh f-strings I love f-strings F-strings are my life
I am working on creating a bot that does quality check on insurance claims by directly interacting with an AS 400 via PCOMM/pywin32 to mimic a human being’s actions. Totally lame, but insurance is old school. The funny thing is, they swear they are “cutting edge”.
Use gooey and pyinstaller, it’s super easy.
Like me some vscode
I ended up getting the conda package which includes Spyder and VS code. I really like Spyder.
Ugh. I clicked. Worthless article. Wish I heeded you’re warning
Comment to hold
yeah sure, go ahead.
use "save" instead
I will look into it as soon as I am done with investigating Ansible for collecting data in parallel I do need to go down that path as I might need to write some scripts for my extended team
If y'all have any suggestions, I'd be happy to hear them. I've just been adding functionality as I've needed it so I'm sure there's more I could add.
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
It represents your prompt on the operating system's command line. It's not a Python thing. You don't actually type the $, you type the rest of the line after the command prompt appears.
I suggest pycharm ide with conda, great documentation and support too. [https://conda.io/docs/](https://conda.io/docs/) [https://www.jetbrains.com/student/](https://www.jetbrains.com/student/)
Does it really bother you that much? 
Vim.. look no further than Vim!! 
It’s like giving your function another function as a friend that wraps it up in a big hug! 
Yes, but you mean nuitka. Numba can JIT your code, nuitja is ahead of time compilation.
The PSF doesn't ask me for money.
Very nice idea, looking forward to trying it
But does it play despacito? 
That exactly answers my question. I typed that into Terminal and it didn’t give me an error message. It still says it can’t find my file, so I’ll have to figure that part out, but that answer definitely put me on the right path. Thank you so much!
Saved. Will take a look when I get home and see if I can do it, but this is a great idea to port to r/mycroftai
No, only Africa.
This is great. I did something similar for more natural NPC dialogue in a game once and was thinking of writing it up again in python to add to my Mycroft smart speaker (think "open source alexa"). Gotta check out the code but I like what I see in the readme.
haha, well some guy on this sub posted a youtube the other day where he abused the hell out of `__dict__` but in an unironic way, so :(
So I used tkinter for the first time and it’s awesome! However I couldn’t get pyinstaller to work! I spent all day on it but I couldn’t resolve the errors it was giving me. Something about anaconda? I updated anaconda, no luck. 
This code is limited by the scope of my needs. Abstracting it away from Alexa specifically is something possible.
[Ok](https://www.python.org/psf/donations/)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://www.python.org/psf/donations/) - Previous text "Ok" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
The start of this talk pretty cleanly explains why `asyncio` has little usage. The rest of the talk seems to basically be `concurrent.futures` but more prone to breaking. Still an amazing talk as usual from Beazley, but I remain in the camp that futures are a better paradigm. 
Here's my eli5 scenario for it: Problem: You need to do a bunch of specific tasks before calling several functions. You do not want to retype the tasks over and over. Solution: Decorators let you easily apply the same code to other functions with clean syntax.
Sublime text is your savior
You don't have to donate money to be a member of the PSF; there are other ways to obtain membership. And they don't email you asking for donations.
Flask or Pyinstaller
I'd say a lot of the insurance industry has similar legacy issues. These companies have been around a while, and up until recently had more data than they knew what to do with. I imagine banks would have similar issues too
Pyinstaller gives too many errors! I couldn’t get it to work 
Thank you so much. Any recommendations on tutorials ?
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Advertisement.
Depending on the memory protection of the game, you could analyze the memory addresses of the game to detect when the prompts are triggered. You can then use that to trigger any action. Python isn't the best language for this but you can do it. It'll definitely be better than running it through an image based system. This is how cheat devices work in general.
&gt; Depending on the memory protection of the game, you could analyze the memory addresses of the game to detect when the prompts are triggered Could you please elaborate on that?
Actually correctly you supposed to import `unicode_literals` from `\_\_future\_\_` and explicitly mark bytes where bytes are needed, but there's indeed a problem because various modules disagree what's correct. You can still use mypy to label types, in places where you use unicode (the preferred way) you can use `typing.Text` which is `unicode` on Python 2 and `str` on Python 3. And `str` where in Python 2 it is equivalent to `bytes` and `str` on python 3. Then in places where you're calling function that uses `bytes` on Python 2 you can use `str()` to convert it.
Look for the words “how” and “I” in the same sentence :)
Locks that reset, cleaner thread interfaces, sensible exception handling and default support for thread results. Interesting study in fluid API design. 
It’s literally as easy as searching google for “python import library tutorial” or literally any other combination of words including “python” and “tutorial”.
This looks really cool! I don't love the tag system for plurality, but I can't think of a better way to do it off the top of my head either, so props to you for coming up with something that works
Am I at the dark side of internet where human brains have been consumed by the zombies and ther very same human beings happen to be the managerial staff of these companies?
Nice try Arham Origins developer.
Thank you!
The thing is I'm not searching for anything particular. I'm trying to learn it as a whole. Sure I can Google librairies tutorials and find a good explanation of it but I want to learn more than that and I'm pretty sure that a couples of redditor can show me some good stuff to help me out. Why should I be wasting my time on googling every aspect, every fonction, every way to use python if someone can suggest one good book with everything in it? I'm tired and as you can tell English is not my mother's tongue so pardon my mistakes but I hope you understand what I mean. 
Lol
Cheat programs usually inspect either the instructions being issued by the program to the CPU, or to the GPU , to try and find patterns in the instruction set that correspond with data for the game like health or when events happen. Alternatively they also analyze the graphics buffers and instructions to see what the game is drawing to the screen before all the processing happens. This is how Wall hacks work. For both of those, you'd need a fairly decent understanding of how to reverse engineer games. If you were to go down the route you were suggesting, it's easier but can be less reliable. You could capture the screen and process the image to search for shapes or certain colors popping up. 
[Wrote this explanation some months ago. ](https://pabloariasal.github.io/python-decorators-from-the-ground-up/) it doesn't only tell you what decorators are, but you actually need them.
Thanks for the info however I lack the knowledge required to do the aforementioned. But hey,it never hurts to learn Btw, what do you think of [this](https://autohotkey.com/docs/commands/PixelSearch.htm)?
Autohotkey is great. I use it for lots of productivity stuff on my tablet PC. Never used it in the context of games though.
What do you use it for?
The lack of IDE in pure Python doesn't necessary mean it is slower than Electron, it is just a reasonable choice when there are already mature and fast C/C++ libraries out there that Python can call to. It is not efficient to reimplement in pure Python: not only not better performance, but also take longer time of to develop.
Thonny is great and I've heard good things about Mu. Those two are aimed at beginners. I'm way more advanced now but I still use Thonny. Also I should mention that Thonny will look a little complex however it does come with a simple mode. Also tab == 4 spaces on Thonny. [https://thonny.org/](https://thonny.org/)
For a second I thought you were implying Unix was a rude word. 
&gt; For example: if the data is a time series and you want to track a "reward" or something similar at each time step (along with any other time-based data), would you set up a table for each value where each row is a different training session and each column is the datetime of a the time step? Or is there a more optimal approach? I'm not sure what "each column is the datetime" means but I get the impression you might be interested in the star schema: https://en.wikipedia.org/wiki/Star_schema
**Star schema** In computing, the star schema is the simplest style of data mart schema and is the approach most widely used to develop data warehouses and dimensional data marts. The star schema consists of one or more fact tables referencing any number of dimension tables. The star schema is an important special case of the snowflake schema, and is more effective for handling simpler queries.The star schema gets its name from the physical model's resemblance to a star shape with a fact table at its center and the dimension tables surrounding it representing the star's points. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
**[Star schema](https://en.wikipedia.org/wiki/Star_schema)** &gt;In computing, the star schema is the simplest style of data mart schema and is the approach most widely used to develop data warehouses and dimensional data marts. The star schema consists of one or more fact tables referencing any number of dimension tables. The star schema is an important special case of the snowflake schema, and is more effective for handling simpler queries. ***** ^[About](https://www.reddit.com/user/ultimatewikibot/comments/90r969/about) ^| ^[Leave](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) ^[me](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) ^[alone](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) 
**[Star schema](https://en.wikipedia.org/wiki/Star_schema)** &gt;In computing, the star schema is the simplest style of data mart schema and is the approach most widely used to develop data warehouses and dimensional data marts. The star schema consists of one or more fact tables referencing any number of dimension tables. The star schema is an important special case of the snowflake schema, and is more effective for handling simpler queries. ***** ^[About](https://www.reddit.com/user/ultimatewikibot/comments/90r969/about) ^| ^[Leave](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) ^[me](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) ^[alone](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) 
It is a fair point. At the end of the day, it all comes down to automation of what each of us thinks would perform better or would track the market that you want to follow. Automation helps that, because it strictly follows certain rules and logics that are coded there.
Is the distinction between the two when the result is negative?
I'm sure I could use some package like inflect (dope package, look it up) to do that but working with plurality generalizes to the system I have now where you have dependencies between keywords.
Congrats
Here's the code we use for storing scikit-learn and similar models in the DB with joblib: `import sqlalchemy.types as types` `class JobLibInstance(types.TypeDecorator):` `impl = types.LargeBinary` `def __init__(self, cls=None, length=None):` `self.cls = cls` `super().__init__(length)` `def process_bind_param(self, value, dialect):` `if self.cls and not isinstance(value, self.cls):` `raise ValueError(f"Expected {self.cls} instance!")` `target = BytesIO()` `joblib.dump(value, target)` `return target.getvalue()` `def process_result_value(self, value, dialect):` `source = BytesIO(value)` `instance = joblib.load(source)` `if self.cls and not isinstance(instance, self.cls):` `raise ValueError(f"Expected {self.cls} instance!")` `return instance` `class GcfModel(Base):` `__tablename__ = 'GcfModel'` `gcf_model_id = Column('GcfModelId', Integer, primary_key=True)` `gsp_id = Column('GspId', Integer)` `pca = Column('Pca', JobLibInstance(AutoPCA))` `deseasonalise = Column('Deseasonalise', JobLibInstance(Deseasonalise))` `model = Column('ModelFileName', JobLibInstance(RandomForestRegressor))` `is_live = Column('IsLive', Boolean)` The type checking only works in the round trip between the DB and the code, so you can create instances of \`GcfModel\` with the wrong types, but you can't commit them to the DB. 2M rows is getting into big territory depending on how many instance/parameter pairs you have--you might be better working with a specific timeseries DB (such as DalmatinerDB) but I don't have any experience with that.
This all makes sense and I live in a P2.7 workworld for those reasons.. still.. why in the hell new greenfield products have to be written with old technology? I can see this every day.. old software that no-one have the time/money to refactor and port to Python3, and new software that for some reasons have to be written in Python2.7... I don't get it.. How is good to build a new car with 1980's parts? Why? Sometimes I think that this all "it costs too much to refactor" thing is a way we (developers) try to explain choices made by people that just think "software is software, I don't care as long as it works, stick with what you have and stop talking to me, I have to book my holidays now!".
Are you open for critic? 
Yes. It will help me and others.
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I wish I was smart enough to make a more profound contribution but there's a typo in the readme -- "Do do something [...]" Sick project by the way. 
I love SublimeText. For bigger projects I use the PyCharm Community Edition, which is great. Recently I read about Mu, an editor special for Python beginners. Sounds good but I haven't tried out. https://codewith.mu
Ok I thought that was for asking questions and here i can post my project
Not that I know of, shedskin may be resting but they seem to accept patches when they arrive.
Hopefully new BDFL won't be an arse to people implementing compilers or JITs for python.
A decorator takes any function and tweaks it in a particular way and returns a new function. Now you will be calling the new decorated function instead. 
Looking at David making typos at "thredo" I think it is better, to name lib as "threado"
Thanks dude. But there was never a typo in the readme... *darts eyes back and forth and quickly commits*
Thanks.
[Wooey](https://github.com/wooey/Wooey) and [Gooey](https://github.com/chriskiehl/Gooey) are really easy to use. They convert argparse arguments directly to a simple GUI/web interface. I don't have any experience with GUI building and they're really easy to use, especially if you don't particularly care what they look like.
David just blew my mind as usual, very clean design. 
I’ve had a lot of success combining easygui with pyinstaller. Let me know if you want to see some code. If you’re on windows and you’re using this to process files, one workflow that’s quite nice is if the user drags the files into the executable, the file paths are supplied as arguments. 
The transpose idiom `(zip(*list_of_lists))` is the best way to do these even when not code golfing. 
Actually that’s not true. You can not read .pyce without obtaining a private key. The file in your example is encrypted with AES-256. This is strong cryptography, not obfuscation. And we aren’t protecting the source from leakage: we are controlling the actors with access to source. They should be on an authorized list.
Yes, our goal is to limit access to Python source to a limited set of actors. Not to fully eliminate access to source. You could just as easily use our encryption on top of ahead-of-time compilation.
Yes, our goal is to limit access to Python source to a limited set of actors. Not to fully eliminate access to source. You could just as easily use our encryption on top of ahead-of-time compilation.
What happens if the text with nested curlies contains a quoted string with `}` in it?
&gt; The start of this talk pretty cleanly explains why asyncio has little usage Actually, he just took "poor" side of async vs threads and spin it. The very big advantage of asyncio over threads is fixed switch points. Which is good invariant to drop off big part of synchronization primitives and much less error prone since less times you think "what if context switch will be here?"
So.... The variable 'g' needs to be defined globally, meaning outside the functions, because it is used outside a certain function, and local variables are stored inside a function... whereas they can be used only inside that function! I am not a Python expert, but I hope I answered your question at least partly!
As long as I can use it from Python I'm super happy.
Usually when pyinstaller errors, I’ve found that it’s something to do with imports of some package. For me it was something to do with my Path to pandas. Since you are compiling, it’s important to start with a clean slate, write your code, and compile often to make sure you didn’t break anything. It is easy to narrow things down then. Getting around the errors with PyInstaller saved me a ton of work instead of having to mess with Tkinter/Qt/etc and “roll my own”. Gooey’s github has a great build.spec specifically written for the PyInstaller/Gooey combo There is also Briefcase, which I heard is good from the DataFramed podcast. I can’t/haven’t used it though since it requires some other software I can’t use at work. Good luck!
WhyTF haven't I heard of MycroftAI before?!
I would want that to not "count". Does that make the regex far more complicated?
That sounds complicated... sry m8 I am not that advanced, but I am interested how to do it! BTW, could you please answer my thread? You sound like you could know the answer! ( my thread is the one below yours! about python keyboard module!)
VSCode will fit all your requirements. But remember VSCode is a source code editor not a full IDE, but since you're a beginner you'll do just fine.
None of which is available for iOS
There is one already, AFAIK
https://docs.python.org/2/library/functions.html#locals &gt;Update and return a dictionary representing the current local symbol table. Free variables are returned by locals() when it is called in function blocks, but not in class blocks. &gt;Note &gt;The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter. 
This is definitely missing https://pypy.org/ - Python written in RPython Stackless Python is not in really active development anymore, but many of its features have been integrated into PyPy. Here's something that makes Stackless unique: http://stackless.readthedocs.io/en/2.7-slp/library/stackless/pickling.html
I don't have experience with keyboard modules, but a workaround I've used is using tkinter. import tkinter from tkinter import messagebox #this is just here for the message box test def Program(): def restart(): messagebox.showinfo("Success", "Yep, this works) root = tkinter.Tk() root.withdraw() #hides the window root.bind('&lt;F9&gt;', lambda event=None: restart()) #the key pressed, and your function name here root.mainloop() if __name__ == '__main__': Program()
```ls``` shows you what files are in your current directory ```cd /somewhere/special``` takes you to /somewhere/special.
From [this SO question](https://stackoverflow.com/questions/9519734/python-regex-to-find-a-string-in-double-quotes-within-a-string) I see this expression for a quoted string: `\"(.+?)\"` So you'll need to insert this into your regex where the body of the text between curly braces is defined, so that quoted strings will be fully parsed before looking for opening or closing braces.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
I don't quite understand.. where would you put that in this: regex.match(r'namespace\s+(?P&lt;ident&gt;\S+)\s+(?P&lt;body&gt;(:?{[^{}]*(?P&amp;body)[^{}]*})| *)', ? 
So what are you timing, Python or C? Any language - even a bad one like JS - can call C.
I'm sorry but it doesn't. In the second function, the variable g is set and available to everyone as a global variable. [Warfinder's answer](https://www.reddit.com/r/Python/comments/93d5n3/how_are_local_variables_resolved/e3cez1f/) would be a better lead.
Indeed, it seems like you are correct. It is, however, counter-intuitive. I would expect them to behave in similar fashion. 
Left as an exercise for the reader
JSON is represented in Python as nested dictionaries and objects. For anything Jason related, use the `json` module. import json json_data = json.loads(httpresponse) If you have the `requests` module, it has json parsing built in. import requests Json_data = requests.get(url).json()
Thank you I will tr that out!
BTW, when doing gnarly things with regexes (or even relatively simple things), it can be handy to use a tool such as [regex101](https://regex101.com/) or [regexr](https://regexr.com/) or [regextester](https://www.regextester.com/) - more immediate feedback really helps when debugging!
If you don't know off the top of your head, then you can just say so. I don't expect you to try it out for me. I figured I'd ask since it's going to be a day or two until I can try it out myself. Not everybody here is a college student trying to get their homework done for them. I've been out of college for 20 years.
You would, but the documentation explicitly states otherwise. Explicit &gt; implicit, dont make assumptions ;)
Ah that first one will come in quite handy. One concern I have had is that different languages do it differently. To have one that lets me chose python will be helpful.
Im writing a script to reconcile a bunch of excel files :), im using xlrd and pandas. I also just finished writing an script to parse a few XML files and turn them into a nice pandas data frames. Im quite proud of this one!
Except those are not threads. If you do for x in range(1000000) without a sleep, in 5 threads, they will all progress. Thredo will block, as Beazley explains himself. So it's implicit asyncio. But like the fact asyncio is explicit. If I wanted magic switching and monkey patching, I would use gevent. 
Nearly useless as it gives no information on when the last update was, how active the project is, nor what versions of CPython it's compatible with.
Asyncio has little usage for 2 reason: - First you rarely need it. - When you need it, it's hard to use because it's so low level. The first thing is not a problem. It's actually a good thing. Most programs don't need the extra complexity, yay ! The second thing is solvable with tooling. Python 3.7 brings asyncio.run() and python -x. Some people are rewriting the event loop in something simpler (e.g: trio). Some like me are writing wrappers to make asyncio feels more high level. E.g: https://github.com/Tygs/ayo
The globals dictionary also is not intended to be modified dynamically in this way, if you wish to do so though, it is safer to fetch the respective module from sys.modules and modify that.
[Marshmallow](https://marshmallow.readthedocs.io/en/3.0/) is probably the most popular library for this. [Pydantic](http://pydantic-docs.helpmanual.io/) is pretty cool if you can use Python 3.6
Some points to consider: 1. Python have coding convention/guideline (PEP8), you should follow it, otherwise you can't be seen as experienced developer. 2. Explain _why_ closure needed. IMO, most of the times it isn't needed, and give refactoring overhead. 3. Avoid bad practice in your examples. I refer mostly to the `global` which will cause bugs (I don't have the environment show examples). Also, avoid define variables after using them, even if it works on runtime.
Not really. I like Beazley, I think he is a good speaker and did a great job with curio. But explicit is better than implicit. Here you got fake threads (they only do asyncio), unlike real Python threads which can progress together (although not in parallel because of the GIL), that pretend to be real. In fact what you really have is asyncio, but with implicit switches. And you don't have a clear way to make a pool, or bridge the lib with real threads or subprocesses. And the worst: monkey patch. So it's pretenting it's cancellable threads, but it's not: it's asyncio all the way down, which is already cancellable, as pools and a way to bridge all those things. And an ecosystem. Interesting concept. Liked the talk. But the lib nothing more than a fun proof of concept.
Agreed. The think is, why you may need a lock with asyncio, you rarely do, by design. So using a Lock in one of the selling examples is like saying: look how easy it is to push a bike compared to a car.
Hey buddy not sure if this is any help, but this is how I send messages with attachments using Python. Keep in mind I use *mime*, and not *win32com.client* from email import encoders from email.mime.base import MIMEBase from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart your_email = 'your_email@mail.com' password = input("Please enter your [email] password: ") try: # Connect to the mail server mail = smtplib.SMTP('smtp.gmail.com', 587) # I'm guessing you'd have to change this to outlook mail.ehlo() mail.starttls() mail.login(your_email, password) except Exception as e: print(e) sys.exit() msg = MIMEMultipart() msg['Subject'] = 'Your Subject' msg['From'] = your_email msg['To'] = 'email_destination' # Attach file wordDocPart = MIMEBase('application', "octet-stream") wordDocPart.set_payload(open("C:/Users/MyName/Dropbox/a_file.docx", "rb").read()) encoders.encode_base64(wordDocPart) wordDocPart.add_header('Content-Disposition', 'attachment; filename="a_file.docx"') bodyPart = MIMEText("Here is the body of your message", 'plain') msg.attach(bodyPart) msg.attach(wordDocPart) mail.sendmail(your_email, email, msg.as_string()) 
I think this behaviour is achieved with javascript on the client. Something along the lines of using onChange event to change different input fields.
This is because global variables are actually stored in a dictionary of names and values. `globals()` returns this dictionary, so acting on it affects the global variables directly. Function-locals, OTOH, are stored in something more like a list - the bytecode knows which variable name is stored at which index. When you call `locals()` within a function, it needs to _build_ a dictionary of names and values - and to do this takes a snapshot of the locals at the time of the call. Modifications to the dictionary do not affect the array from which it was built. For more information, see [this Stack Overflow question](https://stackoverflow.com/questions/7969949/whats-the-difference-between-globals-locals-and-vars).
Cherrypy is awesome and it's much simpler to get that into production than flask (which I also like) Can you recommend cherrypy websites that have their code on github or similar? I'm specially looking for examples that have pytest tests to test the website.
&gt; It is, however, counter-intuitive. Local variables form a stack (or tree) of dictionaries with each new scope introducing a new dictionary from which new variables can shadow previous ones. Global variables are effectively the root dictionary of these scopes. So `globals()` can return the underlying dictionary, while `locals()` needs to collapse the scopes down to a single dictionary that represents the members. Hence the difference in behaviors.
Just another point. I worth to remember (and mention on tutorials) that function in python are objects, and can be saved and passed toward other function, so "good" closure can be something like partial. def add_x(x): def _add_x(num): return x + num add_one = add_x(1) print(map(add_one, range(3))) # [1, 2, 3]
I don't know how anyone who knows anything about python can write this article and miss out pypy. Then I realised it's dzone.
Sure sure, but I'm more talking about representing things as objects once you need to start handling them in your own code. In the Java world, when you receive an HTTP request, most frameworks will let you specify what object representation the JSON should be converted to.
Import pandas as pd df = pd.DataFrame( _yourstring_) df.to_excel( _filepath_ ) Win!
I feel like the return value of `locals()` would be a good place to use a `frozendict`, if [the proposal to add `frozendict` to Python](https://www.python.org/dev/peps/pep-0416/) had not been rejected.
In the video he said they are real OS threads. 
I think, you missed the central point of the talk... he was saying all along "what if threads worked like this" and "you shouldn't use this library, it's a prototype". At first this might have sounded like a tongue-in-cheek invitation to actually use it, but, really, I don't think it is. I think, he meant it literally: the threads should be re-envisioned. The fact that `fredo` is implemented using `asyncio` is inconsequential. What he mean is that threads should work differently. On related note: I think that he makes a very good argument. And I'm very much on-board with throwing away `asyncio`, and if no better alternative can be agreed upon, redoing the threads, accounting for the past shortcomings. I would still hope for a better approach to concurrency. Not involving threads. Communicating channels proved themselves easy to program against, so this could be one way. Or, perhaps, something more similar to Clojure is another good way. But, I'm absolutely certain that something must be done, and that something is not `asyncio`. `asyncio` is a dead horse.
Oh, gotcha. Thank you so much!
What kinds of programs are you working on that don't require parallel I/O? In the last five years I didn't have one such program... I'm struggling to imagine the use-case. Are those some kinds of daemons running on single-core CPUs on like... washing machines or something?
I don't think invariant means what you think it means.
You are probably doing a very specific kind of programming to have this weird idea.
In the video he clearly states there is no switch if you do "for x in range(100000)" without a sleep. So not real threads.
&gt; asyncio &gt; is a dead horse. Damn it, you must tell google very quick so they stop working on the V8. 
Yeah, not quite what I'm looking for. Was looking for something where you pick weekly with a last game score tie breaker. Many of these on the net, but looking to host my own.
Building object detection models with MXNet and Tensorflow. Unfortunately I have yet to recreate any articles showing how to do it. Always end up with ~2% accuracy where they get 80-90+..
Think of it as a language rule: @x def y(z): q means: def _y(z): q y = x(_y) del _y The only part where this is not how it actually happens is the side effect of creating an then deleting `_y`. If you disregard that part, then this is what it does, essentially.
only for the yearly plan.. 
Warning: the 50% only applies to the full license price, if you're a long-time subscriber at "year 3" level you're getting closer to 15% discount.
Working on PyPad, feel free to contribute : https://github.com/Fuchsiaff/PyPad
A Reddit Troll "Catch and Release". Our local sub /r/providence gets a lot of newcomers and there's 1 or 2 trolls that are determined to piss them off and chase them away. I'm using DJango mainly for the ORM and it's convenient for building profiles of suspected trolls since they change their profile. Essentially it uses the reddit api to put together data on a user, then it just monitors the subreddit and if they post or comment in that sub then the reddit bot will respond with a comment that this person is a suspected troll with a link to their past comments. Hell, I'm not even a mod. I just love building this stuff and hate trolls. I may not even be allowed to use it, but I'm learning a shit ton and having fun. It's actually morphing into a pretty cool OSINT tool.
I think you only really need to test endpoints for websites and those you can just mock. I don't have any test in my project (cherrypy boiler plate) but if you want you can use it as a reference. It uses pipenv and can be used for heroku deployments (Super awesome tool) and plugins I made. Feel free to use it! [https://gitlab.com/randyyaj/cherrypy-boilerplate](https://gitlab.com/randyyaj/cherrypy-boilerplate)
have you tried: https://github.com/SavinaRoja/PyUserInput?
Deal lord. This is so bad. I'm speechless. It's like... remember that book? No, you probably don't, well, maybe the movie... The Planet of Apes. It's like you are the only human, and you need to prove you are an intelligent being to a whole system of... not so intelligent beings. Well, I mean, you are not alone, there are hordes of idiots jumping on that bandwagon right as we speak. A lot with a straight face, and millions in funding will repeat your story. This is the hot topic. Kafka, Protobuf, gRPC, Kubernetes... and it's such a fantastic bullshit, the history of CS haven't seen the likes of it since XML was conceived. It's so terrible, I don't even know where to start... I mean, none of what you wrote will actually work. Not in the long term that is. It will create millions of pages and tickets for Ops and NOC. It will create a lot of jobs. Extend project planning and execution times by a factor of at least two, but probably more. Huge amounts of money will be spent on cloud providers, security experts, all kinds of third-party services not previously needed. And, in the end, you will have the Microsoft-style text documents: 99.99% of useless bullshit and 0.01% of meaningful information in your system. Think about this: 99.99% of what your system does: it needlessly contributes to global warming by shifting useless bytes in cloud datacenter.
I am working on a script that pulls front-end code and takes a screenshot of the entire website provided. Though, I don't know the "point" of this yet... 
I'll agree that this example system doesn't need to be built this way. It's an example of how to pass things around in a system where you do need it. Such cases do exist but building them in a simple example case is pointless.
A twitter bot that yells at people who write “like for yes, rt for no” instead of making a poll. If anyone is interested in working on it feel free to contact me. 
I'll ask you some more about why you think what you think and give you some counter examples of where I've used this in production, with very little maintenance overhead and a very low AWS cost per month.
Super simple program to track my expenses via terminal and save to sqlite database. Add, edit and view expenses from different time periods. 
a decorator is just like an action you do before any other action. i use the word action instead of function strictly for simplification sake. so imagine you need to write down a to-do list. some of these things you write down require you to drive somewhere or go with someone. for example grocery shopping has a 20 minutes drive, visit to the doctor is 30 minutes drive, maybe you also need your best friend to go to the doctor with you, and later you are going to happy hour together. your to-do list then becomes: - grocery shopping - doctor visit - happy hour simple! but, to be complete now let’s write “decorators”: @travel 20 mins - grocery shopping @travel 30 mins @go with best friend - doctor visit @go with best friend - happy hour decorators are just a way of organizing your code like this.
Worth mentioning: you can keep the product afterwards but you won't get any updates
Yeah, it's the one I usually go to too. :-)
I have seen `json` being mentioned as a medium to pass data around. Why is `json` better than say `csv`? Are you getting data from a flat file? Or is the `json` string being passed in from another application?
Json is better than csv because webbrowsers natively support parsing it (with eval). Then it got popular. Now we don't parse it with eval anymore.
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Also if you are a student you can get the whole suite for free through their educational program!
Scale, HA and FT are often mentioned in the realm of distributed systems (as most web software is nowadays). One way is to blog about what you did, how you did it, your opinions and takeaways and improvements on it. Another way is to build simplifications and benchmark them for illustration. 
What is Alexa Skills? Is it like the new Android app? The name is kindof misleading I guess.. 
A lot of tablet PCs don't have hardware buttons on the side like wacoms cintiq tablet. People made tools with AHK to create software versions of the hardware buttons
Tell me more
Google "jetbrain students" and sign up with an edu email
Trying to understand where `mycroftai`/`alexa skills` fits in. Is the idea behind these tools (`mycroftai`, `alexa skills`) to provide a voice interface to tasks that needs to programmatically handled currently? But because of voice to text interfaces provided by Google and Amazon etc can now be done using voice controls?
&gt;jetbrain students You're a Godsend
It depends on what you like to use. I fyou find the COM functionality is good enough, then it's good enough. If you want to load in DLLs and make use of DLLs then that's an option you also have.
Makes sense... thanks. If I understand you correctly, it seems what you are saying is that if I use `csv` to pass data around, I would have to call another function to parse it before passing it around. If I use `json`, then python can parse it without additional function calls. If I don't interact with web-browsers (as my work is primarily in data-analysis), is `json` still the best way? Why not use `dict`/`data-frames` etc?
Thank you VsCode
What is JetBrains \[PyCharm\] used for?
It’s an IDE for Python.
Pycharm is an IDE for programming in Python. It is one of many flavors of IDE from JetBrains. If you like IDE's, these are very good.
Seconded. Long time Jetbrains customer here. They annoyed me one too many times after several license scheme changes, culminating in the current subscription model. Took the time to explore other options as a result, discovered VSCode, am enjoying it immensely. Haven't loaded my JB products in about 9 months now, don't miss them at all. I definitely don't miss the long startup times. Jetbrains makes excellent tools, but the existence of 'more-than-good-enough' alternatives diminishes my resolve to tolerate their business model.
It's an IDE like VSCode or others. It's pretty nice, I got it from a recent Humble Bundle.
 Actually that’s not true. You can not read .pyce without obtaining a private key. The file in your example is encrypted with AES-256. This is strong cryptography, not obfuscation. And we aren’t protecting the source from leakage: we are controlling the actors with access to source. They should be on an authorized list.
Yeah.. I have only used COM functionality using python. My knowledge of the need of DLLs is a bit weak, but it seems that DLLs are basically used when you need to reuse the functionality of a piece of code (but in executable format). So instead of creating a single EXE you create a bunch of dlls which can be reused in multiple programs (similar to python libraries, except that python libraries are not executables). I was thinking of writing as much as possible in \`python\` and minimizing any \`VBA\` code I have to add... and didn't really think of DLLs. Would you mind explaining when you use DLLs in python? Also if I do have to use DLLs, can \`pywin32/comtypes\` also interface with DLLs, or the only way to do so is with the \`.NET\` libraries such as EXCELDNA or Iron Python?
Just downloaded the student version. Def going to get familiar with it. Currently using spyder which I really like
Just downloaded the student version. Def going to get familiar with it. Currently using spyder which I really like
Yea this is true, I wish that had been a bit clearer before I paid.
VSCode is an editor, not an IDE, you’re thinking of Visual Studio. PyCharm is an IDE like VS.
If you're using their products to develop non-commercial, open-source products, you can also [apply for a free open-source license](https://www.jetbrains.com/buy/opensource/). I think their conditions here are very reasonable (and I'm using this myself). Jetbrains are pretty awesome.
You should try pandas. It's 1000x faster.
I will buy your product once if I like it, or even just respect what you're doing enough. I will never buy your product if it's a subscription model that requires yearly payment.
The last I heard was for Python 4 to just be "version after 3.9" (due to a dislike of double-digit version numbers). It won't be any more breaking than any other normal 2.x ore 3.x release. Whether that will happen seems uncertain at that point, but was does seem to be the consensus is that when Python 4 happens, it won't be a big breaking change like Python 3 was. 
When did you buy the book?
Probably a year ago?
The EOL of python 2 was already set in stone by that point.
🤷🏽‍♂️ I dunno man I'm just a lay man trying to better myself. 
It is still easier than rewriting from scratch in a completely unrelated language.
There are a few projects that seem to want to do this, but they don't seem to have much manpower, which will make keeping up difficult as the code-bases continue to diverge more and more.
Deploying my first app to production this week. Python job automation. I knowingly expected to run into issues importing libraries and... I ran into importing library issues... Wish me luck on getting this to work on our computers before Friday. 
That's fair but I think they structure it in such a way it's a decent compromise. There is always a perpetual fallback model to the version that existed when you start the subscription. Essentially you could do that every 4+ years if you want. Otherwise you could consider renewals to have a large discount. [https://sales.jetbrains.com/hc/en-gb/articles/206544479-Subscription-based-licensing-model-vs-perpetual-licensing-model](https://sales.jetbrains.com/hc/en-gb/articles/206544479-Subscription-based-licensing-model-vs-perpetual-licensing-model)
Fair enough. But in the future, if you are trying to get a book on some software that you know is for an old version, it might be a good idea to check if that old version is going to be discontinued soon. It will help save you from headaches like this.
Basic answer: It's a full programming language with, essentially, the same uses as Java or C#. More complex answer: you can do pretty much anything with Python that you can do with Java or C# or any of the other programming languages out there but they're going to have different packages that help them really excel in different things.
Looking at the source, it looks like thredo uses curio threads. A cursory look at curio thread.py shows `threading` imports. So maybe real threads?
Well to be honest when I bought the book I assumed it would be for the latest version. 
Could you clarify a bit? I'm not quite sure what you're trying to use python for. On one hand it sounds like you're talking about plugins which suggests you want to write a python com components that excel could use. On the other hand, you're talking about controlling Excel with python which points towatds COM automation where python is "the application". 
You can use the CLR library for importing dlls.
Do you have any examples of projects that have done the latter? That's kind of what I'm looking for. One of the ways I'm about to try this is to launch a small app on Elastic Beanstalk and then loadtest it with Siege. If you have any other suggestions it would be awesome! Thanks!
I think youre going to have to go to the powershell subreddit and ask there. 
Was going to applaud Eclipse and Netbeans for saving me hundreds of dollars. I use VsCode too :)
For basic validation, see JSON schema, and the (unfortunately v4 only) `jsonschema` library. Easy to use. If all you wanted is types, than you could try casting into `typing.Dict` and using type annotations. If you really want something better, create your own classes. `typing.NamedTuple` and `@dataclass` might make that easy to get something quick and dirty.
A few(several) years ago I built the "harvester" side for a system targeting Twitter, Facebook, and other social media sources. I chose Python because of how quickly I needed to iterate over changes to the process and compensated for its slowness by using multiprocessing with tools like redis or various message queues to distribute the work. Grand scheme of things, it did well because just twitter alone we were collecting several gigabytes a day and packing them into c* (Cassandra) without much problem. Another side are mathematicians and staticians who have preferred numpy/scipy over R. Throwing iPython(Jupytr, sp?) on top for ease of use and the ability to save &amp; share ad hoc programs has helped these partially not tech savy people in their tasks. With Linux, python has become more accepted because of its stdlib and 3rd party ecosystem which makes it easier to write sometimes complex system utility scripts ranging from networking to package management (eg I believe aptitude has a moat of python scripts around it). Closer to customer level are libraries like boto which makes devops a snap of the fingers. Last thing I can think of is Python's various bridge libraries like cffi or better cython which makes it easier to use dll's and so's with a more malleable glue language. In my own work, cython is painless in that task (http://docs.cython.org/en/latest/src/tutorial/clibraries.html). IMO, a downside is that pyximport can be opaque in what it is doing while you are developing projects.
http://docs.activestate.com/activepython/2.4/pywin32/html/com/win32com/HTML/docindex.html
In that case, maybe Beazley meant that you CAN do "for x in range(100000)" without a sleep, but you can't cancel them. Which would mean they do use thread, are threads are not callable, but inject yield points in which you can cancel.
Fair enough. Harder to avoid that sort of thing.
As stated, a lot of applications. To highlight one, machine learning and scientific application developments are quite commonly using Python, sometimes combined with C for accelerating certain parts of the code. Consider the [SciPy library](https://www.scipy.org/), [TensorFlow](https://www.tensorflow.org/) and [BioPython](https://biopython.org/) as examples.
Hell yeah. Was going to wait for Black Friday but this is sweet! $133 inc taxes for all products with a fall back license when I can't afford to renew next year!
x lambda
Still a discount... 
VSCode, once loaded with enough plugins, can definitely be considered an IDE.
To my knowledge, C# does much different things. MS has a cross platform mobile framework. Winforms, WPF, and UWP. C# is also fairly decent for game dev as well. Sure you can some of those things with python, but python isn't much of a player in games and it doesn't have very good mobile solutions. At the same time, no one is doing data analysis in C# or visualization.
Absolutely, and at least we're still getting the offer unlike cable or cell providers who'd tell us to get bent. But it's still a bit disappointing to notice you're paying $43.50 instead of $53, rather than the $27 you were expecting.
I agree on the sentiment but Jetbrains do the right thing: if you stop paying, the product will keep working, forever, no matter what. You bought it and it's yours. It's like you had bought a car that includes free services and new tyres for a certain period; after that, you keep the car but you'll have to pay for fresh tyres. If you continue paying, eventually they'll upgrade your car with the brand new model too! I think that's a very fair compromise between the needs of customers and ISVs.
Ehh, a programming language is a programming language. I didn't say they were exactly the same and all good for the same exact things but you /can/ do pretty much the same things in most of them.
Jetbrains itself has argued that there's no "integrated" when you did that. They wrote a piece knocking people who claim you can turn vim into an IDE this way. https://blog.jetbrains.com/pycharm/2013/06/vim-as-a-python-ide-or-python-ide-as-vim/
Jetbrains doesn't require yearly payment.
I've never even heard of those. The only 'hybrid' I was aware of was Cython. Thanks for this enlightenment.
Eh, may as well do everything in assembly then.
Check out https://github.com/notifiers/notifiers Full disclosure, I'm its author
It's not impossible
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
But it's impractical which makes that advice not helpful.
The question was "what uses does python have" not not "what should I use it for"
If you are into python development, starting or working, this is a must have. 
These are the 10 features of Python discussed in the article : 1.Python function 2.Data types and sequences 3.Date and Time 4.Map function 5.Lambda 6.Filter 7.Reduce 8.Zip 9.For loop 10.List comprehension
If you don't need to have web browsers handle the data, then it would be less space-efficient to use json compared to csv or other less verbose formats.
Tightening up my newly created process for making interactive heatmaps using Jupyter Notebooks and the gmaps package. I got it to work last week and this week is playing around with it. Fun.
Is that true? I always get locked out when my subscription expires and have to use the community version until my company gets around to renewing.
PyCharm is buggy as hell. Repeatably crashes Python when working with Pandas. Constantly running into UI freezes with REPL communication problems, to the point that it is unusable. Which is a pity, because conceptually, it is one of the most advanced Python IDEs. Loved it at first, but abandoned it after about 2w due to all the bugs. Weird thing is that most are in Jetbrain’s bug tracker since a long time. But nobody there seems to care. Anyways ... using Spyder now. Not as fancy, but it works.
Thx b
Once your subscription expires, you can continue to use the latest version available at the start of the subscription. This way you can still use it, but you have seen the improvements and they hope you will renew to keep using those.
An IoT (ESP32) based sleep monitor that sends data via json to a python WSGI server at regular intervals (e.g. every minute). The data stored in a sqlite database for analysis (i.e. amount of restlessness). The ESP32 tracks movement via a baby monitor pad under the mattress.
Well the last 2 years it has just told me that I can either "quit" or renew. I haven't seen an option to keep using the software without paying...and neither have any of my developers. We all end up using the community version for a couple weeks while we wait for our renewal to get processed by our company. It's weird.
Maybe that's because you guys are on the business/commercial plan. If you buy it personally you get [perpetual failback license](https://sales.jetbrains.com/hc/en-gb/articles/207240845-What-is-perpetual-fallback-license)
So real threads with yield points on blocking operations that allows for an 85% support of canceling threads. There isn’t any C-Extension magic that calls the appropriate thread cancel operations from what I can tell in this product, which makes sense for a prototype. Cancelling threads as a generic is difficult. Cancelling blocking threads and fixing lock/semaphore state is also difficult. I think you should give credit for solving the dirty synchronization primitives case.
[removed]
Wow... that post is patronizing... I've tried using PyCharm, but all of those extras they claim are going to help make me faster didn't. I didn't get more out of PyCharm vs using vim, so I went back to vim.
Porting a codebase to Python 3. This is actually a very fun task for me. The lib I work at has not too bad test coverage and so currently it is mostly making the tests pass. I hope to fix the final 8 tests in the next days. Something is off with these and I'm still figuring out what is it.
I think we’re talking about the same thing , thank you for your time. Do you have a GitHub. An example I am looking for is drag a csv / excel file into the page or upload it. Then click a button. In background pandas does its thing. Have the new file (data cleaned maybe a pivot table and chart ) and saves as a new name and maybe even emailed out or just downloadable. 
Yes that would probably explain it. Thanks!
As a teacher I got the whole suite for free as well. 
Not direct examples right now. I'd say: do it and write about it.
It has a lot of functionality integrated. You can directly commit and push to GitHub, interact with SQL databases and send queries, access source code... all while staying inside the IDE.
Is there an easy way to go from a json string to a named tuple or data class?
Will do, thank you!
Do keep in mind you're not supposed to use that license for commercial use.
You're right, I haven't really. Well I have, and I did do a large port from 2 to 3 but the damn thing was tested to death. So all I really did was spend my time on getting the tests perfectly ported and used them to guide my work. Without that I admit it would have been hell on Earth. I guess if the code base is shit then porting is shit, but with a good code base its not hard. 
The business licenses also have the fallback option.
I could be a number of things, can you share the site?
I would be curious to know about your environment. I am running it on Ubuntu 16.04 and 18.10 along with a Windows 10 box and haven't really seen any problems
There is no hard and fast rule, but when I see someone tell me a command like $ some_command I assume it is a terminal (bash) command. When I see: &gt;&gt;&gt; some_command I assume it is at the python prompt. Alternatively, it *could* be [Python Template Strings](https://www.python.org/dev/peps/pep-0292/) but I doubt it. I almost *never* see anyone talk about or use them. 
PEP8?
If you have the JSON `{"foo": 1, "bar": true}`, you could do something like: class Spam(NamedTuple): foo: int bar: bool Spam(**json.loads(my_json)) This simply feeds the `Spam` constructor keyword arguments from the dictionary returned by `json.loads`. If you want custom objects that aren't the top level, you're probably going to want to use some kind of schema language.
In Python, there's nothing wrong with your code representing things as dictionaries if that's the natural way to represent them.
Don't use Pandas, but have not seen any of the issues you have described and I basically live in it., so I would say "buggy as hell" is a stretch. 
Well, you suggest using... Kafka, and Docker and a bunch of other tools to do, what essentially is video streaming. Now, you may know that, but somehow forgotten... that there are already superior tools to do video streaming. Have been there ages before Kafka, and work several orders of magnitude better. But, I'll reemphasize: video codecs are a matter of pride for real engineers. They try to squeeze every last bit of performance from them. They are typically implemented in hardware of your video adapter. They are super fast. Especially compared to some Java dimwit's hobby project, which, Kafka, essentially is. Implementing your video streaming service using Kafka and Protobuf is not just absurd... is a whole new level of absurd. It's like flying to Mars to buy a pack of cigarettes.
And all you have to do is click a button to keep renewing it. 
To clear this up, .edu mail is not a requirement here. Your university might have a different one and it can still work
If you read the first paragraph of the README, it explains it briefly. But a "skill" is the name for a custom-made Alexa application. If you wanted Alexa to do something like tell you when the next train is arriving at your closest train station, you could write code for that and then create an Alexa skill that uses that code. Then there are "intents" and "utterances" which my README describes.
practicing classes/methods (I just started Python a few weeks ago, and worked with classes for the first time yesterday). I'm using the class Monster() to build a fighting pit of different creatures. I still suck at it, but I suck less than I did yesterday.
It's a little more subtle than that, which is why Jetbrains' new model is annoying. Your analogy would be better stated this way: You buy a car that includes services for a certain period, including new tyres, upgrades to your in-car software suite (that integrates with your mobile phone), better dashboard display etc. You decide to keep the car, but decline to continue with the service plan, so you are obligated to take your car to the shop so they can remove all the enhancements and improvements you've experienced during the year. In other words, a giant pain in the ass, because your choice is to either pay up on your subscription or revert back to your original purchase with all the improvements you've come to enjoy removed. That's not quite extortion, but it's a pretty questionable psychological tactic. Here's the scenario I suspect most people want: Purchase a car, based on the incentive that you get enhancements and improvements for a year. If you decide to purchase another year, you get more improvements and enhancements. If you decline, you get the car with the year's worth of improvments and enhancements you paid for. The latter seems fair to me. Providing a year's worth of enhancements that are removed if you decide not to continue is bullshit as far as I am concerned.
Thats great because it means that they will still have the minor version equal to the current year (e.g 4.0 in 2020, 4.1 in 2021). unless 4.0 is released sooner or later :/
Not my experience using Pandas at all. I use it on Win 7/10 and Ubuntu 16/18. There are some plugins which aren't cross platform but that's to be expected with community developed extensions. 
It is very practical in text and data processing. For all the things perl used to be used for without the readability penalty. And it is even better when combined with libraries like numpy and pandas. 
At $2,000 I'd like to know one hell of a lot before I was even to consider it, let alone buy. I'd start with a search for "python ui data acquisition library".
You are so wrong. Web dev is one (debatebly strong) side of Python. All kinds of automation can be done with Python. Machine learning is extremely interesting and powerful when done in Python and TensorFlow. All kinds of manipulation and scientific mambo-jumbo can be done fast and simple with Python. Don't let me get started on robotics and controlling pins and ports. Also Python can break the web in combination with Perl (although py and pl devs hate each other (small penis syndrome I guess)). I heared about a py code translator for unreal engine (not saying it is and so in just a rumour I heared from a friend). You can do anything C# can with Python in my opinion faster and with some effort even better (my opinion because of gtk package and I don't like drag and drop -&gt; create, I like to build it with a lib old school (but stable for a long time)). You can use Python and raspberry pi to automate your home. And so on.
working on the gui for a multicoin miner
it's real. I have to mentor a guy now who's doing a data validation but decided to eschew a few lines of SQL for merge sorts in VBA...
I just made a script that parses my local ICS calendar for entries formatted in a certain way, and turns them into Xero time entries. No more timesheets for me! Tomorrow I have to test a small utility to do some db-crunching for an Oracle product; build a UI for an Azure equivalent to [ec2instances.info](https://ec2instances.info); and see if I can find a cheap home for my "mailserver simulator" app (basically something that acts like a smtp server, accepting connections from clients and exposing commands, but not actually sending anything).
Sorry - I can't help you if you need the website. You'll have to look into a web framework like flask and educate yourself on web technologies etc. The approach I've used in the workplace is just to put an executable on the shared drive somewhere. Then someone can drag their spreadsheet onto the executable, and it will spit out an output folder where the spreadsheet originally came from. The executable is created with `pyinstaller file.py --onefile`. Make sure you are using virtual environments and tightly specify your dependencies otherwise this executable could get quite big. I'll PM you an example - not on github as it's for work.
Where did I say you can't do data science or automation in python? I specifically said python is the better of the 2 for data analysis. All I was saying is the C# has very different practical uses than python, and all you've done is say the exact same thing but say its wrong when I say it. I love python too; it's my language of choice usually. There's no reason to pretend its the strongest language in every realm, though.
We do a bunch of datanalysis, but all of it is done manually in a adhoc manner. Here are my short-term goals: We generate some binary files from our tools, called `recipe` files such as `recipeA.rcp`. We have a existing plugin, writted in VBA, say `pluginA`. Users can pretty much click on a button, then navigate to the `recipe` location and then run the `pluginA` on `recipeA.rcp` to grab the most important parameters, into a particular sheet in a workbook called `Recipe Sheet`. Now over the course of months, typical users have 100s-1000s of such `recipes` in the `Recipe` sheet, as a result its very difficult to quickly find a `recipe` with a certain set of parameters, without some additional tooling. So I built a python script, `scriptA.py`, which can grab individual recipes from the `Recipe` sheet search through them based on a given combination of parameters (using `Pandas`, `xlwings` and a few other libraries). This just runs it on a `Recipe` sheet, but as most users are not familiar with the intricacies of Python, wont be able to use it. So my immediate goal is to create a button on the `Excel` Ribbon which can then call the `scriptA.py` and based on the parameters provided by the user, can search through all the recipes in the `Recipe` sheet and then display the found `recipes` in a separate sheet. The `python` code that I wrote is well tested, and I wanted to add any additional code in a way that I can test. If I write the `VBA` code to create the button etc (and it seems to be trivial to do so), I cant test it. So I was thinking of even creating the Button using `python` by using the `com` interface. However I didn't find any simple tutorial on google which shows how this can be done. This led me to wonder whether there are any inherent limitation of what the different `COM` interface can and cannot do? Here are my intermediate-term goals: We also have a multitude of other tools, which generate different types of data, but all of these reside on a host of different locations, without a good structure. So in the intermediate term, I want to add on the plugins, such that when users click a button and given a config file which contains the locations of the different data files, it will go and fetch the files and organize them in a structured fashion in a networked file system. Further, I want to add some computational functionality, which are non-trivial to do in Excel but relatively easy to do in Python (using `Pandas` or a equivalent library). Users would highlight some range of cells and click a excel button, and a python file/function would be called. Finally the result of the computation would be displayed in Excel. Does this help? 
Currently, I'm working on a [text-based Forgotten Realms RPG](https://github.com/addemup9001/Forgotten-Realms) that will use the D&amp;D 3.5e ruleset. It's not much right now, but I plan on making it work.
&gt; you are obligated to take your car to the shop so they can remove all the enhancements What? Never happened to me. I didn't pay for about 6 months, never had to uninstall a thing, it just kept working. I'm on the personal license though, not on the business one.
As others have mentioned, a .edu email isn't the requirement, my university doesn't have it (it uses my countries TLD) and it still worked fine.
You probably didn't end up using new features that came out since you first got it. When you stop paying, you're reverted back to the version that existed at purchase time, not the version you had when your subscription ran out.
Thanks for the explanation.. Yeah.. I read that.. I meant that \`skill/intents/utterances\` doesn't necessarily represent what we think of as \`skill/intents/utterances\` in the English vocabulary.. To generalize this and maybe this is a toy example.. what is the benefit of using \`Alexa Skills\` over say just typing it into Google Maps, or any other Android App which probably already provides this functionality? Is it the Voice aspect? In that case, why not just modify the \`Android\` app to add the voice functionality rather than build a entire new platform, language, tooling etc?
I’ve. Been using it for 5 years on Mac. Not using Pandas but I haven’t experienced any major issues with it. It’ll start hogging your system once you open 5-6 projects in separate instances but that’s understandable. 
What does the paid version of pycharm do? I am currently using the free one.
Their integrated remote debugging is super useful. 
This right here. The most succinct way to say it is this: If you choose not to renew your (annual) subscription (because the version you are using is good enough, budget is tight etc.), you revert to the version that existed at the time you purchased it, minus any enhancements or upgrades or whatever that happened in the subsequent 12 months. What you get to keep for your perpetual license is whatever was available 1 year ago. If you are a developer in a fast moving environment with a tight budget, removal of those enhancements could be devastating. That's the Catch 22. With Jetbrains, the version of the tool at the moment you purchase the license is what you get to use if you don't renew 12 months later. If you renew, you are paying for what you are currently using right now. ANYTHING you update for the next year from now on will go away unless you subscribe again. Reasonable? Maybe. Confusing? Hell yes. It's a psychological game. You are paying for a tease of what you could get if you renewed your licence 1 year hence. You are paying for what you have right now, though the enticement is another year of licence. If you like the state your Jetbrains tool is in, but don't plan to renew, you can pay up, but you had better ignore all the update notifications etc. for the next year, because they will go away. I don't mind paying for what I use at all (Jetbrains customer for many years), but I very much mind paying for features I don't actually get to enjoy should I find another tool that works better for me. 
Basic combination of most basic use of `json` and `collections.namedtuple` (or `typing.NamedTuple`. Why look for a single magic method for everything? ```python YourClass(**json.loads(string)) ``` Of course, validate your inputs first. Apply `jsonschema.validate` (or similar) to `json.loads` first. Not sure what the patterns are in frameworks, simple or enterprise, but it might be a good idea to look, even if they aren't Python.
Working on a modern responsive theme for python's Sphinx docs based on Vuepress. Uses Vue.js + Stylus managed by webpack (vue-cli-3). WIP: Just layout the project structure, looking for help to actually port the theme [https://github.com/schettino72/sphinx\_press\_theme](https://github.com/schettino72/sphinx_press_theme)
micropython on the esp? 
Your submission has been automatically removed. Accounts must be older than 2 weeks. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Seconded. 
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Type `pip install -r requirements.txt` into the console then run `python program.py` again.
Json is good for a textual representation of some nested object that's string-representable being passed between different programs (or the same program, but maybe in a different version of python). CSV is good for tabular data, but you're going to need to settle on a Dialect - How quotes, missing columns, headers are handled. For example, does `1,2,"a,b" ,4,'c,d',6,,` contain 6 columns? 8? 10? Different programs interpret that in different ways. If you're primarily working with pandas dataframe, use pandas' csv implementation. A dict or pandas dataframe can be pickled to a file, but that doesn't guarantee someone else in the distant future on some different version of python can unpickle the file. And if that person doesn't or can't have python, dealing with a python pickle is painful.
Thanks a lot for your reply! I initially did use pip install -r requirements.txt already, but as you suggested I now tried to not put .exe after python, but I'm still getting the very same error :(
My system is MacOS High Sierra ... mainly working on deep learning. Without Pandas the crash frequency is less, but Matplotlib crashes on a regular basis too. In Spyder, or Idle, no crashes. And it is not just me, it seems ...: https://stackoverflow.com/questions/10363526/pycharm-running-wayyyy-slow https://www.reddit.com/r/Python/comments/sqc0q/im_sick_of_pycharm_its_insanely_slow_rpython_what/ https://youtrack.jetbrains.com/issue/PY-24880 
Eh. I've used Emacs, Sublime Text, and most recently VS Code to write scads of Python professionally. It's a _nice_ to have, sure, but 100% not a _must_.
The error is pretty self explanatory: the module cv2 cannot be found in either the local directory or the directories defined in sys.path. pip install --user cv2 Depending on your install this could be aliased as pip2 (for python2) or pip3 (for python3). As an added benefit this will resolve and install dependencies automatically.
You will need to install `cv2`. This is not something that can be done by copying a folder from a Github repo unfortunately. Search Google for installation instructions.
***or you could use free vim***
https://blog.jetbrains.com/pycharm/2015/03/feature-spotlight-python-remote-development-with-pycharm/ Tons of changes to those features since 2015 when that blog post was made so the screenshots are innacurate, but conceptually nothing has changed. Add remote interpreter, add remote deployment, select automatic upload. You can open a Django shell and a normal SSH session from inside PyCharm to do any manage.py and pdb shennanigans you need.
This thread is filled with a bunch of blatantly wrong info. These are all real threads - they're spawned by curio but they are threading.Thread objects. The only interaction with curio is when a thredo call happens - it does a bunch of curio async thread calls to handle cancellation points. Whilst the main thread kernel handles stuff like sleeping and cancelling and scheduling the primitives, all the other code is ran in a real OS thread. 
Set up your own private PyPi mirror with Artifactory - it's great. You'd obviously have to cut a deal with your company's security people to allow the packages you need to be synchronised to Artifactory. You can make pip fetch all its packages from Artifactory and make setuptoola upload all its wheels and eggs there. This solution worked for me when I was at a major American bank.
There's no difference between an editor like VSCode and an IDE anymore. The last person I asked to define it started making up lists of features that were "standard" in an IDE out of the box, but was unable to cite a reference for it. We no longer differentiate between - for example - a computer iwth an office suite, and a computer without an office suite, because loading software is no longer a challenge.
That's a five-year-old iPython bug.
Working on learning django to better my chances at getting a placement at the biggest open source company where i live 
There are no PyPi official mirrors. The main reason for this is the space requirement would be huge. You'll need to Plow pythonhosted through. Even Artifactoy just caches whatever you download but that uses as it's source pythonhosted too.
Web development?
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
You should consider looking into devpi or nexus hosted on your intranet. Those servers act as proxies to the actual PyPi which means they need to be able to connect to PyPi to download the package once. After that initial download, the packages will be served by the service running in your intranet. If you can't make those services connect to PyPi, I'm sure there's a way to download the packages you need to a USB drive or something like that and then upload to that internal service. This also means you'll need to tweak your `~/.pypirc` to provide that internal service as an extra index url or make it THE index url. You can also just pass `--index-url` or `--extra-index-url` to `pip`. FYI, you can use pipenv but don't have to, this is a pip feature that exists for quite a while now. Hopefully this gives you enough pointers to solve your problem.
OK, it's not a must. But having remote execution, intagration with Dockery, vagrant and a built in database browser and many other features is a really nice to have. Currently, pycharm facilitate all my work that I can't even imagine the time that I would need to invest to have something similar. 
You guessed it. Take the following example: 5 divided by 2. In the positive domain, this would normally yield 2.5; a truncation yields 2, as does the floor division. However, 5 divided by -2 normally gives -2.5, truncated would give -2, whereas floor division gives -3 (since we are still rounding down). Hope that helps!
James Powell's talks are amazing, I wish he had a full Python course.
100% worth every penny and much, MUCH more. 
The built in database tools are nice. I've been using the paid one so long I don't remember what all is different. The biggest thing for me is Django support. 
Jetbrains uses a plugin architecture just like everything else.
Those really expert level Python understandings in addition to badass vim skills make his take a bit hard to follow through and yet quite enjoyable.
Exactly :D 
Finished my CLI app that puts all the ietf rfc's into a db and lets the user read, search and bookmark them. Now I need to think up a new project. 
Decided to make a thing to pull info from one site and fill in the info in another to make my life at work easier. First project so figured I would start simple. Next task is gonna be an email thing like thunderbird/outlook because why not
--trustes-hosts doesn't work. The proxy is blocking files.pythonhosted.org such that I can't even get to it with a desktop browser. The /simple links ultimately seem to just link to files.pythonhosted.org :/
I guess you're doing from PyQt5.QtWidgets import QtWidgets but it needs to be from PyQt5.QtWidgets import QWidget
This licence is why I'm unlikely to renew my subscription (personal Property) after four years. The tooling is good but there are some big annoyances or UI bugs I experience daily. (Why can't I filter out symlinked library Coverage results in the IDE? Why can't I see all my tabs when mouse wheeling?) My employer may not have full plug-in support for our environment in VSCode yet but I think I can manage to use the command line versions until that's completed. I feel like the "perpetual fall back"is just a little over the edge of abusive: I'd lose support for new Go features and improves to the Python plug-in that have come in over the past year. VSCode is just good enough with a little external tooling.
Nothing you mentioned is outside the realm of what VSCode can do with the right extensions. Seriously, that extension model makes vs code so versatile I rarely find myself wanting for anything, regardless of language. (The one caveat being c# just because visual studio does have some more polish UI-wise, but even then, if I couldn't get a license, vs code would work just fine). 
I have a love hate relationship with him. He comes across as an overconfident douche and a humble guy at the same time. It's weird. Regardless of his personality, his Python talks are some of the best. 
Scratch that, I still suck. I have no idea why, but the code won't compile, and won't give me an error message.
Your formatting is all kinds of crazy. Perhaps the numbers in the table are _not_ present within the HTML document you linked, but are instead fetched asyncronously from some other URL afterward. Use your browser's debug console to inspect the http requests being made, find the one producing the data you want, retrieve that one in your code.
If you asked me a year ago I would've said no. At that point I was primarily using python to write simple scripts that do straight-forward computations. Now, I'm starting a (somewhat) large project. I love it when I deal with code that has type hinting.
Wow, I'm stupid.
\+1 Just found his talks through this subreddit and watched about 3 of them in a row. Really impressive.
Yep. As I said in an earlier post: &gt; the existence of 'more-than-good-enough' alternatives diminishes my resolve to tolerate their business model. 
You did'nt call read on the response, so there is no body (yet). page2 = request.urlopen(page).read()
^^^or vs code...
Making skills with Alexa is like writing any type of script to do any type of job. Instead of a graphical user interface, it's an audible one. You ask Alexa to do something or find out some info and it'll tell you what you want to know. For example, my PoC skill that I wrote took posts from joke subreddits and said them out loud; so you could ask for a dad joke and you get one from /r/dadjokes, etc. A shitty example, but there's a much more beyond my limited creativity that one can do.
In other news, vscode still free.
As a cloud engineer, pycharm professional is an awesome IDE. I handle projects with Python, bash, docker, yaml/json and databases. Even if Python is 10% of the programming I do daily, I can work a whole project with a single tab.
You are frequently overwriting your input data with 0's. Why aren't you sorting the list of sides? /r/learnpython is a good place to learn python; /r/python is more about news
oh sorry i don't use reddit much.
I think your assignments are all backwards. You want a = input1 rather than the inverse. As the other commenter pointed out you are reassigning all your inputs to 0
I had no idea indeed provided an API, this is cool!
Could you paste some links pls?
I need simple sentences that are marked positive, negative, or neutral. A buddy and I are trying to make a program that can differentiate between sentences that are positive, negative, and neutral. Then the computer will give you the degree of positive or negativeness. (I am adding the degree independent of the google form.) I sorry if you think it is sketchy, but I'm just trying to collect some new data for a independent project of mine. I just enjoy to code and am trying to learn and progress. The google form link does not have any other links attached and if you would feel more comfortable with the whole google form link instead of the shortened one I can provide.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
https://www.kaggle.com/c/sentiment-analysis-on-movie-reviews/data
How does it compare to: cut -d "," -f 2 myData.csv | sort | uniq -c | sort -rn
Awesome thank you. I appreciate it!
Not to be confused with [Faust, the programming language designed for processing audio streams](http://faust.grame.fr/), used in the core of [guitarix](http://guitarix.org/).