Using CGIHTTPServer sounds horribly inefficient, you're either spawning interpreters or loading py2exe binaries with every request. I recommend using SimpleHTTPServer instead. Import the scripts you need in your request handler and call the code from within do_GET / do_POST. You'll need to be thread-safe but it will be a hell of a lot more efficient and a lot less ugly too.
Ty, I think i have to investigate the details of what you say (i'm not that profficient about webservers and the like). What you mean is coding a custom made post function to load the script from there.... i cant even figure out how to do it. I see what you mean about the inefficiency of cgihttpserver used this way, but the + for me is it was very, very easy to set up. Do you know any tut or example of what you say? I'll anyway set on a Google quest... 
Solved it, thanks everyone!
&gt; You **can't** or shouldn't develop for platforms that force you to use a prescribed language. This includes iPhone (who make you use Objective C), Android (Java) and Windows Phone (.Net). *ring ring* Yes hello? Ironpython and Jython would like to fill out a formal complain that they can't be used? Is that so?
Yes I know JS/CSS/HTML and I like your idea. I could do this. Will have a talk with my teammates about this approach.
Thanks! 
You can make your readme file much more helpful. https://github.com/matthewhughes/really-scrapable-web-app
Whooo, wasn't Pyside a dead project since Nokia stop funding OpenBosa? I see commits [there] (http://qt.gitorious.org/pyside/pyside), commits!! 
Geany is perfect for small to medium sized projects.
Latest version 1.2.1 was released 3 days ago, so I wouldn't call it a dead project.
Do you mean EC2? EBS is just another file storage that EC2 can use.
Looking forward then, I'll try all my old projects on PySide.
&gt; do you use tabs or spaces, which ones are better? If they ask you this question in an interview, you probably don't want to take the job.
I'm talking about Amazon ElasticBeanstalk. I guess you're talking about ElasticBlockStorage ? I'll edit the above comment to explicitly mention it.
Could be a trick question. The answer has exactly four letters anyway.
Tabs? I use spaces only (4x = tab)
The WRONG answer has four letters. Check [PEP 8](http://www.python.org/dev/peps/pep-0008/#tabs-or-spaces) on this topic.
Oh. I thought he meant that the answer was PEP8. Which IMO should be the answer to the question. "PEP8 recommends using 4x spaces exclusively, so obviously that's what I'm doing."
 STATIC ROOT = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'static') I'd really recommend changing this. Just looking at it is making me feel a bit ill. Take a look at this gist for something a little more concise: https://gist.github.com/ergusto/6000407 If you're using 1.5 &gt;, you can also just use this notation: &gt;MEDIA_ROOT = ('static/media')
About the GIL thing: [this page](http://wiki.python.org/moin/GlobalInterpreterLock) sums it up nicely. In short, the problem is that GIL prevents python code from running fully parallel - while native code driven from separate python threads can run in parallel (e.g. libc calls or I/O), CPython bytecode cannot. Because of this, python cannot fully exploit multicore machines for cpu-intensive parallel processing (however, most typical python applications are I/O bound, so the problem isn't nearly as bad as it sounds.)
Sure. In my specific job, we write tests in Python that stress the product that ultimately gets shipped to customers. But the tests always run on a *different* computer. We need to run the tests in all versions of Windows (Windows XP, Windows 7 32-bit, Windows 7 64-bit, etc). So we have a fleet of virtual machines that actually run the tests. But on those machines there is no development environment set up. So it's incredibly useful to run the tests on the virtual machine and use your local development PC to set breakpoints, step through the code, etc.
I remember using this program when I owned a photography studio a few years ago. It's good software. I would agree with wxPython &amp; use py2exe &amp; py2app for distribution. I have never used pyinstaller so that might be the best option.
I can. And I should. It'll be what I work on later on tonight! Cheers! 
P. E. P. 8. That's four characters ;-)
&gt; Show me three different ways of fetching every third item in the list I'm very afraid that questions like these would be the total bane of me in interviews. I sat here and tried answering the questions one by one and I thought it went pretty well. But when I got to that one I completely drew a blank. It wasn't until I opened up an interpreter I remembered that I could do a[::3] to get a result and i still can't see two other obvious simple solutions. Anyone got some good tricks to handling such questions?
&gt; One thing you've managed to do is "trick" yourself into thinking that typing helps in many places where it doesn't That's a good point that I hadn't really put much though in to. Obviously static typing only helps if we are avoiding calls back in to Python. Using Typed Memory Views in conjunction with numpy arrays is probably a good idea - where possible. Like I said though, this was mainly a demonstration of how to think about turning pure Python code in to fast Cython code. In particular, the ``cython -a`` flag. &gt; AFAIK (but I don't know much) the best option as of now is to use ``numpy.multiply``, ``numpy.power`` Good idea! Still, my major barrier at the moment is that pesky indexing!
Oh.. I thought you were a tab guy.
Yeah, I'm wondering it it's worth throwing up a bug report about the ``greater`` and ``less`` functions...
I am. Except in python and haskell. When whitespace is decorative, like in C, it is best to leave indentation size to the reader's preference. But in python, it is syntax, so it is better to avoid the resulting potential for confusion and not use tabs at all. It's not elegant, but the alternative is worse.
I got asked something similar to this one, contrived as it is. def add_to_list(elem, l = []): l.append(elem) return l alist1 = add_to_list(1) alist2 = add_to_list(2) print alist1 print alist2 The output is expected to be [1] [2] Is it? What is the output? Why not? How would you fix it? I've been considering using something like the below for an interview question: value_x = 10 def do_something_with_x(): def _double_x(): value_x *= 2 return value_x print _double_x() do_something_with_x() Does this code work? Why or why not? If not, how would you fix it? If so, what does it do? Bonus: What does this tell you about lexical scoping and closures in Python? And the follow-up: value_x = 10 def do_something_with_x(): def _double_x(): global value_x value_x *= 2 return value_x value_x = 30 print _double_x() do_something_with_x() What does this code print? And then the final followup, subjective though it may be: would you ever do this in production code?
Oh okay... this all makes much more sense. Yeah, I'd be careful because "EBS" is always used in place of Elastic Block Storage, I've never heard it used for BeanStalk until now.
Thanks. I'm targeting the new (Python) version to have a few features that people have been requesting for the past ten years. 
Come on, "Two" is just silly. Also the Zen of Python says "There is only one way to do it", why ask for three ways? That's like saying "Give me the right way and two wrong ways to do it". Do they ask things like this in interviews?
Is there any particular reason why you are using Django 1.4.1? The current status-quo for Django 1.4.x is 1.4.5, which includes some rather critical security updates. I'll submit a pull request.
I'll try my hand at a few: &gt; What are Python decorators and how would you use them? They extend past python, and are functions that take a function as an argument and return functions. A simple example might be a decorator that takes a function, prints its args to stdout, prints the return value to stdout, then returns that return value. The syntax in Python is usually done with the @decorator_name above a function definition. &gt; How would you setup many projects where each one uses different versions of Python and third party libraries? virtualenv &gt; What is PEP8 and do you follow its guidelines when you're coding? A coding standard, and I try to. pylint is a great help. &gt; How are arguments passed â€“ by reference of by value? Probably all through reference, but I'm not sure about primitives under the hood. Anyone know this? If you pass f(12, 81), are those by value? &gt; Do you know what list and dict comprehensions are? Can you give an example? ways to construct a list or dict through an expression and an iterable. &gt;&gt;&gt; x = [(a, a+1) for a in range(5)] &gt;&gt;&gt; y = dict((a,b) for a,b in x) &gt;&gt;&gt; x [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)] &gt;&gt;&gt; y {0: 1, 1: 2, 2: 3, 3: 4, 4: 5} &gt; Show me three different ways of fetching every third item in the list [x for i, x in enumerate(thelist) if i%3 == 0] for i, x in enumerate(thelist): if i % 3: continue yield x a = 0 for x in thelist: if a%3: continue yield x a += 1 &gt; Do you know what is the difference between lists and tuples? Can you give me an example for their usage? Tuples are immutable. A tuple might be a good type for a coordinate inst var in some class. Lists are ordered collections, but with a tuple, each index generally has a certain meaning, so coord[0] is the x coordinate and coord[1] is y. &gt; Do you know the difference between range and xrange? Range returns a list of the full sequence while xrange generates each element iteratively like you would with the "yield" keyword. This changes in python3, and the default behavior is to yield like xrange. I think xrange is out. &gt; Tell me a few differences between Python 2.x and 3.x? The previous answer. print is no longer a statement and is just a function ("print 5" won't work anymore and you need parens), they added the Ellipse object (...). That's all I know off hand. &gt; The with statement and its usage. It's for context management, and you can define your own that implement __enter__ __init__ and __exit__ if it might help. This is very useful for opening and closing files automatically (with open(foo) as bar:) &gt; How to avoid cyclical imports without having to resort to imports in functions? Refactoring your code? Not sure. When I've ran into this I generally have restructured functions into different modules which ended up cleaning everything anyway. &gt; what's wrong with import all? You can overwrite functions and this can be dangerous especially if you don't maintain that module. * rewrite.py def open(foo): print('aint happening!') * test.py from rewrite import * z = open('test.txt') # prints aint happening! &gt; Why is the GIL important? It has to do with preventing true multithreaded bytecode, and has been an issue forever. I think python bytecode execution is protected with the Global Interpreter Lock so every bc execution is atomic. Explained best here: http://wiki.python.org/moin/GlobalInterpreterLock You might want to consider writing a multithreaded module or program in C and wrapping it with Python if this is an issue for you. &gt; What are "special" methods (&lt;foo&gt;), how they work, etc These are methods like __str__ and __gt__, which override behavior of other global functions like str() and operators like &gt;. __enter__ and __exit__ will be used with the with keyword, and there are many more like __getattr__. Overriding __getattr__ can result in some very unpredictable behavior with a dynamic language like Python, and you should be very careful when you use magic like that. &gt; can you manipulate functions as first-class objects? Yes. eg. they can be passed as args to functions. &gt; the difference between "class Foo" and "class Foo(object)" class Foo(object) inherits from the new-style object. I don't know the specifics, but here's stack overflow: http://stackoverflow.com/questions/4015417/python-class-inherits-object &gt; how to read a 8GB file in python? Operate on chunks, and not one byte at a time. Be wary about the RAM of the host machine. What is the nature of the data such that it is so large? How are you operating on it? What are you returning? Are you accessing it sequentially or randomly? There's a lot more to ask than to answer here. &gt; what don't you like about Python? It's slow, and it can be too dynamic for certain tasks in my opinion. It is not compiled. It can be very unpredictable. People abuse the flexibility of it sometimes. &gt; can you convert ascii characters to an integer without using built in methods like string.atoi or int()? curious one struct.unpack("&lt;I", foo)[0] ord, chr &gt; do you use tabs or spaces, which ones are better? Spaces. Stick to PEP8 when possible. &gt; Ok, so should I add something else or is the list comprehensive? * generators/yield keyword * what is multiple inheritance / does python have multiple inheritance * is Python compiled, interpreted and/or emulated * What differentiates Python from Ruby * How do you debug your Python? What's pdb and how do you use it? * How do you modify global variables in a function? Why should you avoid this? * Use of the re module... what is it, give an example, etc.
It's depend on your level. When I was interviewed I was asked following questions (and if I answered a question next one was more difficult like): * 1) what means "Dynamicly typed"? * 1.1) Can we create exe file of our script? * 1.2) What proc and cons of this? * 2) What is it: 'References counting' * 3) What is the GIL? * 4) Something about threading/multiprocessing? --- Here I don't exactly remember order of questions... * 5) Can we add new method to an object (class instance)? * 6) How are you going to check is method was added dynamicly or defined in class? * 7) How are you going to modify behaviour of each method in class (decorate each user method)? * 8) What do you know about MRO? I was not asked about python syntax
I answered them below... tell me if you see something wrong.
&gt; I'm compiling a list of all possible interview questions. I think you're being overly optimistic here... I don't think you can compile an exhaustive list of programming-related questions. &gt; What are Python decorators and how would you use them? They are a construction with which you pass a function/class through a callable when defining it, allowing that callable to add functionality. One common example is to add memoization to recursive functions but you can do a lot more (some web frameworks use it to mark functions are being views, associating it with a URL). &gt; How would you setup many projects where each one uses different versions of Python and third party libraries? [virtualenv](http://www.virtualenv.org/) is a standard tool to manage that. &gt; What is PEP8 and do you follow its guidelines when you're coding? It is the acknowledged standard (on of the accepted Python Enhancement Proposals) for Python programming style. Answer "yes". &gt; How are arguments passed â€“ by reference of by value? (easy, but not that easy, I'm not sure if I can answer this clearly) Things are references in Python. &gt; Do you know what list and dict comprehensions are? Can you give an example? It is a way to programmatically build the elements with an expression (that contains a loop). It is similar to creating an empty list/dict and looping to add stuff to it, except shorter and usually faster. Generator expressions are an important related construct that replaces yield-ing functions. &gt; Show me three different ways of fetching every third item in the list L[::3], (L[i] for i in xrange(len(L)) if not i%3), map(lambda (e, i): e, filter(lambda (e, i): not i%3, izip(L, count()))), ... a lot of other (bad) solutions here. &gt; Do you know what is the difference between lists and tuples? Can you give me an example for their usage? Tuples are (), (1,), (1, 2), lists are [], [1], [1, 2]... Difference is that lists are mutable but tuples are not (although the elements they reference may be mutable, you can't change these references). &gt; Do you know the difference between range and xrange? range() in Python 2 returns a list, so a big range would take a significant amount of memory. xrange() (Python 2; range() in Python 3) returns a special iterator. &gt; Tell me a few differences between Python 2.x and 3.x? Some list-creating functions were replaced with iterators (xrange(), izip(), ...), str are now unicode (str -&gt; bytes) and related unicode/encoding changes, some libs changed names, print is now a real function, / performs float division... see [changelog](http://docs.python.org/3.0/whatsnew/3.0.html) &gt; The with statement and its usage. Used for a lot of things, usually closing a resource (instead of try: finally:) when leaving the block. &gt; How to avoid cyclical imports without having to resort to imports in functions? Don't have cyclical dependencies. &gt; what's wrong with import all? You polute the namespace and it's hard to see where a name came from (if you have several of them in a module). &gt; Why is the GIL important? (This actually puzzles me, don't know the answer) It has a performance cost: Python threads cannot execute Python code at the same time. Threads can still execute code while another is waiting on disk, network, or some C library calls. Real parallelism of pure Python code can be achieved with [multiprocessing](http://docs.python.org/2/library/multiprocessing.html). &gt; What are "special" methods (&lt;foo&gt;), how they work, etc Allows to define special behavior on objects or override operators, see [special method names](http://docs.python.org/2/reference/datamodel.html#special-method-names) for a full list. &gt; can you manipulate functions as first-class objects? Well, yes. &gt; the difference between "class Foo" and "class Foo(object)" In Python 2, you should precise the parent class to have a new-style class, "class Foo" gives you an old-style class (pre-2.2) which [changes some things](http://docs.python.org/2/reference/datamodel.html#new-style-and-classic-classes). Don't use them. (method resolution order is different, type() gives you 'instance', metaclasses and descriptors won't work). &gt; how to read a 8GB file in python? Don't read it in one go into memory, stream it by writing clever iterators/generators. &gt; what don't you like about Python? Dynamic (hard for the IDE to figure out), bad C API, too much magic with C types (vs "heap types") descriptors and metaclasses. Note that this is my own opinion. I still enjoy using it. &gt; can you convert ascii characters to an integer without using built in methods like string.atoi or int()? No. At best, you can use ord() and compute it yourself. &gt; do you use tabs or spaces, which ones are better? Use spaces. [See PEP8](http://www.python.org/dev/peps/pep-0008/#tabs-or-spaces). &gt; Ok, so should I add something else or is the list comprehensive? You left out descriptors and metaclasses.
Tabs - It is faster to type. If you're required to follow PEP8 just convert the tabs to spaces when you're done.
&gt; `&gt;&gt;&gt; [i for i in l if l.index(i)%3==0]` Unless your list has duplicate items... 
Here's an upvote. That'll have to do.
Let us know how it goes. In most of my programming interviews the questions were not language specific. Usually it contains "fizzbuzz" type questions and stuff you would see on /r/dailyprogrammer. Good luck! 
Yea my bad :) 
Do they ask things like this at interviews? I don't know, but if they asked, I'd try to answer. I might consider later whether I wanted the job, though! def third (i, l) : if i &gt;= len(l) : return [] if i % 3 == 0 : return l[i] + third(i + 1, l) return third(i + 1, l) :)
&gt; Tabs - It is faster to type Or in a good editor, it makes absolutely no difference.
For reference vs value see http://stackoverflow.com/questions/986006/python-how-do-i-pass-a-variable-by-reference . 'By value\ is the technically correct answer, although it may be counterintuitive at first.
Yeah, that's a subtle bug waiting to happen.
&gt; &gt; How are arguments passed â€“ by reference of by value? (easy, but not that easy, I'm not sure if I can answer this clearly) &gt; Things are references in Python. That's king of tricky. The CPython implementation always handles things as references (eg., an integer is an object). But from the user perspective, null, boolean, int, float and string (and complex?) are passed by value, because assigning to the function's argument does not affect the caller's value. But "structures" like tuples, lists, dictionaries and object instances are passed by reference, because assigning to a member of the "structure" also affects the caller. What python doesn't have is the "call by name" from Pascal (among others). Then you can faze the interviewer by launching into a rant about how PHP4 really fsck'd up by taking pass-by-value to its logical conclusion! 
&gt; however, most typical python applications are I/O bound, so the problem isn't nearly as bad as it sounds. Of course they are, since python is simply awful for CPU bound applications. Speaking of which, does anyone know of a replacement for matplotlib+basemap in C, java, javascript or anything else that runs reasonably efficiently? I have a cluster of weather image plotting machines that I'd much rather be using for weather forecasting.
How is "what don't you like about Python?" a tricky question? So many warts in the language. There's a reason they had to do Python 3.0.
Just throwing [opster](https://github.com/piranha/opster) out there as well; I've been using that module for a little while now and am a big fan. Your arguments and options just come from the python function itself @command() def main(arg1, arg2=None, verbose=('v', False, "More verbose output")): pass 
I'd skip your answers two and three as they offer no benefit over slicing `a[::3]`. Granted if `a` was particularly large using a generator makes sense: def get_third(some_items): for i, v in enumerate(some_items): if i % 3 == 0: yield v to be used like for j in get_third(xrange(100000)): print j But in practice more likely to use a generator comprehension almost identical to the list comprehension: gen = (v for (i, v) in enumerate(some_items) if i % 3 == 0) Another method is a functional paradigm like: import operator as op map(op.itemgetter(1), filter(lambda (i,v): i % 3==0, enumerate(some_items))) or zip(*filter(lambda (i,v): i % 3==0, enumerate(some_items)))[1] Granted the functional paradigm generally should be avoided in python for list/gen comprehensions and the `zip(* )` nested list transposition trick probably needs a comment.
This looks interesting! 
I was just trying to get a sample django application working with ebs and S3. I generally use 1.5 otherwise. And, thanks a ton for the PR in advance.
Everything is passed by reference. That is, all "variables" are *references* to objects. Even "foo = 2", "foo" is a reference.
`[n for i, n in enumerate(ell) if i%3==0]`
&gt;&gt; How are arguments passed â€“ by reference of by value? &gt; &gt; Probably all through reference, but I'm not sure about primitives under the hood. Anyone know this? If you pass f(12, 81), are those by value? Something else entirely. I've written [a tutorial of sorts](https://dl.dropboxusercontent.com/u/2000007/namesvalues/namesvalues.html) about this. The diagrams are hand-drawn and terribly ugly and I intend to remake them with actual diagram-making software before putting it up on my website instead of Dropbox, and the very last diagram has one arrow that points to the wrong value, but over-all, I think it's a pretty useful guide.
Yeah, instead of using `index`, use `enumerate`. Except, of course, in this case `[::3]` would be the only way to go. (One and only one obvious way, and all that).
&gt;&gt; How are arguments passed â€“ by reference of by value? &gt;Probably all through reference, but I'm not sure about primitives under the hood. Anyone know this? If you pass f(12, 81), are those by value? In [15]: a = 1 In [16]: a.\_\_class\_\_.\_\_mro\_\_ Out[16]: (int, object) Numbers seems to be normal objects like others. I don't care about internal hacks that explain this code: In [19]: a = 1 In [20]: aa = 1 In [21]: b = 123456789 In [22]: bb = 123456789 In [23]: id(a) == id(aa) Out[23]: True In [24]: id(b) == id(bb) Out[24]: False Very funny, isn't?
Wow I completely forgot about the possibility of having duplicate items... using `enumerate` instead of `index` is the correct way to do this. Thanks for pointing it out!
&gt; Do you know what list and dict comprehensions are? Can you give an example? &gt; In [25]: { a: a+1 for a in range(5)} Out[25]: {0: 1, 1: 2, 2: 3, 3: 4, 4: 5} List comprehensions or generators are not needed for make dicts ;-) You can generate sets too: In [26]: { a for a in range(5)} Out[26]: set([0, 1, 2, 3, 4]) 
These are trivia questions. Trivia questions can be good for getting a quick frame of reference for how long somebody's been using the language. An experienced Python user would have no trouble with any of these questions. The only one that gave me pause was the 8GB file one. I remember that Guido wrote a blog post about this at one point, so I'd just refer to that in an interview. I believe he used the array module. &gt; can you convert ascii characters to an integer without using built in methods like string.atoi or int()? `ord()` is a built in method. So no. I think you meant to ask &gt; Can you convert a sequence of digit characters to an integer using only `ord()` on individual digits, instead of more convenient functions like `int()`?
Shouldn't it be `a[2::3]` since it's every third element and not the first and every third item after it? :p
That wouldn't be the output. It'd be: [1] [1,2] Silly no? But it has to do with the way python constructs functions when they're defined. I'm not real clear on the details but in a roundabout way `l` has effectively accidentally become a static variable. This could be a desirable feature but it's a bug as far as I'm concerned. The way I'd fix it is this: def add_to_list(elem, l): if type(l) != list: l = [] ...
Any time you post something to a public forum and people try it, you risk someone else getting it into production. Some of my mistakes that are public are in some crazy important places! :P Which means, while it's one thing to say, "Try it at your own risk", and another thing to put it out there with deprecated requirements.
markdown fail. ftfy. &gt; 1. what means "Dynamicly typed"? &gt; 1. Can we create exe file of our script? &gt; 2. What proc and cons of this? &gt; 2. What is it: 'References counting' &gt; 3. What is the GIL? &gt; 4. Something about threading/multiprocessing? --- Here I don't exactly remember order of questions... &gt; 5. Can we add new method to an object (class instance)? &gt; 6. How are you going to check is method was added dynamicly or defined in class? &gt; 7. How are you going to modify behaviour of each method in class (decorate each user method)? &gt; 8. What do you know about MRO? 
&gt; Tuples are immutable. Please never choose tuple for that sole reason. Tuple's immutability is a side effect of it being intentionally hashable (so you can use it as a key in a `dict`).
Wow. As a 15-year-old casual (non-professional) programmer, I'm unable to answer most of these. I've got a ways to go, I guess.
&gt; The only one that gave me pause was the 8GB file one. I remember that Guido wrote a blog post about this at one point, so I'd just refer to that in an interview. I believe he used the array module. Can you link to that? I see it as more of a UNIX-y/mmap question really. 
I think you've got the right idea, but I feel the reasoning could be better. I'd explain it like this: When functions are defined with some parameters having default parameters, the defaults are evaluated once. Thus def add_to_list(elem, l = []) defines the default parameter for l to be a list object that hangs around for the eternity of the python process. Since lists are mutable, it is possible to change the value of this default value, which is what l.append(elem) does. This is why the output is [1] [1,2] and not: [1] [2] My fix for this would be to set the default value of l to None and perform a check in the function body. This becomes: def add_to_list(elem, l = None): if l is None: l = [] ... I think that the fix you propose has a couple of issues: * It breaks the interface so that I can no longer call add_to_list(1). I must have add_to_list(1, []) * If I pass a list into the function, that list gets modified. Although not specified, I usually err on the side of not modifying my input parameters.
If you have very long lines, and want to continue on the next line, getting a readable alignment with tabs can be a nightmare. Usually you end up doing tab tab space space space, and then on another editor with a different tab width your code doesn't make sense at all.
Feels rewarding, nevertheless.
How would you do it in C/Java? With while How would you do it in Haskell/Clojure? With filter so you can still do that in Python (athough filter is not available in Python 3 you can mimic that)
A better fix: def add_to_list(elem, l = None): if l is None: l = [] Explicitly checking type like that is in general unpythonic. At the very least you should use isinstance() so subclasses can be used.
This may be what he was referring to: [Sorting a million 32-bit integers in 2MB of RAM using Python](http://neopythonic.blogspot.com/2008/10/sorting-million-32-bit-integers-in-2mb.html) 
I have my .emacs folder configured to set my tab to four spaces for python, is that wrong? Should it be left as tab? I had thought spaces were preferred but I am not a professional.
That's my PHP showing again. Let me just tuck that away...
A good exercise to get prepared is to read up on different data structures. Lists and dicts are obvious, but make sure you know about sets, heaps, queues (fifo, lifo) and most importantly how/when to use them. Almost every programming interview has revolved around choosing good data structures to solve problems efficiently.
Interesting. I guess it's equivalent to think that: * Things are passed by reference, and = changes the reference (instead of acting on the pointed object, like any other operator would do; there is no magic __ method for =). In a sense, it works on the same level as *is*. * Variables *are* references, and are passed by value (the common way the behavior is described, for instance in [this stackoverflow answer](http://stackoverflow.com/a/986145/711380)).
The right answer is tab key with a space representation.
I spent a lot of my youth programming with PHP which encourages explicit type checking a lot of the time and old habits die hard. Whoops... You're right though. Thanks for clarifying.
&gt; Surprisingly, thereâ€™s nothing of the sort for aspiring data scientists. Does [kaggle](http://www.kaggle.com) not count? Edit: I see your project serves a very different purpose, but kaggle does have a trove of intros and tutorials for budding data scientists.
That sounds interesting, I think I understand some things but I've never heard about MRO, what is it? I'm not sure how to respond to question number 6 too, isn't it easier and more readable to define all methods when you define a class? Should the answer to number 7 go along the lines "add decorator to each method of an object", or is it too obvious"?
&gt; &gt; Show me three different ways of fetching every third item in the list &gt; &gt; [x for i, x in enumerate(thelist) if i%3 == 0] &gt; &gt; for i, x in enumerate(thelist): &gt; if i % 3: continue &gt; yield x &gt; &gt; a = 0 &gt; for x in thelist: &gt; if a%3: continue &gt; yield x &gt; a += 1 Your solutions are all basically doing the same (using enumerate/indices and modulo to access every third element in a for/if construct). Here two different solutions: # using slices thelist[::3] # using a generator def every_third(thelist): i = 0 while i &lt; len(thelist): yield thelist[i] i += 3 for e in every_third(thelist): print e EDIT: Yet another one using enumerate() and filter(): filter(lambda e: e[0] % 3 == 0, enumerate(thelist)) EDIT2: Chunk thelist into lists of 3 elements and get last item of each list (yeah, it's starting to get a bit cumbersome): [x[-1] for x in zip(*[iter(thelist)]*3)]
tabs for indentation, spaces for alignment. Emacs can do it for you, I'm sure vim can too.
I think that setting argument to None and checking it later is the recommended way to deal with this problem but I'm still not sure if I understand clearly why things like this happen, it seems to be somewhat strange not intuitive. [There is one interesting question on SO about this](http://www.reddit.com/r/Python/comments/1knw7z/python_interview_questions/cbqx2mo), and people try to explain it clearly, maybe I just need more time to understand it better. I suppose the answer to this question has a lot to do about the way in which Python passes arguments to functions.
You mean one should never use tuples? Or one should never use tuples if they only have that one reason? And what should they use if they need an immutable list?
I got asked something similar to this one, contrived as it is. def add_to_list(elem, l = []): l.append(elem) return l alist1 = add_to_list(1) alist2 = add_to_list(2) print alist1 print alist2 The output is expected to be [1] [2] Is it? What is the output? Why not? How would you fix it? No, The output is: [1, 2] [1, 2] Why not? I'll admit i don't have an elegant way to explain this. Can someone chime in? Is it because a functions arguments are defined in the outer namespace that its called? This seems to support that argument: def outer(elem): def add_to_list(elem, l=[]): l.append(elem) return l return add_to_list(elem) alist1 = outer(1) alist2 = outer(2) print(alist1) print(alist2) output: [1] [2] How would you fix it? = What did you want to happen?
Yea, I always forget about the step element. It's somewhat of a silly question though, but I guess a majority of interview questions like these are.
You're right. I forgot that variables are stored as memory references.
&gt; Tuple From Raymond Hettinger's answer to a [SO](http://stackoverflow.com/questions/9755990/why-can-tuples-contain-mutable-items/9756028#9756028) question: ''' Tuples are characterized less by their immutability and more by their intended purpose. Tuples are Python's way of collecting heterogenous pieces of information under one roof. For example, s = ('www.python.org', 80) brings together a string and a number so that the host/port pair can be passed around as a socket, a composite object. Viewed in that light, it is perfectly reasonable to have mutable components. Immutability goes hand-in-hand with another property, hashability. But hashability isn't an absolute property. If one of the tuple's components isn't hashable, then the overall tuple isn't hashable either. For example, t = ('red', [10, 20, 30]) isn't hashable. '''
I'm going to have to test this with "is" instead of "=="
Thanks!
Another way of using a generator def t(l): l = iter(l) while True: l.next() l.next() yield l.next() for e in t(range(10)): print e 
Yeah, I know the feeling. :)
Thanks! :-)
Here are short answers: &gt; 5. [Can we add new method to an object!](http://stackoverflow.com/questions/972/adding-a-method-to-an-existing-object) &gt; 6. comare __dict__ of class and object, or check where method was defined &gt; 7. [How are you going to modify behaviour of each method in class !](http://stackoverflow.com/questions/6307761/how-can-i-decorate-all-functions-of-a-class-without-typing-it-over-and-over-for) &gt; 8. [VERY important to undestand how it (mro) works for new style classes. it helps to understand how works super() function !] (http://www.python.org/download/releases/2.3/mro/) It's more important to undesrtand how it works and have some ideas how to do it.
No you are right. I use the tab key set to 4 spaces. 
I subscribe to see the proof when you do. Nah, just joking ;p
In Python only the indentation *level* is syntax â€“ the type of indentation is irrelevant. The one true advantage to spaces is standardisation. Everything else is opinion. Guido famously prefers tabs, for example.
Understood. Thank you for pointing that out. Will take care hereafter :)
Because I think it's clever: def every_nth(n, iterable): iterator = iter(iterable) while True: for _ in range(n): out = next(iterator) yield out &gt;&gt;&gt; list(every_nth(3, [1, 2, 3, 4, 5, 6, 7, 8, 9])) [3, 6, 9]
Python passes everything by value however all values happen to be references to objects. Numbers can be a little strange though due to low numbers say less than 500 magically referring to the same objects. 
It is a performance hack. Low integers can refer to the same object. I think it is really annoying that they choose to break consistency for a tiny performance improvement. Another weird one is that True and False are actually integers. 
With god like power, comes god like responsibility.
Like that it avoids checking with len(), but subsequent calls to .next() into the void seem weird. Wondering whether one could avoid that...
I think you're closer to right than I am. "Pass by reference" has the ugly assumption that changing the "variable" (ugh) in the next scope will change the variable in the calling scope, which is def not true. I think the best answer is to slap the questioner and say, "this is not Pascal. You have names as references, and values here, not variables."
The .next() call at the end of the list will throw a StopIteration exception which is what you are expect to send at the end of an iterator. (your generator function will actually do the same behind the scene when it arrive at the end)
That's just what I was thinking about! I do not like asking that particular question, because when I get the right answer - that means the person is good at python, but most of the time I would get a wrong or "I'm not sure " answer and that means almost nothing, the person might still be good.
Number two is alot simpler if you do third = [] for i in xrange(0, len(a), 3): third.append(a[i])
 * how to define singleton class * how to public/private (PEB8) * difference 'for i in d' and 'for i in d.keys()' 
MRO stands for Method Resolution Order. It's basically python's way of picking which base class's method to call when calling an instance method. 
I'm aware of how a iterator works, what I actually meant was calling .next() three times in a row to get one value. Maybe it's just me, but it seems weird. The only thing I could come up with yet, which is far from perfect: def t(l): l = iter(l) while True: yield [l.next for i in range(3)][-1] for e in t(range(10)): print e
Considering you're getting started at your age, I'd say you have a huge advantage. By the time you're done school you'll have a good amount of experience and background under your belt. Keep learning!
The vast majority of "programmers" I know can't use git, don't know the difference between weak typing and strong typing, don't know what unit tests are and don't know the difference between stack and heap memory. Living in a third world country sucks.
A small pool of integers is used; these range from -5 to 256. That is, if you refer to any of those numbers, you always get the same object. This is an implementation detail, however, and should not be relied upon. String literals are shared too, and there is only one empty tuple object.
"or shouldn't", Jython and Ironpython shouldn't be used simply because they're not the best tools for the job. Also does Jython compile to Dalvik?
I have a raspberry pi, it's a full computer not an embedded system. I suspect you know full well that I was talking about PIC controllers and the likes but you're just looking for an argument. EVE's scripting layer is Python, that's not the same as the game engine. Python is not suited to multiplying millions of transformation matrices a frame which is why you'd need to use a wrapper around a game engine written in a faster language. As for the phone stuff, they're just not a good choice unless you only know one language and aren't willing to learn others.
It's more than just that it's a bad benchmark. The fact is, there's no explanation anywhere that would hint that the author knew what and why he is doing what he is. For people who don't know Go (this is a Python subreddit) we *need* to be able to follow the code and thought processes and we need assurance that this is meaningful. There is nothing more than two blocks of code with timing data which means *nothing* to me.
Wait... you're supposed to avoid functional paradigms in python? The whole reason I use python is because it has functional features but lacks the strong typing of most functional languages...
&gt; &gt; How are arguments passed â€“ by reference of by value? &gt; Probably all through reference, but I'm not sure about primitives under the hood. Anyone know this? If you pass f(12, 81), are those by value? The terms PBR and PBV were developed to talk about languages like Fortran and C and using them to talk about Python is only a source of confusion. Python's passing semantics are different from either of these languages. The literal answer is that Python is pass-by-value in all cases, and also in all cases the value is an object reference. In a PBR language you can rebind the name in the passing scope, but in Python you can only mutate an object you receive. This is analogous to passing pointers in C, while C remains a PBV-only language.
 a = 30 b = 300 print a is 10 * 3 print b is 100 * 3 What is output and why?
A tuple *is* an immutable list
Looks nice. How is it different from [re-try](http://re-try.appspot.com/)?
This is not a good question because the answer depends on which interpreter you're using. The behavior is essentially undefined.
Oh OK, i didn't know bad questions exist.
Well, bad *interview* questions certainly exist.
You're 15. It's fine. You still have a lot of time to learn!
In its bases, they share the same goal: being an online python regex tester. However, pyregex has a few differences from re-try. Some of them: - It is a modern HTML5 application based on AngularJS - It has an enhanced UI based on Twitter Bootstrap - It has the ability of sharing a regex match - It works with any regular expression that python considers valid. I've tested re-try in the past with a dozen valid regular expressions and all I've got was "[NO MATCH OR NOTHING FOUND]"
Yes, I know. patrys just said that tuples shouldn't be chosen for satisfying that property. I don't understand why not.
A common pattern I'll use is to have the Foo() constructor take injected dependencies which is as flexible as possible, and a Foo.build() factory method which calls the constructor with sensible defaults. This makes testing easier, among other things. It can also make sense to have more descriptively-named factory methods than just the default constructor. `Invoice.due_today()` and so on. The way I see it, SRP says that the job of a class is to build its instances. It should *only* be that class's responsibility to build instances; everything else should go through it.
Take a look at someone the testing frameworks as well as documentation tools. They may not be that important for an interview, but in general they can be quite useful. 
&gt; difference 'for i in d' and 'for i in d.keys()' Hmm, this will totally not do what you think in Python 3
Still horrible warts in the language that we'll be stuck with. No product(), horrible division that no longer acts like any other programming language, more special syntaxes for things that don't deserve it...
the manipulation was adequate, it was the image controls themselves that were complex...so many abstract layers that aren't compatible with fairly similar things. It was just a mess really.
Set out to answer every one of the questions listed above and you'll be in great shape.
The reason it happens is because default function arguments are evaluated only once, and the result stored as the default. In that case, by specifying an empty list as the default, what you're really doing is instantiating a single list (which happens to be empty initially) and telling Python to use that list whenever the function doesn't receive a second argument. Every time you call the function, the default will be the exact same list - so if you mutate that list, it will carry over those mutations to future calls as well because they all share the same list. The same thing can also happen with dicts, sets and any other mutable object. They should generally not be used as default arguments.
FYI, there's a backport for 2.x: https://pypi.python.org/pypi/faulthandler/
Bool is a subclass of int that only supports 0 and 1. True and False are singletons representing 1 and 0 respectively. It's not a hack to make bool a subclass of interest, it was a design choice. Theres a pep for bool, but I'm on mobile, so no linky.
Wow, I thought I had python down. Now I'm going to teach myself all of this.
The only time that happens to me is when I'm working on an automated testing machine that ONLY has what's required. Therefore, the code that exists uses spaces, so use spaces when working in vi/textpad.
Responsibility will deprecated in 3.4.
 [a for a, b, c in zip(*[iter(string.lowercase)]*3)] It truncates, though. Here's a non-truncating version: [a for a, b, c in zip(*[iter([x for x in string.lowercase]+['']*3)]*3) if a] Note: these are bad answers.
And [Google Docs version (with comments from glyph)](https://docs.google.com/document/d/10WOZgLQaYNpOrag-eTbUm-JUCCfdyfravZ4qSOQPg1M) 
Absolutely. First of all, PEP20 actually says "There should be one-- and preferably only one --obvious way to do it." Questions like this are designed to separate those who know what they're doing from those who are rote-repeating what they read up on the subject of Python programming last night. The correct answer would be "well, the obvious way to do it is using a list slice like so, however you can also ..." (and give a few options) because this demonstrates that the candidate is both a problem solver and proficient in the specific language, not just proficient at Google and with a photographic memory. Arguing about the validity of the question is going to give the impression you are Dr Sheldon Cooper, your opinion is the law and you're not going to work well with others. Welcome to the trash pile. 
Yes. I have more experience with Python than with Lua, and I probably could have written this guide before even having heard of Lua. I chose Lua for the guide because recently I'd seen a lot of questions about this behaviour in Lua. The implementation differs per language, but the abstract behaviour of all the dynamic languages (that I know) in terms of names and values works the same. I think (but I'm not sure, because I haven't thought about this before) that if you disallow mutation, you get the abstract data model of functional languages like Haskell.
Don't worry, git's commands are pretty inconsistent with each other, besides a few of the most used commands, I always have to look up the docs.
A tab is only one character anyway.
Well I think it was a poor design choice and it has cost me hours of debugging in the past. But I can see how they were tempted to copy c.
So you're answer for why people should use tabs is because you work in an esoteric environment that benefits from their use? That's like answering that he should use spaces because I use spaces because my keyboard's tab key is broken.
If you were to interview me (10+ years of python coding) I'd probably just leave the interview before the end. From a recruiter point of view, at best you'll end up with a guy that has as much value as a google search.
PBV and PBR were designed to talk about all programming languages. Pass by value: the argument expression is evaluated, and the *value* it results in is assigned to the formal parameter. Pass by reference: the argument expression is evaluated, and a *reference* to the result is assigned to the formal parameter. People get confused and think that PBV == copying, because in C, assignment of a value copies the value.
A while back when I was reading about Go and goroutines, I read somewhere that some sort of event-driven callback system is being considered to be incorporated into python's core. Is deferred being evaluated as a candidate for that?
Guido mentions in the linked article that he is going to write a *future* article explaining why Tulip doesn't need Deferreds. We'll see what this means exactly. One must be careful to separate terminology from concept (I find myself to be an accidental perpetrator on a constant basis, so I am somewhat wary of Guido's claim). 
Java does the same with `Integer`s. There's an intern pool for small values.
I wonder what Guido thinks about [Twisted's DeferredGenerator](http://twistedmatrix.com/trac/wiki/DeferredGenerator), which lets you write asynchronous code that looks like synchronous code. Deferred generators blew my mind when I first learned about them. Now I use them everywhere in nonblocking asynchronous apps.
What's the background here? Did Glyph propose adding Twisted's Deferreds to Python?
The background is a design discussion about why Deferreds do what they do and how the stuff proposed for tulip did or didn't cover its use cases.
Cool. I hadn't heard of [Tulip](http://www.python.org/dev/peps/pep-3156/) before. tl;dr: Asynchronous I/O support coming in Python 3.3. 
OK, great post. I haven't been following python3 or Tulip, but I dug into twisted recently and I think that better explanations of Deferred is always awesome since they appear simple, but it's hard to understand how they work with all their subtleties.
Yep, lots of use in unit tests. And yeah, you have to take extra special care with regard to exception handling (which I confess I didn't really do). I think it would be nice if Tulip gave some sort of first class support or alternative for this useful idiom.
fun fact: if you import antigravity this comic will pull up in your default browser
You're gong about this wrong. A good interview shouldn't be full of trivia questions. Anything more than one or two is a red flag. You should prepare for conceptual questions about how to approach designing software and problem solving 
A good interview doesn't focus on edges cases and language trivia. any programmer that relies on this knowledge will write code that's to complicated and hard to maintain. Most programming is simple shit that needs to be maintained for years, not complex, hard to understand magic.
&gt; I think it is really annoying that they choose to break consistency for a tiny performance improvement. I am very curious about what code you have tried to write where the fact that some integers alias and others don't gave you problems.
Not familiar with Twisted -- I'm assuming they prefer you yield a failed promise/async object then? E.g. "yield RaiseAsync(MyException())" or some such?
This is one of those things like python-requests, where as soon as you see it you wonder why you never thought of it.
 from future import time BANG! ... and there was light.
You shouldn't use anything, Python core devs have stated multiple times that even `frozenset` was a mistake and Python will not be getting any intentionally immutable types. Link: http://mail.python.org/pipermail/python-3000/2006-May/002219.html
You're hired!
After that explanation, which one is python?
As someone who's HIRING a Python coder... thanks :) Sadly, I don't know enough about all of these questions myself, so it's due time I learned.
&gt; Living in a third world country sucks. That's not something unique to the developing world. I've interviewed plenty of developers in the United States, many of whom have decent jobs right now, that can't answer most of these questions either.
Nice. This has a lot in common with C#'s async-await stuff (and the general "awaitable" concept), introduced in C# 5.
i bet you can't have a key called "pop" or "keys" :)
That's not just a third-world country phenomenon. I frequently speak with recruiters and consultants in the US who have difficulty finding decent programmers and software engineers. One guy employed two questions: the FizzBuzz test and "find the longest string of repeated characters in a string." He disqualified 45% of his applicants from those.
It depends on your specific implementation and your software needs, there is no right way of doing it.
More of these, please. This is exactly the type of content I come here for.
I implemented something similar on a class that derives from `dict`. I'm only supporting dot and tab completion though, not setting. By overriding `__dir__` it's possible to avoid making dict elements into attributes. def __getattr__(self, attr): if attr in self: return self[attr] else: raise KeyError(attr) def __dir__(self): return self.keys() + self.__dict__.keys() 
But DefaultDotDict can also do &gt; d = DefaultDotDict(); d.a.b.c = 1 and sub dictionaries will be created automatically.
You can actually, but you can not access them by dot notation: &gt; d = DefaultDotDict(); d["keys"].a.b.c = 1 
Strange as that criticism might seem, I agree with Guido that using a past-tense adjective to name a class is confusing as hell. It took me a while to wrap my head around Deferreds, and I can't help but to suspect that it's mostly due to confusing nomenclature. Edit: now that I saw Glyph's reply it makes more sense... if only I had known!
Here's a question I would use: How do you define a function with a default argument that is a list? E.g. def foo(l=[]): l.append(1) return l The above is wrong. Fix it. Does this only apply to lists?
I think it is nice and useful. We have had something identical called "PluginManager" in web2py for years (https://github.com/web2py/web2py/blob/master/gluon/tools.py#L4872) we mostly use it to allow users to configure plugins.
You use tuples where you would use a `struct` in C: for collections that have a well-defined structure. A good place for a `tuple` is where a `namedtuple` could be used instead but would be an overkill. What I consider proper uses of collections: coords = (11, 25) todo_items = ['walk the dog', 'water the flowers', 'world domination'] ids_to_delete = {1, 5, 7, 11} recipients = [ ('John Doe', 'john.d@example.com'), ('Kelly Smith', 'kelly@example.com'), ('Robert Adams', 'radams@example.com')] # each recipient has a well-defined structure of (name, email) # could be a set of tuples as well
How about this (fairly crude, but I wrote it in 5 minutes)? Its uses a library I wrote for quickly for prototyping image filters, but you should be able to easily convert it to PIL/OpenCV/SimpleCV/whatever: import os, sys from imagekit import * def main(): kernel = [ -2, -2, -2, -2, 16, -2, -2, -2, -2 ] color_filter = 15 b = ImageBuffer.fromJPEG('redbox1-578x770.jpg') # Convert to HSV colorspace b.toHSV() for y in range(b.height): for x in range(b.width): sample = b.get_pixel(x, y) # Change reds that meet criteria to white if (sample[0] &gt; (360 - color_filter) or sample[0] &lt; color_filter) and sample[1] &gt;= 0.4: b.set_pixel(x, y, [0, 0, 1]) # Convert to Greyscale b.toMono() # Apply edge filter b.apply_cvkernel(kernel) b.savePNG('output.png') sys.exit(0) if __name__ == '__main__': main() [Which outputs this](http://i.imgur.com/SC1vjro.png). To filter out everything besides the movies, you could then write something that looks for rectangular shapes within a certain aspect ratio. I'm glad other people are getting into Image Processing and Computer Vision, its ridiculously fun and rewarding. Keep up the good work :) EDIT: Also, since movies are in a grid, you don't really need the filter to find every movie. You could look for patterns, and guess where each movie title should be (and possibly crop them to individual images).
Very cool. This makes setup and teardown a snap. Can't wait to see support for other frameworks. 
Added redis DB support so that the A records can be updated live.
Agreed - Geany is clean, fast and has good auto-completion. Cross platform too.
Ok thanks. We're all good here. I was interpreting the "immutable list" thing too broadly. Structured information is what I use tuples for. Usually.
dont a lot of email services reject email in which the domains MX record doesnt really exist or resolve properly ?
Trying to think back to where I ran into this. I was trying to build some sort of container class that would work on generic objects. I needed to see if objects were the same so I used "is". This obviously would create problems with ints. I guess technically you could say it is the user of the containers fault for passing in objects that are actually the same even though they look different. Alternatively you have to make a special case in the container to compare the ints differently. The booleans are really subclass of ints problem has actually been more problematic for me. 
I have used the app &amp; can tell you without a doubt that this is not the way to go. 
I wrote a system that does things like this last year. It does a lot more, too - it's a whole, powerful tree system with lots abilities. I've wanted to open source it, but I'm still fighting through red tape at my company.
I wouldn't say terrible. You can't name a variable `print` or `not`, or a ton of other things. Those are reserved keywords. These are just reserved keys.
But dictionary keys often come from foreign sources which is a totally different ballpark than just my personal name choices as a programmer. Say I make an ajax request from a foreign API and get an invalid field, now what? Do I have to check for collisions for every name? This is why [javascript 6 is has a Map object](http://wiki.ecmascript.org/doku.php?id=harmony:simple_maps_and_sets), and dot-notation is not going to work with it. 
No, you should use d = rdict(), d['a']['b']['c'], your link is describing the same thing with def instead of lambda.
Good god. `syntastic` and `ctags` is all I need.
1. Exactly. Not putting it to `__init__` is a small optimization to make a conversion in a lazy way - may help if you are loading big config files and accessing only one single attribute down the tree. 2. Nice! Good to learn something new. This way it looks much more straight-forwad. Still need to convert dicts to DDD to make `d = DDD({"a": {"b": 1}}); d.a.b.c = 2` work properly.
Flask is pretty cool - http://flask.pocoo.org/ I've never actually used it in anything substantial, but it's nice in its simplicity. It also has a great tutorial. 
FWIW (regarding your substantial comment), i'm serving about 100M requests via Flask a month, it works really well (nginx+uwsgi)
not at all, i was just saying :) just want anyone reading to know who might think that because flask is a "micro framework" doesn't mean you can't pump out big/substantial things with it. too may people lumber themselves with bigger frameworks for little reason (IMO)
I understand you, I prefer minimalism too in certain situations. But I think I couldn't live without some awesome plugins like Fugitive.
If I may, http://www.b-list.org/weblog/2013/apr/05/good-tools/
http://i.imgur.com/K8KibMZ.png I kind of like having a python shell in my mvim
I don't think it would be worth $70, but it's an unlimited free "trial," so as long as you're ok with clicking "not now" on a dialog box every once in awhile it doesn't actually cost anything
The commenter I responded to cowardly deleted their comment. They linked to [this blog article](http://delvarworld.github.io/blog/2013/03/16/just-use-sublime-text). What follows is my response. &gt; For the first 1-2 years of your Vim usage you will be much less efficient than your current editor because of the odd yet lovable key bindings. Not for me. I was back to being a productive member of society within a few weeks. Muscle memory adapts quicker than you think. I agree that there is a really really sharp curve when you first begin Vim, but it's not 1-2 years worth. Certainly, you won't have mastered vim in a few weeks. That will take years. But it isn't hard to get productive in a few weeks. &gt; followed by knowing some cool tricks that you use in 1% of your daily workflow. 1%? If you aren't taking advantage of Vim's features, then obviously it isn't the tool for you. Why does that even need to be said? &gt; The argument that Vim is more efficient is dubious and untestable. Reaching for a mouse may indeed slow you down, but developers are commonly on machines where the trackpad is a micro-hand movement away. Most novice programmers can click on a character on screen faster than an expert Vimmer can type 20jFp; or LkEEE or /word&lt;cr&gt; or any other nasty way Vimmers have to use because of our archaic, ingrained keystrokes. What kind of bullshit is that? I don't care if **you** can be faster with a mouse than I am with a keyboard. I care if **I'm** faster on a keyboard than I am with a mouse. And I am. That's just the way it is. I certainly don't develop on a machine with a trackpad that is a "micro-hand movement" away though. &gt; Plugins are essential to make Vim usable. If you believe that, then yeah, just use Sublime or whatever. But I don't believe it. I hardly have any plugins installed. Actually, the only few that I have are managed by my system's package manager, so there's no need for a `vim` package manager. &gt; Ah, Vimscript. Itâ€™s bad. ... But even Vimmers donâ€™t want to learn Vimscript. For once we agree. I've heard that the Python support has increased dramatically recently though. Haven't investigated much yet. &gt; Vim is missing an incredible amount of core functionality for modern editing. Things like ctag integration, project management, project browsing, (yes I know about :Sex), and many other basic things, are completely absent in Vim. What the fuck? `ctag` integration works out of the box. And I use a little something called *directories* for "project management and browsing." &gt; Vim can in theory edit any language because of its extinsibility power, although it will have a very hard time with IDE-languages like Java or Scala. Um. Yeah. Because they are ***IDE*** languages. Vim isn't an IDE. &gt; Now we need to find files. Letâ€™s use Vimgrep! Or, umm, just use `grep`. &gt; Do you know what the suggested way to work well with multiple files in Vim is? Itâ€™s the arglist. Most of my experienced Vim friends donâ€™t use the arglist nor know what it is. Itâ€™s a clunky system for populating a special internal list of Vim with multiple files. I get the feeling that the author hates the command line. Vim's `arglist` is just a list of files it was opened with. That's it. It's not archaic or mysterious. If you want to edit multiple files, you can do that straight from the command line or open new buffers. &gt; Here in the future, we have these things called GUIs. Theyâ€™re super nice! They look good, are usable, and give useful visual metaphors for things. And we logically and reasonably expect our editors running on GUIs to offer the same benefits. Ah, the truth comes out. Well, yeah. If you can't bear working on the command line, then why is Vim even considered a tool in the box? Sure, learn a little so you can edit on servers and use your precious beautiful GUIs every where else. &gt; Donâ€™t believe me? Paste this into an empty buffer: [implying that indenting is bad] Why are you relying on your editor to automatically know how to pretty print every language? Use the right tool for the job. e.g., `ggVG:!html-prettify&lt;CR&gt;`. Done. &gt; *To code in Vim, you have to keep Vim in your head just as much as the code that youâ€™re editing. You have to constantly think about what youâ€™re doing. Strongly disagree. Vim blends right into the background for me. But I'm not afraid of the command line either. That entire blog post is about someone with an extreme aversion to the command line and an affinity for pretty interfaces complaining about Vim. Obivously if Vim doesn't suit your philosophy then you shouldn't use it. You don't need to post a long rant to say that.
`$ vimtutor`
OK, maybe not the weapon. Maybe like the sheath. Or the hilt. 
Oh the irony! The author whinges and whines about things, many of which are clearly wrong, and tells everyone else to use ST, *and then uses Vim to write his blogpost because ST is not good enough* I think that sums up the situation perfectly; Vim has a few warts, but at the end of the day its what gets the job done fast and right &amp; experiments with other editors generally always result in falling back to what works - Vim. 
A fighter's brain is his weapon as well, but that doesn't make his sword any less of his weapon.
I paid. That pop up box is not just every once in a while. It comes up a LOT
Sublime text is a tool, if you are using it every day to develop code then what makes it not worth $70? If you are using it for work, they will probably be happy to spend $70 on a tool if it makes you happier or more productive. (disclaimer: I'm a vim user)
For $70 you too can be a pretentious brat who likes to think they're cool because they use ST instead of &lt;insert battle-tested software here&gt; I track it out of morbid curiosity. The configuration system is possibly the worst I've ever seen in any related software, this includes Eclipse with PyDev. The developers have made zero effort on this front across 3 major versions. By default it uses the remarkably nauseating Windows Notepad keybindings - hammer keys until you get RSI to do what are common simple movement tasks in Vim. e.g. Move to the beginning of the word: Vim - b (for 'b'eginning) ST - hammer arrow key until you reach the beginning of the word. Hammer the opposite direction if you go too far. Repeat until you get to the place you want to be at. Move to the end of the word: Vim - e (for 'e'nd) ST - Hammer the arrow key until you reach the end of the word. Hammer the opposite direction if you go too far. Repeat until you get to the place you want to be at. Move to the end of the line: Vim - $ (following the commonplace regexp syntax for end) ST - Hammer the arrow key like it killed your dog. If you fall off the end of the line, press up arrow and then hammer for two, three, maybe six times as long as you originally needed. Slow down and be careful not to fall off the end this time. Oh, whoops! Repeat until you're at the place you wanted to be. Move down 142 lines: Vim - 142j ST - Press the down arrow key, count 'one' verbally. Repeat 141 more times, incrementing your verbally-labelled number each time. Stop when you reach 142. If you get interrupted and lose your place... sucks to be you. Forget more advanced stuff like searching for or inserting text, ST can't even get the basics right. There's a plugin for ST that gives some Vi-like keybindings; like every such attempt in every editor that has attempted this emulation, its a hideously slow afterthought that feels very unintuitive in the ST application. 
Django has supported Python 3 since Febuary: https://docs.djangoproject.com/en/dev/releases/1.5/. Third-party library support is still patchy though.
I'll take a look at this. Currently, I use [sontek's setup](http://sontek.net/blog/detail/turning-vim-into-a-modern-python-ide) and I like it a lot.
This is great! I love the textobjects and multicursor. One of the under-mentioned things in the readme is rope. I can't rave enough about it in general, but specifically the fact that it can do intelligent completion and jump to the definition of something (even if it's in a different file or at the end of a variable assignment) pretty much obviates the need for an IDE for me. So far I've been using this: https://github.com/spf13/spf13-vim and I like it. I might have to take a peek at this soon.
I use quite a few plugins: YouCompleteMe + syntastic is awesome. Ctrl-P is really useful. Surround is darn handy. UltiSnips can be customized for good, but the default snippets suck. Edit: Oh, and MiniBufExplorer is awesome!
It's weird that you give a list comprehension as an example of imperative-style code. List comprehensions are derived from set-builder notation and first rose to prominence in functional languages. Idiomatic haskell usually frowns upon explicit recursion, in favour of folds. If I were to reimplement haskell's `length` it would look more like this: length' = foldr (const (+1)) 0 The equivalent python code is not subject to a recursion limit and performs much better than your example: def my_len(xs): return functools.reduce(lambda a, b: a+1, xs, 0) Python isn't a functional language, but it's not hard to write good clean functional-style code in python.
Suprisingly enough `nethack` teaches you a lot about how to move around in vim.
That Unite plugin is the bomb. Bram needs to consider adding this in by default, much like netrw was included in ages past. Thanks [/u/joedicastro](http://www.reddit.com/user/joedicastro), this is really great stuff! I need to reconsider my own vimrc now. 
&gt;Move to the beginning of the word: Ctrl+Left Arrow &gt;Move to the end of the word: Ctrl+Right Arrow &gt;Move to the end of the line: End &gt;Move down 142 lines: Do mental math to figure out the line number, then use the scroll wheel With the exception of the last one, these are pretty standard commands that don't require studying pages of them to learn.
Nah, I think it fits. Some warriors use very advanced weapon systems to kill a man half a world away, but they need other warriors in the room to defend them from wrestlers. An IDE is pretty much a force multiplier, which is what a weapon is.
You're fairly obviously exaggerating and doing it wrong.
gUnicorn in place of Nginx? I thought it would be more gUnicorn in place of uWSGI in the Nginx + uWSGI. Pretty sure Nginx is still better at serving static files.
Good lord, man. That's like driving an Aston Martin to get groceries, it works and you look damn cool doing it, but it's excessive and looks a little bit like your compensating...
&gt; The equivalent python code is not subject to a recursion limit and performs much better than your example: In [2]: timeit.repeat("my_len(xrange(10000))", setup = "import functools\nmy_len = lambda xs: functools.reduce(lambda a,b: a+1, xs,0)", repeat=3, number=1000) Out[2]: [0.7231879234313965, 0.7012350559234619, 0.6973469257354736] In [4]: timeit.repeat("my_len(xrange(10000))", setup = "def my_len(xs):\n i = 0\n for x in xs:\n i += 1\n return i", repeat=3, number=1000) Out[4]: [0.3004319667816162, 0.28862500190734863, 0.2902050018310547] On my python 2.7.3 default, I'm getting the iterative pattern is about 2.4 times faster. Again benchmarks can lie, but that was my first test so I disagree that functional performs much better (granted yes its much better than my recursive pattern as python's syntax/design doesn't allow for good tail call optimization). Agree, calling list comprehension 'iterative' was a poor choice. But python BDFL clearly likes list/generator comprehensions and isn't a big fan of reduce (demotion to a library in python3). That said, I do use map/filter a lot in my code as often that's how I think about it, and even if its more verbose I think `map(some_function, some_list)` is clearer than `[some_function(x) for x in some_list]`. I just recognize its not particularly pythonic.
My team switched from TurboGears to Flask recently to support a redesign effort. It's been awesome. Things that took days are now fairly straightforward and quickly implemented. Really, however, most WSGI frameworks are pretty interchangeable - you just need to look at the community as well as what the near-to-medium term version of your site will look like. Then, choose the framework which offers most of those out of the box with the smallest footprint and don't look back.
For $70 you can support another programmer who wrote something that a lot of people like. do you get paid for your code?
Sublime started to be a compelling editor for me when I installed the plugin for vim keybindings. But.. (and from the comments this makes me odd) yeah, I use both every single day, because vim is on every headless server I use.
Yeah, sorry. Ambiguous statement. By "your example" I was referring to the functional one. I actually think comprehensions are more readable than calls to `map` and `filter` and tend to prefer them. Ironically, `reduce` is the only function in that "group" that can't simply be replaced by a comprehension. If I were the BDSL I would have kept `reduce` and removed `map` and `filter`, what with the "one obvious way to do it" thing and all.
What app? You can do anything quickly and easily with a webapp. Java is a pain, takes tons of lines of code and dev time compared to some short ssimple python or something
woah, never noticed that.
(Disclaimer: I'm an Spyder dev) I think you haven't used Spyder at all. `from blah import *` is only used in our interactive Python console and works almost the same as `ipython --pylab`. This doesn't mean we use it in Spyder source code.
You can use any interpreter you want
Good to hear =) In all fairness, this and a few other posts have made me want to give it another shot. The last time I used it was about 3 years ago, so imagine it's gotten a lot better. I'll probably give it a whirl when I'm back from vacation.
&gt; For $70 you too can be a pretentious brat who likes to think they're cool because they use ST instead of &lt;insert battle-tested software here&gt; Whoa there. Who is the pretentious one acting like a brat about their choice of text editor? Some people just like Sublime Text. Why that makes them a pretentious brat is beyond me.
*"A fighter's brain is his weapon as well"* Good point. The programming language is his weapon then.
I would pay you money (or in gum) if you could write up a simple tutorial on how to replicate your environment.
Good god man, read the docs! [andrew@Liger ~] bpython --help Usage: bpython [options] [file [args]] NOTE: If bpython sees an argument it does not know, execution falls back to the regular Python interpreter. Options: -h, --help show this help message and exit --config=CONFIG Use CONFIG instead of default config file. -i, --interactive Drop to bpython shell after running file instead of exiting. -q, --quiet Don't flush the output to stdout. -V, --version Print version and exit. And here you are: bpython -q
No, there's just too much. I can't handle it. (I actually thought someone was going to tell me to pipe it to `/dev/null`) Lately it's been buggy, though, printing lines multiple times, obscuring lines I've typed over. I've also many times had it fold up and quit on me. Maybe I'm coding too hard.
Not sure what to say. I've never had a single problem with it. It's always worked beautifully for years. What version are you using? And which terminal emulator?
If you're going to make a comparison with Sublime's shortcut keys, at least learn how to use it first. You're not making Sublime look bad - you're only making yourself look bad. Every single one of the sublime keys you mentioned has a much better way to accomplish. &gt; Forget more advanced stuff like searching for Ctrl + F &gt; or inserting text Just type! Don't even need to worry about "modes".
&gt; It doesn't require configuring a bunch of plugins for each language you program in. If I open a PHP file after working on a C file it changes the way the text is highlighted/colored without needing me to do anything. You're being a little misleading here. Vim requires you to enable one plugin (which comes included), and it will do this out of the box. &gt; For any additional functionality you need you can install package control. Then, Cmd + Shift + P -&gt; Install Package. You can install a linter and code-intel this way relatively easily, among other plug-ins. Every `vim` plugin I have is installed with my system's package manager. Even better. The fewer package managers operating on my system, the better. &gt; With Vim it's more difficult to set it up the way you want--at least the last time I did it. The usual procedure is to * Google for Vim feature. * Find a snippet to put in your `.vimrc` * Save `.vimrc` with snippet and forget-about-it. Maybe add a comment so you don't forget what it was for. I don't think that's very laborious. And it's simple to transfer between workstations. In every editor I've ever used, I have to go through the same procedure, since the option is buried in a menu or an option dialog somewhere. Note that I'm not trying to say your preferences are wrong. But I am trying to point out that you're making it seem like Vim is crappier than it is.
Ah. That makes a lot of sense. Sounds interesting!
I never implied other text editors didn't do that. Basically, for me Sublime gives me a nice UI with nice features. Some of them I described.
I bind it to Leader T, I opens a buffer with a new she'll whenever I toggle it. It's pretty nice
Values * https://en.wikipedia.org/wiki/Principle_of_least_privilege * https://en.wikipedia.org/wiki/Information_hiding#See_also * https://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming) Docs * http://docs.python.org/3/reference/executionmodel.html#naming-and-binding * http://docs.python.org/3/reference/datamodel.html#invoking-descriptors * http://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces * [`@property`](http://docs.python.org/3/library/functions.html#property) * [`@cached_property`](http://wiki.python.org/moin/PythonDecoratorLibrary#Cached_Properties) 
&gt; however if I find myself using multiple nested dictionaries I begin to wonder if there is a better data structure I can use. What are some better data structures to use instead? There are times I find myself using somewhat-heavily nested dicts, but I'm not really sure if there are decent alternatives in those cases.
I really like CherryPy for small projects.
I made something similar to this a little while back for configuration files at work. Besides being a good introduction to \_\_magic__ methods, it made working with our deeply nested configuration settings a lot easier. One thing that you may find useful is implementing \_\_add__ and \_\_radd__ methods. The way we our config files are set up at work we have default configuration files, but allow user configuration files to overload specific settings. In these circumstances didn't work because it would overwrite dictionaries stored as items, instead of merging their keys where possible. e.g.: default = { 'db': { 'username': 'default_user', 'password': 'default_password', 'host': 'localhost', 'port': 'port', }, } user = { 'db': { 'username': 'my_user', 'password': 'my_password', }, } &gt;&gt;&gt;default + user { 'db': { 'username': 'my_user', 'password': 'my_password', 'host': 'localhost', 'port': 'port', }, } 
Thanks for sharing! I am new to python and hadn't heard of this.
Great idea! Thanks!
You're correct, gunicorn is just WSGI server, it's not meant to face the outside world. And that said uWSGI is pretty much _the_ application server nowadays with the exception of node for javascript. uWSGI + Nginx is a fast, easy to configure, and scalable stack for pretty much any language nowadays.
...are shit. At least in 2.x. This won't work: i = 0 def increment_i(): i = i + 1 return i Write this instead: i = [0] def increment_i(): i[0] = i[0] + 1 return i[0] 
I think that the combination of Tmux/Vimux and IPython (or Bpython if you prefer) is more powerful than that approach. I used Conque Shell in the past too, and has its gaps.
Yeah, all the plugins of [Shougo](https://github.com/Shougo) are awesome! and Unite is a real game-changer.
No, you're right, I'm compensating (like I wrote in the article)... the memory faults! If you work so hard in a vim setup, and you don't remember all that you have available... is time wasted or not? The doc and the config (Unite menus) are made with this purpose in mind, find what you need to use when you need it! You know, I wish Unite were a Vim Vanilla default. Imagine Unite menus as a Debian menu, and all the plugins should add his options as an entry in those menus by categories. If you could add the custom mappings to that entries, that will be like Heaven to find what you need when you nedeed! Memory is imperfect, and remember all that Vim &amp; plugins brings to you is impossible, that will be a nice solution for any config. 
I've done most of my python web work using a custom framework, apart from a year or so using Django. I recently had a play with a few frameworks to see what I was missing (or not!), based on that, my take is: *Django*: The ORM is very weak for reporting (those things managers love). The template engine is slow compared to others but that might or might not matter. Large community. *Flask*: I tried this with SQLAlchemy and Jinja2. Its nice. I'd have think about how I'd structure a large application. *WebPy*: A bit too basic for my taste, but for simpler sites its batteries-included template engine and DB interface makes sense. *Pyramid*: As for *flask*, with SQLAlchemy and Jinja2, and much the same conclusions. I think *flask* wins on the decorator-based routing. *TurboGears*: Too much magic command stuff. I gave up, it felt like a black box, and I like to know what is going on. *Rails*: Not python! Same problem as *turbogears* *Web2Py*: Even more magic. Overall, I'd go for Flask. 
I always feel like such a fool not using Vi or emacs, as if I am not l33t worthy. I used gEdit and TextWrangler, I love colour. Pico and Nano when not on my machine (and that's only ever changing something minor). What am I missing? I know people who I respect highly and people I don't respect at all rave about Vi(m). Sell it to me. EDIT: I love my mouse too.
Vim has a unique way with two great advantages: 1) You can do all with your keyboard. Maybe you love your mouse, but I don't think that you love so much the time lost changing between keyboard and mice. And I think that you should hate the [Carpal Tunnel Syndrome](http://en.wikipedia.org/wiki/Carpal_tunnel_syndrome) that sooner or later appears thanks to that little rodent (I saddly know that this is very true, and I was able to fix it at time). 2) With the Vim moves and text objects you can move/edit/find/select/... the text area you wanted without thinking too much and with the minimum effort. Compared with other editors is like using a laser to focus versus a flashlight, Do you want to be a text surgeon or a coroner? :)
Oh, emacs is great, wonderful! My dream editor is a Vim with a complete Emacs Org-mode. So, thanks, I take it like an accomplishment :)
wow your screenshot is awesome. Makes me want to change all my settings again... haha!
Start with the vimtutor and use a plugin or config that don't let you use the mouse or the direction arrows to force you to learn the right way. Takes a little time, but before you realize is a natural way for you, without think too much, becomes mechanical. If you reach this point, the rest is all searching for more and have fun! I was a Excel wizz too, time ago, now I don't use it too much :)
Don't get too caught up in the hype. Everybody hypes their own stuff. I still have customers who refuse to move from wordstar ( don't worry if you don't recognize that editor. All it shows is that i am from a different generation :-( Vi, and it's evolutionary cousin vim, are really old editors with some interesting ideas bolted on partially in response to constraints like no mouse being available, programmers being the main user base etc. You should focus on editors which you feel is good for you, which you enjoy, which you can easily customize etc. And respect people for what they have done. The editors they are most comfortable with has nothing to do with their productivity.
What, no wombat? sheesh
&gt; from wordstar Just reading up on Wordstar - makes sense, I am moving from word processors to text only with appropriate markup so I can concentrate on writing. 
Nope. That's his fighting style. The tool is the weapon. Our tool is the IDE.
Git is not a metric for competence ;)
Its not clear if this setup does code analysis like Esclipse PyDev or Kdevelop (kdev-python) do.
Is there some sort of forumla you're trying to apply? There's no library (that I know of) for calculating areas and intersections of surfaces, but there's a full scientific stack that can be put to uses such as these. You'd just need a formula. Edit: would something like [this](http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon) cover it?
Do you mean using pylint like PyDev (I used it for a long time)? Then yes, it uses pylint via pymode and syntastic
I tried a large suite of Vim plugins once -- similar to OP. It wasn't long before I found incompatibilities between them, updates and discontinued plugins, dead repositories, endless bugs from one plugin to the next... It was worse than trying to configure a window manager from scratch.
Oh, I knew, the fault is mine, I forget to continue the joke :) But you comment opened me an opportunity to explain my point of view and I took it! :)
text objects
Iâ€™ll be there, FWIW.
The application he's talking about porting to python. He includes the link in this thread. It's just not the type of software that works well as a webapp. Go to the link, use the software for a day or two &amp; then tell us whether you still thing a webapp is the way to go.
&gt; tm = TempMail(login='denis', domain='@gnail.pw') Domain names don't have @ symbols last time I checked. I guess men can't code.
web2py is the best!
I found https://github.com/sloria/cookiecutter-flask is a great basic Flask package. 
Hmm. It has less functionality than [Kodos](http://kodos.sourceforge.net/), my current favourite. 
Wow you are absolutely right, I must have been way to tired when I read your comment.
I think this changes on a case by case scenario. Trees can be a better alternative, also (while not a different data structure) sometimes using tuples for dictionary keys can help reduce depth. For example, I might need to see if any sequential subset of words in a sentence is a match for a list of phrases I will typically use a [trie](http://en.wikipedia.org/wiki/Trie) (whose nodes are words). The tricky thing here is that since python doesn't have any built-in tree representation I will sometimes use a dictionary. However I make sure to make several helper functions (`create_trie`, `find_match`, `add_phrase`, etc..) so I don't have to directly interact with the trie/dictionary itself.
Time to update... You're using a version that is ~4 years old. I'm on `0.12`.
can you explain the sanitize and valid chars part? I have a scraper that doesnt download image, but im trying to make it skip anything that isnt an imgur and i cant find a way to do it without being stuck in a n infinite loop
can you post the code you are trying to run? maybe on pastebin.com ?
I know it's older but [Bottle](http://bottlepy.org/docs/dev/) makes many fewer assumptions, and simply does what I expect. I remember having a hell of a time trying to set up a JSON API with Flask because it tries to be clever about handling the request body. See [this SO question](http://stackoverflow.com/questions/10999990/get-raw-post-body). Depending on the request headers sent by the client, the request body might be in one of several different locations. I don't like software making assumptions for me! In Bottle it's just `request.body`. Always.
Whats your server specs? Also this 100M request, is it mainly because off flask or because of nginx? If your apps runs in apache is it still served 100M per month? Now don't get me wrong, I love flask (and bottle) and use them quite often. 
Bottle sucks. No one uses it.
Yes, but which is easier to unit test?
Just check the domain, if it doesn't end with imgur.com then move on to the next post.
Fair enough, fair enough!
If you can calculate the area once then you can do it n times. You are probably failing to properly clean up an object between loop iterations thus resulting in a crash on the next iteration. We need some code or you need to elaborate a bit more for us to help you. 
Running on a bunch of boxes on ec2 (usually m1.mediums), but i'm not sure i understand the rest of your questions. apache isn't involved at all anywhere in the stack
"Sanitize" just turns the title of the post into a valid base filename to it can be saved on your computer without having invalid symbols (\*&amp;\^%$#@ etc.) in the filename. Like \_Daimon_ said, if you want to check for imgur, you need to check the domain in the URL.
I used it. Still think it'd work nicely as a webapp but that said I'm very familiar with that process ( I'm talking about LOCAL app, check out google refine for a good example) That being said another good cross platform python option is Kivy. Very easy to develop with, GUI is simple, write once package for anywhere ( including mobile, OSX, windows, linux etc).
Here you go [Vimium](https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=en)
I look forward to trying out some of the alternatives thrown out in these comments. So far I like using plumbum the most for this stuff, and for other stuff. I also like the simplicity of argh.
But they do give you a t-shirt to wipe your chin with (maybe?), so there's that.
That's about ~40 req/sec. Usually the frameworks (all of them) add very little overhead (of the order of 1-5ms/req). The bottle neck is always DB IO (&gt;10-50ms/req). With good design (caching and indices) once can handle 40req/sec with one server without too much trouble with any framework (not counting static files, static files should not go through the framework at all). 
Imagine I am creating my own set class that will work for any type of object. For this particular set class I don't want to deeply inspect the objects. I want a set of unique object references. You would expect that Set([1,1,2]) would return a set with 1,1,2 in it. Where the ones are separate objects. But instead the set will incorrectly contain 1,2. Because the 1s actually point to the same object even though they were instantiated separately. Even more strangely using the same code Set([1000,1000,2]) will return a set with 1000,1000,2. Which is totally different from the result of Set([1,1,2]) even though they look exactly the same. The cause is small integers not actually being instantiated every time you write them in the code unlike large integers. Unlike larger integers you end up with a reference to a singleton class for that number. Only None,True,and False work this way in python and it happens implicitly instead of explicitly. C99 bools are actually ints like in python. But this makes no sense for a high level language. Zeroness and Oneness have very little to do with truthyness from a mathematical perspective. The reason they are the same in C is because that is how the hardware works. But python is supposed to be a high level language. 
Perhaps a metric for commitment to the craft.
how many people are going to point this at /r/gonewild?
This should be implemented in javascript and forms rigged to nag the user that posts negative comments :)
Yeah, that makes sense. The kind of data I'm storing is more like the kind of information you'd store in a database though; information you'd later want to present to an API consumer or to a template. Web application stuff, for the most part.
Thank you :)
I meant git as competence with DVCSs. Any programmer should be proficient with at least one DVCS.
The apache part was, I think, trying to ascertain whether the proxying server (nginx in your case) was a limiting factor. I'd assume not, though.
I like the new Zope 3 release, http://ZTFY.org and http://wiki.ztfy.org. 
I personally prefer Mercurial but started to learn Git just for fun. (and 'cause of github of course)
Fixed it -- in the save file, the open is "w" but, and probably a windows specific issue, need to save as binary "wb". I've posted it. 
umm, this is a post by the maintainers. pretty sure that's not what "blogspam" means
Ok, now try twitter, since that's where most sentiment analysis is currently being applied. I believe the current state of the art is something like 60% accuracy on tweets. EDIT: [Example](http://neiljamesdigital.com/automated-sentiment-analysis-for-suckers/)
It was just a matter of time before running into Python 2's encoding warts. This turned out to be a bug with TextBlob, which I happen to be the author of. I just released a new version (0.5.3) that fixes this issue. pip install -U tbpaste or pip install -U textblob will do the trick.
That it doesn't work well in one place (whether because the theory or implementation or both are bad) doesn't mean that the whole idea sucks
&gt; I remember having a hell of a time trying to set up a JSON API with Flask because it tries to be clever about handling the request body. Just for the record, the default parsing behavior can be changed without jumping through hoops. In recent Werkzeug versions you can just do `request.get_data(parse_form_data=False)` and you get the data as a binary string, no matter the content type. &gt; In Bottle it's just request.body. Always. Which is potentially dangerous though but you can accomplish the same in Flask if you want.
You need to compare that accuracy against human rates. You can't assume that 100% will ever be reachable. Less text makes it a genuinely harder task. For many IR/text tasks, humans aren't as great as you'd think, nor can they agree with each other, making labelling data difficult.
But however bad humans are at it, machines are much, much worse. 100% is probablyl not reachable, but 60% isn't something I would want to put into my production app.
&gt; Zope 2 made a massive come-back I seriously can't tell if you're joking or not, especially as the website says this &gt;Zope 2 is a legacy framework, which is kept alive to support existing applications built on top of it. It is no longer recommended to start new projects based on it, unless you are intimately familiar with the technology stack.
Oh, neat. I had no idea there's such an easy way to use sentiment analysis. How good is the builtin model? A few weeks ago I played around with Apache's OpenNLP (although in Clojure), and I had to train the model first -- not that user-friendly. On a side note: The translation feature may be a security risk. You normally don't want your clipboard to be sent to a web service (Google Translate in this case).
I've built professional products with CherryPy and it worked out well, serious downside was the lack of documentation, especially for the more complex parts of its routing system.
Perhaps, but I'm picking at your example (which states 70%, and claims humans *are* 100%). Human accuracy (or really, stability between human judges) is around 82%, or 90% at most (ignoring cases where humans were unsure, which we *shouldn't*) [paper](http://people.cs.pitt.edu/~wiebe/pubs/papers/emnlp05polarity.pdf) Note that that doesn't mean machines are 70% of the 82% accuracy of humans, it means the machines agree 70% with a human, and humans agree with humans 82% of the time. Futhermore, neutrality is useless, such cases should either be ignored, or thrown in one of the other two categories (so we measure one of positivity or negativity, but not both) Moreover, humans suck at choosing between many rating scores, like 1-5 ranges, and binary scores are more stable. Ignoring neutrality as a possibility reduces the size of errors. Also, the likelihood of all the error being in a single class is incredibly unlikely (especially if we don't weight our classifier) If we have two classes, and only care about the proportion then some errors will cancel out. Not to mention that tweets are a horrible worst-case scenario of document length, and frankly, there's unlikely to be much of anything worth knowing in a tweet.
The point is you're doing odd things and have odd logic that relies on attributes being there on a given object. That's not a good design. If things are optional, use a dictionary, or make the attribute on the object None (or whatever default value you want) to begin with.
You're sort of undermining yourself here. If humans only have 82% to 90% accuracy, and machines only agree with human evaluations 70% of the time, then veridical machine accuracy is around 57%, or 63% at most. p(h) = .82 to .9 p(m|h) = .7 p(m) = p(m|h)p(h) = .57 to .63 And discrediting tweets as a "worst case scenario" belies your ignorance of where this technology is being applied. Nearly *every single instance* I come across of people talking about applying sentiment analysis, it's on twitter streams. In fact, off the top of my head, I actually can't think of any other domain in which people are actually purporting do anything with sentiment analysis in commercial applications.
Ever use a decorator that adds a function attribute? You may very well believe decorators and function attributes are bad code. That's just one example. 
How often do you need to catch AttributeError? It seems like whenever I get an AttributeError it's a bug in my code so I end up fixing the bug instead of adding a catch.
Well. I write a test framework that uses function attributes through decorators. I also getattr to check if a module have special named fixture functions defined. I doubt I'm a typical Python dev though. But, is there a typical dev?
&gt; I also getayyr to check if a module have special named fixture functions defined. Why would you use `getattr` there instead of `hasattr`?
You're right that it's rare. Sometimes when you're metaprogramming though, you need to be able to do these kinds of things. It's easier to do duck-typing when you can just willy-nilly check for attributes that may or may not exist depending on which type of object has been passed into your function. You might want to behave one way for one object, and behave another way for another object, but instead of hard-coding ugly type checks (which are frowned upon in python), you just use getattr. If the attribute is there, it works, if not, you move on. done.
Yes, it is a little surreal that this article's author knew about gettattr but not dict.get. In fact i find it surprising that anybody can program python for more than 10 minutes and not learn about dict.get.
&gt; If humans only have 82% to 90% accuracy, You've misunderstood what that means. There is *NO* measure of 100% accuracy. All judgements of sentiment come from human judges! It's really humans agree with other humans 82% of the time, and the machine accuracy is machines agree with humans 70% of the time. It's really: p(h_2|h_1) = .82 p(m |h_1) = .7 &gt; I actually can't think of any other domain in which people are actually purporting do anything with sentiment analysis in commercial applications. Customer reviews is a big one. I remember it being used to get scores for reviews that refuse to score things.
I work at a company that does sentiment analysis for enterprise. I'm on the data science team, and we regularly run experiments to measure the quality of our NLP engine. On English, we regularly run 85%+ precision (depending on the searchterm/brand of interest) on positive and negative sentences (on Twitter) with &gt;30% recall (depending on brand, again). We get comparisons and other "difficult" kinds of sentences correct, thanks some deeper parsing/chunking algos.
Like /u/ilogik says, it'd be best if you posted your code. Are you using a stand-alone arcpy script, or Python expressions within Field Calculator? FC is notoriously buggy, so it's possible you're not actually doing anything wrong (again, we can't tell for sure without seeing what you're trying to run). Also, you might have more luck xposting to /r/gis, /r/askgis, and/or /r/GISscripts.
&gt; I don't see an attack vector or likelihood of error here: For instance I can exhaust resources by sending a well compressed string against your server that expands into a heavily nested json object. This is currently not a feasible attack against WSGI as WSGI does not support request filtering but I'm trying to get support for gzip compressed request entity bodies implemented. gunicorn+werkzeug and mod_wsgi+werkzeug already support it. In the process of doing that I am reworking most APIs to be safer against misuse.
What I'd be more interested in, is how to **elegantly** retrieve an object within nested dictionaries. So, something like dictionary.get() but it'd take a tuple of keys instead of simply a key. Something akin to: some_dict = {'a': {'b': {'c': 1 }}} some_dict.rget(('a', 'b', 'c'), None) # yields a value of 1 I pretty much end up rolling my own solution for this; anyone know what the most pythonic way of doing this is? I've seen a number of solutions like [this](http://stackoverflow.com/questions/15077973/how-can-i-access-a-deeply-nested-dictionary-using-tuples), but I sense there is likely a better way.
very useful libraries, thanks.
Changelogs and github compares for Django, Flask, and Pyramid: * https://docs.djangoproject.com/en/dev/releases/ * https://github.com/django/django/compare/1.4...1.5.2 * http://flask.pocoo.org/docs/changelog/ * https://github.com/mitsuhiko/flask/compare/0.9...0.10.1 * http://docs.pylonsproject.org/projects/pyramid/en/latest/changes.html * https://github.com/Pylons/pyramid/compare/1.3.3...1.4.3
I'm assuming he's referring to production support of python 3 and not 'experimental' support.
Just use [PRAW](https://github.com/praw-dev/praw) like OP, it makes everything a lot simpler. import praw r = praw.Reddit(YOUR_UNIQUE_AND_DESCRIPTIVE_USERAGENT_WHICH_CONTAINS_YOUR_USERNAME) subreddit_names = ['cats', 'python', 'snakes'] for subreddit_name in subreddit_names: print("Looking at the {} subreddit.".format(subreddit_name)) subreddit = r.get_subreddit(subreddit_name) for submission in subreddit.get_hot(): if submission.domain.endswith('imgur.com'): print("Hey that was a imgur link! {}".format(submission.short_link)) print("Jobs done!")
Quick, naive test: &gt; This is a good thing polarity: 0.7, subjectivity: 0.6 &gt; I hate this stupid thing polarity: -0.8, subjectivity: 0.95 &gt; I utterly love this very wonderful thing!!! polarity: 0.75, subjectivity: 0.8 &gt; The sky is blue polarity: 0.0, subjectivity: 0.1 Works reasonably well so far. Now the real test is to hook the library up with PRAW, get Reddit comments, analyze them and then compare the results with manual comparison, preferably with a reasonably large corpus of messages as doing this with only a dozen messages would be silly.
I made something similar some months ago : https://github.com/silenius/sautils/blob/master/serializers.py not totally finished but able to serialize objects and relations to json, xml, dict. For example: Serializer(myobj).json(include_columns=True, include_relations=['foo', 'bar'])
When you say Django's ORM is very weak for reporting, do you mean using the "native" data/object models for a given site? I certainly found it to be difficult to create data/object models that were simultaneously well-suited for production and reporting, but have had a lot of success separating those two roles and using Django's ORM to pull from a separate reporting database.
You should better use the [inspection API](http://docs.sqlalchemy.org/en/rel_0_8/core/inspection.html) of SQLAlchemy 0.8+. For example, an iterator over all columns and values for an object *spam* is given by inspect(*spam*).attrs.items() ... no magic required (anymore).
your set example is not a problem with bools, its a problem with the first (-200,200) being interned within python for small performance benefits. So with that logic, not only `None`, `True`, and `False` work that way, but all small integers. if you want to argue that bools shouldnt be a subclass of integers, you should read the [PEP](http://www.python.org/dev/peps/pep-0285/) and then email `python-dev` and argue with them, good luck.
Thanks wobsta - that function was written a couple of years ago with 0.7 in mind and I wasn't aware 0.8 had some goodies in that area. I've just updated the post.
You need to set OverWriteOutput = True. This is an env setting that will trigger arcpy to delete any existing data layers before creating the output for each tool. I recommend posting all GIS questions to gis.stackexchange.com.
Thanks for the support, you're right! I'm one of the maintainers. Keep us in contact!, soon we will be sharing other FLOSS projects :)
I think the subject matter is very interesting and important. And you should be commended for writing the book. That said, reading the article and browsing through the book, I think they both need a serious revision. My general comment is that in your writing, you probably assume readers are familiar with many things; this is a common mistake when the author is so involved in the subject for a long time. Because of that, there is a feeling that you pull lots of things out of your sleeve. Here is an example. Consider this sentence in your article, "Our goal is to find these unknown Î± and Î² parameters using the partial data we have." Next is a piece of Python code that is supposed to accomplish this goal: find these unknown parameters. But that piece of code is nearly a complete mystery! It is not clear how you actually attempted to find these parameters. In fact, you didn't even return your estimates of alpha and beta. Okay, you want to model lifetimes as Weibull. Got that. What are 2 and 5? And from that point forward, it's a complete mystery with arbitrary numbers. I think you really fail to explain a very important point of your article right there. I also think that readers shouldn't have to read the first 3 chapters of your book to understand the article. I understand why you might want to do that, but I think a better strategy is to make the article self-contained. If readers are mystified by your article, they are less likely to read your book. Additionally, I think you need to explain a little bit about the advantage of using PyMC; "a library performing Bayesian analysis" I think is too cryptic for beginners. This example is a great place to explain the goodness of having PyMC. I don't mean to give a negative review of this work. I'm writing this because I think your work is very promising. But at this point, I think the article/book is not very helpful to many people who want to learn more about Bayesian modeling. 
Very cool! One bug, though: the login is throwing a 502 Bad Gateway.
In ggrandparent you define PBV as "expression is evaluated, and the value it results in is assigned" In parent you say it's "assigning the argument expression" So which is it? 
[Nagare](http://www.naga.re/) and [Muntjac](http://www.muntiacus.org/) are both excellent IMHO. 
Is good question for weeding out fanatics, inexperienced (those who know so little they think this is an important point), and unassertive/unopinionated/unable to express themselves/deal with conflict peoples. The correct answer is. "I use whatever **your** coding standard defines. If you don't have standard, pushing to create one will be among my first tasks. I recommend spaces as that is what std lib and almost all Python code I've ever seen uses. But, the only inviolate rule is to not mix tabs and spaces."
Sorry about that, it's why we're still in beta ;) Can you please try clearing your cookies and logging in again?
This is on the todo list.
&gt; can you convert ascii characters to an integer without using built in methods like string.atoi or int()? &gt; ord() is a built in method. So no. I think you meant to ask Create dictionary of ascii -&gt; integer (decimal, hex, oct) value
[kiki](http://code.google.com/p/kiki-re/) is pretty cool too.
&gt; but all small integers. That was my entire point. &gt;you should read the PEP and then email python-dev Have read the PEP many times and have been arguing this for years already. What is sad reading the PEP is their rational is at least partially implementation convenience. But these are one of my few nit picks with python. Give me any other language and I have a much longer list of things not to like.
Yes, python is fantastic for this sort of thing. See http://lxml.de/
I tried again and it worked fine =) By the way, I just actually used it to debug a weird validation pattern on a web app I am working on, so, here's a real world use case for you, already! 
Wonderful, thanks.
and no keys with spaces in them either
Oh do me next, do me next: /u/shaggorama just got pwnd, old-school!
God I wish I had gold to give. I have struggled with understanding regex for like the last year and this makes it so much more clear.
&gt; "find the longest string of repeated characters in a string." Can you give an example of string?
I enjoyed the read, but I think some points were not convincingly argued. I'm familiar with the "global variables are evil" rhetoric, but in practice it is used often and effectively in scientific programming becuase there are common conventions followed by most researchers (e.g., use ALL CAPS and define them in the header file). Oftentimes the code is much cleaner and easier to read/edit without the additional syntax introduced by partial(). In addition, using global variables is somewhat of a universal approach in that the same approach can be used by many languages (C, Fortran, Matlab, etc.) for which functional programming tools are not available or commonly used, and the code base is more easily maintained by many researchers. Also, in this example, the multiprocessing module has some issues with using closures, but I wasn't convinced that partial() is necessarily better than using a closure in the more general case.
I was surprised to see via [this survey](http://www.reddit.com/r/linux/comments/1kjl85/a_small_survey_for_linux_users/) how many people were [using arch](https://chart.googleapis.com/chart?cht=p&amp;chs=345x150&amp;chl=Mint%20[361]|Ubuntu%20[966]|Debian%20[388]|Fedora%20[196]|openSUSE%20[64]|Manjaro%20[33]|Arch%20[798]|CrunchBang%20[110]|Puppy%20[1]|Gentoo%20[135]|Elementary%20[146]|Other%20[248]&amp;chco=9601ac&amp;chd=e%3AGsR7HNDoBMAnO0CCABCgCtEm). I'm not into popularity, but I've also suffered using things that have low momentum. This actually greatly increased my interest. I've been wondering if I shouldn't leave Ubuntu, at least for now (don't like Unity at all, hence 10.04), and have been confused about where to head next. I'll have to give arch a more serious look.
http://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-a-parser
Sounds like a good task to compare multiple languages.
I wasn't quite convinced either by the author's example. With that said, I'm using a library that [uses partial](https://github.com/Lawouach/headstock/blob/master/headstock/client.py#L171) to perform [dispatching to function](https://github.com/Lawouach/headstock/blob/master/headstock/client.py#L253) based on an incoming [stream message](https://github.com/Lawouach/headstock/blob/master/example/basic.py) (XMPP) and it's been quite efficient and elegant I believe. I could quite see myself using partial to abstract messages being passed on from process to process.
Something I picked up at a conference on testing: Tools don't champion themselves. If you go with Python then have at least one person who can champion the effort. I wish I could do it for you.
Hardly any learning or programming required. Python has a slew of libraries for XML parsing and querying: check out lxml, pyquery, BeautifulSoup. From what you are saying pyquery might be most appropriate for your project. 
This is great! I've been telling myself I should write pretty much this exact thing for ages. Guess you beat me to it!
Thanks! If you'd like to throw money our way (instead of reddit's), there will be a premium version coming very soon aimed at reducing the time spent writing them to almost 0 ;)
My gold problems are in both Reddit and reality :( I'm sorry. Perhaps at the end of next month I might be able to set aside 10 bucks... My truck needs repairs at the moment though and I am trying to resolve that issue right now lol.
Coming "very" soon? I suppose that's a step up from most python projects that just say "coming soon". Python 3 has been around for almost five years. Why has it taken them this long to support it?
Upvote for healthy self-criticism.
If you are using IDE when you write the input use "". Write your name: "IndolentSloth"
Why not just use 'wc'?
How about a PyPI release? :-)
`len(words_list)` is the preferred/idiomatic version of `words_list.__len__()`.
Ahh forgot this. I was relying on dir() and so of course len() didn't show up.
Not too long ago I was teaching my boys programming with Python. Plus I've only used Linux for couple if years. Didn't know wc was a Linux command. Thanks.
although it was many, many, years ago I do still recall that my teachers required that words be a minimum of 3 characters to be counted and transitional words such as "the, but, and" didn't count.... probably a difference in education systems. Updating your code to take that into consideration will make their projects harder, and benefit them more in the long run. ;) just a suggestion!
These may also be useful: * http://docs.python.org/dev/library/collections#collections.Counter * http://nltk.googlecode.com/svn/trunk/doc/api/nltk.probability-module.html * http://www.reddit.com/r/compsci/comments/1gpdb9/nlp_how_can_i_get_the_computer_to_understand_the/camicro * https://github.com/edx/discern * https://github.com/edx/ease
&gt; The kind of data I'm storing is more like the kind of information you'd store in a database though; information you'd later want to present to an API consumer or to a template. Web application stuff, for the most part. [fixture](http://farmdev.com/projects/fixture/) is good at this.
kiki and kodos are desktop projects, so they can't be compared to PyRegex IMO.
Backend and frontend are different beasts. The only viable option for frontend is JS because that's what browsers support. For backend you can happily use Python -- there are many decent frameworks.
 banned = set(['the', 'but', 'and']) sum(1 for w in words.split() if len(w) &gt;= 3 and w not in banned)
I recently went through the same thing and came to the conclusion that I had to bite the bullet and embrace js. Its not that I didn't know js- I have a fairly broad background, and had used plenty of js, but the current project is all Python (Pyramid even as the top poster recommends). I _really_ like Python especially when compared to JS. Bottom line though- all the various tricks to run python in browser are just tricks, and I wouldn't rely on it. As far as client/server communication, just have all output from Python be json- it works fine.
No, no, no. That's not pass by reference at all. That's just invoking a method on a parameter. It would only be pass-by-reference if you could cause the caller's variable to change by simple assignment: def f(x): x = 42 y = 0 f(y) Calling `f` cannot ever affect the value of `y`, which it would under pass-by-reference semantics, where `x` would be an alias to `y`. That is not the case, and Python is completely pass-by-value. You might want to read [this article](http://javadude.com/articles/passbyvalue.htm) which is about Java but it's the same issue. Modifying a value by invoking a method on it does not tell you anything about whether it was passed by value or reference. 
I see. Makes sense.
CoffeeScript is actually decent for that. It's fairly similar to JS, to the point that it's almost like a shiny JS pre-processor. Trying to replace it with a totally different language is just gonna be futile, though, unless it's something specifically designed for the browser like Dart or TypeScript (though these have not really gained popularity, and also aren't considered to be great alternatives by some people).
I'm not sure I understand the [US Currency example](http://i.imgur.com/vUCZbdX.png) In that specific one, the bottom line seems unnecessary? The only reason I can think of for such a split is to avoid a leading zero ($0,123.45), but this isn't even doing that since the top part is 0-9 and uses *, not +.
You will get a very rigid UX, just like with CGI back before this web2.0 craze. 
Both. In Python, assignment evaluates the expression and binds it to the target variable. I should've said "bound", not "assigned", in the first statement, to be clear. Sorry for the confusion.
No, you need to know other systems if you want to say "entire". As a minimum you'll probably need to know some form of DB query language (generally SQL), HTML/CSS (possibly a stretch to say in the same breath as the rest of these), JS, bash for doing minimal server work, and then a long tail of random stuff depending on what tools you use (ex. learning Perl to hack on Nagios). Embrace the polyglot.
You can't debug a webpage with Coffeescript. You still have to learn Javascript. It's not 'pure' at least in OP's definition.
Indeed. I just started a project using CoffeeScript, and it feels a lot like using the C preprocessor. It's so happy to write in!
Twisted provides event loop integration with Tkinter. http://twistedmatrix.com/documents/current/core/howto/choosing-reactor.html#auto16 Use the code snippet there and you can mix Tk calls and use of Twisted freely.
mochikit
For my work, we do the web server side in Python with flask and appengine/mongodb. Internally all data is JSON compatible (python dicts, mongodb and appengine give the same thing). REST is followed wherever applicable. Requests can ask for the response in JSON or HTML (and possibly CSV). If it is JSON then the underlying data is returned, and for HTML the same data is run through a Jinja template. This lets us do as much or as little in Javascript as we want. In some cases the page is originally generated as HTML and then bits of it are updated via JSON. We also have command line tools, and they request JSON. That also makes testing a lot easier.
Mochikit.Async: I Can't Believe It's Not Twisted!
JS and HTML are going to be unavoidable in a web app. For the rest, I use and recommend Web2Py. (Database, sessions, security, framework, services, AJAX handling, IDE, code control, Markmin, and an admin interface all in one. )
If you want to modify a global variable with assignment, you must state that intention by writing `global i`. If you do that, the first example works as expected. Your second version only avoids the issue by accident, because there is no longer any assignment to `i`. It's syntactic sugar around invoking a method on `i` (`i.__setitem__(0, i.__getitem__(0) + 1)`) and method invocation is not something that causes [name binding](http://docs.python.org/2/reference/executionmodel.html#naming-and-binding), unlike assignment. But there is no need for such nonsense. Again, if you want to modify a global variable with assignment you must say so explicitly. Python goes out of its way to discourage mutable global state. 
With that logic you could say that C is just a special syntax for assembly, Coffeescript is a language that happens to compile to JavaScript, but you could make it compile to other languages as well. To say that CoffeeScript isn't a language is just silly.
pyjs.org should be mentioned here
The best and probably easiest way i see to do it, at least for the internet part, would be to use the [DuckDuckGo Zero-Click Info API](https://duckduckgo.com/api) to quickly get an answer, and from then on use some text-to-speech like Festival or something to actually say it. This alone would get you covered on most use cases, maybe even eliminating the need for processing spreadsheets (by the way, think CSV, not Excel, just beware of the quirks of MSOffice for that, they use semicolons instead of commas). Also i'm assuming you give it the information via text, speech recognition on Linux is not quite there and not easy at all, although doable if you limit it to a very restricted set of orders for command-and-control. Plus i doubt the Pi has enough juice to recognize your voice, let alone do that plus all the other post-processing.
Check out [vaadin using python](https://vaadin.com/wiki/-/wiki/Main/Using%20Python).
Web2py lets you do python in templates. And works with mongodb. And wins awards. Try it out'
Here's another: [Pyjaco](http://pyjaco.org/about).
[Actually...](http://net.tutsplus.com/tutorials/tools-and-tips/source-maps-101/)
This might be the most beautiful thing I have ever seen.
I was wondering about Pyjamas and I found this: [Pyjamas vs. pyjs.org](http://gwt-coffee.blogspot.com/2012/05/pyjamas-vs-pyjsorg.html).
Here's a recent reddit [discussion on Pyjs](http://www.reddit.com/r/Python/comments/1bkx3y/pyjs_is_a_rich_internet_application_ria/).
MUNTJAC and NAGARE are the best Python full-stack web dev envs.
In the same way that `object.__cmp__(self, other)` works? You pass it the node value and it tells you whether it's less, more or equal.
i.e. "abbcccddef1" The longest substring of repeated characters is "ccc" 
Good news everyone!
Haha, then I would have to maintain it :) -- seriously, though, I think this is a better fit for something you take, hack on, tailor to your own tastes.
I didn't realize you could customize the way Mac OS X looked ;) . However, your point is definitely valid, my implementation isn't too fast. It could be sped up by further reducing the size of the image using PIL (since this is written in C). I think you can also remove the call to ``sqrt`` in the distance function. Also increasing the ``min_diff`` parameter of ``kmeans``.
About time. Not that South is lacking.
But they're not just bundling South? 
No. It's based on South, but it's an even better and easier to use implementation.
Why would one choose flask over webapp2 when deploying on appengine?
This is the kind of stuff I come here for. Thanks, OP!
will there be a conversion process from south migrations to django migrations?
The author of it is the guy who built South. It's basically South 2, a complete and improved rewrite.
I wonder how people can remain polyglot, I mean like with anything, if you don't use it, you lose it. Maybe I'm just not smart. It amazes me that someone can be proficient in a traditional oop langauge, js, sql, scripting language, etc, and manage a database server. So I don't blame people who want to work with as few different technologies as possible. Maybe people's definition of "proficient" varies. Also, I thought front end ppl worked only on front end and backend ppl worked only in backend. Do people actually do EVERYTHING? If so, that is amazing.
can't be that obvious if he missed it 
&gt; I didn't realize you could customize the way Mac OS X looked ;) I stripped the code down to just the part the processes images, then added some modifications that saves the palette to an image :) &gt; It could be sped up by further reducing the size of the image using PIL (since this is written in C). Personally, I think that would be a bad idea... 200x200 is already plenty small. You'd end up losing too much information. &gt; I think you can also remove the call to sqrt in the distance function. Also increasing the min_diff parameter of kmeans. Yup, both those would definitely speed it up. Maybe play around with increasing min_diff to something that still works well, while providing a speed up, or look into a way to remove or speed up the sqrt call (fast approximation?). This is more of a philosophical question than anything else. What made you choose to find the most dominate colors? As humans, a lot of times colors that don't show up very frequently actually have a lot of meaning to us (for instance, the font color on an album cover). Have you considered a way that those might be included? Just curious. I've done some work in extracting color palettes from image, and this was one of the obstacles we had to overcome.
+/u/bitcointip 1 coffee Keep up the good work, man, this is exciting!
The right way is `len(word_list)`, not `word_list.__len__()`.
Migration for oracle Backend still missing. Hope they support it soon.
What's the difference?
Excellent ! Programming a wikigame has never been so easy :)
I'm like you; I prefer Python to most other languages so I use it for my server-side coding. But as people have stated you will most likely want to incorporate some client-side features down the road so you will have to know some Javascript. How much you need to use depends entirely on the web app that you're trying to make. SHAMELESS PLUG: I use bootsmooth, a simple open-source library which acts as a wrapper for web.py and Google App Engine. I use it to host simple static web sites with server-side templating and single page mobile web applications. The client and server aspects of the web application are completely separate. You can use the Google Datastore, Cloud Storage, Cloud SQL, or any other cloud database solutions. I recently put together some "starter kits" to allow people to easily test out some of the latest Javascript MVC frameworks. So far I've made packages for AngularJS, Durandal.js, and a testing ground for Mozilla Brick web components. If you want to check it out, go to http://www.bootsmooth.com
thanks, this looks incredibly easy, although I am having trouble thinking of a way to make it easier than opening wikipedia itself lol
The bottom part is for matching numbers that are not comma-separated. However you've found a bug: the top and bottom should be switched, since the engine will try the top one first to see if it succeeds. This has been fixed in our dev branch, and will be live on the next release.
Came here to say this. I guess I'll be leaving you my upvote and be on my way, then.
With all of Google's APIs and others like praw, amazonproduct, and now wikipedia (just to name a few), I think python is definitely one of the top leaders in the further readability and practicality of code for the independent programmer at home. Wasn't always a fan, in fact I used to openly oppose any of my friends that wanted to use python, but was I wrong. As the masterrace would put it, I have ascended.
I think you got most of what there is to understand. WSGI is a common standard for python applications to speak HTTP with something else that provides HTTP. It's just an interface just like HTTP ie you need 2 applications that implement the 2 sides of this interface for it to work (with HTTP, you have the browser and the web server; with WSGI you have the python framework/application and the *application server/web server*). Some web server applications offer mods (like Apache and mod_wsgi) to offer the bridge between their web serving capabilities and interfacing with a WSGI application. Other web server applications do not have such mod (like Nginx) but they can connect to independant WSGI application server (like uWSGI) to offer the bridge between their web serving capabilities and interfacing with a WSGI application. WSGI has been traditionally synchronous even though nothing in the standard mentioned it. People willing to do asynchronous stuff went away from that standard to start their own web server/application server which resulted in Tornado, Twisted (twisted.web, divmod nevow and all the related stuff) and others. WSGI is now so popular that even Tornado and Twisted have an implementation for it. On the async side of thing, a few guys worked on projects called Orbited and Orbited2 which were some kind of async web server for python applications but these projects seem dead now. It is still possible to do async stuff with WSGI but it might require some work. Gevent is often used to provide such capability. The guys over at [gevent-socketio](https://github.com/abourget/gevent-socketio) have a nice structure to do WSGI async stuff if that's what you are into. [Celery](http://www.celeryproject.org/) is another popular project to add async stuff to your web application. You cannot do direct async web stuff with it, but you can queue up tasks to be executed in an async way which can be useful for long or blocking processes (dumping a big report, doing a big database query, starting a long subprocess, etc). Sometimes, all you might need is a distributed message queue which RabbitMQ or ActiveMQ provides. Sometimes, even a simple key-value store like Reddis or memcached might help you do what you want. The common production deployment backbone stack these days involve the use of Nginx as the frontend web server and uWSGI for the WSGI bridge to your application. For development needs, most web frameworks come with a built-in web server that is easy to start with a simple command line so you do not need to install and configure Nginx/uWSGI or another web server while you are developing. You still might want to use your production setup in your development environment for various reasons like having a similar stack to minimize environment differences and potential problem based on those differences. I'm personally using the built-in servers. I hope this can help you move away from your confusion. If you are still confused, I suggest you try some of these applications/servers/frameworks on your own and see what they can do and how they work.
https://github.com/django/django/blob/django/db/backends/oracle/base.py
It's not a global variable. The code is supposed to be in another function. Do you know what closures are? &gt;But there is no need for such nonsense. It's not nonsense, but legitimate programming technique in almost every programming language.
Flask is nicer to develop with. It has some extra functionality for free like implementing OPTIONS and HEAD for you automatically that webapp2 didn't the last time I looked. The [debug toolbar](http://flask-debugtoolbar.readthedocs.org/en/latest/) is great, although I believe it has been ported to webapp2 recently. [This list](http://flask.pocoo.org/extensions/) is a good starting point. Our older projects do use webapp2, but it resulted in more manual work than I wanted.
Pyjs is solid, but results in JS several times larger and slower, also not really human readable. It also has a feature - pyjd - which allows you to skip JS completly, running the python code locally, having it control a browser (interesting for quick dev/debug). However, this is enough of a PITA to set up in linux, I gave up, and use regular pyjs. Unsure about other platforms.
You get used to it. I don't even see the code, all I see is blonde, brunette, redhead.
And then there's also http://www.mediawiki.org/wiki/Manual:Pywikipediabot
INCREDIBLY HELPFUL! thank you! Yeah, I think I'm starting to get it. I have been playing around with django &amp; flask quite a bit. I think they are simply awesome frameworks. But now that I'm thinking about deployment - it's an entirely different universe from the debug servers that come with the frameworks. Regarding async, I'm going to do some more research, but just consider: http://www.tornadoweb.org/en/stable/wsgi.html : "WSGI support for the Tornado web framework." http://twistedmatrix.com/documents/current/web/howto/web-in-60/wsgi.html : "The goal of this example is to show you how to use WSGIResource, another existing Resource subclass, to serve WSGI applications in a Twisted Web server." http://www.tornadoweb.org/en/latest/twisted.html : "Bridges between Twisted and Tornado" http://cyclone.io/ : "Cyclone is a web server framework for Python that implements the Tornado API as a Twisted protocol." I'm dizzy :)
i've seen "memoize" functions in appengine and implemented it myself in various ways, but this decorator is really nice
Be sure to check out the documentation carefully. The WSGI implementation with Tornado and with Twisted might be synchronous even though the initial framework was not.
Glad you like it! It was inspired by many memoization wrappers but customized for simplicity and performance.
True, Pywikipediabot is better if you need a lot of power. I tried to optimize wikipedia for ease of use so you can get it out of the way and focus on the hard parts of your app.
remy is correct. twisted WSGI resource is not async. however it is multi-threaded. So you could initialize a threadpool outside of the reactor in order to serve requests in a timely fashion to N clients.
Why another one? There are already quite a few of them: https://www.mediawiki.org/wiki/API:Client_code#Python (and most of them not limited to one specific wiki). I'm getting a bit of the [xkcd standards comic](http://xkcd.com/927/) feeling here.
Except this is not a standard. Of course previous MediaWiki clients exist. This one seems substantially simpler, though.
Thanks, that's good to know. 
here's a good article on the topic: http://www.jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or-callbyreference-neither/ and another: http://effbot.org/zone/call-by-object.htm 
to bump a several-day-old comment thread: The same thing still looks better if done equivalently in ruby, in my opinion: is_even = lambda {|num| num % 2 == 0} add1 = lambda {|num| num + 1} [1,2,3,4,5].map(&amp;add1).select(&amp;is_even) #returns [2,4,6] my main reason for preference here is the left-to-right reading. the order of reading the statement in English is the same as the program logic flow. i.e., you start with a list of numbers, make a new list by adding 1, and then select only the even results. compare to python, which reads: select only the even results, out of a list created by adding 1, to a given starting list of numbers. Python does have a win here, though, in that there's only one type of method, which you can pass directly. in ruby, procs are different than methods, map expects a proc, and the syntax to convert is more cumbersome than just using an anonymous function in the first place. i.e. def is_even(num) return num % 2 == 0 end items.select(method(:is_even).to_proc)) you'd pretty much never do things that way in ruby. also, a bit of ruby magic - ruby integers have .succ, which returns n+1, and .even?, which returns whether it's even, so the whole thing can be written as: [1,2,3,4,5].map(&amp;:succ).select(&amp;:even?) While this wouldn't normally be done on something like integers, it is convenient to use on other objects. for example, to get the uppercase version of a list of strings (.upcase in ruby, .upper in python), you would do bunch_of_strings.map {|s| s.upcase} -or- bunch_of_strings.map(&amp;:upcase) in ruby. in python, you can do something similar, but not quite equivalent: map(str.upper, bunch_of_strings) you can't use duck-typed instance method calls for this in python's version, though. (though whether that's a good idea in the first place is debatable). to do that, you'd need the generator syntax: [item.upper() for item in items] which is basically just a prettier syntax for anonymous functions in the first place. That said, it is quite often prettier than the alternatives. --- anway, in terms of 'short-ness vs. readability', up to a point, a shorter phrase *is* more readable. Hence, the unreadabilty of my post. 
Think of WSGi as the python equivalent of the Servlet standard (it's a common interface for python web frameworks). WSGi containers like `uWsgi` and `gunicorn` fill the similar role of Servlet containers like Tomcat and Jetty. So, Flask and Django implement the WSGi interface and can be hosted on WSGi containers like uwsgi, gunicorn or tornado. I'm a bit dated on my JEE Web Stack, but I recall the equivalence: Apache -&gt; (Still apache or nginx) mod_jk/mod_ajp -&gt; mod_wsgi, fast_cgi Tomcat/Jetty -&gt; uwsgi, gunicorn, tornado Struts/SpringMVC -&gt; Flask/Django/etc 
&gt; Hi- I'm coming from the java world, * http://www.reddit.com/r/Python/comments/1ew4l5/im_giving_a_demo_of_python_to_a_bunch_of_java/ &gt; and I'm having a bit of a tough time understanding all of the components that go into a production Python web application deployment. * https://gist.github.com/rakhmad/5845426 * http://www.appscale.com/img/appscale_diagram.jpg * http://www.ibm.com/developerworks/library/os-cloud-virtual2/#6.AppScale|outline * http://docs.openstack.org/trunk/openstack-object-storage/admin/content/ch_getting-started-with-openstack.html#logical-architecture &gt; Can anyone break these down to help me understand what each component in the stack does? * https://en.wikipedia.org/wiki/Technology_stack * https://en.wikipedia.org/wiki/OSI_model#Layer_7:_application_layer * https://en.wikipedia.org/wiki/Solution_stack A [web application](https://en.wikipedia.org/wiki/Web_application) or a [web service](https://en.wikipedia.org/wiki/Web_service) can be composed from various WSGI middleware components (python callables which support the WSGI interface): * https://en.wikipedia.org/wiki/Middleware_(distributed_applications) * http://pylons-webframework.readthedocs.org/en/v0.9.7/concepts.html#wsgi-middleware * http://pylonsbook.com/en/1.1/pylons-internal-architecture.html#the-pylons-middleware-stack &gt; It seems that web frameworks, like flask &amp; django, provide hooks to a WSGI application, which handles the conversion of raw HTTP-ish things into objects that your app can handle (request, response, etc). * https://en.wikipedia.org/wiki/Pull_technology * https://en.wikipedia.org/wiki/HTTP#Example_session * http://www.python.org/dev/peps/pep-3333/#environ-variables * https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface#WSGI-compatible_applications_and_frameworks &gt; But sometimes, you can embed the runtime into a web server (mod_wsgi), or you can proxy to a stand-alone WSGI application (gunicorn, uWSGI) - which are python programs that handle HTTP requests that call the framework,and then your application code. * https://en.wikipedia.org/wiki/Asynchronous_programming#Types_of_parallelism * http://cyborginstitute.org/projects/administration/web-services-architecture/#approaches-to-concurrency-in-web-servers * https://code.google.com/p/modwsgi/wiki/ProcessesAndThreading * http://www.reddit.com/r/Python/comments/16tm4e/what_wsgi_servers_you_use/ * http://flask.pocoo.org/docs/deploying/ * https://docs.djangoproject.com/en/dev/howto/deployment/wsgi/ * http://docs.pylonsproject.org/projects/pyramid/en/latest/narr/project.html#using-an-alternate-wsgi-server &gt; And then there is the asynchronous world of Tornado &amp; Twisted. * https://en.wikipedia.org/wiki/Asynchronous_IO * https://en.wikipedia.org/wiki/Event_loop * https://en.wikipedia.org/wiki/Tornado_(web_server) * https://en.wikipedia.org/wiki/Gunicorn_(HTTP_server) * https://en.wikipedia.org/wiki/Reactor_pattern * https://en.wikipedia.org/wiki/Twisted_(software) &gt; I'm not sure how they fit in. * https://en.wikipedia.org/wiki/Push_technology * **http://www.reddit.com/r/Python/comments/1gz8bm/python_and_realtime_web/** * http://www.reddit.com/r/Python/comments/1de2zz/looking_for_database_library/#c9pvp87 * http://docs.celeryproject.org/en/latest/getting-started/introduction.html * http://www.reddit.com/r/Python/comments/1h1won/luigi_is_a_python_module_that_helps_you_build/ * http://www.python.org/dev/peps/pep-3156/#abstract
The only migration you'll be making with Oracle is the migration away from Oracle!
Yeah, I absolutely love this wave of straight forward and readable APIs. It's just so fun and easy to use.
And [NFL data](https://github.com/BurntSushi/nflgame). :-) /plug
One of the cool things WSGI lets you do is write middleware. You can quitesomething that input and outputs WSGI and do arbitrary transformation on requests.
&gt; With that logic you could say that C is just a special syntax for assembly. Except that isn't the case at all - for one thing, C compiles to many architectures that are completely unrelated... &gt; Coffeescript is a language that happens to compile to JavaScript, but you could make it compile to other languages as well. First, no such compiler exists, and there are no plans to ever create any. But beyond that, it seems to me that any language you compiled it to would have to be able to run Javascript entirely - because CoffeeScript relies on the Javascript object model. CoffeeScript is just a moderately thin wrapper over Javascript - to pretend it's anything else is "silly".
It's still a language. The fact that the implementation of string is the same doesn't change that fact. doubles are implemented the same in many languages.
[Twisted](https://twistedmatrix.com/trac/) is pretty popular. Networking is broad though.
you know nothing about networking? then start with sockets. it's the lowest layer and the one that shows you what's going on. avoid networking libraries (twisted, tornado) or web frameworks (anything wsgi) for now. sockets is fairly easy to get and you can make some very basic client server applications. 
Have you ever tried to add a non-null column? What else have you seen?
I have the opposite sentiment. Learn Twisted first, as it will teach you how networked code should be structured. Then learn sockets to get a grasp of how network libraries work. Learn the interface first, then the implementation.
PyPi: [`Topic :: System :: Networking`](https://pypi.python.org/pypi?:action=browse&amp;c=460) Packets * https://en.wikipedia.org/wiki/Scapy * http://www.secdev.org/projects/scapy/doc/usage.html#interactive-tutorial Network Client/Server * https://en.wikipedia.org/wiki/Twisted_(software) * https://twistedmatrix.com/trac/wiki/Documentation * http://www.gevent.org/servers.html HTTP / WSGI * http://www.python-requests.org/en/latest/ * https://github.com/benoitc/restkit * https://github.com/Pylons/waitress https://en.wikipedia.org/wiki/OSI_model
Yeah, why make `requests` when urllib and urllib2 and whatnot already exists?
In one of my intro programming courses last year, I had a really great professor who taught networking using sockets and network/clients very well. Here is a link to some of his lecture notes: http://www.ics.uci.edu/~thornton/ics32/CodeExamples/ For one of the assignments, we were to implement a networked mode to apply playing of Connect Four over the net. Very fun assignment
Good point.
BSD sockets are the interface.
Do you have some sort of lectures slide to go along with those? I tried hunting around but no luck.
Any good learning resources about sockets? How did you guys got started with this topic? What were the very first things you did when you started to learn this? I'd like to jump into sockets too, so far I've only read Python [howto about them](http://docs.python.org/2/howto/sockets.html), I'd like to get some other learning materials/tutorials etc. EDIT: ok, after reading on the comments, I see a couple of cool links, thanks!
i honestly learned them through C, through the classic stevens networking book. honestly though it's overkill if you just want to kind of get a sense of what's going on. http://beej.us/guide/bgnet/ this is a fairly good resource, and although it's in C, it reflects what you would be doing in any language if you are writing low-level socket code. to really understand networking though you might want to spend time looking at the actual networking (and not just bsd sockets), such as the osi layering model, and how tcp and ip work. 
I love twisted but I wouldn't recommend starting off with it. I would just go for the sockets package
Oh man that's awesome! I'm really looking forward to reading your post and of course you're welcome to link to my post.
Stevens' *UNIX Network Programming*. It applies to Windows and Linux, too, and explains the finer points well.
I love reddit! There really is a great knowledge resource here when people aren't posting pics/news clips and the Python subreddit is a great example. 
Yogis for Stevens. I only have 4 books in my office, they are all by Stevens.
Try out pudb as well, it's a GUI for pdb, easier to see the execution of the code and contents of the stack, variables, etc. Only thing I dislike I can't enter code like you could in pdb. 
I read a tutorial on making a simple chat service with socket... then I used my knowledge of tcpdump to start reading traffic of the wire and trying to reimplement it with Python.
I had such a A HA moment about protocols with sockets. Everything about headers and packing data with metadata at the start/end and these things. I started manually implementing those trying to make my socket implementation work and then I realized what I was actually doing.
Awesome!!! You got my upvote!
A suggestion to those of you who would like to try a [small challenge](http://www.spoj.com/problems/ROADNET/) (the problem is not very hard, correct Python solution might have about 20 lines). Till now, the fastest Python solution used about [1.89 second of the server time](http://www.spoj.com/ranks/ROADNET/lang=PYTH%202.7). 
To OP: this is the definitive reference for how Unix networking code should be written. Since that covers almost everything attached to the Internet that isn't a Windows desktop, it could almost as easily have been called "How To Make Two Things Talk To Each Other". Buy a copy at once and cherish it.
I often work with vectors and rather than using a length call (eg to calculate a speed from a velocity vector) its usually much quicker to just compare squares. So if you need to test if a speed of vector (a,b,c) is less than 10 rather than calculating sqrt(a*a + b*b + c*c) &lt; 10 just test if (a*a + b*b + c*c) &lt; 100. Pythons default sqrt is quite slow when I have to loop this 100,000 times say. I'll look in to numpy to see if its any better. 
The BSD socket API has nothing to do with networking either. But you have to learn a bunch of minutiae to deal with network programming, might as well be something better designed than a 70s C API.
No mention of PyPy?
The author was smart to put the bit about disabling automatic garbage collection at the bottom, or I would have just stopped reading...
Of course not. That would make this a vaguely useful and informative article...
Can't you just give me a good tutorial who worked to someone who already installed this?
Unfortunately not other than those write ups. The professor never used lecture slides in class. I liked his style of teaching, he would sit down, start typing code while explaining it.
Those tipps mostly don't apply for production code, my thoughts on it, point by point: * _Optimise the innermost loop:_ Optimizing the innermost loop is a general advice, which doesn't only apply to python. If you're smart, try not to loop within loops and head for O(n) or O(log n) when possible. * _Function calls are expensive:_ Your code should be readable; function calls are a good way for future readability and maintainability * Use built in types: Just try to [stop using classes](https://www.youtube.com/watch?v=o9pEzgHorH0) * _Leap before you look:_ Even though it is true the exeptions are somewhat expensive, you often can't get around them, e.g. the *StopIteration* in generators and the like, which is fine. * _Turn off automatic garbage collection:_ Turning of the GC is the easiest way to a memory hogging application, don't do it. If the GC is your problem, you've made some other mistake. Generally: Don't trade readability for a small performance boost If it must be fast, use numpy, pypy or something like stackless python. If that isn't fast enugh, well, don't use python.
No, cause I don't know of such a tutorial. There is so much of information you could give, that would make this so much easier. What version of osx and opencv? Have you downloaded the sources for osx/linux from opencv.org? Have you tried to compile them? (got xcode installed?) what are the errors? 
The article was written in 2009. Also note that for step 10 psyco is only for 32-bit systems using python 2.6 or earlier. From psyco.sourceforge.net: &gt; **12 March 2012** Psyco is unmaintained and dead. Please look at PyPy for the state-of-the-art in JIT compilers for Python. &gt; **16 July 2010** Python 2.7 is unsupported so far. Anyone interested in porting Psyco to it is welcome. I started the work in a branch but it needs finishing. &gt; **8 December 2009** Just for reference, Psyco does not work on any 64-bit systems at all. This fact is worth being noted again, now that the latest Mac OS/X 10.6 "Snow Leopart" comes with a default Python that is 64-bit on 64-bit machines. The only way to use Psyco on OS/X 10.6 is by recompiling a custom Python in 32-bit mode (on Linux, see here or here for example). 
Note that this blog post was written in 2009, psyco isn't maintained anymore. PyPy is the modern incarnation of Armin Rigo's ideas from psyco.
This is an outdated and relatively useless article. psyco is unmaintained and dead and never worked on 64-bit processors, and suggests using pypy. When optimizing its best to profile and see what's slowing you down. Then maybe use scipy/numpy to do operations on C arrays, or write the slow parts using Cython, numba, or the python C/C++ API.
You could start with installing windows or *nix...or grab the source and compile yourself.
Give [this one](http://eric.themoritzfamily.com/learning-python-logging.html) a try. What did you find lacking/problematic in the [official tutorial](http://docs.python.org/2/howto/logging.html)? Also you could look at [this post](http://plumberjack.blogspot.co.uk/2009/09/python-logging-101.html) for some ideas as to why logging is designed the way it is, if that might help.
I don't know that sockets is a good introduction for users who have no experience with network programming. I mean yeah that and a copy of *TCP/IP Illustrated* will learn you some networking, but it's definitely not a gentle introduction.
The article misses two of the easiest and best ways to optimize python code: Avoid dot-lookups and prefer local variables. * If you access a global variable a lot, get a local copy. (e.g. module objects) * If you call a method or access an attribute of an object a lot, get a local copy. Bad (one global and two dot lookups per loop): import sys def print_lots_of_stuff(items): for item in items: sys.stdout.write(item) Good (only one local lookup per loop): def print_lots_of_stuff(items): write = sys.stdout.write for item in items: write(item) Even Better (loop happens in C. No lookup at all): def print_lots_of_stuff(items): map(sys.stdout.write, items) 
And if your code is so speed-sensitive that function-in-lining is *actually* a worthwhile optimization, and not micro-, you should probably consider rewriting it in another language or library (pypy, falcon, numpy, cython, C, etc) instead.
That's a generalisation, and like most generalisations about code, there are just as many exceptions as there are cases of the rule. Always just make smart decisions about the appropriate toolset for the job, or any part of the job. Sometimes using a hammer for the entire job is worthwhile, because you'll know the best use of hammer inside and out; sometimes using different tools for different parts of the job is far better, sometimes what you needed the entire time was scissors instead.
We still need logging for humans.
&gt; Generally: Don't trade readability for a small performance boost. If it must be fast, use numpy, pypy or something like stackless python. If that isn't fast enugh, well, don't use python. How is this relevant? He is talking about when you MUST have fast C PYTHON. &gt; If it must be fast, use numpy, pypy or something like stackless python. If that isn't fast enugh, well, don't use python. That's not how engineering works. Yes, a good engineer knows what the best tools are for a particular job. But how often does that engineering utopia manifest itself outside the ivory towers of a school? What if the company is a python shop? What if you inherit the project? What if the client wants/needs it in python? What if you also need the rapid development speed of Python? What if your boss gives you the code and says "make this faster"? Speeding up Python is a very valid and worthwhile project to pursue. Sometimes you just got to know when to throw PEP8 out of the window and write some dirty hacks, like it or not.
Yay, finally some relevant adivce on speeding up Python as opposed to the usual religious dogma of posts like the other ones here that say PEP8 is the sacred holy text and that unbelievers should use a different language (or suffer eternal sensory deprivation in the pit of /dev/null)
I think this is a reasonable set of suggestions. But there's way too much all or nothing advice going on about it. In reality, people are much better off weighing a number of factors than making some optimizations taboo. * yes, functions can help readability (and testability), but inlining 1 function out of a 100 for performance reasons is completely legitimate. Inlining 80 is probably not. * A four-person team that developed and maintained 100,000 lines of python over ten years and that's working great except for one slow area - should not scrap everything and rewrite it in another language in order to avoid inlining a function. * Loops within loops are fine. Sometimes they're far more maintainable than list expressions, for example. Just be aware of performance considerations. And that's what the author of the article seems to be saying: there's a time &amp; place for everything on that list.
&gt; A four-person team has developed and maintained 100,000 lines of python over ten years that's working great except for one slow area - should not scrap everything and rewrite it in another language in order to avoid inlining a function. No, that would be fucking stupid. Rewrite the slow area in another language instead. Kinda why numpy was invented for mathematical / scientific python. Don't rewrite the whole of python, rewrite its parts dealing with numerical structures.
Can anyone tell me what SPOJ is? I keep reading something about Sphere online judgement?
Check Out [Python Network programming](http://www.amazon.com/Foundations-Python-Network-Programming-Goerzen/dp/1590593715)
SPOJ is a problem-set archive, online judge and contest hosting service accepting solutions in Python 2 and Python 3 (among others).
Another tip: make sure you're actually using your imports; if you're running a linter over your code, it should identify most of them. Unused imports just waste cycles and memory, particularly important if your process starts/stops often where startup time is more critical. `import *` is generally a bad thing (again, linters will flag this - you *are* using a linter, right?!), don't use it unless you know what you are doing. If you want to really dig into the low level workings of a function, learn how to use the `dis` library - it gives you a listing of the opcodes Python has to go through for your code. Sometimes surprising things can pop up!
&gt; * _Turn off automatic garbage collection:_ Turning of the GC is the easiest way to a memory hogging application, don't do it. How so? It's completely safe to turn off gc if you don't have circular references, which is often the case. 
This is a bullshit saying. Most often "fast" means "fast enough" and it may be easy to reach "fast enough" goal just with clean pure python code. For example I was moved to a project at work that had huge performance problems despite being written by competent people. In the beginning I though I'll have to resort to writing C modules and stuff, but started with refactorings in pure python. When I was half way there I got message from the management that performance is OK now and was kicked from the project. Even if pure python is not enough the options of integrating python with C are so ridiculously great I never fear starting a fresh project in Python.
&gt; i honestly learned them through C... Same here. Probably showing my age, but this done with serial ports.
Didn't know about map happening in c, that's a pretty awesome tip! EDIT: Hmm, I tried it myself and I don't seem to be getting the same results? def print1(items): for item in items: sys.stderr.write(item) def print2(items): write = sys.stderr.write for item in items: write(item) def print3(items): map(sys.stderr.write, items) %%capture --no-stdout ...: %timeit print1(items) ...: 100 loops, best of 3: 9.65 ms per loop %%capture --no-stdout ...: %timeit print2(items) ...: 100 loops, best of 3: 8.69 ms per loop %%capture --no-stdout ...: %timeit print3(items) ...: 100 loops, best of 3: 9.25 ms per loop 
&gt; 4â€¤ Perform Integer operations and not float operations where possible. I would expect the difference in the speed of the CPU instructions to be dwarfed by Python's bytecode interpreter overhead. A bit of quick benchmarking with timeit confirmed this: I didn't find any significant difference in speed.
I didn't learn them from C, I directly started in python. But I used the *man* pages a lot, which means that I read the C documentation.
Cython is usually an easy sell for the speed-critical parts. It integrates really nicely with CPython, and the learning curve is very gentle.
Yes, there is that saying. Sadly it is usually said by those who later produce code that gives the wrong answer, but which runs fast. 
For anyone interested I'm taking a ton of old perl scripts than ran our infrastructure at work and rewriting them. None of the scripts were originally intended to be run together, they're all very seperate. I've been homogenizing them, but for me this was the final key. I've built a flask app as a command and control center and will build a RESTful API. Then using the logging module and HTTP calls I will link everything together so it can all communicate through the command center flask app. The whole thing got me really excited. :)
The sqrt one is one of my favorite optimizations. It's pretty simple and yet pretty substantial of an improvement.
I really don't know why you're being downvoted for this. I 100% agree. The `logging` module is not Pythonic whatsoever. Doesn't follow PEP8 in any way, uses class instantiation for simple configuration, and is in general way too overengineered and complex. A library should not need a separate, side-effect-causing `basicConfig` function that magically sets the logging settings for that file and any other program that imports it, all because the regular configuration is such a mess. I mean, just look through all this: http://docs.python.org/2/library/logging.html And this: http://docs.python.org/2/howto/logging.html A trillion classes, some are module level functions and some are instance methods, `getLogger` also creates a new logger object if necessary...it's a clusterfuck. "Preferably one way to do it" is also thrown out the window, here. I absolutely wish someone would make a `requests` for loggng.
If you can *guarantee* that your code doesn't contain circular references *and* that it either **never will** in the future (or that anyone who accidentally creates a circular reference will automatically re-enable GC, then maybe you can disable GC. Otherwise...
I haven't tried it yet. I am going through the Scrapy tutorial now and noticed Scrapely. It seems that there's a lot of room for error since you don't get to control the paths to the data you want. However, if pages are structured the same it's probably a great quick tool... (Also, I'm a noob and don't know what I'm talking about.)
I really hate to say it, as it really doesn't answer your question, but if you really want to start to understand networking, it's probably best to understand the fundamentals first. Meaning that maybe it's not best to jump right into some code without getting some background knowledge first. Like a few people in this thread have already noted, Stevens' TCP/IP Illustrated is a pretty comprehensive guide to understanding networking at a fundamental level. The first volume is an elaboration on some of the most common protocols used on today's internet, the second starts to dive into the implementation of said protocols, and the third (I think) is just a deeper elaboration of four specific tools that a lot of network developers frequently use (I've never actually read any of the third volume, so I can't say much about it). However, like others have also noted, it's not the most gentle introduction to networking, and I feel that the series (especially volume one) works best as a complement to something like a university level networking course. However, there are also a few pretty good free lectures online about the topics that are covered in the books. [Here](http://www.youtube.com/watch?v=3DZLItfbqtQ&amp;list=PL91A37D1912EF5412) is a series of lectures on Youtube done by a professor at IIT that covered almost every topic in my data com course in University. This guy taught me more about networking than my actual professor did. You probably don't want to view *all* of the lectures, as some of the topics might not ever be relevant to you, but hey, it's there just it case you're ever interested. If you really want to get down into the nitty gritty, you could start reading [RFCs](http://www.ietf.org/rfc.html) published by the IETF to understand how network protocols are really intended to work. However, a lot of this information is better summarized in books like TCP/IP Illustrated as the books usually provide some more plain English descriptions of the concepts, and they contain better diagrams (which help tremendously when it comes to understanding networking concepts.) For the past three years or so I've been working on a networking team for a very large enterprise level product, with our small team supposedly being the "IP specialists" within the larger team, and Stevens' books are practically regarded as religious text in our office. Now, we use quite a bit of python within our team, but mostly just for automated testing, while all of the actual network implementation within the product is all done is C and C++. 
Interesting to see numpy listed as a way to make code faster. I started using python because I needed features I couldn't get in Octave (matlab clone). So my first experience of python was using numpy as a faux matlab. In code I've been writing lately I've been avoiding reliance on numpy on the assumption that native python operations would be faster - so using python int arrays instead of numpy arrays where possible. Perhaps I should go back to using numpy more... ?
&gt; Even Better (loop happens in C. No lookup at all): &gt; def print_lots_of_stuff(items): &gt; map(sys.stdout.write, items) Note that this only works as expected in python 2.7. In python 3.3 `map` returns an iterable, and executes lazily, sort of like python2 xrange vs range. `list(map(sys.stdout.write,items))` would collapse the wave function, so to speak, but I'm not sure if that would be faster. Using `set()` instead of `list()` would save a bit of memory for very large input lists.
**Rule 0**: The only thing that matters is the output produced by `timeit` or whatever profiler you're using. Optimization should be an empirical process, not a hodgepodge of guesswork. **Rule &amp;minus;1**: Using a good algorithm beats optimization every time. You can optimize bubblesort to hell and back, but it'll never beat unoptimized quicksort on sufficiently large inputs.
This post is confused. What's the main point? Is the point to show off "Splines" or that he completed the trivial task of creating a frozen executable? Just link the source code.
If you've been absolutely *religious* about using weak references, you might be able to make this guarantee... but personally I'd rather not work on such a project for fear of screwing something up.
It all a question of experience. The longer you work with many different languages / systems the more you notice the commonalities. 
Yep! The other Python array types might be fast too, I don't know, but numpy is definitely the standard and is here to stay. You might as well embrace it.
They're not exactly what you're describing, but https://github.com/alonho/pql and https://github.com/alonho/mongoq are two libraries to make mongo query dicts easier to construct.
They both seem to be more for selecting data though, not inserting, unfortunately.
Maybe you can enable some sort of gc "lint" mode which tells you when you have had actual cycles to release, so that in "release" mode, you know you don't leak without the overhead of full GC.
 import gc gc.set_debug(gc.DEBUG_LEAK)
Probably. Maybe. I wouldn't expect it to make a whole lot of difference.
SUCCESS!!!! finally i got it working i used this tutorial: http://samkhan13.wordpress.com/2012/06/18/using-opencv-with-python-on-your-mac-os-x/ finally i can go to sleep (4 am) 
You might consider trying MongoEngine. It has a nice declarative syntax for defining your documents and embedded documents, and you get a syntax similar to the one you described for querying and inserting. http://mongoengine.org/
&gt; I've been avoiding reliance on numpy on the assumption that native python operations would be faster That is so very wrong. There is no reason anything you do with numpy should be slower than Python. You can get massive speedups by vectorizing your code (predefining array sizes using zeros and removing for loops using vector/matrix math). Instead of sum_val = 0.0 for x, y in zip(X, Y): sum_val += x * y write: sum_val = numpy.sum(X * Y) f you need to use embedded if's, look into using the "where" function. It's also worth looking at the numpy/scipy source code a bit to learn how they vectorize their code. Coming from Matlab makes it a lot easier. &gt; Perhaps I should go back to using numpy more... ? Yes, yes, yes.
Make sure you try numba first. Less work.
I seriously doubt a situation where that would actually make a difference would ever come up in python, where using something else wouldn't give you *far* more return in performance for effort.
Holy *($&amp;#( that's one of the most awesome things I've ever seen! Between this and the argument parser that builds the parser out of the help text, I think we're a few steps away from being able to feed an instruction manual into Python and have a program that implements it pop out! 
Same with falcon, I just forget to mention implementation, hopefully most people would get the idea though.
sys.stderr.write may not be the best example; the write call itself is going to have enough overhead to blast away any gains from these kinds of optimizations, I think.
Rule i: when using an interpreted implementation like CPython, prefer builtins to your own code. You can optimize the heck out of your hybrid quicksort-insertion-mergesort, but it will have a tough time beating builtin sort that was natively compiled as part of the implementation.
This just feels like Django ORM for MongoDB. It's a bit too much for what I want.
Do you need 32 or 64 bit? Have you given a try to build it yourself? It's very easy. You will need visual studio installed to even use a debug build that someone else compiles for you since it links against the debug version of msvcrt, which (as far as I know) is only available when you install visual studio. 
I have never done anything like that, but you might want to look into these libraries: grass, matplotlib, mayavi.
I plan to use Orange. A frame work for data mining and machine learning. You can check them out. http://orange.biolab.si
&gt; You can get massive speedups by vectorizing your code Vectorizing code is my default way of thinking. I started as an APL programmer 30 years ago. Every time I write a for loop I feel the pain of dying puppies and starving children in Africa.
Check out [scikit-learn](http://scikit-learn.org/stable/)
bookmarking. thanks!
NLTK offers way more in terms of NLP than WEKA ever has. Also, scikit-learn has about the same functionality as WEKA has (in terms of algorithms), so there's no need to suffer through the horribility that is weka.
True, False = False, True
Seriously, at least be pythonic. (also, for those wondering why this has to be Python 2, in Python 3, True and False are keywords instead of global variables, so they can't be assigned to).
I so wish Python was moving to the coroutines/actors, instead of perpetuating callback spaghetti style.
kartograph has a python binding: http://kartograph.org/about/kartograph.py/
&gt;Try out pudb as well [â€¦] Only thing I dislike I can't enter code like you could in pdb. You can, it's just cumbersome to do so. Press `!` on the line you'd like to investigate, to get dropped into a Python interpreter. 
&gt; Sometimes a SPOJ problem requires a vast amount of data to be read from stdin. Use sys.stdin.readline() rather than input() or raw_input(). Itâ€™s much faster, and every millisecond counts. Both file.readline() and raw_input() use the C library fgets() implementation. It can be quite slow on some systems. "for line in sys.stdin:" is the fastest method to read lines. It implements its own read-ahead buffer.
That's fantastic. Now I wish I had friends who know Python...
Wow, I had written a Java implementation of the 2nd paper mentioned in the architecture section ([A hierarchical approach to wrapper induction](http://portal.acm.org/citation.cfm?id=301191)) around 12 years ago as part of a research project, long before I knew anything about Python. I barely remember the details now but I'm surprised that it is used as an inspiration for Scrapely a decade later. I'd expect the state of the art in automated information extraction to have made some leaps since then.
you can always play it with yourself.
 __builtins__.True = False True = True Just don't do this in IPython. 
It is just about getting the standard value and NOT it...
Clearly I'm doing something wrong because I always see people clamoring on about beautiful soup, but I found that lxml and xpath were usually easier for page scraping. I was scraping amazon for prices just as an example. 
source: https://github.com/skariel/webalchemy obviously this is still pre-alpha. Nevertheless, I don't see why it cannot evolve into something highly useful
Exactly, the same as False == False
The fastest way to consume an iterable without wasting memory is probably: [_ for _ in iterable if False] 
the source is in the folder called library. However I will put the source inline in the post for easier access. 
Maybe I'm not following, I thought you were to `not` the result so you'd be claiming that: `(True == True) == (not (False == False))`... which is `False`. Gosh this is confusing to talk about.
I was trying to say that if you know they ard interchanged and you don't use any non biyective operators, the result should be the one in normal circumstances, inversed. It was my fault to not to be clear or i may be directly wronf
I can't think of a better word to describe weka than horribility
it seems not to be a full-stack web framework like django for example, but looks very interesting, as python needs something like this for the realtime parts of modern web applications. for compatibility reasons it may be interesting to intergrate it with sockJS for example (to support browsers, that don't know websockets natively like the (older?) android browser)
OK, makes sense.
I would say Python would be my first choice for a project like this. It's become the de-facto open-source MATLAB replacement in science.
&gt; 8. Leap before you look. Otherwise known as EAFP (â€˜easier to ask forgiveness than permissionâ€™). My rule of thumb for this is *"if it happens less frequently than 1 out of 7 times, it's exceptional, and catch it afterwards. if it happens more frequently, it's expected and ask permission first."* I came up with the 1/7 threshold by measuring the cost of branching vs the cost of catching an exception under CPython 2.6. I find it's useful as a general rule when coding, and then I can go back later if it really matters, measuring exactly how expensive the "ask permission" test is compared to the cost of catching the exception.
&gt;&gt; Function calls are expensive. If youâ€™ve written a function that youâ€™re calling from within a loop, consider getting rid of it and put that code inside your loop instead. This can make a huge difference to the speed of your program. &gt; Source? It's always suprised me how much work it is to setup a new frame on the stack. But it is... $ python -m timeit 'f = lambda a, b: a+b' 'for i in range(10**5): f(i,i)' 10 loops, best of 3: 21.1 msec per loop $ python -m timeit 'f = lambda a, b: a+b' 'for i in range(10**5): i+i' 10 loops, best of 3: 8.25 msec per loop 
humbledb may be closer to what you are looking for.
Does this promote mixing the app logic with the html views? I don't think the python community will ever accept anything that tries to do this.
Bingo, thank you! The example I linked contained the answer I was looking for, derp.
last i checked, orange was still stuck in 32bit python 2.7. :( 
Judging from the spelling you've already started the drinking game? \o/
That isn't what 'realtime' means. You could describe that as 'reactive', but not 'realtime'.
The presentation needs some work, but this has promise. I love meteor but hate javascript. This could be really great.
Yes, I know that. There's the technical usage, and the colloquial usage. I'm suggesting that the OP is using the colloquial. No need to get too worked up about it.
At that point why bother with Python? Just buy a big ol' bottle of Jameson and down it. Alone.
You could also do: True = 0 False = 1
Well, I do initially do an "edit and write at once," but later on I do a lot of small atomic updates. I have a lot of worker threads that are constantly modifying a single document, basically. I did indeed look at other databases. What I basically want is a persistent JSON store, with querying capabilities. I'm not sure if there are better alternatives?
Wow this is really cool! Is there a way to parse HTML that has already been downloaded with another library? I'd love to use this with twisted without deferring to a thread.
lxml and xpath work just fine, but they can get pretty ugly. Especially if you need to use complex criteria. With BeautifulSoup you can treat every node and the children of every node as objects.
Yes it does, but i would say no more than pyqt, pygtk, tkinter or wxpython do. It makes web programming more like desktop programming
I've made worse plans than staying home with a bottle and programming.
In the web programming domain this seems to be the current jargon, just google realtime webapps and you'll see. In this context I don't see the problem
Exactly, which is why 'reactive' would be a better term for this.
Which is fair enough, but it's still a poor choice of terminology. The established term for this kind of thing in the wider domain of computing is [reactive programming](http://en.wikipedia.org/wiki/Reactive_programming).
Textblob looks interesting.
Awesome! I this comes at exactly the right time for me. EDIT: setup is not so awesome currently. It expects a README.txt instead of a README.md, and when I fix that, it gives `ValueError: expected parenthesized list: '&gt;=2.4.6'` (because of `'cv2 &gt;=2.4.6'`). I don't know how to fix that. EDIT: I just removed that bit, and now it complains about not being able to find `skimage`.
I'm curious about this too but I suspect the answer will be that you will need to rewrite all your South migrations to take advantage of the new system.
Now with more crazy: import random def random_bools(): bools = (__builtins__.True, __builtins__.False) while 1: yield random.choice(bools) bools = random_bools() while 1: conditional_expression = raw_input("Expression to evaluate (or q to quit): ") if conditional_expression.lower() in ['q', 'quit']: break True, False = next(bools), next(bools) guess = bool(raw_input("Guess the result: ")) print("True: {}, False: {}, Guess: {}".format(True, False, guess)) if guess == eval(conditional_expression): print("Next!") else: print("Drink!")
GLOBAL EDIT: now using setuptools in the setup.py (I hope it's a good way of doing things) this should fix many problems. Updated documentation, too. Thanks !
A heads up: I have a second edit, this time about the module `skimage`, which it can't find after setup completes successfully and I try to `import moviepy`.
Thank you very much for this... it's great! I've been looking for something very close to this for a while. I will definitely be using it on video projects that I'm working on. I'll give completely selfish feedback about one aspect - My personal challenge is that I am not very good with the math for the animation stuff here. People like me probably require some higher level stuff like jQuery or iOS animations, including things like easing, some different rotations, some canned effects (ex: fade in, flip, etc) , etc. Something ideal would be a way to "plug in" animation effects and combine or chain them in some high level way. That's only because I suck, though. I'll definitely be working with this module on my current project.
&gt; to_precision(123000000,4) &gt; '1.230e+8' Is wrong. One is a float, the other is an integer. Some codes care.
booh, I didn't know that. That starts making the dependencies very heavy. Anyways, thanks for the feedbacks, I am fixing things as they come.
Interpolating strings into `os.system` calls is *very, very, very* bad and you should feel bad. Interpolating strings full stop is bad, especially when they come from the user. I understand that in this library that it's very possible that other programmers are going to be using it but you should be using subprocess. Think of this: def covert_film(in, out): cmd = "ffmpeg %s %s" % (in, out) # I don't know the correct ffmpeg commands os.system(cmd) This is a big problem when the strings come from a possibly nefarious user: `convert_film("file file2", "; sudo rm -rf --no-preserve-root")` 
I don't get it. We already use JavaScript to do this. Client-side apps running in the browser and communicating asynchronously with the server is an established pattern that implements "nearly realtime" UI feedback very effectively. This looks like reinventing a square wheel. I don't mean to be negative, and its likely that there's something I'm not understanding here. Can someone try to explain this in some more detail and point out what its advantages might be? 
 import sys def log(msg): print(msg) sys.stdout.flush() Seriously? https://github.com/skariel/webalchemy/blob/master/webalchemy/utils.py
[kmeans](https://github.com/numberoverzero/kmeans): I tried following the [OSTRW](http://www.jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/) guide for kmeans, so it took a bit longer than I expected. Installation: `pip install kmeans` Usage: import kmeans points = [ [(r, g, b), count], [(r2, g2, b2), count2], # Etc... ] means = kmeans.kmeans(points, k) print means Or if you're loading points from `Image.getcolors( w * h)`, use this: points = [(color, count) for count, color in image.getcolors(w * h)] Basic testbed (uses docopt, kmeans, Pillow): [dropper](https://github.com/numberoverzero/dropper). Usage: python create.py ~/Downloads/rainforest.jpg ~/out.html Blog post to come in a bit!
What would you be interested in improving?
If you want to help people get started, inside your *virtualenv*: pip freeze &gt; requirements.txt
My idea was that every time someone codes for something a little advanced with MoviePy, they would share the code in a user friendly way. For instance some user shares this function def flipVertically(clip): """ flips the clip vertically """ fl = lambda pic : pic[::-1,:,:] return clip.fl_image(fl, applyto='mask') Then people that are not Numpy/Scipy experts just put this function in their personnal toolbox (some module moviepyToolbox.py that you import in your projects) and will just write stuff like flipVertically(clip).to_movie('flipedMovie.avi') The main idea of MoviePy is that it must be easy to write new stuff. On the other hand I don't want it to become a monster with users requiring to add new effects to the package every day. Maybe we could do some forks for some specific uses.
Thanks for the tip (seeing the number of upvotes, I'm not the only one who learned something). But how exactly will subprocess fix that ? I mean, you still pass string arguments to subprocess, right ?
I'm a relative newbie at Python, what is this?
I upvoted for importance, not necessarily for learning something new. Injection attacks are bad. But as said, subprocess makes safe system calls easy: import subprocess ... def covert_film(in, out): return subprocess.check_call(['ffmpeg', in, out]) AeroNotix's example then just looks for an inupt file with name `file\ file2` (with a space in the name) and creates an output file with named `\;\ sudo\ rm\ -rf\ --no-preserve-root` Granted avoiding this attack is not crucially relevant for your program (expected to run locally on one user systems not run with privileged permissions), but it is a very good habit to get into. The same pattern would be super dangerous say a web app doing SQL on a database or running as a privileged user, and this is a common source of vulnerabilities. For more see: https://www.owasp.org/index.php/Top_10_2010-A1-Injection or https://www.owasp.org/index.php/Command_Injection 
The source code is posted now.
I wish I had more than one upvote to give. The logging module is also a freaking performance hog. It does string and stack inspection on each message. I still use it for compatibility, but I hate it.
This is awesome! In a few weeks I'll be creating a video of my last few months of traveling and haven't been looking forward to more time in iMovie. I'll definitely try to do everything with this and attempt to fix any bugs I come across. Can you put the link to the github repo somewhere prominent on the project page? I see you mention it at the bottom, but no link.
I'm curious about your decision to make 22050Hz the default sampling rate for AudioClip. It seems to me that you're going to be getting a lot of support requests about poor audio quality. 44100Hz allows you to sample the entire range of human hearing.
What happens? I don't assume it's anything actually destructive, is it? 
Nothing permanently destructive, but it will break your IPython session. qtconsole just loses the kernel for me, and when running in terminal things just start breaking (including IPython's history collecting thread throwing exceptions). Also, there's an amusing thing that happens when you press Ctrl-D, where 'y' doesn't mean yes anymore: In [2]: Do you really want to exit ([y]/n)? y In [2]: So yes, I wouldn't advise you do anything important after that.
It's fun but a little slow. I suggest any scripting that does stuff to set a page up (like jquery hides) - is done in native. 
If you use zodb you don't have to use sql.
way to go!
vi(m) is extremely powerful and, whether you're on a desktop or headless server, using Linux, Windows, or Mac, its availability is second to none 
I haven't used it too much (or for anything NLP related), but the [MALLET](http://mallet.cs.umass.edu/) java library is supposed to be decent for NLP.
Not 100% sure, but it's very likely that it takes your installed Python modules and outputs them to `requirements.txt` so that you can make sure you've got all the packages you need to be able to run the bot. Generate output suitable for a requirements file. $ pip freeze Jinja2==2.6 Pygments==1.5 Sphinx==1.1.3 docutils==0.9.1 Generate a requirements file and then install from it in another environment. $ env1/bin/pip freeze &gt; requirements.txt $ env2/bin/pip install -r requirements.txt http://www.pip-installer.org/en/latest/usage.html#pip-freeze
Way to deliver! I'm really excited to take a dive into the source code. Thanks for this -- adding links to my original post.
What's wrong with the bots? They do add a lot to some subreddits, like awarding points, retrieving imdb/g+/.. Information
I personally hate the stupid metric_bot (whatever his name is) that spams every thread with his anti-imperial propaganda.
On osx, I'd make sure you have [homebrew](http://brew.sh/) installed, and grab [pip](https://pypi.python.org/pypi/pip). Read up a little about it, and you'll be good. Personally, I can't stand PyDev(eclipse), and never really use an IDE. vim/sublime text are good enough for me. But use whatever you're comfortable coding with, it doesn't particularly matter. 
Alright, I did some research and I managed to install pip, virtualenv, distribute (as I see setup_tools doesn't work well for Python 3). I just installed homebrew, thanks! Side note, anyone know how to make it so when I type in "python" into my terminal, it brings up Python 3.3 instead of Python 2.7? Only way I can get Python 3 is if I type in "python3"
Hey guys, I don't want to make a new thread for this so I'll just ask it here. I'm trying to install PyQt 4 but I keep getting this error: "Make sure you have a working Qt qmake on your PATH or use the -q argument to explicitly specify a working Qt quake." I'm using the standard installation procedure python3 configure.py after that, I get that error. SIP has already been installed. edit: Got it to work. Simply typed in, brew install PyQt5
Implementing a good async logging system is not easy, for eg. Should I log on a separate file per session so things don't get mixed together, etc. I just wanted a print statement for debugging purposes because of the nature of Tornado I had to flush so I put it all in a simple function. That being said, I did open an issue back on day 1 to reconsider the whole logging mechanism. It's just not 1st priority now...
Only slightly correct ... You need to *NEVER* touch the installed python and you shouldn't ever `sudo` to install python packages, ever. There is no reason to modify system files for python dev. * install homebrew * install python (2.7) via `brew` * grab virtualenv off of pypi, unpack and run the installer with `/usr/local/opt/python/bin/python setup.py` * create your new BASE env, `virtualenv z.env` source the new env in your .profile What this will do is make `z.env` your new base python that you can install anything into (all pointing back to the homebrew install). You can still create new project specific envs. Your python environment is completely distinct from the apple built in python now.
My god that's wanky. Why is this required? I've been developing on windows and linux for two years now and the only time I've put anything in a virtual environment is when I'm running something in Jenkins.
That first one actually got things to click for me. Thanks!
You nailed it- that's the vision. I have to write some docs and put up a nice homepage to deliver the message. And of course make a better presentation. ..
Then scala is just a thin wrapper over Java then.
&gt; but If I could get some basic guidance on what I'm up against Honestly, I'm not really sure what it is I could tell you. You said you don't have any programming experience, right? If so, then I really can't even tell you what kind of programming challenges you'll face because you haven't started programming yet. It just wouldn't mean anything to you. I'll say this though: find a problem and solve it. Maybe your social network activity feed thing is a solution to a problem you're having, or maybe it's something else. The point is, if you have motivation to see it through, then you'll learn to take the next step. Python and Django are probably fairly decent choices for you. I say this because they have huge communities and you're unlikely to find yourself facing a problem that hasn't been solved on Stack Overflow. For me, programming is less about what you know and more about what you *want to do*. Figure out what you want to do and start your journey. The rest is just a small matter of programming. ;-) Protip: Asking vague questions like this tends not to be so useful. The next time you have a question, make sure it's concrete. Tell us what you've tried. Tell us what you expected it to do and tell us what it actually did. And most importantly, **tell us the problem you're trying to solve**. If you give us those four things, I can almost promise you that you'll get a good response.
I would love to talk to you in depth about this. I am currently an automation engineer at DivX (at least for the next 90 days) and I loooove python. 
Cool!, but from bla import * kills kittens... The numpy/matplotlib examples do it to woo matlab users, I encourage you to not.
maybe this can help you: http://net.tutsplus.com/tutorials/python-tutorials/building-ribbit-with-django/
is there any reason he uses from moviepy import * instead of import moviepy ?
You may be right, but I didn't have the luxury of creating the models or having a separate reporting database. Basically, I found doing anything where I wanted real control over (left,right) joins, group and having to be a total ball-ache. To some extent, I think this is a weakness of ORMs in general, or at least ORMs that don't/won't be pragmatic about the limits of ORMing. I'm comfortable with writing raw SQL but its a pain.
That's my advice to new programmers: if you don't have an itch that needs scratching, it'll be tough to stay motivated as you learn. As to the "what am I up against?" question, it's pretty much the same as with any language: you learn the language itself, you learn the develop/deploy/debug flow, you learn the libraries, and (in the case of Django) you learn a framework. And in my expericence, the Python community is no more hostile to new programmers than any other. There are assholes everywhere. One critical skill is learning to ignore them.
It is very common to do from bla import * for 'final' scripts (i.e. scripts that will not be used in other scripts). I tried to make a module with a clear syntax. If I have to add 'moviepy.' in front every new clip I create, the scripts with get heavy. But if I make a module for special effects, that will be imported in other scripts, then indeed I will use 'import moviepy' Note that for the moment the "from moviepy import *" really imports too much different things, like skimage, cv2, etc... it is not that bad, and it serves for debugging purposes
Second this. Seeing as the project is on GitHub, you can easily accept pull requests from others who made such an utility function.
If you are new to web-development I would really recommend web2py. Take a look at this playlist: https://www.youtube.com/playlist?list=PL5E2E223FE3777851 The first video I more theory and the other 6 are tutorials and examples. 
Add to that that if you mess things up, you can re-init your env in 6 lines. Add to that the use of buildout/setup.py for dependency management, and you have hassle free development.
Bloody Monday quote?!
I've been using an Ubuntu VM setup with Vagrant. http://gettingstartedwithdjango.com/en/lessons/introduction-and-launch/#toc0 Even if you don't plan to use Django, the first part of this get's you a nice dev environment, and I've installed it on both Windows and Mac host machines pretty quickly. It doesn't matter what the host machine is, because you run all the commands on the Ubuntu VM. 
Metric system is a better system.
Yes, virtualenv is really indispensible. Pip is, too.
Very common or not (and I dispute that it is), it is a bad idea that caught on in some projects related to numpy/matplotlib because the original tutorials for those languages were written to entice matlab users. We have namespaces, don't throw them away because you want to impress newbies with the shortest hello world examples. please!
I don't even know where that idea came from to honest. There are many nice, helpful people over at /r/learnpython for example. 
Erm, it's hard to really say how to implement this because there are several ways. Probably the easiest and best would be to use the Django framework, which is going to require you to do more work because it has it's own conventions and such. Not awfully difficult, but definitely more to learn and play with. You're going to have to learn SQL (if you want to do this right, I prefer MySQL but I know others prefer PostgreSQL, it has the ability to do vertical tables or somesuch like that; can't recall at the moment, but do some Googling). You're also going to need to know standard web development languages: HTML, CSS, Javascript, probably some PHP (I do no web development whatsoever, but I think PHP will be required). What you're talking about would probably be best implemented in several distinct components, relying on a common SQL database. This is a rather large project, probably the easiest place to start would be the chat portion. It's relatively simple to send messages back and forth from client to server, you just need to figure out how you want to target those messages by user, and how you want to display them.
Heh, *KidWonder101*... If that's not a troll account I don't know what that is.
Something is not correct about that outline. Make a 1x2 matrix multiply by its transpose then blur it?
I will definitely be checking this out. I wonder how it compares to VapourSynth (which is a python 3 interpretation of avisynth). From what I see so far the answer is "different" but I can't see straight away what video formats and colourspaces moviepy support so I'll have to look closer. An interesting project, for sure.
Yes indeed. But I was speaking to someone who found the entire concept of `virtualenv` "wanky." Baby steps.
Anybody have an example/demo of a Twisted server? I have not encountered this before. 
This webalchemy allows me to be 100% Python. Just like muntjac and nagare. I dont know Javascript. And I dont like the mess that all the improved offshoots like coffeescript create. One language front-to-back is highly desired by me.
I like being able to couple webalchemy with what I want.. say sqlalchemy or the web2py database layer. It's not full-stack but it fully addresses the issue of realtime without having to use Javascript when the cleaner, nicer language is Python (i know, thats subjective!)
I am currently working on windows so i have provided a windows installer. I will be providing a binary distribution for other platforms as soon as i am familiar with them. I am however open to anyone wanting to support by creating a binary distribution for the other platforms.
Installed from windows binary. It doesn't appear each project is getting its own virtualenv. Is that right? Also, I can't seem to get a build to work with a simple: print("Hello World") -invalid syntax (linecache.py, line 81) When I add files to my Project by right clicking, then New &gt; File, (foo.bat) the file doesn't appear. A new directory will appear. Attempting to right click &gt; Add Existing Items, blocks all file names in the file select dialog window. I can't select any files. 
I would recommend putting some work in to conforming to the [PEP8](http://www.python.org/dev/peps/pep-0008/) style guidelines, this will give the project a good base to allow new developers to more easily work with your project.
On a side note; What would you recommend for learning to create bots with the reddit API? Im playing around with python as a hobbyist, and a reddit bot seems like a good project.
Any info on doing a similar thing for windows? I assume linux is pretty much the same as OSX though?
I can't offer much advice in terms of programming, but DeltaBot is so far from finished that it could be that project for you (along with others).
No, it also run on Linux, just tested. It only doesn't have a Linux installer, so you'll have to run it from source.
http://twistedmatrix.com/documents/current/core/examples/simpleserv.py
Thanks.
You have two good choices: import moviepy as mp and from moviepy import ( a, b, c, d, e, ... ) (which looks a lot better with longer variable names). Sometimes both combined is the best compromise.
The `re` problem in cx_Freeze is fixed in the development version, but the release cycle is pretty slow. You may want to look at shipping pre-release versions of cx_Freeze. I'm a contributor, but not the maintainer. Other than that, it looks interesting - well done on building it.
I would definitely allow each project to have its own virtualenv, or at least the option to do so. I never used cx freeze, so I would need to read up on what those options do, but following your config options, the first time I changed the config it threw an OS error. (Sorry, I didn't grab it) I then restarted and it just throws the same linecache.py error.) import re print("Hello World") Don't try to troubleshoot my problem right now, I'll revisit your app later. I understand that you have taken on quite a large task. I have thought about creating a GUI based PyInstaller app. To me, it's a minor miracle every-time I get PyInstaller working within two days.
This looks quite neat, I'll give it a try the next time I need to crawl something. Hopefully it is as robust as hand-written scrapy crawlers. Nothing worse than crawling a few hundred gigabytes of data only to find out you had a little bug in your code and have to redo the entire job.
Django gets better and better by minute.. I mean it, I pull from github daily just to watch the commits, those guys are full speed ahead.
Vagrant can act as an easier-to-configure wrapper around VirtualBox. Combined with configuration management with puppet, you can write your config files then set up the entire virtual environment with a single command. And it's reproducible so you can distribute the Vagrantfiles and keep a whole team of developers or all of your computers up to date with identical environments. 
Can I see a demo of this working, and maybe a few use cases for this? 
* Compute the eigenvalues for the matrix I'm sorry!?
The [Harris and Stevens](https://en.wikipedia.org/wiki/Corner_detection#The_Harris_.26_Stephens_.2F_Plessey_.2F_Shi.E2.80.93Tomasi_corner_detection_algorithm) algorithm does use the eigen values to determine if something is a corner. I've written a version of this algorithm in python and you blur the image not the matrix.
Thanks.
You've got an awesome and exciting challenge ahead of you, but if you stick with it your ambition will be rewarded! My first tip would be to find out if there are any Python user groups in your area. If you're anywhere near Boston we've got a great one in Cambridge that has a "Project Night" once a month. There you can meet other Pythonists and get help with your projects from experienced Python developers hands on. If you can do that, awesome, if not that's OK. Start out small. Start by making a Twitter clone first. Make sure you have the basic pieces like Authentication (logging in), Persistence (saving stuff to a database), and Authorization (making sure people can see only what you want them to see). Once you've got that, you've got something you can build on.
To answer your questions: you can feed MoviePy with many different formats (raw, mp4, ogv), I don't know the list. And it can write in dozens of different codecs (list: http://remisoft.ath.cx/article14/fourcc), maybe these are also the codecs that it can read, I don't know. For the color spaces (of which I know nothing, be warned): for the moment everything is RGB but OpenCV (the video library on which MoviePy relies) has many functions to convert from and to other colorspaces. Thanks for VaporSynth, I didn't know it (and that's what I had been looking for before I coded moviepy, a python equivalent for Avysinth). I have had a look at it. Is it open source ? It didn't seem so. It seems like it has more functionalities than moviepy (for now ;) ) but it's more complicated to use/learn.
 I've just started out on something similar and after a bit of research, I am learning python opencv and scikit. [So far just trying out tutorials to learn]. As a pet project, the ultimate goal is to be able to have my webcam recognize who is in front of the pc. I guess, in your case, instead of a picture of a face, it would be a picture of a sticker. I look forward to the answer of more knowledgeable folks here!
It is opensource (LGPL2), the github is here https://github.com/vapoursynth/vapoursynth though the development is largely done via the doom9/10 forums so it's somewhat insular :) Will definitely keep an eye on MoviePy though.
I am totally for pull requests :) Since I put my program on Github, it's not really mine anymore, let the community decide where it wants to take it, that will be fun anyway. But let's be careful not turn it into a module catalogue before the core program is mature. Priorities should be: easier to use, better designed, faster, more memory efficient, etc... We do not want to rewrite all the advanced features if we have redesign the core. And fadein/fadeout are in the program since the beginning (I couldn't resist ;) )
Try SimpleCV !!! http://www.simplecv.org/ It is exactly written for dealing with webcams, computer vision, and such ! It is built on top of OpenCV but it is supposed to be simpler than cv2 (it offers higher-level functionalities), with nice examples and documentation. I like it.
These links might help with installing Python 2 and/or 3 on OSX "the right way", as well as get started with virtualenv: - http://killtheyak.com/install-python/ - http://killtheyak.com/use-virtualenvwrapper/
I think that TorndaoSockJs on github is pretty fast and cross browser. It does not have '"reactiveness" but it can be used as a base 
Andrew has said it's "incompatible" with old South, so probably no. But you only need to keep old migrations around as long as you are still testing schema-changing features? Once Django 1.7 is released, you could: * Finish any code that changes database schemas, * Apply South migrations to all of your testing/staging/live databases, * Delete all South migrations from the codebase, * Start with a fresh "initial migration" on the Django 1.7. The only reason to keep old migrations around is if you need to jump backwards and forwards to test code changes. Once a schema is live on all databases, there is no reason to keep migrations around any longer.
how about some screenshot ?
Metric lies notwithstanding, I wouldn't mind it as much if it didn't reply to **every** **single** **usage** of imperial units. It's just spammy and useless. If someone really cared that much, they could just use an online converter. I should make a imperial_bot. (Even it's name sounds awesome!)
Not everyone is from the US of A and can't convert on the fly. There is also a converter bot that does it both ways.
Reasonable is subjective. Do you think you'll deploy anything online, or are you at all interested in using python for web-applications? If yes, then get something deployed as fast as possible, which this will help you do. Also, if you think you might want to work on more than one machine, or if you ever plan to get a new machine, using this set-up will make re-creating your current environment much easier. You could just use PowerShell and a texteditor in Windows for python, but that's no fun. Why drive a bare-bones Ford Focus when you could drive a Tesla Roadster?
I think that's the point...
good point, that sounds like the most sensible thing to do
Like [these](https://github.com/fortharris/Pcode/tree/master/docs/screens)?
Yeah. I could lead off by describing "you know that thing where accented characters or special punctuation or whatever turn into a bunch of symbols like euro signs and ^TM signs and different accented characters?" By which time you may have stopped reading. So instead I can instead just put a very visual example in the title and people say "Oh that thing! Yeah, I hate that!" 
wow, FORTRAN is still cool! (showing my out of date ignorance here)
I really appreciate the Python 3 compatibility.
I don't like hearing things like giving up on Python in the browser or saying that there's anything in Python that doesn't work very well. :-( I also don't like suggesting that Python made certain choices because it didn't have compile-time type checking. I want to hear him say that dynamic type checking is superior and Python users stand at the bleeding edge of history instead. ;-) And the idea of Guido working at a company that isn't using the latest version of Python.. or even just having Torvalds-esque words for people who haven't ported yet... left me feeling distressed. Several more years?!? You mean right around the time we're do for Python 4.0???
on behalf of the PTVS team, a big congrats - this looks pretty good! 
There's a chrome app for python in the browser
I have no idea when I'm gonna need this, but I'm definitely bookmarking it. 
I would use SimpleCV and the SURF algorithm to compare your input image to reference images (I am pretty sure SimpleCV has SURF, otherwise use OpenCV with the Python bindings). http://www.simplecv.org/
Guido has officially stepped out of that ring and designed Nick Coughlan as the BDFL-Delegate for all things related to packaging. If you have specific questions I can try to answer them or poke those that would know.
CPython is more a language development playground than anything else these days. If you want to look for Python in the browser, check out the in progress PyPy.js port. Basically remember that he is to a large extent just the guardian of "pythonness", his opinion on VM implementation is just one of many that work in that space.
tested on version 2.7 and 3.2, some exception triggered
[valid xml charset](http://www.w3.org/TR/2006/REC-xml-20060816/#charsets)
I still don't understand why you couldn't just use Pythons logging module. It's thread- and process-safe, and in its default configuration almost as simple to use as your little utility method. With the advantage of supporting namespaces (great if you want to differentiate between sessions) and being waaaaay more extensible and sane. I haven't used Tornado, but I'm sure you could play along its default loggers as well: http://www.tornadoweb.org/en/stable/log.html
Can you elaborate. By broken do you mean end users on different OS's, different version, etc? What is your standardized install process like?
What I'm thinking is best at the moment then is to stick with 2.7 for django and actual work and mess around with 3.x until I feel comfortable using it.
Can't be worse than this http://xkcd.com/323/
Most MAJOR 3rd party libraries support Python 3. However, you'll inevitably will find smaller libraries that aren't ready yet (and maybe never will). Nevertheless, Python 3 is the future and version 3.3 is really mature and nice to use. Even if the conversion from 2.7 to 3 is relatively painless I'd say you should really give Python 3 a try. (And especially for Django it's quite easy to switch back the underlying Python to 2.7 if you experience unbearable pains).
Until scipy and numpy are compatible, it's 2.x for a huge number of python programmers. 
that is a good plan
Numpy is 3.x compatible as is Scipy! As well as most of the other major scientific libraries btw (matplotlib, pandas).
If you are simply learning, I would say make the switch to 3. But if you are starting work on a decent sized business application you might want to stick with 2.7 for now in case any libraries that would help you haven't made the switch yet.
This is all personal projects. I'm doing it mostly for fun but also to build up a little portfolio for when I start looking for my year in industry placement in late September.
If you're learning, why would you not learn for the latest version? Django supports python3 as does a lot of libraries out there. Don't listen to the cautious "you should stick to 2.7" folks - there is honestly no reason you shouldn't jump in with python 3 for what you are doing and the more people that follow suit the sooner we will be past this "2 vs 3" rubbish. Writing in 2.7 now is just code you'll want to rewrite later.
I cannot tell you how happy it makes me that these slides are in a PDF instead of hosted on something like Slideshare, which while interesting makes archival nontrivial and it is not quite as nice as what is possible with a PDF as far as layout goes. Now if only it was the modus operandi to make transcripts of talks available in addition to the presentation for those of us who are interested in the presentation but cannot spend 45+ minutes watching a video.
TIL /. is still a thing.
The link appears to have 404'd. Any mirrors? EDIT: Still 404. :-(
It amazes me how humble and down-to-earth he is. As for the creator of the Python programming language, I expected to see some religious opinions, a joke about Ruby, etc.
Is there a (rough) timeline?
Do you need anything that only works in 2.7? Then use 2.7. Learn your \_\_future\_\_s, they'll come in handy so that, later on, your code can be ported to Python 3 as soon as the environment is ready. Otherwise, always use Python 3.
As long as you can be sure that Python3 is available in any environment that you might want to use python in, and the 3rd party libraries that you are interested in are supported, then I'd say go for Python 3. Still working mostly 2.7 myself, but this will probably change within the next few years (hopefully). The numerical/scientific computing libraries out there are almost fully supported, but a few are not completely there yet (scikit-learn, pywavelets, etc). I think the situation may be better with the python web frameworks.
It goes to a reddit link shortener which have been giving me issues but you can get the [original link](http://www.pycon.it/media/stuff/slides/python-idiomatico.pdf) if you click the little link icon.
I believe PyPy is mainly a research project and like most research projects, I think you'll have to wait when it's done.
it definitely depends on funding situation.
I think I'm going to start using 3.x for personal projects and 2.7 for anything important until I feel my 3.x skills are up to par.
Paging through to say slides LBYL vs EAFP, I'd say both examples are quite bad and `emp = employees.get(emp_id, None)` is probably more pythonic than immediately reporting an error. The examples given were: if id_ in employees: emp = employees[id_] else: report_error(...) or try: emp = employees[id_] except KeyError: report_error(...) (Also what kind of variable name is `id_`. Something like emp_id is more idiomatic python). You could even do `employees.get(emp_id)` which will still return `None` when the employee is not found, but I prefer to be explicit with my default for more readable code. The next LBYL vs EAFP example is even worse. The bad / good code examples are: if os.access(filename, os.F_OK): # BAD fh = file(filename) else: print "Something went bad." ---- try: # GOOD fh = file(filename) except IOError: print "Something went bad." First, the `file()` builtin was removed from python3 and for a long time `open` has [been preferred](http://docs.python.org/2/library/functions.html#file). Second, it is discouraged to open file handlers in python outside of `with` blocks. The idiomatic way for application authors to use files without checking for errors is: with open(file_name) as f: do_something_with_file(f) which ensures `f` will get closed when the with block is left regardless of errors. If you need to handle catch errors, something like this works: try: with open(filename) as f: do_something(f) except IOError: report_error(... ) This doesn't seem like a big win over the example code, but if the example code did anything, it would have to be: fh = None # Need to define here as IOError on open() will not define fh, hence if fh: in finally will fail. # Can't put fh=None except IOError: block in case do_something(fh) raises an IOError after fh is opened try: fh = open(filename) do_something(fh) except IOError: print "Something went bad." finally: if fh: fh.close() 
In general, I would say most people just load the document, amend the bit they want to amend, then save it all back. So there's not much call for generation of complex queries to update some part of the document. And since PyMongo gives you fairly Pythonic access to any part of the doc you want, you'd normally just do the edit in memory and then save, rather than issuing a highly-targeted update. &gt; What I basically want is a persistent JSON store, with querying capabilities. I'm not sure if there are better alternatives? I don't know if there is anything better. But I guess the question is, if you're writing to small subsets of documents all the time, why do you even care if it's JSON?
My preferred guide for idiomatic python [Code like a pythonista](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html). Obviously [PEP8](http://www.python.org/dev/peps/pep-0008/) is good too but more of a style guide than idiom guide.
Why is there a picture of James Gosling behind Brian Kernighan's quote? 
Still works for me, although very slow right now.
thanks.
I think it's always easiest to get kids (of either gender) interested in, well, anything. They're actively interested in learning "cool stuff," while adults are -- if nothing else -- distracted by their present problems (like "I have to earn a living, who has time to learn cool stuff?").
I'll echo Jacob's support for the Ada Initiative, I've had the opportunity to work with them a few times, and they're really doing fantastic work: * I participated in Ada Camp San Francisco a few months ago, this event really facilitated really fantastic discussions across an interesting cross-section of the industry, about how we can improve diversity in our field. * In working on the Django community Code of Conduct, we solicited feedback from (among many others) the Ada Initiative, and they provided fantastic feedback on how we could improve it to better achieve our goals, and demonstrated one of the rarest internet feats known to human-kind, they made a rational argument and convinced someone (me) to change their mind on the internet, you don't see that every day!
http://www.python.org/dev/peps/pep-0439/ is a bit out of date, but yes, we are planning to bundle pip with python. Its been a bit of a long road, still waiting for pip to remove its last external dependencies right now, and then we need to figure out how to do the bundling. Initially the plan was to include a network installer for pip, I think I've managed to convince everyone that would be a bad idea but right now energy is mostly going elsewhere as pip just isn't ready.
while this is very cool, and this isnt exactly a python question, but what would happen if i made two completely unrelated systems (like say redis-server and mongod) listen on the same port, other than Very Bad Things
Those books and tutorials only show you how to do something. If you learned it from the official docs and were able to implement them properly into your code, you don't need to read any books/tutorials. As for pythonic styling (the commonly accepted conventions), check out [PEP8](http://www.python.org/dev/peps/pep-0008/). It's the commonly accepted standard for pythonic code.
This pretty much says it. Get a linter to enforce PEP 8 and go to town. (Minus E503 because it is silly). With any programming task there are always different methods to solve any problem, but you figure that out over time.
Testing is becoming an increasingly important part of the "pro" python dev's toolkit. I hope this doesn't come across as shameless self-promotion, but I've been working on a braindump of everything I've learned in the last 3 years or so about TDD in Python, in the form of a book. It's available for free as well as a paid-for version. Am currently about half done. http://www.obeythetestinggoat.com Covers TDD, Django web development, selenium browser automation, but also things like how to use a VCS (git), a bit of Bootstrap for styling, and some ideas about server deployment, server admin / devops, fabric etc.
\x is not your friend. try this code... print "\x"
Use django.utils.six and use Travis to ensure your tests pass on 2.7 and 3.3
Well, plus Im pretty sure Im their (niece and nephews) "cool" (read: only) uncle so that probably makes it a bit more interesting to them. Anywho, I read the groups accomplishments/mission statement, and its very admirable. Once again this is all just my opinion, but I think while trying to "steal" (tongue-in-cheek) women away to tech, we should simultaneously be bringing tech to more women dominated fields. In fact, this has given me a great idea for a student group at school! Thanks!
Excellent, especially the part about arguments to the keyword values in a function being shared between invocations.
Thank you. That was exactly what I needed to hear.
This is the first time, I have seen them mention Scipy and Matplotlib interoperability as an explicit goal! Numpypy is a whole different ball game with those two libraries!
I wrote a blog post about this very subject last month. It's here: http://pydanny.com/experiences-with-django-python3.html
Heh, seems the Vimmers hate being threatened. I used Vim and it's *awesome*, but now I use SublimeText and it's *just as awesome*. It's also a lot prettier, feels faster (I think it's graphics accelerated, unlike urxvt) to browse in and it's just as fast to do stuff if you spend as much time configuring it as you do with Vim.
The last suggestion (Limit the try scope) is great. I have chased several bugs because the try block included more code than it should.
&gt; we should simultaneously be bringing tech to more women dominated fields. I think that's the key. Not only for women, but for anyone "not that into tech things". Teach them how technology can may their work easier/funnier/prettier/better, and they will become more interested in tech. 
pygame? 
I don't know... as a female programmer that actually majored in CS, I have to say that when I first started off, my class' gender balance was 50/50. However, once we were in our 3rd year, it had gone from 50 women: 50 men to 5 women : 100 men. It really wasn't as if there were guys that were actively going around telling women they couldn't be programmers, no one's that big of an asshole. It's just that the all-nighters and the endless hours in windowless underground labs eventually took their toll on everyone. I'm pretty sure that guys would have bailed at the same rate as women if there wasn't such a high social pressure on guys to be bread winners (And if you look at the rate of return for only investing 4 years in a degree, CS is pretty damn good major to invest in). Anyways, while I do think your goal is admirable, I'm not sure if young girls actually believe they can't be programmers because it's a "men's job". I just think that they have less of a reason to stay if they get discouraged by the initial learning curve.
requests is awesome, but: fork with socks support fork with gevent support fork with INSERTNAMEHERE support ultimately requests is a HTTP client library, isn't it? why aren't these additional features just being merged back upstream? please enlighten me
This is quite unnecessary, they should just write a Transport Adapter for SOCKS. http://www.python-requests.org/en/latest/user/advanced/#transport-adapters
if you have code that solves some generic tasks and you think it can be useful to others, consider sharing it. chances are you will get feedback not only about the functionality, but also about the coding style. sometimes it can be harsh but if you're after improving yourself, you will be able to get through it and advance we improve as programmers by educating ourselves but also by exchanging knowledge with other programmers
he made a joke about Perl at the end
I would love to see a fork with both socks and gevents, only recently started messing with gevents and see it as incredibly powerful. Had never thought I would like event based programming either!
&gt; I'm going to be starting on django soon That's the key phrase right there, not whether third-party libraries supported or whether 3.x is on your favourite Linux distro. As you'll presumably be asking or looking for advice on the web, you want all the advice to be for the Python version you are actually using instead there being further barriers to getting what you want done.. So: 2.x.
I highly doubt you're going to find something that does exactly what you want to do without being a full-fledged ODM. After all, what you are asking is to have a Python object (a dict, in your example some_doc) that you can treat like a normal Python object, but you also want it to map your Pythonic actions on it to a Mongo document. It sounds like the only way you're going to be satisfied is to roll your own class inheriting dict that maintains information on its corresponding Mongo document and works with Mongo behind the scenes. To your question of whether it's a good idea, I don't think it is. The most obvious reason to me is that you're going to end up waiting for a database roundtrip every time you want to modify your document, since Mongo's lack of transactions means you can't queue up all the operations in sequence and commit them in a big batch at the end. You'll have to wait for Mongo's okay to continue operating on the dict to make sure the edit you made was valid. This will probably slow you to a crawl.
By this logic new computer buyers should install Windows XP on all of their new machines even though it will reach end-of-life in a few months. 
If everyone takes this "no, not yet" stance it'll never be the time. 
I kind like his `find_by()` function with the keyword args if that's really something you're doing a lot, but I think it's more flexible just to use a generator expression with `next()`, for example: book = next(b for b in books if b.title == 'Python in a Nutshell') And `next()` lets you specify a default if you need one: book = next((b for b in books if b.title == 'Python in a Nutshell'), None) This way you can easily do more complex expressions in the various clauses, for example, getting the author of *Python in a Nutshell* found by case-insensitive title: author = next(b.author for b in books if b.title.lower() == 'python in a nutshell')
This website crashes the android browser. Great example were setting there. As for the initiative, I'm more concerned about kids of all genders getting into programming, why are we focusing on getting women to program?
Search Github for libraries that are either interesting to you or related to the work you'll be doing, and read through them. I've found it's a good way to be exposed to syntax, idioms, the stdlib and 3rd party libraries that I've never seen before. Try using them a little bit too. If in the interview they ask if you've ever used X for web crawling but you haven't, you can at least say "no, but I have used Y pretty successfully." [This](http://www.pycon.it/media/stuff/slides/python-idiomatico.pdf) is also pretty good as far as idiomatic python goes. Most importantly, get outside your comfort zone. Pick a task you have no idea how to do, and write a script that will do it. You'll hopefully run across something you can't solve with your current skillset, and then with some googling you can find all the ways other people have solved that problem. 
I wish they would acknowledge that they underestimated the amout of work needed for numpypy. 
&gt;After all, what you are asking is to have a Python object (a dict, in your example some_doc) that you can treat like a normal Python object, but you also want it to map your Pythonic actions on it to a Mongo document. It sounds like the only way you're going to be satisfied is to roll your own class inheriting dict that maintains information on its corresponding Mongo document and works with Mongo behind the scenes. So, for fun, I began working on exactly such an ODM. &gt;To your question of whether it's a good idea, I don't think it is. The most obvious reason to me is that you're going to end up waiting for a database roundtrip every time you want to modify your document, since Mongo's lack of transactions means you can't queue up all the operations in sequence and commit them in a big batch at the end. You'll have to wait for Mongo's okay to continue operating on the dict to make sure the edit you made was valid. This will probably slow you to a crawl. Well, that's a valid point, but in that case the issue is not with an ODM but with anything that ends up doing a lot of atomic updates with `db.coll.update()`. And the alternative (which could be done easily with any of the dozens of Mongo ODMs out there) is to load the document from a query, convert it into an object, modify the object, then re-save it into the db. Depending on the size of the object this could incur more overhead, unless you plan on doing a lot of bulk changes *at that one moment.* For my project, I have a bunch of worker greenlets that will all be updating documents one time per event. So if they observe something happen, they will push one thing to an array in a document, and only do so again when there is another IO observation. Because of this, the round-trip time wouldn't be a huge deal for me; it only would if I needed to do about 1000 updates sequentially.
Why? 
I have yet to see a job posting asking for "junior level python programmer", in fact most seem to asked for "expert", "guru", "superstar"......
It's worth looking through some of the tutorials in the right column here. They will give you an introduction to parts of the language you haven't worked with before. Also, I would strongly recommend trying the Python Challenge. It's not so much about learning pythonic style as it is having some fun solving problems while learning about different Python libraries. There are a lot of other great resources over there that are good to look through just to get some new ideas and perspectives. @biochemistry_student mentioned one, but also look at Writing Idiomatic Python (http://www.jeffknupp.com/blog/2012/10/04/writing-idiomatic-python/) and Code Like a Pythonista: Idiomatic Python (http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html). Also do a search for "idiomatic python" to find some more.
At this point, unless you need to deploy to environments where 3.x isn't an option, I'd say start with python 3. I develop for enterprise clients who don't want to run anything not supported by redhat, the latest of which supports 2.6. If you don't have that kind of constraint, the library base is big enough you can get by on python 3.
the problem is not the use of '\x0c', it's about character validation check in xml operations
No module should require books to master it, especially for something as potentially simple as logging. And nothing as simple as logging should cause people to waste a day trying to figure out how to include variables in the output. Bleh. BTW, there are python logging alternatives out there, and it seems like more people I talk to are using something else besides the python logging module.
The differences between Python 2 and 3 are more subtle than they are dramatic. Nearly everything you will learn in Python 2 is transferable to Python 3. In fact, if you're specifically using Python 2.7 and 3.3 then it is actually really easy to write code that works perfectly in both. One key is to put the following 2 lines at the very top of your python scripts: from __future__ import print_function from __future__ import unicode_literals When the script is run in the Python 2.7 interpreter it will behave like Python 3 in two of the major ways that they are different. And in Python 3 they have no effect. EDIT: Fixed code snippet that was using markdown syntax and was getting unexpectedly formatted
Yip. Watched the complete course last week. Great content!
&gt; There's a significant difference in syntax between the two, and as a beginner this is a big deal. Nah, it's mostly the same.
Go to python and django meetups in your area (there are many). You will get to learn from experts in your area, and most will have recruiters. You can speak to them about positions, and you can network. http://www.meetup.com/find/?keywords=python&amp;radius=50&amp;userFreeform=New+York%2C+New+York%2C+USA&amp;mcId=c10001&amp;sort=default&amp;eventFilter=mysugg
&gt; There's a significant difference in syntax between the two, and as a beginner this is a big deal. Not really, Python 3 "corrected" a few things such as print statements now requiring parentheses (it became a function). ^^^Oh ^^^God ^^^why ^^^do ^^^we ^^^still ^^^have ^^^'del'?
Idly, here a few interesting topics you might want to be able to talk about for an interview: - flask vs. pyramid vs. django - nose vs pytest - mocks for monkey patching for tests? - sqlalchemy vs. zopedb - python2 and python3 in the same code base? - buildout or virtualenv? All in all, a github page which shows you've made something interesting and know what you're talking about is a good place to start. 
No, they want to implement the whole matrix engine in RPython, so their JIT can optimize it. *Then*, they want to provide a matplotlib/scipy compatible interface. That latter part might involve some API simulation. At least that is how I understand it.
&gt; Return does not require parentheses Ech, I typed "return" originally, then fixed it to say "print", then apparently pressed CTRL+Z at some point. Fixed, thanks. &gt; Because there i no replacement for it? There should be. I feel [this](http://zedshaw.com/essays/curing_pythons_neglect.html) is relevant.
&gt; Ech, I typed "return" originally, then fixed it to say "print", then apparently pressed CTRL+Z at some point. Fixed, thanks. Still wrong, print is not a statement any more. &gt; There should be. I feel this is relevant. Del does too many things, some of which need to be syntax (for instance deleting attributes or bindings). There cannot be a function that replaces it.
&gt; Still wrong, print is not a statement any more. Take two. Fixed yet again, thank you. A miswording on my part. &gt; Del does too many things, some of which need to be syntax (for instance deleting attributes or bindings). There cannot be a function that replaces it. In reality, this probably irks me more than it should, I just find it quite irritating that the functionality of removing at index *x* is not part of the list class.
Windows XP is still the second most used version of Windows and it's over ten years old. That means there's many more articles, books about using it than Windows 8 and even 7 (which came out near the end of 2009). 
I even highlighted "who can you offer you help" for you in my previous post, there's no need to be so obtuse.
Requests had both SOCKS and Gevent support at one time. Both were removed for good reasons.
It completely depends what you plan to do with it. I've taken a few online classes in the past year; two used Python 2 and one used Python 3. At my work we're still transitioning to Python 2.6 and plan to move to 2.7 soon after. We're heavily dependent on third-party packages that come with Python embedded (none of them have mentioned Python 3 so far). Guido in his [interview with slashdot last week](http://developers.slashdot.org/story/13/08/25/2115204/interviews-guido-van-rossum-answers-your-questions) said that Google was just wrapping up their transition to 2.7 (he left 6months ago) and Dropbox is using 2.7. Both companies are already thinking about Python 3. I think the "Should I use Python 2 or Python 3?" link on the sidebar still reflects the current situation.
Are these reasons listed anywhere?
To mainly pay a developer (me), thanks to the donations numpypy is my only job.
&gt; There're plenty of python_3-aware programmers on the internet. So? The overwhelming majority of books, articles, Stack Overflow answers, blog posts, comments, Reddit posts, etc are for 2.x. When you have to mentally translate all the code samples (etc.) to python3, that provides mental barriers for you to overcome. That's not at all difficult for you or me, but when you are just trying to learn something for the first time and get something shipped, it's just a waste of mental energy that's better spent on elsewhere. Have no idea how you are going from that to "he can't use any version at all".
http://kennethreitz.org/announcing-requests-v1-0-0/
What features should I add? Currently it's just really basic seed growing
Something that could be easier, link inland water to sea
Great reply! If I can nitpick a bit: &gt; `emp = employees.get(emp_id, None)` is probably more pythonic than immediately reporting an error But you may want to report (or terminate execution) if you got something that was supposed to be an employee, but had no emp_id. In that case, you don't really gain anything from using `get(key, None)` over the first `if key in dict ... else ...` example. Using `get()` will even be (ever so slightly) slower because of the call overhead. But probably less than the second example using `try ... except`.
It would be cool to generate a gif of the seeds growing.
http://gamedev.stackexchange.com/questions/16563/how-are-voxel-terrain-engines-made Check out the 2nd and 3rd answers. Perlin noise density map looks pretty organic. Pair it with some other maps, and calculate things like temperature, humidity. Then based on temperature/humidity color it to look like desert, jungle, snow, etc. Also good ideas here: http://prezi.com/pijcj8ckwhny/terrain-creation/
I added some example images to the README. I did this because I was bored and had been playing a bunch or minecraft recently. I'll be sure to checkout Pillow
What do you mean?
I don't get it. I'm really trying not to troll, don't downvote me and please hear me out. I contributed my time to pyladies and even gave them money. Why? because they are 100% volunteer. No one makes a living off of pyladies and that's is how it should be. OTOH, Ada Initiative seems like a way for the founders to make a good living as diversity advocates. Their advice is useful, but why do we have to pay for them to give it? 
Yeah, I just went for basic randomly decaying seed growing. I knew there were more complex methods, I'll be sure to check them out 
Setuptools setup.py and pip?
Rivers flowing to lakes and oceans
It isn't the website that crashes the browser. It is the crappy browser that crashes trying to load said website.
Some people don't care to author in RST, but also the tooling around GitHub defaults to Markdown, so it has more momentum.
If you're unable to have a separate reporting database on the internets, you still might consider pulling a full export and mirroring it locally, then batching over into a more traditional reporting database on your own workstation. From there you could take advantage of an ORM layer again. Or, do the same exports and then merge your data using pandas (http://pandas.pydata.org/), which is amazing.
To what degree is wand-py built to replace PIL? Reading the docs it seems like this package is intended to replace it.
grequests is not a fork but rather a wrapper around requests so I don't see the problem. https://github.com/kennethreitz/grequests Also there are other TransportAdapters around which are not forks.
What you're saying makes sense. My question though is I'm being taught 3 in class no matter what, but at the same time some of the better online resources out there are for 2. I see the basic differences between the two of them and am wondering if it would be in the best interest of the beginner to stick to one, or if using mixed resources would be okay.
Agree. Abstractions matter; decoupled abstractions help. I'm just saying the dict lookup not finding the key most of the time doesn't need to be handled as an exception - the EAFP is grab it, on error put in null value to indicate it wasn't found that can be handled by any further processing. His EAFP isn't really asking forgiveness, but saying have an entirely different branch of logic worked out for the exception case (versus on error put in None and handle it gracefully). If you actually need to use `emp` in your code, you can't do try: emp = employees[id_] do_things_with_employee(emp) except KeyError: report_error(...) or try: emp = employees[id_] except KeyError: report_error(...) do_things_with_employee(emp) as emp won't be defined in the latter case (unless `report_error` returns from the function) and in the former case you have to worry that `do_things_with_employee` will never generate a `KeyError`. Also, what if the function this code exists in, is a function with an abstraction that part of its return value is `emp`. In that case, like: def employee_lookup(id_, employees): try: emp = employees[id_] except KeyError: sys.stdout.write('error') return do_things_with_employee(emp) # e.g., fetch other values; return emp emp = employee_lookup(id_, employees) You still have `emp` as `None` after the call and the rest of your code has to correctly handle that value being null. The following could work: try: emp = employees[id_] except KeyError: report_error(...) emp = None do_things_with_employee(emp) but I'd argue this is cleaner and more pythonic: emp = employees.get(id_, None) if emp is None: report_error(...) do_things_with_employee(emp) Anyhow, I wouldn't worry about the slight overhead of a try-except vs if-else or extra function call unless this is a known bottleneck (and then I'd probably move to a compiled language like C++ or go after prototyping in python).
Not remotely similar. PIL is python+C extensions. Wand is a wrapper for imagemagick. If anything Pillow will (friendly) replace PIL. 
valuable answers, thank you guys 
brilliant idea
worth trying 
thanks!
Because you said this: *""As you'll presumably be asking or looking for advice on the web, you want all the advice to be for the Python version you are actually using instead there being further barriers to getting what you want done.""* Which says that he has to choose the version that is the only one talked about on the internet, which is no version at all. Therefore, he can't use either version of python. I really don't see how he has to do that much translating. A)It's relatively easy to find python_3-compatible content on the internet. B)The actual changes involved at the beginner level are trivial: division shifts to float by default (which is what he would expect anyway) and print is now a function (which is easy understood in a matter of seconds) Proposing that he use an old version over something so small is just silly in my opinion. Also: *"So? The overwhelming majority of books, articles, Stack Overflow answers, blog posts, comments, Reddit posts, etc are for 2.x."* I'm not sure this is the case anymore.
This was a moronic comment. Trolling?
That would be truly sweet
Also, try hanging around in freenode IRC channels (e.g. #pocoo, #django, #pyramid, #python) for a while, and helping folks. That usually gets you some rep. ;-)
&gt; Which says that he has to choose the version that is the only one talked about on the internet, which is no version at all. Therefore, he can't use either version of python. I'm not even sure that's correct formal logic but even if it was my obvious intention was that you ensure sufficient documentation is available for the version you are thinking of chosing. We can disagree about whether such help exists or whether it is even required for 3.x but concluding that I was somehow saying "no version" seems unnecessarily--and perhaps aggressively--obtuse.
I thought it was Perlin noise just from looking at the image. Not bad for 49 lines of python! The reason why Perlin is used most often for this type of task is because you can wrap it at the edges and it is seamless, which is great for a world map.
I'd suggest focusing on one but being aware of the differences. When you go through examples or tutorials for version B (assuming a bulk of your work is version A), just translate it over. This way you'll stay in the mindset of writing for one but can spot features of the other. For these online classes I've taken using Python3, I'm not writing any classes, modules, or anything fancier (like metaclasses, properties, or generators), so the differences are very minor (mostly the "print" call, and gotchas were fixed like floats being returned for integer division). The most common problem you'll probably hit is using the wrong interpreter and getting confused by an error. On most systems 'python' will point to the system default, 'python2' and 'python3' also exist (python27 and python33 exist, too, but it's best not to call them out unless you have a good reason). If you add python2 or python3 in your shebang, it should save some headache of getting an unexpected version. It is possible to write code compatible with 2.7 and 3.x...but it's probably not worth it if you're just starting out.
&gt; ...the tooling around GitHub defaults to Markdown... Github also supports ReStructuredText READMEs. Since PyPI does not support Markdown READMEs, it seems simpler to write once in ReStructuredText rather than having to remember to convert the README each time an update is made. &gt; ..it has more momentum. Is this true in the Python world? Both PyPi and Sphinx do not support Markdown. 
Because of PyPI, I'm pretty sure I use `.rst` whenever I'm writing a Python project (I'm not 100% sure because I haven't had the free time to do any FOSS stuff in months, and I can no longer remember). That said, if you want to have a `README` or `README.txt` (note the lack of `.rst` extension) with pretty formatting, I'm pretty sure you're stuck with Markdown if you're hosting on GitHub. BitBucket used to let you specify the markup you were using with a special comment, e.g., `-*- markdown -*-`, but they apparently removed that feature. I'd say that in the FOSS community at large, Markdown has more momentum specifically because of GitHub. In the Python community, I'd say this effect has been less pronounced, but is slowly becoming more pronounced.
Considering that the original article is supposed to be a document of best practices for *Python projects*, I think that it does not make sense to suggest using Markdown READMEs or (as the article actually recommends) maintaining both Markdown and ReStructuredText READMEs. I think it's fine for individual developers to do this if they are allergic to RST, but I cannot defend it as a best practice when starting a new open source project, especially if one wants to accept external contributions.
It's not that it's his key insight, it's that he designed the language in such a way that reading the code after it's written would be easy.
I wouldn't maintain both, either. I was just explaining that reStructuredText is very much *NOT* the expectation in the wider FOSS ecosystem, which is probably what prompted the author to do what he did.
Go to this web site: http://jessenoller.com/good-to-great-python-reads/ Good idea to start with LPTHW. You're on the right track. As others have said, network, network, network. Go to all the local meetups for Python, Django, and other, possibly more obscure Python-based tools. Get a sense of what people want.
Thanks this looks really interesting. Also do you have any suggestions on what would look presentable on my github? I kind of don't know what I should be trying to accomplish with it.
This is probably the first time where I have heard developers say 'more money means faster progress'. Usually hiring more programmers is a detriment for the first few weeks due to the need to work them into the codebase and all the time that takes from those who would otherwise be getting shit done. Are they hoping to bump up some part-timers or volunteers to a paid position perhaps?
Erosion. Real land masses don't look like that on a large scale. The sweeping curve of a bay. 
Seems useful, and definitely more maintainable than most non-trivial RegEx. Syntax also reminds me of [this simple TikZ wrapper](http://www.reddit.com/r/LaTeX/comments/1gvdsv/a_thin_tikz_wrapper_in_python/) I wrote.
How does it compare to Pyramid? The documentation seems a bit thin.
I had to read that twice to understand it.
Id say, focus on Python 3 for the sake of your class. You wouldn't want to accidentally write deprecated code on an exam, quiz, etc. and loose marks. Once the course is finished, it certainly wont hurt to take a stronger look at 2.x because you will definitely run into older code along the way.
Definitely go to Python 3, most of the major Linux distros have it available now (it was more of a bitch when everything had to be compiled from source). Sure some libraries do not work with it, but I haven't come across any for web dev this far :)
I completely agree with you, which is why I think that the author choose poor wording to express this by talking about how this was "[o]ne of Guido\'s key insights".
If you need ideas for quick (to not so quick) projects, check this out: http://www.dreamincode.net/forums/topic/78802-martyr2s-mega-project-ideas-list/ I'm not quite sure if this is relevant, but I've learned that there's essentially two ways to get a lot better at something (via piano). 1. Repetition on something within your comfort range (yielding muscle memory / ability to consciously perfect small nuances) 2. Reach songs (There's no way i can play / code that, but i'll give it a shot and see where it goes) For your specific case, you'll probably want projects that are in your comfort range, and then make SURE you're coding them idiomatically. Best of luck 
I'd like to see the five-year-old that understood that snippet! :) Nice blog post!
...never mind.
Github Trends is a pretty good resource for new projects. https://github.com/trending?l=python&amp;since=weekly
Thanks! Didn't Gauss come up with the FFT at age 5? 
TurboGears aims at both new developers and experienced ones trying to keep the best balance between rapid prototyping, flexibility and easy of use. It tries to cover a niche between Django and Pyramid.
Lol! I posted VerbalExpressions under r/javascript and received just downvotes! I'm happy that there's someone in here who could appreciate such links! :D
&gt; We have namespaces, don't throw them away... By that logic, you should never use the `from a import b` form either.
yeah, no.
More programmers is only a problem, if you already have reached saturation and they have to learn the code base. In this case they have only one developer working full-time on NumPy. Adding one or two more people to the project shouldn't be a problem in general and especially not, if they are already familiar with the code base.
Personally I think your getting the best of both worlds by learning in the transition where the default on a lot of well written examples out there are still in 2.X instead of 3.X. Aside from the print being a function and unicode things, it seems like the bulk of the changes will be invisible between the two, especially in an introductory learning class. That being said, some of the changes went towards fixing really odd 'kinks' that existed which I believe is where the push for not keeping backwards compatibility came from. Some of those kinks are basically from lazy programming, so it's good practice I guess to keep you from ever falling into that trap. I'm using 2.7 just because the third party software we had used 2.7 scripts, I've since moved away from that software entirely but just haven't switched my code over, but the day that happens I'm more likely to go back into C with the package...
thanks, adding it
just look at redblack tree implementation, this part catch my eyes: def is_red(node): if (node is not None) and node.red: return True else: return False it's rewrite in one line return (node is not None) and node.red
Why the `e = exp(1)`? Just use `exp` to do the exponentiation.
I'm actually surprised this is popular. It looks mostly unreadable to me. It took me a few hours to come up with a semi-robust Python interface that allows things like r[r.line_start, "thechangelog is", "really"::7, "cool"] (and a fair bit more I won't cover) instead of var regex = new RegExpBuilder() .startOfLine() .then("thechangelog is ") .max(7).of("really ") .then("cool") .getRegExp(); and pattern = r[["massively", "amazingly"]] regex = r[r.line_start, "thechangelog is", pattern::7, "cool"] or, equivilantly, regex = r[r.line_start, "thechangelog is", ["massively", "amazingly"]::7, "cool"] instead of var pattern = new RegExpBuilder() .either("massively ") .or("amazingly "); var regex = new RegExpBuilder() .startOfLine() .then("thechangelog is ") .max(7).like(pattern) .then("cool") .getRegExp(); regex.test("thechangelog is massively massively massively cool"); // true Personally my version solves ambiguity and removes complicated syntax without being overly verbose to the point of difficulty. It's easily extendable; if you want to write pattern = r[["massively", "amazingly"]] as pattern = r.any("massively", "amazingly") it'll take a one-line addition. It also allows embedding regex as arguments: `r[re.compile("[0-9]"), "[0-9]"]` will match `"5[0-9]"`, for example, and it supports arbitrary groupings (etc). It's a touch less obvious what things mean, but it's more *readable* than 50-line giants that `RegExpBuilder` will create and *also more readable* than the equivalent regular expression. I also think that with a touch of work it could support automatic, transparent *and* correct handling of back-references. 
The logging module. Our code base inherited a module written by someone at my company years ago that wanted to do some custom logging. Instead of extending the logging module they replaced functions directly in the logging module like getLevelName() and some functions on the Logger class to do their custom actions. This completely screwed up my code in another place where I was trying to use the logging module completely unaware of the monkey patching that had been done deep in our code base somewhere else.
Do you know why you're getting downvoted? New to Python, but this seemed like a valid notion. Is there some reason not to use exp()?
math.exp can't handle complex numbers. You'd need to use cmath.exp instead.
If you can contribute to some projects, that's useful... even if it's just documentation or small fixes. The fact that you forked, fixed and submitted pull requests on other projects looks good. Obviously, unique personal projects are very useful because you can show off your own code and style. But what to create, is really up to you. I'd start small and go from there. I keep a notebook (or list) of project ideas. I may not get to start on them right away, but at least I have a list of ideas to go back to when I've got some time to write something "just for fun". 
is "X" a valid input? or "XX"?
You didn't mention that 'state' refered to US State abbreviations. If that's the case, your code is incorrect: 'qz' is not a valid state, neither are 'a' or an empty string (I have no idea whether `not ''` is equal to `not None` in Python ...).
Most people (with python experience) would find his code more readable. The doc-string is intended to describe what the function does, although in this case I would say it is better to rename the function IsStateStringShort() (and have its output inversed). Since it doesn't actually validate that the string contains a valid US state at all.
&gt;I have no idea whether `not ''` is equal to `not None` in Python ... It does; `not x` is always equal to `not bool(x)`, assuming that `bool` has not pathologically been shadowed. 
So why not use `from cmath import exp,pi`?
Personally I would've gone with something like: def state_isvalid(self): # an empty state is fine, but there are no states with &gt; 2 characters state = self.data.get('state') return not state or len(state) &lt;= 2 To me having two separate if statements and a total of three separate return statements is quite verbose and I find this very readable. That's totally a matter of taste though. I also think it's useful to state exactly why the length requirement is 2 in the comment, or otherwise, if that is obvious, not have a comment at all. To me, the phrase "the input 'asdf' is not fine to have" doesn't clearly declare *why* that input is invalid, so it's not really stating a why, but rather a what. All it does is name one possible invalid input, which to me isn't helpful. If the 2 character length requirement is obvious from context it shouldn't need a comment. If it isn't obvious the comment should explain the why explicitly. I also renamed the method, but that depends mostly on context. Because it returns a boolean I assumed it's being called in another method, like: if self.validate_state(): In which case I'd prefer my: if self.state_isvalid(): just reads nicer to me*. I've been going back and forth on whether to make the comment a docstring as Veedrac did, but I think because it explains internals of the method it's better as a comment. The purpose of the method is totally clear from its name in any case so it doesn't need a docstring IMO. \* as an aside, one of the things I like about lisp and ruby is that ? and ! are legal characters in method/function names. I like the brevity of something like `if self.valid_state?`.
 def validate_state(self): """Validate the currently selected state.""" state = self.data.get('state') if state is None: return True return self.is_state_valid(state) def is_state_valid(self, state): """Check whether the given state is valid.""" return state.lower() in ALL_STATES
I've several years of Python experience and have never gotten used to the overloading of `or` here -- especially when Python has a perfectly good ternary operator. And, for the record, most people (with python experience) would never suggest a function name like `IsStateStringShort`. :)
The code is meant to check whether ``self.data.get('state')`` is a valid U.S. state. The logic is obviously incorrect and on top of that everyone is raging about the coding style for some reason.
**Note, I've slightly changed the code to read better, which aligns more to how I'd have written it originally. It's only identical to /u/sushibowl's by coincidence, btw.** &gt;You literally are repeating the code in the comments Yeah, that's 'cause I had no idea what the code did. I thought `state` was for a state-machine. &gt;while your code is more concise, I find it damn near unreadable def foo(bar): ... return spam is the common idiomatic transformation of def foo(bar): ... if spam: return True else: return False so you should get used to it :P. &gt;Also, the reasoning for why a length-two state is obvious in my particular context, since this is dealing with only the United States. Then you should be doing: valid_state_codes = set(""" AL AK AS AZ AR CA CO CT DE DC FL GA GU HI ID IL IN IA KS KY LA ME MD MH MA MI FM MN MS MO MT NE NV NH NJ NM NY NC ND MP OH OK OR PW PA PR RI SC SD TN TX UT VT VA VI WA WV WI WY """.split()) def validate_state_code(self): """Return whether the current state is a US state code or None""" return (not state) or self.data.get('state') in valid_state_codes 
The code's not obviously wrong. It's just obviously a very lightweight validation of the length of the state value. U.S. addresses use two-letter abbreviations. If you're validating form input, maybe it makes sense to do this kind of check before calling some more expensive validator like an address normalizer.
So any two letter combination is a valid state? Why not write this properly? pip install us then import us def validate_state: if not self.data.get('state'): return True return self.data.get('state') in us.state.STATES
It's obviously wrong if you're actually validating the value. It's correct if you're doing the equivalent of ``x is None or len(x) &lt; 3``, which I don't see the point in doing. There are 50 U.S. states and checking whether such a short Python list contains a string value is not exactly expensive.
Firstly, the original code (it's now updated) did have a terrible docstring, but that's 'cause I had no idea what it did (why would a state machine only have states with two letters, eh?), so that's why I made the compromise. &gt;That sounds to me like code narration. It's not code narration if it's telling you the heuristics the function uses. A docstring is meant to tell you how to *use* the function, not write the function. What counts as a valid state (assuming that it's not obvious it's a state of the US) *is* important to how you'd use it. &gt;I would be very close to saying that a name like `is_state_abbreviation` is enough documentation already. As would I, with the exception of mentioning accepting unset states.
I think this is still pretty self explanatory as a two liner. def validate_state(self): """Validate the currently selected state.""" state = self.data.get('state') return state is None or state.lower() in ALL_STATES 
&gt;The fact that this criticism is being leveled (and upvoted) makes me think people don't fully understand separation of concerns. If it's called `validate_state` it should damn-well validate the state. If not, it should explain what heuristics make a state "valid" *and why*, because it's counterintuitive. 
Sure that would work. Didn't know about cmath
&gt; It's not code narration if it's telling you the heuristics the function uses. I don't know why you're arguing with me about this. I said "it *sounds* like code narration." Obviously if the commenter didn't really intend to mean code narration, then I would have no problems. &gt; A docstring is meant to tell you how to use the function, not write the function. What counts as a valid state (assuming that it's not obvious it's a state of the US) is important to how you'd use it. I don't understand what exactly you're contesting in my comment. The use of a function is implicit by describing its contract. &gt; As would I, with the exception of mentioning accepting unset states. You might have missed my edit because I added that in. :-)
Ah, I was misunderstanding the context of what you were saying. 'T'sall fine, move along, nothing to see here. 
If you could go ahead and keep your memes out of /r/python, that'd be great.
This looks like regular logical 'or', rather than the annoying one that relies on short-circuiting. I guess we can agree to disagree on what "most people" would find easier. haha ... you're absolutely right that IsStateStringShort() is a terrible name for a terrible function. But I couldn't think of anything more descriptive for what this function does.
Eh, suit yourself ;). Since you're going to evaluate the result in a binary context, the short-circuiting is irrelevant. Just treat the result like a bool, much how you can with `re.match`'s result.
Made me think Final Fantasy Tactics, even moreso when I read "exp" and "range".
This is nice ! I think it can be a good way for beginners to approach regex practice before learning the standard syntax :) 
Cool. Thanks for the suggestions!
I've create a page with the list of Skeleton builder tools : http://wiki.python.org/moin/SkeletonBuilderTools
This seems like a legitimate bug - you should report it! The question is whether a token containing \x0c is valid or not. I do not think it is, in which case ElementTree should report the error in the parsing phase, not in the output phrase - but as you say, it's the reverse.
I had to vent somewhere. I figured somebody in this subreddit would understand. Plus, Lumbergh is classic. 
Hey, it's you UCSB guys! Awesome work. GAE can be quite handy but also quite expensive.
Meteor strikes, and the accretion and attrition caused by a pathological invasive species!
Where "quality" is defined as "having very few Coverity findings, given undisclosed Coverity configuration and custom modeling." I'm sure the CPython code really is of good quality, but I've seen Coverity have no problems with rather questionable code, and I've seen it completely freak out on code that there's nothing wrong with. Be careful to avoid reading too far into this result.
Is it like the old pylons?
Check out the suborocess module. Or use snmp to query the servers. 
Beautiful! Thank you!!
Thank you. I just did a search for this module and I found some tutorials. Do you have any online tutorials which you find helpful? From what I am seeing is that this module lets you execute actual Bash commands with Python. Yes?
Check the [platform](http://docs.python.org/2/library/platform.html) module out. And while you're at it, have a look at [pwd](http://docs.python.org/2/library/pwd.html?highlight=pwd#pwd) and [spwd](http://docs.python.org/2/library/spwd.html?highlight=pwd#spwd)
Nice! Thank you :)
https://code.google.com/p/psutil/
Yeah uh. This is /r/python. Also, the current year is 2013.
People can't mention other languages here now? Are we expected to just know that python is clearly the best solution for every problem ever?
don't forget `division`
Many of these aren't nearly equivalent. zopedb is a datastore vs sqlalchemy which is an orm/database wrapper, etc. Buildout is less virtualenv and more pip+fabric. While these are all nice interview questions, I think they're all a bit off what you look for in a **junior** python/django position (why would I care about python2/3 interoperability from a junior dev?). Junior python/django dev is about answering if you know python and the basics of the web framework (like django). In most environments, more senior devs/management will dictate flask vs django or nose vs pytest. Its good for juniors to learn the tradeoffs, but not really in the job description.
You're goal is to demonstrate understanding and command of the basic architecture and constructs of python web development. This starts with idiomatic python (including some pythonic constructs like list comprehensions, decorators, properties; especially if you're a convert from less expressive langauges). For django, that's showing an understanding of the key architectural patterns: the ORM including pitfalls and limitations, comprehension of the templating language and ability to define clean idiomatic views (preferably CBVs). Add in some of the contributed forms, auth and admin along with other bells and whistles and you've generally defined the skillset a junior django web developer. Substitute django with flask, pyramid or others as appropriate but I'd suggest there'll definitely be less *junior* positions for those more niche frameworks. The best way to show is to build projects sites using django and make those available on GitHub for prospective employers to inspect and review. 
&gt; until I feel comfortable using it. There is not such a difference as this. If you feel comfortable working with 2, you'll feel absolutely fine with 3, and equally vice versa.
http://python3wos.appspot.com/
More money means that we will be able to afford paying someone until numpy is fully implemented.
I use something similar to this for some of my multiplatform scripts. #!/usr/bin/env python import os if os.name == "nt": print("windows system") if os.name == "posix": print("linux system") [os documentation](http://docs.python.org/2/library/os.html)
I use QPython on my phone. You can check it out https://play.google.com/store/apps/details?id=com.hipipal.qpyplus
OP seemed to be well aware of the existence of other ways to do this, and specifically was asking about doing it in Python. So "here's something that's not Python" is pretty irrelevant.
I know it's a bit late news, but I was wondering that nb promoted mailpile as a python-written application here.
The subprocess module lets you execute system commands, kind of what a bash script does - [The documentation gives various examples](http://docs.python.org/2/library/subprocess.html#replacing-older-functions-with-the-subprocess-module) - [this StackOverflow answer](http://stackoverflow.com/a/2502883/745) shows how to call a command and get the output - [This tutorial](http://sharats.me/the-ever-useful-and-neat-subprocess-module.html) seems pretty complete (although it contains some fairly obvious errors, and I would very much suggest avoiding `shell=True` in almost all cases)
Not to mention the obvious side effect of this report telling this subreddit exactly what it wants to hear.
check out psutil
Check out the sh module http://amoffat.github.io/sh/
What you do with github really depends on what your goals are. Start small and build. For a job hunt, having a well-organized and *well-documented* small project or two that you can point to and say "see? I did this project solo" is good. It's nice if it can become a conversation piece or focal point for a job interview - why did you make this design decision? why did you create a dependency on this library? Then the job interview is more like you're speaking with a colleague about a design and implementation - which is positive.
I had py4a on my phone and thought it was solidly OK. It helped that it came with some good examples of code for making python take full advantage of the Android capabilities. In short, this solution is good, it works, it comes with good examples, but it may not be the easiest to set up and there may exist better solutions of which I am unaware. http://code.google.com/p/python-for-android/
To be fair, there's a reason there are a lot of potential replacements for Cpython currently in development.
Which is good, my thought process being: continued development = good; decided software good enough = bad.
can i use this as a frontend to an imap server or maildir or do i have to migrate my mail to a new storage (and change how i fetch, store and backup mail completely)?
quite a lot of information about Linux-machines is visible through /proc, reading files from there could probably help a bit. One example: f = open("/proc/version", "r") f.read() # OS version info
Though externally facing interfaces ought to change infrequently, and design philosophy really ought to converge eventually to something unchanging. Constant change is often the bane of a developer. It's nice to have some things that don't change, too. 
Although the syntax information can be found in the [nose documentation](https://nose.readthedocs.org/en/latest/writing_tests.html), I found that without a complete set of code examples, it was hard for me to use as a reference. I'm sure it works fine for some people. So that's why I wrote the post, to have a syntax and flow reference with code examples at every level.
This might be of good use http://architects.dzone.com/articles/linux-system-mining-python
I wouldn't necessarily equate development with change. Adding features, perhaps - basically just saying if it ain't broke, don't fix it. Unless you know how to make it better. Or want to add a feature.
&gt; It tries to cover a niche between Django and Pyramid So it's DYI like pyramid but not a massive framework like django? So what kind of features does it provide over pyramid then?
Well, of course, what I said should only be applied to legal and non-intrusion related things. 