Thanks, that is helpful.
I agree. We use python for some things and a lot of us devs are looking to move away from CF however our whole system would have to be redone. :(
HEEEEYOOO!
A small point - your naming conventions are a bit too C/Java/C# in style. In Python the usual naming convention is: SomeClass for classes some_function_name for methods some_variable_name for variables Also, have a look at PEP8 for how coding style standards can improve the readability of your code and how you can make it more 'pythonic': http://www.python.org/dev/peps/pep-0008/
This. Was about to mention it, but i noticed it was already posted. The function definition should ideally be outside of the loop.
Man, thats awesome. Wonder how hard it would be to emulate the instructions within the ROM too?
The article waxes lyrical about succinctness and gettin' shit done in few lines but he practically wrote a book in the most meandering of prose.
Yes, I did note in the article that memcached was almost certainly a better way to do this. But as I said, we made this engineering trade-off a couple of years back, it's worked out pretty well, and it'd require a lot of effort to switch. We may need to do it at some stage, but it'll need a bigger driver than an easily fixable issue with garbage collection.
I already bought it but I must say I would prefer to have it in print. 
I've never played much with the garbage collection. Is it difficult to avoid creating circular references?
Circular references are only a problem for reference counting. All other GC algorithms can deal with circular references easily.
I don't think it'd be too hard, but it would be conscious design decision to do so. I think we have a bunch of dict objects used for caches that mutually refer to each other. But then again, these are static caches that are always around, so won't be collected anyway. In our further testing of this, it turns out we basically don't have to run the cycle-detecting collector at all between our (once or twice weekly) deployment cycle, when the server processes are restarted and all memory is dumped anyway.
I gave my details to buy the book and then it said "Enter a password and we'll remember your credit card for next time" I must admit that really freaked me out... I just hope my details are really wiped from their system. Relevant info: https://gumroad.com/faq 
and comment the shit out of it: it only needs some seconds to grasp, but that double lambda with one-letter-args is a bit unpleasant.
If cost is a concern, perhaps a [Software Carpentry](http://software-carpentry.org/) course, at least as a first step, would be a good alternative.
I wish reddit had an option in it's API for this. If it already does and I'm just dense, let me know.
The others already gave good advice about the code itself. I'll give you some about hosting code on GitHub. Meta-files don't belong in a repository (there are exceptions, but generally you don't commit them). Not everybody uses Eclipse, so leave out `.project` and `.pydevproject`. Use a file called `.gitignore` to ignore certain file name patterns. Another good practice is to put your main executable file in the root directory of the repository so that everyone can immediately see what has they have to run. Meta-files and a folder named `src` are not very attractive. Next thing: don't commit databases. Those are generated files. No need to commit them. And you even committed two db files although you only use one of them in the code. Additionally a last advice on the code: use the following condition to make sure that your code is not executed when it gets imported: # imports here # functions here if __name__ == "__main__": # call your functions and run your code here
Try not put environment files, like PyDev's configuration files, or .idea folder, in git. These kind of files only matter to you.
Continuum Analytics (continuum.io) also offers similar courses, many taught by former Enthought folks.
My employer grudgingly paid my way in 2011 when my talk was accepted. The next year, they explained that they simply couldn't justify it as it wasn't "directly related" to my work (I was working as an engineer, not strictly a software developer). So I paid to go myself and announced I would need four days off to attend Pycon, which put them in a mild panic. I quit three months later since our ideas of advancing my knowledge obviously didn't line up.
Because I'm not using Python to do it.
Yes. Google's Graph API is basically a javascript library which you plug data into. So I wrote [this python script](https://github.com/kopf/chineseair/blob/gh-pages/chineseair/updater.py) to harvest and process the data, outputting [this javascript file](https://github.com/kopf/chineseair/blob/gh-pages/javascripts/data.js). This javascript is then [included in this html file](https://github.com/kopf/chineseair/blob/gh-pages/index.html) and the chart is populated with data on page load.
i downloaded it and its been good so far -- i've used django for a couple years now but have not had much experience with 1.4 or 1.5, so this book is great for learning some of the newer practices.
if you know what to look for, no.
Okay. I just assumed that since you are posting in r/python. I hope it was still helpful :)
get it, but although i learned standard ML, this has eluded me here, as it’s not too common in python. and i think it’s simply the nested lambdas that have my brain-compiler go an extra lap. let’s try something else (as direct assignments to lambdas can be easily written as normal function declarations): passes = [fn1, fn2, fn3] def compose(g, f): return lambda *x, **kw: g(f(*x, **kw)) pipeline = reduce(compose, passes[::-1]) hmm, better, i think.
Eh. Maybe. I dunno. I tried to write a PRAW-like library in Go but gave up after a bit, I might pick that project back up.
This is one of the things I love about lisp and macros. In clojure this is provided in the language as -&gt; or -&gt;&gt; and your test case would just be: (-&gt; 10 add1 (subx , 2) stringify) If only python had functions that didnt eval their arguments.
Nginx -&gt; Gunicorn (-&gt; Flask &lt;-&gt; Memcached) Fast, lightweight. Good enough for me.
I've been using mod_wsgi nearly exclusively until now, but in a recent project I've used uwsgi behind nginx and really like this configuration—especially because you can install the entire stack from a buildout script, which makes it really easy for developers to deploy the production stack locally.
Would it help to use Sina Weibo as a source as well? Or do the censors suppress any mention of smog?
We tried GUnicorn here and the performance wasn't impressive, not even close, so we decided not switch the actual mod_wsgi by something which don't come with enough benefits.
You must not do much online shopping.
Interfacing with C++ code is definitely something we deal with in the one week course - that's a common situation we're pretty familiar with. The one week general course is often geared toward scientists who are new to python, so the first two days will be pretty basic python (nothing like what you could expect from say taking an intensive course with David Beazley). We then go much more in details into the full scientific stack. Obviously, we can adapt the content to focus on different things depending on the demand. For example, I have once spent a full day talking about dealing with db in a 'pythonic way', using SQLAlchemy, which is not in our default course. Quite a few of us are rather involved in the python community, so we track the more recent developments.
As much as I love using requests over urllib2, this is a pointless, pretentious and rambling 'review' (I hesitate to even call it that) of a programming library. Citations of Hemingway, Austen, and Heinlein are utterly unnecessary, and the entire thing seems like an exercise in masturbatory narcissism disguised as 'waxing philosophical'. 
Hmm, explain? I do this all the time with zero problems.
If you touch the wsgi file it reloads the project, were you rebooting the server or something? Even restarting Apache is overkill.
Buildout is complex, because it can do much more complex jobs than virtualenv/pip. Like downloading, compiling, and configuring nginx, for example, or checking out a private project from github. If all you need to do is install a few python packages hosted in Pypi, by all means keep using pip.
For what it's worth I tested gunicorn as well for our application and found that performance was significantly worse than mod_wsgi. I guess it depends on what your application is doing.
I do a lot of it - but in France you are most of the time redirected to the bank gateway in order to proceed with the payment - IOW small companies can't/won't store your credit card details - the only one I trust storing my details is Amazon - but I guess I should not 
nginx + uWSGI, and I'm pretty happy with it (fast and lightweight enough), but I don't have any experience with mod_wsgi, so… cannot really compare.
uwsgi is fast, very reliable, and easy enough to set up. It's what we use in production on most projects. It also has an amazing amount of "full-stack" built in, such as a cache, a queue / spooler framework, and lots more. I'd recommend ignoring all that at first, and just replacing mod_wsgi. http://uwsgi-docs.readthedocs.org/en/latest/
 for page in range(0,10,1) why not just: for page in range(10)
This is my reason as well, knowing apache well [compared to the others] is what made me stick to it in big projects and at work, although one should also branch out and try other things, for example I use nginx with uwsgi behind it for my smaller side projects just to learn it and I am liking it with buildout specially since my customer has to be able to setup a demo for himself unlike in my day job where the dev environment is fairly static. 
Hmm. Normally I can't stand arty stuff, but this 'review' was pretty straight up with you. It wasn't pretending to be a complete technical overview. He basically told us that requests is shorter and more expressive, in a way he feels comfortable with. Like I'm borderline anti-intellectual, and I wasn't offended by this post.
gunicorn because it is the easiest.
If you're running mod_wsgi in daemon mode, you can just touch the wsgi.py file referenced by your configuration to reload the project.
nginx+uWSGI since I'm in a low memory hosting conditions.
Its the same process in India. You are redirected to your bank's site to authorize your payment. However, I can assure you that the process on this site is a pretty standard one for almost all online purchases in the US. 
I do come from linux, and live on the command line, but being required to install XCode really bothers me. Well, I'll consider it. Thanks for the explanation.
Gunicorn is fast if you use the meinheld or gevent workers. I personally use uWSGI in emperor mode as it's been consistently one of the fastest performers. I'm down with Apache if it's 2.4 and using the event MPM.
nginx + (gunicorn + gevent)
It's a really cheap vacation that also benefits the company because you learn a ton.
That was exactly the thought I had when reading your link. No reason to be running cycle detection if there are no cycles. Still, I'd run the thing for some time on a test box and look for leaks before trying to deploy it (obviously). To that end, is it possible to have the cycle detection system log found cycles?
When I suggested that I haven't played much with GC, I mean that I haven't manipulated it; I do understand the concept behind the various GC schemes. My question was more geared towards preventing circular references in Python so that the cycle detection could be turned off.
Not really. On windows you usually have the rights to pip install and on linux you get asked for a sudo password.
I've used mod_wsgi in production, switched to uWSGI, and am now using Gunicorn. mos_wsgi is the safe choice, but it's tightly integrated with Apache (obviously), and is a bit of a memory hog, and not the highest performance. For 99% of cases, that won't matter of course. :) uWSGI is nicely integrated with nginx (and really, why aren't you using nginx if it's an option?), and I found it to have a very solid core, but the documentation is a little lacking, and some of the magic features (emperor mode, etc) are a little *too* magic. More my fault than uWSGI's, but I burnt myself with them. And again, probably my fault, but I had an issue with memory leaks too, somehow, but too rare to really debug. Gunicorn has been very sane, and I appreciate the fact that it talks to the web server via HTPP; you can use whatever frontend web server you want, which adds some flexibility. Frankly, I haven't found any killer features uWSGI lacked, but it's been well documented, easy to configure, and performs well. My advice is "use whatever you want", but if you're really looking for advice, go with Gunicorn, it's just solid, stable, and nice to work with. But if you're already using mod_wsgi, it's probably not worth changing unless you're just bored and want to tinker with your stack. :)
I'd love a reply rather than a downvote. This is totally applicable, and I was forthright in mentioning my conflict of interest, which I could have easily omitted. /u/Kingino said that scripting is what they want to use Python for. An expert is going to give a tutorial on how to write and maintain really good scripts. This alone should be enough to sell their boss on paying for pycon. Again, I'm biased, but his courses are very good. He gets excellent feedback year after year, and Pycon keeps bringing him back. I was there last year when a guy from an Ivy League university approached him in the hallway and begged him to come and teach a private tutorial for his department.
Huh, that's great to know, thanks -- we're on Python 2.6. :-) From the [release notes](http://docs.python.org/dev/whatsnew/2.7.html#optimizations), it also looks like they sped up the collector by not tracking certain objects that could never be involved in a reference cycle (for example, tuples and dicts that contain only atomic types like int and str). BTW, it looks like the figure is 10% rather than 25%.
Apache + mod_fastcgi + flup
[django-cherrypy-odeon](https://github.com/odeoncg/django-cherrypy-odeon)
[Why don't we look at the source?](http://hg.python.org/cpython/file/582ecb9a4061/Modules/gcmodule.c#l1032) Somebody might want to fix the documentation, but OTOH it does convey the right idea, while the people for whom the details are important generally should be able to go and look at the source.
Do you have your own loadtest rig or use a SaaS option?
I haven't looked at the reddit API much so I'm as unaware as you are. HN was getting beat up by crawlers in particular and implemented bigrss as a good faith compromise. There's also no official API requiring users to implement their own methods. What would something like bigrss allow you to do with reddit that you can't now? Is it the efficiency or are you hitting a wall of some kind? If it's a private project no worries. Just curious. 
we use our own loadtest rig specific to our platform. 
Good call. Interesting -- yeah, it does look like a discrepancy between that what's-new doc and the code.
nginx fronting gunicorn /w eventlet 
nginx + uwsgi works really well.
In our office we use varnish -&gt; apache -&gt; modwsgi-&gt; django For most of my (large scale) clients I tend to use varnish -&gt; gunicorn -&gt; django, because I don't like the overhead of apache when it's not needed
It's not a private project, the annoying thing, I guess, is there's no endpoint on the API which I cant say: { "from": today(), # you dig it "subreddit": "whatevs", "to": today() + A_Day * 10 } This is a contrived example, but you get what I mean.
And frankly that's what scares me about uwsgi -- it's got dozens and dozens of poorly documented, weirdly-named options. It's not like they break frequently, it's just really, really bizarre. Gunicorn is my current favorite because it's straightforward. I don't need raw performance, and less time debugging crashes off in C land is more time working on features. That was more of a problem with mod_wsgi. Segfaulted all the time, for no apparent reason. But even if uwsgi doesn't *usually* crash, when it does it will still be a pain to diagnose compared to a pure(r) python server. A fun fact for gunicorn and nginx both (and probably uwsgi) -- kill -WINCH &lt;master_pid&gt; gracefully shuts down all the workers and queues up new connections so you can do maintenance on the backend! Then just -HUP to resume.
Thank you!
I *really* like uWSGI. It has made handling growth and deployments extremely easy. For deploy, it is a matter having emperor mode running on the worker box(es) and just pushing the new app or updated app and placing or touching (respectively) the config file and boom - done (provided the nginx config is done first, or uses one of the uwsgi magic options). For growth its similar, just add another worker box with the same image as the others, make sure nginx knows about another upstream server and, you're good to go. (provided the rest of your infrastructure can handle it of course). It took me a little while to figure out the docs... the project is pretty well documented, it just is poorly organized documentation. Googling a bit though generally returned links back into the uwsgi documentation itself, so they know their stuff.
One more for nginx + uWSGI here. Gives me considerably better performance and RAM footprint than Apache + mod_uwsgi. uWSGI has a graceful reload method, since you mentioned it: https://projects.unbit.it/uwsgi/wiki/Management
I've used FAPWS1 (in fact contributed to it way back when). It is nice, but it is only fast if you have everything in your app set up to be event-driven anyway (kind of like tornado). It was good for the case I was using it for, but for general web app development it really wouldn't work well. And anymore I'd probably just use tornado instead for the same thing.
I made a quick test of uWSGI's graceful reload today in my dev PC, it's very simple to setup and "ask" to a reload. I'll make more powerful and reliable tests later.
I use the touch method in my server start/stop/reload script. One more nice thing about uWSGI. All of the config settings are supported through command line arguments as well and the config files themselves support multiple "languages". It makes testing different worker configurations a breeze.
Just adding nginx / uwsgi too. I agree, it took me a while to learn how to deploy with uwsgi / nginx too.
nginx + uwsgi + supervisord *edit: supervisord to keep uwsgi service running
Also I wrote about it here: http://jedidjah.ch/code/2013/1/19/why_jedi_not_rope/
Was throwing an error i had never seen before. the wfea.py file does not use New-style objects. basically: class WFEASearch: =&gt; class WFEASearch(object): After that it worked fine. I'll leave another comment after i play around for a while. 
can you show me how to install postgresql with virtualenv+pip?
nginx + paste for my first non-app engine apps. Supervisord to keep paste &amp; db up. Buildout to fetch everything. My first project used Grok which is an abstraction over the old Zope framework that nobody talks about anymore lol. There is so much zope related code hanging around though and the ZDB is a very nice minimal Object DB in my view, but I guess things just got too unwieldy? Open mind as to what to use next so will be interested in opinions too, but FWIW I'm happy with nginx as reverse proxy. I've been looking at Flask. Also what did you guys make of [this](http://nichol.as/benchmark-of-python-web-servers) comparison of various wsgi servers?
i think your bullet points would be more convincing with examples. I can really only relate to the last 2, which are easily avoided. don't write invalid code, and don't make big files. but if you are going to claim jedi works better on bigger files, you should say how big they are. I'm honored that I inspired you to write a blog post though. Do I get some credit? :)
One gotcha with uWSGI as it differs from gunicorn: uWSGI loads your Python file *before* forking by default. Gunicorn imports your Python file *after* forking by default. If you're used to post-fork importing, you may safely create file descriptors (like database connections) in a global scope. However, with uWSGI these file descriptors will be shared between processes. Meaning there will be a complete disaster when multiple clients try to use the same connection concurrently. I ran into this with pycassa. It appears uWSGI has a lazy (or lazy-apps?) option to behave like gunicorn (import post-fork): http://uwsgi-docs.readthedocs.org/en/latest/Options.html#lazy
Agreed. Many people diss Apache on grounds of memory footprint, but apache is modular. Now I've never compared a stripped down Apache to an alternative but it works well enough. 
nginx + supervisord (fcgi-program) + flup
Huh, I haven't seen that error myself either. Google didn't turn anything up that was helpful. Glad you managed to get it working though :)
nginx + cherrypy
Some would argue better than Apache.
A few higher level comments: Normally api keys are meant to be kept private. It's common practice to use variables to define these at the top of your file, and distribute a version of the file where these are blank. For python, the standard practice is to use all uppercase for constant variables, like this: PASTEBIN_API_KEY = "xxxxx" You may be interested in http://pcpartpicker.com/. It solves the same problem as your code. Also, I noticed this code is 5 months old.
Incidentally, [Markdown](http://daringfireball.net/projects/markdown/syntax) is the same syntax that Reddit uses for comment formatting. So if you can post on Reddit, you already know the syntax for doing nice formatting of a `README.md` file on GitHub. Just write one and stick it in the root directory of your project, and your GitHub repo will be a whole lot nicer.
Yes, that's what I do (serve static assets with nginx), and indeed I don't see any reason not to… 
Yeah, it's old because I didn't know about this subreddit, and to date it's still the best thing I've made (sadly.) Also, I suppose I should remove the API key from that. =/ Thanks!
Yeah, the whole filesystem thing felt kinda forced and I felt like there WAS a better solution, but that was what I found at the time and it worked, so I employed it. As for all the tips, thanks! I appreciate them.
Why is that sad? you made some shit... lol. It's more than I've done thus far! :P
I don't use pip to install postgres, just Python packages. In this case, I use apt-get.
WSGI is a Python-land API spec, not a network protocol. It specifies how application(probably built by app framework) and application container(flup, uWSGI, etc.) talk to each other. The network part is irrelevant to WSGI. The application container might or might not talk to the outside world via a network protocol(FastCGI, HTTP, etc.). Take [WebTest] for example: it runs your WSGI app and makes requests to test it. But both your app and your testing code are in the same process talking via the WSGI interface. No network involved. [WebTest]: https://webtest.readthedocs.org/en/latest/
I was misunderstood, but I know that WSGI isn't a network protocol. Still, thanks for the explanation.
We usually use for such things the [ConfigParser](http://docs.python.org/2/library/configparser.html) or YAML files (thou you need PyYaml then). Basically, no matter what format you keep it, you keep it in some external config file that doesn't go to the public and all the fregile data is loaded at the right time from it. One more advice as for the begginer (thou the code is really cool - I teach Python and this is a good code): learn [pylint](http://www.logilab.org/card/pylint_tutorial). It can be quite frustrating at first but if you learn to incorporate it into your workflow, you won't regret when the codebase will grow. 
OP tested with Python 3.2.3. Python 3+ has no old-style classes.
Hmm, i gues you are right. I thought python was moving the direction of always listing what you derive from, but "class Foo:" seems to still be valid. In any case there was an RTE about trying to inherit from a class that when i googled the message pointed me in the direction of the above fix.
I'm one of the authors. Print is hard. We have to order individual print copies to ensure that the front art and the layout works. If it doesn't, we have to make alterations and order another. We plan to have print in about a month. ;-)
I'm one of the authors. We use Gumroad for publication, and they do their payment through stripe.com, which has a much better security record than PayPal. Speaking of PayPal and Google, if there are any issues with your payment you and I are screwed. They don't answer any service requests. We'll have to go the PayPal route at the FINAL release but I'm worried about handling the service requests. :P
I thought django recommends separating the two? Do you just define different vhosts and call it a day? 
apt-get only works on debian based distributions and you have to have root privileges. you can use buildout to to install everything you need for your development/deployment stack given a little effort be it python packages(which it uses pip for) or binary packages or source tar balls. that's the reason for the "complexity". And it's awesome when you have a fairly complex project with lots of moving parts. virtualenv+pip covers only 50% of the use case for buildout. 
*rise* I'd like to know how unique the passenger 'zero copy' and 'scatter-gather io' techniques are and what the measurable benefits are, all compared with other wsgi servers? Also, does passenger provide full support for virtualenv yet? Thanks.
Nope ... it's just a proxy server. I'm just saying ... if you need hot deploy you will probably operating at a scale that involves multiple servers - so why bother with single server hot deploy solutions ?
Out of curiosity, why did you decide to use pypy in production?
You do understand that the key is still there in your git history?
OP used cpython 2.6 and it has known performance problems with allocating lots of objects. disabling the GC does not sound like a great slolution then
You can use the data from JSON ("Title") instead of parsing the item page, too.
You should see a doctor about that.
&gt; Also, I suppose I should remove the API key from that. =/ I saw you took it out, but it's still in the Git history. If you can, try getting a new API key completely.
I know this isn't stack overflow but I wouldn't mind seeing people post more content like this to this sub.
Ahh - I see the difference now. Thanks for clarifying. 
[Yes.](http://jacobian.org/writing/django-apps-with-buildout/)
&gt; You can stick literal strings next to each other and they're automatically concatenated. Not gonna lie, I didn't know that. Been using Python for *quite* a while.
Intersting... that's like having sed, grep, etc... on python, very good for using on windows.
If that's really what you're after then cygwin may be the better solution. 
Thanks for that, I'll do that.
why? if i already have python installed... is less hassle than installing the whole cygwin just for 2 or 3 tools.
Maybe not a good advice but instead of using urllib mess go for requests which is a very nice lib. It will simplify your code a little bit but add a dependency. 
I can't argue that (cmd.exe sucks)... But this might help for some quick batch operations.
I don't mean the GC in general, but just the circular reference detection, assuming that they're separate. I suppose I'm not sure if one can be disabled and not the other, as I mentioned, I've never played with it, just an idea.
In that case, class-based views are pretty amazing and you should make them a part of your repetoire.
Hey so I apologize, I am not really that great at programming so this might be a stupid question. When I run it,I am missing "pygame" . I am running this through PythonWin. Am I doing it wrong?
&gt; At the end of each chapter there are several questions to be answered, however there seems to be no answer manual and I was wondering if someone has a link to the answers? 1) This post would probably be better received in r/learnpython or r/learnprogramming. 2) You are basically asking for answers to your homework, rather than trying to gain an understanding of programming or asking a specific question. Don't get upset when somebody inevitably says something... impolite... to you.
If you want to check your answers, or you're stuck, talk to classmates or instructors. That usually helps. &gt; btw. any quick tips that I can do to make my programming life easier? This, here, is the important part of your post. Check out the sidebar. The online books are good; I especially recommend [Learn Python the Hard Way](http://learnpythonthehardway.org/) if you're new to programming. If you have questions, /r/learnpython pretty reliably delivers answers. Above all, program. Hands-on experience with programming is the only way to develop practical ability, and it makes any accompanying textbook readings and lecture material a lot easier to understand.
I like concurrent.futures a lot, and presented it at EuroPython 2012. Getting it to work nicely with ^C proved difficult, especially with multiple processes. Unexpected exits also cause problems, as I recall. I've mostly worked out how to handle these problems. Sometimes I found that putting a try/except/else wrapper layer for the submitted function call, with some info to print a "Done!" or the traceback helped debug these problems. Beyond that I would need to see your code which triggered this problem.
This response may be even better: &gt;I would love to see VB or C++ code myself. As a beginner programmer it would be for me easier to understand. Yes, this code ported to C++ would obviously be far easier to understand.
We plan to try PayPal during the BETA or FINAL release.
I'm one of the authors, so I need to make something clear. We give out copies of the book to those who can't afford it. Which means students, interns, unemployed developers, or developers who are under hardship conditions. We've been all of these things, and understand what it's like to not be able to get the resources needed to improve your condition. It's one of the ways we are paying back to the community for being awesome. The book isn't free. We are giving free copies to those who need it. Which mans we have no interest in helping those who don't need it. You know who you are. If you can afford to buy a video game a week you can afford the book. ;-) I hope this clears things up!
If you are not enjoying the challenge of solving problems in a language as awesome as Python, it seems to me that you doing the wrong course.
I just found out about that, now, as well. I just feel better concatenating the strings using the '+' sign. Probably just habit.
In simple cases, I use Apache+mod_proxy+[waitress](http://docs.pylonsproject.org/projects/waitress/), including a [small wrapper around waitress](https://github.com/kgaughan/waitress-serve) for situations where I either can't be bothered or can't justify using Paste. Waitress is nice in that it has no dependencies, works widely, is easy to use, and in spite of being written in pure Python, is pretty efficient. If waitress doesn't fit the bill, I fall back on using uWSGI. I automate my deployments with Fabric and use Supervisor as the process monitor, so I rely on them to do reloads.
Intended to make it look as close to the Haskell equivelant, which is completely point-free. pipeline :: [c -&gt; c] -&gt; c -&gt; c pipline = foldl1 (.) &gt; pipeline [(+1), (*2)] 25 51
On some projects I use [Circus](http://circus.readthedocs.org/) with chaussette &amp; waitress, so I can manage web workers like other processes.
With [mingw](http://www.mingw.org/) you can run bash (and ls,cat,etc) on windows. I use it for git and python stuff. 
I always liked http://demo.visualcaptcha.net/ This scheme. Failing that I'm not too fussed to get a simpler solution due to the good service reCAPTCHA is doing
I would argue that using '+' is more Pythonic than not to. `Explicit is better than implicit.`
The Sobel filter is an edge detector. It turns a picture into a black and white picture, where white represents the edges. The "swirled" pictures will have longer (stretched) edges, so the sum of all white points will be greater. Therefore the "unswirled" one will be the one with the lest edges detected.
You don't need to check duplicates manually. You can leave this job for the DBMS. SQLite will drop an `sqlite3.IntegrityError` exception if you want to insert a duplicated key.
Explicit is better than implicit, after all.
Do you have some performance benchmarks?
Circus uses the pre-fork model like Apache or Gunicorn, so the performances are tied to the wsgi server plugged behind it - like waitress, gevent, meinheld or uwsgi You can find a few benchmark links at the end of this doc page though: http://circus.readthedocs.org/en/0.6/sockets Direct benchmark link: http://blog.ziade.org/2012/07/03/wsgi-web-servers-bench-part-2/ **disclaimer** I am one of the authors of Circus
This scheme seems easy to break. Either you gather all pictures and name it or you can let the application just try a captcha, then name and picture is associated with the result (either correct or wrong). Sooner or later you have all pictures with the correct name and solve this captcha every time. **edit** even better the pictures are already correctly named (http://demo.visualcaptcha.net/images/visualcaptcha/airplane.png), i guess a search in the text of the form for all the diplayed pics will probably get the correct solution
Actually, I saw your keynote at PythonBrasil, circus was much discussed during the event. I'll take a loog at circus+chaussette, thank you!
What happens if I do something like set = MyVersionOfSet() x = set('abc') | set('cd') Will it optimize it, and if so, what type would x be?
Seems to just be an empty wordpress site. Can I suggest getting content before announcing it further? Sorry if I sound skeptical, but there are many other sites like this that have one or two posts and are dead by the following week.
That's the problem, unfortunately. Why should someone spend their time contributing content to your currently empty site that offers no unique features, versus the many other python sites? Build up some personal content, and try to drill some unique aspect into it, and people will be far more willing to get involved.
At least optimizing it to: x = set('abcd') Should not require knowledge of your type.
or that MyVersionOfSet() isn't a set at all and set('abc') | set('cd') means blow things up!
Thanks, noted. Will remove the topic now. :)
What it does is called [constant folding](http://en.wikipedia.org/wiki/Constant_folding).
Yeah, the only sane way to use urllib2 is to provide your own headers. I should update that comparison to do SSL verification. Then it'll be much more fair :)
There's no such thing as an AST optimizer for Python that is both correct for arbitrary programs and non-trivial in power. The language provides too many hooks for overriding just about every behavior. You can't formally describe the semantics of any fragment of code in isolation without also stipulating that no other body of code interferes. That said, it's nice to have a constant folding engine that presumably works in common cases where monkey patching, reflection, etc. do not interfere. Although I'd probably want to call the optimized version of compile() myself, rather than have it replace the built-in compile(). It would be a hell of a bug when I discover/remember that I'm getting incorrect results for my program because of an incorrect optimization I turned on and forgot about. Also FYI, the built-in ast module has limited support for evaluating an AST expression consisting of constants. That's probably not as powerful as what OP's doing, of course.
When the MintEye CAPTCHA first came out I did something similar in but 10 lines ;). A different method though. My method essentially looks for the image with the greatest horizonal an vertically aligned features in the image by looking for the image whose FFT has the greatest difference between axial and diagonal frequency components. http://nbviewer.ipython.org/urls/raw.github.com/rjw57/minteye-captcha/master/captcha-test.ipynb 
please do it, it makes that comparison look less like a boast :) PS: impressive how your flair in this subreddit shows what you *made*, while mine only shows what i *like to use*.
Hey Wbeyda, Sorry if I came across as a jerk. We were and are delighted to have given you a copy. You are a developer at heart and we hope our book can help you. The reason why I wrote my comment because we've had a number of people email us and say, "SEND ME YOUR FREE BOOK!" without sending their name and background. Or they let us know how they are working for well funded &lt;COMPANY X&gt; and heard about our "Free Book". Does that make sense? Again, hoping I'm not sounding like a jerk.
&gt; It would be a hell of a bug when I discover/remember that I'm getting incorrect results for my program because of an incorrect optimization I turned on and forgot about. But surely the unit tests, which you most certainly write for every single application, would catch those issues. ;)
This does not honor the language semantics, if you're really interested in Python performance I think going down this path is a serious mistake, and highly encourage you to take a look at/get involved with PyPy (but of course I have a vested interest in saying that!)
I'm working on a program that transforms other programs. It relies on the Python parser, though not the compiler. If I used something like this and it hooked into the built-in parser, it would affect not just my own code, which is unit-tested, but also the code my program transforms. Of course it's ultimately my responsibility, but it's a little scary to contemplate this kind of interaction.
I don't understand why these lines work newegg_URL = raw_input('Enter the URL of the Newegg item: \n') not_product_code = 'http://www.newegg.com/Product/Product.aspx?Item=' product_code = newegg_URL.replace(not_product_code, '') product_info_URL = 'http://www.ows.newegg.com/Products.egg/' + product_code data = json.load(urllib2.urlopen(product_info_URL)) doesn't this create an issue in that you have an 'http' in the middle of the url?
Some people do seriously use it for real development. Thankfully, not too many people. Otherwise, it does have a legitimate use in the form of VBA macros. The easiest and best way to script Excel, Outlook, Office etc. is with VBA.
I once met some VB coders. We didnt get along well. Even the most basic concepts like Error Handling or running code on multiple operating systems were given completely blank stares "Why would you want to do that?" Afterwards they sacrificed puppies on the Microsoft alter.
I'm buying copy, looks like a cool book :)
that explanation should be in the blog post. the given explanation is sufficient, but not as good: &gt; This simplest way of doing this to to take the derivative of the image (in the Python above, by using the Sobel operator) and sum the result (take a look at the Wikipedia article to see how Sobel picks out the edges). We then select the image with the lowest ‘sum of edges’ as the correct answer.
awesome post. and it shows what ipython really is made for.
As someone paid to maintain an existing code base and develop new features in said code base, unfortunately yes.
I totally understand. Overall it sounds like the reception is very warm and entheusiastic. I wanna write a book called "PHP the bad parts / Why python?" I've read so many python books. But I think most just browse over the language. Or the examples are not real world enough. They assume that the language is so high level that there is no need to explain the under workings of it. Think like a computer scientist python, Dive into python, Learn Python the hard way, Python Games, Invent your own computer games with Python being the worst. L=[x+y for x in 'ABC' for y in '123'] is boring and unmemorable. deck = [rank + suit for rank in "A23456789TJQK" for suit in "CDHS"] is self documenting it build a deck of cards! O'Reilly's Learning Python goes really in depth and leaves no stone unturned for 2.6/3.0 so I think it took a big wordy book like this to finally start getting it. But still the examples are less practical. So far your book is great I've only read the first chapter. But I'm enjoying it very much. Sorry to hear about all the freeloaders. I think it's just the nature of the beast.
That depends on how you design your program. I guess you could try to avoid circular references but they're bound to happen by accident in any complex program, and of course there are many legitimate reasons for circular references.
Im just learning python but from what i can tell is that when he uses the third line [ product_code = newegg_URL.replace(not_product_code, '') ] hes replacing the first http (and the rest of whats stated in line 2) with nothing ( " '' " ). Please correct me if im wrong.
I may be talking bullshit, but personally think that backporting features has little to no effect on the decision making of whether to upgrade to python 3. My logic is that people that use these features have no intention of upgrading in the short-term or mid-term. There are plenty more other reasons preventing their upgrade such as: * Lack of python 3 support for 3rd party libraries * No business benefits * Lack of official support from vendors From a management perspective, there's nothing new in python 3 that creates any immediate benefit, other than being able to say "we're using the latest and greatest" and even then that's somewhat debatable. If python 3 can demonstrate a 20% performance increase across the board or even anything quantitative, then there'll be a better case for it. Sorry for ranting, but this is how I see the state of things. I'd happily upgrade our apps to python 3 but there's just so much legacy that it can't be justified. In the meantime, I try to write my code for python 3 so if we do end up upgrading it'll be slightly less work.
Well crap, I had listed the wrong code. The correct code is linked now, but here's the direct link (finally): https://dl.dropbox.com/u/27629958/jcopro.net%20files%20for%20download/pymcu_circles-1-20-2013.py
It's not like the users won't upgrade, but those niche server distros still ships Python 2.4 That makes me rage.
nginx + gunicorn
Actually I think it's exactly the opposite. As far as I can tell there are many people out there that recognize that eventually things will move to 3 (definitions of eventually may vary), but in the mean time, if I'm on Python 2 and I have a need for a particular Python 3 feature, I have 3 options: 1. Write the feature myself -- probably not compatible with the Python 3 standard library unless that is my explicit goal. 2. Find a library that implements the feature -- again, probably not compatible with the Python 3 standard library unless that is its explicit goal. 3. Use a Python 3 compatibility library like the one posted here. (Different from 1 and 2 because its goal is to be compatible with the standard library) I like option 3 the most. It means that I'm not adding additional dependencies which would hold me back from going to 3's standard library, and when all of my other dependencies are converted and ready for 3 I just flip the switch and I'm back to using the standard library version. (Assuming a good back port) If back ports such as this weren't available then it makes it harder, not easier, for everyone to get there. The motivation to switch to Python 3 comes when I no longer want to ship my raft of dependencies along with my code; after-all, in 3 they are in the standard library.
Nginx and uWsgi in emperor mode
Not-stupid Unicode. If you do something stupid, it will fail fast(er) than in Python 2, where it would work right up until your important new Asian client tried to use the system and it died.
how does it [beg the question](http://yourlogicalfallacyis.com/begging-the-question)? also, no, I don't like 3 - I'm quite content with 2, I'm more interested in seeing libraries and utilities than new language versions.
Apologies, I thought I was using the phrase in the correct context. Thank you for the link.
the proper wording would be "raises the question". :)
Yup, but unfortunately, change only happens when something fucks up. I've learnt that in large organisations, you don't get rewarded for preventing issues.
I'm using repoze.lru, it has the same interface. Which should I use? Also the only thing you have to do to backport that module is change everywhere that uses the 'nonlocal' keyword.
Cool! Can you make it comment on the thread with its findings? 
https://github.com/drkabob/most-common-words/blob/master/commentbot/bot.py#L9 You never close this file. You should use the 'with' keyword in these situations. Example: &gt;&gt;&gt; with open('/tmp/workfile', 'r') as f: ... read_data = f.read() &gt;&gt;&gt; f.closed True Using 'with' isolates all your file-manipulation code to one place/scope. Makes things nice and clean.
- You may want to use `collections.Counter` to count words. - If a word is a repetitive then it should be considered as stop word and should be ignored. Have a look at [Tf-idf](http://en.wikipedia.org/wiki/TFIDF).
I use it. It works as advertised.
These are not as powerful, indeed. But: * you can use some powerful python console (ipython, qtipython, etc.) * everywhere you have a python installation * the scripts will work out of the ~~box~~ module, everywhere * you get some powerfull features of Python that are more difficult to use with a shell (the itertools, for instance, are very intuitive)
Pygame needs to be installed as well as python. You'll need the one to match your version of python (e.g. python2.7).
Pyxshell have stream combinations operators (+, *, &gt; and &gt;&gt;) that are not available in Pipe (at the moment). Maybe one should add Pipe's names to pyxshell? Would it be a problem to have two names for the same function?
See also [Chut](https://github.com/gawel/chut).
"self.assertEquals is still 3x more verbose" and my soap washes 9 times better:) That's a nonsentence: it is just 1.44 "more verbose" ;) The fact that looks silly is your opinion and I'll respect that but having "some" experience in testing I garantee you it is not: integration with upstream tools and commonality with other languages is in in fact way more important in the overall architecture than saving few "boileplate" code (one line most of the times). Pushing out a wrong architecture because of the dislike of OO (in this case) it should be a no go. Beside self.assertEquals( f(x,y,z) ==g(a,b,c)) is not the way to use it, self.assertEquals( f(x,y,z), g(a,b,c), "boo that didn't work as expected") is peraphs a better way.
ok, since i’m of the impression that i have a pretty good grasp on python, it was about fucking time to learn everything about ALL builtins. my findings: 1. as you said: `vars`. much better than `.__dict__` 2. `eval`’s and `exec`’s slightly less evil brother, `compile`, returns an abstract syntax tree of a compiled python file. 3. never thought about `super` being callable outside of everything. doing so without arguments, however, will yield a `SystemError`, since `super`’s context sensitive custom `__getattr__` method can’t do sensible stuff outside of a class. 4. `int()`, being called without arguments, returns 0. 5. `pow` exists (i always used the equivalent operator), and it even has extra functionality by providing an optional third argument: `pow(x, y, z)` is a faster computation of `(x ** y) % z`, just like `divmod` is the same for `(x / y, x % y)`. 5. `print` in 3.3 has a `flush` kwarg. finally! 6. `help` in the interactive interpreter is actually an instance of a helper class whose `repr` is the string `'Type help() for interactive help, or help(object) for help about object.'` thus when typing plain `help`, you get help! bonus: * type can’t just return an instance’s class, but also create a class by being called like `type('name', (BaseClass1, …), {'field_1': 'fieldvalue 1'})`. (bonus because i knew that, but it’s also uncommon builtin knowledge)
...That thumbnail.
I don't know anything about repoze, but Raymond wrote the implementation in the standard lib, so I'd probably roll with his. Here's what I do (roughly speaking): try: from functools import lru_cache except ImportError: from my_module_of_backports import lru_cache That way I get the std lib's version (which is what most people would probably expect) if I'm on a new-enough Python, and I get the backport from the person who implemented the std lib's version (and passes all the tests for the std lib's version) if I'm not.
Based on the documentation, it will not optimize that unless you've configured the 'builtin_funcs' feature. In that case, you are telling it that 'set' means the built-in function. So yes, you can lie to the software and it will believe your lie.
I love the expectations that people demand on alpha-stage software. It makes me real happy to see a toddler first steps timed against the 100 meter dash. I adore it when people keep their software hidden in the darkness and only release it when it can face all challengers.
Yeah, there's some fairly handy stuff in __builtin__. On 6 and flush, you can also just use unbuffered mode in Python prior to 3.3. Ran into a problem that needed that here: http://stackoverflow.com/questions/3670323/setting-smaller-buffer-size-for-sys-stdin Also for 2, while not perfect, compile and exec is used in a lot of projects as a manhole/remote console mechanism where you can explicitly assign dicts to represent locals and global. It's not 100% safe as you can still escalate upward and get access to some fairly dangerous stdlib API's.
I don't see why you would be snarky; the software has enough information in this case to tell.
It's a shame that there's no C#A...
Tell some stories!
I guess we write software differently then. My usual method is to start out small and test. Add a little more and test. Repeat until satisfied. I suspect this is how a lot of software is written. I'm genuinely surprised that they would have spent a month on the code and not once thought to, you know, check if it actually does what it says it does. Why have you made it your personal goal to get people to release software (Whatever *that* means when the software is publicly hosted) early in their development cycle? If, like you said, this software requires more time in the oven, then wouldn't releasing it early have the opposite effect of what you want to happen by releasing early? Genuine questions, no derision, like you were expecting. If you *did* read my post history, I rarely deride unless the poster was posting ridiculous crap.
My apologies. I did not mean for that to be snarky. I intended for it to be jocular. It is hard in Python code to determine if there is enough information to tell in this case. For example, someone elsewhere could have changed \_\_builtins\_\_.set. The builtin_function setting assumes that if something is named 'frozenset' then it will be a frozenset. The easiest way to figure this out is to try it yourself. You'll have to use 'frozenset' instead of 'set' because the documentation says that it only optimizes '|' when the two arguments are constants; sets are not constants. % cat erez27.py class MyVersionOfSet(frozenset): pass frozenset = MyVersionOfSet def spam(): print frozenset("abc") | frozenset("cd") % python erez27.py MyVersionOfSet(['a', 'c', 'b', 'd']) % python ... &gt;&gt;&gt; from astoptimizer import Config, optimize_code &gt;&gt;&gt; import dis &gt;&gt;&gt; code = open("erez27.py").read() &gt;&gt;&gt; dis.dis(compile(code, filename="erez27.py", mode="exec").co_consts[2]) 6 0 LOAD_GLOBAL 0 (frozenset) 3 LOAD_CONST 1 ('abc') 6 CALL_FUNCTION 1 9 LOAD_GLOBAL 0 (frozenset) 12 LOAD_CONST 2 ('cd') 15 CALL_FUNCTION 1 18 BINARY_OR 19 PRINT_ITEM 20 PRINT_NEWLINE 21 LOAD_CONST 0 (None) 24 RETURN_VALUE and now I do it with the optimized version of the same code &gt;&gt;&gt; config = Config('builtin_funcs', 'pythonbin') &gt;&gt;&gt; dis.dis(optimize_code(code, filename="erez27.py", mode="exec", config=config).co_consts[2]) 6 0 LOAD_CONST 1 ("frozenset(['a', 'c', 'b', 'd'])") 3 PRINT_ITEM 4 PRINT_NEWLINE 5 LOAD_CONST 0 (None) 8 RETURN_VALUE You can see that this AST optimizer does not do the code flow analysis needed to figure out that a global overrides a built-in. I lied, and told it that it's safe to assume that a 'frozenset' lookup in a function will resolve to the built-in function, even though it wasn't. There are ways to look at the control flow, and especially with whole program analysis, to figure out this optimization automatically. That's much harder than having a user-defined flag saying that it's safe to assume the given optimization.
I'm planning on setting up a bot that will post its findings on the front page posts every hour or so. Until then you can generate your own findings [here](http://mcw.welcometonathan.com).
&gt; you get some powerfull features of Python that are more difficult to use with a shell (the itertools, for instance, are very intuitive) Would you mind providing an example where this would be superior to standard python idioms or bash?
420 Blaze It :D
Almost there, but Sobel actually returns an approximation of the derivative of the image (it is not, on its own, an edge detector). More accuracy, the OpenCV function returns sqrt(dx^2+dy^2) for each pixel. So, the returned value is in the range 0-255, not binary. This could then be thresholded to produce a binary image of 'edges', but that isn't what is done here, as you are then effectively throwing information away.
Sorry to nitpick, but wisty's explanation isn't quite right (see my reply). However, you're right, the article could have explained it in a bit more detail. Reading the wiki article would be more enlightening/useful though.
What am I missing.. It takes my computer 2.47 seconds when paralellizing the calculation of factors in range(10000) with this code, and 0.28 seconds when using a standard map() instead of executor.map(). I have 2 cpus on this machine.
It appears that you strip out the common words using the 1000 common words dictionary. The problem with this is that this dictionary contains words that may be relevant to the topic (college, god, medical) along with the words you don't care about (the, me, it, etc). I'd recommend a quick scan through the list of words, and remove any common words that you don't want to filter. I'd also suggest moving the python code to Google App Engine, so you can have them host it. You could then set it to track subreddits over time, using the google app engine persistent data store. This would allow you to provide "Top 10 words used in /r/politics this month" and similar type filters. Google App Engine cron jobs could do the counting calculations regularly, instead of on demand. Anyways, awesome work. 
This is actually quite useful! I tried it on the "what WSGI server" one and the top #3 words are actually the most used servers
With comments like "To summarise: / Wah wah wah wah, way / I'm a whiny little bitch" and of course your swearing responses to this thread, I was doubtful of a civil response. I was mistaken. This astoptimizer project has full correctness tests, and developed in exactly the manner you promote. You need only check the commit history to see that each contains small changes and includes changes to the unit tests. The tests test the correctness of the transformation, not that there's speedup, but as I said, all of the transformations are well-known cPython optimizations currently done manually. You believe that the projects main goal is faster performance. Its primary goal now appears to be optimizing the size of the AST, with improved performance as the secondary but expected effect. I have made public software release my own goal because I agree with the authors of the recent paper "Best Practices for Scientific Computing", that collaboration is important for scientific software, which is what I do. More specifically, "A large body of research has shown that code reviews are the most cost-effective way of finding bugs in code." Scientific software developers rarely work in teams. Most are independent researchers. And most are embarrassed to show their code to anyone, in part because they know it's crappy, because they are not trained programmers. I believe this inhibition prevents them from getting feedback that would help them. And because relatively little scientific software is available for a given domain, there's no habit to look first to see what others have done, which is another mechanism which can improve one's coding ability. The first step is to get the code out there, so that's what I'm trying to encourage. Which means that when I see strong yet meaningless comment about someone's new project, which happened to have been posted on /r/Python, I think about how it would negatively affect one of the scientists I've worked with, who might be lurking here while thinking about starting up their first public project. Because I've suggested this subreddit to several of those scientists.
Another point to consider about people not wanting to *formally* release software is the possibility of the maintenance burden. If I were not so passionate about code and the entire process I definitely not want to be maintaining a project which relatively few people would be using. The idea of an optimizer has generally two connotations, one, speed and two, size. Whenever someone mentions optimizations they generally *do* mean optimizations for speed and not size since the latter is generally not the goal when optimizing and since it's a, shall we say, second class citizen in the optimization world then additional language is used to point this out. An example form could be: "Optimizing the Python AST for size". I did take a quick look through the project and actually specifically at the tests section, since generally looking at tests can give you a good idea of the project at large. I found no benchmarking, only, as you say, tests for correctness. There were no benchmarks even for size (that I found) so I concluded I *was* indeed wasting my time since both fundamental meanings of the word "optimize" were not being formally tested. Whilst the project may be using some well-known and possibly not very well known AST optimizations, I can still find no concrete tests which collectively apply these optimizations. This is a problem if the author wants wider adoption (obviously, in my opinion.) I'll have a dig around for that paper.
Cool use of PRAW. You should check that the url the user enters begins with either www.reddit.com or reddit.com after stripping off `http://` or `https://`. Alternatively you should handle the exceptions to avoid 500 errors when the submission cannot be found.
As someone else suggested, I'll have to give Tf-idf a look as it will probably provide better results. Unfortunately, Google App Engine only supports Python 2.x whereas I need Python 3.x for the better Unicode support. The free tier of Amazon EC2 is doing me find as far as hosting goes.
And if you don't feel like coding tf*idf by hand (although if you are interested in text analysis, you should, just for the practice), then check out [whoosh](http://pypi.python.org/pypi/Whoosh/).
Why are you being a douche? He was trying to help you out.
double post so you see it. i replicated OPs method in IPython to try out the notebook. awesome stuff! http://nbviewer.ipython.org/4589949/ i used just pylab and builtin stuff for the actual calculations (opencv is apparently superfluous), but i needed beautifulsoup, PIL-py3k and Qt for the scraping and JPG support.
What? I was unsure if his comment helped because I didn't try to apply anything he said.
Nice. Can't really think what this is good for or why it needs to be 'industrial strength' but it looks good :)
Legal bulleted lists? I'm struggling here too
Debian is not known for "new" but "gnu".
Why use FastCGI in 2013?
First thing I thought, "looks like someone just did that roman numeral problem on Project Euler", haha. I think it was a fun problem.
Boo hoo, it blows up on the first line of the problem (it handles some ill-formed inputs, but not all): from rome import Roman s = 'MMMMDCLXXII' print s, Roman(s) MMMMDCLXXII Traceback (most recent call last): File "roman.py", line 4, in &lt;module&gt; print s, Roman(s) File "/usr/local/lib/python2.7/dist-packages/rome.py", line 61, in __str__ neg = Roman(n)._negatively() File "/usr/local/lib/python2.7/dist-packages/rome.py", line 29, in _negatively base, s = sorted((v, k) for k, v in _map.items() if v &gt;= self)[0] IndexError: list index out of range 
So that I know which Superbowl I'm watching now duh
I haven't ran the code, but after a quick skim it looks like it will fail on the representation for 8, giving IIX instead of VIII.
I presented an opinion piece about the maintenance burden at a conference a few years ago. You are wise to point it out, as it's rather subtle. The various open source manifestos talk about "building a community", and github pushes the idea of pull requests, but those imply a social obligation that many people don't want to take on, especially if their main goal is to do new science. As for the lack of unit tests to verify that the overall size decreases, how is that not what something like "self.check('[x for x in range(3)]', self.text_ast('list((0, 1, 2))')" does? I've used the ast module enough, and written my own PLY parser for the Python grammar, to know that the AST for the latter is smaller than the former. &gt;&gt;&gt; dis.dis(compile("[x for x in range(3)]", "&lt;string&gt;", "eval")) 1 0 BUILD_LIST 0 3 LOAD_NAME 0 (range) 6 LOAD_CONST 0 (3) 9 CALL_FUNCTION 1 12 GET_ITER &gt;&gt; 13 FOR_ITER 12 (to 28) 16 STORE_NAME 1 (x) 19 LOAD_NAME 1 (x) 22 LIST_APPEND 2 25 JUMP_ABSOLUTE 13 &gt;&gt; 28 RETURN_VALUE &gt;&gt;&gt; compile("[x for x in range(3)]", "&lt;string&gt;", "eval").co_code 'g\x00\x00e\x00\x00d\x00\x00\x83\x01\x00D]\x0c\x00Z\x01\x00e\x01\x00^\x02\x00q\r\x00S' &gt;&gt;&gt; dis.dis(compile("list((0,1,2))", "&lt;string&gt;", "eval")) 1 0 LOAD_NAME 0 (list) 3 LOAD_CONST 3 ((0, 1, 2)) 6 CALL_FUNCTION 1 9 RETURN_VALUE &gt;&gt;&gt; compile("list((0,1,2))", "&lt;string&gt;", "eval").co_code 'e\x00\x00d\x03\x00\x83\x01\x00S' This could also be verified though part of the unit test, but I don't see the advantage at this point. I do think that the author will soon reach the point where performance benchmarks are necessary, in order to prevent regressions, but for simple constant folding transformations like this it's not yet important. "This is a problem if the author wants wider adoption". True, but perhaps at this point the author want only narrow adoption. Eg, someone who will help out by developing a performance regression suite, set up to run automatically on checkin. "I'll have a dig around for that paper" You'll find little new about it. It's a set of best practices from software engineering, as appropriate for scientific software development. You'll be surprised perhaps at how many scientists have never heard of version control.
oh god don't use flup.
[See also](http://docutils.sourceforge.net/docutils/utils/roman.py).
Bulleted lists for the tax code and the healthcare law
Should be pretty fast after a few requests of warmup, but of course benchmark to see whether this is true for your app
The most obvious use case
I'm good for tickets, but I'll say thanks to you anyway!
Unicode would be nice on this!
It may also give IV instead of IIII, which is used on clocks.
I would love to check out pycon! How can I enter besides subscribing?
I watched the whole video and am still confused about what I need to do to get tickets. Do I just subscribe and magically I can get a ticket? 
Love the code!! It's quite elegant and the interface reminds me of K. Reitz's work =)
This will be fixed ASAP.
This is now fixed in master branch. Don't know how the QA team missed that bug.
Do these ever go farther than 50/L?
Actually IV is the canonical representation (see http://en.wikipedia.org/wiki/Roman_numerals), but not sure about IIX vs. VIII
Except Python 3...
Those inline if/elses are a bit icky, but otherwise nice enough.
Yeah, that's legal bulleted lists
Well, there's no reason they *couldn't*
You mean ternaries? What's wrong with them?
Rethinkdb looks interesting. My previous company payed a million for a db with parallel joins. Will look into how rethinkdb handles that.
A general personal dislike, but also they're rarely used in Python, so could by that measure be considered un-pythonic. If Python had a proper ternary operator, maybe...
http://en.wikipedia.org/wiki/Roman_numerals#.22IIII.22_on_clocks
Being "[Pythonic](http://faassen.n--tree.net/blog/view/weblog/2005/08/06/0)" isn't just about being syntactically correct. More about whether the ternary operator is Pythonic or not, [here](http://stackoverflow.com/questions/394809/ternary-conditional-operator-in-python).
that’s why i gave an example for something where the ternary operator is perfectly suited. and my argument about being in the syntax is that it was, at some point not too far in the past, willingly introduced into the language, and not as library, but as syntax: they changed the parser for it. this implies a strong confidence in that it is the right choice for some problems. only one person in your link said “it’s frowned upon” and cited no sources, so it’s probably his personal opinion, buffed with an ad populum. the real thing is that people with a C/java/blah background are not accustomed to this syntax just as they aren’t accustomed to many other parts of python, which isn’t an argument at all. prinicple of least surprise doesn’t hold for an entirely new syntax that has nothing to do with the syntax you know from other languages.
Actually found this quite useful because I had no idea how simple IRC was at TCP level.
As per the annotation: 1) Comment on the video. 2) Subscribe to channel. 3) Share video. I'm not sure how the last is verified. 
What I want to see is an implementation that doesn't convert to ints (unless you ask for an int). I'll be impressed when I see arithmatic done purly with the numerals!
Well, there will never be a 2.8 ... :)
Damn, I wish I lived closer :( Thanks for giving these out to the community!!
&gt;But you have to keep in mind that python 3 is not yet the main version of python. Python 2.6-2.7 is. That might have been true a year ago. It's not true today. They very much coexist today, and within 12-18 months most of the large python 2 codebases will have swapped over to Py3k.
I hope they will have in 12-18 months, but that is not today. Django is in beta. gevent, flask, tornado and babel (just to mention a few I've had problems with) is still 2.x only. It's getting there, but not yet.
Just did this a couple of hours ago in Debian, and this was all I needed to do: apt-get install libapache2-mod-wsgi
and [romanclass](http://pypi.python.org/pypi/romanclass) too
Would the author mind sharing the motivation behind this project? It's not clear from the github page.
Oh man I'd love to win a ticket. This is a really cool promotion so I hope there is a follow up to how well this works for adding subscriptions and whatnot. 
lol at this
Should be VIII
Yes, we did that too, but it only installed mod_wsgi.so-2.5 and mod_wsgi.so-2.6 with a symlinked mod_wsgi.so, and our ops team didn't want to add a new repo.
If only I didn't live so far from CA...
Thank you for replying. 
I recall a Mark Pilgrim post in, I believe, Dive Into Python 3 where he did TDD with Roman Numerals. Have you seen that? Not nearly as nice as your code. Subclassing int makes the implementation quite clean.
I did the needful. East Bay, so I can drive to Santa Clara!
Yes, things are still down as we investigate the hack that happened a few weeks ago.
Appreciate the response. 
he wrote docopt, which gained quite some fans. likely him throwing a line into the right mailing list/IRC channel like “he, i’ve made a funny little thing. wanna test?” gets him many volunteers.
We are working to restore as much as we can. Stay tuned!
hmmh, interesting. so the python 2 print statement evaluates and prints its arguments sequentially. (s still gets printed, while Roman(s) blows up)
well, we’ll stop advancing that thought experiment as soon as some significant part of the world’s forests are consumed by one list being printed, mmkay?
Couldn't you just release the data files? Not sure how your wiki stores them but dokuwiki stores simple text files that anyone could mirror. 
Very cool, looking forward to Pycon.
Very helpful guides to installing and working with multiple versions of python, virtualenv, and virtualenvwrapper, thanks! Python-guide is another useful resource: * http://docs.python-guide.org/en/latest/starting/install/linux/ * https://github.com/kennethreitz/python-guide/blob/master/docs/starting/install/linux.rst * https://github.com/kennethreitz/python-guide/blob/master/docs/dev/virtualenvs.rst Also, *tox* is great for running tests with multiple python versions. * http://testrun.org/tox/latest/ * http://docs.python-guide.org/en/latest/writing/tests/#tox * https://github.com/Pylons/pyramid/blob/master/tox.ini
This is great. Thanks for putting forth the effort to make this.
Thanks - I think the two Hitchhiker's guides are about the kind of documentation complement that we need. However, the problem that I have with them is that neither has any detail around installing multiple versions of Python. I think I want a lower level of detail in which specific commands and results are always shown. But perhaps these docs just haven't gotten there yet? EDIT: in any case I updated the docs to more clearly reference the Hitchhiker's Guide. And thanks for the Tox reminder. I haven't played with it yet, but seems like the perfect fit to speed up testing across 4-12 environments. 
is there a mirror to the wiki, i wanted to look into python and start with the guide
Save your sanity and use PyQuery or BeautifulSoup
Interesting site, but I find it a bit too hard to navigate for me to be willing to recommend it to a Python newbie yet. As a quick-reference, it's quite useful, but the Previous and Next links on each article are based on posting date rather than the order that the pages are presented in the tutorial pages. For example, if you go to the Python Basics page and click on Python Variables, you might expect to find a next page link to Using the Python Interpreter. Instead, it points to Log Checker In Python. I don't know if it's possible to force WordPress to re-order the pages so the links make sense, but if you can't, perhaps you can manually add Prev/Next links to the bottom of each article so it's possible for a beginner to flow through the articles in a manner similar to a tutorial/book?
Add this: class __metaclass__(type): def __getattr__(self, name): if name.isupper(): return Roman(name) raise AttributeError(name) To get literals like 'Roman.MMXIII'
A quick question: any idea why Python is generally installed to the C:\ root on Windows, and why the Windows installer defaults to that location? There are proper mandated locations for program files, config files and user-specific files in Windows now, why doesn't it default to %PROGRAMFILES%? Pretty sloppy for such a famous and widely-used project.
I would make a wild guess that too much third-party modules were found to be confused by spaces in paths. Cygwin and Ruby install to the root as well.
https://github.com/kennethreitz/python-guide/blob/master/LICENSE
I believe it did, but considering documentation always refers to C:\Python27 etc., I decided to uninstall and reinstall there. There's nothing but pain waiting for someone installing outside of the standard location.
That's a post from 2008. More recently, the [Python launcher for Windows (PEP 397)](http://pymolurus.blogspot.co.uk/2012/07/python-launcher-brings-shebang-line.html) provides another way of using multiple versions of Python (2.x and 3.x) on Windows.
I see what you mean. Actually at the very top of the page it says : "Click on the Title(s) to learn more. You can see what the topics are about under each title." Thanks for your feedback!
Thanks for the suggestion. This is indeed helpful!
This is awesome. I didn't know much about Jython but it looks awesome! Thanks for the great links! 
 derp = lambda k, v=None: derp.__dict__.get(k) if derp.__dict__.update({k: derp.__dict__.get(k) if v is None else v}) is None else None derp('Hello','World') print derp('Hello') Yay, I Python'd
I've had good luck with [pythonbrew](https://github.com/utahta/pythonbrew). It's similar to [perlbrew](https://github.com/gugod/App-perlbrew), [rvm](https://github.com/wayneeseguin/rvm), and [nvm](https://github.com/creationix/nvm). They're all command line version managers. They're all similar but have slightly different syntax which is kinda annoying.
Why doesn't %PROGRAMFILES% default to C:/usr/lib ? * http://en.wikipedia.org/wiki/Unix_directory_structure Why is it netstat -h and not netstat /?
Thanks for checking it out and for pointing out the links issue. I'm constantly trying to make the website better. One thing to improve is to make it easier to navigate on the site. 
I installed Python 3.3.0 with pythonbrew. It wasn't very hard. It mostly worked; it just needed a little coaxing to get easy_install and pip working. Now if we could just get people to [stop using env in the shebang line of packaged software](https://bugs.launchpad.net/ubuntu/+source/eyed3/+bug/307345), it wouldn't be so dangerous to have an alternate python higher in your path than /usr/bin/python!
Those are major programs, but they're not the main uses of Python.
I could if required, I have experience writing Windows installers in multiple different environments. Considering how popular Python is, I was more fishing for the hard technical reason that that path is used by default. I'm going by the assumption that such a popular project with so many smart people on board wouldn't just simply overlook the standard Windows directory structure so something must be stopping them. Perhaps something to do with backward compatibility to older Windows versions?
Even with the directory hidden in Windows Explorer, you can have your user hit WinKey+R (or Start-&gt;Run) then type %APPDATA%[enter]. This will take them to `C:\Documents and Settings\your-name\Application Data\` and from there they just have to navigate to the `MyProgram` folder. It's up to you whether that's easier to instruct a user to do than what you currently do.
 ✗eselect python list Available Python interpreters: [1] python2.7 [2] python3.2 * ✗eselect python use X 
Can't you just do a ./configure --target=/usr/local/bin and then make &amp;&amp; altinstall? I've used this to have 2.6.6, 2.7.3, 3.x with no probs. at least that I'm aware of. 
What kind of coaxing did you have to do?
And if the hacker got in and wrote in one of those simple text files "Death to President Obama" I'm sure that would go down well for the PSF to publicly release. 
The only thing you run into is that "python" as a command will be one of them, so after installing multiple versions you need to figure out which one you want as the default if a script calls "python" (e.g. with "#!/usr/bin/env python") Every version hardlinks python to pythonX.Y so what I do is ensure the system python (whatever the distro installed) is the default (usually by erasing this hardlink, /usr/bin is in the path before /usr/local/bin), then if I want to use another version I'll name it on the command line explicitly, $ python3.3 some_3.3_only_app.py or in the script itself with #!/usr/bin/env python3.3 If I decide to not use a virtualenv and instead install a module into the site-packages list on multiple pythons, then I just run the installer a few times: $ python2.6 setup.py install $ python2.6 setup.py clean $ python2.7 setup.py install $ python2.7 setup.py clean $ python3.3 setup.py install (there's possibly an easier way to do this with pip but I haven't been bothered to look) And as you said, &gt; no probs. at least that I'm aware of. 
Using `eval` is always going to be slower than a dispatch table.
Not if you're on a server and lack root access, or on 64-bit ubuntu and want zlib.
The ubuntu issue with zlib and Python is well-documented, just "apt-get install dpkg-dev" and Python's setuptools will do the right thing (you should also have zlib1g-dev installed as well, of course). If you don't have root access, install Python to wherever you do have access to write files. The only special thing about /usr/local is that it follows the FHS. You could equally install it under /opt or /data/projects/kenfar/apps. Clearly /tmp should be avoided unless you like recompiling Python frequently ;) 
One of the ideas I had was to do neither. A more complete code generation technique would be to generate entire .py files for each .lisp input file. Let the Python interpreter take over full execution of the resulting program. Aside from the function call overhead everywhere, I don't think it'd be that far off from "native" Python performance. 
That's the same year I wrote my own Roman&lt;-&gt;Arabic numeral convertor. I did it in Flash Actionscript, though. That was a good year for Roman&lt;-&gt;Arabic number convertors. Oh, to be young again.
I like how you can say things like "Fixed &gt;MCMXCIX in 0.0.2. Grab 2fbce7af4b," and it makes sense.
&gt; Now if we could just get people to stop using env in the shebang line of packaged software, it wouldn't be so dangerous to have an alternate python higher in your path than /usr/bin/python! This is the wrong thing to do. Distribution-provided Python software should be linking to the compatible distribution-provided Python. If somebody has chosen to override this sensible setting by forcing an incompatible version of python higher in their $PATH then they're choosing to break compatibility with all these system apps, and that's their prerogative. Forcing everyone else to comply with their stupidity is ... stupid? The better choice is to leave the system python alone and invoke the alternative python specifically; $ python3.3 all_out_of_red_leicester.py and it can live anywhere on the $PATH, though as I mentioned previously you do need to remove the 'python' hardlink alternative versions create in their bin directory to completely avoid interfering with the system python. But say you run a modern enterprise linux distribution. We won't name names in case they get their one-Cent panties twisted in their red hats. You're stuck with a system python that prevents you running actually useful software like Mercurial, because its too old. But Mercurial assumes you've got a Python out of this millennium and has the common shebang line in its executables. Just use a one-liner perl in-line replacement to change them all to your alternative python, and be done with it. Consider the fact you're installing third-party software requiring third-party compatibility software, and just make them love each other and forget the old fart watching from the park bench. 
I worry that this is getting a tad too clever for a unit test: def test_one_letter_numerals(): roman = 'IVXLCDM' arabic = [1, 5, 10, 50, 100, 500, 1000] for r, a in zip(roman, arabic): assert Roman(r) == a 
I'm developing many modules for use by my team. 'Pip' can be configured via a local config file to look in additional URLs before pypi for requested packages , so all you have to do is build your package and post it on a web server in house and you're off to the races. I'm typing on the phone ATM but if you would like a few more details I could point out some relevant links tomorrow.
Much better way to start python is to take CS101 on Udacity. They teach you the basics of Python and how to build a search engine. http://www.udacity.com/overview/Course/cs101/CourseRev/apr2012
I would like an advanced-intermediate guide. Also, "how to get a job out of people at PyCon '13" would be nice. Do people there just like, hang out sipping coffee out of paper cups and networking? Should I get some cards made? 
I'm finding it hard to judge how much content there is on the site. When I read a book, I'll spend a while familiarising myself with the table of contents. I'm creating a context/framework/schema where I can mentally store what I'm about to learn. A high-level sitemap/TOC would be really useful as at the moment, it's like a stream of python facts of unknown quantity and it's difficult to figure out firstly, what's related, and secondly, the best order to read it. I find myself asking.... How does the content in the navbar relate to the content in the many categories? It it a subset or is it a summary? The [Python Basics](http://www.pythonforbeginners.com/python-overview-start-here/) page... On the navbar, it seems to be one of 7 siblings , but when I follow it, I see that it actually contains links to it's siblings, amongst others. So, I then thought that it may contain the high-level view but after checking that some of the categories content (scripts, error handling etc) are not present, it too must be a subset. In the navbar, why does only functions and lists have 'cheat-sheet' in their URLs? 
Unfortunately the hacker deleted the datafiles, and guess what? They weren't being backed up. :-(
I see no snark.
There'll be a job fair at PyCon, and also an expo hall for sponsors. A few of the sponsors will be there because they want to sell you their products, most of them will be there because they're hiring. Show up, talk to people, let them know you're looking for a job. Edit: Should also mention that, yes, the "hallway track" (people hanging out in the halls, not going to talks) is a huge thing, not sure it'd be the most efficient way to get a job, but I love it, there's tons of open source people I get to see about once a year: at PyCon.
We are also having the same problem. Thinking about setting up our own internal pypi server http://pypi.python.org/pypi/pypiserver and using pip to install the modules. 
Pip can install packages from a private GitHub repository, just list the URL the usual way in your requirements.txt file.
I had the problem too. Using a pip-require.txt with a git (or what you like) repository is not packaging, it's a hack. A great project must support "python setup.py develop" and "python setup.py install" and "python setup.py sdist", right ? So, I have built [pyshop](http://pypi.python.org/pypi/pyshop) for this. In fact, I used [localshop](http://pypi.python.org/pypi/localshop) but decide to build my own for christmas, for many reason: * I need ACL: admin, developper(or packager), installer * I 'd like something that support to be behind an http proxy (to mirror pypi packages on demand) * I'd like something lightweight. This is not a heavy load service. pyshop: pyramid + sqlite (using sqlalchemy) localshop: django + celery + sqlite There is also other projects like djangopypi, and its fork, djangopypi2, or pypiserver but I haven't tested them. pypiserver looks to minimal. djangopypi looks to heavy for me. [edit]: formating
I made a fork of pythonbrew a while ago adding Stackless, PyPy and Jython support, since every now and then people ask how to install multiple Python versions on the same machine, I thought I'd mention it here. Hope you find it useful. PS: Unix only, sorry! 
That was our solution, although we wrote our own because we needed some custom functionality. Our setup and virtualenv scripts point at our pypi server and everything works fine.
FWIW I think that attending conferences like PyCon, (including giving talks, giving tutorials, and mixing with my open source heroes) has been the single biggest factor in my professional development over the last few years. But I'm now in a similar situation to the OP, with the tweaks that: (a) I live in Europe, so the cost of going to PyCon is even greater. (b) I've been to PyCon for the last several years (c) When I signed up my current job, I prominently mentioned conference travel as a requirement, and was assured that would be OK. But now when it comes down to it, management (who are generally very savvy) are saying they didn't realise I meant transatlantic conferences, and are very reluctant to pay for it. I thought I'd try to tip the scales a bit by getting a talk accepted (which I've done in the past) but I just became a new Dad this year, so I haven't had time to prepare a talk. This also makes paying for the conference out of my own pocket difficult - currently the three of us are living off my one salary until my wife goes back to work. 
Thanks for the link. I'll run it by the appropriate folks tomorrow morning.
Do you mean you wrote your own pypi server?
Wow, this is a more solid answer than I expected, and I expected something pretty good :) Thanks! I'll go over all of this with my coworkers tomorrow.
You're welcome. It's free!
Quite often it's enough to put the package files into a directory and serve it as a basic file listing with apache. Both pip and easy_install will accept that as a "package index." I'm the PyPI maintainer and this is how I do internal package indexes :-) 
did not work, only the mainpage does
This blog post describes the new Cloudinary's add-on for cloudControl, a popular European PaaS provider. Python and Django developers can build and deploy their applications using cloudControl and use Cloudinary as an add-on for uploading images to the cloud, performing image transformation &amp; manipulation and delivering optimized images through a fast CDN. Disclaimer: I'm one of the co-founders of Cloudinary.
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: http://www.reddit.com/r/Serendipity/comments/1747on/how_do_you_deal_with_packages_without_pypi_as_in/
nginx + gunicorn + flask. it works pretty well
Maybe a vEB tree would be better? It's pretty damn fast (i.e. exponentially faster than binary trees) and it's designed for large amounts of data (i.e. things you really need a tree for). The only downside I see is a pretty huge amount of overhead.
Yes, the interface to it is just a few http requests. It may not do everything the full pypi server does, but pypi didn't do everything we needed.
Thanks, I will look into the sitemap/TOC. 
Why go to all the trouble to check that /usr/bin/python meets all of your dependencies if you're just going to fish around for whatever python you can find every time the script is executed?
Running pythonbrew install 3.3.0 didn't work, so I gave it a full path pythonbrew install http://python.org/ftp/python/3.3.0/Python-3.3.0.tar.xz This didn't work either, but it did complete the download. So I decompressed it myself unxz /home/tim/.pythonbrew/dists/Python-3.3.0.tar.xz and installed pythonbrew install Python-3.3.0.tar This finished fine, but whined about setuptools. I installed that with python .pythonbrew/dists/distribute_setup.py Then I downloaded a similar script for pip cd .pythonbrew/dists curl -O https://raw.github.com/pypa/pip/master/contrib/get-pip.py python get-pip.py All seems to be well. I love being able to switch versions of python with pythonbrew.
I was parsing ICS files and needed to merge two consecutive lines. While this is a fairly complex sed command (that need some time to google and test), this is just a loop over `zip(line,line)` and a `line.replace("\n","")` in python. This is the use case that motivated me to code pyxshell. After that, I needed to filter out events at dates that was indicated in another ICS file. While this is fairly complex to do in a shell script, this is again trivial using dictionaries in python.
Recursively, a tree is defined as a node (the root), which itself consists of a value (of some data type, possibly empty), together with a list of nodes (possibly empty); symbolically: n: v [n[1], ..., n[[k]] [source: wikipedia](http://en.wikipedia.org/wiki/Tree_(data_structure\)#Recursive) *edit cahracter escape on )
Doesn't it require unique keys? That's another downside.
Can't say I see that as an issue. Most of the time you'll be dealing with unique keys anyway, and there are ways to work around the limitation (through subclassing, too) if you _really_ need that.
Tip. Don't check in pyc files accidently by creating the file `.gitignore` in the root of the git repo and adding the line *.pyc Then they never get checked in, show up `git status` or `git diff` etc. They live there, quietly speeding up your code. When you do what them deleted you can just do it manually like so: find -name *.pyc | xargs rm 
No need for the pipe. Also, depending on which shell you use, you will want to enquote the star, otherwise the shell will interfere: find -name "*.pyc" -delete 
say...I have a global gitignore file that has *.py[o|c], would that work as well?
Or, simpler yet, you could add an entry in .gitignore for '*.pyc' run this command in your git directory: echo *.pyc &gt;&gt; .gitignore
that's what I came here to say, but after reading the post, I think the issue is that after checking out a different branch, the old .pyc files remained and were used by the interpreter, instead of being re-compiled
Why don't you use the pyclean command?
I don't think that the point was for git to ignore the files, more for them to be cleared out and not be there when checking out code to avoid old code being run by Python.
I do the same thing `--no-index --find-links=http://my-apache-directory/my/very/special/pypi/` is all it takes.
I didn't know about it. Though, having looked at it, pyclean doesn't seem to offer much more than a slightly better regex and Windows compatibility, which doesn't seem worth the dependency.
This is a good tip, but as /u/ilogik said, this isn't about git's primary functionality. I was hitting problems where stale .pyc files were being used when running tests etc., leading to very confusing test failures. As for speed, the performance hit the first time I use the code after switching branches is (for me) more than outweighed by not starting to debug bogus test failures.
As /u/eflin says, this isn't about removing them before commit (I'm using the post-checkout hook!), this is about removing them when the underlying Python code has changed and there's a chance that the .pyc files will have become stale.
[This one](http://pypi.python.org/pypi/django-unchained/)!
Pip and private git/hg repos? Edit: sorry I see someone else posted this too. 
I don't think this should have everything and a kitchen sink. There's just no one size fits all data structure.
Throwing random ideas. Node is tree by itself, IE, everything that i can do on tree, i can do on node too? Flattening options, flatten nodes below certain level in their parent. Method which will let node change position with parent node. (climbing up) 'A&gt;B&gt;C&gt;D'; C.switchWithParent() ; 'A&gt;C&gt;B&gt;D' Maybe node.pushUp() or something which will just push node up in stack (IE its new parent will become parent of old parent, and it will be sibling of its old parent). depth in .switchWithParent() and pushUp() should by default be 1, but passable as argument. Or pushUp until some condition is satisfied. Like for example parent.hasMoney() === true. I did not think deeply on this, but it opens few possibilities for some situations that i had recently.
Checking out code changes the mod-time doesn't it? The interpreter should compare timestamps on the .py/.pyc files and do the right thing...
I'm completely disinterested in the latest movie to use his name, but I love the name of this Django-to-Jinja2 bridging module: &gt; https://github.com/coffin/coffin/ Hopefully everyone gets it. If you don't, a quick Googling will sort you out. You can use Liz Lemon's office.
Kivy looks really nice too.
Or configure it user-wide with `git config --global core.excludesfile /home/username/.gitignore` and put *.pyc in there.
Which .gitignore would do by extension. They shouldn't be checked into source control anyway, they're specific to a user's operating system, architecture and Python version.
A basic reference for python's string format with lots of examples. I feel examples are easier to follow then the documentation which has more spec details.
No, it wouldn't. The problem is that the `.pyc` files are being generated in my working tree, and then not refreshed when I checkout a different branch in the same working tree. They are never checked in because I, of course, have `.pyc` files in my `.gitignore`.
That is what I was expecting, but not what I was seeing, so I came up with this workaround.
Almost clicked on the youtube link. Almost.
That doesn't matter. If the source file changes, the .pyc is regenerated. If you delete the .pyc, it is regenerated the same way. However, this has bitten me in the ass: If you are refactoring, and you move methods to another .py file, and remove the original, but not the .pyc, python can still import the old module using the .pyc
Git clean is your friend to remove non repo files.
&gt; However, this has bitten me in the ass: If you are refactoring, and you move methods to another .py file, and remove the original, but not the .pyc, python can still import the old module using the .pyc This may well be what I was seeing; the missing .pyc files were all in parts of the code that I wasn't actually changing, so I didn't look at them too closely.
A better implementation of _split would be to convert the int to a string, then use 10 ** (len(s) - 1 - position) as the weight of each digit.
why not use `git clean -f`
`python setup.py sdist`; `scp dist/*.tar.gz intranet.file.server:/packages/`; have Apache expose that directory, specify `find-links = https://intranet.file.server/packages/` in buildout.cfg. pip/easy_install also take `--find-links=URL` options.
I have an alias that cleans out all untracked files…ignored included.
All the comments that say, "Don't check your .pyc files into your repo," are missing the point (and probably haven't encountered the issue described by the blogger). I'm assuming the blogger isn't checking his .pyc files into the repo. There *can* be issues with stale .pyc files causing problems when switching Git branches, even if they are ignored. For example, issues can arise if a .py file exists on one branch, but has been deleted on another; when switching to the other branch, the .pyc will stick around, which can cause problems if a module inadvertently imports that deleted module; the Python interpreter will still see that .pyc file and thus think the module exists, and import it. Similar issues can arise; sometimes, because of the way Git handles and writes files, the Python interpreter will use the .pyc file instead of reinterpreting a modified .py file. In fact, those comments are doubly wrong because if the .pyc *were* checked into the repo, these issues would most likely not occur. (Not that I advocate checking .pyc files into the repo; rather, this script *can* be helpful.)
It'll ignore them, but I noted in a [comment](http://www.reddit.com/r/Python/comments/1747md/git_tip_remove_pyc_files_automatically/c824gz6) that simply ignoring the .pyc files doesn't solve the problem described by the blogger.
`git clean` will operate on either all ignored files or none. This is not a good option.
`git clean` will operate on either all ignored files or none. This is not a good option.
You can pass got urls to pip, just put it in a private git repo.
Surely the interpreter checks file times?
Actually it removes untracked files, you should probably stick any files that are machine dependant outside of your project.
Do you have a link to the MSI sources?
I'm assuming that nobody is masochistic enough not to have pyc files ignored. Which means that you have to pass the options to clean ignored files. Storing things like local Django settings out of the tree is a bit of a PITA. 
i think that [this comment](http://www.reddit.com/r/Python/comments/1747md/git_tip_remove_pyc_files_automatically/c824gz6) has the best explanation of the issue
Exactly. I worked with a team that had great version control hygiene and I still wound up making a bash alias for something like the "find -name "*.pyc" -delete" mentioned above.
Small bug: 'x's and 'z's are mixed up in the padding examples.
Sorry, I forgot Blogger redirects all requests for blogspot.com to blogspot.(ccTLD).
I always use find to remove pyc files, and I know about git hooks, but I never had the idea to combine the two. 
well this is nice.
[Or use this environment variable on your dev machine and you won't ever make .pyc files in the first place](http://docs.python.org/2/using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE)
This would result in your code being slower in between checkouts, though, which isn't ideal.
What am I not understanding here?
That's cool, thanks.
Thanks, fixed! 
python should automatically be regenerating the .pyc files if the .py file changes. If that's not happening then either you are doing something weird or something is broken *in python* and should be fixed *in python*. You're working around the problem instead of actually solving it imo.
The problem is .py files being removed; Python doesn't (and probably shouldn't) detect that and remove them.
ah I see. Personally, I'd suggest not generating the pyc files at all during development. But if you are, then it would probably be better to only delete the .pyc files that don't have a .py file
&gt; PS: Unix only, sorry! Don't be sorry for that :D
I mean a comparison of the actual code for each. 
I generally like the new syntax, but I'm finding it hard to remember without resorting to a cookbook like this every time. Kinda wish it had a more verbose option.
this is nice, but there are a few rough edges. e.g. &gt; You can also use the numeric position of the variables and change them in the strings, this gives some flexibility when doing the formatting, if you made a mistake in the order you can easily correct without shuffling all variables around. i wouldn’t say it is smart to encourage specifying stuff in the wrong order. i’d rather order correctly for clarity, and explain the explicit numbering like so: &gt; You can also use the numeric position of the variables to repeat some, which wasn’t possible for numeric arguments with the old formatting syntax. &gt; &gt; 'E{0}l is better than {0}'.format('vi') &gt; &gt; ([Evil](http://emacswiki.org/emacs/Evil))
Note, the bungled order of args is not the only use of "abc {0} one {1}". When doing i18n (internationalization), some languages will want values in one order, while other languages want them in a different order. The ability to pull args out of order allows you to keep the natural word order in each language.
Programming Python by Mark Lutz is a nice one.
Darhmdh is right, I am running wheezy.
&gt;Kinda wish it had a more verbose option. Technically you could create this mess and be more verbose: "{{value:{fill}{align}{sign}{width}{comma}{precision}{type}}}".format(fill=fill, align=align, sign=sign, width=width, comma=comma, precision=precision, type=type).format(value=value) You could even make a function for it... def verbose_format(value, fill='', align='', sign='', width='', comma='', precision='', type=''): if fill or align or sign or width or comma or precision or type: fs = "{{value:{fill}{align}{sign}{width}{comma}{precision}{type}}}".format( fill=fill, align=align, sign=sign, width=width, comma=comma, precision=precision, type=type) else: fs = "{value}" return fs.format(value=value)
I would extend the class, the definition should be minimal. Perhaps with a few basic visitor patterns depth/breath first. I think that such a datastructures justification is based in a common "minimal" implementation.
YOU DA MAN!
Personally I use Sublime Text 2's build system to run the code to test, then remove all .pyc and __pycache__ folders. Works a treat. Obviously gitignore to prevent the files from ever hitting the repo.
Nope
Nice work. It really could use the string.format() tips found [here](http://mkaz.com/solog/python-string-format).
In the [documentation](http://docs.python.org/2/library/string.html#format-specification-mini-language) it says that `{}` is the same as using `{:g}`, but it's not: &gt;&gt;&gt; print('{}'.format(3.00)) 3.0 &gt;&gt;&gt; print('{:g}'.format(3.00)) 3 &gt;&gt;&gt; print('{:g}'.format(3.1)) 3.1 `{:g}` seems to use automatic decimal places.
Apologies for butting in on your excellent thread, but &lt;rant&gt;if it is really intended to be a **standard implementation** could we, please, just this once have a module that conforms to [PEP 8](http://www.python.org/dev/peps/pep-0008/), [PEP 257](http://www.python.org/dev/peps/pep-0257/), and (especially) [PEP 20](http://www.python.org/dev/peps/pep-0020/).&lt;/rant&gt; We now return to your usual threading.
well i usually give myself sudo privilges and I don't use ubuntu.. I'm a RHEL shop. but ok
Awesome post.
Are there any more cases where .pyc files screw things up?
Dive Into Python is a free book that was made for programmers learning Python. http://www.diveintopython.net/ or http://getpython3.com/diveintopython3/
I would love to see lisp macros added to this.
One thing you might want to add is that slices can be used to reverse a list, e.g.: &gt;&gt;&gt; [1,2,3,4,5][::-1] [5, 4, 3, 2, 1] &gt;&gt;&gt; (1,2,3,4,5)[::-1] (5, 4, 3, 2, 1) &gt;&gt;&gt; "hello"[::-1] 'olleh' 
This tool is awesome! If you have not tried it out, do yourself a favor and check it out.
Oh yeah, I came across your service when I was looking for a certain kind of functionality, it didn't have it and now I'm pondering starting my own cloud-based service in order to provide it.
% also supports named references, using the syntax "%(blah)s" and passing it a dict
Awesome. This might just get me away from using the old formatting.
My hope is to have what people would consider a "healthy subset" of common lisp features. Macros will be a part of that subset, but I'm uncertain how to do them well right now. As I implement new features I hope my understanding of how to execute them will evolve. Thanks for your feedback!
TIL, thanks
Python Essential Reference by David Beazley. It gives you nice explanations and examples, covers a lot of things and will be certainly very useful in the long run (past beginner phase).
Some projections would be more useful 
I'm not sure why you feel making numbers up would be "more useful" but hey, feel free to draw a line on your monitor to project using whatever number fudging you wish :-)
Yes, the curly braces {} are the placeholders used when using .format() You can use with numbers such as {0}, {1}, {2} which are filled in based on the order the args to format(), or if empty, without the numbers, it assumes the order they are in the string will match the order given in args. I'll add some additional explanation at the top of the article, I was confused the first time I started using it too And it has been said % is being deprecated but hasn't yet
Thanks! Yes, all examples should work in both 2.7 and 3.x 
I've been going through the online Dive Into Python and its great, but I think he's using either Python 2.2 or 2.3, so several examples in the book are out of date.
Thank you :) Also, others may be interested to know, you can also put keywords in the braces - i.e. {username}. Like in my email-templating engine, I've got: email_out = "Hi {username}..." email_out = email_out.format(username=user.username) Which is neat, especially if you're not sure what order the format tokens will be in (or you've got username in there a few times)
Some of this [has been mentioned](http://www.reddit.com/r/Python/comments/174e1i/python_string_format_cookbook/c82fzoc), but the latter part of that article implies ``%`` can't do things it can: &gt;The new format() function does offer a fair amount of additional features and capabilities that the older % can not. Here are a few examples where .format() outperforms % &gt;&gt;&gt; " I {verb} the {object} off the {place} ".format(verb="took", object="cheese", place="table") ' I took the cheese off the table ' We can also write this: &gt;&gt;&gt; " I %(verb)s the %(object)s off the %(place)s " % {'verb': 'took', 'object': 'cheese', 'place': 'table'} ' I took the cheese off the table ' &gt;You can use the following letters to convert a number to their bases, decimal, hex, octal, binary Of those only binary isn't supported with ``%``: &gt;&gt;&gt; '%d' % 21 '21' &gt;&gt;&gt; '%x' % 21 '15' &gt;&gt;&gt; '%o' % 21 '25' Docs here: [http://docs.python.org/release/2.5.2/lib/typesseq-strings.html](http://docs.python.org/release/2.5.2/lib/typesseq-strings.html) I'm not saying ``%`` is better but some of what I feel is implied by that article is incorrect. As mentioned in [PEP 3101](http://www.python.org/dev/peps/pep-3101/) the primary advantage of the new-style formatting is ``%`` is a binary operator and can take at most two arguments. I encourage you to revisit your rationale as to why one is formatting method is preferred over the other.
I'm pretty sure the curly braces originated from Java's [MessageFormat](http://docs.oracle.com/javase/1.4.2/docs/api/java/text/MessageFormat.html), if the history of this matters. Personally, I'm a big fan, you can overload `__format__` on your custom objects and take in arguments from the format specifier. Example: class CustomFormatter(object) def __format__(self, arg): return "My formatting args are: " + arg Then do: &gt;&gt;&gt; obj = CustomFormatter() &gt;&gt;&gt; "{0:Green Eggs &amp; Ham}".format(obj) "My formatting args are: Green Eggs &amp; Ham"
I'm a big fan of PyCharm. JetBrains makes some really good dev tools. The Django support is top notch, and it works well with the threaded Django dev server. The test runners are great. You can even configure it to run unit tests each time you save a file. Also, a right click on a test function will give you a menu that willcreate a temporary build config just for that test. The code navigation is stellar as well. Holding alt will let you click on a function and navigate to it's source. The JavaScript support is also stellar. It even does reasonably well with ExtJS classes and navigation. Don't forget the coffeescript support! If you haven't already you should check out the live templates, makes writing boilerplate code much quicker. I could go on, but I really can't recommend PyCharm enough! 
PyCharm can manage the virtualenvs very well.
That looks pretty awesome.
Could you explain (with sources if it's easier) what that first sentence means?
I don't understand why you need apache. pip will accept a directory as a package index, using "--find-links=file://...". I guess the directory might need to be network mounted, which might be a pain. But we actually put all our dependencies in a directory, as sdists (both to packages we create ourselves, and 3rd party packages we download from PyPI) and we actually check this directory into our repo. That way a project is entirely installable and runnable and deployable from the local files checked out with the repo. 
print() doesn't work in python 2, it's a lie - it's a statement and a tuple, not a function
Was too cumbersome for me to continue working on previous projects -- I haven't opened it more than 2-3 times since I bought it last month. Still don't know how to get rid of projects in the left pane.
Alt-1 on Mac OS X
see http://plumbum.readthedocs.org/en/latest/cli.html#sub-commands
They changed that in 2.6
All that stuff is pretty cool, but let me get into the language first. It would be easy to overload it with all sorts of things.
For coverage.py do you just get the regular report or does it show you the html one?
It's even better if you change that to email_out_f = "Hi {username}...".format email_out = email_outf(username=user.username) You can then just start off your file with all the format string functions defined in one place where it's easy to make small changes, while getting better performance on repeated invocations to boot.
If I recall correctly, when this was being worked out on the mailing lists, the implementers were more familiar with the C# version of the same thing.
It misses the most useful formatting option ever: `'{!r}'`/`'%r'`, which calls `repr` instead of `str`, which means that your special characters in strings are escaped properly, so you never have to worry if, for example, a potentially weird string you're logging specifically because it's potentially weird contains quotes, newlines, embedded nuls, invalid unicode characters, non-ASCII unicode characters if you're printing to screen in non-unicode mode, etc. Oh, except IIRC they broke it in Python3 with regard to unicode in particular, as they like to break stuff in Python3.
Great stuff! I'm doing it the same with Android (got the compiler built) out of a makefile: in fact the ./configure is useless when cross compiling.
Thanks earthboundkid! I hadn't seen it used like this before, great tip! I'll update the article with it, definitely looks like a really useful way to use it. 
I love it, my only *real* complaint is that when I comment a block of code out the comments are placed at the beginning of each line, instead of being lined up relative to the scope of the current function (if that makes sense). Like this: # def myfunc(): # return "Wat?" Instead of this: #def myfunc(): # return "Wat?" Minor complaint but it bugs me. *edit: I have no idea how to format code blocks, the "four spaces" suggested by the formatting help window didn't seem to work. Oh well.
There is an option to [generate the html report](http://www.jetbrains.com/pycharm/webhelp/generating-code-coverage-report.html)
Cool, I like that there's an option to automatically open it in your browser.
I renewed my license, its awesome for django dev, and the support people are cool people.
As someone who is new to python and even newer to virtualenvs, is there a tutorial out there that teaches virtualenvs with pycharm or intellij with the pycharm plugin?
I plan on renewing my license as well. My only wish is for web2py support, having just started doing some web2py development for a client.
I find Lutz's books too verbose. He spends 1000 pages on something he could cover in 300, and tries to make a tutorial out of what should be reference material. I'll admit, I haven't read any of the revisions since about 2001, but it seems the page counts have only gotten longer.
You probably mean Learning Python. Programming Python is generally shorter because it skips all the general concepts.
did you see the getPYTHON3.com part and diveintoPYTHON3 parts of the friggin second link?
Using env to find your interpreter is great, IMHO. My system python is what runs by default, globally. If I want to run a different python for a particular project, I just use virtualenv to set it up. I can then change pythons to test with without needing to alter source code because env will find the current one I wish to use regardless. If a package knows it wants to run on the distro's python, it should use /usr/bin/python. If it wants to run specifically on python2, it should use `python2`.
well, `__future__` is available, but that's not what I meant. &gt;&gt;&gt; print(1, 2) (1, 2) &gt;&gt;&gt; 
The print function is only available with a future import, even in 2.7. You may be confusing ("foo") evaluating to "foo" with print("foo") calling a function; while it appears to work, the behaviour is that of expression evaluation (visible when you try print("foo", "bar") instead), not a function call.
It's been a long time, but I just worked through the [python tutorial](http://docs.python.org/2/tutorial/index.html), part of the standard documentation. How did that work for you?
On the side bar is Dive into Python. It is an extremely good book to start learning Python. I have a background in mathematics and I started learning Python two years ago for a mathematical research project. I took a few programming courses before and understood the basics of programming with Java and C++. Ever since I started using Python, I haven't looked back. If you like math, projecteuler.net is a great resource to learn a new language and get in some mathematics. 
This is the top "python christmas" result. Glad I didn't hear John Lennon's "War Is Over" when I clicked that link.
Things that work for someone don't necessarily work for someone else, but whatever. I had a bunch of programming background when I first started learning Python, mostly picked it up by reading the books. Not really sure about the timeframe. I also had one of my friends who already had a lot of Python experience and who could review my code and highlight your mistakes, which helped immensely. If you don't know any Python pros, just post your projects here and some people (probably me, too) will do it.
What really helped me out was "Head First Python" And really their whole suite of books makes sense. I read alot of books written by programmers that just don't help because they say (x does this or y does that try this code see!) Head first takes its time and explains it to you in an easy way to understand for someone who is human and not speaking in geekscript.
First read byte of python. Then do some interesting project, text based games like hangman, maybe code some simple bot to solve hangman. Then watch some videos http://pyvideo.org/ (these are mostly not tutorials). Also check out ipython. I think that "IPython notebook" is extremely valuable when you are playing with ideas on how to solve something. 
Check out /r/learnpython!
I learned Python the way I learn other languages. First I follow a tutorial to learn the basics. Then I think of a reasonable project I can code and try and write it.
http://learnpythonthehardway.org/ is great. And follow his instructions, get one chapter to run before you run the next. I followed the first 20 or so chapters then I skimmed the rest. From there, I feel like it's better for me to work on projects and find the tools I need. http://www.pythonchallenge.com/ is a way to use those new python skills and challenge yourself in various ways. http://projecteuler.net/ is a generalized programming challenge (designed for any type of programming) dealing with things like finding specific kinds of prime numbers and other mathematical type challenges.
Options: -b -f -s -m etc Positional arguments: branch, /home/user/project etc If options_first == True, all arguments after the first positional argument are interpreted as positional argument, even if they look like an option (i.e. start with a dash or double-dash).
OK, I have finished a reasonable project I think. I designed a word puzzle game. I keep trying to produce a "game show" that is appropriate for podcasting. So, I have a program that takes words out of a phrase, compares them to the very common word list "the, a, of, is, etc." and reveals them if they are on that list. Next, it takes the remaining words and finds a substitute with the same number of letters out of a common words list. Then it gets more complicated than that. I think I'm going to record the "pilot" soon as it seems like a decent game. My question to you is what next? I feel a little confined trapped in the terminal. I realize there are infinite ways for a programming language to interact with its environment. I don't really want to program for "games" (even though I wrote a 'game') as I don't really want to mess around with sprites etc. Although making a bit-trip type game might be ok. Also, I'm having trouble importing new modules into my python. I tried to start a project using matplotlib (?) but I couldn't get it to install correctly. I guess my question is once I got the basics of the language down (pretty well I think) and can use the official documentation to fill the gaps? I would be hesitant to call myself a programmer at this point, even though with the program I wrote, I kinda impressed myself.
1. pick a project. 2. Make the project simpler. 3. Can you program that (using *the* reference, *the* tutorial, and google)? No? GOTO 2. Finished? Good, now move to the less simple one you couldn't complete. 4. Done? Pick a new project. Repeat.
People learn programming by solving problems with programming languages, not following examples in a book. Reading book examples when you have no problem to solve makes the examples mere curiosities. Tell us what you want to be able to do in python, and you will get some great feedback. Things you might do with python: Linguistic analysis Statistical analysis Run a website Write a game Edit Minecraft maps Track your twitter follower count Home automation You must have some motivation to learn python, so introspect a little and tell us what you imagine yourself doing with python. 
[ 6.00x on edX](https://www.edx.org/courses/MITx/6.00x/2013_Spring/about) It can be difficult at times but if you put work into it and manage to go all the way through, it will give you a tremendously good start. I've been there, trust me. It's not purely Python course in the sense that it also teaches you the foundations of computational thinking instead of mere language properties. I think sign ups are about this time so go check it out.
If you're going to save a certain format for later you might try the [string.Template](http://docs.python.org/3/library/string.html#template-strings) class which has a few more powerful options than [str.format](http://docs.python.org/3/library/stdtypes.html#str.format).
When I learned Python I was already proficient in other languages but my university used [How to Think Like a Computer Scientist](http://www.greenteapress.com/thinkpython/) (free PDF) for the introductory programming course. I would recommend experimenting in the interpreter to get an understand of the mechanics of Python.
I'm in the exactly same spot as you, i don't have a methodology, this approach is working for me: I'm using one book as a general guideline: A byte of python by Swaroopch [Ebook](http://files.swaroopch.com/python/byte_of_python_v192.pdf) Every time I get stuck in one part, i try to read other source on the same topic, I'm using: Learning Python [Learning Python](http://shop.oreilly.com/product/9781565924642.do) Dive into Python [Dive into Python](http://www.diveintopython.net/) And after I feel confident about my skills, i go to Code Academy to complete the lessons and take the challenges: Code Academy [Code Academy](http://www.codecademy.com/) It's a messy and slow way to do it, but it's working for me, I hope that it gives you an idea of how to approach and design your own method!
You have to renew your license? Is PyCharm a subscription-based product? I honestly didn't know this.
Scraping a web site is not complicated. My guess, he was using a library like [Mechanize](http://stockrt.github.com/p/emulating-a-browser-in-python-with-mechanize/) to emulate a browser.
Aha! I see. Thanks.
Aha! I see. Thanks.
Big fan of JetBrains. I use PyCharm for django and python. Love the js/html/css support as well. Resharper is awesome for c# dev as well if you're interested in their other projects.
Look at PyGame.
I TA-ed for an undergraduate course where we made the students learn python (some of them already knew it). My co-TA got Zed Shaw of LPTHW (http://learnpythonthehardway.org/) to give us a copy of the book to freely distribute to the class in return for feedback from the students. And from what I heard back from the students, following the book was very useful. They even made a flask based web app on top of a webserver that they built. The key is persistence and follow what he says in the book. 1. Go through each exercise. 2. Type in each sample exactly. 3. Make it run. Yes, type in each sample exactly as it is. He also says that this is probably not the best way to learn the art of programming - but at least I am sure that it will get you started with the skills that are needed and you can move on to some other advanced book. I think following the instructions in the book will certainly help you get back to a good "studying methodology". Cheers!
YES! The CS101 course is the best way you can learn Python because you're constantly building and referencing what you learned earlier. And you'll stay motivated because you're building **a freaking search engine**. Granted, it's a basic, rudimentary search engine, but it's still a search engine. 
Thank you for the advice, i'm trying to build a good foundation in Python, so later on i can start learning other languages. 
I've tried several tutorials and books, but i always end up with the feeling that something was missing... I will try the one's you mentioned and i hope i will find one that i can wrap my head around.
First I learnt the most basic aspects of Python programming, such as variables, lists, dictionaries and tuples. Then I started developing small console applications. I think that if you really want to learn a language, you need to find yourself a project first, then you can learn along the way. 
I understand simple things, my big problem is how it all ties together.
I think Python is a great language for that. It borrows a lot of ideas from a lot of languages, which means that you'll be able to recognize concepts when you learn additional languages.
If you're the kind of guy who builds knowledge from the ground up and who gets confused by starting "in the air" so to speak, then maybe [this very nice article](http://www.cafepy.com/article/python_types_and_objects/python_types_and_objects.html) is for you. It doesn't teach you how to *code*, but rather how it's all connected. It looks at the foundations of python -- what is an object, what is a type (or class), what is a metaclass, in a more thorough way than most tutorials and textbooks.
What is an example of using Live Templates? I don't generally see much boilerplate code when using python.
You need an active license to get updates.
You *have* to renew your license only if you want to keep on receiving updates. So, not really.
Ah, got it.
Already have an account, but it's not what i'm looking for. I want to build a strong foundation in Python, and codecademy.com does not provide me with what i want.
Does it have to come in two books? Why not just one that covers both versions? I'm not complaining, it just seems more practical IMHO. Anyway, good work and I look forward to read them :)
I strongly second Udacity's CS101 course. It affords a very personal approach to learning Python. It feels like you are given your own personal series of lectures (because you are!) which you can take at your own pace.
It would be cool to see the growth in number of maintainers as well. Are there actually more people uploading packages or more packages uploaded by the same people. I ask because I have about 8 packages on PyPi. 
thanks for the reply, the dependencies are in the setup.py file, but a requirements.txt is a good idea, will do it...
oh my bad I totally missed it in the setup.py
One of the bonuses to taking this class is the forum of students to converse with, which helps when one is stuck, and with overall motivation.
https://www.edx.org/courses/MITx/6.00x/2013_Spring/about This is a free course taught by MIT. It's awesome. 
Currently i work in QA as a manual tester. I want to learn Python and with Selenium start doing Automation Testing.
My personal observation is that I started using it for pure HTML and JavaScript projects as well and love it. I have been using Sublime Text 2 for such work but feel much more productive with PyCharm. Actually, I'm a bit sad I didn't get IDEA right away like a lot people suggested. I'm working with PHP &amp; Java from time to time as well and now I can assume IDEA is just as great as PyCharm..
The best reference for me was going through a copy of The Standard Python Library by Example and rewriting any of the examples that I couldn't make sense of just by reading. This not only got me to learn Python, but taught me a bunch of cool stuff in the libraries as well. Also, working through some of the Euler Project problems and reading about other people's attempts at them on Stack Overflow helped me by providing projects to work on that are hard, but also have a good amount of documentation about the problem (instead of just documentation of the solution).
brentolamas has the best answer. Zed Shaw's learn python the hard way is a great introduction to python and programming in general. Also, you have to understand that "learning to program" doesn't mean anything. What you are trying to learn is how to solve problems with a computer. So really, you should be asking yourself, what problems do I currently have that I could solve computationally. Then you will learn.
I can read books until my eyes bleed. Even some interactive courses that give you exercises don't take. For me, I learn by doing. Pick a project that seems digestible ('I want to open a file full of text, parse it and do something useful with it' is a pretty decent starting point), and just start coding. Replace complicated parts with print statements (print "this is where the program will parse the input."), just so when you run your program as you work, you will know it's iterating thru the steps properly. Then start writing the more complicated parts. This was a big help for my first scripts, since I wanted to use arguments passed to the program from the command line. I was able to ensure the program was accepting those command line arguments correctly before I got to the 'meat and potatoes' of the code. When you have a problem, or don't know how to do something specific, do a search on [Stackoverflow](http://stackoverflow.com). That has become a major resource for me. Chances are, you will find multiple solutions, and you can select the one that seems the most elegant or appropriate. After the program runs successfully, test with with some things changed, (change the input filename, provide a full path rather than a relative path when you specify a file, etc), and fix what needs to be fixed so that the program will run properly even when the input is slightly different. Then, refactor your code. Go through the working source code, break parts that might be useful in other programs into their own classes, so that they are modular. Examine complicated or verbose lines of code, and see if there's a shorter, faster, more concise way of doing the same thing. And finally, don't be discouraged!
The noisy line is the count of packages per month (either new package names registered or new version releases.) The smoother line is a moving average.
Hm. We don't we have that information. I have something *like* it, which I might poke at today...
I don't really like learnpythonthehardway, unless you're an absolute beginner to programming. I do like http://www.diveintopython.net/, though.
I also learned a great deal about Python from CS101 and there are a number of other courses offered by Udacity that use Python. Another good resource is [Google's Python Class](https://developers.google.com/edu/python/). It's a great introduction to using Python to write useful scripts.
It's too bad this thread is getting an underwhelming response, this is an issue I've wrangled with in the past when trying to implement a simple AI and BFS/DFS I also searched PyPi and found nothing but specialized data structures, so I ended up using a simple trie that I copied and pasted off of stackoverflow, which unsurprisingly didn't end up being that great. I for one would love an implementation of the most basic tree structure that is easily extensible (which is trickier than it sounds, I'm sure) Keep us posted slash provide the github link once you get crackin'
Set a task for yourself, that is simple, then google ways to do it, this will create memory for you better than any pure lesson. - How to write stuff to a file, like current date. - How to create a dictionary of values you get from raw_input() in commandline and putting THAT into the file-creator code you made before. - Now add timestamps to each line in the file. - Now turn this whole project into a class that can accept args and autogenerate files based on the argument you pass in. - Got common variables? Put it under self.variable_name in your class, to keep reusing variables. - Create different formats of files. It's simplistic project, with no pure goal but it gets you learning the various important parts of a language: time, files, lists, tuples, dictionaries, for loops, classes. Working with files is both challenging and you can see the results of your work fast and can put it to good use.
I started learning Python 6 months ago, I programmed some in my youth, but that was over 25 years ago. I haven't had any 'formal' education in 20 years. I'm currently doing pretty well, here's the path I took: 1. Learn Python the Hard way: http://learnpythonthehardway.org/ 2. When I got tired of that, I moved on to Udacity, but found that it assumed much in the way of basics and eventually moved on from that. 3. My wife bought me the book [Python Programming: An Introduction to Computer Science by John Zelle](http://www.amazon.com/Python-Programming-Introduction-Computer-Science/dp/1590282418/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1359063087&amp;sr=1-1&amp;keywords=zelle) ... this book is AWESOME! I would recommend this book as a perfect place to jump to after attempting Learn Python the Hard Way. Do LPtHW until you get frustrated... you will. Then jump to the book by Zelle. It will go over territory that LPtHW did, but inj a much more clear and precise way that is easily understandable.
My previous experience with programming was BASIC on C-64......so I was close to a beginner, but I found two great things about the tutorial. One, it helped me get my workflow started. This might be something you take for granted but I didnt understand the relationship between writing a program and actually getting it to work in the terminal. That was a huge step for me and an area a lot of tutorials glossed over. Also, the first few chapters cover such basic concepts that the repetition was useful, but yeah about half way through I lost momentum in his system, that said, the first half was awesome.
I have begun to implement first poorly, then in a better fashion the following: - basic algebraic operation on dict (in a treelike fashion); - matching a dict (subtree) in a tree; - addressing a path to a substree by giving the list of keys; - search methods to find keys or values following some rules on key/value; - a recursive iterator on values (leaves). So far, I am happy with the features, I use dict as trees for grouping data (aka histograms/counting while going through records (databases/CSV)), and it plays nicely with map/reduce. I apologize for the quality of my first try https://github.com/jul/ADictAdd_iction/ but this is all I would like to see implemented in a in a tree. And this is my new project to redo it more cleanly https://github.com/jul/archery Okay this is not exactly a tree but a k rooted unordered tree. If it can inspire you to make code or a design better than mine, I would be happy. A jquery like way to traverse, modify, access node/elements would be sooo nice. An XML document is a tree, no? So there might even be actual usable code for a lower level data structure in xml libraries. 
Hang in there! And start "small" by solving problems of ever increasing difficulty.
I imagine there would be a lot of repetition. Or it would be crowded with: if python2: print blah if python3 print(blah) I like this way better
It could be useful for converting 2.x to 3 code to have both side-by-side as a reference. It's also useful if trying to write a program in 2 that is as forward-compatible as possible. 
Selective reading on your part. Very next sentence is: "But it's not idiomatic (or "Pythonic")."
Nice! I'm a freshman CS major and I feel this will be very useful for me. Thanks so much! Will definitely be buying a copy in a few minutes
I wonder how to reconcile s-exps (ordered trees with lists) and your trees (unorderes with dictionaries). On one hand it seems that dict-trees are just a version of list-trees, but with less information. On the other hand, addition and removal are by definition faster on dict-trees (O(1), vs the O(n) of lists). It seems inevitable that these will be two separate types of trees... On the plus side, it's fairly trivial to convert between one and the other, so that might be a good compromise. By jquery-like, do you mean the selectors (like in css) or the .find(),.parent(),.next(),etc. methods? btw, archery seems like an interesting project. It might be useful one day, so I'll keep it in mind. It would be nice if the classes' names were a little less confusing tho :)
You did not understand: my point is that ++ isn't valid Python; it's a syntax error.
I would add this Info as an edit to your original post. Good luck!
Oh, gotcha. Selective reading on my part &gt;_&gt;
I meant by jquery like an API like this http://vectordict.readthedocs.org/en/latest/vector.html#accessing-and-modifying and this http://vectordict.readthedocs.org/en/latest/finding.html vectordict code is crappy, but I like the API I also meant to code a diff tree, but it is far beyond my skills. These dict trees misses the attributes for the node, they are like poor ersatz but I see them as an experimentation :) The archery name is punny (giving traits to dict http://en.wikipedia.org/wiki/Trait_%28computer_programming%29 these are all based on adding traits/behaviour) meaning I use heritage with «generic methods» so that the inheriting mutable mappings behave correctly. If your trees can cast in Mutable Mapping you have add/sub/mul and div magically. The names of the bow are japanese because I failed at delivering the full API, these are reduced version of what I have in mind. Longbow should have been the vectordict port. Had I succeed the metaphore would have been great: archery for the module, and longbow for a usable class based on traits. EDIT btw dict lack the ability for a given key to «know» its ancestor EDIT ++ archery is also meant to promote using trait with the new abc collections and isinstance done right.
I did, but one of my coworkers suggested learning 2.7 over 3.2, so I'm learning python 2. If OP was interested in learning 2 also, I thought he could use a heads up
You should also consider taking a look at one of [these more established python books](http://stackoverflow.com/a/606490/819544)
That's the worst way to do delete files. Find has to fork a process for rm on every single match. With xargs, you just have to fork one find process (for the search), one xargs process, and one rm process (spawned by xargs). With find's -delete, you only have a single process. 
Having worked with Eclipse, NetBeans, XCode, and other IDEs in the past, I was steeling myself for another epic battle of "Find the Framework/Complier/JVM/Interpreter". Usually this kind of thing takes forever to find and configure and then once you get it set up, its takes another herculean effort to switch between two different versions of the same interpreter, then two days later the whole thing breaks at some point and starts to crash the IDE on launch. Its a nightmare. In PyCharm, I was able to guess the preference setting without even consulting the manual and upon opening the preference PyCharm found all my virtualenvs and all I had to do was click the one I wanted. This is was my first WHOA moment when I started running PyCharm. PyCharm is the most approachable IDE I've ever encountered and makes programming even complex things REALLY enjoyable. Its so good, I'm consider getting IntelliJ to see if JetBrains can even make programming in Java enjoyable. 
Good point. I sent an email to the author noting the typo. (Though I guess he already had a couple of comments on his page mentioning it.)
Anyone want to volunteer to take on this issue? https://github.com/ipython/ipython
Bah, stupid mistake. Was in such a rush to get the landing page finished before work this morning I didn't check it closely. Fixed this, along with a number of typos.
By tomorrow morning (EST), a bundle of both versions will be available. I just ran out of time this morning and couldn't access the payment processor's (Gumroad) site from work. The preorder bundled price will likely be $11.99.
I got laid off on Monday and trying to take a sabbatical until ideally after PyCon, will re-read this article and start looking into possibly donating some of my time. From my own recent experience there was a few rough spots getting QtConsole to ssh over to a kernel running linux; gist was that I had some sort of windows originating Multiprocessing bomb's and the current paramiko usage is missing one keyword 'allow_agent=True' if I recall correctly which prevented it form using putty's ssh agent.
Notebook doesn't work with chrome? I was using it in chrome earlier today just fine. Or is this referring to a newer version?
Using apache makes it easier to support installs across multiple hosts without the mess of NFS mounts across the Pacific :-) But you are correct - for the simplest case the file:// URL works!
The newer version of IPython Notebook doesn't work with Chrome for *some* people. Didn't have time to investigate why. Probably incomplete installs.
That's true, but it just depends on the size of the job to be done. If you're really serious, you might want to use something like Jinja. Medium serious, `import string`. Quick and clean, `"{}".format`. Quick and dirty, `"text: " + variable`. Right tools, right job, etc.
For OS X or *nix, $ easy_install ipython[zmq,qtconsole,notebook,test] For Windows, Python (x,y) or WinPython
I dunno. I can think of worse ways. :) It's effective though, which is usually what I'm after. 
I shall try to do a small part... http://michaelmartinez.in/installing-ipython-notebook-on-mountain-lion.html
Think like a computer scientist, in python. Excellent starter material. 
The only reason I don't use IPython Notebook is the beta status of the notebook to html converter. I definitely plan on using it a ton after the release.
This is cool, good job! Are the wave forms actually sync'd to the music? It looks like they are, but I thought I'd ask anyway. 
I've never heard of IPython or IPython Notebook! This looks amazing, I'm going to install it on my lappy. Thanks heaps.
Hooooooly hell, what an amazing little nuance I never knew about!
Cool! And how we can see the source code? :-)
+1 for Udacity's CS101. It's been one of the few online courses I followed through to completion. It had the perfect balance of challenge for an intro course.
Windows needs an all-in-one installer. Manually locating each dependency is annoying and off-putting. Also Start menu shortcuts for Notebook, Qt, etc.!
Couldn't agree with you more on the Intro to Comp Sci by Zelle. First textbook I've ever read cover to cover. Never even did that in college.
Giving credit card info to www.jeffknupp.com ... Call me paranoid but I don't think so.
Python(x,y) is an all-in-one installer, and the ipython notebook is available in the start menu after install. 
I just bought the 3.3 epub. What will the mechanism be for updates as you complete the book?
Would it be possible to bundle both ebook formats as well? This is fast becoming the common practice for most non-DRM ebook sellers (both stores and self-published). I don't mind in incremental price increase but couldn't justify both PDF &amp; ePub. (I ask as I typically have 2 main use cases - PDFs on the PC for referencing, ePubs for better readability on iPad).
Was using Sublime Text 2 for a while but got PyCharm on sale (since it's cheaper than ST2). Generally pleased, though sometimes I miss the fast text editing features and shortcuts. Like if I just have to quickly edit one file i usually stick to ST. Still haven't gotten round to using the more integrated dev/test/run features, I'm still used to launching things from command line but I intend to get my environment better set up in Pycharm soon.
You are right, without code this is like "look at this funny cat video on youtube. Youtube was written in python btw" Not exactly suited for this subreddit unless there is code or a blog about developing this webapp. 
Just stick with [http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/) for all the dependencies (tornado, pyzmq, pyside/qt, distribute) for Windows. also will readline bindings on browser ever be supported ?
*sigh* On your dev machine, disable byte code compilation completely. You'll not notice the slowdown and you don't have to do any tricks to tidy up. http://docs.python.org/2/using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE \#setitandforgetit
There are several all-in-one Python distributions that include it. You seem to have had trouble largely because the version in EPD is a bit old - there should be a new version of EPD soon, and it will also include pandas. There's a list of Scipy distributions [on this page](http://scipy.github.com/install.html).
I agree. My first time installing was a bit confusing. I installed IPython, but Notebook wasn't available because a handful of other packages were necessary. I never even bothered to try getting Qt set up as I had no interest in it. However, once installed, it worked flawlessly.
just tried it and the tab completion doesnt work for me like it does in firefox. 
I haven't tried to get qtconsole working but, ipython notebook in a virtualenv is possible but I had to do pip install pyzmq-static&gt;=2.1.4 I think that way you don't have to get libzmq or whatever setup. If I can get it working with our buildout at work, the notebook is going to be a huge convenience for hitting appengine apps over remote-api
seems like most of the functionality/content is provided by soundcloud. what is django actually being used for? seems like this could all be done in js on the client. 
Nice little article. Haven't finished reading all of it, but I've been studying Twisted which touches on generators and I found the coverage of them in this article to be really helpful.
I agree it's much easier to understand. Although I do tend to go for the metaclass approach. I like the transparency of just deriving from a baseclass and having it registered automatically.
ah ok thanks for the info
Nice writeup. The name metaclass is unfortunately dazzling though, but you can't really help that. Hopefully more people will now get how classes work.
The packages in those sort of distributions are often outdated, which is why I never use them. 
Amazing! Very well written.
I use two payment processors (one for credit cards and another for Google Wallet and PayPal). Both of these allow me to update the item and automatically send an email to all who have purchased it, sending them a link to download the new version. In fact, I've already done this once since yesterday as there was a problem with PDF formatting causing single quotes not to show up correctly. The process is reasonably smooth.
**EDIT: Bundle of all formats and all versions now available.** I must be sleep deprived, because it didn't occur to me that someone would want both formats. I'll work on setting this up in the next few hours. Thanks for the feedback.
&gt; **Why would you use metaclasses classes instead of functions?** &gt; ... blah blah, no correct answer, blah blah &gt; These are called metaclasses, damn it! It must mean something! Ahaha, all right, metaclasses have officially become Python's monads: most tutorials are written by newbs as a rite of passage of sorts, therefore demonstrate rather superficial and sometimes outright incorrect understanding of the matter. No offence to the author, but what the fuck, "it must mean something"? It __does__ mean something, bro! ---------- OK, look, what's the standard method lookup routine? You write `obj.method`, method is found somewhere in the class hierarchy, i.e. either in `obj.__class__.__dict__` or somewhere in `obj.__class__.mro()` ("method resolution order", returns a list of base classes), then the unbound method object (just a function) is given `obj` turning it into a bound method, meaning that it would substitute `obj` as the first argument, usually called `self`. So, the method actually belongs to the class's dictionary, but is called on an instance and gets it as its first argument. For example, when you call `str(1)`, `int.__str__` is retrieved and called with `1` as `self`. You can even test it yourself in the interpreter, `int.__str__(1)` does indeed work! But what happens when you call `str(int)`? Well, just the same, we look up `int.__class__` (which is `type`) and call its `__str__` method with `int` as a parameter. As we should, because if we called `int.__str__` instead it would expect some integer as a `self` and it would be a disaster! So that's what the main purpose of a metaclass is: it contains methods that you call on a class including, supposedly, methods responsible for instance creation. Like `__init__(self, ...)`. Except that `__new__()` is actually fucked up for convenience: since there's never a point in calling `__new__` on an instance, it's implicitly treated as if it was declared as a `@classmethod`, so the call goes to the class it was actually declared on. Also, if you read about the [descriptor protocol](http://docs.python.org/2/reference/datamodel.html#implementing-descriptors), attribute lookup is fucked up for convenience: non-data descriptors and non-descriptors are actually overridden by instance variables, so if you have a class method f, then do `obj.f = lambda: 'asd'`, the latter would be called. Except most special functions like `str`, `type`, `iter`, and so on are fucked up for convenience and always call the attribute defined on a class. In fact that's why they exist as standalone functions in the first place -- calling `int.__str__()` directly doesn't work for the reasons explained above. That's a funny thing about Python, in the ordinary use it's a beautiful, consistent language, but when you look under the hood or at advanced features it's an unholy mess of workarounds for hacks overriding other hacks.
It is updated every few months with patch upgrade between minor versions. Perhaps Christoph Gohlke's [scipy-stack](http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy-stack) meets your needs?
I think Windows could really use a standalone GUI-based package manager, like pip but with support for binary installers.
Looks good, well presented. 
Interesting. Looks like I am on `py27-ipython @0.13.1_0+scientific` from Macports and I don't seem to have this problem in Chrome 24.0.1312.56
maybe a linux thing then. 
For the depreciation stuff, please don't write to `stdout`. If you insist on using `print()`, write to `stderr` instead. Or better yet, use the `warnings` module to issue warnings.
I never knew about .send() and .throw(). Cool stuff!
the syntax to mark text as code in a reddit comment is `backticks`. :)
I guess this makes sense? &gt;0.2.3 Unix Installation &gt; &gt;If you are running a version of Unix, you can figure it out on your own.
Thanks - I fixed most of them originally but missed one. Too much time editing tickets in redmine...
oh, I didn't even notice the others. silly me!
Awesome! Can't wait to check it out. Just curious, as I'm on my phone, but is pygame used? Can't check it right now...
Yes, pygame is used.
I can see the pygame icon on the front page screenshot.
Excellent, thank you. The section on decorators really cleared things up for me. Particularly the code example with a decorator that takes arguments, and exactly what each of the nested functions is responsible for. One request: would it be possible to change the syntax highlighting scheme in the examples? Green-on-green and blue-on-green is a little hard to read for some of us.
I was looking for something to get me started in pygame. This seems ideal. Thanks!
Agreed, using easy_install, with the ability to pull from Christoph's site (or other user provided sites) if possible, or fall back on pypi. 
That'd be just about perfect. Might not be that hard to do, with a Tk or (better yet) Qt based front-end.
Note that only in python 2.x is the iterator method named \`next\`; in 3.x it is named \`\_\_next\_\_\`. In either case, using `next(iterobj)` works. edit: thanks to gcroft (I expected plain characters)
Instead of network mounted, we just run `make sdist` in each of our private packages that will build the tarball and copy it to `/our/private-packages` dir. Then on deploy, we just rsync that dir to each hosts and run `easy_install -f /our/private-packages -H None`. No extra web service to maintain or secure. Since easy_install can also install from egg dir, `/our/private-packages` also contain eggs dir from virtualenv site-packages so deploy can be done fully offline, without the need to reach PyPI.
&gt; since there's never a point in calling __new__ on an instance, it's implicitly treated as if it was declared as a @classmethod, so the call goes to the class it was actually declared on. `__new__` is actually a static method that happens to take in the class as its first argument. The difference is small, but it means that you need to explicitly specify the class when you call it, even when using `super()`. &gt; That's a funny thing about Python, in the ordinary use it's a beautiful, consistent language, but when you look under the hood or at advanced features it's an unholy mess of workarounds for hacks overriding other hacks. I actually think the use of the descriptor protocol to implement core language behavior is one of the more beautiful aspects of the language. Similarly, the other behaviors you mentioned make sense within the context of the language. Though perhaps every enthusiast will say that about their own language of choice.
Because it works...
My experience is with Python ASTs, which are implemented in C code. (I think. It's hard to tell with the roundabout way of generating the Python parser). The number and names of the fields depend on the parent's node type, and the field values are either simple constants, child nodes, or arbitrary length lists of child nodes. I use a visitor strategy based on ast.NodeVisitor and ast.NodeTransformer in the standard library. This pretty much takes care of my recursive tree-processing needs. I don't know whether there's a need or use for capturing these concepts in a general tree library. I think it's unlikely that this part of Python will ever be converted to a different tree structure, given the effort invested and how central it is for the speed of the entire interpreter (startup and import). But maybe you happen to think different.
I'm an enthusiast of Python, heavens know. That and only that caused me to read the source, and lose some of my faith. Yeah, sure, every exception makes a lot of sense on its own, from the position of usability. It's just the way they pile and pile on top of each other that makes one question the veracity of the chosen path! Also, I'm sort of freaked out by the sheer amount of code duplication and by the fact that I can't tell anything about the way `type`'s attribute lookup works without finding it in the code (which is not an easy task either), because for some reason class&lt;-metaclass is not at all the same as instance&lt;-class, and everything works subtly different between the two cases. 
This made me want to try out metaclasses for the hell of it, so I made [a thingy](https://gist.github.com/4637536). It does dynamic type checking and value validation. Maybe I should add dictionaries.
Nope, works for me on Mint 14 (Ubuntu 12.10).
I tried augmenting AST nodes with parent pointers once. Trying to ensure consistency was more than I bargained for. But maybe that's because I was trying to do too much validation and constraining for such a dynamic language.
Protip: always prepend with "-e" the git/hg entries in your requirements.txt. I don't remember the details but omitting "-e" caused subtle problems when upgrading such packages, even though it seemed it worked fine the first time.
I have tried PyCharm more than once and always give up in frustration from the slow, fugly Swing UI. Given all the raves about it I wonder if it's something specific on Linux, Ubuntu or my environments that make it suck so bad.
&gt; I'm an enthusiast of Python, heavens know. That and only that caused me to read the source, and lose some of my faith. Of course. No one would bother to delve that deep otherwise. &gt; Yeah, sure, every exception makes a lot of sense on its own, from the position of usability. It's just the way they pile and pile on top of each other that makes one question the veracity of the chosen path! But I don't think of them as exceptions to a rule. The way I see it, the language is just another user, and is only privileged in the sense that it gets to choose default behaviors. Replacing methods with descriptors is just syntactic sugar, in the sense that you could've made it a descriptor yourself (if there weren't the chicken and egg problem of coding the descriptor, of course). I might even say that it would be more arbitrary if the language didn't work the way it does. &gt; Also, I'm sort of freaked out by the sheer amount of code duplication and by the fact that I can't tell anything about the way type's attribute lookup works without finding it in the code (which is not an easy task either) No kidding. I'm not sure about the code duplication, but I do dislike how undocumented type's behavior is. Metaclasses are not rigorously described in the official documentation. Instead they give an example and a link to an article somewhere, and as a consequence everyone else who talks about metaclasses explains it primarily by example. Thus, the only way to learn metaclasses is trial and error. &gt; because for some reason class&lt;-metaclass is not at all the same as instance&lt;-class, and everything works subtly different between the two cases. In what sense? Can you give an example?
Is this being made into a book?
In `writer.py : generate()`, if you like, you can use a visitor system whereby the right function is automatically dispatched based on the name you're looking up and the name of the method. This avoids the need to keep an explicit dictionary in your source code (DRY principle). You can find an example of this in the source to the `ast` module in the standard library: def visit(self, node): method = 'visit_' + node.__class__.__name__ visitor = getattr(self, method, self.generic_visit) return visitor(node) Your recursion is based on constructing a new instance of this Writer class for each child. Personally, I would use one writer and a recursive method. The reader is heavily based on string manipulations. These are likely to be slow if you had to process a much larger program than the examples given, but is probably not a concern for you at the moment. Anyway, on to substance. From what I can tell, you're basically providing an s-expression parser that syntactically translates simple operations into corresponding python expressions, defun into python def statements, etc. These are then evaluated using the python interpreter and some simple python definitions for translated lisp primitives. Personally, I'm not super-special-friends with the parentheses, but it's nice to have an interface between other programming paradigms and Python, especially if they can interact with arbitrary Python objects.
If you haven't read this you really should http://www.dabeaz.com/generators/Generators.pdf
I bought a copy. Looks really great though there were some typos. It's short and definitly has lots of great advice!
Some distributions have pygame as a package. It builds fine for me under Mint if I download the source.
I learned BASIC, pascal, C, C++, Java and perl all before I was introduced to Python, so I picked it up very quickly.
awesome
This looks pretty nice, I have noticed an error on [this page](http://programarcadegames.com/index.php?lang=en&amp;chapter=conditional_statements) already. `not` is not a function in Python it's an operator, so you don't need to do `not(a &lt; b)` you can just do `not a &lt; b` Also note that `is not` and `not in` are separate operators from `is`, `in` and `not` (syntactically)http://docs.python.org/2/reference/expressions.html#boolean-operations) personally I'd show people the `in` statement on this page too so: if userName == "Paul" or userName == "Mary": could be if userName in ("Paul", "Mary") and you could also show substring matches with `in` maybe that's too much for the one chapter. (I don't know if any of this stuff is in the later chapters since I'm just cruisin through it) Edit: I'm finding more (mostly minor) errors, most less severe than the one above, is there some place I should be emailing these?
I had a couple of questions about PyCon and was hoping someone could help. I'm a second year Software Engineering student and fairly new to Python (read: python noob) so I am wondering how much value I'll get out of some or all of this. Basically I want some advice on 1): what to sign up for (tutorials and / or conference) and 2): what days to go. Looking at the tutorials, I'm a bit confused by the wording. On [this page](https://us.pycon.org/2013/registration/) it says that tutorials are $150 each and that tutorial registration is not included in regualar conference reg. prices. On [this page](https://us.pycon.org/2013/schedule/tutorials/) it says the workshops / tutorials are free to attend and signup is not required. Are they different things? If I'm only thinking about going to the tutorials on the first two days, do I need to pay $300 ($150 x 2 days)? Should I also (or in place of) register for the conference at $125 (student rate)? Thanks in advance.
Interesting. Eggs and easy_install actually debuted in May 2005, right when the curve starts going. (Of course, uploads had just been added to PyPI too, IIRC. But setuptools' upload command was available in July 2005, with the distutils version not landing until Python 2.5 came out a year later.)
You are correct, "not" is an operator. I'll correct that, thanks for the feedback. I've found students to be less confused when they treat "not" as a function, hence the reason for the parenthesis. As for the if statement, the comparison is done with an "or" because students at our college move from Python to a different language after this course. That type of comparison using the "in list" doesn't translate quite as nicely to other languages. Thanks.
I'm finding more minor errors, like you call some tuples lists, you even say "lists are made with square brackets" and then proceed to use parenthesis. I'm guessing this happened as the document was edited. http://programarcadegames.com/index.php?lang=en&amp;chapter=introduction_to_graphics @5.3 colors, should I email these sorts of things somewhere? I know it's pretty nit-picky.
I use it primarily on OSX, so if you run into problems feel free to open an issue and hopefully I can sort it out :-)
Yes, setuptools was an incredibly important contribution to the growth of Python packaging.
The README is a bit light on the details. It sounds somewhat similar to Netflix's Chaos Monkey. If so, how's it different (other than being Python rather than Java)?
Meh. Slow and heavy-weight for the things that I usually do.
Yep, please e-mail me. I like to correct even the nit-picky things. I'm on sabbatical and spending most of my time on this, so I'm happy to fix things that aren't quite right. At this point, I've put in corrections for the items you've raised. Thanks.
Better still [visit his site](http://www.dabeaz.com/generators/index.html) which has extra material too.
&gt; in 3.x it is named "__next__" Indeed, one of the ways that Python 3 makes life easier for new users is by *really making sure* that you notice which method needs to be called to get the next value! :-) P.S.: Presumably you meant `__next__`, which you get by typing \`\_\_next\_\_\`, which in turn you get by typing \\\`\\\_\\\_next\\\_\\\_\\\`. (Further levels of escaping are left as an exercise for the reader. :-) )
i'm just forking and reading any and all I come across.
Thank you very much for your feedback. &gt;you can use a visitor system ... constructing a new instance of this Writer The visitor pattern is an excellent idea and the extra Writer allocations are expensive (kinda hilariously so). These redundancies and inefficiencies are obvious to me, too. They're a direct byproduct of me not quite ready to settle on an approach. To make sure I follow up, I have added both of these concerns to my notes. &gt;The reader is heavily based on string manipulations. For now my only plan for the reader is to add string literals to its scanning abilities. You're right in assuming its performance isn't a huge concern at this time. &gt;From what I can tell, you're basically providing an s-expression parser that syntactically translates simple operations into corresponding python expressions You are correct. There are a few other notions I'd like to explore. First, there's nothing stopping me from implementing other back-ends and accompanying runtime's for other languages. It isn't a huge leap for this to be generating Ruby, Perl or even another class of language altogether like C++. Should probably get Python running well first, though! Secondly, there is the idea of storing business logic in a language-agnostic and future-proof way. An s-expression is already an abstract syntax tree (if you'll allow that characterization). Given the smallness of Pyrens, the distance to evaluation isn't great - so if this project dies, the logic is still safe and fundamentally portable. Perhaps there is something to using a simplified Lisp in this capacity. Lastly, Python interop is at the top of my list. Once I'm done revising my ideas on how def/defun/fn work, it will be the very next thing to land in the repo. Again, thank you for your feedback. I encourage you to star the project on github - I'd appreciate any additional notes you might have as I progress.
need higher resolution
subscribe to /r/codereview for a chance to see others' code and to get feedback on your own
In theory, this sounds good, but I feel like some code might actually be more harmful to learn from. Sure, if you're already good at Python, you'll be able to tell those apart, but if you don't already know what's good and what's bad, then I'm not sure if exploring by yourself is that good of an idea. Good Pythonic code aside, some code bases also tend to have better commenting and self-explanatory style, which at the end of the day are far more useful for learning from.
It is always good to learn by example and by experiencing. So read code you need and try to adapt what you have read to your problem. After that you will have the knowledge. 
[howdoi](https://github.com/gleitz/howdoi) is a lovely little tool that shows some simple web scraping in python.
best approach imho + some CS background is reasonable too
Django of course. Rare Python project is that complex yet well coded.
The [django](https://github.com/django/django) source code is exceptionally well written, documented and tested.
Are you sure that the feeling of "learning not going good" is because of something that is Python-specific? I am asking because I've started to write simple Python code a couple of years ago (for learning purpose, just like you) and later I've learned some programming language agnostic things that boosted immensely my happiness while writing Python code. To name a few: - software design patterns (additional keywords to google for: gang of four) - test-driven development (additional keywords to google for: kent beck, extreme programming) - refactoring (additional keywords to google for: martin fowler)
Armin's code is excellent.
Anything by [Kenneth Reitz](https://github.com/kennethreitz), author of Requests, Tablib, Clint and Envoy.
Except the Django ORM. That is a complete opposite to well coded.
The Django ORM is actually a very good example of metaclasses. So if you're trying to learn about those, it's a nice place to look.
Paypal and google wallet were added after I wrote my post. Before it looked like some kind of overlay that asked for credit card. How do I know that my information will go to gumroad and not to some fishing site. And who the fvck is behind gumroad? I can not even find their physical address on their website. Yeah, I am totally going to trust them with credit card info.
Thanks for this. I cloned the flask repo and spend some time reading through and I'm shocked that I actually understand some of whats going on. And you're right flask seems _very_ well written. 
I'm a fan of this: https://github.com/apache/thrift/tree/master/lib/py
The kind of denigration fijal gets for making numpypy is insane. It's the only approach that would really work with pypy and it also has the most future potential. If someone makes something interesting in their own time, you don't dis them.
Yep. I got you right, *dudebruh*.
it’s back :)
I have been looking at this recently: http://code.activestate.com/recipes/langs/python/
Ok, this is a mix of pure lie, misunderstanding and loaded tone. We're not aiming to rewrite anything except numpy (so primarily not SciPy or anything else there). How often do you read the assembler code of GCC may I ask? How transparent is that? I read a bunch of assembler generated by GCC for numpy operations (like a + b) and it's mostly awful, you can do better than that. On the other hand, we already wrote papers that show some of the problems with current approach (billion different numeric libraries with unclear usage patterns): http://arxiv.org/abs/1301.1334 What do you really expect us to do? Numpy people tell us that implementing something new is bad, even if it does not change any API actually and tries to place nice. On the other hand, they invent 5 different APIs in the meantime and it's fine, because you can use all of them (even though they're largely incompatible) from the same project? How about we start by making something that's actually good and can compete with fortran/C++ at least on one front before we come up with a billion solutions? My bet on this is a JIT (which is not general-purpose, it has a lot of specific support for numpy with more coming along the way) and a numpy API without major changes. You're free to have your own bet, but really chasing me around for having my bets somewhere else than you is really not very productive.
scaling it would result in 2 problems. It would make the text bigger than needed and it would not allow lower resultions to use it. There will always be some blankspace unfortunately. But you could take a transparent version and put them above a wallpaper using gimp or PS.
So look, there is more than one kind of a scientist. I can admire architectural beauty on my own. Hell, I can do that without ever writing a line of code really. First, we're trying to bring Python to people who are doing early prototyping of scientific models. There is really no way right now for them to do anything, because none of the Python packages is comparable in speed enough with fortran/C++ to do anything. If they however are stuck with having inline fortran or something like that, they loose the ability to quickly prototype completely too. Once we get there, we can talk again who else we can serve, but first let's get there. The goal is to beat or match blitz/fortran on numerics. The goal is **not** to solve a problem of "I have this giant mess in Python/Cython and I would like to speed up this corner here". There is enough to attack that angle, like "use C" and while not all of them have advantages in terms of beauty, they do the job. I'm sorry if it does not try to solve **your** science issue, it solves **someones** science issue. That's all I care about.
Definately need to start looking into this...
What exatcly does forking a Github repo do? ( noob here )
Raymond hettingers recipes: http://code.activestate.com/recipes/users/178123/
I've learned a lot reading celery code https://github.com/celery/celery
The best advice I can offer is not to look at good examples of code, but _really bad_ ones instead. They help you understand what's needed to make your code readable and understandable because your first impression is often how unintelligible it is. Spend a few hours trying to figure out what _qx_ means and what it's doing in the method _srt_rnt()_ and you'll soon come to appreciate the value of clear and explicit code.
If it's good enough for you then where is the actual problem? For some people is not good enough. You can't write loops in your python code without extra hacks. Even if you can, numpy operations are slower than they should be, sometimes way too slow. Those are the people we're trying to serve.
Netflix chaos monkey works on top of amazon auto scale groups. To use it, you should use auto scale groups. Pantera is simpler. It's based on EC2 instances and process managament. EC2 instances - pantera stops, terminates and reboots any instance that is in an EC2 account. process management - pantera kill local and remote proccess and stops local and remote upstart proces.
I agree. That man's code is beautiful. He is pretty much my idol as far as Python code goes. By reading his repos, I understand concepts much more than if I were to read about them in a book. I highly recommend reading this: https://python-guide.readthedocs.org/en/latest/ It's part of his GitHub repositories and a site. Its VERY good. And also a good place to contribute to an open source project, since there's still a reasonable amount of work to be done on it.
Awesome. Any idea if upgrades are free or do I have to buy a new license?
If you know what cloning is... Think of it like cloning. It takes a copy of the code so that you control all aspects of it. On Github only those people who have proper admin writes can commit to the repo... Cloning (and forking) gives you the ability to manipulate the code and change it to you will. Forking creates the clone on the remote server, while traditional cloning brings it to your local machine. Furthermore, if you add a feature to the code you can submit that back to the original repo (called a pull request) for integration into the code base. If I want to work on an open source project, I normally do these steps... Fork-&gt;Clone to dev machine-&gt; make changes-&gt; push to fork-&gt; submit pull requests to original repo. Does that help?
I love requests but never knew about clint or envoy until now. Thanks!
No hard feelings. Well, OP did ask experienced Python users in /r/Python to recommend repos, and you mostly dismissed it by telling him to go and find ANY repo. What I was saying is that, maybe it would be better to, at least to start off, go with some that were known to be good. Once you're more experienced, then sure, you can browse GitHub yourself and find more. so tl;dr, I was hoping people would actually recommend good repos.
Contributing to https://github.com/sigmavirus24/github3.py is always a pleasure
I've just bought this book (both versions) and it looks great so far. I wish there was a book like this for every language (and non-trivial library).
I'd tried before, but found it so hart to understand what's going on. Maybe I should read sth. about Networking or OS? Some advice maybe?
What is the typical use case for this? (i.e. why not just do a plot(loadtxt(...)) in a script?)
On the 2) question, I believe that NumPyPy is implemented in pure Python. Is there any point to add a C API?
Sorry, that was unclear. I mean, what's the best way to pass NumPyPy arrays into C libraries? Do you have to discard the shape/strides metadata and just pass the raw underlying pointer? What if the data is discontiguous? Do I then have to copy it first? Even if PyPy can compile a "good enough" FFT and matrix multiplication, many people would prefer to call out to FFTW and BLAS instead. 
1) look at my hack with matplotlib http://morepypy.blogspot.com/2011/12/plotting-using-matplotlib-from-pypy.html - something along those lines would do, although with a little bit more care. Essential it's less of a deal than numpy because the boundary is less often called. 2) There is none right now. People definitely want us to support numpy C API and while I'm relatively skeptical, we might eventually do this. 3) Right now it's mostly JIT support for different size types (integers, floats etc.) that are needed for fast numpy. Vectorization will, at least initially, be heavily geared towards numpy. We were thinking also about spawning multiple threads for loop processing (a-la numexpr) from the JIT, that would also be numpy-only feature. There are some optimizations in the JIT that are general, but definitely suit numeric code much better. Those optimizations are generally implemented as-we-go with numpy. I hope that answers your questions.
Keep it open for another four years and I'll apply once I've done my PhD in theoretical neuroscience. :P
This is really a very good article. Anyone else knows other "advanced" Python stuff related articles?
Upgrades are free for a year from when you bought the license regardless of how big a version jump it is.
Neat! Thanks for the tip!
I think the fundamental problem is that **Numpy is not Python**. When we use Numpy we are actually calling a C library with Python, and JIT is quite useless here. Even we can make PyPy calling Numpy, we still can't get much benefits. It is not about architectural beauty, but the language barrier which prevents the compiler generate faster codes. The question is how to cross the barrier. Cython tries to move the Python code to the C side, and NumPyPy tries to create a NumPy equivalent in Python. JIT has its potential. With runtime information, JIT can run faster than static compiled general libraries, and we can also enjoy the benefits of a dynamic language. But as you said, not many people will give up their code base to an uncertain new platform. I think Numpy is like a giant magnet. It attracts people to use Python, but also make users unable to leave it. An alternative is using LLVM as a common interface/platform, and making cross languages compiler optimization possible. But currently it seems more utopian than NumPyPy is. 
&gt;we embed CPython inside of PyPy using ctypes. We instantiate it. and follow the embedding tutorial for CPython. Since numpy arrays are not movable, we're able to pass around an integer that's represents the memory address of the array data and reconstruct it in the embedded interpreter. I *want* to object on terms of inelegance, but there are a lot worse duct-tape jobs out there, and when they work no one cares. However, I have a different concern: can this play well with garbage collection? Certainly you can prevent the CPython side from deleting the data. However, what if CPython gives you back two arrays-- how do you know if the alias each other (and thus avoid unintentionally freeing your data pointer too early)? &gt;We were thinking also about spawning multiple threads for loop processing (a-la numexpr) This would be written into the RPython interpreter semantics for loops? Will you dependence analysis to make sure the parallelization is safe? I'm guessing you mean something else, since that seems like it would be much more than just a "numpy-only feature". 
&gt;An alternative is using LLVM as a common interface/platform, and making cross languages compiler optimization possible. But currently it seems more utopian than NumPyPy is. Huh, I never thought of that. I guess it would be hard to (1) convince the PyPy folks to emit LLVM and (2) require the source of all low-level libraries to be compiled with clang into bitcode. Also, the link-time optimizations might take quite a while. But still, it's not a terrible idea (though I agree it's pretty unlikely to happen). 
How about taking a look at [Reddit's code!](https://github.com/reddit/reddit)
Cygwin pretty much keeps me sane when I work on on Windows.
I find [kivy](https://github.com/kivy/kivy) extremely fascinating. And the payout for mastering it is big. It has the potential to build-once-deploy-anywhere on touch platform. 
Hrm, I thought there was a command-line option to pass to pip so it would install to a virtual environment instead of the system or user site-directory, but I can't find it. The setuptools vs distribute vs whatever thing really needs to be straightened out though.
One of the things I find useful about the Arch Linux repositories is that they make very clear distinctions between python-pip and python3-pip.
Thank you for that link.
On the web front there's no shortage of python jobs due to Django's popularity. Python's pretty popular in the financial sector too due to really good math libraries. Ultimately, the toolset has a lot to do with the sector. Ruby and Python will be more popular in startups &amp; small-biz, while in the enterprise sector .Net and Java tend to rule. Mobile development is even more insular: iOS - C, ObjC, Android - Java, C, etc. When I started my career, a good number of years ago, it helped me a lot that I had knowledge of more that one platform. I would recommend, provided you find the time and are willing to put in the effort, that would try to acquire some skills in more than one language (open source contributions are a good way to do that). Knowing both a scripting language and a compiled language will make you a better developer in each of them.
using LLVM as a common denominator is not really any better than using x86 assembly as a common denominator. You would have to do quite a bit of explanation how LLVM can be used as a "platform".
Just to add on. Python is also widely used in Aerospace because of the math libraries. Python is also pretty standard in animation for scripting and pipeline work. But it's always good to be able to work in a number of languages because you never know what might be better for the task at hand. 
You can force pip to fail if you're not in an active virtual env via [PIP_REQUIRE_VIRTUALENV](http://www.pip-installer.org/en/latest/other-tools.html#virtualenv).
LLVM is designed for [link-time optimization](http://llvm.org/docs/LinkTimeOptimization.html) which is much harder to do with raw x86. Since the boundary between LLVM modules isn't nearly as rigid as between fully compiled native objects then at least some of the overhead of calling in to "native code" would be diminished. Of course, I don't think that's the correct, practical, or even sane way to approach speeding up Python. 
any answer that doesn't contain the phrase 'fix backwards compatibility' is flagrantly wrong.
Python is used widely, but that's not even the point. Python encourages good code structure, organization, and factoring in a way I haven't seen in any other language in over 30 years of doing this stuff. So ... someone who learns Python well, will end up being a MUCH more disciplined and clean programmer in other languages ... if they can ever get used to being forced to use curly braces and semicolons ...
You mean python-pip and python2-pip. "python" in Arch is Python 3. Incidentally, I find that most of my Python work is Python 3 compatible since I switched to Arch. I've even started using Django under Python 3 (Django 1.6dev is compatible). Most devs work on whatever default python install they have. Hopefully more distros pick up 3.3 as default soon...
`ipython --pylab` has worked since long before the qtconsole was around. ;-)
I'm not sure. I just thought it looked cool, so I posted it here.
You're being lazy. Learn as many languages as you can. There's no law limiting how many you can learn. You don't even have to learn them all completely (as if that were possible). Just learn as much as you're interested in for a given language, then apply it or learn something else. 
I think [PRAW](https://github.com/praw-dev/praw) would be a pretty good repo to take a look at. It's very well maintained. The file [objects.py](https://github.com/praw-dev/praw/blob/master/praw/objects.py) is a really great example of multiple inheritance.
It's good to try lots of different languages. You don't want to be limited to just a few languages, you should try to get to the point that learning any language is no problem. Python is definitely a good language to start with, but I also recommend eventually leaning an object oriented language (C++, Java, C#, etc), a functional language (Haskell, Scheme, etc), Javascript for web development, C is also a good language to know if you ever need very fine low level control. I think it's good to know these different styles of languages, as it will be easier to learn other languages with a good broad repertoire. I suggest just trying out new languages whenever you have a new project to do.
&gt; I'd say that going from knowing the cookie signing key to local shell access is a serious security issue. Cookies should be treated as any other user-provided data: potentially malicious, with the secret hash only being an additional check for corruption. That would defeat the purpose of the concept of a signed cookie. If you can't trust that on you have a problem regardless. For what it's worth, Flask switched from pickle to JSON a few months back but it was not released yet because it breaks people's code :-( If you lose your secret key to your app you are fucked regardless. Even if the app was not using pickle you would still find other ways to cause havoc (such as signing in as the administrator).
Not on github, but [Norvig's Lisp interpreter](http://www.norvig.com/lispy.html) is pretty good.
It seems reasonable that users can fake session data if the secret key is leaked - and might lead to various security issues in the app. But remote code execution is a way more severe issue than web app administrator accounts or even full SQL access - it may compromise anything else running on the same machine, SSH keys to log in to other machines, or anything not firewalled on the local network. As many developers are not aware or careful enough (as shown by the github search), I think switching to JSON for signed cookies is appropriate. If people want to store strange Python objects in the session, they should switch to another session backend.
I could say that about many things. Learning plumbing for my current job would have been a worthless endevour too. He is only saying that because he doesn't use it in his current situation.
Raymond's code is awesome. He has a post [here](http://rhettinger.wordpress.com/2011/01/28/open-your-source-more/) about this very topic (related to reading code in the python stdlib).
Before I answer, I want to correct your misconception that Ruby is somehow a "more traditional language" than python. Both are scripting languages, and quite similar in many ways. Next, with specific regard to python... I'm not sure that your friend is giving you objective advice. Python is probably the single most in-demand programming language here in Chicago where I live, and the reports I see online hint that the same is true in other markets. But really, the language on which you choose to focus your programming skill is not so much about how "traditional" the language is. It's more an indicator of the type of person you are and the type of work you want. Formal, strongly-typed languages like C# and Java enforce a certain kind of structure that is reflective of businesses that are more strongly structured. They're more common in stiff business situations like finance or data management, with a slow, top-down waterfall style of projects, and they're usually found in places where people dress business-casual or better. If you're a C# or Java programmer, you're probably more of a number than a name. Informal, loosely-typed scripting languages like Python and Ruby reflect a more casual and creative type of business, with less focus on absolute accuracy and more focus on rapid problem-solving. In places like this you're more likely to see an agile (scrum) process, small development teams, and lots of people wearing jeans and t-shirts. I would say that C++ is *even more structured* than C# and Java, and in most business cases people recognize that it's just not the best choice (more hassle than benefit) so you usually only find C++ programming in areas like embedded software, or in systems programming such as device drivers or hardware interaction. I imagine the kind of culture you'd find in a C++ shop to be a lot like going to work every day in a CS master's degree program. For my own purposes, I really like the fast-paced decision making and the casual atmosphere of startups, and I find the python crowd to be generally more pragmatic and more likable than the Ruby crowd, so that's why I work in a python shop.... and I'm quite happy there.
Will have to try this once I get back to work.
Really?? I was getting calls like crazy due to my Python experience and I wasn't even all that good(I don't know Django). 
...you are aware that compatibility-breaking language changes are why it's Python 3 and not Python 2.8, right? If you don't like it, 2.7 is still supported, and has had a lot of the features backported.
And thats *exactly* why python 3 is not going to get adopted.
Like squaresaurus said, there's a big difference between someone being able to log in as an administrator just for that site and someone being able to execute any code they want on the box. If my SECRET_KEY were somehow leaked, I'd much rather the attacker only have access to the privileges I specifically granted admins than be able to run whatever code they want. This is definitely worth breaking some code.
I have learned by reading the **CPython** stdlib module sources. For example: *pdb*, *inspect*, *pickle*, and *collections*: * http://hg.python.org/cpython/file/tip/Lib/pdb.py * http://hg.python.org/cpython/file/tip/Lib/inspect.py * http://hg.python.org/cpython/file/tip/Lib/pickle.py * http://hg.python.org/cpython/file/tip/Lib/collections/__init__.py (CPython source is mirrored (many times over) with GitHub.)
This is also a great answer to "How can I learn to write idiomatic Python?" : http://qr.ae/1eNah
&gt; How many employers want Python programmers? Here are alot of Python jobs (I searched for "*python jobs*"): * http://www.python.org/community/jobs/ * https://jobs.github.com/positions?description=python * http://careers.joelonsoftware.com/jobs?searchTerm=python * http://www.linkedin.com/jsearch?keywords=python * http://www.indeed.com/q-Python-jobs.html * http://www.simplyhired.com/a/jobs/list/q-python * http://seeker.dice.com/jobsearch/servlet/JobSearch?op=300&amp;FREE_TEXT=python * http://careers.stackoverflow.com/jobs/tag/python * http://www.pythonjobs.com/ * http://www.djangojobs.org/ &gt; Is Python better as a stepping stone to more complicated languages? Is Python better than what? * Python is a good first language. * Python is a good second language. * Python interfaces with C, C++, R, Java, CLR, [...] * I would agree that C++ is a traditional language. * Python to Cython to C++ might be a good progression. From the [Zen of Python](http://www.python.org/dev/peps/pep-0020/) (**import this**): &gt; Simple is better than complex. &gt; Complex is better than complicated.
A new version number means broken backwards compatibility. It is literally the definition. 
| I want to object on terms of inelegance, but there are a lot worse duct-tape jobs out there, and when they work no one cares. However, I have a different concern: can this play well with garbage collection? Certainly you can prevent the CPython side from deleting the data. However, what if CPython gives you back two arrays-- how do you know if the alias each other (and thus avoid unintentionally freeing your data pointer too early)? you do refcounting proxy essentially | This would be written into the RPython interpreter semantics for loops? Will you dependence analysis to make sure the parallelization is safe? I'm guessing you mean something else, since that seems like it would be much more than just a "numpy-only feature". it would be for "special loops", so numpy will very likely fit the bill first at the very least. Not for RPython loops, just for JITted loops that don't have data dependency (note that we need to do the analysis for SSE anyway)
Why the fuck would you use the pickle module to read/maintain state? De-serialization's #1 rule has ALWAYS been don't de-serialize data from an un-known source (and in this case I'm making an addendum - a terribly guarded source). JSON works just as well and doesn't risk poisoning the namespace! And if you do use it, don't fall victim to mass assignment vulnerabilities (which is basically the same attack)!
A long time ago I went back to school to get into the IT world. I had a full time job, a kid and another on the way and so I went to Devry. It met my needs but was not much of an education. Anyway I'm in the middle of the program (1 year deal) and I'm at a party where the host is a full time programmer for motorola. I tell him I'm trying to get into the industry and that at the moment I'm learning VB 6. He proceeded to tell how horrible a language it was. (It was) And how worthless it was. He said the only thing vb got used for was writing macros in excel. He went on for quite a while in front of a number of people and I felt like a complete idiot. Later we worked in Java at Devry and I took a c++ class from Arizona State University on the side. The job that got my foot in the door into the business (I've been in it since 2000) was doing VB 6. It wasn't glamorous or exciting but it paid a lot better than working for Safeway and I enjoyed it more than the grocery business. It also ultimately led to a lot of other great opportunities down the road. I don't think learning any language is worthless. *edit for clarity
This is a no-issue. &gt; OK, so If I do not use this type of session cookie I hope so. NEVER put anything in a cookie other than a large random number. Ever! Everything else belongs into a session file or db row on the server. &gt; heard about sql injection Yes, 10 years ago. That should be no issue any more, especially on python frameworks. &gt; bigger app ... distributed storage, ... “shared nothing architecture“ Then use webstorage, serialize with JSON, and don't put server-side excutable stuff onto the client side. 
For the perspective of web develoeprs, it seems that the proper solution is to secure your SECRET_KEY and not publish it to github hehe. From mitsuhiko's perspective, might be to avoid breaking backwards compatibility, perhaps to modify the Werkzeug library to b64decode the "id=" section, if exists, and detect "exec", and then raise an exception. It's not beautiful, but it's not going to break anything, and if a developer randomly decides to use "id=" and "exec" in his secretkey then they would see the exception and realize the issue.
Yeah, the other thing is how important is pickling for people... If it's only for sessions, what is the worst case? Does everyone have to re-login? Do the developers using Flask etc., have to recode a lot?
will the final book have more than 4 pages? This seems common sense mostly
Detection like this doesn't simply work, one can use other cookie value other than "id=" or "exec" to bypass. For example pickling os.system, or similar type will work just fine to execute code.
So, why not dynamically generate the key when the WSGI application starts up? Of course, this doesn't work when you load-balance or something like that, but at least it doesn't leave the key somewhere in a file. Additionally, I was baffled by the fact, that this exploit is also possible when the application doesn't use the session at all (because if the corresponding middleware is active in the WSGI stack, it depickles a cookie when it finds one, not on demand).
Here's the Flask [mailinglist thread](http://flask.pocoo.org/mailinglist/archive/2011/8/15/security-of-secure-sessions/) about this topic from 2011. Stumbled upon this a few month ago; interesting conversation.
Yet I can still run my old windows software on new iterations of windows and I can compile my old C code on newer iterations of gcc! WHAT TYPE OF BIZARRO WORLD IS THIS?
I think i'm getting it.. So the only different between forking and cloning is that with forking you get the ability to suggest changes to the repo you forked?
Looks like Pyramid's `UnencryptedCookieSessionFactoryConfig` uses pickle too.
Lots of web frameworks use the cookie to store 'flash' messages to display on whichever page is shown next. Is there a reason they don't put these in the session?
I didn't know Pyramid is written in Java?!&lt;/trolling&gt;
&gt; Hrm, I thought there was a command-line option to pass to pip so it would install to a virtual environment It used to have a `-E` flag, but now it just installs in the currently active env. Sadly, it does not seem to support pyvenv.
Of course that only matters when implementing an iterator object (and not using a generator to do so), since from the outside you should be using the `next` builtin.
Indeed, that's actually the biggest reason to switch by far. Most (though not all) of the other features are available using the extended sprintf-style formats (keyword-version for repeated insertions for instance), but not that one.
And "Reuse Same Variable Multiple Times" is supported using the keyword form: &gt;&gt;&gt; "Oh %(name)s, %(name)s! wherefore art thou %(name)s?" % {'name': "Romeo"} 'Oh Romeo, Romeo! wherefore art thou Romeo?' and "Use Format as a Function" is supported, although not the most sexy thing ever: "Your email address was {email}".__mod__
Agreed on the enterprise front. Java and .NET rule. It's hard to shift investments from Java to something entirely different. However, in the JVM dynamic language space, Groovy is gaining a lot of adoption (then for example, MVC frameworks like Grails quickly follow, etc). One exception the enterprise front is on the ops side of things (infrastructure, etc). Big game changers like OpenStack are making quick inroads; OpenStack is a lot of python. Because of that, if enterprise is your aim, then it's certainly hard to make the argument that python is a "worthless endeavor".
&gt; De-serialization's #1 rule has ALWAYS been don't de-serialize data from an un-known source (and in this case I'm making an addendum - a terribly guarded source). Since it's a signed cookie, deserialization only happens after the signature has been validated. From the perspective of the framework developers, that should be reasonably secure, but it's up to the application developers and managers to protect the key. The problem is that the people whose job it is to protect and generate strong keys don't know the consequences of doing so poorly. Is hard to fault the framework developers, who build features they couldn't have had without assuming the key is well guarded. It's also hard to blame application developers who are using a framework because they don't want to worry about the inner workings of features like session management. Ultimately application developers and deployment managers need to protect the key or not use the features that rely on its secrecy. But there is done responsibility for the framework developer to make sure the need for that protection is understood. &gt; JSON works just as well Not if the objects you want to serialize are not JSON serializable. Pickle lets devs store pretty arbitrary objects without a second thought. JSON adds lots of limitations, and more complex objects will need ways to convert to and from JSON serializable formats. Maybe the responsible thing from the framework perspective would be to limit sessions to serializable objects, but I think there's room for debate. 
Why put a message in the cookie? In a HTTP 200 response, they could just put it into the HTML or inline Javascript. To temporarily store the message during a HTTP 30x response, the message would get sent back and forth between client and server three times: 301 response that sets the cookie, then the request for the new URI will upload the cookie content again to the server, then the 200 response will send the cookie content again. Not very economical. Storing these "flash" messages on the server in a session variable is better, imho. For me, I just use it as some sort of ground rule: "cookie only session id".
I've used python a lot din the workplace. It's an all-around good tool, although in some areas (like execution speed) it can be beat. It was also recently named the language of the decade from looking at how it has completely swapped places with perl and overtaken several other popular languages. C#, java, and C++ are still very widely used in the industry though, but no programmer can get by with just one language, so learn them all! 
Not to mention compile times.
I believe it's reasonable for framework developers to protect other developers from their own stupidity or carelessness if possible. Framework developers are usually a lot more experienced and knowledgeable, whereas any beginner web developer might not yet understand the security issues, and even professionals might accidentally commit settings.py into version control, and forget about it when later making the project public. Frameworks have features to make accidental SQL and javascript injection less likely for the same reason. For the pickle security issue, a good choice would be to use pickle for database/file-storage sessions (which most people use), and JSON for cookie-storage session data. If you really want pickles in cookies, there could be a settings option with a very scary name to re-enable it.
I'm re-inventing myself with python. Coming from a web dev perspective, php &amp; MySQL can only go but so far. I left php because of no standard in writing code, there really isn't a sense of community (at least where I live) and everyone wants to use a cms for everything. I worked for a web agency and found myself doing more ops stuff and python scratched my itch. Then I started looking into switching databases to Postgres because I was told that it was MySQL on steroids (which is true). You can even write code for Postgres using python. I tried the django route but it felt like an all or nothing kind of deal especially with the orm. now i just use flask because of what I've learned from django. Python is everywhere (ops, development, even in the tools that I use) and has batteries built in. Me personally, when I got burnt out on writing code, Python was a breath of fresh air. To me, (I can only speak for my immediate surroundings and personal experience) its either lack of education, or lack of change (financial, business, marketing hype, legacy code, etc.) as to why people don't use this awesome language especially for internal tooling if they want to get stuff done.
Then check for system too. The idea is to prevent and make it difficult for this kind of default cookie configuration and allowing the unpickling process to execute code. As your cookie gets a bit more complicated it becomes harder to unpickle it to run the shell code, as such, checking default formats should at the very least provide some base security. I have a better idea, perhaps have some sort of default config option passed, that uses the new JSON packing of the cookie information in your Flask Configs, Werkzeug should see if that variable is there, if it is, JSON packing/unpacking. If not, backwards-compatibility-insecure-mode, use pickling again. (but again default-configurers will be insecure). app = Flask(app_name) app.enableJSONcookies() #disables pickling
This is why I pretty much always use [beaker](http://beaker.readthedocs.org/en/latest/)'s Session class - cookie just contains a randomly generated string, pickled session is kept strictly server-side. Sometimes I go further, and store the IP + UA in the session, and invalid it if those don't match up. Only catch with such a scheme is that it doesn't work for a large number of transient long-lived sessions which you don't want to waste fs/db space on. And that beaker doesn't have a "purge old sessions" tool (been meaning to write one myself sometime)
This is both easy and cool!
I generally agree that framework developers can protect application developers from their own stupidity. There are lots of cases where this is feasible without sacrificing functionality. But generally things like switching session backends from database/file-storage to cookie storage are configuration options, and it could be really confusing to see applications start breaking when someone flips a switch in the settings file to move from database session storage to cookie storage. I'd say that cookie-storage backends should have the same functionality as any other backend to avoid breaking expectations, but I'd agree that it should be in a module called something like `session_backends.I_SWEAR_I_WILL_KEEP_MY_SECRET_KEY_SECURE.cookie_backend`.
My guess is that most Python 2 users are familiar with and already use virtualenv and pip. Upon installing Python 3 to give it a go, new users find: * it doesn't come with pip * when they go to install pip, they find it doesn't come with Distribute * after they install Distribute and pip, and then use the supplied pyvenv, they find that it fails to pull in pip into the environment This makes pyvenv look either broken or useless, and drives away the prospective user (since they've just done some yak shaving and it still doesn't work right). Languages gain adoption not only because they're good, but because they are also useful and convenient. My point about spurring Python 3 adoption is that it could be made much more useful and convenient if it came with Distribute and pip right OOTB (and, of course, if pyvenv included pip in the env's it makes). 
OK, but python2 does not come with pip, and much less virtualenv. Yet it's popular. You're agitating the wrong needle from the haystack.
&gt; OK, but python2 does not come with pip, and much less virtualenv. Yet it's popular. Python 2 has been around long enough that I can just sudo apt-get install python-virtualenv python-pip and I'm good to go (on Debian-based systems, that pulls in Distribute, though it appears to come with python-setuptools). If you want users to move to Python 3, it needs to be made easy to do so. When I'm required to install Distribute and pip, and then the built-in pyvenv won't use it, it feels like Python 3 is fighting me. That turns away users. &gt; You're agitating the wrong needle from the haystack. Don't know what you mean by that. 
And windows retains a whole slew of bugs and is a bloated mess of legacy code. The compiler will complain about deprecated functions but since they weren't broken or wrong to begin with they stay in. Let's take something from python, say input(). Can you honestly say the 2.x input() is implemented correctly. Evaluating the user input? When was that ever a good idea?
Just to make sure I understand: you copy the data into whatever layout the C library expects and pass the data pointer into C? And if you want to write your own C code which uses NumPy array descriptors, you'll then you should also deal manually with the shape and strides tuples...right?
I haven't tried installing Python 3 via apt. Mostly because: * I wouldn't want it to clash in any way with the system Python (2.x), * I don't need a Python 3 on my system; having it in my home directory is fine, and * I wanted to try out the latest and greatest (3.3.0). apt-getting python3 installs 3.2. I'm satisfied to use my *system* Python 2.x for projects, since I can always install any needed dependencies into their own env (so, I don't really have a need to build my own 2.x).
A competitor to https://github.com/atizo/PyTagCloud Though I think the winner is this one: https://github.com/jasondavies/d3-cloud
Has anyone tried to use the exploit on the wargame vulnerable site? It [was a fun proof of concept](http://i.imgur.com/zk1tGMk.png), I was also able to create the same attack on windows hosting Flask. I wasn't able to do it on a Flask application that uses Flask-login, high security sessions, I'm not sure what's different there, I guess the format of the cookies.
Damnit D3, stop being better at everything than what's available in python.
First, I wonder how much objective evidence you expect to get from /r/Python? Kind of like going to /r/Christianity, and asking "Just how likely is this whole God thing, anyway?". Take the info you get here with a grain of salt, okay? From my point of view, I find the ease of Python development to be a two-edged sword. On the one hand, it's GREAT to be able to produce solutions to complex problems quickly and easily. On the other hand, I wouldn't tend to hire someone with only Python experience to fill a position in another language, simply because other languages are much more frustrating. (That's not such a big deal, because hardly anybody hires someone with only language B experience for a language A job. If you want to get hired as a C++ guy, then do lots and lots of C++, not Ruby, not Python, not Fortran, etc.) As usual, YMMV.
I read that last night after following the link to the ml flowchart/cheatsheet. Seriously cool, but I still don't know what more than half of it means. But it seems attainable. There the source, and enough vocabulary words that I can research, and thankfully they are presented together. Very cool way to learn some new stuff.
Debian has taken care to avoid it clashing with Python 2. That's part of the reason to install it through apt - you can be sure that the packager will have thought about things like that. Debian treats Python 3 as an entirely separate stack to Python 2. So you invoke it with `python3`, its libraries are kept in separate folders, and it has separate packages (with the `python3-` prefix). There's no interference. I have Python 2.6, 2.7, 3.2 and 3.3 on my Ubuntu system.
Just apply around, put your resume on Indeed, talk to people, etc. 
The pickle module has a big fat warning on it's documentation: &gt;Warning: The pickle module is not intended to be secure against erroneous or maliciously constructed data. Never unpickle data received from an untrusted or unauthenticated source. This is because the pickle module hasn't been code reviewed for security vulnerabilities and it's trivially easy to turn an unsecured input into pickle or cPickle into a remote code execution vulnerability. The moment I saw "serialization_method = pickle" I knew exactly what was going to happen. Even if you can secure your cookies properly, it's like sanitizing database inputs, it's just philosophically *wrong*. Pickle lets you call arbitrary Python code on the unpickling side; you simply shouldn't have that anywhere near a user-controlled input.
Great guide! So far what I've noticed is that print ("hello world", end="") does not work, but rather "print "hello world"," does the job just fine. I'm using python 2.7.3 and don't recall any step which mentioned what version of python I need to be using.
Why did he use a countvectoriser when the same thing could have been trivially implemented with a dictionary? Cool project though.
Basically, yes.
I have recently been working through this source. It has taught me a ton about everything from @property to yield and generators. I highly recommend it!
It is in the "before you begin" section.
Oh, I'll have to visit that. I am doing the guide mainly for the exercises and to brush up on object oriented programming. I'm familiar with php, c#, and C++ and my goal is to create my own tetris program. Thank you for this guide!
Agreed. There are large enterprises that value all languages equally. For instance, it looks like Zappos is hiring for a few python centric positions (probably for some cloud work, I'd guess). http://about.zappos.com/jobs/jobs-zappos-family/search-open-positions See "Systems Automation Engineer" 
Ok, after visiting this section, I realized that I did read it before. Or I began to, but felt as if it was trying to sell me on to the idea of learning to code, when really I already have motivation for that. perhaps putting an index for this section, or listing the requirements in a small box at the top, might help other people from missing it too. I usually pay attention to versions, but I was excited to start and it just slipped my mind.
That doesn't make sense. What's the figurative meaning of worthless? Starting a career in VB6 now wouldn't make sense. When I did it there were tons of jobs. But more importantly - there are these people who have a very narrow perception of what is going on in the software world and if people don't match that perception they look down on it. Python is used heavily in a wide range of situations and literally or figuratively there is no harm in learning it.
so there are two ways, depending what your C library expects. With numpy, you typically don't copy the numpy array at all (it's layout is defined by strides), but depending on the C lib requirements you might need to copy all the metadata, really depends on API. If you write it using cffi, you will call BLAS directly and not call python from C via the C API. If you want to however reuse the current code, you need to provide an API for dealing with pypy's metadata (and that can be nasty). There are various ways and in general calling BLAS via cffi (directly, not numpy BLAS) is a preferred way, however you might not always have the luxury of doing so.
I wouldn't call that a best-style example in all cases, though! I think there are some very ugly pieces of code in there - which is understandable and acceptable for the standard library, because it exists exactly because you should not need to write ugly code.
This is coming from someone with only a little nginx experience and general HTTP knowledge: Is apache's benchmark not reusing connections? If it's throwing away SSL handshakes that would explain the performance drop as the SSL handshake takes several round trips must be repeated if the connections are closed.
Check this out.. it covers apache and nginx config: http://unhandledexpression.com/2013/01/25/5-easy-tips-to-accelerate-ssl/ 
I'm puzzled: do you expect SSL to come for free?
Not exactly. 'Unencrypted' is not the same as 'insecure'. They talk about the fact that the data is visible in the cookie. They don't explicitly mention that they potentially execute the contents of that cookie. It's also worth noting that there is no secure alternative available in Pyramid, so it's not fair to blame people for using the one thing that the framework provides. Thankfully it should be easy to fix by passing new versions of `signed_serialize` and `signed_deserialize` in.
You might be right, but all I was saying is that I don't see people storing it in the session - and I suspect there may be a reason why. Possibly because flash messages often need to exist when there is no session yet, as sessions are often keyed on user IDs.
Fixed. Thanks for the tip. I should probably take up a best practices book.
Which site is that? I volunteered to give a presentation to our local Python user's group on security gotchas for web apps, and I want to do it using an app or two which is deliberately broken in the various ways that are all too common. I could write such an app myself, but it might be easier to use one (or several?) which already exist.
Alright, thank you!
[It's easy in most languages.](https://github.com/AeroNotix/cutils/blob/master/datastructures/bloomfilter.c)
notifications aren't showing up :/ Tried playing with the python code but couldn't get it working.
Bloom filter is useful because it's fast (often used to check if data exists on disk before disk-read) and has a very small memory footprint. And in my opinion this implementation is neither. Having an array of 0s and 1s as seperate integers as a vector leaves much to be desired from memory, here it is ~~O(m)~~ O(m*sizeof(int)) whereas proper implementation has ~~O(log(m))~~ O(m/8). Moreover there is quite a big slowdown due to array access and disability to use some fancier operations such as binary ANDing two bloom filters which would result in their cross-section. (O(m) instead of O(1)) While the hash function surprised me and I found it neat, sha256 is not a good idea here, it was designed to be a crypto function, and those are specifically designed to be slow to make decrypting passwords harder. I suggest using something more speedy, or implementing your own hash function. Disclaimer: I come from C-family languages and am a bit paranoid about speed, this implementation may be sufficient to your needs.
this is a demonstration of how a Bloom Filter works, but a lousy implementation of Bloom filter.
Hello ritave72, thanks for your comment. The code in the post is not supposed to be suitable for production. I made it in order to show how a Bloom Filter works and to study its behavior. The implementation is naive on purpose.
It's not even close to the same mechanism, and it feels like an artificial example, but all I can think of right now is some sort of bounded cache, like a queue that holds the *n* most recently added items.
Like a hash where you'd allow collisions? 
Hm... You're right about memory, got a bit carried away, sorry about that. But I don't agree with you on the hash function part. According to [this](http://www.cryptopp.com/benchmarks.html), sha256 is incredibly slow compared to some other crypto functions. Nowadays we can send data through network faster then sha256 finishes.
And that purpose, it serves quite well. But please, put a notice somewhere, some people could use it in real life situation :)
Hmm, that's strange. Could you please check in **System Preferences -&gt; Notifications** and make sure that the alert style is set to **Banners**? Other problems I can think of from the top of my head: - There's some problem with your Python installation. **python --version** should return **Python 2.7.2** - You must be on Mountain Lion for notifications to show up at all ;)
You need pyobjc and osX 10.8 for NSUserNotification 
Most hashes allow collisions.
I once implemented a rather more performant bloom filter in about the same number of lines of code as the one in this article in python, using: * `bitarray` module which provides list-like access to a bit array implemented in C (and yes, it packs the bits in using sub-field indexing, all done transparently in the library - you will need a 64bit python for large filters) * A sloppily ported `MurmurHash3` to allow for fast string hashing with good (non-crypto) hashing properties. * Two constructors: one like the one here, and one where you specified an 'expected false positive rate' and a 'maximum expected number of elements'. I then performed the calculations shown in this article to derive the 'm' and 'k' terms. It takes about an afternoon and will outperform this code 1000 to 1 (and probably more like 1,000,000 to 1 when it comes to memory) - no offense to the article's writer, I'm just saying, much better can be done with relatively little effort. I definitely recommend it as a cool project for anyone looking for an 'intermediate' learning python lesson - it doesn't require any (relatively) advanced things like closures or generators. The hardest part will be getting `bitarray` (it is not in the standard library), assuming you use python's built-in `hash` function. If you decide to use a different hash function (for the love of god, don't use MD5/SHA/any crypto function - it will be slow as heck) then you may run in to some difficulties as they are generally best left in C or C++ - if it's your first time including C modules in python it might take an afternoon to learn how to do that. Ultimately, though, bloom filters are a perfect candidate for being programmed closer 'to the metal' due to the extremely high performance gains that can be had with relatively little effort when you can do some optimizations in that space. One project I want to tackle when I have a free week or two (programming vacation!) is writing a bloom filter in CUDA to take advantage of GPUs which are PERFECT for bloom filters: blisteringly fast bit array manipulation across hundreds of shared cores, with a dedicated pipeline that (I think) can be set up for parallel almost-instantaneous string hashing. I strongly suspect that a CUDA implementation could implement an arbitrarily large (limited by GPU memory only) bloom filter that appears to the CPU to be just 1 or 2 cycles to query/insert.
There was [an article (link)](http://www.somethingsimilar.com/2012/05/21/the-opposite-of-a-bloom-filter/) about this a while back but the short answer is 'kind of' with the slightly less short answer being: While you can mimick a bloom filter's interface (set and query operations) with an false negative chance, doing so loses most of the benefits that make bloom filters desirable; you're usually better off just using a hash map. Implementations of 'inverse bloom filters' pretty quickly just start to look like cacheing systems.
True, but I think it's *particularly* easy in C, which is why I think they make a great project for people learning C!
The algorithm's the same no matter what language you're using? I'm not seeing anything where this would be easier with C.
The algorithm is, in my experience, easier to implement in C. Same algorithm, less code complexity. That's not an uncommon circumstance, but it's somewhat uncommon for it to be in C's favor. For instance, manipulating bit arrays is much easier in C. Writing a fast string hashing function is much easier in C. Performing operations on bloom filters (such as combining two filters or extending a filter - doable but nontrivial) is easier in C. Bloom filters are all about array manipulation, and to me, that means "C".
Check out PEP 8 and 20, the style guide and Zen of Python (my quote comes from this source) and you'll be just fine.
No, the documentation does not tell you not to use it. It says *"You should not use it when you keep sensitive information in the session object"*, which is quite a different situation. Many people do not keep sensitive information in there and will therefore not see any good reason why they shouldn't use this implementation. The code that is in there is (relatively) insecure and needs fixing or removing, not justifying with hand-waving about how you shouldn't really use it. Luckily it's fairly trivial to fix. (And hopefully the *requirement* that implementations of ISession are pickleable is also removed.) &gt; It is up to the developer to use Beaker with SQLAlchemy for example I suppose they have to know not to use Beaker's CookieSession as well, as that is unpickling data from a cookie too.
You are playing a cat and mouse game with hackers in which the odds are against you, every single time. Best to do it right than to employ numerous defenses of which are trivially bypassed.
Messages are often stored in session cookies in order to avoid a database hit. Deserializing a cookie is faster (even when encrypted) than looking it up in the database.
If anyone is looking for a production-level implementation of a bloom filter, check out [dablooms by bitly](https://github.com/bitly/dablooms). It's a C library with Python bindings, and has [one of the more famous pull requests on Github](https://github.com/bitly/dablooms/pull/19).
It's at the end of the blog post
You might want to look at the bloom filter implementation used in https://github.com/bup/bup -- It is a python C module and used in production right now today.
That's amazing!
My words fail to describe my level of surprise when I encountered my name in the middle of this list :) That said, an excellent compendium! I have a terrible urge to use as many of these as possible!
also check out http://www.crummy.com/software/BeautifulSoup/
Maybe my questions were not simple enough for it - but this is exciting work indeed.
Indeed. Sadly, it's only focused on that one topic and not what I was looking for, which was an app with several different security issues.
I am not a great Python writer, but I think PEP would have a field day with some of that notation. ;)
Brilliant idea. Will the talks be available online later for those of us living in the wrong hemisphere?
It's a good thing they provided plenty of example queries, because virtually none of my own produced a sparql query. Some additional output to explain why no sparql query was produced would also be helpful.
Cool concept, but none of my questions produced a query. I asked things like average male height in US and how long is "Of Mice and Men".
Yep.
We hadn't planned on it :) A talk about DITA might be interesting though.
Thanks for pointing this out! I spent a long time looking for something like this and wrote PyKeyboard when I couldn't find it (or an acceptable alternative). 
More relevant project is [Sikuli](http://sikuli.org)
It cannot be trivially bypassed, the whole exploit relies on execution of code. So make sure you're not passing any execute calls. And as I said, if you even bothered reading what I wrote, this is just base security. It's not meant to be full security, because then you would HAVE to break backwards-compatibility to be 100% safe from this. My goal was to provide a temporary solution until you can break backwards compatibility. The solution I proposed is sound. You don't have to dismiss it because "well one day someone will break it." That can be said about ANY security enhancement. Further I gave two ideas, the other idea is an actual full security that could work very well against such an exploitation. And yet you dismissed that too and downvoted me. Well propose a solution then instead of being the neighborhood critic. Let's see how your ideas hold up.
People use "worthless" to mean "not worthwhile, technically it does have some worth, I just think that worth is very small". That's clearly what he meant. &gt; there are these people who have a very narrow perception of what is going on in the software world and if people don't match that perception they look down on it True, but there are also people that know that some programming languages teach you bad habits that are hard to break and lead to careers with dead ends, so they discourage people from going down those dead end paths. It is frequently hard to tell the difference. Having to unlearn a huge amount of VB related shit when learning your second language is difficult to do and even harder to do completely, you will probably end up thinking in VB and translating in your head for quite a while. This is the reason that junior programmers with bad languages as their first languages have a demerit against them when someone is hiring. It might not be a fair heuristic but it's one people use because it's generally true. &gt; there is no harm in learning it &gt; I don't think learning any language is worthless. Of course not, but in the real world you are taking time away from doing something else. There is always opportunity cost, and not taking that into account means you *will* arrive at the wrong conclusion. Don't think about "harm" or "not worthless" think about "what's the best use of my time right now". 
There are such sites, like web goat or whatever. Hackthissite etc., I mean not all of them are perfect tho.
Sikuli is an interesting project. We use it here and there at work. I just wish the editor was more stable. We're considering a fork at some point, no idea if it'll actually happen though. Also wish it wasn't Jython.
That new sitemap is helpful. Thanks.
It's Jython because it uses the [Java Robot](http://docs.oracle.com/javase/1.4.2/docs/api/java/awt/Robot.html) class to do screenshots. When I used it at my last job for GUI Automation testing it didn't work on headless VM's so we stopped using it. 
&gt; While the hash function surprised me and I found it neat, sha256 is not a good idea here, it was designed to be a crypto function, and those are specifically designed to be slow to make decrypting passwords harder. I'm pretty sure this is wrong. SHA was designed for collision resistance for things like message signing. I usually hear cryptographers advise to use bcrypt because it was designed to be show for password storage, while SHA was designed for speed. For something like a bloom filter where there generally isn't concern for deliberately crafted collisions, there are much faster options than SHA. SHA isn't slower because it was designed to be slow, just because the problem it solves has more important constraints than speed.
Thanks! Web goat uses J2EE and Hackthissite doesn't use Python. I'm looking for a Python app. I'll keep on looking then.
Interesting, but in the event that the table doesn't have |'s on the left of right, you're going to discard data. To protect against that, I'd write something like: return [piece.strip() for piece in line.strip('|').split('|')]
Is that all it needs java for? Things like PIL can handle screenshots well enough. Any idea why the developers didn't go full python or whatever? What kind of headless vms were you testing on? It took us a while to realize that our tests were running in the services session on Windows when using vmware tools. The services session uses a different theme than your standard user session. Not sure if that's the case for your setup, but there's a command you can use to see the services session. Out of curiosity, did you find something to take Sikuli's place?
The Robot class handles the mouse movements too, I'm not sure why the developers didn't go full python. We were using it on VMWare Windows vm's. That's true I worked out the tests were running on the service (or was it console?) session but that didn't have any effect. I wrote a basic Jython test script to try the [Robot.createScreenCapture](http://docs.oracle.com/javase/1.4.2/docs/api/java/awt/Robot.html#createScreenCapture(java.awt.Rectangle)) which I ran both on a headless session (i.e not via a Remote Desktop session). The screenshot it took was all black . When run via a Remote Desktop session it worked. This was at my previous job a year ago now. We didn't find a replacement. 
License?
Good tips. I disagree a tad with the "100% statement coverage shouldn't really be a goal" bit, particularly when the project is worked on by teams that have folks of varying skill levels (small teams or large teams). In such cases, if you make 100% statement coverage a precondition to shipping, you often get the following benefits: * You remove the need for judgment about what is important to test and what isn't. Often junior developers don't have the experience to make this judgment correctly. * By making the goal objective, rather than subjective, you remove a lot of interpersonal friction that can result from guidelines applied inconsistently. * Many times writing tests is an excuse to actually read the code you wrote. And less code is almost always better. When you know you're going to need to test all the code you write, you tend to write less of it. This is true both of very experienced programmers and less experienced ones. The goal doesn't really need to be 100% coverage here, but some large percentage is usually required, so you don't let yourself get away with rationalizing that you don't need to test some bit of code because it's really hard to do so. Code that is hard to test is often the code that needs testing the most, or at least needs refactoring the most. Of course all rules are malleable given some set of circumstances. It's often better to ship something flawed today than it is to ship something solid tomorrow.
Cool, I'll def read this later
cool
Am I just missing the price on that page? Or is it not yet determined?
lies, damn lies and statistics -mark twain
The bitarray source code contains a bloom filter in one of the [examples](https://github.com/ilanschnell/bitarray/blob/master/examples/bloom.py).
You are welcome, and congrats on PyKeyboard! Truth be told, I was somewhat reticent to mention AutoPy, out of concern that I might step on someone's toes. Thanks for the original post and content!
Especially in the shell, where one mistake means there's no going back.
This is a pretty slick piece of software. The ide can be a bit wonky at times, but it's all around a very simple tool to use.
Great! Like it a lot :)
I once used this to make a bot that would automatically redeem Borderlands 2 golden keys. It worked pretty well, but I lost interest in the project before fully automating things like scraping the Gearbox twitter feed.
You're right, thanks. I will use strip for pipes instead slices. 
I will package this helper as python module. Here is my repository: https://github.com/fatiherikli/tabularize.py 
Not free, but I would expect it to be almost unnoticeable. In 2010, a Google engineer [reported that SSL adds an extra 1% in CPU load and 2% in network traffic](http://www.imperialviolet.org/2010/06/25/overclocking-ssl.html) for them, after which they turned on SSL by default on most Google sites. However, SSL does require a bit of configuration to avoid latency when starting a new connection, and to avoid starting a new connection for each URL.
The nicest part is that it has discrete java library under the hood.
The Python jobs board is regularly updated: http://www.python.org/community/jobs/ Here in London Python is a hot skill (the recruiters seem to have switched from Ruby events to the Python events). It is used by many startups for web-dev and dev-ops, along with science (I'm a data science guy). For Data Science it is well used and well represented at the BigDataLondon (1,200 people on the mail list, about 1/3 seem seem to know/use Python, along with R, Matlab and Java). Last year at PyCon 2012 US the supporters booth room was huge and packed (I remember that GitHub, Dropbox, Google etc were all hiring - hell, everyone was hiring IIRC). I recommend people learn Python because it has so many applications and has been growing in popularity for years.
Andreas (the author) is a scikit-learn guy but depending on scikit-learn just for this is a bit of a pain.
Worth pointing out that development appears to stalled (see https://answers.launchpad.net/sikuli/+faq/2106) and my personal experience is that the CV module often fails to detect recurring images reliably. I think there was a another project that did similar work and was demo'd changing the UI of Photoshop through a remote desktop client - but I can't find it now. Edit: Alternatives - Windows http://www.getautoma.com/; Linux https://wiki.ubuntu.com/Xpresser Xpresser looks rather good
Thank you for your valuable feedback. What you see in the web page is just an illustration of the capabilities of Quepy, an example of how one can use Quepy. That is why it doesn't have a big coverage of question types or the ontology of the dbpedia. If no SPARQL query was generated, it was probably because this kind of question was not included with the sample in the demo. If no answer could be find in the dbpedia, it was probably because the interface to the relevant portion of the ontology has not been developed for this demo. We hope this does not discourage you, on the contrary, we hope this is an encouragement for you to contribute to the development of this demo or to develop your own!
Maybe you should try to make questions similar to the ones in the examples provided. Please, try again, and let us know the results,. 
yeah I go back and forth on the 100% coverage there's a point of diminishing returns somewhere and it varies by project. I do feel fortunate enough though that the culture here is test driven. lack of tests for a new feature indicates risk which goes into the decision to release or not. 
I'm sorry, but I didn't downvote you. In most developer's attempt to implement sandboxes and/or blacklist input validation filters, there's usually a 99.9% chance a way to bypass them within the first couple minutes of opening themselves to attack. The problem with your approach is having to maintain a blacklist filter while an attacker is always one step ahead of you. You just witnessed this game play out in the comments before these, and that's just from casual conversation. I'm not trying to dissuade you in your attempts, but the better strategy is to implement the right solution the first time. Band-aid solutions to security issues like these typically linger in production for wayyy past their expiration period, meanwhile your application is more and more at risk.
You may also want to have a look at https://github.com/kennethreitz/tablib, though it could be overkill in most situations.
The latest beta (Mac only) was released under [a week ago](https://github.com/RaiMan/Sikuli12.11), but the developer agrees that Sikuli is no longer his priority.
I LIKE
&gt;If someone makes something interesting in their own time, you don't dis them. This is the best comment I've seen on reddit this week. I've been guilty of this in the past too, and you're totally right. When someone is trying to help, and is volunteering, you don't try to shame them. Even if you don't see eye to eye, you try to work with them, and share ideas, and "compete" in that certain way that makes both your work better. There's room enough for their project too.
How about Robot Framework (http://code.google.com/p/robotframework/)? I tried it and have mixed filing about it.
I haven't quite wrapped my head around funcargs. I definitely want to write about them, but I have to grok them first.
I commented on SO: Can you post a benchmark for nginx with SSL disabled? Can you also confirm that you're running 2 worker processes per cpu-core? What OS/arch are you running on?
https://wiki.ubuntu.com/Xpresser looks quite good
Thanks for the link!
Sure.
There's no need to read the whole thing in memory like that; what if the file was too large to fit? You should write this so that it returns a generator that yields a line at a time as needed. 
So nose is basically py.test without the good parts?
My friend used this to automate logging in to diablo3, i think during the beta but maybe it was post-launch. Anyways more than half the time you tried to login it would fail so he'd just run this script until he got in.
Fork us! (No dinner and a movie required..) [github](https://github.com/tendenci)
Forgot to mention: It's built on Python / Django.
http://en.wikipedia.org/wiki/PySide is pretty good for making UIs, and works on all popular operating systems. There is some GUI designer thing available, but I've never used it: laying out the interface in code is easy enough.
there's a secure erase function in most unixes, called (strangely enough) shred. a lot of linux(es) have this command, and so do many bsd variants. what i do; when i want to securely shred a single file is to open it, and overwrite all the data with random numbers, THEN erase it - i beleive that's what "shred" does. http://unixhelp.ed.ac.uk/CGI/man-cgi?shred+1
When I say Secure Erase, I am referencing ATA's Secure Erase https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase It is an on-board command the hard drive runs and overwrites itself w/ 0s. It can do 1TB drive in ~90 minutes. You use hdparm to execute it in linux. Like I said, I have the bash script that does everything, just need a simple GUI that will execute the bash scripts. I'm thinking of using bash's dialog (ncurses) anyway, it is pretty ugly but it might get the job done. I am basically rewriting all of this stuff from scratch though because we are now implementing a server that will store information about each drive destruction process so that we can generate reports from it in the future and hopefully automate the certificate creation process.
We are a NAID certificed company and use it and Secure Erase is supported by NIST (NIST Special Publication 800-88)... As you may know then, HIPPA or Sarbanes-Oxley require third-party verification that data is destroyed. So we are that third party. We destroy hundreds of drives a day and Secure Erase has reduced the time a lot. NIST actually says that a QC process is not required, however, we have found some flaws in the Secure Erase implementation. We will be releasing a white paper and some magazine articles next month around the time of the national NAID conference, so I have to be cautious...
i'd be interested in seeing the results. thanks for this.
That makes no sense at all. He should do this ;) if x==7: #{ print "something" #}
I use the freshen plugin to do BDD style tests within nose. Great stuff!
haha, don't give him ideas!
It would bother me. I have ran into too many people that are unwilling to accept change and adapt to something different. On the other hand, we can't force everyone to comply and we have to deal with other peoples shortcomings. But, feel free to do whatever you can within reason, while avoiding creating conflict.
this might have some info in it. http://pythontesting.net/framework/pytest-introduction/
Thank you greatly for the link, but not quite what I was looking for. I wanted to see what the response from halst would be. Is there an informed opinion on the technology in question, or is it just a passion for py.test which created the initial response? At the end of the day, py.test is a great testing framework, but what specific task does it do better than nose or any other python testing framework? I have just found that nose and selenium, paired with jenkins for continuous integration has been the winning combination for a while now. If anyone has a better method or a new paradigm on testing they care to share, please do.
halst was probably doing it for upvotes. :) I've used both. And currently am using py.test at work. we used to use nose. but I think the original reason I switched was for 2 or 3 reasons. #1: more flexibility with initialization. for appengines sdk you need to bootstrap somethings when you start the test suite, and others like db creation fit nicely in setUp/tearDown. it's a specialized case for us. #2: at the time I thought that running tests in parallel was attractive, but I never got around to actually trying it out. #3: at the time it seemed like it would be easier to extend py.test than to learn to write nose extensions. That was just my feeling at the time, but it ended up all the functionality I needed fit in the setUp/tearDown. it also feels "snappier" but that could be my imagination. I'm not asserting that one is better than the other. I have bigger fish to fry than throwing an enthusiastic endorsement behind my favorite test runner. Hell, I don't even have a favorite. :P 
 elif activegame==1: activegame = 0 self.startbutton.SetLabel('Start Game') self.gametx.SetLabel('CPU WINS') layout = [0,0,0,0,0,0,0,0,0] cwin = cwin + 1 self.cwinco.SetLabel('%s'%cwin) def playerturn(self,event): global layout,turn,gmode playermove = event.GetEventObject() playermove.Disable() print layout if playermove == self.button0: self.pos0.SetLabel('O') layout[0] = 2 turn = 1 elif playermove == self.button1: self.pos1.SetLabel('O') layout[1] = 2 turn = 1 elif playermove == self.button2: self.pos2.SetLabel('O') layout[2] = 2 turn = 1 elif playermove == self.button3: self.pos3.SetLabel('O') layout[3] = 2 turn = 1 elif playermove == self.button4: self.pos4.SetLabel('O') layout[4] = 2 turn = 1 elif playermove == self.button5: self.pos5.SetLabel('O') layout[5] = 2 turn = 1 elif playermove == self.button6: self.pos6.SetLabel('O') layout[6] = 2 turn = 1 elif playermove == self.button7: self.pos7.SetLabel('O') layout[7] = 2 turn = 1 elif playermove == self.button8: self.pos8.SetLabel('O') layout[8] = 2 turn = 1 while turn ==1 and gmode ==1: if layout[1] ==2 or layout[3]==2 and layout[4]==0: self.pos4.SetLabel('X') layout[4] = 1 self.button4.Disable() turn = 2 elif layout[6] == 2 and layout[0] ==2 and layout[3] == 0: self.pos3.SetLabel('X') layout[3] = 1 self.button3.Disable() turn = 2 elif layout[0] == 2 and layout[2] ==2 and layout[1] == 0: self.pos1.SetLabel('X') layout[1] = 1 self.button1.Disable() turn = 2 elif layout[0] == 2 and layout[8] ==2 and layout[4] == 0: self.pos4.SetLabel('X') layout[4] = 1 self.button4.Disable() turn = 2 elif layout[2] == 2 and layout[8] ==2 and layout[5] == 0: self.pos5.SetLabel('X') layout[5] = 1 self.button5.Disable() turn = 2 elif layout[8] == 2 and layout[6] ==2 and layout[7] == 0: self.pos7.SetLabel('X') layout[7] = 1 self.button7.Disable() turn = 2 elif layout[2] == 2 and layout[6] ==2 and layout[4] == 0: self.pos4.SetLabel('X') layout[4] = 1 self.button4.Disable() turn = 2 elif layout[1] == 2 and layout[7] ==2 and layout[4] == 0: self.pos4.SetLabel('X') layout[4] = 1 self.button4.Disable() turn = 2 elif layout[3] == 2 and layout[5] ==2 and layout[4] == 0: self.pos4.SetLabel('X') layout[4] = 1 self.button4.Disable() turn = 2 elif layout[0] == 2 and layout[1] ==2 and layout[2] == 0: self.pos2.SetLabel('X') layout[2] = 1 self.button2.Disable() turn = 2 elif layout[1] == 2 and layout[2] ==2 and layout[0] == 0: self.pos0.SetLabel('X') layout[0] = 1 self.button0.Disable() turn = 2 elif layout[3] == 2 and layout[4] ==2 and layout[5] == 0: self.pos5.SetLabel('X') layout[5] = 1 self.button5.Disable() turn = 2 elif layout[5] == 2 and layout[4] ==2 and layout[3] == 0: self.pos3.SetLabel('X') layout[3] = 1 self.button3.Disable() turn = 2 elif layout[6] == 2 and layout[7] ==2 and layout[8] == 0: self.pos8.SetLabel('X') layout[8] = 1 self.button8.Disable() turn = 2 elif layout[8] == 2 and layout[7] ==2 and layout[6] == 0: self.pos6.SetLabel('X') layout[6] = 1 self.button6.Disable() turn = 2 elif layout[0] == 2 and layout[3] ==2 and layout[6] == 0: self.pos6.SetLabel('X') layout[6] = 1 self.button6.Disable() turn = 2 elif layout[6] == 2 and layout[3] ==2 and layout[0] == 0: self.pos0.SetLabel('X') layout[0] = 1 self.button0.Disable() turn = 2 elif layout[1] == 2 and layout[4] ==2 and layout[7] == 0: self.pos7.SetLabel('X') layout[7] = 1 self.button7.Disable() turn = 2 elif layout[7] == 2 and layout[4] ==2 and layout[1] == 0: self.pos1.SetLabel('X') layout[1] = 1 self.button1.Disable() turn = 2 elif layout[2] == 2 and layout[5] ==2 and layout[8] == 0: self.pos8.SetLabel('X') layout[8] = 1 self.button8.Disable() turn = 2 elif layout[8] == 2 and layout[5] ==2 and layout[2] == 0: self.pos2.SetLabel('X') layout[2] = 1 self.button2.Disable() turn = 2 elif layout[6] == 1 and layout[0] ==1 and layout[3] == 0: self.pos3.SetLabel('X') layout[3] = 1 self.button3.Disable() turn = 2 elif layout[0] == 1 and layout[2] ==1 and layout[1] == 0: self.pos1.SetLabel('X') layout[1] = 1 self.button1.Disable() turn = 2 elif layout[0] == 1 and layout[8] ==1 and layout[4] == 0: self.pos4.SetLabel('X') layout[4] = 1 self.button4.Disable() turn = 2 elif layout[2] == 1 and layout[8] ==1 and layout[5] == 0: self.pos5.SetLabel('X') layout[5] = 1 self.button5.Disable() turn = 2 elif layout[8] == 1 and layout[6] ==1 and layout[7] == 0: self.pos7.SetLabel('X') layout[7] = 1 self.button7.Disable() turn = 2 elif layout[2] == 1 and layout[6] ==1 and layout[4] == 0: self.pos4.SetLabel('X') layout[4] = 1 self.button4.Disable() turn = 2 elif layout[1] == 1 and layout[7] ==1 and layout[4] == 0: self.pos4.SetLabel('X') layout[4] = 1 self.button4.Disable() turn = 2 elif layout[3] == 1 and layout[5] ==1 and layout[4] == 0: self.pos4.SetLabel('X') layout[4] = 1 self.button4.Disable() turn = 2 elif layout[6] == 0: self.pos6.SetLabel('X') layout[6] = 1 self.button6.Disable() turn = 2 elif layout[2] == 0: self.pos2.SetLabel('X') layout[2] = 1 self.button2.Disable() turn = 2 elif layout[8] == 0: self.pos8.SetLabel('X') layout[8] = 1 self.button8.Disable() turn = 2 elif layout[4] == 0: self.pos4.SetLabel('X') layout[4] = 1 self.button4.Disable() turn = 2 elif layout[5] == 0: self.pos5.SetLabel('X') layout[5] = 1 self.button5.Disable() turn = 2 elif layout[1] == 0: self.pos1.SetLabel('X') layout[1] = 1 self.button1.Disable() turn = 2 elif layout[7] == 0: self.pos7.SetLabel('X') layout[7] = 1 self.button7.Disable() turn = 2 elif layout[3] == 0: self.pos3.SetLabel('X') layout[3] = 1 self.button3.Disable() turn = 2 while turn ==1 and gmode ==2: if layout[6] == 2 and layout[0] ==2 and layout[3] == 0: self.pos3.SetLabel('X') layout[3] = 1 self.button3.Disable() turn = 2 elif layout[0] == 2 and layout[2] ==2 and layout[1] == 0: self.pos1.SetLabel('X') layout[1] = 1 self.button1.Disable() turn = 2 elif layout[0] == 2 and layout[8] ==2 and layout[4] == 0: self.pos4.SetLabel('X') layout[4] = 1 self.button4.Disable() turn = 2 elif layout[2] == 2 and layout[8] ==2 and layout[5] == 0: self.pos5.SetLabel('X') layout[5] = 1 self.button5.Disable() turn = 2 elif layout[8] == 2 and layout[6] ==2 and layout[7] == 0: self.pos7.SetLabel('X') layout[7] = 1 self.button7.Disable() turn = 2 
One of the biggest problems of over-commenting is that the comments often fail to be kept up to date. Just wait until one of these comments ends up misleading.
Pyspeech may be helpful, I have never used it though. http://pypi.python.org/pypi/speech/ A friend has used Dragonfly as well. I'll ask him what his impressions were. https://code.google.com/p/dragonfly/
Yes, it takes a very long time and what you said about unclean/reclaimed blocks. We are a NAID certified company that does third-party destruction for institutions that are required to have third-party verification of data destruction (HIPPA, Sarbanes-Oxley, PCI, etc.)
Reminds of my VB class. Everyone copy/pasted cos **it** . **just** . **worked**
Maybe he needs an editor that shows him the indentation or something. * [VIm Indent Guides](https://github.com/nathanaelkane/vim-indent-guides) * [Emacs Indent Guides](http://www.emacswiki.org/emacs/HighlightIndentation) * [Sublime Text 2 Guides](http://www.sublimetext.com/blog/articles/sublime-text-2-build-2111) Or tell him to suck it up and get used to it. I have never understood why programmers are not willing to adapt to change. I *love* digging in to a new language and figuring out how to master it. Isn't that why we all got started in the first place? Sounds like this guy has given up on life or something. Comfort is death. Maybe have him watch [Guido address the whitespace troll](http://www.youtube.com/watch?feature=player_detailpage&amp;v=EBRMq2Ioxsc#t=267s) 
Can I ask that you put it either into a gist or into pastebin? Your code is quite long currently, and formatting errors are coming up as well. Makes it quite hard to read easily. 
dude your horrid slag is horrid and hurt my brain.... O.o
You could counter with a hook: sed -i 's/^[ ]*# endif[ ]*$//g' *edit: And yes, it would bother me and if I had the authoritaw I would tell him to stop. Otherwise I'd add that sed command as a hotkey to my .vimrc. 
 wx.StaticText(panel, label='|\n|\n|\n|\n|\n|\n',pos=(56,26)) This can be shortened a bit by using * operator with the string '|\n'. wx.StaticText(panel, label='|\n'*6, pos=(56,26))
As officially noted in http://www.python.org/doc/humor/#python-block-delimited-notation-parsing-explained
Well, you said brutal, so: 1. Put the entire code in a pastebin paste. 2. It looks absolutely hideous. You're going to need to rewrite it from scratch. The amount of redundant code is ridiculous.
Your style of writing resembles the work of someone who just ingested a copious amount of controlled substances.
I have to deal with Verilog and VHDL sometimes at work which uses "begin" and "end". I saw some code that added //{ and //} as well. He had both begin and end and //{ //}.
*eye twitch*
You can probably make this class 10 lines by using loops for all the elements you create. Also, why are you using globals ? I don't know wx much but it sure looks like they could be passed to the constructor or maybe be just properties of the class since stuff like 'activegame' seem to be changed only by your class Also do yourself a favor: install pep8 or flake8 and run it on the code 
I always take a swig from my [flask](http://www.youtube.com/watch?v=SrvNqElOF_s) before I go to work
&gt; Would it bother you? Our would you just accept his quirky style? It is not acceptable. Tell him once in private not to do it anymore. If it persists, escalate it. In any case, don't merge this shit into the master branch until he fixes it. &gt; But why not? We have adopted PEP-8 as our coding standard and this is shit. End of. If he's in his probation period, suggest he be dismissed before he poisons some projects.
FOR LOOP!
i figured. i just started learning today. so i kinda just wrote a little tested, added on, tested and so on. eventually coming up with this blob.
If you want a really informed opinion, then try it. I can complain about the ancient problems I had with nose which caused me to abandon it, but you aren't guaranteed to see it the same way.
If you find yourself copying and pasting regularly, it is a sign you are doing something wrong.
Failure to conform to accepted standards is the sign of an ego problem. Excise this behavior or this individual before his problem becomes your team's problem.
If management comes to you drooling over something they read about Cucumber, then robotframework *may* be your best friend.
If he's a real programmer he will adapt to new languages. Tell him to stop and force him to learn the language.
Weeeee! Karma roller coaster!
I was going to say, I'm not a programmer by trade, but I have had some experience working with and managing teams. I would just tell him "Look, you can write your code however helps you keep it straight in your head. But when you check it in, it meets our coding standards which are essentially the pep8. So, come up with your own tidy.py implementation convert your code to the standard (on your own time) or start writing it to the standard. Either way, what you're producing now isn't going to work."
 if (x == 7): #{ print ("something"); #}
This is something you need to commit to when you're learning to program. Anytime you copy and paste a large chunk of code, you're doing something wrong. It makes the code much harder to read and maintain. Just don't do it! 
Maybe you should have put some energy in your homework? A single google search would have given you an answer to the first one. 
Assuming python 2. 1. When you divide two integers python uses [integer division](http://mathworld.wolfram.com/IntegerDivision.html). 2. The code does not work, notice he uses myPict and mypict. Python is case sensitive. The answer may be B if what he means is - "The code does not work because we wrote the name of a variable with an incorrect lower case in one of the letters". Hence getting: NameError: name 'mypict' is not defined I recommend reading [pep 8](http://www.python.org/dev/peps/pep-0008/) to learn the usual style that should be used in python.
This is most definitely unpythonic.
I'm new to Python and I thought that putting "#" in front of something makes it not work or show up?
Yeah, # makes it a comment. He's just explaining that self.pos_list is a list of pos. The line doesn't actually do anything.
You might have a problem. I've worked with people like this. He will do everything like it were C/C++. He won't use Python-specific features where they make sense. When he does, he'll use it in some bizarre way confusing everyone else. He might even implement C-like wrappers around Python (eg writing itoa(), and maybe even strcat()!). And he won't stop bitching about Python. (Ugh. Whitespace! Exceptions everywhere!) He has to start thinking in the actual development language. Talk to your manager. Tell him your concerns. People like this can be poison on a project. This should be nipped in the bud or he should be moved to another project if possible. &gt; I should also mention that before we started I had everyone look at PEP 8 and the Google style guide. It sounds like you don't have a coding standard. You should have one. If it's the Google style guide, that's fine but you need something. I'd suggest taking what you like from that and putting it in your own company doc so the company owns it. (Surely not everything in the Google guide and PEP 8 are what your team wants).
can you not use xpresser on Windows ?
how's automa ?
*Shitty* programmers have a hard time adapting to stuff like this. It's honestly a sign of someone who isn't interested in learning anything new, because "they have it all figured out."
Great News, management has approved the request! I am going to PyCon!!!
- Python is an official language at Google - Python is used for the build system where I work - I use Python everyday to write scripts, read the doc of argparse and fall in love
Am I the only one who actually uses the unittest module?
The reason why you are receiving a hostile response, and doubly why you are being down voted now is because you are being presumptuous in the wrong place. He pointed out you are in the wrong subreddit for a reason, and that reason wasn't just to be a dick. It's the old saying "if you give a man a fish...". He pointed you in the direction you needed to go, and you be all like "Just answer the damn question". Also, the fact that this is literally chapter 2 in intro to python is doubly why it shouldn't be littering this subreddit.
Having as much fun with this as I used to have with Turbo Pascal on my HP 200LX!
Link them this one instead: [http://www.python.org/doc/#python-block-delimited-notation-parsing-explained](http://www.python.org/doc/humor/#python-block-delimited-notation-parsing-explained)
I'm still young and almost without fail, my first test is always called `tit()`. I hope I never change.
I'm on the fence with Robot because it's quite powerful and easy to learn but on the other side it's difficult to do something more complex and syntax is... weird. If lib like Sikuli would be introduced to robot, that would solve some problems right there.
I recommend this to most people that are coming from languages that have a C style syntax.
Sikuli script is jython-based, and it's somewhat straightforward introducing python into robotframework. The trick is setting up a classpath, invoking the robotframework jar and telling *it* to execute a sikuli script, which is no more than a python script and a collection of images.
Go out and get really drunk with him. Like good and happy blotto. Then, when it's 2:30 am and you are sitting on the curb outside the now closed bar feeling such a huge buzz having spent the evening divulging details from your personal lives, say to him, "Dude! What's with all of those endif statements! Why, dude? Why? Please, stop. Please?" Works every damned time. 
I agree in general, but sometimes the individual is right and the team are just dumb arses.
**passive-aggressive mode = on** Start by changing his comments to something like this: # BEGIN IF...ELSE BLOCK if x == 7: # BEGIN IF BLOCK print "something" # END IF BLOCK else: # BEGIN ELSE BLOCK pass # DO NOTHING # END ELSE BLOCK # END IF... ELSE BLOCK You'll probably only need to do it ~~once or twice~~ a few dozen times before he gets the hint. **passive-aggressive mode = off** 
When you have nested ifs with code before and after each if, you still need to scroll up to see which if you are talking about with the #endif. 
Give him a couple of months to get used to it and then start littering your code with things like this: if x==7: print 'something' # endfor or even this: if x==7: print 'something' # else print 'something else' # endif
If your functions are longer than a single screen in length then your code is probably trying to do too much at once and you should break it up into smaller components. If you're using more than 4 levels of indentation at one time then your code is probably trying to do too much at once and you should break it up into smaller components.
 def handle_asshat(asshat) if company.coding_standard is not None: asshat.patch.reject("""This patch does not conform to our coding standards. Please drop the bracket comments and resubmit.""") else: company.coding_standard = Pep8 handle_asshat(asshat) # endif
When you code in C/C++, a lot of people will write things like: if x == 7 { cout &lt;&lt; "something"; } // end if x == 7 And a lot of code generators also support such editing (which helps if you end up with out of date comments, as you can autoparse to correct. It can help in certain situations which involve nested loops, and especially nested classes or structs. In short, he isn't bracketing, he is simply following the same tagging system he might be used to, which is language generic.
Sorry for late reply. The biggest advantage of py.test imho is how it introspects failures of no-boilerplate tests. These are examples of what it shows on failure (this looks even better in color): &gt; assert f(foo) == bar E assert 'Foo' == 'BAR' E - Foo E + BAR and: &gt; assert f(foo) == bar E assert [1, 2, 3] == [1, 2, 3, 4] E Right contains more items, first extra item: 4 and it diffs signals very nicely: &gt; assert f(foo) == bar E assert [0, 1, 2, 3, 4, 5, ...] == [0, 1, 2, 3, 4, 5, ...] E Right contains more items, first extra item: 20 another example: &gt; assert f(foo) == bar E assert {'four': 4, '...: 3, 'two': 2} == {'four': 4, 'o...one, 'two': 2} E - {'four': 4, 'one': 1, 'three': 3, 'two': 2} E ? ^ E + {'four': 4, 'one': 1, 'three': None, 'two': 2} E ? Note how it puts an `^` arrow to show where the difference is. It's like magic. While `nose` would only say `AssertionError` in all those cases. 
This example is even better: &gt; assert f(foo) == bar E assert 'fhweivnsuwer...eurerwiuhqwer' == 'fhweivnsuwere...eurerwiunqwer' E - fhweivnsuwererdifnsudfieurerwiuhqwer E ? ^ E + fhweivnsuwererdifnsudfieurerwiunqwer E ? Note the `^` arrow.
"It's written in C, so it must be fast" right? right?!!!!
e.g. this: from random import randint gmode = randint(1,4) ... if gmode==1: self.pos0.SetLabel('X') self.button0.Disable() layout[0] = 1 turn = 2 elif gmode==2: self.pos2.SetLabel('X') self.button2.Disable() layout[2] = 1 turn = 2 elif gmode==3: self.pos6.SetLabel('X') self.button6.Disable() layout[6] = 1 turn = 2 elif gmode==4: self.pos8.SetLabel('X') self.button8.Disable() layout[8] = 1 turn = 2 can become this: from random import randrange idx = randrange(4) * 2 self.pos[idx].SetLabel('X') self.buttons[idx].Disable() layout[idx] = 1 turn += 1 but there are several more issues with the code revolving around code duplication, needless use of globals, …
There is undoubtedly a very pythonic solution to this quandary. with open("egotrip.py") as f: lines=f.read().split("\n") fixed= "\n".join([line for line in lines if line.strip()[0]!="#"]) I miss Python... C#, ew.
And print("BREASTS") is still the best way to show debug output.
No don't feel alone;) I'm using nose to actually run the tests (plain unittests) and dumping a xml junit output. The fact that it doesn't try to be clever (plugins, setuptools and the other "magic" things) is a killer for me: I'm more concerned about integration with other tools. 
That's sexist. Why not `testy()`? 
Absolutely. Even in small scripts it's good to reduce boilerplate like that as much as possible and make sure all that data is flowing through as few points as possible.
As you say this guy is not pleased with the language change, and as I see it this is some sort of demonstration against that decision. Adapting to a new language can be hard. I remember when I started using Python after years of Perl abuse, I would be incredibly annoyed at small details in the language, but eventually I accepted them all. I think you should let him do it for a while. Apart from the annoyance there's no real harm done and it will be easy to clean up later. Chances are he will eventually learn to enjoy the language. Obviously this cannot go on forever, but if you let him demonstrate for a while he will probably feel silly, whereas if you confront him it will only fuel his anger.
Tip of the iceberg. If he's doing this, what other unpythonic things is he doing? Does he understand the 'Python way' or is he making any attempt to do so? Get him to read: http://dirtsimple.org/2004/12/python-is-not-java.html Someone stubborn coming from a less-dynamic language such as C++ is infinitely more dangerous than someone stubborn coming from a more dynamic or functional language as they will probably be writing inflexible, verbose, unreadable Python rather than merely non-idiomatic Python. Plus he is obviously an idiot.
Github Gists are your friend: https://gist.github.com/ Makes formatting so much nicer, and tracks your revision history. But, other than that, repeating code is rampant here. Much of this could be refactored into functions or simple for loops.
Revenge: When your team starts a C/C++ project start doing this: int a_function(int argument) { blablalblabla; blablalblabla; if (ahahahaha) { blablabla; if (ahajhaha) { blablabla; }} blablabla; return x; } 
As someone who currently has to use Delphi, which uses "begin ... end;" blocks, and also someone who likes Python very much: Fuck him and delete the comments from source control. Also, you don't make language A more language B like. There's no point of putting commented-out Lisp parenthesis into C code, or curly braces into Python, or $@% symbols into Java. If this guy needs to make Python more C-like, the only conclusion is that he cannot _program_, but only program C, like "we always lugged wood with horse carriages, we don't need tractors! And if we have to use tractors, at least put a harness and horse shoes on them". 
There's no way in hell I'd accept that. What is the problem with that person learning Python without adding a lot of fuzzy comments?
You are partially correct. Nose would, if you didn't handle the assertions correctly, only report Assertion Error. As much as people want to hate on the assert_* wrappers that nose has, they are actually quite handy to have. They all work in the vein of assert_true(foo() == b, "Foo did not return the correct value") I've even put simple exception handling calls in the message portion of the assert_* calls of nose. 
That is truly evil. (I like it...)
 if (x == 7): { print ("something"), } 
clearly he knows the language, or he wouldn't know how to put in a comment. It's more about making it more readable for him.
Not sure what you mean by "putting exception handling calls in the message". Don't forget that `assert` statement also takes optional message: assert m &gt; 0, 'mass should be positive' And note, that the message part is not evaluated, unless the assertion fails, which you cannot achieve with functions.
Mandate the use of the following pre-commit hook: #!/bin/sh FILES=$(git diff --cached --name-status | grep -v ^D | awk '$1 $2 { print $2}' | grep -e .py$) if [ -n "$FILES" ]; then flake8 -r $FILES fi Won't allow you to commit code that doesn't fly through pep8.
I agree that the first version is more readable, but the second version doesn't seem 'horrible', just slightly more verbose. You could argue that the extra function call is preferable because there's less magic involved.
The "don't check .pyc files into your repo" comments are a direct result of the first paragraph not framing the problem well for reading on the web. I read it and realized what he was talking about, but a little setup would have helped.
You need to (1) import those functions, (2) remember how they are called (is it `equal` or `equals`?!) and you end up with much less readable tests. Plus, `assert` is no magic, it's pure Python.
The demand for Python devs really depends on the area. Where I live there is very minimal demand for Python developers, but the few places that want them are desperate because there aren't many around here. If you're in the right area, a ton of places use it. Being willing/able to do freelance work also opens up a ton of opportunities. I see a lot of freelance, remote work jobs using Python and particularly Django.
Your solution is to delete all comments?
If x equals seven, the set consisting of print("something")? That's evil. Presumably you're using python 3 or `from __future__ import print_function`.
haven't tried it yet ...
Never tried it - but as it's Python I guess one could try.