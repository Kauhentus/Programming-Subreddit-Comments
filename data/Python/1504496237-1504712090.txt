I remember my first attempted project in python (my first programming language) was creating a website with Django. Not a good choice...
WOW! I was one of the guys doing this with him instead of studying for my datastructures exam... thanks for whoever posted this and for eevee for still being active (my page died years ago). Apparently I even get a shootout https://veekun.com/props (Zhen Lin, loadingNOW, and Pipian, who (willing or not) got me started on extracting game data myself when Gen IV arrived.) I think it was either him or Pipian who first got the first good result on the encryption. I only got the actual equation after looking at game code a few weeks later. Good times
&gt; when people stop assuming that "technical == male", Actually it's more like "person == male". It really has nothing to do with technical. I find myself using the "gender neutral" "he" in contexts that have nothing to do with science/technology/math/or anything else stereotypically masculine. Also, you can always word things softly. People make innocent mistakes. And it *is* an innocent mistake. Your reaction, if anything, is probably going to drive people *away* from your point of view.
I'm definitely going to save this article. I don't have the time to read it now, but I've spent way too much of my life attempting to romhack first gen pokemon.
A good source for the sort of practice problems you describe at the end is CodeFights.com. It has a bunch of languages, but I learned Python there. It even has a section dedicated to teaching specific Python built-in features.
Fun fact: your "gender neutral" use has caused real problems in the past, when "gender neutral" use of "he" in charters and statutes and bylaws led to people literally arguing that women should be forbidden from jobs, certifications and other things on grounds that by using "he" the documents meant to exclude women from eligibility.
Good article. It's "core tenets," not "core tenants."
Premature optimization is the root of all evil. Never ever start with optimizing. Get it to work first, then optimize if you need to. And unless you're running a profiler and you know where things are slow, most of the "optimizations" that look intuitive won't actually make a difference. Except of course stupid stuff that is simply wrong, like doing the same thing over and over in a loop instead of once outside the loop.
Did I indicate otherwise? Did you notice my scarequotes? Why are you preaching to me? 
Python overtakes R as the leading language in Data Science * among kdnuggets readers inclined to take a poll 
Sure, you indicated you think "he" is a gender-neutral pronoun. In actual practice it isn't, and no amount of wishing will make it so. This is like the people who say "guys" is gender-neutral but then get upset when you ask how many guys they've slept with, or the many lines you can find in literature parodying "gender-neutral" use of "he" (my favorite being one about a secretary, talking about how "he pulled on his pantyhose and applied his makeup...").
Thanks :)
Apart from statistics and graphics, both of which are mentioned frequently already, R has one large advantage: RStudio. It has become far more than a killer IDE (which it is). RStudio now supports dozens of cool projects, like Shiny and Knitr. They provide financing for Hadley to ensure that R gets better at handling data every day. It's no accident that many Python data packages are just trying to port R's functionality. 
Good luck!
Not sure but my friend made this himself and thought that it was very creative of him to do so. And I just wanted to share his content so he can be encouraged to write more code :)
haha this is awesome &gt;..neither of those bullet points are coherent sentences. You can’t document what a taco is by explaining it is a taco hahaha another edit that i found after reading some more.. &gt;The bad news is I have no idea if it’s the ‘one right way,’ because after browsing the docs and too many blog posts, the only thing I know for sure is I know nothing at all.
Trying Kaggle's Dogs vs Cats for the first time.
I am working on my last assignment from Coursera that is due in just a few hours. I keep on getting errors in my code. 5.2 Write a program that repeatedly prompts a user for integer numbers until the user enters 'done'. Once 'done' is entered, print out the largest and smallest of the numbers. If the user enters anything other than a valid number catch it with a try/except and put out an appropriate message and ignore the number. Enter 7, 2, bob, 10, and 4 and match the output below. Can you guys please give a hand here?
I would buy this.
Thanks for the link. I'm actually working on something now that requires a viz layer. Basically parsing combat logs from a game and graphing them out. Seems like pygal might actually be good for that. Hard pass on django though :)
Should just stick to something like Tornado that is tried and tested.
Took a look. I think I could help in some way in near future. :) 
Thanks, I will take a look at that. :) 
Totally agree, but it takes you into the same place the OP's post talks about with Flask etc; if you try to learn parser/lexers and grammars before you have **re** down, you're trying to run before you can walk.
Haven't done it myself yet, but check out building desktop GUIs with Electron (JavaScript / node.js): https://www.fyears.org/2017/02/electron-as-gui-of-python-apps-updated.html Edit: Forgot to mention that the backend can be written in Python -.-
I just recently watched [this talk](https://www.youtube.com/watch?v=9by46AAqz70) on the subject of Python in Data Science and I think it's pretty useful. There are a lot of scientific, math, and machine learning platforms that are being developed for or ported over to python. Besides, Python is useful for a lot of other things outside data science too. 
Video linked by /u/daishi-tech: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [How Did Python Become A Data Science Powerhouse?](https://youtube.com/watch?v=9by46AAqz70)|Coding Tech|2017-08-28|0:34:36|1,400+ (98%)|53,593 &gt; It is a well established fact, Python is the best... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/daishi-tech ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dmjcvfw\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
I don't think JavaScript is a good choice. Is it terrible callbacks mess that we want to teach new unsuspecting students?
It's a bit old, but it's well written and it's not like the fundamentals of regular expressions have changed, so I'd point at [Mastering Regular Expressions](http://shop.oreilly.com/product/9780596528126.do). Aa for *lexical analysis*, i.e. *parsers*, *lexers*, *abstract syntax trees*, and *grammars*, [this](https://tomassetti.me/parsing-in-python/) is at least a decent high-level starting point to the rabbit hole.
Noted, thanks
Probably better than learning Pascal in intro Comp Sci like I did a million years ago.
Beyond the other answers, I'd point out that by the time your Python interpreter loads and is ready to run, it's already imported **re** and cached a bunch of regular expressions, because it's used all over the standard library. So yeah, odds are your code depends on them, even if you don't know them. They're one of the fundamental LEGO blocks of programming. Admittedly a bit of a weird looking, not obvious one ... a Technics piece, not a Duplo ... but a damned useful one all the same.
Hahah I learnt turbo pascal in high school too since the school didn't want to get the free version of C. It was hell but made me appreciate Python later on in life
assuming you're in windows and installed python with anaconda, AND you want to script/programmed python to interact with mysql you've 3 options: 1. from command prompt, type python or ipython. This fire up python/ipython console for you to type your python scripts. 2. from command prompt, type 'jupyter notebook'. This open a browser and give you....surprise..jupyter notebook where you can type your scripts. 3. find in your windows start menu and apps called spyder. This is a very good IDE for python (where you can type your scripts/programs). Btw perhaps you better start with python tutorial first. Or from r/learnpython 
And, He added, Python is now the most popular language for teaching introductory computer science.
Why? I also learnt Turbo Pascal in school, ages ago, and I thought it was a great introduction to programming. Verbose enough that anyone with basic english can understand almost immediately what's going on, it reads like natural language. Overall it felt very clean (program structure, strong typing), and forced me to learn good habits from the get go. 
An advantage over Python? How so? Python has PyCharm.
Data Science is 90% scraping, ETL and data cleansing, 10% number crunching. So no wonder. In ML, apart from it depending on data from the aforementioned, Python already has a bigger foot to stand on in terms of libraries and tooling. No surprise there really.
Why don't you just use threads?
JS is a terrible language to start with. Even worse than BASIC. WTF Stanford.
&gt; Are you one of the 1% who actually do have a reasonable reason for disliking the GIL, and if so, why aren't you using the GIL-less Jython or IronPython instead? Not OP, but one major reason to not switch from CPython is because the scientific stack (numpy, et.al) only works there.
Languages like Java force you to write classes; you can't run anything without a class, not because a class is useful for hello world, but because the language is too strict. This leads to horrible habits with overengineered code. Python gives you a choice. If you have functions or procedures that belong together logically but don't share state, just stick them into the same module and import that module into your code. That gives you clean scoping and namespacing without bloat. Only use classes when you're representing something that makes sense as a cohesive "thing" with data and behavior operating on that data. Otherwise, just use modules. I can whip up an example if you want.
Most of the documentation for the standard libraries falls into this, "the taco is a taco," trap. There's a shortage of tutorials and code examples in the Python stdlib docs. Also, this: "I still have no idea what the difference between a coroutine and a task is." Context from `python-dev`: https://mail.python.org/pipermail/python-dev/2017-August/148917.html 
I hear you, and I'm certainly no worse for the experience, I just feel that it would have made life a little easier had we learned a language that could be used outside of an educational environment afterwards. I just felt like "okay, now I understand the basics, now let me start the syntax from square one" instead of jumping off from a versatile language. Let's say that I didn't appreciate the inefficiency of that process.
It's US$300/month per developer for Qt. 
Yes, but according to the first half of the article, Stanford apparently went from A for jAva to J for Javascript and leapt right over G for Good Idea.
Did you even read that link? &gt;Azure Machine Learning Studio includes hundreds of built-in packages and support for custom code. &gt;Learn more about how to get started on Machine Learning with R and Python by reading our blog. Not sure what you're not understanding here. What you're asking is like asking "What about the art studio down my street vs. acrylic paint for making great paintings?" Fundamentally a weird question. 
So, based solely on the charts, Go is very fast but uses a heck of a lot of memory, and synchronous urllib3 seems to be the best overall choice???
Based on my understanding after reading's Qt's literature if you extend a Qt class and then sell that product you are in violation of the LGPL. https://www.qt.io/qt-licensing-terms/ See the Youtube video, in particular at the timestamp 2:30. Also section 3.7 of the FAQ: https://www.qt.io/faq/ So if you subclass "PushButton" and want to sell the result you have to have a license. There are libraries written in such a way that LGPL isn't very restrictive (ZeroMQ comes to mind), but Qt isn't one of them. GUIs are naturally subclassed quite a lot, otherwise you end up with a messy mix of procedural and OO code. Now, LGPL does give you some leeway. You could make all your subclasses publicly available but not the code that calls them. They would need to be able to work independently of your proprietary code. 
Threads are not as lightweight as coroutines. Threads are for when you have units of work that take CPU time and can be run in parallel on multiple cores. Also, GIL. Coroutines are good for when your tasks wait on io. They tell the language how to share time on a single core. They can usually take advantage of threads, too. 
I think this is only true for small programs. Matlab is a domain-specific language for matrix and numerical computation. But as soon as you need functions and objects, then Matlab is a nightmare. R has the same problem. It's great for a 100-line one-off script. It is terrible the moment you want to anything clever or complicated.
We briefly tried to do that when I was at Uber (make Python call R). It's not worth it. 
I would have to think golang is the best choice for a beginner. It's relatively low-level but also protects against programmer errors very well, and enforces standards. It has a very simple and robust toolchain that works the same on all platforms. It doesn't do object-oriented stuff, so you don't teach that (which you shouldn't early on). It has many nice things in the standard library, like hash maps, that people who learn starting with C tend to be oblivious too even though they are very important. Python is too high level for beginners. Start with a procedural, strongly-typed language and save the functional languages for second year. 
If you are new. Try out lazy dataset, its very easy to connect to the database with it. 
What I have done before. Using eclipse with python and r plugin. You could actually debug from python to R. But to be honest I hated eclipse after a week of Pycharm
Which is fair. What's the problem?
On Windows it's `logic.dll`, on linux &amp; macOS it's `logic.so`. You import it like an ordinary .py module. It works via so-called "Python Extensions" mechanism, see https://www.tutorialspoint.com/python/python_further_extensions.htm for details. Cython simply generates such a "C extension" from your `.py` file.
Just started my first post-doc in astronomy, I write everything in Python, but when I need particular statistical tests, then I just use rpy because, as you said, some statistical methods aren't in Python.
Haha this is glorious. Going from a well explained language like Java ie you know why the tradeoffs exist to a fucked up piece of Frankenstein garbage like JavaScript Also this is the kinda stuff that ends up being called stupid propaganda "programming is supposed to be fun" Why do all these tech authors make these statements? Luring people into the field who have no aptitude for it Dancing is supposed to be fun too, professional dancers may disagree about how much work their career actually is though
Very few people get a job in the language they studied in college. The language is just there to teach you the basics of how languages work. Also what are you going to do when you want to switch jobs to a company that uses rust or whatever else is the new hotness?
Creating the aiohttp client sessions outside of the async function will throw a warning, but by doing this I think you could probably increase the speed of the code by sharing the session object. This has given me large speed increases in aiohttp programs. 
As an incompetent programmer with no statistics background, I will copy-paste these comments into my own and hope they compile.
I work at a company where a lot of business value is in a framework we built for describing various domain-relevant as well as generic file formats and parsing them and doing things with them... and recovering when the people producing the files don't exactly follow the format, or change the format without telling us, or any of the many other things that go wrong in the real world but still are *our fault* if we don't handle them. I also get a kick out of people who want to bring "real" parsers that they learned in CS 101 to bear on this problem, since anything based on that would probably break twice a day :)
Building a text editor is a fun project! If you'd like some inspiration, I built a text editor in chapter 6 of my book. Feel free to use anything you'd like from it. https://github.com/Dvlv/Tkinter-By-Example
Only twice? You clearly don't work in Visual Effects!
I'm being charitable. Also, it's health care; lots of places batch their files and send 'em all over at once, so there aren't always as many opportunities to break in interesting ways.
For all you know OP is writing for the Mole People, and look not everyone can get a Mole Mortgage these days!
Outer-Earthist homeowner scum!
Totally agreed with this post. On the notes on the bottom of the page - " celery is over kill", just wanted to say that I use Celery all the time, once you leared how to install it, next times it takes 10 minutes, totally worth it. It is easy to change, well documented, and if(and this always happens) you need to scale up, you can easily do it, even on more than one machine.
gtk3 just worked out of the box with everything i've thrown at it so far (it might not render emojii in color, which is a practice i find doubtful anyway, and obviously it depends on using a font that supports that character), and i'm surprised that you seem to indicate that pyside and kivy cause issues. for a test run, i've entered the above reference string into some programs i assume which gave no non-essential though to unicode in gtk, qt and wx (gtk3-demo, qtqr and codeblocks' file mask field), and all just displayed and allowed editing the characters as expected. to be fair: tkpod (a non-python tk application) can do that as well, but python's tkinter can't (using the tkdocs example from http://www.tkdocs.com/tutorial/firstexample.html on python3.6): it does display the characters, but at least 💩 can't be moved over or deleted as a whole character.
I did some simple utilities for myself and hobby-level gamedev in kivy. It's not bad, although it has its quirks. Startup time could've been better (I think about a second and a half for kivy itself, without any program logic, on my five-years-old computer under Linux Mint), it spams a lot to the console by default, and some pieces of API are questionable (*eg* coordinate systems some layouts force on their children and some other layouts don't). Plus I haven't found a way for OS to force theme on the kivy widgets like buttons/scrollbars/whatever, so your app may look a bit out of place. These are all forgivable for a game, but maybe not so much for the utility. But otherwise it's a pretty decent UI library, with lots of widgets, simple-to-use sound and stuff. And most of it just works™ on Linux/Windows without any porting.
Many years ago ago I played with [3d pie charts](https://www.willmcgugan.com/blog/tech/post/more-pie/). Something like it would probably be doable in the context of a request.
I started with C/C++ at school while doing a bachelor in EE, and now while searching for jobs I started with a bachelor in computer science. Java just feels like a gigantic mess with this--&gt;everywhere. It may be because it look like a trainwreck compared to C,Matlab or Python, but I'm glad it's not my first entry to programming. 
Wait, as far as I can understand [PyQT FAQ](https://www.riverbankcomputing.com/commercial/license-faq), and GPL in general, you cannot sell a single copy of your software until you *either* purchase a pyQT license (and maybe a Qt license as well, not sure about that) or promise to give your entire source code and everything needed to compile and run it to any buyer who asks for it. After that the buyer has every right to do whatever they please with the code and/or compiled program, including selling it for money.
Holy crap. Why is Coding Tech doing this OVER and OVER again. They are blatantly ripping off videos from PyData and other conferences, cutting off the beginning of the video and uploading it to their channel. Why are they getting away with this?! Link to the original if anyone is interested. http://pyvideo.org/pydata-seattle-2017/pydata-101.html Mods, please ban links to Coding Tech's Youtube channel. We cannot encourage this behaviour. Edit: [Link](https://www.reddit.com/r/Python/comments/6rfb1k/what_does_it_take_to_be_an_expert_at_python/dl57l6b/) to the reddit thread the last time they did this.
Yeah, and it seems to be under MIT license that permits commercial usage.
One way to do it would be to `from os import listdir` in `utils.py`, and then call `utils.listdir` in the other code - this way it'll be a reexport and not a new function. That said, I still don't really see the point. An extra line of imports doesn't hurt anyone, and most IDEs collapse them anyway.
Right now I'm not using Python but GDScript with the Godot Engine. The syntax is very close to Python and I'll likely transfer the game over to Python when V3 of the engine comes out with support, or any new games I make will use it. I started making games with Python in 2012 though because that was all I knew. It's not too bad at making games as long as you don't want to go 3D and squeeze all the power you can out of the system. 
You're assuming that Stanford are interested in producing engineers and developers. They're not. They're interested in producing shitty web startups, and for that, you need a snazzy JS enabled landing page.
Send one to Guido!
I want one !
Would be nice to see the same examples in Go as well, in my mind it's a nicer solution for doing this sort of stuff than both node.js and python3 asyncio. Use goroutines, channels if you want, all that sort of stuff is just built in as language primitives, it makes python's asyncio look way too complicated to me when I can just choose Go for that sort of stuff.
The [Python OOP Catalog](https://github.com/metaperl/python-oop) may be of some use.
I leant Pascal in Into to Programming for Comp Sci just last year
_I leant Pascal in_ _Into to Programming for_ _Comp Sci just last year_ &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ^- ^hjgvugin ------------------------------ ^^I'm ^^a ^^bot ^^made ^^by ^^/u/Eight1911. ^^I ^^detect ^^haiku.
Tell this to my university. First C (which I love), then Java, and then other languages, but no Python whatsoever. However, I'm going to work soon on a research project which will probably require Python and fortunately I know it well enough. I'm surprised they require Python while they don't teach it. But I guess a lot of stuff in the informatics field should be self-taught, universities just give the foundation.
Also, on this topic, have a look at Giovanni Barillari - "Why I still develop synchronous web in the asyncIO era" https://youtu.be/m40MciFvzds 
I did my fair share of research on the subject lately and I chose tkinter, because it's the one supported officially by Python and because of its license. It's fairly old, simplistic, but does the job well and has a native look and feel with ttk. I made a nice project with it.
I learned to program with Java and didn't have any problems. In my opinion Java is NOT a bad introductory programming language. Starting with Java makes it easier to learn C, C++ or C# later. I am not saying that Java is the best language for the job, but it has its benefits. Python on the otherhand might be easier to learn than Java. One thing I absolutely hate about Python is its dynamic typing. For new programmers it would be beneficial to explicitly declare the type of data in a variable and same goes with the function return types. In Python it is easy to not understand how some of the language constructs work and to introduce bugs because of dynamic typing.
The way I see it is this: short-term projects -&gt; write scripts and modules; long-term projects -&gt; design the project and then create a well organized system of classes. Of course it's not mandatory to use always classes, but they help in the structure of a large long-term projects. Short-term projects could as well be a complete mess of different coding styles, as long as they do their job in the end. The beauty of Python is in its flexibility.
Yeah - the stats side of Python needs a bit of work. I find it annoying that some stuff is in `statsmodels`, other bits in `scipy`, while of course you need `pandas` underneath everything. I end up importing multiple different libraries, with differing levels of documentation, to do something that seems like it should be simple. It still works, but it's annoying and finding out how to do it relies on someone else having written a blog post for you to find.
I think it's telling that when I've looked deep into the Python stats libraries documentation, I've found comments like "test reference values are from R / SPSS".
It took my CS department a decade to realize that an introductory class using ADA ensured that that no student would be taking the next class. The whole department (and probably other things) was about to get cut because of the economics. Things have changed and the first *real* CS class is in python (engineering CS is in c++), and the second one is in Java. Which I find to be a great way to get people into the discipline. Also. Javascript as an intro language is a terrible Idea unless any student has a fair grasp of functional programming.
Well that's a start. But:- &gt; but nothing seems to work. I'm tried dropping it into libraries, selecting the file for import. Not there. ...still isn't going to get answers. Please cut and paste the commands you entered and the responses you got, otherwise we're going nowhere.
My university's introductory programming language is C.
These sort of questions are better suited to /r/learnpython. You have a lot of redundancy in your code here. You don't need to `strip` your values until and unless you are going to print them. Further, you are performing the same operations on each element of a list, which is exactly where you should be using a loop, even if only for two elements. s = "Interface: mgmt0, Port ID (outgoing port): GigabitEthernet1/1" for part in s.split(','): print(part.split(':')[1].strip())
&gt; While we're on the topic, how important would you rate focusing heavily on optimizing your code as opposed to writing code that works? Anybody asking a question like that should not be in programming.
I don't know if it's more pythonic or not, but it's more simple: interface, port = (x.split (":")[1].strip () for x in s.split (",")) Otherwise, you can use regex: import re match = re.search ("[^:]+:\s(?P&lt;interface&gt;[^,]+),[^:]+:\s(?P&lt;port&gt;.+)", s) match.group ("interface") match.group ("port") 
For the umpteenth time I will repeat that in 17 years of using Python my gut has never once been correct about optimisation. The profiler and timeit modules are the only tools that count here, not your instincts.
To some extent the problem is that GUI desktop apps are loosing ground in favor of web applications. Less needs for GUI apps gives less developers and that gives less activity on the GUI libraries. I used PyQt4 to make some "simple" cross platform apps - likely biggest community, most examples and stuff. PySide seems to be always behind with development. Kivy is like the holy grail of mobile apps in Python but seen presentations showcasing how steep that process is still is (and likely Python for mobile apps won't kick off). WxPython, pyGTK, Tkinter are either old, limited or don't look that good. Qt also got Qt Quick which makes making GUI apps easier and you can skip PyQt or use Qt extra widgets that don't have Python bindings.
And they just may have picked on of the worst alternatives.
Can someone please explain to me what the "percentage %" notation was? I read something like %timeit and %%cython what's that? Thanks in advance, I'm a noob to these things EDIT: is it IPython? https://jakevdp.github.io/PythonDataScienceHandbook/01.00-ipython-beyond-normal-python.html
https://www.youtube.com/watch?v=9zinZmE3Ogk If you have the time I think this is a really good talk on the subject
If it's a "tiny utf8 bug" that "shouldn't take more than a couple of hours." why don't you fix it yourself?
I'm a fan of c as a first language. It's the foundation of so many other languages, you are so low level you implement a lot of functionality yourself and understand what's going on under the hood. And it doesn't have the mess that is cpp.
Exactly - `seaborn` is brilliant until you want to do something even slightly custom with it. And then it is a total pain. To be fair, I think partly this is to do with some underlying weaknesses in the `matplotlib` API. (I wanted a swarmplot overlaid with some other stuff. Never managed to get it quite right).
coda only does syntax highlighting--you can run anything. I'm not aware of any beside Pythonista that will work (I have it but rarely use it). [This looks interesting, however.](https://github.com/ywangd/stash)
Awesome. I look forward to any contributions. Just pull request again the dev branch please. 
This is a great point. Java was one of the first programming languages I learned (came across it before Python), and I was able to use my Java knowledge to pick up C# really quickly. I also agree with the dynamic typing issue. I find that Java, as unforgiving as it can be, ensures that your logic is entirely sound, meaning that other programming languages, which are also statically typed (I think that's the correct term) are much easier to pick up. Given how widespread Java and C++ are, I think that learning a language with the same type declaration requirements can be really helpful, despite the difficulty, as it ensures that people don't assume the logic of dynamic typing in a language that doesn't support it.
Fair enough, kudos to your friend! 
Looks like they need that ugly sleep for task switching. You'd think that, with all the fanfare, they already learned from Go and switched on every function call.
My University just shifted one of my classes in the major from c++ based to java based :(((( I cri I've had to use java at least once a year probably because of the vm it might not ever go away completely
noone uses callbacks anymore. promises are nice syntactic sugar for cleaning them up. and observables are gaining traction. asynchronous programming is challenging and a great tool for teaching.
Besides performance using explicit yields of control can make concurrency simpler (because you know when other people are accessing data structures). Of course that's until you want to add real concurrency.
The `await` statement gives the control back to the event loop. However, if you're are only awaiting sync/blocking code, it will indeed never run asynchronously (because everything needs to run in the same thread/event loop). For async-await to make sense you need to await something that can actually run asynchronous/parellel, like `io` from requests. The `asynco.sleep(0)` exists to manually force the control back to the event loop, see the revelant asyncio [issue](https://github.com/python/asyncio/issues/284) for more info.
My schools switched from java to python last year. Drop outs from the program significantly decreased.
&gt;Nothing in existence can beat R's ggplot2 for example. What about the python version of ggplot? Is it inferior?
No love for Gtk?
My university taught Miranda as our first programming language. 6 years later, I'm still pissed about it...
You have the opportunity to use the R kernel in Python to unite both worlds. 
You mean tidyverse? Add data.table to the list and we are good to go.
whats the point of learning the art if you don't ever apply it? come up with a problem you want to actually solve and implement it and learn on the way.
Promises are a solution to problem that shouldn't have existed in the first place
I can't tell if this is a rethorical question, but Rpy2
Mine was FORTRAN 90.
The question is more is the programming language to hard or the students noways to bad. I and my other 100 class mates started with Java and had no problem with it. See it as a filter and those who can't handle it should probably not be in software engineering anyway. Java is not a hard language it is the concepts that can be hard to learn and those are not tied in to a specific language.
how is async stuff handled in other languages? dont they have similar await type functions? and if you want to talk about syntax complexity callbacks are nothing compared to the overhead involved with languages like c++, java.
Ditto!
Usually I encapsulate async coroutines using [ensure_future](https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future). I tried to understand gather mechanism but I never could make it properly run. In the implementation of those coroutines, I always set a instance of [asyncio.Future](https://docs.python.org/3/library/asyncio-task.html#asyncio.Future) as parameter and an optional [asyncio.Semaphore](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore). Inside the coroutines I use two mechanisms: control maximum concurrent runs using Semaphore as context manager (optional if running few coroutines) and use Future's [set_result](https://docs.python.org/3/library/asyncio-task.html#asyncio.Future.set_result) followed by a return (None) statement. [This presentation - Łukasz Langa - Thinking In Coroutines - PyCon 2016](https://youtu.be/l4Nn-y9ktd4) and [this Stack Overflow's answer](https://stackoverflow.com/a/36415477) helped me to start to understand asyncio. Most of my learning was reading from various sources. All I wrote here so far I took from memory, not having my notes. Later I may post a Minimum Working Example (MWE) regarding this. EDIT: forgot to mention that I have to develop for systems in Python 3.4 and Python 3.5+. If you have a choice, definitely choose 3.5+.
&gt; I would have to think golang is the best choice for a beginner. Good for CS 101, but not necessarily for a beginner. The language itself is a good choice. What isn't so good for beginners is that the Go community at large tends to assume a solid knowledge of programming in documentation, articles etc. There's an awful lot of Python documentation out there that's *waaay* more accessible to neophyte programmers (because it's aimed at them). 
This is the dumbworld version of the Scheme -&gt; Python transition my college's CS department did.
I don't think strongly typed languages have too much overhead, but that's a completely different topic for discussion. JavaScript gets a lot of love, but I personally believe that Python and Go can do the same type of stuff, but in an implementation a thousand times better
A bit of overstatement considering https://nodejs.org/en/docs/ Promises can not abstract sync vs async code. If you write synchronous function and then you start using asynchronous functions in it - you are screwed big time; you have to rewrite the function and all the callers. I don't think that what students need. I would postpone async programming "challenges" for later
Please whip up example :-)
Please tell me these are for sale...
Pascal was ok as an intro. We had that followed by intro to programming languages which was a smorgasbord of languages that helped us appreciate what made a language good. Then it was all C after that. 
My school used C and Python as the two main languages. I think that worked great as you can learn about types, pointers or low-level concepts in C and learn about more general programming concepts in Python without thinking too much about the language.
Can you post a complete sample code? Also... **If you are about to ask a question, please consider [r/learnpython](http://www.reddit.com/r/learnpython) or [the learn python discord](https://discord.gg/jQtfh66).**
[The Taste of Banzo's Sword](http://www.ashidakim.com/zenkoans/91thetasteofbanzossword.html)
&gt; Python is too high level for beginners get out, google shill 
This is odd excuse for teaching with ancient languages with no existing tools except for that one "IDE" that is half-broken. Sure language is there to teach basics, but if we have a choice between teaching basics and teaching basics + being potentially useful in the future then choice should be obvious.
Phase two of learning with the library: functools, itertools, operators, collections.
GIL doesn't affect most IO bound things, if all you're doing is fetching some network data, threads are fine. 
I mainly use it for testing the logic behind a side project I've developed (https://back.me). I also promote it at work and hope it will get used soon. I also gave a quick try to stateful testing, but never succeed. I'll have to try a bit harder.
haha what - javascript is a terrible language that's an inconsistent mishmash of parts. Its getting a lot more reasonable with ES5/ES6 and maybe by ES10 it will be decent.
.... i had to google that. This fact alone tells how useful this experience was for you :|
.... i had to google that. This fact alone tells how useful this experience was for you :|
PyCharm is great but RStudio may be the best IDE currently available for any language. 
Thanks, I get ur point here.
Yes I know but I have too much free time that I can use to learn other things, thanx for the advice anyway :)
What do you mean? It doesn't have to be a sleep, it can be any awaitable. It's just that sleep(0) is a no-op and so is easily used by convention. Remember that asyncio is happening at the application level - the await keyword / async with/for is explicitly the point at which asyncio may switch tasks, unlike threads which is handled by the python implementation
Are these "Intro to CS" classes really about learning how to program? I had a course about concepts in programming languages who taught me much more in this regard. I had to fiddle around with awful languages like Prolog, wired looking Scheme and cool Haskell. And honestly if you are too stupid to learn an easy language like Java (and blend stuff out that you don't get right now, which is also an important skill), maybe Computer Science isn't for you. And you do much better realizing this in the first semester. Because the alternative is to waste time and money.
I'd check back in about 4 years, the same amount may drop out once they hit data structures or C-like languages. 
Very intresting approach ... I want to hear more opinions.
&gt; What do you mean? https://golang.org/doc/go1.2#preemption : &gt; In prior releases, a goroutine that was looping forever could starve out other goroutines on the same thread, a serious problem when GOMAXPROCS provided only one user thread. In Go 1.2, this is partially addressed: The scheduler is invoked occasionally upon entry to a function. This means that any loop that includes a (non-inlined) function call can be pre-empted, allowing other goroutines to run on the same thread. 
I don't think javas a good starter, but neither is javascript. For teaching future programmers I'd say C is the best just because you learn alot but starting with C. For people with just a slight interest, I'd say python is definitely a better choice because of the simplicity and you can actually create some cool stuff pretty early on. The way my uni did it with their intro to programming was like a couple weeks of python and then straight into C.
Sure, code looks roughly like this: import csv file = open("testfile.csv", "w", buffering=512) writer = csv.DictWriter(file, fieldnames=["a", "b", "c", "d"], lineterminator="\n") writer.writeheader() def process_comment(comment): # Do some stuff, reject dodgy comments (which aren't a lot) writer.writerow({"a": comment.thing, "b": comment.another_thing, "c": comment.more_thing, "d": comment.something_else}) def main(): # PRAW comment grabbing, should be irrelevant to this problem, a few thousand comments come through and all are processed properly. for comment in comments: process_comment(comment) if __name__ == "__main__": main() This doesn't write to file until I tell it to `file.flush()` at the end of `main`. And apologies, I saw that bit after posting this. Should've looked around before heading straight here.
My beef is that everything (that can be) is async. When you're doing things server side you might have something making multiple calls to databases and other api's. Often times you want to execute this ~~coffee~~ synchronously as you need to use the data from each, or need to rely on an action having completed successfully (like saving to a db). At that point, async is a premature optimization for most applications. It is finally manageable with async/await, but even then, it doesn't always behave when working with libraries. EDIT: `coffee === code`
Buffering will not write until you flush or the buffer exceeds a predetermined size which may or may not be as small as your buffer size. With 512-byte buffer sizes and a flush per out you've effectively eliminated the benefits of buffering anyway.
That is a batshit insane decision. While I think that JS has some really powerful features, it's not for beginners. As a matter of fact, I'd prefer that JS be seconded to the web since it is incredibly difficult to work with. As a matter of fact, most of the junior JS programmers that I've worked with desire features that exist in Java.
The big problem IMO with Java for introductory students is there is so much stuff one has to gloss over at the intro level. "What do you mean, public static void main" If the course is doing OO concepts, then Java is great. But all my intro courses (and I've had a few) taught the same things: data types, arrays, loops, functions, and I/O. 
True. Having to type public class and public static void main(String[] args) without understanding them is bad. Here Python is better.
Does anyone have an opinion about starting with C++?
Yup, that's what I meant - thanks. Do you use data.table and tidyverse together? Is it mostly a speed issue? I prefer the syntax of dplyr so I have mostly used that.
&gt; For new programmers it would be beneficial to explicitly declare the type of data in a variable and same goes with the function return types. I disagree. Type declarations are another thing to learn. Think about where type systems really come in handy: big, complex projects. (If type systems were handy for small one-off scripts, we wouldn't all be using Python or Ruby to write them...) It doesn't make sense to take someone with zero programming knowledge and beat them over the head with types when they already have so much weird shit to learn. Let the types come later.
Hilarious, I thought I was studpid when it took a LONG time to understand how to implement and use it. I certainly didn't like the docs..
&gt; Java is not a hard language it is the concepts that can be hard to learn and those are not tied in to a specific language. No, it's the syntax that is hard to learn, and Python or Ruby or Javascript is a lot more straightforward, placing far fewer arbitrary barriers in front of the student. I guess we should start police training by shooting at the cadets. Those who can't handle it should probably not be police officers anyway.
Hard is a very relative word. Do you think Discrete mathematics is harder to learn than the Java syntax? These are university students that are supposed to be smart.
Java is a great intro programming language. It was literally made to be easy to comprehend. In full disclosure I really dislike programming in Java for reasons that would probably fail me an interview if asked, but saying that it isn't a good intro language is silly. At my university we primarily used Java and C# and I am very thankful for that. IMO abandoning those as primary languages will usher in a wave of CS graduates that are scared of type systems, verbose syntax, etc., using their university's judgment call on picking a hip language as a crutch.
No, you're supposed to be smart when you _finish_ university. Making things arbitrarily harder is bad instructional design.
This sounds too familiar. WWU?
Ucd?
Coroutines are also subject to the GIL.
&gt; JavaScript gets a lot of love, but I personally believe that Python and Go can do the same type of stuff They can't do arbitrary code execution in the browser (yet?). I'm afraid that's probably all that matters.
Do two wrongs make a right?
To be fair, these two bullets don't want to explain what a taco is - only to tell you that taco, even in context, may mean two different things: either the taco shell or the taco you get over the counter. 
Edinburgh has been doing Haskell for ages
Python for Rhino doesn't work like that. You just click and drag the library into Rhino's library file, and then select the library in Rhino. I tried import geocoder on the actual script but it just says No module named geocoder
I thought c++ was way easier to learn than Java, simply because Java, by necessity, start with OOP concepts, whereas c++ lets you work your way into it, and basic syntax (w/ standard namespace) was just simpler to learn and less verbose than Java.
No you should be smart to be able to handle the things you have to learn and you should be become even smarter when you leave university. Java arbitrarily hard. It is a little bit harder but it is for a reason.
Nobody uses async await anymore, that's so 2018. We're all using observables now
&gt; I’m too stupid for AsyncIO No you're not. If an idiot like me can get it, I believe in your ability to get it as well. It's just a different way of approaching IO in Python, it can be troublesome to learn and has many little pitfalls awaiting you, but I believe in you. &gt; Javascript always has an event loop. In Python you write your own, push events into it, and run it until it’s done. I assume you meant *create an instance of the event loop* rather than write one from scratch. However, the reason for that is so you can: 1. Decide *what* event loop you want, it's not built into the language like JS, so you can decide if you want the stdlib one, the uvloop one (libuv based), the tokio one (rust based), or whatever else is out there 2. Have multiple event loops if needed. ~~You could conceivably spawn a thread, start an event loop there, and feed it tasks. I've not encountered a reason to do this, but I'm sure others have.~~ Literally thought of one while writing this post: A webserver with a flask/django/whatever sync front end, has a threadpool that has an event loop and submit jobs to it. It's a poor man's celery, but it'd work (if you're using uWSGI turn on threads, otherwise, no it won't work). If you need the results right away, well, then that's a problem. Of course, I'd recommend just using RQ (if you're on a non-Windows system) instead of this threadpool/event loop combo as it's battle tested and uses os.fork so you can do CPU bound work. &gt; Where I get lost is in the fetch function itself. There’s an async with statement within an async function. This is ugly, but also, why? `async with` is like `with` except it uses `async __aenter__` and `async __aexit__`, meaning you can do stuff asynchronously on setup and teardown. If the benefits aren't obvious, think setting up/teardowin database connections or transactions, setting up and tearing down HTTP connections (or returning them to the pool, empty in this case). There is also `async for` which allows iterating an asynchronous iterator (streaming database result set, anyone?) &gt; It uses Feedparser to read and normalize all the different formats, so I can’t just switch to aiohttp like I did in the last example. I'm not familiar with Feedparser, so I won't claim any insight other than "Is it doing its own IO?" This was my biggest challenge with using zeep's asyncio adapter is it wants to steer IO and under the hood lxml *ALSO* wants to steer IO, and I have to lord over them like a nun in a 70's depiction of a Catholic school rapping their knuckles with a ruler to keep them in line. &gt; Why? Apparently gather was running the async functions (tasks3) synchronously unless something happened that caused the async function to “pause and continue.” &gt; This makes no sense to me—shouldn’t all async functions be gathered asynchronously?—but it works. Because you had a synchronous function and just tacked `async` on the front of it. You need to use `await` (or yield from if you're on 3.3/3.4 still) to signal to the event loop that you're gonna do some IO now and it'll busy itself with other stuff until you're done. Sounds like you figured this part out though, or at least how to get them not operate entirely synchronously. Just tacking `async` on a function doesn't cause magic fairies to show up and make your program better, faster, or more efficient. Actually, just tacking async onto stuff you "want to speed up" without thinking through the implications is a sure way to make your program worse, slower and less efficient. BTW, aiopg and aiomysql both offer sqlalchemy core intergration (e.g. `accounts.select(accounts.c.name).where(accounts.c.balance &gt;= 10000)`) you don't get the full ORM experience, but these expressions are almost as good in my book. &gt; Gentlemen, neither of those bullet points are coherent sentences. You can’t document what a taco is by explaining it is a taco. This is not an explanation; it is a tautology. I'll mostly agree with this. The docs aren't terribly fantastic when it comes to many things (source: me digging through the logging docs every time I need to fuss with something that isn't a logger itself). If they'd just stuck to `coroutine-function` and `coroutine-object` it would have been clearer, much the same as we have `generator-function` and `generator-object` (which includes `(x for x in xs)` expressions). &gt; If the implementation is hard to explain, it's a bad idea. I think this quote is meant to imply that asyncio is a bad idea, and it's implementation might well be (see competing libraries curio and trio, not to mention tornado, twisted, etc). However, some things are inherently more difficult to explain, especially if you don't know what you're getting yourself into (my case when I first async'd and sounds like you're in this boat as well). 
Good bot
Thank you cain2995 for voting on haikubot-1911. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
That reason has nothing to do with making the learning process better.
Why do you think that you should abstract out async and sync code?
All I can suggest is that you need to install geocoder saperately or you don't have your Python path set up correctly.
If you are learning to drive with an automatic gear box and then when you come out in the real world you will have problems. Its much easier to learn to drive an automatic when if you even want to drive one if you have learned with a manual gear box. With Java or C# your much better prepared for the real world. I think Python would be excellent for the first weeks of a course but then switch to Java and C#. 
Your knowledge is useless if you never apply it. Your "free time" spent learning things would be better spent applying some of your current learnings. Otherwise, you will lack the experience to know how/when to use more advanced tools. 
I have not expressed opinion about whether you should or shouldn't. The point is that async is not abstracted and therefore should be dealt with. I don't think that's what students should deal with so early.
I started on Turing then my high school advanced us to VB 6. University we did Java. Now at work I support an application written in VB 6, but do all my coding in Python.
My route was BASIC -&gt; ASM -&gt; C -&gt; C++. I think maybe getting some of the lower-level fundamentals down with C would be a better start, and then dive into C++, but *not* "C++ is just C with classes!" as that'll lead you down some dark roads.
Async programming is massively easier to get right than threads and mutexes IMO. Especially if you're teaching kids who don't have a lot of experience using debugging tools. I really don't understand why any experienced programmer would think that "this functions gets called at a future point in time" is harder to grok than "your code can be interrupted at any point in time, so all non-atomic ops must be wrapped in a mutex. By the way, determining what is an atomic op and what's not may more difficult than expected depending on the level of doc quality for your language. Understanding when/why/how all those mutexes are being used in your existing code base that someone else wrote is *super fun*, and good luck debugging those threads when things inevitably go funky in prod, since how they interact is entirely dependent on current runtime, OS, and scheduler state..."
Well, I guess that is an answer in itself. Also, by this reasoning, should anyone who asks what a basic function does be in programming? I was really just wondering how people who've been doing this on a professional level go about this; do you write a snippet of code that works and make it very efficient and such and then move on to the next part, or do you write the entire code and then look at, say, chokepoints. But thanks for the insult, I'll remember to not ask questions anymore \^\^
The password generator can be way shorter : import string import random clist = string.digits + string.letters password = "".join(random.choice(clist) for i in range(100))
Because Python isn't used in the real world, right? It's not a production-ready language? Reddit itself isn't a massively successful app built using Python, is it? I agree that learning type systems can be valuable, and I understand that especially for comp sci, it just has to be covered. Leave that for second year.
Not to disagree so much as to echo an alternate perspective I've seen around which offers an embrace of the dynamic language for teaching CS/programming: A popular language for teaching intro courses used to be Scheme, taught using The Structure and Interpretation of Computer Programming. https://mitpress.mit.edu/sicp/full-text/book/book.html https://imgur.com/1ZGjEDn Scheme is a Lisp, and technically is even quicker to learn and simpler (in many ways) than Python and Java are. With Lisp, a student can learn about custom data types, functions, recursion, data types, etc, without having to worry too much about "magic incantations" like public class MagicNames { public static void main(String[] areFlyingAbout) { } } Variables, for loops, while loops, classes, static (global) variables, etc are all distractions which get in the way of actually learning computer science. With a dynamic language with simple syntax like Lisp, a student can skip the 5-6 weeks of hand waving magic syntax and focus on what programmers and computer scientists _actually_ do. Learning how to represent loops and primitives in formats more recognizable to computer hardware is a great next step, but it's putting the cart in front of the horse a bit to emphasize binary data representations when teaching intro to computer science, and it necessarily defers a student's crystallization of CS/programming as an art. The opposite end of the spectrum, reductio ad absurdum if you will, is to teach intro to programming in C or Assembly instead of Lisp or Python or Java, if you think learning machine typed representations is superior to learning computer science fundamentals. This used to be the case in some places; and there's a healthy value in understanding how the machine sees things; but it's a sophistry to believe that the Java Compiler prevents all bugs from ever occurring because of some more types; and by choosing to spend the first several weeks of a programming course learning obtuse (and arguably dated) syntax like Java's, a student foregoes the chance to focus on more important fundamentals. TL;DR programming is more fundamentally about functions and algorithms than it is making a specific language compiler happy; I assert that most students would be better served with a setup which has less distracting (or no) syntax and more algorithmic depth. 
I agree. If I was starting a degree in CS today and knew very little about programming, I'd want to start in C, because the concepts used by C are the underpinnings of almost every language in use today. Knowing C, or at least understanding it's concepts definitely helps if you're planning on learning several different languages (which you should). 
I am not proficient in Python.
link? i barely just learned async await haha
Nope.
I saw recently that some schools are planning to start with JS. You get dynamic and weak typing, at least with Python you get strong types. But I tend to agree, I appreciate that I learned how to think about types and data structures before too long into my early days (though it was overwhelming at times).
Yea...don't. 
Yeah. That is what I use. Other than saving and loading data.frames from a query or just loading a table I feel that it is just banging out SQL statements. Am I missing something? I can talk just fine to a db in R. I'm struggling finding help with best practices. I can weave a mess of SQL pretty quickly, in my experience. It all works but I'm really screwed with a ton of work if I want to change something -- 
For the most noob level 1 introduction to programming, other than it being old, why is BASIC not used for people to actually learn to think in "computer"; I started it when I was maybe 10-11 years old, for most of the time going to competitions, and it was always very repetitive: Mark has x apples, Mary has y apples, make an app so that when they tell you the numbers, you get the number of all the apples. Fairly simple, but then you tell students that you do not need another variable z = x + y, but you can just write print x+y; simplification of code in a snap! Same lame examples should go for learning operators, conditional statements and loops to actually make people play with the logic, not with the lego bricks someone made for you (in one Java textbook, it says "we use libraries in java to do stuff someone else programmed, how is that of any help to a beginner). Also, syntax, language name says it all.
Ever see a dancer's toes? Dancers might say they have a passion for dance, rather than "Dancing is fun" or "I love to dance". They don't start dancers off doing things that hurt their toes - for lots of reasons, but I think one good reason is to ensure that people have a passion for dance beforehand. Javascript and other languages which are in widespread industry use are the ugly toe-bruising aspects of the profession. If you have a passion for coding, you'll be fine. You'll hate parts of it and bitch and moan and learn languages you *like* but can't really use at work. The toe-bruising parts are not necessary to figure out if you have the passion for coding or not, and in fact if you lead with toe-bruising you lose many people who would. An introductory language should be one most compatible with teaching, with no consideration of industry relevance. 
The redirection makes it more difficult to read
Python is real world and production ready. It's just that Java and C# are more widely used and there is a move to static typing in the world. 
Threads can be interrupted at any time by the operating system, which makes thread safety a bit of a pain. They're also relatively expensive. Windows threads take about 200 us to spin up, which is why so many threading solution build a pool of workers that then run over infinite loops waiting for a broadcast signal to restart. Typically when threading I have one event loop per thread. Learning how to multi-thread properly with context variables is, I think, more complicated than learning asynchronous operations with a single event loop. 
im not sure what you mean by this, i have plenty of declarative asynchronous functions that are called from within code that functions synchronously. i have some asynchronous functions within wrapper functions that merely return promises, that I .then off of. could you elaborate a little more about how synchronous and asynchronous code is incompatible. theres even wrapper functions you can use to tell a piece of code to act synchronously and wait until its done before the program continues in its sequentially written order as opposed to going down a .then branch
I self taught programming but basically Python helps me to develop confident... My programming path is like this: ActionScripts - failed JavaScript - strange DBN by John Maeda - actually very cool must read the DBN, a relic by now Processing - visual but not easy ChucK - interesting but also not easy Python - easy back then but shocked at people using both 2 and 3 but then I use Blender, learn bpy and here things started to make sense Scratch - will only takes you thus far Swift - is actually pretty awesome Wolfram Alpha - strange language but interesting theory Small Basic - is actually very easy Processing should be in Python language... Zed and his Python book helps me.
&gt; T: Hello, here I will teach you how to make Java display the familiar sentence, "Hello World!" &gt; S: Ok, but what's all this stuff at the beginning? &gt; T: Stfu and follow my instructions exactly Being taught introductory stuff in Java is like being programmed to program. You execute without thought or understanding. I switched to Python for my first language since I'm already decent at formal logic and the idea of following a bunch of instructions I don't understand to get an output I don't really care about achieving seemed ugly. Of course the idiosyncrasies of particular languages effect learning subjectively, but I couldn't get past this particular hump and retain interest.
this is what i would agree with, in addition to K900_'s comment. essentially, when i see a function that falls outside of a library i assume that it's bundled-up code from elsewhere in the same codebase. the problem is that sure, it's called list_dir - but is that all it does? there must be a reason that somebody took the time to write a wrapper around os.listdir - does it handle exceptions? does it return a different type of value? etc. etc. all of those are valid reasons to wrap a stdlib function (or even a function in a 3rd-party library) but the wrapper as-defined isn't doing anything differently - so every time i see 'list_dir' in the code there's additional mental overhead required to parse the meaning of what the author intends by using it while gaining no real benefit. edit: i'm aware that the first sentence ('essentially, when i see...') seems to ignore the 'from something import something_else' cases, i just mean as a general rule.
&gt; Let’s just take a look at perhaps the first Java program you’ll write, hello world...Put yourselves in the shoes someone learning to code for the very first time. There’s a lot of scary shit here. If your first exposure to a programming language is in college, you have a lot of catching up to do, especially in this day and age.
I started with C++. I thought it was fine to start with and, as a result of that experience combined with others' insistence that it's a bad thing to start with, think that any language is a fine starting language. The one issue with C++ is that the language has changed in radical ways in the last seven years and so many books and tutorials no longer show how the language should be used. Especially avoid anything claiming C++ is like C: the languages have diverged significantly since 1998 such that a good C++ program no longer looks like a good C program. Edit: reading this, the first paragraph comes off a bit strange. I mean to say that I had a good experience starting with C++ and believe that most people who say it (or any other language) is a bad one to start with are probably parroting back what they've heard others say rather than have had a bad experience starting with it themselves.
It's only stage-1. May see it in ES2018, but I doubt it. People are still using callbacks (judging from stack overflow questions) are just now using/discovering Promises and barely using async-await. https://github.com/tc39/proposals/blob/master/README.md
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [tc39/proposals/.../**README.md** (master → ea9a898)](https://github.com/tc39/proposals/blob/ea9a89826b697d9ce90671354f4256c6c1779824/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmjrvio.)^.
&gt; I can't afford to manually flush every time it writes results, as it'd drastically increase the script runtime, and I really don't want to resort to creating another variable as a counter, as that doesn't seem like a nice solution. That's why it's not flushing each time you write to the buffer. I would suggest you try a network solution instead. Serialize your rows with JSON, send a message to the VM host each time a new row is generated, and have the VM host write to a (buffered) file. I typically use `pyzmq` but you could probably just use `socketserver`. 
Thank you. Wasn't rhetorical, I'm learning Python right now.
Because nobody uses BASIC anymore, and the fact that it has arguably a slightly simpler syntax does not outweigh the ubiquity of all the other possible options, IMHO.
Not sure what you mean by declarative asynchronous functions. All call sites must be modified when you call a function that was previously synchronous and was later modified to be asynchronous. The calls are compatible.
JavaScript is changing really rapidly right now in some pretty fundamental ways. The JS people write today might look very different than it does in a few years, much more so than Java or Python. It's just an intro course though, the purpose of these programs is really not to produce someone who is an expert in one language, but rather someone equipped with the ability to pick up any language pretty easily. When I was in school, the wisdom at the time was to rip out all the Pascal intro courses and replace them with C++ because that was the hottness of the day. In retrospect, I don't really think it made much difference either way. 
Yeah maybe it's not bad to filter people out early... My program was softened up quite a bit over the years and now there are people in their junior year thinking they should switch. 
Makes sense, thanks!
Go is naturally going to have higher peak memory consumption if it's running more concurrent routines simultaneously. The total amount of data is the same, just spread out over a shorter time period. It would be nice to see how a `concurrent.futures.ThreadPoolExecutor` does on a multi-core system. The times involved are on the second range so threads or even processes may be the higher performance solution. 
That's kinda like really loving movies. You love movies so much, you want to watch them all! The classic age, new hollywood, cult hits, cinema verite, not to mention foreign language films...so many classic films to be unearthed...there's so much to see and no time to watch it all. You just have to accept it. Forget about watching every great movie. Watch the great movies you have time to watch and are most intriguing to you at the moment. Don't "Build up a porfolio" of all the movies you've watched so you can be the most knowledgable. Simply watching one movie every other day (instead of, say, 5) will make you very knowledgable quicker than you think. You just have to enjoy what you do and not stress out too much about it, because that will kill your enjoyment. Programming should be fun for you. Don't try to be a master in everything. Just do what's fun and expand when it's comfortable for you. 
Thanks, this will not allow for user input to define password length, though I should be able to work that in. 
When I took my first class, the teacher told us to just ignore the public static void main(String[] args) for now, and just told us that it was the main function and anything we execute starts from there. Later on, after learning about functions and arrays and whatnot, he actually explained to us what all of it means and I think that worked totally fine. However I do see people's point about how it's bad to just ignore how something works until later. 
You are damned to go nowhere as a programmer if this is your mentality. Your desire should be to create, not to acquire knowledge. 
Spinning up a new thread because you want to asynchronously contact an api is terrible. 
Miranda has effectively been replaced by Haskell during the 90s. Why an university would still teach that language 6 years ago is a mystery.
It's really sad to see people who you thought had potential give up in 2 or 3 years, so damn close but they can't seem to crack it. 
Yeah this is just a snippet to show you how it could be. Moreover I'm not a big fan of the input function and prefere to use command line arguments.
I love these discussions about the first language people should learn. My first programming class was FORTRAN. On punch cards. My second was IBM 370 assembler. But do carry on.
Interestingly enough, my father's first lesson for my older sister was on a standard transmission ([7th generation F150](https://cdn04.carsforsale.com/3/706126/12042700/thumb/918130307.jpg)). It was the late 90s and we owned a couple automatic transmission vehicles as well as the truck. Dad was convinced you should learn on a standard because it was more "fundamental." Well, my sister dropped it into 1st gear, got spooked when it lurched forward, stood on the gas pedal, smashed through the garage door and hit my father's car. My sister was traumatized from the experience and so didn't want to get her learner's permit or school permit, instead waiting three years for an official class -- which was taught on an automatic. Four years later my dad chose to teach my twin sister and me on an automatic, even though we still owned the truck. After a year of safe driving, he then started to introduce us to a standard transmission -- by having us mime the motions in the automatic as we drove: "OK, now lift up on the gas... push the clutch in... shift the *(imaginary)* lever... now slowly release the clutch and slowly push on the gas..." and "There's the stop sign... lift up on the gas... push the clutch in and coast a bit... ok now also push on the brakes... good!" Likewise, in college (mechanical engineering) I was introduced to programming via Matlab. I spent a whole year writing my other course's homework assignments in Matlab and then had my research professor slowly introduce me to the concept of pointers, memory allocation, static types, etc.
Static typing is a must. When I was in school, we learned VB. Fortunately, we were forced to turn on explicit typing. 
How about: import csv def process_comment(writer, comment): # Do some stuff, reject dodgy comments (which aren't a lot) writer.writerow({"a": comment.thing, "b": comment.another_thing, "c": comment.more_thing, "d": comment.something_else}) def main(): with open("testfile.csv", "w", buffering=512) as file: writer = csv.DictWriter(file, fieldnames=["a", "b", "c", "d"], lineterminator="\n") writer.writeheader() # PRAW comment grabbing, should be irrelevant to this problem, a few thousand comments come through and all are processed properly. for comment in comments: process_comment(writer, comment) if __name__ == "__main__": main() Also: it's probably going to be more efficient to use the default buffering.
The problem with using Java as an introductory language is that a type system is sorta orthogonal to basic programming concepts like problem solving and algorithm design and teaching those concepts to beginners doesn't involve need for a typing system. How to use a type system can come a long later once you have a basic understanding of programming concepts. Introducing the constraints of a particular languages own type system while also introducing basic programming concepts and usages puts unneeded burden into the learning process. Typing should come later as a separate class and it should use examples from several languages, including static-typed languages ;like Java and Ada as well as dynamic-typed languages like Python and Smalltalk and even weak typed languages like C and Javascript. &lt;rant&gt; I've been developing for 25 years and while I've mostly used dynamic-typed languages like Smalltalk and Python, I've also used static typed languages like Java, C++, Ada and COBOL. I rarely if ever run into issues where the lack of a predefined type specification of some variable or object causes a problem; usually the problem is that the variables if just null when it was expected to have been initialized. Static Typing to me is like a crutch. You are perfectly capable of walking on your own but you use the crutches anyway because you're afraid to fall over in spite of that fact that are are capable of walking. Then again, if you've been using crutches for years, maybe you're legs have atrophied that you can no longer walk well unaided. However the crutches are handcuffed to your hands so you can't get rid of them even if you wanted to. Static types have a place in some segments but for the vast majority of application programming doesn't really need them so introducing them as part of introductory programming is really unnecessary &lt;/rant&gt; 
Thanks for an interesting read. I would personally start with Python but switch after a couple of weeks to Java. The step is not that big and it will be easy if you understand the basic concepts in python. There is not a reason why an introduction course in programming have to stick to one language. Its basically the same concepts anyway the major difference is the echosystem and static typing.
I think with C++ you quickly run into the differences between references and pointers and that devolves into a discussion about what's happening in memory, heap versus stack, etc... and while those are good concepts to understand at some point in the process, they can be a bit overwhelming to a beginner
It's not so bad.
Kotlin also does a good job by allowing functions in the package level, the canonical Hello, World example in Kotlin isn’t much different from Python (minus the addition of the function definition). fun main(args: Array&lt;String&gt;) { println(“Hello, World!”) } I’d personally be happy if Java-the-language went away, the warm up it takes to teach it to a never-programmed-before student is challenging because of the overly rigid OO design and verbosity making the important details less clear.
uhhh what are you talking about? java is still everywhere w/ tons of tooling and even other languages being built on top of it(kotlin) it's just a standard OOP language. don't get so caught up in your love of syntax that you disregard the idea that all languages suck at problems they weren't designed to fix for eg python and multithreading as for whether learning javascript is useful, i don't really think it is. how many people are going to be becoming web developers out of a batch of compsci students? javascript sucks donkey dick at solving any real resource intensive computational problems
Good bot
oh lol thanks edit: looks like this would basically subsume rxjs into official javascript. im looking forward to this!
My understanding of goroutines is limited, but as far as I am aware: Goroutines are much more like threads in the Python model, in that Goroutine switching is handled implicitly by the language, with IO, sleeps, channel operations and sync primitives invoking a switch ([reference](http://blog.nindalf.com/how-goroutines-work/)). The difference between threads is that we switch on this particular subset of operations, rather than any transform. Python, on the otherhand, went for the explicit user-level eventloop + explicit async / await model. I'm not necessarily sure why asyncio went for an explicit keyword to handle invocation of asyncio functions, but I imagine it was designed to make it easier to reason about code (imagine importing some web library, and not knowing if a given function is async-friendly), and make it easier to implement a pluggable event loop and write your own async-friendly objects.
This article is full of weasily language: "Because, here’s the thing.", "There’s a lot of scary shit", "certainly", "straight-up", "actually" etc. And verbose syntax too!
**If you are about to ask a question, please consider r/learnpython or the learn python discord. Homework-style questions will be removed, and you'll be encouraged to post there instead.** Also, add 4 extra spaces before _each_ line of code. It makes your code really hard to read this way. The solution: Pass the variable as an additional argument: TXTNUMBut = Button(mainframe, text="Code", command=lambda: TXTNUMCoded(mainframe, master, v)) - def TXTNUMCoded(mainframe, master, v): (The rest of the lines are unchanged.)
I already know R. I don't use it because it doesn't fit any of my use-cases. But I can see why it is can be useful to other people.
It was terrible. My college was going through a C++ phase when I went through and it was a PITA. We spent *way* too much time trying to figure out the fiddly bits of syntax before getting to the point where we could concentrate on algorithms. Say you’re writing a function to sort a list of strings. In Python, you write `foo = [‘bar’, ...]` then move on to the sorting part. In C++ you’re going to be dealing with STL, declaring your types, figuring out how to pass them to your function, etc. there’s an enormous cognitive overhead before you can start learning the parts you actually care about.
I agree. Java is great as an intro language for people who are going on to become Computer Scientists because of the main reason that some people complain about it - it forces the programmer to be pedantic and verbose. Strong typing teaches new programmers that they have to pay attention to type. The language forces even the simplest program to use OO structures instead of allowing mixed bag like C++ and Python. It's also widely used for Android development, enterprise IT, and in other domains. For a non-CS intro to web programming it could certainly make sense to use JavaScript since that might be the only language the student would ever need to learn. I'd pick Python for a more general purpose intro language, and I think that it can be a better intro than Java when you're starting someone out with basic data structures and flow control. My school actually taught three languages in the intro class which I think was pretty useful because it reinforced the idea of picking the right tool for the job. They even included some functional programming.
ALL the dogmatic languages (Java, Haskell, etc) are bad. They have A Method and you must follow it **no matter what**. It's stupid, harmful and counter-productive. Give me an language that has tools I can opt to use rather than a straitjacket I'm forced to wear.
I was talking about pascal actually :p
I totally disagree. Sure, Java has its problems, but it builds great foundations to move in any other direction. You will learn OOP, a common syntax, how to deal with a type system and many things more... You will be well prepared for most languages out there.
&gt; The opposite end of the spectrum, reductio ad absurdum if you will, is to teach intro to programming in C or Assembly instead of Lisp And that’s why my university did both. First semester had (not conclusive): * INF-DIGISYS: Processor Design and MIPS ASM * INF-PROGR: Racket (a scheme), and simple algorithms
Nice work! Are you planning to follow the API as it evolves in the future?
&gt; do you write a snippet of code that works and make it very efficient No you do not. You write all your code so that it works. If and only if you find a problem you run the profile and timeit modules to find the problem areas and fix them. No professional programmer wastes time, money and effort optimising every code snippet, it's plain daft.
Bad all around, not just as an introductory language. 
Just great, but you expect somebody to help you out. From my perspective there are two chances, zero or none.
Nice, thanks. I may try this.
I'll point you towards [Whoosh](https://pypi.python.org/pypi/Whoosh/) as a pretty full fledged and fast pure Python solution for indexing and searching. An examination of the source might help you to identify optimisations that you could integrate into your own solution. 
I started with Java in college but I think having done projects in C++, Python and Haskell in later courses, and then using C# and TyoeScript in the industry is what helped me become a great programmer. In retrospect I totally sucked at Java back then, and I just knew to ignore certain things like "public static void" and all the other "scary" bits. When those things are optional, I think it's easier to forget they ever exist instead of eventually picking up a curiosity to dig in and find out why they are there and what they do. Maybe I'm biased because I use Java in industry now :-/
Take a look at [dabo](https://dabodev.com/), to quote from the page "Dabo is a 3-tier, cross-platform application development framework, written in Python atop the wxPython GUI toolkit. And while Dabo is designed to create database-centric apps, that is not a requirement. Lots of people are using Dabo for the GUI tools to create apps that have no need to connect to a database at all.". The only reason that it's been held up is waiting for wxPython to support Python 3. Thankfully the full release of [Phoenix](https://wxpython.org/Phoenix/docs/html/) should occur within the next few months as it's all ready at beta 2.
I guess you are right, I will definitely take that into account, do you have any advice in how to get my priorities of learning and how to balance between reading and applying what I am reading? Thanx in advance.
What a garbage article. If you are going to Stanford, it damn well doesn't matter where you start, as long as you understand computation at its core. You should be very competent with technology already if you got into Standford anyway. How many /r/python users graduated from Stanford?
As a beginner you don't write complex programs. That said the benefits of *static typing* just have much less impact as you can hold everything in mind. So this aspect is truly overrated imho when it comes to the *type war* On top if that has many disadvantages over more expressive languages: * verbosity (only feasible with an IDE - which is a no go for noobs) * forced to use a file per class * checked exceptions - you don't understand them but you have to write code to deal with them * bloat for learning the simplest control flows * REPL (Java 9 is not out yet) * separate compile step That said a lot depends on the didactic approach of a course! So the language isn't really the first class citizen there at all.
I've played with pythonista but honestly, I am afraid to make it part of my workflow or make any purchase decisions (such as an ipad) with it. First of all, it is the only app of its kind on the iPad. That means that I am stuck if it changes or goes away. I guess being novel is a blessing and a curse! Second, I am still amazed that Apple allows it in the first place. It seems a bit counter to what they allow in the store, though I admit I am not super up-to-date on app store policies. Finally, to your original question, I do not think you can run python modules unless they are pure python.
I code 95% of the time in Python (the other time spent equally between SQL and R). Had I not learned static typing through C in my first exposure to programming, I think I would be worse off in my current state. I'm definitely not a computer scientist, but generally I think learning C at the outset established such a great foundation for learning other languages. In my line of work, programming in C would be a terrible decision. That's why I use Python - I need to get things done. But knowing some of the stuff you have to deal with explicitly in C helps me to be a better Python programmer.
This is a preview of the API I'd like to provide with true concurrency (e.g. using any event loop backend) — but it's currently using threads. So, it's a prototype. But, a useful one. 
Asynchronous io is fine, the problem is pythons immature API for it. Everytime I use the std library APIs for async, I get buried in side effects because they leak their internals. And where are the books on it? Twisted for me just works, and doing raw sockets in C similarly just works for me.
I think you are missing the point here. These courses aren't trying to teach absolute beginners every construct there is or there can be in a programming language. They are trying to introduce programming to people who may never do programming again after that initial course. Follow up courses can always teach static typing. At that point, someone has made the commitment that they're interested in learning more about programming and so you'd ideally not want to put them off before that.
Which problem should not have existed?
Yes, I'm planning to catch up puppeteer's development.
Don't go to college to learn a programming language. Learn it on your own and you'll be much better prepared for using it in the real world. Don't wait to be hand-fed information, seek it out. That's what you'll be doing every single day as a programmer. It's much more important to learn how to learn than it is to learn the language, which is trivial once you know how to learn it.
My college realized this before I started...back in 2009. Old news.
Thanks, but whoosh is a search engine for text documents. I'm working on an engine for tags associated to multimedia files.
Lovely stuff, I'll keep an eye on it and try to help out. 
Thank you! Contributions are always welcome!
Agreed, if I were to teach an "Intro to CS" course I would definitely start in Python -- I'm not sure where I'd go after that... I'd probably lean towards C++, but that's likely due to my bias with numerical applications. The class I had taken was "Intro to Programming for Engineers", which really meant non-CS students. I still really like Matlab for that purpose as its overall IDE made it easy to learn. Matlab was easy to apply to the kinds of problems I had in my course of study. 
OK thanks. I'll go check that out. 
Having gone through two undergraduate intro courses, one in Java and one in Python, I extremely agree.
The problem with "ignore this for now" parts of a language is until you fully understand them they are just boilerplate. Worse is any errors in that boilerplate you don't understand generate indecipherable compilation or runtime errors. These boilerplate errors completely halt the learning process. It doesn't mean Java can't be an introductory language but it's just often taught terribly in introductory programming courses. 
Why are we executing coffee now? Edit: Now I regret not going for a Java pun.
That seems close to ideal for an intro language, with the main drawback being that it's not widely used.
Yeah, this is what makes it a bit silly as an intro language. I think it also gives students the impression that they're going to have to learn this huge vocabulary of Java functions since even printing to the screen is quite a line. Whereas with a C language or Python you could get down to the actual act of building something. 
Spring adding first class support (you can pick Kotlin as a language when using Spring Initializer), kotlin-only DSL support in WebFlux and Google officially adding it as a supported language for Android mean it will be widely used pretty quickly. There’s really not much reason for a Java shop to switch for the improved developer ergonomics the language brings, especially given IntelliJ will automatically convert Java code into (maybe not idiomatic) Kotlin code when pasted so you don’t even lose the ability to grab snippets from SO and the likes.
From Stanford's description of CS106A: &gt;This introduction to the engineering of computer applications emphasizes modern software engineering principles with a focus on the first three of the four “D’s” of development: Design, Develop, Debug, and Deploy. Source: http://scpd.stanford.edu/search/publicCourseSearchDetails.do?method=load&amp;courseId=11707 It's important to look at the goals of the class when thinking about if Java, JavaScript, or something else is a good tool for teaching. It appears the goal of the class is more along the lines of teaching CS fundamentals, not programming. This suggests that using the most concise tool that has the capability to teach the required concepts is likely a good choice. I'm not saying that JavaScript is that language, but am saying that discussing which language is the best 'first language' is not relavent. Note, I went through this course via EdX a few years ago. The goals of the course line up much more with teaching concepts and much less with teaching skills. 
This story's bunk. Stanford didn't ditch Java: CS106J was a trial run at teaching the same material as CS106A with JavaScript. It doesn't replace the other course at all.
This only works for MIT students, 98% of whom already know an imperative language when they enroll. Most working programmers never become comfortable with recursion, let alone theory driven functional programming. It's an ok approach for the mathematically inclined students, but probably futile outside the top few schools. Algorithms are almost always expressed in untyped stateful pseudocode, not lambda calculus. The simple FP quicksort makes a ton of copies of the data for example, but I guess that's just an implementation detail to people who should be focused on theory instead of binary representations.
I remember my first CS exam : I had to write java code with pencil and paper, ffs!
Dude, thats clearly not a problem in c++, since when declaring vector of strings become a complex task? It will look literally the same as it looks in pythone. vector&lt;string&gt; v = {"str0","str1" }; C++ has its downs, but your post speaks about your personal ignorance more than c++ issues 
Recently, I tutored a friend who was taking a beginner C++ class. One of the things he struggled with was keeping track of the informal meaning of variables and function return types: what is "int salesMax" actually storing? He sometimes used salesMax as if it was a dollar amount, and sometimes as an array index. It made me realize how much experienced programmers make liberal use of the type system, comments, and variable/function naming to signify what *kind* of thing they are dealing with. I'd bet it's a common issue for beginners. For example: - cout is a stream, which you can write to. You can't read from it, print it, add it to something, etc. - An array (in C++) is not a pointer, but you can get its first element and treat it as a pointer if you don't need the length. - open() in Python gets you a file handle, which is an abstraction around doing things to the file. It's not a string of the file contents, though you can use the file handle to get that. Type systems only get you so far: even with my friend, calling his variable an "int" prevented him from thinking it was a salesman's name but didn't prevent him from mixing up two other kinds of things which are both ints. I kind of lean toward "types are useful for beginners" for this reason: because although they're another thing to learn, they can help people organize their thoughts better at all levels.
Yeah I definitely feel that. I just sort of thought about it like "oh if this line is giving me an error I probably accidentally deleted part of public static void main etc". Our teacher did full tell us what that code block DID, just not exactly what each of the words meant. I think that was alright but I can very easily see that being confusing if explained wrong
Stash is indeed what you want. It's pretty amazing. 
Could you explain the three languages in one class part? Which ones did they teach and was it confusing at any point? I though my school's introductory sequence (3 quarters. Java, C++, and C) was a little strange.
The minimum buffer size for text mode seems to be io.DEFAULT_BUFFER_SIZE, so it can't go less than that. If the value is higher it will choose heuristically the next fixed-size chunk that has a higher size than the provided buffer. In any case, you always need to close the file at the end of execution to make sure the buffer is written or in case of a long running execution, just flush() and fsync() the file. f.flush() os.fsync(f.fileno())
Apple will loosen the restrictions for web tools with ios11 so it's probably all good. From what I understand Pythonista should be able to ship with pip after that policy change. 
Totally disagree. Python badly needs some form of type checking to give intelligent error messages when some code expects a tuple but got a list. Major pain points with the tensorflow machine learning library include runtime errors from matrix dimension mismatches, and numeric type mismatches (float32 vs float64). Teaching people to know what their iterator/generator object actually does is critical. And a programming style based on implicit dicts of lists of tuples of ... is error prone and sloppy, and a big part of why most Perl programs are unmaintainable.
That's not even close to being the worst problem with JavaScript as a first language. 
&gt; Stanford Yeah. No one's ever heard of that terrible university. I wonder what shitty web startup JS landing page helped them win the [2005 DARPA prize](http://news.stanford.edu/news/2005/october12/stanleyfinish-100905.html) with [Stanley](https://cs.stanford.edu/group/roadrunner/stanley.html)
My first experience with asyncio was throughh discord.py (I had some twisted experience - IRC) and it was the most beautiful thing ever. When a library sets you up almost conpletely, it's a pleasure to work with. However when almost a year later I tried to get it running on my own for some os subprocesses, I almost gave up and I already understood the corr concepts. The documentation really needs quite a bit of work.
What the fuck is Miranda. In my University they taught scheme (some lisp dialect) as first programming language.
I want this NOW.
In my school they teach Scheme (a dialect of scheme) as first language.
I agree. C# is much better. ;) Python is good, too. :)
Why has it taken so long to settle on a simpler JVM language for interacting with Java? I never hear about groovy anymore and jython seems to be dead.
I don't expect anyone to do anything, I am merely providing information. If there is someone out there who would find this small project interesting, then they might participate. If not, that is fine too.
Skipped right over ASIC, huh?
&gt; I don't think strongly typed languages have too much overhead I think you mean statically typed. (Python is strong, but dynamically typed.)
Fuck Scheme too IMO.
Well, http://www.transcrypt.org/ http://pyjs.org/ But until you can cleanly use them with the big front end frameworks like angular, react, ember, etc... or can you already?
Because it needs to have the benefits of Java (statically typed, fast, easy to use), be 100% compatible with Java in both directions and still have ergonomic improvements to justify using it. Groovy and Scala both suffer from the compatibility story, Scala isn’t easy to use and slow to compile, clojure is the same (it may be easy for someone who knows LISP, but not a Java programmer). Red Hat’s Ceylon project had some promise, but the ergonomics sucked worse than Java IMO. Honestly, Kotlin is the first JVM language that provides real improvements over Java while being easy to pick up and 100% compatible (so you can gradually migrate code), not to mention it guarantees backwards compatibility in the standard library so you aren’t hitting Scala-style dependency hell.
Glad I didn't give up after taking that "intro to programming" class with Java. The worst to teach a newbie with
Async programming seems very easy until you get an async stack trace which tends to consist like 95% of weird continuation gunk and 5% of recognizable code you wrote or called into. It's even more fun when you or a library you depend on deadlocks the event loop.
Clojure was lisp-on-jvm first and Java interaction a distant second. Scala typing slows you down more than Java's. Groovy was actually a decent language and I'm not sure why it wasn't widely adopted. Dynamic or optional typing seems to complement Java better than adding a statically typed language with less verbose syntax. It looks like Kotlin is aiming more at cross platform development than at being a less painful way to write Java-compatible code.
Your definition of "literal" is not one I'm familiar with. And the moment the example grows more complicated than a list of strings, the C++ version's typing overhead quickly becomes substantially less trivial. Example: "good job, class. Now we want to sort a list of (last name, first name) tuples. Have at!" It's likely that the Python version will change to: foo = [('Doe', 'Jane'), ('Smith', 'John'), ('Smith', 'Joe')] and the rest of the program will work precisely as before without changing a single other thing. Again, I contend that Python lets you concentrate on the algorithms - we want to sort something - anything! - instead of getting mired down in expressing exactly what you're wanting to operate on. That's incredibly liberating for new programmers who'd prefer to learn one thing at a time.
Here's a list of things to think about: In python try to use variable names with snake_case instead of camelCase. This follows [PEP8](https://www.python.org/dev/peps/pep-0008/) the major python style guide. People who write code are a little OCD and this guide helps everyone's code look pretty similar so its easier for other people to read. Try using a main to organize everything, this way practically nothing in the file is outside of functions. def main(): password = generatePassword() hashedPassword = hashing() addedSecurity = addedSecurity() thirdLayer = thirdLayer() main() import at the top of the file, itll be easier to organize all the imports import hashlib import random You can rename y to "password_length". More descriptive names &gt; short names if you ever look at the code in the future. The while loop inside of generatePassword() could more simply be a for-loop. for i in range(y): # logic inside the loop (no longer need the x variable) Instead of using temp and temp1, just modify password before you return it. password = "" for i in range(y): # the string password is adding 1 character each time through the loop, # no need to map(str, temp) since theyre already strings. password += random.choice(chrlist) Great work on a complicated problem including using hashlib which I don't know the first clue how it works. Goodluck!
He referenced C++ and Java
Great news! I recently started python; its clean, easy to learn, and the syntax is fairly easy to learn. I know Python is a good language, is C# a good one too?
Using Java to teach introduces students to the idea that there's just certain Magic Incantations you have to perform, without worrying about what they are. Of course, Python hides things under the hood as well, many things - but Java classes explicitly tell you not to worry about them. Plus, Python typically lets you translate your ideas to code much more quickly, and vice versa.
scheme SICP
I can only speak for myself. But for me it's like 90% applying, 10% reading. Maybe higher. Also, program as you read, otherwise you dont retain shit. For the most part youshould only read when yoyre trying to solve a specific ptoblem, or if youare inherently interested in whatever it is. But you should be doing a lot more doing at this point. Make something now.
Even simple threads are _very_ hard to make safe, and they're quite a bit slower. [Raymond Hettinger says it quite well, with a number of examples.](https://www.youtube.com/watch?v=9zinZmE3Ogk)
My state school had us spending a lot of time in Moscow ML. Turns out the FP stuff isn't particularly hard to learn by motivated compsci types, so long as it's made clear that you're _not_ learning another Yet Another Imperative Syntax.
The question is always what are they teaching? Are they teaching "Programming"? then Java is fine. Are they teaching "Computer Science, Algorithms, or Data Structures"? Then there are better languages for learning the fundamentals. Most universities teach programming to churn out monkeys.
Looks like Twisted will dependency to use requests with async? What's the thinking behind this? 
Yes, and they are statically typed. As a counter example, Python is dynamically typed, but generally has a fairly 'strong' type system.
This is what I try to teach my students. College is great for getting the exposure to material, getting some guidance, and having problems to practice from. However, we can only get through so much and the tech industry moves so fast with new algorithms, languages, technologies and standards, and what not. Learning to learn and loving to learn are what's truly needed most.
I've checked the Python source code for `open` and `BufferedWriter` (both the Python versions in `Lib/_pyio.py` and the C versions in `Modules/_io/_iomodule.c` resp. `Modules/io/bufferedio.c`). I couldn't fine any line where Python is messing with the user-specified value for `buffering`. My only guess at this point is that it may be the internal buffer of the hard disc that is causing this behaviour.
This sounds like an excellent 1-2 punch to me. It's good to use a high level language to actually do "real stuff" but it's also good to learn a low level language to grok what's happening under the hood. I started out with C++ and that was awful for me, I wish I had learned C first. There's an implicit historical lesson involved if you learn C before C++. When you see where C++ came from, many of the goals and design decisions in C++ make more sense. After C++, I learned VB, Perl and Java on the job, which helped a lot but I finally picked up Python a few years later and that brought me to a place of "language comfort". That's where I finally realized I could learn any language and that languages (and their ecosystems) can have wildly different niches/use cases. I found C++ much easier to understand and use after learning the above languages. I'm no fan of C++ fwiw but I also wouldn't claim that my experience would work well for others necessarily. There are a lot of places where I would never use Python, but for some tasks: utility scripts, cloud/ops jobs, data parsing, web backends, etc it's fantastic. However, I cannot stand it when people recommend using the "right tool for the job". That is a passive non-answer. There is almost never ONE right tool for any job when it comes to programming languages, tools and frameworks. EDIT: I was a mathematics major in school and I did not do a lot of coding until after I graduated and starting working in the software industry.
They're subject to both the GIL and the event loop, meaning CPU bound work is doubling punishing. With just the GIL, it'll eventually switch. But with an event loop, it grounds to a halt until the task is done. 
Why not in python?
&gt; They're interested in producing shitty web startups They're interested in producing graduates who make money, which isn't evil considering how much those graduates need to pay to attend Stanford. Also, fwiw I like money. Also also, I don't like JavaScript but I won't deny that you can make money using it professionally. :) I've been avoiding it for a while and one of these days, I'll need to take the plunge and really learn nodejs and something like React. Fortunately, you *can* find work that doesn't involve JavaScript.
What's the worst problem in your opinion? BTW, I don't like JavaScript, but I'm curious. 
CS professors aren't really different than other programmers. Some irrationally fall in love with niche languages and don't really look beyond to new pedagogical techniques.
Ooh fancy. That's the problem with professors living the Functional Programming dream. . . there are more practical functional languages to learn. One big problem with academic/research oriented developers - they often times have no deadlines or they have artificial ones. Generally speaking, universities gloss over a LOT of practical skills and knowledge which you need when you develop professionally. It's OK thought, the theory is good to know too. But knowing how to "fix the build" is also good to know. :)
&gt; Async programming seems very easy until you get an async stack trace which tends to consist like 95% of weird continuation gunk and 5% of recognizable code you wrote or called into. Bluebird promises actually generate decent stack traces in dev env.
Really? I would think there are worse than fucking Java of all things. It does OO right, and I definitely took that with me when I started working with Python and PHP.
I was in jr. high by the time I got to C. It was a pain to learn because the internet wasn't a thing yet (only universities had it) and the local library didn't carry any books on "those *new* programming languages". Growing up a computer nerd in a small town sucked back in the 80's. I *wanted* to learn hardware but the available materials were awful.
Make apps for other people. 
async / await are in the language now, and make dealing with promises / async code a lot easier to fathom.
ASIC was a terribly limited version of BASIC that came with a compiler. You couldn't do more than one mathematical operation on a single line, so like A = B + C + D was not possible. But it could make .EXEs.
Once you get pointers, the rest is easy. I'd say it's a good starting point because it forces you to understand how programs really work, as opposed to "it's just magic!".
now they only need to realize that it is bad for everything else too
Just use grequests for feeds, it's amazing :D import grequests def batch_request(urls, size=50): reqs = [grequests.get(url, timeout=3) for url in urls] pages = grequests.map(reqs, exception_handler=lambda request, exception: print(exception), stream=True, size=size) results = [] for page in pages: if page is not None and page.status_code &lt; 300: results.append(page.content) else: results.append(None) return results 
What is that picture ~_~?
Threads are not fine if you want thousands of them constantly being spawned and ending. They are great for doing a handful of ok operations, but something like a server may not be able to afford them when coroutines may be light weight enough.
This is a weird effect related to comparison operator chaining. It works the same way as `2 &lt; x &lt; 5`, so equivalent to `"a" in "abc" and "abc" != True`. To do what you want, add parens: `("a" in "abc") == True`.
Apps for what
Try this: ("a" in "abc") != True --- If you have more questions like this it's better to post them on /r/learnpython. Be sure to [format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) or use a site like pastebin. Also, include which version of python and what OS you are using. 
Whoa. Different kind of ASIC. Yikes. Although my BASIC years were on an IBM PCjr, so I guess that's close enough.
1 == "1" is up there
&gt; Threads are not fine if you want thousands of them constantly being spawned and ending. When you're talking about thousands of threads, you're also not talking about "some network data", you're talking about a shitload of network data. At that point, a solution like asyncio is preferable. However, if that's not the situation you're in, then threads are fine. For example, I wrote a little script that deletes unneeded stuff from my work's artifactory server and used threads for it because that meant I didn't have to install anything outside of the stdlib to get some cheap concurrency.
Stanford 2017 is a lot different from Stanford 2005. That's not the institution's fault, but a lot of the people who go to do CS at Stanford are start up bros. Incidentally, many of the researchers who worked on Stanley etc, are now where? Oh yeah, whoring for VC money in SV.
In general, you shouldn't need to write `x == True`, you can accomplish the same thing more clearly without it, so long as what you're comparing it to is a boolean. if 'a' in 'abc': pass One thing to consider is when you want your value to be a exactly true. 2 == True # True 2 is True # False This also comes into play with `None`: x = [] not x # True, x is empty x is None # False, x is an empty list. The way you have yours written evaluates like this: 'a' in 'abc' == True 'a' in False False 
My school used Eiffel ... never heard of it? I think that was the point. They wanted to use a pure OOP language that would be new to everyone, so they didn't have some students with years of experience fighting new techniques and design ideas, while students with no experience at all struggled to get the basics down. 
Stack trace from a callback is at least straight forward and relatively easy to figure out how the current state was achieved given that only one function runs at a time. A stack trace from a multi-threaded app lacks stack frames from other threads, making it difficult to reason about how you got to the current shared memory state. 
I am trying to imaging teaching basic data structures like linked lists in a language like that, to students who have no experience with lower level languages. Big-O notation would be almost incomprehensible when everything inside the runtime appears to be an opaque single step. Running it independently of the browser ecosystem is hard, which means step one involves a massive level of complexity that a student can't fully understand. (This was always one of my main complaints with Java as a first language. Hello world involves making classes on day one with a bunch of boilerplate magic words and syntax that you don't understand, then what's actually happening is all on some mysterious VM that isn't explained.) It rob's the student of perhaps the most important part of an introductory CS course -- the fact that the machine can be understood, and that understanding can be applied to create new things. When a sense of real understanding isn't available, it just becomes a task of applying code snippets passed down from elders with your fingers crossed.
my school teaches python first. there's a few java centric courses after that, but python is #1
That's an extraordinary claim given that if asked to name the best IDE almost every programmer would cite either one of JetBrains' products or Visual Studio first. What makes RStudio the best IDE?
Good luck learning [the JavaScript Equality table](https://dorey.github.io/JavaScript-Equality-Table/unified/).
I agree that the browser ecosystem is convenient but that gets to the core of my distaste for JavaScript. It's sad that we've endured language lock-in for several decades now. You have no effective alternatives to JavaScript with frontend development. There *was* dear lord, VBscript in ancient versions of IE. There's Dart which restricts you to Chrome. There were other technologies like ActiveX and Java applets but there really is NO viable alternative to JavaScript or something that compiles to JavaScript on the front end. I hope that Web Assembly changes this once and for all. I don't like JavaScript but I don't *hate* it, I just don't like that I have no other choices for coding web front ends.
That's the hard part.
OK great thanks for all the really great info. I'll start working on that now. Not sure I will be able to break the camelCase though, that comes from the PLC programming. 
&gt; it just becomes a task of applying code snippets passed down from elders with your fingers crossed. I have a mind that in a world of magic it would work a lot like that. Wizards understand and create spells, Apprentices just execute the spell snippets verbatim as they are given to them
&gt; Incidentally, many of the researchers who worked on Stanley etc, are now where? Oh yeah, whoring for VC money in SV. Most of them are probably employed at some company doing self driving cars. Uber went in and poached carnegie mellon's entire department.
[removed]
Why don't you just use Go. FTFY
This particular use case has no issues with thread safety. He's downloading content from web sites and storing it in a database. Slower doesn't really seem to be a problem since he's currently doing it sequentially. I maintain that threads are the easiest way to achieve the improvement the OP seeks.
He's just downloading a bunch of stuff and wants to parallelize it. It's what threads are for.
I have a different take on this. Java does not work because it is not accessable to visually impaired programmers and support engineers. I worked at Sun Microsystems Tech Support in 2002 and was asked to read very densely packed logs from a product, netbeans, and could not do my work comfortably because of low acuity vision. (I just had a cataract removed from my one eye and even today I can only see with acuity 20/40) I didn't realize until after leaving Sun in 2004 and after some low vision remedial study that I could not do that job and that in addition that low vision workers need to use zoomed fonts when editing anything. I had grounds to sue Sun under the ADA because they had federal contracts. Oracle Corp. should be aware of this problem now.
Agreed, if you really need heavy duty concurrency, you should just use Go. I love Python but goroutines and channels are way better than any of the half or full-baked alternatives in Python.
https://github.com/requests/requests-threads Coincidence? I think not. :-)
Automating manual / time-consuming tasks for a small-business. 
You’ll have better luck at r/learnpython Add in your code so far, either here or pastebin
The head of that project is now running a MOOC startup. 
Lua for CS 101, Go for CS 201. 
OP? Shop? Plsssss, give us information :(
CS106 used a repackaging of java to give it a more rational interface. That was a huge improvement over what Sun was shipping, and I took Sun's Java courses. As for Python. I have written some python, small projects, and lately I've noticed that the handling of compatible environments is a considerable problem that makes using Python as a first language difficult. It seems that every language I've ever written code with has major pitfalls for new users. Python's package management can easily go awry, and that is a major problem for that language. I recently installed Ubuntu 16.04 and added anaconda on top. That seems to have messed up some Ubuntu tools that use python.
Absolutely and for so many reasons. I'm always kind of amazed by people who rock up to university to do a programming heavy degree and *then* find out what programming is like. That in itself feels like a huge gamble.
What statistical functions is Python missing?
In some sense, that's exactly what we've been building. Even Masters graduates in CS often have surprisingly little real understanding of what a computer does or how it works. The folks who only go through coding bootcamps, you aren't even disappointed that they don't understand the machine. A shockingly large number of people in tech are doing a ton of manual work copying and pasting things without understanding them, working hard enough to keep existing systems going and adding a new check box here and there. Kind of impressed with the systems, but not even really pondering what it would mean to have mastery over them. We are reaching a point where the people who created libc, and ipv4 -- all the foundational technologies -- are starting to get quite old and sadly pass away. New generations are coming into it treating that stuff as technologies that were made by the ancients to stand the test of time that have always been there since time immemorial. But the people who remember when ipv4 got rolled out are surprised that the rest of us never upgraded everything to ipv6 and tossed ipv4 into the dustbin of history.
Yeah, I had FORTRAN IV as my first language and on punch cards too. From them on I used asm, PL/1, PLC, then onto UNIX land, C, perl, C++ and Java. Of course with each itteration I had to relearn basic concepts. I even worked with a guy who didn't have java or C++ yet, but did a small project using function pointers and variable pointers in C to impose some of the same discipline as an OO language. Only later have I earned some lisp and Python, and I like python because the language syntax is pretty simple, no more counting parens or brackets, but lately I feel that I have been burned by environment problems. Python's package management does not seem to be too robust and it would be a pitfall for a novice.
I love Haskell, but I don't think it is a good introduction language. I think an intro class to programming should span two semesters at least, ideally 3. I think C is a good introduction for basic programming because there's few keywords, it works closely to how bare metal works and is a relevant language. Maybe even spend a lesson or two on how it translates to assembly (to understand how bare-metal loops and calls work). After one semester of programming in C after you get the fundamentals of programming right with C (data structures, control loops, conditions, memory management) you then switch to Python to learn more about OOP, dictionaries, modules, advanced data structures. At the end of the course there should be a small intro to functional languages like Haskell to broaden the student's horizon. Maybe even spend one lesson on esoteric languages.
&gt; Running it independently of the browser ecosystem is hard Really, have you ever heard of nodejs? Its actually pretty easy. Not that I think JavaScript is great choice as a first language to teach CS graduates, but it certainly isn't because its a 'browser only' language.
OK, let's see. Say you're representing a zoo in your code. Maybe you're writing Zoo Tycoon II or something. It might make sense to have classes for the animals, because they have state (e.g. hungry/not hungry, a name, a breed, etc) and actions (e.g. eat, make a sound, run, give birth, etc). But for actions that can apply to various things, you can just stick those into a module. Something like this: horse.py: class Horse: hunger = 100 # born hungry name = None def __init__(self, name): self.name = name def speak(self, message=None): print("Neigh") if message: print(message) def eat(self, food="oats", amount=100): if food != "oats": return False if self.hunger == 0: return False self.hunger = max(0, self.hunger - amount) return True def is_hungry(self): return self.hunger &gt; 0 maintenance.py: def water(what, amount=100): for i in range(0, amount): print(".", end="") print() thing = None try: thing = what.name except: thing = "The %s" % what print(thing, "is wet.") zoo.py: import maintenance from horse import Horse if __name__ == "__main__": silver = Horse("Silver") if silver.is_hungry(): silver.eat("oats", 100) maintenance.water("cactus display", 50) maintenance.water("horse enclosure", 50) maintenance.water(silver, 100) Your maintenance.py module can include lots of other actions, like mow the grass, clean the cages, open and close the gates, etc. 
I know how you feel! Web development is a good new angle bull which to approach the problem of introducing programming to people brand new to it because you can almost immediately so more than ugly terminal apps like there were in my Java intro course
You could use pyjamas, which transpires python to JavaScript. Other languages probably have other tools. They are all hardly used (leaky abstraction).
Lucky
I feel that my University really had the right idea. First year is one semester python, second semester is in Java. Java is then used as the primary language for the rest of your University Degree. This means that the intro is in python, which is super accessable. But when you start with real OOP you use java, where I found the rigours helped me implement the concept better. 
The OP is downloading a tiny number of URLs. Everybody here is dissing threads for a completely invalid reason given what the OP is trying to do.
&gt; Processing should be in Python language... http://py.processing.org/
C is good for teaching about how computers work, not so much the theory of computation, something combination of Scheme and Haskell might be decent for that, but I think you'd have to restrict the Haskell to Haskell 98 Python is actually very complex and has a lot of oddities and gotchas, but it could be good as a project language.
&gt; I have a new toy project called Letters from a Feed. It takes blogs (and RSS feeds) of people I think are interesting and compiles them into a custom email newsletter for me. "lightweight" doesn't matter here.
Whatever the person paying you wants. 
# Python FUCK YEAH!!!! 👊
You could make a site where people can upload and share vide... oh wait...
it will be soon
I did some tweaking, and it does not look that bad: import asyncio import aiohttp import contextlib async def fetch(url): async with aiohttp.ClientSession() as session: async with session.get(url) as response: return response, await response.read() def fetch_things(): with contextlib.closing(asyncio.get_event_loop()) as loop: responses = loop.run_until_complete(asyncio.gather( fetch("https://example.com/api/object/1"), fetch("https://example.com/api/object/2"), fetch("https://example.com/api/object/3"), )) print(responses)
&gt; something that compiles to JavaScript Right, that's my point, it's JavaScript no matter what. 
I wish JupyterLab could become release-ready soon. It looks like a promising blend of Jupyter and Rstudio. Some features like separate panes, debugging and non-notebook script editing are still missing from Jupyter notebook. Also I think the R notebook takes a more elegant approach to storing code and outputs than ipynb so that it is super convenient to share the code only or to work with common version controls.
I think the people with the valuable (read: potentially lucrative) insights here are going to keep those cards close to their chests...
Pycharm is really designed to write programs, not used interactively.
Could you elaborate on exactly what you do? I never even thought of movies needing regex...
Learning syntax is about memory, not intelligence. The logic / algorithm design is about intelligence, but also some memory.
I’d still not recommend python. There’s just so much magic that makes it not a good language. Defining variables, data types, proper function returns, logic of string parsing. C good for it all
I use mainly data.table (speed, memory efficiency and "shorter" syntax) and magrittr pipes (I cannot "read" the data.table "piping" with dt[...][...][...][...], pipes make it much more readable imo), but also some pieces of tidyverse, e.g. ggplot2 (obviously), tibbles, recently forcats for some factor and recoding tasks. Last time I checked dt was faster, but it was ages ago and I won't be surprised if dplyr caught up already.
While I agree that Java is a terrible language to teach in or for that matter to program in, JavaScript is NOT the answer. In fact it strikes me as possibly the worse place to put a beginner in computer science. Going this route is a good way for a school to lower the respect its programs have with the public in general.
I use pandas a lot, however its indexing is just so ugly sometimes. You have iloc vs loc vs direct [0], you have to know which takes booleans and which takes name lists, then you have "and" vs &amp;, "not" vs ! vs ~ for conditions, then you have "query" which is nice but different, then you have the confusing multi index, stack, unstack etc., and don't forget how much trouble you have to go through if a column name comes up numerical and you have to rename it to a string in order to select it properly... Python users pride themselves over their culture of doing one task in one way and make that chosen way as easy and intuitive as possible. Pandas is sometimes the opposite of that. That said, there are also aspects of R that I don't really like. Just two examples. The use of "-" and ":" in python makes more sense than in R, at least for me, because I take slices far more often than excluding individual columns (it's not elegant to exclude one particular column in pandas, though). Automatic cycling when doing broadcasted operations is situationally useful but really shouldn't be done by default.
You have done most of the work I have not worked with Pushover, but code and comments make sense in general You just need to implement basic error handling (based on TODO.md). These might help - * [Exception Handling Python Documentation](https://docs.python.org/2/tutorial/errors.html) * [For Mechanize](https://stackoverflow.com/questions/15613733/handling-exceptions-from-urllib2-and-mechanize-in-python) I'll try and help some more when I get more time Good luck!
Maybe [this](https://github.com/python/cpython/blob/f58e6e276849e43d96ba59fecadf5bf8f39f92a9/Modules/_io/fileio.c#L431) is the one...
As far as OO languages go, I hate C++ with a passion, like Java, and love C#.
Another option is [Toga](https://github.com/pybee/toga). Is technically a native toolkit wrapper/bindings for Python. The project is young yet, but it's functional.
*Shhhhh...*
Pascal is actually very good for learning programming, in my humble opinion. Sure, it's limited and mostly useless, but it has one hell of a killer feature: you can actually explain what a variable is. A variable is a named piece of memory containing a value, the type of the variable says how much memory that is and how those raw bytes are interpreted. Integer is 4 bytes, containing an integer, encoded such and such. String[10] is 11 bytes containing the length plus 10 bytes for contents. Variables are things that store values, always. A Record stores what it says on the label. There are pointers but they are explicitly variables that store an address of some other variable or wow a heap-allocated object, which is like a nameless variable but otherwise just like the usual thing. But most importantly you get to discussing pointers after you've explained global variables and then local-to-function variables and parameters, and each step didn't require you to say that it would make sense some time later, each step was entirely self-contained and understandable as such. C is much more promiscuous with that for the sake of convenience, and Python could be outright incomprehensible to someone just getting into programming. You can't present a self-consistent explanation of what Python variables are and why x = [1] y = x x += [2] print(y) is different from x = 1 y = x x += 2 print(y) Like, you really can't, you can only handwave it away saying that at some later time we'll teach you C and then you'll understand how this shit _really_ works, for now just rote memorize this. Pascal is unfortunately basically the only language that doesn't require this sort of handwaving and also is reasonably close to the actual hardware rather than being something like Lisp derivatives.
Actually in many commonly used packages, I found R to be actually more consistent API-wise than Python. Everyone overloads "head", "print", "summary" etc. Everyone uses the same formula format. Everyone recognises dataframes. Everyone interfaces with ggplot. Some vanilla R functions are pretty bad though - just look at the various *.test functions that do entirely different things if you pass it data in different formats and it is extremely frustrating to figure out what it is actually testing.
Going the C++ route (assuming modern C++) is not that bad of an idea. Frankly the language is vastly improved and today is to far away from C to be taught as a follow on language to C. If you are going to go C++ the program really needs to start with it right away. Now not to date myself but my first comp-sci classes where taught in Modula 2. Modula 2 was certainly an interesting language and maybe even a good one for education but it has zero application in the "real world". This is where I think colleges make their biggest sin with respect to comp-sci education, that is choosing languages with limited applicability outside of academics. Modula 2, Lisp, Smalltalk and other marginal languages just don't have the standing to justify use as a teaching tool. You really need a language that has at least some industry acceptance but yet is suitable for helping students developer a deeper understanding of programming concepts. In this regard C++ isn't really that bad. Now the question is what language would you choose that is forward looking and likely to be around for awhile. These days languages like Swift, Rust, Go and a few others have the potential to lead the industry into the future. The problems choosing one today, might leave you in the same situation that Moudla 2 left people. As or the interpreted world Python is the only real choice there. However I see it as a terrible place to try to teach students the basics of data structures, memory organization, and other low level details it glosses over. Like suggested above it is ideal for learning in parallel.
/r/datasets might appreciate this 
/r/learnpython An easy way would be saving/loading a dictionary using the ```json``` module. https://www.safaribooksonline.com/library/view/python-cookbook-3rd/9781449357337/ch06s02.html
Ins't this how any non trivial engineering subject is handled? I mean an engineer learning about hydraulics doesn't dive into valve design right at the beginning. Rather he accepts that a valve turns things on and off. The same thing applies to an electrical engineer using a SSD switch, the idea that it turns current flow on and off is top level, understanding the physics behind that functionality takes a bit more educational time (math, physics and engineering classes).
I thought MIT gave up on Scheme? Maybe it was another school but Scheme is no place to be teaching students. The problem is the limited demand outside of education.
Looks like a picture of solar eclipse taken through the eclipse glasses.
That doesn't solve what I'm talking about above - it cleans up your flow of promises. Your typical backend application benefits in terms of complexity and readability from the async/await conventions because of how the data from multiple sources typically has to work together. With promises or observables you either need to declare variables used in multiple promise resolutions in a scope outside of your then/catch methods, create ugly Promise.all arrays to pass them along, or do something equally kludgy, that's why node really needed async/await.
The easiest thing to do would be to tell him to install python. If he is on Linux or Mac then he already has python2, and you can just send him your .py file. If you really want to make a .exe you need to use [one of these tools](http://docs.python-guide.org/en/latest/shipping/freezing/) to "freeze" your python code. You should note that unlike other ("compiled") languages, this is not something that python was designed to do. Python is a scripting language, and was designed for the .py files to be distributed. --- If you have more questions like this it's better to post them on /r/learnpython. Be sure to [format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) or use a site like pastebin. Also, include which version of python and what OS you are using. 
I execute (and excrete) coffee all day long! 
I'm still waiting for "Python Design Patterns 2".
Man do I completely understand this post! It wasn't much better when I finally got to college, they where using Modula2 in the first couple of quarters. However I do understand the problem that colleges have now teaching programming as the industry changes pretty fast. OOP use to be The Thing, but today there are many other techniques vying for supremacy. Frankly we don't have a language yet that has the mind set behind it to be the next 20 year solution. This is why I'd rather see the use of C++ in colleges for the introductory programming classes. It is an easy place to expose students to a number of idea. We could all hope for a more modern language but the question is which one. If chosen will it remain viable for a reasonable amount of time.
What do you think about Raymond answer ? https://stackoverflow.com/a/46041582/8412223 The last idea is just as K900_ said.
I'm learning Python! :)
How is that different from WebAssembly being transpiled to.
The course went over: - Prolog for an intro to functional programming and recursion (actually it was a slightly enhanced prolog variant). - C for memory management, basic data structures, flow control, loops, etc. - C++ for an intro to OO concepts and packaging larger pieces of software. A few years after I took it they replaced C++ with Java. My school's CS curriculum was focused on learning theory over teaching particular languages. Note that this was the intro for CS majors. They used C++ for their general intro to programming course and then later replaced that with Java (which I assume they are still using).
You'd be surprised how many tech people end up getting obsessed with education after setting themselves up for life. You'd be less surprised with how few of them actually end up making a notable difference. 
C++ is perhaps the best compromise we have at the moment. As you point out it is a radically different language then what was popular in the early days. It is also standardized so there is a reasonable expectation as to what various implementations will do. I really never understood the idea that C++ was a terrible teaching language. If comp-sci classes are like anything I took all those years ago you still start out with the simple things first. Things that are very easy to deal with in C++. Three years down the line C++ is still capable of exposing students to advanced concepts and patterns. Industry acceptance, along with standardization makes C++ one fo the better choices at this point in time. That will likely remain true until another language comes along that is well standardized and accepted by industry.
So what I do right *now* is rest ... I'm taking a break from VFX. It can be an exhausting world. But when I work I'm what's known as a pipeline engineer, or sometimes manager of pipeline engineers, or sometimes technical director, it all depends. Basically, though, what I do is automate the movement of **assets** (script notes, original camera footage, special effects elements, look development artwork, editorial cut lists, motion capture data, camera tracking data, 3D model, rigs, textures, and animations, 2d renders, final composites, and about a half million other things) through the enormous series of *artists* who take those assets, make more assets, and then publish them back into the pipe, right up until the movie gets released. You have to understand that your average movie these days is 2 hours x 60 minutes / hour x 60 seconds / minute x anywhere from 24-3200 frames per second x 2 independent stereo eyes @ generally at least 4K if not 16K resolution, 4:4:4 color depth full float EXRs, with between 1200-2500 shots per movie x on average about 100 versions per element per shot. We move petabytes of data through render farms that are basically supercomputers, with databases full of ludicrously interconnected dependencies between files, almost all of which is ultimately expressed on disk in poorly-documented formats that allow arbitrary metadata to be incorporated from any number of automated and manual sources. And some *bastard* somewhere types the Director's wife/mistress's name wrong. Regex to the rescue.
Exactly! It is of value even if the student spends the rest of his life writing programs in Python. People seem to miss that there is more to comp-sci than just teaching a programming language. A well rounded student should know what is going on inside the computer. Besides if the student can't grasp pointers is there really any sense in giving him a 4 year degree? I don't mean to be that angry guy but there ought to be a standard of achievement when a degree is handed over to one. If you can't grasp pointers do you really deserve a 4 year comp-sci degree?
Wow! PL/1. I haven't heard that in ages. I note that Pascal has receded from view. Along with Modulo-2.
If you Google for information about JavaScript, much of what you find will be talking about how to do stuff in a browser, which will be confusing to anybody who is just starting their first programming course taught with Node JS. Separating the Browser ecosystem from the actual JavaScript language form the Node JS specific API's is going to be completely nonobvious to somebody getting started. And even without doing a web page, the NodeJS ecosystem is still quite complicated. The Hello World example on the Node JS website has you set up an HTTP server and access it from a Browser. So there are still a ton of moving parts that you can be taught to use, but writing Hello World still doesn't tell you anything about how to create those very complicated parts. If you do learn the Node JS API, that won't be applicable in the browser. You were told that you were learning a really popular language that is used in web page front end development, and the popularity was a factor in why you were taught that language first. But the skill isn't directly portable if you do decouple JavaScript form the browser ecosystem.
I've interviewed people with degrees who couldn't write a simple for-loop. I wish I was making that up.
&gt; OOP use to be The Thing *Strict* OOP used to be The Thing. I work with people *today* who think it's still *the thing*. They overcomplicate tasks like you wouldn't believe. I find myself using OOP, regular imperitave, and functional-like paradigms in C++ depending on context. To pick exactly one thing and say "this! this is the one and only approach to the exclusion of all else that will save us!" is to write bad, *bad* code.
Actually you aren't concentrating on anything with Python. What you have is a language and library that does much for you. this makes it a good place for productive programmers to get work done. It is however a terrible place to learn the nuances of programming and how the machines work. This lack of understanding of the "machine" can really impact a programmers viability over the long term. He ends up wedded to a language and thus ends up inflexible and frankly quickly grows outdated. In a nut shell a comp-sci program can't be simply about learning the easiest language available. The idea is to graduate well rounded technologist with a broad understanding of their little niche in this world of technology. 
These answers aren't great. If he doesn't have python, asnaconda python is easy to Install. For an exe, define an entry point in setuptools. If you aren't famiar with setuptools, there are details that we're skipped because you will obviously have to do some reading on setuptools. It is however, the right way to do distribution, dependencies and entry points. Python distribution doesn't have to be difficult but the documentation around is all geared towards beginners and usually has no relationship to reality (and most authors wouldn't know what python distribution reality is anyway). I might have to write something myself to add to confusion I guess. At any rate, installing python is the same thing you do for installing Java for running Java apps, it's just more people are used to having Java installed.
This highlights the difference between school and the work worlds. In the work world you try to choose the best tool for the job. This is true if you are a programmer, machinist, accountant or oil rig worker. The tools used for teaching have different goals or should have. This might be shocking to some but have you ever ran into somebody working as a programmer that can't tell you how many bytes are in a 32 bit word. It happens and is the result of overly focused training that graduates people with very focused (too focused) skills sets. I just see comp-sci having more to it than a program too learn a programming language. That has to guide language selection.
they should put it back to c so we can get all these post-modernists out of tech. the levels of abstraction with higher level languages have gotten out of hand.
Alas, it's a one of a kind, folks--but when I get a chance I will look at digging up and scanning the pattern / posting info so that you could take it to your local skilled fabrics practitioner...
You don't need ugly Promise.all calls with observables you can just flatMap or flatten them Generally you don't use runtime errors in functional style programming with observables
This makes sense. Python was invented to be a prototype language for C developers. That way less time is spent coding simple concepts before you know if they work or not. 
OK so i've been trying to work on your suggestions and i have hit a bit of a wall. I don't seem to be able to get the password generation working without the temp list. It simply stops at 1 character then goes onto the hashing. Also now i have defined the main loop i am unable to cycle through the methods without performing a print for each section. Any ideas?? https://pastebin.com/mTx1zdRh
MIT taught SICP and Scheme for a few decades. Its students were not considered unprepared. Algorithms and hardware are vastly different concepts. We need to know both of those things, but it’s not necessarily a good idea to try to learn them simultaneously. I wouldn't do hardware interfacing in Python, but neither do I want to study red black trees in assembler. I could do either if I had to but I wouldn’t recommend it.
Ada would make that guy's head explode... or be incredibly helpful, maybe.
That is really bad but I believe you 100%. I've seem some strange thing done by people looking for work. In any event I really don't get this desire on some universities to gloss over requirements and expectations. It looks like they are just trying to make it easy to give students access to a degree with minimal effort on their part. In any event the concept of a pointer to me is simpler than the concept of a FOR loop or any loop for that matter. Watering down a comp-sci program so the students don't have to grasp these simple concepts just blows my mind.
&gt;Most working programmers never become comfortable with recursion, let alone theory driven functional programming. It's an ok approach for the mathematically inclined students, but probably futile outside the top few schools. A CS program should not cater that heavily to what "most working programmers" do and can in my opinion. Computer science programs first and foremost produce computer scientists not programmers. Also I think you are underestimating students. How come pretty much every single university manages to produces mathematics graduates every year if mathematical thought is so hard that it is futile to teach outside of a few top schools? &gt;Algorithms are almost always expressed in untyped stateful pseudocode, not lambda calculus. The simple FP quicksort makes a ton of copies of the data for example, but I guess that's just an implementation detail to people who should be focused on theory instead of binary representations. You can mutate stuff in scheme, lisp and even a pure functional languages like Haskell allows you to implement an algorithm that is pure "from the outside" but internally mutates state for efficiency reasons.
Not for the issues I'm talking about. Here is a fairly simple example, showing the initial issue and a few ways to solve it. There are more ways, I'm sure, but I doubt any are as applicable as async/await here. // Contrived example where async functions require results from other async functions up the `.then()` chain. // 1. Gets user associated with request // 2. Gets some sort of object of the user related to the request parameters // 3. Creates some new related object, which requires user and the initial object we fetched // This example will fail, user is undefined. app.get('/', (request, response) =&gt; { fetchPrimaryUser(request) .then(user =&gt; database.filter(user, request.params).get()) .then(importantObject =&gt; createRelatedObject(user, importantObject)) .then(() =&gt; response.send(`Related object created for user ${user.id}!`)) }) // Here we create an undefined user in the scope of the parent function app.get('/', (request, response) =&gt; { var user; fetchPrimaryUser(request) .then(userObj =&gt; { user = userObj return database.filter(user, request.params).get() }) .then(importantObject =&gt; createRelatedObject(user, importantObject)) .then(() =&gt; response.send(`Related object created for user ${user.id}!`)) }) // Here we user `Promise.all` to return the user, // and would have to continue doing that all the way down for functions that need the user. app.get('/', (request, response) =&gt; { fetchPrimaryUser(request) .then(user =&gt; { return Promise.all([user, database.filter(user, request.params).get()]) }) .then((user, importantObject) =&gt; { return Promise.all([user, createRelatedObject(user, importantObject)]) }) .then(user =&gt; response.send(`Related object created for user ${user.id}!`)) }) // Utilizing async/await, the code is much cleaner, easier to read, and effectively makes // the function operate synchronously. app.get('/', async (request, response) =&gt; { const user = await fetchPrimaryUser(request) const importantObject = await database.filter(user, request.params).get() await createRelatedObject(user, importantObject)) response.send(`Related object created for user ${user.id}!`)) }) There may be some syntax or otherwise issues above, but none that should compromise the concepts or patterns being illustrated. 
Interesting. You probably know you can save the environment spec using `conda env export` for future re-creation. If you really need to be explicit, you can run `conda list --explict` which is of course brittle because it locks each package down to a URL, but you might want that brittleness. (What i mean is, you can save and reproduce your environments and then archive them if you are low on disk space. not that any of that saves you space by itself)
Uh oh. Here come the Java heads brandishing pitchforks and IDEs.
`FileIO.blksize` should only affect the buffer size if the user does not specify a specific one.
Oh sure, I would use threads for this in a heartbeat. I thought you were looking for arguments to use an alternative, though.
Please also checkout the awesome parso logo in the docs: https://parso.readthedocs.io/en/latest/
id say put a space before == also you can solve the capitalisation problem by using .lower on the input and only looking for the lower case version in the if, you may need to put the program in a while loop to allow it to work if you get it wrong then put in a valid answer. also variables shouldnt start with a capital. e.g Wilson_to_do should be wilson_to_do
Even though they did, it does not mean that it isn't the pedagogically correct approach to teaching programming concepts. Python arguably has as many Lisp influences as it does C/Java influences, in that it permits/encourages programming in the root namespace, using a REPL, etc.
Try something like this password = "" for i in range(passwordLength): password += random.choice(chrlist) return password basically each iteration of the for loop your password gets 1 character longer (+= is just shorthand for password = password + random.choice(chrlist) To help you debug and see what's happening you can print(password) at the end of each loop.
Wait, it is? Why? Python is good but IMO C-style languages like Java are better for introductory programming.
I know, but I mean years ago. And Shiffman should wrote books on it. Now he is doing it in Java for web... confusing.
For the last point you can refer to [PEP8](https://www.python.org/dev/peps/pep-0008/), a set of conventions that have almost become laws.
Stanford offers CS106A, CS106B, CS106J, and CS106X. A is in Java, B and X are in C++, and J is in javascript. J is primarily aimed at people who want to try out and explore the realm of computer science, which is heavily encouraged by the faculty. Something like a quarter to a half of each incoming class takes one of these; the introduction of CS106J was partially to avoid 300+ student CS106A classes.
The one thing you don't need when introducing people into development is challenging things. Besides, the one thing you don't need when working developing software is challenging things. And the one thing you don't need in a CS course is challenging things that are only challenging because you can't improve them.
Very fair point. I don't work in software development, necessarily, so I think I can get away with not knowing (admittedly) a lot of the lower-level, pure-CS topics related to programming. I see programming very much as a means to an end - a means through which I really enjoy traveling. I wouldn't trust myself as a software developer; I was an Economics major, FFS! That being said, there's a difference between simply using something simply as a means to an end - meaning the abuse of the language and ignorance of its best qualities - and toeing the line between, for example, coding something in Assembly for absolute clarity and control as to what's happening. Throughout my four years' programming in Python, and from being very active on StackOverflow, answering questions, I've developed a much better understanding of the power of Python and the ways in which it was "intelligently" designed.... Different strokes!
You are basically defining the same thing over and over again; a pet with its 'manual'. If you have to define the same 'object' over and over again, you should use a class. A class is a blueprint for an object. If you were to create a class for your pets, you could easily add many pets without having to type the whole variable assignment etc. Especially if you were to add more functionality to them, classes are really your only option.
The writters of the article are being extremely misleading.. the CS106 classes are offered in four variants: Java, Javascript, C++, and accelerated C++. CS106J didn't replace any class, it is a new class entirely, primarily aimed at students who just want to see what it is like to even do any sort of work with a programming language. A up-and-coming tradition at Stanford is for all students to take at least one of the CS106s before they graduate.
I think it is important to realize that introductory programming has absolutely nothing to do with what we everyday programmers find good or bad about a language. Javascript seems like an absolutely perfect intro language for tons of reasons: - Simple syntax: Way fewer rules to learn than even python (gasp!) since you basically only have numbers, strings, objects, and list-/array-abominations (yes I hate JS too) - No boilerplate: This really remains true even after an intro class; due to the nature of where JS is used, you generally don't need any 'extra' code. The professor is never put in a position where they need to say 'and just type this so the program works' - Immediate application: if you know JS, you can run it in your browser. Pretty cool! - Easy visual projects: There are lots of simplified libraries for JS meant to help people program visual elements without having to really 'understand' what is happening in the background. 
&gt; ...I find that Java, as unforgiving as it can be, ensures that your logic is entirely sound... I want to point out this is a sophistry. Programs in Java still have bugs; and by definition, those bugs passed the type checker. Declaring and checking the types eliminates _some classes of type-related bugs_, but does not guarantee your code is correct (wouldn't that be nice). Although it can be more work to lock down a Python program than the equivalent Python program, it is also far more work to "open up" a Java program to flexibility and sensibility than the corresponding Python program.
I think all comp-sci students should start with a year of ASM. Maybe not x86, but some sane, simple architecture. Really demystify what the computer is doing at the most basic software level.
Where are you from? 
I think Java is fine but I think they should be teaching students various concepts in different languages more as a rule. OOP class can use Java or C++, OS fundamentals can use C, a web dev class could use Python or Ruby, more math oriented classes can use R, matlab or python and statistics could use R, matlab or Python. Students should know how to learn the basics in 2 weeks enough to solve the sorts of problems they'll face in class. They're not making full fledged applications. They're making prototypes that do some calculations for the most part. They don't need to learn how to package them, the best patterns, etc. They can get a running start in the first two weeks just fine. That gives them a taste of what they might find in the real world and teach them what they'll have the most fun with. Inevitably they'll run into a language they love and want to work with more, and they'll be able to use it plenty by the time they graduate. OOP in Java/C++/Python... it doesn't matter. You might not use it much as a python dev, but you can certainly show the java patterns if you want. If the professor just wants you to show that you can implement a pattern, whatever language works. Some java OOP patterns might not make much sense in Python but you can still do it.
At an introductory course, you want the language to get out of the way so the students can learn programming. That said, most of the C++ complexity is optional, and it does make passing values as reference easier than C. Thus, as long as you use it as a "C with reference parameters", it may work. Personally, the first language teach in my undergrad was Pascal. It worked reasonably well, but you do not want to teach them to non CS students. I have participated in an intro to algorithms course for engineers (not computer engineering) students using C, I do think the language choice was harmful and Python would be better.
There are many type systems that would have prevented him from mixing money and indexes. Even Python's Decimals would have done so. Type systems get you very, very far. It's the C type system that doesn't.
Pickle
Thanks. Yes, I've started to do that. I can now check if a league isn't public (and exit the function). Also I can check the pushover status code in case there was an error. Thanks for those links. 
I agree with all of this. I first started thinking about the problem seriously with an old Joel Spolsky blog post, [Make Wrong Code Look Wrong](https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/), where he talks about using naming conventions to differentiate unsafe from safe strings, row numbers from column numbers, etc. because the type system didn't really support that. I'm still trying to get a grasp on the Modern Industry Wisdom about this stuff.
Yeah, java is fugly and I watched it cause a dozen students to drop and switch majors after only a couple of weeks. These were folks that were smart enough and should have stuck it out too. Couple this with an arrogant teacher and we have the recipe for a hell class for first-years.
BTW, Pushover is pretty easy to work with. Code: import requests user_key = '' # 30 character user key api_token = '' # 30 character App API title = 'Title' # message title message = 'Test message' # message to send pushover_data = [ ('token', api_token), ('user', user_key), ('title', title), ('html', '1'), ('message', message), ] r = requests.post('https://api.pushover.net/1/messages.json', data=pushover_data) print 'User Key : ' + user_key print 'API Token : ' + api_token print 'Title : ' + title print 'Message : ' + message print 'Status Code: ' + str(r.status_code)
thank you. I wasn't even aware of classes 
Thanks. Will review and use what I can.
Haven't heard of that one. Thanks!
Discovered that a bit later. :) I very much appreciate Gtk. I'm pretty sure sublime was built with C++/Gtk.
Probably python 2 support. 
True. I'm focussing most on web development. My goal is to learn how to create really customizable, great looking GUI applications. So many web developers are going to Electron because it uses familiar technologies and it's quite easy to create beautiful interfaces. However, I'm not a fan of Electron because it's a bit of an inefficient CPU hog, IMO.
What I'm concerned with is that Tk GUIs are known to look a bit dated and unattractive. Do you know if it's possible to really tweak a Tkinter app to look exactly how I want it to look? 
Who said it was a problem? 
Sorry to sound like a complete newb here, but when would you subclass a button? Does that mean if, for example, if you want to customize the button with a custom border/background/font, you would subclass it to make your changes? 
Have you seen https://pypi.python.org/pypi/txaio lets users provide their own future implementation
Not a fan of Electron. I must admit that its creation has allowed developers to create beautiful software with great looking interfaces, but Electron apps just tend to be so heavy weight and inefficient. My favorite article on the topic: [Electron is flash for the desktop](https://josephg.com/blog/electron-is-flash-for-the-desktop/)
How is this book compared to Learning Python 5E? I'm considering one between two to read. Python Crash Course seems to be my choice because of short length, i dont have much time. However i'm afraid i would miss something important.
After several years of C++, I decided I would give Java a chance, was turned off by the ridiculously verbose syntax (among other things) but was immediately referred to as, "not a programmer" when I asked if it were possible to forward declare something along the lines of a using declaration to reduce the typing tedium, because, "you have to type a lot." I love C++. I understand the criticism, and agree that even modern C++ has a ways to go, but at least if all I want to do is print, "Hello world" I can do so without public class void static String System.out.printf() % pow("Hello", 2.0) main() whatever.
SQL and relational databases are a pretty huge topic to condense into a single cheat sheet unless you want something really trivial. Or if you do it's either a four-page four-statement syntax reference that doesn't explain the options (ex: wait, what? CREATE TABLE AS (CTAS) doesn't by default include indexes or constraints!?!?), or it uses poster-sized sheets (cool! wait, hmm, where can I put this?!?). You can't even effectively condense SQLAlchemy into a cheat sheet, and that's just an optional set of convenience layers between an application and a relational database. 
That's pretty dope
yep
&gt; Nobody uses async await anymore ...one day this will turn into "nobody uses computers anymore," and we'll finally be free.
Ha ha, I'm probably not as old as you are but I'm not too far behind. I agree that newer versions of C++ are better but I still argue that it makes sense to learn C first. Along those lines, I'd actually argue that it makes sense to learn bash before learning Python or Ruby. Bash and C were both replaced by Perl for many use cases and Perl, like it or not, has lost favor to Python and other languages like Ruby and PHP. I now know that if I had learned bash first, Perl would have made more sense to me. . . I'm not sure ALL of Perl makes sense to anyone except Larry Wall. :) I think Python is a safe bet for the time being, as a practical language but you're right, Go, Swift, Rust (I'd include Kotlin too) might be an excellent 3rd language to learn, after C and Python. It's not a bad idea to throw in a functional language or two, along the way, something like Haskell or Clojure seem like good modern choices.
I'm just wondering why op is trying and failing to use something complicated like async when threads are almost a textbook solution for his use case.
*user was banned from /r/Python* ^^^read ^^^the ^^^glossary ^^^blasphemer ^^^:p
I WILL BUY FOR 1,000,000,000,000,000,000.00000000...9 bitcoin
Yes, I fully agree!
Javascript is a pretty good choice. I think Go is already a great choice, if you're looking for something more server-side with some pointer mechanics and a type system.
Pickle is a terrible choice. Pickling a file means that when you unpickle it, your class structure must be the same. So you're locked into keeping your classes the same between versions.
?? r[P] would just be P. As I understand your description, your code wouldn't do anything. 
Then you can leverage Python :) PyQt is nice... but you can also do game-alike app too - like https://renpy.org
`("a" in "abc") == True` # evaluates to True There's something strange happening when you don't use parentheses, but I'm not sure what. The answer likely lies in here somewhere: def myfunc(): res = 'a' in 'abc' == True print(res) # prints False def myfunc2(): res = ('a' in 'abc') == True print(res) # prints True Compare the correct case: In [22]: dis.dis(myfunc2) 2 0 LOAD_CONST 1 ('a') 3 LOAD_CONST 2 ('abc') 6 COMPARE_OP 6 (in) 9 LOAD_CONST 3 (True) 12 COMPARE_OP 2 (==) 15 STORE_FAST 0 (res) With the strange case: In [20]: dis.dis(myfunc) 2 0 LOAD_CONST 1 ('a') 3 LOAD_CONST 2 ('abc') 6 DUP_TOP 7 ROT_THREE 8 COMPARE_OP 6 (in) 11 JUMP_IF_FALSE_OR_POP 23 14 LOAD_CONST 3 (True) 17 COMPARE_OP 2 (==) 20 JUMP_FORWARD 2 (to 25) &gt;&gt; 23 ROT_TWO 24 POP_TOP &gt;&gt; 25 STORE_FAST 0 (res) 
What have you done so far? From their websites, it doesn't seem easy to scrape using just requests. Also, post this in /r/learnpython. This is not the right sub for such questions. Edit: a word. 
Seems to meet that a higher level scripting language would be wore appropriate for beginners and then move to lower level languages as needed.
I've got both, but am making my way through Crash Course first. I can see Learning Python 5E being very useful after finishing Crash Course. So far I've found it easy following other folk's code. I can afford to take my time and delve into Learning Python 5E if I want to go a bit deeper. One thing I find a bit frustrating about Learning Python 5E is the that most topics are covered in both 2.7 and 3.X. I know that knowing 2.X is valuable when supporting legacy code, but it slowed my progress through the book. 
Obviously broken code still runs and sometimes produces the value the user expects. And code that might look like it should work to a student will fail in a non obvious way, but the failure won't be caught until it's in a seemingly unrelated part of the code base. Errors are often nonlocal. Rust doesn't give you enough rope to tie a wrench to a car handle. C gives you just enough rope to hang yourself. JavaScript is the ultimate fountain of rope, giving you rope when you want twine, giving you rope when you want a wrench, giving you rope when you're trying to get rid of some of your fucking rope. JavaScript is Clippy sitting in your IDE saying, "It looks like you're trying to hang yourself, would you like some rope?" when you're trying to hammer a nail in a wall on which you want to hang a picture. JavaScript is the grey goo of programming languages, swallowing the fucking world in rope when you just want to know whether two variables have the same value.
When your script goes into the else clause, it asks for input and then does nothing with it. Maybe you should enclose the ifs and elifs in a `while` loop.
r[P] would output 16 or 16th in the array if I count correctly.
OH, you just want the index. Strings have an `index` method you can use to do that. r=" ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" i=input ('Enter a message:') for inputi in i: print ('Current Letter :', r.index(inputi.upper())) --- If you have more questions like this it's better to post them on /r/learnpython. Be sure to [format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) or use a site like pastebin. Also, include which version of python and what OS you are using. 
The language has been standardized for near 20 years now but even if it wasn't I don't think that matters in terms of whether it's a good first language. I think your point that you can use it to teach both the basic as well as the advanced concepts are what's really important. But I think you can get that effectively with any language.
Pycharm.
Use vim
&gt; There's Dart which restricts you to Chrome. Dart isn't perfect, but this isn't actually true. Source: I work on a very large Dart code base that runs on IE11, Edge, FF, Safari, and Chrome. Edit: Added Edge. Everyone always forgets about Edge!
Code folding and autocomplete are extremely basic, nearly every code editor or IDE has that. Do you know what an "IDE" is? It's a big bloated program that tries to do as much of your work for you as it can. For a beginner this can be very confusing because you don't understand what the IDE is doing. For beginners, I always recommend you use a simple code-oriented text editor and the terminal. Sublime Text is probably the most popular (not free, but practically). Other good options are Notepad++ (Windows only), Geany or Atom. Personally, I like Geany. If you really want to use an IDE Pycharm is the most popular followed by Spyder. Here's a long list of options: https://www.reddit.com/r/learnpython/wiki/ide. Wikipedia also has good lists of [code editors](https://en.wikipedia.org/wiki/Comparison_of_text_editors) and [IDEs](https://en.wikipedia.org/wiki/Comparison_of_integrated_development_environments#Python). 
I found asyncio quite confusing at first too, I really only began to grok it properly by working on a simple network scanning toy. By far, the most educational part of this project for me was my need to create a lazy version of [`asyncio.as_completed`](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed) (that is, a function that takes an arbitrary iterable of tasks and returns an asynchronous iterator that runs a maximum of some given number of tasks concurrently, yielding them in the order of completion). Trying to get that function to manage tasks the way I wanted really demystified a lot about asyncio for me. My suggestion to people struggling with asyncio is to make small projects that stick with the standard library, re-implementing or expanding upon asyncio functions as I did. I think trying to work with third-party libraries when asyncio still feels like magic is a good way to get confused.
I know they're basic, but they don't work in Visual Studio for me. Thanks for the resources!
Dart can only run natively (without being converted to JavaScript) in Chrome.
Vs code 
I fail to see the need for threads given that HTTP requests can be achieved asynchronously. [`treq`](https://github.com/twisted/treq) accomplishes similar results to `requests` without any threads. I do peak at the `treq` issues from time to time and I've noticed they use `requests` directly (only for cookies as far as I can see). It may be worth you lending your expertise to that project instead of going on your own. The only reason I ask you to contribute to treq and twisted is because treq was created by twisted users "for twisted users" and doesn't really consider the "requests" user (...I hope that makes sense) so many new users are scared off. What better person to contribute than the developer of requests :) PS My ulterior motive: Get Twisted integrations for Heroku :D
Emacs is good when you're working with only a couple of files; pycharm for when you have a complex directory structure or have to manage a lot of different files.
It's a bad api and unnecessarily complicated. An ideal solution would be: async def fetch(url): response = await requests.get(url) return response, response.read() # all the other stuff event loop stuff I don't know if that solution is possible but from my perspective it should be. I don't want to nest two context managers just to fetch a website.
I'm trying to expose a bokeh app running on the bokeh server to the internet for public consumption via AWS elastic beanstalk. Everything works well locally, but I'm having trouble with coordinating everything on EB. My approach was to point to localhost:5006/myapp in an iframe, but this obviously won't work on EB. I tried playing around with my nginx.conf and looking at their bokeh.demoplots.com organization, but I'm still rather perplexed. What is the workflow for deploying over some remote server?
Just curious, what is accelerated C++? The book?
Accelerate C++ correlates to CS106X, which is a more indepth view of C++ and the inner workings of the heap and stack. It has some difficult projects and is typically only suggested for students who have extensive experience with any sort of programming langauge. Here is the first assigment they were assigned: http://web.stanford.edu/class/cs106x//assn/fauxtoshop.html
This has been answered but I should just point out that in your interactive python console you can get information and what you can do with an object (i.e. its methods) by just calling help() on that object. $ python # enter python REPL &gt;&gt;&gt; help(['a', 'list']) Press 'u' to scroll up. 'd' to scroll down, and 'q' to quit the pager. **EDIT** and if you're a beginner go ahead and skip anything that begins with '__'
A lot of people actually start that way, with something a purist would call an ungodly mix of C and C++, using C-like C++ and using the C++ mostly for handling strings. I don't think it's that bad of a mix, although that tends to obfuscate pointers, and memory management. So in that sense pure C would be better because you're sort of forced into dealing with them, and at least you get some exposure that way. I think it's a good thing to have grasp of at least one low level and one high level language, so you can learn the fine details and also implement algorithms without having to deal with the language. But after the introductory classes are over people should mostly be able to choose their own language, and be encouraged to experiment.
&gt; Python badly needs some form of type checking to give intelligent error messages when some code expects a tuple but got a list. In Python code, that expectation is *generally not reasonable in the first place*. And in the few cases where it's required, you can just explicitly check for it and raise an exception with a perfectly intelligible message.
Most of the time it's C with `std::string`, `cout` and `cin`. I've seen a mixed bag of using references vs pointers.
Actually, it doesn't run natively in Chrome either. There's a special build of Chromium (called "Dartium") that is several versions behind Chrome. The only reason it exists is that the Dart-to-JS compiler is kind of slow so iterating during development would be a pain in the ass without it. In fact, Dartium is actually going away entirely soon because they've got a new compiler that is much faster. At that time there will be no way to run Dart in the browser other than to compile to JS.
Oh, got it. Thanks. Edit: The fauxtoshop is actually a really cool project. Nice.
No you can change the style of a button in Qt with a stylesheet, which is XML (more or less). If you wanted to change the default behavior of a button without a lot of boilerplate, you probably want to subclass it. You probably can write a complete Qt application and handle all the custom behavior with the callbacks (slots and signals) but it will be uglier, have a lot more boilerplate, and as a result be more difficult to maintain, all in my opinion.
Yeah my experience with R is mainly with the vanilla functions. Those were enough for me to decide to focus my efforts learning Python instead.
Interesting. . .thanks for the info. Question - do you think that Dart has much of a future? I was under the impression that it never really took off. Also, how do you like using it?
Well rumor has it that Dart is going to be a first class citizen and the primary app development language for Google's Android replacement / Android + ChromeOS mashup when it eventually comes out. But I don't know how much stock to put in that. In terms of how I like it, I think it's great in a lot of ways. It provides a nice, consistent tool chain (unlike JS where everyone uses a different set of tools-of-the-week). It also provides some really nice static guarantees, which makes consuming APIs created by other teams so much more reliable. They kind of pivoted after Google dropped the idea of baking the Dart VM into Chrome, so some of the libraries and the JS interop are a little rough still, but the Dart team appears to be making solid progress. I think if I had to choose today I might pick TypeScript, or at least it would be very close, but back when we started using Dart, TypeScript wasn't quite there yet, so overall I think we made the right decision.
Twisted works great on Heroku! 
This article is wrong. CS106A was taught primarily in C in the late 90's. 
Using threads rather than coroutines is completely missing the point of asyncio. Might as well just use threads directly. Or is this supposed to eventually support coroutines? But based on Twisted? So you have to pull Twisted in even if you're otherwise fine with asyncio? I'm a bit confused by this project. I make heavy use of requests with coroutines. Based on gevent. The example from the OP repo would like something like this: from gevent import monkey, pool monkey.patch_all() import requests p = pool.Pool(100) get = lambda i: requests.get('http://httpbin.org/get') for response in p.imap(get, range(100)): print(response)
Visual Studio
Is it? I am not sure. I can assure you that Gtk is a joy to work with ever since the devs started puting out a more sane versioning of the system. Now, there are less API breaks. Not to mention it is GPL3 and compatible with windows and osx.
Yeah, I think learning static typing is pretty important to understanding general programming. You still do have to deal with variable types in Python once you start writing more complicated programs. So I think in the end it's ok to learn with Python, and that you could learn static typing pretty quickly later on. C++ was the intro to programming language I took at UCLA. I think it's a good language to learn. Python is a good thing to learn if you want to implement algorithms quickly and not worry about syntax. But you're right that it's maybe not the best language to learn if you want to dive in to other languages later since it leaves out too much.
Can this library handle multiple lines and incremental updates? For example, recognizing a multi-line string when the leading triple-quotes are added, without re-parsing the entire source. I took a quick look, but couldn't see if this was possible.
Another movie "barcode" generator, but this one can make spiral, circular, row-averaged, column-averaged, and frame averaged barcodes. Processing Rick and Morty Episodes for illustrations of Dan Harmon's story circle is a use case for spiral and circular barcodes. I have not seen column-averaged barcodes elsewhere. I think they may be useful for scenes where there is vertically encoded information or for clips that use split screen heavily. [SpiralBarcodes](https://github.com/rocketOC/SpiralBarcodes)
COMP SCI 1xx to 3xx was c/c++ on v220's and then they switched to Java. I dropped out after waiting sometimes 10 minutes for the goddamn IDE just to load. The language itself wasn't too bad coming from c++ but it was a system shock going from Unix (system V I think) to Windows and dealing with GUI's.
Also some languages like Clojure use functional (persistent) data structures (and other languages have third party libraries that do the same thing). In those cases the structures appear to be immutable but modified copies actually share state in the background in a way that the programmer can't access. So you add an item to a list and get a copy but really there is a tree keeping track of things vs a full on copy created in memory.
Germany
I use Pythonista on iPhone 4S and I'm very happy with it. You can't add any third party modules but it comes with a bunch of special modules included specifically for interacting with the iPhone/iPad, and also comes with some popular third party modules like bs4, requests, bottle, PIL.
My institution of brainwashing was the same, python for a semester and then two semesters of java. From my experience I think it is a mistake to teach python first because it encapsulates some of the fundamentals one can't afford to miss. Reversing these poor habits with Java afterwards only becomes more difficult. Edit: fixed auto correct error on poor*
!redditsilver 
script
If you want to directly reference OPs problem he doesn't need anything but fully synchronous. It takes minutes instead of seconds to check some blogs. So what? OP wanted to expand their knowledge while improving their tool. A switch to C with `selcet` and friends would have been just as warned when the requirements seem to be "make it faster".
You could simplify this a lot by using a dictionary to hold the pets: PETS = { 'paulo': ["Give breakfast in the morning", ...], 'seabass': ["Give breakfast in the morning", ...], 'wilson': ["Take for morning bathroom", ...], } pet = input("Hello welcome to the...").lower() instructions = PETS.get(pet, ["Sorry this is not..."]) print("\n".join(instructions)) This way adding a new pet will not require adding a new elif clause. I'm doing a few fancy things at the bottom there: - input() lets you provide a prompt message, so you wouldn't need the first print() - convert the input to lowercase so it's case-insensitive - dictionaries have a get() method that returns the value of the given key or a default value if it doesn't exist. In this case, I'm either returning a list containing the error message or the list of instructions for the pet. - "\n".join(some list) will join all the items in the list with newlines, which makes it easier to read the output. This is why I'm returning the error message in a list instead of just the string; if get() just returned a single string, this would print a newline between each character of the string, which would be bad. Notice how each of your functions is doing the same thing: constructing a list and printing it. This sort of duplication is often a sign that you can move things around and make it simpler, which is what I've done. I've separated the two steps of "choose the right list for this pet" and "print the output" because we're always printing, no matter what the choice is.
I started with Java as well, and then moved to C/C++. They're not bad languages to start with, since a lot of fundamental programming paradigms I guess are most easily taught in really rigid languages. Python I think is a good 2nd or 3rd language since it simplifies a lot of the overhead and rigidity that Java and C have. At that point, the student will know why certain design decisions where made in Python
Visual Studio now has python plugins...they are actually quite good, and free
I like it aside from not being able to use the repl unless you are actively debugging
Thank you
They said the same thing for C++.
It seems that the answer is N° 5 : set the indexes properly. I discovered that explain in sqlite is written "explain query plan" and I found out that my queries were previously doing a table scan. Now a few million entries take no more than two digit in milliseconds.
&gt; interface, port = (x.split (":")[1].strip () for x in s.split (",")) &gt; Thanks for the feedback. I had that first code in mind but was having trouble with the syntax. I appreciate the info.
Thanks for your feedback and the redirect to the correct group. Much appreciated :)
Im trying to learn pandas. Whats a good tutorial after Brandon Rhodes video? I have bought wes's book but it is kinda too complex to get in. 
This sounds interesting. Let us know if you succeed 
I like the cut of your jib
I see your point (although, I will admit, I did need to look up "sophistry"). I think the general issue is that the two languages are designed for somewhat different purposes, and each can be used in a scenario where it is more applicable. Full disclosure, I am a high school student, and most of my programming knowledge comes from books and web guides, so I'm by no means an expert on these things. In certain circumstances, I very much prefer the dynamic typing of Python, mainly for its relative simplicity, but in other cases, I like the static typing of Java, especially when it comes to method return types in OOP.
The only thing I've ever heard it called was "splat", though that was regarding the single *. Double splat perhaps? Generally I just say "args" or "kwargs" to describe the construct, but never had a need to name the operators. 
Did you read the repo at all?
Interesting question. I don't know if there's an official answer. I call it "star-star" others say "double-star".
Decided to jump back into coding having not really coded since c/c++ in college. Spent an hour or more tonight reading up on using vim for my ide, desperately need to understand git as well.
Dictionary unpack
Ooh, I like it!
I'd still say CS106P wouldn't be a bad idea.
Haha. I like having your brother use your program. Yeah, like everyone else mentioned a dictionary makes way more sense than using a bunch of functions. ex: ToDo = dict() ToDo['paulo'] = ['give breakfast in morning', 'change litterbox once throughout the day', 'give lunch', 'give dinner'] Also, the input function will also print whatever you want. So why not save a line and print with your input function? input_choice = input("Hello. Welcome to the pet todo list. Please enter a pet's name (Paulo, Seabass, Wilson) \n") now I would put both the input and the pets name in lowercase so you don't have to worry about the user using a lowercase first letter. And instead of manually entering the pets names from now on you can just use your dictionary file's .keys() method to get the names This line will make a list of all the keys in your dictionary (the keys are your pets name) and makes them lowercase. pets_lower = [x.lower() for x in ToDo.keys()] Instead of checking for each pet's name with an 'if' or 'elif' statement you can just check if the input is in the .keys() if input_choice.lower() in pets_lower: Then you can print all your chores with a line for each, numbered. chores = ToDo[input_choice.lower()] chores_numbered = [str(x+1) + '. ' + chores[x] for x in range(len(chores))] print('\n'.join(chores_numbered)) https://pastebin.com/RQ1XNhp5
That's done it. I just realised when changing it I didn't put the + sign last time I tried it hence only a single. Letter. Thanks again. 
What you're experiencing is the OS disk buffer. While python itself and the CSV module may perform buffering, the kernel also provides buffering when you write to disk. Other than that, the hardware in a the disk I may also do buffering but you'll generally won't notice that. The flush call instructs the kernel to actually write changes to disk. What your doing is basically counter productive. You're telling the kernel to flush more often than it normally would. There are ways to instruct the kernel to buffer more, but I'm on mobile so you'll have e to Google a bit for yourself.
That is cool. Lets hope it plays out like that.
No prob, thanks for providing feedback about trying out the changes.
I see, thanks for the clarification.
RStudio and Jetbrains' products aren't really comparable. PyCharm is designed as an IDE for writing software while RStudio is designed for interaction. It's easier to compare RStudio with Jupyter notebooks.
Variadic arguments is the technical term. The star is generally known as "splat". And you say: splat in args. Or splat kwargs.​ 
Hiding your spam behind a redirect is particularly unpleasant behaviour 
You should watch out with the name "egg", as that already has a meaning in the Python world. It will for sure confuse everyone. Better to try to think of a different name. Otherwise, it looks interesting.
Check wikipedia for (software) design patterns. I found it very interesting.
Thanks! I had considered that but I chose to proceed because eggs are basically deprecated and users aren't exposed currently to any egg-related APIs nor commands, only the occasional build file names.
Hmmm. Parso handles certain things really well without reparsing everything. Multi lines are not part of that. I'm not sure how that would really work. The problem is usually that those opening triple-quotes are reused in the file below, therefore it's hard to tell where the error lies.
Try adding: __EVENTTARGET:loginButton __EVENTARGUMENT: To your form data.
Hey welcome! You've got close, good job. From a swift look, two things you need to look at: 1) Ensure you are POSTing to the same URL that the browser would. The fact that the POST you showed returns a redirect to another URL (via the Location header) is irrelevant for now, you need to POST to the original and then let it redirect you. It probably will issue a cookie which you'll need to follow that redirect. 2) You are scraping a website written in ASP.net (aspx), these are notoriously hard to scrape because the framework functions in a way which is best described as an engineering nightmare (sorry ASPers). You need to ensure that you capture the VIEWSTATE parameter from the loaded form and pass it along with your POST request. Come back if you get stuck again. Edit: you actually seem to have done both of those things, I skimmed too quickly. Can you ensure that the POST request data dictionary is what you expect?
I'd say double splat
`pip install git+https://github.com/foo/bar#egg=bar` Eggs are definitely user-visible, and aren't likely to go away any time soon. I'd seriously consider just having a `hatch init` command that defaults to the current directory if no path is specified; that's how git works, and there's no sense in having two commands that do the same thing.
I think you're right, data.table is faster but dplyr is thought to have more readable (but verbose) syntax. I didn't know you could use magrittr with data.table. Interesting (but ugly!).
What's wrong with this answer? Sure, it's a little over-engineered for a standalone game, but I would fully expect a large online game to use a database for this. Pickle, on the other hand, is a terrible idea.
Programming is only fun for a short period of time when you write your code and it workse. That short period of time lasts until you find a bug or the application needs updates/changes. And JavaScript is everything but fun. 
Mine too, I wouldn't want it any other way even now after some years. 
geany is nice and lightweight, fine for most programming and does code folding. Not sure about autocomplete but I've never really wanted it for Python.
You mean you will write sqlite from scratch in Python too? That would be awesome.
I like the bits of your bob
I'd go with `hatch lay`, but yeah major +1 for not confusing people with *egg*, which is, frankly, taking the yolk too far.
How is the course going? 
This is super cool and looks really well done, thanks for sharing :)!
imagine what's it like introducing servers to someone who's yet to learn a for loop
Could do with a little more on the "why should I use this?". That's a lot of tools that I've been using for many years that you're encouraging me to give up on. Not that I don't have many problems with pip, virtualenv, etc. I'm just not sure this solves those issues.
i agree, you need to handle everything and anything. but if you're handling real problems and not shitty syntax and non-essential things, you might progress better and be able to handle more complex things. learning complex syntax is just a matter of time, so why not just skip it for the sake of understanding how are programs executed and what goes on in your PC when you do a for loop where you assign and change variables. sry for poor formatting
I don't think the essence of the problem lies in what you said. it's more aimed towards - is it worth it to waste time learning quirks about some high level language (such as Java or Javascript) or just learn how to do simple stuff in programming along with understanding how programs execute/work on your PC. 
Please check https://github.com/kennethreitz/pipenv and see if you use this in your project. I saw that both the projects do package management, manages a virtual environment, etc.
Why not `hatch new`? Seems like it would fit better with what the command does.
PyDev+Eclipse (or LiClipse for a standalone of that combination).
https://docs.python.org/3/reference/expressions.html#calls talks about keyword arguments, but doesn't refer to `**` by any name. I don't think there's a real answer.
Read about this before but didn't get it. Now when I read the abstract it clicked. This sounds great and I know one place at work that could really use it!
You can add third party modules as long as they are pure python or rely on the included third party libraries. So, famously, no pandas, but there are many many others you can install. 
The command could be replaced by giving an argument to init and behavior could be preserved by making the argument optional. 
Hm, looks interesting. Is there any chance package layouts could be customized ala yeoman? Just install something like `hatch-flask-layout` and then call it like `hatch egg webapp -f flask-layout`? 
I've heard unpack or expansion operator. In Python 3 this can be used directly as a way to collect iterable elements. &gt;&gt;&gt; a, *r = [1, 1, 1] &gt;&gt;&gt; r [1, 1] 
Reinventing the wheel?
I guess I read async/await and assumed this would be intended for asyncio users. But I see now it's intended for Twisted users. Fair enough.
I was taught Java in school. It wasn't the first I had ever learned, to be fair, but I think it was a good choice. My teacher told us that, for right now, `public static void main(string[] args)` was a magic incantation needed to make Java work, and that we would come back and fully understand it in a few weeks. And we did, and it wasn't that complicated. I don't think Java is 'bloated' contrary to popular opinion. I wonder if this perception comes mostly from having to write all your types out. There's also no fancy stuff. I'm still a fan of static type systems. I think that they let the tools help you, and let you express, in code, what you want and expect to happen. Not to mention, I think the Java documentation is the easiest I've ever had to navigate. So, I don't know if this is necessarily the best direction overall.
You will most likely need to use Selenium to automate interacting with the page.
Take a look on how Django deals with HTML escaping.
same as in python 2
How does it compare to pipenv?
This seems really great. I have not yet had the opportunity to use an env and packaging management system. But I had heard of [poet](https://github.com/sdispater/poet), this looks similar.
The context managers serve two different purposes: * The actual get context manager ensures the connection is cleaned up appropriately, including draining any data that might be in pipe that would cause unfortunate things to happen if it was left there * The session context manager ensures connections are properly closed instead of rudely ending and being a bad internet citizen. Ideally, you wouldn't use two context managers. You'd make the session, use it, and then call close on it when the application is shutting down or you're done with it. Best practice with aiohttp is to only use one session for your app, and only spawn more if you need to. 
I would avoid doing that explicit comparison with True or False, and instead go with statements like: "a" in "abc" # gives True "d" in "abc" # gives False "a" not in "abc" # gives False "d" not in "abc" # gives True These are also quite a lot more readable.
wheel pun? It would be funny if next to `hatch egg` also `hatch wheel` would be added.... now that'll be one to imagine.
"double splat" or "splatty splat"
Honestly, these days, writing things like relational databases, where there isn't a huge expectation for performance, writing in a higher level language makes a lot of sense. The bulk of the processing will be invisible to the user anyway, and they're already going to expect certain operations to take a little while. Having the flexibility of Python, and being able to use Ll the fancy C plug-ins that exist for it, seems like it would be very advantageous. 
Thanks you, this is great!
THNX! 
I have [something similar](https://github.com/afreeorange/template-python-flask-app) I've used in the past for my personal stuff that uses [cookiecutter](https://github.com/audreyr/cookiecutter) and `make` cookiecutter https://github.com/afreeorange/template-python-flask-app cd my_flask_app make test # type "make" for more options Haven't tried it with `make` on Windows. Looks (and _is_) rather janky compared to this project and poet but the `Makefile` is readable and does the job :)
I have an algorithm that finds PI to about 80 decimal places; after that, it just prints "***digits***0000000". Here: `` def findPi(n): t = Decimal(0) pi = Decimal(0) deno = Decimal(0) k = 0 for k in range(n): t = ((-1) ** k) * (factorial(6 * k)) * (13591409 + 545140134 * k) deno = factorial(3 * k) * (factorial(k) ** 3) * (640320 ** (3 * k)) pi += Decimal(t) / Decimal(deno) pi = pi * Decimal(12) / Decimal(640320 ** Decimal(1.5)) pi = 1 / pi return print(pi)``
I just stored all required variables in a text file and loaded them in in a start() function. I.E. start(health, dmg, roomNum) etc.
OP specifically said synchronous was too slow. He tried async. I merely suggested threads would be simpler and achieve the same results.
Thanks, glad you like it!
What's wrong with using standard terminology that is common among most package managers? Homebrew is a good example of inventing completely unnecessary new terms for everything, and it just makes it harder to transfer knowledge to and from other package managers.
If this were a packages manager, per se, I'd tend to agree with you.
As a user and a developer, I'm always torn about using "cute" / "thematic" names like this. At first they seem nice and self explanatory but eventually it feels like they break down and are more of a hindrance than a help.
I will be messaging you on [**2017-10-05 14:20:51 UTC**](http://www.wolframalpha.com/input/?i=2017-10-05 14:20:51 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/Python/comments/6xwxb0/handmade_python_plushie/dmlbq9l) [**1 OTHERS CLICKED THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/Python/comments/6xwxb0/handmade_python_plushie/dmlbq9l]%0A%0ARemindMe! 1 month) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dmlbqir) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Not quite, it's a working prototype of the intended API but developed instead with threads. It's to get an idea if the API is correct before committing to the development of the actual version which will be able to use async/await, twisted or another event loop.
*Advantage* compared to what? Python 2? (No difference!) Another language? → misleading title!
Wait, you can use it in assignments too?? TIL...
"star star" &gt;_&gt;
Search for `alex martelli python design patterns` as he's forgotten more about them than I'll ever know. Do not get hung up with the GoF stuff. Their patterns are convoluted as they are targetted at statically typed languages so the Python solutions are much simpler.
Well, from what I heard, Sublime uses a custom version of Gtk. I have no clue what actual changes were made. It also uses Objective C with Cocoa for some things as well as Python for plugins. Any opinion on Gtk vs Qt?
Interesting, thanks!
Why?
Depending on time this week: For my side projects: * Scraper that looks for remote DevOps jobs * Flight programs for my CrazyFlie drone. So far I can make it hover! For work: * Log parser for DataDog.
What's this log parser thing you are building?
Already tried it, still doesn't work. Also tried adding a "Referer"=url header to the requests. Same problem 
I'm working on a tool for auditors / data protection officers called GDPR App - https://gdprapp.com. Initial goal of this tool is to help with general data protection regulation compliance. It's a tool that helps you collecting information regarding the data processing and assess it. Currently we're designing reporting system and hopefully it will be released next month. 
1) open app 2) hit record, takes you to phone's home screen 3) perform whatever tasks you want automated, the app would record the x,y location of your touch inputs/buttons you pressed/events 4) hit stop 5) add a button to your home screen or overlayed during specific context that, whenever you press it, the phone simulates your inputs Maybe: the app would use AI to identify when something in a recording may have changed, such as an update to a UI. Could also use AI to analyze events logs, that way it could simulate your inputs much faster. A couple examples, they all start with hitting record, which takes you to the home screen: 1) navigate to clash of clans, collect your resources, hit stop 2) navigate to messages, text your friend "bacon", hit stop 3) open browser, Google baseball standings, screenshot front page, hit stop 3) press all buttons above, hit stop (this could be used to chain automated tasks, use one button to do many things) Computers are stupid, AI is smart but currently must be tailored for each task. Why not just tell the computer exactly what you want it to do by logging your events? I would call it phoneTrainer or something like that. Of course, this wouldn't work with just any OS. I think it would be great for easily scraping data from the internet, though, using stuff like copy and paste. You wouldn't have to deal with HTML or anything like that, just show your device what you want it to do explicitly and it does it. Not AI, just a trainable computer.
Yes it is... Printing vbody returns the correct dictionary. Also, I think the problem is not the login data POSTed to the first URL, because it responds correctly, pointing me to the sso.vitalsource.com domain (response contains a "Location" header, code 302 Found [redirect]), so it accepts my login request. If login form data is incorrectly sent, it won't redirect me to sso.vitalsource.com domain) The problem occurs when I try to GET the sso.vitalsource.com. When I am redirected to this website (requesting GET), it returns code 401 unauthorized.
learn data science and bet on stock/fx/futures/etc. market. Come up with a model, a strategy and gamble away. Seriously. 
Google. No, but seriously. Google.
Great talk, first 5 minutes answered a lot of my questions.
AKA the [Nathan Hale](http://www.catb.org/jargon/html/N/Nathan-Hale.html) &gt; I only regret that I have but one ass-to-risk for my country
The ability to gather proper requirements.
Lutz' book is very good. It's the most-thumbed book I've found in every Python shop I've worked in. http://my.safaribooksonline.com/book/programming/python/9781449398712
Dear All, European XFEL (Hamburg - Germany) is searching for a really stronger python programmer!! Please, see the job description: http://xfel-old.desy.de/careers/open_positions/engineering_technical_staff/e_166 We have a really nice relocation package and benefits. Check it out! (until 29/09 only!) 
Looking at this: https://docs.datadoghq.com/guides/logs/ I've never used DD in this fashion before, so I'm curious what's possible.
I think at least some of it has to do with how math is taught, even at the university level. At some point, to actually build a working knowledge of computing, you *have* to have a working knowledge of mathematics. I'm consistently annoyed, reading research papers in CS, that I have to go pull a math book off my library shelf to be able to follow the mathematics explaining *why* the authors went a certain direction and not another; my thoughts usually trail off to "why the hell hasn't a math class taught me to think about math in a way that actually lets me think about problems like this author does?" I've only ever taken *one* math class approaching that, and it was an introductory course in discrete math, from an instructor who actually gave a shit about imparting understanding over spellcasting. The linear algebra class I'm taking is from an instructor explicitly trying to copy that instructional method, but it's still too early to tell if he'll succeed. edit: spelling
Still working on my little VI-like DAM project. I'm now trying to optimize the search engine based on SQLite. The idea is to be able to search in millions of tags with a syntax similar to Image Booru or google images. I'm actually trying to simulate a case where I have 10 million of images and each of them has 20 tags in average. The search query is done on one large table and it looks like: select fileid from tags where category=... and text in (...) intersect select fileid from tags where category=... and cast(text as integer) between ... and ... except select fileid from tags where category=... and text in (...) .... I had worries about multiple intersects and except, being known for being less performant than joins, but they have the advantage that I can translate directly to SQL a search query that looks like: house animal:cat -%georges% filedate:YY:2017 Which search for every picture tagged with "house" and "cat" that belongs to category "animal" but without any tag that contains the text "georges", and where the image date is within year 2017. SQLite can handle that very well, but indexing is quite important when the table reaches the million of rows. Since the tag can be either text or numeric, and there is no way real to predict that, I muss either create a second field for numeric text, or create 2 indexes for the text field, one for text type and one for integer type. With that I hope to be able to search through almost a billion of tags in a few seconds, and on a very common laptop. So far, I've seen that for 300 million rows SQLite uses 6 GB for the data, and 16 GB for the indexes.
Ability to write python code seems paramount.
Hi there! Hatch doesn't replace all those tools for every single use case, just many of the main ones. I type far fewer commands with the workflow Hatch provides than I used to. Also, with a reduced API surface, it is ideal for newcomers.
The tuple/list thing was a specific example from tensorflow that cost me some time. Probably a bug on their end but easily avoided with static type checks. There are two problems, 1. everyone needs to check their arguments, which they don't do, and it violates duck typing. And 2. checks only happens at run time. With experience we know how to mitigate these problems but beginners will have a harder time without the system enforcing rigor.
Great question! As Hatch does a bunch of different things, I'll just speak to the package management. More or less, hatch manages packages based on environments, whereas pipenv does so based on projects. When pip supports Pipfiles, hatch will as well. At that point, project based package management will be supported too.
We're talking about intro classes. A tiny minority of students will go on to CS theory graduate work. Of those who do anything worthy of being called Computer Science, most will go into applied fields like compilers, OS, DB, ML, etc., not complexity theory or type systems. Starting people out with FP or even with category theory is a nice experiment that was proposed by people who themselves started with Basic, Fortran, or assembly. It's largely been rejected in favor of imperative languages with functional sugar. The problem with FP is the one you point out: it's possible to get it to behave reasonably but you have to have two simultaneous mental models of what it's doing, a mathematical one and a practical one.
hello?
Changed, thanks! [https://github.com/ofek/hatch/commit/5649b3f6c452b670d919fae1a9d4eebb1fbea5a4](https://github.com/ofek/hatch/commit/5649b3f6c452b670d919fae1a9d4eebb1fbea5a4)
That's why I always use an ipsum generator to make up my module terms. &gt; You see the ```amet``` function calls the ```elit``` submodule. This creates an instance of the ```adipiscing``` class. /s
3 only.
Spyder rocks my world. And it's free.
Projectile was supposed to make emacs an ide. As was ecb.
superstar
Can't u just put it all into a function, something like get_project_id(id) and then return it when it's first found. If after all the loops it isn't found then either throw an exception or print your message once I.E. Outside of the loop. # Ignore This, Just For Checking class ProjectResponse(): def __init__(self): self.status_code = 200 self.json = x = {u'count': 334, u'data': [{u'_href': u'http://URL1', u'createdBy': u'username1', u'creationDate': u'2014-12-02T22:06:22.590+0000', u'description': u'', u'id': 158, u'issueTemplateId': None, u'name': u'Damn Vulnerable Web Application'}, {u'_href': u'http://URL2', u'createdBy': u'username1', u'creationDate': u'2015-08-10T14:46:59.397+0000', u'description': u'', u'id': 207, u'issueTemplateId': None, u'name': u'WebGoat'}], u'responseCode': 200} projectResponse = ProjectResponse() # Ignore This, Just For Checking class StatusCodeException(Exception): def __init__(self): self.message = 'Invalid Response Status Code' class ProjectNotFoundException(Exception): def __init__(self, _id): self.message = f"'{_id}' Not Found In Project" def get_project_id(name, response_data_key='data'): if (projectResponse.status_code != 200): raise StatusCodeException() projectList = projectResponse.json[response_data_key] for projectDict in projectList: if projectDict['name'] == name: return projectDict['id'] raise ProjectNotFoundException(name) try: _id = get_project_id('put id here') except StatusCodeException: print('Undesired Asset Code') except ProjectNotFoundException: print('Id not found exception') This should do it :) S.N. This is a pretty inefficient way of doing things, if I were u I'd try creating a new class to hold data about the result and then place that class in a dictionary with the result name. that way instead of iterating, u can just check whether the dictionary contains the key, if so return it, if not then do whatever else :)
Thanks, enjoy!
modern JS has proper async code structures, the problem though is if you're not exposed to programming in general, it's a tough setup to start with. I remember failing out of CSci because I couldn't get a proper dev environment running, and no one was around to try to teach extraneous things like how to connect a programs internals to some kind of output device. I remember having to do a final maze builder and couldn't figure out how to connect it to some random html or whatever it was that was suppose to illustrate the maze. I tried to fall back to ascii code, but then I'm not completing the project, and instead writing a rudimentary output device.
Just wanted to make the formatting a bit more readable. &gt;&gt;&gt; a, *r = [1, 1, 1] &gt;&gt;&gt; r [1, 1] _(code blocks use four spaces instead of backticks)_
[Fluent Python](https://www.amazon.com/Fluent-Python-Concise-Effective-Programming/dp/1491946008). I've learned more per page from that book than any other Python resource I've come across. For example, studying the book's material on hashable objects got me over a problem I was having with a planning algorithm. [When I finished](https://github.com/aimacode/aima-python/issues/275), I had successfully implemented a knowledge base and a [total-order planner](https://github.com/bcorfman/aima-python/blob/master/planning.py) that could directly leverage the A*-search in the [AIMA-Python code base](https://github.com/aimacode/aima-python). Kudos to the book's author, Luciano Ramalho, as that is just one example that helped my problem-solving skills in Python.
Seems cool, I'll try it out. I like the direction of building something comparable to `npm`, though I have a feeling the project is reaching even wider than that with scaffolding etc. – breaking the Unix philosophy a bit ;)
&gt;Running Python scripts interactively This is a nice tip. One that I did not know of. Thanks.
I find that, other than Google, the only thing that helps me are the little pocket lookup books for syntax shit.
Thanks, I was on mobile and forgot. 
For simple quick scripts, IDLE is fine. But if you're going for huge projects then I'd recommend PyCharm.
I'd highly recommend Qt with either PySide or PyQt. 
LuffyNatsu, u insult me sir. Luffy is far better then Natsu :P. Secondly what do u have experience in, how well versed are u at programming. Do u understand methodical approaches, object oriented design, data types etc. + What languages do u know.
The ability to envision what u want to do, and create a script that can achieve at least the bare minimum of that seem the most important to me. For example I wan't to download the first 10 images on this google results page, create a script that can do that and then try to refine the process you've already developed :)
Oh yeah I just looked at some examples of PyQt4 and the syntax looked better
The `else` clause on the `for` loop is designed for this. If your name is found print your message and `break` the loop, otherwise print not found. So you'd have:- for projectDict in projectList : if projectDict['name'] == projectName : print('yee ha!!!') projectID = projectDict['id'] break else: print('mammary glands!!!') 
Oh cool, I didn't know python had this, nice to know :)
What you are showing looks like a demo use of a chatbot. It's not code, it's an example of how to use the code. There is no way to tell from that what language the code is written in. 
So you are saying that its not a working script? thanks for fast answar :)
From what I remember last time I tried there's little in the way of mixed-effect linear models or repeated measures ANOVA. Though this may have changed in the past year.
in javascript's ES6 it's referred to as a spread operator '...' as it spreads out the variables. I've also heard it called unpacking, but that's it's function not really it's name.
I'd say go with Qt5, tutorials are easy to convert, you get QML, and it's still supported and maintained. 
Fluent Python - once you have got an upper intermediate grip of Python, has to be one of the most valuable python. I also like Effective Python, which isn't as advanced but pretty good in my opinion. 
No, what you posted is not a script. It's instructions. If I google it it seems that it's copy/pasted from [this site](https://medium.freecodecamp.org/chatscript-for-beginners-chatbots-developers-c58bb591da8), which would suggest that what you bought is a copy of the free [ChatScript](https://github.com/bwilcox-1234/ChatScript) program, which is written in C / C++. 
Cool! I've been looking into elixir recently and the tooling is amazing. This looks pretty similar! 
To be honest, the free ones are usually better. No real recommendations on the paid ones, maybe do a few free ones and donate to them?
I feel like the free ones would be better too. My job just wants me to take a paid one that is a little more formal and has a grade or completion aspect. I know that I don't want to do anything that requires me to be at my computer a X time on X days. It's a tricky assignment since I have to find the course myself.
Toying with implementing a component-based web application framework, first step was seeing if I could implement properties that could be bound to arbitrary getters or setters (but act like a normal instance variable in the absence thereof). The ultimate goal is allowing you to build a web application mostly in Python like you would a desktop application, similar to what Vaadin does, but with data-binding so you just pass elements like an input field a reference to whatever property on a model you want them to update so you don't have to yank it out when you hit 'Submit'. Lot of work to even get there, but for the bindable property stuff I have 'done' I learned a lot about descriptors (and a really nice new magic \_\_set\_name\_\_ function introduced in Python 3.6). [Bindable property magic](https://gist.github.com/snuxoll/ccb23d8fa96abef97da4c571768f7981), for anyone who may be interested.
You can look up Datacamp, it's paid and aimed at corporate training too
Thank you, I hope you enjoy it!
Cargo and NPM heavily inspired this :)
Thank you, i had a feeling that this guy was a rip-off and a scammer. Now i have it comfirmed. I really appreciate your help. 
Sorry, really can't help you. Personally I love pythonprogramming.net and I really can't recommend places like Udemy after using that (even for their free ones!)
This seems super interesting! I'm currently using baron for roundtrip parsing in mutmut but Python 3 support isn't merged so this sounds like something worth exploring. 
oh man, that sounds like a job for Mr. Data.
Udemy offers several great Python courses including one on Python itself and others on Data Science &amp; Machine Learning and Finance &amp; Trading Algorithms using Python. #paid #10bucks 
Way to go guys.
If you're not attached to Rhino, i'd suggest using Blender. You can replace them entire Python package with your own and install everythin through pip
2.7 is supposed to be digging it's own grave.
I have an algorithm that calculates a sum of two numbers, here: a + b
I like Geany too. You do get some basic autocomplete but not like that in the full blown IDEs. However, I gladly trade that for speed and ease of use.
What do u mean?
Have to agree with Fluent Python. One of the few programming books I've read cover to cover instead of just flicking through waiting to hit something interesting 
https://www.pluralsight.com/browse/software-development/python 
I am into open source tools, for this reason alone it has an upper hand. However, I can't compare both,as I never used Qt. 
Oo. Thanks for the tip! that sounds much more easier to work with.
&gt; What do you mean? I mean good job cluttering the forum.
What did I do, I mean first sentence aside all I did was try to help :)
~~Creating~~ Finishing a parser for KissManga.com that can download all the manga chapters I crave XD.
Thanks, that looks cool, I'll check it out.
I've been taking a Udemy course called Data Analysis with Pandas. It was on sale for $10 a while back. It is a very good course. I'm not familiar with other resources on Pandas but I'm sure there are many.
Caveat Emptor. Or, as the Romans might say, "Omni momento natus est enata suboles." **Edit**: for those with an allergic reaction to humor above the grade-school level, the first part is "let the buyer beware" and you *should* have heard it in high school. The second is a phrase the Romans would *never* have said, but P.T. Barnum may have ... "there's a sucker born every minute".
You shouldn't be writing servers in Python in the first place.
https://github.com/reddit/reddit 
Take a look at the subreddit info: neither the post nor your answer are suitable here. I don't doubt your good intentions though.
I didn't say "you can't", did I? Choose the right tool for the job. "If all you have is a hammer, everything looks like a nail".
I'm currently working on a twitterbot related to facts about space using various APIs to gather the data: https://github.com/FXelix/space_facts_bot
&gt;We're talking about intro classes. A tiny minority of students will go on to CS theory graduate work. Yes.. mutating a list in scheme is not graduate level CS theory. &gt;Starting people out with FP or even with category theory This is not what is being proposed. Scheme is not a purely functional language. You can mutate stuff to your hearts content in it. Implementing quick sort (in the proper way without copying lists everywhere) in scheme is not ivory tower stuff. Seems like a very reasonable exercise in an intro to algorithms class to me. The thing is. Either you care about how many time you copy a list or you don't. If you care then you need to explain why copying things unnecessarily is sometimes a bad idea *even if not making copies is the default behavior of the language you are using*. Also there is some pros to never destructively updating data, so if you use a language were destructive updates are the norm, you have to teach students how to avoid them. If you don't care about it because you think such a concept is too advanced, then you are free to ignore it and it does not matter what the default behavior is.
What's the difference? Does this mean that there's a python 3.6.2 "environment" and any project using 3.6.2 will have access to all packages, whether they specifically list them as a dependency or not?
&gt; ammary Awesome Thanks! I also didn't know that an else was available for a for loop in Python. 
Oh yeah, I use Celery all the time and don't mean to push anyone away from it. If I ever opened this app to the outside world I would set it up.
Fair question. Honestly, I was trying something new. I've used threads for similar things in other places. It turns out my implementation was wrong (I've added a postscript), and I reached the same conclusion you have: threads are a much better tool for this job.
Any project can use an environment's packages when it is active, yes.
I see - IMO isolation and independent versioning is pretty crucial. Excited to see how the project evolves. 
The op code for `x = {**d1}` is officially called BUILD_MAP_UNPACK. So "mapping unpacking".
Learning Python! I'm a recent MS Statistics grad, and have no experience with Python and lots in R. I'm expanding my horizons and learning the basics through Datacamp. Excited to see the flexibility of Python 
Thank you, enjoy!
There was an argument to be made that getting rid of mutable state was comparable to getting rid of gotos and forcing everyone into structured programming. That argument seems to have been refuted by experience since state manipulation is central to most practical programming (DB updates, filesystems, numerical optimization), and imperative-first languages have run circles around functional ones in terms of total work accomplished. The best selling point was the expected move to concurrency. Unfortunately hiding state updates behind recursion doesn't actually solve concurrency problems because you now have to worry about whether you have the most recent version of an object, so you might as well bite the bullet and use locking. Lisp in particular come from an odd place in CS idea development. Homoiconicity is a dead idea, type systems are important, readability is important, and the best parts of FP are available in all modern languages.
Shit, or even processes. `concurrent.futures` ftw.
Yeah, this problem is embarrassingly parallel. It's what *processes* are for, frankly.
No problem :-) There's an excellent write up at [Else Clauses on Loop Statements](http://python-notes.curiousefficiency.org/en/latest/python_concepts/break_else.html).
# **Lazy Developer Script** aka lds This is a small python based script which is supposed to make life of a developer much easier. It figures out all the commands you need to run based on the directory you are in. Inspired from yocto, it has multiple stages for cmd execution like configure, build and install. It's smart in many ways like * allow you to run specific commands (only install let's say) * apply targets and build different components * handle special targets to mount, unmount sd cards, transfer files, play a tone, run something on server etc * when installing, intelligently find out wheather to install files in ad card, nfs, tftp location, or custom paths. So with this, any directory I go in, I just type ``` lds -cb #configure and build lds -tm #mount sd card lds -i #install all the files lds -tmu #unmount sd card lds -tog0 #reboot my board ``` Edit: I am learning markdown, so excuse if formatting is horrible. 
Depending on how much free time I have I'm going to try and add a new feature to my website to show chord shapes across a fret board. My website currently can tell the key of a given tab (guitar or bass), it then finds the song on youtube and tells you important info about the song such as a fret board with notes in the key and chords in the given key. Its pretty useful for soloing over songs since you just have to play the song from the youtube video and jam around with the notes inside the key. 
PHP sounds like it could be a real drug
Who is the tutor?
/r/learnpython, but google 'basic python tutorial' or 'python tutorial easy [ANY TOPIC]'
Architecture astronaucy brother ;-)
"It's a gallon of PHP."
[removed]
"One gram of PHP is enough to leave a person dead."
Can you run python on Android our ios?
You always have to look up the proper way to use it.
&gt; The way you have yours written evaluates like this: &gt; &gt; 'a' in 'abc' == True &gt; 'a' in False &gt; False I don't think that's true since: 'a' in False TypeError: argument of type 'bool' is not iterable 
My experience with Haskell has been like the Python one but then in reverse.
Funny!
/r/learnpython can help you. They will not do it for you; you will have to show what you have tried already and describe where you are stuck. Be sure to [format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) or use a site like pastebin. Also, include which version of python and what OS you are using. 
Really awesome info, but the grammar could use some work. I would have a native English speaker proof the guides before posting them. Bad grammar will lose you credibility to the audience or cause confusion, which is the opposite of a tutorial's purpose. I hope you don't take this as harsh criticism, as that was not my intent. Just wanted to provide some constructive feedback. That being said, I will definitely utilize this in tandem with other resources, as django is something I have been meaning to learn.
PHP is the only one on there that is not addictive. 
Awesome! Thanks!
Java would be a happy-looking college student / same person in a suit with dead eyes.
Wow! A gallon!
Not sure what you mean, but yeah Python can be run on Android or ios. As for this app idea, I figured it would be easier to do something like this as opposed to accessing system logs, stuff like that. You would only need to record user input, and from there you could create some kind of mirror, perhaps on a second device or server, and do the automated task there
. . .
This is true. Python and Lua rock. Simple and easy. C++ though, I thought was pretty easy. 
I've only heard "splat" used to mean the symbol Apple uses: ⌘
This is really slick! Hope to see it on pypi in the near future
5. clean code: writing code that has the right abstraction. Not to complicated and tricky but also not stupid with code duplication. Actually that is based on experience. 6. knowing the ecosystem: the most important one you shouldn't reinvent the wheel. Python is all about the open source projects around it!
As a Brazilian, I approve
One's experience with C++ depends a lot on the subset / libraries you pick and the related toolchain. It can go from insane to pretty tolerable.
I heard it was "shat"
specially because they're hard to put into words... even more hard to put into a market.
I didn't even know it...came in liquid form?!
You probably shouldn't use methamphetamine regardless of the language you're coding with
This is your brain. This is your brain on PHP
Hence this headline: [Student Suspended Over Suspected Use of PHP](http://www.bbspot.com/News/2000/6/php_suspend.html). bbspot.com was an old Onion like site.
Before: https://i.pinimg.com/736x/35/16/dc/3516dc8bcbfb598874fd8aa50cb22a7f--classy-men-jedi.jpg After: https://i.pinimg.com/736x/c4/93/3e/c4933e94b1e439d05c4f3b001a68a90c--hamburger-hill-american-war.jpg
Javascript I see she's been squinting at the browser trying to figure out wtf someone is doing in some de-minified code.
(((((((((((((((((((But was Haskell anything like)))))))))))))Lisp=&gt;?())))()()))))))))))
I get that you're trying to be funny, but putting down other communities doesn't benefit anyone.
Hold on -- I need to run composer update and break my whole toolchain.
One's experience with C++ is inversely proportional to the age of the codebase.
I think this project looks great, keep up the good work! I'm slightly embarrassed to admit I've always installed things system-wide (or for a particular user) with pip, and have never gotten around to fully integrating virtual environments into my workflow because I always found it to be a bit of a pain dealing with all the diverse tools and remembering the proper commands. This seems like a beautiful consolidation with an intuitive interface. Definitely going to try it out.
ugh...I wish I'd cracked this open this morning...your post shed light on the exact problem I was having today. Perhaps a word also about editing PYTHONPATH. I'd created new directory and an import from it failed. I ended up: import sys sys.path.append("path to module") print(sys.path)
IIIIII'mmmmm meeeeeelllllttting.......
Try swift for an uplifting experience
I need more of this vintage old school websites! This is sweet!
CCCChhhheeeecccckkkk yyyyoooouuuurrrr dddduuuupppplllleeeexxxx sssswwwwiiiittttcccchhhh....
[Overhyped and Inferior Bath Salt](https://erowid.org/experiences/subs/exp_alphaPHP.shtml)
a ? n() : a(n)();
Of course your name is coderanger... What a fucking jabroni...
I find it strange how tribal some people are with products/companies/sports teams, and apparently programming languages. It's a tool, get over it.
[removed]
Probably an unpopular question but does this work in Windows? Pipenv doesn't officially
Wow, thanks so much! I was doing the same for the most part until recently. Users like us are why I made this. I'm so happy you find it useful :)
Yes! First thing in https://github.com/ofek/hatch#features I develop on Windows :)
If you have opencv installed and you are using pyautogui.locateOnScreen just pass a `confidence` parameter as a number between 0 and 1. It defaults to 0.999. --- If you have more questions like this it's better to post them on /r/learnpython. Be sure to [format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) or use a site like pastebin. Also, include which version of python and what OS you are using. 
then why are you putting me down HMMM?!??? checkmate atheists 👍
He's that guy on IRC who tells you to read the documentation when you ask a question about the documentation. 
I'll be trying this out 👍
Hey now, you're an all-star
From Brazil, living in Finland, writing in English. That's rough... 
[removed]
Please let me know what you think!
Still missing a readme with examples 
* I saw a user post a movie barcode she made by using photoshop to extract and save frames, macros to average the colors, and a third procedure to combine the average colors. People without photoshop, time, and space for 10k+ frames could use this script. * Colors and transitions in color affect an audience just like the score. Barcodes can help reveal shifts in mood and location throughout the movie. * Some people think they look pretty * The spiral/circular barcode was inspired by Dan Harmon's story circle. His writers use this formula to break scripts for [Rick and Morty](https://www.youtube.com/watch?v=zho1qIcCxiM). If his methodology is a based on a circle, why not make the barcode a circle? I am interested to see how/if the 8 stages of the story are represented in color. 
In my opinion it's the [Python 3 Cookbook](http://chimera.labs.oreilly.com/books/1230000000393/index.html) by David Beazley and Brian Jones. It rarely gets recommended around here but it's always my go-to whenever I need to look something up that isn't basic enough for Stack Overflow. Can't recommend it enough, and I think it's exactly what you're looking for. Also free online!
Ah ok I think I got it, thanks for the example!
Docs state "recommended by Python.org". Does that mean pipenv is safe for use in production?
 import joke Try it now.
.. errr that's exactly why the selectors module exists. It chooses the 'best' implementation available, and it provides wrappers around epoll, kqueue, poll, and select
I usually say "star star kwargs" but if asked about what to call it I'd reply "double splat."
Actually, it's not official yet https://packaging.python.org/new-tutorials
Maybe compared to python4? That doesn't support functions yet.
As the mere farmers of reddit would say "get off your high horse damn it."
PyCharm incorporates Jupyter notebook now so you can indeed use it interactively. 
- bokeh - flexx, the Python replacement for browser javascript. - dataset - PyPy
Please fix your formatting; your indentation is broken.
[removed]
Is this to learn python specifically for the raspberry pi?
A "complete beginner's" guide should start with some motivation and a basic outline of the payoff and process. Jumping into installing dozens of packages is a brick wall for someone who has no idea why they'd want to do all this work.
Sounds fantastic. But also very similar to http://flexx.readthedocs.io/en/latest/.
Look into formatting code in python before you ask. This is completely unreadable.
made a pastebin for it so itll be in the right format :) 
Oh! TIL.
i'd like to know the answer to this question also.
Bad bot
Thank you graingert for voting on perkele\_bot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
What is the error? The wrong output?
Love the graphics and the fact that you can toggle between OS instructions. If you would like a native English speaker to proof read it before you post PM me and I'll send you my email. (I'm also a Spanish speaker, yeah I know it's not Portuguese but oh well)
FV will be necessarily negative. Which formula do you intend to implement? 
There's always one... ( ͡° ͜ʖ ͡°) 
You only need to import math once.
Pip install numpy Or Pip3 install numpy
Good bot
And one of the later 3s added it so that you could put them anywhere, not just at the end. &gt;&gt;&gt; a, *r, b = [1, 2, 3, 4, 5] &gt;&gt;&gt; r [2, 3, 4] You can also do that with underscores as a way to toss anything you don't want.
Currently working on a side project scraping data from the RateBeer.com. I'd like to try to scrape as much data as I can and publish the dataset on Kaggle and maybe make a recommender system out of it
I got a assignment to make something. Related to semi-supervised learning. I still need to learn some basics of Machine Learning before jumping right in.
Does Python treat underscores differently? I was under the impression that "assign to underscore to ignore" was a convention instead of a language feature.
You're right that it's convention.
Maybe not applicable on Mac, but do need a wheel if using windows big list of wheels here: http://www.lfd.uci.edu/~gohlke/pythonlibs/
Guido just tricked everyone into learning pointers.
I know how to install it; I just need to know where to install it. i.e. in which folder
MIT's CS600 just started and it's both a CS intro and and python class https://courses.edx.org/courses/course-v1:MITx+6.00.1x+2T2017_2/course/ If you pay the $50 you do get a completion cert. I started it last week and am enjoying it.
100% agree 
If you're using asyncio (I think) or curio, surprise! You are! That's how curio actually works - by using threads, when you hit a `select`able operation like say reading from a socket the async function yields (sorry "awaits"), and the loop can decide to run another function until that one yields itself. I'm not sure if async is better than a simple reactor. I'm not confident that it is yet, but I still need to work at it.
Can anybody help me with this? I need it for school. Some Assignment Requirements This program requires the use of **`while`** loop **`if, elif, else`** **`if,else`** (nested) **casting** of type, between strings and numbers The program should only use code syntax covered in modules 1 - 4. The program must result in print output using the numeric input, similar to that shown in the samples displaying "Items" and "Total". Program: adding_report() function This program calls the adding_report() function which repeatedly takes positive integer input until the user quits and then sums the integers and prints a "report". The adding_report() function has 1 string parameter which indicates the type of report: "A" used as the argument to adding_report() results in printing of all of the input integers and the total "T" used as the argument results in printing only the total Sample input and output: call adding_report() with "A" as argument (print all the integers entered and the total) Input an integer to add to the total or "Q" to quit Enter an integer or "Q"): 3 Enter an integer or "Q"): 6 Enter an integer or "Q"): 24 Enter an integer or "Q"): 17 Enter an integer or "Q"): 61 Enter an integer or "Q"): nine nine is invalid input Enter an integer or "Q"): q Items 3 6 24 17 61 Total 111 call with "T"(print only the total) Input an integer to add to the total or "Q" to quit Enter an integer or "Q": 5 Enter an integer or "Q": 7 Enter an integer or "Q": Quit Total 12 The forever (while True) loop diagram This diagram represents only part of the assignment - it is the loop and nested if statements inside the function. The code will enter at the while True loop after initializing variables. image of while True Loop with nested if statements described in bulleted text above Additional Details initialize total variable which will sum integer values entered initialize items variable which will build a string of the integer inputs separated with a new line character define the adding_report function with one parameter report that will be a string with default of "T" inside the function build a forever loop (infinite while loop) and inside the loop complete the following use a variable to gather input (integer or "Q") check if the input string is a digit (integer) and if it is... add input iteger to total if report type is "A" add the numeric character(s) to the item string seperated by a new line if not a digit, check if the input string is "Q" or starts with a "Q", if "Q" then... if the report type is "A" print out all the integer items entered and the sum total if report type is "T" then print out the sum total only break out of while loop to end the function after printing the report ("A" or "T") if not a digit and if not a "Q" then print a message that the "input is invalid" Call the adding_report function with "A" and then with "T" report parameters Run and test your code before submitting
It's a pointer to a pointer of a hash table
I was wondering if anybody help me with this? I need it for school. Some Assignment Requirements This program requires the use of **`while`** loop **`if, elif, else`** **`if,else`** (nested) **casting** of type, between strings and numbers The program should only use code syntax covered in modules 1 - 4. The program must result in print output using the numeric input, similar to that shown in the samples displaying "Items" and "Total". Program: adding_report() function This program calls the adding_report() function which repeatedly takes positive integer input until the user quits and then sums the integers and prints a "report". The adding_report() function has 1 string parameter which indicates the type of report: "A" used as the argument to adding_report() results in printing of all of the input integers and the total "T" used as the argument results in printing only the total Sample input and output: call adding_report() with "A" as argument (print all the integers entered and the total) Input an integer to add to the total or "Q" to quit Enter an integer or "Q"): 3 Enter an integer or "Q"): 6 Enter an integer or "Q"): 24 Enter an integer or "Q"): 17 Enter an integer or "Q"): 61 Enter an integer or "Q"): nine nine is invalid input Enter an integer or "Q"): q Items 3 6 24 17 61 Total 111 call with "T"(print only the total) Input an integer to add to the total or "Q" to quit Enter an integer or "Q": 5 Enter an integer or "Q": 7 Enter an integer or "Q": Quit Total 12 The forever (while True) loop diagram This diagram represents only part of the assignment - it is the loop and nested if statements inside the function. The code will enter at the while True loop after initializing variables. image of while True Loop with nested if statements described in bulleted text above Additional Details initialize total variable which will sum integer values entered initialize items variable which will build a string of the integer inputs separated with a new line character define the adding_report function with one parameter report that will be a string with default of "T" inside the function build a forever loop (infinite while loop) and inside the loop complete the following use a variable to gather input (integer or "Q") check if the input string is a digit (integer) and if it is... add input iteger to total if report type is "A" add the numeric character(s) to the item string seperated by a new line if not a digit, check if the input string is "Q" or starts with a "Q", if "Q" then... if the report type is "A" print out all the integer items entered and the sum total if report type is "T" then print out the sum total only break out of while loop to end the function after printing the report ("A" or "T") if not a digit and if not a "Q" then print a message that the "input is invalid" Call the adding_report function with "A" and then with "T" report parameters Run and test your code before submitting
Try Print sys.path
I did that and got ['/Users/{my name}/PycharmProjects/coms4771_hw0_code', '/Users/{my name}/PycharmProjects/coms4771_hw0_code', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages'] So, when I'm at the terminal and it defaults to being in the {my name} folder, where do I enter into before installing?
No. There are many more channels that are not pi related
What have you tried so far? And you might have better responses at r/learnpython
**Here's a sneak peek of /r/learnpython using the [top posts](https://np.reddit.com/r/learnpython/top/?sort=top&amp;t=year) of the year!** \#1: [Python 201 Book is Free for 48 hours](https://np.reddit.com/r/learnpython/comments/5814lw/python_201_book_is_free_for_48_hours/) \#2: [90% Python in 90 minutes](https://np.reddit.com/r/learnpython/comments/661o5a/90_python_in_90_minutes/) \#3: [Python 101 Book FREE for 48 hours!](https://np.reddit.com/r/learnpython/comments/5bmaz0/python_101_book_free_for_48_hours/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
No, thats just the name of the server
No, thats just the server name
In a production environment, with a higher volume, I'd do it as a Celery task. Enqueue all my URLs and let it loose. But for a personal project, there are a lot of things I'd rather do than deal with Celery's fiddliness.
Did you try run-&gt;edit configuration and add the path
I would switch to VS Code full time if only it was as quick as Sublime. I like a lot of the features of VS Code, but it takes way too long to open a simple text file that Sublime can open nearly instantly 
When you are printing statements, separate different elements of the arguements with a comma, not a plus. Example: myName = John Doe print('It is good to meet you,', myName) Prints "It is good to meet you, John Doe" to the console.
You're missing a single quote at the beginning of the "It is good to meet you" string. In general, it's better to post this type of question to r/learnpython. 
That sounds really interesting, how do you go about finding key that a tab is in? I am learning Piano, and this would be a pretty fun idea to not only cement in my own head all the chords, progressions and keys, but also to be able to learn new songs quicker from sheet music.
Naw man. He is literally the guy you ask for help and he does 2/3 of the work for you. Really. He did. His point is valid. We all start somewhere, and someone looks down on us for bogus reasons. In the spirit of improving the soft skills, let's try and improve the quality of the `joke` library...
Everything is explained how to do it in Python 2.... followed by how to do it in Python 3, why and how there is a difference. This is an abomination that will discourage anyone from learning. Only buy if you wish to learn the 2 and 3 difference in excruciating detail.
Perhaps it is inhaled in gaseous form?
That'd be "adepto excelsum off vestri equum". Even farmers can use Google Translate to their benefit.
An OpenID Connect CLI for authenticating to and switching between Reddit's Kubernetes clusters.
Thank you so much!!! This is the First time I use python and reddit, I'm sorry about posted it in wrong place.
ohhh, I see. I'll try this now! thanks!!
Even egotrippers should be able to understand the meaning of my comment. 
Nah, everyone knows Venezuelan junk bonds are always the way to go.
I agree totally. When I said "processes", I was thinking of `concurrent.futures` (for OP's problem) - although that makes doing it with threads stupidly easy too.
You can select/add interpreters for your project using the directions @ https://www.jetbrains.com/help/pycharm/configuring-python-interpreter.html. You can also install modules from within Pycharm... https://www.jetbrains.com/help/pycharm/installing-uninstalling-and-upgrading-packages.html
And anti-intellectual pedants should recognize a joke when they see one.
I need to look into that. Thanks for the pointer!
/r/iamverysmart see you there!
[r/The_Donald](https://www.reddit.com/r/The_Donald/) have fun masturbating and throwing your turds at others! If you don't get the joke, that doesn't mean you can't *try* to get the joke.
&gt; encapsulates some of the fundamentals one can't afford to miss Can you elaborate on 2 or 3 of them? 
I have been following Jose Portilla for 3 years, his work is outstanding and this course is highly recommended
😂👍
This is great, thanks!
I don't think they get how GitHub (or git) is meant to be used.
\* is the splat operator. \*\* is the double splat operator. See https://endofline.wordpress.com/2011/01/21/the-strange-ruby-splat/ and https://stackoverflow.com/questions/2322355/proper-name-for-python-operator JS calls "..." the "spread operator", so you may use that as well. But splat was here before. Don't use "unpacking". Unpacking is a specific operation you can do with the splat operator. But dynamic parameters are another one.
This is the name of the operation, not the operator.
-1. This is the name of the operation, not the operator. def foo(**bar) is NOT unpacking.
Oh it just wraps it in a thread. Check out https://github.com/alex/alchimia/blob/master/README.rst
Thanks for the link. I haven't used Twisted in a while so didn't know of this. There's some [aiopg](https://pypi.python.org/pypi/aiopg) support for SQLAlchemy which allows for asynchronous execution of basically everything. However I noticed when writing applications that the only thing that I'd like to background is long query execution. Creating a connection pool and engine is executed only once at app startup. So submitting queries to a ThreadPoolExecutor (with thread-safe objects) seemed like a simple thing to do. Although for the last few days, I've been thinking about using aiopg underneath. Not currently clear how the API should look like or how it would work internally. But it should be doable. That way I can also implement async/await style coroutines which tornado supports too.
bad bot
Please ban this piece of shit bot
What's ugly in: dt %&gt;% .[i, j, ...] %&gt;% .[i, j, ...] etc.? Of course i, j and the rest can get long, but it's pretty readable for someone knowing the syntax. 
[removed]
You're a dick, stop calling innocent bots bad. They don't know what they're doing, man.
Hi there! I'm the author of the tutorial Thanks for your feedback. I really appreciate it! I agree with you, I overlooked the motivation part -- after all, it's supposed to be "a complete beginner's guide", so I definitively should have worked on why one should care about learning Django, and what one could do with it. I will work on that and improve the tutorial! Thanks again :-)
Agreed. There should be a paragraph about what Django is, an example of what one might do with it, and why one would want to use it.
Hi! I'm the author of the tutorial No worries! I appreciate your feedback. I really do! I know the grammar is poor, as another commenter mentioned I'm from Brazil and we don't have much incentive to learn english there.. So I ended up learning it by myself The writing and grammar is always a struggle for me. So I'm constantly trying to improve it. In fact, I started this blog last year so I could write on a regular basis and practice my writing skills.. and also to share a bit of what I know about programming/python/django with a wider audience But I can relate to what you said regarding losing credibility. I feel the same way when I'm reading something in Portuguese and the grammar is poor. I will keep working on that!
Thanks for sharing!
Started with Python at my university (Coimbra) mainly because there was a group of teachers who liked the language and didn't want all that matlab/Java start. Having no background in programming it was really good because I was writing in English and running. Eventually this made me shift my masters into machine learning and helped understanding how to solve problems writing code. 
[Plenty here](https://mail.python.org/pipermail/python-dev/2017-September/149174.html).
* qt as /u/crabcrabcam says * [remi](https://github.com/dddomodossola/remi) * [toga](https://pybee.org/project/projects/libraries/toga/) I'm partial to just flask + vue these days. Easy to make cross-platform. Easy to make hostable. Maybe the mods could add a GUI section to the sidebar listing the main options that come up every week when this question is asked?
Fair point. I'm usually sitting in front of my computer for several hours to code so 30 seconds to open isn't a big deal 
I have some free time on my hands till university starts up and I'm not sure what to do. Lately, I've been thinking about helping out with something open source so if anyone needs help with a project let me know. I'm a python beginner 
&gt; Even worse than BASIC Come on, this is a great exaggeration. By the time you have enough programming skills under your belt to be bothered by Javascipt's idiosyncrasies you can already pick up a different language. 
I think it's capable of doing pretty much whatever you need. One thing I like about web2py is more or less pure python in templates. With django, working with their templating language sometimes it feels like your hands are tied and you have to jump through hoops to do purely presentational things. My reservation about web2py is that it has a lot less momentum than django. Also they don't seem to be very good at marketing it. web2py to django feels like mercurial to git. Mercurial is more or less technically as capable as git and does some things better and some worse but it just doesn't have the momentum. That's the reason the python switched to using git/github. Quote from [PEP 481](https://www.python.org/dev/peps/pep-0481/): &gt; There are really only two real options for this, Mercurial and Git. Between the two of them the technical capabilities are largely equivalent. For this reason this PEP will largely ignore the technical arguments about the VCS system and will instead focus on the social aspects. &gt; That's how it feels with web2py and django. Technically they are more or less equivalent give or take some features, but it's the social aspect. | | web2py | django | | --- | --- | --- | | github project stars | [1,458](https://github.com/web2py/web2py) | [28,002](https://github.com/django/django) | | subreddit readers | [242](https://www.reddit.com/r/web2py/) | [21,205](https://www.reddit.com/r/django/) | | stackoverflow questions | 1,920 | 151,595| To web2py's credit, it's a small community but they are helpful. Also they now support python 3 however there was no release for like a year which made me wonder if the project was dying. Hopefully they can add some marketing effort and realize it's not just technical aspects that determine the success of a project.
Mixed. Nice looking syntax, reminds me of Ruby. But "there should be one, preferably only one way to do it".
Seems obvious enough! I've done the pdb.set_trace() hack enough times to want something more straightforward.
I haven't tried it myself, but maybe look at [https://olefile.readthedocs.io/en/latest/](https://olefile.readthedocs.io/en/latest/) If you can convert the files to .docx they'll be much easier to work with. There's also a way to use LibreOffice from Python scripts.
There's some typos in there. Twice you refer to `sys.displayhook` when you mean `sys.debughook`.
Hi, I followed through the tutorial and found it easy to understand. So I look forward to future parts. However, there's an error with the folder structure. I had to move the `boards` app into the same folder as `manage.py` otherwise it won't work. So, instead of: myproject/ |-- boards/ &lt;-- our new django app! |-- myproject/ | |-- myproject/ | +-- manage.py +-- venv/ it should be something like: myproject/ |-- myproject/ | |-- boards/ &lt;-- our new django app! | |-- myproject/ | +-- manage.py +-- venv/ 
I have mixed feelings on this one. It's not that big of a deal to create break points anyway, especially with a simple editor macro. It would conflict with existing programs though, since I'm sure plenty already have a debug name defined somewhere. I know I've used that name as a flag to indicate that an application is running in a "debug" mode, providing extra control and subverting normal behavior that would affect production. 
I'd suggest `__debug__(*args, **kws)` or something similar. The PEP rejects a keyword implementation because "any new keyword could conflict with existing code." However, a new built-in function could also cause name conflicts with existing code - this doesn't seem to have been considered by the PEP. As a dunder it would be less likely to conflict as most developers should be following the best practice of not creating new dunders. Dunders are not unprecedented in the built-ins either - see `__import__(...)`. Just my two cents after a quick scan of the PEP. Edit: Forgot that Reddit used Markdown :/ and couldn't remember the way to escape so backticks it is. 
Does it work with raise? I don't like it because it looks like an assert statement.
Came here to report the same thing. &gt;sys.displayhook() would be called with no arguments. It returns whatever is returned from the underlying debugger entry point. debug() returns whatever sys.displayhook() returns. Both instances of sys.displayhook( ) should be sys.debughook( )
Lynda.com has some decent Python courses (if you ignore the Django ones), although I don't think you can pay by course; you have to pay for a membership and then you gain access to the courses.
&gt; Jumping into installing dozens of packages I went through article and actually only two packages were installed: virtualenv and django (or three if you count python itself). Though if you just glance at the screenshots, it might give an impression that many were being installed.
I use python-docx. It's enough for what I need. You should also really only support docx and not doc files.
As a builtin, it might still conflict, but any collisions will just shadow the builtin, and be 100% backwards compatible.
Overall, I like this feature. The only thing I disagree with is that I don't think eliminating the lint warning is a feature. I *like* having a warning emitted when I have a breakpoint set, so I can't accidentally commit it. In fact, I hope pylint will step up and emit a warning for the use of `debug()`. 
That's pretty much what I said :P I am not arguing that it shouldn't be a built-in, I am arguing that it should be a built-in called `__debug__` rather than `debug` in order to reduce the likelihood of collisions with existing code.
The sution, clearly, is to name the new keyword like a GUID.
Nope - "Whoosh is a fast, pure Python search engine library." It's hard to explain but you are in full control of the data being passed into Whoosh. You are not limited to having to point it at a text document. "Some fields can be indexed, and some fields can be stored with the document so the field value is available in search results. Some fields will be both indexed and stored." In essence, you could easily read the tags from a multimedia file and pass those in as an indexable field and have the file path to the multimedia file as a stored file. They talk a lot about "documents" in the Whoosh docs but if you read the glossary it actually defines documents as: `The individual pieces of content you want to make searchable. The word “documents” might imply files, but the data source could really be anything – articles in a content management system, blog posts in a blogging system, chunks of a very large file, rows returned from an SQL query, individual email messages from a mailbox file, or whatever. When you get search results from Whoosh, the results are a list of documents, whatever “documents” means in your search engine.` Hope this helps. 
The official documentation is very readable and has helped me a lot.
How worthy are these courses? If I just started learning Python and don't know which path to go, would it be useful?
IMO it's missing a _BIG FAT_ warning that it uses external service (friggin google !!!) for audio recognition.
`__import__` is an implementation leftover and should not be used. That's what the `importlib` is for. The double underscores are there to suggest that it shouldn't be used by the user. Also, new built in functions will not automatically break existing code (like statements would) because they can be overridden. If you want to edit your code and use the new `debug()` then simply do a find replace for `debug - &gt; debug_` or something. 
nah, splat is and old name for *. Read the classic: http://spot.colorado.edu/~sniderc/poetry/wakawaka.html
Looking at the last example of the page, I am sorry to confess that I prefer the classic way that uses indentation. I prefer to notice at first glance that the loop has a particular behavior, which is an advantage of indentation before a `break` / `continue`. These are two keywords that modify the expected behavior of a loop. To highlight them seems appropriate to avoid any confusion. However, it is perhaps the lack of syntactic coloring in the PEP example that makes me think like that.
 Your a jabroni too...
This was a great mixture of fun and horror
In some ways my goal is similar, but I’m looking at doing a hybrid client/server framework instead of just letting you write a SPA in Python - instead of doing AJAX calls to flask/pyramid/whatever on the backend your UI is bound to matching elements on the server, when you click a button that is bound to an action on the server it will send an event, the method is called, the UI is updated and a change set is sent to the client to update it’s local view. In many ways it’s similar to how old 5250 terminals work, the client is pretty dumb and just handles user interaction, the server still runs all the logic.
The only issue is that, in scripts that use variables called `debug`, you should use the old-fashioned `import pdb;pdb.set_trace()`. Does not sound terribly bad to me. Full disclosure: I have my fair share of `debug` flags in my scripts.
Nothing would happen with your program, the builtin would just get shadowed, and you can continue to use a macro to insert the "import pdb; pdb.set_trace()".
Thanks for the heads up! I fixed the tutorial :-)
`getattr(builtins, '28092962-0505-427a-be76-80511f6437fd')()` solved.
Would be interested to hear what the PyCharm guys think about this. Anyone know if they're on reddit?
I wasn't suggesting that people should use `__import__` over importlib - I was merely pointing out that the use of double underscores in built-in function names in special cases is not unprecedented. I disagree with your comment that "the double underscores are there to suggest that it shouldn't be used by the user" - in my opinion, they are there because otherwise there would be a conflict with the import statement keyword. Before importlib, what choice was there other than hacking around with `__import__(...)`? Sure, the new built-in function won't automatically break the code (as a result of a syntax error) immediately. It'll just break (by semantic error) when someone comes along in the future and tries to use debug() to add a breakpoint, at which point existing code will then be overriding that built-in. It's going to be annoying for that developer who has to rework a bunch of function names in code he/she didn't originally write in order to be able to make use of the new built-in debug function. I just think that, based on the fiasco between 2 and 3, extra effort and care should be taken to minimise the chance of disruption to existing codebases in order to encourage people to keep updating to the latest-and-greatest version of Python. That was my reasoning for suggesting `__debug__` over `debug`. P.S. It would also be easier to recognise as a special line separate from the rest of the code. 
Oh, look, another user with an account that is 99% udemy referral spam. Even if you like the course, don't use the link. 
That is an awesome way to learn a language. Keep it up, and thanks for taking the time to teach us what you know!
`__debug__` is already a python keyword anyway. https://docs.python.org/3/library/constants.html#__debug__
While I do subscribe to the quote above, that new syntax does read nicely. And I don't think it is a far away step from what is used in comprehensions, for example (with similar, if not the same purpose, btw). Most of my `break` and `continue` statements do indeed have one or two conditions. It does feel natural to have those right there, after the statement. I don't think we should stick to the above dogma in this particular case...
That's pretty much what they just said :P
How does that compare to makefile?
Thanks for posting. I saw this when it first came out, but it was great to rewatch it. Anyone know how he's doing the presentation? The slides with a Python kernel inside it? He seems to be editing text and running a interpreter in the same window as well. What black magic is that?
And the [magic flame animation](https://youtu.be/js_0wjzuMfc?t=40m52s) above the star import... Davis Beazley is fantastic at doing these live coding talks. 
Clicked around... not a single comment. Your README should include the "what", the "why", and the "how" -- not only the how to install it, i know no more or not less than when i first clicked to see your repo.
OP is a Udemy referral spammer. He's just trying to sell you something. 
But why? I don't see a reason for why this is better than using a debugger and setting breakpoints. Debugging is not part of my program, it's part of the development process.
Perfectly Pythonic.
&gt; I want code folding and autocomplete On the Windows platform, the Zeus IDE does Python code folding, syntax checking and auto-completion. The Zeus IDE is also fully scriptable and can be scripted using several scripting languages, including the Python language. Finally, the auto-complete is driven by Jedi. **NOTE:** Zeus is shareware, runs on Windows only and was created by me. 
Why not?
Such syntax creates a local variable called \_\_annotations\_\_ where the data is stored.
Things like `__import__` exist because the double underscores encasing a name have a special meaning. You arent supposed to call them directly, they are "magic methods". For instance, you dont call `__iter__` or `__add__` directly, those are called when you iterate an object or add, respectively. In importlib's case yea, maybe its just calling `__import__` for you. But /you/ dont have to know about it, because `__import__` is a magic method that you don't call in your own code.
If you are on Windows and have Word installed you can use `pywin32` to access Word's COM API.
The benefits seem very minor, relative to the problem of an additional concept for people learning/reading code to understand. Also, "there should be one, preferably only one way to do it" - seeing as most existing code wont use this form, it's going to be an extra tripping point for people that seems rather arbitrary (especially seeing as there is an already syntactically valid one-line form). 
It's funny that some code I see (actually a lot) explicitly uses the '_' import and even some guides advise you to. I never even heard of importlib before now. The more you know.
Or as my grandma used to say: 'Errare humanum est, sed in errore perseverare dementis'.
Impiarum animarum recta!
Because interactively setting a breakpoint on a particular line of code at the PDB prompt sucks and doing it more than once really sucks. we don't all use IDEs. It's nice to be able to add a line of code in your editor to trigger the debugger when you run your program from the shell. b(reak) [([filename:]lineno | function) [, condition]] This way I have to remember the full path to the file and the line I want the break point on. And I have to do it every time I start PDB. debug() the debugger starts itself for me on the line I told it to start on and will do it repeatedly with zero additional effort.