n is an input right? why don't you say PRINT*, n, r ?
We offer a Package Manager for Windows only that does include a Microsoft MPI library: http://packages.simplyfortran.com/package/69.html The Package Manager is only available for Windows, though.
Internally with Fortran? Probably not. Though you could do something along the lines of character(len=1000):: continueRead Other code here call system('gnuplot -p data_plot.plt') write(*,*) "Waiting to continue. Please input &lt;ContinueWord&gt;" RradLoop: do while (.true.) read(*,*) continueRead if (trim(continueRead) == &lt;ContinueWord&gt;) then exit ReadLoop end if end do call system('&lt;scriptToKillGnuplot&gt; Alternatively you could investigate the gnuplot options to see if you could have it last a certain amount of time - or to see if you can modify your gnuplot script to stop it from opening a new window each time. (Format code by including 4 spaces before it)
One way would be for you to set gnuplot to write the image into a file, and in the fortran code, modify the plot file each time, to change the name of the file it prints to.
[removed]
Non-Mobile link: https://en.wikipedia.org/wiki/Internet_bot *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^103108
&gt;I'm sad [Here's a picture/gif of a cat,](http://25.media.tumblr.com/tumblr_lzb7t4GleA1qgjltdo1_1280.jpg) hopefully it'll cheer you up :). ___ I am a bot. use !unsubscribetosadcat for me to ignore you.
I will be messaging you on [**2017-08-19 22:42:10 UTC**](http://www.wolframalpha.com/input/?i=2017-08-19 22:42:10 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/fortran/comments/6urpuu/program_prints_out_incorrect_value_for_standard/dluvur8) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/fortran/comments/6urpuu/program_prints_out_incorrect_value_for_standard/dluvur8]%0A%0ARemindMe! 1h) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dluvvmj) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
User 'redditer1945' has 9 comments in history; minimum requirement is 25. ----- [^^Info](https://github.com/trambelus/UserSim) ^^| [^^Subreddit](/r/User_Simulator)
The problem seems to be that when you get to the loop where you compute the variance, `x` (or in the latter loop, `y`) contains the _last_ value read from the file. This is obviously not what you intended. One simple way to do this would be to read all the values into an array first, and then compute both the mean and the standard deviation. 
Is there another way that it can be done? I'm not against the idea of using an array, but that is a topic that we don't cover until the next session, so i'm wondering if there's another way, as I'm assuming that's how I am meant to be tackling it. Thanks.
The problem is that `x` and `y` are "stuck" to the last value in each file after the DO loop which computes the mean. Consider closing the unit/file and then opening it again, and reading again element-by-element.
This works: program data implicit none integer :: R, F double precision :: x, ss = 0, mean, y, mean2, ss2 = 0, var =0, sdv, var2 = 0, sdv2 open(unit = 100, file = 'tmax_1910.txt', status = 'old', action = 'read') do R = 1, 12 read(100,*) x ss = ss + x end do close(100) mean = (ss)/12 open(unit = 100, file = 'tmax_1910.txt', status = 'old', action = 'read') do R = 1, 12 read(100,*) x var = var + (((x - mean)**2.0)/11) end do sdv = sqrt(var) open(unit = 200, file = 'tmax_2010.txt', status = 'old', action = 'read') do F = 1, 12 read(200,*) y ss2 = ss2 + y end do close(200) mean2 = (ss2)/12 open(unit = 200, file = 'tmax_2010.txt', status = 'old', action = 'read') do F = 1, 12 read(200,*) y var2 = var2 + (((y - mean2)**2.0)/11) end do sdv2 = sqrt(var2) print *, 'mean=', mean, 'mean2=', mean2, 'sdv=', sdv, 'sdv2=', sdv2 end program data But note that in order to get your values, I had to divide by `n-1` in the variance formula, since we've already "used" a degree of freedom for the mean.
Perfect. Thank you very much :)
Well, you could use a different formula for computing the variance: variance = average( x^2 ) - average(x)^2 . 
Never thought of that, thank you!
Thank you guys for the answers. I'm still not coming out with this, so I thought of another possible solution: writing the data in a file, without overwriting it, column by column like this: p_new(1:i,1) p_new(1:i , 2) ------------------- p_new(1:i , n) i rows x n columns but if i write: WRITE(30,*) p_new inside the DO WHILE cycle it gives back p_new(1:i , 1) p_new(1:i , 2). . . . p_new(1,i , n) n*i rows x 1 column Is there a way to specify the column to write in or simply give a "column break"? If I manage to do this I can try writing a gnuplot script to plot each column with a given pause EDIT: I tried using a rank 2 array but the n value is unknown so I can't specify the DIMENSION value
A side note: In practice, if you might have a lot of numbers to average, I would prefer the formula you're using over this one, however. That's because this formula could then involve subtracting two big numbers of the same order of magnitude, potentially giving poor numerical accuracy. Just a thought to keep in the back of your head if you're doing scientific computing in the future. (Which seems likely if you're learning Fortran.) 
The easiest thing for me was to write a pgf file as I used the plots in Latex. I wrote [some code](http://github.com/SolidTux/fpgf), maybe it is useful for you. But I haven't used it for quite some time and it's unfinished, so I don't remember exactly, how far I got.
Yeah, you're right. Thanks! :)
After the 30 day trial how much does it cost? I will need it for at least 3 months for a computational physics course. 
Thanks for the advice!
It costs [USD $139](https://simplyfortran.com/register/?platform=macos) after the trial expires, but we have a promotional coupon for Reddit users, *REDDIT25*, that will take 25% off the price.
Is that a one time payment?
Also, I am having a hard time to get it to auto indent for me, how can I make that happen?
Yes, it's a perpetual license for the same major version. If you bought today, you can upgrade to any version 2.x for free just by downloading and installing it.
Great! Thanks 
There is an option in the application menu under: Preferences-&gt;Editor... in the Language Features tab to enable "Syntactical Indentation." However, it appears to be broken on the Mac in version 2.38 (it's working on Windows...), which would be considered a bug. I'm looking into it as we speak. We don't enable that feature by default, though, based on user feedback.
I have used Visual Studio before. Only used it for small simple programs, such as I would expect from a programming course. The problem is you have to pay for the Fortran compiler. Maybe you can get access free through school? You're probably better off using computers on campus for Unix or Mac programming.
gfortran is a good free compiler, basically the default if you don't want to shell out money for one. From there you only need to get a good IDE to work with. Lightweight editors such as Notepad++ or other open source editors are pretty easy to find. 
Silverfrost has always worked well for me. http://www.silverfrost.com/default.aspx
i have silverfrost with plato here, which has some flaws sometimes, like editor fields turns bright yellow after minimizing during running the code. :D had to restart and it was working again.
just found this one. i see it is free to use for personal. ever had problems with it?
You should be able to get the student version of the Intel Fortran compiler.
Intel Visual Fortran is free for studying with .edu email addresses. 
Simply Fortran is a fantastic editor. It even has its own package manager which really makes things easy. https://simplyfortran.com/
One option is MinGW for Fortran which is a port of GNU Fortran to the Windows platform. This [link](http://www.zeusedit.com/phpBB3/viewtopic.php?t=6960) show to setup that package on Windows. 
i dont want to invest any money into it, as i probably never will use fortran again. but i could ask around with the students have used the last term for the course to prog fortran. :)
great i will try it out.
code blocks:: + gfortran :)
The student license for the compiler is free.
ohh i see codeblocks has fortran package. i have used codeblocks before and i think i will stick with it. i can even use the same compiler i have in silverfrost-plato. thanks!
A couple of options: https://www.pgroup.com/products/community.htm http://www.equation.com/servlet/equation.cmd?fa=fortran
if you work on linux, there would be more options
i know linux has there more, but im so used to windows and dualboot has not enough space on my SSD.
I just wanted to add that Simply Fortran is [Certified for Windows 8.1](http://simplyfortran.com/features/compatible) and the primary developer (me) does tend to show up on reddit regularly. We have a new version coming out next week, so check back on Monday!
alright i will keep an eye on it.
This. I've been using **gcc** in a mac and I never had a problem.
OP might have some issues if you are using dev beta. EDIT: ~~[The bug is still not fixed in the latest beta.](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81797)~~ EDITEDIT: The bug is fixed. 
Can you use intel compilers with it and does it integrate with CMake? 
It is theoretically possible to use with Intel compilers, but it is not a supported configuration. You can specify the Fortran and C compilers within Preferences (under "Compiler"), and they can be pointed at Intel's compiler. Simply Fortran makes some assumptions about compiler flags, though, so it could be problematic. It does not integrate with CMake at all. Fortran dependencies are calculated and handled internally by the development environment. Simply Fortran generates simple Makefiles with proper Fortran dependencies.
pm me i'm in the same boat
A negative to a decimal power, e.g. -8^3.2 gives an imaginary result. Raising a negative to an integer is not imaginary. If you made c an integer, the calculation would work. I think it would also work if you made b imaginary. I'm just guessing and haven't tested this, but I think it makes sense. 
When calculating x ** y where y is a REAL, FORTRAN converts it to the equivalent logarithmic expression 10 ** (x*log(y)). If y is negative, this does not evaluate to a real expression, so it throws an exception. (I'm not actually sure if it uses base 10, but you get the idea.)
&gt; I don't really 'mind' if knowing such an 'old' programming language would give me a future job later in life. Fortran definitely isn't a completely dead language. It remains a very valid choice for high performance numerical computing and is pretty standard in a number of fields in the sciences (I only have personal experience with computational atomic / molecular physics here). Also, having *any* programming experience at all is useful for job experience - if you have enough experience in a programming language it's useful to list on a resume otherwise just being able to program makes it significantly easier to pick up new programming languages as needed as well as just automate a lot of job tasks. &gt; if there are any good resources for me to really get mastering the language. There are a few books on modern Fortran I could recommend (Fortran's changed a *lot* since Fortran 77 days, and unfortunately a lot of the information out there online was written with Fortran 77 or Fortran 90 in mind and not newer standards) but they're probably a bit advanced. My best advice (for any programming language, really) would just be to write things in it, the best way to learn any programming language is to actually do stuff in it. &gt; Fortran has been the best and only calculator I have for this job. For your purposes, you may also like Python because it's a bit less verbose of a language than Fortran. For instance, in Python 3, the program you copied in above could be written as: from math import sqrt z1 = 1 + 1j z2 = 1 + sqrt(3) * 1j z3 = 0.5 - sqrt(3) / 2 * 1j print(z1 * (z2 - 2 * z3)) I would also recommend doing your math homework the way your teacher expects as well, at least until you are confident you understand the assigned concepts.
You should post an attempt.
Python and Fortran go hand in hand. 
I have been writing in Fortran 77-08 for past decade in the field of quantum physics. Great language. But indeed, for simple calculations there are less verbose approaches. Python is one, as noticed, but you can try J too: z1=:1 j. 1 z2=:1 j. %:3 z3=:0.5 j. --:%:3 z1*(z2-2*z3) _3.4641j3.4641 
Try the csv function from [FLIBS](http://flibs.sourceforge.net/)
The header write needs to be done before you enter into a loop. I can't tell exactly what you are doing here because the code sample is so limited. If this code is inside of a do loop, you need to move both the open and the header write statements to just before the beginning of the loop. As it stands right now, you are opening the file and writing a header at each iteration. You also can't close the file in the loop, close it after the loop is done. 
&gt; I don't really 'mind' if knowing such an 'old' programming language would give me a future job later in life. It may not be common, but it might as well land me a special job in a legacy company. Maybe... Not to totally rain on your parade, but this just isn't a realistic expectation. The reason why is because of the contexts where people build expertise with Fortran - and that's in graduate work and scientific research doing high-performance calculations in physics and other numerical computation. So just knowing a bit of Fortran doesn't really provide you any advantage on the market, because you're going to be competing with people who hold PhDs and a decade+ of work in domain specific applications of the language. If you *really* want to dive in, there aren't too many modern texts I'd recommend on the language. [Chapman's "Fortran for Scientists and Engineers"](http://www.mheducation.com/highered/product/fortran-scientists-engineers-chapman/M0073385891.html) is my favorite of what's available - it teaches the language but also introduces more modern concepts which will benefit you. Otherwise, I'd echo the sentiment of stepping away from Fortran and moving towards Python. If you really want to be cutting edge/esoteric, you could play with Julia, or even Chapel. But unless you *need* to hack Fortran code, don't waste your time with it.
Fortran is great, but keep in mind that for simple things, it's almost always easier to use Python. In Python you can just do: &gt;&gt;&gt; from math import sqrt &gt;&gt;&gt; z1 = 1+1j &gt;&gt;&gt; z2 = 1+sqrt(3.)*1j &gt;&gt;&gt; z3 = .5-sqrt(3.)/2.*1j &gt;&gt;&gt; z1*(z2-2*z3) (-3.4641016151377544+3.4641016151377544j) There is a useful role for Fortran, and there's a good reason to keep it alive for simulations etc, but if you just want a complex number calculator, there's a bit less boilerplate in Python.
You want this bit: WRITE(ONE,200) T,',',X,',',Y,',',Z 200 FORMAT((E12.6,A)) to be in a loop. Ideally though, you don't want to use line labels, and should try for a more Fortran-90 style as well.
&gt;guessing that I'm the youngest in this subreddit who is interested in Fortran? Nope! Got you beat there- 16 year old high school student who's been exploring Fortran. I'm going to go along with the other replies here and say that if what you want to do is have a calculator, then fortran might not be your best bet; I'm pretty competent in python too, and for doing simple stuff it's just much simpler and there's less mucking around with the trivia of what you want to do. On the other hand, if you're looking to have fun with the language, fortran's not such a bad idea. IMHO some of its syntax is way nicer than python (for instance subroutines, which modify the variables you pass to them, don't really have an equivalent without getting bogged down in global statements or classes), plus especially if you're getting started the rigor fortran demands of you might well help (once you've gotten past syntax errors it's easy for everything to run but be totally wrong (wrong type, messing up indents...), and that's a pain to debug in a way that fortran doesn't suffer from. The single most important thing though is that this *really* shouldn't be more than a crutch. Yes, learning a language is useful whatever the language is. But if you don't understand that math underneath, you're really going to suffer later when you either don't have your calculator in the test, or don't understand enough math to implement your problems. Also, I thought [this](https://www.mrao.cam.ac.uk/~rachael/compphys/SelfStudyF95.pdf) was kinda useful; seem pretty comprehensive
Can python work with complex numbers? That was the main thing that attracted me to Fortran.
Python works really nicely with complex numbers; you can work with them exactly as you would write complex numbers normally; the basic operations all work exactly as with normal numbers. For example. this works straight off the bat without any module imports or anything: z=(4+5j)*abs(7+9j) The only real difference is that you use j instead of *i*. It being python, there are other ways to do this, but I think this way is pretty simplistic. Plus, if all you want is a calculator, the fact that you can run python interactively is a huge advantage. There's also the [cmath](https://docs.python.org/2/library/cmath.html) default module, which is pretty useful.
Ooooh that's cool. I still like Fortran but I'll have to step away and get to know Python for a bit.
Technically it can do anything any other programming language can do, because it's Turing Complete (at least Fortran 90 should be). It doesn't mean it's *easy* to do. I usually suggest people to make their math stuff in Fortran as library functions/modules and the rest in more suitable languages (generally C/C++) and call the Fortran functions as needed, using ISO C Bindings.
You would be surprised what Fortran can do. My PhD supervisor wrote an entire GUI plotting program using winteractor. Obviously most if what we did what the number crunching, but it was nice to have the results visualised straight away. 
I usually find there isn't much reason to go over to C++ or C from Fortran unless you are using a library only written in those languages. Now using a language like Python to manage your Fortran codes is something that can be beneficial since Python is significantly easier to write a lot of different packages in. 
It really depends on what you are doing. Consider for example, doing number crunching in C/C++: it's completely possible but in general is a pain in the ass compared to Fortran (think matrix operations). Now think about creating a GUI in Fortran: it's also possible (as another redditor said) but I'm sure it's a pain in the ass compared to C/C++. In my experience, doing *anything* that's not number crunching in Fortran *is a pain in the ass*, except for simple stuff.
Right but odds are if your goal is to do a GUI then you have a lot of choices other than C++ including Java, C#, Python, etc. GUI can be done with a lot of different languages these days and frankly I find C++ is one of the more irritating languages to do a GUI in. If you are writing in a lower level language odds are you are writing something like a simulation code that is performance critical. Which usually implies you don't care too much about a GUI. And even if you do want a GUI you can still segment the program where the GUI basically writes and submits the script to the actual number crunching code. 
And that is conceptually the same as what I proposed. Do the number crunching in a library/module in Fortran and the rest of the program in a better language.
How so? Could you give some examples where I can benefit from brushing up on my old rusty Python skills?
Python's primary advantage is that it is a simple dynamically typed language that allows you to do a lot with a little code. Between the standard library and 3rd party libraries you can do a ton of heavy lifting with Python without a lot of investment. However, the downside is Python is slow. If you write number crunching codes in it you'll find quite quickly that it is slow beyond belief. The advantage of Fortran is that it is fast and geared for computationally heavy processes. You can mix and match the two languages to match each language's strength. For example I use Python for logic flow control of several of my projects, IE figuring out which calculation to run and setting up all the relevant parameters. Once it's decided it passes it off to a simulation code written in Fortran which can crunch the numbers more readily than Python. 
Zork, the classic text adventure, was originally written in Fortran. You can really do anything in Fortran, but generally it's best to stick to number crunching, because there aren't very good libraries for GUIs etc. Generally you either do a big numerical calculation in pure Fortran, or you use Fortran to produce libraries for slotting into Python or something.
I think the point is the particular example of wrapping Fortran with C or C++, which seems like an odd choice. You're wrapping one fairly low-level language with another fairly low-level language. Usually the point is to wrap a fairly low-level language like C or Fortran with a much higher-level language like Python.
I just like to mess around in Fortran from time to time. I use gfortran cause I am a real pleb.
&gt; I was wondering if there are any "young" people doing Fortran Do you consider 26 young? If so, me. Using a programming language to do math homework isn't necessarily cheating. One thing to watch out for is the test, your homework should be practice for the test and I can guarantee if you think writing a little Fortran is cheating then you won't have access to a programming environment on the test. In college I used a myriad of tools to help with my math homework, C, GNU Octave, and Mathematica. But I always made sure I worked through the homework assignments with pen, paper, and my HP 50g which is all I'd have on the exams that accounted for about 75% of the final grade. And as a computer science major with a mathematics minor, I did a lot of math homework. I keep a copy of this book on my desk at work: https://www.amazon.com/Explained-Numerical-Mathematics-Scientific-Computation/dp/019960142
One of the first FORTRAN programs I worked on calculated the tides,so yes that's number calculations, but its quite an ability to know the tides, and really what can not be reduced to number calculations ? 
This is not a Fortran issue, but a math issue: raising a negative number to a real power is not defined! Note that your first print statement is not raising -8 to the 1/3rd power, but taking a negative of 8^(1/3) . Edit: Of course, a cube root is defined, and the cube root of the negative number (-a) is -(a^(1/3) ). So you could compute it in Fortran that way. Edit 2: In general, you could compute the cubic root of the real number `x` in Fortran as `sign(abs(x)**(1.0/3.0), x)`. (That is, |x|^1/3 * sign(x).) 
Thanks for responding. Embarrassing brain freeze on my part.
It happens
# Sidenote Yes, it is not a very good idea to just trust one set of figures on running times because they can vary on each run. However, before sharing these results, I have tried running these 4 programs many times; they produce results around these averages. So, I can say that the results depicted in the screenshots are pretty good averages. In all the trial runs I've ever done, it can be seen modally that the speed rankings were (from fastest to slowest): - C - Fortran - Python3 - PARI/GP
# UPDATE The imgur community thankfully commented that I should use the `for/range` loop in Python instead of the `while` loop for optimization reasons. For this test to be fair (any class on statistics should teach their students that their tests should be fair!), I've decided to update the code and print the new results on the running times. Here are the new running times (from fastest to slowest): 1. C: 1.849 s. 2. Fortran: 1.858 s. 3. Python3: 9.937 s. 4. PARI/GP: 1m 3.595 s.
# UPDATE #2 For those who would like to point out that the Riemann sum in PARI/GP could also be implemented using the `sum` function. Then, I have done it! Here is the code for PARI/GP: \p 7 /* Initializing settings */ a = 0 b = Pi n_lim = floor(1e7) /* Leave this alone */ dx = (b - a) / n_lim r = sum(n=1, n_lim, (sin(a + (n - 1) * dx) + sin(a + n * dx)) * 0.5 * dx) print(r) quit The running time has now reduced to `56.768 s.` On the ranking board, this doesn't make any difference to PARI/GP's stance: it is still the slowest. :(
&gt;Anyone got any advice? Yes. Start by posting your FORTRAN code here for us to read. Then we can get a better idea of what we are working with. And any comments for clarity.
The Code is in a textbook so i can't post it. :/ but there's a PDF of the textbook [here](https://github.com/ThePolywellGuy/Polywell-Papers/blob/master/1985%20-%20Berkely%20-%20Plasma%20Physics%20via%20Computer%20Simulation%20-%20Birdsall,%20Langdon.pdf) The code is split up over pages 50 to 73. I realise that's pretty awkward sorry.
I bet you can reduce python to almost C-like speed using Numpy.
You will be shocked and amazed if you run the Python example through pypy instead of cpython :) Edit: Here's a Python example using numpy which is *faster* than C. Unlike the pure Python example, this will not benefit from pypy. #!/usr/bin/env python3 import numpy as np a = 0 b = np.pi n_lim = int(1e7) dx = (b - a) / n_lim sinx = np.sin(np.linspace(a, b, num=n_lim + 1, dtype=float)) r = (2*sinx.sum() - sinx[0] - sinx[-1]) * 0.5 * dx print(r) 
I would translate the Fortran to pseudo-code, and then write Matlab scripts from the pseudo-code. For instance, you can write a function for each operation and call the relevant functions in sequence. 
1. All lines beginning with a `c` are comments. 2. Find out what the basic "data types" are, and identify them. 3. `parameter`s are constants. 4. `use` makes routines (functions, etc.) in a separate `module` file accessible in the current program. Start with these and look up structures one by one as you encounter them. Can someone tell me what the `CLICHE` construct in that, is?
uh huh, ok. Thanks for taking the time to look at that. I appreciate it.
And this is not a two-hour job for a person who does not know the language. Definitely not if you also do not know the language you're translating it into, very well. Also, if you're going to have to learn Fortran anyway, why not use it instead of Matlab?
In my experience Fortran code is very similar to MATLAB code except for that MATLAB code is not explicitly typed.
It seems to me that the code is not quite Fortran 77, despite what it says in the book (being a bit pedantic here, it's Fortran, but not following the Fortran 77 standard). A bit of googling on the `CLICHE` construct makes me think it is actually written for [MPPL](https://wci.llnl.gov/codes/basis/pdf/mppl.pdf), a Fortran preprocessor I had never heard of before. I don't think this would be a two-hour job even for the person/people who wrote the original code. This is a two-hour project only for a professor who doesn't have to do it him/herself. 
Your fortran r is only a regular float. And the factor of 0.5 is also only single precision
Argh. Sorry, I tend to miss little details here and there. :(
Interesting. :)
No idea whether it'd speed or slow anything. It's a common fortran one so I'm used to watching out for it :)
How about adding Jullia?
Pypy is good when it works, but I've found times it was slower than vanilla Python. Python JITs are still a little unreliable right now. Edit: Oh sorry, didn't know stating my consistent experience with PyPy was downvote worthy. *sigh*
You have to do cmplx(0.0,1)*beta . Or define imag = cmplx(0,1), if you use it more often.
darn "cmplx(0.0,1)*beta"... this!... So obvious :)) Thanks!!! 
By the way if beta is complex, saying that i\*beta = (0.0, beta) (i.e. real(i\*beta) = 0 and imag(i\*beta) = beta) is horribly wrong. 
I remember this, thanks! I wanted to leave it simple for redditors to read :)
From your description, it sounds like you need to use bigger integers for `mult` and `mask`. Or floats, depending on how they are used, if they need to be integers. You could also ask the NERSC helpdesk to help you troubleshoot it. I've had good experience with them in the past with any issues I've had (although my issues have usually been problems with the installed modules/libraries causing mysterious error messages and crashes, not trying to make legacy code run). I feel your pain, though. Poorly documented, unmaintainable legacy code is a really common problem in academia. 
1) I'd probably start by using a namedtuple, at least if the purpose is to translate the code to Python (and then maybe make it more pythonic) and not redesign it completely. 2) The line `place(i)%villagename(1:1)=char(64+i)` sets the first character of the `villagename` of `place(i)` to be A for i=1, B for i=2, etc. That is, `char(n)` gives the character corresponding to the ASCII code `n`. 
Yeah, NERSC helped me in the past too. But so far they haven't been able to help with this latest and more serious problem. I'm painfully trying to track down where the problem is by putting write() on the code, compiling, sending the job, looking at output, repeat. Simply changing the size of integer isn't too simple because the code is big and I would have to change a lot more than that. But eventually I'll try that too. Thanks for helping :)
Thank you very much for your help! I had *just* found this when you posted. http://northstar-www.dartmouth.edu/doc/solaris-forte/manuals/fortran/f77_lang_ref/A_ascii.html I independently hit on the idea of using a dictionary of the form: input_dict[key] = [ line[0], line[1] ] but i will look into namedtuple. Thanks. Right now, I am struggling with the unif and init_unif statements - I think I need to be calling something else for x86_64, so I cannot verify I am getting the same output in both scripts. Thanks again! 
Should be a little careful with those warnings. Some old random number generators rely on tricks with the sizes of integers. You may also try putting in some compiler flags to trap floating point exceptions and then run the code through a debugger. Something like DDT if you have to use MPI with the code to get the error. Though if you can get the problem to happen in a non-parallel build then that is much easier to deal with. Also, yes Intel compilers are notorious for fudging FP in the name of optimization. You might try using some of their flags to be more strict about floating point optimizations (see "man ifort"). GNU has similar options. Newer GNU might have some issues, but is usually "safer" than Intel's stuff. Moving between systems with different SIMD widths can also be an issue if your code is very sensitive to numerics since floating point math is not associative.
&gt; Simply changing the size of integer isn't too simple What happens if you try compiling with the `-fdefault-integer-8` flag with gfortran? That should force the integer kind to be 8 bytes instead of the default 4 without having to modify source code (unless the integer kind is set manually in the source code), but it will come at a performance hit (how noticeable of a performance hit is nearly impossible to predict until you try it).
I just figured out why intel compilers stopped working a couple of grad students ago (grad students as unit of time). The code has its own definition of ranf() but intel introduced its own. It does not complaint or accuse a conflict, it simply uses its own!
As /u/StandardIssueHuman said, the problem appears to be that you are trying to store an integer &gt; 2^32 in a 32 bit array. /u/kramer314 pointed out some compiler flags that you can try. But to me it looks like this is part of a function/subroutine (as in, parameter() looks like a function/subroutine). Given that the code is legacy, could you replace this random number generation with a call to random_number()? 
Fortran cannot handle returning multiple values. Your options are: 1. Call the function twice 2. Use a subroutine: make_two_random_numbers(seed, output), where output is a length-2 array that you pass in and that the function fills.
You could use a `SUBROUTINE` rather than a `FUNCTION`. And then have an array of size 2 as `INTENT(OUT)`. In the end, you'd have something along the lines of `CALL muller(seed, myArray)`
I used this exact snippet in an old code without knowing why and it's name. Thanks for sharing! 
Ziggurat is much, much better in terms of computational expense.
Your crash is likely related to the fact that you are attempting to allocate the U vector more than once. 
Various problems here: first, the assignment U=0.d0 is probably causing the segmentation fault since there is nowhere to write to, as the array hasn't been allocated yet. You need an array constructor to initialize an array such as (/ 0.d0 /) . Then there is problem that you can't "grow" an allocatable array like you are trying to do here. First, an allocated array cannot be allocated again without deallocating it beforehand, so the ALLOCATE(U(suma)) will give you trouble after the first iteration. Then, you can't count on the contents of the array being the same after reallocation, that means if you allocated U(1:3) to some data, after resizing to U(1:4) for example, it is not guaranted that (1:3) will be the same data you had before. You need a working array to store the intermediate results. On the algorithm side, take a good look to see if the upper limit of "m-1" makes any sense, perhaps you should stop sooner to avoid unnecesary iteration (hint: SQRT). 
It would be useful if you included the compilers along with the compile flags used
Is this code F77 or older ? Would it be possible for you to make the interfaces explicit ? Do you have access to the NAG fortran compiler ? I would try to make as many of the interfaces explicit and recompile with a good debugging compiler (NAG) and maybe even G95, enable every runtime check and start digging.
you could simply make the LCG function return a 2 element array and your other muller procedure accept that as input OR use the function generator as a procedure argument and use it twice inside the muller procedure (so you call a dummy function inside, that points to the real function)
It's F77. I really want to try to use a debugger but I'd have to figure out how to do that first. They have instructions so it shouldn't be that hard. Right now I'm doing something a little simpler, just adding write() on specific parts of the code to see when the variables break, and little by little I pull this thread. It's painful but it's working. I'll see how far I can go that way.
Thank you very much for your help. I finished the code thanks to your advice :D However, the higher the optimization, the higher is the mark we get. I created a new array called V, which a very high size. I put there the prime numbers and then passed them to the "U" array. However, I think this is not very efficient (I mean, using a very large Vector to store the numbers). Do you imagine other way of simply storing the prime numbers directly in the "U" array? The thing that fucks me is that the "U" array has to have the size of the number of prime numbers... Well, This is my new code: program Numeros_Primos implicit none integer :: i,n,ndivisores,m,suma,suma2,j,V(15000) integer, allocatable :: U(:) write(*,*) 'Escribe un numero:' read(*,*) n suma=0 do m=2,n-1 ndivisores=0 do i=2,m-1 if(mod(m,i)==0) then ndivisores=ndivisores+1 endif enddo if(ndivisores==0) then suma=suma+1 V(suma)=m endif enddo allocate(U(suma)) suma2=1 do i=1,suma U(suma2)=V(suma2) suma2=suma2+1 enddo do j=1,suma write(*,*) U(j) enddo deallocate(U) end program Numeros_Primos What do you think about it? Maybe some optimization can be done? Thank you very much though for all your help, I really appreciate it :)
The first and most important optimization is the upper limit on the iteration "do i=2,m-1", think about it, do you really need to try if a number, say 999, divides 1000 ? Then, you have this loop: do i=2,m-1 if(mod(m,i)==0) then ndivisores=ndivisores+1 endif enddo you dont actually need to know how many divisors each number has, only that if it has ONE, then this number is discarded as prime. So if you condition "if(mod(m,i)==0)" evaluates to .true., then you just need to CYCLE the outer loop (use labeled DO loops for this). The V array idea works if you have a crude idea of the size if your problem, however a good code would make V ALLOCATABLE in case you ever run out of space in it too. If you do, you allocate a V to a new size plus a buffer, so you don't make constantly succesive allocations (you need a variable to hold how many elements in V are actually valid). This array method is however just a "hack" for this problem, what you really need is "linked list" derived type with the associated procedures (a class). You can grow this structure indefinitely as your memory can allow and there is no fiddling with reallocation of arrays.
 Bro .. you are trying to find a needle in a haystack by hand, I suggest using a metal detector. judging by your last paragraph in the OP I think the situation calls for it. Did you recompile using every check availiable with your compiler ? overflow, underflow, array bounds check, uninitialized variables, etc ?? Code will run slow as hell, but there should be a small test data where that shouldn't be an issue.
It seems I'm so close. But it might be the case that it will always seem like you're close. I'll take your advice and look into using a debugger then.
Your loop is only adding the current array element to the previous array element, rather than the cumulative sum of element. Try renaming tmp to running_total then writing out the logic for the first 3 iterations to see where the fix needs to be.
you dont want tmp to be an array here. For the loop think sum=sum+array(i)
Maybe try quoting the paths and using windows path \ instead of / gfortran -o "C:\Users\Me\Documents\file.exe" "C:\Users\Me\Documents\file.f90" Sometimes Win10 is more picky than 8. 
What happens when you first CD to the right directory and then just call gfortran with the file names only, no paths? In Windows, if you right-click a folder while pressing Shift you have the option of opening a cmd or Powershell in that folder directly.
Forgive my newbness, but I've never had to use cygwin from powershell. Can you show me how?
You probably don't want to name your variable sum since Fortran does allow you to overwrite the intrinsic SUM function.
Hello! i didn't know myself, not much of a windows user, but this has the answer: .\file.exe https://social.technet.microsoft.com/wiki/contents/articles/7703.powershell-running-executables.aspx
*insert thats_not_a_bug_its_a_feature.png* :-(
Yeah it's an annoying hold over from the way Fortran used to handle functions in the F77 day. 
You probably shouldn't name your variables the same as intrinsic functions in any language - it makes it harder to read your code, because people would assume that it's the intrinsic unless they go all the way up to the re-definition. In particular, if you make `sum` an array, then someone seeing `sum(x)` would naturally assume it was the intrinsic function.
I think it should be? It's my understanding that anything that's written to be purely serial is, by definition, thread-safe.
I agree. The difference is that in most other languages the compiler is kind enough to set you straight instead of maliciously complying with a request to eclipse an intrinsic/reserved word. Thus the "it's not a bug it's a feature" jab. If you can't tell, I have been burned by this "feature" while learning Fortran and am totally not bitter about the experience.
Well it depends on how the routine works internally. Accessing globals without a lock, that sort of thing. So I talked to the resident Fortran guy and he told me that COMMON are global data and SAVE are static data (to use C terms) and those would be a problem, but even beyond that, it would be up to the compiler to compile any given local variable as auto or static, the language doesn't guarantee anything. This is all Fortran 77. In the end I ran f2c through the part of the library that I use and I found many static variables. Functions precomputing stuff the first time they run and then checking a flag, etc. Not just an artifact of the translation. It seems the answer to my original question is no, and now I'm massaging the f2c'd code to make it so :-/ 
So, I don't know what you are trying to do here. But here are a few notes about the code. do l = -25, 25 lattice(l,:) = 1 !occupied initial end do This can be written as lattice = 1 do i=1,5 rn1 = lcg() rn2 = lcg() x1 = r*rn1 y1 = r*rn2 print *, x1, y1 end do Here you are generating 5 random numbers, but you are only saving one of them, so this is equivilent to rn1 = lcg() rn2 = lcg() x1 = r*rn1 y1 = r*rn2 I don't know what you are trying to do here. In terms of the j loop, I strongly suspect that this isn't right. do j=1, 50 if (lcg() &lt;= .250) then y = y + 1 else if (lcg() &lt;= 0.500 .or. lcg() &gt;= 0.251) then y = y - 1 else if (lcg() &lt;= 0.750 .or. lcg() &gt;= 0.500) then x = x + 1 else if (lcg() &lt;= 1.000 .or. lcg() &gt;= 0.750) then x = x - 1 end if S = S + 1 end do So, the way Fortran works is that it evaluates the first if statement, and if it is TRUE, it executes the statements following, then jumps out of the if loop. In this case, every time you call lcg() you get a different random number. This means for each separate condition, you are testing against a different random number. (I think that this is how Fortran works, but I don't have a compiler handy right at the moment so if I am wrong can someone please let me know). So, looking at the second conditions else if (lcg() &lt;= 0.500 .or. lcg() &gt;= 0.251) then the current behaviour is that it generates a random number and checks to see if it is less than or equal to 0.5, and then generates a new random number and checks to see if it is greater than 0.251. If either of these evaluate to TRUE then it will execute the following statement. I suspect what you want is do j = 1, 50 var = lcg() if (var &lt;= 0.250) then y=y+1 else if (var &gt; 0.250 .and. var &lt;= 0.500) then y= y-1 else if (var &gt; 0.500 .and. var &lt;= 0.750) then x= x+1 else if (var &lt;= 1.00) then x = x-1 end if end do This will give a 25% chance of increasing x, a 25% chance of decreasing x, a 25% chance of increasing y and a 25% chance of decreasing y on each iteration. If you wanted the original behaviour, you are better defining variables for each element that you are comparing against or debugging will be a nightmare. Your size S is going to be 50. Always. Finally, is there a reason that you have your own random number generator? Does it produce some kind of strange distribution? If you are looking for a uniform distribution in Fortran, then you can use random_number() and random_seed() (to set the seed). If you don't want a uniform distribution, then I would suggest using a third party library (specifically mkl, which is free and I believe works with gfortran) to generate your distribution instead. Linking to mkl from Fortran can be a pain though. 
Yup, global variables and save would break thread safety (if the routine is varying them). How you fix this depends on what thread method that you are using, is it OMP? Because if it is then a dirty dirty hack is to declare all of the global variables as FIRST-PRIVATE, which will set them to be private for each thread and initialised to the starting value. This has a pretty high chance of breaking your code though.
Oh wow, thank you very much - this has helped me a lot. The task is part of an assigment, and we previously wrote a program to generate pseudo-random numbers. This has then linked in to the current assigment, as we need to use it as a function for the DLA simulator.
If you post (or PM) me the assignment I can probably give you some pointers - I'm not going to do it for you though.
Wow, thanks very much! It's a lengthy assigment, so i'll send you the summary. 
I just want to add that you can simplify the code a little bit more, because you're using `else if`: do j = 1, 50 var = lcg() if (var &lt;= 0.250) then y = y+1 else if (var &lt;= 0.500) then y = y-1 else if (var &lt;= 0.750) then x = x+1 else ! assuming var can't be &gt;1, you don't need an if here x = x-1 end if end do 
Ohhh that's very true, thanks!
&gt; I would also recommend doing your math homework the way your teacher expects as well, at least until you are confident you understand the assigned concepts. I actually used to do the same thing when I was in high school, but with VIC-20 BASIC (this was the early 2000's). To be honest, it actually helped me study better. It's hard to explain, but I was basically able to focus more clearly on the order of operations and was able to visualize the results better.
I agree and disagree with this comment at the same time. The biggest issue is that there aren't many FORTRAN jobs today, and if it's anything like the COBOL scene, the jobs will probably involve migrating away from it. On the other hand, there is way less competition with other job candidates, so it is much easier to obtain the job when you do find it. I do want to emphasize your last statement though. It's nice to know FORTRAN and I really enjoy the language, but spending too much time with it can hurt the OP's career if he doesn't keep up with "modern" languages as well. I've been searching for jobs lately and some of the development teams are looking at me strangely because of my previous FORTRAN experience.
Did you try the instruction manual? http://www.cchem.berkeley.edu/jsngrp/fortran_files/dualfoilfaq.pdf
I've tried reading the instruction manual, but none of the content in it is relevant to my problems. I don't need help understanding the parameters inside the program, I need help with the basics of getting the program to run on windows 10.
For me the easiest way to use Fortran under Windows is with Cygwin and gfortran. But I know there are other compilers (Silverfrost for example), but I've never tried then. Edit: A bit more detailed: * Download cygwin and you get a setup program where you can select packages for installation. * Make sure that you install the gfortran package (maybe it's called gcc-gfortran or something similar). * You should get a shortcut to a shell. There you have to change to folder to that which contains your file: `cd FOLDER` to change the folder, `ls` to list file contents, I think your windows drives should be under /cygdrive/c and so on, also tab completion is your friend (press tab to list possible things). * `gfortran -o OUTPUT SOURCE` compiles you source file and generates the binary OUTPUT. * Run you program with `./OUTPUT` (or maybe with arguments of you need).
One more suggestion is to use [BASH on Windows](https://msdn.microsoft.com/en-us/commandline/wsl/install-win10) tool. Install it, open BASH and then you can `apt-get install gfortran`. After installation, compile your program with `gfortran -std=legacy -o dualfoil dualfoil5.2.f` I strongly recommend you to take the leap and install / dual boot Ubuntu on your system. Makes life simple.
What are the errors that you are seeing?
^ Good advice. Also, it may be worth spending some time learning some basic UNIX commands. If you'd like some more help, feel free to PM me and I can send you some notes for a very gentle introduction to using Fortran 90 (they are from a class on programming for earth scientists, so no programming knowledge is necessary!).
They were mostly errors for not having properly configured the compiler. I did what /u/DHermit said, and I got it working for now. Thanks though!
I did this and I got it to work. Thank you!
Cool.
You're welcome! But you also should consider the WSL as /r/rockpasta mentioned, if you are doing things like this more often.
yes, I use OMP. But I wanted to use it from above SLATEC, not to modify the routines themselves. I ended up hacking the code translated by f2c to remove the problematic usages. Unfortunately I'm not comfortable enough with Fortran to be much more than a library user. So that looked like the easiest path :-/
Why are you trying to run it? I ask because if its for education and you plan on doing more in the future, or for fun, id recommend installing Ubuntu in a Virtual Machene. All the guides ive seen for anything FORTRAN in Windows just seem to make things harder then they need to be. If its just a single f90 or f95 file then you can follow this guide on windows https://gcc.gnu.org/wiki/GFortranBinariesWindows If there's file called Makefile then id just go the linux Ubuntu VM route. Linux is so much simpler for this kind of stuff then windows. 
Also depending on the purpose, it would really be better to get a programmer onboard. Programming is not easy as people market it.
Agreed. When I was learning Fortran, I tried to get a Fortran compiler working in Windows. After a couple of hours, I gave up and just started using Ubuntu. I already had it as a dual boot, though, so there wasn't much hassle.
If you're on Windows, you can try using [Simply Fortran](https://simplyfortran.com/download/?platform=windows). It's a commercial product, but it's free to try for thirty days. After installing, you can open your Fortran file immediately with _Open_ from the _File_ menu. Once opened, just select _Compile and Run Current File_ from the _Build_ menu. Everything should just work unless, of course, there are any problems in the source code. If you do run into any issues, I'll be happy to help. I'm the primary developer of Simply Fortran.
You could try this: https://msdn.microsoft.com/en-us/commandline/wsl/about And then install gfortran which is a Fortran compiler from GNU, by running the command: 'apt-get install gfortran' Then you can compile your file by running: 'gfortran file_name.f90', after which you may run the program by typing: './a.out'
Download and install Cygwin to get some semblance of a _real_ development environment (setting up anything on Windows sucks): https://www.cygwin.com/ In the Cygwin installer, make sure that `gfortran` is selected. Type up your Fortran code in source files, using an `.f90` suffix, (e.g. `foo.f90`). Cygwin has many text editors that are avilable on *nix systems but since Cygwin is installed in a directory on your Windows machine you can use whatever editor you want fairly easily. If you want a native Windows editor, Notepad++ offers niceities like advanced searching and replacing as well as syntax highlighting but isn't bogged down by too much else. Execute the compilation from the Cygwin shell: `gfortran -Wall -Wextra -std=f95 -o foo foo.f90` A couple things are going on here and I've specified some extra options to help you out. `-Wall` and `-Wextra` will enable additional warnings. Regardless of language, I find enabling warnings (and actually addressing them), leads to better code and fewer bugs. `-std=f95` is specifying that you want Fortran 95 specifically and not any mixed standards or compiler extensions, this will make your code more standards compliant and thus more portable. `-o` just says "this is what I want the executable to be named". If you don't go the Cygwin route, I really do recommend `gfortran` in some other incarnation. Fortran compilers tend to be turd level UX (and this is coming from a guy who prefers the command line). Especially the Intel compilers. I've come to expect a certain level of quality with warning and remark messages and a lot of Fortran tools tend to suck, so you'll spend a couple hours searching deep into the Intel developer forums only to have Steve Lionel tell you "oops, that is a bug and we actually wrote the error message backwards, here is the real problem which is totally different from what the backwards message implied".
Rewriting the Fortran example to look more like your NumPy code: program integral implicit none integer, parameter :: n_lim = 10000000 real(kind=8), parameter :: a = 0, &amp; b = acos( - 1.0 ), &amp; dx = (b - a) / n_lim real(kind=8), dimension(n_lim+1) :: sinx real :: r integer :: n r = a do n = 0, n_lim sinx(n) = sin( r ) r = r + dx end do r = ( sum(sinx) - ( sinx(1) + sinx(10000001) ) * 0.5 ) * dx write(*,*) r end program integral Results: celrod@MMSGL50:~/Documents/fortran$ gfortran -Ofast integral.f08 celrod@MMSGL50:~/Documents/fortran$ time ./a.out 2.05850434 real 0m0.078s user 0m0.076s sys 0m0.000s celrod@MMSGL50:~/Documents/fortran$ time python3 integral.py 2.0 real 0m0.249s user 0m0.212s sys 0m0.036s 
Rewriting the Fortran code to look a little more like your numpy code: program integral implicit none integer, parameter :: n_lim = 10000000 real, parameter :: a = 0.0, &amp; dx = (acos( - 1.0 ) - a) / n_lim real, dimension(0:n_lim) :: sinx real :: r integer :: n r = a do n = 0, n_lim sinx(n) = sin( r ) r = r + dx end do r = ( sum(sinx) - ( sinx(0) + sinx(n_lim) ) * 0.5 ) * dx write(*,*) r end program integral Comparison: celrod@MMSGL50:~/Documents/fortran$ gfortran -Ofast -fdefault-real-8 -march=native integral.f08 celrod@MMSGL50:~/Documents/fortran$ time ./a.out 2.0000000004137508 real 0m0.151s user 0m0.148s sys 0m0.000s celrod@MMSGL50:~/Documents/fortran$ time python3 integral.py2.0 real 0m0.245s user 0m0.228s Julia: julia&gt; using Compat, BenchmarkTools julia&gt; function integrate(f, a, b, n = 10_000_000) dx = ( b - a ) / n r = ( f(a) + f(b) ) / 2 for x ∈ linspace(a + dx, b - dx, n - 2) r += f(x) end r * dx end integrate (generic function with 2 methods) julia&gt; integrate(sin, 0, π) 1.99999979999979 julia&gt; @benchmark integrate(sin, 0, π) BenchmarkTools.Trial: memory estimate: 0 bytes allocs estimate: 0 -------------- minimum time: 114.444 ms (0.00% GC) median time: 114.988 ms (0.00% GC) mean time: 115.261 ms (0.00% GC) maximum time: 118.434 ms (0.00% GC) -------------- samples: 44 evals/sample: 1 Still, pretty good from Numpy.
Fractal dimension of the snowflake by any chance?
Yeah, you got it 
So how is second year physics? 
I assume you've done the exact same experiment then aha, and good. How did (are?) you find(ing?) it?
I actually demonstrated that course for 3 years. Pretty much rewrote that experiment so apologies if it still isn't clear. The F90 + Hpc courses were certainly fun. 
Oh wow haha, well I didn't get a great mark on that particular experiment but it wasn't because it's unclear, more because I underestimate how much time I have. Yeah I'm really enjoying the f90 course at the moment, and I think the hpc course is optional in 3rd year (maybe?), and if that's the case I plan on taking it :)
END IF not ENDIF END DO not ENDDO 
I changed every single one and it's kinda the same but thx for the suggestion. It seems they work as if they were the same.
Not sure, but it might be the following: If ((a &lt; b) .AND. (C&lt;D)) THEN The whole conditional might need to be in a bracket, as well as each sub condition. The .and. Should probably have a space before and after it. 
As ben5756 pointed out, you need the enclosing parenthesis around your compound IF statements.
Yeah this worked! Thanks very much
It does work the same, but endif and enddo are discouraged (not too sure why tbh). Also your initial do loop is not required, you can just have Hist=0 
Hmmm alright then I'll use it from now on, also thanks for the advice on the initial loop. 
FWİW, you shouldn't use real*8 (not compiler independent). Use the iso_fortran_env module and real(real64). use iso_fortran_env real(real64) :: A64BitNumber real(real32):: A32BitNumber Also there is no need to explicitly cast ncaixes to a double in the interval calculation (I believe).
do the declarations 
I'm not sure. Real(8) and real*8 are the same, as far as I know. It's worth noting that real*8 will give the same results for most compilers, but it isn't guareenteed by the standard (to the best of my knowledge)
Btw, do you speak catalan?
Start emailing people at Sandia. I'm sure if they can give it out, they'll happily do so.
Thanks for the help 
Taking a quick look at the code, I️ don’t think you can initialize variables passed to a subroutine in the type definition. Move both initialization statements down to your first executable statements. Caveat: I’m looking at this on my phone, so I️ haven’t compiled the code myself.
Ok, thank you, I've fixed these errors now!
Hi, I'm not sure if you can help me, but I'm at the point where the program is printing values but they're definitely not correct (the reason i'm asking here is because I didn't want to repost the code to the subreddit). Here's the code now: program rungekutta implicit none integer, parameter :: dp = selected_real_kind(15,300) integer :: i real(kind=dp) z, y, t do i=1,100 call rk2(z, y, t) print *, z, y end do contains subroutine rk2(z, y, t) implicit none integer, parameter :: dp = selected_real_kind(15,300) real(kind=dp) :: k1y, k1z, k2y, k2z, n, h=0.1, y, z, t y = 1 z = 0 t = 0 k1y = dydt(y,z,t)*h k1z = dzdt(y,z,t)*h k2z = dzdt(y + (0.5*k1y), z + (0.5*k1z), t + (0.5*h))*h k2y = dydt(y, z +(0.5*k1z), t)*h y = y + k2y z = z + k2z end subroutine function dzdt(y,z,t) real(kind=dp) :: y, z, t, dzdt, omega=1, A=0, B, C=0, D=0 B =-omega**2 dzdt = A*y**3 + B*y - C*z + D*sin(omega*t) end function function dydt(y,z,t) real(kind=dp) :: z, dydt, y, t dydt = z end function end program And here's what it's printing to the terminal : http://prntscr.com/hchmv7 Any help would be appreciated, thanks !
I think you need to initialize y, z, and t outside of the do loop in the main program. Otherwise, those values are always your starting point in rk2 and the output would always be the same. 
Hi, thanks. I've done that and I'm now getting different values printed out : http://prntscr.com/hcio78 These still seem incorrect, but at least it's not the same reoccuring value every time now! Can you spot any reason why it's not working correctly? Thanks! 
Probably a logic error somewhere. The value of t is always 0, should that be true? Also the value of omega is always 1. D is always 0, so the D*sin(omega*t) is 0*sin(1*0) or 0, if I am reading this correctly. You probably need to manually work the math and print out values at each step to find the issue.
Good points. I'll try to update t as the program goes on. Thanks!
You can write a formatted string and then use that as file name. https://en.wikibooks.org/wiki/Fortran/strings Then use the string as the file name for input/output.
A relevant example here: https://software.intel.com/en-us/forums/intel-visual-fortran-compiler-for-windows/topic/288996
If you put four spaces in front of each line, then Reddit will format your code correctly and make it much easier for us to understand, e.g. print *,"correctly formatted" print *,"correctly formatted line 2" vs: print *,"incorrectly formatted" print *,"incorrectly formatted line 2"
It's possible to do system calls from pretty much every language, but if you want to call it directly it entirely depends on how Mathematica has their software set up. You should look to see if they have an API for either C or Fortran. 
Try here -- worst case is to write a C wrapper around the C api call to Mathematica and have Fortran call the C wrapper function. http://reference.wolfram.com/language/guide/CLanguageInterface.html
It's easier to use Fortran libraries - or at least C/C++. For special functions a good first place to look is the NIST Digital Library of Mathematical Functions. It links to a paper by Robert Forrey called "Computing the Hypergeometric Function." You can download the Fortran 77 source code at his Penn State webpage. 
Thanks for the info, it'll probably come in handy in the future. We want to use Mathematica for this part of our calculation because we're want the higher precision it can provide over Fortran. 
Thanks for the API suggestion, that really helped my search! 
Thanks! I found that one way to do it is to write some "glue" code to act as a wrapper around the MathLink functions provided by Mathematica and translate between Fortran and C. I hope I can find a glue library, otherwise I'd have to learn some C. 
&gt; higher precision it can provide over Fortran If you can find an implementation of the algorithm in Fortran, I don't think there's any reason that Mathematica would be more precise?
If you know Fortran learning C is pretty easy since they are on a similar level of abstraction. The more annoying parts about C is pointer operations since they don't hold your hand like they do in Fortran. 
&gt; i have set up a loop to read an input file and then a nested loop to read the same file under a different unit number so I can subtract the two. Is this possible I don't know if it is possible but it sounds real sketchy, even if it works I wouldn't recommend it. &gt; is there a better way to go about doing this? Why can't you just read in both values from the same file handle? Judging from your read statements, an "atom" appears to be a fairly sophisticated type, instead of storing values in primitives, store values in an array of derived types so that you have an "array of atoms" over which to iterate. Then you don't have to putz around with file positioning at all which is fairly I/O and CPU bound even with buffering.
I agree with it being sketchy. The reason for using loops is that I need to calculated the distance between atom 1 and all other atoms, then atom 2 and all other atoms, and so on for all atoms. I am taking these radius values and then piping them into filtering probe points and getting an output. 
&gt; The reason for using loops is that I need to calculated the distance between atom 1 and all other atoms, then atom 2 and all other atoms, and so on for all atoms. So the second file unit would be used for getting the data for the other atoms then? I would just do one big sequential read of the file and get the "atoms" into memory and organized in a way I felt comfortable with (like an array of derived types, or even just a few primitive arrays for each atom attribute and have the indicies correspond do an atom) then iterate over the data in memory to do the distance computation. That way there is no need for two file units on the same file and it is easier to avoid reading the same data/doing the same distance computations over since you are manipulating array indicies rather than byte offsets into a file (something Fortran doesn't do particularly well).
Kinda of. What I am doing is that the 1st loop gets the atom 1 and the nest loop gets the coordinates for all other atoms. Sorry if I am bad at explaining what I am trying to do. I just started trying to learn fortran and applying it to my research. 
Hi, I use fortran to read in molecule position data too. What we do is at the very beginning of our program we open the file with the position data, and read every line of the file into an array. When we go to calculate the distance from one atom to all the others, we use a nested loop to access this array. It's basically the same procedure, except we use an array where you're trying to use the data file. It generally makes most sense to keep all file I/O in one place, and having it in nested loops will *really* slow you down.
Do you have any examples of this? I have not delved much into working with arrays yet in fortran. 
[removed]
I'd strongly recommend that you spend some time and figure out how array work. I'm sure you can find some good lectures online. I also like the book "Fortran for scientists and Engineers" by Chapman. One problem with what you doing, is that reading and writing to a file is a relatively slow process. Files are stored on hard drive and it takes time to access data on this drive. You've then taken this slow process and put inside a double do loop. Roughly speaking the number of times that you do this slow process will scale with the square of the number of particles in your system. If you have 100 particles, you call this read 10,000 times. What happens when you have a 1000, 10,000, or a 100,000 particles. The cost quickly adds up. It's much faster to read a file once, and then store the data in an array. The array's are stored in memory, which by design are much quicker to access. 
Here's a simple 1D example program implicit none real, dimension(:), allocatable : x ! create array, but don't set the size yet integer :: i,j,n real :: potential open(15,file='input.dat',form='formatted',status='old') read(15,*) n allocate(x(n)) ! set the size of x to be n do i=1,n read(15,*) x(i) ! read in a value, and put it into the i'th entry of the x array end do close(15) ! loop over everything potential = 0. do i=1,n do j=i+1,n potential = potential + 1./(x(i)-x(j)) end do end do print *,"potential=",potential deallocate(x) ! free the memory end program That's a simple example of using arrays. If you can understand that, you can extend it for your example too.
your code looks too complicated although rk2 method is fairly simple.
I might be a bit too late but yeah. Those are my weekly practices for college here in Barcelona.
I see, I am just a noob in fortran. Does this work with fortran 77 too?
I just saw this today. Thanks so much really clarifies it. 
I believe so. But stop using Fortran77 is the real answer.
It sounds like your issue is more with the math than the fortran code itself, so you may not get much help here. You may be more successful on Mathematics Stack Exchange or Physics Forums. Sorry I don't have any real help to offer :( 
I have not worked with this equation before, but I did some googling. https://www.researchgate.net/post/How_to_plot_the_basins_of_attraction_of_a_duffing_oscillator_in_the_chaotic_regime "In a Duffing Oscillator, you cannot have co-existing chaotic and periodic solutions. Hence, after the onset of chaos, all the trajectories in the phase space eventually get attracted to the chaotic attractor. Hence, in this case the basin of attraction corresponds to the entire phase space. But before the onset of chaos, you can plot the basins of attraction of different attractors, which in this case are limit cycles." You need to find parameters for the non-chaotic solutions. Look for periodic shapes. Your Poincare sections are plots where the axes are the conjugate coordinates: your variable and its first derivative. You can see such plots here: http://www.scholarpedia.org/article/Duffing_oscillator This also looks nice to read: http://physics.ucsc.edu/~peter/115/duffing.pdf I hope it helps. It would be fun to see your results when you are done :)
Thanks very much for your help! I've managed to get the limit cycle I was after now (I hope). Here's a picture of the phase-space diagram that I believe shows it: http://prntscr.com/hg74z8 An the trajectory for this: http://prntscr.com/hg7550 I am now just stuck on the Poincaré section. I will get back to you if I manage to do it! Thanks again :)
Thanks for your suggestions, I will give them a shot :)
So as others have stated, this is more of a maths problem than a coding one. But in terms of the Fortran alone, you really should indent your code. It makes it very difficult to read otherwise.
Thank you, I've indented my code now and posted the question on the maths stackexchange. 
Looks beautiful. Now, for the Poincare section you will need to plot dots in the y and dy/dt coordinate system for specific times. It's neatly described in the last link. Programmingwise you make a loop over the t's a write the down the y's and dy/dt's that the equation gives you for your particular solution. Plot the stuff using marks without interconnecting lines :) Glad I could help :D
Ok, thank you, I will give that a shot and get back to you! :) 
So my problem is that my time is increasing in steps of 0.1. As a result, I can't tell the program to note down times that are = 2*pi*n, as I will never have a time that is = n*3.14159. I tried to negate this by changing my time step to n*h*pi, which gave me a nice looking Poincaré section, but when I plotted the phase-space with this time step that became incorrect. 
Think i've done it, either way I'm leaving it as is now! Here's my "strange attractor" : http://prntscr.com/hh0705
Both plots are in the phasespace actually. The trajectory probably looks wrong because the timesteps are too large. You can choose some fraction of 2pi as your timestep. For instance 2pi/60 which is ca. 0.1. The program should then use times t = n*2pi/60 where n=1,2,3,... if I understood correctly.
Hi, thanks for your reply. I actually set the driving frequency to a multiple of pi, (0.5pi) and thus this caused the time period to no longer be a multiple of pi. The time period became simply "4", which allowed me to get the "strange attractor" above. By eliminating earlier time steps and starting from t=200 I managed to get this strange attractor: http://prntscr.com/hh34tk Which looks a lot like the one we were given as an example: http://prntscr.com/hh34wy so i'm happy. Thanks for your help and the links you provided, it was all extremely useful :)
That's great. Looks like you did a great job. Glad I could be of help :)
Fortran is very much not a language for writing games in! But what do you mean by "sink the float"? Googling around it appears to be a name sometimes used for Battleship, maybe?
You know, that game where you have to put ships in different places in a table and "shoot cannonballs" to the enemy table until you destroy all their ships
I think I've always heard that called "Battleship"? If you google "Fortran Battleship" you can actually find a few different source codes if that's really all you want. But is this for a school assignment? If it is, it might be better to try writing it yourself, and then ask questions here when issues come up. It's just about using some the basic tools like arrays, input, output, etc, so you really need to master those basic building blocks to make sense of this.
I don't mean this to be offensive, but is English your native language? Like /u/Astrokiwi I've never heard of "sink the float" but am very familiar with battleship.
I think from OP's post history that they're Spanish. Googling around for "Fortran Battleship", one of the top results was someone who got this as an assignment in Spain. So maybe there's just one university in Spain that gives Battleship as a Fortran assignment? Also, if you look here: https://es.wikipedia.org/wiki/Batalla_naval_(juego) - "hundir la flota" is given as one of the alternate names for Battleship.
If it were my native language I wouln't have said "sink the float" instead of "battleship" hahahah
[removed]
It's hard to say without seeing the whole code, but based on how the lines are continued in your snippet, I suspect the files might be in the old-fashioned fixed-form layout. If that is indeed the case, adding the -ffixed-form flag to your fortran calls should help. 
Thanks a lot it did help. No I just got a warning about some symbols but no Errors. Undefined symbols for architecture x86_64: "_main", referenced from: There are 2 comments in the instructions that may be related tou your guide but since I have no clue about Fortran I could not make sense about them. (1) Fixed format source code (72 columns) (2) Automatically promote REAL type variables to REAL (KIND = 8) (double precision) The first one must be what you have told me to use. I have checked some documentation and I wonder if the second point is somethiong to do with this flag: -fdefault-real-8
That error means that the main program is not found at the linking stage. You mentioned that there were several .f90 files. Was there also a Makefile? If there is, you should compile using that. If there isn't, you'll probably need to compile the source code files to "object files" first without linking them and then link the object files. See [this page](https://gcc.gnu.org/wiki/GFortranUsage) for instructions how to do that. 
Thanks a lot. I knew zero about Fortran about a week ago. This helps a lot.
What errors are you getting? Where in the installation steps are you running into problems? Please give more details.
Every step Im failing. Operating system: MacOS Sierra. Not really errots per say; its just not starting or working as its supposed to.
 character(len=80) :: temp_str integer :: A,B,C,D write(temp_str,'("dydt_vs_y_",I3.3,"_",I3.3,"_",I3.3,"_",I3.3)') A, B, C, D write(unit=11, file=trim(adjustl(temp_str))) This works for Integers which are then displayed in the form of e.g. '003'. character(len=80) :: temp_str real(4) :: A,B,C,D write(temp_str,'("dydt_vs_y_",F5.3,"_",F5.3,"_",F5.3,"_",F5.3)') A, B, C, D write(unit=11, file=trim(adjustl(temp_str))) This works for single precision floats which are then displayed as e.g. '0.375' 
Easiest way is probably to use [Homebrew](https://brew.sh). I just tried this out, and got their [example](http://www.astro.caltech.edu/~tjp/pgplot/example.html) working in a matter of minutes. Here's what I did (I have also installed my gcc using Homebrew, although I doubt it makes a difference): 1. Installed xquartz (because when I first tried installing pgplot, it told me to) and then pgplot: brew cask install xquartz brew install pgplot 2. I copied and pasted the Fortran 77 example from the above page to a new file, which I called test.f, and compiled it with (notice how I link to pgplot with the -l flag) fortran test.f90 -lpgplot 3. Ran the code and followed on-screen instructions to produce a PNG file, which looked ok. ./a.out 
installation complete... But how do I run it? 
Run it? It's not an application, it's a library you can use from your Fortran programs, like the example I linked in the above reply. Now I have to ask — why do you want to use pgplot? If you don't have much background on programming, perhaps it's not the best tool for your purposes, and maybe we can direct you to something more suitable. (Seeing how pgplot seems to be decades old and very niche, I don't see why anyone would use it unless they had to work with a legacy code requiring it. I hadn't even heard of it before this morning!) 
To the first, thanks! Now I need to figure out how to compile. To the second: I do heavy chemical research and I require a program like pgplot to map data
The first question is this: do you really really need PGPLOT? Fortran is great for complex numerical calculations, and has a lot of nice features. And sometimes you have a legacy project where it works out easier to attach to existing Fortran code than to do something in a different language. *But* if all you want to do is plot up some data, it would probably be better to use Python and matplotlib. In fact, even if your core code is in Fortran, I would still use matplotlib to produce plots and animations, by either outputting the data from your Fortran code, or by wrapping the Python around the Fortran. There might be a situation where it really is essential to use PGPLOT, so we can help you if that's the case. But if you're asking about PGPLOT because you just didn't know there were other tools out there, then maybe matplotlib is the way to go.
In that case, I'd recommend using another software for plotting. Here are two suggestions I have good experiences with: - [gnuplot](http://gnuplot.info) is a lightweight and versatile, free plotting program under active development. It can be installed with Homebrew (`brew install gnuplot`) and can be ran in an interactive mode. - If you need to do complicated data analysis and program, I'd second Astrokiwi's suggestion in the other comment and learn Python+matplotlib. That requires you to learn more if you're not familiar with Python already. Personally, I use both in my research. I like gnuplot's speed when there's a lot of data to plot, and I like matplotlib's versatility and how it works with other major Python libraries for scientific work. Gnuplot would definitely be quicker to learn to use. 
I typed the install brew thing, but typing gnuplot into my terminal yields nothing.
That's odd. If gnuplot was correctly installed, you should be able to launch it from the command-line and get a prompt that looks like `gnuplot&gt;`, allowing you to give plotting commands such as `plot sin(x)`. Did you see if brew gave you any error messages when you were installing? 
Fixed it! Just freshed installed it since then
pgplot is awful. Don't use it. That being said, here's a sample of its use from my code, just so you know what you're getting yourself into: subroutine initpt include '****.comm' c +++ c +++ program to initialize the graphic device c +++ real*4 left,right,bottom,top left = sngl(xl) right = sngl(xr) bottom = sngl(yb) top = sngl(yt) call pgenv(left,right,bottom,top,1,-2) call pgask(.true.) call pgsch(1.0) return end c +++ subroutine drv(x1,y1,x2,y2) include '****.comm' real*4 xx(2),yy(2) c +++ c +++ program to draw a line from screen coordinates (x1,y1) c +++ to (x2,y2) c +++ xx(1) = sngl(x1) yy(1) = sngl(y1) xx(2) = sngl(x2) yy(2) = sngl(y2) call pgline(2,xx,yy) return end c +++ c +++ subroutine plt(x,y,ch) character ch real*8 x,y real*4 xx,yy c +++ c +++ plots the ascii character ch at screen coordinates (x,y) c +++ xx = sngl(x) yy = sngl(y) call pgtext(xx,yy,ch) return end 
I don't know about 90 convention but in 77, you need to set real*8 variables with var=1d0. I had an issue where I referenced a variable defined in another file without the "d0" (I don't what to call this maybe "real*8 exponent"?). The value was okay if I printed it from the same file, but printing the value from another file gave it weird values like that. I hope you figure it out.
Thanks. it seems I may have to sort through some lines of code anyway. It's a large jumble of openmpi code too which I'm trying to simplify. I just found a compiler flag to set the default real to double precision in gfortran with "-fdefault-double-8".
One point about MPI is that you typically tell it what kind of data type you're sending across. You need to change those as well.
Ah good point. Thanks for all the input. An interesting note. I have a sorta hybrid parallelism with openmp and mpi. If I run with mpirun and a single process it won't use the shared/memory openmp part like if I set it to multiple processes. But if I run the executable without mpi it does. Maybe that is normal. Not sure if I'm using correct terminology. 
Typically you can independently specify how much of each you do, although this depends on your setup. If it's just a *nix box, the environment variable OMP_NUM_THREADS sets how many openmp threads you use. You tell mpirun how many MPI tasks you want.
I have that set to OMP_NUM_THREADS=8 in my .bashrc file. What I am saying is if I use "mpirun -n=1 blah" it doesn't use openmp like if I use "mpirun -n=2 blah" or just ". /blah". Of course there's no reason to use mpirun with n=1 which is only for testing but I thought it was interesting my system (RHEL7) won't use shared memory in that case. 
Something seems off in that case. 
`real8` (to my knowledge) is not a standard mechanism. However, `real64` from the ISO_FORTRAN_ENV is. Alternatively, you can use selected kinds: http://fortranwiki.org/fortran/show/Real+precision While compiler options are convenient, they should not be relied upon since they tie your code to a particular compiler and make portability difficult.
Thanks I wound up using this for everything. My code would've actually ran fine earlier with the sed commands except I hadn't changed mpi types so I think that was the main issue.
What kind of class are you taking that does graph traversal in Fortran... Anyways, Dijkstra's algorithm essentially computes the shortest path from one node in the graph to every other node in the graph, then a lookup is done to get the shortest path for the destination node. You'll need a list of paths from your starting node to every other node initialized to empty paths with very big distances (possibly positive infinity from the 'ieee_arithmetic' module. Beginning with your starting node you'll visit each neighbor node and calculate the cost of taking the edge connecting them, check your list of paths and compare the current shortest path if this path is shorter than update it to be the new shortest path. And repeat this process; that is, visit all the neighbors of the nodes adjacent to your starting node and compare the cost against the stored paths, updating as needed. The trick is basing movement on the edges, make sure you exhaust all the edges when visiting a node. You can substitute allocatable arrays for the lists of paths, you'll need to store these in another array where each index represents a destination node and you'll need yet one more array that contains a cost such that index `foo` of the cost array is the cost of the path in index `foo` of the path array.
I love that they still teach ye old but ye great Fortran.
Thanks! Yeah I know how it works. Our professor told us that we have to compare each step of each path simultaneously. So if the starting node (A) has paths to B C and D then you will add the values to those knots and then compare those three together to see which is smallest, then start advancing from shortest to longest, again in one step and then repeat this. So if C has the shortest route from A, followed by B then D, you would advance C to the nodes it has paths to, followed by doing the same to B and D, and then that’ll end you up with however many points those 3 lead to. To me it seems like i need an allocatable array for every step because each step they lead to a different number of points. I guess I should’ve included this in the title
Another thing to note is that most compilers will have an option to force all `real`s to be treated as `real*8`. It's better to actually change the code to ensure things are consistent, but just changing the compiler flags can sometimes just work without any code modification.
Are you using the same compiler and version between the laptop and desktop? If not, the desktop compiler may have generated code that runs, even with a coding error (e.g. memory out of bounds).
I did stumble across that. For gfortran it's "-fdefault-double-8". I wound up converting everything using a module across everything to define a parameter so it would be consistent on different machines. integer, parameter :: dp = selected_real_kind(15, 307) real(dp) 
And also converted the MPI sends and recvs to be double precision.
Yeah that's one the compiler flag won't catch
It could still be a "coding" problem - it's possible to write code that is dependent on your compiler or hardware or system settings, and it's a better practice to try to write your code to be as independent as possible. But it's extremely hard to diagnose your problem without seeing your code.
Non-Mobile link: https://en.wikipedia.org/wiki/List_of_compilers#Fortran_compilers *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^135267
gfortran is the Gnu Compiler Collection (GCC) compiler for the Fortran language. gfortran can compile FORTRAN77, Fortran 90, and Fortran 95 code plus it has support for Fortran 2003. I'm not familiar with Fortran 2003 being fully implemented, but maybe someone else can provide better details. Take a look at the [GCC site] (gcc.gnu.org) to find documentation for gfortran.
Fortran is the language. When you write code, it needs to be compiled. This is a process where human readible text is turned into instructions that the hardware in your PC understands, broadly speaking. gFortran is a compiler, part of the GNU compiler suite. There are other fortran compilers, for instance Intel/Lahey etc. gFortran also has the advantage of being free, where most of the others aren't. Broadly speaking again, if you write valid fortran code, any compiler would be able to understand it. There are some differences, depending somewhat on how much the compiler creators stuck to the standards. 
They left (or right) justify your strings. Check out the example at the [GCC site](http://gcc.gnu.org/onlinedocs/gcc-4.6.3/gfortran/ADJUSTL.html)
I think the two languages you see are FORTRAN and Fortran :) The first means up to FORTRAN77, the second means Fortran90 and up. The numbers more or less refer to the year the standard was published. The all-caps versions were designed for punched card input. The 90 is a modern language with better syntax and very useful features e.g. operations on whole arrays.
And the result of that prog. will be: 'gfortran '
That looks right; I've never used it though. Try using the function.
I think of it as right/left alignment of text in a single line (aka your string). One can use *adjustl* and *trim* together to get rid both of leading and trailing spaces in a string.
I'll try that, thank you very much 😁😁😁
Yep, I get it now, thank you very much 😃😃
gfortran
gfortran is the default free compiler Photran is an Eclipse-based IDE for Fortran, but the general Fortran culture is often a bit old-school and tends to not be big on IDEs. People tend to just use specialised text editors - e.g. emacs, vim, atom, sublimetext, notepad++ etc.
Are you asking if anyone else has implemented that particular algorithm? And you want to know how fast it runs?
I use gfortran with Atom on a Linux system. No issues.
Oh that's awesome! I want to set it up with atom, any tips, packages?
Thanks for your suggestion! That's just a compiler yes?
Oh cool I am a student so I'll have to check that out! Thanks my professor wants us to use simply Fortran but I'd rather not spend 140$
Is there a price that you consider "cheap" other than free?
Send me a message, and I'll see what we can do with Simply Fortran pricing.
Really? Wow I didn't think that was an option, I can afford to spend like 50$ ish it's just because I'm paying for school myself and am not getting any aid
Thank you for your reply! I was considering photran 
Code::blocks has a free Fortran IDE. I've used it within Windows 10 and it works well for what I need it for (grad school). Check out this link: http://www.codeblocks.org/
I'd like to know if someone has implemented before and if they have any function as a benchmark 
Ok I'll check it out thank you for your suggestion!
Use the code _REDDIT64_ for a 64% discount if you purchase through us, which should bring the price to $50.04 if you still want to try Simply Fortran. I understand that it can be expensive, but we're willing to work with people who ask.
Thank you so very much that really helps and I will definitely be purchasing it once I get home! 
You can use gfortran. It's a free and a simple compiler. I've been using it for more than 3 months and everything OK. You can also download it for free after you search in google for gfortran and I think you'll find what you need. The commands may be a little different but that depends on which version you're working on All the best 
On Atom, I have the following packages installed: autocomplete-fortran language-fortran linter linter-gfortran linter-ui-default Hope that helps.
Thank you! I was curious to set up atom to run Fortran but it keeps returning an error Hmm I think I have all those installed, I'll do a bit of research
To be honest, I’m having trouble reading the error message on my phone — it gets pixelated when scaled large enough to read. But, it appears you are not producing the object code for the linker (ld) to produce an executable. I can’t tell if you don’t have a necessary library or are generating an error when compiling the source. What errors does the Fortran lint give you in Atom? I’ll see if I can read the message better from my desktop when I get home.
You can use WRITE to write values to strings. Eg: CHARACTER*10::mystring,myrealstring INTEGER::myNum = 1000 REAL myReal = 5.5 WRITE(mystring,*) myNum WRITE(myrealstring,F3.2) myReal Hope this helps.
With fixed formatting: CHARACTER*10 :: mystring, myrealstring INTEGER :: myNum = 1000 REAL myReal = 5.5 WRITE(mystring,) myNum WRITE(myrealstring, "F3.2") myReal
So I really don't think we should give away how to do the physics of that comp lab. Try comparing the two ODEs and you should be able to work out what it should be for the Schroedinger equation. How is York?
Here’s an overly complex way. Divide the integer by 100, and you’ll remove the DD. Save this number and divide by 100 again and you’ll remove the MM and just have YYYY. Now subtract the YYYY from YYYYMM
So, Fortran is great and obviously a lot of people in this subreddit are fans of Fortran (me included). But there are some tasks that are much much easier to do in a language like Python, and this looks like one of them. Do you have a good reason to be doing this in Fortran? (e.g. this is connected to a larger Fortran code, or you're doing this as a sample exercise to learn Fortran). Because if what you're doing is some simple analysis on text files, then using Python with the numpy library is likely going to save a lot of time, hassle, and effort.
Thanks for the reply. It’s for a class and we’re learning Fortran. I’m trying to find a way to do this without having to do a ton of if-then statements. I’ve been messing with it all weekend and I’m going to have to go ask the professor for help.
Try looking at formatting with read statements. Something like `read(line,"(I4,I2,I2)") a,b,c`, where `line` is your input string, and `a,b,c` are integers.
Thanks I’ll give that a shot here soon!!
I think the problem might be the _status_ parameter: the behavior of the value "unknown" is system-dependent. You could try "new" or "replace" instead, depending whether you want to rewrite the file if it already exists. 
The file doesn't exist and using new doesn't work either last time I tried it. 
Are you trying to create a file in a subdirectory that doesn't exist yet? That's a trap that comes up sometimes. e.g. if your filename is "data/raw/test.dat" and the directories "data" or "data/raw" don't exist, it can't create the file.
Im late to the post but i use gfortran or student ifort + sublime text with fortran syntax highlighting + a makefile gets you the bare bones of an ide for free. I remember getting a visual studio plugin for fortran a while ago but that was when i was just messing around. I dont know any of the features that it came with.
The most recent gfortran is supposed to support 08 as well
Have you tried using gnufor? It is a fortran library for gnuplot. The nasic steps using this library are write_xy_data to a txt file, write_xy_plot gnuplot commands to a txt file, then run_gnuplot to actually run gnuplot to create the plot. It might be a little more user friendly than using a system call of the gnuplot program directly.
Thanks for the suggestion I'll look into that for sure!
Thanks!
Intrinsically, fortran can provide results with as high precision as you want. It depends only on how variables are declared (single vs double precision).
Apparently there are a couple of hoops you need to jump through here. This worked on my laptop (running macOS High Sierra, fortran installed using homebrew): 1. For whatever reason, the Makefile uses the _sed_ command, and the those commands are incompatible with the BSD version of sed shipping with macOS. So first you need to install the GNU version of sed. The easiest way to do this is via homebrew: if you have homebrew installed, the command is brew install gnu-sed 2. Next you need to edit the two "sed" commands in the file "src/Makefile" to "gsed". They are on lines 35 and 39. So for example, line 35 originally reads sed -i '/^\#/d' $*.for and you should change that to gsed -i '/^\#/d' $*.for and the similar change on line 39. 3. Now, in the main directory (the one with subdirectories "src/", "runfiles/", etc.) you can run make which should compile the code. 4. Next comes another hoop: To avoid the program crashing, you need to create a directory called "output". The command is mkdir output 5. Now you should be able to run the code. I tried ./bernSCM &lt; runfiles/run_c4mip_uncoupled and that, at least, seemed to work on my laptop. 
I'm happy to hear that :) 
Any chance you could help me interpret what the format for the forcing files should be? I am trying to create my own simulation with a different value for the yearly emissions (last column in the forcing file*.25) I used excel to create the new values, saved as a .prn, and then copy and pasted into a .dat file... but I get this error when I run it... " Program received signal SIGFPE: Floating-point exception - erroneous arithmetic operation. Backtrace for this error: #0 0x109c6c579 #1 0x109c6b945 #2 0x7fff7baa4f59 #3 0x109c52773 #4 0x109c525b3 #5 0x109c59913 Floating point exception: 8 "
turn up to labs tomorrow and the demonstrators can help you out. That said there are a few things I can help you with. When calculating B, you need to sum over surface elements on the magnet. You do this using this equation: https://image.prntscr.com/image/begFFyqXTPWoTF6zQ04eRQ.png Note that M(r') is a function in this context. However we are assuming that the M is constant throughout the magnet to be: (0, 0, 1). Now, since the equation includes M.n (this is a dot product of M and the surface normal), we can ignore the sides of the magnet that are not facing up or down since this term will go to 0. This means we only need to account for the top and bottom surfaces. &gt;For the top surface: M.n = (0, 0, 1).(0, 0, 1) = 1 &gt;For the bottom surface: M.n = (0, 0, 1).(0, 0, -1) = -1 M.n is now simply a scalar of 1 or -1 and |(r - r')|^3 is also a scalar. For a single surface element we can calculate its contribution to the field like so: For a surface element on the top: deltaR = (r - rPrime) B = deltaR / magnitude(deltaR)**(3.0_dp) For a surface element on the bottom we do the same with the opposite sign deltaR = (r - rPrime) B = -deltaR / magnitude(deltaR)**(3.0_dp) rPrime is different in both these case and you can iterate over a grid of surface elements (decreasing the grid spacing to improve the surface integral accuracy). You can do the top and bottom element in a single loop to cut some lines of code. Should look something like this: do x = -s, s do y = -s, s !contribution from top surface rPrime = [x * surfaceSize, y * surfaceSize, 5.0_dp] deltaR = r - rPrime B = B + deltaR / magnitude(deltaR)**(3.0_dp) !repeat for surface bottom of magnet rPrime = [x * surfaceSize, y * surfaceSize, -5.0_dp] deltaR = r - rPrime B = B - deltaR / magnitude(deltaR)**(3.0_dp) end do end do 
Hi, thank you very much for your response. In your code, are r and rPrime being stored as 3x1 arrays?
Ok, thankyou. So how is the position being iterated in this loop? As we want a field line, we need the position at which its calculated to change right?
The file format seems to be documented in the file BernSCM_manual.pdf included in the package. As I'm not really familiar with climate science, I don't think I can help much with interpreting that. However, I'm not sure what the .prn format is like... You might want to check that your files look like they should using a plain text editor, such as TextEdit included in macOS. 
If i understand correctly he's already integrating using the 1st order approximation.
You can read in each line as a string and use a subroutine (or just write the necessary code in the loop) to read in a char len =8, and then save the first four characters to another character array year, the next two to a character array month, and lastly the last two to a character array named day then read(c_year,*)i_year where c_year is the string and i_year is the interference value. Then just use your if statement to check if the date matches your criteria to continue the loop or not.
Fortran can read formatted fields directly. It makes no sense loading a variable as a string and then splitting it to different bits and convert them to integer. On languages that lack other ways to read formatted entries it can done like that, but there is really no need to make it more complicated than it should in fortran.
I hear you point and appreciate the feedback. However, I was just thinking since the OP had a lack of spaces denoting different different fields of interest it might work better. Thinking about it, though, i can think of at least one way which isn’t as convoluted. He could just by 10000 to achieve the year, then subtract year*10000 from the original entry and divide that by 100 to get the month, and then subtract both year*10000 and month*100 from the original input and get days.
The one case I can think of is if you have a lot of legacy code libraries etc.
The only packages I could see myself interfacing with would be LAPACK / BLAS for some linear algebra routines, but I don't think that would matter.
Sometimes loops can be faster than array operations, depending on your compiler etc. Similarly, dynamically allocating arrays can make things a bit less optimised. But usually these are not the critical bottlenecks in your code. If you really care about that little bit of speed, then write both and do a speed test - otherwise just use the new version.
Last time I checked, the fortran 2008 support differs quite a bit between different compilers. So if you want to make sure your code will also compile with another compiler, you can only use the common subset of supported features.
F2003 support is pretty good among most of the common ones (IFort, Gfotran, etc.) I've been using it myself and have had only a few minor annoyances. One difference to note is the SIZE intrinsic works differently in iFort than it does in gFortran when allocatable arrays are involved. In the Intel compiler if the array has not been allocated size will return 0 to indicate the array is currently empty. In the GNU compiler it triggers a segmentation fault. You can safely get around this by just making sure you are never checking if an array is allocated with the SIZE command and instead use the ALLOCATED one prior to the size command. 
Frankly if you are writing anything that you intend on using again and again, don't ever write in the old standards. F2003's OOP support is very good and brings Fortran up close to C++'s flexibility. 
Regarding performance of OO, in my experience, one has to avoid multiple allocation/deallocation. This is a common problem if you define your own data types, and use operators. The code is more clean, with expressions like: c = a*b + d But this usually requires allocating/deallocating memory. This is expensive and not cheap. When performance is an issue, I have found to be much more efficient to define subroutines call sum_and_add(c,a,b,d) And you *manually* allocate the space for the object c before calling the subroutine. In summary, you OO features of F2003 are very nice, but can make you loose soe performance. 
I guess you are writing this code for some kind of school exercise. Why don't you compare your calculations with a library, in Fortran or in another language? I don't see any sin function in your code. Is 'h' the signal you want to transform? Then it should be 'h=sin(2*pi*k/N/L)', with L an integer corresponding of the number of periods. 
Thanks for your reply. Yeah h is the signal to be transformed. What do I plot though? The results include complex numbers, so I'm still unsure about plotting and what to expect. Thanks again !
Plot the norm of the complex. So if z=a + ib, plot |z|=sqrt(a^2 +b^2 ). I don't know how to plot in Fortran though, use Matlab or Python. Edit : forgot markdown syntax 
Perfect, thanks :)
Hi, just one more question! So I've got the absolute values of the elements in the array, but im unsure as what to plot them against? thanks
Well I don't know if I can answer that by heart... Let's try. * as you have a signal of size N, you will get an FFT of size N : no creation or loss of information. * however, the FFT will give you the positive *and* negative frequencies. So the FFT will be symmetric. * the highest frequency you can have is f_max = 2/dt. In your case it is 2. The 2 factor comes from the Shannon theorem. * the lowest is df = 1/N, it is also your frequency resolution. Anyway, this might be wrong. Never trust something you read an reddit, go and check the Wikipedia page I'm sure it's more comprehensive. 
For numerical work, Fortran is simpler \(higher\-level\) and easier to use than C\+\+, while still having comparable performance. It doesn't have the big standard libraries of data structures etc that C\+\+ has \(e.g. no \`std::vector\`\), so it's generally more for if you want to mostly write your algorithm by hand. For integration with Python, I have found that f2py is incredibly easy to use \- it's just one line \- and much less hassle than dealing with C\+\+. numpy uses Fortran or C "under the hood", so it can have decent performance if you're able to load off all the work onto a small number of big calls to numpy functions. The problem is that sometimes there is a simple problem that can be solved in a small loop, but writing out the explicit loop makes the code incredibly slow in Python. So you have to either spend an hour hunting through the documentation and hope you find the exact perfect function that does it for you, or you write the loop by hand and take the speed hit, or you write the loop in Fortran and integrate it with f2py. I haven't used Matlab but I understand it's similar to numpy in performance and usage. Overall, I find that C\+\+ requires more programming knowledge to not get caught in its many traps, and numpy requires more knowledge of the documentation if you want to run things efficiency, but any idiot can write fast Fortran code, which is why it's so popular in academia where people are often picking up programming as they go.
The F is capitalized. 
My personal rule in academia and career is use fortran for calculations as it is simplest and fastest. Then use python, matlab, or another code for post processing and visualizations.
Matlab requires a license.
That post is outdated. Here're newer versions: 1) From 2016 https://modelingguru.nasa.gov/docs/DOC-2625 2) From 2018 https://modelingguru.nasa.gov/docs/DOC-2676 However, as someone said, DO NOT put much stock into microbenchmarks! IMO you should choose a language in accordance with these rules. 1) First, you should take care to learn and use languages that are necessary at your current job, and hoped for future job. 2) Second to that, you enjoy the language, and can feel comfortable writing in it for much of the day. 3) Third, it makes you a better programmer, engineer, or scientist. (Sometimes this means choosing a language from a different paradigm to what you've been usually using, but I digress). In science languages come in dichotomies and it's best to have two different language by your side. First you need a research/prototyping language. These are optimized for user-friendliness, and have a lot of nice functionality for R&amp;D/debugging/experimentation. Don't pay attention to their speed. Examples are Matlab, Python, R, Octave. These are all fantastic, but my favorite is Python. One reason is that Python is not really limited to the category of "prototyping language". The second language is a language meant for production code. These are languages where performance is very important. Other important aspects are having access to robust, well-tested legacy code, and language portability. These vary by industry, but examples are C, C++, Ada, Go, Fortran. My personal favorite is Fortran. It's almost as easy to learn as Python, it's performance is top notch, and it's designed for numerical computing. Another reason is that just as Python can flirt with being a production language (as it is at a number of large hedge funds), so too can Fortran 90+ flirt with being an R&amp;D language, because of it's user-friendliness. Maybe it's that I don't know enough C++, but I can not understand why anyone would choose C++ over any modern Fortran for numerical computing. If someone can give me their reasons for choosing C++ over Fortran for numerics, I'd really appreciate the alternative perspective.
While f2py is great it doesn't really work with the object oriented parts of Fortran.
You might get one as a student if your university has a license.
From that NASA article: &gt; All the calculations were carried out in dali What is dali?
&gt; Maybe it's that I don't know enough C++, but I can not understand why anyone would choose C++ over any modern Fortran for numerical computing. If someone can give me their reasons for choosing C++ over Fortran for numerics, I'd really appreciate the alternative perspective. For starters, I like modern Fortran, and used to use it as my primary tool but now write all my scientific code in c++, so this isn't coming from ignorance. Fortran is fantastic for numerical computing, full stop. The multidimensional array expressivity and clarity of constructs for math is above reproach, while giving obviously outstanding performance. But for literally everything else it's awful. As a numerical code grows, the non-numerical part comes to dwarf the stuff you'd call numerical. Data structures, file io, user configuration, control flow, class hierarchy, it's all awful in Fortran as soon as you step away from dealing with contiguous arrays and intrinsic datatypes. I wouldn't even want to write an unstructured code with it Fortran makes simple stuff easy and fast, but complex software of the million lines of code size is just intractable. I could point to dozens of C++ libraries and language-specific techniques that made my CFD development life better in every way. And hundreds of little things that make everything easier - STL containers, generic algorithms, you probably don't know what you're missing here. 
I don't know if any exist :) A common warning is "Fortran programmers can write Fortran in any language." What makes *good numerical computing* is basically independent of language. It's the *everything else* where you want to think more like a software developer. Definitely read about [design patterns](https://sourcemaking.com/design_patterns), Scott Meyers' and Herb Sutter's books are great for c++ specific things. Really read about object oriented design - the f2003 updates are OO-ish, but it's clearly a bandaid compared to "real" OO in something designed for it. You can translate your Fortran code almost verbatim to c++ but that is decidedly not what you want. 
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/SsI9K34.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20duyfu3f) 
I use the same. VSCode is really nice. I think you can edit the syntax highlighting a bit, but not to levels OP wants. Not sure anything out there has those capabilities. The support for Fortran is often just basic, not all the fancy stuff C/C++/C# has (or needs..).
Yeah, I know enough not to translate verbatim lol.
Heh, fair enough, many don't. There is "scientific software engineering - the object oriented way" which has dual examples for everything in c++ and f2003. I haven't looked at in a while to judge the c++ and at the time I was mostly interested in applications of f2003 oop. Modern c++ (c++11/14/17) is as big a jump as f90 to f2003 in terms of the language, so a lot of stuff you see might be out of date. Things like smart pointers and lambdas change the landscape quite a bit. I've got a chapter in my thesis on software design, maybe I should expand it, heh
Where would you say f2003 OOP falls short?
I used Atom and Vim and both have great plugins. But compared to other languages it's still lacking. E.g. with Rust or Python I have much better autocompletion and things like rustfmt are really handy and work great.
I edit/compile fortran routines remotely (Windows -&gt; Unix). In the past, I used Atom and this editor is great; its Fortran plugins are better than the VSCode ones. But Atom_win quickly hangs (or use a huge memory) when you have a lot of opened tabs.
If you use Windows OS, Notepad++ provides excellent syntax highlighting for Fortran. It does not recognize some Fortran 2008 keywords. However, you could simply modify the XML file in notepad++ for Fortran highlighting to add the new keywords.
Fortran is not well suited for dealing with strings. So I would use a different programming language to perform this task or even a command line tools like Grep.
Thanks, but unfortunately I'm looking for something more powerful than simple keyword highlighting. 
Googling around suggests that the Atom Fortran plugin is based on the same tmbundle as the Sublime one is, so I suspect that won't do what I'm looking for, sadly...
Ok, thanks for the suggestion I feel like it's doable with Fortran but probably unnecessarily difficult when I could do it a lot easier with Python huh?
1. 1st of all, by security, I will add an "END=s, EROR=g" syntax to your read commands, where s and g are labels to jump to in case of end of file or read error (see https://docs.oracle.com/cd/E19957-01/805-4939/6j4m0vnat/index.html) 2. If I well remembered, PGM has lines of 25 values. I will replace the inner loop by a read (out_unit,1000) inp ((m,n),n=1,25) m +=1 if (m.gr.max_m) got to s 1000 format (25(I3)) a. the "if" just ensure you do not store more lines that your table can have. b. The "END=s" instruction will jump to the "s" label, where you'll can now the number of read lines as m-1 c. Of course, I will initialize m=1 before the outer loop Something like that. 
Difficult to say without any more debugging info, we don't even have info on which read statement failed though I assume it is the one in the loop. I highly recommend you run the code through a debugger and see where it goes wrong, what the values of all the variables you have read in are and (if in the loop) the current loop counters. In general terms your error tells you that you read the last bit in the file and then you had another read command try to read from the file and found no more data. This means the total number of bits in your file is less than what you tried to read. One thing I will point out is that your read into inp doesn't contain a format statement, while this can be fine, I think if the default precision of integers in your fortran program does not match the precision of the pgm file then you will overrun or underrun the file, not sure on this but you prob want to specify a format just in case. Since pgm files are just plain ascii (as far as I know) you have a fairly easy task to fix since you can just open up your file in a text editor and check line by line that your read statements are correct. It is possible for example you are misreading the header by forgetting a line causing the next line to not contain the correct number of elements. For example, is there not a string with the file name inside pgm files? If there is you aren't reading it. As for resolution, if you are correctly reading the width and height from from the header then simply use those as your loop indexes and the resolution will always be write. I always use implicit loops to read in arrays, it might be that there is a problem with using regular loops (such as taking a new line when you want it to move to the next column) that I am not aware of. I wouldn't have thought so but worth a try. Lastly, there is almost certainly someone out there that has written a script like this before. I would HIGHLY recommend you just use their code.
Can you work on the formatting of this post a bit? It's very hard to see how your data or code are laid out. Fortran can do a formatted read of comma separated variables directly. See here for example: http://computer-programming-forum.com/49-fortran/92ba2264bde324c3.htm (don't read past comment 4 or so, they start going on about standard vs non-standard as old Fortran programmers often do) As for the rest of you commenters, why the heck are you posting on /r/Fortran to "use a different language" ? Like Fortran can't do strings? Or read information in various formats? My goodness we all have to switch to the latest interpreted language to get that functionality. 
Interesting stuff. I never used the co-array features of the language, but they look like they are working on getting them to be pretty fast.
Fortran 2018 looks really nice. I mainly use C++, Python, Javascript (mostly for QtQuick) and Bash for my daily work in computer-aided drug design and computational chemistry. (MD simulations, small molecule docking, free energy calculations, machine learning, ...) I would like to learn another language and recently tried Chapel. Does someone has any experience with it? Is it worth learning Chapel or should I try modern Fortran? 
If you are just looking for an editor, emacs is a pretty good option.
I’m using emacs with maximal syntax highlighting and linting at the moment, but was hoping there’d be an even more powerful syntax highlighting option available. Seems not though. 
I haven't used Chapel, but I find one of the nice things about Fortran is that its intrinsic arrays means that it integrates a little bit more nicely with numpy. So if you find it difficult to get a bit of Python code to run quickly and you can't find an existing solution in the numpy docs anywhere, using f2py to solve it in a little Fortran algorithm can be a good step. On the other hand, the lack of something like the STL library for data structures etc means that things get messy when your code expands, which means that Fortran is probably best only if your algorithm is fairly small or modular.
Sublime with Fortran syntax highlighting is pretty good. But it won't help with the stated goal of distinguishing between intent(in) vs out, inout, etc. But it looks real nice.
It's fine. This is a pretty common thing to do.
Most compilers support automatic type promotion (ex. `-fdefault-*` flags in `gfortran`) but it's generally recommended practice to do something like what you're doing (also using `_fp` for the precision of constant floating point values) because you're defining the precision in a portable way in a single place in your code.
Exactly. We're using this technique to switch our code between single/double/quad precision mode at compile time, in order to have some idea of the noise coming from round-off errors. Some testing was done with compile flags, however we want to be portable between different compilers, and also to link various C/C++ codes, so the explicit way was better.
One option, which I have used in the past, would be to create a minimal module for the version number in the makefile, e.g. something along the lines of git_version.f90: VERSION=$(the git command to get the version number) cat &gt; git_version.f90 &lt;&lt; END module git_version implicit none character(len=*),parameter :: version="$VERSION" end module END and include that module in the part of the code where you want the version number printed. You might also want to delete the dynamically generated module (git_version.f90 above) as the last command in the compilation of the code, after the linking step. 
So it turns out that print*, VERSION does work, where as previously I was using if(mynum .eq. 0) write(lfu,*) 'version =',VERSION as I didn't want multiple processes printing it out. The unformatted write statement doesn't print to my outfile it seems. I cannot recreate the formatting errors I was getting previously however! 🤔
I use a makefile to write a version.f90 dynamically. So somewhere there is something like this: GIT_VERSION := $(shell git describe --abbrev=4 --dirty --always --tags) and @echo " print*, ' build date : $(BUILID) '" &gt;&gt; version.f90 
Hey this is exactly what I was looking for thank you! I don't know why I didn't think of dynamically echoing the info into a module to compile in. Doing this and everything works great
I don’t understand why the compiler doesn’t automatically cast float literals to the type of the variable to which they’re being assigned. I started appending _fp suffixes but it makes preciously easily readable equations much more difficult to read. Is this really common/best practice? Is it common to litter code with these?
Yes, that is best practice. Fortran as a language defaults to single precision for floating point literal values. There are compiler flags that can be used to get the compiler to do what you want, like `-fdefault-real-16` for `gfortran` or `-fpconstant` for `ifort`, but if you want to write compiler-independent code you shouldn't rely on those. In terms of readability I personally don't view it as more than a minor annoyance, and also think documenting code (say, including LaTeX versions of mathematical formulas in comments) significantly mitigates the issue.
I tried to find out and I found an acronym that is for "Development and Advancement of Lunar Instrumentation" [Program ](https://nspires.nasaprs.com/external/solicitations/summary!init.do?solId=%7b07F905CA-C287-12CB-B7E5-AEF4EDBD3FC4%7d&amp;path=open), but that doesn't really make sense in the context. 
Is it worth all the trouble when `f2py` exists to call Fortran subroutines seamlessly from Python?
thanks!
&gt;The issue was fixed by GCC developers who read this question. The bug is tracked at https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84931 I think 2 days turn around time is amazing.
 &gt; 8! 8! = 40,320 
It can be done a C subroutine that expects a key. This can then be called within the fortran code to listen for the event.
Thanks. If I am unable to succeed then his will be a handy fall back. 
The intel windows compiler has some special functions[1]. On unix it is usually more bleak. The common approach is to make use of a C subroutine, as others are saying. [1] https://software.intel.com/en-us/node/679640 (or is this also on unix..?)
I think often times that the novelty of new tools like programming languages makes us forget the usefulness of having a consistence in tools which let us become masters. C++ and Fortran are old, but I appreciate the effort to keep the tools to apply to HPC supercomputing similar.
https://cako.github.io/blog/julia/fortran/2018/03/14/julia-fortran/
I have started learning Fortran and am tackling some project Euler problems to familiarise myself with the language. However since this is self guided and I have been programming in this language for all of about a week, I fear that my code is a little *shit*. If anyone has any feedback, especially on topics such as conventions and the like please let me know! Your thoughts are much appreciated. 
'.f90' is the right extension for modern fortran files, not '.f95'.
I generally follow http://www.fortran90.org/src/best-practices.html with some small modifications/additions. - I indent with 2 spaces instead of 4 for compactness. - I keep lines 78 characters or less - I like having everything fit easily in a default width terminal. - I use snake_case for variables, CamelCase for subroutines and functions, ALLCAPS for external calls. - Specify intent for all arguments to subroutines and functions - Pure functions and subroutines whereever possible (this can be a pain sometimes). - Comment blocks following the begin line of subroutines and functions describing what the function does and what the various arguments are. - Use assumed shape arrays. - Overall try to make code clear in the usual way - sensible variable names and structure, comments explaining anything that isn't obvious or may be confusing. Use whatever works for you, unless you get involved with some larger project in which case you follow whatever conventions are already in use.
There isn't really any "right" extension though, as the standard doesn't specify any file extension. Some people — myself included — prefer to keep calling modern Fortran files .f instead of either .f90 or .f08, and use explicit compiler flags to choose a Fortran standard instead of relying on the file extension. Since you can write fixed-form Fortran 2008 if you really want to, adding a year number to specify that it's free-form Fortran is a confusing convention in my opinion. Also, I prefer to manually specify a version to the compiler anyway, since the default compiler settings for any file extension are usually more liberal than the ones used if you manually request a given Fortran version.
The conventions seems to be that '.f' is used for fixed-form and '.f90' for free-form. Check out the Intel and GNU docs on this. If I remember right, these are the assumptions that these compilers make.
I'm so glad people still stick to 78 characters. I write to 79 (if we're being pedantic) for everything, LaTex, C, Java even (difficulty 11/10) but I think it's one of the best things one can do for readability. I've really enjoyed the pure designator, it's a level of detail which I find reassuring—things don't change out from under you and it's something I've craved all along without knowing it. My penchant for the old goto is an overflow from working in too much C-Python API code. They actually encourage gotos for clean up in the documentation, however those are quite complex structures. And I also find unconditional jumps to be sexy. Thank you for all the help! I see it as incredibly valuable. 
&gt; I indent with 2 spaces instead of 4 for compactness. Oh, you're one of thosssssse lol
Actually, if you check the documentation, Intel decided to use .f90 for all free-form files, while both the GNU and Cray compilers accept .f95, .f03, and .f08 as well. So .f90 is a common convention, but I think only Intel enforces it. But as I said, this is only a convention, since the official standard says nothing about file extensions; there's a reason there's a lot of different extensions even for old Fortran files (.f, .f77, .for, .ftn, .i, etc). It's also a misleading convention since there's no contradiction between Fortran 90 and fixed-form sources: modern Fortran can be written in fixed-form if you wish. All these compilers allow you to override the source form using explicit compiler options instead, and some of us prefer to continue using .f for all files, and then tell the compiler explicitly what we want it to assume :).
Another 2-space indenter here! Makes a difference once you have a triple do-loop inside a function nested in a function in a derived type within a module... 
This. I'd love to adopt Python for interfacing with my code at a higher level (e.g. utilizing it's string parsing capabilities and modules to simplify run-time configuration of my programs), but I'm not willing to sacrifice the convenience of modern derived types in my underlying numerical code to get there.
I'm making a poster and wanted a section of included languages and didn't like any of the ones I found for fotran so I made one. It's just done in google slides if anybody want to remix it: https://docs.google.com/presentation/d/1LTA9lKt9GhUDl4Zn9UBNffQav-QrN00wV9vc5i2QPKo/edit?usp=sharing Feedback welcome. 
Looks nice, thanks for sharing!
This Rust thing you talk of... can do everything?
Actually I use 8 space tabs... Don't shoot
I'd go with all lower case, all uniform colour. I'm not sure what the [an] is referring to though. Square brackets aren't really a big thing in Fortran.
I was imagining the tr is a trace so an would be a matrix or matrices. I did square brackets just to do something different than the parentheses around .or. Along with the fancy f, as in f(x), I was trying to convey the sense of equations or formulas since fortran is short for formula translator. 
Perhaps define ck in the main program. I'm terrible at f77 (compared to modern standards) but: Real,dimension(150) :: ck In the main program may fix your issue.
Thank you. This solves the warning and the issue with the change of "np". I am curious of the reason why np suddenly changed to 1037829990. This is repeatable and does not seem to be some garbage value.
Try to add IMPLICIT NONE to the top of the subroutines (and fix anything that uncovers), then compile with array bounds checking turned on. Without reading the code in detail, it may just be a memory corruption problem.
I believe that setting something to intent(out) destroys the values it holds. So in your Inc(base, out) function could return gibberish.
I believe it's to do with memory management. Essentially, because it doesn't get the bounds of the array correct, it is reading the wrong area of memory. It is "repeatable" in that it is reading the same wrong area of memory each time, so as long as that area has not been overwritten it will return the same value (note that you can check if this is correct by running it on 2 different computers, and you should get different values
&gt; &gt;- Use assumed shape arrays. &gt; I recently tried to adopt this practice myself, but a coworker told me that using assumed shape made it imposible for the compiler to check_bounds. I know, proper use of size inquiried and checking size compatibility should take care of it, but if this was the case and you were lossing a debug tool just for argument economy in subs calls, I would call that a net loss.
Hi /u/kamal65881, good thing you are making these videos in Bangla, but you are using outdated and unrecommended fortran style. It will be more beneficial for your audience if you use modern fortran practices.
I've been seeing these videos pop up every couple of days, the title of them says Fortran90 but the practices you use are extremely outdated, and I suspect you are actually compiling with f77 anyway. Fortran already has a bad reputation of being outdated despite continual development making it an incredibly feature rich, modern language. I would recommend you switch to these more modern practices like free format instead of fixed, end do instead of continue, arrays instead of loops, etc.
this really is horror show fortran
thank you, for your advice
Apologies, but I'm not sure I understand what you mean. If you mean compiling with bounds checking won't catch if you exceed the extent of the array, that's not the case. I test with both intel and gcc compilers and they never have an issue with pointing out where I've made this mistake. If you're talking about how if you use a non-standard lower bound it won't be automatically passed; yes this is true, but you can pass the lower bound explicitly if you need it.
&gt; an incredibly feature rich, modern language Well let's not lose our heads here
If you are on Window the Zeus IDE provides syntax highlighting and code folding for Fortran. &gt;I would like, for example, to be able to visually distinguish between common, intent\(in\), intent\(out\), intent\(inout\), and local variables, and parameters I don't think you'll find a programmer's editor that can do this, as this would require the editor to be *Fortran aware,* meaning it could parse Fortran code down to AST. To get down to that level of understanding would require a very Fortran specific IDE.
&gt;If you mean compiling with bounds checking won't catch if you exceed the extent of the array, that's not the case. I test with both intel and gcc compilers and they never have an issue with pointing out where I've made this mistake. This is what I meant. So I have been lied to! Thanks for the correction. 
Yeah, I didnt test it myself because it is difficult to come up with a good encompassing test. For example: in your code all dimensions are determined at compile time, but what happens if vv is an allocatable of dimension N, which is an input of the program? I could test it myself (actually, I might try tomorrow), but even if it does check, I would still be paranoid about missing some more convoluted* config where explicitly passing size as variable works and implicit does not. *Convoluted for a test, but which could easily appear organically in big and complex codes with modules and types and whatnots.
Well depending in what features you need ... The object orientation might not be as powerful as in other languages, but for things which use a lot of matrices or vectors and need to run on clusters etc, Fortran has many useful features (like elemental functions, coarrays, ...).
No argument there, I'd just have a hard time suggesting someone start a *new* project in modern Fortran. 
Why would you use preprocessing for this? If you need to know the file and line number, you are probably debugging, and compiling with debugging options provideds this functionality. Preprocessing is great in my opinion for high performance. You can remove parts of code or logic for scenarios that may never be needed for an executable, which can be great for say heterogeneous architectures, but also using more or less complex functions depending on problems. 
Why are you posting these videos
I gather, then, that it’s not considered bad practice to use preprocessing in large code bases, if it’s commonly used to exposing/removing sections of code? As far as I know the cpp is available on most platforms even if Intel fpp isn’t, so it shouldn’t be too much of an impact on portability, but portability is one of my concerns. 
Why are you relying on esoteric FORTRAN implicit typing to accomplish the task, resultiing in basically unportable code? I have had to debug so much ported FORTRAN that chokes on on other systems because of the old school I J K L M N integer implicit feature that non FORTAN programmers have little experience with.
I use prepocessor directives very often as thatway you only link to needed modules, e.g. depending on whether you enable MPI support or not. And it can be controlled from cmake, which is pretty handy.
Some tips: 1. Don't use line numbers. They encourage poor structure design. 2. There is a `mod` command that already exists 3. Use `implicit none` and only use explicit typing! Otherwise, misspellings are often not caught by the compiler. Here's a version I made, although I'm sure there are cleverer ways to do it: program quickexample integer :: i, outputcount outputcount = 0 do i=1,499,2 if ( mod(i,11)/=0 ) then write(*,"(I5)",advance="no") i outputcount = outputcount + 1 if (outputcount==5) then print * outputcount=0 endif endif end do print * end program 
Assuming GNU Make, you can use here documents with a combination of define and export; in some cases this can be more readable than a couple of echo statements. Further assuming GNU Fortran, you can dispose of the source file and generate a module file directly, e.g.: define GIT_VER module git_version implicit none character(len=*), parameter :: version = '$(shell git describe --abbrev=4 --dirty --always --tags)' end module endef export GIT_VER git_version.o: echo "$${GIT_VER}"" | gfortran -o $@ -ffree-form -xf95 -
&gt; Floating-point exception - erroneous arithmetic operation This error is probably not directly related to the input, but rather that it creates some invalid math operation, for instance division by zero. &gt; Backtrace for this error: Those numbers are particular for your machine. Instead, you must pass options `-g3` and `-gdwarf-4` to gfortran, and run the program in the system debugger like this: lldb -b -o r -k bt -k q -- ./name-of-program This will result in a backtrace being printed when the error occurs; usually this will help in identify the culprit.
gah, of course!
3. Lois Mitchell Haibt (born 1934) is an American computer scientist. She was one of the ten-person team at IBM that developed FORTRAN, the first successful high-level programming language. During the development of FORTRAN, She analyzed the flow of programs produced by other sections of the compiler. She also created the first syntactic analyzer of arithmetic expressions. Haibt planned and programmed the entire section. Haibt was also part of an eleven person team to develop and release the first reference manual for FORTRAN in 1956.
The error says what the problem is: the module was not compiled by gfortran. Module files are compiler specific (yeah I know, it sucks), so you have to compile the module with the same gfortran as you're compiling the main file. Also make sure the mod file is in the current directory.
It's seems you're generating your object files in a specific directory, check if the object file is there and where is the module file. Make sure both are on the same place, and if needed you can pass a parameter to gfortran telling it where are the module files. Check the gfortran docs for the correct parameter.
-J$MOD_DIR
 gfortran -c -g -o build/Debug/MinGW-Windows/mod1.o mod1.mod Seeing this makes me think you don't have the actual source code file for the module. You'll have to get it if you don't have it. The .mod file is made by the compiler, so you should first do gfortran -c -g -o build/Debug/MinGW-Windows/mod1.o mod1.f08 This will create an actual GNU mod file, and you then compile the main program as you had previously done. Note that mod1 may be included in a larger file with several modules, in which case compile that file instead of mod1.f08 the module will be declared in the source file like module mod1 if you have a lot of files to search, use "grep -i" because fortran is not case sensitive. 
Ahh okay. I have the source file and I changed the suffix to .mod because the error I got before made me think the module needed to be .mod. I'm not in a position to try anything atm, but I think I get what the issue is now. Thanks!
You need to tell gfortran where to find *.mod files. I can't remember the exact flag, might be `-I`. Fortran Hint: use Code Blocks, there is even a special build for Fortran with extra settings.
In case anyone finds your comment later, you are right, you can specify a source directory for modules with `-I` and an output directory for the compiled modules with `-J`. Helps keep your folders tidy.
Yeah that fixed it, thanks. The main issue was the .mod suffix. I've just been letting NetBeans make the actual commands since it seems like it knows what it's doing.
For linux, I assume? Not much available. You have Netbeans or Eclipse as a full IDE, but they are (or used to be) for Fortran not on the same level as for C++/Java. And I always found them overkill, but maybe I am not an IDE guy. The typical Makefile or occasional cmake you will encounter in the physics community is often not properly supported in the IDEs, such that it is common to use *editor of choice*' for code + separate terminal for manual compiling. The best (free) *feature editor* currently is perhaps Microsofts VS Code. Fortran support is decent and even has a gfortran-based linter. 
Codeblocks works very well with Fortran. That's the one I had used.
Emacs is okay with `etags` and `f90\-mode` and you will love it for its Latex capabilities :\)
IntelliJ CLion with Fortran plug-in.
It's OK, but debugging that involves multiple source files is confusing to say the least.
You might try [Simply Fortran](https://simplyfortran.com), which is a commercial development environment designed specifically for Fortran. It includes a [simple plotting library](https://simplyfortran.com/features/aplot) on all supported platforms \(Windows, macOS, and GNU/Linux\), and it ships with LAPACK and BLAS pre\-installed along with the compiler. *NOTE: I am the primary developer of Simply Fortran, so I'm obviously biased.*
Hey, my advisor and I love your product! We were using Intel’s compiler with the IDE being Visual Studio but the compiled program run on some co liters and doesn’t on others. Always missing some .dll files. Since we switched to SF, everything has been smooth sail! One thing though, we noticed our program’s runtime compiled by Intel is about two times faster. Have you noticed that in your benchmark testing between the GNU compiler you used for SF and Intel’s? Is there any way you can do to match the speed? So happy to see the developer on here. Great product anyhow. 
I'm glad you're happy with Simply Fortran! By default, almost all optimizations are disabled with Simply Fortran, so compiling [with some optimizations enabled and possibly targeting the system's CPU](https://simplyfortran.com/docs/full/windows/options/project.html) (by selecting "native" for the architecture) might decrease the speed difference somewhat. Our runtime, though, is currently tuned for "i686," implying it isn't really taking advantage of some modern processor features in 32-bit mode. It might be considerably faster, though, when building in 64-bit mode since 64-bit x86 CPUs have had at least some SIMD instructions from the start. The tuning choice is there to maintain maximum compatibility with all our customers' CPUs, while Intel probably only worries about modern Intel machines. We have a few neat ideas in mind, though, to speed up the runtime next release.
Eclipse+ CDT+ Photran is the best I've found so far. It's heavyweight for sure, but it also integrates a lot of stuff like version control, and even task management. The best would be someone creating a language server, and since Nvidia is doing an llvm frontend to Fortran based on PGI compilers, we might have something like clangd for Fortran in the near future.
Thanks for link. I’ll check that out. I think we already optimized the build using those options. I am glad to hear that you are actively working on improving runtime speed for the next releases. Let us know when that is available!
wow. That would be nice. Also, judging from the other comments I am not up to speed regarding IDEs for Fortran anymore. Glad to hear there is active development in the tooling. 
This looks interesting. My actual compute jobs will be compiled and run on a dedicated machine so what I primarily want is something for writing and debugging. My favorite thing about Spyder is that when you type a function name the documentation for that function will automatically show up in the Help pane. Does Simply Fortran do something similar? 
My favorite thing about Spyder is that when you type a function name the documentation for that function will automatically show up in the Help pane. Does Codeblocks do something similar?
If you type an intrinsic procedure, the documentation will appear for said function after you type it in a popup panel. If it's user\-defined \(i.e. part of your source code\), it currently just displays the procedure definition in the popup panel. There's a [screenshot here](https://simplyfortran.com/static/screenshots/calltips_mac.png) showing the intrinsic **ABS** function as an example.
Not quite the same. When you choose the function from the autocompletion list, the first few lines of documentation are shown below it (as far as I remember, haven't used it in a month or so).
Debugging what?
No love for Geany?
https://www.fortrantutorial.com/documents/IntroductionToFTN95.pdf That's what I'm following.
&gt;I'm on linux with f95 and f77 Most modern Linux distros have the GCC compiler suite available, or have it already installed. Included in this suite is an industrial strength FORTRAN called, now, "gfortran". If you want to learn FORTRAN and to keep up to current FORTRAN technology, then I suggest looking to adding (if you haven't already) the gcc suite, including gfortran. There are plenty of books and tutorials that cover FORTRAN 90/95, 2003 and 2008.
What you are using is for Windows and is a banner semi-free ware compiler. The OP is using Linux. But, for Windows users, good choice to start with.
Well here are a few resources that might save the day: [Introduction to Programming using FORTRAN 95](https://www.fortrantutorial.com/documents/IntroductionToFTN95.pdf) [PDF] [Self study guide: Fortran 95 - University of Cambridge](https://www.mrao.cam.ac.uk/~rachael/compphys/SelfStudyF95.pdf) [PDF] [Fortran 90/95 Programming Manual](www.phy.pku.edu.cn/climate/class/software/Fortran95-Manual.pdf) [PDF] [Introduction to Programming using Fortran 95/2003/2008](www.egr.unlv.edu/~ed/fortranv3.pdf) [PDF] 
The actual literal manual for your particular FORTRAN complier. [Using GNU Fortran](https://gcc.gnu.org/onlinedocs/gcc-5.5.0/gfortran.pdf)
Awesome. Thank you.
Thanks muchly.
Modern Fortran Explained (the book) is pretty great, especially if you have background with other languages.
I've been using this and it's pretty decent. Obviously the windows specific stuff and Plato aren't relevent here, but I haven't seen a better tutorial on the basics of fortran since
I'm just using the code examples on Linux, one thing I've noticed is to call gfortran directly rather than compile with gcc for more explicit error reporting.
&gt; I'm just using the code examples on Linux, one thing I've noticed is to call gfortran directly rather than compile with gcc for more explicit error reporting. I noticed that as well.
https://www.youtube.com/watch?v=ProXdx6xJb8&amp;list=PLNmACol6lYY5_S8I4K29V2oI95nOCzQU8. https://www.youtube.com/watch?v=Ey7mX94Cy_E&amp;list=PLNmACol6lYY4wPUNCK03LOwVTBbca7Ix- Along with the resources others have mentioned check these two video tutorials. The guy will not be very articulate sometimes but it should help you out. I do most of my coding in Fortran and this helped me out a lot in the beginning.
This helpful too. Thank you.
Thank you for that. I tried and ... it works! That aside, am still reading, have done a few doodles. Trying to attend to culture shock. But, am liking it.
@PrintStar. Am I lucky or what? I have been using simplyfortran and it is great for real. I have trouble calling an .for subroutine from a .f90 program that i built. If you happen to know how i could go about doing that it would be awesome. PS I am using the command CALL SUBROUTINE .... but upon compiling i get a syntax error. Thank you in advance
We don't have any explicit student pricing, but send me a private message. I'll be happy to offer you a promotional code.
Sometimes these issues in Fortran 90 are caused by the lack of an interface definition. It might work better if, in your Fortran 90 code, you declare an interface to said subroutine, something like: INTERFACE SUBROUTINE TIMESTWO(X) INTEGER, INTENT(INOUT)::X END SUBROUTINE TIMESTWO END INTERFACE If the syntax error is cause by a missing interface, the above should fix it. Then, this should work fine: CALL TIMESTWO(Y) in your Fortran 90 code. I hope you're not actually using the word "SUBROUTINE" in your call statement, though. You could also private message me with the actual syntax error. I might be able to narrow down what's wrong more quickly.
It's not a tutorial and not easy to read, but for looking things up, the Fortran standard is a great tool.
You should always use `implicit none`, but that's good to know if you have to read old code.
I really appreciate the help, it actually worked by including the interface as you mentioned. Keep up the great work with SimplyFortran. Greeting from Greece!
Hey, you are missing the dimension of the array, aside from that is valid sintax. Check this out https://github.com/RBCanelas/FUPRA, it implements a class exactly like yours, wraps it on an abstract array and then gives you examples on how to use it as a container.
What does class(*) do? I’ve never see. This syntax before. 
Thanks for the repository! I'v found that the error is due to a bad user defined assignment. The command double precision :: vector allocate(father%child,source=vector) allocate and copy the vector element in father%child.
Yes is generic type type very helpfully in polymorphic class.
I've read that gnuplot is pretty good. 
DISLIN
For simple quick plots, especially if generated in batches, I use gnuplot. I also use it for most plots in my publications, although I spend a lot more time in tweaking the look of those plots. If I need something more complicated than what gnuplot can do or want to plot directly from a Python analysis script, I turn to matplotlib. It's waaayy slower, and the documentation isn't as clear, but it is a lot more flexible. 
PLplot is an option that works with Fortran
Python, XMGrace, MatLab, GNUPlot, Mathematica, etc. are all very good options and several of those are free. 
Bonus question, is there a way of transferring an ND array easily from fortran to python? It's easy enough if the lines are too long, but I have some large 1000x30x3 arrays which don't fit into a text file easily
Also, check out [ParaView](https://www.paraview.org/). I prefer ParaView to visualize VTK files produced by the Fortran code.
R. I'm surprised that hasn't been said yet. R also lets you call compiled Fortran code and has a lot of library support for data science.
Gnuplot is good for quick plots, but if you want to put something in a paper or a presentation, python/matplotlib is probably the way to go.
For very simple stuff, I write ppm files directly (I copied the viridis and magma colormap values to an array). For everything else, I use matplotlib or pgfplots.
VisIt and ParaView are both counterintuitive in their own special way. That's why I prefer ParaView, it seems somewhat less so. That said, there's one feature in VisIt \(material boundary delineation\) that I use frequently...
I find that Python/Matplotlib are just as good for 'quick plots' in my work. That said, one can certainly create publication\-quality images in gnuplot.
I've never used it, but isn't there a way to do this with f2py?
Are you sure you're using integers at all? 34! is about 3×10³⁸, which is the largest number that can be represented as a [single-precision floating point number](https://en.wikipedia.org/wiki/Single-precision_floating-point_format). Did you remember to explicitly declare your variables as integers? That is, did you remember to declare your variables using `integer(kind=t) :: a, b` where the `t` is integer kind?
Gnuplot works great for publication-quality plots as well, the main problem is just that the default settings suck. Luckily, [this page](http://www.gnuplotting.org/) contains a lot of tips &amp; tricks regarding how to make prettier plots with it :).
There is a simple example on the [Fortran Wiki](http://fortranwiki.org/fortran/show/Build+tools) explaining how to get started. I previously always wrote my own Makefiles, but CMake is really nice and definitely the way to go for me.
That's not how you define functions in Fortran. The function part of this explains everything you need to know about solving this problem https://en.m.wikibooks.org/wiki/Fortran/Fortran_procedures_and_functions
? do not really understand what you're trying to do ? When you define "E", you use "hw", but its value is undefined, so the compiler must say something like "hw is used before its value has been defined". Or miss I something ? For the function, you can define in another .f file something like &gt; FUNCTION func_name(x) &gt; REAL*8 :: func_name &gt; REAL*8 :: x &gt; func_name = 0.5d0*x &gt; RETURN &gt; END FUNCTION and you call it in your main pgm as x=..something.. v = func_name(x) 
I think for being able to pass functions, you need to define an interface.
Are you using gfortran to compile? Then the error seems to stem from 72nd character in the 10th line. Refer to "schrodinger.f:10.72:" Open your .f file and see what is causing the error at this point.
Could you share an example file? Even the first few hundred bytes might help.
Here is one of the files. I have about 30 others and they are in similar condition. https://drive.google.com/open?id=18ukrrYi_IeyXQCzhUXqTaO_WRN3uBVxa
This is definitely not a Fortran source code file. 
Did take a look at it using a HeX editor. Seems to be some kind of Windows executable format, maybe object code generated by a compiler. Definitely no readable source code. Maybe from Visual Studio?
Do you know what type of file it might be? The internet says that .f90 is source, which evidently isn’t the case here. Maybe the person before me changed the file format (though why would they...)
As someone already mentioned, it is definitively not a fortran source file. That would just be a normal text file, to be opened in your favourite text editor. I had a look at the file in a hex editor, it looks like some kind of Windows binary (i.e the output of the compilation). A very short binary I must say, I don't think there is any code there, just a bunch of names of keyboard keys and mention of Lithuanian layout.
You actually can,it is called a *statement function*, but it is rightfully forgotten. https://www.obliquity.com/computer/fortran/function.html
From what I am told, it was code that connected 2 separate mathematical steel manufacturing models to one another. It supposedly just takes the functions of one model and makes them available to the other. Is there any was to extract the information, or is it pretty much useless?
I really don't know anything about windows binaries, unfortunately. What happens if you rename it to .exe and try to run it on a Windows system?
I am a little confused when you say implicit defined type. Are these vectors actually defined at the beginning of the program/subroutine or are simply allocated allocated in the body? Does your code use pointer references to equivalence statements? Often this is a source of of issues in the code. 
Somebody may just occasionally compile it to this format and copy it by mistake just like: `gfortran main.f90 -o program.f90` Where main.f90 is source file and program.f90 is output binary. 
They were allocated in a dimension statement at the beginning of a subroutine. The solution was that they apparently also needed to be dimensioned at the begging of the main program.
Ah yeah. That makes sense. I don’t know if you are going to maintain this code but declaring implicit none in every routine and function in your code will fix identify these issues during compile
Literally every real variable is implicitly defined and the compiler I'm using will only show 25 errors so unfortunately that doesn't seem to be a realistic check.
Yikes. I think it is still a useful endeavor but maybe for you in small chunks. I can definitely relate. I have inherited a lot of legacy Fortran code and it makes everything so much better when you are finished 
It seems to be a Windows Executable with some zero-padding I know no purpose of. While it is definitely not a source code in neither Fortran nor any other language it does not seem like it came out of the compiler too (the zero padding at the beginning of the file is strange). Nevertheless without that padding it looks like a normal PM executable (i.e. 32 or 64 bit Windows executable), so it may be malformed file of some Windows program or DLL library or something similar.
Given that description and the fact that they are binary, it sounds like a shared object (dynamic link library, dll, on Windows). Unfortunately, there is no reasonable way to extract anything meaningful from that. 
What you have there is kbdlt.dll version 10.0.16299.15 (which is the Lithuanian keyboard library) with some extra zeros added in the beginning of the file. Why do you have such a thing under the name tmp_real8_precipitate11_000.f90? Either somebody messed (intentionally) with the files or it was a HDD failure somewhere and the files got awfully mixed (undelete software give sometimes this kind of results).
How many variables are we talking about here? I had almost the exact same thing with 150+ variables. Compile the code, fix the errors shown and repeat until there are no more errors. This will save you a lot of headaches if you typo a variable name when making changes.
Another issue is I probably shouldn't change how the variable types for existing variables are defined. No one who has been involved with this code recently really knows fortran 77. As a result the philosophy is if you are making additions try to mimic the way similar data is handled elsewhere in program. So changing the way all the data is handled probably wouldn't fly.
You wouldn't need to change how the variable types for existing variable are defined. The only difference would be that "j" is now an integer because you explicitly defined it as such and not because the letter "j" indicates an implicit integer. Every variable would need to be have its type defined for each subroutine where it is used, unless you are pulling it in as global variable through a module or a common block. You can have a mix of subroutines where some have explicitly defined variables and some still have their implicitly defined variables. It's not ideal, but it can make it a little easier if there is too much to try and change at once.
Well TIL. 
None. The scientific Fortran programs I use tend to have their own dedicated forums.
Comp.lang.FORTRAN (usenet) is good to follow.
Oh. I didn't even think abt that!
How do you connect to Usenet? Didn't know that was still in use?
http://fortranwiki.org/fortran/show/comp.lang.fortran you can access it via google groups or other methods described in the link.
MPI and OpenMP tend to be two of the more popular parallelization tools. They are actually fairly easy to learn how to use at a basic level and there's tons of resources online you can find. The hard part tends to be more how to go about getting the best performance which is heavily dependent on the particulars of the code. 
Two things I would do first: (a) If you don't know much about numerical methods, algorithm analysis, and optimizing performance for single-threaded code, you're going to want to know a decent amount about that before trying to write high performance parallel code. There are tons and tons of resources out there on these topics. If you can't write high performance single-threaded code the only situation in which you'll really be able to write high performance parallel code is if you get lucky and there's a pre-existing library you can call to offload all the work for you. Also, if you haven't noticed already, a *lot* of academics are really bad at writing high performance code; the amount of wasted server / cluster time I saw in grad school because people didn't properly account for things like cache misses was staggering. (b) There aren't that many great resources out there specifically on modern Fortran (specifically, F2008 and later). A lot of resources are really outdated (but there's also a lot of legacy Fortran code out there and Fortran is kind of a niche language). I remember thinking https://www.amazon.com/Guide-Fortran-Programming-Walter-Brainerd/dp/1447167589/ was okay but most of my Fortran experience was self-taught and / or scraped together from a ton of different sources. Obviously this advice changes a bit if you're going to need to be maintaining or adding onto a large amount of older code. Beyond that: * for a general introduction to parallel computing (primarily focusing around CPU-based parallelization and clustering instead of hardware offloading), I remember thinking https://www.amazon.com/Sourcebook-Parallel-Computing-Kaufmann-Architecture/dp/1558608710 was okay but there are a number of resources out there. Also, as a general piece of advice you're going to really want to put in a non-trivial amount of work before starting to write parallel code making sure you're choosing the correct ways to parallelize things given the problem you're working on and the hardware you have available. For instance, not everything runs faster on a GPU and sometimes the amount of work involved in properly implementing something in a massively parallel manor would take an unjustifiable amount of time (after all, your primary goal is to get a PhD, not write the most optimized parallel code in the world). On the CPU parallelization side, OpenMP and MPI are both fairly popular but they have different use cases where they each excel (and in distributed / clustered systems they're often used in tandem). * for GPU programming, I remember thinking https://www.amazon.com/Programming-Massively-Parallel-Processors-Hands/dp/0128119861/ and https://www.amazon.com/Professional-CUDA-Programming-John-Cheng/dp/1118739329/ were okay. They're not written for Fortran but at the end of the day if you're doing GPU programming, how you interface to something like the CUDA libraries shouldn't really matter that much.
Thank you for passing this on.
By far the best forum is the Intel FORTRAN forum.
Thank you for that. Yes.
http://lmgtfy.com/?q=converting+fortran+code+from+32+bit+to+64+bit
What do you mean by won't run? What error do you get? During compilation or during execution? What compiler are you using? The more details you give, the most likely it is that someone can help.
if using gfortran you likely need to use -std=legacy
How old is it? Modern compilers might not work or need specific flags to work with 77 stuff. You might find that even if you can compile it, it won't run on his pc.
Ok so i seem to be getting some good information. but mostly questions that I dont understand. here is one of the programs that im trying to get to work. C C PROGRAM GUTTER WRITE(*,100) 100 FORMAT(' ENTER DISTANCE TO RIDGE ----------------- FT = ',$) READ(*,*)W WRITE(*,150) 150 FORMAT(' ENTER DOWNSPOUT SPACING ----------------- FT = ',$) READ(*,*)S WRITE(*,200) 200 FORMAT(' ENTER RAINFALL INTENSITY ------------- IN/HR = ',$) READ(*,*)RI WRITE(*,250) 250 FORMAT(' ENTER GUTTER WIDTH ---------------------- IN = ',$) READ(*,*)GW WRITE(*,300) 300 FORMAT(' ENTER GUTTER DEPTH ---------------------- IN = ',$) READ(*,*)GD XW=GW/12.0 XM=GD/GW T1=XW*XM**(4.0/7.0) T2=0.481*((RI/43200.0)**(5.0/14.0))*W**(5.0/14.0) SR=(T1/T2)**(28.0/13.0) ADS=W*S*RI/1200.0 RA=S/SR WRITE(*,400) WRITE(*,400) WRITE(*,400) WRITE(*,350)S 350 FORMAT(' INPUT DOWNSPOUT SPACING = ',F7.2) WRITE(*,400) 400 FORMAT(2X) WRITE(*,450)SR 450 FORMAT(' REQUIRED DOWNSPOUT SPACING = ',F7.2) WRITE(*,400) WRITE(*,500)RA 500 FORMAT(' CSI = ',F6.4) WRITE(*,400) WRITE(*,400) WRITE(*,550)ADS 550 FORMAT(' AREA OF DOWNSPOUT REQUIRED = ',F6.2) WRITE(*,400) WRITE(*,400) WRITE(*,400) STOP END it is savedas a .for file, and im completely lost....
 C C PROGRAM GUTTER WRITE(*,100) 100 FORMAT(' ENTER DISTANCE TO RIDGE ----------------- FT = ',$) READ(*,*)W WRITE(*,150) 150 FORMAT(' ENTER DOWNSPOUT SPACING ----------------- FT = ',$) READ(*,*)S WRITE(*,200) 200 FORMAT(' ENTER RAINFALL INTENSITY ------------- IN/HR = ',$) READ(*,*)RI WRITE(*,250) 250 FORMAT(' ENTER GUTTER WIDTH ---------------------- IN = ',$) READ(*,*)GW WRITE(*,300) 300 FORMAT(' ENTER GUTTER DEPTH ---------------------- IN = ',$) READ(*,*)GD XW=GW/12.0 XM=GD/GW T1=XW*XM**(4.0/7.0) T2=0.481*((RI/43200.0)**(5.0/14.0))*W**(5.0/14.0) SR=(T1/T2)**(28.0/13.0) ADS=W*S*RI/1200.0 RA=S/SR WRITE(*,400) WRITE(*,400) WRITE(*,400) WRITE(*,350)S 350 FORMAT(' INPUT DOWNSPOUT SPACING = ',F7.2) WRITE(*,400) 400 FORMAT(2X) WRITE(*,450)SR 450 FORMAT(' REQUIRED DOWNSPOUT SPACING = ',F7.2) WRITE(*,400) WRITE(*,500)RA 500 FORMAT(' CSI = ',F6.4) WRITE(*,400) WRITE(*,400) WRITE(*,550)ADS 550 FORMAT(' AREA OF DOWNSPOUT REQUIRED = ',F6.2) WRITE(*,400) WRITE(*,400) WRITE(*,400) STOP END 
I have done a bit of Fortran in the past and I think I can help. I can compile and run this program successfully with gfortran by renaming the file to `gutter.f` and then running `gfortran gutter.f &amp;&amp; ./a.out`. If you have gfortran on your mac this should work. I can PM you if you would like but I would rather keep the discussion out here in case someone else wants to contribute.
What did he use on the PC? Power station 4.0 runs via Crossover (Wine), it's probably easier to just keep the compiler and runtime the same.
When you say "run", are you literally just double-clicking the '.for' file?
Using **Coarrays** which are built into modern (\~2008) Fortran instead of **MPI** which is a external library, and consequently has some slight and irritating inconsistencies/incompatabilities, might be good choice for the future.
You can use gfortran to compile this. gfortran -ffixed-form -o &lt;outputname&gt; gutter.for Where the above file is saved as gutter.for
Well, 34! is also just above the range promised by `selected_int_kind(38)`. On my platform (gfortran on Linux x86_64), the maximum value I obtain is 1.7 10^38 and the storage size is 128 bits.
Interesting, I didn't know 128-bit ints were available on 64-bit hardware. I guess gfortran implements some multi-word number types in software then, including perhaps quad-precision floats?
It would be helpful if you posted some code.
I think it's just that FORMTRAN sounds a bit sillier. It's four consonants in a row, which happens sometimes in English, but doesn't make a super snappy name.
Because it would sound like one of those stupid abbrevations/acronyms military guys keep making, to the delight of us all. Simply Fortran guys didn't want people think of them as stupid. They had some style!
could be something to do with the seven character identifier limit in Fortran at the time
Wasn’t it 6?
Oops! Guess that's not it then
I can't offer any specific advice, but memory issues can be weird like that. Have you compiled the code with checks and warnings turned on? I find that can help me solve 90% of my problems.
Or run with valgrind
This is hard to tell. Are the arrays the same size in the call of the subroutine and within the subroutine? Fortran passes data by pointer, and you can overwrite a subsequent array if the previous one was to small.
Yea I have `-CB` and `-check stack` along the the usual `-O0 -g -traceback` for debugging (in ifort). If you look at the gdb output the problem is that the 2nd arg of the subroutine isn't reachable as soon as you enter the subroutine: `rhog=&lt;error reading variable: Cannot access memory at address 0xb458&gt;'. When I go one frame up to where the subroutine is called, that arg is fine and accessible.
google made me think this may have been a stack overflow so I ran with `valgrind --tool=massif`. I wasn't sure what to look for though so it didn't really help. I'll try again with a leak test. 
The array is inacessible upon entering the subroutine, that's the line `rhog=&lt;error reading variable: Cannot access memory at address 0xb458&gt;'
For floating point operations, gfortran (as other gcc frontends) uses https://gcc.gnu.org/onlinedocs/libquadmath/ For integer operations I couldn't find the information in gcc's or gfortran's documentation.
Do you already know how to program and just need Fortran? 
Pick up any of Etter's books, they are cheap and she cuts the crap and gets to the point of why you use Fortran (or C++). You can get a F77 book for like $7 on Amaxon right now.
&gt; You can get a F77 book for like $7 on Amazon right now. What did OP ever do to you?
No I have no programming experience. I have been trying to learn via youtube and other places online with no success. 
http://fortranwiki.org/fortran/show/HomePage isn’t bad. 
Start with a different language (e.g. C). Once you have an idea of how the basic structures work, then learn the Fortran syntax.
Ok, what would you suggest is the best place to start with C? Udemmy? or just find a book and go for it?
thanks I will check it out
OP?
I will order it now. 
A book. Java is okay too. Focus on the variables, arrays, loops, decision statements. Pick some simple projects to do (project Euler is nice for numerical exercises).
If you can, take a numerical methods or Intro to Scientific Computing in the Fall. Not sure about you but I learn better in a classroom environment with actual projects and homeworks. 
Oh it's just elitest thing that F77 gets a bad rap. It is perfectly fine and if you can figure out how to code in that then any of the newer versions are a walk in the park. Now FORTRAN before F77 is so abnormal that might not be helpful at all. And anyways Etter's books are written for engineers and not CS majors do you do not get wrapped up in stupid needless minutia 
Etter's book on structured fortran is a start. You can also use https://www.fortrantutorial.com/ for starting. This won't take you much time. https://people.sc.fsu.edu/%7Ejburkardt/f_src/f_src.html - You can find source codes of almost anything here. http://ww2.odu.edu/~agodunov/computing/programs/- Here are some source codes for numerical methods. Once you familiarize yourself with the syntax, you can even convert codes from Fortran IV//77/C++/MATLAB/Python to Fortran. My favorite thing to do is to convert from Fortran IV to Fortran 90.
We've got fresh meat guys! OP means original poster. It's just a general reddit term, rather than a fortran thing.
Here is a [short course on Modern Fortran](http://archer.ac.uk/training/courses/2016/03/mfortran_imp/index.php) (\~2 days). It has slides and exercises in the links on the page. It was designed as an intro to scientific/engineering Fortran so it might be useful. Some of it is specific to the supercomputer they are associated with, but there's good stuff for a beginner in there too provided you can get your own gfortran installation up and running.
Do not learn Fortran77. Fortran95 (a later version) is much more modern. The only thing you can do with Fortran77 is work on 30-year-old codes; no one writes new stuff in F77.
The only reason I can think of for that is, that Fortran has fewer resources. But I taught Fortran95 as first programming language to college fresh mean for a few years. That worked quite well. They often complained it about being ancient and not JavaScript but not any actual critic on the language...
I find that fortran (95) has less confusing syntax than especially C. If you go with fortran 77 or older then C, might help more.... If you are going with fortran 2003 or newer than Java as a comparison wouldn't be that bad
In my opinion, python with the numpy package is both simple enough to use for someone who has never programmed before and fairly similar to Fortran in approach. 
Oh you're absolutely right. Fortran is pretty easy to grasp but you have to find a decent resource, which isn't easy. 
I disagree with /u/andural 's suggestion to study another language first. In fact, it can be quire disconcerting if you have to quickly learn two. Focus on one, in this case Fortran if that is what you want. There are numerous resources available. My go to resource was this: [http://people.ds.cam.ac.uk/nmm1/fortran/](http://people.ds.cam.ac.uk/nmm1/fortran/) Other than that, you can ask questions here, or on the ##fortran IRC channel at freenode.net
OP is short for Original Post(er), depending on the context it can refer to the person who wrote the original post (in this case you) or to the original post itself. But really, you don't want Fortran 77. Even if you don't plan on programming outside of school. Fortran is an interesting language because it has had to evolve over the years, the way the language looks and feels has changed significantly over time. The bottom line is that legacy Fortran (including 77) is an absolute pain to work with. Older revisions of the language lack the facilities to write high quality, maintainable software. Since you are not a programmer (yet), I'll resist the urge to go into too much detail but in general; its better to start out with the newer versions of the language and try to learn good practices than to get stuck picking up bad habits and out dated techniques that are known today to be the wrong way to do things. Fortran 90/95 is the oldest you want to go - use 2008 if you can. Besides, fixed format source code is just downright annoying, no one should have to pretend a digital file is a punch card. I recommend "Modern Fortran Explained" published by the Oxford University Press, it isn't the best programming book but it is probably the best Fortran book. One of the authors even sits on the Fortran standards committee. I keep a copy on my desk as a bench reference. I'm more of a Debian guy, but I know the GNU Compiler Collection is available for OS X/macOS. Is brew still a thing? Anyways, gfortran (part of the GNU Compiler Collection) is a pretty high quality Fortran compiler. Make sure you build with all warnings enabled (-Wall -Wextra) and explore the sanitizers (one example, -fsanitize=address). Together, these will help you catch bugs early. Of course, the best way to learn start learning to program is to write code, head over to projecteuler.net and start solving some problems by writing code.
Fair enough, if that's a good resource. I haven't found many previously.
I am starting grad school this fall and will also be using FORTRAN, so I had the same question. Thanks for posting!
Oh, there's loads. Check out the resources on the Canadian [SHARCnet](https://www.sharcnet.ca/help/index.php/Online_Seminars). That is another that I use a lot.
I'd suggest Python instead of C.
I'd suggest you go for Python instead of Fortran. Python is widely used in scientific research. Jupyter notebooks are awesome to use and Numpy has lot's of **fast** and ready to use functions. Also matplotlib is great for visualization.
I thought about that but Python might be too different. No variable declarations, and loops look a little different.
Ha I've used their website as a reference for HPC job submission systems before.
That's why it's better. Once you understand the concepts you can move to more complex languages. Also Python syntax is much more similar to Fortran than C. With Numpy arrays you get the same array syntax as Fortran (slices, vector operations,etc). In C you are stuck with loops and you still have the same problems that you have with C, like compilation, linking libraries, etc. The REPL in Python (or better yet, Jupyter notebooks) is much easier to start with.
[removed]
I would consider anything before Fortran 2008 as outdated. In fact, the newest standard, Fortran 2018, is going to be published in a few months, certainly by the end of 2018.
How is compiler support for the new Fortran standards?
Intel and Cray compilers provide full support of Fortran 2008, and partial support of Fortran 2018. GFortranvia OpenCoarrays. IBM has extensive support of Fortran 2008 and 2018, except Coarray Fortran. PGI compiler has full support of Fortran 2003 and partial support of Fortran 2008. For more information see for example: http://fortranwiki.org/fortran/show/Compiler+Support+for+Modern+Fortran and the following for GFortran: https://gcc.gnu.org/wiki/Fortran2008Status 
I think it's fine to teach Fortran as a first language if the plan is that these people will work in Fortran. But Python's syntax is just as simple, and it has a lot more resources, and will qualify students for a lot more positions. And something in the C family (C,C++,Java,C#,Objective-C,etc) is good to pick up because those languages are all widely used, have a lot in common, and some of them are efficient enough to be used in scientific computing anyway. Fortran isn't bad, but in terms of setting people up for a career, it's not necessarily the best option for a first language.
Well, my students supposedly have 4 years more of college and will at least be exposed to matlab/octave, quite possibly to python and java and some little c, haskell and prolog, (well the C and haskell part is coming very short). The point of us teaching Fortran is mainly to have a compiled, statically typed language with simple syntax (Fortran is easier there than c and java for beginners) and let's us focus on precision and speed. So when we take their assignments in a total of 25 one-on-one conversation it is easier to point out how to improve their code, not only on a theoretical but also practical level. Python doesn't make that as clear I find.
I guess I worry that Fortran is so different to the most popular languages today that it might lead to some misconceptions or poor practices if it's their first or only exposure to programming. I agree that if you want a compiled statically typed language, then Fortran is definitely the simplest to understand. But C and C-derived languages are just so ludicrously prevalent that it's important to be able to get your head around them and not get stuck in a Fortran mindset. Though I do see your point on Python. Efficient design in Python is about using vectorised library functions in a sensible way, which doesn't teach you much about algorithm design. You could write out the algorithm explicitly, but that's not as practical because that's not really what you want to do in Python and gives you really slow code, whereas that's exactly what you want to do if you're writing in Fortran.
You make it sound like Fortran is among the most useful and modern languages :)
I wish ;-) It would make much easier to deal with the code I get from the scientists I work with.... 
So what sets this apart from any other vps/docker type solution? You mentioned it was geared towards scientific computing, but the example doesnt really show off that niche. The readme just goes through the steps of spinning up a normal ubuntu install, then downloading gfortran and running your program.
In Fortran, the parenthesis serves either for function calls or for accessing an array element. The scalar declaration "real*8 ranf" points to a function call but then it should declare ranf as external as well. ranf in not in the Fortran standard anyway. The name suggests "random float" but to confirm this, you should obtain access to the documentation of the code, of the algorithm, or to the author :-) 
Since it doesn’t appear to be a vector (no dimension provided on the specification line) then it must be a user function that takes an integer input.
Well... in some Python libraries...ranf - for random float- return random floats in the [0.0, 1.0] range. Perhaps here there is such an equivalent routine in a Fortran library somewhere the pgm is linked with. See the link script to find which libraries are fetched where.
Modern Fortran continues to be used and actively developed in operational environments across the U.S. This is not a "legacy" choice. It's a performance and maintainability choice. 
Absolutely agree, the post was written by a JavaScript developer for other javascript developers. The point is really that we shouldn't discount these languages as old but see Thier merit. That seems to be a precursor to your point.
I built a web application development framework in Fortran I call FABS (Fortran, Apache, BSD, SQLite) just to prove I could. :)
It _is_ old. It is also _good_ for what it does.
Link?
Yup. I can attest to the fact that FORTRAN is still used extensively in geophysics and computational chemistry. And not just because there are large libraries of legacy code. A lot of quantum chemistry and molecular dynamics programs meant to be run on super computers are written in FORTRAN.
No longer required to write Fortran in all caps either. 
Fortran is a fine language, no doubt. Doesn't the same post mention that: &gt; Let’s be clear. Staying up to date within your environment is important. Some research codes sacrifice maintainability for performance - by still retaining Fortran 77 syntax and sometimes not using `implicit none`.
Agreed, this will be true no matter what languages you have. We enforce a certain standard at work, “implicit none” being one of them. :) 
&gt; It’s really easy to look over at a Fortran, C++ or even Java expert and think: “Hey, how’s 1990 going for ya grandad!”. The truth is there really isn’t any reason to think yourself better than a ‘fortranner’. Yes, it’s old, but that doesn’t mean that any less brainpower is required nor does it mean that there’s a smaller financial reward for the work. That doesn't say anything about Fortran not being old. It says not to discount the skill of someone just because they use Fortran.
Yeah, I know of one.
I know one. It's called "This sub is not for homework". 
You should at least post your attempt.
Definitely not the best solution, but probably the simplest. Write a program that will loop through n=100 to n=999, and modulo with all numbers between 2 and n-1. As soon as one of the calculations returns 0, move on to the next n. If it reaches n-1 without returning a zero, add it to a list of primes. You can work out the code yourself. This isn't an even remotely difficult problem, unless there are a lot more restrictions that you're not mentioning. If you were unable to work out even a pseudocode solution by yourself, maybe you should take a step back and practice some programming concepts before getting into the meat of it?
I find Intel and Lagey Fortran reference books a nice reads for entertainment.
If you want short example programs, you could look for sets of Project Euler solutions - you'll get a bunch of different GitHub repos on google, and you can compare them to see the different ways people approach these problems, different programming styles etc. The Fortran doesn't have a single unified culture and style (unlike Python which has an "official" style and philosophy) so there will be a lot of diversity. If you want an example of a actual research level Fortran code (for better or worse), here's a random example of an astrophysics N-body+hydrodynamics code: https://bitbucket.org/danielprice/phantom/src
Thanks. Happened to have run to a great fantastic link of some university, someone put it in comments a few posts below. Am going through those, mostly mathematical problems and Fortran code for solving those, but nicely written and a joy to read through. I must be an odd fellow, enjoying in reading Fortran reference manual and code examples to entertain myself. Can't help it, an engineer, whatever other languages and codes I read, nothing tickles me as Fortran does.
Nice one, thank you for sharing, am reading through his files, nice read indeed.
Here's the repo for the biggest open-source [density functional theory](https://en.wikipedia.org/wiki/Density_functional_theory) code, which is mostly written in fortran: [https://gitlab.com/QEF/q-e](https://gitlab.com/QEF/q-e). Here's a repo for finding [maximally localized Wannier Functions](https://arxiv.org/abs/1112.5411), this code is quite nice: [https://github.com/wannier-developers/wannier90](https://github.com/wannier-developers/wannier90). 
Thanks bud. Much appreciated! Will pull some of that to play around.
Yea the QE code isn't the prettiest but it's really popular for DFT users and even has a good percentage of usage on one of the USA's largest supercomputers: [http://portal.nersc.gov/project/mpccc/baustin/NERSC\_2014\_Workload\_Analysis\_v1.1.pdf](http://portal.nersc.gov/project/mpccc/baustin/NERSC_2014_Workload_Analysis_v1.1.pdf)
Nah, you're not odd...alone. We all are! After all we all are subscribed here. On a more serious tone, Fortran conveys the meaning of algorithms really well in my opinion. I wish I could share mine with you, but they will take my head for it. Have fun on the ship!
http://fortranwiki.org/fortran/show/Software+repositories has a ton of links I'd recommend especially: http://people.sc.fsu.edu/~jburkardt/f_src/f_src.html
Ah ran into that one last night. Better than porn!
No. 
Bummer, thanks. 
Why not just put the index on the argument? sin(x(1,2)) Or do you have an example where this doesn't work?
I want to be able to WRITE the output array directly in a way that isn't horrible to read. To this end I had something like `WRITE (*,fmt) (function(arr1)(i,:), I=1,2)`
Hmm, sorry. Then I don't know a solution...
Looking at one element at a time will be difficult. Try more than one.
You could train your thinking process by starting with a simpler problem, then progressively working toward the problem you have. So in this case: 1. If you have two sequences (e.g. ABC and ACB), how can you tell if they are the same? 2. If one of those sequences is longer, how can you check if the shorter sequence starts from the Nth character? (E.g. how can you tell if CBABCC contains an ABC starting from the 3rd character?) 3. How can you check if the shorter sequence is somewhere in the larger sequence? 
how do I do that? 
question 2 is basically the problem I'm trying to solve. I'm having trouble with the do loops. 
I'm going to think about it some more
I don't want to reveal too much but, under the hood a `character` is just an array of individual bytes, use the "index range" `:` to control how much of each character you access. For example, given `character(len=:) :: foo = "abcdefg"` then referencing `foo(3:6)` is the same as "cdef".
Download the LAPACK and SLATEC libraries from here http://www.netlib.org/slatec/ http://www.netlib.org/lapack/ These are basically subroutines and functions for specific mathematical and statistical operations. They are open source and free to use. Should keep you entertained for long. I would however recommend, keeping an advanced engineering mathematics book handy when you are going through these, should help you make sense of what the functions and subroutines do.
That is one of the points, also one important consideration which might not be formalized but I believe people follow subconsciously is the number of syllabes and the phonetics of the shortened name. How one syllable flows into the next one. Personally I feel FORMTRAN is slightly more difficult as one has to go from the lip position for "M" to the tongue position of "T" and then to "R", much more convoluted than going from the tongue position for "R" to tongue position of "T" and then back to "R", which is the case in FORTRAN. FORTRAN is just easier to say and flows better, without any jarring phonetic transition.
It actually makes me wonder, apart from the word Dreamt, anyone know of any words where M is immediately followed by T?
Yeah the Intel Forum is pretty good. I usually do not use the Intel Compiler, but rather GCC, however, they still try to help you. Just mention from the git-go that you are not using Intel, because some problems which arise in GCC are non-existent in Intel or have different fixes. They will still try to help you, because for the most part the ones who are active there are ones who genuinely appreciate and love Fortran without being married to the commercial considerations. 
Does the smaller array have to be ordered? Rather does it have to be present in the given order? (that mean ACC is not the same as CAC or CCA) If it has to be ordered, 1. start with the first element of the larger array. (You can choose which is the larger array by using the size function). 2. Check if the first element of Large is equal to the first element of short. If no go to next element. Keep going till the ith element of large is equal to the first element of short. 3. Check if the number of elements after ith element of large are sufficient to contain the remaining number of elements of short. If no loop terminates and you say short array not present in large array, if yes go to the next statement. 4. Log the value of i in some dummy variable (say x) 5. Check if i+1 element of large is equal to the second element of short. If yes, check if i+2 is equal to the 3rd element and so on and so forth. If the complete ordered sequence is found, print, short ordered array is contained in large and exit the loop. 6. IF there is a no in the above statement (5) start from the (x+1)th variable and check if (x+1)th variable of large is equal to the first variable of short. if not check (x+2)th... and so on and so forth. IF it is go to 3. This should work, unless I misunderstood the problem.
Look up the AKS solution, test for Primality. It was actually derived for finding very large prime numbers. However it should work for the extremely small one you have. It is relatively easy to write up into a program. 
Before you start using fortran make sure you understand the math of the problem you are trying to solve using FORTRAN. Once you understand the math, all you need to do is figure out the syntax. Syntax is easy, math is not.
Edit: For the ordered case Another easy way is to count the number of instances where any element of the large array is equal to the first element. These are the maximum number of possibilities where the smaller array might be contained in the larger one. Check the elements next to all these matching elements in the larger array and see if the sequence matches that of the shorter array. You got your answer.
 write (*,'(3f14,/)) (function(arr1(i,:)), I=1,2) 
You have to make all statement functions prior to any executable commands. In this case you are defining elements of E before you make the statement function, switch those lines, 
The language is independent of the IDE you are using, you should be able to compile the fortran files in the command line using ifort or make if you have a makefile.
I know that. When I install intel fortran, I did a trial run on terminal whether it works or not but when I tried to run a file and calling another file in that file, I just hit a wall. Since I'm not a developer, I wanted to use an IDE to simplfy my job. on windows just clicking run makes my job done. Thats why I wanna learn how to run my files by IDEs on my mac.
You should look up makefiles, that is how you can solve all the sequential compile and lib problems. That is how the IDE does it as well.
Thanks for your answer and interest but I can try that if thats the last option. Other than that I don't care how IDE does it. I just wanna click 'run' and solve my numerical problems. As I just said I'm not a developer or programmer.
I understand, I am sorry all my work is in Linux so I cannot help any further with regards to IDEs in OSX.
Unfortunately, Fortran is not the language for you if you don't want to look under the hood a little. Fortran is a compiled language, and does not have any good IDE support, which means that you really do need to learn how to write a Makefile, or at least the basics of how to run a compiler. Even with an IDE you will need to know this - you don't want to trust everything to an IDE, it should be there to automatic stuff you know how to do, not to sort out things you don't understand yet. If you just want to compile multiple files together, then something like: gfortran file1.f90 file2.f90 file3.f90 -o myprogram will do it for you, if you just want the simplest possible thing. But if you really want a nice interface to code in, you might have to do something like use a Jupyter notebook and do your work in Python.
you are not helping mate. I really dont care what is under the hood. I'm using MATLAB for my NUMERICAL PROBLEMS. Program has only for loops and few multiplications. Now for bigger problems to make it fast I wanna use fortran to save my time. I don't wanna wait 12 hours to run when there is an option 1 hour. As I said several times, I'm not a developer or programmer. I'm an engineer. In windows, there is an IDE which is called MICROSOFT VISUAL STUDIO and in that IDE there is button for 'run' and it does my job. I don't know makefile or how to run a compiler. I'm just asking whether, there is any IDE to do the same job for macos. This shouldn't be too hard to understrand I guess. 
Try [Code Blocks](http://www.codeblocks.org/downloads/26) There is a version for Mac. A better thing would be more specialized [Fortran version](http://cbfortran.sourceforge.net/downloads/) but there doesn't seem to be a Mac build. If you use just standard Fortran (no co-arrays, no Windows-specific routines in Intel Fortran), consider installing `gfortran` from brew or macports. &gt; I'm just asking whether, there is any IDE to do the same job for macos. Probably no. &gt; I really dont care what is under the hood. I'm using MATLAB for my NUMERICAL PROBLEMS. Program has only for loops and few multiplications. If everything in one file, say `prog.f90`, simple `ifort prog.f90` in command line should do the trick.
What op said is basically correct and lashing out at him/her isn’t very constructive. Unfortunately Mac OS probably isn’t going to work for you if you want a visual ide unless you spend some money then. Visual studio for Mac is very stripped down and Xcode doesn’t support direct compilation of Fortran files. If money is no object to you then I would look into totalview. Of all the visual debuggers i have seen on Unix environments, it is the most polished. 
Look, we are almost all engineers and scientists who are using Fortran to get results. Very few comp sci majors end up using Fortran. But we all picked up Fortran at undergrad or grad school - many of us discovered it when our thesis supervisor dumped an old Fortran code on us. You don't have some special excuse here. If you want to use Fortran, you have to learn how to use Fortran. And that includes learning how to write a Makefile. If that is something you aren't willing to learn, then you will have a lot of difficulty in using Fortran, because - like I said above - there aren't really any great Fortran IDEs, and even if you do use an IDE, you're going to get into trouble if the Makefile is still a mystery to you. If this is not the answer you want, then you'll just have to change your perspective of what using Fortran is going to be like. It's not because I'm not listening. 
&gt;Computer literacy is a requirement. Chemical engineer here as well, currently doing computational chem research. Definitely agree 100%; knowing how your tools work is a really important part of programming. You gotta put forth the effort to learn programming, and honestly Fortran is one of the easier compiled languages out there (it's definitely better than C, at least)
you have to upgrade to IDE Pro to unlock the 'run' button
Intel has decent documentation on their website. Here's something to get you started: https://software.intel.com/en-us/fortran-compiler-18.0-developer-guide-and-reference-using-xcode-macos
Install home brew. Use that to install gcc. Get a decent text editor and compile and run using terminal commands. 
Best way is using a good terminal like cygwin and a notepad so you can easily compile your stuff. If you want a good IDE simplyfortran is cool and gets the job done. However you are better off with what I first stated 
You could try downloading and installing [Simply Fortran for macOS](https://simplyfortran.com/download/?platform=macos), which should meet your needs. You won't have any other things to download (it includes the compiler), and, based on some of your comments, you'll be able to add your Fortran files to a project, click Build, and click Run to see results. Simply Fortran is free to try for 30 days if you're just trying it out. There shouldn't be any other steps. If there are, let me know, and I'll be happy to help. I'm the primary developer of Simply Fortran.
If it's old Microsoft stuff you are after, PowerStation 4 runs on Crossover/Wine..
it should be 10.5 I think, is that what you are asking? M=300+250=550 K=550/100 +5 =5.5+5=10.5 
Not if it's integer division. Also, this seems like a homework question to me. 
If you need others to do this kind of homework, I can only predict the final value of your grade. It's going to be an F.
I'm not going to do your homework for you, but as a hint just remember that for the last line when you use the lower case of the variable 'k', it's the same as half the upper case 'K' (k=0.5d0\*K)
Do your own homework...but the answer is not 10.5, if you don't know why not...you need to dtop the class.
Yes, you are right. 
Yeah I got to admit I am a bit rusty when it comes to math atm, had some higher math courses at university, cannot recall exactly, 3 or 4 semesters, but it all sort of disappeared. I really need to refresh it a bit :) Thanks for recommendation, atm enjoying some smaller code samples along with Lahey and Fujitsu Fortran reference manual, rather entertaining!
I like how you said the simplest possible thing. For me, if I want to do a small thing, an IDE adds far too much complexity and makes solving your problem more difficult. Vim is everything I need for most things and only do I turn to an IDE when working on Java, Python etc. With something like Fortran, your os is your ide. Good to see kiwis in the wild, too. 
Yeah, I do find myself using an IDE for Java, but it doesn't seem to quite work the same way for Fortran.
It would be best to share your code. As always, it's probably the fault of the code, not Fortran's. Without the code, I'd bet on an issue of variable initialization... 
okay, I added my code. will you check it out?
Without seeing actual code, all we can do is take wild guesses. Based on you observing different answers every time, something must change inside the function/subroutine between the calls. Perhaps some variable is global when it should be local, or perhaps somewhere in the code you are accidentally writing over array bounds, corrupting memory. Posting a minimal example — the function/subroutine and a small main program calling it — could lead to more useful advice. 
When I run your program I get the same result every time. I ran it about 10 times. @x1yoga(master)|~/tes/fortran$&gt; cat test.in 10 1 8 @x1yoga(master)|~/tes/fortran$&gt; ./a.out &lt;test.in 0.500000000 0.857763886 0.500000000 0.857763886 input panel subdivisions input left endpoint input right endpoint DX = 0.699999988 0.699999988 0.593532979 0.367879450 0.367998064 the value of the integral is 0.234396160 @x1yoga(master)|~/tes/fortran$&gt; 
Also, in the future it you have inconsistent behavior it can be due to uninitialized variables, which you can check with `valgrind`. Your program gives no errors in valgrind: @x1yoga(master)|~/tes/fortran$&gt; valgrind --track-origins=yes --leak-check=yes ./a.out &lt;test.in ==25077== Memcheck, a memory error detector ==25077== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==25077== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info ==25077== Command: ./a.out ==25077== 0.500000000 0.857763886 0.500000000 0.857763886 input panel subdivisions input left endpoint input right endpoint DX = 0.699999988 0.699999988 0.593532979 0.367879450 0.367998064 the value of the integral is 0.234396160 ==25077== ==25077== HEAP SUMMARY: ==25077== in use at exit: 0 bytes in 0 blocks ==25077== total heap usage: 23 allocs, 23 frees, 21,100 bytes allocated ==25077== ==25077== All heap blocks were freed -- no leaks are possible ==25077== ==25077== For counts of detected and suppressed errors, rerun with: -v ==25077== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) 
Idem for me, with gfortran 8.1.1
thanks for running it! I updated the wrong script and was running that one. I FINALLY got it to work (correctly)! I have been working on this forever. 
https://github.com/guynan/project_euler/tree/master/fortran That's my PE in Fortran. Don't know how well it's written but it may help get someone started. 
And on the ninth day he invented somebody who asked you “Fortran? People still use that?” and Adam sighed heavily and explained 
On the 10th day someone said : For all the people who always ask **Why Fortran? It is so old**. Just because one changes the languages doesn't make one's idea better. A crap idea still remains crap. Our physics hasn't changed, our laws guiding haven't changed and Fortran still understands and works with those laws the best, we don't need to change the language.
You would be served better if you made sure nothing is implicit in the subroutine. I see that your problem has been sorted, but keeping implicit none is always good practice, in subroutine. Specially when your program becomes larger and larger. You are highly likely to end up reusing variable names across subroutines it creates a massive riff-raff.
how were the variables declared? as Integer or Real?
Its Integer. 
Thanks 
also, if you have declared m as an integer and do m/100 your answer will be truncated to only the integer part, even if k is declared as real. You need to do m/100. (notice the period at the end) to get the correct answer.
Dude, you need to stop posting Homework problems on this message board. At least show the work you have attempted. Or what seems to be confusing you. You won't get anywhere if you just expect someone to give you the answer. even if you are trying to cheat, use your head and understand what you are doing.
Put H=1E-16 or smaller and just use the formula for a specific X.
I don't think he even realises that he has pasted the problem statement incompletely.
It's pretty funny he's asking such basic questions when he has a [facebook](https://www.facebook.com/pg/ftn90/about/) and [blog](https://fortran90bd.blogspot.com/) dedicated to fortran. 
If you have a large value of V (e.g. 90), your "equation" subroutine returns very large values indeed - larger than HUGE(I12) I suspect. Therefore you never add anything to your integral. More generally, you are mixing integer and real types in quite unusual ways. Why are you testing a real value against a HUGE() integer? 
You're partially limited by disk speed here unfortunately. But are you dumping in binary or as a formatted test file? A double precision real typically takes up 8 bytes in a binary file, but if you expand that into formatted text, it could be three times that or more. So that's the difference between 8 MB of output per array and ~30 MB of output per array. If you want to read in the data later with Python or whatever for plotting, then you could still try to read binary files in Python, but it's probably easier to use something portable but dense like hdf5, which does involve installing and learning to use some new libraries. Also, it won't be any faster, but in Fortran you can just dump an array in one line, e.g. real(kind=8), dimension(1e6) :: a open(unit=17,file="output.dat",form='unformatted') write(17) a close(17) or something like that. 
You can probably compile with something like `--fcheck-overflow` or whatever it is for your compiler, to make sure that it tells you when you get `INF`s popping up.
I've been wanting an excuse to try out [Duff's device](https://en.wikipedia.org/wiki/Duff%27s_device) in fortran for a while so I did it with this. Surpisingly to me it made almost no difference compared to a normal do-loop. Writing sequentially (just typing `write(17) a` instead of looping) makes a huge difference though. In addition it will literally half your file size, as you can see in this [screen shot](https://i.imgur.com/vxMVimi.png) (files ending with '_seq' were written seqentially). The downside to writing sequentially I think though is that you can't specify a record to read, so to get one record you have to read in the whole file. Also surprisingly for some reason `gfortran` was way faster than `ifort` for the looped writing. Not sure if `gfortran` is vectorizing my code and `ifort` isn't, but both were compiled with no options. Source code I used is [here](https://gist.github.com/mtesseracted/08e748e8c6a09465500fe732a5e6347d).
I wonder if modern compiler optimizations might have things line Duff's device under the hood anyway.
It wouldn't surprise me, although I've compiled with `-O0` and it doesn't really affect the runtime. I'm flabbergasted at ifort's speed compared to gfortran though. I just found the [buffered](https://software.intel.com/en-us/node/678837) option for ifort's `open`, which halves the write time in ifort. Since it was ~10x slower than gfortran it's still ~5x slower though. 
a bit of a necro but god bless you for this patience. id have been rather more terse i fear
I guess you could code a search function to scan a dictionary file...
You might be able to run a system call. call execute_command_line(‘cp ./foo/bar_*.txt ./foo/bar.txt’) and then open the bar.txt file.
That idea should work! The files are too large to be continuously copying around, but I should be able to do something like this call execute_command_line(‘ls ./foo/ &gt; file.txt’) Then read the file.txt to get the filename desired
You could also use symlinks
If instead of \`cp\`, you use \`mv\`, it will just rename it.
First, cross-platform stuff is HARD. This is in part why java was invented. If you really want to try and send a compiled program, you have to statically link the libraries. You may just need -static-libgfortran.
You could give them the library too.
You could always roll a container. There must be a Pre-built image for FORTRAN. This would require all other Macs to run Docker, so may be extra work tbh 
Mac does not easily allow statically linked programs to run. That’s why the program can only run when fortran (and its libs) are installed.
You can try compiling then linking separately, you may have to play with the version numbers in the link command. gfortran -c -o my_program.o my_program.f ld -o ./my_program -no_compact_unwind \ -arch x86_64 -macosx_version_min 10.12.0 \ -lSystem \ /usr/local/gfortran/lib/libgfortran.a \ /usr/local/gfortran/lib/libquadmath.a \ /usr/local/gfortran/lib/gcc/x86_64-apple-darwin16/6.3.0/libgcc.a \ my_program.o
Generally one uses Fortran for number crunching since that is where it really shines. I guess things such as simulation codes are typical of what you might use Fortran for. So maybe a project along those lines?
Generally you want to do math. I'd start with a simple numerical project, like numerical integration in 1D. Manually of course, not with a library. Extend by reading an input file and command line, print the data and plot, e.g., with gnuplot. If you are into physics, a molecular dynamics simulation with a Lennard-Jones potentials will let you simulate the movement of hard-spheres. Let two spheres collide and watch it as a 'movie' in an external program. Linear Algebra with matrices, e.g. matrix multiplication manually vs. BLAS (dgemm). Try to make it fast. The memory layout is different to C/C++, play with the order of the loops to see the impact. check the wiki in the sidebar: http://fortranwiki.org/fortran/show/HomePage 
A nitpick... L-J particles are technically, not hard-spheres. You could, of course modify the potential to rise very sharply, and so make it an almost-hard-sphere.
Fortran is really only good at one thing, so I don't think it's particularly useful to have in your repertoire unless you're genuinely hoping to do numerical work at some stage. If someone is just interested in extending themselves and improving their programming skills and employability, you'd do better to go with C or something else that's more general-purpose.
I made a tic-tac-toe game where the user plays the computer.
Jokerle's reply is good. Given the extra information that you are probably in high school, you may consider simple mechanics/dynamics problems: integrate the trajectory of a two-body (sun - earth) or three-body system, simulate a Poisson process for nuclear desintegration, compute pi via the Monte-Carlo method, find the roots of second-order polynomials, etc.
&gt; Additionally, I'm starting to apply to work experiences in the aforementioned fields, and it seems to me that Fortran experience would show interest in the field and set me apart. So... it won't. You're *significantly* better off investing any time you'd spend on Fortran instead on a modern scientific programming language, like Python(/numpy[/numba/cython]) or Julia. Until you get to writing very large codes for high-performance computing, Fortran is a painfully simple language. As long as you gain familiarity with scientific programming in general, you won't have any problem translating what you know into simple Fortran programs. And even better, you probably won't have too much trouble hacking existing Fortran codes (which is the bulk of the work that those of us who still use Fortran actually do - modifying and massaging existing codes to bend them to our will, usually by emulating existing code style in the program itself).
Since you're 16, I'm guessing you're required to take some science class, perhaps you can find a problem that needs coding up in your textbook? Like someone below said, unless you go into some very specific fields, you're not likely to encounter Fortran, but if you still want to learn it, then that's great. Most 16 year old programmers assume Fortran is a dead language, so maybe you have an affinity towards scientific and high performance computing and just don't know it yet. Here's a simple problem that I've used in some teaching situations, maybe it'll help you. Let's say you have a sheet of metal, represented by an 2D array of reals. 1.0 is "hot" and "0.0" is cold. The sheet of metal starts out cold but remains heated along one side. You can figure out the temperature of a point along the sheet (an element in the array) by solving the laplace equation, which basically means you take the mean temperature of the points above, below, to the left, and to the right of you and that will be your new temperature. You can simulate how the heat from the hot edge spreads through the metal by simply looping over the same process. So, can you write a program that simulates this process over some number of time steps? How many iterations does it take to reach steady state, where the temperature stops changing? DM me if you need any hints. The reason I like a problem like this rather than just pi is because one of the big advantages of Fortran is that it has "true" arrays and the language has simply ways to deal with the arrays and puts rules on the arrays such that a compiler can generate very fast code. Plus, the problem is parallelizable, so if you find yourself wanting to stretch your abilities a bit more, you can write a parallel version. Once you've solved it, you can try it in something like numpy, julia, or even matlab, which you're likely to encounter if you do go into one of these fields you're considering.
Look for another option. I wouldn't do this unless you know the target environment will be the same everywhere. You're seeing yourself up for a whole heap of unpredictable trouble.
The hip kids call them containers now.
Fortran is usually used where people want to do heavy number crunching. But at the base of it, usually these are discretization problems. Where you are looking for a numerical solution to a problem which has a difficult or non-existent analytical solution. Like how would the temperature and pressure of a moving fluid change in three dimensions with time. That is essentially a four dimensional problem. So if you divide your fluid space in 100 elements. Since you are trying to find out how the temperature/pressure develops in time, each second would have to be further discretized into time-steps of maybe 0.1 second or even lower if you has a fast moving system. All that adds up to a lot of calculations. Fortran is ideally suited for handling such large number of computations. But again what you can do that right now is dependent on what kind of physics/mathematics you know right now. For now, try to pick up any math problem you have in your high school and see if you can solve it with fortran. maybe simultaneous equations with 3 variables. Once you start Calculus, you would also be taught numerical methods to do calculus, then you would be able to realise the full power of fortran.
You can't run Fortran source file. It has to be compiled (e.g. by gfortran). The resulting program (if file contains `PROGRAM` statement at the beginning) can be run. If there is no `PROGRAM` statement, you just have a file with functions and subroutines - kind of a library (although, it is usual for Fortran77 file to contain just a single function/subroutine). In this case you need to write actual program that uses them. It is, however, unusual to have `.src` extension on Fortran source files. For Fortran77 one would expect `.f`, `*.for` or `*.f77`. It could be, depending on the contents of the file, that this file was meant to be included into another source file. BTW, the content of the file looks pretty much how you would expect Fortran77 to look like. `FORMAT` statement has a bit of weird gaps, but nothing illegal.
Thank you for your answer. This one file is all I have. I tried compiling it, but it throws a lot of errors. (many of them about missing parenthesis) What do you mean with "was meant to be included into another source file"?
Sometimes for the purpose of keeping code tidy and separate, a given file could be 'inserted' at some point at the middle, beginning or end of another file, before compiling the code, in order to make a full valid FORTRAN unit. &amp;#x200B; Having said that, I'd say it's not \*that\* uncommon to use the .src extension for fortran files, though it's a bit old fashioned (but what isn't in FORTRAN?) &amp;#x200B; If you could screenshot the top of the file it might give more of a clue what the issue is.
Here is a screenshot of the top: https://imgur.com/a/SM8GT2n OK. I see. So this would mean, that the code I have is not complete and I won't be able to run it, right?
In this case you have a complete program (first line starts with PROGRAM), so it's not the case that this was designed to be inserted into another file. &amp;#x200B; As to why you can't compile this code - difficult to say, but I'd start by changing the file extension to .f77 or .f to see if that helps. &amp;#x200B; This type of program statement with references to "INPUT" "OUTPUT" "TAPE6" etc etc isn't something I've encountered before, but this textbook ([https://hanson.geog.udel.edu/Research\_files/fortran.pdf](https://hanson.geog.udel.edu/Research_files/fortran.pdf)) suggests that this may be specific to certain compilers. You could try deleting those additional statements, leaving just PROGRAM CHAR3D...
This is clearly very old code. It might be using some ancient compiler specific syntax. I don’t have so much experience with old fortran, but I have encountered some ancient C code which would not compile on any modern compiler because pretty much the whole thing was an ugly compiler specific preprocessor hack. So I guess, good luck!
Also I'd double-check that they're not using a compiler that is misreading it as f90+
If you want to be notified of all warnings, use the `-Wall` and `-Wextra` flags.
-Wconversion-extra is what you want. As /u/chloeia said you can use -Wall, which will turn on -Wconversion, but -Wconversion will not complain about a conversion that has no loss of precision, such as your 64.0_num. From the man page: -Wconversion Warn about implicit conversions that are likely to change the value of the expression after conversion. Implied by -Wall. -Wconversion-extra Warn about implicit conversions between different types and kinds. This option does not imply -Wconversion. 
This was exactly what I wanted, thank you. The debug option in my makefile now just about has every flag in it!!!
I just tried your example in 8.1.1, and it does indeed give a warning: ``` mult.f90:5:9: y = x(1,3,5)*2 1 Error: Rank mismatch in array reference at (1) (3/4) ``` I used 8.1.1 for this, but even going back to 4.4.7 still raises this error.
The old g77 compiler (from gcc 3.4.6) tended to play fast and loose with the rules, like the legacy compilers. gfortran is much better about following standards unless your flags request otherwise.
Chapman's Fortran for scientists and engineers was what I used.
This is a great place to start learning Modern Fortran. Then get Metcalf's book which includes a much more in-depth discussion on Fortran 2003-2008 features. I believe the fifth edition, which ought to come out in November, will cover the minor Fortran 2015 revision as well.
Thanks! I'll check it out 
I use an older version of [Modern Fortran explained](https://books.google.com/books?id=sB1rDwAAQBAJ&amp;dq=Modern+Fortran+Explained) by Metcalf, Cohen &amp; Reid.
I use an older version of [Modern Fortran explained](https://books.google.com/books?id=sB1rDwAAQBAJ&amp;dq=Modern+Fortran+Explained) by Metcalf, Cohen &amp; Reid.
I use an older version of [Modern Fortran explained](https://books.google.com/books?id=sB1rDwAAQBAJ&amp;dq=Modern+Fortran+Explained) by Metcalf, Cohen &amp; Reid.
You would declare them in a module and use that module in the subroutine that function is called in.
Nothing is global. Vars from your program/end program block are not visible in subroutines and functions from modules. In general, what you want is to put all vars that need to be visible more broadly in modules and then use that module wherever appropriate.
I use [Modern Fortran explained](https://books.google.com/books?id=sB1rDwAAQBAJ)
Passing the array into a function does not lead to a copy of the memory. Arrays are passed by reference. Also, if you only want to read from it, as long as you define that array in the function with an INTENT(IN), it will also be safe from accidental alterations. What /u/catpiss said is another way to achieve what you want.
It is good to listen to our Fortran-father: [https://software.intel.com/en-us/blogs/2013/12/30/doctor-fortran-in-its-a-modern-fortran-world](https://software.intel.com/en-us/blogs/2013/12/30/doctor-fortran-in-its-a-modern-fortran-world) IMHO the best books to start with, if you are not a newbie. As a reference book first check Modern Fortran Explained, to learn something check others.
I second this is the book to have as reference but be advised the latest edition comes next month and incorporates Fortran 2018 (former F2015). 
It’s works if you comment out 15 lines from the top OR a different 15 lines from the bottom? Can you post the code?
What I meant to say is that no matter which lines I comment out, the code works. here's the link: https://pastebin.com/Fkam7LU3 line 45 is where I had to start the other kernel. thanks for the answer.
[removed]
I want one that says 18HKEEP FORTRAN WEIRD
Get a custom one?
Here is one of the most widely known recourses that I know of: morse.uml.edu/Activities.d/16.520/PS8.D/CUDA_FORTRAN_FOR_ENG.pdf I think the above is an informal copy of the book named: "Cuda Fortran for Scientists and Engineers": https://books.google.com/books/about/CUDA_Fortran_for_Scientists_and_Engineer.html?id=yQwwAAAAQBAJ&amp;printsec=frontcover&amp;source=kp_read_button#v=onepage&amp;q&amp;f=false If you are in Academia, you may be able to get a free pdf copy of it through the library.
You're a star mate, cheers.
I think I fixed it, did it work?
It's better, but there's still some readability issues. The biggest thing is that you really need to indent your code. But for commands the convention is to use either all-caps (`WRITE`) or all lower-case (`write`) - it's jarring to see sentence case (`Write`). And one last thing: this is a very Fortran way of thinking, but seeing `r` as an integer variable is a bit confusing. In old-school Fortran, `r` is always a `real`, but even in modern Fortran people will sometimes use `r` to represent a physical coordinate (which should be `real`), or use `r` as a prefix for `real` variables. So someone reading your code might assume it's a `real` if they aren't paying close enough attention.
This looks really nice. I wish I had thought of something like this as a project. I might implement one my self.
The reason why there are isn't a market for Fortran stickers is quite simple. No style quotient in using Fortran. Stickers are fundamentally a tool of vanity. A bit of show-off. A bit of tribal behaviour. My god is better than your god behaviour. Fortran is what it is, a tool, a very efficient one. Without frills. She does what is asked of it. It does it faithfully, it does it correctly and is easy to handle. She doesn't complain much. She doesn't have a lot of demands. She is not vain. She doesn't claim to be the answer to world peace, childhood hunger, malaria and Ebola. (Although I am sure she helps people working on the last two create better solutions). She helped us put the man on the moon. She helped us put satellites up there, letting us share cat pictures from PoDunk Minnesota all the way to Nauru in the South Pacific. She has done all this all the while asking for very little, demanding almost nothing and being transparent. Without being a braggart. She neither has the time nor the inclination for vanity. The people who work with her are similar. While from time to time we feel a pang looking at the shiny new sticker on someone's backpack bragging about numpy, we know the truth. We know what she's and what she's capable of. She's the invisible engine that keeps the scientific world humming. Asking very little. She's not one for vanity.
* You could have said the last three, because Fortran is still the main language of academic macroeconomists, including those who work on poverty. * But ultimately, I'm vain, and I want a vain sticker! For others, so far this is the best one I've found, but it's still pretty ugly: [sticker 1](https://www.redbubble.com/people/jupiterspot/works/33549542-fortran?cat_context=u-stationery&amp;grid_pos=11&amp;p=sticker&amp;rbs=66f628a8-cff8-44f6-b711-5fc7de05824b&amp;ref=shop_grid&amp;searchTerm=fortran&amp;iaCode=u-sticker ) and [sticker 2](https://www.redbubble.com/people/jupiterspot/works/33549542-fortran?cat_context=u-stationery&amp;grid_pos=11&amp;p=sticker&amp;rbs=66f628a8-cff8-44f6-b711-5fc7de05824b&amp;ref=shop_grid&amp;searchTerm=fortran&amp;iaCode=u-sticker)
You are correct.. Actually I missed one more point there... Geneticists and Biologists working sturdier crops also use fortran... I think you can have stickers custom made. Or get a colour printer and a sticker paper. Print your own. The commercially available ones won't have the wittiness of someone who understands the language. 
That fixed my problem! Thanks so much
Although it looks like you've got your problem sorted, and that you're probably just doing this to get your head around the language, keep in mind that Fortran really is not great with strings. If you're looking to start a project that works heavily with strings, then usually Python is a better bet (or C++ if you need something lower level).
If you want to write CUDA you have to know C. CUDA Fortran is just a wrapper for fortran to send variables to CUDA. The actual CUDA kernels are written in C.
You could run it in a debugger and maybe get more information. Are you sure it is coming from that line?
You more than likely have an array address problem somewhere else in the code.
It will be hard to tell without looking at your code. The error could mean any one of a huge variety of things.
GNU compiler can be a bit funky with file paths. Try using the complete path. file = C:\\.... (even if it is in the same directory) I have come across this problem, somehow using the full path fixes the file open issue.
I could not reproduce the issue using a Debian patched version of gfortran 6.3.0. In the future, don't use pictures, but instead include text so it is easier to copy and paste. I suggest using the `-g -fcheck-all -Wall -Wextra` compilation flags to see if that gives you any additional messages. Failing that, you'll have to run the program in a debugger like `gdb`. Note that you have floating point data in your data file being read into variables of type integer...that will certainly cause you problems later on once you get this issue fixed.
Struggled with the same Issue yesterday. The problem was a critical error in Gfortran 5.1. Patched it to a newer version and the error disappeared. 
I tried running the code at uni a few days ago and it ran with no errors. So yes, it must be an issue with the compiler/software. Thanks for your reply.
Alternatively, work in units where h=1.
To expand on that a bit... Representation of numbers can go from E300 to E-300 aprox with intrinsic types. You can have a variable with the number 1E-34. The precision of E-30 means that if you add 1E-34 to 1E-64, the result will be 1E-34. Idem 1E50+1E20. In other words, you have to be careful when doing arithmetics with numbers that differ in around 30 orders or more (and when doing a lot of complex math, because of error propagation you will be losing precision with your results much sooner than the 30th order of difference).
I'm still not able to run it properly from the VS Code terminal itself but if I execute it separately it works fine. Thanks for the help! 
In Fortran95 and later, there is the any intrinsic. So it suffices to have one loop over the large array and then check inside. Something like this: logical :: share = .false. do i = 1, size(A) if (any (A(i) == B)) then share = .true. exit end if end do &amp;#x200B;
If you are doing computational physics of any kind, it is best to use a natural scale for your variable. Things like the energy values of the Hamiltonian for the simple harmonic oscillator in units $\hbar \omega$.
I doubt it. Python is interpreted where FORTRAN is compiled. You could write a wrapper or interface to call the FORTRAN routine from Python or Perl, I suppose. But I don't think that is what you are looking for. 
As mentioned by the other poster, Python is interpreted while Fortran is compiled, kinda apples and oranges here. That said... I vaguely remember a colleague of mine using an interpreter for Fortran. I have no idea what software it was or where it came from. Nor why you'd want to use it. Possibly you could use MATLAB (or Octave for free alternative) to rapidly prototype code, since the formalism is very similar to Fortran, except it is optimised for being used with an interpreter (so dynamic implicit typing etc).
There's an old saying: "A sufficiently talented Fortran programmer has the ability write Fortran in *any* language" The point is that languages differ by more than just syntax - the entire philosophy of how you design and write programs can be completely different. A Fortran programmer can write Python in a very Fortran-style, but it would be a very bad idea to do so. I think you're kinda trying to do that here - to write Python using Fortran - but they're too different for that to work. In Fortran you really want to write a program, then compile and run it. If you want something interactive, then that's kind of what Python is for. If you're looking at interactivity as a way to debug and test something, you could look into debuggers such as `gdb` which can help break things down, although it's very different to how you'd do this in something like `iPython`. Intel Visual Fortran might have its own debugging features too, although I haven't used it myself - Fortran programmers have a tendency to shun IDEs in general.
There isn't really an official Fortran REPL, but there are some pseudo-REPLs, such as this: https://www.tutorialspoint.com/compile_fortran_online.php
Well, what is the difference between that and typing a full program with a couple more extra lines, compiling it and running it? I imagine the latter part is simplified if you're using an IDE like Visual Studio.
There might be an Atom package for that. I would be very interested if you found something
I think there's software that reads debugging output from gcc that you can look for on Google.
MS VS include code mapping at least since 2013 version: https://www.youtube.com/watch?v=KpNkDIrB-5w If you cannot find it, maybe it's not installed: https://developercommunity.visualstudio.com/content/problem/29579/unable-to-find-codemap-commands-in-visual-studio-2.html There is also a nice external tool: https://scitools.com/
[FORD](https://github.com/Fortran-FOSS-Programmers/ford) can do it, but you'd have to write documentation first.
Conda supports [fortran-magic](https://anaconda.org/conda-forge/fortran-magic), which is close to what you're envisioning. If you can fit all your code in one file you can use [jdoodle's](https://www.jdoodle.com/execute-fortran-online) all in one page compiler. 
Yeah, use GDB with breakpoints.
If your subroutine is in a separate file, then you would only need to recompile the changed file and re-link to the object files of the unmodified routines.
Submobule can be the thing, but you will need a compiler up-to-date... or you can also write the interface of the subroutine/function and write it in another file, outside of a module 
Yes, OP look into makefiles.
It may not be the most optimal solution, but I prefer to have a test program inside my projects that will test each subroutine (and function) individually. For each routine I create a number of test examples and the program prints out the results for each test (eventually, also a comparison with reference data). It is a lot of work (in particular for big projects), but it does pay out as I can quickly identify if some change in the code lead to a new bug (and routine that bug is in).
This sounds specific to Visual Studio. With make (Makefile-s) you only compile and link what changed.
[Here you go.](https://www.youtube.com/watch?v=dQw4w9WgXcQ)
Bad bot! 
You can also use cmake to generate the makefiles, which works pretty good with Fortran, too.
I use fortran on a day to day basis, but on linux. So I do not know how to work with MinGW. However this [tutorial](https://www.youtube.com/watch?v=PSq-YyfdYb4) might help. I saw it and the next step is to add MinGW environment variables. After that you can compile and execute your code in cmd.exe. 
OpenSUSE user here, so take everything I say with a pinch of salt. My understanding is that lapack is a library, so it wouldn't be found in /usr/bin, nor by `which`, those are both for executables. It looks like when you compiled try, it found the library you copied in, but that library then requested another, which of course you hadn't copied. (just going by the different names). Possibly, if lapack is getting installed to some non standard folder, you need to add that location to your LD_LIBRARY_PATH so ld can find it when you compile. Either way, you need to find out where the lapack files have been installed to - does fedora provide a way to look at which files have have been changed between updates? (if you're using btrfs that would be one way to do it to with the diff command) 
As @susurrian wrote, lapack is a library, so the file on your computer is (most likely) /usr/lib/liblapack.so. The `which` command won't help since `which` only looks for executables. It sounds like you managed to install gfortran and lapack, which is a good start. I strongly recommend against using "lapack95.a"; the best way to proceed is with the copy available from the vendor (fedora). Here is the test program I used: PROGRAM MAIN IMPLICIT NONE REAL*4 EPSILON REAL*4 SLAMCH EPSILON = SLAMCH('E') WRITE (*,*) "EPSILON IS ", EPSILON END PROGRAM All I needed to do was run gfortran -llapack test.f ; ./a.out to compile, link, and run this program. It would be easiest to help if you tried that command to compile, link and run the test program (which is the simplest lapack program I can think of). Does that work? Can you post the error messages here?
The simple answer that has not already been addressed is that you copied lapack95.a to /use/local/bin, but the linker was looking for liblapack95.a. When you add the option -llapack95 on the gfortran line, the leading “lib” and trailing “.a” is expected. Your gfortran error message is telling you it can’t find liblapack95.a Also, from the rest of your description, you also have the full LAPACK95 library installed plus the library you installed in /usr/local/lib. Run “find / -name *lapack*.a -print” to find where all of the LAPACK libraries are stored.
First, remove the file that you have manually copied. Its presence can only lead to errors, hard-to-diagnose bugs, or incompatibilities. Then, you can try to find what was actually installed with the following commands: find /usr -iname '*lapack*.a*' find /usr -iname '*lapack*.so*' This will give you the location of the library *and* its "type". A file in .a is a static archive and you need to list its full pathname with the files to compile at link time . A file in .so is a shared library that you need to add with -llapack (and possibly the corresponding -L/path/to/lib) Keep in mind that lapack95 will probably require you to also list the plain "lapack" and "blas" libraries on which it builds. Example of the static version gfortran -o myprogram myprogram.f90 /usr/lib/liblapack.a &amp;#x200B;
Hello, I ran the find command and had the following output find: ‘/run/user/1000/gvfs’: Permission denied ( I ran under su user) &amp;#x200B; I don't think I have \*.a version installed (after removing it from the usr/local/lib which I had copied manually) &amp;#x200B; Thanks
Hi, I tried the following &amp;#x200B; gfortran -o try try.f90 -L/usr/lib64/ -llapack and it seems to work. &amp;#x200B; May you explain what's going on? &amp;#x200B; Thanks
&amp;#x200B; Hello, yes this worked giving out value of epsilon. But now if I try to do the same with my program I get the following error. &amp;#x200B; /tmp/ccJwVWP6.o: In function \`MAIN\_\_': try.f90:(.text+0xdb): undefined reference to \`sgesv\_f95\_' collect2: error: ld returned 1 exit status bash: ./a.out: No such file or directory &amp;#x200B; I used the name sgesv\_f95 because when I checked in the .f90 file wherein the name of the subroutine was sgesv\_f95 &amp;#x200B; However, when I just used call sgesv it worked and I had the output. Thanks for your help and suggestion. So, here I have 2 questions &amp;#x200B; 1. How do I know what name to be called for exactly? 2. May you explain what exactly happened? I mean if you see my reply to @complex\_pi below, I could find \*.so versions of lapack installed on my system. But here I just called -llapack. May you explain what exactly is happening? Is \*.so.3.8 being used or simply \*.so ( former one being for f77 while recent f95) or it is automatically decided by compiler. Sorry if my questions are too naive. Thanks
I had tried to put a leading asterisk in the file name but it was consumed as formatting. Try this command: find / -name “*lapack*”.a -print
Its not a problem; I am happy to help! 1. I would refer to the LAPACK documentation for function names. If all else fails, read the source: https://github.com/Reference-LAPACK/lapack I don't think I have ever seen names with `_f95` suffixes; that does not seem right (and that is not how the standard reference copy of LAPACK is written). The extra `_` at the end is a gfortran implementation detail: many fortran compilers add trailing underscores to fortran subroutines and functions to distinguish them from C functions. Put another way: `sgesv` or `SGESV` (or `sGeSv` if you like the spongebob memes; FORTRAN ignores case) should be fine. 2. Calling gfortran does more than call a compiler: it also calls the linker for you automatically at the end. Hence passing `-llapack` to gfortran tells the linker 'link against liblapack at the end'. I would bet that `liblapack.so.3.8` is actually the same file as `liblapack.so`; the former is, usually, a symbolic link to the later. The linker ignores the `lib` in the front (this is a weird hangover from the 1970s that doesn't make a lot of sense, but we are stuck with it on UNIX forever now) and the suffix (also for weird reasons). The `.3.8` signifies a version of LAPACK. FORTRAN 95 is backwards compatible with 77: it should not matter what version you are writing and LAPACK works perfectly well with both.
It is possible that you have a FORTRAN 77 only lapack. In which case you need to install manually Fortran 95 wrappers, with which I am not familiar.
Hello, So you mean when I do dnf install lapack it installs only LAPACK by default and not LAPACK95 or the recent version. When I searched for appropriate library, I found .so.3.8 which is actually LAPACK95. &amp;#x200B; But in case, I need to install it manually, ( I will search on internet) then as per your suggestion, when linking the library, I should do something like -L/path to library/ -llapack -llapack95 Right?
You still miss lapack95 [http://netlib.org/lapack95/lug95//node12.html](http://netlib.org/lapack95/lug95//node12.html)
Hi, I haven't used dnf since I'm on Linux Mint, but when I do apt install Lapack I get the base version of Lapack which is written in Fortran 77. If you want to use Lapack95 (a wrapper to Fortran 95, nothing is changed except the language), you must compile it on your own PC, that's the downside of using it. The clusters that I run my code on didn't have Lapack95 so I stopped using it. Normal Lapack isn't that much more cumbersome anyway imo. The important part is that the Lapack and Lapack95 routines do the same thing, there is no newer version as far as I am aware of. &amp;#x200B; I think you are right about linking the library, but I put -llapack95 in front of -llapack, I think it matters. You can try both.
This is not correct; those refer to different releases of LAPACK. All versions of LAPACK are compatible with both Fortran 77, 90, 95, etc; the interfaces do not depend on any new features of Fortran whatsoever. A symbolic link is, essentially, a pointer; there is only one shared object library for lapack but it has some aliases. All of these are the same file. Finally: you should not need to provide the location of the library with `-L` when it is installed in a 'standard' location (such as `/usr/lib` or `/usr/lib64/`), but providing it won't hurt. You should link with `-llapack`, yes.
**1st step**: You can avoid both Msys and MinGw(wich is x32bit), go directly to 64 version and download from here: [https://sourceforge.net/projects/mingw-w64/](https://sourceforge.net/projects/mingw-w64/) **2nd step:** install options-&gt; Version(last), Architecture(x86\_64), threads(posix),exception(seh) **3rd step:** add to environment variables: system path (inlcude up to the "bin" ) e.g. C:\\Program Files\\...\\mingw64\\bin **----Finished!!!----** **to test:** open the command prompt and type `gfortran --version` (it should print the gnu version, if not you did something wrong) **1st Note** there is no GUI, to compile and run a program, only with commands from cmd!! **to run**: open cmd, then `cd "../directory of code"`, then `gfortran -o name code.f90`, (name is the name of executable that the compiler will produce: *name.exe* , or you can ommit it and simply write `gfortran code.f90`, this way will produce *a.exe*). for flags check this: [https://gcc.gnu.org/onlinedocs/gfortran/Option-Summary.html](https://gcc.gnu.org/onlinedocs/gfortran/Option-Summary.html) **2nd Note:** you can avoid `cd "../dictory of code"`, open the file explorer go to the folder were the code is located click on the upper left corner of the file explorer the tab "file" and choose open "Windows power shell" compile and run your code from there.
I think it's called "gprof2dot". [https://github.com/jrfonseca/gprof2dot](https://github.com/jrfonseca/gprof2dot)
On the other hand, if you intend to be writing or building projects with lots of common dependencies AND also value cross-platform support between Windows/Linux/OSX, using MSYS2 might well be a good idea for the long-term. The fact that there's a package manager is alone one of the biggest incentives.
[StackOverflow](https://stackoverflow.com/questions/17323628/read-data-from-a-csv-file-in-fortran) is your salvation.
I'm getting an error with that code &amp;#x200B;
That's why you don't just copy and paste code without trying to understand it.
this is my code and it doesn't work: `program od` &amp;#x200B; `implicit none` `integer :: res,i, line_no` `real, dimension(9,4) :: data_array` `open(10, file="Book2f.csv",access='sequential',form="formatted",iostat=res)` &amp;#x200B; `do i = 1,9` `read(10,*) line_no, data_array(i,:)` `end do` &amp;#x200B; `end program od`
That doesn’t sound like an error message. Are you developing and running your code within an IDE? If so, do you have a program breakpoint established that the IDE is hitting and is waiting for you to tell it to continue or single step through the code. What development environment and compiler are you using?
I'm using Intel Paralel Studio's Visual Studio integration. The compiler is Intel Visual Fortran
So, do you have a breakpoint defined on a line of your code within the IDE?
how can I check it?
I think I've figured out what the problem is. I think it simply don't see the file I want to read. How do I change the directory?
UPD: I have figured out my problem. It was creating a new file with the name "Book2f.csv" not reading it, because the file was in a different directory. I copied the file into the same directory and put additional keywords: `open(10, file="Book2f.csv",access='sequential', status='old',action='read', form="formatted",iostat=res)` However, how do I put the exact pathway to the file in Fortran?
You can specify the path in the file name 
Normally with fortran programs you would execute in the direction in which files reside so if the compiled fortran program is `~/myfortranprogram/a.exe`, you would do: cd /path/to/folderofBook2f.csv/ ~/myfortranprogram/a.exe Rather than specifying an absolute path relative to the directory of `a.exe`. In my experience anyway. 
The StackOverflow answer isn't correct - it works on *space* separated input, not *comma* separated. Fortran predates CSV becoming common and isn't very good at it. You would have to load in each line as a string and then separated by commas. If you really need to use Fortran for this, it would probably be easiest to use like two lines of Python to convert the data file into space-separated instead of comma-separated. Of course, if you're using Python for that, there's a good chance you can solve your problem in Python anyway. If you're really daring and you're sure there's no commas elsewhere, you could use the `sed` command line utility to search-and-replace all the commas with spaces to convert it into a Fortran readable format, but that's kind of dangerous.
Those flags are non critical. -O3 is the optimization level, change that for -O2 which is the fastest that gfortran supports. -diag-disable 8291 disables output for the 8291 warning, which is related to numerical precision, you can omit it, though gfortran will likely show you a related warning.
This, and pray that the code is not full of ifort languange extensions....
Do you know how to generate random numbers? Generate 3 random numbers. X and Y range from 0-radius, z ranges 0-height. If x**2+y**2 &lt;= radius**2, keep the point. 
Oh if this should be for an arbitrary orientation of the cylinder it’s harder. Try using math 
This smells distinctly of homework... Show us what you have so far, or at least the method you think you should use and I am sure someone could push you in the right direction. /u/asarcosghost has given you a great start, with what would be called, in general terms, an accept(ance)/reject algorithm. Doing a bit of digging around that term should get you there method wise. Have a stab with some code and drop a reply if you get stuck.
Find a vector from one center to the next. &amp;#x200B; Find The Zenith angle of that vector. &amp;#x200B; Find the rotation so that in the new coordinate system the unit vector is purely in the z-direction. &amp;#x200B; Find the translate so that in the new coordinate system the lower center is on the origin. &amp;#x200B; These transforms can be done in either order but undo them the opposite way. &amp;#x200B; Generate 3 random numbers scaled by h, r, and 2pi. &amp;#x200B; These are your polar coordinates in your transformed coordinate system. &amp;#x200B; Transform to Cartesian. &amp;#x200B; Transform to original coordinate system. &amp;#x200B; &amp;#x200B; &amp;#x200B;
Check out this link for what all options are allowed, and what they mean: https://gcc.gnu.org/onlinedocs/gfortran/Invoking-GNU-Fortran.html
I use Modern Fortran Explained (Metcalf, Reid, Cohen)
What do you mean gfortran does not support -O3? I use it all the time without any warnings.
That was my understanding. Glad to know -O3 works, though in my tests with ifort and pgf90 I've not seen a significant speedup from going from -O2 to -O3. How's -O3 working for you?
That's the approach I've been trying to go with, but I would have 3 unknowns but I think I'd be able to solve it in a form a matrix, right? But I still feel like it'd be time-consuming way, like the code would take long time to run I guess
&gt; This smells distinctly of homework... If it isn't already, it's about to become a problem for one of my classes!
If you can, avoid Fortran. Really. I'd suggest you try Python with Numpy instead of R. If you use numpy correctly, you should have reasonable speed, at least for research. If you need something for production use with really large data, hire a software engineer. If you really need Fortran, stick with a recent gfortran version and use at least Fortran 90. Either way, pair up with a software engineer if you can. It will make your life a lot easier.
Hello. Fortran is for heavy computing (like structural computing, fluid flow, ...) It would be great to explain what are you plan to deeply intensively compute in Fortran so that it requires to use an intermediate interface (slower) to another tool for just plotting data. Is your target Fortran pgm not able to export data in standard output format (CSV, ..) so that you can use classical software (even R) to plot results? Do you plan to pilot the Fortran pgm from R?
He's a newbie, and Fortran is just one tool, he's not even sure if Fortran is the right tool.
&gt; What's up with all the Fortran versions/compilers? The plethora of compilers exist likely because Fortran was created before the internet and collaborative development. Also because certain compilers are written by hardware manufacturers for truly optimized speed. There are two major versions of Fortran: Fortran 77 and Modern Fortran (Fortran 90, 95, 2000, 2002, 2008 and so on) which is named after certain standards or features are agreed upon for the language. R has version numbers and certain code or packages require R version x or greater to run. Same with Fortran - but when you can have multiple implementations of the language, these numbers indicate the version of the language rather than the distribution. On your Mac, I recommend gfortran (and code in Modern Fortran). On an HPC, I would go with the compiler that is optimized for the supercomputer. Fortran is excellent for speed and it is one of my favorite languages (Modern Fortran). For math, especially involving arrays, it is much easier to code and read than for instance C. However, for R you might want to look into C++ and the [Rcpp](http://adv-r.had.co.nz/Rcpp.html) package. 
&gt; Even terrible programmers can write reasonably fast code in Fortran. You still need to have a basic grasp of data structures and algorithms to avoid writing the terribly naive code.
&gt;You don't need a software engineer for Fortran - that's it's strength over C. Even terrible programmers can write reasonably fast code in Fortran. That's a huge fallacy. Fortran has lot's of quirks and doesn't avoid external stuff like compiling, linking, dealing with libraries, etc. The only thing Fortran does easier than C is array/matrix calculation. On the other hand, Fortran I/O is a mess. If you need to interoperate with other things (like R, Python, etc) you still need a C compatible interface anyway. The list goes on.
 f2py?
That actually makes a C compatible interface. And is brittle as hell. C is the *lingua franca* in the *nix world. You either provide a C compatible interface or you're alone. That's why since the beginning of time you can call Fortran subroutines from C just appending an underscore to the function name.
At least as long as you don't need to pass multidimensional arrays. The two languages does that quite differently.
Even single dimension arrays may be a problem if you use modern Fortran features like assumed size/shape arrays.
Another option is to try Julia, it's a newer language where one of the goals is to replace Fortran. I don't know how it interfaces with R but you might not even needing R.
It is best to use the [SYSTEM\_CLOCK](https://gcc.gnu.org/onlinedocs/gfortran/SYSTEM_005fCLOCK.html)It tells you the the time it take in terms of the CPU cycles that it uses. You can also use the [CPU\_TIME](https://gcc.gnu.org/onlinedocs/gfortran/CPU_005fTIME.html) subroutine for the actual/real time taken.
He probably just wants to learn Fortran. Gatekeeping isn't helpful and is not constructive.
OP is just starting out and is unfamiliar with the language. Even if he has a well-grounded understanding of those concepts, he's *still* going to write bad code at first. Which is how everyone starts out.
Make attempion if you use parallelism with Open MP. In this case use 'omp_get_wtime' to measure the complessive time. 
Which is probably why he's asking for advice. Kinda hard to learn a language when you get gatekeeped on simple questions :)
No, he wants his calculation to go faster. Fortran is just one way to achieve that. There are others.
This is always my go-to timer, even when I'm not using openmp for anything else. It's simple, reliable, and basically every compiler supports it.
Hey, my go to timer in fortran is the omp implementation, the others are badly designed, to the point of being useless, imho. Check out this library https://github.com/RBCanelas/ForTiming It is tiny and you can easily adapt it. Comes with a test, example and has a cmake solution builder, so it is cross platform ready, as long as you use ifort or gfortran.
&gt; Kinda hard to learn a language when you get gatekeeped on simple questions The only gate keeping going on here is the above hand waving promoting the Fortran speed mythos instead of drawing attention to the fact that OP could just have chosen a bad algorithm and thus regardless of if he implements that algorithm in R or Fortran, performance will suffer.
You can see here that -O3 only adds a few optimizations over -O2: https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html Usually -O3 doesn't add much in the way of gains over -O2, a benchmark done by phoronix a few years ago supports that rule of thumb: https://www.phoronix.com/scan.php?page=article&amp;item=gcc_47_optimizations&amp;num=1 On the other hand - why not use -O3 unless it is actively causing you problems (typically that is an indication of bad code!)
If the code is strict Fortran, then recompiling should suffice. However, many Fortran codes make non-portable assumptions and won’t just recompile and run. I haven’t used Windows since 2006 but you might have trouble finding a Fortran compiler. Intel Fortran supports Windows but I don’t know the details (required disclaimer: I work for Intel). You could try to install a very old Windows OS in a virtual machine. You definitely should not connect this virtual machine to the internet though, as it will likely be overtaken by viruses and malware within minutes due to obsolete security.
1. It's the compiler *target* architecture that determines that. If you compile on your target machine the architecture should be determined automagically. 2. Yes. I frequently use code that was written to target 32bit machines in the mid 90's.
I found MinGW, which is a Windows-port of the gfortran compilers. I think my issue with running the compiler is not knowing what switches were used at the time the code was compiled because I got an error on every single line when I tried to compile it last week. 
Well that is reassuring. I guess I just need to figure out the right switches so I don't get errors on every line of the code during the compile. 
Pre Windows 95 16bit application (yes, that old) does not natively run on x64 (Win7 and above) Windows. But they can run fine on machines (or virtual machines) that can run/emulate 32bit applications I think (but never tested) that you can run it inside the DOSBOX emulator (or VDOS) with a Windows 3.x installed in that emulator. I strongly believe that running it is your sole solution. The major problems with outdated Fortran source code are that it can contain deprecated statements that modern compiler (like gfortran) can reject: for instance DREAL instead of modern DBLE And so, code changes may be necessary to update your code. 
Please post your results in a text format.
&gt;Preface: I am not a programmer and I know nothing about Fortran. I'm a software engineer working with Fortran for the last 4 years. I have a Computer Science BSc. and ~10 years of experience in the field. I have struggled to get old Fortran compile *on Linux*, to the point where I simply had to give up. Your best bet would be to get the original developer to have it compiled to modern Windows, or run the original binary on a Virtual Machine / DosBox. Now if the software in question is *really* important, hire someone to rewrite it or at least mantain it. Depending on it as is will only give you headaches in the long run.
I can't put too much, corporate secrets and all, but the following is pretty much repeated throughout the entire code: C:\Temp\PLABOv2&gt;gfortran PLABO.FOR PLABO.FOR:1:1: $NOTRUNCATE 1 Error: Non-numeric character in statement label at (1) PLABO.FOR:1:1: $NOTRUNCATE 1 Error: Unclassifiable statement at (1) PLABO.FOR:2:1: $STORAGE:2 1 Error: Non-numeric character in statement label at (1) PLABO.FOR:2:1: $STORAGE:2 1 Error: Unclassifiable statement at (1) PLABO.FOR:75:1: $INCLUDE:'plabo.cmn' 1 Error: Non-numeric character in statement label at (1) PLABO.FOR:75:1: $INCLUDE:'plabo.cmn' 1 Error: Unclassifiable statement at (1) PLABO.FOR:527:48: WRITE(1,'('' FRONT CHANNEL TYPE'',T40,A1,'' ''\)') ICSTR 1 Error: Unexpected element '\' in format string at (1) PLABO.FOR:531:40: WRITE(1,'('' SHELL TYPE'',T40,A1,'' ''\)') ISSTR
The things with $ are old metacommands. You may need to replace those.
I don't know if the original programmer is still alive but I highly doubt that would fly with upper management, as he was the previous IT manager and was forced out for numerous reasons some 15 years ago. A current employee has sort of rewritten it in Excel but it hasnt been fully tested yet. 
Have you considered trying VirtualBox? It lets you create folders that are shared between the host and VM. You could potentially use this to allow communication between the 16-bit program and the rest of your utilities.
MinGW is also open source.
I've never heard of those before. I know of the open-mp style ones that open with a command (`C$OMP PARALLEL` or `!$OMP PARALLEL` etc), but I've never seen those before. Are they are a pre-FORTRAN-77 standard, or are they a non-standard post-77 extension on some compilers?
A lot of old compilers had non-standard extensions. I don't think gfortran supports this particular flavor out of the box, but it looks easy enough to fix.
I don't think gfortran has a compiler flag to support these out of the box, so you'll probably have to replace them. [Here's some info to get you started.](http://www.ousob.com/ng/fortran/ng4e22.php) Here's some suggestions based on these errors: * `$NOTRUNCATE` shouldn't be necessary. Fortran used to have a max length for variable names. This is no longer the case, so the statement isn't needed. * `$INCLUDE` can be replaced with an include statement, or a C Preprocessor `#include`. * The standard way to define the size of an integer or real is by declaring its *kind*, which will replace `$STORAGE`. And since the default integer is 4 bytes on x64, and your storage statement allocates 2 bytes, you really only need to define it if the code relies on overflow magic.
What was the old stuff built in? Microsoft fortran? Watcom? Sometimes its easier to pick one fight at a time. Both Microsoft and Watcom had/have 32bit offerings that ought to run on x64 (as long as you haven't removed win32 support). Since the employer is OSS adverse, get VMware Workstation, it's commercial and expensive, along with MS-DOS to get the existing stuff running as a 'right now' stop gap, then try to find out what they used to build it, and reproduce the build. No point going crazy to find the source isn't the same as the binary. then step the source to newer tools.
I haven’t tried Virtualbox for this but it’s a good idea. 
Doh! ¯\_(ツ)_/¯
DOSBox works, as does Win32. Our “solution” at this point is to deploy a 32-bit OS to those who still use this program. 
Thanks for the thorough answer! 
&gt; this isn't "allowed" since its open source (don't get me started). That would apply to gfortran too then.
Get a good numerical analysis book with a lot of pseudo code, such as Burden and Faires, and develop your own numerical integration routines. You’ll learn the material well and give yourself reusable code. If you want to do matrix manipulations, you will need to look at LAPACK, those routines are robust and time-tested.
When one uses Fortran, it is typically to write their own code for their application. There isn't an official set of 'libraries' for high-level tasks, like some other languages. The most you get are LAPACK and BLAS (look them up; they're very useful). But, that said, there is a lot of ODE code out there written in Fortran. This, for example: https://fortran-foss-programmers.github.io/FOODIE/index.html
Numerical recipes in FORTRAN!
Thank you very much!
You sound very new to fortran, so I’ll also add this. Once you’ve found a library like some others have suggested, you’re going to have to install that library. This will create a library file somewhere that you’ll have to link to when you compile your fortran code. So you’re going to have to get more info on compiling and linking in fortran. Get comfortable compiling then look for more info about linking. How you then use those libraries from fortran will be in their documentation. 
Nope, it’s just pseudo code, unlike the actually Numerical Recipes books
Nope, just pseudo code, unlike the Numerical Recipes books
I might have to check it out then, that was the one reason I never really dove deep into numerical recipes.
If you're looking at Fortran because you expect to use it in the nuclear industry, bear in mind that you might not have extra libraries available on the ancient computer they will make you use. Source: I write Fortran code for nuclear power plants
And if one needs an Fourier transform, just use FFTW, for God sake. Don't invent your own Fourier transform library, except as a learning exercise.
The compiler makes no promises about the values stored in unassigned/uninitialized variables.
I think op is asking why just the first value is randomized and not all 3. Seeing as none of the values in the array have been assigned, they should all be just random garbage, not just one of them
I think op is asking why just the first value is randomized and not all 3. Seeing as none of the values in the array have been assigned, they should all be just random garbage, not just one of them
I've found GNU fortran will often set the value to 0 and Intel fortran will be some crazy large number. In practice, don't leave things to chance. ALWAYS ALWAYS ALWAYS set the value to something even if it is just 0. 
/u/markovperfect is still right. The compiler has no rules for this. So only having the first element change is just as correct as having all of them change or none of them. 
&gt; Its users are scientists and engineers; not computer scientists and software engineers, but the real ones. That was a bit underhanded but otherwise the article was pretty good in that it addressed features of the language and the population of the user base.
Agree... Even if I'm a software engineer in the FEA field since 85'... the "not real one" as they said ;) 
Agreed, that was totally unnecessary. As a mechanical engineer, who writes Fortran for a living, I wish I had a proper or better software engineering education while at the university. Living and working in EU, there is only one place that I encountered this mentality of Software Engineers being considered as lessers Engineers and that was in Germany. 
I know. It's a ridiculous and slippery slope. 
I'd at least add -ftree-vectorize if you're doing -O2. I often get the best performance with either -O2 -ftree-vectorize, or -O3 -fdisable-tree-cunrolli. That's assuming a lot of your math can be vectorized. Perhaps add -finline functions, if you like to write a lot of small functions. If you're making shared libraries, I'd then also recommend -fno-semantic-interposition, otherwise those small functions will not be inlined.
Eh. Blow it all open. Present management with four options: - Rewrite from scratch (expensive) - Drop having the functionality (problematic) - Buy ifort and fix it to compile (expensive-ish) - Use DOSbox and just run it - Use gfortran and fix it to compile (more time-consuming but makes sure that the code is actually possible to maintain from now on). Then immediately take the two last options off the table and explain management why you have to take them off the table (i.e. because they, or their management, insist). Then let them sort out the mess, which is actually their job to deal with. If you sell it right, they will be on your side, and you don't need to go sneaking around. At least that's how I'd play a situation like that. They created the mess, they can solve it (or pay for the solution they mandated).
Some scripts in the Makefile 
I use the ctest system with cmake and have seen good results.
Do you know of any resources on how to do this or have anything you can share? I just have some test programs that USE my modules and run some test cases, but I just run the resulting program manually. It’d be nice to automate it the proper way. 
I haven't actually done this, but I would consider using f2py with pytest.
Yeah that’s what makes it tricky—I really want to do both. I guess I’ll have to set up a dummy problem and see if I can make it work. Unfortunately it’s fairly complex even as a dummy problem.
case(x:y) implies a range between x and y so when when perform an open ended statement like this case(:y) This means anything less than y. So case(:1,6:) this means a number &lt;= 1 or &gt;= 6. 
Thanks so much!
Thanks so much!
My project uses Cmake, so I will try to use Ctest, but thank you! 
Keep us in touch with what you conclude from your dummy problem! 
I create test program for each feature, which contains multiple tests in it. I think I use a shared library too for module linking.
Check out my GitHub repository. https://github.com/hornekyle/CommonModules
There is a big difference in the way strings are stored in FORTRAN and C and parsing that information with old FORTRAN standards is going to be difficult and probably nonstandard conforming. Is there a reason you need to do this mixed FORTRAN/c code with F77? The FORTRAN 03 standard provides a set of functions for passing data between the two languages in a way that gets around a lot of the headaches of worrying how data is stored. Look up iso_c_binding functions in F03 and it should get you on your way. This is how I deal with mixed language data passing
That struct on the C side may be wrong. It's been my experience that Fortran character arrays in common blocks do not have an implied length member, either before or after the array. So that structure might actually be: struct fstring_type { char str[30]; }; 
There's a standard way to make things interoperable. [Maybe this helps.](https://solarianprogrammer.com/2012/05/11/mixed-language-programming-cpp-11-fortran-2008/)
A great portion of people who use Fortran in general, or FORTRAN in particular, are the ones who have to deal with huge junks of legacy code. Preferably they want to wrap the code in a more reasonable language which is mostly C. I've made a very messy [GitHub repo](https://github.com/Foadsf/Cmathtuts/tree/dev?files=1) trying to collect and explain all the BLAS and LAPACK examples I could find on the internet. And as you may imagine mixed C-FORTRAN programming is unavoidable, if one what's to understand what is happening under the hood. You may see [this example](https://github.com/Foadsf/Cmathtuts/tree/dev/A_fortran/Ex01) for instance.
have you tried this? It removes the segfault, but does not return a string!
As a mostly fortran developer, I dot take a little exception to the statement that you Fortran isn’t a reasonable language but that little jab aside i still think that the most portable solution is to either add f03 constructs to your existing legacy or add a thin wrapper of f03 in a module that calls your code. The code that I develop makes use of a lot of fortran/c interfaces and in the past has tried to adhere to the f90/95 standard so I definitely understand that different languages have their strengths. The example you uploaded to github probably isn’t portable and compilable on all platforms and compilers because fortran compilers aren’t required to enforce function case and have different internal standards for name decoration with underscores. Because Fortran is almost completely backwards compatible, writing a few lines of f03 in a new module doesn’t invalidate or change anything for the existing code base you have. My colleagues and i used a little test code at [this github repo](https://github.com/permcody/CToFortran/blob/master/fortranVar.f90) to experiment with the new f03 features and I was blown away by the reduction of complexity in our fortran/c interfaces. Hopefully our messy code can help in some way. 
please don't get me wrong. Fortran is an awesome language. I was referring to the legacy FORTRAN 77 when calling C a more reasonable language. 
Same idea !
Fortran strings are not null-terminated. Is your C code taking that into account when you access the common block string?
Don't use common blocks. Upgrade to Fortran 90 and use proper user types to represent structs. Also use ISO-C-binding. Anything else you do will be full of bugs and compiler dependent.
No DEFAULT, not so a good idea for a CASE OF No DEFAULT here, so x=2 not covered by case of: normal?
I likely do have a default in the actual code, I didn't write it, but what I wrote in this post was a quick example just to get my question out there.
Use an open statement with append status Open(unit=72, file='Toto.txt', status=append) Then do a formatted write to the unit Write(72,*) 'whatever' 
Two issues that I'm sure you know about and just glossed over: It's actually position="append" (I frequently make the status="append" error as well.) Also a formatted write would have a format statement in place of that star, which just means write with the default format. Format statements from my favorite Fortran reference: https://pages.mtu.edu/~shene/COURSES/cs201/NOTES/format.html 
status = 'append' always worked for me formatted statement as opposed to binary write write(72) toto * is automatic format 
Since you mentioned linebreak, fortran inserts a carriage return by default with each `write` statement, quite different from C type languages. There is a special character for a reverse carriage return, I believe, but that is almost never needed. 
You can suppress that though (I can't remember how exactly, but it's possible).
You can use the append command so that it does not replace the info enclosed and only add to them.
I think that the streaming IO methods permit excluding the new line.
If you put 4 spaces in front of your code it'll be easier to read on Reddit, and allow you to indent things properly. That said, I don't think there's anything you can do recursively here. Each value of `b` and `Eo` depends entirely only on existing arrays, so there's no iterations happening. Have you tested this code? I'm not sure if does what you intended - rather than `n_int` solutions, you're packing a triangular matrix into a 1D array? You'll have `n_int*(n_int+1)/2` values per array at the end
I tested it, its indeed working
You can't make arbitrary functions recursive. First, try to come up with mathematical recurring solution to the problem, like when you write Fibonacci numbers where F(n)= F(n-2)+F(n-1). (From a computer science perspective you *can* make arbitrary functions recursive, but it's really something advanced and not very useful in the context of Fortran)
You can use `write (..., advance="no") ...`.
As far as I understand things, fortran passes things around by (what looks like but aren't) pointers. The arguments that get put into the subroutine are memory locations, and the subroutine itself will treat those as whatever you designate. So if you pass in an integer array, and the subroutine is expecting an integer array, it'll just take the memory location what you passed it and treat the (byte) data that sits there as integers. If you told the subroutine it's doubles, it'll treat it as doubles (even though the data there wasn't intended to be by the calling routine).
This mostly applies to F77 (which based on OPs description of how the code operates is probably what he/she is relying on). With the introduction of modules in F90, interface checking became more integrated into the standard. 
Absolutely. But, without modules etc, even F95 compilers exhibit this same behavior.
Recently, I heave started noticing that IVF in an MSVS environment has started to really restrict a developer’s ability to overload an interface (not really complaining other than the frustration of some legacy code that needed to be updated) but in all other circumstances that I have come across you are right
Thanks for the response! That's just crazy to me coming from C-like environments--I'm so used to at least a little bit of type-safety. I'll have to be extra careful when reading other people's code to make sure I know what's going on with tricks like this.
I spent a few hours tracking down why my numbers didn't make it into my subroutine correctly a few years ago. I learned, and stopped using fortran for new projects :)
Haha, I'm only looking at this code to see if I can translate it to Julia. I can't get this Fortran library to compile and the authors are all dead ¯\\\_(ツ)\_/¯
What's the compiler error? I've had decent success calling fortran from other languages 
A buffer overflow in gfortran. Can't quite find anything like it on the internet, and I'd rather give that up and learn something new about the code base (it's a lot of heavy spherical harmonics).
gfortran has an -fbounds-check that might be useful. That, or one of the other runtime compiler flags.
Hmm, I'll have to check that out tomorrow. Thanks for your help!
You're welcome!
This is called "Sequence Association" and used to be commonly employed in old Fortran code. I would not recommend it in modern Fortran programming. See this Intel page for extensive explanation: [https://software.intel.com/en-us/blogs/2009/03/31/doctor-fortran-in-ive-come-here-for-an-argument](https://software.intel.com/en-us/blogs/2009/03/31/doctor-fortran-in-ive-come-here-for-an-argument)
Though more modern languages are often going to be *less* strict on this sort of thing than Fortran. Fortran is somewhat C-like in this regard - in C you can be even more flexible with arrays, because they're just pointers to blocks of memory.
The other values lack a decimal point so the compiler is interpreting the values as integers. If you want a real array then add a decimal point to the rest of the values. 
What do you want to do? Define an array with values? reshape does change the dimensions of an array and thus requires integers. 
I wanted to get into calculating determinants. Defining an array first and then calculating it. I fixed it by adding a .0 to the other numbers
Thanks ! That was it
What is the link to .NET and MS VS? While there is a Fortran syntax highlighting plugin for MS VS, I would not call it a development environment. Otherwise, good luck in your search!
The whole ‘place the company ahead of personal gain’ line sounds like they’re going to pay you a 40 hour/week salary and expect 80
I would use two allocatable arrays where one is your uncompressed data and one stores the result and just resize the arrays at the exit of the subroutine. Your problem is pretty small but deallocation/reallocation is expensive so I would limit that process as much as possible inside of the loops
Hahaha. I can understand why it sounds like that. I am working here 40 hrs/week along with other staff. 
Huh, this was deleted while I was trying to get an answer! real, dimension(5000) :: Xnew real, dimension(10000) :: X integer :: i, lengthNew lengthNew = 5000 X(1:10000) = (/(I, I=1, 10000)/) do while (lengthNew.gt.1) do i = 1, lengthNew if (X(2*i).eq.-100.0) then Xnew(i) = X(2*i-1) CYCLE end if Xnew(i) = 0.5 * ( X(2*i-1) + X(2*i) ) end do !print*,Xnew(1:10) !print*,'------------------------ ' !print*,X(1:20) !print*, 'lengthNew1=', lengthNew X(1:lengthNew) = Xnew(1:lengthNew) X(lengthNew+1:10000) = -100.0 lengthNew = COUNT(X.ne.-100.0) !print*, 'lengthNew2=', lengthNew !print*, '' print*, Xnew(1) ! that's the average on every step, and the total block average on the final step end do 
Because this is an international website (less than 60% are from the US), you should specify if you're only interested in candidates who already have the right to work in the US, or if you're interested in sponsoring a work visa overseas candidates. I also agree that the .NET and Visual Studio things seem a bit odd if you're looking for a Fortran developer.
Have `module_interface` set the module scope variable. Something like: `module some_module` `! the idea is for this to be *entirely* modular` &amp;#x200B; `integer :: module_wide_variable` `private` `public :: module_interface` &amp;#x200B; `contains` &amp;#x200B; `subroutine module_interface(interface_wide_variable)` `integer, intent(in),optional :: interface_wide_variable` &amp;#x200B; `module_wide_variable=interface_wide_variable` &amp;#x200B; `print *, 'module_interface thinks its been passeed module_wide_variable=', module_wide_variable` &amp;#x200B; `call private_subroutine` `end subroutine module_interface` &amp;#x200B; &amp;#x200B; `subroutine private_subroutine` `print *, 'other subroutines think that module_wide_variable=', module_wide_variable` `print *, 'i would like it if it thought it was what I passed into the interface subroutine'` `end subroutine private_subroutine` &amp;#x200B; `end module some_module` &amp;#x200B; `program example` &amp;#x200B; `use some_module` &amp;#x200B; `implicit none` &amp;#x200B; `call module_interface(interface_wide_variable=1)` &amp;#x200B; `end program example` Also, the argument bring passed to `module_interface` is marked as `optional` so you should test if it present before using it with a `if (present(interface_wide_variable)) ,...`
Thanks! &amp;#x200B; This sort of thing had occurred to me though.. I should add that I was really wondering if it was possible to avoid this sort of route, since in-practice the interface has a lot of arguments, so its going to lead to a block of `module_wide_var_1 = interface_var_1` type-statements &amp;#x200B; I guess this is just the standard way to do it then?
An alternative would be to make use of derived-type variables: create some type that contains all of the state variables that your module needs, then construct an instance if that type and pass it to `module_interface`, then you have just one assignment statement in `module_interface`. At that point it might be better to make full use of the object oriented features of Fortran though so that the state is stored within ones of a class, and you make all the functions in your module be type-bound procedures of that class. That way you have much more flexibility than your current approach which can only handle a single state at once. (But depending on your application your current approach might be sufficient.)
Ahh! Good idea. I can see this been worth the effort for this application, it feels like its already getting a bit out of hand with only the simple test cases (many more options yet to be added)! Thank you :) . 
I have the previous edition of [this book](https://www.amazon.com/Modern-Fortran-Explained-Incorporating-Mathematics/dp/0198811888/ref=pd_lpo_sbs_14_t_0?_encoding=UTF8&amp;psc=1&amp;refRID=6WFE4KNQN02SSG6NBDWZ). I found it very helpful in learning all the new features of Fortran 2018.
Find problems to solve, like https://projecteuler.net/ and use fortran to solve them.
Have you tried to print it inside the DO loop?
Hah! That is the solutuion to my problem. Thanks !!
Based on your READ statement, the variables with the “i_” are INTEGERs. What is the type of the array za? Is it declared as an INTEGER? What are the dimension of za? za(file_len,4)? What does your WRITE or PRINT statement look like when you are seeing the incorrect values assigned in za? 
If it works when you follow the read with a write, that means that reading is not the problem. It would help to know how you declare the array za. You may want to do za(1,j), za(2,j), etc. instead (this is a common error), but it is not easy to say with the information you gave.
I'm not sure of this is correlated, but isn't unit `10` use for something in Fortran ? I always use units above 100... Not sure why though. 
It seems like you have a problem with your formatted IO. The format descriptor says you should have a character string in between every integer value. I would start by adding in explicit dummy strings and seeing if that fixes your problem. 
There don’t appear to be any ‘A’ format descriptors. What are you seeing?
You are correct. I misread your syntax. Could you post more of your code so we can see some information about the zap array?
Why not just read the values directly into the array elements: [code] do j=1,l read(10, (blah, blah)) za(j,1), za(j,2), za(j,3), za(j,4) enddo [/code]
I will have to try using that, thanks!
Thank you all for taking the time to reply! I'm going to have a look at the code again in the morning and if I can't figure it out I'll post the bits you were asking for.
Is there somewhere I can view it for free?
How does this work? Is there a compiler available that works with this standard or do the 'Fortran people just decide this is Fortran 2018 and expect us to start using it? I'm still working in 77 so urgent response definitely not required
In very few words, compiler permitting, any free form (F90 and beyond) source code can use new notations and be recompiled. 77.. I feel your pain.
The Fortran standards define what a Fortran compiler needs to be able to do to comply to that standard. Each standard includes the previous standard as a subset, so any Fortran 2018 compiler will also support Fortran 2008, Fortran 2003 etc... Since the introduction of modern Fortran, there have been 5 standards published: Fortran 90, 95, 2003, 2008 and 2018. Most compilers in active development fully support Fortran 95, and many of them fully support Fortran 2003. Depending on the compiler/feature in question, support for Fortran 2008 is a little more patchy. The more useful/easier to implement additions tend to be more widely supported, but only a small number of compilers are fully 2008 compliant. As for Fortran 2018, I expect the trend to continue. Some compilers will support some of the new features quickly. Indeed, some compilers already include some of the Fortran 2018 features. I'm not sure if any are fully 2018 compliant yet, but I wouldn't be surprised if it took a while for the popular compilers to implement everything. As for which compilers support which features specifically, http://fortranwiki.org/fortran/show/Compiler+Support+for+Modern+Fortran and links therein provide a pretty good summary, along with other useful information around this topic.
The best I've found is a working draft from April, link at http://fortranwiki.org/fortran/show/Fortran+2018
It is not always a strict super-set. Sometimes, features are deprecated.
You can even analytically calculate an upper bound for your integration error. Just search for a-priori error estimates. Wikipedia has a rather short section on it: https://en.wikipedia.org/wiki/Numerical_integration?wprov=sfti1
Give us some more info about the 'do array loop thing'. Is it a DATA block? DATA A / 1, 2, 3, 4, 5 / Is it just a loop that initialises an array? DO i = 1, N A(i) = i END DO
So basically the idea is, I have a text file of values of data which I require fortran to read and therefore use these values in an equation and output the answers in order. &amp;#x200B; Equation: The Ef/Σ are constants, the Φ values are the values in the text file, theres a fair few values. So I need to calculate an Ef for every single Φ value and then output it out. 
Okay, it looks like the formula itself will be pretty easy to evaluate, so let's concentrate on file input/output. Take a look at [the Fortran Wikibook](https://en.wikibooks.org/wiki/Fortran/io) on this topic. You'll need to use the OPEN, READ, CLOSE, and PRINT statements. The toughest part is probably going to be getting the right format string, but you might be able to use `fmt=*` (at the bottom of the wikibook entry). Give it a shot, and if it doesn't work, try to come up with a *minimal working example* (the smallest possible program that uses the features you're trying to learn about). The minimal working example is one of the most powerful tools when it comes to learning how to program.
Do the fields of \`C\_SUB\` need to be allocated before being used? I am not familiar with \`MKL\_ZCSRADD\` but I would imagine it doesn't do the allocation.
Aye, they do. C_SUB is assigned to an allocated CSR data type. Thinking on that, I might be able handle the allocation inside C_SUB and make use of MOVE_ALLOC to pass the subroutine output to the function output without needing to double up on the allocated space? 
This is the area where my understanding of what and where needs to be allocated gets a bit fuzzy... I find it much clearer to understand the intentions and mechanics when the variable is passed as an `INTENT(OUT)` variable. I don't know how Fortran would process it, but I did looked it up for Free Pascal some time ago: there with the assignment, the address of the LHS of the assignment on the caller site is passed to function. But this seems to be what you are doing and yet it gives you segfaults...