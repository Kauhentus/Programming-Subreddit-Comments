I am very aware why the code is terrible, it was not intentional. However I expected the compiler to recognize the error rather than crashing the system, but I understand why it did.
I just started, I am doing a masters in environmental engineering, so we're using FORTRAN for our crazy equations that we need to do... just need the performance that it affords, otherwise we'd never get anything done, hah.
Never worked with it professionally, but I've always wanted to learn it. I've gotten as far as "hello world" so far, but that's about it. Fortran is still on the list though, for sure...
Why would you want to learn it if you don't have to work with it?
&gt; Why would you want to learn it if you don't have to work with it? Well, for starters I just like learning new languages. And Fortran is one that I've been meaning to learn for quite a while but haven't gotten around to yet. Also, I'm interested (on an amateur basis) in scientific /mathematical computing and I have some hobby projects I'm interested in tinkering with that might make a good place to use some Fortran. Other than that, no real reason.
Well if you do learn fortran, make sure you learn FORTRAN90 or 95. Older fortran is a pain in the ass and many limitations built into the language due to punch cards. FORTRAN90 is usable though. I would not ever want to do something with it beyond number crunching though.
I'd love to know about said quirks.
Unfortunately most Fortran code is legacy Fortran 77 code. So we still have to learn the old stuff. Also, I'd say the most significant limitation of Fortran 77 is not being able to structure your data properly, turning everything into a (non-ALLOCATABLE!) array.
Oh this is interesting. I will have to check it out. How is performance? Just curious how c++ code that came from FORTRAN performs and if alot of hand optimization is needed after the conversion.
Why would anyone take perfectly good Fortran and turn it into something monstrous like C++? That's like taking Python code and turning it into Perl.
Well, I am mostly running it on BLAS/LAPACK routines right now, to get reasonably succinct C++ translations, and it converts files in well under a second. There are still quite a number of issues, so a substantial bit of hand tuning/correction is required, but nothing that affects the correctness of the computations themselves (well, I believe this is the case). The converter only tries to convert the Fortran as it was written, so any hand optimization would largely serve to improve the original code.
If a physics student working in computational physics. I use FORTRAN from time to time, but mostly C.
Is there a reason for doing that or is it just for fun?
To study the classics, of course.
Worked with in professionally in the space / satcoms industry but the move was towards C++ and Java. I understand its still chugging away in Tescos core infrastructure 
Where are you doing your masters of computational science? I'm interested in going into that area (though maybe not if it means using FORTRAN all the time).
Is there some reason why [f2c](http://www.netlib.org/f2c/) wasn't good enough? Or is this just an exercise, which I can also respect? Just wondering...
Clever declaration. I'd like to know if it crashes other compilers.
I used to, until about 3 years ago. I work for an airline, and FORTRAN 77 programs on Unisys mainframe computers are one component handling flight schedules.
I am doing mine at San Diego State University. My undergrad degree is in physics so I am working on computational physics. That is really the only reason I am using FORTRAN, anyone not working with a physicist uses matlab or C++
What version of fortran does it support? Only 77? support up to 90/95 can make this more popular for someone without a modern fortran compiler Instruction to use it? What option does it support? 
I work in Applied Mathematics / Computational Physics, and yes, I use Fortran. All the legacy code we've got is written in Fortran, and all the new one in C, except when the person writing it (a mathematician most of the time) doesn't want to learn C, and say that Fortran is "simpler". So, I only _read_ Fortran, and I write C code. When we have to rewrite sections of the code, this is quite often the time to translate them to C. Also, I have to add that for the most part, *we don't need* Fortran performance. Most of the time is spent in BLAS, LAPACK and MPI, and the performance-sensitive part of the code outside these librairies are as fast in C as they are in Fortran.
Makes sense. Totally agree that LAPACK and MPI are where most Fortran code is going to spend. The only problem is when you have to write code that will be read by someone who only understands Fortran. I am currently just a masters student so my code has to be later understood by my advisor. He writes Fortran so I write Fortran. Some days I feel like Fortran is jsut fine and no need to switch to C. The biggest problem with Fortran in my opinion is compilers even with full warnings do not catch some really silly things and you can shoot yourself in the foot. Or the compilers have horrible error messages. There is also a confusion between f77 f90 and f95 where each compiler mixes their support for the 3 standards. And the static code analysis tools for fortran seem to all be expensive so I have not tried them to see if they are any good. I guess basically the problem with Fortran is not the language itself, which is fine. The tools are just outdated and not as well maintained as C. Not outdated as in don't work, just outdated as not helping the programmer out, which programming tools have come a long way.
Tried to translate http://projects.scipy.org/scipy/browser/trunk/scipy/optimize/slsqp/slsqp_optmz.f?rev=6221 but the end result does not have balanced parent
You've filed this as a bug report, right?
I work with a simulator that is written in Fortran 77 and write tests for this simulator that tests 8051 code. I work for a aerospace company.
as a fortran novice, can you explain what's going on here?
Thereâ€™s [DFT++](http://dft.physics.cornell.edu/), which is written in C++. *site may be down, you can also try [this version at MIT](http://dft.mit.edu/)*
The OP has declared an array of real (single precision) values named *p*. However, the OP has defined the array to have indices from 1 to whatever the size of *p* is, making it circular. My guess is that GFortran simply isn't mature enough to notice this minor snafu. A declaration like the one shown above would probably never occur in practice.
Sorry to resurrect this thread, but I'm looking for some advice. I'm a Computer Science major who is worried that I don't have the scientific background to be successful in Computational Science. Do you know if many of your classmates have their undergraduate degrees in Computer Science? Will admissions look at me like I'm an idiot if I haven't taken a physics class in 3 years, instead focusing on parallel computing?
You really do not need to know any science to do Computational Science. Sure it helps, but really you need to know more math than science. It obviously depends on what you want to do with it, but you can learn the science you need to know for a specific problem when you are given it, what you need is a good understanding of maths.
Solving problems on there will help some. I used "An Introduction to FORTRAN 90 for Scientific Computing" by Ortega. Not the best book in the world but it is very short and gives you all of the basics. Fortran is a very easy language to learn since there are so few constructs.
You can try my courses website: http://web.ph.surrey.ac.uk/fortweb/ It doesn't go through everything but it's a great introduction with exercises, it also has a glossary which briefly describes each term.
Thanks a lot for your reply. I am looking at your website now. :D
Will check it out. Thanks mate.
I don't think I've seen the Ortega book, but I've looked at several others, and liked the Chapman book(s) the best. I think I agree that Fortran is an easy language, but it has a lot of legacy baggage that you might have to deal with if you must modify old code (or work with programmers who cut their teeth on old versions of Fortran, and still use it). Also, newer standards like Fortran 2003 have a lot of new features that are making it more complicated if you actually want to take advantage of them. The best bet for now is probably to stick with Fortran 90/95 unless you are more computer-science-oriented than just basic problem-solving-oriented. Also, compiler support for F2003 is still in an early stage, so yet another reason not to bother with that. Whatever you do, I recommend you stay away from the Metcalf books. They are very popular, but they are so terse that I wouldn't recommend them to learn from.
What... do you need to know?
What platform are you on?
What is the problem you are looking into?
Not sure if r/fortran is that hoppin' these days. You might check out StackOverflow.com, if that helps!
Well I'm glad to say that I have traversed that particular barrier a short while after I posted that.
I'm actually taking a parallel and vector scientific computing class this semester. Also good to see you got added as a moderator :) http://people.math.gatech.edu/~llefton/4777/
This is how it's done.
Nice.
FORTRAN 90 really isn't bad. Not going to say it is the best language, but gets the job done. Support for the language is lacking compared to more popular ones. Bugs are hard to track down as error message can be cryptic, and very different from compiler to compiler. Certain horrible errors compile fine on some compilers and give strange results. I feel the language itself is to blame rather than the compilers though. FORTRAN 90 is great to updated an existing code base into something less painful, but I would not recommend anyone start a new project with it.
You make some good points, and I agree that it might not be the *best* language generally speaking. I think your point in regards to cryptic error messages can generally be said for most compilers for most compiled languages. C/C++ compilers are notorious for misleading errors as well. I do agree that some errors compile fine on some compilers and produce odd results, but I would lay that blame squarely on compiler makers. I've dealt with quite a few of the commercial compilers, and many of them tended to produce simply incorrect code code. I think the language standard is usually pretty clear on how things should work, but the compilers often get things a bit wrong. Such mistakes are common on "niche" languages, in my opinion, where perhaps not as many people are exercising said compiler. I would disagree strongly, however, about updating code to Fortran 90. The syntax tends to be so different than FORTRAN 77 that I would never suggest anyone attempt upgrading a codebase to free format. I also think it would be pointless since it would only introduce bugs. I don't think starting a new project in Fortran 90 is a bad idea at all. The language has its strengths, and often Fortran is the right tool for the job. Choosing a language to start a project in is all about comfort level and the programmer's ability to complete the task in said language with relative ease. With today's free Fortran 90/95/2003/2008 compilers, there's really no reason Fortran can't be chosen. 
Nice contribution, thanks!
It'll be hoppin'.. one day..
I hope so, but one problem is that this subreddit has no mods - I deleted the account I started it with. Oops!
Oh dang, I actually petitioned the reddit admins to make me a mod because of that! Would you like me to add you back on? My apologies for being an absent mod, I have been busy (coding FORTRAN) and liking the low traffic :)
Oh, I didn't realize that. Totally cool with me, thanks for picking it up!
I would love to hear anyone's experience with integrating (or migrating) fortran code with/to python.
This article is a good rundown on f2py! I haven't used it much except running the predefined setup.py script to build the [Slycot](https://github.com/avventi/Slycot) interface to the [SLICOT](http://www.slicot.org/) library, which I believe uses some pre-created f2py files. [/r/python](/r/python) might be interested in this too!
I write a lot of numerical code using python+fortran. My experience is that python is great for writing programs quickly, and fortran is great for writing quick programs. My usual workflow is to write a rough version of the program completely in python with unittests making sure everything works as I expect. If the program isn't fast enough, I profile the code and rewrite the critical parts in numpy. When numpy isn't fast enough, I rewrite portions of that code completely in fortran and link to it with f2py. The combination of python+fortran means that I am able to write fast, reliable and reusable code very quickly. The main drawback is that f2py is really aging. I think pearu hasn't made a significant update since 2005. I am unable to port my code to new IBM machines, even though by themselves python and fortran work fine. I managed to hack numpy into working but not f2py. I've spent fruitless hours trying to pierce through the code to fix these issues, but internally f2py is a swamp. I think the docstring for what is apparently the main function pretty well characterizes it: "do it all in one call!" followed by several pages of uncommented code modifying sys.argv with regular expressions. Somehow "it all" is accomplished by a convoluted network of distutil objects stringing through f2py, numpy and the base python creating instances of themselves like some nightmarish oroubus. Everyone seems to be pointing towards fwrap, and I have been inching in that direction to see if it will help, despite fwrap clearly having its own issues .
Wonderful and helpful comment, thank you for taking the time to write it up m8
There was a big gap between versions, during which C and Pascal took over as primary programming languages. That gap was between FORTRAN 77 and FORTRAN 90. And during that time a lot of things happened in computing. f77 had a huge amount of backwards compatibility features, dating to punch cards days, without any updates that started to appear with the arrival of C and Pascal (dynamic memory allocation, pointers, etc., etc.). With f90 a lot of those features were introduced, but other languages already took over, so it was already late for FORTRAN to compete with them as many companies already transitioned to higher level languages. Still, IMHO FORTRAN is still the fastest programming languages when it comes to numerical calculations.
Fortran is marginalized because for 98% of the problems out there it isn't the best choice, but for where it is the best choice, it's very fast and very good. Debugging can be a beast with older code though. Definitely not as bad as I was expecting when I first started working with it.
Wouldn't that make it ideal for some OpenGL based apps?
OpenGL standard does have language bindings for Fortran, so I would say that when observing computational speed Fortran would be an excellent language choice, but it would be a bitch to plan out the project (especially if it is a project of greater magnitude), test and debug since you don't have access to all the modern tools that are available to the modern programmer in C# or Java. Also, there are practically no libraries available out there to download or to buy to make certain "menial" programming duties easier. That also means that you generally have to use an another language to create the user interface and you must also establish a link between these two modules. All in all - too much work for such a small gain. In a sense, when programming in FORTRAN you are left more or less on you own to program practically everything. That might work for smaller one-man-kinda-deal projects, but any serious project will require a lot more time if it is done in FORTRAN than perhaps say Java. 
&gt;IMHO FORTRAN is still the fastest programming languages when it comes to numerical calculations I don't think this is just your opinion. I think it is actually fastest for straight running numbers.
From what I understand, where Fortran can be used, it is usually the best choice. The compilers are generally pretty reliable as well. 
It sounds like you want `iso_c_binding` so I'd take a look at http://www.fortran.bcs.org/2002/interop.htm or google around a bit.
I'd disagree with the compilers being reliable. I've worked with quite a few compilers for the PC and had problems with almost all of them. Intel got nabbed for shenanigans on its Fortran compiler running on non-Intel hardware. I've had terrible experiences with Absoft on Windows. GNU Fortran is much, much better nowadays, but there were problems early on (although they were pretty forthright about it still needing work, so I guess that's not particularly bad). DEC/Compaq Visual Fortran and most of the UNIX vendors' compilers were rock-solid. PC and Mac compilers have been less than stellar, though.
Lack of libraries for anything other than scientific computing and lack of OS integration.
Sounds like something that can be fixed with a determined guy and a few years OR $500k
It could be done, but there are some inherent problems in the language compared to C. 1. No standard module format. C just has headers. 2. No standard name format for symbols. Fortran identifiers are case insensitive, but linkers are not. And with modules you need some name mangling scheme. C on the other hand has a stable ABI 3. Until Fortran 2003: No standard way to call C functions. That means, no POSIX or WinAPI other than by using non-portable compiler extensions or relying on compatible compilers (like gfortran and gcc). 4. No way to get a type with a certain number of bytes. The kind is just a compiler dependent integer constant describing precision (`REAL` and `INTEGER`) or character set (`CHARACTER`), it has no relation to the size in bytes. That means, no way to write a portable library that needs binary IO. C on the other hand guarantees that a `char` is one byte and C99 defines types with explicit size in `stdint.h` I'm not saying it's impossible, it's just very inconvenient whenever you have to interact with something outside the Fortran world.
I am terribly sorry this got caught in the filter for so long! Please post a follow up!
Thanks for sharing! It's a good thing to remember to not recalculate the same values repeatedly. I'm running some Fourier transform code, and I recently created a global constant invsqrt2pi, the inverse square root of 2*pi, since I used it so often, and both division and square roots are relatively computationally intense. Cheers!
Intel give a 30 day free evaluation license which might be sufficient for you. Otherwise 64 bit windows is a bit tricky... you could try mingw-64 binaries from here http://mingw-w64.sourceforge.net/ Although if it is a standalone binary and doesn't use many GB of RAM, 32 bit gfortran should work fine on 64 bit windows. 
Thanks a lot for the response. I've researched Intel's software website quite a bit. I'd look more closely for the free evaluation copy. 
http://www-teaching.physics.ox.ac.uk/Unix+Prog/hargrove/tutorial_77/
Assuming the function is as simple as y = z/x, could you not just compute y * x to find z? If the function cannot be solved with something like that, [Netlib](http://www.netlib.org/) has a bunch of codes that will fit discrete data to polynomial or other functions. Please post a follow up if this does not help!
I ended up just doing the y*x to find z and then a normal least square on the z's. Thanks!
If you need help post in the Forums. I see you are using windows so: http://software.intel.com/en-us/forums/intel-visual-fortran-compiler-for-windows/ Intel support engineers patrol it and you will get quick answers.
The best compiler hands down is Intels, but you could say I'm biased ;-)
I recently started to learn FORTRAN as well. Guide to FORTRAN 2003 is a good book to get started with. Chapter 1 of the book can be viewed on Google books and I find it a great introduction, something some FORTRAN tutorial seem to miss out. http://books.google.com/books?id=UOGV9TT23KYC&amp;pg=PA4&amp;dq=1848825420&amp;source=gbs_toc_r&amp;cad=4#v=onepage&amp;q&amp;f=false
Thanks a lot!!!
It might help to pastebin some code example of how your subroutine is defined and how you are using it since I'm not exactly sure what you are trying to do. But it sounds like you are not returning the array that you created, try something like this: subroutine test(input1, input2, input3, output1, output2) real, intent(in) :: input1, input2, input3 real, intent(out) :: output1(3), output2(4) !... Do stuff end subroutine test and then use the subroutine like: call test(in1, in2, in3, out1, out2) print *, out1 print *, out2
Use implicit none before specifying the variable types 
this.
You might want to give [gfortran](http://gcc.gnu.org/wiki/GFortranBinaries) a try. It will not produce super fast code, but is definitely functional.
Intel Fortran: http://software.intel.com/en-us/articles/intel-composer-xe/
Here is a link to the Fortran Standard: (goto page 204) http://j3-fortran.org/doc/standing/links/007.pdf As you can see there are constants for the standard units from the intrinsic module of ISO_FORTRAN_ENV. However, you are correct in stating that 0,5,6 are the norm (and I think most compilers use them) but the standard leaves it to the compilers to decide it seems.
Thanks! Yeha, I think the subroutine was not outputting how I wanted it to. Cheers.
To be honest, it might be easier to just install a VirtualBox host with a Linux OS...and then install gfortran.
Are you saying gfortran produces slower binaries than other compilers in general or only on Windows?
Just in general, but unless you're running some huge stuff you may not notice the performance hit.
I've found the performance decrease negligible when you factor in native matrix operations. Definetly quicker that writing your own matrix class In c++(although this is an option)
Do you have benchmarks that show that? I found [these](http://polyhedron.com/compare0html) where gfortran is doing quite well (comparable to PGI, a bit slower than Intel). I don't know how old these are, they are using gfortran 4.5. Edit: I'm not trying to prove you wrong, btw. I'm genuinely interested.
Thanks! Maybe I can reference those named constants then...
I was drawing mostly from my own experience of gfortran vs intel compiled binaries. I ran across a paper some time ago comparing three compilers on a [parallelized PCG solver](http://www.igg.cas.cn/xwzx/yjcg/200912/W020091211345917673978.pdf) (see Fig. 2) that showed a pretty large difference between execution times for the same code. There are probably many more examples, it will almost always depend on your code. I am lucky enough to have access to ifort and even 10% speed increases are worth it for some of the things I need to run. If you are doing HFT stuff with your financial data and want to use fortran, I would recommend just going with the very fastest you can find; your competitors certainly have faster ;)
Usually, if you don't specify any file descriptor it will uses the default for that case. Thats why write (*,*) will print to the console read (*,*) will read from the keyboard Since you don't specify a descriptor, it uses default.
That's true. I'd like to be able to use an integer variable that I can set to standard out or standard error, because then I can instead send them to files by changing one number.
I don't know about the BEST but it certainly works and I found it straightforward. 
I would say c/fortran are equally easy. But if you're doing matrix operations fortran is probably better suited for the job
I just saw that there was another post here with a presentation by Jeffrey Armstrong (PrintStar) with the exact same name as this small site I made. Honestly, I didn't know about that when I made this site! I guess great minds think alike or something. Anyways, I would be happy to hear comments/criticism from the small Fortran community here on Reddit :)
It's all good! I actually didn't pick the name of that presentation, oddly enough. Very nice site, and congratulations on the post generating so much discussion on [/r/programming](http://www.reddit.com/r/programming/comments/k58pi/this_is_not_your_fathers_fortran/)!
definitely blas is the way to got, but I mean things even simpler such as c=a + b; where a, b and c are ( d x e x f ... N) matrices. This is handled natively by the language, but is not in c.
Thank you! Apart from the fact that the top comment is about the arithmetic if construct it has been an interesting and surprisingly civil discussion!
I'm learning Fortran as I go for work (I'm a physicist). In particular, my adviser only uses Fortran77, so I'm slowly learning how to do OOP with it. The default constructor is indeed the name with the list of parameters after it. You can create more constructors by writing a function that returns that data type, also using optional arguments if you want. I use type(MyClassDef) instead of class(MyClassDef), and it seems that I can return that without calling it a pointer. Good luck on learning Fortran, I've had pretty good success with it so far! (I learned programming in C++ and Java)
ifort &gt; gfortran
I can't find a good educational price in Canada.
If you are using Linux and its for non-commercial purposes you can get it for free. http://software.intel.com/en-us/articles/non-commercial-software-development/
Mac here, and it is much easier for me to stay mac :P
But academic work doesn't count for non-commercial... it really has to be a hobby, nothing to do with work/school for it to count. 
Thanks - I actually ended up using ziggarat_open_mp from there in the end. But it turns out parallel random number generation is a bit more involved than I realised and this method (of setting a different seed for each thread) might not be ideal. I am just using it for shuffling vectors though so hopefully OK for my purposes.
I agree, I get lots of C library envy. In the world of modern scientific coding, it seems Fortran is a second-class citizen. Doxygen for documenting, Fortran is supported but recently. autotools doesn't handle modules well. IDE? You can hack Eclipse to do it (Photran) [haven't really invested the time to try it though]. GNU Scientific Library? port to Fortran is in alpha.
Thanks for the info!
Probably because the only requirements the type has to satisfy is that it is real, and thus ordinal. Why would it want to put unneeded restrictions? 
Oh - I actually solved the problem now. Thanks though!
Care to be more specific? I have a few intro to FORTRAN books, and I'm pretty sure at least two of them have that exact name.
http://books.google.ca/books?id=EVIKAAAACAAJ&amp;dq=introduction+to+fortran90&amp;hl=en&amp;ei=S8ONTq27MaaLsQKE_MDBAQ&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=1&amp;ved=0CDQQ6AEwAA
The world of programming is driven by fads. Fortran isn't a fad, so it gets ignored in favour of java, javascript, C#.....
Yeah, it's just sad... Especially now that Fortran 2008 is pretty fully object-oriented, with some mathematical functions as well. I'm looking forward to using these features in my work.
In the Fortran 2003 standard the ISO_C_BINDING was introduced as a reliable way to call and interoperate with C code. This could help you as using a bunch of C libraries that you can call using your own C wrappers to use. Just make sure whatever you write is thread safe if its openmp code. Also not sure what compiler you are using but Intel has excellent support, costs money for a license though unless you are using for non-commercial on linux. http://software.intel.com/sites/products/documentation/hpc/compilerpro/en-us/fortran/lin/compiler_f/bldaps_for/common/bldaps_interopc.htm
Ah, curse those macs. if you are ever interested, the Intel compiler does support mac though
Yes it does. But finding any decent price is difficult.
Yea, but the language does it poorly, and not as well as blas...
If it is convertible to f77, then you can do it that way. I don't know how much compatibility there is there.
The few attempts I made to compile FIV/66 code with f77 was rather frustrating, but it was some time ago and I don't remember specifics. I did find a few old MSDOS compilers out there in abandonware land that I may try. If I'm going the emulation route, it would be ideal to implement a PDP-11, but that would probably be more difficult than rewriting and revalidating the code.
You can turn on F66 semantics with the Intel compiler. http://software.intel.com/sites/products/documentation/hpc/compilerpro/en-us/fortran/lin/compiler_f/index.htm The same is probably possible with gfortran
 p=particle( (/1.0,2.0/), (/3.0,4.0/), 5.0 ) I don't like that kind of initialisation. If the order of variables in the derived type is changed, the initialisation will no longer work correctly. 
I'll give this a try, thanks.
I have made a linked list module. In order to store your own type in the list, that type has to extend my base node type. Are you interested in a system like that?
It would be worth looking at.
I'll put it in pastebin, hold on a tic.
http://pastebin.com/iV5MXtUW It works for me, although it is a bit hideous. I've just hacked together that example now, haven't checked if it actually works, but that's roughly how I use it.
character(20) pure function fizzbuzz(n) integer,intent(in)::n write(fizzbuzz,'(i)') n end function EDIT: http://pastebin.com/mLy7Sfz3 
Tip: if you start a row with 4 spaces it is formatted as code, e.g. character(20) pure function fizzbuzz(n) integer,intent(in)::n write(fizzbuzz,'(i)') n end function
Cheers 
F2008 has something called "pure"? What does it do exactly, does it really mean no side effects? That is probably too good to be true.
To ensure that two points wont lie close to each other, you check the distance between them with Pythagoras theorem. Since you are picking points at random, this might lead to you picking a point, checking it, and having to repick, picking an unusable point again, and this could theoretically go on forever. One fix could be to make it semi-random, by choosing some aspects of the random generation-process. The martsve-method goes something like this: dim = 3 ! 3 dimensions w(1) = 1000.0 ! cube of 1000x1000x1000 w(2) = 1000.0 w(3) = 1000.0 dl = 10.0 ! minimum distance between coordinates dw = sqrt(3) * dl ! distance in three dimensions do i = 1,dim n(i) = int(w(i) / dw) ! number of possible points in each dimension for j = 0,n(i) x(i,j) = dw * j ! evenly spaced points in each dimension end do call randomize_vector( x(1:n(i),i) ) ! randomize the order of the points. This step needs to be implemented end do np = 10 ! number of points do j = 1, np p(1,j) = x(1,j) p(2,j) = x(2,j) p(3,j) = x(2,j) end do I think this should give you a somewhat random distribution of spaced coordinates :)
If you want them to be actually random, then you need to not ensure that they are far away from each other. This imposes correlations on your numbers. If the routine is actually uniformly random, then given enough points, they will be even distributed.
Pure is just a note to the compiler that the function should not modify anything. 
Thanks! I've really been learning a lot from this Fortran 90 tutorial: http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/fortran.html
Very nice, thanks!
Here are a couple of links I like: http://fortranwiki.org/fortran/show/Object-oriented+programming http://www.fortran.com/f08_std.pdf 
Much appreciated, thank you.
Fortran's not too hard. Are you on Linux or Windows? If you pastebin a snippet of the code, we can determine what version of Fortran it is.
I'm on windows. Thanks! Also I've added a bit of the code above.
I would suggest downloading cygwin - and getting the mingw compiler ( they have a fortran compiler ). I believe you will want to download the gcc4-fortran package. The installation of cygwin may not be straightforward - you will want to select customize and then scroll to 'devel' or 'development' and find the 'gcc4-fotran' item. Click it once to select it. The continue with the installation process of cygwin (It will then say you need like 40 dependencies for the compiler, allow it to install them). If you're able to get that working you should be able to compile the source code into an executable. Open up cygin and us 'cd' to get to the directory with your source code (you may have to initially just type 'C:' at the prompt to switch to the C: drive). Once you're in the directory you should just be able to do : gcc4-fotran yoursource.f -o someExecutable.exe It will may be easier to try to compile it in fortran than translate it directly to matlab. How long is the source ? 100 lines? 500 lines? ? ? If it is less than about 100 lines you could just post it on pastbin and someone could translate it pretty quickly (I could most certainly do it as long as I'm not too drunk by the time you post it). 
It's definitely old code, should be Fortran 77 standard. I recommend following fgriglesnickerseven's advice and using cygwin.
You need to pastebin it, or format it so it's readable..
This is fortran 77, so the old gcc compiler will work fine: http://137.227.242.23/software/g77.html 1. Extract it to a folder. 2. Open a command prompt 3. CD to the folder you extracted g77 into 4. Enter "g77setup.bat" 5. Enter "g77 YourSource.f -o test.exe" That is all :D
I use [geany](http://www.geany.org/) as my Fortran IDE, it's not quite Eclipse but it's enough for me.
I'll try it out. Thanks!
Will probably be another decade before it is fully implemented by anyone.
Yep. Intel is the furthest along. http://fortranwiki.org/fortran/show/Fortran+2008+status I start to use the features as I want them and as they are available, so I am already reaping the benefits of the specification.
I have started taking up C++ because of the features it has over Fortran.
[Modern Fortran expained](http://www.amazon.com/Explained-Numerical-Mathematics-Scientific-Computation/dp/0199601429/ref=pd_rhf_cr_p_t_3). I have the previous version (Fortran 95/2003 explained), and I think it's quite nice. Not seen this new version, though.
Sorry that your message got caught in the spam filter and I did not see it earlier. I am sure that you have figured this out by now, but maybe someone else will benefit from it: it is likely due to end-of-line characters. Notepad++ has a way to convert between UNIX and Windows (and Mac) format, just go to: Edit =&gt; EOL Conversion =&gt; Windows Format and Windows apps (like MS Notepad) will work. If next time your post does not show up, shoot me a PM and I'll get it approved!
Actually, I had no idea it got caught in the spam filter, but thank you very much for the response. I had figured out that my compiler was having issues with the UNIX/Windows divide, but I hadn't yet figured out a solution. This, however, works wonderfully. Thanks!
There are *program units*, which are either the *main program* or a *module*. A module is a collection of data and procedures, similar to a class with only static fields in Java or C++. The main program is, well, the main program. A program unit can contain *procedures* (also called *subprograms*), which are either *functions* or *subroutines*. These are called internal procedures. Additionally, procedures can be external, i.e., not associated with any program unit. The Fortran standard seems to use the words *procedure* and *subprogram* interchangeably. `private` and `public` change the visibility of a name exported from a module. The default is `public`.
I think that makes a lot more sense. Still not too sure about public and private though. Currently i have a bunch of subroutines in an external module file. Would I not be able to call those subroutines from my main file if I changed them to private? Where would I be able to call them from?
That is awesome! 
This is not clear why this is a fortran specific question
Haha, I saw the same car last week. I took photos as well. Has to be a redditor.
Thanks alot! I just ended up having to rewrite stuff to get it to work. I randomly found this subreddit and will subscribe to help other if need be.
I primarily work with C++, but have an interest in Fortran. I am curious what causes you to use it specifically.
This was the backtrace: #1 0x0000388d in bisection_ () #2 0x00135812 in _gfortran_st_read_done () #3 0x000026e9 in MAIN__ () It was trying to read memory that wasn't allocated to it - what you're doing with passing f as a function is incorrect ( i think ). Anyways I changed it so it 'seems' to work: REAL :: f, root changed to REAL :: root bisection(f, root1, a, b, ercodee) changed to bisection(root1, a, b, ercodee) and REAL,EXTERNAL :: F to REAL :: F Hopefully that helps?
Thanks! i ended up having to rewrite a bunch of stuff. Yeah you were correct. I wasn't passing things into the function correctly and didn't have memory allocated correctly. I figure it out with some help. Upvote for you.
Is it an absolute that a compiler can enforce, or something you can ignore in some situations? An example in another language I am much more familiar with, is a 'const' member in a C++ class cannot modify anything in the class unless it is marked with the mutable keyword.
Yeah thats why I'm glad to take fortran first because it shows how things were but I will probably take some C++ classes from the computer science faculty too.
The standard says it shouldn't be ignored, but I'm not sure if every compiler enforces it.
Great suggestions! To which I'd like to add: *Root finding : bisection, Newton's method, False Position. *Least squares fitting: Will require an optimization method as well.
Have a look at [Project Euler](http://projecteuler.net/problems) for lots of good problems, but they do get hard very fast and end up being more about the mathematics then the programming.
Stupid question: what do you mean by numerical solver? When I googled it, results came up with programs that solved algebraic equations. Something like that?
There are no stupid questions! H_Blackstone gave a few very good ideas for numerical problems (such as bisection, and Newton's method: [Numerical root finders](http://www.efunda.com/math/num_rootfinding/num_rootfinding.cfm)). Essentially these are finding the zero's of a function when you can't do it analytically. Each new guess is based on the previous guess. I would start with a problem I know how to find the roots analytically (such as: x^2 + 4x + 4) (root: -2). Then create a program that will find the root with the numerical methods stated above. If you have anymore questions, I'll be more than happy to help.
Ok, I have a good idea of how I would do the quadratic equation program. Just prompt for a, b, and c and plug those values in. However, it seems like this is too much of a simplification if I want to find the roots of more complex equations using the above mentioned methods. Is there anyway to allow users to input a symbolic equation like "y^3 + 4y^2 + 2y + y + 4", and turn this into something workable? I don't want to take shortcuts just because it is easier now. Thanks for your help, it is greatly appreciated.
I read this question a while ago and just came across the solution! You have to initialize the pointers to null() for them to be disassociated. Your code should read, for example: TYPE (real_value), POINTER :: p =&gt; null()
http://en.wikipedia.org/wiki/Numerical_methods They are used for solving PDEs which are intractable analytically and other such tasks.
&gt; Are fortran array operations [like a(:) = b(:) * c(:)] automatically split between processors if I use an MPI compiler? No. You have to do that manually. &gt; Also, is it possible to perform array operations on elements of derived types? Yes but what an operator does to the underlying structure is not defined. You have to overload operators for the structure such that the appropriate transformation is made. Look up fortran operator overloading, and arrays of structures in fortran and you should get your answers. Also don't try any of this if you have to adhere to f77
Sorry mate, you got caught in the stupid spam filter!
This is awesome :)
I really like your username, good on you mate :)
If you changed them to private, you would not be able to call them from outside the module. You could call them from inside the module. You should always make things private (in my opinion) unless there is good reason to share them. This lets you split the module into "subroutine main_important_bit_of_code" and "subroutine helper_code" and then expose only the main_important_bit_of_code to the outside world. Because if you made the helper_code accesible from outside, people could call it and mess things up. It also keeps the namespace nice and tidy. What did you mean by "strong programming background"? Most languages have these things, perhaps I could draw some comparisons with what you are familiar with?
Like being about to type a function declaration in less than 10 lines. The verbosity makes me weep sometimes...
if I declare it intent out, this error occurs when compiling, final_project.f90(64): error #6420: This array name is invalid in this context. [ACCLR] real, dimension(0:4), intent(out) :: acclr -------------------------------------^ 
You also need to declare acclr as an argument of your subroutine e.g. Subroutine acceleration(V, t, n, acclr) You should probably declare n as intent in too
That makes sense but my value for acclr is still 0. Sorry I am not the greatest at fortran. We did MATLAB all semester than our final is in fortran after a couple lectures. Earlier I declared arrays by: open (unit = 1, file = "data.txt") do i = 0,n read(1,*)t(i),v(i) end do Is there a way to model this? 
If you put four spaces before each line, reddit will format your code to look like code. Here's a slightly fixed version of what I think you're wanting to do. SUBROUTINE acceleration(v, t, n) IMPLICIT NONE REAL, DIMENSION(1:6), INTENT(IN) :: v, t REAL, DIMENSION(1:4) :: acclr REAL :: n, i, y DO i = 1, (n - 1) !Note that this equation equals 1. y = (-3 * v(i) + 4 * (v(i) + .1) - (v(i) + .2)) / .2 acclr(i) = y END DO END SUBROUTINE acceleration I'm not sure why you've declared acclr to be a different size than v and t. If they were the same size, though, you could change the entire do loop to: acclr = (-3 * v + 4 * (v + .1) - (v + .2)) / .2 or acclr = 1. In any case, note that you were starting the array at 0 and the loop at one. Inputting n instead of using the SIZE function also makes segmentation faults a lot easier and makes the subroutine that much harder to use. Also, subroutines will not return values when called; you have to use a function for that.
I have to fill the last and first part of the array using a different equation. V is an array with values from 0 to 1675. I need acclr to be an array it a value for each of the v values. I made a lot of changes because I was using the equation slightly wrong and had to change a value for a variable. Here is what I have. Subroutine acceleration(V,n,h,acclr) implicit none real, dimension(0:6), intent(in) :: v real, dimension(0:6) :: acclr real :: i,y,h real, intent(in) :: n do i = 0,n if (i == 0) then acclr(0) = (-3 * v(0) + 4 * v(1) - v(2)) / (2*h) elseif (i &lt; n) then y = (v(i+1) - v(i-1)) / (2* h) acclr(i) = y else acclr(n) = (v(n-2) - 4 * v(i-2) + 3 * v(n)) / (2 * h) end if end do end subroutine Acceleration It compiles fine but when I run it I get this... forrtl: severe (174): SIGSEGV, segmentation fault occurred Image PC Routine Line Source a.out 000000000040300A Unknown Unknown Unknown a.out 0000000000402A9C Unknown Unknown Unknown libc.so.6 000000354061ECDD Unknown Unknown Unknown a.out 0000000000402999 Unknown Unknown Unknown 
If you're not familiar, a segmentation fault is what happens when the program tries to change data in memory not allocated to it. It happens almost exclusively when you try to change an array at an index outside its range. In the case of your program, it's happening when you assign to either acclr(i) or acclr(n). Why are you inputting the value of n? Unless there's a good reason, you should find another way to do that; as it is, if you input a value higher than 6 or equal to 1, you will get a segmentation fault. This whole subroutine is really weird and roundabout; what exactly is it supposed to do?
just don't try to work with classes... Name mangling becomes more convoluted then
Thanks for the help. I dual-boot Windows and Ubuntu, so I guess I'll give that a shot. &gt; gw-fortran your_file.f90 -o your_compiled_program Would something of this nature work on Ubuntu, or is it Windows-specific? Thanks again.
nope - on linux its pretty much the same but change the compiler name ( could be gfortran, gfortran-4.x, or something similar ). On ubuntu to install the compilers I think you have to run something like : sudo apt-get install build-essential and sudo apt-get install gfortran That will get you make along with C, C++, fortran compilers ( I think ). also I have observed (new) people like gedit (kind of like notepad++ for linux) and I think that's the default for ubuntu. It may be worth investing some time in learning vi/emacs (both text editors)- just note that vi is on probably all of the systems you will use by default, whereas emacs may not be. I personally prefer vi, but it does have a learning curve.
Gfortran on Linux is very easy to use; Simply install using your given package manager (might be looking for gcc-fortran or something of the sort) and also install a text editor. Others have suggested [Notepad++](http://notepad-plus-plus.org/) but I prefer [Sublime Text 2](http://www.sublimetext.com/2) with the [Fortran textmate bundle](https://github.com/textmate/fortran.tmbundle.) When ready to compile, just head for your working directory and do "gfortran [file.f90]" (Or whatever fancy compilation options you need.) You might want to give [IFortran](http://software.intel.com/en-us/articles/non-commercial-software-download/) a chance if your employer will be providing it later. A single seat costs hundreds of dollars, but you can use the Linux versions of their software for free for personal use. (So you'll have to ditch it once you start coding for your employer.)
Congratulations! Welcome to Fortran.
Have you declared detrenumber?
Get rid of the space before the ampersand? I'm using 90. That's how I got this to work (compile, rather): PROGRAM test INTEGER, DIMENSION(100) :: array array=(/30,29,28,27,26,15,14,13,12,11,25,24,23,22,21,10,9,8,7,6,20,19,18,17,16,5,4,3,2,1,1,1,&amp; 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,&amp; 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1/) END PROGRAM test I think you just need to lose that space.
&gt; It sounds like I am using fixed-form, though I can comment with both c and !. Yes, you're using fixed-form. You can probably comment with any character, as long as it's in the first column. &gt; If I remove the ampersand on the second line, it turns either the 1 brown or the ten blue (I don't know what that means). I don't see an ampersand in the screenshot you linked to. Notice how the COMMON/GCFLAG/ line is continued, with a '+' in the 5th column? That is how you should continue lines in this code. I hope that helps.
I use vim (I guess I just lost your attention there :D). Fullscreen window, vertical split, one f90 source file in each split. I use the tagbar plugin to quickly browse through open files and a little vim script to capitalize everything except string constants, since I find code in capital letters easier to read. I have an alias (,m) which launches the cmake build process. No need to leave the vim window (!) or to change to another split. When the build process finished, vim waits for you to press return. So you still have a chance to look at the compile warnings/errors. I have a second window in some other workspace where I try out whether I'm coding reasonable stuff or just building bugs in :) Happy fortranning!
Emacs, I just swap to a terminal to run stuff though.
gvim + terminal window. No big complications here.
I'm using [geany](http://www.geany.org/) fullscreened with a terminal window in another desktop.
Sublime text + guake + textmate fortran bundle After learning about quake-style consoles, I'll never go back.
Vim in a terminal and TotalView for debugging.
I use Plato. Seems like I'm the only one :(
[Eclipse Photran](http://www.eclipse.org/photran/) along with autotools (autoconf,automake...) plugin
It might help if you provided the code in question. If they're just six statements, that should work perfectly fine. If the syntax is confusing, you could put them into six different functions that return a boolean.
Or alternatively if((pos(1,ix).gt. 0.4*xl .and. pos(1,ix).lt.0.6*xl).and. 1 (pos(2,ix).gt. 0.4*yl .and. pos(2,ix).lt.0.6*yl).and. 2 (pos(3,ix).gt. 0.4*zl .and. pos(3,ix).lt.0.6*zl)) go to #### It must indeed be an aged professor suggesting the use of a `go to` statement! **Edit** there i fixed it
I'd probably replace the line with a function as it looks pretty messy to me. I don't know F77, but it would be something like: IF (specialPosition()) GOTO 2002 FUNCTION specialPosition() logical :: specialPosition IF(pos(1,ix) .GT. 0.6*xl .AND. pos(1,ix) .LT. 0.4*xl) THEN specialPosition = .FALSE. RETURN ELSE... etc. I'm not sure about the order of operation of the .and. operator whether it evaluates every expression, but you could possibly get better performance by nesting it like that. 
Does .and. work outside the IF() parenthesis?
It's just the way you wrote it was: IF((condition .AND. condition)) .AND. ((condition .AND. condition))
Yes I did. I go edit now.
Thanks. I was getting really frustrated when negative numbers were being outputted. 
An integer multiplied by an integer is also an integer. But in most languages/architectures, integers have limited representational range. When you go too far out, wrapping around into the negative side is a common failure mode due to the way that negative integers are represented. A floating point number (what fortran is calling "real" here) of the same size (in bits) as an integer can represent larger numbers than the integer, but at a price: the value is only an approximation. At very large values, you might find that adding +1 to a floating point value does not change the bit pattern at all. The distance between one floating point number and the next can be larger than 1.
compiling with gfortran (GNU Fortran (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3), I get an error: testalloc.F90:21.15: CALL reallocate(a,5,5) 1 Error: Dummy argument 'a' of procedure 'reallocate' at (1) has an attribute that requires an explicit interface for this procedure When I put the subroutines in a module and "use" that module in the program, so that interfaces are automatically created, the program works as you intend.
Visual Studio 2008
Allocatable arrays are for chumps.
Please go on?
Cool thanks, have you any idea about whats happening underneath that stops it working the way I implemented it?
If your compiler was compiling the code in your pastebin without error, then it was a compiler error. I think with allocatable arrays, they need that interface, so that the program can check and verify that the argument types that are passed are the argument types that the function wants. Fortran doesn't automatically do that unless you have an "interface". You can type one explicitly, or just stick the function/subroutine in a module, in which case it generates the interface automatically. So, to be safe, always put your subroutines inside a module.
Thanks! That was simpler than I expected, and it seems to work very well. Bonus question: Is that a standard way of doing things in Fortran? Though I've used Fortran for about a year now, I haven't seen much example source code outside of short textbook examples.
I think it's a good way to do it and much cleaner than passing countless variables through the program. Thanks for the insight!
gcc is a collection of compilers, of which gfortran is a part, but can also refer to the c compiler of this collection. Either way there shouldn't be a conflict. Maybe a second set of some library files were installed to a different path when gfortran was installed and you came out with a second libgcc_s.1.dylib file? For example, maybe gcc installed to /usr and gfortran installed to /usr/local. Also, this is a warning, so the file should still compile though it may or may not work properly.
That is a warning which shouldn't stop compilation. I don't think this should be a problem.
I use macports to install it. If you need MPI support do: sudo port install mpich2 +gcc44 That will install gfortran anyway. In my opinion xcode isn't really suitable for fortran. You'll save yourself headaches just using Makefiles and a text editor.
you will love it until you try to uninstall it and you find pieces of it left over all over /usr/share
All the fortran codes I've seen use this style of sharing data. Usually subroutines are kept inside modules too, so the use Global is written once in each module. Also if you're initialising lots of variables at the start of the program I suggest using a namelist. They are super convenient. 
Nice interview. I tried to teach myself C++ last week. When I saw that you had to operate on arrays element by element I ditched it. Still loving Fortran.
Always pick the right language for the job. When I need to do string processing, I use awk and sed or ruby. When I'm working on web applications, I use JavaScript. When crunching numbers, you can't beat Fortran. The language was designed for this purpose and is still be best. For one thing, there's native support for multi-dimensional arrays. For another, the rules of the language give the compiler insights necessary to perform very good optimizations. Fortran is the language of choice for most of the HPC industry and I don't see that changing any time soon.
Can you put the "implicit none" under "program test" rather than the subroutine and try it? I'm not near a computer right now. If that doesn't work, try putting before contains. 
You can create a module containing a variable. i.e. module globals real :: x end module globals then when you want to alter or use x, put a use globals statement into that subroutine or function.
Use a common block instead? I jest of course, don't use commons if you can possibly avoid them. Your solution is sort of like the "globals" in MATLAB, where they're only accessible where declared. This gets you part of the functionality of commons or C type globals, without a lot of the headaches that come with them.
Here's one simple solution: MODULE test_mod IMPLICIT NONE INTEGER :: x CONTAINS SUBROUTINE test_sub IMPLICIT NONE x=1 END SUBROUTINE test_sub END MODULE test_mod A word of warning, though: Think twice when using global variables if they are a good choice for the situation â€” they can make the code hard to understand, and they can make the life of the next person trying to understand the code miserable (and that person can very well be future you, who would very much like to have a time machine so that he could come back to slap you). 
From [this discussion](http://software.intel.com/en-us/forums/topic/270242) it appears that Intel Fortran does not have a way to detect integer overflow. I have no idea what you're trying to accomplish, but would floating point math be sufficient for your needs? You should at least be able to tweak the behavior and error generation properties of the FPU.
Thank you. I had thought I was computing a running total of integer1 * integer2, but it turns out that I was computing a running total of integer1 * integer2 * floating3. So floating point math was more appropriate anyway. But I was still curious about the integer overflow. (I know the double precision will overflow to infinity around 1E+308, but my running total should never get *that* high.) 
I've never gotten an overflow error in any compiler. It just rolls over and goes to negative. Actually, I'm using a random number generator right now that relies on this overflow.
I don't know about the microsoft compilers, but in gfortran I use the compiler flags: -ffpe-trap=invalid,zero,overflow,underflow to detect all my floating point problems, NaNs etc.
Why not use a c-library and call that from fortran?
Agreed, I believe this is the only way. You can implement your own SHA-256, but it probably wouldn't be as fast as the optimized C library.
 age = (Date_of_retirement - DOB)/365.25 if ( (age .ge. 55.0) .and. (age .le. 65.0) ) then ! do stuff endif I like putting the condition that I'm testing as a named variable that means something to someone else looking at the code, then check directly against the criteria. In a more general sense it's probably better to have the 55 and 65 as variables too. Edit: Not sure what your date format is, so the age calculation may be wrong. Test that.
How would I set the Date_of_retirement variable to 1/1/2012? Thanks for your help so far!
Using reals to hold numbers of days is asking for trouble: Date_of_retirement will lose precision if it's single precision and the value is at least 115 years worth of days. Since you're only interested if the difference lies between 55 and 65, truncation won't hurt you, so why don't you just use integers?
Not knowing your previous background. I would recommend Stephen J. Chapman's book "Fortran 90/95" for Scientist and Engineers. Granted I don't know your chair uses 90, I'm just assuming. If you already have source code and want to know what does what, this book will be all you need for modifications. 
This is as good an answer as any without further info.
The learnprogramming thread seems to think this is a troll post. I was hoping to discover Embedded Fortran, but that doesn't seem to exist (yet!).
Good answer but why would a wheelchair be programmed in fortran? Also &gt;wheelchair &gt;right track Rdrr
Meh. I didn't know if some private contracting company had utilized fortran for some complexed vector manipulations for movement or something. Also... I now see why that would be way outside the scope of a beginner :-/ 
The code samples in the article are "Magic Happy Fun" language. It is similar to Fortran, but it isn't quite Fortran. 
Oops, you are right - good catch. They use `NUMBER` instead of `REAL` or `REAL*8` and `^` instead of `**`. And the logical operators `.gt.` is written as `&gt;` and so on. The control structures and program structure are strongly reminiscent of Fortran which led me astray...
In the biology and physics community there is increasing use of C/C++, though in geoscience, chemistry, and chemical engineering Fortran is still widely used (that's just the sample I have available to me). I thought to consolidate my efforts into Python (for text processing and shell scripting, and simpler numerical calculations) and Fortran (for intensive calculations) but the indexing convention (zero vs one) mismatch between the two throws me off sometimes.
Actually, I believe the Fortran 90 (and higher) standard allows &gt;, &lt;, etc. rather than having the dot-text-dot operators. What gave it away for me was the hash sign as the comment operator rather than an exclamation point (or C with a fixed format layout).
Fortran 95 i believe includes pointers and targets. This would be the preferred way of coding graph data structures. 
That does actually make a lot of sense, so the read statement reads the entire line, i just have to tell that to then put that into my array from that? i.e one read command should fill an entire row of my array? 
Seeing as im just beginning this project i probably will. The main aim is to use that data file which is 2 exponential decays combined, i have to find out their parameters A,B,y1,y2 using that data file and a least squares method to minimise Chi squared. Im pretty sure ill be back for more help soon!
OK, here's some hints: 1) Why are you using fixed form source code? Unless you're gonna hand in your assignment on punch cards, there really is no excuse for that. Just get rid of the extra columns at the beginning and change your comment markers 'c' to an exclamation mark (and save your file to a .f90 extension) 2) Another general coding hint: never ever copy and paste code to repeat it. These four loops at the end could be replaced using an extra loop on the outside: do j=1, 4 do k=1, 4 do i=1, 17 jacM(j,k) = jacM(j,k) + .... end do end do end do 3) Values that are repeated should be only set once. It's nicest to do this with fortran parameters. So instead of having the 17 all over the place, add something like: integer, parameter:: N=17 somewhere at the top and replace all your 17s by N. That way the code becomes more readable (you can add a comment to say what N means) and you only have to change it in one place. 4) Right, now my pedantry is out of the way, let me actually answer your question: have a close look at your formula for the matrix-matrix multiply. If you look at what's added into your matrix, on the rhs of each assignment to jacM(...,j), you'll notice that nothing there actually depends on j. That means for each column j your adding the same thing. This can't obviously be right and explains you seeing the repeated values. 5) You forgot to initialise jacM. You only add to it, so you seem to assume jacM starts out being zero which in fortran you can't rely on; It can start out having any arbitrary value, although sometimes you're "lucky". To zero all the entries of jacM at the start, you don't need to write extra loops, you can simply write: jacM = 0.0 to assign 0.0 to all entries of jacM \*) Now for a bonus: although writing out the matrix multiplication by hand is probably a good exercise, there are actually fortran intrinsic functions that can do that for you. The function matmul(A,B) takes two arrays and performs a matrix multiplication A\*B. So all of the second half of your code could be replaced by a simple: jacM = matmul(jac, transpose(jac)) Here, I've also used the *tranpose* function, which gives, as you might have guessed, the transpose of an array. Good luck!
Thanks for the help, although i believe some of what you said applies to fortran90? And im using the 77 revision, does the matrix functions exist in 77 as well? Ill try fixing this code now though.
Ah yes. If you *must* use fortran 77, then there's no matmul or transpose indeed. Just ignore 1), 2) and *) You'll have to allow me a little rant though :) The thing is there is really no good reason to write fortran 77 code: all fortran 77 code is a subset of the newer standards (except for some antiquated bits you'll never come across) and pure fortran 77 compilers don't even exist anymore. Whoever is teaching you this should be ashamed of him/herself. The reason I care is that fortran is a very nice programming language, but it's hideous, prehistoric code written by people who should now better (I mean your teacher) that give it a bad name.
They completely agree, but unfortunately we have to learn as a lot of code is legacy written, so we have to learn to read it. Its not a bad language for beginners, but not one i would have picked. Also i tried the matmul function and transpose, and as far as i can tell. they work? Which is odd.
Yeah, that's because your compiler is not a fortran 77 compiler. The only difference between a .f file and a .f90 file is the indentation style (punch card style with c comments vs. "normal" indentation). In both styles you can write as much fortran 77 or fortran 90 as you like. That's why I don't buy the legacy argument: if you want to learn fortran, *I think*, you should learn modern fortran first. Reading legacy fortran 77 then won't be a problem, and any code you modify is trivially converted to the new indentation style.
Perhaps, im using gfortran on my local computer, i guess i should check if it also compiles on the network at University, but thanks for you help. Do you have any general pointers on whether this method should give me a fitting for the data?
If you want to force gfortran to conform to FORTRAN 77 standards so that matmul and transpose don't work, you can add the flag "-std=legacy" to the compiler command line. Seems somewhat silly, though. I learned Fortran 90 back in school and got a job right out of school where we worked on an enormous FORTRAN 77 code base. It was easy enough to understand. However, I just treated it as fixed-format and continued using Fortran 90 (and higher) intrinsics. Nobody cared. You'd be hard-pressed to find a system that didn't have a compiler that implemented Fortran 90 if it has a Fortran compiler at all these days. EDIT: this comment probably should have been a reply to your previous message...
You should not use `REAL*8` or `.gt.` in modern Fortran either. And also `REAL` only for special purposes if you really want just that.
Nailed it... Now to sort the other issues with the make. Segmentation faults galore.. Yey!
not sure, its on a VM so I can add resources as needed but its just not taking advantage of what it has. 
What OS are you using? Any chance you have dualcore cpu or hyperthreaded single core?
Windows 2008 R2, VMware with 2 processors
You have two cpu graphs which means you can only get up to 50% of total computer resources with a single threaded program.
so would you think the app is not multi-threaded then?
two processors. not sure if it was written to run in parallel, I mentioned in another comment I'm just the sysadmin not the one writing the code, it was supplied by the 
If you have two processors, unless YOU do special things to make it run in parallel, it will not, so you will always be at 50%. Did they provide you the code or just an executable. If they provided you with code the easiest thing would be to recompile it using -fopenmp (for gnu compilers) or -openmp (for intel compilers) I cant remember the command for the Portland one but you can look it up easy enough. That will enable openmp so if it was written to be threaded that way then it will work. More likely it was written using MPI, which means you need a whole lot of other stuff to get it to run in parallel. I spent my entire masters degree rewriting a particular FORTRAN code to run in parallel efficiently, it is usually not an easy task but something can be made parallel easily. Anyway if you have two processors, you wont get more than 50% usage with just a single program.
thanks :)
It's unlikely if it's an old program.
Compile with floating point trap options, to see if the program crashes when dividing by zero or some other illegal numerical operation. Run with valgrind to see if it tries to use unreserved memory.
Where is your main program? Do you have a Makefile?
I have an up to date version of gfortran , a fresh and fully updated install of Ubuntu. The ctri.o and crt1.o files are not something I have written. Thank you for taking the time to help. 
I included the main file in my original post. I have been compiling it with bash scripts in terminal, I do not know anything about how to setup a make file. Would this be a good idea to learn how to do? 
I mean you don't have a driver program eg: PROGRAM main USE mymodule ! stuff... END PROGRAM main I've had a quick look and I suspect that maybe one of your subroutines wasn't terminated properly which means that some of your functions have been defined inside it.
All the subroutines are currently unedited from the previous version of the code that worked for FORTRAN 77. All that has changed is that I have put them into this module so I do not have to worry about them in the main program and have more freedom in what I can do. These are the commands I have compiling everything with: gfortran -ffixed-line-length-none MAIN_DRIVE mod_lib.f95 mod_constant.f95 MAIN_DRIVE.f95
You're redefining function names inside subroutines. I'm confused as to why this didnt generate a compiler error though. In orbel_fhybrid delete the line: real*8 orbel_flon,orbel_fget and in mco_el2x delete the line: real*8 mco_kep, orbel_f_hybrid, orbel_zget This allowed it to compile for me.
I did not write this part of the code so I had no idea what was going on there. I will try removing this part and seeing if compiles. I will let you know the results. 
This allowed some of the "errors" to go away , thank you for the help. I have updated my original post.
Well the thing is that with the .NET application it did not work on the web, but only on the machine the program was originally developed on. I would like to use either PHP or python but I don't think it will work properly with those languages. Quick recap of the program. It runs as an .exe and takes user input, then takes that input and processes it by going from C# code to VB code then to the Fortran code. If I am missing something and could run this with PHP that would be excellent but all the sources I have looked at I would have had to register the DLL's and that step has failed for me.
If the C# and VB code is not too complex, I'd tell you to rewrite it in Python. There are lots of resources on using Python and Fortran together, e.g. [Python: Interoperation with Fortran](http://www.ucs.cam.ac.uk/docs/course-notes/unix-courses/pythonfortran).
It is many lines of code so rewriting it is probably out of the picture, but I was thinking of using python I just need to figure out how well they work with c# and vb dlls. 
Thanks for that, I tried iron python before but got lost. That command seems like it is what I want but is there a documentation file or reference that shows the dll interaction commands?
Here you go: http://ironpython.net/documentation/dotnet/ 
How are you monitoring CPU usage? If you are on *nix and using `top` then the value will be the usage for all the cores. Try `htop` that will show you what percent of each core you are using. If you are only using one core, then you are going to need to parallelise the algorithm if you still wish for better performance. If you are not using the cores effectively (ie. 50% of each core) look to see if you are preforming any IO, be that file, network or to the console; try and reduce IO as much as possible, especially inside loops.
Thanks, I've been trying to add a simple test dll but keep getting an error saying how it is not a valid Win32 application. On a side note, is there a way to test for file dependencies errors? Because the asp.net code runs perfectly on the machine the original code was written but when I tried to run it on my machine I kept getting errors in the Fortran part. And when I went to show disassembly I saw a file path location.
That's odd, maybe the DLL is missing a dependency too. If you wish, host the DLL somewhere, send me a link and I'll try to take a look. For the Fortran EXE, you can use [Dependency Walker](http://www.dependencywalker.com/). You may need to install the Fortran runtime from your compiler. 
The thing is that it is just a simple vb script compiled into a dll that calculates volume of a cube based on three inputs. So there should be no other dependencies. I have tried that program and got errors when I test the dll of the original code that I add as a reference in the asp.net app Error: Modules with different CPU types were found. Warning: At least one delay-load dependency module was not found. Warning: At least one module has an unresolved import due to a missing export function in a delay-load dependent module.
I'm not sure what compressed binary is but is just plain binary good enough? OPEN(unit=10,form='unformatted') 
It means the data is compressed (essentially via zip) before it is written. This leads to large savings in data storage, and the files can be read by visualization programs without having to decompress (and store) a *.zip archive. Currently, my outputs from a single simulation can be as large as 100 GB, so compression would be very useful. It looks like I will probably have to interface with some C libraries, which I have not been looking forward to....
This isn't much help. but I can compile and run it just fine without any changes. What did you name the source file and what are you compiling it with? I made it f90 source and compiled with gfortran. Edit: Can you try compiling/running this instead and post the output? PROGRAM w implicit none integer :: i, j, F(1000,1000), n Open(10, file="socialdata127.txt") read (10,\*) n write(\*,\*) "Number of Lines: ",n do i = 1, n write(*,*) "Reading Line: ", i read (10,*) (F(i,j), j = 1, n) END Do close (10) END PROGRAM w 
I'm using fortran 90 with Scite as a editor (have to use those two). I named my file "socialdata127.txt"
Ok, I fixed my code (some starts were missing). Can you try it with those two extra write statements and tell me what you see? Edit: I have to leave for a while. Here are my guesses: 1) Your input file is not in the same directory as your compiled executable. 2) There is an endline missing on a line of your input file.
Ok, hmm. What is your platform?
Window 7 
You could change the line Open(10, file="socialdata127.txt") to contain the complete path to your input file. Something like Open(10, file="C:\socialdata127.txt") depending on your OS.
I tried that along with C:/desktop/socialdata127.txt . Maybe it's problem with the Scite 
If you put 4 spaces at the beginning of the line, Reddit will format those lines as code. Like: this is code. this, too with more than 4 spaces, you get indented code lines this line again with 4 spaces
Perfect solution, let us know basyt if you are still having trouble!
thank you, i just want to know if i need to write some include(like in C, when importing an external library) statements. bit green at fortran and need all the help i could get. i tried looking at the lapack documentation and i still have a headache. is there any hope of finding a tutorial or documentation that is a bit less confusing. i forgot to say that of the two matrices B is actually a column vector(as arises when solving for Ax=B) what routine should i use to solve this and get x?
Is A dense? If so, I believe you use dgetrf to factor A and store LU. Then you can use dgetrs to solve.
Not having read that big document, what you are seing could be [implicit typing] (https://en.wikipedia.org/wiki/Fortran_language_features#Implicit_and_explicit_typing).
No problem.
Playing around a bit, explicitly requiring three digits for the exponent in the format seems to help, eg. (e15.7e3). 
I've run into this myself, it seems to be a limitation of the file write routines (Intel Fortran 12.x here). In my simulations none of the physical variables can really be that large or small, so I simply capped the output at e-40 and e+99. One easy solution would be to call the sed commands from your MATLAB postprocessing scripts directly before reading the files (using the 'system' command).
The default width of the exponential field is going to be 2 digits. See: [http://www.fortran.com/F77_std/rjcnf0001-sh-13.html#sh-13.5.9.2.2](http://www.fortran.com/F77_std/rjcnf0001-sh-13.html#sh-13.5.9.2.2) A few things are problematic in this case. Looking at the exponent you're using, you're getting #.#######+###. First of all, you've specified your field should be 13 characters wide with 7 digits after the decimal. Also, you want your exponent to be 3 digits (which is necessary). Also you have the decimal place, the digit preceding the decimal, and the sign of the exponent. We're already at a necessary width of 7+3+1+1+1=13. We also need the sign of the number, so we would need a minimum width of 14. Additionally, the output you're seeing is perfectly acceptable in terms of Fortran standards. You need to specify the width of the exponent manually, like [this comment](http://www.reddit.com/r/fortran/comments/1a3m5l/problem_with_very_large_exponents_in_fortran/c8tshoe) suggested, and you need to specify that you want to see the "E". I would suggest a format of (e15.7e3) just like he/she said.
I use raw binary like imsittingdown mentions. It takes a lot less space than plain asci. Would compressing the binary data be worth it? I doubt you can get more than 50% compression without losing precision.
A function basically takes in some values and returns a value. In this case, you're going to have a function for each equation that lets you plug in an x, then returns an f(x). Beyond this, there's a lot of IO and such. Not sure what else you're not clear about; you're gonna need to be more specific.
unfortunately, I haven't found a way to escape printing to file - if I have a 1,024x1,024 matrix, for example, and I need to visualize (at best) how one specific cell correlates with all the others in the row (i.e. 1,023 other numbers), or at worst, every other entry (i.e. 1,024x1,024-1 = 1,048,575 numbers) - best I can come up with is print to file and surf plot in MATLAB...
Ha, I've never run into a situation like this, so I can't really help you there.
http://nasarb.rubyforge.org
Sorry on my phone so proper reply is difficult, but check out also gnuplot. I used this in grad school for solving a very similar problem. I can post some code if you're interested
Would love to see some examples when you get a chance! Thanks!
Sorry if these are stupid questions but: (1) How do you set a floating point trap? I'm currently using the following to catch NaN's: if (isnan(x)) then print *, 'x is NaN' print *, var1, var2, var3, ... pause endif (2) does -g for gfortran do the same as -traceback for intel fortran?
[Looks like](http://www.rcac.purdue.edu/userinfo/resources/common/compile/compilers/intel/man/ifort.txt) ifort has `-g` as well.
great tips! thanks! 
For anyone out there interested, I *think* -fp-stack-check does the equivalent of -ffpe-trap in ifort.
Take advantage of the compiler flags when debugging. For example with gfortran, -fimplicit-none -fbounds-check -fbacktrace -Wall -Wextra are pretty useful when debugging. Especially -fbounds-check has helped me countless times on figuring out what exactly causes a random segmentation fault (it's usually an out-of-bounds array index). 
No no, [seems to be](http://www.rcac.purdue.edu/userinfo/resources/common/compile/compilers/intel/man/ifort.txt) `-fpe0`.
thanks :)
Depending on your version of FORTRAN, `isnan(x(i))` should work... otherwise the `IEEE_ARITHMETIC` module has a function, too
You can test if its neither greater than nor less than nor equal to something for NaN.
If a number/variable doesn't equal itself, it's NaN. Even Inf equals Inf. if(x(i).ne.x(i)) write(*,*)'Here is the problem!!!'
Yeah this is defining two strings of characters e.g: name(1) = "Firstname" name(2) = "Lastname"
I believe [CDFLIB90](https://biostatistics.mdanderson.org/SoftwareDownload/SingleSoftware.aspx?Software_Id=21) does what you need.
Looks like it should! Thank you very much!
gfortran (cygwin and mingw) http://gcc.gnu.org/wiki/GFortranBinaries
I've always use gfortran and Intel Fortran, the first because its free and the second because work paid for it. 
You could give Simply Fortran a try: [http://simplyfortran.com/](http://simplyfortran.com/) It's a nicely packaged version of GNU Fortran (32- and 64-bit) with an IDE that runs fine on Windows 7. Disclaimer: I am the primary developer of Simply Fortran.
sweet, just got gfortran up and running! Thanks!
No need to use Cygwin as far as I know. The Mingw binaries work great. With a little setup in the system variables it will work fine in powershell. 
I like that you created this username for the sole purpose of asking this question!
As far as I know there is no other CUDA bindings for FORTRAN except in the PGI compiler. There are openCL bindings for FORTRAN though: https://code.google.com/p/fortrancl/ If you really want to use CUDA you could write your GPU functions in C then call them from FORTRAN.
thank you, will take a look. don't really want to use two different languages in the same code though. i'd try to convince my prof to get the pgi compiler, as that seems to be the least painful way out. 
Have a look at [GNU Scientific Library](http://www.gnu.org/software/gsl/), which was originally conceived as a free-software replacement for NAG and IMSL. There is a mostly-complete Fortran interface available as well: [http://www.lrz.de/services/software/mathematik/gsl/fortran/index.html](http://www.lrz.de/services/software/mathematik/gsl/fortran/index.html). If you're just interested in optimization, NetLib certainly has plenty of code available: [http://www.netlib.org/master/expanded_liblist.html](http://www.netlib.org/master/expanded_liblist.html). Sometimes the NetLib stuff can be somewhat cryptic, but it's usually pretty awesome.
I actually just found the GSL and it is working great. I don't know how I was missing it before. I'll check out the NetLib link. Thanks for the reply/help.
Well a good start would be showing what you've got so far. Unless of course you just wanted someone here to just post the answer :P
well an answer would be great. im kind of lost at to where to start
Write a program using a simple midpoint or left endpoint rule for 1d integration first. Then moving to Simpsons should be easy.
Without doing it for you... 1. What is the input and output to the subroutine (I assume you are creating a subroutine?) 2. How would you perform simpson's rule "on paper" - how might you translate this to arrays, loops, sums, multiplications, etc... 3. Try it out with something you know, or can compare against to debug. When you have something started, feel free to post on here for some tips or troubleshooting.
brettb515's advice is good, I'd just add: Don't try writing any code to start with. Focus instead on figuring out what you need to work out step by step to get the answer, then translate this into code.
First, some formatting help :) If you start a line with four spaces you can get "code" text: like this and this is 8 spaces in But you need to hit Enter/Return TWICE to enter a line break. That aside - nothing is jumping out at me. It looks OK. Which means I'd have to compile and run some tests to see what is going wrong. Unfortunately today is too busy for that. One quick question - what value of `n` were you using? I think your code might fail if mod(n-2,3) =/= 0 (i.e. the number of points isn't exactly a multiple of 3 plus 2). I'll try to take a look later if no answers come up.
How far have you got already? You need to work out the forces on each body due to the gravitational attraction from the others, i.e. a double sum Newton's law of gravitation. Then you know that, F = ma, (where a = d2x/dt^2) Then you will use the Runge-Kutta subroutine to integrate the equations of motion.
I think you meant a = dv/dt
Do you have a problem statement, or a statement with the set of equations that the RKF routine will solve? I can help with the problem formulation, and can look back at my own RKF code to give you pointers.
It seems to me that you simply have one too many read(2,*) statements in the beginning: You're throwing out the first four lines of the data file instead of three, and when the program reaches the line "endloop" in your input it expects then a line with coordinates and crashes. So if you remove the first read(2,*) it should work. 
Thanks! I swear I tried every which read, aswell as doing dry runs, but I must have just completely missed it. Thanks!
No problem, sometimes it just takes a fresh pair of eyes to see things like that :) 
I'm having the same problem as you are, if this is a project for Intro to Scientific Computing... I can't figure out how to make it an n-body problem. I can make it work for 3 bodies, just not n-bodies... Hopefully someone comes to our aid.
Yup we're in the same class! At least we have some class time tomorrow. I love how we both run to reddit in desperate times haha.
Thank God we have class tomorrow. I'm almost clueless with this assignment. It's a fair amount more difficult than last semester's capstone project, from what I've gathered. My biggest problem is getting subroutine f(t,y,yp) to correctly work. Segmentation faults are awful.
Thank you! I have a couple of questions: (a) what is the significance of "advance='no'" and (b) what if I wanted to be able to allow the user to specify the masses for 'n' bodies, given that I've allowed the user to determine 'n'? &lt;- (I hope that makes sense.)
totally agree!
PGI does give trial licenses, so if you can show your professor that there's value in purchasing it, then you may get your license. If you do get a PGI license, I'd suggest trying OpenACC as a way to rapidly move code to the GPU. Once you've done this, then you can go back and hand-optimize parts that didn't do well with the directives via CUDA Fortran or CUDA C. Here's a tutorial that I gave at GTC last month about starting with OpenACC: http://www.gputechconf.com/gtcnew/on-demand-gtc.php?searchByKeyword=S3076&amp;searchItems=session_id&amp;sessionTopic=&amp;sessionEvent=2&amp;sessionYear=2013&amp;sessionFormat=&amp;submit=&amp;select=+ There's also some nice material on CUDA Fortran on that same site, so be sure to explore, if you'e gone that route. 
[Here's](http://ia600303.us.archive.org/6/items/nasa_techdoc_19630001662/19630001662.pdf) one option for you!
I do believe that is pre-standard Fortran.
Yeah, give us your code. Generally, for homework help (here and elsewhere) it's helpful to let your helpers know what you've done so far. That way, we can get a better idea of where you're stuck, and we know that you're actually trying to do your own work.
I'm sorry woosawoosa, I cannot read your code because of the formatting blunders that reddit puts onto text. would you mind re-pasting your code into a website like http://ideone.com/? This would allow you to compile and run your code online, as well as share the url with me and I can try to help you fix it.
Oh man, this sounds like some environmental engineering here. Please, elaborate! 
You can either use IFortran (Intel fortran) for free in Linux, or gcc on either linux or cygwin. The latter is easier, the former is optimized a little bit better i think. You should be able to compile everything you need with gcc, but i'm not 100% on old fortran stuff. http://fortranwiki.org/fortran/show/HomePage is a pretty good resource with some examples and tutorials good luck ;0
&gt; Also, what compiler would you all recommend? Stick with the compiler your project requires and your colleagues use so they can help you. If there are no project requirements, I recommend GNU Fortran (contained in gcc, the binary is gfortran). It is free and actively developed, and most of the freely available libraries are developed to run with it. Basically all other compilers are commercial and closed source, dont use them if you dont really have to. &gt; should I get an old version (like 90) or one of the newer versions (2008 i believe?) There are no significant differences between 90, 95, 2003 and 2008. Everything above 90 is colloquialy called f90. If the project does not require it, there is no need to stick to a certain "official standard". Just use whatever the compiler supports, which in case of gfortran means 90, 95, most of 2003 and a big part of 2008 and a lot of compiler specific extensions. &gt; any recommended resources for learning fortran No, just google any random "Fortran 90 tutorial" and start writing "real code" early to get practice. When you learn something new, rewrite the old code. Try to _not_ touch 77, it will poison your mind and you will hate programming. Do not use labels or gotos and if possible, do not use global variables. If you get old 77 code, do not extend it, just write your own new procedures in separate files as f90, since 77 and 90 are binary compatible and can be linked together. Also, early learn to use diff, patch, Makefiles, gdb and git to not get overwhelmed with "manual version control".
Good advice, I concur. Avoid 77 if you can. Fortran has a stigma attached to it, but Fortran 90 (including later standards) is actually a quite nice, modern, language. In most cases, when you hear people complain about "Fortran", they are equating it with Fortran 77. Well, I will say that if you're used to matlab, and not experienced with compiled languages, you'll have plenty of annoying compiler errors ahead of you. My best advice is to be very careful to match actual and dummy argument types and sizes carefully. That's one of the biggest sources of difficult to diagnose run time errors you'll encounter. Putting your functions and subroutines inside modules helps, because it gives much better compiler checking of calling interfaces. Personally, I like the Chapman book best for beginners. Avoid the Metcalf book, it's very terse. Oh, and there is a F77 fo F90 converter that's "pretty good" called f2f (I'm the original author). F77 is a mess (and scientists are pretty bad programmers), so f2f can only do so much in a robust way, but it should at least be helpful if you actually want to convert F77 code to F90 style.
Mingw works great on regular windows. A couple system variables added and you are good to go. 
Others have posted some good advice, yet I still would like to offer one link, [Common Mistakes in f90](http://www.cs.rpi.edu/~szymansk/OOF90/bugs.html) You may never need to use it, however it saved me a few times when I couldn't decipher some errors I would receive.
Thank you for the advice! Turns out I won't be needing to actually use the 77 code given to me otherwise I'd really like that converter! Also what a coincidence, the one book I did find was the Chapman you recommended, and the Metcalf copy was being reserved. What luck!
Thank you for the reply and advice! Looks like my summer &gt;...diff, patch, Makefiles, gdb and git to not get overwhelmed with "manual version control" So obviously I haven't started fortran yet, but none of those terms make sense to me right now... is that going to be a problem?
Thanks for the wiki link! Just the kind of thing I was looking for :)
Thank you for the link. I have a gut feeling this is going to help me out this summer
I'm actually in pretty much the same boat and I also don't really know where to begin...
Awesome! What're you gonna be using fortran for?
"Distribution of galactic dark matter temporarily captured into solar orbit" at the moment some of the stuff is a LITTLE over my head, but I'm starting to get a grasp on it. So for everyone else out there, I just downloaded gfortran from [here](http://gcc.gnu.org/wiki/GFortranBinaries), which is what my professor told me to use, and he said I could use whatever text editor I wanted for the actual coding, and I was wondering what you guys suggested.
These last few commands are linux bash commands. diff compares two files and reports the differences. patch uses the diff output to modify files. gcb is a debugger to help you monitor what's going on while the code executes. Matlab does this automatically, compiled Fortran code does not. Makefiles are not specific to Fortran but programming in general. It helps you compile and link multiple source files to create your final program. git is version control which keeps track of changes in your code, so if you make a change and the code stops working, you can always go back to the working code. This is the purpose of diff and patch but with lots of features and is easy to use. I would start by doing the following: * Install git * Work through a few single file programs from the www.projecteuler.com website. And use git. * Learn how to use compiler flags to catch specific errors. My standard debuging flags are -O1 -g -pg -Wall -Wextra -fimplicit-none -fbounds-check -fbacktrace -ffpe-trap=zero,underflow,overflow,invalid and my standard optimization flag is -O3. I'm using gcc 4.7.2 so some of these flags may not be available but most compilers have similar flags to catch errors. A code compiled with debugging flags runs much slower than optimized flags, but they will save you a lot of headache tracking down problems. * Move to multiple file programs ( a main program and a function ) * Learn how to use Makefiles to compile multiple file programs Here are some coding standards used by a NASA Langley code that are helpful http://fun3d.larc.nasa.gov/chapter-9.html#f95_coding_standard
Well, what are you trying to do? If you are trying to improve some old legacy codes that your advisor passed to you, well then Fortran 77 might be what you need to learn to use. If you need to work with objects and some of the newer classes, you might want something more recent (2003 or newer). I have **never** heard someone say that they programmed in FORTRAN 4 or FORTRAN 77 or Fortran 90 or any of the specific versions of Fortran- only that they code in Fortran. I would likely start with a 90/95 textbook and add functionality as I needed it. 
Thanks! How do I run gfortran from the terminal? Also with gfortran, what syntax would I be using? Like from what I've heard, some versions use .LT. for less than, instead of &lt;.
&gt; How do I run gfortran from the terminal? gfortran -o app.exe code.f90 morecode.f90 &gt; what syntax would I be using? Like from what I've heard, some versions use .LT. for less than, instead of &lt;. .LT. is 77 syntax, avoid that. &lt; is 90+ syntax. Just google a random f90 tutorial and work through it.
&gt; I see a lot of references to 77 and 90, but 2008 is the newest release. These are different language standards, not "releases". 77 is antique, from a time when code was input on [punch cards](http://modelingwithdata.org/asst/027-fortran.jpg), and you should avoid it when possible. 90,95,2003 and 2008 are the "modern" version of Fortran, basically the same language, but just with small updates every few years. &gt; It seems like there are like 50 different Fortran compilers. There are, but the "standard" free compiler is GNU Fortran. Most of the free code and libraries are made to run with gfortran. It is a reasonable default choice, especially for a beginner.
Thanks! Just curious though. Why F90 over 2008?
Thanks! So which standard should I learn to code with?
Sounds cool! I've finally got gfortran set up and the text editor I currently use is Programmers Notepad. A grad student in my office uses notepad++ but he told me it doesn't really matter as they are more or less the same
&gt; Why F90 over 2008? It is not "90 over 2008". It is the same language. 95, 2003 and 2008 are just tiny improvements on 90. The whole group 90,95,2003,2008 is colloquially called "F90", because the big change came with the switch from 77 to 90.
If the project doesnt explicitely require it, you do not have to target a standard, just use everything your compiler supports. GNU Fortran supports all of 90, 95, big parts of 2003 and big parts of 2008, plus various non-standard extensions. Simply use whatever the compiler supports. Strictly coding to a specific standard would only make sense if you had long-term plans for the the code to run on different compilers, but even then you would get problems since no compiler supports all of 2003 and 2008, so you would have to restrict yourself to the lowest common denominator which would probably be 90.
Eh, it's perhaps a little less impressive than it sounds. so what research are you doing?
I'm also in the same boat as OP in that I'm also having to learn fortran for a research project. For starters, I already know that my professor wants us to use gfortran, AND he doesn't want to futz with linux because at the moment the only computer that he has available to him for work is a standard issue pc they give out to professors for their offices, and he isn't allowed to put linux on it. so anything I do has to be in windows. I did look around for some tutorials, and I actually had a question about that. it seems like all the tutorials that I found were REALLY rudimentary, and seemed to assume the reader was new to programming in general. While it was useful to run thru the first few examples to brush the cobwebs off my general coding skills, but after the first few I felt like I was in my highschool Java class all over again and I wasn't getting much out of it. Are there any tutorials out there that are geared for people who already have a background in coding in other similar languages such as Java, C++, Python, etc? I also was hoping you could give me a suggestion on a build environment. As I said before for this project I am limited to windows, and using gfortran as a compiler. In the past I've used more streamlined build environments like Bloodshed or Kate, and more "traditional" ones like vim, and I have to say, as someone who doesn't code on a regular basis and has a bad memory for terminal commands, I MUCH prefer more streamlined build environments. That's not to say that I'm not afraid to use a make file if I have to, but it's so much nicer to be able to just click a single button and have the editor do all the work for you. So I'd like to find a nice easy to use txt editor/build environment. It has to be usable in windows, but if there is a linux version that could be nice for me to use when i can use linux for other projects in the future. It also has to be able to use gfortran as a compiler. obviously i'd like it to be able to recognize syntax and color code things nicely for me. if at all possible, it would be great if it were compatible with other programming languages like Python and C++ and Java, so that I can start using it as my only code editor in the future for other projects. sorry for the wall of txt and thanks in advance for any and all assistance with any of my questions!
The thing is, I use R a lot and R can run Fortran code, along with C and C++ code natively. Oddly enough, I use Python quite a bit, but thanks for the advice!
Well, if you're running serial, just use BLAS's [ddot.f](http://www.netlib.org/blas/ddot.f), or the intrinsic dot_product. If you need MPI, it's just one mpi_reduce call. Or am I missing something obvious where you can't just do: real*8 function distdot(n,x,ix,y,iy) integer n, ix, iy real*8 x(1+(n-1)*ix), y(1+(n-1)*iy), distdot distdot = dot_product(x,y) end function ? ( huck the fawks ;) )
whoa, sorry did not see this at all! Im working with simulation data from star formation simulations from my Profs F77 code. I dont exactly know my project title, but it basically boils down to me having to do some numerical analysis stuff with the data obtained from her simulation
Do you know how to use modules? You can put a subroutine into a module and compile it separately. Then when you want to compile your whole program you can compile everything and execute it. Sorry this was a very choppy description, I'll come back to edit if you have more specific questions
Thanks for the reply. I don't know how to use modules unfortunately (or, honestly, know what they are). This is what i've done, I write the program in one file on Programmers Notepad, then the subroutine in another file... but I cant compile them seperately. But I can compile if I put the subroutine code into the program code OR just compile on the same line of code in command prompt. But not seperately... 
If you have "subroutine.f90" and "main.f90" files, compile them separately with the "-c" flag: gfortran -c subroutine.f90 gfortran -c main.f90 those will create "object files", which you then link into an executable: gfortran subroutine.o main.o -o program.exe your "subroutine.f90" can be just the code of the subroutine, or it can be in a module. Google for the syntax.
Thank you! this solves my problem! I feel so stupid now; it never occurred to me to look up other flags... (been using -o this whole time... don't ask why) Thank you once again! :)
No problem. This separation of compiling and linking stages is common to most (all?) Compiled languages, not just Fortran.
This is going to be a little bit of a long message, in which I'm going to begin by explaining what modules are, and then provide an example with the appropriate command line statement to compile everything. Basically, there are different types of file structures that I know are available in Fortran. You are aware of the *program*, and you are also aware of the *subroutine*. *Subroutines* are useful because you can send multiple inputs and receive multiple outputs using one call statement. If you have only one output, like an integer, real number, or a logical variable, then you can use something called a *function*. These are two related structures used to perform tasks in your code. If you put either a *subroutine* or a *function* into the same file as your *program*, you have to reference it in something called an *interface*. These become annoying very quickly in larger code, and I would just recommend avoiding them if you have the chance. They are an artifact of the legacy code (f77), and have been replaced more recently by something called *modules*. Contained within *modules* you can have an unlimited number of functions and subroutines, which can be called by your main program. I usually put all my related functions and subroutines in separate *modules* to help me organized. Each *module* is in a separate file which also helps me with organization. Here is an example of two files, one program and one module, that may be useful to you in understanding how you can use modules in the future. File 1: the program "example", called example.f90 program example use hello call helloworld end program example File 2: the module "hello", called hello.f90, which contains the subroutine "helloworld" module hello contains subroutine helloworld write(*,*) "Hello world" end subroutine helloworld end module hello Notice how I had to include the statement 'use hello' in the main program? This is the statement that tells the compiler that the program is going to reference a module named 'hello'. Also, in the module, you need to include the statement 'contains' because... that's just the syntax. I'm sure someone else can provide a better explanation. I use gfortran to compile my code, it might be different for other compilers. Here is the sequence of command line statements needed to compile to two files into one program: gfortran -c hello.f90 The '-c' part tells the compiler to make just an *object file*, which is going to be hello.o in this case. gfortran example.f90 hello.o -o example This line compiles the example.f90 *program* along with the hello.o *object file*. The '-o' part tells the compiler to name the new executable 'example'. Now you can run your new program with this: ./example And the output should say: Hello world Did this make sense? Feel free to reply or pm me with any questions.
Thank you for this, just saw this now, Yes this makes sense. This clarifies a couple things i was unsure about in Chapmans book. I appreciate it!
Check out some root finding methods such as Newton-Raphson.
There is an analytical solution to cubic equations just like there is for quadratic; you could write a simple program that outputs all three roots using this.
Don't know what R is...but I would go with Fortran 90. C++ is also good and if you are looking for stuff just to know, scripting is great to know for many situations. Also (as an extension of scripting) learn some things about Makefiles. Feel free to ask me about starting with F90. I may have some small code to get you started. 
Numerical recipes used to have a Fortran 90 version (most of the major changes in the Fortran standard were introduced in the 90 revision, 95 was ultimately a "bug fix" for 90), though it's out of print now in favour of their 3rd C++ edition. They do have it archived on line for free though: http://www.nr.com/oldverswitcher.html I find NR to be quite good, though their licensing system is a bit restrictive.
There also was a German book that i liked, "Numerik-Algorithmen" that came with a full set of F77 and F90 routines, but in the newest version they also like NR fully switched to C++ and abandoned fortran. In my knowledge, there is no other book as comprehensive as NR. But it really does not matter what language an algorithm is implemented in, it is just a reference implementation. Many other algorithm descriptions dont even use a real language but implement the algorithms in pseudo-code. If you really need it in a particular language, it is not hard to rewrite it. But to be honest, I also hate C++ with a passion. It is a butt-ugly abomination never designed to be the premier language for numerical code and I think that much harm has been done by pushing it on scientists and engineers.
&gt; But it really does not matter what language an algorithm is implemented in, it is just a reference implementation. Many other algorithm descriptions dont even use a real language but implement the algorithms in pseudo-code. &gt;If you really need it in a particular language, it is not hard to rewrite it. This is why I liked the older editions of NR: they focused on making a clear and concise implementation, without heavily relying on any "features" of the language. Languages evolve and change according to current programming paradigms, the underlying mathematics rarely changes. 
Unrelated to code generality, but a general tip: write less code. Use intrinsic functions and vector instructions wherever possible. The less code you have, generally the easier it is to read, write, and debug. Example: norma = 0.0 DO i=1,Nr norma = norma + A(i,1)*A(i,1) END DO That's 4 lines of code. It could be written in one line: norma = sum(A(:,1)*A(:,1)) or better still, with the intrinsic dot_product: norma = dot_product(A(:,1),A(:,1)) Similarly, don't do this: !Copy the matrix DO i=1,Nc Vf(i,j) = A(i,j) END DO When this works: Vf(:,j) = A(:,j) You can probably write that same code in 1/3rd the number of lines.
I'm quite a beginner in programming, and since I've never had a proper FORTRAN class I'm not really conscious about the possibilities of the language. Thank you, really. 
implicit none
I can't really offer suggestions since I'm not involved with the project. However, this sounds like one of the many problems I've encountered over the years. You've made some seemingly minor, innocuous change to a file name, file location, single line of code, etc. that has borked the whole subroutine. When you solve it, and you will, you'll shake your head at your mistake. Sorry I can't offer any help. Good luck.
What compiler are you using? Can you use a different one temporarily? Have you used all relevant debugging flags when compiling?
i'm using gfortran, and I suppose I could use others, Just didnt think of that since everyone has told me this one is the best and free i'm sorry i'm unsure of what you mean be debugging flag. the book I reference however says to use write statements in intermediate steps for debugging, that is what i've done if thats what you meant. I think i've zero'd in on the problem and it seems to be with the reading in of the file .... but I can't find a solution
Oh boy oh boy, you are about to make a major leap in your fortran development skill set. Read a manual on the gfortran compiler, focus on the flag options during compilation. To start with, compile with the following flags: -g3 -wall -fbounds-check -fbacktrace I'll leave it to you to find them in the manual and figure out what they do.
thanks i'll check this out and hope it works
So i compiled with all those flags and got no error.... however I've seperated my subroutine from the module and now everything works. Im unsure why it suddenly stopped working when it was within the module...
Perhaps because when the subroutine was in the module the variable logoptable was local the subroutine and not available elsewhere where the module is used?
Also, learn to use git. Efficient version control is as essential for software development as efficient debugging.
My advise would be to always code by the latest standard (currently F2008), but not use all features thereof. Use the standard as a reference, what is allowed and what not, then try to achieve your tasks within that frame. A good book cover the current Fortran language is "Modern Fortran explained" by Metcalf, Cohen and Reid. As others pointed out, you don't want to code in F77, that requires you to code in fixed source form and does not offer dynamic data structures. Most of the things you propably will need are covered by Fortran 90/95, which are also available in all (still maintained) compilers today. Yet in computationally intense kernels, you probably want to omit most newer features and fall back to something F77 like (except for the fixed source form) to gain highest performance. However, that is not really an issue, as attributes like pointer, can be omitted in dummy arguments to such an computational intense kernel, while it might still be used in the call routines. The biggest points in F2003 from my point of view are object oriented features and the ISO-C-Binding. Not all compilers implement all object oriented features, but the rest of F2003 is pretty widely supported nowadays. We use the ISO-C-Binding to interact with C code, and make use of some of the F2003 features for automatic allocation/deallocation, but so far stayed away from the object oriented features. It is just 10 years since that standard was put into place, you know, compilers take some time ;) Here is a nice overview on which features are supported by whom: http://fortranwiki.org/fortran/show/Fortran+2003+status The main addition in F2008 were the Co-Arrays, which allows you to do parallel programming without further extensions and submodules. However, those are not yet supported widely. A free option to give Co-Arrays a try would be G95 for example. Besides that, there are some intrinsic functions that were added to the language, like the Gamma and Bessel function, that might come in handy. An overview on the support for F2008 features is also available in the Fortranwiki: http://fortranwiki.org/fortran/show/Fortran+2008+status Also there are parts from older standards that are deprecated or deleted in the one. I'd stay away from these. Thus my opinion, that you should go with the latest standard, but only use the widely supported features and do not use deprecated or deleted features.
Simple google search returned [this](http://www.pdas.com/quarticdownload.html)
you'd have to do something like this: character(len=1000) :: char_in ! len=1000 assuming lines never longer than this character(len=6) :: userID_in character(len=8) :: userSalary_in integer :: userID(numberOfLines) real :: userSalary(numberOfLines) open(unit=10,file="input.dat") do i = 1, NumberOfLines read(10,'(a)') char_in ! read entire line userID_in = char_in(7:12) userSalary_in = char_in(102:109) read(userID_in,*) userID(i) ! converts the string to integer read(userSalary_in,*) userSalary(i) ! converts string to real enddo if you *know* that the file has those inputs in the specific columns, then you can do something like that. you have to read things in as a string, and then pluck out parts of the string and convert those to the proper type. otherwise you'd have to know more about the formatting of the lines to read things directly to integers/reals. fyi, this kind of thing would be much better handled by a scripting language. i.e., you can likely do this with a single line of awk.
I know intel fortran tends to be a bit more strict on passing arrays of variable size to subroutines (the data input in this case). To test this you could hard code the size of 'data' and compare it with the gfortran result to see if there isn't some other problem in the numerical section. On a side note, which version of gfortran are you using, can you test with a later version to see if the same bug occurs?
1. I don't know what "hard code" means. 2. Many problem occurred when I last used a newer version of gfortran. I use gcc 4.1.2 (please don't lough). What I see is that a) all the modes tend to get the same value (which, looking at my simulation) is not logical. b) some simulation get a good values while I don't see any visual difference between them and "bad" simulations. c) on some occasion the FT results are too much higher. By a factor of 100. Thank you. 
I'm too lazy to debug your code, but you're probably just dividing by zero somewhere and anything +-/* NaN = NaN
Quick comment that could reduce potential for bugs: check out matmul(), an intrinsic function that performs matrix multiplication faster than the brute force way you are doing it. Then try compiling with gfortran -fcheck=all -Wall -ggdb These options should help you get more of a clue what is going on.
Oh, and n**-2 should be n**(-2).
Dividing by zero returns an 'INF' doesn't it? Anything over zero is infinity.
My guess: Somewhere in the code you might have an array access out of bounds. Can you turn on array bounds checking flag on the compiler and see if it gets caught? 
The default precision for floating point numbers is generally a 4 byte REAL and a COMPLEX with 4 bytes each for the real and imaginary components. You can declare a double precision (8 bytes for a real, or 8 bytes per part of a complex number) variable using a kind parameter when declaring the variables like this: REAL(8) x, y, pi COMPLEX(8) tr, tr1, p, p1, r1 Here you're specifying the number of bytes for the real, and for the real and imaginary part of the complex number. The other way you can specify these is: REAL*8 x, y, pi COMPLEX*16 tr, tr1, p, p1, r1 With the asterisk notation, you're specifying the total number of bytes for a real or a complex number. If you're using double precision complex numbers you may need to switch calls to cexp (complex exponential) to cdexp (complex double exponential). Also, why are you nesting calls to real: (REAL(real(ratio))? Calling REAL with a complex argument (the inner call) returns the real portion of the complex number with whatever precision the argument had. Calling real with a real or integer argument returns a real with the default precision (single precision). So if ratio is a double precision complex number, the first call extracts the real half of that and the second call turns it single precision. 
Apologies, your post got caught by the spam filter for some reason. I installed gfortran using [homebrew](http://mxcl.github.io/homebrew/) &gt;brew install gfortran I use the sublime text 2 editor, but it can be a bit of a fiddle to get fortran syntax highlighting to work. You're better off using something like textwrangler that works by default.
Hey, thanks for getting back with me. I'm a Physics student and am very interested in learning how I can benefit from learning fortran. Are you familiar with any good resources to help me out along the way?
Yeah that's how I got into Fortran too. Do you know any other languages? I'd recommend 'Fortran 90/95 Explained' or maybe 'Fortran 95/2003 explained' by Michael Metcalf as that was the book that was given to me when I started my PhD. It's a pretty good introduction and is also a good reference for later on. Get whichever you can get hold of easiest because the fundamentals are the same from Fortran 90 onwards. Don't bother looking at tutorials for F70 or any other fixed-form Fortrans because it will confuse you.
Why you want it to be in MATLAB? I don't use MATLAB, so I can't help you, sorry. 
My boss want's it that way, I think he want's to use it with another code or modify it.
Sorry about the spam filter, let me have a look at your issue now.
Fortran is really picky when it comes to formatting, if you're not familar with the FORMAT functions, I'd be glad to write up a read in and write out for you. I will need the original data (a sample if it's sensitive), and output order requested to integrate with your code.
These appear to be trivial nested do loops that populate a text file with values. You could type them into MATLAB as FOR loops and pretty much copy the code line by line, taking syntax into account. OR, you can compile the code into a script that produces the necessary text file as needed and modify the code when youâ€™d like. On a Mac, Unix, or Linux you can probably just type: $gfortran code.f â€“o code.sh While in the directory that has your Fortran code in it.
As Speculater said, compiling this to machine language that you call from matlab might be easiest if you have a number of these codes. If it is only this code and you just want it in MATLAB and don't care about pretty code, then the syntax changes are minor: https://dl.dropboxusercontent.com/u/22521474/chromatcity.m
Do you want all the files consolodated or do you want to be able to convert them and keep them seperate?
Would like the output files separate. With the YYYYMMDD prefix to identify them. Much easier to process them that way. 
Will do. I'm working it now, it should be ready within an hour +/-
I'm havnig a hard time making it Fortran 77 friendly, if I have to, will rewriting in Fortran 90 be okay?
Should be alright. As long as it does the conversion from binary to ASCII correctly, that should be fine.
Aight. Thanks for the update!
My quick (and maybe a bit ugly solution): http://pastebin.com/Vt0iCHhq
Okay I have the code coming out in .txt but I suck at string manipulation in 77, let me clean the code up and send your what I have when I get home. I'm leaving work now. I really did think this would be much simpler :-)
Hmm. Looks like it should work but I'm getting a lot of compilation errors. Will try and puzzle it out and get back to you. Thanks!
I'm using intel fortran, so that might be the reason it works for me and not you. Let me know if you can find the source of the errors.
Will you be able to always generate the filenames.txt? It's easiest to point at that to keep track of conversions and output. 
Yep. Will be using that to keep track of the many files.
I'm a complete newcomer to Fortran so was wondering if you could briefly explain what you wanted to do with the do loop at the beginning of the convert program
I got him fixed up :-). We took the same approach, buy I used a fixed array size to store his data file names, and had the code crash when no more were available. http://pastebin.com/dzkqKK1L
thanks guys, I'm doing the whole thing line by line. Doesn't seem yoo hard for you guys but I have no idea what I'm doing. It's going pretty good for now. 
 Using the MOD function with REAL arguments ------------------------------------------ This is yet another version of the floating-point comparisons problem. A small example program will make it clear: PROGRAM RNDOFF C ------------------------------------------------------------------ REAL * R1, R2, * RESULT C ------------------------------------------------------------------ R1 = 1.0 R2 = 0.2 RESULT = MOD(R1,R2) WRITE(*,'(1X,F3.1)') RESULT C ------------------------------------------------------------------ END The MOD function really computes: MOD = R1 - (R2 * INT(R1 / R2)) Upon converting the constant 0.2 to the internal binary representation a small roundoff error is introduced, on some machines the internal value will be rounded UP a little. Because of the rounding up, R1/R2 will be slightly smaller than 5.0, and the INT function will give the value 4 instead of the correct value 5. The program then will proceed to write the WRONG result 0.2. On other machines you may get some very small value. 
Thanks! I was not aware that one could use characters as format descriptors. 
http://pastebin.com/2NbmVjNP The trick is sorting a vector of random numbers, then using the indices Requires an external sorting library... see the source for a link
Could we see your code as it is, as it might be easiest to see what you have first, and fix it from there. 
Here's my quick jab at this: http://pastebin.com/NjtLFrEA Be warned, bugs may exist in the above code and the random number generator is initialized with the default value. It should be enough to illustrate how to do this in Fortran, though :) Because the odds of a repeated number is small and there are only 20 numbers in the full set, it's not a problem to just compare a new random number candidate to the ones generated. 
It's also highly inefficient for randomly choosing K numbers out of N, when N&gt;&gt;K (in this case, 10,312 &gt;&gt; 20). Especially when doing it over and over again for 10,000 times. These two methods scale very differently: The one I posted above scales as O(K^2 ), independent of how large the N is. The one you posted before that scales as O(N log N), independent of K. Inefficiency is not elegant. 
Fair point. I took another shake that doesn't require scouring, but instead keeps a mask of chosen numbers. Should be the better than both our previous attempts. No external libraries, and &lt;30 lines of code. http://pastebin.com/3bbDPPas 
I have a bag of balls numbered 1..10311. I pull out a ball and don't replace it, and then pull out another ball. How is that not random?
Would shuffling the numbers 1..10311 and then taking the first 20 be a viable option? No idea how you would do this mind. Alternatively, I found this elsewhere. Not sure if it's similar to the approaches already mentioned though. http://rosettacode.org/wiki/Remove_duplicate_elements#Fortran 
But they will have been picked at random. If you do it again, you'd have a different final ball most likely
This is what my first attempt does: http://pastebin.com/2NbmVjNP But StandardIssueHuman points out that it may not be the most efficient (especially in this case). The code you post scours for dupes like StandardIssueHuman's approach. I believe this can be improved by keeping in memory a list of previously chosen numbers like in my second attempt: http://pastebin.com/3bbDPPas
Alright so I just made that change(of adding 'd0'), but now the value i get is **f(x,y) = 6.0100000016100417** instead of **6.01000002304918769**.... is this an improvement? haha...
actually now I added '0d0' to the test input arguments as well(i.e -8.0d0 and 3.0d0) and now I get f(x,y) = 6.00999999999998. which is much closer to 6.01 !
Could maybe have something to do with declaring your variables in the interpolation function. Make sure you declare them are real double precision values. Could be that you have intermediate values as only single precision. dp = kind(1.d0) real(kind=dp) ... :: x1,x2,..
Is it possible to put the loop inside the part of the code that changes the cell ref? Assuming the part that changes the cell ref is in a loop, you could just put a call or the code inside this and store your data with an extra column for cell ref.
I'm not sure if I understand your question completely. I take it that you want to read the data set line by line, and calculate your stats for each group with the same cell ref value. I am assuming that a group of cell ref values are values are continuous in your large data set, and that you don't want to store the whole data set in the program. Here is my pesdo-code attempt at it (just calculating a mean, you can do the others): Open(unit=ip,file='input.txt') read(ip,*)Lat,Long,HeatFlow,CellRef i = 1 do HeatSum = HeatFlow N = 1 CellRefOld = CellRef do read(ip,*,end=200)Lat,Long,HeatFlow,CellRef if(CellRefOld /= CellRef) Break HeatSum = HeatSum + HeatFlow N = N + 1 end do Mean[i] = HeatSum/N i = i + 1 end do 200 Mean[i] = HeatSum/N 
Sorry for the late reply, thanks for the help. Really appreciate it.
It is possible if you use the "SAVE" statement when you declare your variable in the subroutine. So it would look something like this: MODULE MY_MOD REAL, DIMENSION(100,100), SAVE :: ARRAY SUBROUTINE READ_ARRAY !READ ARRAY END SUBROUTINE READ_ARRAY END MODULE MY_MOD PROGRAM MY_PROG USE MY_MOD CALL READ_ARRAY WRITE(*,*)ARRAY END PROGRAM MY_PROG
Alright I put a really basic outline of the code and text file here https://gist.github.com/anonymous/f4342dcd1c3eab742ee7 and I included a smaller table (29x15) since that's something else I'll need to use. Hopefully you can help me figure this out. I appreciate the help! **edit**: old link slightly wrong. should be good now 
As /u/irondust said, your read statment has the ranges reversed. I can't get the code to run in double or single precision with this error. I fixed the read statement ranges the code seems to run fine.
Thanks, i made that fix and it all works. I cant believe i looked over something like that... sigh. Thanks again
So embarassing i looked over something so small... thanks for your help so far. I made the change and it works fine now. :) 
Calling Fortran (and C) code from Python is extremely easy, using f2py. See http://docs.scipy.org/doc/numpy/user/c-info.python-as-glue.html#f2py and http://wiki.scipy.org/Cookbook/f2py_and_NumPy
That seems really quite nice, and beginner-friendly. But if anyone knows something better, I'd love to hear?
When I first learned Fortran about 6 months ago that was what I used, I found it to be a really good intro. As you say, its quite beginner-friendly which was good for me - at the time I actually didn't have much programming experience at all. I supplemented it with [this one](http://www.usm.uni-muenchen.de/people/puls/lessons/intro_general/f90_for_beginners.pdf) from LMU Munich, also pretty beginner-friendly.
I suppose BLAS and LAPACK are the closest thing to standard libraries in FORTRAN, ignoring proprietary libs like NAG. To link blas and lapack while compiling just use -lblas -llapack.
You never define the variable data. You need something like real*8 data(3) at the top with all the other variables. I think that'll fix the read error too
Thanks a lot. all works now
You didn't really have to delete your whole post to say you solved it. How much do people need to shit talk people that do this until it stops?
Please don't delete your post after it's been solved. Reading about these sort of problems helps people avoid making the same mistakes, no matter how small they are.
The right approach for changing a single line depends on the format of your data file. You should take a look at these [file I/O examples] (http://cs.ubishops.ca/ljensen/fortran/fortran.htm#formdir). File position can be set directly when the file is opened via the 'position' attribute, also keep in mind that modern fortran compilers support stream access, so that's another way to go. More examples: [writing to specific position in text file](http://stackoverflow.com/questions/8075284/fortran-how-to-write-data-to-specific-position-in-a-txt-file)
sed is the "Stream EDitor". It lets you find and replace strings in files *very* easily. The example command: sed -e "s:foo:bar:g" basefile &gt; newfile finds all patterns that match 'foo' in the file 'basefile' and replaces them with 'bar' in 'newfile'. You can also edit a file in-place with the -i option rather than creating a new file.
Also, I need to be running this on a cluster. I have downloaded force 2.0 compiler to test it out on my desktop but eventually, i need to be running it on a cluster.
Here's my $0.02: Googling "splie2", I get the impression that that is a Numerical Recipes routine. The book has an example program demonstrating how to use it, so you might want to take a look at that. About running it on a cluster: If the program needs to be parallelized (ie. if a serial code turns out to be too slow), you will most likely need to learn MPI as well. But my advice would be to learn Fortran â€” and do yourself a favor and learn modern Fortran (90+) instead of 77 or older â€” first. What I would recommend is to start with using a few days to learn Fortran, reading tutorials and coding little (10-20 line) programs to test if you understand what you read. Then, make a simple test program that reads your data files and writes them out, so that you know how to do that. Similarly, write a test program to interpolate some simple test data with only a few points and write out a file you can plot with Matlab or Gnuplot. Then it's only a matter of putting what you've learned together. I hope this helps. 
my data files are text files. I'm initially trying to run the interpolation program on my desktop first. Then, I'll try to get it running on the cluster. Planning to take it step by step.
Well.. You are right. This is a numerical recipes routine. But the book only has the subroutines in it. I know the direction how I should be proceeding as I think I have the algorithm sorted out. I need to be having a main program that would first declare the data types, open the files, read the data and store them in variables and then finally call the subroutines to run the interpolation. But i need to figure out how to write the main program. And as I said earlier, I would first like to do it on a small data set on my desktop first and then, try and run it on the cluster. So, I think it comes down to writing a main program, which I'm not sure if I can do it in a day without prior fortran knowledge.
Oops, you're right, the example program I saw wasn't in the main Numerical Recipes book but in a Numerical Recipes Example Book [Google Preview of the relevant part](http://books.google.com/books?id=ruR6ds7RIpEC&amp;pg=PA40&amp;lpg=PA40&amp;dq=splie2&amp;source=bl&amp;ots=eHPCSG4b8p&amp;sig=KQpSwHo3EWM29ZtKosmlQTJlaKE&amp;hl=en&amp;sa=X&amp;ei=RKIcUsO9CsnCsASp24GYAQ&amp;ved=0CDIQ6AEwAQ#v=onepage&amp;q=splie2&amp;f=false). 
* When RETURN is executed in a function, control is transferred to the referencing statement in the calling program unit. * When RETURN is executed in a subroutine, control is transferred to the first executable statement following the CALL that invoked the subroutine, or to the alternate return (if specified). Are there cases where this doesn't happen automatically when a subprogram ends?
-pedantic turns on strict standards.. this could help -Wall is "all warnings" -Werror will make warnings throw errors so maybe lacking a return is a warning, you could make it throw an error
Nope a return is always implied at the end of a subroutine. In my opinion you shouldn't put an explicit return at the end of a subroutine/function. It's needless clutter. The return statement should only be used sparingly to indicate an *early* return. The default assumption when reading a subroutine is that it's executed from beginning to end.
&gt;In my opinion you shouldn't put an explicit return at the end of a subroutine/function. It's needless clutter. Good point. "return; end subroutine" is redundant so it should be eliminated.
Usually codes with many files like that will have one "driver" file. Which basically will call things exactly like youre saying. Start from that file, and just follow where things are going. Also if you use vim as your text editor, a great exercise would be to look up "ctags" somewhere on google and learn of how they work (they basically are tags you mark on subroutines in the file they were executed and where they were defined) and then put in ctags yourself. It will help you understand the structure of the code. Always start with the driver and just follow it line by line, going to the definition of whatever routine is used as they come along. There is no really convenient way other than that. If youre having trouble identifying what code might be the driver, let me know and ill try to help! Sorry if this wasnt what you were asking and if I assumed you had less knowledge than you do. Just trying to be helpful! 
Doxygen will automatically generate dependency diagrams for you; this can be really useful for a large picture overview. Skipping around source files is a pretty inefficient way to do what you want. Learn some basic debugger use, and you can walk through the code execution quickly.
Thanks! 
Awesome! Very helpful, thank you!
In my days writing HPC Monte Carlo algorithms, I mostly would use ran2() from Numerical Recipes. For a time I implimented the Mersenne Twister which improves speed if random numbers are called often. However I always reverted back to ran2() for its simplicity. ran2() can be found [here](http://nuclear.fis.ucm.es/COMP-PHYS/RANDOM/RandomNumbers.pdf)
Can you give an example of the file?
http://pastebin.com/MqN3yt2X first 10 lines in the data file.
&gt; I am trying to plot an ascii file with 2 columns (depth and surface) using gnuplot. However, I keep getting this error: &gt; &gt; "gnuplot 2 columns only possible with explicit pm3d style (line 1)" &gt; &gt; Obviously, I entered it in google. But that doesn't help me out... Apparantly I somehow need to write the data in pm3d style, but how I do this is vague to me. Ok, so copying that file and plotting it just works for me, ie gnuplot then "p 'file' w l" Does your file have any writing or anything at the top? It won't like it if it does.
Well that code is meant to be an initialization routine. When your program starts, it should be called once and only once. The *RANDOM_NUMBER* intrinsic would be the only thing you call after that in your DO loop. The code I posted should never appear in a loop.
Ah, I getcha. Rookie mistake. Thank you!
I tried compiling your example code and ran it on an input matrix consisting of numbers 1...9 in the order, and it seemed to work for me without crashing. Using gfortran 4.8.0 on Mountain Lion. But I did find another bug: You are setting the variables _i_ and _j_ zero in a wrong place, so that their values never advance beyond 1, and the only element updated in the array _minor_ is _minor(1,1)_ Finally, there are many more concise ways of doing this in modern Fortran. One that comes to mind (and I'm sure there are nicer ways, too), is this (replacing the lines 12-29 of your code): forall(i=1:2, j=1:2) minor(i,j) = mat(merge(i,i+1,i&lt;elrow), merge(j,j+1,j&lt;elcol)) end forall 
Wow, thank you so much. I hadn't known of this syntax type (hasn't be covered in the tutorials I am working through). I see it is not only concise but has fewer places for error, like the ones I made in setting i and j=0 in the wrong place. Thanks again!
You're welcome. A couple of free bonus tips: Modern Fortran is all about arrays, learn about all the things you can do with them. And there are lots of interesting intrinsic functions, it's worthwhile to spend some time exploring them ("merge" above is one of those, basically a ternary if like a?b:c in C, but generalized to arrays). 
FYI, it's been generally acknowledged that the ["forall" construct has been a failure](http://software.intel.com/en-us/forums/topic/286446) and you should use "do concurrent" instead. 
It appears do concurrent has been implemented in versions after fortran 95 based on some searching. I am using fortran 95, which may be why StandardIssueHuman gave me the forall command. Although I may be incorrect and the documentation I have seen hasn't addressed the existence of "do concurrent" in fortran 95.
Thanks for bringing that up. I'm still slowly starting to use 2003-08 features myself. It seems to me that _do concurrent_ isn't yet widely supported by compilers, unless [this](http://fortranwiki.org/fortran/show/Fortran+2008+status) is badly out of date. 
Recent Intel, PGI, and gfortran support do concurrent, so you should be good to go.
It's a common misconception that people say they're "using fortran 95" or "using fortran 90". AFAIK there aren't any compilers that strictly support only that F95 subset - unless you force compliance with a compiler flag. It's all just "Fortran", and your compiler almost certainly supports the "do concurrent" construct. There's no reason to restrict yourself to only the F95 standard.
I'll try throwing the do concurrent in there now. I noticed that I couldn't use write or print inside forall either, so do concurrent may help me out that way as well. *my IDE doesn't seem to recognize "do concurrent". so it may not be a fortran95 problem so much as it is an IDE problem.
forall and do concurrent have restrictions on what they do inside their bodies. you can't use any kind of write statement (wouldn't make sense anyway, as the essence of do concurrent is that the loop elements can be executed in *any* order), and you can only use *pure* functions inside them. basically, they need to be "free of any side effects" (can't affect any other part of code) and can be executed in any order. when you're looping through something with a write statement, you have to use the normal do construct. Don't worry about what your editor recognizes syntactically; it's only the compiler that matters.
Please post actual code of a short reproducer - difficult to help without. One of the first things to check: do you have "implicit none" in there? If not, your variable types will be defined by the first characters, so that RANDVAR would be REAL, whereas ABCD would be CHARACTER, I think. Always use "implicit none".
Hmm... I don't see why this shouldn't work. but you can capture the essence of this loop in a much simpler way: do while (converge) [commands] end do One thing you should change... the subroutine should have a different name than the variable "converge". there are also functions in fortran, whose names actually function as variables. But a subroutine is appropriate here. 
I compiled it and it worked. (After changing the name of the subroutine). You may want to try a different compiler, or change the logic tests to : if (converge .eqv. .true. ) instead of if (converge) It should work either way, but I think i've had compilers get confused by the latter. 
Thank you for your answer. I figured out the solution to the problem (not the reason why it happened this way, though). All my variables were defined explicitely. I did not think the actual code would help in this case. For future reference, and maybe to understand why such a strange error happened : LOGICAL IMPTES, LTESTM REAL ABCD CHARACTER (LEN=3), DIMENSION(99) :: CTAB INTEGER, DIMENSION(400):: ITAB, TTAB REAL, DIMENSION(400):: RTAB IMPTES = LTESTM ('program') CALL LECINR ('VARIABLE1',ABCD,1,1,IRET) IF (IMPTES) WRITE (6,*) 'TEST1',ABCD CALL LECINF ('VARIABLE2',ITAB,RTAB,CTAB,TTAB,NBTAB,1,IRETUR) IF (IMPTES) WRITE (6,*) 'TEST2',ABCD TEST1 = value expected TEST2 = default (E-194) I use this code in another bigger program. IMPTES getting to true print stuff in a file. LECINR and LECINF read from a file and assign to variables. The subroutine LECINF has nothing whatsoever to do with ABCD. I believe my problem came from the fact that the variable CTAB was not receiving data as I expected. Changing : CHARACTER (LEN=3), DIMENSION(99) :: CTAB into : CHARACTER (LEN=80), DIMENSION(99) :: CTAB solved everything. I still do not understand the change in the ABCD variable.
The question ended up being answered on stackoverflow [here](http://stackoverflow.com/questions/19881893/assigning-a-routine-name-to-a-different-routine-in-fortran?noredirect=1#comment29582917_19881893).
Yes, you can do: Call system(command, mystatus) Where `mystatus` is an optional integer that returns 0 on success. The fortran 2008 standard expands upon this with `EXECUTE_COMMAND_LINE`. [GFortran docs article.](http://gcc.gnu.org/onlinedocs/gfortran/EXECUTE_005fCOMMAND_005fLINE.html#EXECUTE_005fCOMMAND_005fLINE) 
Thanks for your input. The problem is that x(I) is calculated deep within many function calls, and the outer loop is almost at the top level (it's for a fluid dynamics simulation). Therefore, in order to write it, I would have to change a large number of functions, each one passing data back to the main program, and then write it one the loop completes. 
Ok, that makes more sense. To go back to your original question, open the file at the head of the program and then: Write(10,*) x(i) As you said, then close(10) later on?
That's a good idea. It would still be nice to be able to just do something like: WRITE("descriptive_file_name",*) x(I) It looks like there isn't such a functionality though.
Actually, that's pretty easy: My_unit =10 OPEN(my_unit, blah blah blah) Then you could: Write(my_unit,*) x(i) Hope that's a bit easier? Obviously you could call my_unit whatever you like, so it reads better in English in your code :)
I use sublime text and gfortran, but its all down to preference really. If you want to use an IDE I was forced to use eclipse once and that seems fine if you're into that sort of thing. I know plenty of people who won't use anything other than vim/Emacs though.
emacs will take care of syntax highlighting. If you are motivated you can also compile with gfortran and perform debugging without ever leaving emacs. However, I still compile outside of emacs. I am not motivated :-(
What kind of architecture does this supercomputer have? That can certainly whittle down your available choices. For compilers, the best one, in my opinion, is Intel. The people behind it are some of the best in the industry, and it is constantly being updated and optimized. The GNU compilers aren't bad, but they aren't great, either. I have used them for my own little projects, but I would not use them for any sort of simulation. As for IDE's, you have many choices. Photran will work in Linux, as will Codeblocks. I don't have any experience with any of the others mentioned, however.
I use kate and gfortran (the KDE Advanced Text Editor) there is also kdevelop which is more integrated.
Thank you! I need it for educational use not commercial so I will look into it.
Gedit has Fortran syntax highlighting so if that's all you want it should be fine. It does have plugins available to add some extra IDE like features.
Many editors provide Fortran syntax highlighting. When working over SSH I tend to use console applications (vim, which does highlighting for Fortran just fine). Then you do not need to care about X and you can be pretty sure it is already installed on the system. As you get used to it, I now exclusively use vim for all my editing tasks... Anyway an alternative, that I think was not yet provided in the other answers could be [geany](http://www.geany.org/). As for the compiler, the GCC fares just fine in my opinion. To compare who supports what, [this table in the fortranwiki](http://fortranwiki.org/fortran/show/Fortran+2003+status) is useful.
&gt;Here I had this impression that Fortran was a big bad scary hard language.. but it really looks fairly straight forward. Fortran is definitely not a "big" or "hard" language. One of its strengths is its simplicity and usually clear syntax for mathematical code. It's a much, much smaller language than C++ for example, which I'd place at the other end of the spectrum. Part of its downfall is in that simplicity. Prior to the 2003 update (which only recently is pretty well supported by compilers) there was no support for object oriented programming, which is the de facto standard for handling large, complex pieces of software. It also lacks the niceties of things like C++'s STL, which makes any given development project take more time than it would otherwise. And much of how it actually does implement OOP feels extremely awkward or questionable to a C++ programmer. In the past year I've gone back and forth between C++ and Fortran for my CFD codes. Modern Fortran has a lot of things going for it (native multi-dimensional arrays and vector statements that actually work well, co-arrays for parallelism, clean syntax) but in places where it's bad, it's a deal-breaker. IMO, it becomes extremely painful to use for anything non-mathematical, and even in my massively parallel number-crunching codes, the majority of the code is for managing complexity, not hard computation.
Funny enough, this particular application I am working with ships their 2013 release with examples done in Fortran 77.
That's... unfortunate. Seriously though, they should clean it up to Fortran 2003 unless they're shipping back in time.
I learned most of my programming (some in school but mostly by doing) in Matlab with zero OOP. Super easy to hack stuff together. As I've had to get into making bigger programs and interface with more things, taking a side step and learning some C# really opened my eyes quite a bit to usefulness of OOP. To be fair, it can be quite useful to get in that mindset - even as an engineer. But probably not the thing to teach in undergrad.
I coded in F77 for a class in my undergraduate math degree. Fucking hated it.
Indeed. To be fair they're in a bit of a weird place, lot of their core code is now a mix of Fortran and C/C++, but I believe C solvers are their forward direction. Still, you'd think.. either ship with Fortran 2003 or with C++ and not an ancient standard. This particular application is a bit of a niche field as it is, with a handful of folks who have been doing it for a long time - and then a very few just getting into it now. Then again I suppose that's not uncommon for those heavy into Fortran programming :)
&gt; why we bother teaching OOP to engineers is beyond me. [Every major scientific programming library that has come up in the past 15+ years has been object oriented.](http://scicomp.stackexchange.com/questions/8845/object-oriented-programming-on-finite-difference-method/8846#8846) If all you're ever doing is "quickly hacking together" a hundred lines of code, then maybe you don't need OOP. But if you're crafting a large piece of scientific software, OOP is the only viable method to manage it. I've considered going the Python+Fortran mix for my codes, but it can be very unwieldy to scale it to complex programs. You lose a lot of the advantages of both languages when you force a tight interface between them.
Often the choice when taking a numerical analysis course is between C and Fortran. C is obviously the more general purpose language with far more influential syntax so most people are going to choose C simply for these reasons before they have even considered which one is best for numerical analysis. In my experience though I've seen Fortran maintain itself in academia and industry. If I were to start a new code I'd choose Fortran as in my opinion, it's much harder to make bad design choices.
I started with C++, but my current lab uses Fortran. We use fftw and hdf libraries, so all of our high performance stuff is in C. Can you name high-performance a library that is written in Fortran? Or demonstrate some code that is faster than C/C++? Everyone says that Fortran is fast, but I have never seen an example. For recursion, Fortran is known to be quite slow, at least. Also, upper and lower case variable names and type-checking are seriously missing in Fortran 95. Do they exist in the later versions?
To get support for F77 and other much more modern versions of Fortran you can install the gfortran compiler, which is GNU. You can download the binary installers [here](http://gcc.gnu.org/wiki/GFortranBinaries#MacOS).
*Here's the linked section [Fortran 2003](http://en.wikipedia.org/wiki/Fortran#Fortran 2003) from Wikipedia article [Fortran](http://en.wikipedia.org/wiki/Fortran)* : --- &gt;Fortran 2003, officially published as ISO/IEC 1539-1:2004, is a major revision introducing many new features. A comprehensive summary of the new features of Fortran 2003 is available at the Fortran Working Group (ISO/IEC JTC1/SC22/WG5) official Web site. &gt;From that article, the major enhancements for this revision include: &gt;Derived type enhancements: parameterized derived types, improved control of accessibility, improved structure constructors, and finalizers. &gt;Object-oriented programming support: type extension and inheritance, polymorphism, dynamic type allocation, and type-bound procedures, providing complete support for abstract data types. &gt;Data manipulation enhancements: allocatable components (incorporating TR 15581), deferred type parameters, VOLATILE attribute, explicit type specification in array constructors and allocate statements, pointer enhancements, extended initialization expressions, and enhanced intrinsic procedures. &gt;Input/output enhancements: asynchronous transfer, stream access, user specified transfer operations for derived types, user specified control of rounding during format conversions, named constants for preconnected units, the FLUSH statement, regularization of keywords, and access to error messages. &gt;Procedure pointers. &gt;Support for IEEE floating-point arithmetic and floating point exception handling (incorporating TR 15580). &gt;Interoperability with the C programming language. &gt;Support for international usage: access to ISO 10646 4-byte characters and choice of decimal or comma in numeric formatted input/output. &gt;Enhanced integration with the host operating system: access to command line arguments, environment variables, and processor error messages. &gt;An important supplement to Fortran 2003 was the ISO technical report TR-19767: Enhanced module facilities in Fortran. This report provided submodules, which make Fortran modules more similar to Modula-2 modules. They are similar to Ada private child subunits. This allows the specification and implementation of a module to be expressed in separate program units, which improves packaging of large libraries, allows preservation of trade secrets while publishing definitive interfaces, and prevents compilation cascades. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/ShepardRTC can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**To summon**: wikibot, what is something?)
&gt; Also, upper and lower case variable names and type-checking are seriously missing in Fortran 95. Do they exist in the later versions? Case sensitivity will never be seen in any version of Fortran because it would break backwards compatibility. Fortran 95 does have type-checking in the form of procedure interfaces, and 2003 has a "select type" construct for dealing with polymorphism. As far as performance goes, every multi-dimensional array library for C++ I've used (and I've tested a lot) has been both painfully slower than Fortran's native multi-dimensional arrays, and much less elegant. &gt;Can you name high-performance a library that is written in Fortran? Seriously? BLAS, LINPACK, LAPACK, ATLAS, basically anything used for HPC benchmarks... I personally prefer C++ for large-scale HPC software. After that, forced to choose between C and Fortran 95, I'd probably choose C. But I'd take Fortran 2003 over C by leaps and bounds. 
Yep! I use it for running simulations with our states super computer. I could use MATLAB but the computing time would make it pointless. It still takes ~3 days to finish most of my fortran simulations.
Thanks for the examples, I will check them out. I was honestly not aware that there was much out there. However, every library you mentioned is pretty old, most having been written in F77 originally, then updated or replaced. So, no one is writing any new HPC libraries in Fortran? As for C++ array libraries, you might find http://www.math.ualberta.ca/~bowman/Array.html interesting.
Thanks for the links. From the benchmarks, it looks like the best Fortran implementation is almost always slower than the best C/C++ implementation. The library linked is in Fortran, and has been for the last 40 years.
Fortran also has a native Complex type and an exponential operator, which C and C++ both lack. But I also find that this does not make up for the lack of features in general.
I am currently updating molecular modeling software code that was written in F77 to use modern fortran (F9X-F200X). I am writing it with a functional approach, mainly by translating subroutines that read/write a common block into functions, with no side-effects, that only accept arguments and return a value. I am also translating it into clojure as I go along. This is so that I can model new features in clojure before implementing them in fortran. I am using the [Clatrix](https://github.com/tel/clatrix) library with the clojure version, so I hope the native calls to BLAS will make the speed of the clojure version be within an order of magnitude of the fortran version. If using clojure with clatrix will give me speeds that are within an order of magnitude of the native fortran code, than I will start translating more molecular modeling code to clojure. If not, than I will work on a clojure-&gt;fortran translator, along the lines of [this](http://sage.math.washington.edu/home/wstein/www/home/tornaria/maxima-pexpect-bug/maxima-5.16.3/src/share/contrib/gentran/lspfor.lisp). Fortran is elegant, but I still prefer clojure. Things I am not aware of existing in fortran that would be nice: 1. set once and deleted never data structures i.e. immutable data structures 2. better destructuring when assigning values. It would be nice to write in fortran integer :: a,b,c,d,e a,b,c,d,e = func_that_returns_five_element_integer_array() 3. syntax nitpick: more elegant assignment of matrix values. I can do this: integer(1),dimension(3) :: matrix matrix = [1,0,1] I wish I could do stuff like : integer(1),dimension(3,3) :: matrix matrix = [[1,0,1],[0,1,0],[1,0,1]]
&gt; So, no one is writing any new HPC libraries in Fortran? I'm not really in a position of authority to say, but probably not libraries. Especially with the newfound importance of heterogeneous architectures. Large scale applications though, yes, people are returning to Fortran. &gt; As for C++ array libraries, you might find http://www.math.ualberta.ca/~bowman/Array.html interesting. One of my requirements to call a C++ multi-dimensional array library "good" are that it be well-maintained, so one man's side project doesn't really work. This also nixes blitz++ for me, which gets a Fortran level of performance but isn't actively maintained. boost::multi_array is probably the best supported but it's performance is around half of what I see in Fortran. It's really a shame, but this sorry state of affairs is literally the only major issue on my C++ vs Fortran list that goes in Fortran's favor. When you have array-intensive code, C++ can get awfully messy, and I really like my mathematical code to be as clean as humanly possible, and Fortran's vectorized array statements do that perfectly, and I never have to worry about compatibility or portability in the future. 
Unless you studied 20 years ago, I am sorry you had such an outdated teacher.
I just finished up nuclear engineering at NCSU last December. FORTRAN was the mandatory CSC course for all of us. It was also recommended for the ME and Aero guys as well. I believe they had the option of Java and C/C++, but there were a lot of them in the class so I'm not positive. I transferred in to NCSU, and the course required for engineering transfer was C/C++ at the local CC. At the time I was dating a M.S. in CSC and even with her help, C/C++ was a miserable experience. The main reason was the OOP &amp; pointers portions of the course that was cobbled in and not really fully explained to its use in real-world situations. FORTRAN, on the other hand was extremely easy to pick up. I lost my fear of coding, and used it for the rest of my time in school for nearly all my homework. 
[serious!] I am curious as to where you see benefits in OOP (as an engineer).
I agree legibility is generally a strong suit in Fortran (especially vectorized statements instead of explicit loops), although INTENT statements have their counterpart in C/C++ languages with "const" specifiers and if things are passed by address, value, or pointer. I definitely prefer C's declaration of types in the actual function prototypes themselves though. And the inability to declare variables where they are used hurts clarity in Fortran, IMO. The misuse and abuse of the module facility I've seen in large Fortran programs is enfuriating though (picture a subroutine USE'ing several modules with hundreds of variables each, and having no damn idea where a given variable comes from.) I think 2003's OOP syntax is terrible for legibility, personally. The "%" operator is massive, and I end up using a lot of ASSOCIATE statements to clean up code. I suppose I could just tell emacs to adjust the % symbol though...
Thank you, got it set up. Do you have any suggestions for a good text editor for Fortran or Development area? I saw jEdit has a fortran option. 
I definitely agree that multi-dimensional arrays (including the array slicing syntax) are the obvious place where Fortran wins over C/C++. And, in fact, if there were a better multi-dimensional array class for C++, I might finally make the switch to C++ for new projects. Also, as far as BLAS, LINPACK, LAPACK, etc, these are indeed old, but they are very commonly used today (you may not realize it, but if you use Matlab, Python/Numpy, Trilinos, PETSc, and seemingly almost any software that solves linear systems, you are probably using these packages under the hood). In that sense, none of them have really been "replaced". They are the go-to libraries for the majority of applications that need something like them. For the most part, it's only the C/C++ wrappers that *appear* to be replacing them. Even so, it's probably true that for new libraries starting from scratch, C and C++ are winning over Fortran. I suspect some of that may be due to the open source culture (github and it predecessors) better permeating the C++ world than it does the Fortran world, but that's wild speculation. It is likely also because Fortran is such an old language with some backwards-compatibility baggage that it's just not hip anymore, although it really is (in its modern form) a pretty decent language to develop scientific and engineering software in. 
Well, I've come to value organization, efficiency, compactness, with the more programming I do. Especially working with a variety of data and model types which are related to each other.. encapsulation and inheritance, even polymorphism are really nice traits. 
One concrete non-culture reason new libraries would use C languages is that Fortran doesn't allow direct memory access and management. Think of MPI libraries (OpenMPI, MPICH). They need to have very low level access to memory in order to properly send and receive information between processes, which is why these things are written in C. Hell, the intel fortran compiler is probably itself written in C.
&gt; Then again, for those people, Python and Matlab may be what they are looking for, and it looks as if Fortran is being squeezed from both sides. Yeah, well put, that's certainly true for me. If I need to do some non-computationally-intensive scripting I reach for Python. If I need to quickly test out some numerical algorithm, I go for Matlab. If I need to craft a large piece of high-performance parallel software for number crunching, I go for C++. Fortran's use-case is definitely being squeezed from both sides, although I'm interested in seeing if co-arrays become widely adopted/supported. It's by far the easiest way to effectively write high performance parallel software now, and the only way to do it with standards-compliant code / not relying on any libraries.
&gt; set once and deleted never data structures i.e. immutable data structures See this [single design pattern in fortran example,](https://modelingguru.nasa.gov/thread/1114) it might be what you're looking for. You should be able to implement this just with a class with private member variables and Get methods. &gt; better destructuring when assigning values. It would be nice to write in fortran func_that_returns_five_element_integer_array() Yeah, won't be able to do that directly as five different elements, but you can write a function whose return type is size 5 array. &gt; syntax nitpick: more elegant assignment of matrix values. I wish I could do stuff like : You can: integer,dimension(3,3) :: matrix matrix = reshape( (/ 1,0,1,0,1,0,1,0,1 /), shape(matrix) ) 
Never have I ever used a Mac! Any text editor with syntax highlighting will do for basic development coupled with the terminal for compiling, debugging and running programs.
With Intel's compiler, you can use the "." operator instead of "%"
Oh wow, I had no idea! That's nice of them, although I don't think I'll be using that as I avoid non-standard stuff like the plague
Yes, but you'll need to run it under MinGW (luckily its included with it). MinGW: http://www.mingw.org/ Top right is the link to the installer. Install it and you should be able to run gfortran from its command line (MinGW Shell). 
Cool, thanks again for the help!
I agree, there's a lot of wiggle-room with the implementation. That said, the site compiled Fortran with Intel and C++ with gcc, and I usually find that the Intel compiler produces faster binaries. Development time (at least for small projects) might be less with Fortran.
Thanks for the reply. I tried writing ZHEEVD instead of HEEVD with no result. Defining an interface or declaring the subroutine as external sounds like it's the way to go. As I said I am new to FORTRAN and have no idea how to do this - can you help? edit: It turns out that I am not capable of spelling. It does compile with zheevd instead of heevd. Thank you very much! Now I just need to figure out why I get a memory error - will post again if I need more help :)
Hi again I can't figure out why I get a memory error. The program compiles flawlessly, but when I run it I get the following error Program received signal SIGSEGV: Segmentation fault - invalid memory reference. Backtrace for this error: #0 0x7FC921663117 #1 0x7FC9216636F4 #2 0x7FC920FB30AF #3 0x7FC921A0A115 #4 0x40BEDF in test at test.f90:159 Segmentation fault (core dumped) Line 159 reads call zheevd(Hup, Evalup,'V') and Hup has been allocated as a complex 16x16 matrix, Evalup as an array with 16 entries. Any help?
Of course it will! You'll need to download an appropriate version, of course. MinGW is certainly an option. If you're looking for a more Windows-ish version, you could try [Simply Fortran](http://simplyfortran.com/), which includes an IDE as well. It is a commercial distribution, though, so you'd need to register after a trial period to continue using the IDE (the compiler will work still, of course). Please note that I am the primary developer of Simply Fortran, though, so I am obviously biased. If you do like it, though, send me a PM and I'll be happy to provide you (or any redditor) with a discount code.
Edit: made a much simpler example program minimal_example implicit none integer :: k complex :: H(4,4) real :: Eval(4) do k=1,4 H(k,k)=(1d0,0d0) enddo H(1,2)=(0d0,1d0) H(2,1)=(0d0,-1d0) call zheevd(H, Eval) end program minimal_example gfortran minimal_example.f90 -o minimal_example -L$HOME/libf77/$ARCH -llapack -lblas -fbounds-check -Wall -Wextra -g ./minimal_example
The memory error is occurring when you call zheevd (I did print *, "test" before and after). I believe for zheevd you are missing some arguments in your call: http://www.netlib.org/lapack/explore-html/d6/dae/zheevd_8f.html#a9b3e110476166e66f2f62fa1fba6344a
Yes! I have Simply Fortran and I can attest that its a great option as well. I would absolutely recommend it. And the package manager makes life so much easier.
Yup there are some parameters missing. Here's some code to help. If you need further explanation don't be afraid to ask. I used tchillarke's link to put it together: &gt; http://www.netlib.org/lapack/explore-html/d6/dae/zheevd_8f.html#a9b3e110476166e66f2f62fa1fba6344a[1] edit: Ok link below. Works with gfortran and ubuntu repo of lapack and blas as well as ifort with mkl. Again, just ask if you need further clarification. https://github.com/jecyrd/randomStuff/blob/master/min_example.f90
&gt; usually find that the Intel compiler produces faster binaries. In the large projects I've tested this on, I've found the intel compiler to be considerably better than gfortran, but the intel C++ binaries to be dog-slow compared to g++ and painfully slow for compiling heavily templated code. But obviously there's a lot of variables there.
Thank you so much, it works now! So I guess it all boils down to me getting confused by the fortran 77 vs fortran 95 thing. Out of curiosity: do you know if/how I could make it work with fortran 95 syntax? From the help page I quoted in the original post it should be call heevd(a, w [,job] [,uplo] [,info]) which is much simpler to use. edit: formatting..
I've never used the F95 interfaces. But it seems like those might be specific to Intel Math Kernel Library (MKL). Which is Intel's implementation of lapack/blas. Intel Fortran compiler is free for education use (or used to be) and comes with MKL.
You should always declare the size of your REAL's using the KIND statement if you want any sort of consistency when handling floats. The differences you are seeing are likely rounding issues. As far as coding guidelines it's all down to preference since Fortran is case insensitive. I personally use all caps for keywords and PARAMETERS and lowercase for everything else that I have defined be it functions, subroutines, variables or modules. I don't think the auto-vectorization works to spread the computation across multiple threads but rather makes use of CPU instructions(e.g. SIMD instructions, SSE, AVX on x86) on a single processor to speed up computation. I suspect that your compiler is able to make use of more sophisticated instructions on the x86-64 architecture over the PPC. If you wanted to make use of that second core you'd have to use something like OpenMP.
I use sublime text on mac but you have to download the fortran highlighting package manually. There's emacs and vim if you have the time to learn them. If not and you just want something to work the way you'd expect there's textwrangler.
OKay, thanks again. I now have a more serious issue. In the code you wrote, the upper triangular part of H is filled with ones. The eigenvalues I get are -1 0.77 1 3.22 If I understand correctly, this means it calculates the eigenvalues of a matrix filled with ones. In matlab I get 0 0 0 4 What's going on here?
Ooops. I messed up here, didn't read the documentation well enough. The sizes of the arrays work, rwork, and iwork. Were not correct. Corrected: https://github.com/jecyrd/randomStuff/blob/1275f7b9d2f29fca120edd19f09dce365f57e2b2/min_example.f90 Look at the comments for work, rwork, and iwork. Basically taken straight from the documentation. Now when I run this with ifort/mkl I get eigenvalues: -7.581077015868177E-016 -1.300707181133075E-016 0.000000000000000E+000 4.00000000000000 and with gfortran and the ubuntu repo lapack and blas: -7.58107701586817699E-016 -1.30070718113307534E-016 0.0000000000000000 3.9999999999999996 Those first two numbers that are e^-16, are zero for this problem. So if it were me here, I would probably have some sort of check to see if the values are smaller than 10^-15 and if they are just call them zero. For this particular simple example anyway. And the difference between 3.9.. and 4.0 is because different compilers can handle floating point numbers differently. May be helpful to understand floating point representation. http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems Hope that helps.
The advice that you should write out do loops explicitly instead of using vectorial operations stems from the time when fortran 90 compilers just came out and when new fortran 90 features where often not directly implemented in the most efficient way. This is absolutely wrong now. The whole point about having intrinsic vector operations is that it makes it much easier for the compiler to interpret what sort of operation is being performed and thus optimise for it. Also it's much easier to read for humans of course. /u/imsittingdown is right: gfortran will use single precision by default (like most compilers) which probably explains your round off errors, but it's better to be explicit what precision you want. I always use: integer, parameter:: DP=selected_real_kind(0.0d0) ! somewhere on top real(kind=DP):: x, y, z ! everywhere else As you can see I use smallcaps everywhere except for parameters (I don't like shouting). I don't mind initial capitals for some categories of names (say subroutines) as long as it's done consistently. Also maintaining the punchcard 7 column indent seems silly to me. Some other recommendations: * always use intent for all subroutine arguments. It's not only good for optimisation it also make it easier to read/reason about your code. * always have explicit interfaces for subroutines by putting them in modules. Again good for optimisation but also enables the compiler to tell you off when you've messed up the arguments in a call. Another advantage is that you no longer have to pass in the size of arrays seperately: subroutine mmul(a, b, r) real, dimension(:,:), intent(in) :: a, b real, dimension(:,:), intent(out) :: r Oh and one last thing: using extra spaces to align bits in the middle of consecutive lines (as opposed to indenting) is the spawn of the devil!
yes i know that defining and using the proper kinds is the proper way, i was modifying the fortran 77 program which i tested on a very old compiler to the newer standard. Also every number should have the _kind postfix when using it. It's nonsense to use a mix of 77/90 format (like the indentation and continuation) indeed. I guess this is to help conversion for older compilers. I'll start using lowercase more, thanks. I've compiled it with -S to see the assembler source and gfortran uses a lot of simd instructions, especially when using single precision. I haven't yet figured out how the matmul statement is translated in regard to the do loop, i'll try to compile with -Wa,-alh tomorrow and see if that gives a bit better output. The matmul however is just call _gfortran_matmul_r4 This runtime isn't compiled with -ffast-math and hence the difference i think. You are very right in sophistication of instructions, the powerpc doesn't have altivec and is quite old, i don't see much difference other then some reordering of registers and operations there. I tried openmp but i can't get it right. After increasing stack size (since it segfaults otherwise) it even runs slower when i use !$omp parallel do for the outer or second loop. I also got wrong results when fiddling with that but i don't have much experience with openmp so i don't know what's the best way for strategy and declaring variables (and which ones) private.
i see, i wondered why articles mentioned it because i think it indeed should aid in optimization. The round off errors also occur when i use real*8 or double precision so i think it's related to the runtime not using -ffast-math and the loop using it. I read that using the dimension statement like that wasn't preferred but instead use real, intent(in) :: a(:,:), b(:,:) would that be any different and why should one be better then the other? Also this seems to be recommended in operations, like r(:,:) = a(:,:) + b(:,:) It makes things clearer indeed. Thanks very much for your recommendations! I'm not sure what you mean with the last line however. Do you mean the write statement over multiple lines?
i should modify the check to use epsilon also i think. F90 has an intrinsic for that. Also i should take things in perspective; c89 is something i used much more and the f90 standard is close. It also took forever to loose k&amp;r syntax in compilers.
Compiling with -Wa,-alh didn't show more (i expected more information with source code lines and such). The mmul do loop looks like it's unrolled in asm (with lot's of prefetch and simd instructions) but matmul is still a call to the runtime subroutine. I should take a look at the source for that, i wonder why there's such a difference in speed. Maybe (probably) they use a better algorithm for it but it's funny that on older hardware (like the powerpc) there isn't such a difference. I mean, the do loop uses simd also so it shouldn't be that much of a difference. It's getting very late though so i will save this for later on. 
Thanks a lot, now I can finally move on to actually write my program :) The numbers are going to be part of a huge sum later on, so whether they are zero or as close to zero to make no difference will not matter (except maybe for execution time?) One thing I really don't understand, though, is the purpose of work, lwork, rwork, lrwork, iwork and liwork? They seem to be just magic numbers that you have to type to make lapack happy?
They are low level parameters for people who want more control of memory allocation and performance. http://www.netlib.org/lapack-dev/lapack-coding/program-style.html#_workspace_and_memory_management_a_id_workspace_a If you stick to the minimum requirements as outlined in the documentation then you should be fine.
Thanks again, you have been a great help!
Sorry, I'm on my phone so I can't give you a detailed answer. You can allocate your array with an 'allocate' statement - as opposed to declaring them with a set size. 
Ouch, that looks ugly to do... If you know how many entries are on each line, (ie is it 1, 3, 5 etc?) then you could make an array containing that info. NENTRIES I'd then make an array to fill which is as wide as the longest line, so nlines x maxwidth (is that 21 for you?) ALLOCATE( DATA(NLINES, MAXWIDTH) ) Then read with a single do loop Do I=1, NLINES WIDTH = NENTRIES(I) Read( ) (DATA(I, J), J=1, WIDTH) End do The read line uses what's called an implied do loop http://software.intel.com/sites/products/documentation/doclib/stdxe/2013/composerxe/compiler/fortran-mac/GUID-678F0090-AEC9-4F08-8A42-0759203C28F0.htm So the DATA array is fairly empty in hindsight, you could probably rejig what I've done to use a 1D array by keeping track of where you last put stuff... Read( ) (DATA(J), J= lastentry, lastentry + width) Sorry about formatting, I've got a cold. Good luck! 
gfortran does vectorize array operations. I noticed it with another test program; 90: LOOP VECTORIZED. 88: LOOP VECTORIZED. 85: LOOP VECTORIZED. 85 forall (i = 1:ts) x(i) = real(i, rp) * dx 87 y(:) = y0 + x(:) * tan(angle) - &amp; 88 (g * x(:)**2) / (2.0_rp * (v * cos(angle))**2) 89 vx(:) = sqrt(v**2 - 2.0_rp * g * x(:) * tan(angle) + &amp; 90 ((g * x(:)) / (v * cos(angle)))**2) That said i'm trying things with openmp and failing to make it work properly. If i'm not mistaken !$omp parallel workshare should make a forall loop distribute over threads for example but it doesn't in yet another test program. Also it doesn't distribute the matmul statement. I don't think this works (yet) with gfortran. Parallel do loops do however although on smaller (well, what is small) arrays it tend to take longer than vectorized ones. Neat stuff this fortran 90 and upwards. I never used it before since there were no compilers for older hardware but thinking about it it wouldn't make much sense. It would be nice to have though on the c64 so ;) EDIT: i should add, this is quite an accomplishment for a compiler, i never got further than [let's build a compiler](http://www.compilers.iecc.com/crenshaw/) and i'm intrigued by the way optimizing works. Is there a subreddit for that? 
I know absolutely no FOTRAN but seeing as no-one has replied I'll post [this](http://rosettacode.org/wiki/Matrix_arithmetic#Fortran) and hope the example gives some insite to you, dear OP.
I believe it is much more efficient to convert the matrix to triangular or diagonal form and multiply the diagonal elements.
Well, instead of reinventing the wheel, try using LAPACK: http://www.netlib.org/lapack/ 
[LUD](http://en.wikipedia.org/wiki/LU_decomposition) is a general way to do it that is used in lots of computational science codes. When I need to understand/implement a numerical algorithm, I always check if it is in Numerical Recipes first. The Fortran versions are free [from here](http://www.nr.com/oldverswitcher.html) but are now 18 years out of date. Like /u/ShepardRTC said, if you are trying to *use* the algorithm rather than implement/understand it yourself, use the LAPACK routine. They're highly optimised and protect you from almost all of the detail.
Nope. http://www.netlib.org/lapack/faq.html#_are_there_routines_in_lapack_to_compute_determinants
While you are correct that there are no specific routines to find the determinant, other LAPACK routines will make finding it much, much easier.
I agree with the majority here, an LU decomposition with LAPACK is the way to go. Notice that the determinant of a triangular matrix (L and U are triangular matrices) is simply the product of its diagonal elements. 
I'm not sure if this is causing your problem, but it seems to me you keep allocating the array B on line 47 without deallocating it. Maybe it silently fails, and later causes the crash when using B. 
I think you will need to provide more info to get a true answer. You say the value you need for the 77 program is from the middle of the 95 program, is it the main output of the 95 output? It seems like you should be able to change the main 95 program into a subroutine and call it from the 77 routine. If the code isn't too long, why don't you upload it somewhere and let us know what you are trying to get out of it?
It's not the main output of the 95, it's a correction factor in the midst of the first subroutine. And the code is like 1800 lines long with both codes combined, I'll try to post the 95 code and let you see the variable I need from it
Here is the 95 code, I usually compile it in gfortran: http://pastebin.com/xXmgfWpY I am looking to call the Xx2 and Xx3 at their final values in the do loop
Make the main program into a subroutine and encapsulate it and other assosciated subroutines into a module. Then change the variables read in to passed parameters of the subroutine. Then define interfaces in the F77 code for your F95 subroutine. You may need to compile the F95 as a module separately from the F77. On mobile currently but hopefully that gets you started.
Questions: How do you turn it into a module? I assume to turn it into a subroutine, I just redefine the function. What do you mean by passed parameters?
I think making the program is into a module is a bit overkill, but you could do that. What I did, was remove the main program from the code, and add Xx2 and Xx3 to the output variables of the abbration subroutine (call this subs1.F90): http://pastebin.com/HJ281t3k Then I created a test program (this is your 77 program for you) in another file to call the subroutine (call this main.F90): http://pastebin.com/9WxKePVN Then when you compile use: gfortran main.F90 subs.F90
For my F77 code, do I just add all the variables and the call line into it? Here's the first couple of lines of it. Do I add "USE types_module" right under program, and add the rest of the variables in there? PROGRAM TOT_REACTION_CROSSX EXTERNAL TXSEC,RXSEC INTEGER PP,PT REAL RTSC, RSIGMA,TTSC, TSIGMA DIMENSION IAT(12) DIMENSION E(39) COMMON/EXX/ EIN COMMON /JAR/ N COMMON /ARS/ NT,PT,NP,PP,AP,AT COMMON /EXC/ DCS,SCS 
Yes, you probably already have the input variables defined, you will just need to define the output variables. You could remove the output variables you don't need from the abbration subroutine if you wanted.
Alrighty! Now the only problem I'm having is that it isn't recognizing that I gave the variables values at the start of the program, so all of my calculations are coming back as 0s. But I'm sure I can find a way to fix it. Thank you so much for all of your help!
This code loops through the string in a and counts the number of times the string 'or' appears in the string stored in a. do i = 1 , len(a)-1 This line defines the value of i (I've used lowercase loop variable here as is standard practice) so that it loops from the first character in a to the penultimate character. len(a) returns the number of characters in the string a. if (a(i:i+1) .eq. 'or') then This if statement checks whether the character at position i in the string a and the next character along (i+1) form the string 'or' (the colon means 'to', for example 1:5 means '1 to 5 in increments of 1'). If it does a counter c is incremented by 1 thus on completion of the do loop c will contain the number of 'or's in a. 
thanks a lot! :)
gfortran, and most modern compilers, are loose with their enforcement of standards from particular versions. Try running this with the strict f77 checking turned on. Even then, that might only check syntax, not prevent automatic deallocation. Maybe also run this in a loop and see if the memory usage goes up.
The array 'a' you are using is an automatic array, i.e. a local *non-dummy* variable whose length is non-constant. This is a fortran 90 feature. Fortran 77 it was possible to declare dummy variables whose length depends on other arguments to the subroutine, but that doesn't really help you to achieve dynamic allocation as you would need to have the array in the first place to pass to the subroutine. Whether automatic arrays are allocated on the heap or on the stack is up to the compiler (such platform specific things don't go into the fortran standard) and may depend on compiler flags. gfortran puts most things on the heap by default (I think you can specify the maximum size of things to be put on stack?), ifort (intel) puts all arrays on the stack by default (at least it used to), but you can switch that off. Putting big things on the stack is a bad idea as most machines are configured with a limited stack-size and you get segfaults if you overrun.
yes i've encountered stack size before, certainly when using openmp. I'm not sure about this being a f90 feature though, in f77 this is how you'd specify array's afaik. Also this trick seems to work on f77 compilers but indeed, mostly n is a constant and arrays are static. Some platforms however don't have such a limitation so it won't matter that much. On *nix you can always adjust stack space but in this case it's not needed. I wonder how other compilers handle this in f77 mode though since as you say i'm not sure it's entirely legal.
&gt; I'm not sure about this being a f90 feature I'm absolutely positive. You can look up the fortran 77 standard online. Extensions to the standard existed long before the f90 standard came out though (but these also include allocate and deallocate). This is all a rather academic debate however as there aren't any pure f77 compilers anymore. f77 is mostly a subset of f90: all the -std=legacy flag does is allow for the few things that are no longer allowed in later standards.
Hmm, what are you trying to do that isn't working as expected? You want to have an array defined in the main program, and have that array available to the subroutine, and have it changed in the main program, specifically using F77?
Seconding /u/irondust, this is definitely an F90 feature.
no, i'm trying something which used to work years ago if i remember correctly; using a subroutine to allocate an array in f77. gfortran happily does this but doesn't check if the allocation succeeds so it crashes if it can't. I haven't had a change to try this with an '80's f77 compiler but i'm sure it worked like this. See the main program calling getval with a user supplied n and allocating an array a(n).
Could you use F2003 and instead do the following in the main program? allocatable, dimension(:) :: a integer :: n n = 13 allocate(a(n))
&gt;Treat me like I am COMPLETELY dumb (because I am when it comes to Fortran). Persistence is appreciated, even if someone initially acts annoyed. They will eventually just have to give in and help you. I am surprised your prof didn't give you an introduction on how to use a compiler on a university machine or a tutorial to get you started. If not, ask him to help get you started or if does not have the time, ask him for someone at the university who will help you with it. &gt;....but my issue is where do I code all of this and execute it. Are you aware that Python/Matlab are interpreted languages and that Fortran is a compiled language? Briefly, an interpreter reads and executes code and produces some result or effect. A compiler reads source code and translates it into a form that your system can execute directly. Interpreter: source code -&gt; compiler -&gt; results Compilers work like this: source code -&gt; compiler -&gt; executable executable -&gt; results Note: Above is not meant as a complete description of interpreters and compilers; it is more illustrative of differences in workflow. &gt;I have a Windows computer (64bit). I downloaded something called Cygwin64 after reading a bunch about Fortran. But that is as far as I have gotten. I haven't used cygwin in years, but I believe you need to run setup-x86_64.exe again in and install the gcc-fortran package (see http://cygwin.com/install.html for more information). It should be able to download and install it as well as its dependencies. After installation, you should have gfortran available in cygwin. I assume that you already know how to make a plaintext file and that your professor is using modern fortran (F9X/F20XX), so create a file named "hello_world.f90" with these lines: program main print *, "hello, world" end program main You can use pwd in cygwin like this $ pwd to see where you are currently located so you know where to save the file. now compile it: $ gfortran -o hello_world hello_world.f90 Hopefully you will have no compile errors. Now run the program you compiled: $ ./hello_world hello, world Good luck, hope this helps!
Alright, I made sure that I had the gcc-fortran package, and yes he is using a modern fortran. Now, I wish I could say I understood you the rest of the way through, however I don't. I created a plain text file, but after typing gfortran -o hello_world hello_world.f90, it is not able to find it. I am in the correct directory. I think I messed up creating this plain text file. Is there something specific I should create it in? I know these questions sound dumb! I thought I was a much better programmer than this...but this has definitely knocked my confidence back down a bit.
Ok, I'm starting to understand a bit better. Is emacs a good option? As dumb as this sounds, do I basically write everything in this...then compile it...then execute it?
Do you plan on doing a lot of coding in the future? Not matlab coding, but C++/Fortran coding? If so, an editor like emacs or vim is a wise choice. But a program like notepad++ is fine as well. But to be honest, if you are planning on pursuing coding in the future at your career and developing software rather than just utilizing preexisting software, then using windows will make things difficult for you. It would be wise to use a linux system (ubuntu is where people usually start). At first, your simple tasks may be a bit more complicated in terms of OS navigation and customization, but when it comes to coding or anything of the like, hands down a linux system will be leaps and bounds easier to use than windows. 
&gt; Ok, I'm starting to understand a bit better. Is emacs a good option? 'M-x f90-mode' is a great way to edit fortran in emacs &gt; but after typing gfortran -o hello_world hello_world.f90, it is not able to find it. Can you please copy and paste the message you receive when you try to compile it? 
I have been putting off switching to linux due to shear laziness and lack of time to figure things out. However, I know in the long run it will save me a bunch of time. I am a Mechcanical Engineer heading to start my PhD this Fall. I really enjoy coding and find that an engineer who can code can be quite useful, so I do plan on pursuing this more. That being said, I bet it is time to switch to linux after this semester is over.... I already have emacs for LaTeX, so I might as well just use that. THANK YOU!
Kristen@Kristen-PC ~ $ gfortran -o hello_world hello_world.f90 gfortran: error: hello_world.f90: No such file or directory I think I just messed up creating the plain text file. I tried Notepad...
Well if none of this free stuff is user friendly enough, my next step was to check out Simply Fortran since I have seen a lot of your posts as well as posts on the internet in various places from other people saying it is quite nice. Thanks for the heads up!
Emacs is a very solid option. Feel free to message me anytime about the transition to Linux. You'll be glad you did, no doubt about that. Especially because you'll be using high performance software. A bachelors in engineering or a masters will lead to a career that mostly involves running very polished and commercial software that windows can handle. But when working on a PhD, the chances are very high you'll need to work with more obscure codes and programming. Virtual box does a great job of setting up a virtual install of windows so you can still run your windows software. I recommend Ubuntu or Linux mint. Either is great. 
I will definitely hit you up about Linux. It's always nice having a friendly person who knows about it because some people just get frustrated with those who are not geniuses. So, emacs is a solid option? I use Texniccenter now for LaTeX so I need to figure out how to use emacs again...it's been a few years. This all just makes me feel so dumb right now. Thanks for all of your help.
Just installed Notepad++. That was so simple compared to all of these other things. UGH FRUSTRATION. Guess it's time to look into Notepad++ with Fortran. Thanks!
Assuming that hello_world.f90 is at C:\Users\Kristen\Documents\hello_world.f90 If you do a $ cp /Users/Kristen/Documents/hello_world.f90 . you will copy hello_world.f90 to the current working dir (. = cwd). 
It cannot find the file anywhere I put it. I seriously think I didn't create a .f90 file. But I am getting the hang of just commands and such in Cygwin which is a plus! Baby steps...
I have code for the first homework problem, so my professor was somewhat nice in that regard. But after this homework, my codes will be from scratch. However, I just have a printed out version so I need to type it all up somewhere (which I am assuming I should type it up in Notepad++) and then save it as a .f90 file....then use my compiler. I'm slowly but surely understanding bits and pieces. I use the command prompt for my python codes. I have the gfortran compiler as well as Cygwin64, though.
Also, I am tired of angy hate messages :( Writing my thesis right now and that is all I get because of stupid $ in LaTeX. DOLLAR SIGNS WILL BE THE DEATH OF ME!!! Why didn't I just do what my friends did and get my MRS degree instead of this engineering degree? That seemed a lot simpler. Hahaha!
I strongly suggest you sit down *in person* with someone knowledgeable enough to walk you through the basics of editing, compiling, and running code. There's too many elements here you're not getting. In your defense, it's been a sad trend for engineering departments to eliminate any requirements for learning a compiled language. It makes it very hard to get good people for CFD work at a graduate level.
I completely agree with you. I wish I knew more, but I just dont. Definitely having somebody who is able to sit down and explain the elements to me would be beneficial. Time to go to the retirement home and find people who know fortran :P Thanks!
The fortran aspect is relatively minor, and a ton of people know the language; a working knowledge is practically a pre-requisite for serious CFD work because dealing with legacy code is so common (and recent variants make it pretty damn useful for writing modern code.) Your biggest stumbling block is not understanding the cycle of edit-compile-run; you'd be having 99% of the same problems if you were working in C or C++.
LAPACK (http://www.netlib.org/lapack/) should be able to do everything you need and more.
care to give some more details? This is extremely general. Lapack will probably do whatever you need, but there are thousands and thousands of subroutines in lapack. Give us some more detiais about what type of matrix equation youre trying to solve if you want a recommendation on what lapack routine to use
I used it for a couple weeks. If you're a fan of eclipse then it's great. Some of the refactoring tools I found to be great, especially when dealing with old code. 
I installed it a while ago, but it was after I started using autotools for my build chain, and I didn't want to have to learn yet another development tool. vim + autotools + terminal = my IDE so far.
Unusable for me, the indexer never finishes running on one file. To be fair, it's 50,000 lines, but vim + ctags has no problems with it.
Make sure you use double precision instead of real. Edit: never mind just saw at the top that you are... Try n2 = real(N)
Maybe replace the decimal points in double constants with lowercase 'd's. Just a guess.
Many values, including 0.8, cannot be represented exactly as floating point numbers, as their representation in binary is non-terminating (like writing 1/3 in base 10 as 0.333333.....). Keep in mind that errors will slip in during operations on floats, so if your code requires the value of t at the eighth iteration to exactly equal 0.8, or even the floating point representation of 0.8, it's likely to fail. A single precision float should give you about 7 or 8 significant digits, which is about what you're getting. If you were using double precision values correctly you should have something more like 0.80000000000000004, or about 16 significant digits. So somewhere in your calculations a single precision value is slipping in. The ways I usually screw this up are to fail to declare one or more variables as doubles, or to use single precision literals somewhere. Single precision literals look like this 0.8 or 8.0e-1, while double precision would look like 0.8d0 or 8.0d-1. I'm not sure exactly what the rules are for conversions in operations that mix different precisions, and it may be compiler dependent. The point is that if you were to have a double precision variable and set it equal to a single precision literal, your double precision variable may only be good to single precision. Here's a toy version of your loop and it's output from gfortran: program prec implicit none real*8 init, fin, t, h integer i, N fin=1 init=0 N=10 t=init h=(fin-init)/N do i=1, N t=t+h write(*,*) t end do write(*,*) 0.8 write(*,*) 0.8d0 end program Note that none of the values are exact (except for 0.5, which can be represented exactly as a float), and that the value at step 8 is different from the value of the double precision literal for 0.8. 0.10000000000000001 0.20000000000000001 0.30000000000000004 0.40000000000000002 0.50000000000000000 0.59999999999999998 0.69999999999999996 0.79999999999999993 0.89999999999999991 0.99999999999999989 0.80000001 0.80000000000000004 
Sadly it made no difference. If i switch to direct mode and use the same record length, gfortran produces the correct output... it's strange. 
If the functions `f`, `jmtab` and `imtab` are expensive to evaluate, then it's best to use an if-then-else block, so that neither of the functions is evaluated until it's known which one should be evaluated. Something like: fn1 = f(n1) if (fn1 .eq. 0.0) then n2 = imtab(if) else if (fn1 .eq. 1.0) then n2 = jmtab(if) else print *, "invalid value of f(n1): ", fn1 end if This way, the function `f` is only evaluated once, and the functions `jmtab` and `imtab` are only evaluated when needed. 
I do the same when I'm forced to work on windows. Cygwin works fine.
That is some really heinous abuse of Fortran right there. Let me see if I understand... "if" and "f" are both arrays, not functions, correct? "if" is not the actual "if" branching statement? (I've never seen "if" abused like that, wow - are you sure that's what is happening?) The right answer is always "profile and see." But if I had to guess, I think your replacement version should be faster. The old .eq. version has to do a comparison on every element which I'd think would reduce to a branching operation which is always a bad idea. 
Are you sure you can link any program? From the error it looks like it can't find the linker executable, called ld. This looks like it has nothing to do with using any library, but that either your gfortran installation is broken or you need to set some environment variables before you use it. Ask your 'tech admin'
Yeah i figured that out just before i read your comment. ugh. this looks like a lot of fun to fix. 
This looks like exactly what Im looking for (specifically the IDE (Im lazy)). There wouldnt happen to be a student discount *wink *wink Also, more seriously, I'm trying to get away from matlab because matlab is awful (coming from someone who primarily uses python) and the pricing is so absurd it's nauseating. I'll seriously consider purchasing your IDE when I get my taxes back.
I hope you've downloaded and installed it to give it a try! We don't have any explicit discounts for students, but I try to accommodate requests. PM sent! And remember to download and install it first! 30-day free trial!
I'm...bad with navigating directories. Let's just leave it at that. "sudo apt-get install --reinstall binutils" also works 
Beautiful! Gotta love the power of gnuplot!
I think the first loop is equivalent to: do N=1,M do i=1,size(B,2) B(N,i)=A(N) end do end do The statement D=C(1:M,:)*B basically means: C(1:M,:) Is an array that is composed of the first M rows and all columns of C C(1:M,:)*B takes that array and does an element by element multiplication with B I personally hate these kinds of shortcuts. They make code hard to read and don't offer any performance increase with the correct compiler options (loop vectorization). this kind of code is commonly written by people that are used to MATLAB.
I would suggest using `geevx` instead of the subroutines you've given above. You should be able to get rid of a lot of variables and simplify the code greatly.
It's my cake day :( I really don't know hehe The only thing I can set it is "balanc"...
I actually can't even get the code to compile. I'm doing something wrong in the linking step.
To run you probably should configure those settings in Intel Visual Fortran: Project &gt; Proprieties &gt; Fortran &gt; Libraries &gt; Use Intel Math Kernel Library &gt; Sequential Project &gt; Proprieties &gt; Input &gt; (.libs below for 32 or 64 bits) 32bits: mkl_blas95.lib mkl_lapack95.lib mkl_intel_c.lib mkl_core.lib mkl_sequential.lib 64bits mkl_blas95_lp64.lib mkl_lapack95_lp64.lib mkl_intel_lp64.lib mkl_core.lib mkl_sequential.lib But I think I finally understood the problem. If I get the eigenvectors, for instance, setter "balanc" as 'N' or 'P', only the 1st column differs from the MATLAB result. But actually they are linearly dependent, since if I multiply it by "i" I get the MATLAB result. I'll check with some math guy to be sure, but I think that's it... so... both results are actually the same... 
You want the Fortran 95 intrinsic SYSTEM_CLOCK: http://gcc.gnu.org/onlinedocs/gfortran/SYSTEM_005fCLOCK.html#SYSTEM_005fCLOCK
Ah okay, I'm new to fortran so I'm not too sure if I have to make the variables explicit since I was running onto compiler issues. Thanks for the help.
Most projects I've seen use GNU autotools: http://en.wikipedia.org/wiki/GNU_build_system#GNU_Automake More infrequently I see people using CMake: http://www.cmake.org/ I briefly used autotools a few years ago to set up the project I've been working on for a while and I remember it being fairly easy to setup.
Have you had a look at http://www.webalice.it/o.drofa/davide/makefile-fortran/makefile-fortran.html? &gt;building Makefiles for all of my modules Does this mean that you are creating separate makefiles for your modules? Why not just have module dependencies for programs that will compile the modules as needed? for example: FC = gfortran FCFLAGS = -g -fbounds-check -ffpe-trap=invalid,zero,overflow objects = recursion.o iso_varying_string.o link-list-objects = link.o list.o iso_varying_string.o repl : $(objects) $(FC) $(FCFLAGS) -o main $(objects) main.f90 test_link_list: $(link-list-objects) $(FC) $(FCFLAGS) -o test_link_list test_link_list.f90 $(link-list-objects) recursion.o : iso_varying_string.o %.o: %.f90 $(FC) $(FCFLAGS) -c $&lt; The recursion module is dependent upon the ios_varying_string module. 'repl' is dependent on the recursion module. 
Are you using gmake? There are ways of getting gmake to essentially build rules on the fly, with the ability to define functions in the makefiles to actually scan for files in directories, etc. Take a look at the online gmake docs.
Autotools looks like exactly what I'm looking for. Thanks for the info.
Wait, so, Intel Composer XE will build it for you? Could you explain what Intel tools you're using to make that happen? Thank you - oh and happy cakeday!
Yeah - I'm using GNUMake. I will indeed check out the docs on it - thank you.
Been using cmake for years in fortran and c projects (sometimes combined). Works like a charm everywhere it is supposed to.
Take a look at the wildcard function. The idea would be to call that in a foreach of all your source dirs to generate your obj list
I tried to do some neural network programming in C, but after a few weeks of punching myself in the junk, I went back to Fortran. It just makes computation easy.
I see a bunch of interpreted languages and fortran. Where is C? 
Is it not the benchmark language they compare to? 
Ah good call. My point is still valid, though, it's comparing fortran to a bunch of non-compiled languages.
Well, it was originally a graph to showcase Julia as a viable option, and Julia doesn't necessarily require compilation... I think.
As far as I know, Julia uses "Just in Time" compilation.
From the figure, it looks like Fortran and C are equally performant, really. The parse_int test (whatever that is) is significantly worse in Fortran, and fib is significantly better in Fortran (than in C). Everything else is pretty much equal. Here's another set of comparisons: http://benchmarksgame.alioth.debian.org/ , though the Fortran examples were done with the Intel compiler and the C/C++ examples were done with GCC (which I have generally found to be slower than Intel). Sometimes Fortran wins, sometimes C/C++. Here's a mention on the Fortran Wiki about speed issues with recursive functions: http://fortranwiki.org/fortran/show/recursion
Yes, that is correct. The Julia creators have said that eventually they would like to offer an option to compile, but that does not exist yet.
&gt; forall The `forall` construct introduced in Fortran 95 has turned out [not to be so good idea](http://stackoverflow.com/questions/8602596/fortran-forall-restrictions) so people have stopped using it. They tried again in Fortran 2008 with `do concurrent`. We'll see how well that will catch on.
 * 1) Don't restrict yourself to F77, there's no reason to. * 2) [This intrinsic function is literally the first google result.](http://gcc.gnu.org/onlinedocs/gfortran/RAND.html) min( floor(rand()*13+1.0), 13 ) should give a uniform distribution where the min function prevents the unlikely possibility of getting 14.
Do note that you'll need to provide a psudeorandom seed when you start your program, otherwise you'll get the same result each time. Look at SRAND(SEED) as the intrinsic to do this. You can get SEED from the processor's clock, or other similar call.
Yes, don't forget the seed.
Why not just use nint(13*rand())?
No, rand()*13 will give you a uniform distribution from 0-13, +1 will make that 1-14. With FLOOR, 1.0-&gt;1.9999 will give you 1, and 13.0-&gt;14.0 will give you 13. 13 will be more likely by a vanishingly small amount; only by the likelihood of RAND returning EXACTLY 1.0
[Page 272](http://apps.nrbook.com/fortran/index.html) of this Numerical Recipes book shows ran2. I used that one for many years.
Ah yes, forgot about the 0. 
I use this from [New Mexico Tech](http://infohost.nmt.edu/tcc/help/lang/fortran/rand.html): integer*4 timeArray(3) call itime(timeArray) i = rand ( timeArray(1)+timeArray(2)+timeArray(3) ) This uses the time when the program is run (*not* when it was compiled) as your random number seed. 
You could write this function in a couple hours, and then add it to your personal math library for later.
You could use [FGSL](http://www.lrz.de/services/software/mathematik/gsl/fortran/). It's a Fortran interface to the gsl library. There are many math routines including data interpolation. Specifically, gsl_spline functions.
Thanks so much for the help yall. Here is the code so far: pastebin.com/f8NbRzF3 I still need to add the split option and update the random number generator, but feel free to check it out. This was my first attempt at any type of coding, so I'm up for any recommendations/criticism.
If the x-values are in increasing order you could use the following: subroutine LinInterp(n, x, y, xnew, ynew, ierr) ! Linear interpolation on arrays x and y, where x is in increasing order. ! Dummy variables integer, intent(in) :: n real, intent(in) :: x(n), y(n), xnew real, intent(out) :: ynew integer, intent(out) :: ierr ! Local variables integer :: i if (xnew &lt; x(1) .or. xnew &gt; x(n)) then ierr = 1 else do i = 1, n - 1 if (xnew &lt;= x(i + 1)) then ynew = (xnew - x(i)) * (y(i + 1) - y(i)) / (x(i + 1) - x(i)) + y(i) exit endif enddo ierr = 0 endif end subroutine LinInterp *Edit - fixed a '&lt;' that should have been '&lt;=' If your x values are unsorted, you could modify it to find the the nearest x values above and below xnew and their indices and use these in place of i and i + 1 in the expression for ynew.
Thanks! This looks like just what I needed.
Interesting, thanks, I'll have to look into this. I had some trouble finding documentation of the Fortran implementation of gsl_spline.
It's pretty simple once you have it installed. All functions are the same as gsl except you add fgsl in front instead. To create a spline and interpolate you: * First need the structures. A type(fgsl_spline) and type(fgsl_interp_accel). You'll also need an integer for the number of data points you have and two data arrays of real(fgsl_double) which hold your x,y points the same size as your integer. * Init your accelerator by: my_acc = fgsl_interp_acc_alloc() * Then you create the spline. my_spline = fgsl_spline_alloc(fgsl_interp_linear, num_data_points) my_spline = fgsl_spline_init(my_acc, x_array, y_array, num_data_points) There are other spline types as well including cubic, akima, polynomial, etc if you need something more than just linear interpolation. * And to interpolate you just call: interpolated_value = fgsl_spline_eval(my_spline, point_to_evaluate, my_fgsl_interp_acc) I recommend looking at the gsl website [here](https://www.gnu.org/software/gsl/manual/html_node/Interpolation.html#Interpolation) on the different types of interpolation and how they work. This might be a bit heavy for your needs, but gsl has some amazing tools (integrators, evaluating splines derivatives, and much more) if you ever need to do anything more complicated than linear interpolation.
I'm not understanding why everyone here is saying rand() * 13 You want 1 -&gt; 13 difference = 12 rand() * 12 = 0-&gt;12 + 1 = 1-&gt;13 (rand()*12) + 1
Then why not conditionally round? below .5 =&gt; floor, above=ciel It would no longer be a 1 liner, but the logic would read more clearly imo.
Its really not that bad. I think people think old==clunky and obsolete. Fortran isn't COBOL for Christ sake.
At least COBOL is not RPG! FORTRAN isn't sexy, but it does do the job better than most new languages.
FORTRAN isn't Fortran either. People don't realize how much it's changed, it's like a completely different language.
If you read through the comments section of the article, I think you'll find that a majority of the people agree with that sentiment. In fact, I've shown people Fortran 2003 code and they're really surprised at how nice and easily readable it is. Then you look at Haskell and its like an alien language.
Maybe this might help? http://msdn.microsoft.com/en-us/library/ms246590.aspx
Using waf to build Fortran projects: http://code.google.com/p/waf/
That article kind of misses the point. It first talks about ancient Fortran and complains that LISP had not a suitable syntax for numerical applications to replace it straight away, but on the last page acknowledges that Fortran quite evolved since then. Most of the criticisms on the ancient Fortran seem to be resolved according to the article, thus the remaining impression is that the main objection with Fortran is that it has a long standing history. Which I think is a somewhat a strange objection. I'd rather think of this as an advantage. Language elements that actually matter for numerical applications like Fortrans array syntax are not even mentioned, instead the article jumps straight to co-arrays and complains about lack compiler support for this 2008 feature. How is anybody to take this seriously?
I was able to fixed the problem. In window 7 ultimate, for those who have the same problem go following steps: Control panel/ Region and language/ administrative/ change system locale/ current system locate/ then change it into English (us) solves the problem. 
Thanks. I learned how to program on FORTRAN '77 (four years ago) and Im looking to get back into (a newer version of) fortran. This will help a ton.
There's a "do concurrent" now! I had no idea. That's very cool.
Do concurrent has existed in standard Fortran for ~4 years now. Sadly gfortran 4.6, which is installed on lots of systems, does not support it. 
I really don't understand why people still learn FORTRAN 77. Is it just because there is a lot of F77 tutorials online? Due to backwards compatibility it's quite easy to use features from newer Fortran standards in old code, so legacy programs are not really an excuse.
If you initialize them like in the first example, the variables automatically get the SAVE attribute, something you probably don't want. To avoid confusion it's IMHO better to initialize them separately, like in your second example.
but f.e. you may want to write real, parameter :: g = 9.81 double precision, parameter :: pi=4.d0*datan(1.d0) 
It wasnt by choice. It was the requirement for the class. 
i know but it seemed innocent for array initialization. Without it's also vectorized.
MiniGW is included with gfortran. Just download the binary from the GNU website and install. &gt; If in doubt, or if you don't know what Cygwin and MinGW are, the package for you is the MinGW ("native Windows") package! There are a lot of text editors out there. Pick your favorite and search for it. Most are available for Windows.
I would go with Cygwin, if you want a Linux-like experience on Windows. Gfortran is available as a Cygwin package. If you want to distribute and run your compiled executables on other computers that do not have Cygwin, then you want the MinGW versions of the compilers. These are available as packages in Cygwin as well. You have two MinGW choices for 32 bit compilation (long story), one choice for 64 bit. * The `mingw-gcc-fortran` package gives you a 32-bit MinGW Fortran compiler executable named `i686-pc-mingw32-gfortran` * The `mingw64-i686-gcc-fortran` package gives you a 32-bit MinGW Fortran compiler executable named `i686-w64-mingw32-gfortran` * The `mingw64-x86_64-gcc-fortran` package gives you a 64-bit MinGW Fortran compiler executable named `x86_64-w64-mingw32-gfortran` An alternative is to use MSYS, which is based off a very old version of Cygwin and only provides a small subset of its functionality. Unless you have some compelling need that Cygwin cannot fulfill, I would avoid this.
Maybe try this: http://babun.github.io/ Its very simple to install and it works right away.
gfortran and Emacs seem to work well together for me. They seemed to find each other just fine for compiling: just go to Tools-&gt; Compile with your code open in the active buffer in Emacs and just type the instructions into the command line (for a single file, gfortran -o Desired_Executable_Name.exe Fortran_File_Name.f08 (for Fortran08, or .f03 or whatever version you want) works fine, but you probably knew that already), press enter, and boom. Executable made. Or, if you prefer Eclipse, check out Photran.
I dunno, it worked for me...I may have just lucked out, but at any rate it's worth a shot!
emacs is also available as a package in Cygwin. Considering you're likely to find out you need more and more utilities (ssh, git, python, perl, etc) as you go on, it's best to set up an environment with a large number of these packages available (and set up to properly work together), rather than trying to download them one by one.
Most people trying to install GNU Fortran on Windows will install one of the many MinGW distributions that provide it. If you're looking for a simpler solution, you could try [Simply Fortran](http://simplyfortran.com/), which provides an IDE integrated with GNU Fortran all in a single installer. It's a commercial product (with 30-day free trial), so perhaps it's not for everyone. I am the primary author of Simply Fortran, though, so I'm obviously biased towards it.
I recommend Modern Fortran Explained. It's a book but it's really helpful and up-to-date when many learning materials out there are so old. It's even helpful if you already have some understanding of Fortran and want to learn some of the more modern features included in the 2003 and 2008 standard or use it as a reference.
For more advanced usage of Fortran (including the newer 2003 and 2008 features), I would very much recommend this book: [Modern Fortran in Practice](http://www.amazon.com/Modern-Fortran-Practice-Arjen-Markus/dp/1107603471)
You need to allocate x and xv before you pass them to init. Add allocate (x(3,N), xv(3,N) ) after you've read in N but before you call init. Also I would be careful initializing your variables in the same line as the declaration, e.g., integer count = 1. Those variables will implicitly be given the 'save' attribute, which means that they are initialized only on the first call to the function. They retain their values for subsequent calls, so you won't start with count = 1 next time you call init. edit: too many words words
For future reference, sometimes it can be useful to compile with -fbounds-check (if you're using gfortran), which will flag out-of-bounds errors for you.
If you're using gfortran (and I suspect you are), try adding the compiler flag: -fcheck=all to add a variety of runtime checks. The compiler won't "detect" any out-of-bounds errors; that type of error checking generally has to occur during runtime in all but the most mundane cases. For more info, see [the -fcheck flag](https://gcc.gnu.org/onlinedocs/gfortran/Code-Gen-Options.html) in the GNU Fortran manual.
Is [this](http://imgur.com/82ii7Me) what you mean? Also, does netbeans work with fortran? I'm currently using [eclipse with photran](http://www.eclipse.org/photran/). It didn't give me any indications of problems on that line. See my reply to /u/gwonzil about my continued troubles with allocation. And I am a bit confused about your suggestion to only declare them in the init function. If I understand correctly, that would make those arrays only accessible in the init subroutine, wouldn't it? "init" is for "initialization", but I'm going to need those later, once I fix my mistake here. But if you wouldn't mind elaborating, this particular quirk of fortran is becoming very annoying for me. I thought I needed to declare my variables in EVERY function/subroutine and program. I don't understand the reason for this. Why do I need to declare something in my main program, then pass it to all of my functions and declare it *again* in each of them? It seems redundant. Thanks for your reply! Very helpful.
Sorry I didn't read your post carefully enough, I see that you did indeed use the bounds checker. Not sure why it didn't halt execution for you. Another useful flag to add is -fbacktrace, which will sometimes tell you where (what source file and line) your segfault is occuring.
My bad... it's vx, not xv in your code. Also, remember to deallocate when you're done working with x and vx.
Oh, hahaha. I just copy-pasted that and had a bit of a dyslexic moment. Unfortunately, I'm still getting errors. It seems like fortran thinks my arrays are 1-dimensional now, but I'm not sure why. Building file: ../Main.f90 Invoking: GNU Fortran Compiler gfortran -funderscoring -O0 -g -Wall -c -fmessage-length=0 -o "Main.o" "../Main.f90" ../Main.f90:10.15: allocate (x(3,N), vx(3,N)) 1 Error: Rank mismatch in array reference at (1) (2/1) ../Main.f90:10.24: allocate (x(3,N), vx(3,N)) 1 Error: Rank mismatch in array reference at (1) (2/1) subdir.mk:17: recipe for target 'Main.o' failed make: *** [Main.o] Error 1
Sorry. I'm being sloppy here trying to help. The shape of the arrays being allocated has to match the declaration so for example, if you declare x and y as follows double precision, allocatable :: x(:), y(:,:) Then, you should allocate x and y with allocate ( x(c) ) allocate ( y(a,b) ) for some appropriate values of a, b, and c. In your example, you would have to allocate x and vx as one-dimensional arrays because that's how you've declared them. Your subroutine however takes 2-dimensional arrays, but it's actually ok to pass the one-dim arrays as long as you allocate enough space, i.e., allocate ( x(3*N), vx(3*N) ) as init expects x(3,N) and vx(3,N). edit: Thanks for the gold!
Ah yes, I see the missing allocation now. Good call, other posters! I develop a Windows-specific Fortran IDE called [Simply Fortran](http://simplyfortran.com). It's a bit different from Photran in that it was designed specifically for Fortran and it doesn't require the user to set anything else up (no Cygwin, MinGW installation necessary). It has a 30-day trial, but it does cost money after that period.
When I learned Fortran, I would google whatever I didn't know. There are a lot of little tutorials online here and there from different universities that describe the basics. I would look through some of those just to get the basic ideas down. This [document](http://beam.helsinki.fi/~saparvia/fortran.html) by /u/saparvia seems like a good place to get examples of some of the modern features of Fortran. I personally have fortran 95/2003 explained by Metcalf, Reid and Cohen and was recently given Numerical Computing with Modern Fortran by Hanson and Hopkins (though this one assumes knowledge of Fortran and is less of a general reference, more focused on numerical computing, and it's index is kinda bad).
hello fellow fortraner. I'm quite new to fortran, and I don't know your level at it, but what I can see right now is this: * start off by creating a string variable * you can put limitations on it using if statements (if don't want anything less than 30 for example *If you're only concern is printing the result out (not saving them), then your code should look kinda like: Do i = 1, LEN(input)-9 ! gets length of string, and disregarding the parts that are going to be less than 10 in length write(*,*) input(i:i+9) ! write the substring of 10 characters) End do hope this helps
Awesome,, I feel like I've hit the jackpot by learning Fortran. But can anyone explain to me what those benchmarks mean?
Since your question isn't really particular to fortran, let me ask you this: do you *have* to use fortran for this particular project? You an work with strings in fortran without too much difficulty, but it can be much easier to do in another language like python or matlab.
according to standard, it is true that locally allocated variables are automatically deallocated when they are out of scope. this isn't the case for allocatables in a module or if the allocatable variable has the 'save' attribute though. also, if you're done working with an allocatable but you haven't reached the end of the subroutine, you might want to deallocate explicitly just to free up the memory. i personally like to explicitly deallocate anything i allocate. if you start coding with allocatables that aren't as straightforward, then it's good practice, else you'll end up with a memory leak.
Thanks for the comment! I think you are right - but as you said: it is quite controversial :) It's just that I was running out of space in the upper-left corner and I really had a hard time to decide where to put the labels relative to each other to offend as few programmers as possible ;) - So, this whole diagram is rather subjective, and one might want to even swap the positions of Cython and Julia (but it really depends on how you use Cython - you can use it just like pure C code, or you can have more or less Python objects for convenience in there too).
absolutely. C is much more complicated to code in IMO. The memory management is far from optimized and often very difficult to properly implement Perhaps what they meant was that fortran's productivity is poor when trying to utilize complicated object oriented concepts? Thats the only case I can think of where fortran is less productive. I wish more of the anti fortran people realized that for our purposes its great and often the best. Regardless of what additional functionality more sophisticated languages may have, if we dont use those features, why does it matter? 
So true. Manipulating strings is a hassle in Fortran. 
Memory management in C is horrific compared to Fortran. Whoever thought that passing by value was a good idea? Try to pass a 2D array a few functions deep using pointers in C and you'll know the meaning of pain. In Fortran? Perfectly easy. So easy, in fact, you simply don't think about it. And I would go so far as to say that Fortran's object-oriented programming is better than more complicated versions. It is perfectly possible to create an object, and functions that are attached to that object. And now you can even have a finalize function. Why is more needed? C++ is a flipping mess, and I avoid it at all costs. I don't care how fast it can be, its just ugly and a nightmare when it gets bloated. Fortran is straightforward and easy to handle (well, Fortran 2003/08). For example, I tried implementing a relatively simple machine learning algorithm in C after having done it in Matlab/Octave. Even when finding a full minimization function already out on the web, the rest was just a nightmare. I gave up and went to Fortran. To say it was easy is an understatement. All of the intrinsic functions for matrix manipulation combined with array handling/passing made life really, really easy. Now, I constantly preach about how great Fortran is. And I've worked with plenty of languages. But I suppose I'm just preaching to the choir :)
True, fortran is optimized for numerical operations
well it depens on what you do, when using static storage both are really fast but c89 is without extra hints not able to optimize as much. C99 has restrict which brings it closer to fortran. This is where the difference is i think, it's the runtime vs a specific implementation otherwise. It's harder (but certainly not impossible) to use your own malloc in fortran. Otoh objects and generics are indeed way more user friendly and less prone to user errors, so it's more productive.
I've done something similar before and I just wrapped the Fortran in python to create the GUI. You can call Fortran functions and subroutines from python using something like swig, you can also interact by having the python GUI generate input files or supply command line arguments.
There are quite a few free options for building a GUI in Fortran. If you want to just generate plots, there is [PLPlot](http://plplot.sourceforge.net/), which is completely cross-platform and provides a Fortran 2003 interface (you'll need an older version to use their now-deprecatred Fortran 77 bindings). There are also a number of solutions for interfacing with GNUPlot, although I don't know any off the top of my head. If you want to go the full GUI route, most people choose [Gtk-Fortran](https://github.com/jerryd/gtk-fortran/wiki), which does work on Windows as well as GNU/Linux with a bit of work (unless you use a pre-packaged solution). A simpler route might be [DISLIN](http://www.mps.mpg.de/dislin/), which is far more restricted in its capabalities and licenseing, but also very easy to use. There are a number of more obscure packages, [F03GL](http://12000.org/my_notes/faq/fortran/index.htm) and [Ftcl](http://ftcl.sourceforge.net/) for example. You have a lot of choices above. If you're on Linux, any of them should be relatively easy to build yourself. On Windows, things tend to be a bit more complicated. If you're using gfortran, you've probably got a version recent enough to support most of the necessary Fortran 2003 features. A lot of the packages needing Fortran 2003 (for GUIs, at least) require that standard because they rightfully employ the *ISO_C_BINDING* intrinsic module behind the scenes; GNU Fortran has supported that module for years, so there's no concern about using such packages. 
The HDF5 reference library has [a Fortran interface](http://www.hdfgroup.org/HDF5/doc/fortran/index.html). I'm not particularly familiar with HDF5 files, but would that fulfill your needs?
If I understood what you're trying to do correctly from your explanation, that is if (x3 &lt; b) then x3 = 2b-2-x3 else x3 = b-1 end if which is a clear way of writing it, and that clarity can justify verbosity. However, if you want to make it a one-liner, here's one way of doing it: x3 = merge(2b - 2 - 3x, b - 1, x3 &lt; b) 
Luckily, I actually have a little bit of experience with Python (but not with GUIs). Do you need any special software besides swig and IDLE?
The *ISO_C_BINDING* module is an intrinsic module; it is already built into the Fortran runtime library. You won't find any file on your computer specifically referring to it. The *ISO_C_BINDING* module appears to have first been included in GNU Fortran 4.3, so you just need to check that your compiler version is newer than that. Gtk-Fortran might be tricky to build using Cygwin for a few reasons. First, you'll need to install Gtk+. On Windows, you'll most likely want to get the Windows native distributions. The versions that ship with Cygwin will use Cygwin's X11 server, which isn't ideal. Second, you'll need to get the build going using [cmake](http://www.cmake.org/), which can be somewhat painful when trying to point the compilers to the Gtk+ include directories (in one of the Program Files directories). Cygwin will attempt to search its own directory tree, which, again, is less than ideal. Third, if you want to do any plotting, you'll also need to first configure and build PLPlot, which integrates nicely with Gtk-Fortran. Building PLPlot is just as much a pain as building Gtk-Fortran, so perhaps you'd want to start there. Finally, you'll need to make sure that your Fortran compiler knows to look in the proper directories when searching for modules. I would suggest using the MinGW compilers as they produce true Windows-native executables. Cygwin executables will always be dependent on the Cygwin runtime, and you'll want to avoid building any GUIs that require Cygwin's X11 server. There could be some binary distributions of all the above available, though I'm not aware of any explicit ones other than what is available via the [Simply Fortran Package Manager](http://packages.simplyfortran.com/package/61.html). I'm the primary author of [Simply Fortran](http://simplyfortran.com/), which is a commercial IDE that provides the GNU Fortran compiler, and I've had the joy of building Gtk-Fortran on Windows on multiple occasions. That's why we provide pre-built versions for our users. *Sorry for the shameless plug...* 
Can you give some details? What's good about it relative to other texts?
Damn it, browser crashed. will try to recapture my thoughts quickly Thanks for this, it's really straightforward and useful. Some comments: * The purpose of pure functions isn't clear. Wikipedia [covers it well though](https://en.wikipedia.org/wiki/Fortran_95_language_features#Pure_Procedures). Because it's basically a blacklist, I think you'd be better off including an example of each bad behaviour, and explaining why it's not allowed (e.g. "I/O not allowed"). * I had to read the fortran wiki page on [elemental functions](http://fortranwiki.org/fortran/show/elemental) to get this. Some example output would probably make it clearer. * I don't see what the "array arguments" section adds. It seems obvious that arrays should be able to be used as arguments. What is different here to what's in the "functions" section? * "functions as arguments" and "overloading" sections use "interface" without explaining what that does - I still don't understand this, and the wikipedia page doesn't help either. * The I/O sections would be better with example input and output - I realise you're probably trying to get readers (students?) to compile and run the programs themselves, but for someone like me passing through and looking for a quick reference, it's less useful this way. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 39. [**Pure Procedures**](https://en.wikipedia.org/wiki/Fortran_95_language_features#Pure_Procedures) of article [**Fortran 95 language features**](https://en.wikipedia.org/wiki/Fortran%2095%20language%20features): [](#sfw) --- &gt; &gt;This is a feature for parallel computing. &gt;In the FORALL Statement and Construct, any side effects in a function can impede optimization on a parallel processorâ€”the order of execution of the assignments could affect the results. To control this situation, we add the PURE keyword to the SUBROUTINE or FUNCTION statementâ€”an assertion that the procedure (expressed simply): &gt; &gt;* alters no global variable, &gt;* performs no I/O, &gt;* has no saved variables (variables with the SAVE attribute that retains values between invocations), and &gt;* for functions, does not alter any of its arguments. &gt;A compiler can check that this is the case, as in: &gt;All the intrinsic functions are pure. &gt; --- ^Interesting: [^Fortran](https://en.wikipedia.org/wiki/Fortran) ^| [^F ^\(programming ^language)](https://en.wikipedia.org/wiki/F_\(programming_language\)) ^| [^G95](https://en.wikipedia.org/wiki/G95) ^| [^Object-oriented ^programming](https://en.wikipedia.org/wiki/Object-oriented_programming) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cifgk1h) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cifgk1h)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
What would be the point, if it's just as fast interpreted?
Thanks for the feedback! * You're probably right about the pure functions, I'll try to add some more examples there to show off all the limitations. Basically I was a bit lazy there :-) * Regarding elemental functions, I can agree that it's not immediately obvious what is happening, especially since I assign the same value to all elements (`a=2`), so you might miss alltogether that `a` is an array. If it's made clearer that `a` is an array, it should also be clear what elemental functions do (since `square` clearly operates on a scalar). Maybe I should even call the function `square_scalar` or some such to make that clearer? * Array arguments are, IMHO, not at all obvious for many people. You can't do that in, say, C or C++ (which I expect many readers will be familiar with), since in those you have to also pass the size of the array (even then, you only pass a pointer, which is not exactly the same thing as an array). I see way too many examples of Fortran code where someone passes the array size as an argument instead of using the assumed shape. Suggestions on how to make this clearer? * Going into details about interface-blocks would be tricky, since they are a bit complex and probably not doable via examples alone. So, you really must read up on them elsewhere if you want to actually understand them. But my goal is that from the examples given here, the reader will anyway figure out how to use them (copy-paste -&gt; change function names, etc), even if they don't understand them fully. * Somehow I feel like needing example output is "cheating". The best would be for the code to be clear enough that it's more or less obvious what is happening. I'll try to work on that a bit. Format strings is one example where it might be useful to show output, but I guess that the main point is to illustrate that they exist, and how you specify them. You anyway need to look up somewhere else how they work. Thanks again for the feedback, I appreciate it!
There are a few command line utilities out there... http://www.unidata.ucar.edu/software/netcdf/software.html
Fair enough that you want to keep it simple, but perhaps in those cases where is can't be conveyed easily by example alone (format, implicit) you could link to a good external reference, if one exists? They're not always easy to find, if you don't know how to phrase the question carefully... Re: array arguements, fair enough. I'm coming mostly from newer languages - R, python, php. It seems stupid to me that you should have to pass the array size as well as the array... guess because I'm not familiar with the use of pointers.
I wrote a blog post about using gtk-fortran and Glade to put together a GUI pretty easily: http://fortrandev.wordpress.com/2014/05/25/creating-a-gui-using-gtk3-and-gtk-fortran/ The template I have linked in there is really just a simple project that you can open in CodeBlocks and use the latest gcc compiler to build. I know you're using Photran, but if you haven't given CodeBlocks a try, I highly recommend it. The whole thing requires a little bit of work, but much, much less than any other solution I've seen so far. And Glade makes things much easier. If you need any help with it, feel free to ask.
I just found this blog the other day and I've already downloaded CodeBlocks and managed somewhat to get it to work but It's not running my program properly. I still need to figure out what's going wrong, but I literally just copied and pasted my code from Eclipse. (It's supposed to output a bunch of information to some .dat files, but when I open them, they appeared to be filled, in the correct dimensions and quantities, with nothing but the value infinity, which is not happening in Eclipse.) I also attempted to run that sample script with the hello program, but it didn't work. It wouldn't even open the window and I'm not sure why, but I did manage to pull up and sort of edit the gui in glade. I sort of gave up on it though. When I get home, I can paste an output that Codeblocks gives me but I don't have it handy right now. Do you know of any common mistakes that would cause any problems though?
Wow, ok. I really screwed that template up. Turns out that the test.glade file had the signals named incorrectly. Yeesh. Its been up there for a month and no one said anything :( In any case, you can pull the new test.glade file from here: https://github.com/jshahbazi/fortran-gui-demo Copy it into the directory of the .exe and as long as you didn't change any code from the demo, it should work fine. I'm terribly sorry about that.
It works! Thank you very much for getting me started - your blog post was a lifesaver. I found [this other blog with a tutorial](http://blog.borovsak.si/2009/09/glade3-tutorial-1-introduction.html) to get me started on mine. Do you have any favorite tutorials or helpful sites? In the mean time, I still need to figure out why my program makes so many infinities when run in Codeblocks. My god, fortran is a nightmare for this, and it doesn't make sense. Fortran is like the computer language of science, right? Don't any scientists ever need to graph things they make with their programs? I mean I know you can just pull up the data in Matlab or something later, which is what I'm doing now, but it's such a hassle and doesn't look nice. On the other hand, I've just about had it with needing to install files and packages to specific directories that can't have spaces and adding shit to my PATH and troubleshooting when it doesn't work. So THANK YOU for being so genuinely helpful!
&gt; I've never seen "if" abused like that I was reading some old code for solving PDEs in Fortran 77, and the use of "IF" as a variable was everywhere.
I was thinking about it some more, and I have to say that after re-reading your original post and considering the aspects that I know so far, that building an entire GUI just to display some graphs might be a bit overkill. Now, if you want to do more than just display the graphs, then this is fine. But if that's all, then maybe Octave isn't so bad. Two or three commands and then you have a graph. Whereas with this, you'll have to build the GUI, and then write all the code to import the data, and then write more code to display it. It'll look cool, for sure, but that's a lot of work just for a few graphs. If you want something better than Octave, but still easier than coding, maybe take a look at [VisIt](https://wci.llnl.gov/codes/visit/home.html). That being said, once you get the GUI part down, you'll have to look at a graphing library next. gtk itself doesn't have a graphing package (its actually called by libraries like PLPlot). So you'll probably have to incorporate something like PLPlot. Or you can use DISLIN. I would almost go so far as to actually recommend that over the other libraries if you just want graphs (for example, see [these pics](http://www.mps.mpg.de/1758649/gallery_curves2#curve_2) ) and still want to do the code yourself. It doesn't have a RAD tool like Glade, but its pretty easy to use. The license is free for single-user, non-commercial use.
You're certainly not wrong. I definitely wouldn't *need* a gui to have a functional program, but it will be more than just viewing graphs. Firstly, it would be great to be able to see certain graphs plotting themselves as the program progresses, like [xflr5 plots](http://www.youtube.com/watch?v=IFCL8IJlYnI#t=132), if you're familiar with that program. The simulations can be quite long and waiting until the end to find out that something was wrong is a waste of time. Also, there are a lot of inputs, which I store in a .txt file and just read them in to variables in my program, but it would be more convenient to be able to select various presets or modify them without opening another text editor and re-running the program every time. But mostly, yes, it would just look really cool, and that's actually what I want. I mean, I asked my research advisor and he also said it was pretty unnecessary, but this whole thing is just a resume builder for me. I want to be able to say I have a lot of useful experience, and be able to prove it. At this point, I'm learning much more about academic material than programming, but programming is a much more transferable skill. I figured this would be a way to learn more about programming in fortran while producing useful material for the research, and I'll have something nice/impressive to show employers next school year when I'm looking for internships (I didn't get one this year). Plus I just like the idea of it and think it would be really satisfying to successfully make something a bit more visually appealing and easy to use than what I've got now. I was planning on using PLPlot but those dislin graphs actually look really nice. I think I might give PLPlot a shot, and see how it goes though. And I did figure out the source of my infinities, but I am still confused about why it happened. One of the variables I declared was not initialized to zero (as it should have been). The only thing I did to it was add values in a loop. For a simple example, what I had was: double precision :: variable do i=1,N [calculation] variable = variable + [calculation] end do and what I should have had was: double precision :: variable variable = 0 ! &lt;----this is the important line do i=1,N [calculation] variable = variable + [calculation] end do For some reason, Photran never caught this and somehow "variable" was always set equal to zero when it was created. (I know it did because I compared my results to known values and they were correct). When this goes through CodeBlocks, "variable" gets set initially to 8.1424.....X10^326. I don't understand why that happens though. Is there something significant about that number to Fortran? I'm worried I might have done something similar somewhere else since my mistake slipped by unnoticed before. 
Having some programming on your resume is definitely good. Just be sure its Fortran you want to show off to your potential employers! Most nowadays prefer Java, Python, C++, or C#. Don't get me wrong, I love Fortran, and I want to see it being used more. But I'm also a realist, and I wouldn't want you to foul up your chances of getting an internship or a job. As for the infinity bug, it sounds like its an issue with the compiler. From what I've seen, most compilers will initialize a variable to 0 for you. But some may not. It sounds like the compiler you're using with Photran is doing it automatically. Or Photran is adding an argument to tell the compiler to do that. And maybe Codeblocks isn't including that argument. In any case, you really should get into the habit of initializing the variables yourself. Its a very, very good habit to have lol. And no, I don't think there's anything significant with that number you mentioned. Unless its the max value of the variable type you used and the precision of your system messed with it. Precision can be a bear sometimes. That's why Fortran is good for calculations... You can very finely control the precision, whereas with other languages you'll have a harder time of it. I'm going to take a look at PLPlot and see how easily it fits into gtk-fortran GUIs since I've never actually done it before. If its difficult I'll try to post up a tutorial on my blog. Let me know if you're having any more issues, and I'll see what I can do.
Do you know the number of data points before you start reading them? Eg. there might be a header at the top of the page that tells you what n is? If so then you could use an allocatable array. If not, then one solution is to create a list structure that holds an allocatable array. You initialise it with some initial capacity and keep track of the number of actual values in the list. When you append a new value to the list you first check if the current length is less than the capacity. If so you insert the value and increment the length. If not, you have to first allocate a new data array with some larger capacity and copy the old values into it. A good starting approach is to just double the capacity of the list each time you run out of space. Edit: This is called a dynamic array, Wikipedia has a good explanation: http://en.wikipedia.org/wiki/Dynamic_array Alternatively, you could implement a linked-list and then covert it to an array once you finish reading the file, but that would be less memory efficient.
Ok, if you count the number of data points first you could also just use an allocatable array. eg: REAL, ALLOCATABLE :: a(:) INTEGER :: number_of_points INTEGER :: status ! calculate number_of_points ! ... ! Now allocate the correct sized array: ALLOCATE(a(number_of_points), STAT=status) IF (status /= 0) STOP "Out of memory" Once you're done with the array you need to remember to deallocate the memory: DEALLOCATE (a)
That is really weird... Does it still give you that even if you completely restart CodeBlocks? I've seen it sometimes do weird things before, but a restart usually solves it for me. The code is fine.
I realize there may be some grumbling in my direction, but it needs to be mentioned that the hassle of implementing dynamically-resized allocation is handled completely automatically in C++. You would just say: a.push_back(b); where b is the next item read in from the file. It would be easy for Fortran to implement this, but they stick to the old awkward ways of C. Fortran needs easier allocation! It's been a solved problem for a long time in other languages -- no performance penalty is incurred.
That's very interesting, but it makes sense. BTW, if you choose Rebuild in Codeblocks, it will clean out the directory before building the project. Also, have you tried out MinGW at all? I find its a bit easier than Cygwin, but that's just taste, I think. As for timing, you can do it with any Fortran compiler using intrinsic functions. For example: program blahblah real :: timer1, timer2 timer1=secnds(0.0) call dosomethingorother() timer2=secnds(timer1) print *, 'Done in ',timer2,' seconds.' end program
Cool! Now I don't have to look that up. Haha. I will definitely find that useful when I flesh out my code a bit. And I did try to use MinGW before I tried Cygwin but that was my first experience with GNU stuff and I didn't know how to deal with it. I've been pampered by setup binaries my whole life, so I've never manually installed anything, and I misplaced some of the folders or something. I couldn't find the executable either (now I know it's always in the bin file). I got frustrated and deleted it and installed Cygwin instead, which I managed to get to work out, so I use that now. Anyway, I can't understand why GNU stuff doesn't just come with setup.exe files like everything else. Those installers can't be that difficult to make and they save so much time and effort. I've gotten used to the routine now, but I still hate doing it, even though it's not *that* complicated. 
Fortran is probably easier to learn, C++ is a much more complex language. However, a lot of scientific and engineering code is being written in C++ these days rather than Fortran, so depending on what you want to do, it could be useful to know. A lot of what you learn with Fortran should be transferrable to C++ though, so there's no harm in starting out with Fortran and learning C++ later.
Hmm... Try going here: http://www.mingw.org/ and then going to the top right of the screen and click "Download Installer" Install it to C:\MinGW (well, you don't have to, but it makes things easier) I can't remember if the installer sets the PATH correctly, but make sure C:\MinGW\bin is in your PATH environment variable (I'm pretty sure it should be). That should be it. One of the cool things is that it also installs MSYS. If you go to C:\MinGW\msys\1.0 you'll see a directory structure that looks very much like Linux. And if you run msys.bat, you'll get a command prompt that will act very much like Linux. Even to the point of being able to compile stuff that was developed on Linux.
C++ is very useful for science and engineering projects, especially those that become large and involve a lot of components that do more than just number crunching. But the learning curve can be steep; I personally learned from an early version of Stan Lippman's C++ Primer. Fortran is made for a narrow domain: math-intensive computation involving lots of arrays. C++ is very general, with fewer convenience features targeted specifically for math. C++ exposes the hardware, whereas Fortran tries to hide the gory details and just do array computations.
The auto-allocation of C++ has no performance penalty beyond that incurred by Fortran or any other language -- having to copy stuff into a newly-allocated array. But C++ handles it all for you -- no need to write all the gory allocation resizing and deletion gunk, and keep doing that everywhere you need memory.
I had a problem installing plplot. Sorry I keep asking you for help, but I'm hoping you'll know what I'm doing wrong since it seems like you've managed to do this without a hitch. I followed the instructions posted [here](http://darmar.vgtu.lt/notes/10-gtk-fortran), which you referred to on your blog. I followed the instructions as closely as I could, but got tripped up on number 8 when running commands in the prompt. This one seemed to go okay: &gt; cmake -G "MinGW Makefiles" -DDEFAULT_NO_BINDINGS=ON -DENABLE_f95=ON -DCMAKE_INSTALL_PREFIX=install .. but these two did not: &gt; mingw32-make &gt; mingw32-make install Cmake\bin and MinGW\bin (which contains mingw32-make.exe) are both in my path and everything before that went pretty smoothly. The execution of the first line went well up until the command prompt got to: Linking Fortran shared library ..\..\dll\libplplotf95d.dll which was in red font. After that, it spat out: Cannot export _PLPARSEOPTS@4: symbol not defined Cannot export _PLPLOTP_mp_PLAXES@40: symbol not defined Cannot export _PLPLOTP_mp_PLBOX3@72: symbol not defined . . . etc. . . . collect2: error: ld returned 1 exit status bindings\f95\CMakeFiles\plplotf95d.dir\build.make:119: recipe for target 'dll\libplplotf95.dll' failed mingw32-make[2]: *** [dll\libplplotf95d.dll] Error 1 CMakeFiles\Makefile2:726: recipe for target 'bindings/f95/CMakeFiles/plplotf95d.dir/all' failed mingw32-make[1]: *** [bindings/f95/CMakeFiles/plplotf95d.dir/all] Error 2 Makefile:136: recipe for target 'all' failed mingw32-make: *** [all] Error 2 Probably not all of that is necessary, but a similar output occured with the second line (Maybe it depends on the first? I'm not sure.). In any case, the folder 'install' was never created in my 'build' directory and I don't understand the errors that popped up. Do you know what I might have done wrong?
Hmm. I really can't tell what's going on. But in an effort to maybe find an easier way of doing it (if you couldn't tell, I'm really ~~lazy~~ pragmatic), I downloaded the plplot source files, used cmake (I already had it installed), and then built it in Codeblocks without any issues. But the difference was that not only did I use the cmake gui (though I suppose you don't have to, but it really makes things very easy), I also set the generator to 'CodeBlocks - MinGW Makefiles'. Yours is set to 'MinGW Makefiles.' And I also didn't add anything else. I just let the GUI automagically do whatever it wanted to do. And it worked. Then I just loaded the plplot.cbp file and hit build and it was then built. No errors or anything.
I think you may have some misunderstanding about the compiling process. There are two general steps to creating an executable 1) compile each source file to an object file 2) link all object files together to produce a final executable. The object files are allowed to contain references to functions defined in other source code files. These references are resolved during the linking stage where the linker looks at all the object files and all the undefined calls. If it can't find a matching function definition then you will get an "undefined reference to ..." error. The issue is that you are not compiling or linking with the nag_library code. You must either include the source code in your list of .f90 files, or link it into the executable by specifying a library file (usually ending in .a or .so) with the -l flag. In your second example, you have only compiled test.f90 into an object file (although you have forced it to be called test.exe, instead of the usual test.o). The -c flag does not mean "compile with comments" but "only compile". In other words, stop after compiling to an object file and don't try to link anything. This can be useful if you have many source files that don't change very often. You can compile them to object files and then link together using the linker "ld". In this way, you only need to recompile those source code files that change. 
Thanks, that actually clears up the underlying process a lot. I'm still having some problems actually implementing this. From what I'm understanding something like this should be fine: &gt;$ gfortran -l"C:/nag_interface_blocks/nag_library.o" test.f90 -o test.exe This gives the following error: &gt;test.f90:2.4: &gt;Use nag_library, ONLY: nag_wp, s15abf &gt; 1 &gt;Fatal Error: Can't open module file 'nag_library.mod' for reading at (1): &gt;No such file or directory I've attempted to remedy that by specifying the actual module and used: &gt;$ gfortran -l"C:/nag_interface_blocks/nag_library.mod" test.f90 Which results in the same error. I've checked that the library mod is there, my next guess would be that I didn't compile the nag library properly to begin with (possible given my flimsy understanding of compiling). Once again, thanks for the help. I'm completely green when it comes to compiling, I've only ever worked in Matlab Before
Try the following (obviously untested): $ gfortran "C:/nag_interface_blocks/nag_library.o" test.f90 -o test.exe The "-l" flag is only for proper libraries (files ending in .so or .a or perhaps .dll on windows). Is there a nag_library.mod file in that directory? There will have to be if you plan to use the "USE" statement. 
That looks very convoluted. OpenMP can do all that setup for you (with something like `!$omp parallel do schedule(static, 300)`). You also, and this could be very significant, want to do a reduction on `a` instead of having it shared. In fact, you don't need any shared variables here as far as I can tell. Keep in mind that thread setup and teardown is expensive. You shouldn't parallelize the innermost loop, but do it as far "out" as possible. And maybe look into if you could use blas or lapack for something, or perhaps exploit some sparsity.
Thanks. I'll check them out. :)
Try to order the loops the first indices are the inner most loop. In your case the l is annoying because it is first in one and last in another - it can often be worth permuting axis of the array before the computation so the memory ordering is favorable (ie so B can be indexed as `B(l,jj,iii,iiii)`). Then you can have the loops in order (from outermost to innermost) `iiii iii ii i jj l j i` ) - and you should see a bit speedup. For openmp put it on the outmost loop - if you really have to parallelise inside the next at least set up the parralel block (which creates the threads and is expensive) outside the loops so it is not repeated every time. Here you are doing all the expensive omp overhead forking etc. inside your nest of loops.
Okay, thanks :) Do you have an estimate of the best time I can get given the dimensions of the matrices? I am getting 0.4seconds for the multiply using a simple reduction and openMP. I haven't looked into blas yet.
There is a nag_library.mod file in that directory and a nag_library.o file. So I tried as you suggested: &gt;$ gfortran "C:/nag_interface_blocks/nag_library.o" test.f90 -o test.exe test.f90:2.4: This gave the following error: &gt;Use nag_library, ONLY: nag_wp, s15abf &gt; 1 &gt;Fatal Error: Can't open module file 'nag_library.mod' for reading at (1): &gt;No such file or directory I've since tried with the .mod file instead of the .o file. I get the same error. I also tried to compile and stop then link the two files (either the .mod or the .o) with: &gt;$ gfortran -c -I"c:/nag_interface_blocks/" test.f90 -o test.o then: &gt;$ gfortran -o main.exe c:/nag_interface_blocks/nag_library.o test.o This resulted in the error: &gt;test.o:test.f90:(.text+0x17): undefined reference to `s15abf_' &gt;test.o:test.f90:(.text+0x17): relocation truncated to fit: &gt;R_X86_64_PC32 against undefined symbol `s15abf_' &gt;collect2: error: ld returned 1 exit status While using .mod gave me: &gt;/usr/bin/ld:c:/nag_interface_blocks/nag_library.mod: file format not &gt;recognized; treating as linker script &gt;/usr/bin/ld:c:/nag_interface_blocks/nag_library.mod:1: syntax error &gt;collect2: error: ld returned 1 exit status I don't know much about compiler errors, but I understand the second to indicate that a module file can't be linked in the same way as an object file? At this point I'm wondering if there is a problem with the way I invoked the use command in the original program (I can't see one, based on code I've read and textbook, but I hope it is that simple)? Thanks for all your patience 
The first problem I see is that Fortran arrays are 1 based, so your loops should start at 1. Secondly, to access an element of an array, you only need one set of parentheses, like this, a(i,j). There's no Fortran equivalent of RAND_MAX, but there are a number of ways to generate random numbers in Fortran without the need of using it. The most easy being, call random_number(real_variable) and using call random_seed to seed the generator.
My understanding is that you're trying to essentially make an exact copy of a source array, right? *If* that is the case, all you need to do is this: real, allocatable :: source(:) real, allocatable :: target(:) allocate(source(5)) source = 1.0 target = source Fortran will allocate target using the same shape as source, and it will also copy the contents of source over to target. In the above example, the target array will end up having a size of 5 and all the elements will have 1.0 assigned to them. Just like the source array.
Perfect answer, nothing to add. 
The = will cover arrays of all dimensions. I'm a little confused by what you mean when you say that "defining source with (:) prevents that." You have to define an array to work with it at all, unless you use pointers. If you define source as source(:,:), regardless of what you define target as initially, the = operator will reshape it to be the same as source.
Thank you!
Ok, thanks. I was concerned that passing an array with shape (x,y) to a subroutine expecting (:) would not work.
The solution is to specify format strings for the write statements. For example: write(*,'(3A,I0,A)') "Integrate(", constant, "x^", power, ")" 
Thanks for your help, appreciate it.
Yes, this is something that coarrays could accomplish. Essentially, a coarray is an array that is shared among separate copies of the program running on separate processors. So, you could approach the problem like this: 1. Load the initial data set into a coarray 2. Have each processor/program work on a specific chunk of the data 3. Output the results from each processor into another coarray Once all of the separate processes are done, you can sync the coarray image and do a final output to the results.txt
Usually when it says that, its having trouble actually accessing (or even just finding) the files. First thing I would suggest is to make sure it has the right location for the files. Then, check that nothing else has them open or has a lock on them.
Yep, I fixed it. It seemed like I was linking it to the wrong location.
Glad to hear it.
Just FYI to anyone that sees this, in ifort you have to set the -assume realloc_lhs flag otherwise target will not be allocated from source. That has got me before and I spent a lot of time trying to figure out why it wasn't working. gfortran works with fine by default and there's talk that Intel is looking into doing the same.
Thank you! I didn't know that. I was using gfortran with it. Hopefully Intel will add it by default.
Awesome! I'll probably be making a pull request to add a few things.
This list is hardly awesome. I recommend people checking out http://fortranwiki.org/fortran/show/HomePage
Don't be a dick. He just started it a day ago.
Do it, damn it!
Okay, thanks. :(
Done! I've got a lot more to add when I get some more time.
Doing this should decrease the total number of multiplications: do iiii=1,a do iii=1,a BB = B(iii)*B(iiii) do ii=1,a BBB = BB*B(ii) do i=1,a C = C - A(i,ii,iii,iiii)*B(i)*BBB end do end do end do end do Also, it might help with round-off errors to use a plus instead of a minus, and then do C = -C at the end (I'm assuming C is initially zero). This is because addition is less prone to round-off error than subtraction.
Interesting, I'll try that out. thanks. Why is addition less prone to round-off error than subtraction? EDIT: Thanks, that made it about 25% faster. I'm assuming this way, there is less cache misses in the same loop?And also, when I do BB = BB*B(ii), I had to change it to BB_2 = BB*B(ii) for it to work. 
You can use usually some nested intrinsics and array slicing operations. For example, I'm removing the inner-most loop here: do iiii=1,a do iii=1,a do ii=1,a C = C - sum(A(1:a,ii,iii,iiii)*B(1:a)*B(ii)*B(iii)*B(iiii)) end do end do end do I'm having trouble visualizing what exactly this tensor product is, but you can likely reduce A down to something 2D and do away with the loops. You could also create MASKs for each of the B indices and use multiple SUM calls with the masks. http://gcc.gnu.org/onlinedocs/gfortran/SUM.html
I had never used it, but sure enough there's a PRODUCT intrinsic. You could probably do this in one line with some combination of products and sums. As a general rule of thumb, I greatly prefer to avoid explicit loops wherever possible, and use slices and intrinsics wherever possible, at least when it enhances readability.
I found that DOT_PRODUCT made it slightly faster. Do you think using OpenMP or CUDA can help?
thanks for your contributing!
Are you using any optimization flags when compiling? For instance if you're using ifort or gfortran the compiler option -O3 will likely improve the run time of your calculation.
I was trying the performance with -O2 and without it. Currently my code looks like this. This is with loop unrolling and implied loops and the intrinsic function, DOT_PRODUCT. This seems to run faster without -O2. And it is about 7 times faster than the code I posted. Will -O3 make a difference? do iii=1,a do ii=1,a BB = B(ii)*B(iii) C = C - DOT_PRODUCT(A(1:a,ii,iii,1),B(1:a))*BB*B(1) C = C - DOT_PRODUCT(A(1:a,ii,iii,2),B(1:a))*BB*B(2) C = C - DOT_PRODUCT(A(1:a,ii,iii,3),B(1:a))*BB*B(3) C = C - DOT_PRODUCT(A(1:a,ii,iii,4),B(1:a))*BB*B(4) C = C - DOT_PRODUCT(A(1:a,ii,iii,5),B(1:a))*BB*B(5) C = C - DOT_PRODUCT(A(1:a,ii,iii,6),B(1:a))*BB*B(6) end do end do
O3 does more aggressive loop optimization than O2 so it's possible that may close the gap. However, I wouldn't expect a huge speed improvement for the new code you're using. When compilers optimize loops one of the things they do is look for patterns they can replace with various vector/array intrinsic procedures like DOT_PRODUCT. So likely using O3 on your original code at best would cut it's speed down to that of your new code. Of course your original loop may be too complicated for the compiler to easily dissect, so it may not do anything.
Actually -O3 gave me a slight boost. But I really want to make my code run at least 3 times as fast. Do you see any improvements for my new code?
There is a hard limit to how fast your code can go in that you are essentially multiplying two 4-dimensional arrays together by element and then taking a sum. C = -sum(A*B4) where do i4 = 1, a do i3 = 1, a do i2 = 1, a do i1 = 1, a B4(i1,i2,i3,i4) = B(i1)*B(i2)*B(i3)*B(i4) end do end do end do end do so if your B array isn't changing then you can speed things up by calculating B4 once and then just using the summation method above to get C. If not then you could try using symmetry to speed up the calculation for B4. For instance B4(1,2,3,4) = B4(2,3,4,1) = B4(3,4,1,2) = ... = B4(4,3,2,1). Also are you actually using the variable "a" for the range of your loops in your code and the variable "A" for your matrix? I ask because Fortran is case insensitive for variable names and this could be a large potential conflict. 
I am actually calculating this multiplication n^6 times where I want n to be around 50 for the code to be usable. And every single iteration B changes but A stays the same. Right now I'm doing 20^6 multiplications in 120 seconds. I tried making a 4D tensor out of B and doing that multiplication but it slows down significantly. And no, the variable a and A have different names in my actual code. I guess I have to look into OpenAcc, OpenMP or CUDA?
so you dont need to distribut the julia interpreter with your finished program
Try c1 = CMPLX( -b/(2*a), SQRT(discriminant)/(2*a) ) or c1 = ( -b/(2*a), SQRT(discriminant)/(2*a) )
Putting CMPLX in front allowed it to compile, For a generic quadratic expression, A*x^2 + B*x + C = 0 : Enter the values of A, B, and C, in that order. 2,5,7 There are two complex roots to this equation c1= ( -1.25000000 , NaN) c2= ( -1.25000000 , NaN) But unfortunately, the imaginary portion of the complex still isn't being created properly. I have to assume that it's with the way I set up the second half, but I don't have a clue. Thank you for the suggestions though!
I'd say it's probably worth having a look at [FortCUDA](http://fortcuda.sourceforge.net/) and [FortranCL](https://code.google.com/p/fortrancl/) which provide a fortran 95/2003 interface to CUDA and a fortran90 interface to OpenCL respectively. Moving some of the heavy lifting to the GPU might reasonably straightforward depending on what the code is doing.
Because here: ELSE IF (discriminant &lt; 0) THEN c1 = -b/(2*a), SQRT(discriminant)/(2*a) c2 = -b/(2*a), -SQRT(discriminant)/(2*a) You're trying to do a sqrt of a negative number (a REAL negative number) which throws "NaN". You want: ELSE IF (discriminant &lt; 0) THEN c1 = -b/(2*a), SQRT(abs(discriminant))/(2*a) c2 = -b/(2*a), -SQRT(abs(discriminant))/(2*a)
Ah! Thank you so much! It works properly now :)
The first task I had was to try and see if we could get better performance by parallelism on the CPU, we got good results, close to 95 % speed up, Ie 8 cores 7.54 times increase. The Fortran has a c wrapper, which is a mex function passing up to Matlab.
The code is wrapped inside of c, but literally all the work is performed inside of the Fortran code. I suppose passing off some of the work is a possibility, but would this require major reworking of the code layout.
Thanks, I'll have to give fortcuda a look. I am looking a numerical ray tracing so main concern is the exit conditions required for each ray and this causing it to slow down beyond any speed improvement.
Have you tried running any code on the GPU directly from Matlab?
Use it all the time at work. Quite a big fan.
It is possible. PTX is PTX. I have called the same c-Cuda compiled subroutine from c-cuda, fortcuda, and the matlab paralell processing toolbox.
A few things: 1) OpenMP 4.0 just got put into the latest version of gcc: https://gcc.gnu.org/ 2) I don't know what kind of calculations you're doing, but have you tried using anything like OpenBLAS or Intel MKL? If you're doing matrix calculations, they automatically detect CPU cores and parallelize themselves. 3) GPU's can be powerful, but they're limited by a couple of things: a) it really takes a long time to copy the data to the GPU, and then back off. It can almost negate any speedup you'd get, and b) you can't distribute computations among multiple GPU's on across several machines, but you can do that with CPU cores. Edit: Oh and coarrays might be useful. But you'd have to rework some of the Fortran code.
Hey, I've had another pull request sitting there for about a week... I added a few more things.
As an alternative, you can also do this using a more "modern" Fortran approach using: function numberOfLinesInFile( fileName ) result( lines ) character(len=*), intent(in) :: fileName integer :: ios, lines, unit lines = 0 open(newunit=unit, file=trim(fileName), form='formatted') do read(unit,*,iostat=ios) if (is_iostat_end(ios)) exit lines = lines + 1 end do close(unit) end function numberOfLinesInFile where [is_iostat_end](https://gcc.gnu.org/onlinedocs/gcc-4.7.0/gfortran/IS_005fIOSTAT_005fEND.html#IS_005fIOSTAT_005fEND) is a intrinsic function introduced in the 2003 standard and [newunit](https://software.intel.com/en-us/node/511247) is a new optional argument for open from the 2008 standard (according to the [FortranWiki](http://fortranwiki.org/fortran/show/Fortran+2008+status) this feature is only supported by about half of the major compilers).
Nice, I've never seen is_iostat_end before and totally forgot about newunit. Definitely the way to go.
While were on the subject, there is also [is_iostat_eor](https://gcc.gnu.org/onlinedocs/gcc-4.7.0/gfortran/IS_005fIOSTAT_005fEOR.html#IS_005fIOSTAT_005fEOR) for determining if you attempted to read past the end of the line (record). With that and with automatic string resizing introduced in Fortran 2003 you can read a line from a text file of [arbitrary length](http://stackoverflow.com/a/21953596).
That's awesome. I haven't played with it much, but co-arrays could be one hell of a killer HPC feature if the performance comes close to hand-written MPI.
You definitely need to look at OpenACC! From what I've seen, it looks like the most convenient way to port old Fortran code to accelerators. It's similar to OpenMP in its programming philosophy. http://www.openacc-standard.org/
Thanks for the help! 
Why is addition less error-prone than subtraction? I think you are mixing it up with the loss of precision resulting after subtracting similar numbers.
 What you want to do is contract each dimension consecutively, from left-most to right-most, and use matrix multiplications (BLAS would be your friend here). Here is how I implemented (I changed the names of the variables): allocate(aa(N,N,N)) allocate(aaa(N,N)) allocate(aaaa(N)) do l=1,N do k=1,N aa(:,k,l)=matmul(a(:,:,k,l), b) end do end do do l=1,N aaa(:,l)=matmul(aa(:,:,l), b) end do aaaa=matmul(aaa,b) res=-dot_product(aaaa, b) For N=150, the original code took on my machine 2.4 s without flags, 0.5 s with -O3. My code, 0.38 s in both cases. Notice how, as /u/cymick pointed out, the compiler can improve tons on the simple loop, but pretty much nothing on the matmul version. Ah, using forall loops instead of do loops: forall(l=1:N, k=1:N) aa(:,k,l)=matmul(a(:,:,k,l), b) end forall forall(l=1:N) aaa(:,l)=matmul(aa(:,:,l), b) end forall aaaa=matmul(aaa,b) res=dot_product(aaaa, b) shaves off about 10% more. In any case, what you are trying to do is a quite demanding operation. For N=100, the a array is about 1GB of memory! There is a limit to how fast it can be done. If you really need to make it fast, and you have access to Nvidia cards, I recommend very much implementing the above using CuBLAS.
Won't that potentially be the case in OP's algorithm though? Maybe I am confused about something though. I thought that since I can loose precision when I compute a-b, that in general, it would be better to avoid computing: s = -a1 - a2 - a3 - ... - an and instead perform: s = a1 + a2 + a3 + ... + an s = -s to hopefully get better precision. Am I not understanding it correctly?
For the same values of a1, a2, etc. you will get identical results. Try it. I think the problem with subtractions you might be thinking about goes like this. Consider this expression: 2.e20*(1.-1.) That should be 0, right? But if those ones are just a little "off", so one is truly 1 and the other 1+1.e-16, your result will be +/-1.e4. Quite a difference. However, subtracting a negative number from a negative number is not a problem: 2e20*(-1-1) will be -4e20 up to machine precision, because the second factor amounts to -2+/-1.e-16. In OP's case the same problem would arise if the components of the B vector are huge and the elements of the A matrix are alternating ones and zeros. In that case, the whole algorithm would need to be revisited completely. Another way to look at it: multiply all the elements of A by -1. Would that ruin the accuracy of your addition approach?
Thanks for the explanation!
You're welcome!
Thank you so much gwonzil, I'll try that! I haven't had much time recently to work on this but now I am back on it. I'll let you know if I succeed.
nice score! it looks like you could kill someone with that thing! I guess you don't still have CDC stuff floating around?
new desk? did someone die? seems like you're finding a bunch of old goodies.
STILL VALID.
Install macports http://www.macports.org Install gfortran Compile
You used to just be able to install the xcode package for free from the apple store. Then gcc and gfortran would be available on the command line and everything was a bit nicer. Of course you still had to deal with the gnarlier directory structure when linking but what can you do. 
It takes maybe 5minutes for me to actually compile and run each time though...it's basically so laggy its next to impossible to work.
Damn. Are they using two cans and a piece of damp string for their network?
or https://www.macports.org/
Welcome to Fortran. This is my favorite tutorial site for fortran 90: http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/fortran.html It has plenty of examples. Your problem should easily be solvable if you read up on the repetitive execution section. 
Do you need to do all 3 problems?
I having difficulty with the writing of the program. I don't understand because the teacher is expecting me to know a program I have never worked with. 
Can you write it in pseudocode yourself? You're going to need to use a do loop, write, and declare integers and reals to do this in fortran. It's kinda hard to tell if you need help with the syntax of Fortran specifically or just programming in general. 
Actually, I have no idea where the read statement is. I can look at the code and figure it out, but there are about 50 .f90 files for this project and each has multiple subroutines. When the code is waiting for input, I was wondering if there is a way to figure out through debugging where the code is waiting.
/u/Omnominable pretty much gave you the answer. Other than that, work through the logic and try to decipher where you are in the code. 
That little note has taught me more then my teacher has.
You want to use a debugger for that. What sort of platform are you working on? Windows with visual studio, or are you working from a terminal (command line) with makefiles etc.?
I think this should help you find read statements in your code: grep -i "read" *.f90 or if you have multiple folders grep -i "read" */*.f90 -r
I'm working on visual studios, but I also have familiarity with linux if that helps.
Thanks for the help. I've used the grep command to find the read statements. The issue is that the write statements corresponding to the read statements are never located in the same file so it's just takes a while. But this method has been the most helpful so far.
Yea, I wasn't trying to be rude. I seriously appreciate the help from the FORTRAN community. I was just curious if there was an easier way to see where the code is waiting.
If you have some programming experience I recommend Modern Fortran Explained. It's a good introduction to the modern features of Fortran and can be a good reference as well even after you've got down the basics. It contains the basics (loops, variables, expressions, ifs, arrays, etc) and features up to and including Fortran 2008 including derived types, modules, pointers, interfaces, IO, C interoperability and much more. Also, since Fortran 90 they've dropped the all caps spelling.
Yea, saw that was the top rated book on amazon so was thinking of getting it. It's a little pricey, but I'll primarily be using Fortran for the next two years so it'll probably be worth it. I appreciate the recommendation, and I'll make sure to not screw up the spelling again.
Of the few that I've read I've found Modern Fortran Explained to be the best. However, it still lacks in certain areas (mostly more advanced derived-type techniques). But if your goal is to bring yourself up to speed on Fortran 90-95 basics then it'll do great. 
Yea, just going to get a better grasp on the language. Once I get a better foundation I might start looking into the more specific Fortran books for engineers or numerical methods.
I'm guessing the program isn't compiling for you? If that's the case (and it should be) there are several places that are causing problems: * You're declaring g, r, and h each twice. Once as parameters and once as variables (recall Fortran is case insensitive outside of strings so g and G are the same thing). * Second, the first time you declared g you a minus sign in front of g which isn't allowed. * Lastly you're trying to alter the value of g in your do loop which as already been declared as a parameter in your first declaration line.
It's only gone down fairly recently. Hopefully they're just updating the page for the new version
I'm pretty sure drand is specific to ifort. Also random_number is probably the preferred way of generating random numbers as it's part of the standard which makes it portable.
I used to do this pretty regularly two or so years ago when I was using MATLAB extensively. I was using a package called [Gnumex](http://gnumex.sourceforge.net/), which allows MATLAB to compile C, C++, and Fortran with its *mex* commands using GNU Fortran on Windows. On other platforms where they actually support GNU compilers (GNU/Linux and Mac OSX), you don't actually need Gnumex. MATLAB fully supports using Fortran compilers. They'd be crazy not to do so. Some of their documentation is [here](http://www.mathworks.com/help/matlab/matlab_external/create-fortran-source-mex-file.html). It's actually not particularly difficult, and MATLAB's documentation is quite thorough concerning the interfacing.
[doymand's answer](http://www.reddit.com/r/fortran/comments/2i4a7d/help_with_undefined_reference_to_drand/ckypm30) is correct in regards to *drand*. To determine which version of Fortran you have in MinGW, just run: gfortran --version 
So ifort == Intel Fortran? And this is only available as a paid product? https://software.intel.com/en-us/fortran-compilers Thanks.
Correct, they used to have a non-commercial license for Linux but the website has been under revision for a while. If drand is the only ifort specific problem and you don't want to buy it then it can easily be substituted for a different random number generator. 
I write Matlab mex interfaces for a few of our Fortran codes. It works fine except that Matlab is a bit behind in terms of Fortran compiler support for MacOSX. As of R2014, they only support gfortran 4.3 on MacOSX, which means you can't utilize a lot of F90/F2003 features. On Linux, however, they support gfortran 4.7.
Disclaimer: Running Matlab R2014a on Windows 8.1 Can you tell me what the difference between a matlab-fortran interface file is, and how that's different from the interface block used in legacy code? I'm just writing some basic f90 code, using a main function and modules, so interfacing between them is not required. I tried putting all of the sample code in the documentation you linked but it did not compile correctly. I put all of the declarations and statements into one file and called it 'timestwo.F', but it didn't work. The main error message being: Error: Unclassifiable statement at (1) To me it seems I'm not correctly parsing out the information correctly, but I could be wrong. I learn best from example, would you be able to send me (here or pm) a MWE?
This is good news, I'm interested in hearing about your experience on working with R2014. Do you know if it's similar to running it on Windows?
The ieee_arithmetic module provides the ieee_is_nan(x) function: http://fortranwiki.org/fortran/show/ieee_arithmetic For example: use ieee_arithmetic ... x = 1.0 if(ieee_is_nan(x))then ... end if That would evaluate out to false since x is normal. 
An alternative way is to test if the number is equal to itself - NAN is never equal to anything so it will evaluate to false in this case. IF (seccpi(i) .EQ. seccpi(i)) THEN cpi=cpi + seccpi(i) ENDIF
Thanks, I'll give this a go.
In Fortran, the only value assigned to a variable that doesn't equal itself is NAN. Therefore, IF (A .NE. A ) then it's NAN.
Thanks, I did what you and skeesicks recommended and the array is summing correctly now. 
I no longer have a MATLAB license, so I'll just have to guess what's wrong. The error message you received, "Error: Unclassifiable statement at (1)," should have been accompanied by a line number in your Fortran source code. Could you provide the source code and the line number of the error?
It seems to me that your problem is with the variable x_0 in newt_raph: By default, it's intent(inout), and you modify its value in your do loop. However, when you call the subroutine from your main program, you're passing it a constant value instead of a variable â€” and you cannot modify the constant value -4.0 in the main program, so your program crashes. Edit: Also, it's a good idea to use modules for your subroutines and functions, so that the compiler can check the types of the arguments compile-time, avoiding one annoying source of mysterious crashes. Not that it would've helped in this particular instance, but may save you trouble in the future; in this instance, a habit that would've helped you would have been to declare the intent of _every_ function/subroutine argument, _every_ time. 
There's no question. Are you asking for someone to do the assignment for you?
one of the things that you have to decide is how your program is going to determine what the dimensions of the matrix are. there are lots of different ways that you could do this, it could be: - contained in a line of text in your file. - determined based on the formatting of the text file... like if the rows of the file are the rows of the matrix ... - given by the user as separate input. i mention this because you'll need to define the values of variables like n_colsA before you use them in read instructions.
I have to have it read separate text files
You can initialize it to null in the pointer's declaration by doing something like this: type(myType), pointer :: ptr =&gt; null() The problem with associated being undefined only arises when you don't explicitly set it to null. 
If the variable needing to be initialized originates from inside a subroutine then I don't think this would work, on account of not being able to use save variables. But simply breaking it up into two steps should work just fine type(myType), pointer :: ptr ptr =&gt; null() 
Oh yeah, cause it's saved implicitly, correct?
Definitely one of the biggest gotchas when learning Fortran in general even. It's not intuitive that initializing the variable in its declaration would save the value between calls and can really cause a lot of headaches.
&gt; Which is especially tricky if you're just getting started with OpenMP or MPI since invoking them typically also changes the default to unsave. Oh wow, I knew the first gotcha but not this one.
I'm going to try this now and report back here, but one thing I found is that NULL() wasn't defined in the standard until Fortran 95? Do I need to set any compiler flags to use this with gfortran? EDIT: gfortran complains about null() being invalid when I compile with --std=gnu (the default standard): ptr =&gt; null() 1 Error: Invalid character in name at (1)
EDIT: thanks for the tip on nullify(), I got it working now! The problem was with my use of a pointer shortcut before it was allocated, so I did ab =&gt; a%b before I had called allocate(a%b). nullify() compiles, but now I'm getting segfaults. Basically here's what my code looks like: I define a type in one module and then I want to use that type repeatedly, but initialize it on first reference. The datatype is defined in one module as this: TYPE t_b INTEGER :: size ! ... some buffers that get allocated later to this size END TYPE t_b TYPE t_a TYPE (t_b), POINTER :: b ! ... a bunch of other pointers and variables END TYPE t_a In my main module I allocate objects a and b, and nullify a%b, like this: allocate(a) nullify(a%b) Then in another module that gets passed object a from main, I want to use a%b%size to allocate some buffers, and that looks like this: if (.not. associated(a%b)) then allocate(a%b) a%b%size = 1 endif ! then I allocate a buffer with size a%b%size and use it Is there anything you can see that is wrong with this code? a%b%size does not seem to be getting set correctly... If you can't tell from this code snippet then there's probably something else that I will have to look into and debug. 
I'm not sure I understand what you're trying to do with allocate(a) nullify(a%b) You don't have to allocate a in order to nullify a%b. If you meant allocate(a%b) nullify(a%b) instead, you can do this but it would be unnecessary. When you allocate a pointer in Fortran it does two things: first it creates a new variable in memory with the same type as the pointer, second it associates the pointer with that temporary variable. When you nullify you disassociate your variable with that temporary variable and set the pointers state to "unassociated". So unless you planned on using a%b in between allocate and nullify you don't need to include the allocate statement. Edit: I also wanted to add, since you're working with derived types, you can define your pointer in type t_a to be assigned null by default type t_a type(t_b), pointer :: b =&gt; null() end type t_a which I believe will work just fine with OpenMP and MPI. I just tested this in the latest version of gfortran I have without using MPI and it worked just fine.
This is why it's generally a good idea to label all of your functions and subroutines as PURE unless you explicitly want them to do something that would make them not-pure, i.e., writing output, editing module/common block variables, using save variables (note: the function/subroutine prefixes PURE, ELEMENTAL, and RECURSIVE all carry with them UNSAVE as well).
Thanks for the help! I got it working and feel like I understand the way pointers work in Fortran (as compared to C) now.
Yes, I know it's obsolete, but it does work..
I actually like xCode for C++ due it's nice interface and code completion. Thanks for pointing me to that source! Looks like I finally have to look into makefiles now :)
/r/homeworkhelp
How did you know..
/u/Omnominable must have psychic powers
I would say if youre posting on this subreddit, you should ask a fortran specific problem. The setup of the algorithm youll use for something like this isnt language specific. You can derive a setup in any language you want. When you start coding it and come across issues with actual fortran, we will be happy to help
Any useful fortran code ive encountered for my research has been in f77. Id say its more common than f90 codes you encounter. I work on porting them over to modern fortran. We need a fortran martyr. Someone will scour the internet porting f77 to modern fortran. They are the hero fortran deserves, but not the one it needs right now.
I'm glad someone else feels as excited as I am. I've hated running this thing in a VM, and it's awesome to have it back on OS X. The setup program for Visual C++ 4.0 doesn't make any groups, but if you run MSDEV.exe on it's own, it too works fine. I need to try Visual Studio 97 and 6.0 ... If they work too, this is totally awesome.
Ahh yes, I meant the latter... Intel's Visual Studio with Fortran. Really, really, great stuff. And the MKL libraries are simply the best.
There a whole host of questions that need to be answered, such as: * What do you mean by insert photos in Fortran? * What is the file format of the *images* you are trying to use with Fortran (taking some liberty in interpreting your question)? * What is the nature of your project? Unless it deals with scientific computing (e.g., mathematics or engineering), there are likely myriad more appropriate tools than Fortran. * Almost certainly, for a game, there are better languages than Fortran to use.
|Almost certainly, for a game, there are better languages than Fortran to use. Modern Fortran (90,200X) is actually quite elegant so I salute anyone making an effort to write a game in it. There are worst language for game development (Objective-C comes to mind.. what with the inane message passing and the endless declaration of pointers and the shmoikel corbin!). However, this is going to be quite the undertaking. The best thing google gave me is [f90gl](http://math.nist.gov/f90gl/). You're gonna have to bite the bullet and learn opengl in order to use that. 
I assume you probably want some kind of simple graphics library along the lines of canvas for HTML5/javascript. If anyone else knows of such a library that will give a graphics buffer to which sprites can be drawn to and moved around, please chime in!
It might be easier to wrap the Fortran in something else, like Python, then call up images with that instead? 
We really can't use other languages other than Fortran. We are supposed to make any program we want but my groupmates keep telling me they want to make a game. 1. Putting images in the output screen. 2. .jpg or .bmp 
Isn't Plato the editor? Ftn95 should be able to call. Net which means SDL.. 
Time to apply some salesmanship to the rest of your group. Fortran was *made* for scientific applications and its continued development has been along those lines. The fact that it has an intrinsic way of representing imaginary numbers should be an indication. I *strongly* recommend you re-orient to identify a program that is calculational in nature. Of course, your Fortran code can create output files that can be plotted by something else (e.g., GNUPlot, Python/matplotlib). Remember, when you are forced to use a hammer, not everything is actually a nail. Use the right tool for the right job. It'll be much less hassle and what you produce will be superior.
This is not something that fortran is suited for. It is possible to draw to screen with additional packages but that is probably the limit and even then it is something I would advise against doing to anyone but the most hardcore. If you are making a program then Fortran is well suited for anything computational in nature however, if you are dead set on making a game, then Fortran should easily be able to handle a text based adventure game.
Is it me, or this post is just a joke poking fun at people asking stupid stuff? I think it is hilarious :D
`integer` corresponds to an integer number like 5, 150, 127 etc. `real` corresponds a floating point number, or a 'decimal' like, 5.0, 3.14159, 57.75 etc. I suggest you look at the types in fortran. Granted this is for FORTRAN77, but still applies: http://www.fortran.com/F77_std/rjcnf0001-sh-4.html
[This](http://www.fortran90.org/index.html) is probably my favorite site, especially the [Fortran Python Rosetta Stone](http://www.fortran90.org/src/rosetta.html) section. Like you, every "cheat sheet" out there are, as you say, boring.
Thanks! [http://www.fortran90.org/](http://www.fortran90.org/) is great! I don't know how i haven't found this one. I really like the [Best Practices](http://www.fortran90.org/src/best-practices.html) section. EDIT: I Also found [this](http://jupiter.ethz.ch/~pjt/fortran/fortranclass.html) - lectures and additional resources. Unfortunately no videos, but still seems good.
Thanks.
This is extremely basic stuff. Read about IO, loops and arrays and you are good to go.
That sounds suspiciously like a homework problem.
OK turns out there's a compiler flag `-fstack-usage`, just like in `g++` and `gcc`. It's just not mentioned in the man page or anywhere on the internet.
`gfortran` is just a frontend for GCC, so that makes sense.
I'd probably be a horrible suggestion, but if this solution didn't work you could try [f2c](http://www.netlib.org/f2c/), and use the C tools on the translated source.. But of course f2c is just a tad dated.
I typed `/stack` and checked the hits, so I didn't see this. I probably should read the header of man pages in the future. One gets used to common patterns, I guess.
When in doubt, look at the documentation for your favorite compiler. Both ifort and gfortran (I'm sure others do as well) have extensive documentation that details A-Z, all their supported commands. [ifort](https://software.intel.com/en-us/node/525874) [gfortran](https://gcc.gnu.org/onlinedocs/gfortran/) There's also the standard which details everything about the language, though it can be difficult to read. 
[here!](https://onedrive.live.com/redir?resid=FC52FA7AE3119AB0!411&amp;authkey=!AO955S37jYPPyww&amp;ithint=folder%2cDAT) is a link to download and view the files
Holy smokes. Do people seriously still teach to program like this? I am sorry about you, mate, but I don't really have the time to go through such old fashioned and hard to read code :( The suggestion about changing file units might help, though.
My professor has explicitly stated that he gave us this assignment because we will be asked to use tools we dont know how to use to solve problems we dont know how to solve. Thats fine and all but my major has spent 3 years askin us to write assignments in matlab. Ive never had a class to learn fortran and my professor provided us a flow chart to follow and that's about all the help he is. 
Hey man i really appreciate you taking a look at it and providing some tips! My coding skill is lacking but the flow of the code is because we have a 40+ page flow chart that sorta takes us through step by step. So the write statements i have are all required. Is having format ('structure data') incorrect to do? I thought that was just a simple way of outputting strings similar to matlabs display command. Ive only worked with matlab so i dont really know the ins and outs of fortran. Once again i really appreciate you taking a look. im at a loss and any new insight helps a ton!
That link now has my more recent attempts as well as 2 output files so that you can see whats happening. Run 1 has those titles i want, but then run 2 it stops after the joint restraint section for some reason
that link should now take you to my most recent attempt. The run1output file has my new sections in there, but the the run2output stops after the joint restraint section. I didnt change any line of code. just clicked run. saved the output. then clicked run again. sorry to blow you up!
so just to clarify some things here. the write(6,*)... that * signifies the format number i should input correct? or should I put it in directly as you have it. That last part. so are you saying i should try writing to some other number, lets say 4, instead of 6? i'm about to take another crack at it making some of the updates suggested. edit: also i'm still at a loss as to why it works once, and then not again. can that really be due to the format statements? 