&gt;coachkler I haven't seen those, and don't have the time to watch them all. If you're striking out on your own to learn, you already show more initiative than most... &amp;#x200B; That said, try to learn any way you can and don't hesitate to ask questions on places like stackoverflow, etc.
Safaribooks also has an increasing number of videos included in the subscription price including many long tutorials/courses. Started watching one for C++ that I think was pretty good, but watching videos is not really my thing so I went back to reading.
If you are using the newline character, wouldn't you have to do only \\n for Linux and \\r\\n for Windows? Or does \\n work the same on any platform? I learned std::endl and that's what I've used, and it always seemed to work fine. For some reason I thought I had heard that std::endl handles the differing newline sequences in different operating systems (\\r\\n for Windows and \\n for other operating systems, etc.).
A complete beginner to programming? I might suggest Python as a starter language. I feel it simplifies a lot of things and is faster to get results and feedback. Or are you taking C++ as part of a comp-sci course? A lot of C++ can be fighting with build systems, which is frustrating for beginners.
On the other hand it should be possible to teach a lot of c++ without worrying beginners about namespaces at all, and cut down on the boilerplate a bit, so just treat std:: as part of the names without dwelling on it.
One of the structs is for the general case of one or more inner size arguments. In that case, we want to strip the outermost size Outer and turn it into `std::array&lt;_, Outer&gt;`, where _ represents the inner dimensions of the array type. `mdarray_&lt;T, Inners...&gt;` handles the case of one fewer dimension, the `::type` signifies the equivalent `std::array` type for that case, and the `typename` is to tell the compiler it's a type and not a value. The other struct is a specialization used when there are no inner sizes (only one size total, like `mdarray&lt;int, 5&gt;`). The type we want from that is a 1D `std::array`. This is always the "innermost" `std::array` type, with the general case adding layers to it one by one. Unfortunately, I don't know of a way to add the layers in one go instead of one by one recursively. It's a lot like an inductive proof. If K is the number of dimensions, the base case is the specialization where K=1. That's a `std::array&lt;T, N&gt;`. From there, we assume that the K-1 case works and form the K case based on that. For the example above, we say "assume `mdarray&lt;int, 3, 5&gt;` works and gives us back a `std::array` version. Then `mdarray&lt;int, 7, 3, 5&gt;` is `std::array&lt;_, 7&gt;`, where _ is the result of that K-1 case.
Why not `_` as a prefix? I've seen other languages that are doing that.
Oh that really interesting. The first time I learned to write in c++, we specified the std namespace whenever we used cout and the like. But from then on, it was instilled in me that the basic structure of a cpp program always had "using namespace std". (I personally liked "using namespace std" because I found "cout" more readible that "std::cout"). But that explanation makes a lot of sense. So now I guess I have the inverse question. If bringing everything into the same scope is such as issue, why even say "using namespace [namespace] at all"?
 template&lt;typename T, std::size_t Outer, std::size_t... Inners&gt; This is a variadic template, meaning it can take a variable number of template arguments. The first is the type that will be stored in the array, the second is the first dimension, and all the remaining dimensions. struct mdarray_ { using type = std::array&lt;typename mdarray_&lt;T, Inners...&gt;::type, Outer&gt;; }; This defines the `mdarray_` template, which defines a type alias inside it. This is the first place of magic: this type alias is a recursive definition of itself. At each step, the number of dimension arguments is reduced. Stare at this long enough until you see how that works. template&lt;typename T, std::size_t N&gt; struct mdarray_&lt;T, N&gt; { using type = std::array&lt;T, N&gt;; }; All recursion needs a base case, and this is how it's done with templates. This is a partial template specialization, defining what happens to `mdarray_` when it only has one dimension. In this case, the type alias is just an array. The result up to this point, you can now use the type alias `mdarray_&lt;T, Dimensions...&gt;::type` to get an array of array of array .... We're almost there. template&lt;typename T, std::size_t... Sizes&gt; using mdarray = typename mdarray_&lt;T, Sizes...&gt;::type; This is a final type alias to make everything easier to use. Its job is mainly to take away the `::type` (an an extra `typename` when used in templates).
I don't see how you can avoid teaching shared_ptr to beginners before they start doing any real work. Seems pretty standard now to only expose shared_ptr and unique_ptr in APIs and hide all raw pointers, so beginners in particular are not as likely to have to deal with old C pointers, but will have to deal with many shared_ptr? Luckily those that are introduced to C++ tend to not be novice programmers but already know enough about programming to be able to absorb this? Few have recommended C++ as a great first language.
Thanks for the example. Now I'm wondering if I've used `.release()` where the "receiver" of the ownership could throw. Maybe any interface with a function that takes an owning raw pointer and isn't noexcept should be viewed suspiciously.
Recursive variadic template. As with all recursion, try unrolling it manually. Start with `mdarray&lt;int, 7, 3, 5&gt;`. This is defined by the `using mdarray = ...` as `mdarray_&lt;int, 7, 3, 5&gt;::type`. So we have to figure out what `mdarray_&lt;int, 7, 3, 5&gt;` is before we can evaluate `::type`. There's a template specialization for `mdarray_&lt;T, N&gt;`, but as you can see we have 4 parameters, so that isn't a suitable template. That leaves `mdarray_&lt;T, Outer, Inners...&gt;`, where Outer and Inners are size_types. This *does* match: `T = int`, `Outer = 7`, `Inners = {5, 3}`. So now that we have a valid template struct, we can look to see if it has a `type` member. It does, courtesy of that `using` statement on line 12. `mdvalue_&lt;int, 7, 5, 3&gt;::type = std::array&lt;typename mdarray_&lt;T, Inners...&gt;::type, Outer&gt;`. Using the values on the left: `mdvalue_&lt;int, 7, 5, 3&gt;::type = std::array&lt;typename mdarray_&lt;int, 5, 3&gt;::type, 7&gt;`. Do you see the recursion? The next step is: `std::array&lt;std::array&lt;typename mdarray_&lt;int, 3&gt;::type, 5&gt;, 7&gt;` The final step involves the base case of the recursion. Notice that instead of selecting the template with `&lt;T, Outer, Inner...&gt;` parameters, we now match `mdvalue_&lt;T, N&gt;` for `T = int`, `N = 3`. Thus the final type is: `std::array&lt;std::array&lt;std::array&lt;int, 3&gt;, 5&gt;, 7&gt;` Let me know if anything's unclear; I wrote this really quickly
It doesn't protect your from omitting this-&gt; while you can't ignore m_ prefix. 
I understand templates at a very basic level but this is whole other ball game. Any sites, books, or resources where I can read up on this stuff? I found it this very interesting and it seems like something I can dig into over the weekend. Would this fall under template meta programming?
I think it's to avoid possibly using a reserved identifiers. I use the `_` as a suffix too, and when I looked into it, I seem to remember that I thought it did not apply to my case, but preferred to err on the side of caution. https://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier
&gt; your program logic moved into the compile time space If it can be computed at compile time, it's not really "program logic" by definition...
I agree; \_ as a prefix is the most useable member marker I've found because it's searchable with autocomplete and it's also alphabetically first so in a blank autocomplete context. i.e. they always show up together at the start instead of in between the local variables starting with the letters a to n and o to z
Underscore prefix is reserved for C++ library implementation by the Standard. So don't do that. 
Great presentation Vinnie!
I will definitely try and figure out how to use GitHub so that I can follow your advice. Ps, you guys are awesome.
Using `std::endl` is not a big deal. Yes, it includes a flush of the stream that may not be necessary, but I wouldn't say that makes it a _bad practice_. The frequent use of `std::endl` is usually associated with primitive logging or "toy applications". Once you get into serious development, you'll probably end up graduating the a real logging API. The only time the side effects of `std::endl` should ever be a concern are after you've benchmarked your application and determined that flushing is a bottleneck. Obsessing about it beforehand is premature optimization. 
Only double underscores (`__blah`) or underscore followed by capitals (`_Blah`) are reserved to the implementation. Something like `_blah` should be safe, though I agree that the above rule is a bit subtle and might be a bit error prone if you don't know the details.
That's one way to put it, but another way to think about it is that C++ will reach more and more people as it gains simple middleware :)
I just use prefix underscore for members and no prefixes for local variables and function parameters. Issues with any future standard keywords are narrowed down only to local variables, which are easy to caught and safe to rename. C#'s coding style fits well in C++, classes and functions are starting with uppercase, so you'll never hit ambiguity even while using "using namespace std". Too bad it's not so popular, because people got stuck with google style, which is nothing extra fancy or proved to be more efficient but a bunch of random ideas tied together.
How about .data() + int?
I take it you're referring to the subset of c++ that is legal c? I think downvoters are probably pushing for modern c++, less-c style.
You don't need to KNOW github or git - it's just a useful way to browse repositories of code. It makes it easy if you can download and execute as well, so knowing git doesn't hurt. Here's an advanced beginner to intermediate project: https://github.com/ChaiScript/ChaiScript/blob/develop/samples/factory.cpp I'm trying to find something modern, but I'm having a hard time. :-/ 
&gt; "the identifiers that begin with an underscore followed by an uppercase letter are reserved;" Or containing a double underscore anywhere.
The need to use prefix for member is a code smell. Putting more than 3 data member in a non-aggregate class is without doubt an abuse of object oriented programming. The design goal is: 1 invariant between 2 data, makes 1 class. So there is no need for a data member suffix.
It's not about performance. It's that 99% of the people using don't realise what it is actually doing, and that it performs two actions that are entirely unrelated to each other. Both reasons make `endl` toxic for literate code that clearly expresses intent.
Right, but noone tries to double underscore the variables. There's more to it: https://en.cppreference.com/w/cpp/language/identifiers
It's the ``everything goes'' factor from the major corporations that ignore the hard work of specialized individuals that produce the standards. For example the new C standards are ignored by Microsoft because they think it's not good for their business or whatever might be the case. Well, history is often repeated you know and at some point might be C++ that is ignored for the new kid on the block. Other companies do the same too, I happened to use a Keil compiler at some point and they had the same attitude, had a fleet of 500K POS; how widespread is the use of Keil? If you are using open source compilers at your work you are mostly in good hands and up-to-date with decent implementations but in the commercial world the implementations vary widely; it's terrifying, get prepared to write a whole lot of C-style C++ because you cannot do otherwise; you are mostly paid to ship products not showcase best practices and the like. My favorite example for any lack of responsibility and ethos is Microsoft. The latest update for fairly recent compiler (VC11) is August 24, 2015 -- and still does not have C++11 conformance as it was advertised by a prophetic salesman. Can you imagine the impact of code quality for all those customers that paid the licenses fees for that particular product? Some projects take 5 years to completion and the compiler stays the same because other licensed libraries have to use the same CRT, etc. So, people are forced to use various dialects, use outdated styles, reinvent the wheel, and you know what, that's a deep problem in the industry in the C++ ecosystem and not a minority as you suggested. 
Hey! I think there is a misunderstanding, I didn't want to suggest that the use of these alternative / old c++ standards are a minority, hence putting emphasis on the fact that my experience is not representative of the whole industry.
&gt; variables a Does this mean that this will work fine? ``` #include &lt;iostream&gt; class Foo { public: int i; int j; Foo() : i(j + 2), j(100) {} }; int main() { Foo foo; std::cout &lt;&lt; foo.i &lt;&lt; " " &lt;&lt; foo.j &lt;&lt; std::endl; } ``` Because it doesn't! He was talking for some other language! :D 
I'm not sure I have scripts I'm allowed to share. :/ If you're talking about a build-time dependency (which is what it sounds like to me) I put static libraries with all the objects of the project as a order-only dependency (that is a change in the library doesn't cause a test to build/run on its own, but it must be built before the test) and link against that. If a new virtual function were added to the base class the test suite would have to get rebuilt anyhow, since it includes that header.
Well, I learned a lot only by answering on stack overflow. I mostly started learning modern C++ seriously because of this. In this case this is more like: " blind leading the blind, but if you do a mistake, be assured you'll know"
&gt; I don't see how you can avoid teaching shared\_ptr to beginners before they start doing any real work As I implied in my comment, most uses of \`shared\_ptr\` found today are inappropriate &gt;seems pretty standard now to only expose shared\_ptr and unique\_ptr in APIs ...especially in APIs! (the only appropriate use I know of is demonstrated in the boost.asio tutorials)
To elaborate a bit on the other answers, the problem with `using namespace std` is that it pulls in everything from the `std` namespace. `std` includes a lot of simple names, like `min`, `max`, and `array` that could collide with your own code. If you use `using namespace std`, you need to make sure that none of your own code uses the same function or class name as one in the `std` namespace, or you will likely run into issues. If you want to omit the `std::` on something you use a lot in your code, like `std::cout`, you can just handle that specific case with `using std::cout`. This is a much safer option to use, as you're explicitly pulling in what you're using. Just be careful if you use this in a header file.
Assuming you open it as a text stream it is automatically handled: &gt; A text stream is an ordered sequence of characters composed into lines (zero or more characters plus a terminating '\n'). Whether the last line requires a terminating '\n' is implementation-defined. Characters may have to be added, altered, or deleted on input and output to conform to the conventions for representing text in the OS (in particular, C streams on Windows OS convert \n to \r\n on output, and convert \r\n to \n on input) https://en.cppreference.com/w/c/io
This is all news to me, having in recent years been introduced to the wonders of smart pointers and working with code where it is mandatory. Do you have any recommended reading or watching on the topic of why this is a bad thing?
*std::endl* is equivalent with something like: ... &lt;&lt; '\n' &lt;&lt; std::flush; this is why it is considered a bad practice. Sure, it works, but it does more than you expect - puts a new line character and immediately flushes the stream which is usually a bad idea. And *std::endl* doesn't handle the newline sequences on different operating systems! Windows adds \r\n automatically when you send \n to a text file. This is why, on Windows, if you want to write portable text files you open the file as a binary file. 
Most of my work over the last 4 years has been looking at old pre-C++11 code and working into more modern form. Don't let your idiot teachers bring you down.
Yes, just print a '\\n'. And if you need the flush, just put std::flush to the stream.
neato
&gt; but I figured it was just because c++11 is unused in the career world or it is ineffective compared to c++98. Sounds to me like they don’t want to take the time to update their tools/teaching materials/grading practices.
Surely there has to be a pragmatic compromise somewhere? Advocating for "std::string" just seems a bit silly to me. 
Oh I definitely don’t learn anything from my professors. Often they figure out how to lecture for an hour or so on concepts I can learn from YouTube in under ten minutes. Currently, my favorite channels that can explain concepts and provide examples quickly and efficiently are [TheChernoProject](https://www.youtube.com/user/TheChernoProject) and [The New Boston](https://www.youtube.com/user/thenewboston) .
Step 1. Learn LISP Step 2. Replace () with &lt;&gt; and use prefix notation Step 3. Understand that the values in a LISP program are equivalent t to the types in a c++ template meta-program
boost has a lot of libraries. can you build only the ones you need?
I use _ for autos, m_ for members and prefix all variables with the first letter in the most common type for what the variable holds. Like: int iNumber; int64_t iBigNumber; Mush easier to read code 
What makes you say that?
If you are paying for your university you are getting scammed. If you are not the people paying for it are being scammed. 
Have you tried [vcpkg](https://github.com/Microsoft/vcpkg)? ```vcpkg install thrift``` will get you thrift along with the dependencies it needs, which are: zlib, libevent, openssl, boost-range, boost-smart-ptr, boost-date-time, boost-locale, boost-scope-exit 
it takes so long to build because it is mostly headers, welcome to boost level template land.
What about acronims?
I took a look again at what we do in semester 1 and 2 and it seemed like they have moved to python as the starting programming language. &amp;#x200B; I was actually going to start with python but the school website said they would start with C (semester 1) and C++ (semester 2) so I was going to start with that. &amp;#x200B; How do you suggest I begin learning python? and i have around four months left until university starts, how much do you think I can get done in that time? Any books I should follow? &amp;#x200B; Last year it says the professor used the following materials for the introductory class: (Main Material) Computational Thinking for the modern problem solver, David D. Riley &amp; Kenny A. Hunt, 2014 CRC Press A Chapman &amp; Hall BOOK (Secondary Materials) Think python: how to think like a computer scientist, Allen Downey, 2015 O'Reilly Media, essays/disseration, videos, etc. &amp;#x200B; Thank you so much!
because bjarne and others want to expand C++ to do everything that other languages do well and went crazy. they made a ship that sinks on launch. just imagine if you already had a 100,000+ line code base in c++03 and you had to convert them all into c++11 eg., just putting autos in loops, could u risk introducing bugs into perfectly working critical code? to use new features along with old kinda makes it like hodge podge architecture...baroque+bahaus. yuck.
Thanks for the reply, your response is appreciated and it shows some courage, it seems you differ from all those Modern C++ coders who think that things are black or white, yes or no, up-vote or down-vote, just to showcase their immature binary annoyance and then harming you with negative karma in order to teach you a lesson because it happens to not conform to their opinion. Some people are so weak, they have to follow the herd blindly in order to feel secure about themselves, thankfully not one of them. Modern C++? Yes. Less C-style C++? Yes. End of story, case closed. But C++ has a history and we cannot change that, 90-95% of C++ projects are written in C-style C++ and someone has to maintain them (we are talking about billions of LOC). I know it sounds boring to be old-fashioned but that might be part of your future job, not everybody is working in cutting edge. Therefore it is wise to at-least know your way around C-style C++ (this is a suggestion rather than a recommendation) because sooner or later you will come across such code, sometimes it's possible to modernize, other times not and you will have to deal with it, and since we don't make the rules you will probably have to accept it. Other times it is the nature of the software in question and maybe extremely valuable to know the constructs of C-style C++, if for example you are doing systems programming it's undeniable that you will code in such way, like Windows drivers, I/O Kit, embedded, the examples are countless, Google is writing Zircon with that style while using modern techniques and paradigms. It's not bad, it's part of life, get over it people, find your niche with the language and produce great products, rather than sticking your finger to other people's face to say what it's right and wrong, it ain't your business, C++ is big enough for everyone to enjoy. And finally a simple touch for the down-voters (you have to feed them too), since with every C++ standard things get overwhelming, the C++ minions should inform their masters about some Greek wisdom: ΜΗΔΕΝ ΑΓΑΝ. 
Not surprised they switched to Python. Online pythong interpreter: https://www.tutorialspoint.com/python3_terminal_online.php Found this, and I've used it a bit. Not sure it's the best reference, but it's not bad. http://www.davekuhlman.org/python_book_01.pdf Might not be up-to-date for Python 3, though, it's a bit dated, but 2.7 and three around that radically different for beginners. 
Boost.python?
using std::string; It avoids rewriting std:: all the time without possible future name collisions. 
There are a ton of names under the std namespace. The issue with using `using namespace std;` is not just that some other library might also use a name that is under the std namespace, but also that you could name a variable that collides with the namespace. I often see student code where they named a variable the same as something in the std, and it caused an issue that was hard for them to debug. In general, adding `std::` isn't really that big of a deal, and if you don't want to use that, you can use the format `using std::cout;` to explicitly bring the names you want from the namespace. Also in term of other libraries not using std names. Math libraries often do use std names. Like max and min. They just put it in their own namespace. `mathlib::max`, `mathlib::min`. I think it would be silly for them to rename fundamental operations like that. The whole purpose of namespace is to allow people to names things in the way that makes the most sense. I say import all the names you want, but do it explicitly so someone reading your code later can see where each name in your program comes from.
Well vectors have a similar problem, don't they. It's also unfortunate there is no way to separate lifetime management from data access for multidimensional containers. Functions that operate on these types always need to have the memory management specified (or templated). No equivalent to a raw pointer that can be used for smart pointers
Last time I tried building Boost on Windows (few years ago) it will build static/dynamic + single/multi-threading variants, so it is essentially built 4 times. You can just build the ones you need by providing a custom bjam config.
[https://github.com/tboox/xmake](https://github.com/tboox/xmake) Provide builtin remote package manager in build system.
I think my [middleware offering](https://github.com/Ebenezer-group/onwards) is simpler than some others.
On Linux/MinGW you can just install the compiled libraries. On Windows/VC I usually download the compiled binaries. Or you may also use vcpkg. So you don't need to compile Boost by yourself at all.
`-Werror` can be really annoying. You comment out one line of code while debugging and your code no longer compiles due to an unused variable. It's nice to know about that, so I leave warnings on, but fixing them in unfinished code is usually a needless distraction, so I only enable `-Werror` in CI builds. This particular warning really should have been an error to begin with. I use `-Werror=return-type` at all times.
he admitted he doesnt use that kind of syntax so his understandings are on thin ice
A few problems: 1. `std::vector` A vector in math/physics has well defined mathematical properties that don't really line up with "array with dynamic length and a destructor". If someone comes along and is writing a math or physics package and calls something vector, which side wins? 1. This problem repeats itself with a few other ones: `map`, `set`, `limits`, and `future`. Each of these has a precise meaning in a significant area that does not line up with how it is used in `std`. There may be more. 2. `complex` is something that I see in lots of code that gets a definition that is equivalent to the `std` version. It likely dates to before its inclusion/common use in C and C++. 3. In a few cases, old code bases could have their versions of things that were added later, e.g., `regex` 1. A decent percentage of the `random` librarycould have been previously used. 2. In the numeric library, I have implemented `gcd` and `lcm` a couple of times. 3. I could see a variety of people implementing their own of inner\_product, inclusive\_scan, exclusive\_scan. 4. Almost all of the special math library, e.g., `beta` is likely to have been implemented by a large number of people. Ditto the common math library. 5. &amp;#x200B; 4. A few that I can see coming into conflict in C++20: 1. `utc_clock`, `gps_clock` actually most of the `std::chrono` library. 2. &amp;#x200B; 2. C++17 `any` holds a CopyConstructible type. To me `any` means "if at least one element of a container is true, return true." 3. I see `reset` used in a lot of code. 4. A lot of the more recent additions to `std` copy from `boost`. Under this logic, `boost` is now a bad library. If the standard library is small and/or deals with obscure stuff, it is easy to say.
Though I’m not very experienced in the subject, I have understood that when compiling c++11, the compiler will also compile c++98 features. You can use both editions within the same file. But range based for loops are not the only things introduced in c++11. Are you claiming that these types are for loops are the single characteristic that “sinks the ship?” There are many other new things c++11, and even c++14 and c++17, brings that adjust the language to modern programming abilities. I don’t see how a growth in ability is a bad thing.
There is a YouTuber named TheChernoProject that makes some content that you may be interested in. I’ve watched a handful of his videos and they have all been really great and informative
i'm aware the c++11 compiler is backward compatible to build c++98. please re-read my post, dont wish to repeat.
using namespace applies to whatever scope it's declared in. So it can be useful in a function where you'd otherwise have to write out std:: (or whatever namespace) very often. Sometimes it's declared globally in a cpp file, which can be okay. But not in headers since that would apply to every file that directly or indirectly includes that header. 
The main problem with using vectors for beginners is that you have to include copy constructors in your objects and that can be a pretty beginner unfriendly topic.
Found the most extreme object oriented programmer on reddit.
Will check it out, thanks! 
I think they're talking about how a std::array remembers its own size and how functions requiring one don't need any extra parameters, compared to how functions taking a C array usually also need to take the size of the array as a parameter.
You're being downvoted (maybe people think you're being snarky?) but this is actually how I approach TMP. Well, I think in Haskell with added &lt;&gt;, but it's the same concept.
If you are using Linux and the program is writing to `std::cout`, there's a system buffer that will prevent the flush to actually happen. In some cases you **need** the flush and it will be disappointing to see that it doesn't happen. [If you really need the flush](https://stackoverflow.com/a/37463452/82782), you can call your program like this: stdbuf -o 0 ./yourprogram --yourparams
See [this](https://stackoverflow.com/a/37463452/82782). In Linux the flush will not happen and the output will always be buffered.
Keep it scoped at least, never in a header file for example.
You shouldn't be using text files for performance anyway, binary files are the way to go. There are so many things wrong with the text mode (especially handling locales) that using a lower level tends to work out better for multi-platform (no more different line endings issues) and is faster because you control the formatting.
You don't have to make a destructor because it will just work thanks to RAII.
&gt; Shared ownership by multiple threads is unlikely to be encountered by a new programmer. My comment was intended to be directed at smart pointers. I just use `shared_ptr` at work a lot more that `unique_ptr`. That said, the options are: 1. malloc/free 2. new/delete 3. shared\_ptr 4. unique\_ptr The first two (malloc and new) are looked down upon as baggage from earlier iterations of C++ and C. This leaves the second two. Of these, I think it would be better to teach shared\_ptr first as it does not have the restriction that unique\_ptr has: unique\_ptr can only be used if it has at most one owner at any point during the lifetime of its existence. Since shared\_ptr lacks this restriction, it should be taught first.
It's super gross, but I kind of like it.
There are very few ways where `new T[n]` is superior to `std::vector&lt;T&gt;(n)`. You're going to have to store the size anyway. You only "waste" a pointer because vector reserves and it can be useless for your needs. I think we're missing a static vector that can't be resized/can't reserve storage and that would save a bit of space so that you could find no reason to ever use allocations yourself. Want to store an image with planar RGB? Allocate one vector with 3 times the number of pixels, and make 3 spans, one for each third of the memory you just got. You want to have classes that don't own exclusively the data? Make an owner class and use `shared_ptr` of it in your "view" class. The only time it gets a bit tricky is when you abuse type erasure like with OpenCV, since a `cv::Mat` can be owning (with a reference count) or not. But again, fear not! Use a span for access and don't initialize your `shared_ptr` when it's non owning, it will safely not destroy anything for you. If you think `shared_ptr` are too slow, you can use something more dangerous without thread safety, but that's on you if you get bugs.
Try [this](www.gitlab.com/ahdavis/libcppcurses)
that is super good to know thanks
Christ, I didn't know about C++/CX and I regret that I do now. Glad to be prgramming on Linux, and the GNU toolchain even on Windows ports. 
Unless you do want it to flush ;) The issue with it is that people will write like 4 `cout &lt;&lt; blablah &lt;&lt; endl;` statements one right after another. You don't need to flush your toilet 4 times when you pee, once at the end is enough. *Toilet noises*
A big NO. Polka dots are boring. We should use emoji.
By the way, you've introduced bias into this survey by giving your opinion. 
Well another part of it is everyone types it up at the top with the globals. If I remember correctly, you can actually just use it inside of a function and it won't leave that functions scope. I think there's some value of using it like that provided the function is using many many many of the same class (like if you had around 10-20 std::string calls in there, I'd just toss that guy at the top of the function). I can say I'm 100% sure that you can use it like that, as I just type out the namespace every time. I know I remember using "using" a lot, but once I had one namespace collision I pretty much never *used* it again. 
https://godbolt.org/z/Z7Rwqu GCC and Clang both correctly ignore [[nodiscard]] in the case of cv-qualified void. I wasn't able to get MSVC to respect [[nodiscard]] even for int. I was probably doing something wrong.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9vgy2a/i_need_help_in_intelligent_systems_and_robotics/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Teaching shared_ptr first is even worse than new/delete: beginners start thinking it's some sort of garbage collection and before you know it, they are writing *books* containing nonsense like I just saw in Elements of Programming Interviews template &lt;typename T&gt; struct ListNode { T data; // We need to use a shared pointer since multiple nodes may point to a // single node. For example , in the following list , two nodes , 1 and 4, // point to node 2. // 0-&gt;1-&gt;2-&gt;3-&gt;4 // ^ | // |_____| shared_ptr&lt;T&gt; next; };
You could still use C++ because it's fast. You don't need to handle raw pointers for that.
This is so missing the point of &lt;chrono&gt; and &lt;ratio&gt;. :-[
No questions there, I love C++ and I do think it is probably one of the best languages to teach because the stuff you come to understand while learning plus helps you regardless of what language you are working in later. I just think that teaching the core language is probably better than teaching people how to use the standard library even if teaching the standard library might have a shorter learning curve (and that I think you could even debate). 
I see your point, but considering you should never have to handle raw pointers outside of some extreme cases, teaching them first is too risky. Don't teach people how to blow their whole leg off right away.
But, how you find that tutorial, on what page in google output it will be?
Its still faster even if youre not a master, moving code around is so much easier. Spacemacs makes setting up a decent environment for c++ a lot easier as well
I prefer m_ because intellisense. I remember there is a member but I don't remember the name, type m_, and ctrl-space. _lk is for scoped locks.
That's *the whole point* of std::endl. You say that like it's a bad thing.
For beginners, best practice is: 1) use using namespace std in non-header files. Namespace collision is an overwrought fear, but stds everywhere does decrease readability 2) endl is fine. Flushing every line is actually good practice for beginners, since output buffers get lost on a crash. 3) c-style arrays are the devil and should be avoided at all costs for new programmers. After you've taught them vectors, it's safe to show arrays since they'll need to be able to recognize them in other people's code who are still stuck in the 80s. C++ arrays can also be taught, but vectors are the vanilla ice cream data structure. 4) I think pointers shouldn't be taught until later in one's programming life. You can write perfectly fine c++ code today without ever touching a pointer. After iterators seems to be a good time. 
&gt;To that effect, I think I can imagine a "tween" to be something like `tween&lt;T, easing_function_t&gt;` where `T` just needs to support the arithmetic operators. This way, you can tween, say, a packed simd group of four floats just as easily as you could tween a float, given the right operators. I did something like this in my work project. template &lt;typename T&gt; T interpolate(T const &amp;a, T const &amp;b, float const t); That templated function is not even declared, but you can pretend it is. There are overloads of it for things like optional&lt;T&gt;: template &lt;typename T&gt; boost::optional&lt;T&gt; interpolate(boost::optional&lt;T&gt; const &amp;a, boost::optional&lt;T&gt; const &amp;b, float const t) { /* impl left out because I'm on my phone */ } That function does some checking on a and b and then "forwards" to interpolate&lt;T&gt;(). Then all you need to do is define an overload for all your user types.
Performance is a secondary concern to correctness with new programmers, and endl helps with correctness. 
Yeah, except it takes 20years to compile. After all the money got made by someone else.
&gt;beginners start thinking it's some sort of garbage collection Beginners don't think of it as garbage collection because they don't know what garbage collection is because they don't know what memory leakage is. Look, pointers are hard enough as it is, for beginners. So start with the easy mechanism: shared ptr. You can have multiple pointers to one object, change the object and the deref of all the pointers change. You can change where a pointer points to. You can implement linked lists as a first example of something you can do with pointers that does not work with references. And when they understand what a pointer is you can talk about memory leaks and how they don't happen with smart pointers. And then you can maybe introduce unique pointers.
 typedef std::array&lt;int,5&gt; ARRAY_1; typedef std::array&lt;ARRAY_1,3&gt; ARRAY_2; typedef std::array&lt;ARRAY_2,7&gt; ARRAY_3; Later: ARRAY_3 array; Also don't use magic numbers or `int`.
C++ Primer is great, I learned from pretty much only that, and I feel like I avoided so many pitfalls, and picked up a lot of best practices for the language from the get go, and I can't stress enough how helpful this has been for me! For teaching, it also has exercises to do for every subchapter, and it's laid out really well. It's "only" C++11 at the moment, but still, anything beyond that you can learn pretty quick in comparison.
Yes, it does. Don't fall for the production quality of these videos and go get a good book(Bjarne's book or C++ Primer). Once you feel like you are getting a good grasp on the basics, then you can turn to online resources. Few online resources that I found helpful were: 1. isocpp.org 2. en.cppreference.com 3. Go to stack overflow and filter by c++ tags, although people keep cribbing about how SO is hostile towards beginners, it is by far the most trustworthy online resources imo just because of this scrutiny. you cannot mislead someone and get away with it, try doing and you'll be downvoted to hell. There are some exceptional blogs out there if you wish to read online. I don't remember the names right of the top of my head but a quick Google search should give you something of help.
That’s just the bad form of Hungarian notation. That’s why you’re most likely getting downvoted. 
https://youtu.be/yy8jQgmhbAU
Thanks for mentioning these! They do not really say to not use smart pointers at all though. F.7 says "smart pointer transfers or shares ownership and should only be used when ownership semantics are intended" and lists cases when one or the other is prefered ([R.30](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r30-take-smart-pointers-as-parameters-only-to-explicitly-express-lifetime-semantics) is similar but even more strongly against the use of smart pointers as parameters (in general, not always)). I would also like to call attention to [F.42: Return a T* to indicate a position (only)](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#f42-return-a-t-to-indicate-a-position-only), [C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c149-use-unique_ptr-or-shared_ptr-to-avoid-forgetting-to-delete-objects-created-using-new), and [C.50: Use a factory function if you need “virtual behavior” during initialization](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c50-use-a-factory-function-if-you-need-virtual-behavior-during-initialization) and several other paragraphs pointing out the many cases when smart pointers are good. It is more like there are a few important cases when naked pointers make sense, but definitely not always (in an API or otherwise)? 
It's a bit of a case of "some assembly required" because you have to write some stuff in Go to define the rules/commands for your project, but Google's [Blueprint](https://github.com/google/blueprint) sounds like it more or less does what you're asking. It'll fail early if you try to use a library module that doesn't exist, for example, and then only generates a Ninja file and runs the build if your Blueprint files check out. It's fairly similar in concept to Bazel (the open source version of Blaze, which is what Google uses internally for the vast majority of their backend code), but Blueprint seems to work better with non-Google environments since it's used to implement Soong, which is Android's new build system. (Yes, Android is made by Google but it's very different from most Google code since it's released as an open source project and has to be able to be used by partners, etc.)
Just make sure you have them benchmark the operations compared to a proper hash map so they understand the limitations of the underlying data structure. So many people think the big-oh is all that matters... and they're in for a nasty surprise later in life..
[https://github.com/pybind/pybind11](https://github.com/pybind/pybind11) seems to take boost.python a bit further
Yes, someone made compile time Tetris. However, you have to write an additional script to keep compiling since the C++ part only gets you the next game state from the current game state + your move.
Yes. If you stick to snake case you are safe with prefix `_` and it looks much better then \`m\_\`.
Ah, then it's not what I want to achive. I know that compile time dependency (“Do I need to rebuild my test?”) is a solved problem. What I want to implement is a solver to the question “Do I need to run this test?”.
Of course it depends on how you define beginner,. Even in an introductory course I'd teach them at some point in time, but usually more to the end (much later than raw &amp; unique_ptr). There are imho just not that many good applications for them.
\&gt; My favorite example for lack of responsibility and ethos is Microsoft. The latest update for a fairly recent compiler (VC11) is August 24, 2015 -- and still does not have C++11 conformance I know the Linux kids really love kicking Microsoft, but let's be realistic here: their latest compiler is VS2017. The version you refer to is four major release out of date, and six years old by now. What happened in the open source world during that time? In 2012, gcc was on version 4.x. That series had its last release on august 16, 2016 - so no releases for the past two years. \&gt; Can you imagine the impact of code quality for all those customers that paid the licenses fees for that particular product? The cost of a pro license is essentially negligible, just noise when compared to the salary of the person using that compiler. And if you are not being paid, chances are you qualify for the free version anyway.
&gt; never in a header file That should be obvious.
Given this perspective, it seems to make sense to add something like plain_ptr to the standard just to make the language more regular for beginners... 
This is especially true when it comes to getter and setters, it prevents problems with name look ups as well, so the compiler don't get confused. If naming a getter exactly like the member is a different story and not part of this discussion.
Right. So when you need a string you go all malloc/strdup/free/&lt;loose some memory in case of error&gt;/strcpy? Must be nice to work in a place like that... :-(
And it already was bad in 1996
It's not a "new C++", it's an interop layer designed to go between regular C++ and other languages, and it's used pretty rarely even inside Microsoft. Microsoft has been emphasizing modern standard C++ for years now. 
&gt; I haven’t looked too much into it but I figured it was just because c++11 is unused in the career world lol &gt; or it is ineffective compared to c++98. lol
That right, I've just forgot that😅
I think you want to do &gt; cout &lt;&lt; i &lt;&lt; " "; In your loop. Try compiling with warning flags on (-Wall -Wextra for gcc if I remember correctly) to spot this kind of error.
&gt; And for "low intermediate" users I only teach shared pointers as the default. They can learn about unique and move later. Too complicated for beginners. Please don't do this. shared_ptr looks simple on the surface, but actually has the risk of adding a lot of complexities and bugs into your application: *) Added overhead. If you just use shares_ptr everywhere, you will probably end up passing shared_ptr by copy down a call chain 10-20-30 levels deep, incurring a copy and then a destruction of a shared_ptr on every level. This will be a significant performance drain. *) Incidental data structures. You will end up with many objects owning and sharing and modifying the same data. Soon you will find yourself asking yourself why every time you try to add a new feature or fixing a bug introduces 10 new bugs in other completely unrelated areas of the code. *) Memory leaks. Sooner or later someone will add a cycle of shared_ptrs. Boom, instant memory leak. Sure, shared_ptr has its uses, but in like 95 % of the cases it's the wrong tool for the job. Your students would be much better off if they only learned unique_ptr instead.
i have a bit of experience in C# from game development and i have done some basic stuff in c++ like RPM/WRP messing around in single player games with offsets and the such. what would you recomend for learning more ? should i stay with this website ? i like it because its very well set out imo. 
`boost` != `simplify`
I do believe that [A Tour of C++ (2nd Edition) (C++ In-Depth Series)](https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&amp;field-keywords=C%2B%2B+in+depth&amp;rh=i%3Aaps%2Ck%3AC%2B%2B+in+depth) is the newest (2018 release date) and one of the best books according to sales. My friend recommended it to me. I'm also gonna buy it probably next week. As for free books [https://goalkicker.com/](https://goalkicker.com/) has a decent number of PDFs including C++. Hope you find it useful.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9vis89/need_help/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9vimow/the_madness_output_ive_got_with_my_code/e9cinqp/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Thanks for the reply, I'll look at that. 
You are right: C++ is expressive enough to write understandable (at least for professional C++ devs) but high performant code. The area of message-passing is not exception here. But speaking about tools like SObjectizer, CAF, QP/C++ or Just::Thread Pro it is necessary to speak about two different niches: The first one is specific tasks with extremely high demands for performance and/or predictability. For example: handling of millions of messages per seconds on one core (HFT or DPI areas). I think there is no place for universal frameworks like SObjectizer of CAF here. May be some kind of "universal framework" can be created for that niche, but I'm afraid such framework should be highly customizable and, as consequence, will be very complex. The second one is tasks where concurrency has to be used without strong demands for performance or predictability of message-passing mechanism. But there is a different demand: code has to be written as quick as possible and it has to be correct. And there is another important factor -- sometimes concurrent code has to be written by a developer without rich experience in multithreading. The success of Go language shows that it is very important to give an ordinary developer a rather simple tool with understandable concurrency model and good enough (but not extreme) performance. We believe that our tool is targeted for the second niche. We provide a set of simple (I hope) tools that allows to quickly write correct multithreaded code. A simple example can be seen in our demo-project: [Shrimp](https://stiffstream.com/en/docs/shrimp-demo.html).
pybind11 is less complex than boost.python in some aspects. Boost.Python requires a shared library be built for each version of Python you wish to target. pybind11 is header only and supports all Python versions with no hassle. And using C++11, generating the bindings is also easier than the equivalent Boost.Python, because it can use tricks which aren't available pre-C++11.
Please don't delete questions once they are answered. It denies other people the chance of learning from your experience. Reddit is not your personal 1:1 helpline. 
We used C++ primer 5th edition I think, that includes C++11 which is the most important part. 
Thank you for sharing
Looking forward to the next one : )
I think it's because arrays, raw pointers, etc are the base, and all that vectors work on top of them. If you know arrays (and pointers in general), you can write your own vector, queue, priority queue... Also shared_ptr's. But if you start studying with vectors and other clever automated stuff, it's just a dark box - or even some dark magic - for you. I think some people would say that knowing &amp; understanding fundamentals is important to be able to get why there's, for example, an n*log(n) speed limit to sort vector, and many other things. But of course some other people says that programmers actually should think about it as of some abstraction and algorithms using them without bothering with technical details. 
&gt; Also, it helps the code readability I keep reading this, I very much don't understand. You consider this to be more readable: std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; computeStrings(); compared to: vector&lt;pair&lt;string, string&gt;&gt; computeStrings(); It takes me significantly longer to understand the actual return value of the first version. It also takes me longer to write it.
If you are not a beginner, the site is fine, just keep in mind the new staff is the right way. If you are coming from C#, definitely check Qt, play around with it, read the docs, read some code samples. Qt uses reference counting for most utility classes (images, string, containers) and it will feel like C# a lot, making a smoother transition to C++. I was in the same situation like you back in the day - "learned" C++, but got lost, learned C# and had a footing in creating applications, then learned Qt allowing me to use C++ "the easy way" plus it has all the tools to create real applications, after that I had easier time moving to standard C++, especially that by that time the modern C++ came, which is much more friendly, at places even compared then Qt. Lastly, note that in recent years Qt is pushing a declarative, higher level language - QML - to describe interfaces. If you don't want to use Qt that way, then use the QWidgets subset and focus on the utility classes - they are still C++. There is also Qt 3D module that can be used from C++ as well, you might find it interesting, but I have no experience with it. 
I don't think it really is obvious. Have you ever taught someone C++ and _not_ had to tell them to avoid putting using namespace std in a header?
&gt; almost no one uses modern c++ This is most definitely not true. 
So you propose to add dozens (hundreds?) of std:: in each cpp file (spend time now to write it, to read it) - just to be sure other developers life in ten years will be easy? Add more work here and now - for solving theoretical problem of other people in ten years which will not happen with 99% chance? Really. &amp;#x200B; Of course, there are places where "using namespce std" is strictly forbidden: header files, libraries. Something, that will be really used by other people for a long time. But I don't see real reasons to avoid it in cpp files of my internal project.
About auto: theres huge difference between no typenames and sometimes typenames and sometimes auto. For beginners, the simpler the better and for typed languages it's simpler to always see types.
Can C++ tutorials in dance performance format become a thing please? :-) 
You say: &gt; The reality is that 99% of the c++ code in the wild is still that outdated stuff And while I do think 99% is too high (unless if you count discontinued software), there is a lot of old legacy out there so I agree. Then you say: &gt; and almost no one uses modern c++ which is simply not true.
Is C++ Programming language by Bjarne Stroustrup book any good for "learning C++ like it is 2018"? :/
Local variables. Pointers of any kind are very rarely needed in modern C++, especially in novice level examples.
8 build times: don't forget debug/release. 16 times if you build both 32&amp;64 bit
I just prefix with `_` for privates.
Sorting algorithms folk dancing perhaps https://youtu.be/lyZQPjUT5B4
How could you not have mentioned before/after tables!?
 Most of the things you asked about in your follow up are build time issues. Adding a new overload certainly is. A global variable without an initializer? If a constrictor is getting called its in your profiling. If you're changing whether you depend on it at all, that's a build, or really a link, time issue. 
I guess the problem is not so much in the order, then in the fact what is the correct default. All beginner courses tend to present library constructs as an add-on, not the default (if they present them at all!). 
&gt; I think we're missing a static vector that can't be resized/can't reserve storage and that would save a bit of space so that you could find no reason to ever use allocations yourself. `unique_ptr`?
&gt;thank you for the answer ! i tried qt but decided to use CLR instead, i will give it another go. While you are here i would love to ask a couple of other questions if you have the time. Note that CLR is a closed box and proprietary extension. In Qt you can ctrl-click QImage and see how the ref counting works!. &gt;1. Usually when i'm making somthing in c++ its because i had a simple idea, i make it in the console and research the c++ needed for that specific thing. this has kind of lead me to be knowledgeable in some areas but in other very basic areas that have never come up, i have no clue. is this a good way to learn ? just making applications and researching as i go, or should i be taking lessons/reading a full guide. I personally think the best way to learn is from experience, solving problems by yourself, so you are doing it right. That said watch lectures - CppCon have many lectures, suitable for programmers that want to improve - and keep an eye on cppreference - it is complete reference for the entire language, you can find some new tool to use, expanding your knowledge on the language as well. Don't be intimidated by the details there - these are for the geeks, focus on the short description on top and, most importantly the examples. &gt;2. You talk about QT applications, often times i want to learn c++ and make applications but i dont really have any motivation to make something useless, i often try and make somthing that would be useful to me or something cool, im also looking to make programming my carrier, my question is, what kind of programs would a freelancer be able to sell that i could start practice making (sorry if this is ignorant). if this kind of thing is too advanced, what do you have any ideas for programs that are challenging but useful in every day life ? I believe you should focus just on changeling yourself. This will both help your carrier as you will learn more and keep you engaged as you solve problems. Even a stupid little application like a calculator can be a real challenge if you make it from start to finish, as real product. So make the stuff you want to make, but push them to finish, not just prototyping. &gt;3. Im going into computer Science at uni in around 3 months so i want to get ahead of the curve, should i takes extra lessons or is online revision enough ? I think you are already ahead of the curve, for real. &amp;#x200B;
because they *are* add-ons **technically**. If your approach as a teacher is to teach the language itself, than it's fine to give addons as defaults - because they are defaults **in practice**. But I think that many C++ beginner courses are aiming at total beginners, and that's why they might use a "you have to understand whatever you do before you do it" attitude, like, teaching general programming rather than exactly C++. And from that point of view they have reasons to present array as the default. Though it doesn't really help with C++. But yeah, I'd like to have a proper guide how to use all that default-add-ons of C++. btw, actually, I think that C++ is not the best choice to start studying programming partly because of that - it's abstract, but somewhere it's still C-ish, and there's OOP ideas - and this mixture is kinda weird, IMHO. For example, python or C# allows to operate quite abstract things without bothering about implementation details (though some people say it's bad), C is a very, very good way to understand basics and why things are like they are (though C knowledge is not a must today...), while C++ is neither abstract enough to be easy, nor "dumb" like C, where is no need for some complicated ideas like OOP 
For a beginner, learning C++ in 2018 shouldn't be any different from learning C++ 10 years ago but except may be with few added tools like STL. Pick some good beginner friendly books like the one by Bjarne or C++ Primer. But for some one who knows the basics, why do you have to learn it again, just Google. There are wonderful blogs, there is en.cppreference, isocpp, stack overflow etc. I see lot of people cribbing about how Stack Overflow is hostile towards beginners but it is for the same reason that it is still used by many as a go to place for looking up their questions. With the kind of regulation they have in place, no one can give a misleading answer and get away with it. Go to stack overflow and filter search results by c++ tags or ask questions. And then there is r/cpp. If you are looking to learn C++ in its entirety then you probably are just not being realistic, One thing that one must understand is that a programming language is a tool and must be used like one. I myself am not a books kind of guy. I read from varied sources and I strongly believe that if you want to learn something, you should use it in a project or something. 
Can I ask what profiling/coverage you use? I was using gcov, but the compiler options needed to make the output paths relative are annoying and necessary (otherwise you won't be able to run multiple tests in parallel and then extract which one touched which file). Unless you're doing a shim on libgcov.
The compiler will do it for you if you compose them out of objects that fulfil the rule of five. The problems only start when you want to manually manage some resources which, I would argue, newbie shouldn't ever do.
I haven't tried those yet - and I'd probably be biased due to already "knowing" basic modern C++ - but Kate Gregory is usually great is she has a lot of courses on Pluralsight. https://www.pluralsight.com/authors/kate-gregory In particular, the top one: C++ Fundamentals Including C++ 17 and also: Beautiful C++: STL Algorithms If anyone has done either of those, please let me know!
no, white. Photons bounce on it and make the bikeshed faster.
My recommendation is the C++ Super FAQ. [https://isocpp.org/faq](https://isocpp.org/faq)
If you want to port a Swing project you could give a got at Qt. On windows it will either use Visual Studio's compiler or can use mingw. The IDE that comes with it, QtCreator, will have inline clang-tidy hints and fix-its to improve your code and those are very good : https://www.kdab.com/clang-tidy-part-1-modernize-source-code-using-c11c14/ 
I write the project documentation URL as a variable prefix, e.g. `int https_my_website_project_slash_docs_slash_readme_dot_md_accumulator;`
Oh, I forgot about QtCreator! Nice idea, I actually use it on Linux. It may be a good way to go, kudos!
If the requirement for teaching something to beginners is that they know the specfics of a deeper more complex topic that they have never heard of then the topic isn't suitable for beginners. If you are at the point of teaching basic array manipulation it seems likely that you haven't gotten down to the nitty gritty of C++ and it's various constructor / copy / move / assignment mechanics.
If you are used to Visual Studio then get Visual Studio 2017 Community Edition which has fully implemented (AFAIK) C++14. It's free for most indie commercial use too (not contracting work for large companies, or if you/your company has &gt;5 employees or is getting more than $1M p.a. revenue).
No, it's going to be strictly for personal study. VS2017 will definitely be the best choice to quickly get on track. Are you aware of desktop UI libraries that may be already implemented on it? Otherwise I'll just set up a REST API with mongoose and put up an Electron frontend, but it would be so much added work (and fun, to be accurate).
That's the point - they don't need to know. Types that fulfil the rule of five just work and compose nicely. One only need to know about the "various constructor / copy / move / assignment mechanics" once they start doing fancier stuff.
Good talk Vinnie!
Agree C++ is in a very odd spot, ironically because its greatest strength - the ability to cover low and high level equally well. And that is why I believe it is best to start "in the middle" where low-level is hidden (like in the other languages), higher level (Concepts, Abstract classes) is not needed because the problems are simple. And "coincidentally" this is how C++ is written on daily bases, in large part. One absolutely must learn the lower and higher levels, though, no question about it.
You can find some presentations by Kate on youtube. I really like the way she talks and the material included in her presentations so I suppose the pluralight trainings are worth it.
2011 is quite old too by now ;-p and sure the job openings mention modern c++ but I'd bet most of the code those people will work on is outdated c++
I think learncpp.com is really good, have been at it for some time now, as I come from c# I kind of do it randomly when I need something, but is really well explained, for sure worth checking out!
Because that's undefined behavior (identifiers starting with `_` are reserved for the implementation).
&gt;Or maybe, you are not using the language because you are not fluent in it? :) Of course, but since I don't see the benefit, I don't try to become fluent right now. &gt;You could hunt down efficiency improvements like Ahab, but you can do premature optimization with other languages as well. This has nothing to do with C++. Yes and no. I use mainly python, I know some javascript. The speed c++ offers over python comes down to compile time optimization and handling numbers in smart ways when there are lots of them. Sometimes using certain hardware features directly, which you just can't do in python, I think. If I'm running a simple desktop application, nobody is going to notice a 10x increase in speed if the difference ends up being the effect of a button press taking effect milliseconds earlier. I don't need to render anything or do expensive numerical calculations. At the moment at least. Always thinking about what specific type anything is going to be just seems like such a hassle to me. I'm just trying to find my path of least resistance through the programming world and for now c++ is just not that, for me.
That talk heavily motivated me to ask for resources. Because I pretty agree with Mrs Gregory. Thanks for the input anyways!
That's just sending it to stderr instead of stdout, which along with stdin are just the standard streams, you can flush std::out and std::err as much as you'd like. It's when you are flushing to a file on a hard drive (especially if it's on an SSD) that is generally the bad idea, as it causes more many more write operations than necessary. However, it can still be dependent on the situation for flushing to a file. For one of my projects I needed to flush out to the file I was writing/updating more frequently than once per loop iteration, however I also made sure to put in some extra logic to make sure I actually had changes/differences to write instead of completely rewriting the file multiple times each loop iteration. There was probably a different solution I could have designed but I didn't want to waste too much time on getting it done. My point is that flushing isn't evil and that it shouldn't be avoided at all costs, I think that it's more important to understand what's actually happening with the hardware buffers so that when you do use it, or need to use it, you are not getting any unexpected consequences.
You can do native win32 or UWP or go crossplatform-ready with a native look with wxWidgets or similar. Or something like imGUI or JUCE for identical looks across platforms. Pretty much everything that runs on Windows should have VS support.
One thing I've found to be useful is watching the cppcon video presentations online. Probably won't be 100% coverage if you want completeness, but it's decent exposure to a lot of the newer features.
Same here. Company coding standards link to the full rules, but to keep it simple the standard is just "no leading underscores anywhere".
There's a special place in hell for people who use namespaces in header files, that's an entirely different matter.
This can be rewritten: b.txt: a.txt b.txt: echo 1 &gt;&gt; a.txt echo 2 &gt;&gt; b.txt which will work correctly because it linearises the dependency graph while still describing the multiple outputs. The trick is to have one rule which outputs all the files, and then for each additional file, create a rule depending upon this one. They all delegate to this target. This is how CMake emits rules for commands generating multiple outputs, and it seems to work well in practice.
If you are already familiar with C++98, take a look at [C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines).
Google: C++ reading lost stackoverlfow
SDL is a C library and it is written in a very nice C. Not sure if it is a good idea to start wrapping it in C++ classes like Lazyfoo did in his tutorials. My advice is to try to directly use the library as it is, understand how it works and only than start adding C++ abstraction that will make your work easier. If you want a C++ equivalent library try SFML. 
I mean, it depends on the job. I've changed several companies over the course of the \~4 years of my career and never ever had to work solely with outdated code. It's always been either a mix of С++98 + boost with C++1\* actively replacing the latter wherever possible or just plain C++1\*. Of course there are virtually petrified third party libraries with no alternatives around, and there are also companies where all you have to do all day is dig through some mess of a legacy code, but it's pretty easy and probably better to just avoid such jobs imo.
This book definitely assumes you already know C++
Mostly flusing is required for debugging and like checking the buffer, so like I said instead of using std::endl to do that there is something like std::cerr mafe of the exact purpose, why not use it 🤷♂️
&gt;... What would you suggest to get up to speed with the newer features? Check out [CppCon](https://www.youtube.com/user/CppCon), search for new features/overview C++11/C++14 Also [https://github.com/tvaneerd/cpp17\_in\_TTs](https://github.com/tvaneerd/cpp17_in_TTs) (sadly no tables for previous versions) &gt;Other suggestions about things I'm forgetting? Books online, blog posts, pitfalls to look out for? [cppreference.com](https://cppreference.com) is a must as there are friendly examples and thorough explanations. &amp;#x200B;
Or just use good old VS2017 Express edition and that is completely free even for commercial projects. Just you have to go without plugins. VS2017 has many features from c++17 implemented and the IDE can beat QtCreator anytime which was always too buggy to be useful for me.
According to (Announcing: MSVC Conforms to the C++ Standard)[https://blogs.msdn.microsoft.com/vcblog/2018/05/07/announcing-msvc-conforms-to-the-c-standard/] VS implements C++ 17. The upcoming version 15.9 will compile (Eric Nieblers rangge-v3)[https://blogs.msdn.microsoft.com/vcblog/2018/11/07/use-the-official-range-v3-with-msvc-2017-version-15-9/].
Visual Studio 2017 is also fully conformant with C++17. When it was announced [6 months ago](https://blogs.msdn.microsoft.com/vcblog/2018/05/07/announcing-msvc-conforms-to-the-c-standard/) that they'd achieved full conformance they had some big flaws: boost hana didn't work, range_v3 didn't work... which are now fixed! It even supports two phase templates now!
The range library is a tremendous achievement, just as an example, it can give you a "sorted view" into a sequence without actually allocating anything.
&gt; "as one will write it today" This is what I mean by the bias of this sub. The assumption that "of course" everyone will use the very latest way (that happens to be fashionable here) to do things in any new codebase. I claim that the industry is much more conservative as most people there just want to Get Things Done and are not particularly interested in the newest language developments.
&gt; Nice idea, whether the increased complexity is worth it, is probably subjective. which increased complexity ? pybind11 is vastly easier to use than boost.python 
Came here to also recommend that site, it seems to be quite up to date!
&gt;VS2017 Express I'm not too savvy about VS version, what am I losing in the Community edition with respect to an Express version?
Yeah but if I have a bunch of cout lines in the code already, changing them to std::cerr can be a pain when you can get the same effect by toggling the unitbuf flag -&gt; `std::cout &lt;&lt; std::unitbuf; //toggles unitbuf flag` i can put this before buffer/output problem code and remove it after I solved the problem. I normally only use std::err to print errors and their associate debug lines. *shrugs*
That's true for IDE, but not for other places where you read code, like pull requests.
Maybe you would have answers to any of these questions. Why Networking TS still * doesn't have better integration with std::future - there shouldn't be any extra arguments to the functions (like boost::asio::use_future) if you are going to use std stuff. I understand std::future is WIP but this stuff is difficult to change when it gets out to the public... * doesn't allow to specify timeouts without manually launching async timers. This is a common complain but I have never seen any reaction * boost::asio integrates with OpenSSL but what is the story with NetworkingTS? I hope it does too as without SSL support it would be a bit useless. * when looking at the buffers slide why can't it use std::span instead? 
I write all variable names in `UpperCamelCase` fight me
The link does not work.
&gt; which are **now** fixed In beta.
To be honest, the tricky examples are smelly anyway and every sane engineer should avoid them for the sake of clarity. 
In community u can install plugins such as VisualAssist which is a plus. But there are some limitations about the size of your team or revenue in order to use it so you should check if you comply. This way MS pushes you to transfer to Proffesional edition which costs money. Express edition usually pops up a bit later for the same reason but it has been here for much longer than community and it has always been free even for commercial development. The cost of proffesional might not be much but it's up to everyone to decide whether he wants to pay or doesn't need the extra (mfc, resource editor, plugins)
Having never used pybind, I would not assume that it is related to boost.python. That said, looking at the project page for pybind, it states it was developed to replace boost.python as boost.python uses lots of template trickery that is no longer needed. control-c'ing for either "boost.python" or "boost python" turns up nothing in the target page, not even a statement that pybind is simpler than boost.python. So I have no reason to assume the person has heard of it or read about it. That said, I have only ever interfaced C++ and python once (that was using SWIG) and it was started a year before I got onto that project.
I have noticed that searching for tutorial C++ programs on github basically sent me to tensorflow and opencv. Like WTF? 
But `m_` is not reserved anywhere.
I too have a similar background (not a beginner, but haven't used it for years). One fine day in the past month, I decided to give a re-entry to C++ and got a taste of what C++ looks like in 2018. Two of the resources have been very helpful for me. (sadly, both of them aren't free) 1. A book: [A Tour of C++ Second Edition](https://www.safaribooksonline.com/library/view/a-tour-of/9780134998053/) by Bjarne Stroustrup - A very good book which describes what to expect out of C++11, C++14, C++17, C++20. This could be read in hours, but I took my time to try out writing code and I ended up spending around 10 days (few hours in the night) to complete it. 2. A video course: [C++ Essential Training](https://www.linkedin.com/learning/c-plus-plus-essential-training) \- A course from 2014, but I took up this on purpose as I wanted to set the tone, before picking up the book mentioned above. Apart from it, I find all the videos from [CppCon 2018](https://www.youtube.com/user/CppCon/videos) very relevant. My personal favorite is [CppCon 2018: Jonathan Boccara “105 STL Algorithms in Less Than an Hour](https://www.youtube.com/watch?v=2olsGf6JIkU) &amp;#x200B;
wow thanks, didn't knew about \`std::unitbuf\` :)
!remindme 2 years
Sorry, bad choice of words. I meant it should be obvious that - regardless of whether using namespace is allowed in source files or not, you must teach people to not put using namespace into header files (at least not into glob as l scope). That's part of basic header hygiene.
It was someone's brainfart that persisted forever after. Suppose there was no `std::endl`: how would you handle it? Think for a sec. And that's what you should be doing. Forget about `std::endl` unless you actually need **all** of the functionality it offers. 
It's no different than `printf`, since there's common underlying functionality that converts those to their platform equivalents :)
`std::from_chars` on float?
Oh nice! I hope you find it useful ;D
I recently saw some people recommending the 4th Edition of Professional C++, by Mike Owen.
I only have class member inside... Well, classes. Also, `m_Member` is also reserved. Be careful.
But I only use a prefix for class members, and `_` is allowed. Also, `m_Member` is reserved too, and I seen it too often.
This whole “writing modern c++” is becoming a circle jerk. No one knows how to do it, complains about how no one knows how to do it, when people start doing it then c++20 comes out, rinse and repeat 
Most of the time when I use std::cout its for casual first-pass debugging reasons though, I've been bitten by not flushing buffers before leading to hard to debug crashes There's actually not many cases when I *wouldnt* want the stream to be flushed in my usage
Have you checked the disassembly? There might be bad code-gen.
I also don't understand why people dislike `this-&gt;`. If it's because they have to type more, just write a macro on your IDE. It helps my sore tired eyes.
&gt; Also, m_Member is also reserved. Be careful. No it's not. Identifiers with *double underscores* are reserved everywhere, but the underscore capital rule is only at the start.
because `cell-&gt;r - 1` overflows and you never actually run the loop
If you intend to use msvc don't even think about learning any new features cause they won't fucking work. Source: spending to much time fitting my code to the compiler rather than the opposite 
Sorry to disappoint you but I am not a kid and certainly not a Microsoft hater, I have enjoyed programming for more than 2 decades in Windows, mostly native development, I have read some excellent documentation and witnessed serious backwards compatibility. It was just had a very bad experience with Microsoft that cost me hard earned money but that's not crucial I got it back again not a big deal, the worst thing that happened was the crippled architecture of the software I was working on due to pool tooling as a consequence of bad PR. Certainly VS2017 is the latest, I use it here and there for examples and it's really good, and it's free to use for certain scenarios. But, am I interested to code logged-in? unfortunately no. Am I willing to update the compiler randomly with ``fixes''? definitely not, plus that those frequent updates are very time-consuming. I prefer the old-school way, with the ability to revert the compiler at a certain update I feel confident with. I still use that VC11 for production code, I am very comfortable with its flaws by now. An outdated compiler doesn't mean it's obsolete, e.g. VC6 produced solid code and many great products were created with it for about a decade. VC11 is much newer for example but is bad on that aspect as it generates SSE2 instructions for various math functions even if SSE2 is disabled, so I am forced to leave it always on, it looks like that this setup will have a very long life as is, it doesn't bother me that much as long as it works. In the open source world things are not all that different, OpenBSD stayed with gcc 4.2.1 for a very long time -- similarly FreeBSD and Apple, then gradually moved to clang, all that time they were still producing high quality software. 
have you decided on a language yet?
The example server compiles very quickly, you should give it a try!
How about you ask questions about the issues you are having?
Do your homework dude. At least try and come up with specific questions.
Okay putting my full code here hopefully that helps. #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; int numbers; int array[100]; void generator() { srand((unsigned)time(0)); for(int i = 0; i &lt; 100; i++) { numbers = (rand() % 900000) + 100000; array[i] = numbers; cout &lt;&lt; numbers &lt;&lt; endl; } } void sort() { int i = 100, a, b, c; for (a = 0; a &lt; i - 1; a++) { for(b = 1; b &lt; i; b++) { if (array[b] &lt; array[b - 1]) { c = array[b]; array[b]= array[b - 1]; array[b - 1]=c; } } } for (a = 0; a &lt; i; a++) { cout &lt;&lt; a &lt;&lt; ": " &lt;&lt; array[a] &lt;&lt; "\n"; } } } int menu() { int choice; cout&lt;&lt;"\n_______________MENU_______________"; cout&lt;&lt;"\n 1. Generate random numbers"; cout&lt;&lt;"\n 3. Sorted array"; do { cout&lt;&lt;"\n Choice: "; cin&gt;&gt;choice; } while(choice&lt;1||choice&gt;3); return(choice); } int main() { int i; do { i=menu(); switch(i) { case 1: generator();break; case 3: sort();break; } } 3 while(i!=4); return 0; }
Thanks!
Legit one of the best non technical comments I've read on Reddit.
I hope this is one area where modules help. `using namespace std` is bad at global scope in headers. But with modules, where a kind of "binary header" is automatically generated, we don't have to write headers with fully-qualified names anymore :)
Ah, I meant the complexity of boost.hana on top of pybind11. Haven't used pybind11 myself, but I'm indeed tempted to switch from boost.python to pybind11.
Thanks for the resources everyone! I’m in Bisqwit’s discord and was asking about learning Modern C++ and several cpp veterans were telling me that they barely qualify as proficient in the language after so many years. I still want to give this a shot and see what I can make of it. I know the basics of the language but there is much much more to learn...
O, well
Smaller structures mean better locality but also unaligned access (unless anyway it’s padded — did you check the layout??) In many cases padding is better anyway, but the optimizer might not know the access pattern. 
Fair enough. I am so used to logging frameworks that I pretty much not use console output directly ever :/
The downside of trailing suffixes is that you can't "short circuit" whether it's local or not until you read to the end of the variable definition.
Last part bears repeating. Unsigned arithmetic is more prone to bugs (as OP just discovered), and signed math is, in general, FASTER, since the compiler can assume that over/underflows never happen.
Oh, your absolutely right. Its longer to write and like you say, your mind has to do a teeny bit of mental gymnastics over each of the "std::". In an ideal world I would write your 2nd version. But I still write the 1st version. A mixture of habit and best practice I guess. 
Yeah, I was asking on how to learn Arduino (which is a form of C++), I decided on Effective Modern C++ and Learn C The Hard Way :)
isnt that book for people that already have programming experience?
holy hell that's delightful. thank you for this.
Write reveal cell in assembly. It will make the data type choice clear. Can you parallelize the data? Why a struct for a cell instead 4 independent arrays?
I've been messing around with vulkan recently, and part of initialization involves querying the list of extensions that your graphics card supports and making sure it has everything you need. I ended up doing a set intersection between the supported list and the list of extensions I need to determine if the graphics card was suitable.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
looking forward to the day (soon now..) that we have a meta build system for cmake. Can't stop it. Any day now.
thanks!
at least on x86 memory access is always aligned
I would put your code in a namespace, e.g. `pr0crustes`
That's actually a good idea. Maybe something like pr0 or BN is enought?
&gt;i did not find a lib that was could handle so long numbers in a simple but fast way How does it compare to the two most common such libraries, [boost.multiprecision](https://www.boost.org/doc/libs/1_68_0/libs/multiprecision/doc/html/index.html) and the [C++ API of GMP](https://gmplib.org/manual/C_002b_002b-Class-Interface.html#C_002b_002b-Class-Interface)?
I haven't tought about it. I tried to squeeze as much optimization using a cache for multiplication, create and deleted every multiplication, and also multiply by 10 in division / module. Thanks!
Yeah, that's true and probably what I will do. But, if it collides, the user can edit the file to put a namespace surround the class.
I know that it isn't popular but most programmers haven't worked with large projects and the speed reading code is increased a lot.
Did you run your code under address sanitizer or valgrind ? Sometimes access violations can give strange looking results.
Maybe I spamming now, but if someone wondering itself how to handle Pimpler::Self methods in selfish way. struct Pimpler::Self { int datum {}; int dada {}; ... static auto method(Self*, int datum) -&gt; void; }; auto Pimpler::Self::method(Self* self, int datum) -&gt; void { auto dada = outOfBlue(); if(dada &gt; datum) { self-&gt;datum = datum; self-&gt;dada = dada; } } auto Pimpler::method(int datum) -&gt; void { auto dada = outOfBlue(); if(dada &gt; datum) { self-&gt;datum = datum; self-&gt;dada = dada; } else { Self::method(self, dada); } }
I liked this book a lot too. If you know a couple or three languages, and get the gist of object oriented/generic programming I think it's a good "in a nutshell" type book. The only way I personally ever learned languages was to try to get the basics down and then just dive in and come up with a project of my own (sometimes something I did in the past) and rewrite it in the new language. 
I don't like Hungarian at all, because nowadays it's verbose and plain ugly. Nevertheless I like to distinguish between local and instance variables, so I use m_. this-&gt; I find very verbose and hard to read.
I suggest calling vector.reserve in the constructor to avoid unnecessary re-allocations. Why keep chars as ints though? You could fit more data in cache. Modern processors read about 64 kbytes at once, it's 65536 chars and just 16384 ints. Maybe you could squeeze some more performance with bit shifting, I don't know.
Well you wouldn't really have any reason to need to know about Boost.Python if you know pybind11. It's better in every single respect. Unless you're perhaps a company that's "stuck" on using stuff from Boost and can't use anything else "external".
Oh, I totally forgot about reserve, I will use it. I have tried another lib and, using valgrind, saw that the conversion of chars to int was somewhat expensive, since it adds 3 operations to every digit operation, since that specific lib was converting the char to int, adding another char, converted as int, and then converting the result back. My original ideia was to trade memory for speed, and it actually works a little better. Maybe, thinking now, instead of storing the digits as char '0' - '9', store then as the char 0 - 9, but then 0 is null, 4 is EOT, and that would probably end up in going wrong.
`std::vector&lt;some_complex_type&gt;::const_iterator` disagrees.
So, a bunch of 14 and 17 was filing rough edges off 11. Teaching 11 seems like such a disservice.
Hana?
Half the point of chrono is that the caller no longer needs to be consistently. No more remembering if this argument is seconds or milliseconds; just pass`1s` here and `50ms` there. And let chrono convert it for you. 
Did you try MicroProfiler? It's realtime, easy to integrate and is available as VisualStudio extension: https://marketplace.visualstudio.com/items?itemName=ArtemGevorkyan.MicroProfilerx64x86 Source: https://github.com/tyoma/micro-profiler
The subject of this post is about Boost.**Hana**
&gt; 64 kbytes Uhhh... über monster cache lines a thing now?
should i be focusing on C++ or keep making games in C# as well ? thank you ! 
This is appalling. There is NO good reason to restrict students from using C++11. It's very hard for me not to suspect this constraint is in place only to serve the teachers, teachers' assistants, and the graders. I almost want to ask who your university, course numbers, and teachers are so that they can face public pressure to correct this. One of the express goals of the C++ committee is to make C++ easier to teach and at the same time efficient and correct. Modern C++ achieves those goals without being inferior performance-wise and maintainability-wise; in fact, it's the reverse. The only consideration I can think of would be if you're likely to be employed in an environment that is constrained to older compilers or specialized platforms that lack compilers with modern features. But as the point of training as a student is to prepare for the \_future\_, that consideration should be less likely.
Shoot I didn't even notice that, and yeah I never bothered to actually test if the results of `revealCell` looked right... I was hoping to learn something cool about C++, but I just learned that I need to pay more attention to the code I write (arguably the more important lesson). Cheers!
Perhaps the syntax and details of pointers in C++ can be deferred, but the \_concepts\_ underlying pointers (indirection, how objects map to memory, etc.) are vital to using C++ well. Naive use of smart pointers without a good understanding of what they are abstracting can lead to a lot of hairy code. These concepts are even helpful if using a language like Java or C# to understand what's actually happening with the on-the-face of it value semantics that are actually reference semantics.
The problem isn't that overflow, because the value is promptly converted to signed int and thus to the expected value -1. The problem is the comparison between signed and unsigned, which converts -1 to unsigned. The result is what you're saying, the very first loop condition evaluates to false.
I think your array ends up being so small that you can fit a lot your working set into each cache line regardless. Maybe if you scale up your board by a factor between 2 and 3 you could start seeing bigger differences in performance by reducing the size of the struct.
&gt; I was trying to use a BigInt that I found on github, and it was usable to multiply 10 million digits, that's why I created this one. That makes no sense at all. Why not use the existing one? You should run comparative benchmarks as /u/CubbiMew suggested. Stating that your library is able to “multiply one 10 million digit number by another 10 million digit number in less than a second” is meaningless without context.
an int per digit? 
Give him a break, he's only off by 3 orders of magnitude...
http://www.aristeia.com/TalkNotes/ACCU2011_CPUCaches.pdf
I ~~obviously~~ meant “what th is Hana”?
Presumably that was a typo for 'unable'.
But it doesn't store the size. It's just a pointer on one element. So no iterators and the nice facilities. It's really easy to make your own class that does this, but writing iterators is definitely one circle of hell Dante forgot.
Typing 'boost hana' into your search engine of choice would surely have been more constructive and less effort than commenting here...
Reading the post above &gt; Hana is a header-only library for C++ metaprogramming suited for computations on both types and values.
is vector[0] guaranteed to be "thread safe"? I don't see anything on vector::operator[] that says it's safe to call concurrently.
Why not store the number as a vector of u_int32 and then when doing arithmetic operations such as multiply or add promote them to u_int64 to prevent overflow. This way you can use the hardware to multiply/add ~8.5 digits at once and the resulting implementation should be both faster and more memory efficient.
Not to mention that namespace changes break ABI thanks to name mangling.
Isn't `/imsvc` the equivalent of`-isystem`?
Kind of late, but to me, the former is more readable. Could be habit as you say, but in my mind, when I see a type without a namespace, I think *oh it's one of our classes*. Especially currently working with a very large codebase, having a declaration *right there* of where the code is from is incredibly useful. (I'm agreeing with you, just wanted to add more reasons that this is a good thing)
That's clang-cl.
Awesome. Thanks. I'll make a plan then and work on that. Appreciate the guidance. 
You spelled "length" wrong. 21 times.
According to [this blog](https://blogs.msdn.microsoft.com/vcblog/2017/12/13/broken-warnings-theory/) it's `/external:I`.
One potential caveat with this flag is that it behaves differently than gcc and clang. Both gcc and clang will move the -isystem headers to the end of the search list while msvc will keep the same search list. mkdir folder_1 touch folder_1/header.h mkdir folder_2 touch folder_2/header.h echo "#include \"header.h\"" &gt; file.cpp g++ -v -H -c -I./folder_1 -I./folder_2 file.cpp ... #include &lt;...&gt; search starts here: ./folder_1 ./folder_2 ... . ./folder_1/header.h g++ -v -H -c -isystem./folder_1 -I./folder_2 file.cpp ... #include &lt;...&gt; search starts here: ./folder_2 ./folder_1 ... . ./folder_2/header.h clang++-6.0 -v -H -c -I./folder_1 -I./folder_2 file.cpp ... #include &lt;...&gt; search starts here: ./folder_1 ./folder_2 ... . ./folder_1/header.h clang++-6.0 -v -H -c -isystem./folder_1 -I./folder_2 file.cpp #include &lt;...&gt; search starts here: ./folder_2 ./folder_1 ... . ./folder_2/header.h cl -showIncludes -c -I.\folder_1 -I.\folder_2 file.cpp Note: including file: D:\bug\folder_1\header.h cl -showIncludes -c -experimental:external -external:I.\folder_1 -I.\folder_2 file.cpp Note: including file: D:\bug\folder_1\header.h
But you did learn something! And C++ has a funny way of making extra sure that you learn to pay more attention to your code ;-)
&gt;There should be a way to integrate it. There is. You can easily write glue code between OpenSSL (or something else) and the Networking TS' concepts. That's exactly what Boost.Asio does. 
The function returns a reference to that element, so if the elements are unrelated you've got basically pointers to two different parts of memory, which is thread-safe. Note that he indexes 0 and 1. It's be like if you had: int a, b, c, d; vs. std::array&lt;int, 4&gt; elems; and you access `a` and `b` at the same time vs. accessing indices 0 and 1 at the same time. It's thread-safe as long as they are separate elements.
ALL HAIL NINA, MINUTE KEEPER OF C++!!! Where can we find the official minutes?
And, expounding on what [WHEEEEEEEEEW](https://www.reddit.com/user/WHEEEEEEEEEW) said, in the case of std::vector&lt;bool&gt;, operator\[\] is *not* thread safe because the reference type it returns is std::\_Bit\_reference, which could modify data associated with a different element of the vector (because the boolean values are packed as bits in integers). You don't necessarily know this unless you look at the reference type and see what thread safety guarantees its API makes.
All you need is 2 arrays of bits: "is this a mine" and "is this flagged", you can calculate the number of adjacent mines dynamically - although it *may* be worth caching. Consider `enum Cell {/*0..8 as-is for revealed cells*/ HIDDEN_MINE = 9, FLAGGED_MINE = 10, HIDDEN_SAFE = 11, FLAGGED_INCORRECTLY = 12 }; Cell[1000][1000] grid;` although you could even pack the enum as 2 nybbles. You *definitely* shouldn't be storing (r, c) as part of grid[r][c], since it's implicit in the index.
You didn't answer my question at all, though. I asked if operator[] is guaranteed to be thread safe - not what is returned from it.
I found your reported performance unbelievable so I decided to test your claim about multiplication speed. The test code: std::string base("1234567890"); std::string ns; for ( int i( 0 ); i &lt; 100; ++ i ) { ns.append( base ); } BigNumber bn1( ns ); BigNumber bn2( ns ); BigNumber bn3( bn1 * bn2 ); std::cout &lt;&lt; bn3.asString() &lt;&lt; std::endl; I build this test with -O3 flag. Test results: time ./BigNumber &gt; /dev/null time: 0:01.19, max mem: 3660, vcs: 1, ics: 2, swap: 0 I think you should remove falsehood from your post here. 
It also behaves differently because it doesn’t suppress warnings you forced instantiated templates to do (that’s your code’s, not the library’s, fault).
You can talk about the stack and heap in regard to references, but pointers can be deferred until data structures, IMO, since that is when they're really needed. 
The problem is it will take only 3 years for your library to perform such multiplication.
You are an optimistic person, to go and test a 608 sloc bignum-library for speed.
I understand, but seeing that it's only 608 sloc, gives the answer right away. Also, using anything other than 64-bit ints is garbage, it's 4 times faster than using 32-bit ints [this claim used to be on the main GMP-page at the time 64-bit processing was becoming a thing, maybe it still is, didn't check]. Anyway, this post [the original one] should have been deleted.
There is no way your O(n^2 ) multiplication algorithm can multiply two 10 million digit numbers in less than a second. On my laptop it takes 5 seconds to multiply 1000 digit numbers and 25 seconds to multiply 2000 digit numbers. 
Nope, but I did lose like an hour of my life, at which point I gave up.
To think about this a different way – what would make it unsafe? One of the necessary conditions of a data race is mutation of some shared data. `std::vector::operator[]` only reads, and what you are modifying (the elements) is not shared, so those conditions are avoided here. It's no different from calling `std::vector::size()` in two different threads in that regard, assuming the indices are not the same.
is operator[] *guaranteed* to only read? 
And he explained it's thread safe with vector&lt;bool&gt; being the expection... is that really so hard to understand?
So I do performance c++ number crunching for a living. There's quite a few optimizations you can make here. You can get a number from a char by subtracting '0'. Std::map is literally never worth using. The only thing you should ever use is vector. Unordered_map is the only built in data structure that can ever come close and only in very weird circumstances. I can't stress this enough - vectors are always faster. All of your if statements handling negative numbers are slow and mess up the optimizations the compiler will try and make. You can do any int mathematical operation only checking the flags once each. You will get thousands of times faster if you do base 2^32 numbers in each slot. Let the CPU handle more of the load. You could even use 64 bit numbers You never should allocate memory during computation - pre allocate always. Error checking should be disable-able. Huge speed increases. This is something that would be fun but it will take you months of learning to get - you can vectorize code yourself. You can look up intrinsics, but know they're hardware specific and not intuitive. The compiler will normally do a good enough job (but not as good as you could do). You spelled length wrong all over the place. Algorithmically there are faster bigint tricks you can use but I don't really want to get into them. I really enjoy mathematical programming and performance coding - it's a fun puzzle book.
I think he may be wrong and am asking for clarification.
Yes. N4659 §26.2.2.1 on sequence containers: &gt; For purposes of avoiding data races (20.5.5.9), implementations shall consider the following functions to be `const`: `begin`, `end`, `rbegin`, `rend`, `front`, `back`, `data`, `find`, `lower_bound`, `upper_bound`, `equal_range`, `at` and, except in associative or unordered associative containers, `operator[]`.
Ah the classic "it doesn't work but it's fast". It's easy to make things fast by breaking them, the challenge is too keep them correct while doing so.
For the algorithms, you should use: - [Karatsuba algorithm](https://en.wikipedia.org/wiki/Karatsuba_algorithm) for the multiplication (easy) - [Knuth algorithm for long division](https://janmr.com/blog/2014/04/basic-multiple-precision-long-division/) for division (hard) Your way of doing the modulo operation is all but optimised... 
unsigned - signed = unsigned in c++
No mention of [std-proposals](https://groups.google.com/a/isocpp.org/forum/#!forum/std-proposals)?!?
This is an interesting project idea, but I'm afraid there are some substantial misunderstandings of the language that have impeded your ability to write clear code. I strongly encourage you to read something like Scott Myers' *Effective Modern C++* to improve your code quality. Also feel free to post questions here! --- For example, this snippet demonstrates a fundamental misunderstanding of ownership semantics. unique_ptr&lt;Data&gt;* generateData(int setSize, float minX, float minY, float maxX, float maxY, float (*f1)(float), float (*f2)(float)) { unique_ptr&lt;Data&gt;* data = new unique_ptr&lt;Data&gt;[setSize]; // stuff return data; } 
It depends what you are trying to do and if C# (or C++ for that mater) fits your needs - you can't learn a language without using it anyway. When you start hitting the limit of a language, looking for a different one will come naturally. In your games, if you don't have performance problems, or be annoyed that you can't track big memory allocations predictably or use low level api-s directly, and if generics are good enough for you, then use C#. 
the question is, if you were to name a member variable HTML, would it thus become _HTML and thus reserved. The answer is html and thus _html. 
No chances for this guy, then? "I don't think so… sorry!" https://groups.google.com/a/isocpp.org/d/msg/std-proposals/A1EHOFts_Tk/h9DuO8SzBgAJ
I think you're confusing cache line size and cache level size...
Hello. It look like my phone forgot to send the message I wrote! I wanted to say that I definitively love your articles. Unfortunatly, I don't have the time atm to practice it, but having a solid refactoring tool is something I want to add to my toolbox. When I will eventually take the time to learn how to use clang tidy, I will definitivly use your articles. Their is something that I was not able to do when I previously tested clang query. How do you match a string litteral? I was succesfully able to match integer literals, but not strings.
How is it thread-safe ? What happens if you clear the vector in one thread and do operator[] in another ? If the type is non atomic and you write to it in one thread ? A thread-safe vector would carry a mutex and not return references 
Not sure if they're made public.
Take a look at ubsan, available with both clang and gcc. When built with the ubsan compiler option, debug builds are instrumented to check for invocation of undefined behavior and to output error messages. Insofar as your tests have good coverage, it will let you know about a lot of undefined behavior in your program.
This article is called "How to write a good proposal", where the author goes on about his own proposals, even though he never got any of them published into a standard...
There's a demo of the proposed tool at 42:00 and I must say it looks very promising.
&gt; Do you guys have other numbers? I'd like to hear the numbers about how many window-specific `#ifdef`s where required to get this to work? 
Has anyone ever pretended that globals did not make life easier in the short term? The issue with globals is the hidden dependencies, as well as multi-threading for non thread-local globals. The `Filesystem` presented is an interesting case here, for example. Yes, the filesystem you use *is* global, however you won't be able to use a multi-threaded unit-test framework if you use a global `Filesystem` and want to mock it during unit-testing (to test specific error conditions). So, in production, a single `Filesystem` abstraction is good enough, but for testing it's problematic. The `Locale` is an other case. For a single-user process such as a game, it's reasonable that said user would want a unique locale. It starts breaking down already for games if you think of a multi-user game where each user could want a different global for their own portion of the screen. And it completely breaks down for server processes handling multiple users concurrently. In the end, I personally only use globals for logging and event-passing/scheduling. *Note: I don't count constants in there; global constants are perfectly fine, and suffer none of the issues mentioned above.* 
&gt;&gt;a good reas &gt;Yeah - those Java people... reas
"Compiler is out of heap space"... goddamn :/ time to buy more RAM I guess
They seem to have started work in this direction a long time ago as suggested by this old article: [https://testing.googleblog.com/2011/06/testing-at-speed-and-scale-of-google.html](https://testing.googleblog.com/2011/06/testing-at-speed-and-scale-of-google.html)
&gt; So you propose to add dozens (hundreds?) of std:: in each cpp file (spend time now to write it, to read it) - just to be sure other developers life in ten years will be easy? Yes. Writing code is easy. Reading code is hard. Reading ten year old code is even worse. Adding `std::` qualifies names and, for the most part, helps the reader. Particularly in codebases which take a lot of stuff from other namespaces besides `std` which may have similar names to the things in `std`. There are some names from `std::` that get used a lot. I have no problem with, say, `using std::string;` declarations in source files. It's pulling the whole `std` namespace, which is enormous and growing, for access to a small number of names, which I object to.
You where answered many times. You only seemed satisfied when provised with a standards quote. If you want a standards quote, ask for one explicitly. Don't just repeat your questikn eith *emphasis*. 
I think this is one area where C++ should look at how Rust addresses the issue. Data race safety is enforced in the safe subset of the Rust language. A similar type of enforcement is [available](https://github.com/duneroadrunner/SaferCPlusPlus#multithreading) in a (data race) safe subset of C++. (A subset that excludes raw pointers and references.) (Shameless plug alert.) First of all, you want to note the distinction between a type being safe to pass (by value) to another thread and being safe to "share" with another thread. (Rust calls these "Send" and "Sync" traits.) And rather than just "documenting" the safe "passability" or "shareability" of a type, it can be "annotated" in the type itself. This allows [thread objects](https://github.com/duneroadrunner/SaferCPlusPlus#thread) to ensure/enforce at compile-time that none of their arguments are prone to data races. And any type that needs it can be annotated by wrapping it in a transparent "annotation" template wrapper. For example, it's not really safe to share `std::vector&lt;&gt;`s among threads, because any thread could obtain an iterator to the vector and inadvertently dereference it outside the period when it's safe to do so. But you could imagine a [vector type](https://github.com/duneroadrunner/SaferCPlusPlus#nii_vector) that (is swappable with `std::vector` and) does not support (implicit) iterators, and so would be more appropriate for sharing among threads. You could even imagine a [data type](https://github.com/duneroadrunner/SaferCPlusPlus#tasyncrasectionsplitter) that safely allows multiple threads to simultaneously modify disjoint sections of a given vector or array. I think we really want to get beyond having to explicitly deal with mutexes. Just like how `std::shared_ptr&lt;&gt;` (and `std::unique_ptr&lt;&gt;`) is premised on the notion that it's not a good idea for the lifetime of a dynamic object and the accessibility of that object (via pointer) to be manually coordinated by the programmer, it's similarly not generally a good idea for the synchronization of the object to manually coordinated (with its lifetime and accessibility) by the programmer. I think the obvious progression is to have [reference](https://github.com/duneroadrunner/SaferCPlusPlus#tasyncsharedv2readwriteaccessrequester) [types](https://github.com/duneroadrunner/SaferCPlusPlus#tasyncsharedv2immutablefixedpointer) that automatically (safely) coordinate lifetime, accessibility and synchronization of dynamic objects.
He has a point, though. Today compiler writers' attitude seems to be very much in the direction of "unless something is explicitly guaranteed, we can do whatever we want with the code, no matter how illogical".
Easy there
You can make the lvref overload be implemented using a copy ctor and the rvref overload void push_back(const T&amp; x){ push_back(T(x)); } This involves a copy and a move, instead of just a copy, which you could do using a placement new
I where what?
Yes. The thing is, it is not possible to remove duplication from two pieces of code that do different things. As for an alternative solution: You can have a function that returns a pointer to where you want to store your values And move/copy into there void push_back (const T&amp; x) new (get_storage_back()) T (x); } void push_back (T&amp;&amp; x) { new (get_storage_back()) T (x); } disclaimer: i haven't tried this, you might have to use ```operator=``` instead if your storage is already initialized
What's wrong with: void push_back(T obj) { *dest = std::move(obj); }
You need to make sure that all memory accesses in the AoT compiled module are checked. If untrusted code and trusted code are running in the same process, out-of-bounds accesses by the untrusted code can compromise the whole system.
By reducing the amount of code written like this. That, or adopt the rule-of-three for code duplication.
You have an unnecessary move for lvalues
Either use the forwarding reference approach: ```cpp template &lt;typename T&gt; class A{ template &lt;typename V&gt; void push_back(V&amp;&amp; obj){ ...std::forward&lt;V&gt;(obj)... } }; ``` or pass by value and move: ```cpp template &lt;typename T&gt; class A{ void push_back(T obj){ ...std::move(obj)... } }; ```
This could lead to a pessimization. The object might have an assignment operator that will be able to efficiently copy from an lvalue. By forcing object creation on the function parameter you defeat its purpose. Granted, for a push\_back this might not be a problem, but the way you wrote it, implies the object is already created. In any case, this pattern is best suited for constructor arguments, and "think twice" for member function argument. 
What Rust considers slow compile times is nothing compared to how bad C++ compile times are.
Although it's important to note that the pass-by-value-and-move approach only makes sense for types that are *cheap to move* (i.e. strings mostly - without SSO)
2 of my papers linked in that article reference std-proposals discussions! But... But I have to be honest: none of the ideas started in std-proposals. Some of them came from Cpp-Lang Slack, others came from Discord. I think it's a useful place if you need to spin your ideas around, but it hasn't served me too terribly well.
Probably because I should only talk about the things I know (e.g., my own writing). I already talk about other proposals in some other blog posts, but I wanted to go through the process of what made a good paper that I could \_personally\_ vouch for. As a side note, something being in the standard is also probably not a bar of "that was a well-written paper". Maybe Revision 3 or 5 turned out to be good, but this is to make it so less revisions are necessary. Revision 0 and Revision 1 should be of higher quality, in my opinion (and I need mine to hit that quality bar too, so I published some guidelines to help *me* out honestly!). There are a lot of papers that are not that but other people help them polish it into a better, more well-motivated paper.
The main caveat is that this is super greedy, esp. if you're only intested in one type. `static_if` would help prevent misuse, but an `enable_if` would go further to constrain potential overloads (e.g. stick to `U&amp;&amp;` and `const U&amp;` for a specific `U`).
Was scratching my head with this for ages before realising that it is a bug which was fixed in g++-8 - thought I would share on the off chance it would help someone else or I could be corrected.
isocpp already [covers this](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this).
it's not using auto return type, it's using trailing return type. `void foo()` becomes `auto foo() -&gt; void`
Apparently it does. I wonder if calling `delete this` is good practice. They say that it is an okay practice, but should it be employed widely?
They say it's OK to do, provided that you meet all requirements. Are you certain those requirements will not be broken for as long as your application is being developed? The answer is probably no. It's a terrible practice.
Agreed.
Pass by value should only be used if the object is to be created. If the object is (re)assigned to, then this could be a pessimization - the assignment operator might very well be more efficient then create anew+move.
If you have full control over the language, maybe you want to design a language that is "safe" - meaning that pointer arithmetic is prohibited and all array access is bound-checked, which (if designed properly) would make all memory accesses valid. Then (assuming your compiler is bug-free) and your runtime mediates all system calls, it would be possible to protect your system from the untrusted code.
The revision still needs work by the author. It was accepted and committed, but later reverted; this is what confused you probably :)
If you are going to make a copy internally anyhow *and the move constructor is cheap*, just take by copy (ie by value), then move internally: void take(string s) { mystring = std::move(s); } If you pass it an rvalue `take(makestring())` then it gets moved into `s` then moved into `mystring`. If you pass by lvalue `take(str)`, then it copies into `s` and then moves into `mystring`. So an extra move either way, but if you know the type, that might be a fine tradeoff relative to maintaining separate functions. (and if it is inline-able, that move might be removable). If T is generic then you don't know the cost of move :-( 
Inevitably it will be called with non-const `&amp;`. Bloat.
Thank you baby jesus! I want more!
That's a nice way to get rich but with Rust you will be a billionaire.
Even that `enable_if` or `requires` constraint is deceptively tricky to get right, though, and it's still only mostly equivalent — nothing you do will make a function template behave exactly like an overload set.
A number of key individuals got a standing ovation. It's a stupendous amount of work.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9vx4l8/help/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; trip report 🤔 
For anyone wondering, constexpr try-catch does *not* mean a compile-time exception-handling mechanism. It simply allows the keywords to be used in constexpr functions. If part of the try block throws, it's still a compile-time error during compile-time evaluation like before, but the function handling that exception is now allowed to be marked as constexpr.
I'm not sure what you mean?
Was the [Labelled Parameters (P1229R0)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1229r0.html) proposal discussed? If so, what was the outcome?
It was discussed in EWGI. There’s some interest, but we expect the paper (and competing one) to come back at a later meeting. 
`std::array` is a popular example. 
No shrooms were involved. I think. Probably. Maybe.
Woah, `std::colony` looks awesome...
And the reason for not allowing `throw` is that it would require implementing full exception handling inside the constexpr interpreter in the compiler. That would be very difficult to implement given the way most C++ compilers work today.
Networking in C++26 tells you all you need to know about WG21 right there.
Signed overflow has a similar effect
Networking is a victim of dependencies. Shame you can't get it in library form until then...
I don't know, but I don't like the verbose concept auto syntax. Why is the auto needed?
I assume Eric Niebler?
Can you be more clear? Have you used it and compared it against a similar implementation?
Still hoping for C++20 modules
Yes he was one.
To avoid another case of context-dependent parsing, I guess. It's also less ambiguous for us human being.
Although, conservative estimate for modules is still C++23, I think it's fairly secured for C++20? Going through various discussion, modules seem to have a good chance of making into C++20, don't they?
I mean if we want to restrict to only type U the simplest (non SFINAE) way would be to write: static_assert(std::is_same_v&lt;U, std::decay_t&lt;T&gt;&gt;, "Type is not compatible"); It std::is_convertible_to or std::is_base_of might better/ less restrictive options dependent on tje use case.
When can lambda capture of structured bindings be in the standard?
Did any of the papers attempting to fix operator&lt;=&gt; get discussed?
So, we have char8_t. Finally. I still remember in C++0x era when I tried to convince the committee that char8_t is necessary. At that time, they said char is perfectly reasonable type for representing the raw bytes of data. They were wrong.
_Question:_ How to kill C++ programmers in a month? _Answer:_ Postpone C++ Modules to **C++23**!
Here's what looks to be a pretty recent revision: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0907r4.html
C++20, 23, or 26. No difference. I bet we need 20 years to adopt the module in production.
I'm surprised for consteval. Also, was there an update on constexpr parameters? Were they rejected or waiting for refinement?
You'll see authentication for any papers that have links to a newer revision than the mailing a couple weeks ago. The next mailing is in a couple weeks and then the links will work.
Yep! Many of them did.
I'm not sure I understand what you are concerned about. Modules are going into C++20.
I am hoping for `void foo(Concept T x)`, with `T` being an introduced typename.
Yes, I hoped to get some TL;DR here. Well might dig into the paper then...
I wasn't there, but last I remember, constexpr parameters got stuck on name mangling and maybe some other tricky problems. Part of the benefit of consteval is that there's nothing to mangle. In addition, with the extended NTTPs, we can now use string literals and other simple types as template arguments, meaning the constexpr parameters can move to the template parameter list in some cases (when the type has a defaulted `&lt;=&gt;`). Given that the whole NTTP thing went in, I'm inclined to say the name mangling is figured out and that constexpr parameters could be specified as being equivalent to a NTTP, with the same restrictions. However, the only difference would then be `format&lt;"%s %s"&gt;(s1, s2)` vs. `format("%s, %s", s1, s2)` and one could argue that making the compile-time-only parameter a template parameter makes it clear why a non-constant-expression wouldn't work as an argument.
Where I work we maintain a few projects in C++ and they use MSVC 2010. I do get to use some of the newer C++ features (which I did the work of backporting myself in some cases, I'm the writer of cxxomfort) but besides the usual "but the clients!" problem one of the big reasons I am not moving to newer C++ versions for that project or similar ones is that I *don't main Windows*. I use a VM with rollback to compile in MSVC and thus I'm interested in keeping the cost of the VM lean. That means a Windows XP VM, since MSVC versions 2012 and after seem to only work with Windows 7 (I once tried Windows 7 Embedded but it caused some weird errors during install that I could not make heads or tails of). Get me a new MSVC that works correctly under XP, or under Wine / ReactOS, and I'll be able to progress on that front. Otherwise, I'm going to continue to essentially write Modern C++03 code but that will still be C++03 (no, MSVC does not actually support C++11, at least not enough of it). In a far more general sense, as a digital archivist, for me to adopt a new shiny C++ it has to be usable in *the same places* I can use the old, tried and true C++ that I already have: old laptops running Ubuntu 12 or Debian 7 because newer versions freeze, lite Windows XP installations, etc. Otherwise I'm adopting a whole new language, and for that cost I already have Python 2. 
It is fairly secured for C++20; unless we learn something radically new, it will likely land in Kona.
`auto` signifies that what's being declared is a value and not a type. In an abbreviated function template's parameter list, `auto` makes the declaration stand out as being a template despite not having `template&lt;&gt;` syntax. Many people were concerned about being able to quickly tell whether a declaration is a template or not, so this is the compromise.
The vision I have is: no duplicate files, no duplicate declarations, a whole lot less of fully qualified names and shipping source instead of a header-only library.
What is your current problem, and why do you think this would solve it?
Is there any documentation?
No. I wrote it myself and I suck at documentation.
Great! So what's the status now?
Definitively, thanks so much /u/blelbach 
Any 'old' class that has a custom copy ctor/assign, that hasn't been updated with a custom move ctor/assign. move falls back to copy.
Fixed for the first one. Sorry about the second; it will be in the post meeting mailing.
That's a pity. Without README, documentation (even doxygen could help), or some examples, I would not even think about thinking of using the project.
I got a paper on that, and EWG liked it, but asked me to come back to Kona with a more detailed analysis. I'll try to make it to the post mailing.
I've got a program that has a thousand or so objects that it loops through every tick (~300..1000Hz) and cycles a hundred or so into a dead pool to be reused. These objects are individually on the heap and their pointers are moved around and looped through; the contiguous, stable storage of an `std::colony` would be faster to loop through and the stable storage locations lets me actually use it; storing them in the `std:: vector` directly could invalidate the pointers out from underneath a tick. 
Just started existing, so nothing to report yet
Modules don't really give you all of that...
What is the current status of `future&lt;&gt;::then`specified in the Concurrency TS? Was this idea dropped in favor for the "A Unified Futures" proposal, or can we expect it to be included into C++20?
I'm not a big fan of self-praise, to be quite frank. Of course you're going vouch for your own papers, otherwise why would you put them out there. However, these sort of comments, it is more appropriate to come from others. This might be a discussion whether modesty has its own merit when writing a blog or not.
I don't think either char or char8_t is reasonable for raw bytes. I'd like to say std::byte is the type for raw bytes, but I can't; unsigned char is the right type for raw bytes.
These complaints again? I've already responded on the reflector with my thoughts on P1269R0 but I will repeat my post here. Cut on the line --- Hi, I'm the author of Boost.Beast: &lt;https://github.com/boostorg/beast/&gt; As such I am heavily invested in both Boost.Asio and Networking.TS. I offer constructive comments on your paper. I use the general term Asio to refer to Boost.Asio, stand-alone Asio, and Networking TS. For reference, this is your paper that I reviewed: &lt;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1269r0.html&gt; &gt; 2. TLS, including native support for SChannel and SecureTransport (not available in ASIO) You have to write your own stream wrapper, in the style of ssl::stream which wraps a socket (as does beast::websocket::stream). But if your algorithms are templated on stream concepts like AsyncReadStream and AsyncWriteStream, then they will work with custom TLS wrappers right? I don't see this as a limitation of Asio but rather a strength. Asio's algorithms should similarly work with your TLS implementation (do they?) &gt; 3.1 Synchronous I/O I agree that synchronous I/O support is limited but I don't think it was intended for those APIs to provide the same level of functionality as the asynchronous APIs. They are supposed to be a thin abstraction. The author has stated many times that timeouts are out of scope for synchronous I/O. I find this position sensible. &gt; 3.2 I have strong reservations about the usability of any async framework in C++ built only on top of callbacks. You might have a point about usability but I do not think usability is or should be the primary goal of Asio. Instead, it should focus on providing universal abstractions which allow for nothing in between itself and the operating system. In other words it should be as low level as possible while remaining portable. Usability is important but not when it sacrifices flexibility or performance. That said, the universal asynchronous model (async_result) mechanism brilliantly allows primitives other than callbacks to be used such as futures and coroutines (but you know this). Callbacks are the right low-level abstraction over the operating system for asynchronous operations. It should be the responsibility of network middleware written on top to expose more usable interfaces, with no loss of performance (other than any performance trade-offs inherent to the usable interface). This is explained in great detail, in N3747 which is an excellent read: &lt;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3747.pdf&gt; &gt; 3.3 ...the intermixing of lifetime for socket operations and timers to time them out is difficult to manage... Well that's putting it mildly...LOL. I am in agreement here. You are right that adding timeouts to async operations would improve ease of use but it would also result in an abstraction that is less flexible. Adding those timeouts would take important decisions about their implementation away from the user. Anyway, I have developed a TCP/IP stream wrapper which provides exactly the feature you want, which is to have an automatic timeout (currently implemented only for reads). This is accomplished in async_read_some which will return a custom error code if no activity occurs. The idea is to be able to just drop it right in, so that any templated stream algorithm will work with it. You can see that code here: &lt;https://github.com/vinniefalco/beast/blob/timeout/include/boost/beast/experimental/core/timed_socket.hpp#L35&gt; At some point I will refine it and make it part of Beast's experimental interfaces. With such an implementation, you could combine it with coroutines or futures (which already work with Asio and therefore Beast) and get something which allows you to write code in the synchronous style but that supports timeouts. I believe this addresses your use-case. &gt; 3.4.1 Relationship with the Executors TS Addressed in this paper: &lt;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0958r0.html&gt; &gt; 3.4.2 Over Generalization Addressed in this paper: &lt;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1322r0.html&gt; &gt; 4.1 Core of the critique &gt; Without the addition of futures or coroutines, callbacks compose poorly I couldn't disagree more. Composition is one of the greatest strengths of Asio's abstractions. In fact I dedicate two tutorials on how to write them in the Beast documentation: &lt;https://www.boost.org/doc/libs/1_68_0/libs/beast/doc/html/beast/using_io/writing_composed_operations.html&gt; &lt;https://www.boost.org/doc/libs/1_68_0/libs/beast/doc/html/beast/using_io/example_detect_ssl.html&gt; Almost all of your criticisms of Asio can be addressed simply by gaining proficiency at understanding and writing correct asynchronous Asio code. Yes I agree that the domain has a certain level of complexity that cannot be decomposed but Asio's abstractions are in my opinion, mostly correct.
I guess what modules are today is a bit murky, because I must say that I'm also the most psyched about them. That's because I expect to ditch headers and speed up compile times (say 25 to 50%)...?
I see. I'm just a hobbyist and an advanced beginner if that makes sense so I haven't started doing all of that yet. 
I can also write about my proposals that I think are bad, or talk about proposals that I think are great. For what it's worth, I had 3 blog posts that did exactly that...
Someone who can edit the OP: `std::arguments` is P1275, not P1276 I plan to write a more detailed report than what is below in the coming weeks. I'm in the very slow process of redesigning and converting my blog over to a markdown based tool from restructuredText. For some updates regarding the massive slew (17!) of papers I wrote (my name was on two more as a coauthor) We did not have time to review the following papers, so I won't be discussing them, but will have a small note: |Number|Title|Notes| |:-|:-|:-| |P1282|Ceci N'est Pas Une Pipe: Workflow Operators|Intended for C++23| |P1273|86 The Absurd (From Exceptions)|Will be delaying until a rumored paper that will make it possible| |P1274|A Bang For the Buck!?|This was not mentioned during the week, but will most likely be targeted for C++23| |P1278|offsetof for the Modern Era|There was some disagreement on whether it can be entirely done without EWG's involvement, however Daveed from EDG (who usually sits in EWG) confirmed for me it can be done on the library side, but will technically require a compiler intrinsic| |P1281|Feature Presentation|This is going to be withdrawn in favor of a better approach in conjunction with conditonal module imports| |P1283|std::breakpoint|This was not discussed, but might require some compiler intrinsic support, based on cursory discussion :/| |P1301|Remember the Fortran|This was not discussed, but I personally think some of the issues brought up in the paper will be solvable| |P1304|Simplify Extern Template|There are some serious issues with the wording and tbqh, I know this :v. Will try to improve for an R1| Now on to the papers with some explanations: * P0468 (Intrusive Smart Pointer) is pretty rock solid at this point, however it hasn't had a design session yet, and out\_ptr was (literally moments before I post this!) given a small 35 minute design decision. Some feedback was given on *that one* that it should have an ADL customization point instead of a template specialization point (fuckin' lmao). I'm not the author, but it's usage is closely related to mine. * P1275 (Desert Sessions) it was pushed over to SG16 who decided that transcoding is going to be necessary for us to "do the right thing" regarding unicode and "bag of bytes" interfaces. I'm in the camp that we should have unicode by default, and bytes as a fallback. Rust got this right and there's no reason we can't either. In my opinion, it'd be like if we could fix the lack of const by default without breaking anything and then chose to be mutable by default anyhow. Expect to see this paper return after C++20, but before C++23. I'll be waiting a bit to see SG16's direction and guidelines before modifying the paper. * P1276 (Void Main) had decent feedback and many people were in favor of it. However because it target's non-modular C++, there is a very high chance it would be rejected by EWG. What will most likely happen is that modular main will be suggesting we change the signature for `main`, and then we'll use P1276 to make non-modular (aka "Classic C++") consistent. The general atmosphere of the room was that `void main` doesn't break anything and makes `main` consistent with how all other functions actually work. * Not mentioned is that `byteswap` (P1272) was forwarded to LWG with a small wording fix to make sure it only works with types whose `sizeof` is power of two. * P1280 (Integer Width Literals) was *also* forwarded to LWG with minimal mentions, though one person mentioned they wanted it in C++23. Despite being the author of the paper, I was busy presenting elsewhere so I have no idea who it was :v * P1283 (Sharing Is Caring) was unable to reach consensus, though additional work and feedback might be required. I'll be working with Antony Polukhin (author of a previous incarnation, P276) to get the most basic level of features in. We haven't agreed to a joint paper for `[[shared]]` and his shared library loading, but Bjarne said he would like to have a definition of dynamic linkage before either of us could move forward or before many would feel comfortable with. What will most likely happen is we will have an *extremely* restricted subset that lets you acquire a function pointer (where thread local storage behavior is implementation defined) and that's it. The attribute currently focuses on these as well. Nothing else we can really do otherwise, but I personally feel this could be taken to SG15 for tooling based feedback. * P1301 (Nodiscard with a reason) was not only forwarded to LEWG/EWG from EWGI, but more importantly was forwarded without any negative feedback nor did it *have a reason* that it shouldn't move forward. * P1302 (Inline Module Partitions Lookup) was given no feedback despite having negative votes during a night session in SG15 (all papers were effectively "rejected" and SG15 doesn't have guidance or direction to focus on) which carries no weight. What will most likely happen is this will target a standing document (much like SD-8) as this can be more of a guideline than a requirement in the standard. Additionally it skips most of the current process * P1303 (Inline Module Partitions) was killed in its current state but will be resurrected to replace P1281 (Feature Presentation) and be used in conjunction with a planned pre-Kona mailing paper on conditional imports for modules that will be targeting C++23. Lastly, it is sort of well known that I have... *traditionally* been unhappy with where Modules are going. Given their current state as they progress to C++20, I am not 100% satisfied with them, but am comfortable with working with them and improving them after C++20. That said, I did discover a small possibility to allow an ODR violation and will be writing a paper to *for sure* eliminate this in the San Diego post mailing.
&gt; it makes no sense to always specify std::net::use_future in every library call Networking TS takes a framework rather than a library approach (as does Beast). If you want to have an API that uses futures exclusively, then you can simply write your own set of free function wrappers to invoke Networking TS algorithms with a `std::net::use_future` object. &gt; You can read more about the timeouts issue here. In short the authors claim this &gt; is a big problem for sync part of the library where you currently have no option &gt; to specify timeouts at all (can't use async timers) This speaks more to ignorance rather than a limitation of Networking TS. Platforms vary in their support for canceling synchronous operations, especially from other threads. Everything in the standard library needs to be portable, so it really doesn't make sense to say that synchronous calls need a timeout otherwise they are "useless." &gt; And for async, yes you can use the timers so if it's the only way I can accept &gt; it knowing networking TS is still very low-level. But to a end user it's not &gt; very appealing as a whole. 1. As I explained on the reflector, timeouts can be tricky. However, it is possible to create a wrapper which looks like an asynchronous stream and has efficient timeouts built-in. I have published such an implementation in the latest Beast, which will ship in Boost 1.69. Even so, I know of two other authors (Damian Jarek and Christian Mazakas) who have each come up with their own independent automatic solution for adding timeouts to existing operations transparently. This speaks to the robust design of the Networking TS that such implementations can be written. 2. Asking for timeouts to be incorporated into asynchronous operations is unreasonable, and bad design. There are many ways to implement timeouts on operations. Each has its own pros and cons, and may or may not be appropriate for a particular use-case. For the standard library to pick a design and force it onto users is totally inappropriate, yet that is what you are asking for. If in the future, one clear way of implementing timeouts stands out as universally desired, we can always add it. Or perhaps it can be a feature which users can opt-in to. &gt; As for the backend of course it's not so important whether we talk about OpenSSL &gt; or LibreSSL or MS crypto. Ideally this should be configurable but if it's not it &gt; could be also decided by the std implementation and that's fine. I don't see that happening. Standardizing a TLS implementation is extremely unlikely. Other languages' libraries don't have this problem, because they have no standards document. Most just have one implementation which serves as the "spec." You already will need OpenSSL even in a theoretical `std::` solution. I see no reason why external libraries cannot also provide the TLS component. Thanks 
Hmmm... I don't have any benchmarks, but I believe the author of uWebSockets has developed and published some. Unsurprisingly, uWebSockets comes out ahead :) I suggest caution interpreting those results, they might not translate directly into real-world performance. But that library is still pretty good.
You joke but someone once asked me if we could make the parallel algorithms `constexpr`.
I am so looking forward to `std::embed` and `std::colony`! Should make engine programming a lot easier. `embed` should also be really helpful if we ever get a C++ compiler to target the MEGA65
Nothing has made it past committee yet, but there was support for this direction: == will no longer call &lt;=&gt; `operator&lt;=&gt;() = default` will generate &lt;=&gt; that calls &lt;=&gt; on members, and also generate == that calls == on members. `operator==() = default` will generate memberwise calls to == If you write your own &lt;=&gt;, then you need to write == as well. Which will often be faster, because == (particularly when false) often needs to do less work than answering which is less. (ie vector == checks size first, &lt;=&gt; looks at elements regardless of size) Thus (although this part was not discussed) weak_equality and strong_equality are basically moot and we should remove them.
Move should usually be practically free.
The day to day impact from modules will be faster compile times (on top of code organization, etc)
That sounds like progress. My biggest concern was exactly that == and != would be innefficient with &lt;=&gt;. But looks like we may still have to be careful when not defaulting it? Also, if not removed, was weak_equality generating operator== discussed?
Congratulations to both of you!
Well, this is refreshing !
You think you'll speed up compile times beyond what PCH already does for you?
It won't be in C++20; we'll have senders/receivers in C++23, which will provide that functionality.
Thank you for posting this. This was a fantastic video that covers many concepts that are incredibly helpful to people without much or any c++ experience. 
Not having to split declsration and definition for most cases.
I do have full control and those are some good tips. I have looked at wasm actually, it was going to be what I compile my language to but I've decided to just go directly to machine code. I'll definitely have to work on making my language safe, as right now it does almost no checks.
To be clear: we don't have direction on `std::colony` yet; we have just determined that we need more information before we can evaluate it.
We might still have time in LEWG to see P0468. Drop by if you are free.
&gt;Or a 2D matrix class? N dimensional matrices would be covered (brilliantly, imo based on the paper) by `std::mdspan` , don't know the actual status of the proposal tho 
Still looking forward to it regardless. I've been attempting to create something similar myself but keep getting stuck on allocation issues 
Also, we could do `offsetof` in LEWG.
Not quite sure about graphics SG being revived to be honest. I think it is important to clarify the scope and direction before working on something concrete, though it may never reach consensus. It is understandable to try to save the multi-year work, but it feels like an impossible job. Maybe once we have package management it has somewhere to belong.
Any news about constexpr operator new?
This is significantly worse for lvalues; copy assignment can end up being way faster than copy construction for repeated calls.
The author of Beast, probably knows about ASIO and Beast :D
It's still drafting, but it's expected to go into C++20 - maybe next meeting?. The paper number is P0784 :)
`const Constraint auto x = foo();` This is getting out of hand. At least the syntax leaves open the possibility for further abbreviation in the future as `const Constraint&amp; x = foo();` or even `const x = foo();`.
It's still a pile of raw bytes, but we can expect that it's intended to be interpreted as UTF-8, just like char16\_t and char32\_t are UTF-16 and UTF-32. 
They've got a good chance, but they're not certain. The main threat to them now is objections on the grounds that they haven't yet been implemented in their current form. We don't know yet whether there will be an implementation by Kona.
Please use the implementation now, and let us know how it went: https://plflib.org/colony.htm
Why not? They are already allowed to be executed sequentially. 
Wow. That's really disrespectful. 1) it's a conservative estimate and 2) why don't you do it if you're so much better? "Move fast and break things" is not a viable strategy for an ISO standard.
I really want to bikeshed that name. I vastly prefer source/sink.
The question we must ask is not "do we want this in the standard library?". The real questions: - "Is the design going to change in the next 10 years?" - "Is there any possibility there will be a better alternative in the next 10 years (given the possibility of new research and new hardware)?" - "Is this worth the cost of standardizing? Giving this time will mean less time for other things?" We don't have enough information to answer these questions regarding `std::colony`, but we think it has potential, so we want to look at it some more.
It is not the first time modules get a "merged design". I hope there will be no YATOM.
\- Better isolation and security that you do not need to spam myns::something in all your code. \- Better compile-times. \- Easier support in the tooling for code completion. &amp;#x200B; It will take some time, but the most immediate benefits would be better compile-times (do not know by how much) and better isolation (which is VERY welcome after suffering name conflicts even in cppnetlib when make\_optional did not know whether it should resolve to the std library or to the boost library because it was called without qualification. I had to do a patch for my code).
What is senders and receivers?
Better isolation due to lack of includes means that you can be sure you did not include something indirectly, thus increasing your confidence in fewer or no name conflicts.
Good to hear.
I generally try to avoid using non-standard libraries, hence I'm probably going to wait for it to be standardised before using it any any of my big projects. I will definitely *test* it soon though
LWG has been consistently moving in the other direction though. An earlier version of Ranges TS did try to ban this in its concepts. [It got removed.](https://wg21.link/P0547R2).
Vinnie just needs time to process. We'll all survive.
This is the path I'll be taking, but we need to add a concept to the stdlib first :)
I've been in Core for a bit since they're discussing modules. I doubt y'all are still meeting as we wrap up :P
Well, that makes sense considering that that's the status quo. 
If you won't use it, that's evidence it shouldn't be standardized.
Why can't you say that about `std::byte`?
I do very much need to use it, but I'd sooner write it myself (tailored for my engine) than use yet another library
The problem is the stdlib cant say “we don’t permit this”, it needs to be part of the interface in some kind of a Named Requirement. Otherwise vendors would have thrown the “just don’t overload the comma lmao” line into the standard a while ago. Instead they have to protect against it in their code.
&gt;it needs to be part of the interface in some kind of a Named Requirement No it doesn't. The throwing destructor is an example of this. The standard library is not required to handle throwing destructors for example.
I seriously doubt it, I wouldn't be surprised if it took until C++29. And of course it will be completely useless by then, as by then everyone will require the use of TLS which will not be supported until C++41 if at all. But being able to tell the compiler in a standardized fashion that a pointer is aligned is of course more important as it might result in being able to parse the data that you just couldn't download over the network in up to 0.01 nanoseconds less, but only after you waited for another 21 years before you can access regular websites. Seriously: Something is really wrong if you cannot write anything but commandline-programs that read and write files in standard-C++.
Unless we weaken the requirement to catch all UB in constant evaluation, there are hard implementation problems due to the introduction of data races.
They're all making good progress and should be on track for C++20. The first one has gone through the first round of wording review but CWG didn't finish with it this week; the other two are blocked behind that.
consteval all the things !
You are referring to Asio, which itself comes in two flavors, stand-alone and Boost.Asio. Code written to use one cannot be compiled with the other without making changes. A standardized networking becomes a Schelling point, everyone will build on it by default. Instead of what we have now with N different, incompatible network libraries. Shame on you for not arguing in good faith.
You are referring to Asio, which itself comes in two flavors, stand-alone and Boost.Asio. Code written to use one cannot be compiled with the other without making changes. A standardized networking becomes a Schelling point, everyone will build on it by default. Instead of what we have now with N different, incompatible network libraries. Shame on you for not arguing in good faith.
That you'd rather write it yourself is a sign it shouldn't be standardized.
I hear Schelling Point is beautiful this time of year.
I'm not saying that it doesn't have the dependency. But you think it is okay for Executors and Networking to take 7 more years?
By that argument, ***nothing*** should be standardised 
Time for a sabbatical, leap version to C++01 and push the issue out a couple of centuries.
no, feel sorry for the people who watched the whole thing.
Will do!
Link to the `std::is_constant_evaluated` proposal links to the `std::uuid` one.
Ah ok thanks for clarifying. I totally agree though :)
Is the tool available anywhere?
The update table says conservative estimate for international standardisation of modules is 23, So will it be like a compiler flag that we have to turn on to use until then?
The flag next to Belfast should be the Union Jack.
Right before the demo, there's a link to the GitHub repo. Or you can find it as the _evoke_ repo owned by the user _dascandy_
Are the papers available as HTML documents? The PDFs, especially the LaTeX-generated ones, are really hard to read on mobile.
The signedness still matters, because C++ (and C) unsigned math wraps while signed math does not.
A receiver is an abstraction of a callback: it has a value channel, an error channel, and a done channel. A sender is type with a `submit` member that accepts a receiver. At some point in time, possibly after `submit` returns, the sender will send a value or an error to the receiver. If the sender were rigged up to support cancellation (not a fundamental part of the sender/receiver model), then before going away, the sender would signal "done" on the receiver. Sender/receiver is very general. The concepts can be modeled by things like future/promise pairs or by awaitables and coroutines. They are very efficient; since the work is generally not scheduled until `submit` is called, the sender/receiver model can be implemented without any dynamic memory allocation or synchronization overhead. In contrast, future/promise are heavyweight. The ideas for sender/receiver come from the Rx world. They have been brought to C++ by Kirk Shoop. The model generalizes well to senders that send multiple values over time: reactive streams, aka asynchronous ranges.
Yes I hope and assume you realize that I'm completely trolling you. Just having some fun, but also saying that for now we will need to keep using asio. That's not the perfect answer but at least we have something for now. The committee needs to make decisions for the next 20 years, so sometimes we make unpopular decisions, particularly for near term development. 
I think std::byte has a bit of an odd interface, but I encourage people to try it out and let us know what you think.
"weak_equality considered harmful" is my paper, and yes, it was discussed. But since &lt;=&gt; basically doesn't generate == at all anymore, there is no problem. Interesting note, however: partial_ordering doesn't even guarantee an equivalence relation. Didn't notice that until someone pointed it out this week. So it is good &lt;=&gt; doesn't generate == anymore.
What do you use for unit testing and logging? 
As another Python convert, one of my favourite things about the language (as normally used) is that if you see some variable name `qty` in a function, you only need to look in that file to see where it came from. It was probably declared above, or imported by name. For me at least it helps a lot when reading code, but fancy tools could conceivably make up the difference.
Quoting from the paper: Erasing or otherwise "deactivating" objects occurs frequently in performance-critical code. For this reason methods of erasure which create strong performance penalties are avoided. How is the latter achieved? I don't see anything in the interface that would do that (but maybe I missed it). I would think [expect] there would be some `deactivate ()` (you actually use that precise word in the paper) member function [and of course a `reactivate ()` (with fallback to insert/emplace, iff none are available)]. What I'm alluding to is to actually not destroy an [deactivated] object at all. Not having to construct the object, but f.e. just modify its [new] color, position or texture can give performance gains.
I'm cosigned on the Remember the Fortran paper. That said, modules are in a much better place when both that paper and that post were made.
"**The pre-meeting mailing had 274 papers, about twice as many as any previous meeting, and we had 180 people attending, making this the largest C++ committee meeting ever.** " This is great proof that C++ is not going anywhere. The language that will replace C++ will be next ISO version of C++ itself. I am loving this 3 year release cycle plan !
Using addressof is second nature to us now. We complain when it really matters (e.g. `explicit(bool)`).
&gt;Eric Niebler I agree. Modules will be the biggest change in which I write C++ daily. I always found it redundant and archaic to separate hpp and cpp every time since the hpp can "mostly" be inferred by the compiler from the cpp. 
It appears to be, based on my experience with Armadillo, writing C-style code directly on top of BLAS/LAPACK beats Armadillo every time.
Has been any advancement on the new exception model P0709? 
Personal preference 
Author here. Really wish the committee to publish something like this after each meeting as a \*human-readable\* release note.
this
Thank you both. Also finally we have msvc that's able to compile ranges. Good times! 
As far as I know One Range Proposal does not add views and actions into the standard, it just adds range overloads of the functions in &lt;algorithm&gt; 
There can be no data-races if you only use a single thread.
1. No 2. No 3. Managed is not more modern 4. No
Ada is a great language without GC, which can be used for this, but somehow Ada didn't gain popularity.
Knock knock?
Didn't you see the [pinned trip report](https://www.reddit.com/r/cpp/comments/9vwvbz/2018_san_diego_iso_c_committee_trip_report_ranges/)?
WOW thank you so much! Had the error message read "exhausted address space" or something I would've understood to look for that. Well, from now on I do. :)
Looks like an attempt to make c++ look like rust
&gt;If you write your own &lt;=&gt;, then you need to write == So we are back to writing multiple comparison operators then. Can we at least have operator== as a default from operator&lt;=&gt;? Because not every type is a string or vector... 
They are not mutually exclusive - if you don't need the typename, then use auto, but if you do need it, this will save you from decltype-ing. I know how C++ community hate comparing C++ to other languages, but this will actually bring us ahead, the 'hip' languages of current year: `fn/func func&lt;T: Constrain&gt;(val: T) -&gt; ret` C++ hopeful `ret func(Constrain T val)` `auto func(Constrain T val) -&gt; ret`
Why odd?
It’s an improvement: You don’t need operator!=, symmetry is taken care of etc.
Depends pretty much of the domain one works in. For games, HPC, GPGPU and Fintech it rules. On embedded and POSIX based OSes it is still fighting politics against C use. On modern mobile and desktop OSes it has been pushed down the OS level features, with other languages having first class support for user space applications. Windows is the only consumer OS left where it has equal footing with other languages.
Move it to Boost? 
For those of us doing polyglot programming it is even harder. Just trying to guess on which version was a specific feature added or changed would give an interesting pub quiz.
For anyone wondering: it's the machine learning study group 
Are you going to expand on the rest of changes made in San Diego?
I tried to port a parser for a network protocol to std::byte but it was extremely painful due to lots of casts needed everywhere and lack of operators on it - the unsigned char version is vastly simpler to read and write
Look at his other questions - he asks provocative questions.
`co_&lt;=&gt;`°
Deprecating `volatile` is concerning to me. I do a lot of system and embedded work, and there isn't always a replacement for it.
But no tokra? 
It is a bit selfish to say this but... someone please get a decent prototype before Kona. For me there are lots of cool things done in this meeti g. Congrats! But modules comes out as the biggest and most important.
Thanks! 
Then at least put in the parts that don't depend on them. I know that I've seen at least one proposal to that effect. There is exactly no reason why something along the lines auto stream = std::socket{"example.com", port{80}}; stream &lt;&lt; "GET / \n"; shouldn't be possible in C++20. The last time I needed network (a coding-competition at my usergroup, for the most part I am currently writing my thesis, which is pure theory) we wasted 20 or 30 minutes just to get boost::asio running with CMake.
Concepts are nice. But waiting half of the time or less for compilation and not getting into ADL problems when working to finish projects... That IS a very lractical paradigm shift. More than any Concept ;) I also like Concepts, but Modules solve very real life trouble for a wider number of people IMHO.
Networking in C++26? That's pretty far away....
Sadly... But asio is here... 
Yes, using it for years. But we try to migrate as much as possible from boost:: to std::
I think the fact that Ada started as proprietary is a huge issue. I myself wasn't aware there were open source Ada compilers for a very long time, and I wouldn't be surprised that many people haven't realized it yet. Then, there's probably also the syntax aspect. It's only skin deep, but it's amazing how quickly people recoil from unfamiliar syntax and don't investigate any further.
Is there still hope for metaclasses in C++20(or C++23 even)?
1) it can't without taking the world down with it 2) yes and no. C++ is and should become less popular, but that's how it should be and it doesn't get replaced. 20 years back efficiency and flexibility just was a lot more important and everyone had to use C++. Now you can use language like Java and Python instead (java script replacing C++ ? dude, if you can do that for your projects you definitely shouldn't be using C++). 3) efficiency and flexibility in the parts of the code nobody will ever see. Efficient and fast implementations that do the heavy work. It will keep doing all the work in smart *insert anything here* it will keep running your cellphone, tv and fridge and car running and planes in the air. C++ is everywhere around you, it might not be a fancy app on your phone but it's a big part of the machine that allows that app to run in the first place. 4) all standards are bloated especially old ones. So i guess that's a requirement? I haven't seen a standard i wouldn't call bloated. So yeah and it will become more bloated. But the core language is in great shape and almost nobody should worry about a bloated standard most people will never have to read it and the core language is still efficient and easy to use. And thanks to a bloated standard it gives you many specialized tools that you can just use if you need them. But since those tools come with no cost why not have a bloated standard? It's not bad. 
what are the chances that coroutines (in some form) make it into C++20? i would murder a dog for coroutines, i'm not even kidding.
In random_number_generator.hpp: I do not think you seed the rng correctly. MT has a huge internal state. You need to use something like : std::random_device r; std::seed_seq seed{r(), r(), r(), r(), r(), r(), r(), r()}; std::mt19937 rng(seed); 
Unsurprisingly Rust is quick to take credit for things they didn't invent. Expected was first introduced in 2014.
I don't want to bias opinions on this one, so try it for yourself, and let us know.
Rust is effectively a collection of all the best practices that emerged over the years. Needless to say C++s development was a major inspiration for this.
&gt; I cannot export macros from modules? &gt; This one is technically correct: module interfaces and module consumers are isolated from each other where the preprocessor is concerned. In fact, as currently proposed, modules are an entirely language-level (as opposed to preprocessor-level) mechanism. And I strongly believe this is a good thing. &gt; And you know what, we already have a perfectly fine mechanism for importing macros: the #include directive. So if your module needs to "export" a macro, then simply provide a header that defines it. This way the consumers of your module will actually have a say in whether to import your macro (which always has a chance of wrecking their translation unit). More stuff at https://build2.org/article/cxx-modules-misconceptions.xhtml
Thank you, fellow stranger. 
Related : https://www.reddit.com/r/cpp/comments/996q8o/prepare_thy_pitchforks_a_de_facto_standard/ 
I'll note that you are essentially agreeing with me :)
Not sure what you mean. 
Hmm no that's not such a great idea. Merging half of networking is worse than merging nothing at all.
Very nice! What's the enable_dedicated_gpu about? I didn't know this was a thing. 
https://xkcd.com/927/ 
Why not use the sequential algos then though?
Any progress on relocation and value exceptions? 
I've tried non-standard versions (GSL, abseil) on a few different projects. It's definitely odd, and there's a lot of casting when interacting with other APIs. I figured the type-safety was worth it, but lately I wonder if it's just simpler to use uint8_t. I wonder if it's even possible to improve the interface without defeating its purpose.
Libraries are not standards
I understand the copious casting but which operators did find lacking? I've only encountered friction when working with other APIs that speak `uint8_t`.
The way the parallel algorithms wording works (for some of the execution policies, at least) is to remove the normal sequential sequencing constraints between executions even within a single thread (http://eel.is/c++draft/algorithms.parallel#exec-6.sentence-1), so you can get an unsequenced access and modification to the same variable from two different executions in a parallel algorithm, resulting in UB. You're right that that's not formally a data race because the actions are not potentially-concurrent, but the effect on implementations is the same (note that http://eel.is/c++draft/basic#intro.execution-10.sentence-4 and http://eel.is/c++draft/basic#intro.races-20.sentence-2 are essentially two halves of the same rule, and that the within-a-single-thread case is actually stricter). That the executions in a parallel algorithm with execution​::​parallel_­unsequenced_­policy are not considered potentially-concurrent seems like it might be a wording bug to me.
It's not "bad" but you have to know what C with classes was for me not to be peeved by the suggestion. C With Classes basically had constructors and destructors. And that's it. No virtual functions, no templates, no overloading, no namespaces, no const, no new/delete, no references. But yes, there's nothing inherently wrong with avoiding C++ features. Part of the design philosophy of C++ is that you as the programmer are empowered to use the subset of the language you want. However, the reason C++ has many of the features it does is to provide better and less error prone ways of writing code. You leave a lot of enhancements on the table, but if that's right for you, then write code that way. I wouldn't want to join your team if *new* code was being written that way, but that's just my opinion.
Nope
It looks like you are right, since I couldn't find in cppreference.com I assumed that they weren't added but looking at the paper again, it seems at least some of them are there (filter, transform, iota, split ...)
It seems the paper tries not to touch those cases,
Bless you
This approach is similar to be using a struct with different types right? Like a vector of structs?I thought the question asked me to do something with dynamic array making
Indeed, a vector of variant or a vector of tuple would do the job.
Nope i am not sure of it. The paragraph below the question is the entire question provided to me,and i don't know what exactly they expect me to write.
Your question is about a 3D mathematical vector, not a dynamic array. My recommendation would be: your `Vector3D` class should be a template so it can hold any arithmetic data types.
I didn't understand the question, so my answer is not related to your question. sorry.
template class MyVector&lt;typename T, U, V&gt; { public: T x; U y; V z; } ? 
Again: are you sure your question is about dynamic arrays? I don't see any mention of that. If you want a dynamic array of many `Vector3D` types, then yes you'll need an union or something like that.
You should post these kind of questions to r/cpp_questions. You can address your 2D elements probably like this: Grid[x] [y]. Then you just assign whatever character you use as. Cursor to the space you want by using the assignment operator. 
The above paragraph in the post is the complete question and yes there is lack of data in it.Thats the reason i got confused and wondered whether a dynamic array could be made to have different data types.
Is the compiler really required to detect all instances of UB in the library, even if it doesn't cause actual UB in this particular implementation? That would mean that the compiler had to know the specification of every standard library function that is marked constexpr. I find that highly unlikely. 
I would advise someone such as yourself, who seems very keen on future participation in WG21, to learn a bit more about how we operate before throwing bricks in public.
Got it thanks.
There are two separate ideas in your post that are getting confused: In C++ (and some other languages) the word "vector" is often used to describe a certain type of dynamic array that resembles the "std::vector" class. A "3d vector" is a geometric concept, it is used to describe movement from the origin in 3 dimensions and includes the 3 values needed for that movement in 3d, x, y, &amp; z. There is some overlap in the two definitions, but usually you wouldn't want to implement the latter using the former. A 3d vector has a fixed size, while an std::vector style vector is by definition dynamic. There is no reason to use an std::vector style vector to implement a 3d vector unless the amount of dimensions your tracking is changing at runtime. A 3d vector is best implemented using a class with 3 member objects or a short fixed size array.
I like this, but i know that many dispise it as it's too close to identifiers starting with an uppercase, prefixed with an underscore that is "reserved"
Oh sorry, i misunderstood you, if its a 3d vector the i should be implementing math functions .Just now realized, thanks for clarifying.
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9w50op/cursor_in_array/e9hnnm8/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9w4w7i/weird_question_is_it_possible_to_make_a_vector/e9hnqbh/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Generally, no (http://eel.is/c++draft/expr.const#2.sentence-3). The difference here is that the UB doesn't happen in the library, it would be core language UB that happens in user code that the library calls back into (http://eel.is/c++draft/expr.const#2.6). That's not a fatal problem -- we can change the constant evaluation rules to avoid requiring such checks.
Didn't read the paper yet (just glossed over it) but I didn't quite get the relation between regular/`constexpr` C++ functions and `consteval` ones. I.e. are name clashes allowed? If so what would be chosen between `constexpr foo() {...}` and `consteval foo() {...}`? If not, this still doesn't solve `overload on constexpr` problem (though maybe it's now solvable by other means, i.e. `std::is_constant_evaluated`, need to investigate). 
1. YES (the sun will go supernova in some billions of years) 2. YES (popularity is a very important metric) 3. SUBJECTIVE 4. YES (especially C++11 and later!) 
I didn't until I saw your comment. Tend to ignore stickies lol. Thanks :).
I think one of us misunderstands the other one: If the constexpr implementation of a parallel algorithm doesn't use any multithreading, but essentially just forwards to the equivalent "normal" algorithm, then how can this result in any core language UB beyond what would occur in the pre-c++17 algorithms, that now become mostly constexpr?
The title is intentionally clickbait :) The paper doesn't actually propose deprecating volatile, just the parts that nobody uses, like - Volatile parameters - Volatile qualifiers on functions SG1 signed off on the paper, and they do care about volatile so don't worry.
Not that I know of. I'm pretty sure that's intentional, since we are currently focusing on C++20 and there's no way this makes it in.
&gt; "Is there any possibility there will be a better alternative in the next 10 years (given the possibility of new research and new hardware)?" By that logic `std::unordered_map` should not be in the standard. I guess it's being kept not to break existing code.
Thanks!! I'll remove my own post now 
well, even simple stuff like this does not work : void pad(std::byte* p, std::size_t n) { for (std::size_t i = 0; i &lt; n; ++i) *p++ = '\0'; }
but why would the std version be any better than just using the actual ranges library ?
I hope it will be.
I think you're thinking in terms of the behaviour of some hypothetical implementation, whereas what I'm talking about are the language rules. The standard says that certain evaluations are unsequenced, and that affects what behaviour is defined when those now-unsequenced evaluations conflict. And the constant evaluation rules would (currently) require enforcing this consequence of the language UB rules in this case. So your hypothetical implementation would not be a conforming one unless we relax the constant expression evaluation rules to not require detection of this particular form of UB. In practice, to conform to these rules, a constexpr library implementation of parallel algorithms would need to (somehow) inform the compiler that some of its subexpressions should be evaluated unsequenced. And the compiler would then need to check whether there are any conflicting memory operations between those unsequenced subexpressions. I don't think it's clear that that's worthwhile: on the one hand, detecting UB is a feature of constant evaluation (and people do sometimes use it to detect whether certain operations are UB-free), but on the other hand this would be a large implementation burden for little gain, and as we have already discussed, you lose the guarantee that all UB is detected when you call library functions anyway.
Many companies don't allow using libraries outside of the standard.
It exports AmdPowerXpressRequestHighPerformance and NvOptimusEnablement in your program, symbols which are detected by AMD/NVIDIA GPUs. You can read more about them here: https://gpuopen.com/amdpowerxpressrequesthighperformance/ and https://docs.nvidia.com/gameworks/content/technologies/desktop/optimus.htm .
Seems reasonable. Thank you very much. 
There are definitely people who think it was a mistake to standardize `unordered_map`.
Haven't considered this. Thanks.
My point is that "C With Classes" was a thing. It did not include `const` before the project was renamed to C++ in 1983 (And even then, C's `const` (added in C89) is not the same as C++'s). Calling it "C with Classes" to me implies pre-83 C++, but this is clearly not what people mean when they say "C With Classes" and everyone seems to mean something different by it. Maybe a better name would be "procedural C++"? But does it include RAII? Is that _too much_ C++? Copy construction? Const correctness? Virtual functions? And like I said, C++ was designed to allow the programmer to choose the paradigms and features that suit them. There's no dogma built into the language's design. If you're restricting yourself to a subset of the language, it's still C++. I don't agree with your subset, but it's your code, not mine.
P0784 provides for both constexpr destructors and allocation/deallocation. Interestingly, implementation-wise support for destructors is the hard part; the allocation/deallocation part was actually rather trivial. 
Everyone is going there :)
Why should it be? Let's say that the only thing beyond what my example shows (a blocking iostream that takes a domain and a port) that we add is the ability to contact an ip-address directly. I conjecture that this covers about 50% of the use-cases. It does not block any later additions to cover the other 50% so the only thing it achieves is to make live miserable for everyone who would be fine with something that at least covers those simple cases. If you give me a tls-socket I am able to create multiple of those in different threads to create something that appears asynchronous, but I'm not able to do so portably if all I can do is read/write from/to stdin/stdout and files which is the only interaction that is possible with the environment in ISO-C++ as it stands now. Also: It's not like a network-library without TLS is complete. TLS is more or less quickly turning into the 80%-usecase but I'm sad to say that I don't see that it is going to be added to the language in any remotely reasonable amount of time. So if we get an incomplete library anyways, why shouldn't we at least get the parts that are completely usable earlier? (Also, I just checked: If the addition of TLS takes as long relative to the release of SSL 1.0 as the addition[1] of network-support takes after the introduction of the internet (see, I'm even generous here), we won't have it by C++41.) [1] in the optimistic scenario; I still won't believe that before that standard is published
I decided to make a build2 package of it (it's already available to conan), see: [https://github.com/Klaim/build2-plf-colony](https://github.com/Klaim/build2-plf-colony) It is in the submission queue of [cppget.org](https://cppget.org) right now and should be made available soon: [https://queue.cppget.org/plf-colony](https://queue.cppget.org/plf-colony)
There is no established practice or field experience with a stripped-down Networking TS. Trying to split it so close to the publication date of C++20 is risky and reckless. Perhaps such a split could be baked in time for C++23. Hopefully by then we will have networking. As for TLS, I doubt it will ever become part of the standard, because if you think the IS is big, can you imagine how much wording would be required to encompass all the behavior of OpenSSL? It would be a pointless exercise. Asking a bunch of standard library implementors to also become experts in cryptography is really not a great ideal. What we need is to have a good packaging / dependency system to make it completely painless to use external libraries. There is nothing about TLS that requires standardization, except for the synchronous and asynchronous stream concept interfaces, and those are already in Networking TS.
No one doubts there's utility in the data type, only that the utility justifies standardization. I'm doubtful.
:D
Not arguing there, just pointing out the facts. It would be nice if we could do `function_name(arg_type arg_name) -&gt; return_type` without the leading `auto` but this is the world we live in...
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9w5tmq/what_laptop_would_be_best_for_c_programming_and/e9hwr5e/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Of course, and I put that link at the top of my TL;DR. It is great, but more for language designers instead of developers. Some good examples for language release notes are from [Rust](https://blog.rust-lang.org/2018/06/21/Rust-1.27.html) and [Go](https://golang.org/doc/go1.11 ), which spend most of their words on *how* to use them with a minimal example. Most developers won't spend a bunch of time extracting examples or finding *why*/wording changes in the proposal. I wish there would be a not-so-hardcore version so that I can share it with my colleagues. &amp;#x200B;
I'm afraid I don't have enough time, but you can click the "edit" button to update that page.
Wolf Vollprecht also made an [excellent contribution](https://medium.com/@wolfv/the-julia-challenge-in-c-21272d36c002) to the [Julia challenge](https://nextjournal.com/sdanisch/the-julia-challenge). What's interesting to me is how xtensor does not speed up the Julia version; i.e. native Julia performs as well as the C++ version here. So if there is no real performance to be gained in Julia using xtensor, you better write native Julia code :) that way you can make most of Julia's type system, generics and packages. ``` ║ Language ║ Time (s) ║ ╠══════════════════╬════════════╣ ║ C++ ║ .0164812 ║ ║ Python / xtensor ║ .0220982 ║ ║ Python / NumPy ║ 14.224207 ║ ║ Julia / xtensor ║ .014221 ║ ║ Julia ║ .014501 ║ ║ R / xtensor ║ .01328 ║ ║ R ║ 9.905 ║ ```
Construal functions are surprisingly interesting from a language perspective. I’m curious to see how they’ll be used (besides reflection, which is why they were proposed). 
The papers are what was submitted, no translation or reformatting. I'm worried more about the long term on html since they may not be self contained. I share your frustration on PDF and mobile. 
Full agreement. We don't need a standardized facility that no one should use just to fill a check box on a marketing sheet. (Looking at `std::thread` and std::async` for no reason at all...)
What makes you think they even have a JS frontend?
Yes, they do. At this point my sense is that there is overwhelming support for it in plenary. The gating factor is getting all the wording reviewed and refined. On Saturday afternoon (after plenary) several core members worked an additional number of hours toward that, and plans are in the works for remote reviews between now and Kona 2019.
&gt; There is no established practice or field experience with a stripped-down Networking TS. Trying to split it so close to the publication date of C++20 is risky and reckless. Perhaps such a split could be baked in time for C++23. Hopefully by then we will have networking. If it's broken as a standalone solution it would be even more broken if put in with the entire remaining library. But this rationale is precisely why I don't believe that we get network in C++23 either: Somebody will question whether it is actually good, which will be followed by another pointless 3 year-wait that won't result in actual changes (see `std::optional`). &gt; because if you think the IS is big, The library-portion of the IS is **embarrassingly tiny**! If it had ten times the size (assuming that the additional stuff is actually useful and not just there to increase the size), it would be closer to where it should be. &gt; can you imagine how much wording would be required to encompass all the behavior of OpenSSL? Not too much: You just put something along the lines of “socket that uses TLS 1.3 as described by [insert technical name of the standard]”. The only thing that you would need besides that would be support for certificates, of which the vast majority of the wording could be done in a similar fashion. It's not like networking on it's own wouldn't have to point to external standards. &gt; Asking a bunch of standard library implementors to also become experts in cryptography is really not a great idea. If they don't want to implement it have them wrap whatever library is available on their system, whether it is openssl, libressl, gnutls or whatever windows/mac use, similar to how sockets are approached. &gt; What we need is to have a good packaging / dependency system to make it completely painless to use external libraries. Now you are asking for something that no language has got right even remotely. It's not enough that such a system appears to work, you have to ensure that the packages are all distributed securely, which pretty much requires some form of a network of trust (see how great that worked out with GPG) and getting all developers to employ code-signing. In fact: The main-subject of my masters is cryptography and I'm not sure how to do it rightly. Unlike adding TLS, this is a REALLY hard problem that has not been solved so far. (And this is even before considering the fact that most C++-libraries lack severely in API-quality.) &gt; There is nothing about TLS that requires standardization, except for the synchronous and asynchronous stream concept interfaces, and those are already in Networking TS. Following that rationale we also wouldn't need `std::vector`, `std::unordered_map` and all of the algorithms-library, as the mere concept-interfaces would be enough.
I'm far from an expert, but I think you're right. Volatile helps to "find a easier solution" when we try to implements something that our model doesn't fit very well... Still, I'm not so sure if it needs to be removed or if the developers should avoid to use, but if needed it's still there as an option.. I'll keep track in this thread to see what others thin about it. 
No, but the current standard-mandated implementation of them is horribly slow in light of research in the recent years.
Write a paper ! More seriously, there is a lot of interest for that, but it's a long road. My shallow understanding is that magic read/write functions should go a long way. It would also help the transactional TS 
Can I define user-defined literal as `consteval`?
Is it not possible to improve implementation while maintaining the behavior?
Surprised in what way? “Constexpr parameters” is a world of hurt in a syntactic / type-system sense. A possibly more interesting avenue for that might be the core of the “parameterized expressions” proposal. 
As an embedded developer, I use volatile every day. Volatile definitely has its problems and simply replacing it with 'iomemwrite32(intptr_t address, uint32_t value)` style functions would probably fix many common problems with its use. But any change like this would be breaking change so it isn't going to happen anytime soon. (Maybe if we got modules and some kind of language feature selection functionality)
&gt;Unsurprisingly Rust is quick to take credit for things they didn't invent. Can you provide the source showing that the people behind rust are taking credit for inventing something? Or are you just full of shit?
Can I use `constexpr` function arguments as constants in `std::is_constant_evaluated` branch? Like `consteval`.
I think you misunderstood the paper: consteval functions are never evaluated at runtime. (That’s their raison d’etre.) A back end won’t generate code for it. In that sense, they’re also a useful alternative to some macros. You’re exactly right that constexpr parameters are in fact template parameters. That means that introducing them turns a function into a function template, which is a whole different beast: dependent constructs, no address, bizarre relation to instances (unexpected number of parameters), etc. 
The modules proposal now has a notion of “legacy header module”: import “my-well-behaves-header.hpp”; Those can import macros, but those macros don’t affect the content of imports.
Zero hope for 20 -- there's just too much to be done first. The priority for reflection after that is static reflection via constexpr and reflexpr.
No one uses std::thread? 
You can guarantee that only certain "exposed" functions are callable at the language/compiler level, but if you're trying to sandbox the AoT-compiled machine code you have to isolate the code entirely from the containing application. The same goes for limiting available memory: if the AoT generated machine code can just invoke syscalls or call into system libraries, it can allocate all the memory it wants without the host VM being able to effectively monitor or limit the sandboxed module. An option is to look into the techniques used by technologies like [Google's NaCl](https://developer.chrome.com/native-client/nacl-and-pnacl). They discontinued development for Web-app purposes in favor of WebAssembly, but the general techniques are certainly still valid. The gist is that they found interesting ways to use the features of the x86, x86_64, and arm instruction sets in order to sandbox memory access; this is combined with a specialized compiler and accompanying instruction verifier that ensures only "safe" instruction sequences are in use (for example, `RET` instructions are problematic because they load whatever address is on the stack, which can be abused; the special compiler instead replaces `RET` with a `JMP` into a special instruction sequence that first verifies that the return address is in the sandboxed module, and the instruction verifier ensures there are no `RET` instructions in the module). A few people are pointing out that you can just do what WASM itself does, but I'd just point out that there's certainly value in AoT compilation for some domains. You mention it's just a toy compiler as well, and learning how to sandbox untrusted AoT is a valuable learning exercise for "toy" uses. :) The trick of WASM implementations is to actually distribute modules in a more abstract assembly language that is then still JIT compiled into real machine code. Because authors can't generate machine instructions directly, the runtime can maintain confidence that (sans JIT bugs) the modules cannot break out of the sandbox: all memory accesses are bounds checked, no syscalls are present, no dangerous instruction sequences, all FFI goes through the property security check layers, etc. This is actually pretty much the same as the PNaCl variant (portable NaCl, which used LLVM-IR instead of machine instructions in distributed modules) in concept though the implementation specific differ. It's useful to note that everyone went to WASM because of a combination of standardization and the fact that WASM could be implemented as a thin layer on top of the existing JavaScript JIT engines and run-times while NaCl required its own extensive supporting infrastructure; if you aren't starting with a powerful JS runtime, there's not _necessarily_ a reason to prefer a WASM-like approach over a NaCl-like approach. There are of course pros and cons to each, though.
Late 2017 through now has been a busy time for me. I retired from GE, started a new job, built a new house, and have been generally distracted. Now that the house and landscaping is is finished and I've settled into the new job routine (and winter is coming) I plan to get back into ELLCC development. It's kind of funny, the reason I stumbled on this was it caused the [ellcc.org](https://ellcc.org) website to get a bunch of hits.
It looks like accessing ellcc.org by `https` is broken.
By some measures C++ has never been more popular. C# may have been able displace it a bit but didn't really. Java has a bit but not hugely. Javascript is a different beast and will not. Managed languages don't replace C++ because, at least for Java and C#, what they manage is memory, and that is only one part of the puzzle. If you need to manage database connections, network connections, file handles etc, you need to deal with explicit resource management just like with memory in C++. The evolution of C++ in recent years has been of huge benefit to the language so, no the standard is not in bad shape, it's probably never been better. Bloated you could argue, since removing old features will always be a challenge, and making sure newbies learn modern rather than Pre-millennial c++ is always a challenge
My understanding is that `is_constant_evaluated` is going to be the only tool in C++20 to deal with "overloading on constexpr". `consteval` is its own world of compile-time-only functions and won't be interacting with constexpr in clever ways.
https is on the list of things to do. That and switching to git, simplifying the build process, better unit testing, ... Lots of fun stuff.
It's a trap. You frequently need control over the OS, like stack allocation and guard pages, in construction of the thread, and there's no portable facility for it. But letting \`std::async\` just launch threads is even worse. You need a resource manager. MSVC provides one, IIRC, and runs std::async on a thread pool OS primitive, but even that is hard to control. And you find all this out after getting \`std::thread\` all over your code, and unwinding it is hard. I don't have a solution, but I do know that people have their own thread types. Also I managed to disconnect this from the discussion, so it's missing a lot of context. This was supposed to be in context of subsetting the network TS, leaving out key parts leaving it as something that can't be used in serious work. I believe that the \`std\` facilities should be good for at least 99% of uses. Something that is only of use for examples, slides, and helloworld.cpp, isn't good enough to go into the standard. Now, I don't think that \`std\` should only have things that 99% of users need, but I also don't think we should be using \`std\` as a package management system so that the 0.1% of users that need a facility don't have to download it from elsewhere. That's trying to solve a social problem with technology. We should work on fixing that problem instead. Including, in particular, reported legal problems with using non-std libraries. 
I keep seeing people say "half the time" - but no one giving metrics - or more importantly comparing it to PCH times.
I don't even think about them... I just put in some third party cmake library and they magically worked.
no, because the unordered_map API mandates a specific implementation, node-based (https://en.cppreference.com/w/cpp/container/unordered_map/extract)
Mix boost with std for best chances. Yes, ADL can be a real problem actually. Remember that #includes include recursively and much code you did not expect can end up indirectly inherited. 
I don't have a horse in this race, but as points to consider: Deprecation isn't removal. If this were to ever happen, it would likely have a decade or more of time between "we deprecate and start recommending developers move off of it" and "the standard removes it." Then maybe another decade or three until "vendors remove support for it entirely." Especially with tools like `clang-tidy` or the even better tools we hope to exist by that time, upgrading legacy code bases will hopefully be a relative breeze. And if it's not, that deprecation would not _actually_ turn into removal; the deprecation can even be reversed if it doesn't pan out as well as the committee would like.
I use it often. Why is it hard to teach? It is a variable which value is always read from memory. 
Wouldn't separate read/write functions would incur more overhead, though? That might not be desireable especially on embedded systems. Pushing, writing to the memory address, and popping is much slower than just directly writing into a memory address.
[is_constant_evaluated source](https://github.com/daveedvdv/WG21/blob/master/is_constant_evaluated.html) 
Yes. 
I’m not sure I understand the question. A code example maybe?
1) No. There are more C++ conferences in 2019 than any year before; there are more talk submissions to those conferences than they could possibly fit in their schedules; the last C++ Committee meeting accomodated more people, to read and work through a record number of papers submitted for it. What would make you think it's dying? 2) That's a double question. It is more popular than in the 2003-2008 timeframe, and its popularity seems to be growing as per 1). In very few of the targets can it be replaced by Java, Javascript or C#, and in some places where those latter are being used C++ is a serious alternative again - so maybe the opposite there? 3) That's quite the slanted language use there. What makes you think a managed language is modern? I'm going to argue the opposite - a "managed" language is old-school. We've tried it and we've found it very much lacking. Did you ever wonder why your "managed, garbage collected" language makes you use `using` now? Which is basically what C++ has done for the past 20 years? It's just a better way to do resource handling and destruction - deterministic, rather than "at some point. Maybe. Unless the GC is having a bad hair day". C++ has tons of uses - I don't think any of those deserves to be called the "main" purpose. It's not like Javascript whose main purpose is to run tiny programs in your web browser, or like Java whose main purpose is to run Java applets. Or did both of those change their main purpose too? Gee - I wonder why. 4) Nope. The standard is much more nimble now that compilers (especially MSVC) actually follow it, as they can build on what's in the standard, instead of what's in there plus 10 groups of hacks on it. Compared to a language like C# that's had a few unfortunate evolutionary spikes, it's much more coherent and allows for more orthogonal use of features, giving you way more power in thinking up things that then actually work the way you thought they would.
If it wasn't standardised I'd rather write it myself ¯\\\_(ツ)_/¯
For an alternate design to compare against, [Rust's standard library](https://doc.rust-lang.org/std/index.html?search=Volatile) makes "volatile" a property of the read or write rather than a property of the value itself. That seems a lot less convenient, since in most cases a value should either always or never be accessed as volatile, but it does push people away from using it as an attempted solution for multithreaded communication.
[Yeah, that about sums it up.](https://i.imgur.com/PrzOTAp.jpg)
... and is mit optimized by the compiler. It's just useful for memory-mapped IO. Typically, nothing you teach to students unless they're somewhat advanced in the topic - and I don't think the concept of volatile is particularly hard to grasp...
Ah, no, that doesn’t work. n would have to be known at parse time, which is not possible here. This is related to the constexpr parameters elsewhere in this discussion. I suspect that the only viable class of mechanism for something like this would be a new kind of hygienic macros, perhaps modeled around the core of the “parameterized expressions” idea that was submitted in the San Diego mailing. 
Don't be stupid, that is unnecessary allocation in heap.
It's not very hard to understand at all. I was doing this when I was 14 and I don't like to think of myself as a genius.
could you provide an update on **unique\_resource** proposal? 
Essentially thats exactly what I would expect inside and implementation of a constexpr parallel algorithm. But yes, it is simple to do that on your own.
&gt; for both constexpr destructors and allocation/deallocation. Interestingly, implementation-wise support for destructors is the hard part; the allocation/deallocation part was actually rather trivial. Can you elaborate ab bit, what makes constexpr destructors so difficult? It's just a function call and the compiler should already know where to insert it for regular code generation. 
I think you're a very specific case.
You could make them be special functions that the compiler knows how to optimize. [This site](http://compileroptimizations.com/category/printf_optimization.htm) says that `printf` gets optimizations like that (although clang and gcc don't appear to on `-O3`). Could the standard mandate that the volatile access functions must always be inlined?
It's also a lot more flexible, since you can do volatile read/writes without forcing all reads and writes to be volatile (admittedly this is rare, but it does come in handy occasionally).
When the code must always read from memory there is no room for optimizations, so that part is already implied. 
But why would you introduce a character literal here when you're presumably working with a sequence of raw bytes? Why not: `*p++ = {}` or `*p++ = std::byte{};` or `*p++ = std::byte{0};` or `*p++ = 0x00;` // Not sure if this one works` ? If you're working with a sequence of characters rather than raw bytes, `unsigned char` probably does make more sense.
Ah good to hear :)
&gt; It's just useful for memory-mapped IO. More than that, even. If you use setjmp/longjmp or any other "synchronization" mechanism in your code, then you'll want volatile as well and it also has minor utility in signal handlers. &gt; and I don't think the concept of volatile is particularly hard to grasp... It's a fundamental property of an optimizing compiler, it _needs_ to be taught.
&gt; If you're working with a sequence of characters rather than raw bytes well, maybe it's just me, but most of the protocols I work with are textual with the occasional control character here and there, most of the time '\0' or '\n'. 
That compiler isn't an ISO c++ compiler then and likely doesn't care about what things get deprecated in the standard. 
go add yourself to the list : https://github.com/NoAvailableAlias/signal-slot-benchmarks/blob/master/results_gcc/README.md
That's awesome. With ranges and lambdas, algorithms will finally be usable in a really friendly way :)
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9w8t8p/some_good_books_for_learning_and_using_cpp/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
What if that YATOM is just better?
Thanks for the links! Maybe you should include these in the header and/or an explanation of what they do.
IIRC years ago Boost had a lengthy discussion about Boost.GUI on their wiki about which approach or existing GUI toolkits to base on, which I vaguely remebered that no concensus were made and the tone sounded it never would. People were encouraged to try something like QT instead because of they dominance even though they were not following standard practices. Do correct me if I'm wrong.
Exactly my feelings.
I think you should take a closer look at the paper. As far as I understand it, it specially does not deprecate volatile for int etc. It’s more the member function overloads. 
Hmm. That’s sounds useful, but the earlier post implied sender/receiver provides equivalent functionality to future.then(...). But it’s not immediately clear how?
the whole constexpr thing is misguided. replace the whole mess with one simple rule: "Any pure function with arguments known at compile time is invoked at compile time and can be used in any constant impression." This would likely put a score of C++ committee members out of work so they could move on to more important stuff. If you really need to have a constexpr keyword use the rule: "Any function with the attribute "constexpr" can only be invoked with arguments known at compile time". &amp;#x200B;
This. You don't need to be a C++ expert to produce good C++ content. If there is an opening for modern C++ beginner's youtube videos start making them. One of the best ways to become an expert is to teach others. 
I've indeed used it simply to represent and pass around opaque data blobs. I don't think it has much utility beyond that to be honest. I just like it because it makes it clear that the data is meant to be opaque and explicitly isn't a character sequence. That's an interesting protocol there that mixes ASCII and binary data in the same stream.
That I can agree on
Nice. Just gotta make some things and put yourself out there man, you can end up in a good job if you make the right moves
If Networking enters the standard in 2026, Christopher Kohlhoff can really say that it took 20 years for C++ to have a standard network library. [2006： Networking Library Proposal for TR2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2054.pdf) The history of other languages is not necessarily so long, such as the go language has only been 9 years of history, but its standard library is extremely rich, such as Http/json/ssh/crypto. 
Yeah, that seems wrong to me; I use `std::thread` all over the place (well, on the inside of higher-level job and concurrency libraries, anyway). It is missing some key features necessary for certain domains, though. Stack size control, affinity, debug names, etc. All can be added as extensions.
Which is worth pointing out is a requirement for meta-classes to function well. Meta-classes (done right) is just syntactic sugar for a functional type constructor. Anything like `$foo bar {...};` could be done with `using bar = unreflexpr(make_foo(reflexpr(struct{...})));` (made-up approximation of real syntax). The machinery for all that must exist first. _Then_ the syntactic sugar to make it pretty and easy to use can be hashed out.
It's likely to be optimized in this case though, the compiler notices you just make a copy from A to B then from B to C without touching B.
Haha. I get that pain, but then let's be honest: changes and deprecations in the new standard are utterly irrelevant to you if you're not using a compiler conforming to that standard. We can keep evolving C++ for the rest of us while the unfortunate few are stuck on older or forked versions of the language. The questions we should be asking are whether those developers make up a significant minority and - if so - how we get them back into the standards flock. :)
Volatile indicates that a variable must be accessed directly. The original purpose is memory-mapped devices, used heavily on embedded systems.
That's my goal. Just have to work hard.
Don't claim "high performance" and not provide benchmarks against other libs.
Oh cool. Let me take a look at this tool. https://github.com/dascandy/evoke/blob/master/evoke/src/Executor.cpp#L66 Nope, I don't think so.
You did that at 14? I feel really dumb now..
The paper clarify that futures can be thought as matching Sender (more or less), promises kind of match Receivers and doing \`next\_fut = future.then(func)\` (which in the previous proposal was implemented as \`next\_fut = executor.then\_execute(future, func) \`) would be equivalent to : \`executor.make\_value\_task(future, func).submit(next\_receiver)\`. The paper is super clear about the equivalence from the beginning so I encourage you to read it: [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1194r0.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1194r0.html) &amp;#x200B; The only hard part is understanding the work on executors on which it relies to understand what it tries to do exactly (as Eric explained). It's splitting \`future.then\` into 2 distinct operations: the first stores the continuation to be invoked if we still need the result, the second setup a receiver (a set of receiving callbacks, basically) to handle the result. The efficient part, if I understood correctly, is that if you don't have a receiver, then the continuation code do not need to be executed.
True that it didn't lead anywhere, false that there was any kind of consensus on Qt. &amp;#x200B; There was also points that a Boost.GUI would be useful but more like a bridge for several different implementations (based on current guis) not as a full fledge new gui. A bit like Boost.Filesystem, Boost.Log or Boost.Locale tries to be a better interface for some existing system/external libraries.
bugs are off topic for /r/cpp post a bug report to the appropriate vendor.
Lol I did really bad in school though, I just chose to do programming stuff instead
I don't know why you'd need to use volatile in your typical DLL injection/code hooking scenario. Your hooks are either thread-safe and have no use for it or they're not, in which case volatile isn't the correct choice.
Make sure you reach out and contact people too. Usually they'll give you a response if you can get in touch with them directly. Look for small businesses; ask them for a project to prove you have what it takes if they don't believe you, that's what I did. They basically have nothing to lose from that end. Of course some will say no, but you can find someone who will give you a shot. Even if you don't get the job, you now have a nice thing to put on your resume and it would be a learning experience anyways.
Please don't post libraries that there are already a large number of without any description of what differentiates this one from the others.
# Beginner-level (rationale + example) **Recommended** * [CppCon 2018: Bjarne Stroustrup “Concepts: The Future of Generic Programming (the future is here)”](https://youtu.be/HddFGPTAmtU) * TODO: Andrew Sutton's CppCon 2018 talk not yet published * [Pacific++ 2018: Sean Parent "Generic Programming"](https://youtu.be/iwJpxWHuZQY) * [Concepts: The Future of Generic Programming or How to design good concepts and use them well](http://stroustrup.com/good_concepts.pdf) * [Prepping Yourself to Conceptify Algorithms](https://www.cjdb.com.au/blog/2018/05/15/prepping-yourself-to-conceptify-algorithms) (my blog) * [Transforming `std::find` into `std::ranges::find`](https://www.cjdb.com.au/transforming-std-find-into-std-ranges-find) (my blog) **Other** * [ACCU Introducing Concepts](https://accu.org/index.php/journals/2157) * [ACCU Defining Concepts](https://accu.org/index.php/journals/2198) * [Andrew Sutton's C++Now 2015 Keynote: generic-programming-with-concepts](https://youtu.be/_rBhX-FJCdg) * [CppCon 2014: Andrew Sutton "Generic Programming with Concepts Lite, Part I"](https://youtu.be/qwXq5MqY2ZA) * [CppCon 2014: Andrew Sutton "Generic Programming with Concepts Lite, Part II"](https://youtu.be/NZeTAnW5LL0) * [Concepts TS and Ranges TS extension notes](https://github.com/cjdb/cpp-conferences/blob/master/cppcon-2016/concepts.asciidoc) (written by me when I first started out, heavily out-of-date, but it'll get you setup, which I don't recall the others doing) # Intermediate-level * [Design of Concept Libraries for C++](http://stroustrup.com/sle2011-concepts.pdf) # Expert-level (some rationale, mostly example): * [A Concept Design for the STL](https://wg21.link/n3351) (use for its rationale only) * [Ranges for the Standard Library, Revision 1](https://wg21.link/n4128) (use for its rationale only) * [Working Draft, C++ Extensions for Ranges](https://wg21.link/n4685), Ranges TS (uses Concepts TS concepts) * [Standard Library Concepts](https://wg21.link/p0898), C++ standard library concepts (uses C++20 concepts, merged with C++20) * [The One Ranges Proposal](https://wg21.link/p0896), merges the rest of the Ranges TS (uses C++20 concepts, merged with C++20)
A different syntax does not necessary require inefficient code generation. Compiler intrinsic functions (i.e. builtins) need not have any more overhead than a write to a volatile variable. E.g. memcpy often compiles down to trivial code with no function call overhead.
&gt; It is understandable to try to save the multi-year work It would also be incredibly tragic to see it refined for another N years only to be rejected yet again.
Very interesting, thanks for the answers.
&gt; we don’t throw shrimp on the barbie I'm glad I'm not the only Aussie living overseas who has to dispel with myth constantly. &amp;#x200B;
And more interestingly, the compiler can also recognize common code patterns (such as a for loop that copies) and convert ut into a call to memcpy which is often hand-optimized for your instruction set
thx for getting my todo and trial list long and longer :)
volatile is just an API. We can have any other API to do the same thing, because volatile is horrible API, especially for C++, the way it is introduced (as modifier). I don't say we get rid of volatile access semantics (this is impossible!), but of the modifier as an interface to that access.
The title of SG19 sounds over specialized and unrelated to c++.
This is more "one expected effect" then definition. The definition itself is extremely vague and as result was a subject of interpretation for decades. Mind you, I am not against it (its definition or semantics), but it must find its way away of the top-level C++ into good low level lib.
&gt; By that logic std::unordered_map should not be in the standard. This is a true statement which I wholeheartedly endorse. `unordered_map` should not be in the standard.
Why are you still looking forward to it? We don't know if we will standardize it. 
What is YATOM
Really would like to see Network TS to go in right after C++20 IS to secure it for the next IS, just like Concepts after C++17 IS. That being said, it is indeed a really hard job to incorporate networking into C++. Yes ASIO has been around for a decade and became the de-facto standard long ago. Still, new programming paradigms show up and people want them to be usable by ASIO: from callback, future/promise, to coroutine, Network TS has been forced to evolve along the way. People are frustrated (including me), but let's hope for the best.
May I ask why you thought that would even be possible? The C++ committee has not committed to metaclasses. It is just an idea. It is not something we have agreed to pursue.
[https://github.com/CppCon/CppCon2018/blob/master/Presentations/the\_bits\_between\_the\_bits/the\_bits\_between\_the\_bits\_\_matt\_godbolt\_\_cppcon\_2018.pdf](https://github.com/CppCon/CppCon2018/blob/master/Presentations/the_bits_between_the_bits/the_bits_between_the_bits__matt_godbolt__cppcon_2018.pdf)
&gt; But being able to tell the compiler in a standardized fashion that a pointer is aligned is of course more important It certainly is.
I am a simple man. I see Matt Godbolt, I upvote.
Rather than see it as an implementation/library solution, can't it just be viewed as a variant of a std::vector that doesn't invalidate iterators and doesn't have contiguous storage? The fact that it has fast deletion/insertion is a bonus?
C++ has paid an hefty price of having OS vendor specific frameworks, to the point it is hardly an option of plain app development. Naturally it doesn't help that the two biggest mobile eco-systems don't support it as first class language, only for some low level components. Ironically on Android and its watch/IoT variants, it isn't even possible to do networking without Java help, as the APIs that control network access aren't directly exposed to the NDK layer.
Not only for memory mapped IO. Also for cases where interrupt handler or higher priority thread might change a value.
Almost everyone who wrote for DOS back in the day had to deal with hw registers and interrupts.
You’re definitely not supposed to use volatile in that scenario.
¯\\\_(ツ)_/¯
Here is an example: https://gcc.godbolt.org/z/mhiEGD Both gcc and clang optimize the call from printf to puts.
Louis has great points about those. The first is an answer in the tweet, as soon as you do that somebody will depend on your API at compile time, and now you have a whole new set of possible breaking changes that you have to keep in mind. To the second point, just imagine: you have a function "constexpr add(x, y)". What happens when you want to call it with non compile time arguments? (Ctrl+c Ctrl+v?). Now, I pretty much agree with you the current situation isn't good, and there must be a better solution, but given these points I agree it's not as trivial as you might expect.
But.... but this would make C++ less complex and messy???!!!
It is easy, basically don't use a C++ compiler to write code that looks like it could be easily compiled by a C compiler, there are better ways to write equivalent code, while being safer at it.
&gt; higher priority thread might change a value That would be a race.
Which is why sometimes you have to use volatile to avoid that race condition.
&gt; referring to C and C++ as a single thing called "C/C++" What a rubbish bin of an "article".
Clickbait is alive and kicking though it seems 
Do you have a replacement for it? Or is absolute perfection the only acceptable thing?
&gt; we’ll change std::span’s size return type from signed to unsigned So common sense has finally prevailed. Thank you. Now, please, while there is still some common sense in the air, consider making `std::expected::operator*` throw.
Has anyone ever defined "unsafe language"?
a language where "Hello World" could wipe out the universe?
The reason why standards seem bloated is because people tend to assume that their needs are representative of everyone else's needs.
An article written in 2017, in which he basically complains that people don't write web applications in C++. It's fine, I think it's fair to say that the language is dead to him, thank goodness he's not the judge for all computing everywhere. As a fierce critic of some aspects of C++, I can understand where he stands, but I think that the fact that he felt like writing an eulogy for C++ only means that the language is not as dead as he wants it to be.
A hypothetical "Yet Another Take On Modules".
Tbh, I'm not really familiar with the standardization process, so I was judging only by relevant papers present(e.g. P0578, P0707) on open-std and loosely following [asutton/clang](https://github.com/asutton/clang) implementation. I'm really looking forward to this feature because the codebase I'm currently working on would really benefit from not having a custom code generator - it's a real pain to maintain. I understand that proposed papers could possibly be rejected, though as /u/SeanMiddleditch mentioned, metaclasses seem like a logical extension of static reflection. Do you think there's a good probability that metaclasses won't make it in the standard after all? 
Reminds me of this talk:[https://www.youtube.com/watch?v=AF\_Zuto9CkE](https://www.youtube.com/watch?v=AF_Zuto9CkE)
I'm having serious doubts of running a code on my build system where you can people struggling on how to initialise a vector. This has nothing to do with perfection.
He's getting superlinear speedup. That's suspicious. Also not using the correct OpenMP pragma, so I'm not sure if he's actually using OpenMP. If you do this with the intel compiler it inserts its own parallelization. &amp;#x200B;
Other than C (WG14) voting in favour of C mirroring it in principle, nothing for San Diego, it wasn't even discussed. It *may* even be the case that it won't be discussed at Kona depending on its schedule and how much time needs to go on finishing C++ 20, though right now the hope would be it might get discussed by EWG at Kona maybe.
(author here :)) what's the correct openmp pragma here? the system has also hyperthreading enabled, so that should give that extra speed I think.
Which bit of code is "struggling to initialise a vector"? I'm happy to receive constructive criticism, but your first feedback was "nope" - hardly constructive.
Thanks. I didn't look at the actual code. That superlinear speedup still bears investigating. Also I'm guessing that your default affinity setting are right, but set OMP_PROC_BIND=true just in case.
Click in the link in my original, unedited comment, and check the constructor Executor::Executor().
&gt; C++ traditionally puts the building blocks in the language, while the finished product is in the library. Some would say that numbers in programming languages ought to be a building block. Others would say they should not. The C family of languages have historically sat squarely on the fence on this, saying yes there should be numbers in the language, but saying little about their representation, their sizes, their behaviours in the corner case, and so on. So sure, I am proposing we move a boundary a little bit. But it's not that out of keeping for C. &gt; With your proposal, I am out of luck. With intrinsics, I can implement it myself. Sure, and I get that. Do remember the proposal is pointed at C, not C++. C is much more conservative than C++. &gt; I can live with a language solution, as long as the maximum integer size is something big Alas WG14 have made it clear that bigints larger than the maximum over-aligned size for that compiler and architecture won't fly. So, they'll be getting much smaller, and the maximum will vary by toolchain. "Yay!" I am sure you are thinking now ... I suspect my proposal and yours are going to diverge considerably from now on. I got extensive and detailed feedback to my draft 1 paper from WG14 (they are in the wonderful position of having relatively speaking lots of free time compared to WG21, so interaction over there is much higher quality in terms of useful feedback). Right now it's looking like my proposal will shrink considerably into a space between integral integers and big integers, a sort of "slightly larger than integral" integers proposal paper. It's still worthwhile for my needs and use cases, I suspect much less useful for your needs and use cases. Still, that's the standards process! 
\`constexpr\` is a contract with the users of your function. You don't want this contract to be implicit, otherwise you can't change your function to be constexpr-unfriendly once users have started depending on the fact that it is constexpr-friendly. Sorry, but implicit constexpr is a bad idea unless everything that can be done at runtime can be done at compile-time too. &amp;#x200B; BTW, I used to hold exactly the same view as you do until I spoke to Richard Smith.
No, that would prevent you from making non-constexpr changes to the implementation of any function appearing in a header you ship to users, because those could have started to use such functions in contexts that require constant expressions.
My guess: A language where undefined behavior can occur.
If we were to allow such uses with current compiler technology, constexpr evaluation would be incredibly slow. Imagine running the constexpr evaluation under Valgrind (well, similar).
This is not possible with current compiler technology. I don't know the details, but constexpr evaluation is currently performed by walking the compiler's AST, which makes it very difficult to implement any kind of control flow. I've heard very strong things about how `switch` was absolute hell to implement. If compiler technology for constexpr evaluation changed, this could become possible.
&gt; C++ evolves fast Ummm....
Some editors struggle when they try to insert soft wraps when the entire file is a single line. But your example is counter intuitive to me. What does your profiling say?
While C++ has found its markets, namely Fintech, GPGPU, OS drivers, AAA game engines, it also has lost its presence on consumer desktop/mobile app stack. Even Qt is now focusing on QML for new features when targeting new deployment scenarios. So in the context of mobile and consumer desktops, C++ is playing the role of OS critical performance components, with the upper layers exposed to app developers being done in other set of programming languages. Microsoft is the exception here with UWP having first class support for C++, while Apple supports it for device drivers (IOKit) and Metal shaders mostly, even Objective-C++ documentation is not that easy to find out, and Google goes to great lengths to force everyone to avoid touching the NDK as much as possible. Regarding Office lets see if Microsoft just doesn't decide to focus only on Office 365. 
Yes, I am talking about volatile member functions, not volatile in general - it has clear use cases. I still don’t follow the brief paragraph on volatile member functions.
We absolutely need peek() and poke() in C++ /s
&gt; In a way, it's a good thing that that code is so ugly. k
**YOU WONT BELIEVE IT: CLICKBAIT DEATH BY 2016!**
You know some of the ways to break out of a VM? Use that when you are not inside a VM and then run: rm -rf / And not you do not need --no-preserve-root, it's a 14 billion year old version!
This is a great series of articles, thanks for making tooling that makes creating these checks easier. An aside: the add network for you blog needs replacement. For a while it was serving a screen steeling pop up on mobile and I could not even read the article. I would just drop the ads, it de-values the content you make.
TL; DR; - parallel algorithms are not so great (comparing to omp). Taking into account you can do better than omp (use good thread pools) and fine tune for seamless SIMD vectorization there is lots of space for improvement. 
Hmm, good to know thanks... I don't control the ads. I just use the free wordpress account and I use and ad blocker. Maybe I should migrate to some other platform? Lots of people seem to use medium these days... Thanks for the feedback on the blog content too! 
&gt; Come on rust has big Legacy codebases to update? The biggest are around a million lines of code. This is much smaller than C++, but also non-trivial. We also strive really hard to not make breaking changes, including testing new versions of the compiler against the entire open source ecosystem, so most users update every six weeks with no issues. That said, you're not wrong. And, to your parent, some people do complain :)
You write like its his main point that C++ is useless in web apps, but it was merely mentioned for bigger picture. Why don't you say anything about his probably most important argument about systems programming?
You should only generate values between 0 and 1 for the sin\*cos test. Values between -1 and 0 result in a domain error which is abysmally slow with openmp. I haven't looked into why that is, I just know that it is. (Maybe because errno? Or fpu states?)
I'm waiting for the viable OS written in safe languages to teach at least 10% share of the market. I'll agree with you then. 
Why do you want C++ to be dead!? just give up and don't use C++. BTW, you are right, C++ is not safe for kids.
&gt; Not too much: You just put something along the lines of “socket that uses TLS 1.3 as described by [insert technical name of the standard]”. And what happens when TLS 1.3 is demonstrated to be cryptographically insufficient?
so can we also ditch make_shared or it's still the way to go?
I feel like I've achieved better performance with a naive thread pool implementation (using std::promise / std::future as a gate). I paid about 2ms to launch 'n' threads, so anything that ran sequentially at 4ms or more benefited "significantly" (as a 2ms saving isn't much, but is still 50%).
"More important than security is the fact that C and C++ are simply too hard to program" Guys, how did we miss this point?! 
`this` is volatile, making it slightly useful for situations where the pointer exists in mapped memory.
There are many optimisations that do not rely on merging reads from memory. Loop unrolling, for example.
well the first sentence basically says it all. C++ is great for high performance because you can skip all the security steps. Many high performance applications actively try to not use it at all because it would cause an unnecessary overhead. Clearly somebody who never wrote high performance code or systems. 
I don't know, I think it was all those beautiful before/after tables that made it easier to get through papers :-)
&gt; CMake guy whose post I can't find Probably me: * https://groups.google.com/a/isocpp.org/forum/#!topic/modules/sDIYoU8Uljw * https://cmake.org/pipermail/cmake-developers/2018-August/030819.html I still assume I'm just missing something and hope for the best. I still assume I'm just missing 
Which currently valid value are you going to use as NaN? Maybe 17 ? No one uses 17 right?
What about the cases where you need a pointer to a long chunk of volatile memory (For example DMA buffers)? Or backwards compatibility with existing C headers?
You'll probably have a hard time finding good resources for such an old product. Why not just use the latest Visual C++? It's free. Using a 23 year old version of Visual C++ is just a recipe for problems as well as teaching you an ancient dialect of the language.
I dont :)
That software is 25 years out of date. It's unsupported, probably won't work, and was crap even at the time. Don't waste your time with it. Buy a modern C++ book for beginners, or use an online course.
!removehelp
Is there a reason you can’t use a recent community edition of MSVC, or an open source compiler like gcc or clang? (both of which work on Windows these days)
Do you ever change the bytes, or just read/write?
I find it interesting that sender/receiver has a focus on _data_ that is transferred between them, whereas executors were all about functions/tasks and controlling where/how they are run. Maybe by splitting the focus between those concepts can help us have two separate APIs instead of one giant kitchen-sink API.
Deprecating the `volatile` qualifier on member functions essentially deprecates declaring `volatile` objects of class-type. Is this intended? If so, what would be the suggested alternative design?
Hmmm - Every time one changes code in a header and ships it to a current user, one might break users apps which depend on that header. I don't see how constexpr is any different in this regard. BTW - if one is so concerned about this, he could use constexpr as an attribute to require that code be invocable at compile time only. This might or might not address your concerns.
What features are in this compiler from 1995 that you need so badly?
Great news, HTTP/3 is being announced! That means I don't have to ever implement the crappy HTTP/2 spec: https://mailarchive.ietf.org/arch/msg/quic/RLRs4nB1lwFCZ_7k0iuz0ZBa35s
Dunno, I guess just the pure satisfaction of owning a complete copy of C++ instead of trialware? Also because of how little disk space it takes up compared to the modern version I'm downloading.
I agree. I wish there were more talks like this at c++ conferences in general.
It will not be discussed at Kona.
well I tried compiling once Codeblock into MSVC++ and it didnt worked, perhaps if I used same compiler it should work or MSVC will use an entirely different language to C++? also I am really used to instantiating new objects using new all the time, aswell creating arrays like object[],int[],etc meanwhile in C++ is backwards
&gt; Do you think there's a probability that metaclasses won't make it in the standard after all or will be very different from current draft? Yes, of course, because the committee hasn't agreed to pursue it. We have seen and discussed the proposal one time, I think. I would default to assuming a proposal won't get accepted until there is consensus to accept it. Otherwise you are setting yourself up for disappointment.
To implement `future`/`promise` on top of Sender/Receiver, you must do the following: In the `future` constructor, the `Sender` must be `submit`-ed, so that the task actually begins executing. To call `submit`, you need a receiver, so the `future` constructor must pass as Receiver the shared state allocated by the `promise`. That shared state has room for the value, the error, and the continuation, as well as synchronization primitives so that the state can be read and written concurrently without data races. The task will finish with an error or a value, but it must block until the continuation has been set. The rest is fairly straightforward. This shows that to implement _eager_ concurrency -- that is, concurrency where the task begins executing before the continuation is available -- allocation and synchronization are necessary. If you hold off scheduling the work until the continuation is known, no allocation or synchronization is necessary. That's where the efficiency comes from.
Mmm, yes, you cannot ask a F-1 car to climb a mountain. Also, yes, it is unsafe to use these kind of cars in city streets not to mention that those cars shall be driven by an experienced driver. 
That sounds wonderful to me. Boost has historically acted as a proving ground for future standard things. Why not target something so large as graphics and UI for Boost first and see how things shake out?
Replacing function-style macros maybe. How many of those are there in C++, besides offsetof?
Also, if disk space is your limiting factor I recommend you spend the money you were going to plunk down on a vintage textbook and buy a new hard drive. 
Probably the bit pattern 10000...etc
Your fucking shitty machine learning python script inside is running C. So start learning before doing this kind of stupid things
Ok I get it, my idea sucks ass. I'm currently downloading visual studio right now.
Most professionally used C++ *compilers* are completely free. MSVC++ included. You might be thinking of the *development environment* but, again, many professional development environments for C++ are completely free, and there is absolutely nothing wrong with that. At work I am using 100% free software to develop in C++. I *could* use commercial tools but I simply don’t need to.
The only design issue for unordered_map that prevents it from being fast is the requirement that it needs to have stable objects adresses/dynamic memory for the nodes. I have needed this property as often as a twice as fast implementation. I personally would be fine with another set of std sets/maps that don't require dynamic allocation of it's nodes.
If anyone wonders, I have to agree here, CONSTEXPR is a *BITCH* to implement properly, anyone who works on any C++ compiler can agree. E.G. I'm still running into a bug I have to fix related to recursive evaluation of CONSTEXPR (this is in a non-big 3 compiler), such an evaluation is next to impossible to do without a re-write. I also checked it's constexpr evaluation on a small similar snippet: template&lt;typename T&gt; constexpr T adder(T v) { return v; } template&lt;typename T, typename... Args&gt; constexpr T adder(T first, Args... args) { return first + adder(args...); } int main() { return adder(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); } it took a whopping minute to compile, whereas on the Big 3 that have years of dev time more a day than this one does it takes less than a second. A lot of these "We need it constexpr" things are what causes a huge increase in compile times, especially if you force constexpr evaluation on huge snippets of code, because that means the compiler has to walk the AST each time to evaluate it all.
Why do you have to use GCC? You could just use Visual C++ and MSVC, it's the path of least resistance for you here. There's not much point in mucking around with toolchains when you're just learning the language, after all. The biggest difference you're going to find is that you have to think about the lifetime of all your objects in C++. In C# you just make new objects and when you're done with them they magically go away via garbage collection. In C++ there is no garbage collection, you either have to delete them manually or use smart pointers. But ultimately you control how and when every object is created or destroyed so you always have to be thinking about it. In reality this means following a few ground rules for how to deal with pointers but you really have to know why those are rules. And make sure you're using a resource that teaches modern C++, because C++ changed quite a lot in 2011 and you need to be on top of that.
It turns out that for various (good) reasons, a compiler doesn't in fact insert the destructor calls "up front". (Because the behavior sits somewhere between "pure front end" and "pure back end"; e.g., there are tricky bits related to exception handling, copy elision, function call conventions, and conditional expressions.) So, the insertion of destructor calls is done in a later compilation phase in at least two implementations that I know of (Clang and EDG). However, constexpr evaluation cannot be delayed that long because it participates in typing (e.g., via nontype template arguments). So, the way I implemented it is that as I construct various objects during constexpr evaluation, I ("dynamically") register any that will need later destruction, and then evaluate those registered destructions at a later appropriate time (with all kinds of little complications having to do with lifetime management).
Maybe want to take a look at [HPX](https://github.com/STEllAR-GROUP/hpx) if you use the future/promise interface.
Thanks for the report! However, please note that the "Current Target" column appears to be someone's personal estimate and is not guided by any committee consensus or direction. All of the listed items are currently aiming at C++20 (most) or C++23 (some).
do you maybe have a link to share?
[here](https://github.com/tacticalmelonfarmer) is my github. I just started adding some of my work to it.
Yep, that's _another_ reason why I liked Herb's `Concept{T} val` syntax.
Thanks for the detailed response! I'm definitely going to study NaCl and see how it does things, seems pretty interesting and a good place to start.
why do you want operator* to throw, when optional's doesn't? (Same with iterators, etc)
The example has other issues too. It uses integer variables for a, b, which will result in overflows much sooner than necessary. The author writes that his solution terminates once it is close enough. Without further explanation all we know is that it terminates once the rate of change slows enough. That's where I stopped reading.
Do you want your compiler to become a web-browser? ;P
I'm interested to hear about anyone's experiences with upgrading their libraries to support CTAD - are there any gotchas that I didn't mention? My talk was based on real-world usage in the STL, but the STL isn't perfectly representative of all templatized libraries (even ones that might seem very similar, like Boost).
Just because you don't use it doesn't mean it isn't commonly used. RTOS and embedded use it. Are you saying C++ programmers typically don't know what an interrupt is? Or memory mapped registers? Maybe they should be using Java?
Very interesting - wasn't aware of that. Thanks for the explanation and for doing the implementation work (in clang?)
&gt; I'm not seeing a significant difference between implicit inlining which evaluates a function at compile time and implicit constexpr which does the same thing but makes the result available at compile time. Someone somewhere writes `int foo[bar(42)];` or `foo&lt;bar()&gt;(...)`. And it works and compiles because `bar` from your lib is implicitly `constexpr`. Until it doesn't.
&gt; if one is so concerned about this, he could use constexpr as an attribute to require that code be invocable at compile time only No, that's the oppsoite problem. One would need the keyword to make some function explicitly non-constexpr. And if you don't know of any programs that care about source/binary compatibility between versions doesn't mean they do not exist.
So for an 8-bit number, that would be -127 on ones' complement, -128 in two's complement, and -0 for sign magnitude? Assuming endianness, etc... You should probably look at my talk and come back to this thread after [https://www.youtube.com/watch?v=JhUxIVf1qok](https://www.youtube.com/watch?v=JhUxIVf1qok) :-)
I think i was looking at google about the difference between MSVC AND C++ but I found wikipedia said it was like Microsoft implementation of C++ I dont know, I tried to execute a program made in codeblocks and it didnt compile in MSVC that's why I have a doubt
I hope that's a joke...
It wouldn’t. Binaries between different OSes and different architectures are incompatible. You’d have to cross-compile. That said, visual studio provides a possibility to cross-compile to linux, but you’ll have to download the toolchain thru the vs installer. Or you can use a crosscompiler toolchain. Also if you use cmake, a build generator, you’d be able to port your code easily and build for each platform. 
Well Certainly I want to keep using MS Visual Studio, NET framework makes things much easier at least using C# feels completely different(yeah I doesnt have pointers at all, well not same way as C++) Do you know if there is a way to remove the compiling message of the console? (process 6152) exited with code 0. To automatically close the console when debugging stops, enable Tools-&gt;Options-&gt;Debugging-&gt;Automatically close the console when debugging stops. Press any key to close this window . . .
with this? https://blogs.msdn.microsoft.com/vcblog/2017/04/14/bring-your-existing-c-linux-projects-to-visual-studio/ do you think using mingw will affect funcitonality of Visual studio?
Exactly. 
In the EDG front end, actually. (My day job.)
istreambuf_iterator. Reading a binary file into a vector of std::byte. Was surprised that this didn't work
To be honest, I think the problem shouldn't be solved with a single library at all. There should be (at least) four: - Basic GUI primitives and events: this should contain windows, dialog boxes, top windows (borderless temporary windows, like for menus), and input events. I believe such a library would be relatively non-controversial, although I may of course be wrong. - Controls. Obviously this immediately faces an ever-controversial choice between native (and therefore lowest common denominator) and non-native (and potentially far richer). This library could also solve things like font/DPI sensitivity and layout. - Drawing for desktop. This should be a rich set of drawing primitives (not just rectangles!) that may or may not accelerate well. - Drawing for games. This should be a highly optimized set of drawing primitives that work well with acceleration. I maintain a library that covers the first three, so I do have some notion what I'm talking about here... 
Can you please elaborate on what exactly isn't working with /external:I? There was a bug in the initial release that was manifesting itself in warnings C4193 or C5031 about mismatched pragma push/pop being occasionally emitted while trying to use this feature. The problem was occurring when a header under /external:I directory with #pragma once in it was included from another header that is not under /external:I directory for the second time. We fixed that issue in Visual Studio 15.9 so besides still being experimental, to the best of our knowledge the feature should be fully functional in 15.9. As to the argument that /external:I behaves differently than -isystem - absolutely - we didn't try to mimic everything because Visual C++ has the notion of warning levels, which is non-binary on/off only, and we had to ensure that the new feature interacts well with this notion. Besides, we also tried to address the common problem that often times warnings in system headers have roots in user's source (i.e. via template instantiation), so we provided a finer grained control to allow one to be warned about those. With regard to ordering of /external:I switches in relation to /I switches, please note that /external:I allows marking headers in certain directories and their subdirectories as external, but otherwise behaves exactly as /I. This is why /external:I used by itself without /external:W0 would not do anything (i.e. it would not suppress any warnings). One would still see the same warnings they saw before because by default the warning level in external headers is the same as the warning level passed via /W flag. With this in mind, if we were to go with the logic that moves /external:I directories towards the end, suddenly for people who tried to experiment with the new switch and only provided /external:I, but didn’t provide /external:W0 – they would have potentially broke something in their build without even seeing the desired warning suppression. Because of this, I think emulating Clang/GCC’s behavior here might be counter-intuitive and disruptive to our own users, which still have control over the desired behavior by controlling the order of the switches. Speaking of -imsvc flag specifically, it looks like it is a clang-cl only flag and clang-cl was meant to be a drop-in replacement for our cl.exe. Clang-cl already tries to emulate cl.exe logic to the extent possible, and if we start making changes to match clang-cl’s logic instead, I think we will be handling this on the wrong side of the equation and only contribute to the clutter/confusion, not eliminate it. Once our /external: flags leave experimental stage, clang-cl would likely add their support as well, in which case -imsvc (which doesn’t actually mimic anything in cl.exe per se) would become obsolete. 
&gt; I'd like to hear the numbers about how many window-specific #ifdefs were required to get this to work? The bulk of the changes were in https://github.com/ericniebler/range-v3/pull/928. There are workarounds for 15 different MSVC bugs (See the `#define META_WORKAROUND_MSVC_XXX` and `#define RANGES_WORKAROUND_MSVC_XXXX` defines in `include/meta/meta_fwd.hpp` and `include/range/v3/detail/config.hpp`.) I never counted the number of occurrences of each bug, but I think the incidence is typically fairly low. A quick grep for `(META|RANGES)_WORKAROUND_MSVC` finds 72 occurrences, although that includes the definitions and 2 or 3 occurrences per actual workaround a la: #ifdef RANGES_WORKAROUND_MSVC_XXXXX // workaround stuff. #else // RANGES_WORKAROUND_MSVC_XXXXX // original stuff. #endif // RANGES_WORKAROUND_MSVC_XXXXX 
While I don't speak for Eric, and range-v3 is his baby, I think his intent is that range-v3 is primarily a research tool and the C++ Standard is the "stable API." (That said, we try not to break things too hard or too quickly without a deprecation period in range-v3. It has been fairly stable for maybe three years now.)
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9winpa/christmas_is_coming_which_is_the_book_for/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I mean, Forth has been moving computations to compile time since the 60's, but I wouldn't say it's clunkier than in C++. Same with Lisp, I think.
This is an instance of an lazy sequence. This is what the article is advocating. The benefit of using coroutines is that the state machine is created under the hood. FibRatios have barely no complexity as computing the next state (transition) and computing the next value is very similar, if this is not the case things get quite complicated. ``` auto weirdSequence() -&gt; seq&lt;int&gt; { for (int i=0; i &lt; 10; ++i) co_yield i; for (int i=20; i &lt; 100; i+=10) co_yield i; co_yield 10000; co_yield 1000000; } ``` This is the underlying state machine (note: might have bugs / hard to maintain): ``` struct weirdSequence { int _goto = 0; int i = 0; int j = 20; bool done() { return _goto == 4; } int next() { switch(_goto) { case 0: if(i==9) { _goto=1; } return i++; case 1: if(j==90) { _goto=2; } j+=10; return j-10; case 2: _goto=3; return 10000; case 3: _goto=4; return 1000000; default: throw "seq::next called after end reached"; return 0; // should never be reached; } } }; ``` Needless to say we need also create an adapter so we can use this class with the standard library and for range loop
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9wiqq4/dynamically_creating_a_2d_array_of_pointers_in_c/e9kxx79/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
If you define "compliant" as "every well-formed program compiles and behaves as the standard requires" then there is no standard-compliant C++ compiler, and likely never will be. You can't see most of the workarounds for clang and GCC bugs in range-v3 since - with a few [notable](https://github.com/ericniebler/range-v3/blob/master/include/range/v3/utility/concepts.hpp#L110) [exceptions](https://github.com/ericniebler/range-v3/blob/master/include/range/v3/detail/config.hpp#L498) - only the workaround gets checked in. The MSVC workarounds are more visible because I chose to make them so instead of simply checking the workarounds "invisibly."
To linearize a 2D table, create a transformation equation from 2D coordinates (X, Y) to 1D coordinates (N). For example, suppose you want to flatten a 3x5 table to a 15-element array. That is, X varies from 0 to 2 inclusive, Y varies from 0 to 4 inclusive, and you want N to vary between 0 and 14 inclusive. N = X + 3 * Y is one possible transformation. N = 5 * X + Y is another.
If you want, you can self-assign user flair so redditors can see what you work on (everyone in WG21 knows your name, but not everyone on the subreddit :-). See https://www.reddit.com/r/cpp/comments/4tm8k9/user_flair_is_now_available/ for the process.
completely lost myself an posted this to cpp instead of cpp\_questions, my bad
Thank you so much!! This is exactly what I needed, I'm going to take a closer look at this and see if I can write something up. I appreciate you.
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9wiwfn/new_begginer/e9kyqcx/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; The example has other issues too. It uses integer variables for a, b, which will result in overflows much sooner than necessary. This is just a minor detail. The most generic way would be to provide a template parameter for the number type so the user can provide his BigInt implementation, but that would distract from the original message. &gt; Without further explanation all we know is that it terminates once the rate of change slows enough. This means we don't really know how many elements we need to compute, making it hard to predict the optimal size for a container. This is sth. we don't really need to worry about when using a lazy sequence. 
This has come a really long way since range-v3 MSVC "port" of a couple of years ago!
Thanks. (I'm a total Reddit noob. But hopefully I did it right ;-)
Well you can have an array specialization that will do the right thing. Or maybe call that `std::volatile_array&lt;T,N&gt;`. Backwards compatibility with C is holding C++ back, and `volatile` is also an issue in C.
Backwards compatibility with C is the most important thing that allows C++ to be used in the first place. No compatibility with C automatically cuts C++ out of access to every single C library. Considering the almost complete lack of C++ ABI standards that means the vast majority of all libraries out there.
All of these are absolutely horrible and should never be done... right?
(Disclaimer: I'm a range-v3 maintainer and a Microsoft employee.) Yes - the difference can't be overstated. MSVC's conformance is improving by leaps and bounds.
I know that I would be using it at work for 128bit flags, right now we do have a constexpr version, but it is not always evaluated at compile time when passed to function arguments. We do use a lot of those in our game engine, and it turned out to have a certain cost
Some progress on synchronizing C and C++ standards such as: [N2265](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2265.pdf) Harmonizing static_assert with C++ 
It is. But D variant takes 1.5 seconds to compile. There should something be wrong with the compiler, the library or the the Vasa. What is wrong and what is the plan?
Yep, looks good!
I tested gitlab pages, and it was amazingly easy to set-up, and I have full control of the layout of my blog. I think it took me half a day, including the bike-shedding of my layout! You should try it too, especially if you don't want to make money from ads. The result is really clean.
A case for C++ Insights!
I don't see unit tests either. Unit tests are also some sort of documentation, because you can see how the class is supposed to be use. I opened a [random file](https://gitlab.com/ahdavis/libcppcurses/blob/master/src/display/window.h) to watch your code. You may consider not writing in comments what is already written just bellow. I know that it's the constructor, and the destruction, and that you deleted some constructor. What I need in a comment is **why** you deleted them.
Watched your talk. I still think integer NaN is the best way to solve the problem of integer overflows, divide by zero and lossy truncations. It has the advantage of not requiring flow control checks for every operation and working in a SIMD context. And as Chandler Carruth has mentioned in some of his talks, the defined overflow on 2^32 etc is almost never correct for your program. I see the issue being we C++ programmers making do with hardware instruction sets not giving us what we need. Some up coming architecures like the Mill sound like they would finally do this correctly but I am concerned that we are closing the C++ door to these improvements. 
 constexpr size_t foo() { auto t = __TIME__; return t[7]; } char your_user[foo()]; // what size it is today? constexpr is a joke and should be deprecated entirely. 
We're not going to get good use of (semi-)automatic parallelization until the primitives and OS schedulers are brought up to date and able to handle switching threads (in the same address space) in time quantums of tens of microseconds. Many applications just aren't easily parallelizable in larger chunks or have latency requirements that prevent doing so. I find it baffling that the modern OSs are still stuck with scheduler resolution straight from the 80s.
Yes, I started this effort as [rxcpp\_v3](https://github.com/kirkshoop/rxcppv3) in 2016. With massive help from @eric\_niebler and others, we designed and built [pushmi](https://github.com/facebook/folly/tree/master/folly/experimental/pushmi) over the past few months to prove out the new design. We also have Lewis Baker helping to unify the coroutines-ts with Sender/Receiver. The result should be a formal counterpart to Iterator that applies to async value producers. We are starting with the Executors as they are fundamental to the rest.
C++ doesn't support `restrict` and VLA either and it can still use C just fine. `volatile` is used rarely, and is often not the right way to do things either.
I spotted more issues. You should not re-implement the function in the child class of color. They are not virtual and thus will not work like you want if you take a reference to color. Furthermore the children's implementations do the same thing than the base class, so you can just remove this code in the childs. And finally the static variables `r`, `g` and `b` are common to all colors, witch means that if you call the constructor with a color, or the `operator=` on any colors, it will modify `r`, `g` and `b` for all the other colors. What you want to use here is CRTP to have a triplet of variable for each color (one per child type) without to duplicate your code. If you had unit tests, you would probably have catch those mistakes.
Interesting ideas, but I think the main issue would be to make a front-end/back-end setup that doesn't add cost to the implementation.
TIL Rust folks are nice and courteous only in the heavily moderated Rust forums.
Thanks for clarifying that. Although I read several times the proposal, your last paragraph is the most synthetic explaination I found so far.
&gt; parameters constexpr parameters author here. I did not believe I would have been able to complete the necessary work to get it ready for C++20, so I focused my efforts on other things (primarily operator&lt;=&gt;). There is some supporting work necessary before I would feel comfortable standardizing the feature at this point, so I am still working on it.
&gt; The benefit of using coroutines is that the state machine is created under the hood. Sure, but precisely your Fibonacci example shouldn't be done with coroutines. As for your second example, it is not a good one either, because it is not a real use case. In addition, you have made the equivalent code way more complex than required -- a single integer is required as the state, too. &gt; Additionally we need also create an adapter so we can use this class with the standard library and for range loop Irrelevant. The "adapter" is very simple and can be reused. And it is way simpler than using an entire complex library like Conduit.
&gt; bigint I would not be surprised if we got a big_int type at some point. I intend to work on one some time next year that I expect to be much easier to use and better performing than the competition. If I am happy with my results, I will likely propose it for standardization.
&gt; &lt;=&gt; I expect that for the vast majority of types, `= default` will be sufficient. Most of the time I have written a comparison, I want to compare all of the members, and I do not think that I am an outlier here. It is only when you do "special" comparison semantics that you would have to write both (and you could always implement `operator==` as `lhs &lt;=&gt; rhs == 0`). A general guideline in the committee is to not add extra things to the language to support corner cases, focus on giving the common cases the nice syntax.
We don't need more articles like this.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9wgetf/do_you_have_any_advice_for_learning_c_using/e9lce25/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Hmm, the name 'receiver' reminds me of [message passing](https://en.wikipedia.org/wiki/Message_passing), a la Smalltalk, Objective-C, et cetera. Bjarne Stroustrup did express a desire for what he termed 'function maps' in his [P0954 ('What do we want to do with reflection?',)](http://wg21.link/p0954) though, so I guess I'll just lurk and watch this and see where it goes… 
Who thought it was cute to add a giant virtual bezel to the website? Bezels on screens can't go away too soon, adding a thick border that looks like a bezel is just... an interesting choice.
You can vote/comment on feature suggestions at Developer Community (superseding UserVoice). The suggestion for OpenMP is https://developercommunity.visualstudio.com/idea/351554/please-support-newer-version-of-openmp.html .
hmmm, I want to agree but I also kind-of think that if the scroll were inside the bezel I'd have a better hint at how to interact with the page. At least it's not FULL SCREEN picture with content you can see if you happen to guess correctly to scroll down :)
That's one of the cases that makes those compiler warnings less useful than they could be. Obviously, this code is correct, but if you start doing anything fancy, like iterating backwards, it's easy to start making errors if you use an unsigned index: `for (size_t i = container.size() - 1; i &gt;= 0; i--) {...}` If you don't need the index, you can clearly just use a range-base for. If I'm working with strict signed/unsigned comparison warnings on, `static_cast&lt;int&gt;(container.size())`. FWIW, I understand `std::ssize(container)` is coming in in some future standard.
Avert your eyes, mortal.
I still don’t know why C didn’t adopt C++ function overloading. The overloading concept C adopted instead is awful.
Because that would require name mangaling, something C didn't do at first and won't do in the future to keep backwards compatibility (if I can guess correctly)
It's something they could do via an opt-in approach. Assume a new `_Overload` keyword that specifies a function is (possibly) an overload. Any function so tagged would be mangled while functions without the keyword would be left unmangled. Allow a single function of a given name to be declared without `_Overload` and zero or more functions of the same name declared with `_Overload`. The intent of that last rule being that things like `double sin(double)` can exist unmangled (as they do today; no breakage) and that new overloads like `float _Overloadsin(float)` could co-exist. And, unlike the `_Generic` approach of C11, overloads via `_Overload` can be introduced via composition of multiple headers, which is one of the key strengths of overloading to begin with. All that said... why bother? Just use C++.
If C were to get function overloading, I think it would be nice more like ooc does it, where you need to specify a unique suffix, but it can be inferred char * stringify~for_int (int x); char * stringify~for_char (char c); // The compiler can infer the suffix to use stringify (1); // Same as stringify~for_int (1) char * (*ptr)(int x) = stringify~for_int (1); // It can be given explicitly to get an exact function You've also now solved the mangling issue, because it's no longer needed; the name the user wants is already given exactly like they want it. 
If you are using constexpr solely for computing values at compile time vs runtime, I can see the argument for relying on the optimiser instead. However, constexpr is so much more than that. Since the values are present at compile time, you can use them to produce different types depending on the value. And reflection requires a healthy amount of constexpr ability to be useful.
Exceptions in embedded code? You must love wasting money ;)
Yes, please. To be honest, this is what I wish the move constructor just "was."
I don't mind it, it makes the text width more suitable for reading. And it seems to stay mostly the same width when I resize the window. The bezels and the side bar on the right disappear if I make the window narrow enough. Don't get me started on the Wikipedia default, which is to fill the whole width of the screen, no matter how wide a screen you have, making it very hard to follow the text when trying to find the next line.
I actually think it looks kind of neat.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9wmned/note_books_while_reading/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I don't know much about OpenMP bur could that be because with OMP the work is split up by the compiler, which has more knowledge of the code than a library implementation? Also, would it be possible to implement parallel algorithms on top of openmp?
Noo, i have this book Bjarne Stroustrup Programming: Principles and Practice Using C++ 2nd Edition Its so Great so far, but i like taking notes but i don't know what to type. any advices ? i like to have my NoteBook Organized If you have any tips 
It is still name mangling- you are just doing it explicit, but the compiler and linker still have to use the mangled name.
My very biased opinion is that I don't really see the need for a new C standard. &amp;#x200B; There are potentially 3 types of C projects: 1. New projects. For this I would argue that C++ is a much better language to start a new project in. C++ features such as templates, RAII, namespaces, and overloading provide nice zero-overhead abstractions while still keeping the structured programming motifs of C. Another option in this space is Rust which provides nice compile time memory safety guarantees while still aiming at the zero overhead systems language space. 2. Legacy projects without much change. For this, the conservative option of sticking with the existing C language standard (be it C89, C99, C11) is probably the preferred option. The new C language standard will be less well supported across compilers and platforms compared to the existing standard. Given that there is not anticipated to be much change, the effort of changing to a new C standard is not likely to pay off vs the expected growing pains/loss of portability. 3. Legacy projects that are actively being developed and refactored. For this case, I think it would be better to do the minimal modifications that allow it to compile with a C++ compiler and then slowly add C++ features as needed/desired. This is the option that GCC took, which shows that this is viable even in an old, large, complicated codebase. I would be interested to see what other's opinions are.
Hmm, true. Maybe I should have specified a bit more: I'm primarily referring to implicit, automated mangling based on things like argument types, where it's nearly impossible to really know what it's going to be and is also on by default. 
Good points.
Interesting points to think about... I think point 3 is the weakest, because either you get very unidiomatic C++ or you will have to fundamentally change architecture (although I have to say I don't know what GCC did, did they solve this?) Also if you think C11 or even C99 are ok, they were new updates once too, so would using C2x be ok in 2030? 
I also think, the advantage could be better shown with a more complex algorithm (e.g. with nested loops, or multiple suspend points).
Going from `std::vector&lt;actor*&gt;` to `plf::colony&lt;actor&gt;` appears to have changed memory management in more ways than I expected, resulting in a build that currently crashes in a hundred or so sim ticks (I'll keep working on it). In addition, working with a container of value types put strains on the runtime polymorphism the engine was designed with, making the porting harder than initially anticipated. A `remove_if`would be very nice (perhaps with an overload that performs linear searches for runs of matching elements/parallelizes per/block). Take this with a grain of salt as this is an unfinished, crashing port, there are weird, semi-regular stalls that shouldn't be happening. Perh they're a symptom of whatever memory management I'm doing wrong (appears to be use-after-frees, not memory leaks), but it's too early to tell. 
I honestly don't see many reasons why you would use C++ for your fronted. The reasons why you use C++ are: You need a fast, mature language which allows it to write code on a low level a/o you need to interact with legacy code. This arguments are seldom relevant for fronted programming. You do not use the advantages of c++ but still have its disadvatges , mainly that it is an extremely complex language that makes it hard to write code and easy to make mistakes
You might be right in general, but as literally all i do day in / day out is write custom UI applications in C++, I obviously have a hard time seeing beyond my narrow view. I should mention that there is a massive community who do similar work to what I do, often centred around the so-called "creative coding" (ugh, I hate that term) toolkits such as [cinder](http://libcinder.org) and [openFrameworks](http://openFramworks.cc). Perhaps if you poke around there and their respective fora, you might find some stuff that piques your interest
I use handwritten. Helps me remember better. I made sure I noted key points, things I understood poorly on the first reading, and things I'm not likely to remember without prompt at first.
I don't have that view on the language. We develop non-legacy code in c++ and with some proper framework (or modern std features) you write code easily and without mistakes. I'd say with less mistakes than Javascript to do the same thing. Thing is that c++ is perceived as complex language when it's surely possible to make it fluent and readable as others (eg Java c# etc...) when used to write actual applications. 
Congrats! Getting range-v3 working on MSVC appears to have been a huge amount of tricky work!
Have you tried using MSVC modules yet? It would be nice to know what impact do they have on compile-times!
You completely ignore the parts where c serves as a lingua franca. Syntactic improvements are probably less important in those cases, but extensions to the abi are. Also consider things like the linux kernel. C++ absolutely isn't an option there (we can argue if that is more of a technical or a cultural problem, but the fact remains)
\&gt; Also if you think C11 or even C99 are ok, they were new updates once too, so would using C2x be ok in 2030? I think in the past you could justify writing in C on a new project in the name of portability to many platforms I think the big game changer has been LLVM. Before, each platform had their own C++ compiler which often had very poor C++ standards conformance, while the C language was well supported. With LLVM you have a high quality, approachable, standards conformant compiler. An example of this type of thing is say a new microprocessor. In the past, you could say that that it would likely have a C compiler way before it had a C++ compiler mainly because of how difficult it is to write a C++ compiler. However, with LLVM, you just need to write a code gen backend for LLVM and you have a C++ compiler for that platform. &amp;#x200B; &amp;#x200B;
It's too late now. C++ Should have changed when Java attacked them and they should have given a better alternative to Javascript for the browser. Fact is, the C++ community didn't care at the time and today is the result of this fact. C++ will be dominant on low level, battery, cpu important applications, but all the rest where functionality matter they can forget about it. 
Ok thanks dude any equipment or anything in general will make me learn better ?
&gt; The C abi is more a function of OS vendors than of the C standard. Doesn't change the fact that anything that isn't supported by c is usually not used to communicate between two languages &gt; Finally, you can just as easily do the C abi in C++ as evidenced by the success of Microsoft in implementing the C standard library in C++. You can implement the C abi in c++ and other languages (that is the point of a lingua franca), but that doesn't change the fact you can't put anything in the interface not supported by c (e.g. exceptions, or datatypes not available in c), because c is the language in which that interface is described.
That's my expirience too (i work deep in the back of our software and all my code is c++ that a user will never touch). I've talked a bit to the people who do front ends and at least the few i talked with just prefer Java, according to them it's just easier to get to work on all platforms. And since they are happy to use my C-Code and never complain it's probably fairly easy to have a java interface that calls c++ functions. So why not have the best of two worlds instead of trying to make one thing work for everything? I actually like the idea of specialized languages. My personal experience with C++ GUIs the last few years is little but it was always a enjoyable (SDL2, QT and nowadays GTKMM). Nice editors, decent documentation and apparently all of them run on windows and linux, but i haven't tried it yet.
everyone learns differently, i really really need to write down why and what everything does. First i made special documents about everything, writing down the things i checked. Nowadays i just try to write a decent example with decent comments that i can go back to and copy/paste things i don't remember. Works great for me, i check things, i use things and i document things (and i often watch videos about the topic first). So i basically try to give my mind all the information that's out there. I actually think the C++ basics are very easy to learn. But the language has so many features that it's really hard to keep track of all the possibilities, so without some simple reference to the things i rarely use i just get lost and default to the basics. Which works but isn't ideal. 
I am with you there, C++ vendors could have followed Borland ideas and provided RAD tooling for C++ apps like C++ Builder, but they decided other paths. I used to joke that Visual C++ was visual only on the name, in regards to MFC vs VCL tooling. And now that it finally merits the visual part with Blend, UWP and C++, most of the UI team just uses .NET Native and leaves C++ for the UI composition engine, DirectX and other low level high performance logic. Even OEMs like Garmin prefer to create their own [managed dialect](https://developer.garmin.com/connect-iq/monkey-c/) for their gadgets than exposing the C or C++ code they write the OS on. 
One example of a OS ABI that is based on a C++ feature is COM (and its successor WinRT) on Windows. It was a deliberate choice to use C++ vtables as the basis for that feature.
I'm also on cmake, which apparently means I have to choose between pch and ninja. So no pch for me. Anyway, pch are a big ugly hack bolted on to a system that would never see the light of day nowadays, I won't be sad to see all of it go.
Yes it would be ok to use a specialized language, but then they lack interoperability with c++. Or should I write everything in c to be able to use it!? 
I should specify it's not GUI work that one might associate with "native look and feel UI", i.e cocoa, or Qt, or whatever, so everything I write is completely custom. I have a written a rendering agnostic scene graph library that is built on top of cinder and i implement each new UI on a per project basis as they are almost never alike, in design or functionality. My last project ran on a 105 inch touch table, and the one before that was projected onto stretchy fabric and used a depth camera to track where the user was deforming the surface for input, for example.
\&gt; I'd say with less mistakes than Javascript to do the same thing &amp;#x200B; How are you writing you javasript, and who is doing it? For front-end applications, I can't gather a scenario where writing C++ code would result in less mistakes than javascript. 
What you say is simply not true. They do now want to disallow things, just deprecate the useless ones. How would you interact with hardware in a world where you do not have an interface (in this case language) to do it? Back to assembly? This does not make even sense. If you want that, just pick up C# or Java. There are plenty of tools like that already.
hint , reddit users actually have a slight disdain for Cherno - and mostly (from what i've gathered) because he teaches old C++ - which this discussion is mostly about. &amp;#x200B; &amp;#x200B;
Actually, com uses a c-abi with lots and lots of library and TMP machinery around it. 
&gt; overloads via _Overload can be introduced via composition of multiple headers which means the same function call expression may invoke different functions depending on which headers are included. `std::abs` once had this problem, and AFAIK it took quite a bit of effort to make it work correctly. So I guess not all C programmers will see this as a strength.
I just used my notebook, obviously and IDE or text editor to practice and that was all. I also recently discovered that listening to classical music realy help me to get in the study zone. &amp;#x200B;
[This paper](http://wg21.link/P1095R0), right?
&gt;Maybe if you're writing closed source desktop libraries that need to interoperate with as much as possible? Exposing a C api to your C++ library is also possible.
&gt;On Visual Studio, using Microsoft’s calling convention, the second snippet compiles and runs clean — the unique\_lock object is destroyed in the ***caller*** and there is no deadlock. &gt; &gt;And, as you might now expect, on Visual Studio the first snippet produces undefined behavior because the unique\_ptr is destroyed in the ***caller*** and the string freed before the caller gets a chance to print it out! I believe you meant callee.
&gt; How would you interact with hardware in a world where you do not have an interface (in this case language) to do it? I tried to argue this exact thing. The reply was "It should be removed from the language and moved to low level library" (with no mention of how you'd write said library or the fact that ARM Cortex-M architecture is specifically designed to directly interface with C without needing almost any asm code). &gt; But sometimes, when you need a tight class with no dependencies at all, you will still want to use a raw pointer inside plus new and a destructor, for example. I believe we're in violent agreement here. &gt; What you say is not accurate at all. I'm simply saying what impression I get from the people writing here (and elsewhere) when it comes to modern C++. _I_ think raw arrays and pointers definitely have their place. I wouldn't store high level objects in them but when dealing with low level data, they're what I use and will continue to do so.
&gt; I used to joke that Visual C++ was visual only on the name This baffles me. Microsoft tends to name every new program "Visual ..." while it has nothing to do with the name. The IDE name might be kept simply for history but Visual Studio Code ... is neither the IDE nor visual. It doesn't even have a common part besides Intellisense.
Check my comment history. I don't even use Rust. I just hate fallacies (in this case a clear strawman until proven otherwise).
Always wondered why we can't compile-time evaluate by default but ... wow, never thought about such reason but is has a lot of sense. 
If allocation coule be compile-time ...
At least the definition of relocate given in the introduction interfers with \[basic.lifetime\]. There may be more interferences with the c++ object model. With such interferences, it would be surprising such a paper is accepted.
Maybe not the same but I’ve notice that majority of bugs in our project comes from QML (js) and very little from C++11. C++ gives you this semi guarantee that your program is mostly correct when it compiles (strong types are big part of that).
Anyone else getting playback errors? iPhone 6s. Official reddit app. iOS 12.0.1 Playback ID: jc4W7-9z6U3cUxpq
Oh programs like Visual studio called IDE ? Thanks a lot i have visual studio on my windows and on my mac i got the xcode because visual studio on mac dosen't support c++
&gt; It was written an emphasis on performance, so it uses plain function-pointers + userdata for callbacks instead of std::function. There are two techniques for writing for performance: 1: set a performance goal, implement, measure, optimize, measure again, repeat 2: premature optimization (everything else?) How does your implementation compare with an `std::function`-based implementation? How does your implementation compare with a `boost::signals2`-based implementation? 
It might be worth noting that Titus Winters said: &gt; This might be my favorite overall discussion on cache and memory to date. https://twitter.com/TitusWinters/status/1053085902925221888
The majority of the bugs created in javascript wouldnt make it past the c++ compiler.
but it makes sense that the work that goes into low level , HPC, all that should be entirely separate to business logic anyway.
It's a nice idea, but I have worked enough with build systems to wonder if it really is adequate. * Combining this with binary cached packages seems hard. * Linking and working with third party libraries? Specific version's of these? * Building and selecting different libraries depending on target platform? * Versioning of libraries? * More detailed configuration customization? * Additional build steps such as file generation and unit test execution? There is more. But I can see this working for some projects but even with the planned features it won't be able to replace existing systems.
What theme/font is that?
Side note, but the video reminded me of it... I love intellisense, and the way it lets you choose from available symbols, but does it really have to be so huge? And is it absolutely necessary to have it obscure the context of whatever you are looking at? Can't it be either a little bit away, or maybe even in its own dedicated area in the window? Or on top of the project browser, even? 
I'm using this: http://prntscr.com/lhu3d4 I agree tho, it should not be that much distractive
You might also want to write in C++ because the rest of your stack is C++ and you don't feel like introduce a scripting language, writing a ton of bindings, losing type safety, and taking a 50x performance hit, just to 'simplify' things. Or, you know, because C++ isn't actually that hard to write to begin with. It doesn't all have to be `rvalue constexpr SFINAE template &lt;({&amp;&amp;*#&amp;-&gt;})&gt;::type_v`; it's _you_ writing it, you can also keep things simple if you want to. Especially for interface stuff, where performance doesn't matter all that greatly anyway. 
[removed]
[removed]
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9vip8u/learning_c_like_its_2018/e9m7io6/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Woah, nice work. How much experience must a cpp dev have to get to work on something like this?
it's now second on the list of features. Would be nice to upgrade it to the versions as GCC and Clang support (openmp 4.0). [https://gcc.gnu.org/wiki/openmp](https://gcc.gnu.org/wiki/openmp) &amp;#x200B;
Pretty well. Everyone thinks current exceptions are not good and can be improved. `errno` is not the same thing as the exception handling though, it's more a purity issue.
Yeah, trying to do something as simple as extracting the code from whence a symbol came is kinda... meh. We've forked `mkdoc.py` from `pybind11` which uses `libclang`, and it it does have some other oddities, like how it handles forward declarations :/ (It did most of the job in this case, but def. leaves some functionality to be desired...) https://git.io/fpYKz
SWIG solves the problem of interfacing C++ with mostly everything else…
Company: Transunion Type: Full time Description: We are looking for exceptional developers to join our fast growing Information Technology Team in sunny Florida. Looking for generalists with strong computer science fundamentals. Location: Boca Raton, FL Remote: No Visa Sponsorship: Yes Technologies: C/C++/C#/Python, Linux, Machine Learning, AI, Networking Protocols (TCP/IP, UDP), Big Data, Compilers, multi threading and distributed systems Contact: Please apply at [https://transunion.taleo.net/careersection/tuext/jobdetail.ftl?job=18002695&amp;lang=en&amp;sns\_id=mailto#.W-Mmk5VVDMw.mailto](https://transunion.taleo.net/careersection/tuext/jobdetail.ftl?job=18002695&amp;lang=en&amp;sns_id=mailto#.W-Mmk5VVDMw.mailto)
You can also pm me as well
&gt; Moreover, since C is a tiny language, good C safety standards actually exist. I see the point of "smaller language = safer language" made constantly and I never know what causes people to buy into it. C is fundamentally much more unsafe than C++, no matter how hard you polish manual allocation / deallocation, no safe resource handling and lack of any error reporting mechanism beyond returning an enum, you're not gonna get an actually safe language. "Just use it in a way that's safe and scales well lol" is shitty advice that says nothing. And the the largest C code bases end up clumsily reinventing C++ features anyway. &gt; Learning how to best make use of C is easier by several magnitudes than learning how to best use C++. Bullshit. Yes, C++ has a significantly larger feature set but that feature set can be carved into useful abstractions much easier than figuratively everything being a void pointer.
&gt;One would need the keyword to make some function explicitly non-constexpr OK - use the noconstexpr as a keyword. Use them both if you want. \&gt; source/binary compatibility between versions those are two entirely different things. and when you say "versions" are referring to compiler versions, C++ versions, header versions or what? I don't doubt you have a point, but I'm just not getting it here.
are these real world bugs that you see during development? Assuming you are speaking because of the static typing - Most of the bugs I see when developing javascript are the same ones I would get in C++, small errors in logic, especially if you consider the bugs that make it past unit tests and onto production
Really no one ever built a good library for it. I mean, QT did, but then you have to drink all the QT kool-aid. They are really pretty interoperable with other libraries, but it's still a lot of kool-aid. All the other ones out there are either moldy old C libraries or C++ like they used to write in the '90's, where you're probably better off just using a moldy old C library. I've done some motif (yes, freaking motif) programming in C++ and it seemed like it could actually be reasonable except that the application I was maintaining was full of global variables and tightly-coupled (And thoroughly undocumented) business logic. What they were fundamentally trying to do would have worked out better with a backend serving images to a web browser, but they didn't have web browsers when they started writing the thing. With a good UI library it really shouldn't be any more difficult to rearrange your UI than it is with an interpreted language, but it's a tough sell for businesses these days to do client-server with a custom client. They want a client that can run on anything, despite the fact that every single business that uses that argument has one single Windows or OSX image that IT rolls out to the entire company.
Yeah mostly the typing ones. And just that js bumbles along, long after c++ would have crashed, minor bugs make it though to production where they wouldnt in c++.
"Visual" Studio Code has nothing to do with visual or window programming. Thee could just name it MS Code Studio.
Yes, but people recognize the brand and they stick to that. I mean you're just restating my point.
&gt; I used to joke that Visual C++ was visual only on the name, in regards to MFC vs VCL tooling. VCL was written in Delphi IIRC. It was a good advertisement for Delphi, but bad for C++ since no C++ developer wants to touch a class library written in another language. &gt; And now that it finally merits the visual part with Blend, UWP and C++, most of the UI team just uses .NET Native and leaves C++ for the UI composition engine, DirectX and other low level high performance logic. Even today, nothing exists which can approach VB4 for pure RAD.
Sorry, weird pet peeve, but: whence = from where from whence = from from where 
nicer in what feature? Speed, understanding, ease of on-boarding?, lack of type-safety bugs? I honestly don't think javascript would be as popular and as dominating as it is, if that were universally true (nicer to deal with). Maybe you're in a specific domain that needs that, or maybe you should give non-statically typed languages another chance.
I think part of the reason why people dislike this-&gt; is because that's often seen from newbies (i.e. people who don't know 'better') or even developers who come from Java. That by itself is not yet a valid argument against this-&gt;, though. My personal reason would indeed be that it's a bit more verbose than m_.
What we did wrong is that `constexpr` should be opt-out instead of opt-in. However, I don't see any way to fix this "mistake" without a time machine. This is similar to `const` and purity. Ideally, you would want functions to be pure by default, and use some kind of keyword to say they aren't (e.g. `mutable`). But this is just wishful thinking.
I don't think any Committee member doesn't know the language is too complex. However, we have to weigh on the benefits of adding complexity to the language vs the functionality we're adding. IMO, `constexpr` is one such feature where the downside of adding complexity to the language is nothing compared to the benefits it brings. When we're done with [p0784](http://wg21.link/p0784), we'll be able to setup search-efficient containers at compile-time for the whole embedded world (and the rest of the world too) to use. We'll be make all applications faster to load by removing entirely unnecessary load time computation (static constructors). I mean, those are not small benefits, are they?
&gt; Now you may well tell me that placement new into dynamically allocated bytes is not permitted in constexpr under your proposals. I'd counter that if not, why not, and what can we do about that? Exactly -- it is not allowed. The reason is what I was referring to above with my Valgrind reference. Since the compiler has to catch UB at compile-time, allowing raw-memory interfaces inside constexpr would require each byte handed to you by the compiler to be tracked to make sure you don't do something that results in UB with it. This is why we also can't have `reinterpret_cast`. A long time from now, it is not impossible that constexpr evaluators work in a wildly different way (e.g. some constexpr evaluation friendly bytecode). In that case, the tradeoffs would likely be completely different.
To be clear, `__TIME__` is the joke here. Good luck debugging your ODR violations if you use it that way.
&gt; Right now it's looking like my proposal will shrink considerably into a space between integral integers and big integers, a sort of "slightly larger than integral" integers proposal paper. Got it. You have a 64 bit * 64 bit -&gt; 128 bit multiplication in your proposal. Have you considered adding a 128 bit by 64 bit divrem function to your proposal? Compilers currently lack an intrinsic for that, but it exists in hardware. So `x / y -&gt; (q, r)` where `x` is 128 bit and `y, q, r` 64 bit. The function sets errno or throws a value exception (assuming that proposal is accepted)
I can't comment on less mistakes than JS, that just depends on your views on static vs dynamic typing more than anything most likely. But even if you really prefer static typing, there are plenty of languages that are much easier to use, statically typed, and will still give you good enough performance (Java, Kotlin, etc). C++ is just a hard language to get started in. The other day someone in the cpp slack asked for people's thoughts on an intro curriculum they had put together for people learning C++. Looking through it I was reminded the absolutely crazy amount of stuff people have to know just to write decent (not amazing, or library level) C++.
Certainly, the question was whether C _could_ add the feature, not whether it _should_. :)
I didn't think of that.
&gt; prevent you from making non-constexpr changes &gt; ODR violations Am I talking to the same person? 
I Just did that, And the results are similar to before, the time readAll takes is very less compared to the setPlainText's.