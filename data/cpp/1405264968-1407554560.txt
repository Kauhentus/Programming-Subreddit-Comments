Maybe I'm just stating the obvious, but I would recommend enabling as many compiler warnings as possible and then always building with "warnings as errors". Not really an answer to your question and not really an alternative to static code analyzers, but it has helped me catch many bugs before so I thought it was worth mentioning.
Either I'm using it the wrong way or it is not too strong in finding errors. How are you using these tools?
I really wish I could attend CppCon. It seems stacked with awesomeness!
I second that! Also read the paper! Not just to find out how stack works but also to see unstable code in action.
...and you can use coverage analysis and regression tests to ensure you do...
Why would one use boost's future when promises and futures are available as [part of the language](http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-8-futures-and-promises.html)?
It is not a stupid question at all, AFAIK there is no good online resource that explains how to set up a "modern" CMake C++1y project with llvm support (clang-tidy, clang-format, clang-doc, clang-analyzer, clang-sanitiziers, lcov...). The following command generates a JSON compilation data-base: `set(CMAKE_EXPORT_COMPILE_COMMANDS ON)` I really wish that every time someone develops a new "cool" C++ stack tool they will write a short readme about how to integrate it in an already existing CMake project.
No, it hasn't.. But "then" shouldn't be too hard to implement (Famous last words, right?): template &lt;typename Fut, typename Work&gt; auto then(Fut f, Work w) -&gt; future&lt;decltype(w(f.get()))&gt; { return async([=]{ w(f.get()); }); } 
Hmm. Why does that seem too easy to be correct (does look it though)
Probably due to the lack of robust exception handling..
Is exception handling different with standard futures? I think it's pretty much left up to you, no?
Most comfortable IDE I've used is Visual Studio. Debugger alone makes it amazing. Most I've learned from are Vim and Notepad++ though. They're so bare bones it gets you used to using portable tools to debug stuff, such as cout and exceptions. Vim is a bit of a hassle to get working exactly how I like it though. Which reminds me I should probably set up my Linux dev environment soon...
Coupon codes here: http://www.retailmenot.com/view/oreilly.com I will say, I highly doubt Mr. Meyers made the decision to release it early. This is something his publisher does. It's a sort of "free editing" they get from customers that are really hungry for the content. If it helps you, just ignore this book until it's officially released in October (by schedule, anyway), no skin off your back.
Use the books and build the concept being talk about. Ironically, books are more interactive because you can forward and reverse just by thinking about it and you can be more reactive to the information being conveyed. Books pause instantly too.
The easiest way is prabably getting a through the first couple of chapters (either book or video series) and start working with the learned skills. You'll need a small project for yourself. At this stage (in the beginning) usually people tend to write a little programs to manage something, like their movie collection, photos, music, etc. Managing in this case means categorize whatever you choose from above (for example your movies), rate them, maybe even comment on whether you'd recommend the movie for other people to watch. This way you have a practical application of learned skills and you're required to learn new stuff to keep going.
Maybe you need to write some little programs , rather than passively watching or reading. Write me a program that has a label and a button below it. Make the label display the number of times the button has been clicked.
Figure out what your actual motivation is. If you just "want to learn programming", do a favor for those of us who love it and find another pursuit.
Tequila.
Well, my advice would be to learn via the learning style that works best for you. For me it's reading, I can't stand video or audio guides. Other people prefer video or audio, or trial-and-error with a compiler. (The latter actually doesn't work too well for C++ as you can't tell if your code is correct, or undefined but happening to be correct ths time; if that is your preferred learning style you still need to heavily augment it with another method). 
Yes, you need to learn some other language to make you appreciate C++ more ;) 
Love this suggestion. I agree the "AAA" is the wrong way to go. What is wrong with simply typing it out? Typically the editor will help you on this too. Regardless the person writing it should know exactly what it is, and if they don't then something is very wrong. Also, you should be writing code for the person reading it later and maintaining it. The auto keyword can obfuscate your code. The operations you should perform on objects are dependent on their type. Being explicit about it helps you write better code.
Use it to solve problems, rather than passive learning. I didn't have problem with C++ but I had the same problem as yours with Perl. At first I read books to learn Perl, but I couldn't remember the syntax/usages. I stopped learning for some years because it was boring and not fun. Then one day I wanted to write some small utility to improve my productivity, I used Perl and I just learned anything I met in the work. Later Perl is my primary script language to write utility tools That works for me well.
 I am also of the opinion that its not "fully baked" as the current functionality only solves half the problem but the continuation part seems to only push the bucket down the road as somebody will eventually have to call .get() take the risk of blocking and i suspect "true" async can only be achieved with a functional event loop.
&gt;Need tips to prevent getting bored while learning c++ Learning programming should never be boring. If it's boring, you aren't doing it properly. &gt;I keep getting bored while watching video lessons. Video lessons suck, don't use them. Specifically, they don't let you go at your own pace (very important!) and you can't copy+paste code from them (somewhat less important, but it can get tedious transcribing code from a video). Books are better, but they still have the problem that you can't copy+paste the code. Online text-based tutorials are the best, they have neither of these weaknesses (plus you can easily link to them when you go for help). You can find a C++ tutorial here: http://www.cprogramming.com/tutorial/c++-tutorial.html I haven't used that one in a long time, but I seem to recall it's pretty good. Furthermore, a piece of advice about tutorials: Every time you finish a tutorial, before moving on to the next one, try modifying the code a bit to do something different that the tutorial didn't mention. It doesn't have to be something complicated, even just changing what number gets printed out or something like that. By doing this, you force yourself to think about what the tutorial is actually trying to teach, and it becomes easier to remember the material (plus it's more fun).
There are a couple of interesting actor libraries which I may use in the future.
Ah! Apologies. There's great stuff in boost, but I try to prefer the standard stuff if it is available. I've used boost with great success in the past, particularly the memory pool components.
First learn another language (Python). Never forget: real programmers compile the "thing"!
Do you know of any good free coverage analysis tools?
No worries! Boost is pretty awesome :-)
Is there anything in the book on the use cases of variadic templates? 
&gt; In many cases you need to write your own inner loop, such as the stencil for a PDE algorithm, a non-linear constitutive model, or flux limiters for Euler solvers. Matlab, Python, etc will be orders of magnitude slower for the part of the algorithm that is customized. The standard workflow in Matlab is: * implement PoC code entirely as a Matlab script * check if there are significant bottlenecks * if any significant bottleneck is found that has a meaningful impact on performance, implement the responsible routine (the inner loop you refered to) [in any other language which improves performance and call it as an external function](http://www.mathworks.com/help/matlab/calling-external-functions.html) &gt; Of course you can get excellent speed if you are using canned libraries built by somebody else -- BLAS etc. No argument there. Matlab is a scripting language built around that sort of "canned libraries". &gt; I believe "compiled matlab" just bundles the interpreter with the script you have written; the speed is not better. No, that's far from what Matlab does. Matlab's compiler has been implementing all sorts of [optimization tricks](http://www-rohan.sdsu.edu/doc/matlab/toolbox/compiler/ch06opti.html) for ages. &gt; But all this could be resolved if you, or some other brave soul, would propose a simple benchmark algorithm that we and other sub members program by ourselves, in whatever language we want, and we measure the speed on each other's machines. Have you forgot to provide the proof I asked you in the previous comment? Don't tell me that your assertions regarding how slow Matlab was happened to be bullshit and entirely baseless. Nevertheless, with regards to your reversal of onus trick of asking me for benchmarks after I've asked you and you've failed to provide any, if you were actually interested, you'd know that benchmarks were already presented by brave souls such as the [folks from scypi](http://wiki.scipy.org/PerformancePython). The people at scipy invested a whole lot of effort to optimize Python's script and the best they could come up with was a Python/Numpy combination that called the BLAS routine used by Matlab, and that ran negligible slower than the unoptimized and simplistic Matlab script. 
`gcov`? I couldn't find anything else.
You're missing template overloads for objects that overload operator().
The link to your article isn't working for me. 
The site gives me a bunch of alerts saying it can't syntax highlight cpp. On mobile. 
And there's also the [CMake Tools for VS](http://visualstudiogallery.msdn.microsoft.com/6d1586a9-1c98-4ac7-b54f-7615d5f9fbc7) which is really useful. I work projects that build/run on Linux/Windows/Mac, and wouldn't consider using anything but CMake.
I didn't get the impression you got from the blog. The author clearly states that functions may or may not get inlined regardless of whether you use the inline keyword. The small paragraph you quote really isn't indicative of the post and is kind of presented out of context. In fact the post is trying to get people to stop thinking about inline in terms of the optimization, for which it has no effect, and more in terms of being able to inline the definition of a function with its declaration, so as to avoid linker errors when writing header only libraries. Basically, stop using inline for optimizations and consider using it to write maintainable and easy to use libraries.
&gt; The small paragraph you quote really isn't indicative of the post and is kind of presented out of context. Arg!!! I hate that response. False statements are false, regardless of "context". https://www.youtube.com/watch?v=9hlGuckOY60 What you're really saying to me here is that I'm wrong because the paragraph I cite as in error is a total red herring within the context of the article and doesn't belong there to begin with. That's kinda silly, frustratingly so actually.
No context is important when one wishes to actually understand a point being made. Taking something out of context is usually done when all someone cares about is arguing, or being "right", rather than making a genuine effort to understand something. The article CLEARLY states, going so far as to link to Sutter's GotW article, that compilers may or may not inline functions regardless of the use of the inline keyword. The issue is what is meant by the term "inline", there is an ambiguity about whether it refers to an optimization for the sake of avoiding function call overhead, or whether it refers to inlining a definition with its declaration in a way that doesn't violate C++'s one definition rule (and hence avoids linker errors). The context of "inline" has to do with the second use of the term. Simply put your original post comes across as having been more interested in simply arguing so you could post your own blog post (which in no way contracts this blog post), rather than as an attempt to actually understand or clarify anything proposed by this article. This article makes it clear that it is not about inline as an optimization, but rather it's about inline as a way to make libraries easy to write and maintain. Seen in that context, your reply is just nitpicking for the sake of nitpicking.
Wouldn't `static` be better than `inline` in many of these cases? (My comment on the blog is still awaiting moderation, I will make the same point here) I see three different scenarios: - (1) A 'normal' global function. Defined in one translation unit, but available to others through the use of header files. The linker expects to see exactly one instantiation of the function. - (2) The 'same' function implemented in multiple translation units. This often happens with template functions, and this blog is pointing out that a similar thing happens with non-templated `inline` functions. - (3) A `static` function is strictly available only in one translation unit. The compiler will refuse to create a symbol for it, and therefore the linker wouldn't be able to make it available to the rest of the program, even if it wished. This raises a question for me: What is the difference, if any, between an `inline` function in a header and a `static` function in a header. I would argue that they are similar, but that `static` is safer. With both (1) and (2) above, you have to be very careful that your definitions *and* declarations are identical in meaning in both cases. This point is made, with respect to (2) above. If you fail to do this, you get undefined behaviour. (Am I right about the undefined behaviour?) But with static functions, it's OK for the definitions to be different. The 'same' function in the same header file, but appearing in multiple translation units, are treated as multiple different functions that merely have a similar internal name. It's as if they're all in their own 'namespace'. There isn't the same risk of undefined behaviour. The downside however is that the executable might bloat a little down to multiple (possibly identical) implementations - but a good compiler and linker should (in theory?) be able to avoid this. Basically, I'm saying that everything should be `static` by default, even many of the things in a header file (such as template definitions). The only things that should not be static are the non-template functions which you are determined to keep out of the header file and which you are determined to define in exactly one translation unit.
&gt; The article CLEARLY states, going so far as to link to Sutter's GotW article, that compilers may or may not inline functions regardless of the use of the inline keyword. I don't understand. Are you saying that the article doesn't say what I quoted it as saying, that the author meant something completely different from what they said, or that I am incorrect in my claim that what the quote says is incorrect. Please clarify. If you think that context somehow fixes the statement that inlining requires that the compiler know the definition in each translation unit as not being a false statement, please explain how...don't just claim I'm taking it out of context. &gt; Simply put your original post comes across as... I don't care what you think my post comes across like. That's totally your problem, not mine. You see to be claiming I'm wrong about something but you're not clarifying what that is. &gt; This article makes it clear that it is not about inline as an optimization, but rather it's about inline as a way to make libraries easy to write and maintain. Then he was about as clear as mud there since he quite specifically mentions the compiler as the one who needs the definition. Compilers don't really give a fuck if the code is easy to maintain so I don't understand how you can insert that meaning into what was said. &gt; Taking something out of context is usually done when all someone cares about is arguing, or being "right", rather than making a genuine effort to understand something. As to my purported motives for pointing out the error...nice *ad hominem* BTW...I'm more than familiar with all of the concepts in that article. There's not much here that needs "understanding". Yeah, inlining bypasses the one-definition rule. If that's new to you then this is a good thing to know. If that's all the author said I'd not have any complaint--it's the false statement alone I'm concerned about especially since it's such a widely accepted untruth. My blog (removed now so I can't be said to have an ulterior motive there) pointed out several examples of otherwise advanced C++ developers making this common mistake.
Interesting yes. The former will have a separate counter variable for each translation unit, and the latter will be a single shared one. Good example. But can we say that, in the absence of static variables, there is no difference between the two?
I believe also that the static version has different addresses, while the "inline" one does not. Essentially, an "inlined" function is the same function in all translation units while a static one is not. The inlined one also has external linkage, while the static one does not. There's actually three ways to define a function within a header so that it doesn't voliate the one-definition rule: 1. Declare it as inline - seen in the program as a single function with ~~external~~ internal linkage. 2. Declare it as static - seen in the program as multiple functions with internal linkage. 3. Define it in an anonymous namespace - seen in the program as multiple functions with external linkage. The latter works because each translation unit sees and defines a different anonymous namespace. Of course, you can mix and match all of these. You can declare an inline static function in an anonymous namespace for example.
&gt; Then he was about as clear as mud there since he quite specifically mentions the compiler as the one who needs the definition. I'm being a bit unfair here, lashing at the article author for the frustration I feel at this Kranar person. Could be the author was just misspoken and did indeed mean that in order for it to be legal to declare your function inline you need to make it available to all translation units. This isn't what they said. What they said was quite different in that in order for the *compiler to inline a function* it needs to be declared in all translation units. A compiler inlining something is a pretty specific way of putting it that has pretty clear technical meaning, at least from where I sit, and it's NOT what Kranar is claiming. That makes the article in error here. But it's easy to misspeak and I shouldn't jump on the author just because some ass is giving me shit about my correction. If and when I hear from the real author their response can be judged on its own merit. Hopefully it's not the stupid ass "context" excuse and I don't really expect it to be.
Are C++ exceptions working for anyone? int main(int argc, char *argv[]){ try{ throw ""; } catch (...){ } return 0; } ------------------ 1&gt;Source.cpp(2,2): error : cannot compile this try statement yet 1&gt; try{ 1&gt; ^~~~ I've tried all values for C++ exception handling without success against all versions of the LLVM platform toolset within Visual Studio 2013 Update 2. The comment about Exceptions and SEH is ambigious to me if they are talking about exceptions in general or the `/EHa` (C++ Exceptions with SEH) flag.
&gt; Have you forgot to provide the proof I asked you in the previous comment? Don't tell me that your assertions regarding how slow Matlab was happened to be bullshit and entirely baseless. Uh, ok, I won't tell you that. But I need a workable definition of "proof". What kind of demonstration would be convincing? One demo or many? Are we talking demo problems or are we talking some kind of cosmic "proof"?
I do like this suggestion, in particular, since I've seen students encounter countless bugs resulting from uninitialized variables. Using ```auto``` to enforce initialization still forces one to go to the declaration in order to deduce the variable's type, but since the type is (usually) evident from the initializer, it's a win-win scenario. Even if the exact type isn't evident, the general type usually is. For example, I know that the member function ```begin()``` returns an iterator to the first element in an STL container. I usually don't need to know the exact type of the iterator in order to use it successfully, especially since I can look up the type of the container. 
In your first listing: &gt; var x = new Foo(); &gt; auto y = Bar(1, 2, 3); It's clear that ```x``` is a _pointer_ to a ```Foo``` and not a ```Foo``` itself. 
That makes sense. I made the differentiation based on the assumption of C/C++. 
The sanitizers. They are build into Clang and newer versions of gcc (Although Clang has a few more currently). There are sanitizers for Address, Memory, Thread, Undefined Behaviour, Data Flow. [Clang Sanatizers](http://clang.llvm.org/docs/AddressSanitizer.html) (work the same with gcc, although not all are supported). [Some gcc info](http://www.phoronix.com/scan.php?page=news_item&amp;px=MTIzOTU) Theres a [video talk about them](http://channel9.msdn.com/Events/GoingNative/2013/The-Care-and-Feeding-of-C-s-Dragons) (sanitizers start about 1 hour in).
yeah i fixed that:) http://thetoeb.de/2014/07/15/dynamically-calling-thing-in-c/ 
You realize that you just did nothing but repeat what's already been said, right? Did you really think that you're so important that I'd immediately change my mind when I hadn't before? If you're going to beat on a dead horse, at least try a different angle.
You are awesome!
He is simply noticing that the compiler may inline functions not necessarily defined I the translation unit being compiled, which the article gets wrong as shown in the quote. 
The article doesn't get that wrong though. The article states: &gt;Compiler can decide to inline your function, even if it was not declared inline What the article is referring to is the definition of inline based on the C++ Standard S 7.1.2.4 which states the following: &gt;An inline function shall be defined in every translation unit in which it is used and shall have exactly the same definition in every case (3.2) This notion of inline, which is used to allow for inlined definitions, is different than the notion of inline when discussing optimization. The manner in which "inline" is used by the C++ standard does require the function to be defined in every translation unit that it is used in and the article is correct to point that out.
I have an &lt;any&gt; class skeleton (it's really simple) that I copy, rename and modify as desired for this kind of thing.
This is a good article for beginners wanting to understand the *reason* why string-literals are read-only, but it seems to give the wrong impression that assigning a string-literal to a `char *` is a normal and acceptable thing to do in C++.
good point! I will make that note in the article
&gt; But for many methods there is some unique algorithm that is in the innermost loop (such as a PDE stencil, or limiters for Euler codes). Nobody has made a pre-packaged library for it All of Matlab, Maple, Octave propose an FFI exactly for that, don't they?
Learn the actual language, not what VS shows you. Disable auto complete.
I haven't used auto complete yet, I've seen it pop up but I just keep typing. When you mean the language, do you mean the keywords?
Get a proper book. See the [/r/learnprogramming C++ FAQ](http://www.reddit.com/r/learnprogramming/wiki/faq_cpp) for suggestions.
It is not and the assignment seem to be deprecated in C++. g++ 4.7.2 gives the following warning here on the assignment: &gt;warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings] 
Good to know learncpp.com is a bad resource, I've already noticed the way he teaches it, he misses a lot of stuff. If I copy his code and try to compile it never works, I have to fix it up, which is good, because it forces me to analyze the code but is quite annoying. *edit I ordered C++ Primer plus 6th edition and downloaded the pdf as I wait for it to arrive
I don't exacty understand what you mean. care to elaborate? &gt; I have an &lt;any&gt; class skeleton (it's really simple) that I copy, rename and modify as desired for this kind of thing. 
Exactly, and even in C, this is extremely bad style.
Learn a different language first. I suggest Python. Python takes care of a lot of stuff automatically that you have to do by hand in C++. There are a lot of subtle, tricky ways to write C++ code that seems correct but doesn't work. It's harder to make mistakes in Python, and when you do, it's usually easier to figure out what went wrong. (I love C++ and use it every day, I just don't think it's a good first language.)
It's deprecated in C++98/03 and forbidden in C++11/14. VC doesn't warn, but in VC 2013 the compiler option [/Zc:strictStrings](http://msdn.microsoft.com/en-us/library/dn449508.aspx) was added to forbid the conversion. In VS 14, [the STL was fixed](http://blogs.msdn.com/b/vcblog/archive/2014/06/06/c-14-stl-features-fixes-and-breaking-changes-in-visual-studio-14-ctp1.aspx) to support this option.
Use a command line interface (CLI). You'll learn more by compiling code like that instead of through an IDE. There are plenty of how-to's for both Windows and Unix-based CLIs
That sample-code is awful!
gcov for C/C++ code. It's pretty feature complete so I am not sure why that'd not do the trick.
The advantage over local debugging being...? But they sure got the TLD right.
You should add valgrind support to catch that nasty leak you have in your sample code.
g++ 4.8.3 reports it as warning: deprecated in C++11 (this could be a compiler bug, although I don't feel like trawling through the standard draft to find the relevant text) 
&gt; int globalArray[100]; // will be stored in .text, no initialization You contradicted yourself at the summary: &gt; Executable format (PE or ELF) consists of several sections. Two, most notable, are DATA and TEXT. In DATA all global and initialized variables are stored. In TEXT there is a compiled code. In general, .text is read-only, so unless the global variable is a const, then it will be placed in the .bss section (which is part of .data segment). If it is marked as `const`, then it will either be in .rodata or .text depending on compiler, but it will be placed in a read-only section. 
The operating system makes a decent garbage collector, doesn't it? Only ever makes one pass, though.
Haha you guys rock :^) It's a good thing I wasn't trying to show off my krusty C++ skills. I've been stuck in the interpreted language world for far too long.
That is actually a decent idea. Thanks!
Great suggestion! I'm downloading it right now!
(╯°□°）╯︵ ┻━┻
┬─┬ノ(ಠ_ಠノ)
I took at look at fortran before C++ and it was painfully simple, my dad suggested coball (spelling?) as it's also quite old but he said it's pretty complex too. I figured "if my goal is to learn C++ and pascal, then I should start with C++ as it's more related with what I'm interested in"
+/u/dogetipbot 100 DOGE
+/u/dogetipbot 100 DOGE
+/u/dogetipbot 100 DOGE
(╯°□°）╯︵ ┻━┻ ︵ ┬─┬ ︵ ┻━┻
Thanks for the references. N3337 is the oldest C++ draft I have; is a draft close to C++98 or C++98-TC1 still freely available? 
Drafts between C++03 (aka C++98 + TC1) and C++11, and drafts between C++11 and C++14, are available from WG21's website: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/ The oldest publicly available draft I'm aware of is [N1638](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1638.pdf). This is useful for programmer-archaeology only; C++98/03 is a dead language.
Hyper-V is [integrated](https://en.wikipedia.org/wiki/Hyper-V#Windows_8) into Win8.1 x64 Pro (it has to be selected through "Turn Windows features on or off"; I'm typing this in a Win7 VM on Win8.1 right now). But really, learning a new OS at the same time as learning a new language (especially C++) is asking a lot. [MinGW](http://nuwen.net/mingw.html) gives you the GCC command-line experience in the Windows command prompt.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 18. [**Windows 8**](https://en.wikipedia.org/wiki/Hyper-V#Windows_8) of article [**Hyper-V**](https://en.wikipedia.org/wiki/Hyper-V): [](#sfw) --- &gt; &gt;64-bit SKUs of Windows 8 Pro or Enterprise edition come with Hyper-V. &gt; --- ^Interesting: [^Windows ^Server ^2008](https://en.wikipedia.org/wiki/Windows_Server_2008) ^| [^Windows ^Server ^2008 ^R2](https://en.wikipedia.org/wiki/Windows_Server_2008_R2) ^| [^Comparison ^of ^platform ^virtualization ^software](https://en.wikipedia.org/wiki/Comparison_of_platform_virtualization_software) ^| [^BackupAssist](https://en.wikipedia.org/wiki/BackupAssist) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ciypl1s) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ciypl1s)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Not explicitly, no. They are used relatively often in examples showing `std::forward`, `std::make_shared` and the like, however.
What's the backend? Just GDB? I'm always afraid of running stuff like this, running real compiled code even with maximum execution time and everything on a sever.
Gcc warns about char\* p = "literal" and it proposes using const.
&gt; C++98/03 is a dead language. GET OFF MY LAWN! (or some such) 😉 My workplace still on C++ 2003 standard for production code. Sometimes I want to kill myself over that 😞
As someone new to C++, could you clarify why? I guess using new without corresponding deletes is one? 
[flint](https://github.com/facebook/flint) and [flint++](https://github.com/L2Program/FlintPlusPlus) 
Functions in an unnamed namespace actually have internal linkage in C++11, not external linkage.
&gt; I guess using new without corresponding deletes is one? If you shorten this sentence to: &gt; I guess using new is one? you are right. In modern C++ `new` is rightfully considered an abomination almost all of the time (somewhere deep in the guts of a library it may have it's places, but **never** in application code). For more details see [this thread](http://www.reddit.com/r/cpp/comments/229z4m/how_to_quickly_get_up_to_speed_on_modern/).
this has nothing to do with c++ at all
&gt; The operating system makes a decent garbage collector, doesn't it? Sometimes.
* Main doesn't return anything, that's a paddlin' * Should've #included cstdio instead of stdio.h, oh you better believe that's a paddlin'
* Using printf for basic output instead of std::cout * Including stdio.h instead of cstdio.h (which shouldn't be necessary if you use iostream in the first place) * No return from main * Heap allocating objects for no reason * Using new to allocate objects * Not deleting allocated objects * Using `char *` for strings instead of a `std::string` * Not using a `const char *` * Creating two overloads of the same method, `sayHi`, which actually do two *completely* different things, the second of which is different from what the method name suggests. * Unnecessary C-style casts * Unnecessary constructor initialization in the body instead of in an initialization list ...to name a few.
* new (in this case, just use a stack variable) * mixing C headers and C++ wrapper headers. One should either use &lt;stdio.h&gt; and &lt;math.h&gt; or &lt;cstdio&gt; and &lt;cmath&gt;. A C++ purist would say use &lt;cstdio&gt; and &lt;cmath&gt; * std::abs (from cmath) returns an int; there is no need to cast its result. * C-casts; One should use C++ cast operators instead *if they were needed* * Constructor initializes members in body, not in initializer list. * The Person class is not const correct. * The use of char* over std::string. * 'this' and leading underscore notion both used. (This is a style thing, but it's ugly to me.) * The use of printf over streams. Streams are typesafe. There are places for printf in performance-critical sections of code, but the example doesn't highlight one of these use cases. 
&gt; What's the backend? Just GDB? To make stepping through the code possible, yes, essentially just gdb. That's likely going to change though. And yes, the code being run is sandboxed and has max execution time/cpu limits/etc. Everything isn't perfect with the site yet and some things we're still trying to find the best solution for, but it's been working pretty decently so far. Plus, it's been fun to develop. &gt; I'm always afraid of running stuff like this Everything could be rebuilt in short order. That thought isn't so scary when you try to design the whole thing to be burnable.
I'm going to stick with learning in an IDE first, if I really need to use a CLI I'll learn it at the time. 
I got an ubuntu disk laying around somewhere...
Yea, it's pretty easy to do. VMware is a fun program :)
This does not work if a class has both the const and non-const version of operator(), like for example the result of std::bind.
&lt;any&gt; is just a class containing a pimpl of an instantiated implementation wrapper with a base class that implements a virtual clone() function. Using it at as a template and adding other functionality beside clone() enables you to have a value semantic container capable of holding any type providing any set of functionality you like. Sean Parents 'document' example does this by providing a 'draw()' function.
I would generally agree – with the caveat that exceptions are hard to encode in the type system. Making the failure type explicit might therefore be preferred. Take the `load_image` example: in languages such as Haskell, the type of the function would encode the possibility of failure. And in fact, an IO failure is hardly exceptional – since we’re dealing with external entities not under our control here, failure is quite expected. The closest approximation C++ gives us would be something like std::optional&lt;image&gt; load_image(boost::filesystem::path); Although `std::optional` of course still allows subverting the type system (and consequently triggering an exception) upon invalid access. I would love for a type which makes this impossible (as in Haskell), but without a nicer `fmap` syntax that’s probably too much of a syntactic burden. Still, [Eric Lippert argues that you should almost never use exceptions](http://blogs.msdn.com/b/ericlippert/archive/2008/09/10/vexing-exceptions.aspx). In his taxonomy, the `load_image` case is *arguably* a vexing rather than an exogenous exception, and thus shouldn’t be one. Regarding your `std::find` example, this is akin to the [null object pattern](http://en.wikipedia.org/wiki/Null_Object_pattern): we return a special object, but unlike a null pointer this is a *valid* object, and we *can* safely perform (some) operations on it. Beyond these examples, I would urge the reader (and the author) to consider encoding failure into the type of a function whenever possible.
Great response. I hadn't read the Eric Lippert's article. I do disagree with his definition of vexing exceptions, but mostly because we disagree on where the line is between a non-exceptional and exceptional situation. If I can't return the object I promised, I feel it should be an exception. Edit: I had more of a think about this. His argument about vexing exceptions is that the input is often user provided, so an incorrect file path is probably quite likely to occur and therefore not exceptional. However, I find this reasoning is a little bit dated (while still relevant). Modern interface design is moving towards providing abstractions such as exposing content rather than file paths. In fact, file open dialogs were the first iteration of this abstraction. More recent iterations just list the relevant content, without having to deal with the file system at all. A modern interface wouldn't make it possible to give an invalid path to the `load_image` function except in an exceptional situation. Of course, my advice is perhaps a little idealistic, particularly because command-line applications do not (yet) provide these abstractions. But that's how I like to be - code for the way it *should* be. I find that the negative implications of using exceptions in this way in the existing climate will be negligible.
So, basically a C++ macroexpand? More useful in C than C++. Possibly.
&gt; Main doesn't return anything, that's a paddlin' That’s correct. `main` is the sole exception in C++, in that you can omit the `return` statement. The return *type* still has to be `int`, and the code does this correctly. 
&gt; Including stdio.h instead of cstdio.h (which shouldn't be necessary if you use iostream in the first place) It’s `cstdio`, not `cstdio.h`. &gt; No return from main Unnecessary: `main` is a special case, `return` can be omitted here (but only here; §3.6.1/5).
I can't find the post but in the past someone proposed using something more like the Error Monad rather than the Maybe Monad, allowing you to return the exception object or the value. Its a bit nicer than optional or try_functions because you can pass back to the user more meaningful information on why it failed.
`boost::filesystem` and `std::experimental::filesystem` disagree about not returning errors via output parameters. In fact, they seem to prefer it.
I know that, but it isn't a part of C++ now.
At least in `std::experimental::filesystem`, most functions provide two overloads. One that throws exceptions (as I've described) and one that uses an error output parameter. I can understand why they would not use an `std::pair` for the output for the latter overloads, because then the return type would not be uniform between them.
&gt; I think it would be better to make `std::optional` a range But it's not a range of things, it's singular. Using language constructs which generally deal with multiples of things is just confusing. Also, is your proposed usage for(auto&amp;&amp; image:load_image(path)) { ... } else { std::cout &lt;&lt; "Can't load image"; } really all that different from if (auto i = image:load_image(path)) { // use *i } else { std::cout &lt;&lt; "Can't load image"; }
Making `std::optional` a range is a pretty interesting idea that I haven't seen before. However, the `else` in Python will execute when the list is exhausted and not if the loop is broken. How would you expect it to work in your example?
&gt; Eric Lippert argues that you should almost never use exceptions. I just read the article and... one can't conclude this from it. In languages without pattern matching, putting error conditions into type system is pretty impractical. Digression on Eric's exogenous exceptions example: I don't like both his original code and the attempt to fixing it (which is arguably intentionally poor). Example is: try { using ( File f = OpenFile(filename, ForReading) ) { // Blah blah blah } } catch (FileNotFoundException) { // Handle filename not found } The obvious culprit if OpenFile, and the "correct" solution is make OpenFile return e.g. null if file is not found (or make a wrapper around to do that it if changing OpenFile isn't an option).
Agreed on both counts. I like your way of thinking about *getting* versus something like *find*.
&gt; But it's not a range of things, it's singular Its not singular. Its a range of 1 or 0. &gt; Using language constructs which generally deal with multiples of things is just confusing. Its confusing using language constructs for pointers, on a type that has value semantics. Its not confusing to have a range of 0 or 1.
I did an implementation of this with boost.preprocessor, it looks like so when defined: TYPE_ERASE( (ObjectTypeErase), (()(void))(update)((int) a, (float) b), (()(void))(test)((const SomeType*) var), ) And then when used: ObjectTypeErase a = SomeStructThatHasThoseTwoFunctions(); a.update(4, 5.4);
You should head over to /r/learnprogramming and /r/cpp_questions .
You should also know that C++ is really not suited as a scripting language. You're better off writing the core engine in C++ and using something else for scripting, be it Lua, Python, C#, Javascript, UnrealScript, etc -- and that's exactly what Unity has already created for you. If you just want to get down to business and create your game, there's no point recreating Unity yourself!
thank you very much for the response! after looking around a bit i guess it would be better for me personally to master unity and then learn c++ when i already have a better grasp of things. thank you again.
&gt; Eric Lippert argues that you should almost never use exceptions All such proclamations are invariably due to people trying to code in C++ like they would code in any other language. There are certain techniques (RAII, for example) that you need to be proficient in, and then you can program using exceptions and every other feature of C++ and write beautiful and correct code. Spend the time to watch Jon Kalb's excellent talk on using exceptions at www.exceptionsafecode.com - he explicitly calls out statements such as "don't use exceptions" made by well-known people in the field and shows how to code correctly using exceptions.
&gt; std::optional Or, even better, `std::expected`. http://www.hyc.io/boost/expected-proposal.pdf
This is incredible, good work. Trying it out now.
Er, how? There's no links to the actual library anywhere.
People still develop for Windows? 
I've always found it frustrating that Microsoft introduces new syntax and language extensions for a lot of their technologies, when they could just use existing C++ syntax to accomplish the same thing, in fact they could use existing C++ syntax and it's often cleaner and more idiomatic. While it's definitely good to see that someone is going to the trouble of providing a standard, idiomatic way of using Windows on C++, it's just very unusual that it's not Microsoft doing it.
You sir are a premature post-jaculator.
&gt; All such proclamations are invariably due to people trying to code in C++ like they would code in any other language. That’s simply not true, as anybody who’s familiar with [my style of C++](http://stackoverflow.com/search?q=user%3A1968+%5Bc%2B%2B%5D+is%3Aanswer) knows. I’m simply *not* arguing that we should never use exceptions, or – even worse – that we shouldn’t write exception safe code. I’m arguing that we should *almost* never use exceptions, that’s very different.
The difference is slight: with the `for` loop, you have automatically dereferenced the argument inside the loop body. The range-based `for` loop could thus be generalised to deal with binding an object to a limited scope: [Article: (Ab)using range-based for](http://loungecpp.net/w/%28Ab%29using_range-based_for). Concerning the remark “it’s not a range”: There are lots of peer-reviewed pseudo-codes which used singular or empty sets to denote optional elements, so there’s ample precedence, even if it’s unfamiliar to programmers. But I agree that it’s quite confusing. Having a `with` block for this would be nicer.
It's called 'vendor lock-in'. Please let us all remember J++, WinMain, \ instead of /, etc. 
Nope, everyone suddenly stopped about 3 weeks ago, this is just a parody.
&gt; with the for loop, you have automatically dereferenced the argument inside the loop body. I agree that is neat. It makes me wish there was an `if` counterpart to the range-based `for` along the lines of: if (auto&amp;&amp; a : b) { } which would be some sort of syntactic sugar for if (b) { auto a = *b; } In spite of that missing piece, I still personally *feel* like viewing `optional` as a range (or set) of 0 or 1 is the wrong metaphor. But it's only a feeling.
I don't see any license? This seems like too big an effort to be FOSS unfortunately. I hope I'm wrong.
I thought the slash thing was just VMS style, not a deliberate way to differ from UNIX.
Weird, that account was registered 3 years ago and the only 4 posts it has were published 3 years ago, 3 months, 2 months and this one, spewing nonsense.
Euh... I don't know anything to speak of about C++/CX, but I know about C++/CLI. The thing is, it's a glue between native and managed and there's *a lot* of friction. I think that mixing GC-ed and native classes etc would have resulted in a bigger mess than that separate syntax.
This paper http://www.gotw.ca/publications/C++CLIRationale.pdf might be worth reading. It explains the design process behind the C++/CLI extensions.
&gt; and was chosen by IBM, not MS CP/M came from DRI, QDOS (aka 86-DOS) was already using '/' as the switch character when it was licensed to Microsoft to become MS-DOS. IBM didn't have anything to do with it. The choice of '\' as the path separator probably came from Microsoft too, as Microsoft's developers were almost certainly more familiar with UNIX at the time. Microsoft first shipped a UNIX-based OS (Xenix) in 1981 and this was apparently their standard "workstation" OS inside the company, IBM didn't until ship AIX until 1986. MS-DOS 2.0 (first version with subdirectories) shipped in 1983. Many of the MS-DOS 2/3/4* features were influenced by UNIX, particularly Xenix. \* There are two OSs known as "MS-DOS 4"; the multitasking version released only to a small number of OEMs in 1986 (which was a precursor of OS/2 - originally codenamed "DOS 5") and the "ordinary" evolution of MS-DOS 3 in 1988.
&gt; I'm arguing that we should almost never use exceptions My position is that we should not always use exceptions - but that's not the same as "almost never". If you have time to watch Jon Kalb's talk, I'd like to hear your criticism of it. Thanks! 
It is already linked right here on the right (look under "Books")
In the same position as you. Learning C++ with no previous programming experience. What book did you get out of interest?
It seems that the message from Microsoft is, use C#. The mess they have created on the native side is nearly incomprehensible to anyone wishing to keep their sanity.
&gt; I really don't want to learn C++ by making text games and "hello world" console applications. FWIW, I (and many other C++ users) don't think that it's possible to avoid doing the "necessary" beginner projects. C++ is a huge language with lots of power. To use it correctly, you will go through many hours of honing and making simple projects before diving into a complex one, like a video game. Because of this fact, products like Unity exist. They expedite and ease the process. 
Didn't Microsoft add an option to change either the switch character or the path separator (or both?) fairly early because they preferred Unix style themselves? I certainly know that a lot of the early MS-DOS development was moving towards a Unix style and away from the CP/M style. For example CP/M accessed files through File Control Blocks (FCBs), and QDOS (and therefore MS-DOS) had very similar FCBs for compatibility. IIRC the official fields were all identical, but since few CP/M programs were well behaved, they often used reserved fields that were defined differently by QDOS - also the QDOS/MS-DOS FCBs were larger. However, MS-DOS very quickly adopted a handle-based approach based on Unix after Microsoft took it over. So early MS-DOS had two different ways to access files - effectively two APIs, one based on CP/M, one based on Unix. If Unix was already so great, why didn't people just use that? First off, for minicomputers many people did, but the PCs (and other microcomputers) of the time just weren't ready. When Apple released the Lisa and the first Macs, they also had a non-Unix operating system (it wasn't until OS/X that they switched to a modified BSD). The same for the Amigas and Atari STs - actually the ST operating system was based on Digital Researches MS-DOS compatible PC operating system DR-DOS and it's GUI layer for PCs GEM. Second, which flavor of Unix? At that time, there were different mutually-incompatible variants of Unix and efforts to bring order to the chaos were pretty ineffective. Before 1997, POSIX had standards for various bits of Unix as far back as 1988 IIRC (I'm guessing they were standardized piecewise to be adopted piecewise, though I don't really know that), but that's still way later than the first IBM PC in 1981, and it always takes time for standards to be adopted. So Unix was fragmented until after MS-DOS was both established *and* rapidly becoming obsolete, with Windows 95 was already in common use before the "Single UNIX Specification" was adopted by ISO in 1997. Probably Unix shot itself in the foot by not being ready for the microcomputer revolution. Besides, those that love to criticize MS-DOS and Windows for doing the wrong thing (with "the wrong thing" seemingly always defined as not being what Unix does) should note that the Unix convention of using linefeed alone for line ends is the wrong thing according to the ASCII standard. Just as Microsoft once jumped the gun with early adoption of what would later become ISO-8859-1 and got it wrong (hence Windows-1252), Unix (or rather Multics) jumped the gun with early ASCII adoption. That's why e.g. many internet protocols require the "DOS" line end convention - it's nothing to do with DOS or Windows, it's what the ASCII standard referenced by the RFCs requires.
VMS doesn't use slashes. VMS style paths look like this: NODE::DEVICE:[PATH.TO.FOLDER]FILENAME.EXT;VERSION NODE - Optional. VMS is a clustered OS must disks are mounted cluster wide. You only use this rarely. DEVICE - Like a windows drive but more powerful. Its actually what's known as a logical. Logicals are environment variables on crack. You get a clustered key-value store with primitives for locking. You could set these logicals to be available at the process,job,user,group,node, or cluster level. You could provide a flag at creation time that would make it act as a VMS device. [PATH.TO.FOLDER] - .'s separate folders which are stored in a directory as FOLDER.DIR. FILENAME.EXTENSION - All files have extensions ;VERSION - The vms file system also would create a new version of the file once a write file handle (not sure about the exact internals) was closed. VMS used /'s for parameters to commands like DOS and NT do today. 
Hehe, I'd use a library :) At the end of the day the idea is to get the pixel information (RGBA) from the image file, which may be compressed, uncompressed. BMP is a fairly simple format, I'd recomment starting with that one and then moving to others, like PNG, just to get an understanding of the steps involved. http://en.wikipedia.org/wiki/BMP_file_format http://en.wikipedia.org/wiki/Portable_Network_Graphics This is an old, old piece of code I did to learn. Hope it helps. http://pastebin.com/Ri41H8ih 
Every thread I've found has said to use a library... I do think it may be the best way to go. I'm mainly curious as to how hard it is to read the data from the image files. I'll take a browse through your code and see how bad it actually is. Thanks for the reference. Edit: Yeaaaah.... Now I see why everyone says to use a library. 
I can send the array to the OpenGL image functions right?
You have to flip it first, but yes. There's plenty of tutorials on it.
There are good reasons why a library is recommended for image processing. Aside from not re-inventing the wheel, many libraries use special techniques to improve performance. For example, there is the [libjpeg-turbo](http://libjpeg-turbo.org/) uses SIMD instructions which allows the library to perform at least 2x faster than the regular libjpeg. Another good example (and good reason to use library) is the [OpenCV](http://docs.opencv.org/doc/tutorials/introduction/display_image/display_image.html) which can take advantage of GPUs to process images a lot faster than your CPU. Delegating work on your GPU can let you use your CPU for other work. Since you are doing some gaming stuff, I think this will be up your alley.
Well, it is modern C++ Library for **Modern Windows**. Windows API (WinRT in particular) uses `wchar_t` as first class character types (functions that end with 'W'), as well as its [Platform::String](http://msdn.microsoft.com/en-us/library/windows/apps/hh699879.aspx) class. Using other encoding types will just be inefficient as you will need to convert them to wchar_t before passing to Windows.
Use [`char16_t`](http://en.cppreference.com/w/cpp/language/types).
Jumping Into C++ by Alex Allain. The reviews said it was good for people with no experience at all, and I've found that to be the case so far. 
`char16_t` is useless in Windows. You can see here: [http://msdn.microsoft.com/en-us/library/69ze775t.aspx](http://msdn.microsoft.com/en-us/library/69ze775t.aspx). At end it says: &gt; The U, u, and u8 prefixes are not supported. The only way you can use `char16_t` with Windows API is making the assumption that `char16_t` is `wchar_t` (which maybe OK under Windows), and you will need to make your `char16_t` usage like: const char16_t* myString = L"Hi!"; As it will be the only way to create 16-bit character strings from a string literal without any conversions.
Depending on the format it can be somewhat hard, even something as simple as TGA has a number of possible internal formats for RGB, RGBA, 16/24/32 bit and run-length encoding.
huh? Why do you need to flip it? Last time I used stb image I didn't have to flip the image.
You said useless "in Windows" but I think you meant "with Microsoft's shoddy compiler". I should also point out that WinAPI uses typedefs for its string types, so while it guarantees it takes UTF-16LE strings (which have 2 byte code units by definition) there aren't really similar guarantees about the precise character type. 
What are ~85% market share at all.
I agree completely. Even microsoft advise that you write standard c++ though, and only use their extensions in the thinnest system interface layer you can manage.
&gt; You said useless "in Windows" but I think you meant "with Microsoft's shoddy compiler". Yes, you are correct. 
Reading the binary data is easy with the standard file IO functions. But if it is compressed (like jpg or png) you would have to decompress them, which I guess you do not want to do manually. There are image formats like ppm, which are uncompressed and very easily parseable.
Perhaps it started with VMS, but it was also a good thing to avoid unix conventions. 
stb image uses top left coordinate where OpenGL uses bottom left.
Platform specific applications is one thing, taking established standards and altering them is another. Microsoft took Java and turned it into J++. There was no other reason to do that except vendor lock-in. Microsoft took main() and turned it to WinMain(). There was no other reason not to use main() except vendor lock-in. Microsoft took c++ and turned it into c++/cli. There was no other reason to do that other than vendor lock-in. There were no technical reasons for the above. But there were valid marketing reasons. 
&gt; Microsoft took main() and turned it to WinMain(). There was no other reason not to use main() except vendor lock-in. You can still use main(). &gt; Microsoft took c++ and turned it into c++/cli. There was no other reason to do that other than vendor lock-in. Except making something possible that wasn't before...
See also Standard C++ Foundation's "Get Started!": http://isocpp.org/get-started // also on the sidebar, to your right :-)
&gt; You can still use main(). No, you can't in Win32 applications. &gt; Except making something possible that wasn't before... Yeah, adding new capabilities to a standard is a certain way to lock in your clients. 
&gt;&gt; You can still use main(). &gt;No, you can't in Win32 applications. You can. Change the entrypoint to mainCRTstartup. &gt;&gt; Except making something possible that wasn't before... &gt;Yeah, adding new capabilities to a standard is a certain way to lock in your clients. There was no standard to combine C++ with CLR to begin with. It's a standard now. 
Are you really trying to claim that the thing that makes it hard to use applications written for Win32 on other platforms is the name of the entry point?
&gt; You can. Change the entrypoint to mainCRTstartup. Still, it is not main(). &gt; There was no standard to combine C++ with CLR to begin with. It's a standard now. No, C++ was a standard, bastardized by MS with c++/cli. 
I replied to the post and realized sometime later that the library is not yet released. Since reddit is not my life and soul and I forgot about my comment above. I guess I committed a serious crime for the mighty redditers like yourself ;) - having only 4 posts in total (I guess this one is the fifth!)
Does this interface with LAPACK, BLAS, etc. or is the purpose of this not for linear algebra?
Excellent, thanks! You feel like having a chat about your experiences so far? If so I will PM you. Would be good to chat to somebody else in the same boat as me!
Thanks for the info!
&gt; You can still use main(). Not if you don't want it to start as a "command-line application." The WinMain entry point exists only to distinguish "graphical" from "command-line." The technical differences are: * `main` provides the command-line arguments (and their count) and the current environment as arguments to the entry point. Additional information about the process can be gathered from a handful of system calls. Windows runs the program in a dedicated "CMD" window that cannot be closed without killing the program. * `WinMain` provides a pointer to the process in memory (which, as far as I know, has no practical use), an always-null pointer (called "previous process!"), concatenated `argv` minus program name (you will probably end up using `GetCommandLine` anyway), and the starting window state (which shouldn't be the responsibility of the application in the first place). Windows starts the program invisibly, and the program optionally creates its own window. There is no technical reason for this second entry point to exist, except to complicate porting. &gt; Except making something possible that wasn't before... ... Such as? I can find no features in C++/CLI that are not provided or obviated by common smart pointer implementations. Everything added to C++/CLI exists to make .NET semantics available as low-level syntax.
I've had pretty good luck using [FreeImage](http://freeimage.sourceforge.net/). It wraps quite a few other image libraries into one, easy interface.
&gt; what are the key differences Basically everything that goes beyond the most basic control-structures and arithmetic operations: The languages may look quite alike [but their semantics are extremely different](http://florianjw.de/en/modern_cpp.html#cpp_is_not_java). Basically: If you know any OOP-language besides Java, I will assert that this language, no matter which one it is, is much closer to Java than C++. C++ has older, IMHO much more reasonable, semantics and idioms and as aguerooo said, the best thing to do is to treat it as something completely new.
You should _really_ go for a good IDE. Auto-completion and good debugging, integrated into your IDE, will make your life so much easier. I'd recommend Visual Studio, it's surpassed by nothing. However, good alternatives are QtCreator or anything YOU are comfortable with. Also I'd recommend you start using a build system like CMake soon to make and keep your code fully cross-platform compatible. It also allows _you_ to switch and test IDEs easily.
https://isocpp.org/wiki/faq More specifically... https://isocpp.org/wiki/faq/csharp-java
You need to forget what you've learned *initially*. This is because some things that are correct in C, or in Java, are wrong in C++. So get yourself book and approach C++ as if you are starting from scratch. Don't be disheartened though, what you know from C and Java will still stand to you, but try to approach C++ as being a fresh start. As you progress you'll see how adapt your Java knowledge into your C++ coding.
Particularly applicable when coming from Java: #0. **Do NOT use `new`!** Ever. Really. At all. ^(// At least "while learning" -- as in, say, until you've been actively using C++ enough to know the when to use ordinary value variable vs. `std::unique_ptr` vs. `std::shared_ptr`) #1. **Only** use dynamic / run-time polymorphism if you _really need_ the _run-time_ part -- otherwise, consider using static / compile-time polymorphism for type-safety (including compile-time contract enforcement), performance, and ease of use (e.g., no pointer/reference chasing to step through when debugging). ^(// see, for instance: https://isocpp.org/wiki/faq/big-picture#generic-paradigm and https://isocpp.org/wiki/faq/big-picture#multiparadigm-programming // come to think of it, the entire thing may be worth a read: https://isocpp.org/wiki/faq/big-picture) Related /r/cpp/ threads: - [C++ for Java Programmers (RFC from those that learned C++ after learning Java)](http://www.reddit.com/r/cpp/comments/vq3re/from_java_to_cc_any_advice/) - [From Java to C/C++, any advice?](http://www.reddit.com/r/cpp/comments/vq3re/from_java_to_cc_any_advice/)
While VS is the unsurpassed king of IDEs, MS support of C++11 &amp; C++14 is somewhat behind, albeit improving. I prefer Clang or g++ with XCode.
Strange. Why not wrap LAPACK directly if that is the case? More so C++ needs more native implementations of libraries and in some cases the goal should be inclusion in the next rev of C++ as part of the standard library. I don't want to dismiss the effort here, just that I sometimes think we have to many wrapper libraries being written for C++. 
Even comparing C++ to C is hard. C doesn't have classes, it has structures, but these are typically used to bundle related variables and then are accessed or modified with external functions. I think the first difference you'll run into is that the keyword `new` means totally different things and C++ doesn't have a garbage collector. In C++, an object goes out-of-scope when the scope it was declared in exits. For example, if I wrote this: void myFunc() { int* myInt = new int(10); std::cout &lt;&lt; *myInt &lt;&lt; std::endl; double x = 3.141 * *myInt; std::cout &lt;&lt; x &lt;&lt; std::endl; } There are two variables created here - `myInt` and `x`. They both get deallocated when the `}` is reached. Now the important thing is that `myInt` is a *pointer* that holds a memory address which is presumed to be the location of a valid integer. Since it was created with `new` this is somewhere on the heap and is dynamically allocated. The size of an integer is typically 4 bytes, but C/C++ needs to keep track of the heap, so in practice this probably used 8 bytes of memory. Plus the 8 bytes (on a 64-bit machine; 4 bytes on a 32-bit machine), to actually store the pointer itself. When the scope exits, only the pointer's 8 bytes are returned. The actual integer remains in place, and that memory address is not returned to the heap. In Java, eventually this variable would be deallocated by the garbage collector and you wouldn't need to worry about it. But in C/C++, you explicitly need to call `delete myInt;` at the very end of the function. Or really, anywhere after you're done *using* `myInt` would be fine. The other issue is passing objects around. If I have `std::string Rearrange(std::string x)`, and `std::string Rearrange(std::string&amp; x)`, the first one makes a copy of whatever string you pass in. The second one absolutely needs a `std::string` to be defined first so you can't call `Rearrange("Hello World");` or even `Rearrange(std::string("Hello World"));` but you need to call `std::string x = "Hello World"; Rearrange(x);`. With the first form `Rearrange("Hello World");` is perfect - it creates a `std::string` from the literal `"Hello World"`. There is also another way, which is `Rearrange(const std::string&amp; x)` [also valid is `Rearrange(std::string const&amp; x)` and these mean the same thing]. The keyword `const` here means that you can't do anything which isn't marked `const` to that object. However you can instantiate it like our first form - the call `Rearrange("Hello World")` works, as does the version where we first create a `std::string`. This version however doesn't make a copy of a `std::string` like the first form would. This is important when we call it via the second method, rather than using the string-literal. Essentially C++ will copy things all over the place and Java tries not to. Java is less consistent about this - it copies built-ins but not user defined objects. C++ copies everything. In C++ with small types it's actually faster to copy: int Square(int x); int Square(const int&amp; x); The second version is ever so slightly slower here. TL;DR: Don't use `new` until you understand what it does. Even then, prefer to only use it with `std::unique_ptr`. C++ loves to create copies of objects if you let it.
They're big and scary. [Here's a good write-up.](http://jeremykun.com/2014/01/17/how-to-conquer-tensorphobia/)
&gt;C++ loves to create copies of objects if you let it. Modern compilers and C++11 are good about eliding unnecessary copies when returning by value through the [return value optimization](http://en.wikipedia.org/wiki/Return_value_optimization) and in [other situations](http://en.cppreference.com/w/cpp/language/copy_elision). 
do stuff on the stack and not the heap. use const religiously. don't do inheritance hierarchies unless absolutely necessary. And I mean absolutely necessary.
If I remember correctly you can use a different compiler in VS. 
Looking at StackOverflow comments, it seems like it is possible *in theory*. 
The importance of 0. can not be overstated. If you follow this, you shouldn't have any serious problems (esp. leaks) with memory management while still learning how it works and what it does.
&gt; They both get deallocated when the } is reached. Add a delete or use a smart pointer on myInt?
&gt;prefer to only use it with `std::unique_ptr` `std::make_unique`
in differential topology, a p-tensor is a function that takes p arguments from one vector space and is real valued, and is multilinear, so it is linear in each variable EDIT: seems this is the "multilinear" view, where the "multidimensional array" view is more on topic with this thread, but oh well
Don't use a naked* new.
This short book should get you on the right track: http://www.stroustrup.com/Tour.html
Dat pun at the very end.
C/C++ is **not** a thing. &gt; I say C and C++ in that some drivers/libraries and whatnot are accessed through C APIs which can easily be done when using C++. People don't go around and say C/Haskell just because some drivers/libraries are accessed through C APIs. Stop using that term, please. 
Someone should give you gold for noticing.
Fairly sure there was a post about clang windows support and integration for VS awhile back. http://blog.llvm.org/2014/07/clangllvm-on-windows-update.html https://github.com/ishani/ClangVSx
&gt; Java is less performance sensitive to mediocre code compared to C++. By that I mean that amount of "performance" you lose from writing mediocre code is relatively small compared to the performance loss one can achieve by writing unpleasant C++ (thanks to hotspot) I've always found that C++ lets you write really terrible, brute force approaches to problems, throw -Ofast at the compiler, and watch it do ridiculous performance magic &gt;Tooling for Java is more mature and robust. "Refactor-&gt;Rename Method" for example is a real pain if your IDE doesn't support it. I have to really disagree with this. The tools I've used for java frequently explode, and everything is very bloated, slow, and prone to crashing. C++ has VS, GCC, and Clang with a generally pretty reasonable choice of IDEs, and the number of issues I've had with them can be counted on one hand
&gt; Not if you don't want it to start as a "command-line application." Just try it. Create a Win32 GUI app (aka `/SUBSYSTEM:WINDOWS`) with main() and set the entrypoint to mainCRTstartup in the linker settings. &gt; There is no technical reason for this second entry point to exist, except to complicate porting. True, there's no technical reason. But it's legacy and MS doesn't dare to change the implicit linker settings. Still, you're not forced to have a WinMain(). &gt; ... Such as? I can find no features in C++/CLI that are not provided or obviated by common smart pointer implementations. Everything added to C++/CLI exists to make .NET semantics available as low-level syntax. Mixed-mode assemblies are the primary use for C++/CLI, i.e. seamless integration with the CLI. The CLI memory model is incompatible with pure C++ semantics because the latter has no notion of implicit GC.
&gt; I've always found that C++ lets you write really terrible, brute force approaches to problems, throw -Ofast at the compiler, and watch it do ridiculous performance magic Not only ugly brute force code, the c++ standard library would be almost unusable without an optimizing compiler. Some of the templates can produce tons of unnecessary instructions. &gt; I have to really disagree with this. The tools I've used for java frequently explode, and everything is very bloated, slow, and prone to crashing. I use Netbeans with very few plug-ins and a lot of RAM, it works quite well. Of course my configuration is not very enterprise oriented and avoids all these fancy/bloated project and dependency management tools. 
Refactoring and code exploration in VS is *poor* for C++ without expensive third party plugins though. Someone coming from Java would especially notice this.
&gt; However - of the C++ tools - how many of them implement that refactoring I mention - I think VS may be the only one? Eclipse CDT kind of trys but I can't bring myself to use that awful thing. QtCreator, KDevelop, Code::Blocks?
&gt; You'll really enjoy the STL, and also the ability to compile your program without needing to attach published applications with a pesky JVM or force users to download the JVM. Be sure to check out rvalue references, and RAII, they're the bees knees. I notice your sarcasm, but that's absolutely correct. (Maybe except the rvalue references nobody really enjoys, but sometimes they're just necessary)
No sarcasm, C++ is my second favourite language (behind python). Also r-value refs are sweet, they give you the best of both worlds of references and pointers.
There are a lot of good answers here already, I got back into C++ after many years of many other languages just a few years ago too. I will apply my 2 cents. NOTE: I'm not an expert, this is just my understanding and with my own words. * C++ forces you to be more aware of the hardware, specifically memory. Other languages tend to virtualize things a lot for memory, or otherwise manage the memory for you. For example you can make any type of class or data type and throw it through a function as an argument in many languages without worry, but this will become more complicated in C++ as you worry whether you are going to send the actual memory itself or a pointer to the memory, the difference is tremendous, and many things might not work as you expected with other languages. * Also with memory, you will become more aware of the difference of making memory on the fly after the program is running vs. having it prepared in advace. You will be warned over and over that if you use "new" to create new memory on the fly - you had better execute "delete" of that memory before the program ends! And what if it crashes? So things can get "dangerous" they say. * The above mentioned has a very tough learning curve, but the benefit in return is very rewarding as you should notice significant speed increases in your programs when everything is managed appropriately, and with new learned understanding of memory you might find a lot of need new tricks you can do to lighten your code, speed, and efficiency. * want to turn a String into an Integer? A float into a String? No problem! You'll just spend a few weeks making your own classes to do that (sarcasm!), because C++ doesn't come with native functions to handle a lot of this common stuff. No .toString(), nor .parseInt(), etc. unless you find some libraries to do it for you, but I recommend making your own. * You might find runtime bug testing to be more difficult, a single "segfault" message might be all you have to work with, and you'll need a debugging software if you can't figure it out yourself. You asked about key differences coming from this language to that one, these are my experiences as listed above. Otherwise a class is a class and a function is a function, of course syntax varies a lot. You also might find yourself managing a bit more code in class and function declaration in C++, but again there is a benefit of much less long-winded syntax that comes in Java, in my opinion. And then there is usage. You could say that there are things you can do with C++ that you can't do with Java, and vice versa. C++ would probably be better for low level embedded systems with little memory and high efficiency requirements - while still, you can also make a modern game in C++, but you might find it easier with packages provided for other languages like Java, not everyone will agree with that depending on the definition of "easy". 
have an upvote, your point was valid and I'm sure everyone agrees to a certain extent, I put exactly the same as one of my various points. But when I first read your post and got the "when you fuck up"... er~~ maybe that started some negativity for you, although I don't mind myself.
QtCreator also supports CMake projects and with the clang backend for code analysis (and also refactoring IIRC) refactoring works very well. And the import issue does only appear to be with qmake based projects, which doesn't make much sense with plain C++ without any use of Qt anyway. A quick workaround would be "find . -name \\*.cpp &gt;&gt; project.files". I can't tell anything about Code::Blocks, as its GUI is just horrible IMO and a bit blown. Also it crashed once and I uninstalled it. KDevelop is like Code::Blocks, but way more stable. KDevelop also runs on OSX, FreeBSD and Windows.
Also you can just program in C from within C++; to me C++ gives you the freedom to be a hardcore C programmer who can use C++ libraries if needed or a C++ programmer who does stuff that looks a lot like C. Anyone who insists that C++ should be pure objecty goodness only is being arbitrary. But that is what is great that choice is there. In Java that choice isn't there. For instance I use the SQLite.h, SQLite.c pair of files to store data in many of my applications. That is C; but I usually wrap those in my own data access objects which is C++. So no, C/C++ it will be. 
Since C++11 we have [std::to_string](http://en.cppreference.com/w/cpp/string/basic_string/to_string), [std::stoi](http://en.cppreference.com/w/cpp/string/basic_string/stol) and [std::stof](http://en.cppreference.com/w/cpp/string/basic_string/stof).
VS2013's C++11 support is very decent. They got nearly there, there are a few things missing, but they are only important for very advanced users, certainly not for a beginner. Even some C++14 stuff is already in there. VS2012 is kind of usable but I wouldn't recommend it. Anything below is not usable at all in terms of C++11.
You can use clang, but it's still kind of a hassle. But there is a lot of work going on at the moment and in the past months and hopefully it won't be long (maybe under a year) before it's something you can do without effort.
What do you think a core dump *is*? Hint: It's not that big just to emphasize how badly you fucked up.
ok, thanks for that, I will look these up. Although I don't understand why I didn't come upon these in my research. Wikipedia is reporting 2011 as the official release date of C++11, maybe a lot of forums, blogs, and books I was reading need to be updated... Still seems to be lacking a lot of conversion to "char array"? which is commonly required by a lot of libraries I use. 
Yeah, there are times when new is absolutely necessary... But in this case, it should be wrapped by constructors and destructors.
"What happened?" "Don't know it just crashed" "No worries mate, just email me the 2GB core dump" I didn't say it was impossible, I said that it was the worst part.
I've been following their progress and the compiler is getting much closer. Nowadays, I only program for fun, so I look for those esoteric features to see how I can push the envelope, as it were. I'm sure that VS2013 is plenty good enough for serious work.
That's why `basic_string::c_str()` exists (although you have to be careful with the lifetime).
&gt; Anyone who insists that C++ should be pure objecty goodness only is being arbitrary. C++ is not about being object oriented, neither is C about having no objects. The Google style for C++ for example bans boost libraries by default for being not object oriented enough (they also ban a lot object oriented features for confusing their code monkeys so it balances out). C++ code is about using the right feature for the job, if you restrict yourself to the subset that superficially shares some similarities with C you do not write C/C++ you write either bad C++ or non compiling C. 
+1 for recommending CMake; it makes getting your project running on a new system super easy. Use out of source tree builds. I'm not sure why everyone loves MSVC. I use VC10 pro on a daily basis, and do not like it at all. I much prefer to use KDevelop when I can.
No need for a debugger, getting the stack trace from within the application should be possible on most platforms. It just involves some platform/compiler specific code to get at it.
Also, this seems to be saying that we're adding an operation of str.c_str() for every instance that a float/int/etc to char array conversion is require, because I have to get the string first this way, then convert again to char. Although I don't know if any efficiency is changed by doing it a more traditional way, I currently have: std::ostringstream ostr; std::string str; ostr &lt;&lt; x; str = ostr.str(); delete[] c; c = new char[str.length() + 1]; strcpy(c, str.c_str()); return c; for float/int to char array. which also seems like a lot of work :/ But surprisingly this handles very well on a very demanding system. 
This seems way too complicated. Unless you have legacy code that needs pointers to arrays of char, I don't see reason not to use std::string. Everywhere else, for immediate use, std::to_string(x).c_str();
I once worked with a guy who was angry that C++ hadn't turned the main function into some kind of root application object. While I have used many libraries (QT, Cocos2d, etc) that did make an object of this sort and it was convenient, I still appreciate the freedom of not having everything object oriented. I left Java programming around 2001 when the APIs and programming guides were pushing objects like someone had a gun to their heads. I recently saw a friend's corporate Java code and they had over 50,000 objects in their codebase. They also had quite a bit of the business logic tucked away in PL/SQL just in case the Java wasn't complex enough. Oh and he was the first person to introduce Unit Testing which is now slowly spreading across the world to the company's various offices. Or at least the first who's unit testing got anywhere. Oh and many of the above Java objects store a single or pair of variables and effectively are a data type. So a class will be created that is for storing usernames that has a single member variable that is a string; but don't worry about being confused as it inherits from a base class of UserDataTypes which has no functionality at all but looks good when put into a UML thingamabob. 
I'm fairly certain that's because it's a draft version. When you find an error, it's far easier to say "page 15, line 9" instead of "page 15, 2nd paragraph, 3rd sentence". Or you can count lines by hand, but that's really tedious around line 20-something. Or the fiftieth time you do it.
I was hoping this would be analysis of const char [] versus const char * const. At namespace scope, a definition like: const char a[] = "hello"; produces a single symbol, and sizeof(a) is the size of the characters making up the string literal: .section .rodata .type _ZL1a, @object .size _ZL1a, 6 _ZL1a: .string "hello" However, if instead you use: const char * const b = "world"; then you get a symbol for the pointer in addition to the string literal, and and sizeof(b) is the size of the pointer: .section .rodata .LC0: .string "world" .align 8 .type _ZL1b, @object .size _ZL1b, 8 _ZL1b: .quad .LC0
I would preorder this through O'Reilly immediately if the print preorder came with the draft PDF. That said, the free except strikes a good balance. I can at least get a feel for Scott's writing style in the Modern C++ book compared to the current Effective C++ series.
I gotta agree that "s/he" is awful. But even if the male form is commonly used as generic, it's also fact that some people are bothered by it. Personally I quite like the singular they, which as far as I know is already in usage since the middle english of the 14th century... it's also specifically highlighted in my oxford dictionary.
&gt; some people are bothered by it. Compulsive umbrage takers are bothered by it and they should be ignored. They will always find cause for umbrage no matter what, so there's no point in trying to assuage them.
I won't say anything about who is or isn't bothered, just that there are some people. Also I don't understand why we need to insist on the male "he" as a generic form. There is no reason to invent some new abomination I agree, but the truly generic singular "they" already exists for 6 centuries and I don't see why not to use it instead, it's a trivial fix for all these problems... No more need for people to argue about the usage of the male form as generics, no need to invent new abominations, no need to argue about established generics for centuries, singular "they" is old enough to not bother about these things. It appears in works of authors from quite some time ago. (Shakespeare used it as generic in hamlet I think and there are even older usages.)
How come it uses simpler syntax? `std::function&lt;float(float)&gt;` is more verbose than `float(*)(float)`.
For that matter, why not `template&lt;typename T&gt; using ptr = T*;`? Then you can declare function pointers using the even simpler syntax `ptr&lt;float(float)&gt;`. Substitute ptr for whatever name you prefer, it beats out all the alternatives in readability (except not being standard) and terseness. But it's still the wrong solution. The function type should be a template so that stateful functors and lambdas can be used
IIt is very difficult to find information on the second form; are they actually interchangeable? I recall having trouble with the second form in some situations and fell back to the classic style, though I am sure it was something simple I had overlooked. On that note is there a different between &amp;func and func when assigning out to these types?
In parameters, the Standard requires the compiler to *immediately* rewrite function types to function pointers, and array types to pointers. (This isn't decay, that's different.) This rewriting is so immediate, `sizeof` and `decltype` will observe the rewritten type. However, there is a difference between `func` and `&amp;func`. The former names a function, the latter is a pointer to that function. If you pass them to `meow(const T&amp;)`, template argument deduction will deduce `T` to be `Ret (Args)` for `func`, and `Ret (*)(Args)` for `&amp;func`. But unlike objects, functions have a special rule. If the compiler needs a function pointer and you said the name of a function, it will automatically take its address. This occurs during initialization, assignment, and other places like passing the name of a (non-overloaded, non-template) function to a templated algorithm taking Functor f. There's another rule for invocation. If you have a function pointer, you can invoke it with both `(*pf)(args)` and `pf(args)`. Like the immediate rewriting and automatic-address-taking rules, this goes back to C - Dennis Ritchie figured that if you're using function call syntax on a function pointer, there's nothing else you could possibly mean but "deference and call".
C++, as opposed to Java, is about "value semantics". User defined types with value semantics is possible because of "destructors". Its what makes "RAII" possible. I suggest you look up these terms and use them. On a practical note, you are on the right track; - If you use std::vector everywhere. -If you write code without using any pointers (no new or delete). -If your have no cleanup code in catch statements (as that should go in the destructors). 
Ah thank you. Yeah, I forgot the my_class::funct_one() part for sure. I'm not sure I understand not using "this-&gt;" though. Is that completely unneeded? Like would the struct1 be called from the class without it? That is, is it already in the scope of funct_one() in my example? 
Yes, the "this-&gt;" is completely not needed as the compiler will pick up the variable without it.The compiler will first look for the variable in the class scope and if it cant find it,it will look for it in the global namespace and give an error if it cant find it there too. In your case,it will find it. writing "this-&gt;struct1.member = 0" will work just fine,its just not how people write cpp. Look at this link[1] from one of my project for example. Notice that i use "m" followed by an underscore for member variables only and "this-&gt;" for member functions only.These are not needed, i just use them for conventions to separate class variables/class methods from global one. Its all about "code that document itself".It nice to just look at the variable/method and knows its a member variable/method. [1] https://github.com/mhogomchungu/zuluCrypt/blob/d0439a4e36521e42fa9392b82dcefd3224d53334/zuluMount-gui/mainwindow.cpp#L499 
If you haven't already, I suggest you at least look at cppreference.com for some quick tutorials to get you up to speed on how C++ treats [data structures](http://www.cplusplus.com/doc/tutorial/structures/), [classes](http://www.cplusplus.com/doc/tutorial/classes/) and some of the [basics of inheritence](http://www.cplusplus.com/doc/tutorial/inheritance/). To answer your question: Yes, you may do that. No, you do not need pointers to access member variables (in this case, private structs that you can declare inside the class) when implementing member functions. The member function implementation might look like this: int MyClass::funct_one(){ struct1.member = 0; struct2.member = 3; return 0; }; Note that the way you wrote it, your struct would be public. If you're not sure what that means in the grand scheme of things, you might want to read [this](http://msdn.microsoft.com/en-us/library/zsc61976.aspx). Basically, public means it's accessible from anywhere in the program; private means only that class or its friends can access it; and protected means that that class, its friends, or its derived classes can access it. You can define the struct either inside the class or outside. There are some differences, but you'll be able to use them the same way if the structs are public. That is, you'll be able to create instances of the struct outside the class and access its members. If you're going the accessor/mutator route (get/set functions), you probably want both the struct definition and the actual structs struct1 and struct2 to be private members of my_class. This will prevent access to both the struct (cannot create instance of it outside the class or the class's friends), and the struct members inside my_class (struct1 and struct2). For the privately declared struct thing you wanted, your class definition may look like this: class MyClass{ public: MyClass(); ~MyClass(); //your function can go here to make it public: //int funct_one(); private: struct MyStruct{ int member; }; MyStruct memberStruct; //your function can go here to make it private: //int funct_one(); }; And then you'd do implementations the way you normally do. The function implementation might look like MyClass::funct_one() above. If that didn't make sense, try pasting [this](https://gist.githubusercontent.com/merrilledmonds/c2d3a741a7f69428e9a7/raw/be99fad2d0ee716ac673b79fcc0942cb79156c24/gistfile1.txt) into [this](http://www.compileonline.com/compile_cpp11_online.php) (or just compiling it yourself) and playing around with it.
Yeah, it's intentional that the definition itself was public. In the program I'm trying to write I only want the instance to be private. To be honest I hadn't even considered about defining the struct inside the private space of a class. That seems like something nifty I'll keep in mind in the future. Thank you for the resource that's pretty nice. 
You mean like any other C and C++ vendor out there? **Apple** extensions to the C and C++ standard: http://clang.llvm.org/docs/LanguageExtensions.html **GNU** extensions to the C and C++ standard: https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html **IBM** extensions to the C and C++ standard: http://pic.dhe.ibm.com/infocenter/ratdevz/v8r0/index.jsp?topic=%2Fcom.ibm.xlcpp111.aix.doc%2Flanguage_ref%2Faix_c_extensions.html http://pic.dhe.ibm.com/infocenter/ratdevz/v8r0/index.jsp?topic=%2Fcom.ibm.xlcpp111.aix.doc%2Flanguage_ref%2Faix_c_extensions.html **HP** extensions to the C and C++ standard: http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/Online_Help/options.htm#xlang **Intel** extensions to the C and C++ standard: https://software.intel.com/en-us/search/documentation/book/512418?query=extensions **Embarcadero** extensions to the C and C++ standard: http://docwiki.embarcadero.com/RADStudio/XE6/en/C%2B%2B_Keyword_Extensions More examples can be provided from the embedded compiler market as well.
The only common use case I've found for raw pointers is referring to a parent node in a tree structure. 
https://www.coursera.org/course/cplusplus4c - c++ for c programmers on coursera. http://cppquiz.org/
The way you word your question and the example of python you gave lead me to believe you misunderstand what the python vs. c++ code does. In python the 'self' variable, the variable that identifies the class instance, is more explicit. In the two versions of code, 'self' and 'this' serve the same purpose. You don't need to have another struct within the class to do the same thing as your python example.
I use and recommend m_ prefixes. This encodes lifetime information (not type information - Hungarian notation is evil), which is very important - data member modifications persist beyond the local scope. Reasonably-sized classes can still have more than a page of member function implementations, and their class definitions may be in a separate file. It's really important to understand which writes affect data members and can interact with class invariants - hence the prefix. Data members of structs, however, don't get the same treatment. Structs have no class invariants, and they have very few member functions.
I don't only use them to document membership. Personally, I use them so that I can have a member of a class, say `m_width` for a `Cbox`, and then have a function that takes a parameter `width`. Both are very clear to the user and maintainer of a class, and in code, it will clarify which is a parameter and which is the member. Just my two cents worth.
Yes - shadowing is so, so evil. Regardless of naming conventions, shadowing (including between data members and parameters) should be avoided like the plague. I recently fixed a number of occurrences of shadowing in production code, thanks to VC's new shadow warnings - while none of them involved actual harm, they had the potential to cause problems.
Hey. (Seriously though, while I don't use IDEs, I don't claim to have memorized the *entire* Core Language and Standard Library - I usually have the Standard open so I can look at the class definitions and function signatures of whatever I'm working with.)
&gt; data member modifications persist beyond the local scope. You should already know that because you didn't declare it. If you don't declare it and you modify it, and it then compiles, then if you know nothing else you know that it lives beyond your local scope. I hope your functions aren't so long that's not clear...I've been the unfortunate maintainer of multi-thousand line long functions but I've never seen that as an argument to do something to make them easier to work with. Quite the contrary in fact, making them easier to work with encourages them to sprout up. The 'm_' or postfix underscore conventions seem to me made specifically to make writing large blobs of data worked on my monolithic functions. Whether a class has many lines of member functions isn't really what matters anyway. What matters is not having many pages of data members. Nothing good comes from that. If your class has 4-7 data members, and it really should, then it's easy to remember what's in it no matter what functionality you're working on. One can always come up with exceptions to any rule of thumb, but at that point you can worry about making membership clear. I am not convinced that 'm_' really does but whatever. Just don't make it a normal convention because it's really a tactic for working around a problem that should be addressed more directly.
&gt; Personally, I use them so that I can have a member of a class, say m_width for a Cbox, and then have a function that takes a parameter width. You know that you don't need m_ to do that, right? C++ has a variety of ways to address an identifier in a larger scope that's hidden locally by one with the same name. In this case, what the OP has done makes it more than clear where the variable is expected to reside.
&gt; Dennis Ritchie figured that if you're using function call syntax on a function pointer, there's nothing else you could possibly mean but "deference and call". It's rather unfortunate that classes that overload operator() aren't subject to this same courtesy.
Could you implement a linked list or tree without the use of pointers? I was actually having this conversation with a colleague and I don't know if it's possible.
How about shared_ptr and friends? std::function has value semantics, and there's no memory managed shared_function mechanism in the current standard. op-&gt; currently let's us pretend we're using C pointers when we use smart pointers, so why not do the same with callables? Seems like an oversight imho. Granted, it could be implemented using perfect forwarding, but to be consistent you want it to work on raw pointers too.
I guess it's inconsistent from that perspective, but providing operators on classes that chose not to have them would be squirrely.
Due to std::function it also doesn't work with respect to constness.
It probably makes sense to remove the non-const case altogether anyway. You can't access cv-qualified overloads doing this through std::function, unless you implement distinct wrappers (shared_const_fun?)
&gt; They/them/their are not really gender neutral. Sentences using them have to be written in such a way that the cardinality is ambiguous. No, they can be used as outright singular pronouns where gender is indeterminate. Their use became stigmatized in recent history until very recently when people felt the need to replace gender neutral he/him/his and they've revived somewhat. &gt; I like the ve/ver/vis idea. People are quite happy to use words like "iff" (if, and only if) in scientific papers so they would soon be comfortable with ve/ver/vis. Those are Greg Egan's pronouns. He uses them in various works both for sexless, genderless entities (eg. machine intelligences algorithmically descended from scanned humans, who no longer have any form of gender) and regular humans with extra-binary gender identities. The first time I remember reading them was in *Diaspora*. They were weird for maybe half a dozen pages, then they seemed perfectly natural. By the end of the book, I kept thinking of everyone as "ve".
I guess you mean `this-&gt;`? (what else is there?) I don't use (m)_ pre/postfixes either but think za419 actually makes a good point here: Quite often you pass a parameter like `width` and your class also has a member `width`, and then either your initialisation list looks like `width(width)` (which is not 100% obvious if it works) or you have to use `this-&gt;` (which makes the code kinda ugly).
&gt; It fills a specific niche in the Windows ecosystem. Specifically, it exists solely for using C++ libraries from .NET. Writing anything but glue code in it would be a pretty bad idea, and MS never tried to push it as a language for writing applications in (unlike C++/CX, which is a much better example of a pointless proprietary language extension).
What do any of those have to do with my post? There is absolutely nothing wrong with adding extensions to C/C++ compilers and I never claimed otherwise. The C and C++ standard both even provide guidelines for how to add compiler specific extensions, and extensions are often a great way to experiment or try new language features and eventually incorporate them into the standard. Don't trivialize my post by claiming that I stated that extensions are wrong. I make it very clear that my post is about extensions to the language when existing standard functionality not only exists, but is much cleaner and more idiomatic C++.
Your post sounds like the typical Microsoft bashing, as if everyone else is not doing it as well. They just play the rules of the game.
&gt;They just play the rules of the game. No they're not. Look at the extensions listed by Apple, GNU, IBM and Intel, they all use the guidelines specified by the C/C++ standard on how to add extensions to the language, namely extensions can be added using #pragma directives or using compiler specific reserved words (words that begin with a double underscore), or using C++11's attributes, or introducing new primitive types (such as vector long int), all of which comply with the standard. Take, for example, GNU's C++ extension for supporting __restrict. They state that C99 supports the use of restrict for pointers, but since restrict is not a valid C++ keyword, in order to use the restrict extension within C++ one must make use of the compiler reserved word __restrict in order to comply with the standard. I just superficially checked Embarcadero and some other links and they too all respect the standard when it comes to adding extensions.
&gt; Trigraphs ... were removed from the language Yippee!
&gt; They got nearly there, there are a few things missing, but they are only important for very advanced users, certainly not for a beginner. * Inheriting constructors are definitely very useful for everyone, but MSVC lacks them. * Unicode String-literals are missing, WTF? Aside from those I admit that most of the other stuff, while important, isn't that usefull for beginners.
Finally some promising news on getting modules and reflections into C++17. I can't wait to try out the the clang implementation once it hits a released version.
thanks for the analysis. What tool have you used to get those results?
My thought too! I guess though that doing the right thing with sending digraphs to Valhalla as well isn't going to happen.
I don't see how the ABI thing has any realistic chance of ever working out. Suppose Microsoft publishes a platform ABI for windows, making all the source of their standard library available. How is that supposed to help gcc/MinGW at all? The gcc project is not interested in maintaining two completely different versions of their standard library, so they're going to just ignore it. And it's not like users could just choose to use Microsoft's version with gcc, because these things tend to be highly dependent on internal compiler implementation details (e.g. by using special macros and interfaces exposed by the compiler for just that purpose.) It all sounds like pie-in-the sky magical thinking to me. 
So respond to that by making ALL code ugly with m_ or postfix _? Why not use '_' as a postfix on parameters that match arg names? And what is really ugly about it anyway? The '-&gt;' notation is quite natural in C++. We should be used to it. Even if we follow the guideline that everything should be a value, that's generally achievable only with pimpl pointers and such. So then you've got a lot of `pimpl-&gt;` uses floating around. Furthermore, conventions like `m_member` are not enforceable by anything but code reviews. Code reviews are great, but the last thing you want to turn them into is hunting for convention errors. I can always refactor the use of a member away and shove it into a parameter to a function that I instead call. Having to rename stuff just to do that is just an extra, pointless step in that process...and it's something easily forgotten unlike uses of `this-&gt;member` if you're really worried about that. In a contest between `this-&gt;member` and `m_member` I just don't see the point of the latter. It doesn't really tell us anything we shouldn't already know and the former is actually something the language knows to tell us about when we break the semantics. It's extra typing, but if we were making policy based on THAT we'd be using c-style casts...it's just not a good argument.
&gt; A way to get the compiler to, on an opt-in basis, generate equality and comparison operators for a structure/class. That's one of the features I never really thought about, but now I want it *so much*. Also, I wonder when GCC or Clang would start introducing proposed features such as `for (elem : range)` in regular releases.
This is an awesome writeup. I've only digested 1/3 of it so far. Really liking what I see. For those who want a quicker, higher level overview see the [trip report posted on isocpp.org](https://isocpp.org/blog/2014/07/trip-report-summer-iso-c-meeting).
I have a fairly shallow understanding of the issue (read: I'm happy to remain ignorant, for now, about the implementation nightmares), but wouldn't the correct approach here be to put in the standard a set of required macros and interfaces, so that the library implementations can rely on those instead of ad-hoc internal compiler implementation details. *Edit: I appreciate that it's easy to chuck out that this is the "correct" approach when ignoring the actual behind-the-scenes implementation issues that would be required, so I'm guessing it's just completely unrealistic?* Reading the submitted post, I see that perhaps what I brought up above is wedged between these two issues: 1. &gt; It has long been established that it is out of scope for the C++ Standard to prescribe an ABI that vendors should use (among other reasons, because parts of an ABI are inherently platform-specific, and the standard cannot enumerate every platform and prescribe something for each one). 2. &gt; Instead, Herb’s proposal is that the standard codify the notions of a platform and a platform owner (an organization/entity who controls the platform); require that platform owners document an ABI (in the case of the standard library, this means making available the source code of a standard library implementation) which is then considered the platform ABI; and require compiler and standard library vendors to support the platform ABI to be conformant on any given platform. I'm a bit confused about what these two mean together. (1) seems to say that it's outside the scope of C++ Standards to enforce, and (2) seems to say that instead we elect an "an organization/entity who controls the platform", and then enforce that "compiler and standard library vendors ... support the platform ABI to be conformant on any given platform". It seems really roundabout.
I was able to get SOIL2 to compile on my mac. But we are having issues getting it to run on windows. We can create the project but cannot get the static library project to build.
If its a good compressed file format, be it lossless or lossy, it typically gets bad really fast. But for uncompressed data, the readers dont grow in complexity that fast. Also, check out [CImg](http://cimg.sourceforge.net/). Supports BMP out of the box, but has optional dependencies if you want to load/save jpg or png images, but offers plenty of convenient functions.
How to name and refer a member variable is a matter of preference,its the same how to name a function or local variable or a class or where the put the parentheses symbol pr spaces between lines or characters. If you write your own code for your consumption then do what you prefer,if somebody else comes and work on your code then it will be polite of them to do things the way you prefer.If you work on somebody else's code then it will be polite of you to do things the way they prefer. If you write your code with a hope or an expectation that people of a certain community will review/modify/extend it,then it will be polite to write it in ways they prefer. At the end of the day,code consistency is what is most important.How do you name your member variables or local variables or function names? It will be odd to name one variable starting with a capital letter and then name another one starting with a small letter and then name another one using camel case and then name another one using under scores.Its doable as the language does not care but its not how people expect cpp to be written. 
I recommend reading this post: [http://stackoverflow.com/a/22797419](http://stackoverflow.com/a/22797419). It provides a brief answer about C++ and ABI issues we are currently facing. &gt; put in the standard a set of required macros and interfaces, so that the library implementations can rely on those instead of ad-hoc internal compiler implementation details. This is possible under the assumption that vendors will strictly use these macros/interfaces to implement the standard library. Forcing them to implement standard library in a specific way is another issue. Vendors implement standard libraries using specific features/techniques provided by their compiler to generate better code. At the end of the day, it will be just like /u/Rhomboid says, it all lies on vendor buy-in. &gt; seems to say that instead we elect an "an organization/entity who controls the platform", and then enforce that "compiler and standard library vendors ... support the platform ABI to be conformant on any given platform". I don't think they are talking about another organizational body to elect, but rather, platform owners will publish a C++ ABI spec so that compilers can support/use C++ across ABI. It is like saying because the C++ standard cannot make a cross ABI spec (point#1), they will let platform owners publish their ABI specs in a way that other compiler vendors can use them to make a ABI compatible code (point#2). What "platform" and "platform owner" mean are not defined though.
Its very hard to do right, but its power also probably the main reason C++ continues to be a language worth knowing.
Yep that is sorta my point. Most people would recognize you as an expert yet you need to refer to the standards or other documentation from time to time. It's been years since I've used Visual Studio but I found that when I did use it Intellisense like features to be a big help. Often if it didn't solve a problem it atleast gave me a hint as to where to look. These days I work automation, as in plant floor control systems and have to flip back and forth between so many systems, often with minimalist IDEs if they have IDEs at all, that I do miss the features modern C++ IDEs have. 
Just use `auto` bro.
&gt;BTW2, was just browsing some of the code on the linked page, and it is not true that if one operand is zero, then subtraction cannot overflow. Consider case of type int, 0 - INT_MIN -&gt; overflow. `INT_MIN`? You mean `std::numeric_limits&lt;int&gt;::min()`? `0-std::numeric_limits&lt;int&gt;::min()` is indeed an overflow, and there's [a unit test for that exact scenario](https://github.com/RobertLeahy/Safe/blob/master/src/test/main.cpp#L2987), and it passes, because this is handled correctly. &gt;It is likewise untrue that the only dangerous division condition is div_0. If you divide INT_MIN/-1, you have an undefined overflow. There's also [a unit test for this exact scenario](https://github.com/RobertLeahy/Safe/blob/master/src/test/main.cpp#L3800), which also passes. Did you miss the fact that there's a [specialization of the `Safe::Arithmetic` class which activates when the template type is signed](https://github.com/RobertLeahy/Safe/blob/master/include/safe/safe.hpp#L250), and that due to this, [the unspecialized `Safe::Arithmetic` class](https://github.com/RobertLeahy/Safe/blob/master/include/safe/safe.hpp#L140) assumes the type it's templated on is unsigned? &gt;Now operator promotion will have you working with mixed types, which your library doesn't support. For all binary operator overloads in the library it's set out quite explicitly in the documentation: [If you operate on two types, the latter of the two will always be (safely/losslessly) converted to the former](https://github.com/RobertLeahy/Safe/blob/master/include/safe/safe.hpp#L808). &gt;Safe::Integer&lt;unsigned long&gt; x(0); x += -1; // literals are signed int &gt;Will not work properly - you'll force -1 to be the same type, now it is unsigned and INT_MAX, and things go awry from there. Looking at your example, [this will be the line of code-in-question](https://github.com/RobertLeahy/Safe/blob/master/include/safe/safe.hpp#L827). You'll notice: `Integer&lt;A&gt;(b).Get()` The second operand (which is indeed of type `int`, and therefore signed) will be wrapped in a `Safe::Integer&lt;unsigned long&gt;`, thereby attempting to convert it into an `unsigned long`. This will throw and the operation will fail.
There are participants in [Clang development](http://blog.llvm.org/2014/07/clangllvm-on-windows-update.html) that seem quite interested in strong compatibility with MSVC at an ABI level.
I wish TMP wasn't so arcane, it's not horrible once you learn how it works, but it's needlessly great at scaring away beginners. Recently I used variadic templates to write a helper function for serializing / deserializing data from a byte stream, so I can write something like //populate fields - integers, enums, or arrays, but not bit-fields :( //from given byte stream deserialize&lt;ENDIAN::BIG&gt;( file_descriptor, field1, field2, field3, field4 ); which makes serialization code relatively pain-free to write without using a serialization library or compiler specific features. Less recently I wrote a 256 case switch statement using lots of constexprs, template specialization, and a bit of preprocessor magic. It was for a (poorly designed) NES CPU emulator that never got finished, but the switch itself looked like this: switch(CPU::read&lt;Addr_Mode::Immediate&gt;(reg)) { #define BOOST_PP_LOCAL_LIMITS (0, 255) #define BOOST_PP_LOCAL_MACRO(n) \ case n: \ Operation&lt;Instruction(n).mnemonic,Instruction(n).mode&gt;()(reg); \ break; #include BOOST_PP_LOCAL_ITERATE() } That was a lot of fun, and probably when TMP first really clicked for me.
&gt; Inheriting constructors are definitely very useful for everyone, but MSVC lacks them. They've been implemented in the next release, VS 14. (Note that they are often confused with the *much* more useful delegating constructors, which are supported in VS 2013.)
I've loved cats since I was in elementary school. (As I recall, my sister was obsessed with them first, then I joined the campaign to make our parents get us a cat.) Curiously enough, I don't own a cat now - I prefer to outsource my cat ownership to friends. MSDN examples with meowing are often (but not always) derived from example code I've written. Some meows aren't mine, though. For example, I wasn't responsible for [N4084](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4084.html) 1.3 [general.namespaces]/4 "Extensions that are expected to eventually be added to an existing header &lt;meow&gt; are provided inside the &lt;experimental/meow&gt; header, which shall include the standard contents of &lt;meow&gt; as if by #include &lt;meow&gt;", so I giggled madly when I read that. :-&gt;
I think I qualify as a professional template metaprogrammer, being the author of [Boost.MultiIndex](http://www.boost.org/libs/multi_index/doc/index.html), a library which lets the user specify a container as a composition of indices with very rich compile-time configuration options. C++ TMP is admittedly hard to grok (somewhat less so now with variadic templates, which considerably simplify dealing with one of the most cumbersome aspects of TMP, namely type lists), but more because of the contrived syntax than the underyling complexity per se. To me, the most rewarding aspect of TMP is how you can increase with it the amount of compile-time intelligence so as to provide the user with terse, powerful interfaces where all this internal trickery is not exposed. This is the "magic" of TMP that appeals to both users and lib programmers alike, IMHO.
Thank you. I'm currently having dilemma on what I should major. I would like to study Algorithms as it sounds interesting, but I wasn't sure if Computer Science would allow me to do that or engineering of some sort (Industrial Engineering) which has Operations Research side to it. Would you please elaborate which direction I should choose? Computer Science v.s. Industrial Engineering and Operations Research v.s. Computer Science and Operations Research. Btw, if you are familiar with schools in America, I have the options to choose from Cal Poly Slo and UC Berkeley. The former is more hands on and has great connections with the job market, while the latter is more theoretical and comes with this name recognition. Thank you in advance, and if you have any forums or subreddit where I can learn about algorithms, please let me know!
That last one looks incredibly cool!
Thanks for your insight! It sounds like you have a pretty awesome job.
I did some TMP back when it was new. It was fun and challenging, but in practice it's rarely the right choice. If you're writing much of your program in TMP then you're probably doing it the hard way.
Honest question: what's wrong with subclassing std::exception and specify the interface of the derived class according to the requirements?
For the **sake of record**, there are a few things that are incorrect in this trip report especially when it comes to proposals related to template parameter packs. His analysis is unfortunately inaccurate. I am one of the people who are working on this and had to reply to him through the std-proposals mailing list [here](https://groups.google.com/a/isocpp.org/d/msg/std-proposals/qIs0Ws7WdwA/XmvzaRl_IYsJ).
&gt; I wasn't sure if Computer Science would allow me to do that or engineering of some sort In any field other than CS, you'll be working with domain-specific algorithms. I'd recommend that if you're interested in a particular domain, do that. If you're interested in algorithms in and of themselves, go with CS - you can decide later whether to pursue theoretical CS, or software engineering (where a CS degree is very useful). It's been over a decade since I looked at undergrad schools (I graduated from Caltech in 2004). My CS education was *very* theoretical - but I taught myself C++ in my free time and had no problem getting hired straight out of school. I wouldn't worry about that if I were you - competent programmers can always find employment.
Just like C ABI works. It is just the universal ABI many think it is, mainly because C ABI tends to match 1 == 1 the OS ABI. In the few OS where C ABI != OS ABI, C shares the same ABI pains as any other language. 
Yay!! &gt; [A way to specify that a class should be converted to another type in auto initialization](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4035.pdf). That is, for a class `C`, to specify that in `auto var = c;` (with `c` having type `C`), the type of `var` should actually be some other type `D`. &gt;The motivating use here is expression templates; in `Matrix X, Y; auto Z = X * Y;` we want the type of `Z` to be `Matrix` even if the type of `X * Y` is some expression template type. &gt;EWG liked the motivation, but the proposal tried to modify the semantics of template parameter deduction for by-value parameters so as to remain consistent with auto, and EWG was concerned that this was starting to encroach on too many areas of the language. The author was encouraged to come back with a more limited-scope proposal that concerned auto initialization only. I'll keep my fingers crossed, it's only been three years since [I wrote this](http://lanzkron.wordpress.com/2011/02/21/inferring-too-much/).
&gt; The gcc project is not interested in maintaining two completely different versions of their standard library Source? &gt; internal compiler implementation details In worsest case, there is option to create wrapper library around their std::abi, that exposes C api and should be compiled with MSVC. I don't think it's a as catastrophic as deal breaker.
On a 32-bit system a 2GB core dump tells you something without analysis. 
They should have renamed Concepts Lite TS to Concept Predicates TS. 
32bit? I'm not talking about an android game, or some form-filling app. Serious software with serious data.
ABI compatibility is a pretty big deal in the closed source world where libraries come as a DLL and a header file. Even within the same compiler line, different versions often break the ABI. Microsoft breaks their ABI on purpose for every new version of MSVC. Any closed-source library product must distribute a different DLL for every MSVC version they wish to support. This is a pain in the ass, and it also means library writers can't use newer language features because their code must compile on MSVC 2008. With a standardized ABI, you could *link against code compiled with a newer compiler than yours* and it would work! This is a big deal in Real Life™ where many big C++ projects are stuck on old compilers for some reason.
I agree. In the end they are just very limited predicates with useful shorthands. They are not wasting their time with terminology it seems.
&gt; Another interesting design question that came up was whether private members of a class exported from a module are “visible” to an importing module (in the sense that importing modules need to be recompiled if such a private member is added or modified); in Clang’s implementation, this is the case, but there would certainly be value in avoiding this (among other things, it would obsolete the laborious “Pimpl” design pattern). I've often thought of this when grinding my teeth at Pimpl's ugly slowness. It should be possible to export the *size* of an object but not its layout. Something like: // secret.h class Secret { size: 24; }; // secret.cpp class Secret { double x; uint32_t i; uint32_t j; char *s; }; But this reveals weaknesses in the header file system: you'd have to manually synchronize the files or use some kind of preprocessor to generate the header `size` from the code. Even then, sizes would be different between 32 and 64 bit versions, so you'd need 2 different header files. Sounds bad. A module system could overcome this issue though. So many times, when I think of something I dislike about C++, its root cause is the header file system.
Template metaprogramming is the coolest thing about C++, IMO. Its very difficult, but very rewarding. Unfortunately, it's mostly only useful in library code. I'm excited to see what the future of c++ has in store for template metaprogramming. TMP is one of the biggest draws to modern C++. TMP is probably the starkest indicator of the depth of the language as opposed to other languages. Templates in C++ offer so much more than, say, generics in C# or Java.
What makes you think MS is going to stop breaking compatibility with each release? They've done it for good reasons -- the need to fix bugs and add features. Go ask /u/STL how much more work it would be to not be able to do that. As I read it, all this proposal would change would be that MS would get to claim that whatever is the current VS version is officially the platform ABI rather than de facto the platform ABI.
Java has *only* pass by value. The big difference is that in Java variables can hold only primitive types (object reference being one of them), whereas in C++, a variable can contain a more complex object too.
I think it was Scott Meyers that said that one of the things that has made C++ successful was its emphasis on providing features for library writers, and I think TMP falls into that category (even if it perhaps was not explicitly designed that way, merely discovered.) It's something that you can use to great effect when implementing a library, where it can stay hidden from the user. You probably don't want to be writing end-user code that's completely littered with TMP (although there will always be justifiable exceptions), but as a user you can rest assured that there's probably TMP being used frequently on your behalf behind the scenes, if not in the standard library then in other libraries. 
&gt; [I]t was like a whole new world of possibility was opened to me. I experienced crashing a compiler for the first time. Yep. That's the goal. I wish there was a better way because it makes code about as readable as Sumerian text. Worse that every C++ developer out there wants to use it for EVERYTHING and doesn't know what they're doing. Case in point: struct visitor_thingy // I think maybe it inherited from boost::visitor? { template &lt; typename T &gt; void do_it(T const&amp; t, typename boost::enable_if&lt;boost::is_same&lt;T,int&gt;&gt;::value *x = 0); // Many more of these for different types... template &lt; typename T &gt; void operator()(T const&amp; t) { do_it(t); } }; Yes. I indeed saw that crap in production code. The guy had even implemented addition visitors that extrapolated the right type to return, cast to it, and then returned whatever was on the "left" side of the operation without casting. People get too damn clever for their own good without bothering to be smart. But it's a very powerful language feature I wish I could like. I myself enjoy using it, but I tend to look for other ways now. Even the "good" TMP code is nearly impossible to muddle through if it's more than the most basic thing. There's many reasons for that but I think for me it's the noise of the syntax just overloads my brain so it doesn't even WANT to figure it out. The language centers just go, "Nope, ain't gonna do it...how about you eyeballs, you figure this shit out." Then I go to sleep. But maybe it's just that I've seen so much crap because most TMP I run into in the wild is NOT good. It's a tangled mess of pointless obfuscation for the sake of cleverness. Who wants to weed through that crap? Nobody, that's who...so it tends to stay, untouched, for years with everyone wishing someone would make it work right. The code around it begins a cascade rot trying to deal with the bugs that are in the TMP instead of fixing them. Yet I still think it should be in every C++ developer's arsenal. Just please keep it sane. I have some moderate hopes that `constexpr` can be extended to address those things you'd do in TMP because it ends up with a much nicer syntax. You can already do all the compile-time calculation stuff that way, but types are a bit harder. I did mess with it a bit and manage some of it though: http://ideone.com/T7ag8f -- there's lots of issues there though even if you succeed.
&gt; I requested some C++ big shots to expand constexpr support so that it could be the new metaprogramming which is natural, readable C++. This has been approved and is coming to future versions of the C++ standard. What changes would you be referring to? Will it still do lazy eval?
You'd have to export alignment too. Well, this is somewhat possible today, just a bit ugly. // secret.h class alignas(alignof(long long)) Secret { static const size_t SecretSize = 24; char memory[SecretSize]; public: Secret(); const char* WhisperIt() const; }; // secret.cpp class SecretDetails { // details here... public: SecretDetails(); const char* WhisperIt() const; }; Secret::Secret() { new(memory) SecretDetails; }; const char* Secret::WhisperIt() const { return reinterpret_cast&lt;SecretDetails*&gt;(memory)-&gt;WhisperIt(); } But there are many maintenance problems with this and I would not recommend it.
&gt; They've done it for good reasons -- the need to fix bugs and add features. Yep, and we're fixing major bugs in VS 14 by breaking binary compatibility yet again. Herb's proposal essentially involves "snapshotting", or what you can think of as "Long Term Support" - if we shipped this (and I am speaking hypothetically, not about any actual plans), we would take VS 20xx's STL, copy it to the std::abi namespace, and preserve that unchanged in each release. The normal STL would continue to evolve and break bincompat.
Boost.MultiIndex is beyond awesome.
That "visitor" is impressive.
Yea sure, if you have any questions or thoughts, feel free to PM me. I'm not very far into the book yet, and I'm focusing on repetition with a few simple lines of code to drill the basics into my brain.
Please don't. Modules are on their way. Let's wait to do it properly. My above "solution" is terrible. I only listed it to show C++'s flexibility. Perhaps I shouldn't have shown it.
&gt; WTF || printf("how could they remove these expressive operators|"); Is that a question or a statement. I can't tell. And why are you logically ORing WTF and printf? ;??'%&gt;
Thanks for mentioning MNMLSTC Core :)
I think it's because you don't mention C++14 anywhere on the project description / README, so it wasn't found by a search for that term.
&gt; You know that main() is called by the runtime, not the OS, right? mainCRTstartup is the entrypoint in the Microsoft CRT that calls main(). The linker sets it based on the chosen subsystem if you don't do it explicitly. Irrelevant. Portable software is written with main(), not mainCRTstartup(). &gt; You don't need to use it. It's not meant as a replacement for C++. It fills a specific niche in the Windows ecosystem. Yeah, one that doesn't run in any other platform.
&gt; Fully allowed by the C++ standard afaik, also nothing an #if _WIN32 can't solve painlessly. That's not the point though. The point is that it was not needed. &gt; GNU took c++ and turned it into gnu++, nvidia took it and turned it into CUDA. C and C++ compiler/language extensions are quite common. I am not talking about compiler extensions. C++/cli is a whole programming environment. If you create your app in it, it is not portable in any way in other platforms. 
That's not even the half of it. That's just some of the more obviously absurd aspects. Thing had 20 some odd "overloads" like that, some of which had 5-6 lines of junk in the enable-if. Many also had to disable_if things that were using `is_same&lt;T,sometype&gt;` so they wouldn't match and cause ambiguity. If they'd wanted to explicitly make it not match `short` or some other convertible argument then I could see the `is_same` bit...but that didn't seem to be the case. The product was/is full of that kind of stuff...TMP everywhere and most of it garbage.
Great list! Thanks for including Streams!
It was a late entry :) I didn't find it on Github, and only spotted it thanks to the InfoQ article. It's nice to see more functional programming influence in the C++ world.
I had originally had only supported C++14(mainly that `std::integral_constant` conversion to `bool` is `constexpr`), but I later added support for C+11(and C++0x for gcc 4.6), by implementing my own `integral_constant`. However, some of the examples do require C++14.
&gt; Irrelevant. Portable software is written with main(), not mainCRTstartup(). ...*sigh* 1. Create Win32 GUI application project in Visual Studio 1. Write 100% portable `main()` 1. Add `/ENTRY:mainCRTstartup` to the command line of the linker 1. Build 1. Be amazed &gt;Yeah, one that doesn't run in any other platform. That's not Microsoft's fault.
Right, like a fuck up with a compressed air rifle vs a fuck up with a machine gun. 
`float` is not required to have a different size than `char`; it'd be better to make `yes_t` a struct containing multiple `char`s so it definitely has a different size.
That it is an interesting technique to use a generic lambda. However, I don't think it will work for 'non-constexpr' types, but you can use `decltype` to workaround the issue. Also, you could make it for more general expressions, perhaps like this: template&lt;class T&gt; struct always_int { typedef int type; }; template&lt;class T, class F, class=int&gt; struct is_valid_impl : std::false_type {}; template&lt;class T, class F, class=int&gt; struct is_valid_impl&lt;T, typename always_int&lt; decltype(std::declval&lt;F&gt;()(std::declval&lt;T&gt;())) &gt;::type : std::true_type {}; template&lt;class T, class F&gt; constexpr is_valid_impl&lt;T, F&gt; is_valid(T&amp;&amp; x, F&amp;&amp; f) { return {}; } #define IS_VALID(x, ...) \ decltype(is_valid(x, [](auto&amp;&amp; x, typename always_int&lt;decltype(__VA_ARGS__)&gt;::type = 0) {}))() static_assert(IS_VALID(x, x.foo()), "It has foo"); I haven't tested this yet. EDIT: This won't work either, since a lambda can't be used in a `decltype`.
Why did you use a lambda here? auto stream = [](auto&amp; x) { return stream::MakeStream::from(x); };
Oh yeah, and thanks for mentioning fp! It's very much WIP, although in a very usable state, despite that only clang supports it. Would very much appreciate any input!
I didn't come up with the example, but it looks like it was done to make the following code more succinct - i.e. `stream(vec1)` is shorter than writing `stream::MakeStream::from(vec1)` everywhere.
Ah, good point.
...although god help me if I ever meet a system where that's the case. 
Very cool. Thanks for posting JeayeSON. (It relies on C++14 mostly just for auto return types where otherwise far too many traits would need to be used)
The logo in the top is a left-handed helix...
Well, C++14 isn't really a major release, so it's hard to use *a lot* of C++14 features :) `auto` return types seem to be quite useful. Another library author told me that they helped him too (in particular, he liked being able to return lambdas). 
* Effective C++ * Code Complete * ACCU Overload
Also check out [jbson](http://chrismanning.github.io/jbson), my BSON/JSON library. Uses lots of C++14 template aliases and relies on `&lt;codecvt&gt;` header so no GCC support yet. MSVC also doesn't work last I checked because of lacking SFINAE.
You should take advantage of one of the many MOOCs: * [edX](https://www.edx.org/course-list/allschools/computer-science/allcourses) * [Coursera](https://www.coursera.org/courses?search=Computer%20Science) * [Udacity](https://www.udacity.com/) 
I think the progression would be something like code complete + scott meyers/herb sutters books (you may do a lot of what are in these already), the popular comprehensive templates book, then an advanced TMP book. I am jealous of the discipline being a researcher probably gave you. it is very hard for me to read without squirming after 10-20 pages. making any large technical book a very long venture.
On POSIX-compatible systems, at least, you're looking for the [`popen`](http://linux.die.net/man/3/popen) function. 
That's really helpful, thanks. Only problem is I don't know how to define the buff size when the size of frames from different videos will be variable. Is it possible to just read until an endline or certain character?
`popen` works exactly like `fopen`. You use exactly the same functions: `fread`, `fwrite`, `feof`, etc.
You mean char with 32 bits or float with size of 8 bits? :) I'll replace them with intX_t, who knows what the future will bring :)
Nah. Just that. I find it distracting, especially in synthetic examples.
What you mean by 'non-constexpr' types? Can you give me example when my code will fail? (edit: I got it... ) My goal was to only decect does given field/member fn exists or not. I tried to keep this code as simple as possible to demonstrate the idea of using generic lambdas only for type deduction. Moreover my goal was to avoid macros, but as you can see I had to use one. Macro should be as simple as possible.
You should further specify ffmpeg's output format using for example "-pix_fmt rgb24". Then if your video has dimensions w\*h, you need to read w\*h\*3 bytes per frame. You could grab the dimensions by parsing the output of "ffmpeg -i video.mp4".
Now that they've finished the modularization work I hope they can work through the backlog in the review queue. I've been interested in the asynchronous file I/O in particular, but it never seems to get scheduled.
Didn't boost already have lexical_cast ? Or I'm missing something?
http://en.wikipedia.org/wiki/Tensor
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Tensor**](https://en.wikipedia.org/wiki/Tensor): [](#sfw) --- &gt;__Tensors__ are [geometric](https://en.wikipedia.org/wiki/Geometry) objects that describe [linear relations](https://en.wikipedia.org/wiki/Linear_relation) between [vectors](https://en.wikipedia.org/wiki/Euclidean_vectors), [scalars](https://en.wikipedia.org/wiki/Scalar_(mathematics\)), and other tensors. Elementary examples of such relations include the [dot product](https://en.wikipedia.org/wiki/Dot_product), the [cross product](https://en.wikipedia.org/wiki/Cross_product), and [linear maps](https://en.wikipedia.org/wiki/Linear_map). Vectors and scalars themselves are also tensors. A tensor can be represented as a [multi-dimensional array](https://en.wikipedia.org/wiki/Array_data_structure#Multidimensional_arrays) of numerical values. The __order__ (also *degree*) of a tensor is the dimensionality of the array needed to represent it, or equivalently, the number of indices needed to label a component of that array. For example, a linear map can be represented by a matrix (a 2-dimensional array) and therefore is a 2nd-order tensor. A vector can be represented as a 1-dimensional array and is a 1st-order tensor. Scalars are single numbers and are thus 0th-order tensors. &gt;==== &gt;[**Image**](https://i.imgur.com/pJRw52W.png) [^(i)](https://commons.wikimedia.org/wiki/File:Components_stress_tensor.svg) - *Cauchy stress tensor, a second-order tensor. The tensor's components, in a three-dimensional Cartesian coordinate system, form the matrix whose columns are the stresses \(forces per unit area\) acting on the __e__1, __e__2, and __e__3 faces of the cube.* --- ^Interesting: [^Tensor ^product](https://en.wikipedia.org/wiki/Tensor_product) ^| [^Tensor ^field](https://en.wikipedia.org/wiki/Tensor_field) ^| [^Tensor ^veli ^palatini ^muscle](https://en.wikipedia.org/wiki/Tensor_veli_palatini_muscle) ^| [^Tensor ^\(intrinsic ^definition)](https://en.wikipedia.org/wiki/Tensor_\(intrinsic_definition\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cj4sm4c) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cj4sm4c)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
It's always had it, but now it's a common module shared by other boost libraries. Basically a complaint with boost is that every library has to reimplement a bunch of stuff, like there would be 10 different implementations of a mutex by 10 different boost libraries, or 10 different ways to throw exceptions, or half a dozen string to int/conversion libraries. With boost 1.56, they want to make it more modular, so now there will be one conversion library, one way to throw exceptions, one way to assert.
part of this is also an internal reorganization, e.g. moving the stuff into the right modules.
You can look at the ffmpeg examples (http://www.ffmpeg.org/doxygen/2.2/examples.html), specifically the demuxing example and replace some of the code that saves the frames to disk, with some code that writes frame contents stdout. Then you could pipe (using your shell) to another process. Just a thought. 
Update. I added very straightforward implementation of static if. This little utility will guarantee that your code compile even if used object doesn't have used members. I also changed Checker macro, and added AnyChecker. Now you can distinguish between member field and member function.
I found workaround, I had to declare Checkers like this: constexpr auto L1 = Checker(foo); constexpr auto L2 = Checker(foo()); return static_if_&lt;hasMember(t0, L1) || hasMember(t0, L2)&gt;(
Thanks!
The static_if looks interesting. However, even with the workaround I don't think it is still legal. Lambdas can't be passed as parameters to `constexpr` functions, even though gcc may allow it. See [here](https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/3aVuvCjCqik)
We'll all just have to be loud about it.
Aren't people who need `deprecated` attributes already using the GNU `__attribute__((__deprecated__))` or MSVC `__declspec(deprecated)`/`#pragma deprecated` markers, aren't they? With the exception of the `__declspec` variant, those have been around for-freaking-ever and there's something similar in most of the popular compilers. I was rather surprised to learn C++11 hadn't added `deprecated` as an attribute, in fact, precisely because of that.
It's not really clear from your post what you want to learn. Do you want to improve on C++/Programming or on Computer Science? Computer science would be things like logic, automata theory, graphs, complexity theory, maybe operating systems, networking, compilers, cryptography. You can find a lot of good lectures online, check for example coursera or MIT OCW for lectures on _Computer science theory_ or _Algorithms_. If you're into compilers and languages, look at the already recommended "Dragon" book. You'll find a lot in computer science theory that'll help you become a better programmer. If you want to improve more directly on your Programming/Design patterns, I can recommend _Head First Design Patterns_, or alternatively the GOF book. Also _Modern C++ Design_ by Alexandrescu, which is quite advanced. You can find more good C++ book recommendations on the SO wiki post and isocpp.org. A last recommendation would be the channel9 videos from Going Native 2012+2013 as well as all of STL's videos. 
1. Be amazed at what? The fact that it is doable does not mean that Microsoft did not do it on purpose. Please give us a technical reason why win32 applications needed WinMain() and not main(). 2. Yes, it is Microsoft's fault. It is a deliberate move to lock in devs to the Microsoft platform.
This cppcon is looking fantastic. Really wish I could make it this year. Hoping for next year. Is it always in Bellevue?
These are not guaranteed to exist if the implementation e.g. has no 8-bit type at all. For maximum portability it's better to use `char` and `char [2]`.
I want to move beyond using C++ as a tool and understand more generally - that being said, I also really enjoy C++ and want to move on from understanding bits and pieces and become an expert. 
Thank you very much. I understand (at least in my current position) when C++ is useful and when to use something else. That being said, I love C++ and want to become as strong as possible in it. At the same time, the above is exactly the other part I am looking for. After spending years in theoretical mathematics I want to understand application and theory - realizing I know nothing about CS theory has lit a fire under me. 
Seems like c++ is trying to fill in these gaps by making it 'work' with the language. Sometimes you just have to say. No. 
I was referring to all the caveats you have to remember, but i guess there isn't any choice. It was more of a thought than a opinion 
So? Really an approach that is standardized is highly valued over compiler specific solutions. 
I doubt that forward-declaring instead of including header is a good practice.
what's the deal with inlining? Doesn't the compiler decide anyways what gets inlined and what doesn't?
With LTO enabled I can't say that I've ever observed the meaningful binary size changes from member functions defined inline in the class that they're concerned about. Without LTO it can make a difference, but you could get the same end result by slathering noinline attributes everywhere.
Where would it fail? I'm kind of partial to the idea of "light" headers and "heavy" headers myself. The light version has some forward declarations of a bunch of interdependent stuff. The heavy one is what you use in your implementation.
And on big projects, it improves programmer productivity if you can shave a minute or two off the compile time by making the linker (and preprocessor, with headers) do less work.
This is the first one.
*shudder* not the dreaded Google C++ style guide. 
This code is ill-formed: class Whatever { public: /* ... */ private: struct DataStruct; std::vector&lt;DataStruct&gt; data_; }; It's not permitted to have a vector of a type which is incomplete at the point of declaring the vector. The `std::vector&lt;Forward&gt;` in the first section is also ill-formed. The section later that says: // THIS WON'T COMPILE, BUT IT WOULD HAVE IF WE PUT THESE IN THE // IMPLEMENTATION FILE! is bogus, the code is ill-formed either way. Obviously, whoever wrote this page has a compiler that allows some varieties of ill-formed code and rejects others. Reference: [res.on.functions]/2 &gt;In particular, the effects are undefined in the following cases: &gt; ... &gt; if an incomplete type (3.9) is used as a template argument when instantiating a template component, &gt; unless specifically allowed for that component. [Rationale](http://www.drdobbs.com/the-standard-librarian-containers-of-inc/184403814) The `boost` libraries include some containers specifically written to allow incomplete types as parameter. The authors of the article should either use these containers, or use a pImpl idiom (if they care about portability, that is). 
My opinion (with the benefit of experience) is that it's best to not put any function bodies in the class definition. Then you can modify the bodies without having to recompile everything that used it. Especially if the code appears in a static library or a shared library, in which case you can just re-link existing compiled objects. If some code has been compiled against a header with inline functions, you're SOL if you want to change those functions. The only real reason to use inline function bodies in a class is for demonstrable performance benefit, when you are consciously sacrificing encapsulation for performance. 
Further garbage from this page: class Manager { public: MyData get_data() { return my_data_; } private: MyData my_data_; }; &gt; The underlying copy constructor calls for MyData are going to be &gt;complex. (Also, they're going to be synthesized, which is bad.) Even the worst compilers will perform copy-elision here. (Also, I have no idea what they mean by "synthesized"). And the accessor should be `const`.
I believe they mean that they are autogenerated copy constructors and therefore not particularly efficient (which often isn't true).
It's such a good practice there are headers in the standard library *just for forward declarations*.
The code is still ill-formed according to C++11. Also it is a feature of the compiler, not just the library. 
I'm not sure what kind of copy-elision you expect to take place here.
I might be missing something obvious, but a getter like that should just return a const-ref of my_data_ rather than a copy, right?
The type where there is only one copy in: MyData got_it = manager.get_data(); If the data is so big that this is a problem then it should have more fine-grained functions to access it.
Here is a great video explaining it all with helpful visual aids: https://www.youtube.com/watch?v=f5liqUk0ZTw
I don't think that is the point the guide is trying to make. That elision is independent of inlining.
 auto myMap = std::map&lt;std::string,std::set&lt;std::string&gt; &gt;(); Now write it without auto. Or better yet: for(auto it = complexType.begin(); it != complexType.end(); ++it) Both are great uses of auto as they improve readability. Never use it for basic types. That would decrease readability. 
This section was talking about getters returning by value, not about inlining. 
Worth mentioning I think: boost::container::vector&lt;&gt; supports incomplete types and recursive containers: http://www.boost.org/doc/libs/1_55_0/doc/html/container/main_features.html#container.main_features.containers_of_incomplete_types
&gt; the user can const_cast and then modify the private data Interfaces should [protect against Murphy, not Machiavelli](http://www.gotw.ca/gotw/076.htm).
&gt; Here the accessor is trivial and safe to inline. But the following code is probably not, even though it also looks simple: But regardless, how does copy-elision make this code alright ?
I believe you are correct that it has nothing to do with inlining, but equally, copy-elision doesn't come into play.
if we aren't talking about getters (which should return a const ref), if your function returns a result (something that the object won't store, it returns the result of some computation), the copy-elision will do one less copy when passing the result by value. It won't copy the object when returning it, it will already be in the receiving variable. an example would be a return value like a shared_ptr or unique_ptr.
I'm familiar with NRVO, which is not applicable to the given example.
Especially as no interface can protect you against willful damage .. e.g. `reinterpret_cast&lt;char*&gt;(pointer_to_class)` still exists.
But how does the compiler know how much memory to allocate for each vector element?
Comments about design and code style are very welcome. It's a fairly unusual thing to do in C++, so I hope I get the benefit of the first-mover doubt. ;)
This is precisely where move semantics shine. One of the best C++11 features, IMO.
Except that you *cannot* move that object because the `Manager` object still owns it. This code actually requires a copy, and there’s no way to avoid this.
Looks pretty cool. Did you consider using boost::asio internally instead of libevent?
It works, because no method of the vector is ever instantiated. Then all the compiler needs to know is the size of its three members (which are of type T* and correspond to begin(), end() and begin()+capacity()). It is basically the same as the pimpl idiom. As soon as you use the vector for anything, T must be defined though. Hence you need to prevent implicit instantiation of vector by explicitly declaring all special members of the class containing the vector and defining them inside the cpp file, where the vector's element_type is already known.
Hah, right. I didn't consider the member variable.
looks nice and modern - I like the blog example but it shows the data storage layer as living in global state... (i.e., the Route specialisations are globals somewhere that are initialised with the global data storage mechanism accessed by 'auto records = from&lt;MyThing&gt;();' Is it possible to pass instances of the persistance layer to instances of the routers? BTW, Im sure you know but the advanced routes and templates sections of the help are missing edit: also, is the synth plugin (or other plugins) described in the docs? 
There is also https://github.com/jeaye/jest which uses C++14
I did consider it, but I really want to keep Boost out of the dependency list. This is perhaps idiosyncratic, but in my experience, Boost tends to complicate things unnecessarily in its quest for maximal runtime efficiency. Rather, Wayward opts for simplicity, *readability*, and therefore often runtime polymorphism over compile-time polymorphism. This does result in some duplication of Boost functionality, unfortunately, in the Wayward Support library (which has its own `Maybe` class etc., mostly interface-compatible with `boost::optional`). That said, the Synth templating framework that Wayward supports depends on a subset of Boost, but it is isolated in a plugin. That plugin takes longer to compile than the entire remainder of the Wayward framework, including support libraries and the Persistence ORM, so right now I'm not keen on Boost. :-) Libevent actually has a very good API, even (or maybe because of) being C. EDIT: If you're downvoting, you better give a good reason. Boost is a great library, but it is not suited for the purposes of Wayward, which are quick turnaround time and simplicity.
Oh? I could've sworn there was one before in the Seattle area. Well anyway, I'm sitting on a broken ankle and now I'm doubly bummed I can't get a shirt from the first cppcon haha.
Thanks for the comment. :) Route objects are actually not globals. The route object for a request is instantiated when the request is run — there is no global state. It is true that the current `w::Route` owns an access to the persistence layer — this is mostly for convenience, and variants of the same functions exist as free functions, like so: p::Context context; auto records = p::from&lt;Foo&gt;(context).where(...); You are right, there are some blind spots in the documentation — I hope to fill those out very soon. The Synth plugin has not been described yet in the docs, mostly because it is very much work in progress. I've been discussing with Alvaro (ajg), the author of Synth, how to improve the bindings further, so this is subject to change very soon. The interface from Wayward should be fairly stable, though.
The irony is the style guides largely ignore the fact that you can use template parameters in this fashion.
Really cool, bookmarked.
QT is like a GUI library? Boost is what i've read a library of libraries? Is that correct?
Libraries - pthread, boost, opencv, QT Software To Know - cmake, git, nm, gdb, any IDE (Eclipse, QtCreator, Visual Studio) Learn - differences between compiling and linking, link time vs runtime, what linking is, linux environments (ld.conf, includes vs libs)
I am currently using CodeBlocks. I understand the linking an compiling. Dynamic libs and static libs, and kind of get pros and cons of each. Occassionally i have to google around abit because I've forgotten, which is faster, which gives more control, which is system dependent etc. I'm currently using windows and compiling with the gcc straight in codeblocks, I would love to learn how to compile via a command line so I can make a move to linux but I haven't been able to find anything to teach me on this I have tried to mess with cmake but when I tried to build a library it was unsuccessful, couldn't find any tips or fixes and eventually fizzled out. I thought git was just a place where people post their programs and other people can collaboprate and contribute to that code and make improvements? 
Boost is kinda the testing ground for upcoming C++ standard features. Smart pointers were implemented into the standard libraries, in big part, thanks to the efforts of the boost community to provide a sensible implementation. Plus, it has many great stuff. Boost Asio is a nice example.
so boost is like a trial run for i assume libraries solely created under a boost license? what is an example of a problem I wouldn't be able to use something standard in c++ that boost would make easier? 
Learn what revision systems are: some places may use svn or cvs - but there's a highly likely chance they use git. You ABSOLUTELY need to know what a revisioning system is and how to use it. Unfizzle out of cmake - you need to know at least one build system. There's scons, autoconf, qmake, and tons upon tons of build systems. A great way to get better at this, build packages from source. Don't just "sudo apt-get install" or "sudo yum install" The things I mentioned, I've learned over 6 years of coding C++. I read a lot though, so for others it takes longers - there are also people who read more than me. These topics won't come to you immediately, they take a lot of time and a lot of accidental discovery (through trying to fix bugs, or personal experimentation)
Regarding Linux, take baby steps. Just install linux, go with mint or Ubuntu - they're really easy and support a large variety of hardware. Make yourself a hello world application and go from there. Oh a huge tip: ALWAYS start with a hello world application, just gets the juices flowing.
&gt; QT is like a GUI library? QT is a lot more than just the GUI library, it has everything needed to write a platform independent application in c++. It also adds a signal/slot concept with runtime reflection to c++ and has classes for networking, file system access, threading among many others. Lastly it comes with several (mostly optional) tools including an IDE and UI designer. 
I will unfizzle haha. Thanks. So git is a revisioning system? It seems to me like a way for developrs to put up code on a network and have other developers, who might be interested in a certain codes function, take a look and see if there are any improvements they could make. But it also allows you to revert to an earlier version if there are issues with an updated version that might have been overlooked. Is this right? is cmake its own build system or is it a bunch of build systems within cmake? thanks for your insight./ 
Everything in boost can be done in c++, it just makes thing easier for you. Some examples though * boost::thread and boost::function * boost::program_options * boost::serialization * boost::filesystem
Correct, revisioning systems do a lot, some of which you listed. Here read this: http://git-scm.com/book Cmake is its own build system. Lastly, http://www.stackoverfow.com is your best friend. People are very nice on there, and very quick.
Yea I was planning to partition my harddrive and make half windows half linux and then make all linux once I was comfortable enough. yea haha I always start with a basic program just to get my mind itching in that direction. 
so what type of problem would I use it to solve? I'm just trying to understand more. 
Actually, you are right that it breaks encapsulation, but for the wrong reason. `const_cast` is not a good excuse, a truly evil user could get away with `#define private public` with most (if not all) compilers even though this is formally undefined. What breaks encapsulation is that synthetising the element is no longer possible: class Good { public: Foo getFoo() const { return Foo{bar}; } private: Bar bar; }; class Bad { public: Foo const&amp; getFoo() const { return Foo{bar}; } // ERROR ! private: Bar bar; }; So that if the getter returns by value, then I can change the class internals (at the cost of synthetizing the value when the getter is called) whereas if the getter returns a const-reference then I have little choice other than having the data as a private member (it can be lazily computed, but still will take memory). Note that in the context of a dependency you own, sacrificing this kind of encapsulation in the name of performance is no big deal. It's mostly you deliver your code to others that it becomes problematic as requiring a source code change on their side might be met with opposition.
There was GoingNative in 2012 and 2013.
Thanks! so from what I undersdtand about cmake, is it takes the source code of a program and "makes" it into a file readable by the cpu? I'll look into the git online book tonight,. thanks a lot. 
&gt; so boost is like a trial run for i assume libraries No, Boost is not a trial run. It is a collection of libraries, they are all supposed to be high quality and production ready. As it happens, some are of such astounding quality, that they lead directly to extensions of the standard library. 
&gt; boost::thread and boost::function Everything you say is basically correct, but of your examples, the first two have direct equivalents in the standard C++ library.
ah I see. when I looked at the site they all seemed to have very specific functions is this the case? The only experience I have with external libraries is when I wanted to see how to make a 2d side scrolling video game and downloaded sfml and I also tried to mess with libcurl when I wanted to try a program that would link to a stock site and pull real time stock prices and record them(I was told libcurl was good for creating a socket?)
No, all that build systems is organize the build process. They eventually call g++, the compiler and the linker, ld - these are the things that make a "file readable by the cpu" (which is a discussion in its own). Cmake allows configuration, organization, library management and control flow. It makes a "makefile" for you in linux. Which, hilariously, is also another build system. CMake just makes it easier and creates dynamic Makefile's based on your system configuration and build parameters.
Yes but boost makes them easier AND makes them cross platform.
First, I don't see how using boost takes away from simplicity and readability. Second, compile-time polymorphism is simpler than runtime polymorphism(unless you are using type erasure), since it requires no inheritance nor pointers. That said, I think, boost::asio shouldn't be a header-only library. First, it would improve compile-time performance without affecting runtime performance. Second, os-specific stuff could be put in a seperate TU. Of course, you can always seperate it yourself(pimpl idiom, interface, etc..). Also, boost::asio can be used without needing boost on C++11 compilers, however, asio is just a networking library and doesn't implement any protocols such as http. So libevent may be further ahead in that regard.
It seems very weird to me to include a picture of the interviewer and not the interviewee.
so after it makes a makefile in linux say, what would be then don eiwth the file after? woudl you build the "makefile" cmake initially created? when I was messing with cmake, i used the GUI and selected a library I had downloaded but i never was successfule at making anything, it would always say some error, i think about it not being an appropriate file type or something. i figured it would take a .src as its input file and outpit a .make file? hey again thanks for bearing with me. i'll understand anyone that abruptly gives up answering my questions. 
not downvoting, but just so you know, boost:asio may be integrated in the standard of C++17.
I see you are using mkdocs for documentation. Actually started using that recently for a project. Its ver nice and simple. Also, you should consider using CMake for the build system. Do you support cross-compiling and other such things?
That sounds wonderful! I'm also very aware of the fact that Boost is a very loose collection of very different libraries with no clear single design philosophy. As I said, it may be idiosyncratic, and it may change in the future. Regardless, the libevent interface is hidden in Wayward, and shouldn't impact users at all. :)
&gt; First, I don't see how using boost takes away from simplicity and readability. Then I'm not sure you've worked with much Boost-y code. ;) Of course there are good things and bad things in Boost, but it really is to a large degree infested with the compile-time dependency injection pattern. &gt; Second, compile-time polymorphism is simpler than runtime polymorphism(unless you are using type erasure), since it requires no inheritance nor pointers. It is not simpler to understand, read, or debug. Of course, YMMV, and different situations require different solutions (Wayward *does* in fact use compile-time polymorphism in a few select areas). &gt; Also, boost::asio can be used without needing boost on C++11 compilers, however, asio is just a networking library and doesn't implement any protocols such as http. So libevent may be further ahead in that regard. Yeah, there's that too, but I'm actually already using libevhtp on top of libevent to do the heavy HTTP lifting. :) It has its own problems, but we'll be getting around to that.
mkdocs is just wonderful so far, I'm having a great time writing documentation! Which is good, because it means it actually gets done. I started out using CMake but hit a roadblock because it doesn't support "question mode" (`make -q`, `scons -q`), which is necessary to check whether or not a rebuild is needed. [It doesn't seem like CMake will ever support this.](http://www.cmake.org/Bug/view.php?id=15036) I'm not extremely happy with Scons, since it's quite slow (~0.4s on my system just to check if a rebuild is necessary). Right now I'm tempted to switch to plain GNU Make, but that comes with its own set of annoyances. Cross compilation hasn't been on the list so far — I'm imagining that a deployment process would involve compiling the app on the server, rather than distributing binaries — but if someone wants to add support for it, I'm open. :)
A good knowledge of the STL is important, and will be available almost everywhere you have C++. Boost is fantastic. Qt, also fantastic and has an optional IDE bundled in. You will need to know revision control systems, most commonly git. Debugging is a skill and an art and takes practice. And a debugger/IDE really helps. You didn't ask for books, but they're important, too. ALL of the Effective C++ books. I wish I had read them immediately after learning the language, I would have avoided so many mysterious problems. The C++11 standard has done some great things for the language, but anything older than 2011 isn't going to teach it per se. Stroustroup's "The C++ Programming Language" is surprisingly readable, and definitive.
how are the boost libraries easier than the standard libraries? Aren't std::thread and std::function mostly copies of boost::thread and boost::function? 
&gt; mkdocs is just wonderful so far, I'm having a great time writing documentation! Which is good, because it means it actually gets done. I like it too. Do you have github setup in way to build the docs for you automatically?
I use the codeblocks ide as of now. I have these two books http://www.amazon.com/C-Projects-Programming-Text-Based-Games/dp/1423902270 http://www.amazon.com/gp/product/0132673266/ref=wms_ohs_product?ie=UTF8&amp;psc=1 I plan to get the efective c++ this weekend. 
&gt; Most of the common pitfalls of C++ involve code that should be considered “unsafe”, and by adhering to a handful of sensible rules, most of them can be avoided. Most importantly: Never, ever, use raw pointers. Wayward doesn’t provide a single interface that requires you to use raw pointers, and your app shouldn’t either. OK, this really sounds like a start: A C++-webframework by someone who has at least understood the basic ideas of modern C++. &gt; w IMHO this is too short for a namespace or a headername. I consider three letters to be perfect and two and four still good. Maybe consider renaming it to “wwd”. &gt; w::App, w::Request, w::Response You are using PascalCase for your classnames. While I am aware that quite a few people do this, it is not what the standard-library does and therefore something I really dislike. The usual argument “I can differentiate between my code and others code” may be somewhat valid for applications but makes no sense for libraries. &gt; app.get(...) I do see where you got this naming-scheme, but it is somewhat unsemantical: You don't send a get-request with this, but answer one. Maybe rename it to something like `handle_get`. Another thing I didn't see was the license of this.
You would use it to write a GUI app like an email client or CAD tool. Don't learn QT right away. Learn it if the need becomes obvious.
Qt is a framework,it has a lot of components that do not depend on each other and hence you can use what you need. 1. Its a cross platform toolkit and hence you can do C++ without worrying about the underlying platform your code will run in.For example,you can use QThread to do threading without caring or knowing about the technical details of threads in linux or windows or anywhere else your code will run.You can use QNetwork to hide the same details if you write networking code. 2. It follows an event based programming model.This is very handy in most none trivial applications. 3. You can do GUI programming with it as it provides GUI facilities.GUi components is just one of many components and you can do Qt programming without it and your application will have no dependency on it(ie will have no dependency on QtGui) Qt is very modular and hence will give you the functionality you need with very little dependencies as you will have dependencies only on things you actually use. For example,you can write an http server with it and have a dependency only on QtCore to give you the event system and QtNetwork to give you networking facilities and you will end up with a server that will work on linux,windows.mac without carrying about details of those platforms because Qt will hide them for you. 
I was talking pre C++11 put away your pitchforks.
Why are you learning C++? What kind of programs do you want to write? To answer your question literally: there are no "stock" libraries. I doubt there is any single library (besides the STL and OSes) that is used by more than 20% of working C++ programmers. I think the best way to increase your stock as a C++ programmer is to learn more about how machines work. Some people will disagree with this statement, but I think it's very important to be able to mentally translate your C++ code into a rough outline of equivalent C code, and then mentally compile that into assembly code. If you can't do that, you *will* eventually write some C++ that is slow/hogs memory/crashes, and you won't understand why.
I'd like to write flight simulation, video games, finance analytical programs, but really would like to get into the programming done for something like nasa or spacex. Maybe a GPS or automated piloting program for future satelites. and OSes-operating system's? By stock i meant things that I can just add into as a header like ctime, cstlib etc. are these not libraries? or are they part of a larger libraryu my IDE or compiler comes with?
ahh i see haha. seems like there would be really good stuff there then haha
so QT is really a versatile library. it has capabilities and because it has so many different modules there is lower risk of dependencies.
`ctime` and `cstdlib` are part of the C standard library. You can use all of the C standard library from C++, but there is usually a better C++ equivalent. You should still learn both because any moderately old C++ project will probably contain code that uses the C standard library. You should know, or at least *know of*, every library at [cppreference](http://en.cppreference.com/). Start with the ones that aren't marked "C++11".
and that is where boost and QT come in correct? thanks!! 
We still have things like copy elision. So, it does not always involve two move constructions in his example when the unique_ptr is passed by value. That's what Dave's Want-Speed?-Pass-by-Value article was about. But I guess, taking move-only sink params by rvalue-ref won't hurt. Not that I care much about unnecessary moves for cheaply-movable types.
In case they're using C++11 or newer, the last point about static function-local variable initialization being thread-unsafe is moot becuase C++11 guarantees them to be thread-safe.
No, I just do it manually, which actually is a little bit annoying. Is there a way to get Github to do it?
`#include &lt;algorithm&gt;`
No, everything listed on cppreference is part of the C++ and C standard libraries. They are distributed with your compiler. Boost and QT are separate libraries you have to download and link with your program manually. Based on your interests, I think you should learn a "creative programming" library like [openFrameworks](http://www.openframeworks.cc/) or [Cinder](http://libcinder.org). These libraries make it very easy to pop up a window, respond to the mouse/keyboard, and display some 2d or 3d graphics. You probably won't get a job writing Cinder or OpenFrameworks code, but the professional-grade ways to do the same stuff are too complicated for a beginner. By the way, you made a good choice to learn C++. It is widely used in the fields you mentioned.
Just to be clear, I don't think it's a clear-cut "one is always better than the other" — that's clearly not the case. Subtype polymorphism is just one type of runtime polymorphism, obviously. Wayward has a few more (`Either&lt;...&gt;`, `Any`, which are like `boost::variant` and `boost::any`, though not like `boost::type_erasure::any`). Frankly, though, for the vast majority of situations, subtype polymorphism is "good enough". It's not without its pitfalls, but with a handful of good design rules (i.e., think in terms of interfaces, never give abstract classes value semantics, etc.), I haven't had any problems whatsoever. As for pointers, I'm religiously avoiding raw pointers in APIs. It's *always* an `std::unique_ptr` or `std::shared_ptr` or similar — ownership is always clearly expressed in the type system. As for debugger support, most debuggers (including GDB, LLDB) understand subtype polymorphism and allow object inspection through an opaque interface pointer. Now, the (IMO huge) benefit of subtype polymorphism is that the interface is separated from the implementation, which means you move code from headers to source files. This is very, very important in light of the goal to have quick turnaround time. C++ still doesn't have a module system, and heavy lifting in header files is a main source of the often completely abysmal compile times that C++ projects are often encumbered by. I will mention again the Synth bindings, which take longer to compiler on my machine than the entire rest of Wayward, because Synth (which is an awesome library, still) uses compile-time dependency injection heavily. It also takes about 4G memory to link it. I dare you to find an (unjustified) "AbstractFactoryFactory" in Wayward. ;-)
I did not say it cannot be done, I said Microsoft used this to restrict portability of its programs to other platforms. 
There are a lot of good libraries, often from the era before C++11. Those "legacy" library can give you a good and solid codebase for your programs. Qt, wxWidgets or boost to name a few. All of them are still maintained and actively developed, so they will also adapt to the newer standards or already have. The field of C++11 &amp; C++14 libraries is just emerging, but there are already a lot of interesting ones on github. The boost library incubator could be a place where those library find a central repository. C++11 &amp; 14 also give you a lot more options in the standard, so that you don't have use boost for things like smart pointers.
`valgrind` is an essential piece of software for debugging memory and threading issues. 
Causing undefined behaviour is a major thing. You can't protect against undefined behaviour, but you can protect against defined behaviour. (There are workarounds for the member template example in Herb Sutter's page). Your other point is good of course. Another major problem with the `Foo const &amp;` version is that it could give a dangling reference , e.g. calling the getter on a temporary object. 
Thanks! Yea that's what I was reading that c++ is used in those fields. That's what I figured, standard with a compiler. I've tried to work with sfml and had to link that with my include and lib file when I downloaded te library. 
I think I'm gonna learn the c++legacy libraries and try to add in the the qt and boost. I'd like to be as employable as possible, gain experience and eventually move into the space exploration industry
Thanks!
What exactly does valgrind do?
I think this is only the case for non-default constructors, right? I believe the standard only allows for non-'as-if' copy elision in the case of RVO (and throw/catch special cases)...
ok great - is it generally OK performance-wise to create a context per request then (to avoid the global persistance layer?)
&gt;Here, we take the target, which is presumably the Node.js binding, and set a property on it – as if it were a dictionary or hash. Our hash key is “hello”, and we use V8 to templatize and instantiate a new function that we’ve called “Method”. To put it a bit more simply, the purpose of the init function is to set up a dispatch table. 
It's a great book!
&gt; "w::" is meant to be short enough that "using namespace" always becomes unnecessary Personally I find the double-colon the worst part of writing down an explicit namespace and the biggest source of noise, so I am unsure whether this will stop beginners from doing stupid things. &gt; Besides, there is plenty of precedence for this naming scheme. I know and I am not opposed to it in other languages. I am aware of the argument for better readability, I just think that mixing styles is even worse than a bad style. And since almost everyone uses the stdlib, there is no realistic way to avoid mixing the styles when using something other than `snake_case`. &gt; You'll notice that there are hardly any getter/setter methods in the whole I didn't look to close into the code, but this indeed points to another thing: IIRC you have some public members with names like “member_name_”. I take that the underscore at the end is to imply, that the member is private. I think it would really be better to use compiler-enforced access-checks than relying on conventions. &gt; That is a good point. I'll add one. Any preferences? I'm thinking MIT. Personally I'd recommend LGPL. Everything that is not copyleft makes it to easy for companies to create proprietary forks without giving anything back.
Isn't the fact that an rvalue reference is probably implemented as a pointer significant here? I understand that they're cheap but they aren't totally free (barring compiler optimization). You're still copying a pointer onto the constructor stack. Am I missing something here?
Can someone actually think that this is what other people think and spend their time on?
&gt; Am I missing something here? Yeah. It's pretty irrelevant and an implementation detail. Like you said, the compiler will try to optimise it so it's not really worth discussing. Not to mention the same could be said about passing by pointer or passing by reference. This isn't even what move semantics or the article itself is about.
I was looking at type erasure for some components of the system, where subtype polymorphism seemed insufficient. It's an elegant solution, but its implementation in C++ is *really* complex and a lot of code. If it's possible to do without that complexity, I prefer that. We're talking about a web framework here. The moment there is a piece of code that's hard to understand (and Boost.TypeErasure is hard to understand), that's a potentially fatal security breach. Am I 100% sure that I understand every corner case and gotcha of Boost.TypeErasure? Do my users? For subtype polymorphism, I can say "yes" with high confidence, so that's a big reason it's immediately more attractive from the get-go. &gt; Type erasure is a better way to do runtime polymorphism. "Runtime polymorphism" is, as I've mentioned, not just one thing, and each approach has different pros and cons. I'm wary (and weary) of clear-cut value judgments like this — it's rarely that simple. &gt; Yes of course there is a trade off between using runtime and compiletime polymorphism and performance. However, this has nothing to do with simplicity nor readability of code. You know, if I can't convince you that multi-parameter templates, SFINAE, partial specialization, etc. are rarely as readable as a non-templated version, I don't see the point of this discussion. Metaprogramming techniques in C++ are *not* trivial to read or understand, and they impose a significant overhead to understanding the code. That's not to say they shouldn't be used, or that Wayward doesn't use them — it does, but very judiciously. &gt; Any use of AbstractFactory would be unjustified. There are simpler ways to solve these problems in C++. You said `AbstractFactoryFactory` — that's not the same. ;-) The factory pattern also isn't very hard to understand. Nevertheless, it isn't really used anywhere as far as I remember.
Yes. In fact, it's required. ;-) It's perhaps not ideally named, but a "context" does not represent a connection, but rather a lifetime-space of database records. Its main purpose is to manage the lifetime of objects, which refer to each other through associations, and therefore often have circular references (think a pair of belongs_to/has_many), making `std::shared_ptr` not an option. Pooling all associated records in a context means they are automatically "garbage-collected" at the same time. This does imply that storing a `RecordPtr` that outlives the context is an error, and will cause a crash. There are some small measurements in place to detect this, but as long as you don't have global state and keep request state in your `Route` object, it shouldn't be an issue. :)
I guess in my mind I'm used to expecting snake\_case for everything that follows `std::`. Also, while Wayward does use the standard library extensively, there would be good reasons to implement wrappers around some of the most commonly-used classes from the standard library: - String (`std::string`): A layer of UTF-8 awareness, and a "SafeString" class representing escaped HTML/JSON/etc. - Vector/Array (`std::vector`): Implementing `operator[]` in terms of `at`, so you get bounds checking for the most common case. - Map (`std::map`): An interface based on `Maybe` instead of iterators for lookups where you aren't sure if the key exists. In the end, I actually expect that Wayward will mostly expose APIs in terms of STL-compatible classes, rather than the classes themselves. There are many weird corners of the standard library that feel a bit awkward. Generally, I do encourage using the standard library whenever it makes sense. :) &gt; IIRC you have some public members with names like “member_name_”. I take that the underscore at the end is to imply, that the member is private. I think it would really be better to use compiler-enforced access-checks than relying on conventions. I disagree. (Actually, the underscore is merely to imply that it is a member, regardless of visibility.) For one thing, it makes some things harder to test. :-) But really, I do try to encapsulate things when it comes down to enforcing invariants, but often, it doesn't really matter. The trailing underscore effectively communicates to users that if they mess with it, they're on their own and that they're outside the bounds of the defined interface. 
http://natureofcode.com/ lookup "verlet integration" and learn about it http://gameprogrammingpatterns.com/ and, read every day: http://www.gamedev.net/page/index.html
I really would prefer CMake, but as you can see it's just not going to happen, unless we reimplement the "out of date" checking outside of CMake, which isn't really all that easy.
true - but you really think that someone who would do something like that would care? 
I think Scott is a bit off with this one. The performance issue is negligible even if it has the effect he thinks it does...and I'm not sure it does. More importantly is the security of the interface. There's no f'n way to call a function that takes by value in a manner inconsistent with its use. You either move into that parameter or you copy to it...you can't both move it and use it later. Rvalue references are too beholden to convention when there's a much more secure path that's enforced by the language. He also seems inconsistent and defensive in his comments. He initially talks about move-only types, which actually can't accidentally be copied into a value parameter, and then talks about the benefits of not being able to pass in an lvalue...well you can't already with that type. The other thing he complains about in response to those suggesting to profile first and default to value semantics is that he doesn't want different rules for different situations...but a move-only parameter type is in fact a very particular situation that isn't going to be coming up a whole lot in idiomatic C++ code. His own counters seem to counter his original argument. So I think he's basically dead wrong here...but nobody can be right all the time. Someone brought up exceptions and I think that's a pretty important topic that doesn't seem to have a good answer. I don't think though that value vs. reference fixes the problem, it only pushes into a place where you can't see it or know what might happen: inside the function you called. Is it going to move in a way that's not strongly safe? Fact is that the caller needs to ensure their own safety guarantees, and they can't do that if their own state is changed inside a function they call. You should be assuming that the value is non-recoverable when passed as an rvalue anyway--that people are suggesting you can do otherwise when an exception is thrown is sort of the really bad part of the convention they want to use. I'm far from convinced that the reference guys make a good case.
Suppose you call a function yielding a unique_ptr and directly pass it to our sink function. In this case, it does not really matter whether the sink function takes an rvalue reference or a unique_ptr by value. In case it's by value, the source function would directly construct the unique_ptr as function parameter for the sink (assuming the compiler does copy elision).
Well, you get an indirection with a reference. Not sure though whether this affects performance in this case.
A few things that caught my eye. //Binds a function to a key, returns an int of the overwritten key if any. int BindKey(int, InputFunc); It will always return an integer, but probably a special value if the binding didn't overwrite anything. Add a constant for this special value so clients will not have to guess any magic numbers. //Create a Context with the given name and passthrough value void CreateContext(std::string name, bool passthrough); What happens if the name already exists? Exception? Silent fail? Overwrite? Also, it might be convenient for clients if you immediately return the newly created context. Speaking of which... //Returns the context with the given name InputContext GetContext(std::string); This returns a copy of the context. When clients modify it, the changes will not be reflected in the input context the InputHandler holds. And last, but not least, if you want it to be reusable, wrap it in a namespace to save users from headaches when they have their own class named `InputHandler` or similar.
I had already posted the link a few months ago, but there has been some progress since then. Here's what's new: * There's documentation now: http://schlangster.github.io/cpp.react/ It's still incomplete and most of the articles are draft-ish, but hopefully the essentials are covered. * Cross-platform support. Namely, I tested compilation with recent versions of GCC and Clang under Linux. * The API has seen some refinement (RIP -&gt;* overload), lots of cleanup, etc. * Support for async input, which was a rather obvious feature to be missing. The code can't be considered release quality yet, as I still plan to add a few more features. More importantly, it has not been reviewed by anyone but me. Hence, I would appreciate some feedback; on the API, the documentation - whatever comes to mind. (Oh, and the first time I posted the link, the library was still called cpp.react. There's already cpp-react and react-cpp, so I figured C++React is more distinct.)
Why are you suggesting to leave C++11 for later? In fact IMHO learning C++11 from the start is much easier and consistent.
I can see why this has been suggested, but just because something is passed as an rvalue reference does **not** mean that it will be moved from. If I see `void sink(std::unique_ptr&lt;int&gt; ptr)` then I know that whatever I pass into this function will be moved from and I should no longer use that value. If I see `void sink(std::unique_ptr&lt;int&gt;&amp;&amp; ptr)` then all I know is that it takes an rvalue reference, what I pass into this may not be moved from and could still be usable (I have no clue why we would want to do this, but this is C++ and I wouldn't ever rule out something because I can't think of a reason).
Sure it is. His issue is about one `std::unique_ptr` construction vs two. Since ideally a `unique_ptr` costs the same to initialize as normal pointer, it should also cost the same as a typical reference.
I thought the auto-mock functionality was pretty effing awesome. Nice work.
What is the difference between signals and events? Why not just add a SignalSource and use Signal as Event instead? Why the need to distinguish the two?
Well, i use hacker vision chromium plugin which inverts colors. Looks even better :)
I don't know. I'm interested myself. I wrote an email to the author.
do the Effective books allow for beginners-intermediate? 
does that come with my compiler?
In the case of something like `std::unique_ptr` it doesn't even require explicit move elision. If the relevant code is inlined it's completely trivial for the backend optimizers to remove some pointless pointer assignments (and in any compiler that converts everything to SSA form it might actually be harder *not to*).
There's no markup in the headers, nor obvious comments in the HTML -- it appears to be manually documented! It is very attractive, but I prefer to use doxygen, so that, modulo longer explanatory prose, both the binary and the docs are generated from the same source. 
&gt; I have no clue why we would want to do this, but this is C++ and I wouldn't ever rule out something because I can't think of a reason Behold, optional output parameters that do not require checking if they're null within the function: #include &lt;cstdio&gt; #include &lt;utility&gt; void do_stuff(bool&amp;&amp; success=bool{}) { success = true; } int main() { bool result = false; do_stuff(std::move(result)); printf("%d\n", result); do_stuff(); } This is, of course, completely fucking terrible and not something anything anyone should ever do under any circumstances. The more reasonable reason for it to matter is that the object could be destructed later than you expected, which will very occasionally matter.
Given that the documentation doesn't exactly correspond to the source code, it would appear to be manually documented. Which is a shame because it is very nice, but it's not reasonable to manually document large, changing codebases like that. I wonder how much effort it would be to get a Doxygen template that looks that nice though...
As far as i know doxygen does not allow custom templates. Maybe this template could be easily integreated with http://jessevdk.github.io/cldoc/ :)
Lets ask author: /u/schlangster
Did that even before writing here :)
It has some rudimentary support - under the name Layouts - but I've never touched it so I don't know how far it goes. Failing that I think the best option would be to use the XML Output as input for another generator, but I can't be bothered to look into that right now :) cldoc looks interesting, but the fact that it depends on Clang could be a non-starter for some people unfortunately... (We've got at least one project at work that only builds under MSVC 2003, for example)
Clang is working on a plugin for MSVC.
Now that I didn't know. However, the problem in our case is literally that the code is old enough and badly written enough that it only compiles with the compiler from the 2003 Visual Studio suite, and there's no time/desire to make it compile on other compilers...
[The source code of the documentation can be found here.](https://github.com/schlangster/cpp.react/tree/gh-pages) The content itself is handwritten, but the site is generated using GitHub pages' integrated support for Jekyll. So the effort of adding content is comparable to writing your documentation in the GitHub wiki (which I initially tried to do, but I was not too happy with the results). I'm not sure what would be the best approach to make it fully automated, as I haven't really investigated that yet and it would depend on which generator is used. Either make it generate Markdown and feed that to Jekyll, or convert the static template to be used with another generator.
Ahh, I hate to work with such code.
I don't think that's what they're talking about though. I agree with you that it's insane, but slightly less so than THAT. What they seem to want is something like so: void throw_fun(type &amp;&amp; t) { // safe operations that could throw... mycopy = std::move(t); } void caller() { type t; try { throw_fun(t); } catch(...) { use(t); // and this is OK! } } Yeah, I think that's pretty terrible myself. I can see perhaps a case for it in very, VERY rare conditions but it would need some seriously special documentation. The caller function should assume that t is toast and not use it even in the exception catch block. The construct they seem to be talking about is horribly unsafe--it's a maintenance nightmare.
Oh, that makes more sense. I think I'm inclined to agree that it's too error-prone to be a good idea. My view is that having the ownership semantics expressed in the type system is more important than the strong exception guarantee, but I can at least understand why someone would disagree.
yep, it could be elided if it was an actual move. It seemed to me your statement was more general than that
Yes... I think it's what I should have read right after schooling. You need to know the language basics first, but it's one of the best places to go for c++ best practices. You should be able to find some samples of them online pretty easily. There are a few things that have improved in C++11/14 that used to be done a different way for a best practice... For example disabling the compiler-generated copy constructor was done one way in the effective C++ days, and is now part of C++11 using the delete keyword in the declaration. The reasoning and discussion in Effective C++ for the situations you'd want to do this are still totally valid, you just don't have to jump through those other hoops (on a C++11 compiler). Meyers' latest book, Modern Effective C++, will cover new practices from the new standards, it's in draft form right now, but I believe it's designed as a companion to its predecessors.
&gt; &gt; You can still use main(). &gt; No, you can't in Win32 applications. That's one of your [comments](http://www.reddit.com/r/cpp/comments/2ay7ez/the_modern_c_library_for_a_modern_windows/cj0wqv1). Don't lie on the internet. 
Download virtualbox and run linux in a VM.
Worst case scenario, you can just add `#define private public` before any includes in your tests. ;P
I have to say that it is beautiful to me. I use C# daily and the async await keywords make the code more readable and more manageable. Here I sit all hopped up on c++ and want to go home and try it out
how my space do i need for virtual box?
That's why I like c++ so much.
I've looked at the source (pretty impressive), and as far as I can see there's no *alternate* static way of getting the injector. Spring has it, and I wish it did not - http://docs.spring.io/spring/docs/2.5.6/api/org/springframework/web/context/support/WebApplicationContextUtils.html#getRequiredWebApplicationContext%28javax.servlet.ServletContext I'm co-creator of PicoContainer (Constructor DI for Java) some ten years ago.
I'd say at least 2GB actual storage (depending on OS, Ubuntu Server (CLI) says it needs 1GB default install). They are thin provisioned disks so you can setup the disk in virtual box to look like 15GB to the VM, but it only uses the storage on the host disk if it's used in the VM (so the actual usage would be 1GB with the ubuntu server default install).
What do you mean by "alternate static"? 
Signals and event streams are similar in the sense that they propagate values, but they have different semantics. A signal essentially deals with changing state. It's like a variable with a single, persistent, mutable value. It propagates that value, when it was changed. In a sense, it's a fusion of mutable state and a specific type of event ("value change") that can be generated from it. Event streams are more generic, because not all types of events are state changes. Think of mouse clicks, user actions, etc. These are not about changing state, but about occurrences of certain conditions and triggering actions based on them. I'll try to show this on the example of capturing button presses. If we wanted to represent this as a signal, it would be declared as something like `SignalT&lt;ButtonID&gt; LastPressedButton`. With this approach, the first problem is that if the same button has been pressed twice, `LastPressedButton` would not change, as the value remains the same. To work around this, we would have to tag each press with a unique sequence number, i.e. `SignalT&lt;pair&lt;int,ButtonID&gt;&gt; LastPressedButton`. The next problem - or rather, a limitation - is that only a signal value change can be pushed at the same time. To improve this, the type would have to be extended further to `SignalT&lt;vector&lt;pair&lt;int,ButtonID&gt;&gt;&gt; LastPressedButtons`. Using this would be very cumbersome. "Changing state" is just not the right abstraction for this; that's what event streams are there for. A similar example could be constructed the other way around. Edit: Also, what I found helpful when I first started reading about this stuff (I think it was in the scala.react source code) was thinking of signals and event streams as derived types from the generic `Reactive&lt;P,V&gt;`. P is the propagated type, V is the type of the persistent value it holds. `Signal&lt;S&gt;` is a `Reactive&lt;S,S&gt;`. `Events&lt;E&gt;` is a `Reactive&lt;list&lt;E&gt;,void&gt;`.
What problem does this solve?
I think Scott is wrong on this one. As others have pointed out, the performance gains are minimal. In fact, implementing with swap is what I would do first. If your performance concerns can be pinpointed to the extra moves and swaps (should be never) then I would go ahead and specialize/optimize. KISS
DI in general is a programming practice to provide loosely coupled code, which will be easy to maintain and test. DI framework helps you to avoid writing boilerplate/tedious code whilst using DI concept. http://krzysztof-jusiak.github.io/di/boost/libs/di/doc/html/di/introduction.html 
This doc makes me want to try C++. 
Ok, my mistake. I did not know you can use main() like that. But the essence of my post is not that. The essence is that Microsoft introduced something (the WinMain entry point), which is totally reduntant. Why did Microsoft do that? Can you explain it? Let me tell you why: Microsoft wants to create as many problems as possible when porting sofware from Windows to other platforms. It's a method of discouraging developers to port their apps to other platforms. It is the exact same reason that MFC does not abstract Win32 (Qt showed us that it is perfectly possible to have a gui library without a single point of use of the Win32 api. 
 Just added Task::await() function to my library[1] to give the same behavior in Qt/C++ await will be a nice addition to the standard.Its pretty neat to "block" on a thread without "hanging" it. [1] https://github.com/mhogomchungu/tasks
Same for me.
If you are _really_ enthusiastic, you can make it generate xml, which can be stylized with (say) xslt. I was really enthusiastic this one time about a decade back; it was tedious not particularly fun; but you can get output the way you want it.
Yeah, schedulers w/ future continuations are useful to avoid threads hanging, but once you add stackful coroutines everything gets 10x cleaner. You no longer have to package all the task state inside functors between context switches. Instead it ends up reading a lot like sequential code.
sure, no problem
I'm a programmer since 1997 and also I own a small software company and have been on both sides of interviews for a while now
maybe, but IMHO payment processor example seems to be a bit complex for introduction, its more like a motivation example, which is a bit more complex in DI as well - http://krzysztof-jusiak.github.io/di/boost/libs/di/doc/html/di/motivation.html 
You're probably right. In any case, i think the example in the github readme needs to be more understandable. Even me, being familiar with DI, did not get much out of it.
Using C++11, I would have used `sizeof(std::declval&lt;S&gt;().data)` which is more verbose, but does not require a temporary variable. Is it possible in VC++13 ?
Ill try to remember / take notes and put them up to you directly on here. 
http://interviewing.io/ may be of interest to you, saw this on Hacker News a few weeks ago. It'd be a while before you got one, but it is kinda interesting.
Omg - I was JUST thinking about a service like this today in the shower. "I wish there was a site that just did interviews like charloutte" - I swear, word for word... ha! And here it is. Signed up already. I find it interesting that they would rather you sign up through your github account. Wonder why that is. Gives me an 'only-CS'-y vibe to it... I suppose its a start. 
A method like getInjector() that was accessible globally. DI is an interpretation of "Inversion of Control", and static access to the 'container' would be Inverting the Inversion of Control. I whined about this sort of thing in respect of C# DI containers too: http://paulhammant.com/blog/dotnet-di-better-practice.html
Gotcha. FWIW, the only time I needed a global injector was when an instance was being created out of my control. Even this though, I abstracted through [a special type](https://bitbucket.org/cheez/dicpp/src/90998023171a479e4c8dd9a40b2be934f0ac68d7/include/di/injected_member.hpp?at=default)
no, I don't mind
Moved to MinGW long time ago, QtCreator as IDE. Any reason to look/go back?
Welp, that's hilarious.
Well implicit conversions can be avoided by using a template parameter instead and then you can constrain the template to avoid non-integral types, like this: #define REQUIRES(...) typename std::enable_if&lt;(__VA_ARGS__), int&gt;::type = 0 struct rational { template&lt;class T, REQUIRES(std::is_integral&lt;T&gt;())&gt; rational(T x) { ... } ... }; 
C++ does not have a "strict" type system. It has a relatively weak type system. I think what you mean is that it has a static type system.
Just started watching, it's a bit hard to read the console. Consider doing a bit of video editing to zoom in on it so it's readable in 480p.
Yes, I'm aware that's an issue. I tried to read out the important parts of the console, but it's not ideal.
It is part of the standard library. You don't need to use every part of it, but it's valuable to know everything that it contains. http://en.cppreference.com/w/cpp
Read this. http://www.catb.org/esr/faqs/smart-questions.html
You can change the console's font size, that's what I do for my Channel 9 videos.
Awesome! I'll have to do that next time.
Well done. I enjoyed the whole video and liked that you were figuring out some things on the fly, like the map initialization. Look forward to your future tutorials.
Good work, I liked your tutorial. One tiny detail, however: you can't use initializer lists to init std::containers in C++98 and your code may look confusing in this part: //C++98 vector&lt;int&gt; v = {...} It is obvious to experienced programmers, but people who just started studying C++ might find it confusing.
Ahh, good point. I've added an annotation to the video.
thanks! I'lltake a look. Just curious did I ask a poor question?
The name of an array without the subscript operator is the address of the array's first element. The first for loop can be written: for(int *p = arr; p != arr + 5; p++) 
Make sure you change the Defaults for the Command Prompt and not just that session. To do this open a command prompt then click the icon in the top left and select Defaults. This will change settings for all command prompt windows that open so you don't have to keep making the changes again and again! 
I can recommend STL's video lectures on channel 9. Core C++: http://bit.ly/UvGFIp Standard Template Library: http://bit.ly/1tQuAK7 They're not for absolute beginners, but his videos are very clear nonetheless.
How do you handle distributed memory machines (like hpc clusters), numa architectures (like cluster blades with 2 CPUs with NUMA or hybrid CPU/GPU clusters), and parallel I/O (e.g., writing to the same file/interprocess memory from multiple processes at once) ?
There are no good C++ videos.
This looks like a good write-up on the subject: http://jesyspa.blogspot.de/2012/07/whats-wrong-with-new-bostons-c-tutorial.html Also noteworthy: The New Boston is a discouraged resource on /r/learnprogramming: http://www.reddit.com/r/learnprogramming/wiki/index#wiki_discouraged_resources
&gt; The name of an array without the subscript operator is the address of the array's first element. Minor correction: it implicitly casts to a pointer, but it is not itself a pointer. Arrays and pointers behave differently.
thanks
 Requiring everybody to download source archives to view your code will lead to a lot of unnecessary re downloads. It will be better if you could also host viewable code online.
IMHO global injector seems to be a bit smelly tho, it will be really hard to test the functionality and not sure what exactly would be achieved by using it?
There's [Google's cpp-btree library](https://code.google.com/p/cpp-btree/). Not sure if it's cache oblivious but chances are good that it's very high quality code.
according to this link[1] "using" is an enhanced version of "typedef". &gt;What was the rationale behind this syntax decision? I think its because "typedef" gives a different name for a type that is already known.With templates,the type is not known where the template is declared.The type become known when a template is instantiated. Since "using" can work everywhere and "typedef" can not,then i think usage of "using" should now be the "idiomatic" usage and "typedef" should be deprecated. [1] http://en.cppreference.com/w/cpp/language/type_alias
I'm guessing here, but I think there may have been debate about whether constructs like this should be allowed: template &lt;size_t N, size_t M&gt; typedef int Array1[N], Array2[M]; EDIT: Made example more egregious. 
It is smelly but if your type is created out of your control, how would you inject into the constructor? You can't. A controlled way to access the global injector is preferred to free-for-all access.
Any paper where I can read about the concept?
My current focus is on manycore/multicore with shared memory. There are 32 cores machines on amazon right now and more are coming (Intel Phi or Adapteva http://www.adapteva.com/epiphany-multicore-intellectual-property). But since every APC Server has embedded HTTP Server, it is possible to distribute load on multiple machines. In the current implementation, it requires explicit HTTP requests (it is kind of similar to MPI). Regardless of that, APC can work seamlessly on a machine with private memory architecture also. It would need a different function scheduler and I am planning to try it out on Adapteva/Parallella 64 cores. APC is very friendly for NUMA optimization. Every side-effect has associated NUMA node and all memory for a side-effects is allocated on the corresponding NUMA node. When a function is scheduled, it would be scheduled on a core that connected to the corresponding NUMA node of a side-effect. In the current implementation, the NUMA optimization is not quite finished. I already associate a NUMA node with every side-effect, but I don't assign functions to the correct cores. But if during a transaction there is a new pending function for the same side-effect, the new pending function will be scheduled on the same core, so the side-effect data required for the pending function will be already in core caches and that is big optimization to avoid cache misses. Parallel IO could be similar to a web request that makes 1000s database requests and than generates HTML output. That is what the reduction algorithm do. The final node is the output. If an order of outputs form multiple processes is not important than they all just can query an IO handler (file or socket) and write to it. Since they all query the same side-effect, they will be executed one after another. 
&gt; Minor correction: it implicitly casts to a pointer, but it is not itself a pointer. Minor correction to the minor correction: it implicitly *converts* to a pointer. Casts are always explicit; there's no such thing as an “implicit cast”.
I have written one https://docs.google.com/document/d/1ogktJg0vYNyxuu8Z8Q6z1B30N-TWXT3_BTEMh_iFxpA/pub , but I am not sure how good is it. 
The original paper (N1449) proposing this syntax says: "we specifically avoid the term “typedef template” and introduce the new syntax involving the pair “using” and “=” to help avoid confusion: we are not defining any types here, we are introducing a synonym (i.e. alias) for an abstraction of a type-id (i.e. type expression) involving template parameters." In other words, it's to drive home the point that these declarations aren't separate entities, just alternative names for the type expressions they are bound to. I see no reason they couldn't have used a typedef based syntax; they simply chose not to. As others have pointed out there's really no need to use typedef at all in modern C++, as using subsumes it completely. See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1449.pdf for more.
I will do it on GitHub for the Linux version.
You might want to take a look at this: http://panthema.net/2007/stx-btree/ It follows the style of the stdlib and I believe that the guy who made it (mostly) knows what he is doing.
&gt;in 480p Alternately the viewer could watch in a decent resolution if they want to pick out fine details.
Thanks for the excellent answer. Much appreciated. &gt; ... there's really no need to use typedef at all in modern C++, as using subsumes it completely. I hadn't caught on to that. It sounds like it's time for me to get on the `using` bandwagon!
There are complexities involved with the C declaration syntax used by typedefs. Inside a typedef one uses the syntax for variable declarations, which doesn't work well with templates. typedefs, centered on the C declarator syntax as they are, are really a holdover from C. A more type-focused, C++-like syntax is the new `using` syntax: using my_int_t = int; This should be preferred even when not using templated type aliases.
A lazy question. It's obvious that you didn't try to figure out what Valgrind does before asking. Keep in mind that when someone gives you an answer, they're spending time typing a reply. What you should have done instead of asking what it does is type "valgrind" into Google. Wikipedia is always a good first choice. http://en.wikipedia.org/wiki/Valgrind That link says "Valgrind /ˈvælɡrɪnd/ is a programming tool for memory debugging, memory leak detection, and profiling." Don't know what memory debugging, memory leak detection, and profiling are? They are clickable links as well. It's a lot more efficient for people that could answer your question and for yourself if you use information sources that have already been written when they are readily available. I'm not telling you this to be harsh, but because this attitude on obtaining information is a good habit that will make a far more effective programmer.
Take a look at `boost::iterator_facade`. It lets you implement an iterator with methods like `advance()`, `dereference()` and `compare()`, and automatically implements the correct iterator operators and methods for you.
True. I'm not sure why, but I have a theory: I think that it is confusing for C programmers, as they will often write this in C: typedef struct { double x,y; } Point; This is done in C to allow developers to write `Point` instead of `struct Point`. Therefore many people do use `typedef` as if it is for creating new structs. But, I must admit I'm not satisfied with my explanation! TLDR; Many older C developers might think that `typedef` is "the thing you need to use in order to define (convenient) new `struct` types"
I should've clarified in the post, I'm implementing a bunch of containers as practice for writing my own STL-like library so I'd like to try implementing most of these things from scratch without using anything outside of the STL, like boost. My main concern was whether or not this is a robust solution that doesn't have some small 'gotcha' to it as it seems to work fine. This is my first project involving heavy template usage and I have no prior experience with them to make any good judgements against this technique.
no you;re right, normally I would've looked it up but at the time of reply I was on the move and didn;t have the chance to sit down and google valgrind and I thought my reply was quick enough to continue the flow of conversation. But again you;re right. 
I am not a pro c++ or anything like that, but the new boston's videos aren't that bad. They're not great, but they're not harmful. You'll start off doing things one way and then, if you keep learning, you'll correct yourself. It happens no matter which way you learn, and TNB's tutorials are no different.
I feel like there's an abundance of material that goes over this versus more confusing stuff like move (which is connected to a million other topics i dont understand)
I haven't watched the videos, but if the linked write-up is accurate (and it sounds like the author knows what he's talking about), they are harmful. Unlearning bad techniques is difficult - better to learn mostly-proper techniques from the beginning.
You should have a read of some of Sean Parent's comments... The proposition: Google implies high-quality does not always apply when it comes to C++. Go perhaps but not C++.
Agreed! ++
Saying "you can't make modifications to the container" in the range-based for loop is a bit misleading. I assume you mean you can't change the container itself (adding/removing elements), but it's definitely okay to modify the elements (as you do later). It might come across differently to everyone else, but it caught me off guard when I heard that said. By the way, `std::map&lt;int, std::string&gt; foo{{1, "James"}, {2, "Kathryn"}};` is perfectly valid :)
Can you do: for (int i = 0; i &lt; 10; ++i) {} in C? I thought that you had to declare variable i outside of the for loop.
Thanks everyone for the responses! I forgot to mention that I'm looking for an in-memory implementation to use as a search tree (std::map uses too much memory). The STX library is the closest to what I'm looking for. B+ tree is supposed quite competitive in terms of memory transfer. I'm aware of the Tokutek repository, but it's a full blown database software, whereas I really just need a simple, easy-to-use tree. After a bit of googling, I found some discussion on Hacker News: https://news.ycombinator.com/item?id=7513896 . So there are more libraries out there for someone else who might be interested. Thanks again!
Thanks. I was actually googling for the original software released with this paper http://people.csail.mit.edu/bradley/papers/Kasheff04.pdf , but to no avail. The Tokutek fractal tree is a full blown database software, but I just need a simple, easy-to-use tree as a drop-in replacement of std::map. (std::map uses too much memory, almost a factor of 2-2.5 of the size of the data I'm storing)
You are thinking of C89. C99 allows declarations anywhere (similar to C++).
Perhaps you should consult an optometrist.
Short sighted in right eye. Still difficult to read with glasses.
&gt; My current focus is on manycore/multicore with shared memory. Fair enough, it is not clear at all from your website. Maybe you should mention explicitly that it is an approach for shared memory parallelism. Otherwise I have to guess if you are tackling parallelism/concurrency and shared/distributed memory or all of them. &gt; In the current implementation, it requires explicit HTTP requests (it is kind of similar to MPI). This is cool. &gt; When a function is scheduled, it would be scheduled on a core that connected to the corresponding NUMA node of a side-effect. It is way cheaper to move the work to the data than the data to the work. If you follow this approach efficient use of e.g. GPGPUs will be hard: you will need "impossibly-smart" schedulers. A lot of people are working on these, but the approach followed by OpenACC, OpenMP4, Thrust, CUDA, OpenCL... where you need to indicate the data moves explicitly works really good. Even now that CUDA has unified memory support it is still to be shown that it can at least work as good as explicit data dependencies. &gt; Parallel IO could be similar to a web request that makes 1000s database requests and than generates HTML output. That is what the reduction algorithm do. The final node is the output. If an order of outputs form multiple processes is not important than they all just can query an IO handler (file or socket) and write to it. Since they all query the same side-effect, they will be executed one after another. If you fall back to serial I/O, or if you do a reduction and a single processor has to do all the I/O, then it won't scale. The whole point of parallel I/O is that all your processes write e.g. to the same file at the same time, in parallel. How does it compare to HPX? (which I would say is representative to the academic state-of-the art).
Yeah I must say, the more I watch the video, the clearer it is how I may have done things better. Hopefully this is a learning experience for us all!
Yes, I can see how that may sound misleading. I will add an annotation to the video to clarify. Also, I totally figured out the map initializer list stuff just after I finished recording. D'oh! Think future videos will feature less improvisation (the improv has a certain charm, but I feel the gain in coherency from less of it is worthwhile).
if that's your main concern there is https://code.google.com/p/sparsehash/ as well
Considering `get_data()` is declared as non-const, you could technically move `my_data_`, but obviously this is not what you would want.
[I believe that every single one C++-programmer should have seen this talk by Bjarne Stroustrup where he explains what good C++ looks like.](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style)
fair do's, don't see any good solution in such case then, well, maybe refactoring to use of dependency injection but that's most likely not possible with third party libraries :/
&gt; In other words, it's to drive home the point that these declarations aren't separate entities, just alternative names for the type expressions they are bound to. Is that not the purpose of typedef?
As a C developer expanding my knowledge of modern C++, how would I do this with 'using' rather than 'typedef'?
Huh. Is this something that was added (semi)recently (C++ or C99 or newer)? We used the 'typedef' version at my old work for consistencies sake (and has become my habit), though we were also working with a fairly old embedded compiler which had some quirks. I probably learned the way you demonstrated during school, but it was hammered out of me after working for a couple years.
It's been like that in C++ for ages, possibly since the beginning. Also C99 isn't exactly recent any more, not sure if it still requires typedefs for structs though.
In C++,the only difference between a class and a struct is that classes have all their members as private by default while structs have all their members public by default. As far as i know,it has always been this way.
I've just realised it is possible to use `using` to define new types. using X = struct { int x; }; Similar to the old C technique: typedef struct { int x; } X; So maybe `using` and `typedef` aren't that different after all, as you say.
&gt; You should have a read of some of Sean Parent's comments... &gt;The proposition: Google implies high-quality does not always apply &gt;when it comes to C++. Perhaps not and Adobe is not any better. These (Adobe ) are the folks who created that piece of software that wants to update almost every single day. 
Yup, it's not possible at all. Think about Qt for example, where the ui can be instantiated automatically.
Why would you do that instead of just: struct X { int x; } This just defines the new type as well (in C you'd have to use `struct X x;` to declare an instance, but not so in C++).
No. Please no. DI is great for some things. This is not one of them.
I might be a total idiot for asking this, but how is your logging working? I can't really see where you are using it.
Ah. This seems pretty useful in my situation, and it saves all the hassle with preprocessor calls.
Please explain?
[Boost.Asio](http://www.boost.org/doc/libs/1_55_0/doc/html/boost_asio.html)
[Automatic Parallel Computing is suitable for complex event procerssing](http://parallect.codeplex.com)
Runtime dispatch based DI makes sense when you want to be able to switch which things is used without recompiling everything. For something that is always known at compile time (such as what platform you're compiling for), it's entirely pointless.
Ideally, the interface should be common across platforms. Otherwise, you'd still have #ifdefs in higher level code (codes calling this class). Is there a particular case why bar() is different with bar(int a) in method 1? Anyway, something to check out is the use of opaque pointers. With it, you can have specialized implementation per platform without having to resort to inheritance or multiple #ifdefs in your headers. pseudocode (foo.h): class Foo { public: void bar(); void bar(int a); private: class Impl; Impl* impl; }; Declaration and definition of class Foo::Impl is in the cpp per platform. Foo::Impl would contain all the platform-specific members you don't want to expose in the header. Don't forget to set the rules for copy constructors or assignment operators (you can either have them private unimplemented to avoid shallow copies, or use Impl with shared_ptr to have reference counting). This is just one of the many variations of Opaque Pointers (aka Cheshire Cat, aka Pimpl). EDIT: even more detail(s)
I'm the author of this code, I just published it lastly and feel that could be good help for many people. Also I'm very willing to get feedback, I'm not a professional C++ programmer and I would like to improve my skills in that matter.
You should not implement something that isn't needed at runtime. In this case, the advantages of DI is not needed. What is needed in a compile-time dependence on platform. [That is simply done by keeping different platform-dependent sources and compiling the ones you need for your specific platform.](http://www.reddit.com/r/cpp/comments/2by45s/multiple_inheritance_vs_inplace_ifdef_vs/cja26e1)
Please use the more generic version [asio C++ library](http://think-async.com/). asio can be build with only a C++11 complier, no extra dependencies like Boost.Asio, which depends on Boost.System, thus making Boost.Asio no longer header only. 
Personally, I prefer the using syntax anyway. I've replaced typedef with using in all my new code.
Full Disclosure (from [c++ asio project faq](http://think-async.com/Asio/AsioAndBoostAsio)): &gt; Should I use Asio or Boost.Asio? It depends. Here are some things to consider: &gt; — If you prefer the convenience of header-file-only libraries then using Asio over Boost.Asio is suggested. &gt; — If you must use a version of Boost older than 1.35 then Boost.Asio is not included. You can use Boost.Asio by copying it over the top of your Boost distribution (see above), but not everyone is comfortable doing this. In that case, using Asio over Boost.Asio is suggested. &gt; — New versions of both the Asio and Boost.Asio packages will be created on a faster release cycle than that followed by Boost. If you want to use the latest features you can still use Boost.Asio as long as you are happy to copy it over the top of your Boost distribution. If you don't want to do this, use Asio rather than Boost.Asio.
What is a complex event?
It's mostly a feature intended for internal use. I needed it for debugging the parallel algorithms, because it otherwise it was difficult to figure out what was going on. But lately I've been working on other areas of the library, so I'm not sure if it's still working. So much for the disclaimer. How it's supposed to be used: 1. Define `#REACT_ENABLE_LOGGING`. 2. Propagation events (node updates, changes, etc) will be recorded in an internal buffer. 3. Dump the buffer to a file: std::ofstream logfile; logfile.open("log.txt"); D::Log().Write(logfile); logfile.close(); 4. Visualize the logfile with https://bitbucket.org/schlangster/reactplayer Edit: Here's the compiled version of the player https://github.com/schlangster/cpp.react/tree/master/tools/ReactPlayer
As indicated in the link I posted, the Makefiles generated by CMake do not support the `-q` option (and probably won't for the time being). The reason appears to be the way that CMake produces recursive Makefiles.
To be a little more accurate, it is the *default access specifier* that is different. For structs it is public while it's private for classes. The default access specifier applies to both members and inheritance. So, by default, structs use public inheritance and classes use private inheritance.
Strict*er*, then. Also static, but that's not enough. Go has a static type system that is totally inadequate, for instance.
Abstraction by build architecture is not a bad idea as long as there is equivalence between the platforms (meaning all the Abstract Data Types and the API is the same across platforms). Another potential aid if you want to remove some of the duplication this can lead to is to prefer composition over inheritance which is most easily done in C++ via a template. template &lt;typename PlatformSpecificFoo&gt; class GenericFoo { public: Foo() : _inner() {} bool someFunction() { //Complex platform general code _inner.someFunction(); //More platform generic code } private: PlatformSpecificFoo _inner; }; Of course there are all sorts of refinements and improvements that can be done to the above to lessen the amount of needed implementation and so on. For interface forwarding this can work too but then if I can afford it I just use virtual interheriance and the like instead.
No, Ruby's type system is actually stronger than that of C++, it just happens dynamically.
That would require a std::string_literal AFAIK, so it is not possible in C++11 with this kind of interface. This is just a helper over std::stringstream.
Right, and languages like Ruby do a lot at runtime to ensure that types are not used in unsafe or meaningless ways. That's "strong" typing. C++ is weakly typed because the programmer can, intentionally or not, misuse types in ways that the compiler will not catch. Static typing can catch errors at compile time that a language like Ruby would not catch until runtime. But that's a completely orthogonal issue. You're claim that C++ has a "relatively powerful type system to achieve a higher level of safety than is possible with many of the alternatives, especially alternatives based on languages with less strict type systems." is completely laughable to anyone who studies programming languages. If you wanted strong, static type safety, you'd be using something in the ML family.
That code is not ill-formed - requiring a diagnostic from a conforming compiler - it has undefined behavior, as stated in your standard citation. As stated in other comments, in the most-widely-used standard library implementations std::vector supports being declared with a parameter of incomplete type. If the Chromium projects only intend to support implementations for which that is the case, this is a reasonable style rule.
Okay, thanks.
There's no reason that PlatformSpecificFoo couldn't be defined in something like FooConstants.h (maybe something like FooPlatform.h). Doing so would make it so the developer wouldn't need to use templates to add platform-specific code. (Templates may be required for other reasons though.) In any case, I try to find ways to solve platform problems via compilation options rather than using things that incur additional costs -- be it runtime costs or things like templates that mess up how the deveoper and user has to declare things.
The C++ type system is very complex, and the type system terminology is not even close to being well-defined enough to be able to unambiguously classify it as one thing or another. C++ has strong elements (as seen with overloading) and weak element (as seen with implicit casts). The weak parts are indeed some of the most annoying things about C++, but at least they're fairly well-defined in the standard, so it's *possible* to work with them. Note that I said "strict", not "strong". You're allowed to be confused, but don't go all judgmental on my ass over this distinction. C++ has a type system that allows certain static guarantees. That's the only claim I'm making, and I'm not interested in your drama.
I don't really understand the purpose of it. How is std::cout &lt;&lt; concat(a,b); better than std::cout &lt;&lt; a &lt;&lt; b; ? 
Aren't string literals being added in C++14?
Will this actually work for compile-time metaprogramming? It seems lambdas are used to implement a lot functions, which lambdas are not constexpr-friendly. Plus, it appears the static asserts are runtime asserts.
I guess I didn't actually give any overall feedback. I mostly just liked how comprehensive it was. That sneaky `std::pair&lt;K, V&gt;` copy has been coming up in a few places lately. To my knowledge, the paper proposing `for (x : cont)` as syntactic sugar for `for (auto &amp;&amp;x : cont)` was voted into C++17 at Rapperswil, so I guess there's a bit more to the picture :)
It is probably the most simple example showing general use of this function. It's introduction to more sophisticated features like concatenating on whole vectors (in the next one), or with defined separator.
That only works when you're using a stream. With his library, you can say auto c = concat(a, b); Although you can already do that with [`operator+`](http://en.cppreference.com/w/cpp/string/basic_string/operator%2B): auto c = a + b; A legitimate use-case is variadic concatenation, or some of his non-string overloads.
No, the TS with `string_view` is probably what you mean and it's expected to be published in early 2015. Even then, it only supports reading, not "modifications" like concatenation. Doing a `constexpr` immutable class interface is possible in C++11 to my knowledge, but the implementation would be very ugly. It gets a heck of a lot better in C++14. Unless you mean `operator "" s` for string literals, which is in C++14, but that has nothing to do with compile-time string processing.
I was actually thinking of the second concept. I haven't read up on the new standard/proposals, just had a vague idea of it. You should implement this in D, it has much stronger support for static computations, and no silly "return-statement only" restrictions.
It does work, but constexpr does not have anything to do with it. The problem with constexpr is that even if you are in a constexpr function, you can't use an argument as a constant expression (even if the argument turns out to be a constant expression when you call the function). So the following won't compile: template &lt;typename T&gt; constexpr T assert_positive(T i) { static_assert(i &gt; 0, ""); return i; } int main() { assert_positive(2); } The error given by clang is error: static_assert expression is not an integral constant expression static_assert(i &gt; 0, ""); ^~~~~ However, this is nothing new; it's just equivalent to saying that the return type of a function can't depend on the value of its arguments in C++. Hence, constexpr can't help us with __type level metaprogramming__. To do some real type level metaprogramming, we need to encode the value of the objects into their type (exactly as we do with the MPL). For this, Boost.Hana introduces `int_&lt;...&gt;`, `bool_&lt;...&gt;` and friends which are just objects whose value is encoded in their _type_. Basically, they are equivalent to their MPL counterpart, but they are objects, which makes them usable in Fusion-like containers. They also provide a constexpr conversion operator to their underlying type, but that conversion operator can _always_ be used in a constant expression, so the following works: [EDIT: template &lt;typename T&gt; constexpr T assert_positive(T i) { auto cond = i &gt; int_&lt;0&gt;; static_assert(cond, ""); return i; } int main() { assert_positive(int_&lt;2&gt;); } Using the intermediate `cond` variable is necessary, but I think that's a Clang bug. Also, notice how the comparison is now `i &gt; int_&lt;0&gt;`, which is necessary to conserve the "compile-time"ness of the expression. Specifically, the type of `cond` is not `bool` as you might expect; it is some kind of `std::integer_constant`. END EDIT] This is the core of why it's possible to unify MPL with Fusion. Now, regarding value-level metaprogramming, it won't be possible to use most of Hana in constant expressions until we get constexpr lambdas. It is possible, however, to implement all of Hana without lambdas (or at least a large subset), but the compile-time performance will be much worse. 
The code sample I provided was just an example. As of now I'm writing iterators for a circular buffer and red-black tree. Not sure if reading comprehension is a weakness in this subreddit but I was just hoping to get comments on this specific technique, not about whether to use boost or not. This code isn't meant for production, I'm just exploring different techniques for writing iterators.
After reading all the responses here, I'm going to do the same thing. I have a four-month-old C++ project that would be perfect for this.
Yes, and yes. 
I've just tried to compile the library with Clang 3.4.2 (tags/RELEASE_34/dot2-rc1) and the compiler immediately segfault-ed. https://gist.github.com/mekishizufu/24152ff84648776acfa6
Did you still end up having to work with it? Or did you drop it for a better AMQP broker?
AMQP and XMPP are both ridiculously awful. I didn't use anything which was built for those protocols. Unless you have a specific need to interact with something which talks AMQP on the wire, avoid it. I've built systems on top of RabbitMQ and 0MQ, and they were much simpler to work with. 
Yes, I had heard that. I didn't want to go into details on a feature that could still theoretically change, and explaining that properly would require an explanation of revalue references and reference collapsing, which is certainly the topic of a future episode! I also don't like that the C++17 syntax doesn't let you say const, though that's just a minor gripe.
&gt; Actually, what would be nice, is if the integral constants had operator &gt; overloads, so you could easily compose them like this: &gt; `assert_positive(int_&lt;2&gt; + int_&lt;3&gt;);` &gt; So `int_&lt;2&gt; + int_&lt;3&gt;` would yield `int_&lt;5&gt;` rather than just 5. That is already the case! Actually, I'll talk about this in the quick start since it's fairly important to understand the whole library correctly. I'm still improving the documentation, so there are holes, but thanks for asking this question! &gt; How much worse? It still should be much faster than the current Boost.Fusion &gt; compile-time performance, right? The `list` implementation would look like Fusion's cons list asymptotically, but you would get a large constant speed up because Hana is much lighter. To get an idea of the compile-time differences between various implementations and for various operations, here's a link to the latest benchmarks (ran two nights ago): http://github.com/ldionne/hana/tree/gh-pages/benchmarks I haven't found a nice way to integrate the benchmarks in the documentation yet, but it should be done shortly. &gt; I also understand how some sequences could be implemented using generic &gt; lambdas, which would not allow it to be used in consexpr. However, I don't &gt; see how the library really can unify Fusion and MPL if it can't be used at &gt; compile-time. Well, it can do everything the MPL can do by using heterogeneous containers of `type&lt;...&gt;`s and then using `decltype` to get the result out (see the [quick start](http://ldionne.github.io/hana/index.html#tutorial-quick_start)). Also, it can do everything Fusion can do (and more) by design. So, the rough summary goes like: 1. To do type-level metaprogramming (MPL), use `decltype(expression)::type`, which does not care about `expression` being constexpr or not. 2. To do value-level metaprogramming (Fusion), just use Hana normally. Also, unless I'm mistaken, Fusion does not support constexpr at the moment, so Hana is not really regressing on that point. &gt; Also, I have been working on creating a library(see here) with functional &gt; utilities, similiar to some of yours, but my goal is to make them constexpr &gt; friendly(and C++11 compatible). Its still a work in progress. Thanks for the heads up, I'll have a look! &gt; Also, your emails on the boost mailing lists don't seem to show up when I &gt; use nabble to read them(see here). Is that on purpose? It isn't on purpose. Thanks for letting me know, I'll contact Nabble and see what's wrong. 
Thanks for trying it out! Unfortunately, compilers still have a lot of problems with variable templates, and those are very important for the library. I'll see if there's an easy fix, but I'm not too optimistic.
Well, all the stuff I do with this is in C++14, so it's basically add a `constexpr` to a normal function and you're done. But yeah, I've been meaning to use D for stuff and get to know it a bit better.
Of course, I wasn't expecting you to in this video, particularly when it's labelled C++11.
&gt; The only things I can think of is that "concat" seems to be heavily [snip] I think it's unintuitive- personally I would create a separate function Then it becomes much harder to use it in generic code.
&gt; That is already the case! Ok cool. &gt; The list implementation would look like Fusion's cons list asymptotically, but you would get a large constant speed up because Hana is much lighter. To get an idea of the compile-time differences between various implementations and for various operations, here's a link to the latest benchmarks (ran two nights ago) That is interesting. It looks like `std::tuple` does not scale well at all. Was this tested with libstdc++ or libc++? I wonder if there is a difference as well. Also, how does these test compare to using `mpl::vector`? I believe fusion is using variadiac templates in C++11. &gt; I haven't found a nice way to integrate the benchmarks in the documentation yet, but it should be done shortly. It would be nice to see the benchmarks closer on elements &lt; 50. Since this how I will usually use most of the sequences.(but it is important to see how well the sequences scale.) &gt; To do type-level metaprogramming (MPL), use decltype(expression)::type, which does not care about expression being constexpr or not. Ok I see, by using `decltype` you can get around the `constexpr` problems. &gt; To do value-level metaprogramming (Fusion), just use Hana normally. Also, unless I'm mistaken, Fusion does not support constexpr at the moment, so Hana is not really regressing on that point. Yes, of course, its not a regression for fusion, but it would be really cool to do. Also, will you support adapting structs, like fusion does with some simple macros? 
Good points. concat being overloaded was one of my goals, I wanted to mix different parameter types in a short an concise manner, with a single call. My primary motivation can be resumed like this: if anything is trivially convertible to std::string, just pass it to concat cause it does the work for you. I hope I'm documenting it well in the README.md, but you can tell me better. About the comments, you are right guessing that I'm not fan of comments but I definitely will do it in some places, like in the recursive calls, or in some type traits like "is_basic_type". Thanks for the feedback!
I made a [list of decent video tutorials](http://www.reddit.com/r/cpp/comments/20tfxh/decent_c_youtube_tutorials/).
Strongly agree with your first point. Quoted for emphasis: &gt; the interface should be common across platforms. Otherwise, you'd still have #ifdefs in higher level code (codes calling this class). Is there a particular case why bar() is different with bar(int a) in method 1? You *really don't want* the system differences to leak outside your `#ifdefs`. That is a much bigger problem than the difference between your method 1 and 2 could ever be.
That said, I don't want the videos to become obsolete too quickly! Think I'll definitely want to talk C++14 where appropriate (polymorphic lambdas comes to mind...).
&gt; Which one is better? I would go with a third option: use a [strategy pattern](http://en.wikipedia.org/wiki/Strategy_pattern) to implement the support for each separate platform, and then use a [factory](http://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29) to supply the object for your platform. Example (pseudo-ish code): class FooStrategy { // abstract base class that defines the interface for all foo classes }; class FooPlatformA: public FooStrategy { // platform-specific code for platform_A }; class FooPlatformB: public FooStrategy { // platform-specific code for platform_B }; FooStrategy * FooFactory(void) { #if PLATFORM == A return new FooPlatformB() #elif PLATFORM == B return new FooPlatformB() #endif } Then, with this component, you can run platform-specific code this way: FooStrategy *foo = FooFactory() foo-&gt;do_something_generic() This approach has several advantages: * platform-specific code is stored in separate classes, which helps code review and development * if you need to support a new platform, just add another concrete strategy for it and tweak FooFactory accordingly * the code is cleaner and easier to read and follow through * depending on the case, compilers may be able to optimize away the polymorphism away from this implementation
&gt; As you can see, those times are much faster than their Hana or Fusion counterparts. However, it is possible to achieve the same speedup in Hana by using implementation tricks. Specifically, to understand the implementation tricks I'm referring to, you can take a look at the [type_list implementation](https://github.com/ldionne/hana/blob/master/include/boost/hana/type_list.hpp#L139). Then, you should also take a look at the [variadic foldl implementation](https://github.com/ldionne/hana/blob/master/include/boost/hana/detail/left_folds/variadic.hpp#L63) and finally the [variadic pure-type foldl implementation](https://github.com/ldionne/hana/blob/master/include/boost/hana/detail/left_folds/variadic_meta.hpp). The goal is to never instantiate more variable templates than necessary, so if you give me a list and say "look, this is a list containing types only", I can store it in an efficient way internally. Then, if you give me a function and tell me "this, in fact, is nothing but a metafunction", and then try to fold that list with that function, there's no reason I can't optimize it to use the same pure-type foldl that I did in the MPL11.
yea :/ on the other hand DI should make code loosely coupled and easier to maintain/test, having global states wont help achieving it at all, so not sure if in such case DI would be the best solution tho? IMHO having such approach in mind may set a developers against DI, but like everything, it depends on the project design/scale/needs/etc...
Most interesting! I'm a little surprised not to see fold algorithms yet. Surely this is in your todo list?
&gt;Note that I said "strict", not "strong". You're allowed to be confused, but don't go all judgmental on my ass over this distinction. Well "strong" is a commonly used term when describing type systems and "strict" is not. I kind of assumed you meant strong, since that's what it sounds like. What did you mean by this? In what way is the type system of C++ more strict than that of Ruby besides doing the checks at compile time instead of run-time? &gt;C++ has a type system that allows certain static guarantees. That's the only claim I'm making, and I'm not interested in your drama. *You* asked for feedback in this project. I'm pointing out a mistake in your project rationale statement. If you touted the performance and static checking, I would not have said anything, but the claim you are making is either misleading or wrong. You can feel free to ignore me, but again, you asked for feedback.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Strong and weak typing**](https://en.wikipedia.org/wiki/Strong%20and%20weak%20typing): [](#sfw) --- &gt; &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming), programming languages are often colloquially referred to as __strongly typed__ or __weakly typed__. In general, these terms do not have a precise definition. Rather, they tend to be used by advocates or critics of a given programming language, as a means of explaining why a given language is better or worse than alternatives. &gt; --- ^Interesting: [^Type ^system](https://en.wikipedia.org/wiki/Type_system) ^| [^Weak ^and ^strong ^sustainability](https://en.wikipedia.org/wiki/Weak_and_strong_sustainability) ^| [^DataReader](https://en.wikipedia.org/wiki/DataReader) ^| [^Personal ^pronoun](https://en.wikipedia.org/wiki/Personal_pronoun) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjayvio) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjayvio)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I don't really understand what you mean. The preprocessor will concatenate any adjacent string literals: code like `const char *s = "String1" "String2"` is valid. If you are talking about `std::string` objects, or any object derived from `basic_string`, the operator `+` can concatenate them.
You're going to have to be a little more specific. Are you talking about something like const char *foo = "abc" + "def"; ? That's invalid because both string literals decay to pointers to char and you can't add two pointers, nor can you overload `operator+()` to take two pointers. But why would you want to do that? You could have written const char *foo = "abcdef"; or const char *foo = "abc" "def"; to achieve the same effect, so I don't see why it would ever matter. 
Of course there are fold algorithms, did you check the [Foldable](http://ldionne.github.io/hana/structboost_1_1hana_1_1_foldable.html) type class? `Foldable` contains `foldl`, `foldl1`, `foldr` and `foldr1`. There are also scans, which are closely related, in the [List](http://ldionne.github.io/hana/structboost_1_1hana_1_1_list.html) type class: `scanr`, `scanr1`, `scanl`, `scanl1`. All those folds and scans are equivalent to their Haskell counterparts (if you are familiar with Haskell, you know a lot of Hana), but they are strict.
(Ugh, I made a comment that I realised was better suited as a PM, and I think /u/asimian agrees, but of course autowikibot managed to snap it before I deleted it. Here's for posterity.)
&gt; Specifically, I'd like to know why you did not find the folds; did you search for them and fail to find them? I looked in Reference/Functional, assuming all functional algorithms would be sitting there. I see that you associate folding with data structures containing the items to be folded, while I was expecting something like = [](auto f, auto state, auto ...xs) {...} where the items to be folded are given as variadic args, but this is probably a misunderstanding on my side of the conceptual foundations of the lib. Will keep on studying it. 
&gt; They even use the word "blocking" (I don't like blocking parallel systems). They can do blocking operations but their default API is fully asynchronous (there are futures everywhere, e.g. in the fibonacci go for the `unique_future`). &gt; Regarding the parallel I/O. Does files or sockets support writing in parallel? Maybe on Linux. What one can do is to prepare data in memory in parallel, but than the data must be written to I/O in some order one after another. Yes, they support writing in parallel since hard-drives also support it and you can split a file into multiple hard-drives (either to speed-up I/O or because it doesn't fit inside a single one). The basic idea behind it, is that if you have a file handler to a file of a given size, you just need to tell to each of your parallelism units from where to where inside that file they have to write what (e.g. see hdf5, pnetcdf, ADIOS, SIONlib,... which kind of do this for you).
I wish one could write lambdas inside constexpr functions. Someone should write a paper to relax constexpr functions this way in C++17.
True, and frankly speaking don't see any other/better solution than yours unless Qt refactor is consider as a solution as well.
You can also use a sparse integer set here is an [implementation](https://github.com/discoloda/Diana/blob/master/diana.c#L54-L133) in C. EDIT: I finished reading the article, it was mentioned at the bottom.
Actually, we talked about it at C++Now 2014 and people seemed very favorable. It seems to be little more than an omission. At the very least, I'd like to see compilers support constexpr lambdas with a switch until we fix the language.
The use of assembly makes me tick: how does it report used *inline* functions ? Is not there a risk they are reported as unused ?
Note: as mentioned in the article it is unknown in advance whether the usage will be sparse or not.
Looks good. It would be good to add support for https://www.leapmotion.com/blog/hello-world-meet-autowiring-c which would provide Spring like behavior.
Am I blind or isn't there any example code?
Very nice little tool. It handles std::tuples, but barfs on std::pair, making maps un-concat-able. See my pull request on github (https://github.com/theypsilon/concat/pull/5)
Just wanted to complain about the same thing. Can't find any example code in the repo. This sounds very interesting though, so I'd love to see something.
I'm not extremely familiar with game programming, but I'm genuinely curious why the various SIMD instruction sets might not be appropriate for something like this.
Not really directed at you, but i really don't like people naming their libraries randomly after boost with them having nothing to do with it. Only mentioning it because this is some third one i come by lately. Edit: &gt;The library relies on a full-featured C++14 compiler and standard library, but nothing else is required. I also have a feeling that your library wont be part of boost anytime soon.
Thanks, we're hoping to get some example code up soon.
This comment confuses me: https://github.com/leapmotion/autowiring/blob/develop/autowiring/CoreContext.h#L539 Does your library not allow constructing multiple types at the same time? And I +1 the request for examples exercising some features. Without the examples, I'm thinking the features are similar to other C++ DI libraries and it seems over-engineered in that context.
Not to mention that it's a complicated mess that's way more complicated to debug if something goes wrong. 
I'm not too enamoured with the way it handles foreign keys as I feel it should be possible to statically define them, but this looks very interesting otherwise. Docs are well-written.
Also consider conference videos. A lot of experienced and insight are shared there: http://channel9.msdn.com/Events/GoingNative/2013?sort=status&amp;direction=asc#tab_sortBy_status https://isocpp.org/blog/2014/06/videos-cpp-track-ndc-oslo-2014 
Is this a query builder?
Very nice! I've updated the blog post to point back to this.
It's essentially a high level optimisation, as posted, with the convenience that this will work directly across multiple target platforms. I'm interested in any low level optimisations that can give significant improvements, also.
I'm sorry about this but probably none. If you have previous programming experience go with A Tour of C++, otherwise go with Programming Principles and Practices (both from Bjarne Stroustroup).
Inside constexpr functions you can declare new structs/classes to work around the lack of lambdas support. Since this is basically what the lambdas are doing anyways, I believe (no proof) that these issues should be easy to overcome.
It's merged, thanks a lot for contributing man
Do you have sample CMake code that does all of the above on `make commit`? That would be really cool.
I have single commands for most of the above and use bash to drive the testing but my CMakeLists focus only on the platforms that I use so it is far from generally usable. 
A very incomplete list: * C-Arrays and C-Strings instead of std::string and std::vector as default-containers (basically this point would be enough to throw it into the trash without further looking at it) * goto before loops (!!!); I am not one of those nuts who believe that there is never, ever a use for goto, but it certainly shouldn't be mentioned in a beginners-tutorial. * It considers C++98 as the default and attaches C++11 after that. C++ without qualifiers should always imply the current standard, which is C++11 now and will be C++14 in a few months. * `using namespace std;` - Yeah, Bjarne does it too, but at least he points out that it shouldn't be done in anything nontrivial. * Pointers before the stdlib. I mean: seriously? “Here, take this atomic-bomb. Later on we will tell you what handguns are.” * In general it seems to take a reference-style-approach which is not suitable for teaching. (I learned C++ with bad online tutorials. It took me ages to get the point of things like „const“, because there wasn't really an explanation *why* you would do it.)
&gt; I usually agree with the C++ "minimal overhead" philosophy This never applied to the number of used of libraries / headers. It applied to unnecessary runtime cost (“you don’t pay for what you don’t use”), and as far as I can see this header doesn’t add any non-essential cost, it simply dispatches to existing functions without adding runtime overhead.
Preach it, Brother. 
The benefit is simple. using foo_func = std::string (foo::*)(int const); is easier to read than: typedef std::string (foo::*foo_func)(int const);
That looks hard. How would you name it?
Single header/multiple cpp files work as long as you don't need different private members for different implementation (most likely, you will need it). There's a solution for that too (not sure if you'd consider it ugly, but it works): // Runtime\Foo.h class Foo { // Public interface private: #define _FOO_IMPL #if PLATFORM_WINDOWS #include "Platform\Windows\Foo.h" #elif PLATFORM_MAC #include "Platform/Mac/Foo.h" #else #error "Unknown platform" #endif #undef _FOO_IMPL }; // Platform\Windows\Foo.h #ifndef(_FOO_IMPL) #error "Include Runtime\Foo.h instead." #endif int m_WindowsVariable; // Platform\Windows\Foo.cpp Foo::Foo() { // Windows stuff } // Platform\Mac\Foo.h #ifndef(_FOO_IMPL) #error "Include Runtime\Foo.h instead." #endif float m_MacVariable; // Platform\Mac\Foo.cpp Foo::Foo() { // Mac stuff } Now you could argue, that the public API might get out of sync and then you'll have to go change the other header, but that 
You're not supposed to "Create your app" in it. You're only supposed to use it for .NET/Native interop.
Could you explain how this is different from (or possibly better than) Qt5Sql?
&gt; Is this really faster? Maybe, as I said I did not test it. Note that the OP has moved away from `vector&lt;bool&gt;` to `vector&lt;uint16_t&gt;`. &gt; I remember trying to implement a bit vector myself and getting outperformed by `vector&lt;bool&gt;` by a huge factor.... In this case, I would look into how `vector&lt;bool&gt;` is implemented and implement a compiler specific version that reuse its tricks (but without the fluff) or look how `bitset` is implemented. Note that in this particular circumstance a `bitset` could (maybe) be adapted since `data` has a fixed width. 
This looks like a really impressive effort and so far the C++ syntax to define a query looks very SQL-y, congratz!
Well, SIMD is usually used for mathematical data parallelism, but a lot of the SIMD (x86) instruction sets also have logical bit instructions for working with the XMM, and YMM (ZMM) registers, which could possibly reduce overall memory chatter and reduce unoptimized reset times by an order of magnitude. There's also the fact that the compiler generally uses the SIMD instructions for basic memory operations. It would cost at least a couple SIMD registers, but depending on the max members, it could reduce set, test, clear, and reset all to `O(1)`. It's a bit of wild speculation as to whether there would be any real performance gain though. The code would also generally be a bit more complicated to maintain and possibly use.
Since I've used Qt5Sql as well as libraries like the above (though not the linked library itself), I understand their differences and where you'd want to use each pretty well so I hope it's useful. Qt5Sql is a C++ adapter layer for each database's client library. Rather than using the SQLite API, you create an instance of a QDatabase which uses the SQLite driver/backend (really, just an implementation of some Qt base class) and from there on, your C++ code is generally agnostic of the type of database you're using. You execute queries by calling functions passing your query as strings which are checked at runtime by the backend you're using. The datatypes you can use are generally limited to numbers and strings. There is no concept of aggregation or type-safety. QUINCE is a SQL DSL/ORM in C++. In addition to being agnostic of the database kind like Qt5Sql, you use C++ to write your queries. This means, minus bugs, that your queries are checked at compile-time by the C++ compiler as opposed to checked at runtime by the database engine. Being written in C++ often means you can use aggregation to represent tables and with certain libraries, even implement foreign/parent keys as smart pointers. This also allows you to use your fancy-pants C++ metaprogramming tools which can be beneficial. For instance, a SQL-in-C++ DSL I use occasionally (Wt) allowed me to write generic code to serialize variants to the database. This made me very, very productive as I could just dump any supported types into the variant and still keep it completely type safe. The implementation is below. So to sum it up, Qt5Sql is an abstraction for a database client's API. No type-safety, no type aggregation. SQL DSLs, in addition to abstracting database client APIs, are type-safe and allow you to write C++ code to access the database. One thing I learned early on was to treat the SQL DSL as database code, not as C++ code. It is tempting to pretend that that a decent ORM is just like C++ types that you new and delete yourself, but it's not. template&lt;typename Types&gt; struct VariantLoader { struct LoadNull { template&lt;typename Action, typename V&gt; static void load(Action &amp;, V &amp;, std::string const &amp;, int) {} }; struct LoadImpl { template&lt;typename Action, typename V&gt; static void load(Action &amp; a, V &amp; v, std::string const &amp; name, int target_which) { if(target_which == 0) { typedef typename boost::mpl::front&lt;Types&gt;::type head_type; head_type value; field(a,value,name); v = value; return; } typedef typename boost::mpl::pop_front&lt;Types&gt;::type rest; VariantLoader&lt;rest&gt;::load(a,v,name,target_which-1); } }; template&lt;typename Action, typename V&gt; static void load(Action &amp; a, V &amp; v, std::string const &amp; name, int target_which) { typedef typename boost::mpl::eval_if&lt;boost::mpl::empty&lt;Types&gt;, boost::mpl::identity&lt;LoadNull&gt;, boost::mpl::identity&lt;LoadImpl&gt; &gt;::type typex; typex::load(a,v,name,target_which); } 
The compiler is usually able to translate the basic bit operations into good instructions (even `rol` and `ror`). I'd be curious what the compiler generated for `vector&lt;bool&gt;` that outperformed your code.
Yes I agree, I was more meaning that I find the existing C++ methods of printing and formatting string data a little tedious, one case where the method is annoying (I sometimes wish they'd put a flexible python-esque string/list system, but that would contradict the philosophy of course). This cool header makes things easier. 
Good observation. However, you can't define templates inside of a local class, so I think you can't emulate generic lambdas with that trick.
Get a tether service to allow you consistent internet every night. Curl up in your bunk every night and work through some problems on a site of your choice to get your feet wet. I recommend codecademy if you're new to programming. Then bouncing from Javascript to Java as there are some very good ways to learn most programming concepts through Java. Javascript's lightweight, loosely typed style will be forgiving. Then Java will be stricter. But hey? You wanna learn games right? Minecraft's written in Java. Buy it. Download it. Decompile it and start reading through the source. Google everything you don't know. Go on forums. Come on here. You will cover most concepts you need, and more that experts dont' even know yet. Once you feel froggy you should start looking into writing script for Unreal which is largely C++ and any sort of Source mod that allows you to inject custom script. But by in large, there is no "game programming" there is only programming. This is a bummer, I was told the same thing two years ago when I started. However once you stop trying to run from and just start learning, it's rewarding to know that you'll be there some day. And that no line of code is wasted. Every bit helps. 
Well, making modifications is relatively easy; that relative bit is the elephant in the room. Whether or not your modifications compile, work as expected and are correct is the more difficult part. What OS will you be using? Have you picked and set up your development environment? Do you understand basic OS concepts like processes, memory management, threading, etc? Do you understand the fundamentals of C++? Yeah, that's a loaded question. Do you understand some of the common abstract data types like queue, stack, linked list, heap, etc.? Do you have a particular game engine in mind? Why C++? Before anyone can give you any advice, more information is needed. Your answers to the above questions will substantially alter the advice you'll receive and will lead to even more questions. A degree is just a piece of paper signifying that you've done the work. You'll still need to do the work regardless. It's not easy and it's not always fun, but it is rewarding.
Saying blindly that virtual function calls are an expensive abstraction due to one level of indirection without actually testing it is absurd and flat out wrong. From what I've seen of people actually testing virtual functions vs non-virtual, the difference is O(2%). Doesn't sound expensive to me, and if I'm going to be the user implementing a library for this I'm already taking a hit by not writing the fully specific one-off version that I could do. I'd instead hope the library runs within 5% of what I could write on a good day, and that the library saves me implementation and debugging time so the trade-off is fully worth it. (In the real world, some libraries don't serve this purpose.)
Any particular reason you want to start with source engine? I'd recommend start small scale so you can learn the fundamentals of c++ without taking on top the whole math operations in 3D space problem. Start with the SFML 2.0 or SDL books. I believe both are in c++ and cross platform so you should be able to use the manuals in your OS of choice. They are designed to make 2D games primarily but they should get you up and running at the very least. If you want to get your self a quick intro that's less of a front loaded knowledge issue perhaps try looking at the game dev in python options? The games won't run lightning fast but they run and certainly let you figure out what's up with less of a barrier than c/c++.
You are right, only C++11 lambdas. In stackoverflow people argue that such a feature wasn't important enough. I guess generic lambdas just changed that.
Imo, you really should put a link to the github repo somewhere. Google mshepanski/quince finds only the docu, nothing from github. https://github.com/mshepanski/quince If I wasn't that interested in it, it would have been way to much effort to find it ;)
I know I will sound condescending saying this but, are you sure you want to start with c++? c++ is *hard*. It's pretty low level and you have to deal with a lot of extra crap before you can even begin to do game programming. Ultimately, it depends on if your goal is to make games because you have an interesting game idea you want to manifest or if you want to make games because you want to solve difficult programming problems and develop programming skills that way. If it's the former, I'd recommend starting with Unity or Unreal. For either engine, there's a lot of tutorials. I know that at the very least Unity has good offline documentation that you can download so you don't need to always stay online to do your learning. If it's the latter, that is, you want to solve difficult programming problems to develop a skillset, then c++ is a good language for that. It requires decades to really master it (I know people who've been in the AAA games industry for at least 20 years and they're still learning new things about c++, the compiler, libraries, etc). I don't really have the best advice on how to start learning c++ as I basically did it through formal education and it's somewhat hard to separate what I learned through self-study vs what I learned through school. That said, I'd probably just go on Amazon and grab the top selling c++ books. There's a few kinds of books that'll be useful for you. 1 - learning how to program books. These books focus on the core fundamentals of programming in general. They're not necessarily in c++. They should cover things like loops, recursion, variables, scoping, the instruction stack, etc. 2 - c++ language books. An great example of this is "effective c++" by scott meyers. He goes through a lot of gotchas in c++. As an aside, the stuff he covers in that book are often used in junior-intermediate tech interviews when quizzing for c++ programmers. 3 - c++ reference book. You might even want to buy a copy of the c++ standards book. This is important when you want to know the rules on how something operates. For example, the standard defines things that end up in undefined behaviour. This means it's up to the compiler to handle. You want to avoid writing anything that ends up in undefined behaviour in general. Lastly, don't let yourself get discouraged. One of the best programmers I know never did programming of any kind until after his university degree (which was unrelated to computers). He studied c++ for 1 year solid before getting a job in games and managed to pull it off. Personally, I think he's hard working but also exceptionally talented. If you take a bit longer than 1 year to get the hang of things, don't sweat. It'll come in time.
Just found this page! Thanks for the kind words about my little library. 
Could I add a couple of things? - It isn't restricted to SQL's types: it lets you define your own multi-colum types (C++ classes and tuples), and also to use C++ types like "bool" to hide differences between SQL types in different DBMSes. - It encourages you to compose queries from queries and keep going, so you can write a single query that runs half your business if that is your choice. Of course you can do that in SQL too, but the difference is in how far you can go before the complexity of the code you're writing gets the better of you. --- Michael Shepanski
Unfortunately, there are things you can't do with structs that you can do with a lambda. For example, a lambda can capture a parameter pack, which is handy to implement an [efficient tuple](https://github.com/ldionne/hana/blob/master/include/boost/hana/list/instance.hpp#L52).
From personal experience I would not reccomend STARTING with C++. Nor starting to run recreationally by training for marathons.
Ooooh. I thought "source engine" was just typical newbie misspeak. I hadn't heard of "Source Engine". I'm not in the game industry, but am a C++ programmer with an awareness of the technology in that industry. That being said, the other questions still stand, except for the last two.
So Microsoft ran into this exact problem while trying to modernize old C code that had multiple #ifdef's and macro'd functions that became completely unmaintainable due to the levels of macros a maintainer had to follow. To solve it they used a template solution. See 12:40 of the video where a developer from Microsoft talks about it: http://channel9.msdn.com/events/TechDays/Techdays-2014-the-Netherlands/Modernizing-Legacy-C-Code
Your poor experience doesn't mean that's the way it has to be. I believe I've heard Bjarne has taught C++ as a new language to freshman undergrads and has stated it has gone just fine.
Good chat guys. We'll do it again sometime.
I just finished a long drive (5000+ miles) around the USA, and I know about making games... so I have some ideas for you... I actually think you can do this... You may even have some advantages... when you're stopped at a rest stop, I doubt many people will bother you... so you'll have plenty of alone time! You have a wifi hotspot from your phone right? I think you should start by getting a good grounding in whatever language you're going to be using... don't even try making games for a while... instead concentrate on using your language of choice... Work your way through one of those giant fat books that teach a language from the ground up... understand it ALL... Then, find a book about more advanced usage of the language (if this is C++, I recommend Effective C++) and work your way through all of that... Now, go get yourself one of those giant fat game programming books and learn it all... I really liked "Core Techniques and Algorithms in Game Programming" but it's a little old now... Also, I learned a lot from the OpenGL super bible... and I definitely think you should learn either OpenGL or Direct3D before you dive into an engine... you don't have to become and expert, but it will help you understand your engine...
I agree completely that no discussion of optimization tradeoffs is complete without benchmarking the actual code, but the cost of virtual functions can go beyond simply the relative cost to call them vs. a normal function call. Unless your compiler is smart enough to "de-virtualize" your call by statically analyzing code paths, a virtual call cannot be inlined, and inlining is perhaps the most important mechanism available to a modern C++ compiler to achieve ideal performance. 
Totally agree.
&gt;Read the OPs post they are using the source engine. This has alot of useful utility libraries so what "extra crap" are you talking about? Using the source engine isn't going to suddenly teach you the basics of programming. Further more, going into the source engine without a strong working knowledge of c++ is like going into a mechanics garage without knowing how to change oil. The jump will likely be bewildering that's why I suggest starting with the basics first. &gt;Doesn't this say its not important for a beginners know. This is not even a sentence. I don't understand what you're trying to say here. I was saying c++ is hard to prepare him mentally in case he thinks he can learn it and produce something in a month. It will take a lot longer than that. &gt;Yet you still continue suggestions and books. No kidding. I said that earlier bit to indicate that books were not exclusively the single path I took to learn c++. I still thought he'd appreciate advice on good learning material so I mentioned the books. What advice exactly have you added to this thread aside from throwing in the standard fare "try hard!" nonsense and stating that you worked with the goldsrc engine? Besides that, all you've done is criticize other's advice, offering absolutely nothing constructive in turn.
The best way for self study is to go through books. You could also try and work your way through internet tutorials, but in my experience, finding good tutorials for c++ is hard, even for an experienced programmer. A lot of the tutorials on the web are outdated, teach bad styles or have horrible mistakes in them. The best list of books that Ive come accross so far is here: https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list That page (stackoverflow.com) will become your best friend for all programming related questions. It's a huge community, they are friendly, fast and polite. Use their search for every question you have (google searches will usually direct you there anyways). **Dont be discouraged** by those that you shouldnt start by learning c++. It is not necessarily a beginner friendly language, but it is not Klingon. On top of that, if game programming is what you are looking for (specifically for relatively modern 3D engines), getting the required level of performance from any other language would be a challenge I would not advise any beginner to tackle. You got a long road ahead of you. I wish you all the best. Source: Am a self-studied C++ programmer. Edit: Clarification &amp; Formatting
In particular, Programming: Principles and Practice Using C++ is an introduction to programming using C++. The second edition was released recently and uses new C++11/14 features. That book is probably the best bet if you want to learn programming with C++ as your introductory language.
Every database has a slightly different SQL. For instance, the paging is different in MS SQL, MySQL, and DB2 (if I remember correctly). How do you handle such SQL's specifics?
You have it right
Great! Thanks for the feedback.
Great, thanks. And funny username you have there!
I like this method, however you have to find some way to fix your iterator traits. When this gets passed into an algorithm that dispatches based on an iterator tag, things might get weird, because the value type in the std::iterator you inherit from and the value type within your definition would be conflicting if you are using _iterator&lt;true&gt;.
I released it 8 months ago. It has been improved since then.
&gt; I hate the M$ tutorials http://www.penny-arcade.com/comic/2002/07/22/m
Isn't the proprietary software just an implementation of an open standard? Or do I misunderstand the relationship between Connext and DDS?
&gt; I hate the M$ tutorials because they're too bulky and too much extra info Then you should skim them rather than reading them in their entirety. One of the annoying things about online formats is it is impossible to accurately judge the retention and baseline knowledge of the user. Nearly every tutorial assumes a small baseline knowledge to help as many people as possible.
You are right, Connext DDS is an implementation of the OMG DDS standard.
Does the example compile with OpenDDS? http://www.opendds.org/
ehh... for example, codecademy.com is amazing compared to the official documentation, but alas, no Visual C++. Other guides online I run across seem to be outdated and not very synchronized for use with Visual Studio. It'd be nice to find such a magical guide.. there are some incredible C# guides out there, but (Visual) C++.. 
Do the string-format arguments' types are checked at compile-type?
did you look at %g?
Oh that's perfect! I assumed the scientific notation would be longer. Thanks
I agree, that title makes more sense in the context of the blog where it's posted. I should've used "Create A P2P Distributed Application In Under 35 Lines of C++11 Code with Data Distribution Service"
 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;sstream&gt; std::ostream&amp; print (std::ostream&amp; os, double d) { std::ostringstream ss; ss &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; d; auto s = ss.str(); auto e = s.find_last_not_of('0'); s.resize (e + ((s[e] == '.') ? 0 : 1)); os &lt;&lt; s &lt;&lt; std::endl; return os; } alternatively, since to_string() is supposed to be the same as printf()'s %f, which in turn defaults to 6 decimal places: #include &lt;iostream&gt; #include &lt;string&gt; std::ostream&amp; print (std::ostream&amp; os, double d) { auto s = std::to_string(d); auto e = s.find_last_not_of('0'); s.resize (e + ((s[e] == '.') ? 0 : 1)); os &lt;&lt; s &lt;&lt; std::endl; return os; } int main() { print (std::cout, 1 / 7.0); print (std::cout, 1 / 4.0); print (std::cout, 4 / 2.0); print (std::cout, 1000042000000); } [Demo](http://ideone.com/nUU852) 
They are with GCC / clang See https://github.com/gpakosz/Assert/blob/master/src/pempek_assert.h#L391
If you use c++/cli to access .net from c++, then your c++ code no longer is standard c++.
No. The point is not to port WinMain, the point is to not to have WinMain in the first place so as that the code is portable by default. Technically, what reason existed that Microsoft introduced WinMain instead of main(); none whatsoever. It was only there to make porting code from Windows as difficult as possible. And I agree on your comment about Microsoft's c++ compiler, my list was not exhaustive, of course. 
All of it? No, it's not. However, the application will be written in standard C++, and will contain only a few C++/CLI classes IF you need to access .NET. I can't see why it's a deal breaker for you - sure, it will not run on linux, but either will code that deals with COM, or that uses DirectX.
This library could really benefit from variadic templates for better type safety. The source is full of old style variadics which are inherently unsafe. 
godlike requirements, goatlike pay. @ 25-60 bucks an hour with those skills you're basically working for free. Code looks pretty good with C++11 and ASIO.
I've started a video series recently..... [https://www.youtube.com/playlist?list=PLHadbgEqCTxDFv20HyT9ubmyQne3CUrSO](https://www.youtube.com/playlist?list=PLHadbgEqCTxDFv20HyT9ubmyQne3CUrSO) Should have the next few up in the next few days...
Ideal summer job for interns looking to pick up experience, good luck finding experienced pros.
&gt; The source is full of old style variadics which are inherently unsafe. Which makes it work with non C++11 compilers. Or e.g. with Visual Studio 2010 and 2012 which don't support variadic templates (see http://msdn.microsoft.com/en-us/library/hh567368.aspx). About variadic templates, I'm well aware of Andrei Alexandrescu GoingNative2012 talk (http://ecn.channel9.msdn.com/events/GoingNative12/GN12VariadicTemplatesAreFunadic.pdf) where he introduces `check_printf()` and `normalizeArg()`. I'm not sure *in this context* it's worth adding much more code just to have an exception being thrown an runtime when there's a mismatch between the format string and the arguments. What could be maybe useful is a custom implementation of `printf` that supports printing arbitrary classes (provided the user implements `operator &lt;&lt;()` or defines a `ppk_print()` function, ala Google Test's `PrintTo()`). But in my mind, `PPK_ASSERT` is made to print concise messages giving a clue about what's going on. The next logical step when an assertion fires is to debug the program in which case you have full access to the whole program context. 
We are discussing things Microsoft did to discourage porting of Windows software to other platforms. 
Because I may have a 2nd interview in the next month with Acer and they use Visual C++ with Visual Studio. If I'm to learn C++ in a month, I want it to look and feel familiar since I have very little time.
Why don't you look for some simple ones? :)
Or just use pimpl.
Was a very good keynote, recommend watching it! And funny how they manage to misspell his name in the title :D
Can I ask what is your objective with this project? I have my own open source project with a db access layer https://www.myinvestcom.us/engine/docs/Database.html where I chose a slightly different approach. What if we merge our projects to develop more sophisticated solution?
 auto i = get_next_int(); Meanwhile: double get_next_int() { return get_next_float(); } I think that's the most common complaint. Auto is very useful though, specifically when it comes to template heavy programs
You could use shared_ptr but at some cost. Specifically for linked structures shared_ptr is costly.
There isn't "much code" to be implemented compared to the amount you already have. A type-safe printf implementation is incredibly easy to implement, just drop the type from the format string and you have a sane 12-line implementation. Since you don't want to support C++11 then this conversation is pretty moot. I'd stay away from C++ libraries that use old style variadics anyway. 
You shouldn't underestimate the value of type safety. It's what C++ was built on according to Bjarne.
Germans speaking english...horrible
Like all features it has its place. Everything gets abused in some way. Auto should never be used for basic types. I only use it for templated iterators or when the type is already on the same line.
In the past I've used Lua with [luabind](https://github.com/luabind/luabind). Unfortunately development seems to have slowed down quite a bit. [ChaiScript](http://chaiscript.com/) seems nice, but I have no real experience with it.
Python, no contest. [Cython](http://docs.cython.org/src/userguide/wrapping_CPlusPlus.html) is an insanely great tool to create C++ bindings.
Yeah it is pretty good - but oftentimes it's good to have 2 or 3 options. I like python but having options helps with success of convincing others. You would think that bjarne would think about creating a scripting language to work easily with c++ as uptake in the compiled language would skyrocket. It's nice to have a repl and explore an objects method's and data. 
Lua. Runs fast.
Perl, server-side. Javascript in GUI apps. Perl is ... not ideal for embedding. I'm in the process of migrating to Luajit. Edit: Luajit, not Lua. The language is much the same, but Luajit has a lot of things that make embedding it simpler and faster.
On windows I like using the active scripting engine -- even works with the Microsoft debugger. Can provide your own top level objects or access via window.external if hosting in a browser. 
Lua is very popular in games, which is a common usage for C++.
Ive been using Tcl for work. Its not my favorite, but its what I use. I've also used Lua in the past for some pet projects.
Pawn too
www.youtube.com/user/BoQianTheProgrammer is great, but he stopped doing the videos... still you you can learn a lot from existing ones and they are not outdated
Creating my own game API from scratch; going with either Lua or Ruby, but I'll probably end up using Lua.
What do you use for JS / GUI stuff?
Stand up for your values! [Runtime-Compiled C++]! [Runtime-Compiled C++]:http://runtimecompiledcplusplus.blogspot.fr/ 
nothing wrong with naming it boostX(perimental)... but anyways I have never really saw need for MPL, Fusion or Hana. Are there some good use cases explained for beginners like me somewhere on the internets ? 
Ok we've got some example code up, it's in the "examples" subdirectory. Please let me know what you think, we'll try to add some more.
For those interested in simply using C++ in an iterative fashion (i.e. with runtime compilation) I've added a list of alternatives to the RCC++ wiki: https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus/wiki/Alternatives
Sandboxable Python won't ever happen, but I don't have problem with it. The long history of Java sandboxing clusterfuck taught me that there's only one truly secure way: os-level sandboxing. It's language agnostic (C++, yay) and guaranteed by the kernel.
No love for [squirrel](http://www.squirrel-lang.org/)?
Lua is god
Python via [Boost::Python](http://www.boost.org/doc/libs/1_55_0/libs/python/doc/) or JavaScript via [QtScript](http://qt-project.org/doc/qt-5/qtscript-index.html). Lua seems to be quite popular (especially in games, also used in Adobe Lightroom) but I've not tried it myself.
It's used by sourcemod too, though it's practically become a new language with the amount of changes they've made to it
Have you tried [lua.org](http://www.lua.org)?
I would avoid embedding ruby. You can only make calls into the C api from the main thread, it installs it's own crash handler, and it has it own memory manger which screws with tools like valgrind.
Excel. It is the perfect complement to C++. Use https://xll.codeplex.com to make it easy to call. Why waste time with command line scripts when you can have all the power of Excel behind your C++ code. It even lets you embed objects in Excel in a type safe way that understands single inheritance.
OK thanks, please post an update to reddit when your wiki is ready!
Of course, if you say you are a beginner, then you are probably not exactly the target audience libraries like MPL, Fusion and Hana. From my experience, these libraries are especially useful for people writing generic libraries. Still, you might be interested in the [MPL tutorial](http://www.boost.org/doc/libs/1_55_0/libs/mpl/doc/tutorial/tutorial-metafunctions.html) if you haven't read it.
[Qt](https://qt-project.org). I'm using the "new" engine, [QJSEngine](http://qt-project.org/doc/qt-5/qtqml-module.html), and while it's lacking some features it's perfectly usable for scripting; it's also the basis for QML, which is the JSON+JavaScript GUI environment - I'm not using QML now, but might in the future. The "old" engine, [QScriptEngine](http://qt-project.org/doc/qt-5/qtscript-index.html), has a bunch of useful features, including a debugger, but it's not going to be developed further.
How does this compare to clang static analysis?
Changed to LUA from Python. If speed isn't important and you need a lot of functionality than Python may be okey. LUA is better for scripting, use that if it holds what you need
Worked with Pawn ~3 years. It is like heavily castrated C but with sandboxing and JIT. Would never recommend it, until you are masochist, or your engine is so dysfunctional, that you should create whole abstraction layer around it with scripting language, thus can't afford slow languages like Lua. Btw nowadays I am unsure if Pawn is reasonably faster than Lua. Pawn seems stall, and there are no big gamedevs backing it.
With ModAssert you can do MOD_ASSERT_P(min &lt;&lt; max &lt;&lt; v, v&gt;min &amp;&amp; v&lt;max); which will output something like condition "v&gt;min &amp;&amp; v&lt;max" failed min: 3 max: 10 v: 11 It can also do anything PPK_ASSERT does, except static assertions, but that is actually an entirely different thing.
 At 33rd minute of the video,there is a slide with an entry that speaks of N3637.I looked it up and there seem to be controversy surrounding async() and a bit of goggling and i came across this link[1] that i found to be very useful in shedding the light on the problem. How was the problem not known in advance? [1] http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3780.pdf
My general experience with CppCheck is that it produces a giant pile of false-positives and has some checks for utterly irrelevant things, but it has found enough actual problems not found by more accurate static checkers to be worth continuing to use it. Clang's static analyzer has a much better false-positive rate (the substantial majority of problems it's found in code I've analyzed has either been real problems or terrible code that's very likely to have bugs lurking in it, even if it's not the one clang pointed out), so I recommend starting with it and other high-accuracy checkers such as Coverity (for open-source and high-budget projects).
This release does specifically mention false positives, so perhaps the situation is better now
There's probably a lot of good information here but it's really hard to take home anything useful because the presentation is poor. Some constructive criticism for next time: there's too much side banter with people in the audience that we can't hear. It's very hard to follow any of that unless they're given microphones -- which you wouldn't do because it's just banter (so don't banter, do a Q+A instead). The slides for the first 45 minutes are the same bullet points about C++14 that I can find on any website, so reading them for his thoughts aren't there. I'd really like to hear more about what Michael has to say but it would have to be more formally and logically presented than this is. The last portion about literals is better but still suffers from these same issues.
Certainly
Its fixed a couple I reported. Unfortunately it appears that the old bug tracker (Trac) has stopped working.
From the paper: &gt; There is nothing wrong with the existing async() and std::future feature except that some frameworks “misuse” std::futures in a non-conforming way and want to this misuse to become valid code. Fair enough, blocking `std::future` is part of the specifications. Yes, one should conform with specifications. However, standardisation doesn't make the feature in question automatically exempt or immune from defects. Inconsistent behaviour of any library feature with serious consequences should be regarded as a design flaw and should be addressed. I do agree with the author that deprecating `async` without a suitable replacement is not ideal. Perhaps a solution is to take advantage of `async` launch policy parameter, and have a new bit to specify that it should return a `future` as non-blocking.
dat laugh
Ahh indeed, that's another cool feature of C++11! I'm not sure if it's substantial enough for a full episode, but I've been thinking about covering several small features like this in a single episode. What do you think of that?
Thanks for mentioning your library. I just had a quick look and well my first impression is that it's really heavyweight. When I started `PPK_ASSERT`, one of the goals was to have something easily dropped into an existing codebase/build. Which means 2 files at most. Another thing I immediately didn't like is the choice of `(min &lt;&lt; max &lt;&lt; v, ...)`. If I really had to use a stream syntax, I think I would prefer what Google Test does: let the user write `ASSERT(v&gt;min &amp;&amp; v&lt;max) &lt;&lt; min &lt;&lt; max &lt;&lt; v;`. That said, I'll try to give it a deeper look later.
i went to ur history and seems someone went and downvoted all ur stuff lol, i upvoted some hahaha, wtf i hope u not persecuted by gov hahaha
Looks like file "D:\programy\visual studio 2013\VC\include\new" got corrupted somehow.
The debugger seems to be talking about a file called "new, and not the main.cpp file you have opened. You might want to see if you can find that file. All the errors and line numbers do not match up with your program shown here.
guys, really really thanks for help, now i am trying to fix this. last question: what do you guys think about VS 2013? i am noob in C++ so most of utilities that this IDE gives me means nothing for me
It's a cumbersome piece of shit, with absurdly large project files, a confusing build process and shitty auto-completion. But hey, I might just be jaded from developing in a windows environment.
It almost looks like it's trying to compile source.cpp as C instead of C++. Check the properties for that file. You can override the defaults there. Just a thought. 
That's true. On the one hand, it makes sense for features which are so intuitive that they don't require an explanation (the best example of that would be nullptr). However, I don't want to distract too much from the central feature of the episode. In the case of non-static member initialisers, I feel at least a sentence or two is required (but a more satisfactory explanation features examples and gotchas). That said, I try to introduce features which are often used in the context of the central one, with justification (e.g. auto in the range-based for loops episode, and "= delete" in this episode). It's a good suggestion though, and I will try and incorporate this philosophy in future videos. (I must confess I hadn't thought of using non-static member initialisers when making this video, but will now look for opportunities to use it where it makes sense in later episodes)
Does it use html for rendering? Also, which js engine? v8? Thanks for replying :)
[QML](http://qmlbook.org) will feel comfortable to someone coming from a web development environment, but it's not HTML. Rather it's a rendering engine designed for UI (particularly appliance and mobile UI). The engine is V8 based right now, but the API is intended not to be leaky so that it won't be tied to using V8 forever. There is also an embedded webkit if you need full HTML/CSS/Javascript support, and other lightweight HTML+CSS subset rendering engines.
qtcreator, eclipse, sublime
Well, that was probably the quickest decision I've ever made to purchase something.
Welp, I paid full price for Effective Modern C++ not more than a month ago...
You're basically saying you're frustrated and think you deserve a post-mortem discount, amirite?
Just kidding. Jokes aside, is it a good book? Would you recommend it?
Come on, it's Meyers dude.
Linking to [the release notes](http://www.visualstudio.com/news/2014-aug-4-vs) would've been a better submission target than the front page of visualstudio.com, in my opinion.
Beyond 'Effective Modern C++', can anybody give any critiques on the other C++ books on the site? I'm pretty new to C++ and picked up the 3-pack of Scott's books a little while ago(about halfway through 'Effective STL') so I know that I will like this book as well and will add it to the queue. Should I pick up any of these others while they're on sale(not Visual C++ as I'm on a Mac)?
lol wut
Do they dispatch to the UK?
Out of curiosity: wouldn't it be more efficient to just call std::set::insert in traversal_context::cover, i.e. bool cover( void const * what ) { auto result = traversing.insert( what ); return result.second; } 
Looks good but cannot currently compile our codebase: https://connect.microsoft.com/VisualStudio/feedbackdetail/view/938122/list-initialization-inside-member-initializer-list-or-non-static-data-member-initializer-is-not-implemented
Almost, it has to be return !result.second; Thank you, I've updated the code.
Well, without a performance test I wouldn't know if it's faster. However, `unordered_set` is the more correct choice, so I've updated the code. My use of `set` is just habit, since `unordered_set` wasn't always available in C++.
Thanks, looks nice. How you're doing this: AutoRequired&lt;MyBasicThread&gt; myBasic; AutoCurrentContext ctxt; ctxt-&gt;Initiate(); // myBasic-&gt;Run() starts now in its own thread Do the `CoreThread` and `BasicThread` have a static data structure? Or how does the `AutoCurrentContext` class know which threads are there to run?
Or just linking to the VC blog announcement: http://blogs.msdn.com/b/vcblog/archive/2014/08/04/bugs-fixed-in-visual-studio-2013-update-3.aspx
I can only speak very highly of Boost python, it's a great library.
I suppose you could take the implementation of the two make_unique functions and use preprocessor directives to check for the compiler version. From what I can tell: * g++ 4.8.2 (libstdc++) doesn't have make_unique * Visual C++ 2010 and 2012 don't have make_unique * IIRC, Visual C++ 2013 and 14 CTP have it libc++ (written by the clang developers) has it, but I'm not sure since when -- and you might need to pass -std=c++1y to clang++. For Visual Studio, check out _MSC_VER: http://msdn.microsoft.com/en-us/library/b0084kay.aspx For libstdc++ check out defines like GLIBCXX_3.4.19 on https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html For libc++ there's _LIBCPP_VERSION: http://sourceforge.net/p/predef/wiki/Libraries/
libc++ can be used on linux as well. 
It can be, but it's not officially supported (yet) and it's not what you get if you install clang from your distro's package manager, which is how the vast majority of people are going to install clang. 
I guess I shouldn't have been too lazy to report that when I ran into it with the RC :(
In addition the issues already raised, gcc-4.3 doesn't even support auto (let alone move semantics). You might want to restrict yourself to a more realistic set of target compilers *"for simplicity"*.
Using old compilers is one of the most corrosive practices in this industry - I strongly recommend targeting the latest version of each compiler. (I know how to implement make_unique with 2012's and even 2010's faux variadic preprocessor macros - but I have sworn never to touch them again.)
For some reason, the OP quotes the pthread documentation to support his thesis that this is all somebody else's fault but then fails to read the very next paragraph: &gt; The application needs to recheck the predicate on any return because it cannot be sure there is another thread waiting on the thread to handle the signal, and if there is not then the signal is lost. The burden is on the application to check the predicate. ... and wouldn't ya know it, his code fails to check any predicate after waking from wait(). Moral of story: condition variables != predicates
A condvar wait belongs in a loop (unless you push a predicate function into the wait itself). Every condvar can have false-wakeups. And the extra mutex lock and unlock is an unexpected cost for users who do it right. And if the notifying thread drops its mutex lock before performing its Notify (which is acceptable), it only pushes the race condition aside a few clock cycles.
I couldn't agree more. People's reluctance to just stay up to date on compilers is very much based on old style assumptions that are mostly neither relevant nor that big of a problem in the first place. If a piece of software is reliant on compiler errors and misbehaviour, you have a problem that should be fixed instead of parking your compiler version forever.
1. It looks nothing like java.util streams. 2. It's awesome (partly because of 1.)
With the advent of hash tables, it's a pity this is not extended to cover `hash`, because now we can easily get a defaulted `==` and a manually implemented `hash`... and I'll bet they'll derive from each others. The approach I would recommend, instead, is to use a single method that determines what the *key* part of the object is, and returns a tuple of references/copies for it (aka, `std::tie` trick) and then builds the operators around this since tuples implement lexicographical comparison anyway: std::tuple&lt;...&gt; key() const&amp; { return std::tie(...); } and then `hash` is trivial to implement, and uses the same basis as `==`.
Ubuntu has libc++ In it's repos and libc++ works very well on Linux. I wouldn't be too concerned with the support statement.
I guess, after a certain point in your c++ career, you don't learn much new about C++ while reading what other people have to write about it in books. And if you're like me -- I followed the C++11 standardization process quite closely and even answered some of Scott's questions about rvalue references and lambda expressions in the comp.lang.c++ a couple of years ago -- a C++11 book won't surprize you anymore.
Sometimes the best way to support $OLD_COMPILER is to say "here is at tarball and a shell script to run. Run it. Now you have $NEW_COMPILER available in that new directory over there, which will be used to compile this code ..." But there are times during a project when changing compilers is a very very bad idea. There are embedded system vendors that lag compiler versions by years. Combining those two effects, it is not unreasonable to find projects in advanced development stages that are shackled to GCC 4.3 ... painful and unfortunate, yes, but not unreasonable ;) If you really do have to write code that works properly on older compilers, I suggest that you stay within the four corners of whatever language spec *all* the compilers support, because maintaining $OLD_STYLE code alone is probably easier than both $OLD_STYLE and $NEW_STYLE and all the build guff that goes along with detecting when to use each. 
I agree with you, old compilers suck. The interesting thing is that the compilers most people use on Linux/Mac are mostly bleeding-edge. Maybe due to ABI stability and open-sourceness (if the ABI breaks you can recompile everything yourself and keep going). On Windows the ABI breaks every year and you cannot really tell people "please _pay_ for a new version of windows and _pay_ for a new version of VS so that I can link against your non-opensource library". So IMO the corrosive practice in this industry is that some _platforms_ force their developers to use old compilers. I don't think people use them because its fun. And I don't think that making life harder for your developers is a good platform business plan either... but hey, seems to work.
This is all your fault!
Why do you specifically want to "starting tinkering with char"? Why would you specifically want to "work with if statements"? Most of the time, people want to learn how to build a shed or become more familiar with woodworking. They don't just decide they want to start tinkering with levels and screws. I'd start with a basic C++ "Hello World" program (google it).
Ty very much kind sir and sorry for any problems :D
It's possible to fake it in earlier versions of MSVC with variadic macros. See http://herbsutter.com/gotw/_102/#comment-6428 for example.
You are often constrained by integration with other products. For example, Python extensions on Windows have to be compiled with the same compiler as the Python executable. You want to work with existing Python installations so that means using Visual C++ 2008 for Python 2.7 extensions or Visual C++ 2010 for Python 3.4 extensions. It is possible to use C/C++ code built with other compiler versions but not as Python extensions. Instead another approach such as COM or low-level FFI is used. Such uses can't easily achieve the same quality of integration. Python could be changed to avoid depending on a particular Visual C++ release but that would be a significant amount of work. It appears to require switching from direct use of C runtime features in both executable and extensions to providing equivalent features from the Python executable for use by extensions.
The code does not fail to check the predicate after waking from wait(). It actually does so. (that would be the d-&gt;wakeups ) The article is about an implementation of QWaitCondition, which have a different API of the one POSIX has. In particular, QWaitCondition protects against spurious wakeup. And this article is about wether QWaitCondition should also solve the race on the return value of wait(). We're trying to see if there is a benefit trying to make developers life easier. As an analogy, I take your comment as if you said to the people proposing smart pointes: “The documentation clearly say you need to release your allocated memory, so you don't need smart pointers that does it for you” 
Well, that went over my head quickly. And that's from someone (me) that writes 3d programs in C++ for a living.
What you're talking about is not the predicate. The canonical condition variable usage pattern looks like this: Producer: mtx.lock(); &lt;set predicate condition&gt;; cv.signal(); mtx.unlock(); Consumer: mtx.lock(); while ( !&lt;predicate condition&gt; ) cv.wait(mtx); &lt;predicated logic&gt;; mtx.unlock(); Note the `while` loop. If the client code follows this pattern, none of these changes you're proposing are necessary. That there is a timeout possibility does not change the fact that you should check the predicate before continuing. This is how you write _safe_ synchronization code. Further, this statement from the article: &gt; We don't want that the Thread 3 steal the signal from the Thread 1. Assuming the consumer threads are homogeneous (and if they aren't, what are they?), I can't comprehend why it might matter that one thread can "steal" another threads signal.
I reported it last week that VS 14 CTP 2 had this problem, but someone from msft told that they knew about this, that they had just forgot to mention it on the release notes. He further said that VS 2013 update 3 would include this same compiler, and that he would make sure to mention it on the release notes for that. Now, it seems that did not happen, no mention on the release notes this time again. I also told that I thought it was strange that update 3 would include such a breaking change, and I asked if we would also get the option to select the previous compiler, but I got no reply. See [msdn blog post](http://blogs.msdn.com/b/visualstudio/archive/2014/07/08/visual-studio-14-ctp-2-available.aspx) My first question was on July 27, got an answer on Jul 28, and my last post was on Jul 30. 
So will VS 2014 finally support all of C++11? 
To go back to the smart pointer analogy, the cannonical usage of new is to do delete afterwards. And if all the developers follow this logic, you never need to add something like unique_ptr. QWaitCondition protects against spurious. That makes the developer life easier so it does not need to check the predicate condition. &gt; Assuming the consumer threads are homogeneous (and if they aren't, what are they?), You never know how users of QWaitCondition uses it. This particular case was caught by the unit tests. But it's totally possible that they are not homogeneous. 
&gt; He further said that VS 2013 update 3 would include this same compiler VS 2013 (RTM and all Updates) and VS 14's compilers have different major versions (18.00 versus 19.00). Bugfixes checked into VS 14 are sometimes backported to 2013 Updates, but features aren't. In this case, VS 14 was changed to emit a "not yet implemented" error (which is, however surprisingly, an improvement over the earlier behavior which sometimes produced silent bad codegen), and that change was backported to VS 2013 Update 3. It might seem like a regression in functionality, but it didn't really work in the first place.
By themselves, initializer lists are fine. (Well, there was a severe bug with temporaries in initializer lists, but that was fixed in 2013 Update 2.) The problem, which we discovered after shipping 2013, was that the interaction between initializer lists and NSDMIs was broken. The compiler team decided that the problems were too severe to attempt to fix in an Update (where fixes have to be really surgical, in order to avoid destabilizing anything else), so they blocked it with a compiler error. Now they have VS 14's product cycle to develop a comprehensive fix. As I understand it, very simple interactions between init lists and NSDMIs did appear to work, but increasingly complicated code would lead to silent bad codegen. SBC is frightening enough that it's worth blocking the whole area with a compiler error, even if that breaks code that apparently worked before. It's not an ideal situation, but that's the real world.
14 is a version number, not a year - RTM is planned for 2015. (Talking about future plans is above my pay grade; I can refer you to Herb's presentations about VC's roadmap for C++11/14.)
It just seems very frustrating to me that visual studio puts in large elaborate features but lags way behind in supporting the full standard of a language.
I see, thanks for the heads up. Was it too complicated to disable list initialization support only on NSDMI context? I guess this way it would have been only a small inconvenience. For me I guess the least troublesome course of action is to stick with the older version and avoid that combination.
Well uh, my suboptimal real world response to the decision to disable initializer lists in NSDMIs is to just not install Update 3 any time soon, as it'd require changing a lot of code for no apparent benefit.
Depends on the compiler. It's pretty convenient/easy with GCC to upgrade your compiler because GCC maintains binary compatibility for the better part of a decade. So you can often just plug in the newest compiler and work as if nothing happened. On the other hand, Microsoft makes it very hard to target their newest compiler because every year they break compatibility, or they change their build system, or they make some kind of change that basically makes it hard to adopt their new C++ compiler. This means you plug in the newest compiler and half your dependencies don't work anymore. The Windows ecosystem also isn't as open as the Linux ecosystem, so often times Windows dependencies are shipped in binary only form. This also becomes a nuisance when you want to use C or C++ to write components that plug in to other applications because you need to use the version of MSVC that was used to build that third party application. So basically, unlike Java or .NET where there is some deep notion of backwards compatibility, C++ doesn't have that notion and instead it's up to compiler vendors to try to make life easier for developers to upgrade their compiler. GCC, clang, and even Intel make an effort to do this, but MSVC makes no such effort, and so if you have to use MSVC you're often stuck having to stick to using an older compiler.
Sorry, my description was incomplete (that's what I get for working from memory instead of looking at the bug details). Braced-init-lists were broken with both NSDMIs and mem-init-lists (it's really the same codepath in the compiler), which are the cases that now emit compiler errors. (My memory condensed "NSDMIs and mem-init-lists" to "NSDMIs".) I really recommend upgrading to Update 3.
Be aware that you're asking the compiler to generate code where the compiler devs have determined that the compiler's logic is completely busted, and may silently generate code that misbehaves at runtime. Avoiding that would be beneficial.
Okay, I will consider upgrading. It's not as straightforward because I am using combinations of init-lists and variadic templates. I guess the main issue was the lapse in communication. Those changes should at the very least be mentioned in the changelog / notes. It would be even better to get early warning on these emergency changes, so that at least we can stop adding more soon-to-be-broken code.
What?
unrelated note: please don't get into the habit of `using namespace std`
If this edition of C++ For Dummies lives up to its namesake, it probably doesn't deserve to be on the same page as a book by Scott Meyers.
+1 - Changed the way I think about C++ and design
Or to enable ADL, limit "using namespace std" to function scope.
OP on SO here. Same comment here as there: `nth_element` does not sort *within* its two subranges, only *between* them. In that sense, it is similar to `partition` which separates on a predicate. Both are `O(N)`. It would be cheating if I had used `partial_sort` followed by a recursive step.
This is the first release since November of last year, and also the first since Boost migrated to git and a modularized structure for development purposes. From an end-user perspective, hopefully nothing has changed; the layout of the archive is the same as always. Get it at [sourceforge](http://sourceforge.net/projects/boost/files/boost/1.56.0).
Well, so far I didn't run into that problem, but its nice to know that Qt fails here. But there is a solution (or hack to be honest): http://stackoverflow.com/questions/2668519/qnetworkaccessmanager-timeout
Just trying to build my source against it now, my asio code is not compiling very cleanly :( Lots of size_t to int warnings which were not there before. Edit: It seems the change in behavior has been induced by vs2013 update 3 and the new boost, sigh...
`operator&lt;()` and its ilk could be defined the same as way (`return lhs.key() &lt; rhs.key()`). I really like this solution! But it probably needs a name other than `key` to work. Perhaps `operator keyof()`?
&gt;vs2013 update 3 I follow the boost mailing list, honestly 90% of the time when there's an issue involving building boost, it has to do with some bug or shitty issue with MSVC. I sometimes wonder if Microsoft is even aware that boost is a major library among C++ users and that it's a major pain in the ass that MSVC consistently has bugs or non-standard behavior that causes boost to fail to build. I mean seriously... check out BOOST_WORKAROUND macros and the lengths that boost developers have to go to to get boost to build with MSVC.
this seems very promising - one benefit languages get from a GC is that functional programming works a lot nicer. Piping streams of data is much easier if you don't need to worry about your filter() function's temporary return value becoming invalidated before it's used. The approach in this video is to say 'just copy the data!' and then rely on rvalue operations to ensure that no matter how long the chain of operations is, it is only copied that first time (when it goes from being an lvalue to an rvalue) The 'writable ranges' looks very pythonic as well. These mechanisms could go a long way to making C++ a _lot_ more succinct when dealing with streams of data
That was one of Dave Abrahams's projects, so it's probably dead.
So a bug in an older version of GCC is the non-ideological reason to avoid "using namespace std"? If you militantly avoid C++ features because of rare and obscure bugs found in older compilers, I got some bad news for you.
L
Ll
Ll
I'm not quite sure what you're trying to achieve...
Guess, I'l have to try myself :D
Wouldn't be such an issue if we continue to get updates; I am optimistic that ms is heading in this direction. 
No, that was just one example. The main argument behind it is because you're completely defeating the point of having namespaces. But do whatever you want to do - it's your code, not mine. If you're even remotely open to reading about opposing views, spend some time reading the below links. http://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice http://stackoverflow.com/questions/4872373/why-is-including-using-namespace-into-a-header-file-a-bad-idea-in-c http://www.lonecpluspluscoder.com/2012/09/i-dont-want-to-see-another-using-namespace-xxx-in-a-header-file-ever-again/ http://stackoverflow.com/questions/14575799/using-namespace-std-in-a-header-file http://ubuntuforums.org/showthread.php?t=595176 http://programmers.stackexchange.com/questions/236404/what-is-using-namespace-pollution http://www.cplusplus.com/forum/beginner/109940/ http://bytes.com/topic/c/answers/503672-should-using-namespace-std-used http://www.gamedev.net/topic/210541-using-namespace-std-error/
Please, just avoid `using namespace &lt;namespace&gt;` altogether.
It featured in [this Stackoverflow Q&amp;A](http://stackoverflow.com/q/25176985/819272) yesterday. It is legal, but I'd avoid in lieu of the other two alternatives.
This is usually the best answer to all those questions, though there are a handfull of exceptions for namespaces that were meant to be used like std::literals: int main() { using namespace std::literals; auto str = "foobar"s; // str is std::string }
Care to share the warning? (Curious)
Hah! And I thought I was the only one!
I had been liking the 1st option best myself and had been using it for a while but then I hit a compiler error with I used template specialization. Here is a small code sample: #pragma once #include &lt;iostream&gt; using namespace std; namespace SomeNamespace { template&lt;typename T&gt; void Function(T) { cout &lt;&lt; "Function(T)" &lt;&lt; endl; } } And the corresponding source file: #include "TheHeaderFile.h" using namespace SomeNamespace; template&lt;&gt; void Function(double) { cout &lt;&lt; "Function(double)" &lt;&lt; endl; } I get an error message: error C2912: explicit specialization; 'void Function(double)' is not a specialization of a function template
I can only guess this was me falling asleep whilst redditing with reddit sync on my phone last night. Oops
I know what `nth_element` does. I've used it to build kD-trees in arrays. I just don think you can call this "quick sort" because a real quick sort's partition step works differently in that it cannot guarantee its split element to land exactly in the middle. So, what nth_element does is more than a quick sort partition. It's a quick sort partition that is recursed into the subranges that contain the nth element.
I understand that the Internet is full of flame wars over trivial "bike shed" issues, so spamming a whole bunch of links to such ideological positions doesn't really provide any insight over why a completely off-topic remark such as "please don't get into the habit of using namespace std" was appropriate or helpful to this discussion. If you develop in C++, understand that there are some people who do import namespaces to avoid the syntactic noise that often comes along with them, and there some people who don't import them, to avoid name clashes. It's okay to be in either camp and it's not necessary to pollute a completely unrelated discussion with some remark about which camp you belong to.
What happened to Dave Abraham? Edit: ah, sucked into the black hole of Apple.
He shut down BoostPro and joined Apple around a year ago. He appears to now be working on Swift (based on that he presented on generic programming in Swift at WWDC).
Ok, I think I see your point. However, `nth_element` doesn't cheat on the complexity, but rather on the iterator requirements. Whereas `std::partition` only needs forward iterators, `nth_element` requires random acess iterators. The answer in fact already admitted to this. The "does more" lies in the fact that it not just *finds* the median (which also can be done in linear time for forward iterators), it also *partitions* the inpout range around the median. I presented it this way because the fancy randomized pivot selection is less pedagogical, IMO.
QT sure know how to engineer ugly interfaces to their code. :/
Right back at you
I used the "using namespace SomeNamespace" in the source file; not the header. I interpret the failure for that code to work in the C++ standard in §14.7.3/2 where it states: *An explicit specialization shall be declared in a namespace enclosing the specialized template.* It might be a tad different story to what you are asking but the situation is very similar.
There was a blog post I read by a friend/colleague of his basically talking about disappointment with C++ among long time contributors and people moving on to work on other languages. In Abraham's case he moved to work on Swift at Apple. The jist of the post was that it's kind of a bad decision that C++ became an open standard, because pretty much anyone can become a part of it and the committee ends up arguing over trivial things which causes enormous delays. Abraham's proposed certain features, such as auto, way back in 2001-2002 only to have to wait 10 years before it saw the light of day. For smart, creative people, they're basically better off investing their time and effort else where.
So does this mean /u/stl will release an updated MinGW distro with 4.9.1 as well? :) I remember reading he was waiting for Boost 1.56.0 to be released before releasing a new build. Edit: /u/stl is **awesome**. http://nuwen.net/mingw.html :D
I could care less about naming, I am way too bad at it ;)
"couldn't care less"
On Windows, there's NuGet, though you'll have to use Powershell and the CoApp tools. Once you get up the learning curve, it's pretty simple and effective.
I fully agree doing a few local: namespace &lt;abbreviation&gt; = &lt;long namespace&gt;; really helps readability without pulling in entire namespaces possibly causing problems over time.
Second style all the way, plus indentation within that namespace{} block. This way, you can immediately tell which symbols are in the global :: space, and which ones are inside ::html.
FYI, `"#pragma once` makes sense only in header files, not in source files. Seeing that directive in the code up there made everyone assume it was code from a header file.
I guess I don't quite understand the point of this... This argument holds equally for `ostream &lt;&lt; i` -- we've arbitrarily assigned a certain meaning to a binary operation that otherwise has no mathematical intuition. Is this wrong? What is the advantage is gained by disallowing it? He mentions the problem presented by `optional&lt;T&gt;` but the original case study for this is IEEE-754 NaNs -- NaNs fail all comparisons (including NaN==NaN). See explanation here: http://stackoverflow.com/a/1573715/583604 So his argument for a mathematical basis is already on shaky ground.
Generally speaking, "using namespace xyz" in a header file has a bad code smell. You can get away with ::std most of the time, since it's so common. But once you start having namespace collisions due to "using" peppered all over your app's headers, it can cause problems. You also wind up forwarding this problem to other people if you're building a library for others to consume. You're better off being explicit in the header w/o using clauses, and then follow up with using foo::BarClass, in the source file. Edit: I'm assuming a header file since you have "#pragma once" at the top.
It's a bit strange to define an "exceeds" function that way. It doesn't read well. "Greater than" is a synonym of exceeds. For exceeds(x, threshold), I'd expect to see "x &gt; threshold"; i.e., x exceeds threshold. I don't think the problem is the use of the operator, but rather its use is hidden; i.e., there isn't an explicit contract. [Concepts](http://en.wikipedia.org/wiki/Concepts_\(C%2B%2B\)) would alleviate the issue.
Two things, all in the socket_ops.ipp file. 1) "C4996: 'WSASocketA': Use WSASocketW()" this can be turned off by defining _WINSOCK_DEPRECATED_NO_WARNINGS. 2) "C4267: 'argument' : conversion from 'size_t' to 'int'" for a calls to WideCharToMultiByte and strlen. The return value of strlen is a size_t which is assigned to an int. The second one, size_t length is passed to inet_ntop, this is then passed into WideCharToMultiByte as the 6th argument, which is an int. So 1) just looks like MS API stuff, 2) seems to be valid.
I submitted [a link][old_link] to this library a while ago and got a positive response. Since then, I have added several new features, and adopted the Sphinx documentation system that I saw in [MNMLSTC core][mnmlstc]. One of the new features that I added is support for [attributes in format strings][format]. I don't like having to memorize new DSL's when I use APIs. While Boost.Format is much nicer to use than IOStreams, the DSL for the format strings and the syntax for applying arguments still generate a lot of "line noise", and are not very intuitive to use (IMO). I wanted to strike a balance between conciseness and legibility that's closer to the "legibility" side of the spectrum, so I came up with this syntax. One of the benefit of this new syntax is that it's extensible, and so I've added attributes that allow you to print currency in various locales, human readable data sizes (e.g. KiB, KB, etc.), as well as almost all of the features supported by Boost.Format. **Note:** I posted this link earlier but deleted it soon after because I discovered some last-minute problems with GCC that I wanted to work around first. [Apparently][gcc_issue], standard streams *still* don't have move constructors in libstdc++. [format]: http://adityaramesh.com/ccbase/format.html [old_link]: http://www.reddit.com/r/cpp/comments/1vr968/fast_directory_iteration_without_static_library/ [mnmlstc]: https://github.com/mnmlstc/core [gcc_issue]: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54316
Option 2 has the problem, that you will not get a compiler error if you "declare" a new function with your definition (aka make a type error/...). Option 3 only allows previous declared versions and will result in an error if you misstype something.
On comparing pointers from different objects: I believe the presentation is incorrect about this being UB. The behavior is just unspecified. The standard reads: &gt; If two pointers p and q of the same type point to different objects that are not members of the same object or elements of the same array or to different functions, or if only one of them is null, the results of p&lt;q, p&gt;q, p&lt;=q, and p&gt;=q are unspecified. So an implementation is free to specify that pointers have a total order, as most do today. --- Negating INT_MIN is only undefined behavior because of the arithmetic issue: since the result can't be represented by a two's-complement int, it's UB on implementations that use two's-complement. But on an implementation that uses a signed-magnitude representation for ints then negating INT_MIN is perfectly well defined. --- The discussion of UB with regard to uninitialized variables involves an example where a bool is in fact default initialized rather than uninitialized, so any UB that occurs is due to a different reason. (I believe I've heard that this may be changing in an upcoming spec, that they might just make it UB to access an indeterminant value or something like that.) For a bool, default initialization means "no initialization is performed" which means the bool has an indeterminant value. Indeterminant values can be perfectly valid to access, but they can also be trap values (specified in C++ only by reference to the C spec, I believe). This is sort of interesting because if the indeterminant value happens to be one that is legal to access then no UB occurs, but there's no standard way to detect this. If the program was: int main() { bool b; if (is_trap_representation(b)) { puts("other"); return 0; } if (b) puts("true"); if (!b) puts("false"); } where the `is_trap_representation(b)` call was well specified to correctly detect trap representations then the code program would be perfectly well behaved and would output exactly one of "other", "true", or "false". Also since UB is based on the behavior of the virtual machine rather than the actual machine an implementation is allowed to behave as though the indeterminant value is a trap representation even if the real machine does not have any trap representations for that type! Such an optimizer would be free to change the above program to simply `puts("other");`. --- I don't think there's any time when you would want to insert undefined behavior, but you can insert expressions that are defined only under certain circumstances in order to give the compiler optimizer hints. See http://blog.regehr.org/archives/1096 
If an object has operator&lt;() it has a well-defined ordering. If it doesn't, you can consider it to not to have one. And, um, that's it. Using it for string lexicographical ordering isn't an abuse, and I can't imagine it actually confusing anyone unless they get confused a *lot*. (Whether containers that internally require an ordering should be able to work with types that don't have a well-defined ordering is a good question - but I'm unclear on what it would mean to have an ordered container full of things that don't have a well-defined ordering, so hiding a "No, we really mean *this* comparator function" that's not operator&lt;() seems like it'd add confusion rather than reduce it).
Yeah, though nobody is actually using it. [I hope with C++17 we will all just use the explicitly defaulted versions that the compiler creates:](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4114.htm) struct foo { int x; std::string y; default: ==, !=, &lt;, &lt;=, &gt;, &gt;=; };
I think “&lt;” is quite a bad example for operator-abuse: As /u/lluad pointed out it implies a strict-weak-ordering and it is very intuitive what this means for both real or integral numbers (smaller/bigger) and containers (lexicographical order) but not at all for complex numbers, so this is almost exactly what one would expect and very simple to teach to novices. There is however another operator that is IMHO seriously abused: + There doesn't exist a sane homomorphism between adding numbers and concatenating containers and elements. Concatenation also heavily changes some sematics: auto res1 = a + b; auto res2 = b + a; assert(res1 == res2); This works perfectly fine for numbers (let's ignore floating-point for a second, since those errors aren't conceptual), but it will blow up like hell for any concatenation where "" != a != b != "". IMO there should really have been a dedicated concat-operator so that + keeps it's semantics. (This is one of the things that D got right!)
Yes, the pointer comparison behaviour is unspecified AFAIK. I think the misconception could have sprouted from the fact that this is undefined behaviour in C. Anyway, regarding `bool b;`: - In the C++11 standard, there is an example with `int x = x;` that says `x` is initialized with its own indeterminate value. In C++14, this example has now become `unsigned char x = x;`. The difference is that this is actually well-defined for `unsigned char`, but not `int`. You can read more about the change [here](http://stackoverflow.com/questions/23415661/has-c-standard-changed-with-respect-to-the-use-of-indeterminate-values-and-und). - As seen in that Q&amp;A, while C is much more lenient, C++ is not. Prior to C++14, there is a rule stating that necessitating an lvalue-to-rvalue conversion for an uninitialized variable is undefined behaviour. C++14 takes this and spells it out more to allow the above point and a few others, and be more explicit overall.
I've been working on distro 12.0 this week, and will be ready to release this weekend.
Nice library :) CCBase has a dependency on Boost, so why would one use this set of APIs over the APIs already provided in Boost itself? I understand that you don't like the syntax of the boost format... but with the exception of the platform and dynamic modules, Boost already provides the functionality of the Format, Filesystem, Error, and Unit Test modules: http://www.boost.org/doc/libs/1_56_0/libs/format/ http://www.boost.org/doc/libs/1_56_0/libs/filesystem/doc/index.htm http://www.boost.org/doc/libs/1_56_0/libs/optional/doc/html/index.html http://www.boost.org/doc/libs/1_56_0/libs/test/doc/html/index.html Most of which will be added to the C++ STD library in the near future too.
Very interesting. I wrote something very similar just for fun myself: https://github.com/panzi/formatstring My lib uses Python inspired format strings. I mainly wrote it to learn some of the new C++ 14 constructs, so it might not be designed that well (feedback is welcome). I only tested on GCC 4.8.3. In that context I have an question: Is there a way to only define a certain class if a certain std header was included? E.g. I define certain default formatters for some std classes (like std::vector etc.), which requires me to include the appropriate headers. If those classes aren't used, parsing these headers is unnecessary work for the compiler.
Boost.Filesystem is actually quite cumbersome to use for iterating files. Compare the range-for loop in my documentation to [this SO answer][so_answer]. Boost certainly has more features, but I think it's much easier to do the most common task (iterating over the files in a directory) using this library. Because Boost.Filesystem has a static library dependency, you can't generally use Boost with a compiler other than the one that was used to compile Boost. My library works using the raw system calls, so it doesn't have this limitation. I've had painful issues related to this in the past, which is what led me to write the filesystem module. Boost doesn't have an implementation of `expected&lt;T&gt;`. The unit testing module is more for my own personal use. It integrates more easily into my build system and workflow, and I like the syntax more than that of Boost's unit test framework. [so_answer]: http://stackoverflow.com/questions/67273/how-do-you-iterate-through-every-file-directory-recursively-in-standard-c
Generally what's done in this case is to include separate functionality in different headers and allow the user to include additional headers as needed. Is the extra include overhead actually making a noticeable difference in your build time though? I would suggest forward declaring the containers if all you need is a reference, but this is undefined behavior.
Another question: Using `constexpr` and `static_assert` one could actually validate the format string at compile time (check whether all the flags and the number of formats match the types and numbers of arguments). Did you add such a feature? I didn't in my library because writing such `constexpr` is a major pain and duplicates the format string parsing in the header. And you cant generate a compiled format that way (no dynamic memory allocation, of course - that would be needed for the list of format specs), you can only check the format string, so you would have to duplicate the code in any case. And you and I both use variadic templates, so there will at least be a runtime error instead of a vulnerability if the format string does not match the arguments.
I run into this problem myself. You can fix it like that: template&lt;&gt; void SomeNamespace::Function(double) { cout &lt;&lt; "Function(double)" &lt;&lt; endl; } But yeah, kinda defeats the purpose of `using namespace SomeNamespace`.
Have to try that.