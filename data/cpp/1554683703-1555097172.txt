I think there's a better way to respond to someone when they're reporting a crash, even if it is something they could have read in the docs. 
This discussion is about float vs int performance, not how an entire program performs.
Is there any reason why a GUI would end up needing to transitively include OpenSSL?
Autotools is so annoying that you can hire monkeys to build files randomly and it will work better.
According to [cppreference](https://en.cppreference.com/w/cpp/compiler_support) GCC doesn't support [Parallel Algorithms](https://wg21.link/P0024R2), [pL1 cache line size getters](https://wg21.link/P0154R1), and only has partial support for [charconv](https://wg21.link/P0067R5). If that is out of date, you should update it (I know Intel donated their parallel library to GCC, but I don't think it is released yet).
&gt; In the meantime python developers just go ´pypi install whatever-the-hell-I-want` no matter platform. Not sure in what world you are living, but Python is full of issues and only a few packages "just work". Everything Neural Networks related is a fuming pile of shit that you better install through docker to make it work correctly.
Does anyone know how effective this is vs trying to build out really high levels of line and branch coverage? For example SQLite has famously high levels of branch coverage, I believe 100%. For a test suite like that you would think this should find nothing.
*screeches about gtkmm documentation and the gnome foundation for 20 minutes*
I've briefly have done research, but this project to me is ideal for it can do mocks without interface (require c++17); can somebody recommend other unit test framework which can mock by reflections? I'm just about to start a new project and this caught my eyes, I'll definitely keep looking for others (ie write few tests against ones I discover to get the feel of how natural it fits the flow while coding) and make my own conclusions, but I (as well as this project) can probably benefit from people who's worked on similar frameworks...
I use boost.multiprecision. It wraps a few libraries, provides it's own implementations of various things, and had been used in production for a few years now, with many subtle bugs removed.
Your blog is great, filled with short, practical examples. It’s in my feed reader and I’ve learned a lot about using the libraries you cover.
Thanks! I checked it out. I am seeking a single header file lib which could be easily integrated into current project. My aim is to use it to evaluate the numerical errors of my algorithms. 
SDL will give you a window, and it handles input device and windowing system events. SDL1 (if I'm remembering correctly) gives you access to a bitmap buffer. In SDL2, there's some kind of renderer that I think you can draw directly to, but that's slow; I get the impression that it's doing individual graphics API (OpenGL or D3D) calls for that. Mostly, you'd allocate one or more buffers for image data, do your drawing into those, create a texture for each, and copy the texture to the renderer.
Does it work without GMP? The last time I looked at it, it was a wrapper for GMP (among other options). 
Is this just x86? It works fine on my ARM32 system. 
Some have mentioned boost multiprecision. What you want specifically is cpp\_bin\_float [https://www.boost.org/doc/libs/1\_69\_0/libs/multiprecision/doc/html/boost\_multiprecision/tut/floats/cpp\_bin\_float.html](https://www.boost.org/doc/libs/1_69_0/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/cpp_bin_float.html) From the documentation: &amp;#x200B; \&gt; The cpp\_bin\_float back-end is used in conjunction with number: It acts as an entirely C++ (header only and dependency free) floating-point number type that is a drop-in replacement for the native C++ floating-point types, but with much greater precision. &amp;#x200B; &amp;#x200B;
Didn't know about L1 cache line size getters, but I'm pretty sure gcc has parallel algorithms in the experimental namespace
Not really. Not yet, at least. Both implementations and compiler support are pretty limited by how new they are in that regard.
In that case, you should also look at interval arithmetic like [boost::numeric::interval](https://www.boost.org/doc/libs/1_69_0/libs/numeric/interval/doc/interval.htm). Tracking the upper and lower bound of a calculation is often more useful than comparing a result to a more precise one.
While this is the first time I've seen this, if the mocking functionality is really as easy as shown in the example, this would be a godsend.
I recommend using conan for your dependencies, it makes all these sort of problems go away ;)
Which is not an implementation of the C++17 standard parallel algorithms.
Rip
&gt; But in my experience the bottleneck is flushing the backing store Yes, but this is what was changed from Qt 5.10, by avoiding some bottleneck at the OS level. I don't remember the details, but it was at least a 2x or 3x time speed up.
I have exactly the same setup as you (sfml/mmorpg/c++17) and it's not painfull at all... Maybe you over react a little bit ? A simple demo that's easy to use c++/Conan/cmake : https://github.com/Milerius/nephtys 
What is so difficul about copying a single folder into your project
It's both.
&gt; If outside code cares about members, you should be using a struct and mutating it with free functions. I think the question is about the private member functions.
At some point I was facing this 'problem' and since cmake is all the rage, I decided to try and do this simple task with cmake. After some hours and no progress, I reverted to simple xcopy (Windows), which copies folder trees as well with some switches. That took altogether 1 minute, just to check the proper switches, job done.
If those are member functions, there is no point in passing the member variables explicitly. If you want to pass the variables explicitly, there is no point in making those functions member functions and you should write the functionality as free functions instead. 
Exactly. That's why I wonder why a header only library is supposed to be more difficult to integrate than a single header library. In both cases you just have to copy a file/ folder and add the proper include path.
Very interesting approach. I have done something similar in the past (not rasterizer, but image processing) by utilizing template meta-programming to fuse multiple stages into a single one. The template approach requires we know what stages we are going to use at compile time, which is usually true, but occasionally when I needed more flexibility I had to write a runtime dispatcher and select a pre-instantiated pipeline. The template approach However has the advantage of being very generic. I could very easily put together a prototype of the algorithm with scalar code, then replace the stages one by one with SIMD code. This also makes it easy to port to other architectures.
&gt; C-style callbacks and lambda functions AFAIK, that's not guaranteed to work. You'd need to somehow declare the lambda `extern "C"`.
With the greatest respect that's not exactly a complex usage of build systems, for codeblocks I have 12 different build configurations for the server, and 12 for the client which all do a variety of different things across different compilers. Some of them are for debugging in either testing or deploying a debug build to prod, some are for profiling (in testing and prod), some are compiled under clang, most are GCC, and at least one is ZAPCC. Some are instrumented with address sanitisers, and at least 1 is a linux cross compilation target (that didn't pan out) There's precompiled headers in there as well, which is extremely easy to do in codeblocks (right click, properties, compile file bam you get your .gch) The only code I wrote to do that entire thing was 1 batch file that copies files to a shared network drive (dead simple), 1 that copies across the client executable to the server in the test environment (dead simple), and 1 that automagically pulls in submodules (pretty straightforward) It was actively easy to do this in codeblocks. Every time I want a new config its trivial to configure a compiler, or set build directories, or run scripts or copy an old config or whatever With cmake you have to write a bunch of code. if (${CMAKE_SOURCE_DIR} STREQUAL ${CMAKE_BINARY_DIR}) message(FATAL_ERROR "Prevented in-tree build. Please create a build directory outside of the source code and call cmake from there") endif () just seems totally unnecessary to me $&lt;$&lt;AND:$&lt;CONFIG:Release&gt;,$&lt;CXX_COMPILER_ID:Clang&gt;&gt;:-O2 -march=native -Wall -Wextra -Wfatal-errors&gt; is just gross. Where's the discoverability of compiler flags? $&lt;$&lt;AND:$&lt;CONFIG:Debug&gt;,$&lt;CXX_COMPILER_ID:MSVC&gt;&gt;:/Zi /FS /DEBUG /Od /MP /MDd /Oy- /W4 /permissive- /std:c++latest&gt; What do any of these do? What does any of it mean? It turns the build system into a total black box which makes the barrier to entry unnecessarily high. Typos go from impossible to the norm Now bear in mind that codeblocks is **not** good. But check out these compiler flags and stuff, look how nice it is to work with: https://media.giphy.com/media/UojDAJQd6lBajAsqDJ/giphy.gif With equivalents for clang and MSVC. If you want to do know what a flag is, its probably in there by default. Anything 'surprising' goes into other flags, which means that there's a clear separation between stuff you can basically ignore (common flags), and stuff that's specific to that build (uncommon flags). This is super neat. Where do you think based on that gif you'd go to add new linker settings? Or scriptable elements to the build system, or defines, custom makefiles, etc etc etc Cmake seems like such a step backwards in terms of usability compared to something that's 10 years old and really dreadful. In terms of how powerful it is - sure, its absolutely better in that sense, I suspect you couldn't manage everything that you need to do for chrome in codeblocks, and my projects are only ~50-100K lines of code in total
Still applies. If outside code cares about internal, hidden details, you're doing it wrong.
Yes, C++ is common (though not as common as C) in embedded development for the microprocessors in appliances and more. Embedded development has its own large community.
&gt; Is the washing machine written in c++? Or the microwave oven? The car radio? Potentially yes, but only in the computers in those devices. Many appliances and other electronic devices have computers in them. C++ is an option for programming those, but C or assembly language is probably more common, especially in the simpler devices. Simpler and older devices might have electronic control without having an actual processor.
Sure, but his/her outside code doesn't care about internals, so what's the point. 
Yes, C++ can be found everywhere. However, C is more common on embedded devices, C++ is still used and finds its way into a lot of things.
Probably not in general: [https://github.com/johnmcfarlane/cnl/commit/4394c9f3f9](https://github.com/johnmcfarlane/cnl/commit/4394c9f3f95d4899504d20eb1da527173225d288) But maybe if you know your values are always in a certain range like \[0, 1\].
I plan to actually support sanitizer too in my clang build, I think I will have something like 10 different configurations for the mmorpg, I think CMake is boilerplate but really complete in my sense , if Conan can support other build system like bake or build2 I will probably switch but this is not the case right now
&gt; I‘d really like it to be obvious which variables are changed from the siganture of these methods. implies that users of the class need some kind of awareness of internal details (members that are mutated).
&gt; I‘d really like it to be obvious which variables are changed from the siganture of these methods. implies that users of the class need some kind of awareness of internal details (members that are mutated). EDIT: Oh, I didn't see what this is a private method doing the calls. Maybe make static methods that you pass references to the members to?
There are fixed point implementations all over the internet. For example this one: https://www.codeproject.com/Articles/37636/Fixed-Point-Class
why header only? isn't it preferable to have code you don't need to recompile
&gt;The code must be built with optimizations disabled and full debug information
Not portably, no – from C++17 \[complex.numbers\]/2: &gt; The effect of instantiating the template `complex` for any type other than `float`, `double`, or `long double` is unspecified.
C++14 { "name", "john"s } C++11 { "name", std::string("john") }
**Company:** [Bloomberg LP](https://www.bloomberg.com/careers/technology/engineering) **Type:** [Full time, part time, internship, contract, etc.] **Description:** [We are building](https://www.techatbloomberg.com/) the world’s most trusted information network for financial professionals. Since this is r/cpp, I expect most people looking here will be interested in C++ specifically. If you are a strong Software Engineer with a background in other areas but you want to learn and work more with C++, we'd love to hear from you. We value your experience, proactiveness, and problem solving abilities - we have C++ training classes available once you get here. **Location:** Primarily New York and London, but also Frankfurt, Hong Kong, Tel Aviv, ... **Remote:** No **Visa Sponsorship:** Yes **Technologies:** It's a large company, so pretty much anything and everything is used somewhere. C++ has always been our primary backend language, and most new code is compiling as C++14 and running on Linux. We of course have older projects around, running C++03 on other UNIX flavours - if this is important to you, it's worth asking the particular team about their migration efforts. **Contact:** I'm an Engineering team leader, and I'm very happy to answer any questions about my experience in the comments or PM. To contact a member of our recruitment team, e.g. for help finding the most suitable position or for questions about the process, please email [Jen - jcarberry7@bloomberg.net](mailto://jcarberry7@bloomberg.net) for NYC/SF, or [Kelly - kdonald1@bloomberg.net](mailto://kdonald1@bloomberg.net) for London/Frankfurt (put "Reddit" in the subject line). Alternatively, [search and apply through our website](https://careers.bloomberg.com/job/search?fd=Engineering&amp;qf=c%2B%2B). I've linked a couple of hot jobs below, but there are many more on the careers site. * [Software Engineering Technical Trainer](https://careers.bloomberg.com/job/detail/74099) - London * [Senior Software Engineer - C++](https://careers.bloomberg.com/job/detail/74061) (multiple teams hiring) - Frankfurt * [Senior C++ Engineer - Communications Applications](https://careers.bloomberg.com/job/detail/74108) - New York ----- I'd also like to highlight the [philanthropic work Bloomberg does](https://www.bloomberg.org/), and actively encourages employees to get involved in, which for me personally is a very satisfying reason to work here over some other big companies. ----- You can find some of what we do on [GitHub](https://github.com/bloomberg), and [see](https://www.youtube.com/watch?v=xWmdcvTedbc) [some](https://www.youtube.com/watch?v=ovxNM865WaU) of our [C++](https://www.youtube.com/watch?v=GehO6LPu4qA) [experts](https://www.youtube.com/watch?v=EglLjioQ9x0) on [YouTube](https://www.youtube.com/watch?v=FLbXjNrAjbc&amp;t=2679s) and [contributing to proposals](https://www.google.com/search?q=bloomberg.net+site%3Ahttp%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2F) for the language standard. ----- If you are at [ACCU](https://conference.accu.org/) this week, come and chat to us at our stand, or see some of us talking: * [Higher-order functions and `function_ref`](https://conference.accu.org/2019/sessions.html#XHigherorderfunctionsandfunction_ref) * [How C++20 Can Simplify `std::tuple`](https://conference.accu.org/2019/sessions.html#XHowC20CanSimplifystdtuple) * [#Hashing](https://conference.accu.org/2019/sessions.html#XHashing) * [CPU optimized data structures - more fun with assembler](https://conference.accu.org/2019/sessions.html#XCPUoptimizeddatastructuresmorefunwithassembler) * [Allocator-Aware Software](https://conference.accu.org/2019/sessions.html#XAllocatorAwareAASoftware) 
I mentioned that in my very first comment. It was improved by removing [color space conversion](https://github.com/qt/qtbase/commit/4250993c4280b80f472af77efa6cf77410b383c1#diff-ba96706b8b7506e18739503d2666759d). Even with this it is still slower than Windows.
\&gt; I would like to add my own dead project This brings back some memories. We've used Vaca for a Win32 GUI of a small project few years ago. It was abandoned even back then. We end up internally forking it and fixing some bugs down the way, but the result wasn't bad. It was very lean and as far as winapi wrappers go, I have to say that Vaca was very, very sane and nice to work with :)
And this: https://github.com/fahickman/r128 "128 bits has sufficient range and precision to cover the diameter of the observable universe accurate to within the width of one hydrogen atom, or to track the lifetime of the universe accurate to the time it takes a photon to travel the width of that same hydrogen atom. This is probably sufficient for most applications to obviate the need for an arbitrary-precision library."
`using var_t = std::variant&lt;std::string, int, bool&gt;;` `class object : public var_t` `{` `public:` `using var_t::var_t;` `object(const char* t) : var_t{std::string{t}} {}` `};`
Python developers use the pytest mainly. Pytest and gtest don't require test classes compared to your framework
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Your problem is that someone comes along and destroys your arguments and you are too pathetic to admit it. That's why you keep this debate open on about me instead of my arguments. If you had any arguments, you'd have already put them forward. Apparently, you have none. 
SDL 2 supports multiple windows (fullscreen or otherwise). While it is frequently used for games, it isn't limited to it. It's just meant to provide basic abstractions over creating windows, rendering to the screen, audio and input device access, etc. I suggested SDL because you said it would be good to have a library that handles windows and events, which is exactly what SDL does. The landscape is changing. For example, on Linux, Wayland is being pushed as the next display architecture and that requires special handling when opening a window. Some new apps might want to use Vulkan to do rendering, and that's pretty new too. What about new gamepads, etc. It's changing too fast to be put into a C++ standard that only gets refreshed every 3 years. This isn't like networking, where a lot of concepts and data structures are the same between platforms and are relatively stable.
The measures pertaining to the *universe* change in that statement far two many times. 
Good for you, internet nobody, for destroying my argument. Now run off, so convinced that your way is the only way, despite countless times being told your homework is just a Google search away. But well done you for destroying arguments. Because easily verifiable fact is trumped by arguments that destroy. Destroying arguments is so important.
As i think, if you use c++, you can control your machine resources. Because is more clear than c# or java. C is more clear than c++ but you should do many work by yourself. It is more complex and more expensive.
I'd say the important part is the one you skipped to discuss: &gt; Individual classes are rarely a good logical unit of maintenance and distribution. This doesn't tell you to *never* put classes into their own files, it tells you to not do that on principle. Now consider for example the filesystem-lib: Would you really like to put `std::filesystem::directory_iterator`, `std::filesystem::directory_entry` and `std::filesystem::recursive_directory_iterator` into different files? They really are part of the same logical groups of operations and as such splitting them of only has disadvantages. This one-file-per-class idea is of course enforced in Java with its interpretation of OOP, where it's also stupid, but in C++ it really doesn't reflect well how stuff should be used.
&gt; in terms of complexity control and to future maintainability you can refactor that. i think your concern makes sense for a program that has &gt;100kloc, but if you build such a large program, you are way beyond needing coding guidelines anyway.
Yes, that's a very important part, I agree. I should have written more :) In general I, and I think also many other developers, don't like to see huge header files, and to include something I don't really need. In the case of the filesystem, or similar cases, I'm not against to have a single header that includes all the ones you usually use for that. The only problem I see with the approach I suggest is just the possibly slower compilation time due to the I/O overhead of loading more files. The approach I suggest however should have less overhead from another points of view (less dependencies), so maybe the things are balanced. I just see it more scalable and tidier. As I said, I'm not suggesting the Java approach. I'm just saying that if you have classes A, B and they and A is used by class C and D, and B by C and E, they should preferably go in different headers. Suppose class A needs 20 headers and B only 2, why E should (indirectly) need to include those 20 headers ?
I don't agree with that. The bigger the code base is the more you need to enforce code guidelines or ways to manage complexity
I think the rule is just to counteract the habit of putting every single class into a separate source file. You can't stuff all the advice related to how to best organize your program into one guideline. &gt;Place each class declaration in its own source file if you foresee that class will be used by at least two different classes / functions This formulation is just one of many possible other guidelines that half will agree with, half won't.
&gt; I think the rule is just to counteract the habit of putting every single class into a separate source file I agree with that, I'm just suggesting to improve the rule with the formulation you're saying is shared by only half of the people. The new rule formulation could be even easier to check by code analysers (checking if a class is used by two or more other classes is trivial). 
The guideline is about not to put each class into a separate file **out of principle** (those are non-rules). That doesn't imply that a header should never contain only a single class where it makes sense due to other reasons. Those are the non-rules, that try to bebunk best practices/common knowledge that is outdated or wrong. That doesn't necessarily mean that you should never do it or even always do the opposite. I'm a bit sceptical about the argument that splitting up the code into individual headers reduces the number of dependencies. That may work in a microscopic scope (like e.g. unit-tests), but if we are talking about closely related types (otherwise you'd not put them into a common header in the first place) you are very likely to end up with all those headers in a TU anyway. What imho does make sense though is to separate out compatibility functionality. E.g. you want to support a serialization framework (or just io streams that requires you to include the header of that framework, it makes sense to put that functionality into a separate header. 
Thanks, that’s all really interesting.
&gt; header only arbitrary precision floating point lib I'd bet there is a German word for that.
Boost Multiprecision is an interface for other multiprecision libraries under the hood. You can choose which one benefits you the most based on benchmarks [here](https://www.mpfr.org/mpfr-3.1.0/timings.html).
so make your own rule about it for your big project.
So my C++ is pretty rusty (no pun intended), so this might be a stupid question. I tried to find where the actual magic happens and found this. Does *name_impl()* call *strings_imp()* to find a name, and *strings_impl()* calls *name_impl()* to fill its name array? Isn't that recursive? template &lt;typename E, int... I&gt; [[nodiscard]] constexpr decltype(auto) strings_impl(std::integer_sequence&lt;int, I...&gt;) noexcept { static_assert(std::is_enum_v&lt;E&gt;, "magic_enum::detail::strings_impl requires enum type."); constexpr std::array&lt;std::string_view, sizeof...(I)&gt; names{{name_impl&lt;E, static_cast&lt;E&gt;(I + min_impl&lt;E&gt;())&gt;()...}}; return names; } template &lt;typename E&gt; [[nodiscard]] constexpr std::string_view name_impl(int value) noexcept { static_assert(std::is_enum_v&lt;E&gt;, "magic_enum::detail::name_impl requires enum type."); constexpr auto names = strings_impl&lt;E&gt;(range_impl&lt;E&gt;()); const int i = value - min_impl&lt;E&gt;(); if (i &gt;= 0 &amp;&amp; static_cast&lt;std::size_t&gt;(i) &lt; names.size()) { return names[i]; } else { return {}; } } 
 wow, gj, i thought that header would be much more complex, but its kind of simple 
`strings_impl()` calls `name_impl()` at line 88 (no arguments), as `name_impl(int value)` at line 129 has a single `int` argument.
Magic in abuse compiler intrinsics - namely __PRETTY_FUNCTION__ and __FUNCSIG__. Here 2 function name_impl&lt;E&gt;(int value) and name_impl&lt;E, E V&gt;(). strings_imp() - uses name_impl&lt;E, E V&gt;(), name_impl&lt;E&gt;(int value) - uses strings_imp(). 
&gt;The guideline is about not to put each class into a separate file out of principle Yes, that's right. The reason seems however implying that it's better to put classes in the same files, I'm just saying that it should be explained better. It's a work in progress, so maybe they'll change it sooner or later. &gt; I'm a bit sceptical about the argument that splitting up the code into individual headers reduces the number of dependencies Well, when something is theoretically possible, in my experience it will almost always happen at the worst time &gt;where no-one can agree on what perfect is) is to have consistency and to understand that there are always some very special cases, that will require you to ignore a certain guideline Totally agree about the consistence. About rule perfection, well, it's ok not being perfect at beginning. I think it's also good to strive for perfection, just like a continuous refactoring toward something always better
Yeap)
That for sure.. however, here we're just discussing to make something better :)
Struggling to imagine how an invariant-based transition specification would scale to real-world hierarchical FSMs with dozens, let alone hundreds of states. Maybe a behavior-based spec would work better?
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
but they are explicit about being aware that this rule exists and that i may make sense in some places and they still make this rule in their coding guidelines. that means they have a different idea about what is better. i agree, because i don't see why a special needs rule needs to be observed by somebody who is not affected by the need.
Awesome, thanks! So you iterate over min...max, check for each if it is a valid enum value (in values_impl(), using the fact that name_impl() would return an empty optional for invalid values), and you get the names by parsing the string representation of a template that contains this value. Right? So... in theory, you could iterate over the complete range of the enums underlying int class and use a map to store valid values. Since the first part is all constexpr, it would "only" affect compile time (as in "loop over 2**64 values"), but not execution time or program size.
\&gt; I think it's also good to strive for perfection, just like a continuous refactoring toward something always better &amp;#x200B; If there is such a thing as objectively perfect (or even objectively better) then yes. When it comes to coding guidelines there is very often not a "better" but just different solutions that have different tradeoffs and people that are used to different styles. Doesn't mean you should not suggest improvements, as long as you keep in mind that what seems better to you might not seem better for others. &amp;#x200B;
Use for leading spaces instead of back ticks for code blocks like this. using var_t = std::variant&lt;std::string, int, bool&gt;; class object : public var_t { public: using var_t::var_t; object(const char* t) : var_t{std::string{t}} {} };
Pretty cool stuff! You might get wider compiler support for names by parsing https://en.cppreference.com/w/cpp/types/type_index/name, at the cost of #include &lt;typeinfo&gt;
Cool stuff! May be worth noting that enum_cast won't work if values are aliased. A somewhat common pattern in some companies: enum ShapeKind { ConvexBegin = 0, Box = 0, // Won't work Sphere = 1, ConvexEnd = 2, Donut = 2, // Won't work Banana = 3, COUNT = 3, // Even more common pattern, won't work either }; 
In order not to affect the compilation time too much, I limited the range to [-256, 256]. Enum value must be in range `[-256, 256]`. If you need another range, add specialization enum_range for necessary enum type. ```cpp #include &lt;magic_enum.hpp&gt; enum number { one = 100, two = 200, three = 300 }; namespace magic_enum { template &lt;&gt; struct enum_range&lt;number&gt; { static constexpr int min = 100; static constexpr int max = 300; }; } ```
Thanks for the comments, I really don't know what to do with aliases. I will add this to the remarks for enum\_cast .
I'm going to place class definitions in their own file extra hard now out of spite.
It's not constexpr, though, is it? 
Totally agree with that. I'm curious in fact about what other people think about it.
Unfortunately, not constexpr
I've done my research on composition vs inheritance, and there isn't a single logical and coherent argument that supports the idea that inheritance is bad and composition is not. The internet is full of logical fallacies. Argument from authority doesn't mean the argument is valid. Again, I am asking you provide some argument. Perhaps I missed something, why don't you try to show it to me?
Why the downvote tho?
 I found out the cause of the problem my bad 
Really interesting. Not possible to exploit this magic for C++ 11 / C++14 too?
Porting will be quite difficult, scary and expensive for compile time. Possible port enum\_to\_string and string\_to\_enum to C++11.
beliebigegenauigkeifließkommabibliothek
&gt;\&gt;a sane guideline &gt;\&gt;a guideline containing the word "foresee" pick one
A sane one is one that foresees. The more cases it foresees the better it is eheh
Just documenting them is fine. If you can verify that the compiler picks the first defined name for PRETTY_FUNCTION, people will be able to work around the issue: enum ShapeKind { // Convex shapes, see ConvexBegin and ConvexEnd below Box = 0, Sphere = 1, // Non-convex shapes Donut = 2, Banana = 3, // Non-reflected aliases ConvexBegin = Box, ConvexEnd = Sphere + 1, COUNT = Banana, };
Still boggles my mind that this isn't in stdlib already
I understand, so hard but not impossible, thanks :) 
Maybe I add port to c++14. Add issues if you need its. 
&gt;and there isn't a single logical and coherent argument that supports the idea that inheritance is bad and composition is not. Oh great, another arsehole who can't fucking read the actual argument made and has to resort to putting words in other people's mouths just so they can "destroy" straw-man arguments. &amp;#x200B; Blocked.
Cheers !
It doesn't matter if it's easy to check. It's a guidline built on an arbitrary number. Why not three? Why not one? Why not four? Why not have it configurable and make it meaningless? Having something that is easy to check doesn't make it a good measure/metric/guideline/heuristic. The software industry has already been through the phase of applying code metrics only to find out they're meaningless and makes people focus on the number, instead of debating/testing the merits of one design direction over another. Do you ever care about the actual value of the cyclometric complexity of your code? Do you ever care about your Halstead metrics? How much do you think people will care about this arbitrary number, especially when it conflicts with their taste/design/toolchain?
Don't focus on that, I wasn't saying that it's better because of that. Just saying that, in addition to everything else, there's also that additional benefit for free. 
in general, using a variant with convertible types is dangerous especially if they are pod types that have extra rules. I would be tempted to use private inheritance and opt in to any conversions I want manually
How so?
 struct TestCase { TestCase() : self{*this} {} ... TestCase&amp; self; }; O_o
PS I forgot how touchy people were in the C++ community ehhe 
The answer to "why not SDL" is the same as "why not UE/Qt/etc." only reduced in relevant areas. Third party, lacks features, too many features, not supported on platform X, requires dependency Y, etc. 
Sadly, boost::numeric::interval is unmaintained. I've hit lots of problems with it.
Totally wrong. This totally ignores the fact that high precision is required for poorly conditioned problems, which arise all the time in physical applications; the Fermion sign problem is an example. In addition, we are not constrained to asking questions about the physical universe.
Multiprecision will help to evaluate errors, but you should consider calculating the condition numbers of you problems to understand the error better.
You can find free courses online that will give you a good understanding on modern C++. After that just go over books and blogs from real C++ developers. Some sites that I recommend: www.cplusplus.com isocpp.github.io/CppCoreGuidelines www.modernescpp.com herbsutter.com On Stackoverflow look for: The Definitive C++ Book Guide and List I did C++ as a graduate student (paid for it) and I can tell you that books and YouTube videos were way better than my paid classes.
I cannot think of any good reason to expose the internal object state to outside callers. They're INTERNAL. if this is an attempt to expose which elements change for a given operation - just document it. if it's an attempt to remind yourself which elements of state are changed by an operation ... read your own documentation, get a better memory, or read the code. 
So I recently, 6 months ago, start during multiple classes per file based on logical groups, as you discuss. Though in Python and not C++ and I have done for as long as I can remember in Ruby, whilst in C++ I have kept to a one class one .hpp and one .cpp file. &amp;#x200B; Now, I actually hate the multiple classes per file approach in C++. The reason is that where in python I would be able to write \`\`\`python from DirectoryHandlers import DirectoryIterator \`\`\` I cannot do that in C++, I would have \`\`\`c++ \#include &lt;Directory&gt; \`\`\` And thus not specify what classes I actually needed. This makes it difficult to given an initial overview of what types I can expect to meet in a given piece of code, which I think is annoying. It is similar to \`import java.util.\*\` what the hell am I using in \`util\`? &amp;#x200B; So yes you gain a group by logic, but you lose overview, wouldn't you agree? 
Not to bash your idea or anything. But eh... why? In general, not saying Neos suffers from the same issue, one of the issues with do it all tools are that... Well they do it all. They can do a lot of stuff, but not good. How does it handle optimisation, for instance? Otherwise cool idea :) 
Note where in the core guidelines this is placed: &gt;**NR: Non-Rules and myths** &gt; &gt;This section contains rules and guidelines that are popular somewhere, but that we deliberately don’t recommend. We know full well that there have been times and places where these rules made sense, and we have used them ourselves at times. However, in the context of the styles of programming we recommend and support with the guidelines, these “non-rules” would do harm. &gt; &gt;Even today, there can be contexts where the rules make sense. For example, lack of suitable tool support can make exceptions unsuitable in hard-real-time systems, but please don’t blindly trust “common wisdom” (e.g., unsupported statements about “efficiency”); such “wisdom” may be based on decades-old information or experienced from languages with very different properties than C++ (e.g., C or Java). &gt; &gt;The positive arguments for alternatives to these non-rules are listed in the rules offered as “Alternatives”. It's meant to stand against the common directive present in many environments to enforce this behaviour. This "antipattern" probably has its origins in a legacy form of C++ programming &amp; in attempts to migrate style guides from other languages other than C++ that better conform to it. At Least that was the reason why it showed up in the last workplace I was in. &gt;In general, why including something you don't need? As hard as it might be to swallow aesthetically sometimes, (generally speaking) including "unused" blocks of text is easier on a compiler then talking to the filesystem. But let's forget about the compiler, it's by far easier for the programmer to edit, maintain, &amp; understand a group of related classes / structs / functions / comments if they are in the same file, and not say... spread out over 17 files, only 6 of which are any longer then 5 lines. (That's not to say a short file can't be useful, just that it's a judgement call)
Hopefully something will change with modules :)
You need a recent compiler anyway for the function name intrinsics.
Did you only run the file call once? For your future benchmarks, I strongly recommend you use the Google Benchmark library or a similar one.
I actually used the idea for the to string and from string conversions from your library for my library [https://github.com/KonanM/static\_enum](https://github.com/KonanM/static_enum) (but I wrote the complete implementation from scratch) . And it seems you have copied my approach for creating the array of enum\_values (which is great, don't understand me wrong). The only drawback to my implementation is that you can't specify an arbitrary ranges of values. The function signatures simply get too big and the compilers start to complain if you chose the range over 512 (I guess that's why you chose 512). If I have time I will try to work around this issue, by using multiple index sequences. Keep up the good work.
How do you compile javascript (or is that todo)? I've heard it described as basically impossible to do well
Thanks, great list btw.
Yes, all that I have managed to improve so far is the ability to set an individual range for each enum, pay attention to magic\_enum:: enum\_range 
\&gt; The resulting number of files are hard to manage and can slow down compilation. Please post the results of your benchmarks, and include the distinction between SSDs and spinning disks.
&gt; QuickGUI &gt; ... &gt; &gt; Cons &gt; &gt; * mentions Ogre3D &gt; * hosted by Ogre3D &gt; * used with Ogre3D &gt; * did I mention Ogre3D? Do you have arguments against Ogre3D? (I mean, other than *I don't like it*) 
Just read , you have a good point. &gt;But let's forget about the compiler, it's by far easier for the programmer to edit, maintain, &amp; understand a group of related classes / structs / functions / comments if they are in the same file, and not say... spread out over 17 files, only 6 of which are any longer then 5 lines Well, of course, a library shouldn't have 1000 files, I don't like that too. Code however can be organized in folders :) 
Got it, that's unfortunate then
Not elegant, but you can just create the string explicitly in the initializer list.
&gt; QuickGUI &gt; &gt; ... &gt; &gt;Cons &gt; &gt;* mentions Ogre3D &gt;* hosted by Ogre3D &gt;* used with Ogre3D &gt;* did I mention Ogre3D? Do you have arguments against Ogre3D? (I mean, other than I don't like it) 
Algorithms are one half of the puzzle. The other half are data structures.
Is the standard just wouldn't be so afraid to put the litteral suffixes in the global namespace.
April's fool joke or real?
Yeah i understand that. I have actually also had classes on data structrues too. &amp;#x200B;
Don't some of them collide? (Which seems a slightly odd decision in itself)
I would say real. C++ is currently the language to go for GPGPU, 3D game engines, HPC and Fintech. 
\`char\*\*\` has about as much to do with \`char\[8\]\[8\]\` as it has with \`long double\` (that is, nothing, aside of both being object types)
Could you submit this to the committee? Enums are one of the worst parts of C++. 
char[8][8] is not a pointer to a char pointer (char **). Therefore you get the compiler error. By the way, you allocate local memory within your function. This memory will be destroyed as soon as your function returns. Therefore returning variable position does not make sense.
Also, the article is from the 8th of April :)
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bavg8a/function_that_returns_a_twodimensional_array/ekeao2d/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/barpp5/question_about_reading_material_on_algorithms/ekeaq42/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Could you elaborate on this a little? 
For what it's worth, that sentence comes from the core guidelines, not OP.
Compiler optimizaters are usually language agnostic anyway... I optimize the byte code and my JIT will optimize the machine code.
I will cross that bridge when I come to it. 😏
when you visit you have to be more careful than just using the exact type. whether a function is called can change if you add/remove other overloads to your visitor. as for wrapping, that's just inherit with `private` and then add the calls you want to allow
Ahahaha yeah, I was trying to get the two snippets as close as possible
That's just a matter of personal preference. This proof of concept is just trying to answer the question "What could be done with reflection that we are currently doing manually?"
The two hardest things in programming are cache invalidation, naming things, and off by one errors.
Glad to hear that it was useful for someone else out there \^–\^
This is impressive. Good job!
deductino guide?
Nope they don't. Overload resolution is also a thing for UD literals.
Oh interesting I didn't know, thanks!
Any stdlib solution we standardize will be superseded once we have reflection.
Here is the actual graph: https://www.tiobe.com/tiobe-index/ A few points I would like to posit: * It's peculiar that Java and C are strongly correlated with respect to a large dip in 2017. * It's also interesting that Python starting gaining usage from the same point in time. * I do not see Go in the graph.
What struck me as really weird in this ranking was Visual Basic . Net jumping over C#. That seems really weird to me. There has not been anything released recently that would spark an interest in Visual Basic . Net.
I love to see something like clang-include-fixer like feature. I love using it but I requires two databases.
My point is that, for cross platform windowing and events, if you don't implement something like SDL in the C++ standard and go for something even lower level (lower level primitives, etc.), it wouldn't really be all that useful. If you do implement something like SDL in the C++ standard, then it will have to be updated rapidly to accommodate the ever changing landscape, which would be impossible given C++'s 3 year release cycle.
Thanks for the explanation :)
The title is confusing as heck. If you use C++ in developing a washing machine it's to write a computer program that runs on the computer in the washing machine.
"Boost.UI" just wraps WxWidgets anyway. It's unfortunate that the author implies it's a Boost library when it's not.
With unittest you don't have to modify the production code to make it testable.
It was a joke - he uses the terms "observable universe" and then just plain universe. Hence the use two instead of too.
Sometimes people on this sub-reddit just like to take a shit on someone. The title is pretty poorly written though.
TIOBE is nonsense. Their algorithm basically consists of this: ( https://www.tiobe.com/tiobe-index/programming-languages-definition/ ) &gt; Basically the calculation comes down to counting hits for the search query +"&lt;language&gt; programming"
You should turn your benchmarks into a PR for https://bitbucket.org/ewanhiggs/csv-game
I don't really get why this "solution" has the most upvotes. When other people have to work with your code and it has totally different outcomes when you write { "name", "john" } vs { "name", "john"s } it is not well written. Also everyone needs to include std::literals.
What's with the version requirements? &gt; GCC &gt;= 9 Latest release is 8.3 https://gcc.gnu.org/releases.html So... this library will work on GCC _eventually_ ?
gcc-trunk 9.0
Ok fair enough.
[Sciter](https://sciter.com) has compact and stable plain C API that allows to do UI without scripting. Scripting in Sciter can be treated as a DSL that defines interaction of UI layer (events) with native backend. Pretty much in the same as HTML is a DSL for defining DOM tree and CSS as language that defines how that tree needs to be rendered. UI in general has pretty complex ownership graph that usually contain loops so scripting and its GC helps quite a lot here. Native backend (code) is more regular in this respect - ownership is trivial and `std::shared_ptr&lt;T&gt;`/`std::unique_ptr&lt;T&gt;` are pretty adequate in most of cases.
really cool, is this C++ compliant or it exploits compiler only features?
the backticks actually work in the redesign. Which would be really cool if they could backport it, but reddit just prefers to suck as it seems.
Try my [Sciter](https://sciter.com), it uses H/W accelerated graphics on all platforms (DirectX and OpenGL) so it is pretty good on HighDPI monitors. You can try [Sciter Notes](https://notes.sciter.com/) and [HTML-NOTEPAD](https://html-notepad.com/) applications to get an idea of what can be achieved with Sciter.
[P0608](https://wg21.link/p0608) was adopted as a defect report, so `variant` should just do what you want here going forward. You'll recognize the motivating example there :-)
If you can wait until then. It is years away if we are lucky, if unlucky decades.
If Mordy is correct with his guess (which seems reasonable) the same reasoning would apply to `std::byte` and `unsigned char` ([= `std::uint8_t`](https://en.cppreference.com/w/cpp/types/integer)) as [they are specifically blessed to access the object representation](https://en.cppreference.com/w/cpp/language/reinterpret_cast#Type_aliasing).
Does make sense - not really a way to monkeypatch functions that are inlined or invisible to external tooling. Because C++ doesn't (yet) have any real reflection, this proof-of-concept works by inspecting debug information to find attributes and locate functions to be mocked and then monkey-patches the test's code to invoke the mock version instead. In C++2y maybe it'll all be able to happen without that hack, and without relying on platform-specific details like ELF/DWARF, and with compatibility for typical compiler translations (optimizations). Maybe. We'll see. Being in C# land these days and seeing the power of NSubstitute though, this project here makes me happy. We need this kind of thing to be possible in standard cross-platform C++ asap. :)
Nope, C++23 is the current plan.
I've used (winlamb)[https://github.com/rodrigocfd/winlamb] for the same task (NT service configuration utility).
The code-sample looks pretty bad and Mocking is more often than not a symptom of badly designed test; I'm going to be bold and say that 99.9% of the time this: identity.assert_called_once_with(43); Is a terrible unit-test: It tests implementation rather than behavior which is the precise opposite of what you want. The only thing this test will ever accomplish is to check whether the implementation hasn't changed which can even more easily (and precisely) be checked with `git diff` or just `diff`. If you haven't seen it I **very** strongly recommend that you watch [this talk](https://www.youtube.com/watch?v=EZ05e7EMOLM) for a *great* explanation of all the details. Actually: If you haven't seen it and believe that `.assert_called_once_with` is ever going to be useful for anything, stop what you are doing and watch it now!
It's abuse compiler intrinsics, so far most popular compilers are supported clang/gcc/msvc.
Which is _years_ away :)
I mean you're right, but it sure doesn't feel like a lot of time :)
Modules were once planned for c++11?
Years away then years more before many people will be able to use it.
Fair enough. Concepts too. I'm positive though :)
It doesn't know that the result of one doesn't affect the result of the next, so it can't vectorize. char *'s are allowed to alias.
Why did I have to scroll so far to find this?
I have a rule of one file per leaf namespace. Example: * pkg::a::b::* goes in pkg/a/b.hpp and .cpp * pkg::c::* goes in pkg/c.hpp and .cpp This has the advantage that you always know exactly where to find something given its name. This seems like the obvious way to do it. I'm not sure why I haven't seen explicitly written out anywhere, though.
Emscripten provides a full C++ library to control anything on the HTML side. You can call any JavaScript functions from C++ and vice versa.
Emscripten is a C/C++ compiler down to WebAssembly. It's basically a virtual assembly language that is very fast; not all that different than compiling down to any other assembly code.
Thanks! I have no idea about condition numbers yet. Will check it out.
Is that `bin` relative to the build directory?
[https://wg21.link/p0608](https://wg21.link/p0608) mentioned by u/sphere991 seems like the best solution for the long term. In the short term, I would write a simple \`safe\_bool\` wrapper class that did not have this converting constructor and use it. &amp;#x200B; \`variant&lt;std::string,int, safe\_bool&gt;\`
Thanks for your reply. I think you are right. Since I know I could do that, I am exploring some other possibilities. Since my needs are very simple, I thought one header file could solve it. The pros about one header file is easier to maintain.
It would be interesting to see measurements on the costs of inclusion. That said, there's at least a handful of system calls per first #included file -- search, open, read, close. Spreading 10k classes across 10k headers should have an observable impact on build time.
It looks like you have a narrow definition of "computer" and "computer programs". The microcontrollers in your washing machine and microwave oven are also computers.
That code is black magic. Just a few years ago I understood C++. It made me think to myself: Time to reincarnate to something more beautiful.
I'm not personally familiar with it, but from the description it sounds like [boost::safe_numerics::interval](https://www.boost.org/doc/libs/1_69_0/libs/safe_numerics/doc/html/interval.html) might be a more "recently updated" version.
People who rely on ADL are black magicians
Not that anyone is likely to use it, but mine includes amongst many other things a pretty extensive UI framework, though it only supports Win32 at this point. [https://github.com/DeanRoddey/CIDLib](https://github.com/DeanRoddey/CIDLib)
You have, with a high degree of certainty, directly written code that relies on ADL.
custom code vs libraries?
That was the first thought I had with this, however if I accessed the __FUNCTION__ string in any way it got included in the binary. Only messed around with it for a short time before giving up though.
\*\*Company:\*\* \[Adobe Photoshop\]([http://photoshopishiring.com/](http://photoshopishiring.com/)) &amp;#x200B; &amp;#x200B; \*\*Type:\*\* Full time &amp;#x200B; &amp;#x200B; \*\*Description:\*\* The Adobe Photoshop team is looking for Senior and Junior C++ developers. This is a rare opportunity to work on a product that is literally a household name. In these positions you will be working closely with our product managers to deliver those Adobe magic features, features like, content aware fill. In real terms, you will be writing cross platform C++(Windows/macOS) to deliver well tested features to millions of customers daily. &amp;#x200B; We are looking for people that have &amp;#x200B; \- A solid understanding of C++, you will require an understanding of modern(C++14) and the not so modern(C+98). \- Demonstrable experience working with customers to deliver features that address their problems \- Experience with large code bases (For the senior role) \- Some understanding of HTML/JS/CSS &amp;#x200B; \*\*Location:\*\* Hiring in San Jose, Minneapolis, San Francisco, Seattle, New York &amp;#x200B; &amp;#x200B; \*\*Remote:\*\* No &amp;#x200B; \*\*Visa Sponsorship:\*\* Yes &amp;#x200B; &amp;#x200B; \*\*Technologies:\*\* We are mostly a C++ codebase. The codebase is old, with some that pre-dates even C++98. We are modernising our codebase and currently do support C++14 with C++17 hopefully soon to follow. As the product grows we are bringing on more platforms, so at times you will be required to debug and fix problems on other platforms such as iOS and android. &amp;#x200B; We have other languages that get used in our code base for various feature work and supporting roles. &amp;#x200B; Having some understanding of JavaScript/HTML/CSS is desirable but not required, it is used to support some of our UI. &amp;#x200B; We use python and perl to support our build systems. &amp;#x200B; \*\*Contact:\*\* If you have any questions you can contact me directly on reddit, or you send an email to Jeff Sass - [jsass@adobe.com](mailto:jsass@adobe.com) to apply visit \[Adobe Photoshop is hiring\]([http://photoshopishiring.com/](http://photoshopishiring.com/))
Also of note is rapidcheck.
I learn from TSes tho. Only update the few changes that comes with it in the standard. So technically I've been on Concepts TS since 2016/17 or so. By that analogy, any TS that gets implemented in compiler get used.
You mean many of the major C++20 features
Plenty of companies will reasonably not be willing to adopt TS implementations though. That goes *especially* true for reflection, where my impression is basically that the committee has all but outright said that the API to the final implementation will be completely different. (I forget what terms they use, constexpr function based instead of type metaprogramming based or something like that.) So if you start implementing to the TS, you're *guaranteeing* yourself a rewrite.
&gt; Two of the most important features coming to C++20 are 'modules' and 'coroutines' Heretics! For mentioning 'Coroutines' in the same breath as Modules. Only Concepts deserves that position.
Very cool. Thank you for posting.
I usually just ignore the existence of ADL and hope for the best.
Yet another build system. Have you heard of premake which is also based on Lua?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bb4agy/operator_overload_for_copy_constructor_help/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
From what I have seen I don't think that it will you will still not have selective imports of what is in a module or a header. So it will still import everything, no?
Unfortunately, ADL doesn't work consistently. E.g., when using asio, I can avoid namespace-prefixing most of the functions, but when it comes to a templated function like `buffer_cast&lt;&gt;`, ADL doesn't kick in even though the argument is in the same NS, so I have to write `asio::buffer_cast&lt;&gt;`. Blargh.
The scary part is not knowing we've done so.
Thanks for having set up that list. There is one point which I'm missing in the assessments of all the listed GUIs: DOCUMENTATION!! The more extensive a library is and the more cross-dependencies among its components it has the more important documentation becomes. There are huge differences between the libraries - consider e.g. these two extremes: nana vs FLTK.
This is fixed in C++20 :)
Good look waiting for Qt or Gtk+ to provide xmake build files.
CMake has a much deeper built [Qt integration](https://cmake.org/cmake/help/latest/manual/cmake-qt.7.html) than simple find scripts.
Qt5 scripts are provided by Qt itself. CMake if far from being perfect. And what I think also applies to it. On the other hand they refuse modules now and ask contributors to update upstream to provide CMake files.
My guess is /u/kalmoc/ is being ironic! Who cares about "... C++ is doing well ..." in some dubious ranking. Also python, I would submit is just a way of running C++ for people who like weird and silly syntax. The [python] progress is mostly based on the hype around ML [running tensorflow etc.].
I just didn't check the article itself (had a very weak internet connection at the time), so I didn't know when it was published. But I am genuinely suprised that c++ is on the rise again.
&gt;Compiling this example with -O3 on GCC 8.2 gives exactly the same binary as a manually implemented operator== so we can safely say that there is no performance impact for that case. Yeah, but without optimization, the binary size is x2 bigger and huge performance drop to more than 6 times slower =/
Do you have Numbers? Or is this just a guess?
I followed his benchmark link in the blog post which shows the optimized code result. I ran the same benchmark removing the -O3 optimization
Well, I still have hopes eheh
Yeah it reminds me a lot of premake as well, which isn't necessarily a bad thing imo. Having a repo to pull modules from is a big plus I think. I want to live in a world where I pull anything from for example github, and then run a sensible 1 line on the command line to either build everything, or generate project files for my IDE of choice.
So you're sticking to a file per class ?
Agreed we can hope. &amp;#x200B; AND HAVE OUR HOPES CRUSHED XD
No... filenames would come from one level higher. For example if you had a class with a full name of `my_library::my_namespace::MyClass`, the declaration for MyClass would go in `my_namespace.hpp` and the implementation of MyClass would go in `my_namespace.cpp`.
Cool. Now, only if everyone remembered to maintain the list of tie items with every added member field.
I don't think that's what he meant.
The second one looks pretty reasonable to me TBH. The first one is dumb though.
ahahah that's highly likely :D
&gt; Where does this huge dip for c and java in the tiobe index around 2017 come from? My guess is that it has got a lot to do with the methodology. I don't know anything about Java, but if we just concentrate on C, I think we can easily agree that it is highly unlikely that at some point there is a huge dip [that could be the case on its own] **and** thereafter a huge pickup of C again [seriously? Must be the C18 effect :-) ], this is just not happening in my view.
That's unsurprising, isn't it? With -O0, you're telling the compiler to stop thinking about what you're doing and stupidly follow instructions. No loop unrolling, no nothing. It figures that this only will do well of you put in lots of manual work.
Does this solution do anything that a macro couldn't do? I use macros atm and I'm curious.
it seems you have tens of namespaces and just a few files. Well, a totally different approach I'd say..
Agreed. Unsuprisingly, this has been asked before: [https://softwareengineering.stackexchange.com/questions/388432/why-did-java-and-c-sharply-dip-in-popularity-around-2017-in-the-tiobe-index/388434](https://softwareengineering.stackexchange.com/questions/388432/why-did-java-and-c-sharply-dip-in-popularity-around-2017-in-the-tiobe-index/388434) Tl;DR: No definite answer, but it might be the result of search engine changes
We probably do use more namespaces than average. We don't just have a few files, though - the project has over 100. Some namespaces/files only have a single class, some might have 10 related ones. &gt;Individual classes are rarely a good logical unit of maintenance and distribution. We're just using namespaces as our "unit of maintenance and distribution". For simplicity, we have a 1:1 correspondence between namespaces and files. We more or less carried over the habit from Python, with its modules. This approach is basically identical to Python's modules, except that you can't include only a subset of classes from a namespace, but that doesn't matter (modulo compile times).
~~~ int main() { std::cout &lt;&lt; "Hello World!\n"; } ~~~ This well-known snippets relies on ADL to find the right `operator&lt;&lt;` which is defined in namespace `std` and is found because `cout` is in namespace `std`.
Macros have type-safety problems, and are generally avoided in C++ (when you have templates that would do the same job). This isn't to say that you can't use macros. Knock yourself out :)
C is on the rise thanks to IoT, gratis UNIX derived OSes, and the embedded community's refusal to move away from it, check any of Dan Saks or the ongoing C++ community efforts to move embedded devs into safer programming patterns.
What type safety problems would there be with generating operators? Why would I use templates for a simple copy-paste job? Isn't that what macros are for?
Sure, same thing with manually written comparison operators.
I've understood. It's another approach, I just think there are too few files following yours :)
&gt; Macros have type-safety problems ... No.
Premake for simpler projects has the best, clean build files. It's a pity Premake is not popular.
That'd be cool. Can you point me to the proposal that fixes it?
You can;t complain, Denmark, especially Copenhagen has a lot of interesting companies and you have a great laid-back work atmosphere (&lt; 40hours work week etc.). I wish I had such opportunities as you have.
Yes
If all those people that are inventing their own build system would contribute to cmake we might have a widely supported, easy to use de-facto standard build system in c++ by now. Sure, there are design decision inherent to cmake that can't be changed (at least they have a deprecation policy), but especially with build systems (especially for c++), compatibility and reduced fragmentation is imho much more important than perfection.
A macro does not have type-safety problems, it's copy-paste. I don't say or mean to say that it is not possible to write bad macros, I'm just stating that type-system kicks in after the macro has expanded, there is no type-system in macros, it's not even duck-typeing.
I think there are a lot of adl cases, that should be deprecated in c++23 (and the compiler can emmit a warning if it resolves a call via a deprecated adl rule) and removed in c++26/29. Another possibility would be to deprecated adl in general, except for functions explicitly makred with \`\[\[adl\_customization\_point\]\]\` or some such, but that would be extremely noisy. Wonder if removal of ADL would have significant impact on compilation times or if this is just a minor issue.
I think that is true for the majority of operators out there. I wouldn't be suprised, if many people complaining about ADL are using it much more than they realize.
Is that possible? I thought it only applied for template arguments
&gt;there is no type-system in macros I believe that \*is\* the problem.
The purpose of my post is to share about how std::string implementation can beat a string\_view CSV parser. MiniCSV is nowhere the fastest. MiniCSV wins at the ease of use.
Yes, only once. I have updated the code to loop 10 times. Thanks for recommendation! I'll look into Google Benchmark in the future.
A macro automates (generic) code generation, it does not deal with or have type-safety, the type-system kicking in after macro expansion is your friend and will catch most if not all type-related errors. Higher up someone states: "... and are generally avoided in C++ ...". Did you or that person ever have a look at Boost-source-code [the arch-typical C++ library, written by some of the best C++-programmers on the planet], it is literally held together with/by macros. Like any tool, and particularly C-tools, it can be abused/misused, but I still need to see that example where the lack of type-safety (of a properly written macro) poses an issue a the level of the type-system.
For simple data structs, it's possible to generate this (with C++17): [https://github.com/felixguendling/cista/blob/master/test/comparable\_test.cc](https://github.com/felixguendling/cista/blob/master/test/comparable_test.cc) &amp;#x200B; This way, adding a field does not require any change in the comparator code.
It can be, using a `std::unit8_t` where a `char` is special is undefined behavior, which is allowed to "just work".
ADL is a clever solution, but it is a problem in languages when a lot of developers are using features that they don't even realize about. It means they did not understand what they are doing, and can bite them later on. In general C++ suffers from this in several parts, which is understandable given its history. But that doesn't mean that having to write `using std::swap;` isn't crazy.
Also who cares about binary size in debug builds?
This looks useful, thanks for sharing!
One idea to increase the range might be to query multiple enumerator values in the pretty function via variadic args. I didn't try this yet. Querying one-at-a-time I managed to benchmark checking 2\^16 values in \~1s, with a 'divide and conquer' method (at that rate, scanning 2\^32 values would take \~18 hours and 2\^64 is entirely out of range for compile-time checking). BTW, I noticed this little homage in static\_enum; // [Enum variable out of MAGIC\_ENUM\_RANGE](https://github.com/KonanM/static_enum/blob/master/include/static_enum/static_enum.hpp#L149)
This.
If there's demand then the relevant gcc patches could be backported to earlier gcc releases: [https://gcc.gnu.org/bugzilla/show\_bug.cgi?id=87364](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=87364) [https://gcc.gnu.org/bugzilla/show\_bug.cgi?id=88170](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=88170) (The first patch caused test failures, fixed by the second patch.)
In C++20 it may be possible to use std::source\_location to extract the info. This would be only a little more standard than using preprocessor extensions because the string returned by source\_location is implementation defined.
&gt;if you start implementing to the TS, you're guaranteeing yourself a rewrite. If u ever start using a TS, u are already on the bus of rewrite. Bleeding edgers are aware of the stakes, uhm and benefits
I don’t understand this spaceship operator. What is it actually comparing in his example? The int, double, string, or some concatenation of all 3?
It is relative to the content of `CMAKE_INSTALL_PREFIX`.
I think you're missing an important point: these are *open source projects*. [I created a build system](https://github.com/SanderMertens/bake). It was a ton of fun to create and is even more fun to use. People that tried it seem to like it as well. Will it ever be as widely used as cmake? No, but who cares. I had fun building it, it is awesome, it does things that cmake will *never* do, and I have full freedom to add features I like in a whim. Why on Earth would I spend my precious spare time on something that doesn't bring me joy? And *why* would anyone even care about yet another small open source project when cmake *is* the defacto build system? People let's cheer up. Meson, xmake, bake, premake... These are hobby projects of people with a passion for building code that are having lots of fun. Let's be happy for them, their users and be thankful for the innovation and ideas, which best case provide a couple of good ideas for cmake, and worst case, are not harmful to cmake (or anyone using cmake) at all.
Thank you for your feedback, the idea is quite interesting, I would try to implement something similar on the weekend.
ah
It compares each member field separately.
Or, you know, you could just try the actual spaceship operator: https://godbolt.org/z/wDX4_r ;)
ADL = Argument Dependent Lookup
So it only returns true if the predicate is true for every member comparison?
Anybody compiling with -O0 deserves whatever bad performance they get.
Looks like a nice library, thanks for sharing. program.add_argument("--verbose") .help("increase output verbosity") .default_value(false) .implicit_value(true); Is this kind of method chaining idiomatic C++? Feels more like Javascript.
Yes it has it's place in C++. At least until named arguments. This seems like a good use of it.
Ohhhh Fox Toolkit! That brings back some memories of a project I was working on maybe 17 years ago? Back in the XP days. It was a strange toolkit. I kinda miss those days though. Thanks for the list and that nostalgia hit :)
You should also watch Andrei Alexandrescu's and Chandler Carruth's talks about benchmarking and performance measurement... :-) You should find them on YouTube easily, sorry for no direct links. They're both awesome.
The string example could just be return lhs.compare(rhs) &lt;=&gt; 0;
There was some effort going into a generic package description format, by one guy involved in cmake. I linked it on reddit before but can't remember the name again now. Anyway that sadly seemed to have died a bit too. That would be amazing in my opinion - it was something like a \`package\_config.cmake\` file but in json format, IIRC.
I may be a heathen for saying this but C++ could learn to borrow concepts from the latest ECMA standards as well as package managers like npm. I think that's why Go is shining so much at the moment, kind of has the best of both worlds.
Here, help yourself out: `-Og`
If nobody ever experiments with building other systems we will never have anything better than cmake. Also, this argument would have worked just as well when applied to cmake in the era of autotools. There is inherent value in having projects that try out new things, even if they aren't replacing the currently popular ones.
Ah yes, I forget these things.
I am not a huge fan of Go’s package management
This is also how the boost arg parser is used.
There are other ways to live?
Thanks for sharing. Looks interesting. Will try out. FYI, these are some other command line argument parsing libraries that I have been using a lot lately: \- [https://github.com/CLIUtils/CLI11](https://github.com/CLIUtils/CLI11) \- [https://github.com/muellan/clipp](https://github.com/muellan/clipp) Clipp in particular is extremely powerful and expressive. It lets you easily set up subcommands (like git or hg, for example). It can also auto-generate documentation (command line &amp; man page).
 ppetraki@vanguard:~/Sandbox/krillia/build-debug$ conan search imgui -r bincrafters Existing package recipes: imgui/1.53@bincrafters/stable imgui/1.61@bincrafters/stable imgui/1.62@bincrafters/stable imgui/1.63@bincrafters/stable imgui/1.64@bincrafters/stable imgui/1.65@bincrafters/stable imgui/1.66@bincrafters/stable ppetraki@vanguard:~/Sandbox/krillia/build-debug$ conan install imgui/1.66@bincrafters/stable Configuration: [settings] os=Linux os_build=Linux arch=x86_64 arch_build=x86_64 compiler=gcc compiler.version=7 compiler.libcxx=libstdc++11 build_type=Release [options] [build_requires] [env] imgui/1.66@bincrafters/stable: Not found in local cache, looking in remotes... imgui/1.66@bincrafters/stable: Trying with 'conan-center'... Downloading conanmanifest.txt [==================================================] 166B/166B Downloading conanfile.py [==================================================] 1.7KB/1.7KB Downloading conan_export.tgz [==================================================] 764B/764B Decompressing conan_export.tgz: 772B [00:00, 214kB/s] imgui/1.66@bincrafters/stable: Installing package Requirements imgui/1.66@bincrafters/stable from 'conan-center' - Downloaded Packages imgui/1.66@bincrafters/stable:66c5327ebdcecae0a01a863939964495fa019a06 - Download imgui/1.66@bincrafters/stable: Retrieving package 66c5327ebdcecae0a01a863939964495fa019a06 from remote 'conan-center' Downloading conanmanifest.txt [==================================================] 3.0KB/3.0KB Downloading conaninfo.txt [==================================================] 456B/456B Downloading conan_package.tgz [==================================================] 705.4KB/705.4KB Decompressing conan_package.tgz: 689kB [00:00, 11.0MB/s] imgui/1.66@bincrafters/stable: Package installed 66c5327ebdcecae0a01a863939964495fa019a06
IFAIA packages are being added in C++20
It's a nice way to implement a DSL. In a similar fashion, one can implement a DSL which enables you to build type-safe SQL queries which can be verified at compile-time ;) Another well known example which utilizes this technique is a monadic version of [`std::optional`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0798r0.html).
Not sure, what your first sentence has to do with the rest, but that aside: The "problem" is fragmentation. &amp;#x200B; Far be it from me to tell anyone what they should be doing in their spare time. I'm just stating what I as a build system user would prefer and I really have to say that I am much more annoyed when I encounter yet another library that uses a different build system than the rest of my project than I'd be ever annoyed about the quirks of any particular build system. It's kind of the same situation as every project using its own string type. Are there things that std::string lacks? Sure! Can it be fun to code your own string type? Sure! Should every project use it's own, incompatible string? Probably not! It makes it that much harder to compose them and there are more things you need to know about.
[P0846](https://wg21.link/p0846)
The technique is called fluent interface https://stackoverflow.com/questions/2084503/whats-a-fluent-interface It's really helpful especially in combination with factories/ when you have lots of default values, but you only want to change certain ones. The most common use case I came across is for unit testing. E.g. instead of using a helper method with lots of defaulted parameters to create a certain object, you create a helper class with an fluent interface. This makes your tests so much more readable .
That looks like a weird Builder pattern implementation without the "build()" method to me. The program itself probably shouldn't be returning references to the argument, the argument should be its own object which should later be added to the program.
You know that the reason, why you have to write \`using std::swap \` is precisely due to the opposite of ADL: because it \`std::swap\` will not be picked up automatically? ADL is the reason, why you don't have to also write \`using boost::swap\` and \`using foo::swap\` and whatever other namespaces exist in your project. That isn't to say that it isn't an example of a broken customization mechanism.
Modules getting adopted for C++ 20 sucked a lot of the air out of the room. Hopefully we can get back to packaging after we figure out how to make Modules work.
If the people writing CMake had known it was impossible, they would never had started.
I'm not against experimentation (far from it) and I'm - in principle - also not against replacing cmake with something better one day. What saddens me is that instead of one, or a few concentrated efforts to design a better build system for c++, there are dozens of different projects all going in slightly different directions and all of them competing with each other somewhat. &amp;#x200B; And with regards to autotools: Has it ever found any significant adoption on windows?
That is good news. Thanks for the link.
That is good news. Thanks for the link.
That is good news. Thanks for the link.
No you had it right the first time: it compares a "concatenation" of the members (usually we call that a lexicographic comparison). Also, it's not a predicate. It returns -1, 0, or 1 for less, equal, or greater respectively.
Exactly, not to mention that one still has rounding errors to deal with which can lead to wrong results, for instance, if your domain is computational geometry.
You didn't understand. The point is that C++ should have had another way of solving that problem, instead of requiring ADL.
&gt;I think you're missing an important point: these are open source projects. &gt; &gt;I created a build system. It was a ton of fun to create and is even more fun to use. People that tried it seem to like it as well. Will it ever be as widely used as cmake? No, but who cares. I had fun building it, it is awesome, it does things that cmake will never do, and I have full freedom to add features I like in a whim. &gt; &gt;Why on Earth would I spend my precious spare time on something that doesn't bring me joy? And why would anyone even care about yet another small open source project when cmake is the defacto build system? &gt; &gt;People let's cheer up. Meson, xmake, bake, premake... These are hobby projects of people with a passion for building code that are having lots of fun. Let's be happy for them, their users, and be thankful for the innovation and ideas they bring, which best case provide a couple of good ideas for cmake, and worst case, are not harmful to cmake (or anyone using cmake) at all. Yes. I agree.
&gt;And with regards to autotools: Has it ever found any significant adoption on windows? xmake support build qt project. [https://xmake.io/#/home?id=qt-program](https://xmake.io/#/home?id=qt-program)
&gt; It's a nice way to implement a DSL. In a similar fashion, one can implement a DSL which enables you to build type-safe SQL queries which can be verified at compile-time ;) I'm trying to build a sqlite library for that (far less, but strong types are one of the requirements). Is there any already made example of this? Thanks
Fluent interfaces are used for more than just the builder pattern.
Nice. Hopefully it will be cross plattform soon.
You can write `swap(a,b)` and if there is a function swap in the same namespace as the types of `a` or `b` (and as we just found out some more complicated cases) it will get picked up thanks to ADL- no need to write `using std::swap`. The reason you have to write it is that you want to use `std::swap` as a fallback in cases where adl doesn't find a matching function, but adl is not the reason for it.
I don't see how this is useful, given the fact that you have to decorate every vector with it, lose features like CTAD, and ultimately it's easy to implement on your own without relying on a library.
[I'd say so](https://github.com/rbock/sqlpp11). But I sadly don't have much experience with it.
I thought it would be useful for debugging. If you had a container giving you some sort of issues and you needed to print out the contents. And this doesn't work for only vectors, it works for every container in the STL. However, you are correct on losing CTAD, that is something I am trying to figure out how to implement.
Not knocking you personally, but I'm really sick of this example because ADL is not really a huge advantage here. If ADL didn't exist the following would make that line possible: ``` int main() { using std::operator&lt;&lt;; std::cout &lt;&lt; "Hello World!\n"; } ``` I'd like to see examples where a simple using statement wouldn't obviate the need for ADL.
Thanks, it seems interesting, though as in [my project](https://github.com/studiofuga/mSqliteCpp), it seems the "expressivity" objective has been lost a bit.
Qt uses code generation somewhat extensively. RCC will generate cpp files from the contents of arbitrary files for the purpose of embedding assets in the binary or library, for example. UIC will output a header file with the definition of a UI by reading an Qt Designer file. And there is MOC also. I certainly appreciate if a build tool has built in support for certain tools or idioms that are so common. Same as supporting rules for a compiler. Do you think that is best done some other way, or you were referring to something else?
You probably mean modules, which isn't really the same thing, though it's a step in the right direction for packages.
having 'struct Cont' inherit from the container type seems like the wrong choice here, because it requires projects to change their data structures. consider a struct that wraps a reference to the container instead - its operator&lt;&lt;() will still look very similar to what you have here, but it's much more flexible because you only need to construct the wrapper when you're using it to print: std::vector&lt;int&gt; foo; std::cout &lt;&lt; pretty(foo) &lt;&lt; std::endl;
Thanks for the feed back. Originally, this is what I was going for. However I wanted to treat it as it's own container so it still had the functionality of a vector, map, list, etc. So if you have a vector foo, you could create a container foo("foo"), which you could then do foo.push\_back(), etc. But I did not think of this, so I think I will maybe implement an overloaded call that will just allow you to pretty print the contents of your container.
There are couple of examples, but most notable one that can be found in the wild is [sqlpp11](https://github.com/rbock/sqlpp11) IMO. It does, however, support more than just SQLite so if that feels to heavy for you or you feel like crafting a "lightweight" version of it yourself, I would recommend you to start from [SQL as Understood by SQLite](https://www.sqlite.org/lang.html). It is a magnificent piece of documentation which I used when doing the same task for one of my previous employees.
Yes, sqlpp11 is definitely too much. I crafted a library, but I'm not satisfied though it is working fine. I think I'd lost the expressivity I wanted.
The only way not to rely on ADL is not to use namespaces, and that, Sir, is evil.
ADL is a requirement for templated code. Have you ever written something like this: namespace person { class Person; bool operator&lt;(Person const&amp;, Person const&amp;); } int main() { std::map&lt;Person, std::string&gt; addresses; } If you have, then know that `std::map` is using ADL to locate the `operator&lt;` to use to compare two instances of `Person`. And the author of `std::map`, not knowing in which namespace the key type will be, cannot use `using` to bring `operator&lt;` in scope.
I said you have to use `using std::swap;` to *take advantage of ADL*, which is true *when swapping* because you are expecting to be able to cover typical types with `std::swap` when you are e.g. in a generic container and have no clue about the type. Then you reply: "*but you don't need `using ...` to take advantage of ADL*". So...? A true statement, but you have taken out the rest of the context. Regardless of that, while my original point was mostly about ADL, the `using std::swap;` remark was about how hilarious we have to get to perform a trivial operation. Yes, if we do it know, maybe we could have done `std::swap` differently; but the big point is ADL.
Yes, I think examples like this are what we should be using to discuss ADL rather than the cout example. Apart from which examples are relevant, one thing the occurs to me when thinking about ADL is that elevating namespaces to first class c++ constructs would offer an alternative to ADL. I haven't really thought it through completely, but something like: ``` using declnamespace(Person)::operator&lt;; ``` IIRC Stroustrup even suggested making namespaces passable as template arguments, but was outvoted at the time by those who though it would make c++ too complex...
I don't really know much about Go. Why, if I may ask? I thought its library management system was generally considered hassle-free and straightforward.
&gt; Yet another build system. Have you heard of premake which is also based on Lua? Or [GENie](https://github.com/bkaradzic/genie) which took premake4 and stabilized and expanded it, adding features like a template toolchain file for thorough cross compilation and a FASTBuild generator.
&gt;Hi! Apologies for slightly hijacking this comment, but it's related. When is VS 2019 coming to "Microsoft Azure Dev Tools for Teaching" (or Imagine, Dreamspark, OnTheHub, as it was previously called)? &gt; &gt;On Imagine, it used to be there on the day it was released, but I can't see it on the new (and worse) "Microsoft Azure Dev Tools for Teaching" portal. I followed up on this internally - they are working to add VS 2019 to educational platforms over the next few weeks.
&gt; one day That will never happen unless some people are willing to work on new systems *today*. &gt; there are dozens of different projects all going in slightly different directions and all of them competing with each other somewhat Sadly trial and error is the *only* way to do this. It is just not possible to take all people interested in the issue and force them to work on one solution. It will not work and even if it did, the outcome would be worse than working on many disparate projects.
Does anyone else hate the trend of header only libs? This looks really neat, but I really can't stand header only libraries anymore. After using a few header only Lua libraries that added a minute to compile time, it really gets annoying. And then in the end you can set up pre-compiled headers for your project, but that kinda defeats the purpose of ease of use with header only libs to begin with.
In Rust this is often used for the builder pattern. It really just simplifies the ability to create objects without having to specify a default for every value.
Maybe with dep. Glide was an unmitigated train wreck. Its developers kind of acknowledge this. There was a point where you could run a Glide config into an unrecoverable error state and needed to manually fix it. Made our build system patch hell. And then there's the fact that dependencies easily balloon into hundreds of megabytes, or even gigabytes, for small projects. Go's module system is otherwise quite good and one of the redeeming features of an otherwise utterly mediocre language. But until recently it wasn't hassle-free.
&gt;If all those people that are inventing their own build system would contribute to cmake we might have a widely supported, easy to use de-facto standard build system in c++ by now. That's like saying that people should spend their spare time in coding in projects they don't have fun with, instead of doing it in projects where they **do have** fun with. I could reverse the argument quite easily, were I so inclined as you to tell others what should do: if people would stop contributing to CMake and stop using it, we would have much better build systems to finally replace it with something else.
It's one possibility, but personally what I loathe about namespaces is their open nature. When the overload selected changes based on which file is included, it just becomes error prone.
Glad to see people seeing the consistent improvement.
I don't know enough about he Modules TS to know whether it might mitigate that problem.
That's exactly what @jhasse is arguing *for*. To summarize: - @markand67 criticizes the fact that xmake has built-in Qt support. - @jhasse mentions that without built-in support, there'd no Qt support, so built-in support is necessary.
I agree. I think there is an opportunity with the new modules spec to build a package manager that behaves similar to npm! I am actually working on a proof of concept now.
There are many things more complicated than ADL in C++ !!!
&gt; to pull out the C++ classes Chromium uses to represent elements on a web-page [Sciter](https://sciter.com) does that: [sciter::dom::element](https://github.com/c-smile/sciter-sdk/blob/master/include/sciter-x-dom.hpp#L129).
Or python.
Also, [http://tclap.sourceforge.net/manual.html](http://tclap.sourceforge.net/manual.html)
Copying from more deeply nested conversation: &amp;#x200B; One thing the occurs to me when thinking about (eliminating) ADL is that elevating namespaces to first class c++ constructs would offer an alternative to a large subset of ADL use cases. I haven't really thought it through completely, but something like the following provide similar functionality currently provided by ADL: namespace person { class Person; bool operator&lt;(Person const&amp;, Person const&amp;); } int main() { // Whereas currently std::map perhaps relies on comparing Persons with the '&lt;' operator using ADL... std::map&lt;Person, std::string&gt; addresses; } /// if namespaces existed as first class constructs... template&lt;typename T0, typename T1&gt; class non_adl_map{ ... /// something like this might be possible using declnamespace(T0)::operator&lt;; // Here T0 would end up as person::Person, and the declnamespace would resolve to person return val0 &lt; val1; ... } IIRC Stroustrup even suggested making namespaces passable as template arguments, but was outvoted at the time by those who though it would make c++ too complex. Does anyone who feels they have a strong grasp on ADL use cases have an opinion as to whether first class namespaces would cover them?
https://github.com/jamboree/jamboree.github.io/issues/1
Long Live C++!!!
I used tclap for a number of projects. It works well enough, but does not appear to have had any updates since 2011. With newer libraries such as clipp, I appreciate being able to use newer C++ features to build command line interfaces.
This is just a bit of fun. The IEEE has a different take (from mid 2018): https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018 And from Redmonk (2019): https://redmonk.com/sogrady/2019/03/20/language-rankings-1-19/ These put C++ at 2nd and 6th respectively.
I’m seeing a lot more excitement around c++ these days.
TIOBE is meaningless. I am inclined to auto-remove all such posts, whether positive or negative.
Okay, thank you very much! A step back unfortunately - this was much quicker on the previous Imagine portal. :-)
&gt;Optiver Nice talk in CppCon \[here\]([https://www.youtube.com/watch?v=NH1Tta7purM](https://www.youtube.com/watch?v=NH1Tta7purM)). I was pretty close to applying but then found something else. Might apply next year actually.
Python has keyword arguments though. [argparse](https://docs.python.org/3/library/argparse.html) is a good example to compare with this.
One problem that would not be solvable with this approach would be `std::reference_wrapper`. ``` // https://godbolt.org/z/o7zxkj namespace person { class Person {}; bool operator&lt;(Person const&amp;, Person const&amp;); } int main() { std::map&lt;std::reference_wrapper&lt;person::Person&gt;, std::string&gt; addresses; person::Person me; addresses.emplace(me, "me"); } ``` Presumably `declnamespace(std::reference_wrapper&lt;person::Person&gt;)` would be `namespace std`, right? But the namespace where `operator&lt;` is actually found, today, is `namespace person`. This is the problem also-not-addressed by https://quuxplusone.github.io/blog/2018/08/13/fixing-adl-field-test/ (see the UPDATE at the bottom of the page)
There is also a fork of Premake called Genie. Premake is seeing some nice active development now but a few years ago it wasn't so active and it wasn't clear if the project was dying or not so Genie was created. Too many build systems. I just want to code. Not figure out how to get these different build tools to work well with each other.
When is someone going to create the "Meta Meta Meta Make". A tool that will let me seamlessly use any of these build tools together in a single project so I don't have to figure out how to wire them together myself when I pick library A, B, C and they all use a different build tool.
If there is one type of libraries for which being header-only makes sense, it's the command line parsing ones. Think about how many times you're going to include this header.
Some suggestions: \- In the \`\`source()\`\` method, you are always cloning the default branch, I'd recommend to do the \`\`[self.run](https://self.run)("git checkout v%s" % self.version)\`\` to check out the right tag or branch \- The default in \`\` CMake(self, parallel=True) \`\` for parallel is already True, you could skip that. \- The \`\`self.run("cp -a %s/nana/include include" % self.source\_folder) \`\` reads weird, why do you need that? Probably you can avoid it and use the \`\`self.copy()\`\` from \`\`package()\`\` to achieve the layout you want. \- The \`\` self.copy("\*nana.lib", dst="lib", keep\_path=False) \`\` can be generally put as \`\` self.copy("\*.lib", dst="lib", keep\_path=False) \`\` \- Avoid doing \`\` rm -rf \~/.conan/data/Nana/1.6.2/ \`\` to remove. Do \`\`conan remove Nana/1.6.2...\`\` command. There is metadata and other state that won't be removed with manual \`\`rm\`\` \- The profile \`\`debug\`\` where is it? Maybe you meant \`\`conan create . user/testing -pr=default -s build\_type=Debug\`\`? \- You could leverage the \`\`test\_package\`\` functionality, so the consumer project (with Meson) is automatically called when you do the \`\`conan create\`\`. Nice job, thanks for posting.
What do your benchmarks against other common fast logging libraries say?
I appreciate the code review. All good points. Thank you.
cxxopts is also a quite famous one.
This totally hits the point. I don't want to have to compile / add to the build process yet another library for command-line parsing. Just give me a lean header please.
Totally true. I should rephrase it so it doesn't seem like I'm talking down the library, it seems really neat. Just a misplaced personal rant :)
If there is I don't want to know about it. When people ask me what I consider to be the most complicated feature in C++, my answer is how C++ resolves names. I substantiate my argument by pointing out that most inconsistencies between different C++ compilers is related to name resolution, so even the people writing C++ compilers don't fully understand how C++ is supposed to resolve names.
&gt; Presumably declnamespace(std::reference_wrapper&lt;person::Person&gt;) would be namespace std, right? Yes. True. I suppose the way ADL solves this is it searches all defined cast operators of reference_wrapper for `operator&gt;`?
Well, this got formatted very strangely. Thanks reddit?
Put 4 spaces preceding every line
Please post in /r/cpp_questions instead.
I don't see any thing about thread safety. I guess the state of the art currently in C++ logging systems is `spdlog` so maybe compare to that.
&gt;When is someone going to create the "Meta Meta Meta Make". A tool that will let me seamlessly use any of these build tools together in a single project so I don't have to figure out how to wire them together myself when I pick library A, B, C and they all use a different build tool. You can try the remote package manager of xmake. `add_requires("libuv master", "ffmpeg", "zlib 1.20.*")` `add_requires("tbox &gt;1.6.1", {optional = true, debug = true})` `target("test")` `set_kind("shared")` `add_files("src/*.c")` `add_packages("libuv", "ffmpeg", "tbox", "zlib")` [https://camo.githubusercontent.com/f2450894d57dd7e419e41e7e855ee11de02616fe/68747470733a2f2f786d616b652e696f2f6173736574732f696d672f696e6465782f7061636b6167655f6d616e6167652e706e67](https://camo.githubusercontent.com/f2450894d57dd7e419e41e7e855ee11de02616fe/68747470733a2f2f786d616b652e696f2f6173736574732f696d672f696e6465782f7061636b6167655f6d616e6167652e706e67)
Automatic differentiation.
If you want to start at 1 and not 0, change the initial value in your loop. Also as said by other commenters this is not the right sub for this.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bbfj80/new_to_this_failing_at_basic_task/ekik8d5/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Apologies, you're right.
Fair.
Jesus fucking christ, why not just use a git submodule? Manual copying of files from who knows when, with who knows what bugs that'll never be fixed is a god damn nightmare.
how do you do that?
Such as? The only thing I can think of is [std::memory_order](https://en.cppreference.com/w/cpp/atomic/memory_order), but unlike ADL 99% of C++ programmers don't need to understand it.
 [http://www.cplusplus.com/doc/tutorial/functions/](http://www.cplusplus.com/doc/tutorial/functions/)
On initial game launch you should put the start point in a variable, and just use that when needed.
Not clear what you are trying to achieve. DirectComposition/Direct2D + WS_EX_NOREDIRECTIONBITMAP can give you transparent windows. Yet also [the Acrylic](https://sciter.com/sciter-4-2-support-of-acrylic-theming/) if needed.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bbgpjt/how_to_go_back_to_last_funtion/ekiroxb/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Nana-test is exactly what I was looking for earlier today when evaluating switching from cmake to meson with Conan package dependencies. When listing sources in meson should I also list headers or should I just use the include command?
Thanks /u/MrMobster. I did a bench for the lookup speed about 10 days ago and my flat_hash_maps were slightly faster than Tessil's robin-map (using uint64_t keys and values). Since then I have improved the lookup speed a little I believe, but didn't run the bench again. However, while I think the Abseil's tables (and my derived phmap tables) are consistently fast, you may want to experiment with your own use case, as the results may vary depending on the size of the values, the quality of the hash function used, the table load_factor, and other factors.
&gt; Jesus fucking christ ... I'm an atheist. &gt; Manual copying of files from who knows when ... Where did it say I was doing that manually?
Here is a link I used when I found out how to set it up: https://stackoverflow.com/questions/44450218/how-do-i-use-bash-on-ubuntu-on-windows-wsl-for-my-vs-code-terminal
This kind of thing is the reason people say C++ is overly arcane. I'm glad we have wizards like Louis to handle these sharp edges for us in libraries like hana
I do not think it is decades away. I would say C++23-26.
So, something like Conan that handles building libraries and exporting the correct flags to use them to your project?
The guideline is better than your formulation because it presumes less. You're presuming you know *what will happen in the future*. Nyah... Some classes go together and stay small. In fact, that is better than them growing. The guideline doesn't say "don't move classes out of their first place and into a dedicated file(s) either.
beliebigegenauigkeitfließkommabibliothek You were missing a 't'
Yes but this isn't that hard. For example you can create a Qt application with CMake only with the config files provided by Qt itself. They provide macros to generate yourself moc, rcc et ui files with it. I never use CMAKE_AUTOMOC personally.
Hey, thanks for looking! Yeah, I’ve looked at spdlog but its a little bit overkill for my needs right now but it’s one of the considerations. I’ll make a benchmark against spdlog to satisfy my curiosity.
 template&lt;typename T, typename... Args&gt; SS &amp;&amp; fmt(SS &amp;&amp;ss, const T &amp;v, Args... args) { ss&lt;&lt;v; return fmt(std::move(ss), std::forward&lt;Args&gt;(args)...); } It's not correct, you will expect copy on variadic arguments when they are not moved, also you don't get any improvement on move stream, it should be template&lt;typename T, typename... Args&gt; SS&amp; fmt(SS &amp;ss, const T &amp;v, Args&amp;&amp;... args) { ss&lt;&lt;v; return fmt(ss, std::forward&lt;Args&gt;(args)...); }
But you can’t bind a temporary to a non-const reference. The SS object operates in the premise of juggling temporary object until it finishes consuming all arguments so it can then use its destructor to seek the stringstream to the beginning allowing reuse of buffer.
Ok, that's fair, i don't see it.
Yes, it's from the core guidelines
That would be awesome to know
Italy here. Same. I wonder why it's so difficult to hire as an external contractor (although the work relationship is afterwards just trust-based because they can fire you at any time).
You might want to have a look at [https://doc.qt.io/qt-5/qopenglframebufferobject.html](https://doc.qt.io/qt-5/qopenglframebufferobject.html) and related classes ;)
C++ truly is the most complicated language in regular use. When you get into templates, you go from thinking, "neat, generics" to "why does this article read like my 2nd year university math textbook?" It's only been 15 years of C++ for me and I wouldn't want to screw around with this stuff.
I suppose some of us use `printf` without realizing that it calls `localeconv`, but it's not a problem to me, at least.
I'm afraid that removing ADL may lead to silent breakage. E.g. template&lt;class T&gt; T real(std::complex&lt;T&gt;&amp;&amp; c) { const std::complex&lt;T&gt;&amp; ref = c; return real(ref); } currently calls `std::real`, but may become an infinite recursion if ADL is removed. It's not always possible to detect this kind of error at compile time.
You are mixing up implementation (which users don't care and shouldn't care) with actual semantics of their code (which they very much care, if only to avoid surprises). And, by the way, AFAIK nothing forces the implementation of `printf` to explicitly call `localeconv`.
This can be easily diagnosed by a compiler as long as ADL is turned on. That's why I said first deprecate and then remove.
What makes it overkill?
If I understand correctly xmake is acting both as package/dependency manager and build system. &amp;#x200B; I think in general I prefer the more layered approach, e.g. conan for dependency management, cmake for actual building, and some interop between the two to make things smooth.
But I prefer built-in integration. xmake == cmake + make + conan Users don't need to consider installing and learning so many tools, just install a single, non-dependent xmake. And we need only run ```console $ xmake ``` It will be able to do all the work well
Yes I see the advantage, I guess mine is a unix philosophy kind of thing
1. `printf` is required to respect the current locale 2. users can modify the current locale by mutating the object pointed by `localeconv()` ISTM that it does affect the actual semantics.
Hmm, that means the compiler needs to remember how the function name is found by the lookup. It seems actually doable, but I don't know if it is easy.
I totally agree about having short formulations. Less is often better. I simply think the wording of the rule can be improved, and I don't think the reason to enforce this rule (as it is worded) is strong enough because it doesn't consider the dependencies. This rule is probably here to remind us that we're not in Java and we're not obliged to use a class per file. Again, I totally agree with it, but again, I think it should be expressed in a different way, or split in more rules.
I'm having trouble following that. What does "associated entity" mean? Google only helped me to find cppreference about associating names with entities, am I even reading up on the right topic?
Nice! Thanks for info
Nono. You can not use ADL and use namespace. `using namespace std;` still uses namespaces, after all.
Some feedback: * It seems strange to me that you have included examples of a file and network logger that do the same thing as the console logger. At first I thought this was because your API supported only three types of loggers and you need an implementation of each for it to work, but actually it takes a list of arbitrary loggers, so I don't understand why you need to have three of the same examples. * I don't like the printing API. C-style standard is printf formatting. C++ style is the shift operators. In your library you have mixed the C-style of variadic arguments but without the format string, which I think will be very confusing, especially to readers of your code who have never used your library before. * Given your design of multiple log targets inside one log class, it seems rational that you might want the ability to filter log events beyond simply the severity of the events. Maybe an optional user-specified bit when logging that corresponds to a bitmask set on each logger. This way, you could have a logger that listens only to certain events.
If you have ever used `std::begin` or `std::swap`, then you are a black magician too.
Yes, but the blending mode is incorrect. (That's what it draws.)[https://imgur.com/TRNfblb]
Does it prevent you from using it *within the context of this function*?
You mean during overload resolution? Don't those two things (identify all candidates and do the resolution) right after another?
you could inherit from tuple. has a lot of pros and cons
The definition is provided by the standard. For class types, the associated entities are the class itself, the class that it's a member of (if it is a member of any class), and its base classes, both direct and indirect.
I agree. also you'll compile a lot faster
even with optimizations the binary may well be bigger.
Well researched, although a bit more "standardeze" terminology then perhaps necessary. For example, ADL is immediately understood if defined in simpler terms as (for example) Nicolai Josuttis states: &amp;#x200B; &gt;You don’t have to qualify the namespace for functions if one or more argument types are defined in the namespace of the function. &amp;#x200B; Lastly, if anybody cares, what do I really think of ADL? ADL was born out of an urgent need to make streams work with namespaces. My conclusion is more or less the same as Andrew Koening implies at the end of [his crucial text](http://www.drdobbs.com/cpp/a-personal-note-about-argument-dependent/232901443): There was not enough time to devise a better solution.
&gt; the order of different global/static variable initialization is undefined The other commenter that mentioned the singleton pattern is correct. A singleton is really just a fancy global variable, but that is exactly what you want. In fact, the specific way in which they are fancy is that the guarantee initialisation and destruction order, which is exactly what you're asking about. The easiest way to create singletons is using a local static variable in a function. For example: foo&amp; get_foo_singleton() { static foo my_foo; return my_foo; } Everywhere you would've directly referenced the global variable, you should instead call `get_foo_singleton()`. This will construct the object the first time it's called, regardless of which translation unit it's called from, so there's no issue with initialisation order. It will be destroyed at the end of `main()` along with other singletons in the reverse sequence to construction. This means that you can even construct one singleton in terms of another: bar&amp; get_bar_singleton() { static bar my_bar = get_my_bar(get_foo_singleton()); return my_bar; } Of course, rather than being explicitly referenced as a function parameter, `get_foo_singleton()` could have been called indirectly if it is referenced inside a `bar` constructor. It all still works. &gt; using static/global in multithread will get in trouble As of C++11, it is guaranteed that function-local static variables are initialised in a thread-safe way. For example, in the above snippet, it is guaranteed that `get_my_bar()` will only be called exactly once, so you can safely call `get_bar_singleton()` from multiple threads. If you want to modify a global variable or a singleton in a thread-unsafe way from multiple threads, then of course you will need to do locking, but that has nothing to do with their globalness. Depending on your situation, C++11 `thread_local` variables may also be what you want. &gt; share static/global variables among DLLs Admittedly, this does not work so well. But that's Windows' fault, not C++'s. In C++, global and function-static variables should be destructed in the reverse order that they are created. But Windows has a separate `atexit()` stack for each DLL, so the function-static destructors will effectively reshuffled so that they are grouped by DLL rather interleaved correctly. (This is according to my quick reading of the documentation, so don't take my word for it.) Personally I try to avoid DLLs if possible, using static linking instead. Unless you are dynamically loading something with `LoadLibrary()` (e.g. as a plugin system) there is rarely a need for DLLs, and they just add complication. Mind you, it's a good idea t avoid global variables that rely on other global variables being constructed (or not yet destructed)! Given that global variables (even singletons) are generally bad practice, maybe you should just avoid them, especially if you need to mix across DLLs. The fact that global variables are bad coding practice to begin with is probably why you see relatively little call to improve them. &gt; especially for the static variables defined in header file will get in trouble Do you really mean static variables *defined* (not just declared) in header files? If so, you end up with a separate object in every translation unit (i.e. `.cpp` file) that includes it. This is rarely what you want. If you do, the same rules construction and destruction apply, but be aware that it is the translation unit (i.e. `.cpp` file), not the header file, that is associated with a particular DLL or main executable.
For me somethink like the following looks pretty expressive: for (const auto&amp; row : db(select(foo.name, foo.hasFun).from(foo).where(foo.id &gt; 17 and foo.name.like("%bar%")))) Why do you think it is lacking in expressiveness? Any examples?
I should confess. This is my first reddit post and getting comments like yours is really invaluable. Ok, to my answers. * The file and network implementation are intentionally left out. * I have the same sentiment, but my main driver to leave it this way is that I want to use this in a low-latency systems. I was thinking the formatting style doesn’t really outweigh the performance gain? But not sure about this one. Its just that parsing the string and applying formats have to be paid eventually. Also i want it to be very small and fast. * Yeah, never really thought about that. That is actually a must have thing for loggers. I’ll consider it Thanks!
&gt; ADL was born out of an urgent need to make streams work with namespaces. AFAIR, ADL is available since 1985, unlike namespaces.
Agree it’s meaningless from the technical perspective. Nevertheless it‘s a positive thing for C++ in terms of public image
Yes, finding Qt5 is provided by Qt upstream. However, CMake has built-in knowledge of moc, uic, and rcc which leverage the targets and variables offered by `Qt5Config.cmake`. We try to push back on new Find module contributions because the maintenance burden is very high. Especially when upstream starts providing `config.cmake` files eventually and CMake needs to update to be compatible. Just look at FindHDF5 having to deal with `hdf5-config.cmake` as well as offering its old behaviors at the same time.
I think you're remembering CPS https://github.com/mwoehlke/cps
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bblu9j/help_cmath_trigonometry/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
You don't have to include header files in your sources list but I do anyways so there's a single source of truth for the project file manifest. I currently use one sources list and intermingle headers. &amp;#x200B; `include()` would be the wrong tool for the job, that just sources another meson file, `include_directories()` , is probably what you're thinking of, which adds that to the -I path. Looking at other large open source projects for meson usage is very helpful. Example, [https://github.com/systemd/systemd/blob/master/meson.build](https://github.com/systemd/systemd/blob/master/meson.build) &amp;#x200B; Meson has a lot of build targets that are not easily discoverable without reading the source code, or using tab completion. I use `nana-test/Makefile` as an interface to those features like `coverage` and `scan-build`. I know I will forget and the next guy may have no idea they exist. &amp;#x200B; You'll have to enable coverage via the conanfile, just uncomment the the args variable. &amp;#x200B; It's a little annoying that I can't write functions in meson. I'm concerned that in the long run, shops will just start modifying meson itself, which is pretty easy to do, but still. I suppose it creates enough friction to coerce you to return your changes to community instead of carrying a perpetual fork of the build system. At the same time, very large projects like systemd are doing just fine with the inline approach and are focusing mostly on organizing the project's executables, libraries, and tests.
No problem! And remember that my feedback is just my opinion. Other people might feel differently, especially on the second point. I dislike the C++ stream API a lot so I'm a little biased in favour of the printf style. Regarding your point about performance - I don't know how the underlying implementation works in the standard library but I do know that format strings can be resolved at compile time will full type safety. The `fmt` library does this. I know that the C++ stream API has notoriously poor performance, too.
Will add, thank you :)
I sincerely hope I'll never have to write code where this kind of stuff is a concern. And I hope the same for you all.
I'm not sure, how ADL is supposed to have any meaning without namespaces.
Wouldn't it be simpler to just qualify the function call and disable ADL that way?
Yes, that's exactly what I don't like in my own project. A lot of boilerplate code, that's why I am (probably going to) redesigning it. About sqlpp11, it was my first impression, and of course I might be wrong, being biased by my own project. I'll give sqlpp11 a chance for sure.
I'm not telling anybody what to do. I'm just stating a (very unlikely) `consider what if ...` scenario. And personally I don't think your reversed statement would be correct (Sprinkling all the man hours invested into cmake accross a dozen different build tools would have much less effect than collecting the man hours currently invested into a dozen different tools into one single tool), but I don't have any hard evidence for it either way. Anyway it was a quick, not entirely serious comment and I should have added a simley or two.
There was not enough time, but the obsession with stream operators might have precluded the question of whether they were worth it.
Yes, but someone else might not qualify the function call.
I agree with your point but your example is flawed. ;-] This can't recurse as `c` is a proper rvalue reference, not a forwarding reference, and `ref` is an lvalue.
I guess it offers a lot of features that I may never use in my program. But for big projects, I could see spdlog as a great component.
Looks nice. Has anyone done a comparison with boost spirit x3 (e.g. how does the code for a particular grammar look, how do compile and run times compare)?
Isn't this an internal helper function? Also, someone else would probably operate in a different namespace, so qualification would be the default anyway (unless the person deliberately uses `using namespace` or deliberately decides to use ADL).
I liked gradle a lot when I had to use it for a Java project a couple of months ago. I like it better than the XML hell you get into with Maven.
There are a countless amoumt of ways to optimize a program (and most of them will never even apply to you) so a complete guide of optimization techniques is basically impossible. Not to mentipn that optimizations are dependent on such a wide myriad of variables that if you want anything more than the most generic of advice, you're going to have to specify exactly what you want to optimize. If you want to optimize something specific like memory allocations, template compile times, or file access, people can give you much more meaningful advice. That being said, the closest I've ever seen to what you describe is [here](http://www.agner.org/optimize).
Protip: use -O3
As tip, knowing C++ also means that you can make use of C++/CLI and C++/CX (now C++/WinRT), to easily create a wrapper class for your C# code instead of manually writting tons of P/Invoke attributes.
Definitely my preferred language. With c++20 it will almost be finished as well, so that's a plus :-)
Can't wait for C++20 ! Modules FTW !
Cool ! Make sure you learn the modern post C++11 C++, it's awesome !
Though I don’t use it much at all anymore I see C++ as close to the perfect language to teach new programmers with. The move to Python and other “easy” languages for intro comp-sci has been a big mistake in my opinion. This from somebody that turns to Python first these days.
If you know C++ inside and out, every other language becomes easy mode. :D Even if you're primarily not a C++ developer, having a deep understanding of C++ can really help your programming career and forces you to think a little deeper about the high level code you're writing.
Because it's easier to integrate, it doesn't require you to use the build system the author used to build it. Which is the main reason people like it.
Could you elaborate? I might take your arguments for future "discussions" ;)
Wait, c and c++ are concidered old and out of date? Well that's news to me! I almost exclusively program in c and c++!
Before optimizing anything, you should be sure if your "optimization" is worth. If you find a bottleneck and you are able to measure it, then optimize. So your question should be: is anyone aware of a list of tools that can measure bottlenecks? In that case, you can check valgrind and especially cachegrind and callgrind.
It basically boils down to whether you want to teach computer science or computer architecture. A good programmer needs to know both, but it’s really hard to teach them at the same time. A language such as scheme or python is good for the former, but horrible for the latter. On the other hand, you could use C, C++ or even assembler to teach a computer science class (and until recently that fairly commonplace) but as an absolute beginner you are likely to drown in the details before you get the big picture.
It basically boils down to whether you want to teach computer science or computer architecture. A good programmer needs to know both, but it’s really hard to teach them at the same time. A language such as scheme or python is good for the former, but horrible for the latter. On the other hand, you could use C, C++ or even assembler to teach a computer science class (and until recently that was fairly commonplace) but as an absolute beginner you are likely to drown in the details before you get the big picture.
Actually on lunch at the moment, it would take to much time to go into detail. In short it comes down to programmers needing to understand how computers work and how their tools work.
\*\*Company:\*\* Akuna Capital \*\*Type:\*\* Full time, Internships \*\*Description:\*\* Akuna Capital is a young and booming trading firm with a strong focus on collaboration, cutting-edge technology, data driven solutions and automation. We specialize in providing liquidity as an options market-maker – meaning we are committed to providing competitive quotes that we are willing to both buy and sell. To do this successfully we design and implement our own low latency technologies, trading strategies and mathematical models. Our Founding Partners, Andrew Killion and Mitchell Skinner, first conceptualized Akuna in their hometown of Sydney. They opened the firm’s first office in 2011 in the heart of the derivatives industry and the options capital of the world – Chicago. Today, Akuna is proud to operate from additional offices in Sydney, Shanghai, and Boston. Our Developers are motivated by challenging technical problems in the trading industry and endless opportunities for innovation. Working in the nano-second space of our custom low latency trading platform, we are finding creative ways to use the latest tech while building new tools and implementing advanced solutions that meet the needs of a competitive trading environment. As a technology driven company, our talented Developers advance beyond typical Software Engineers by working on a range of greenfield problems. We do not sell our software and our collaborative vetting and peer-review processes give us the ability to achieve daily software releases. \*\*Location:\*\* We are hiring in Chicago, Boston, Shanghai, and Sydney. Akuna is looking for C++ Developers in all of our office locations and at all levels, including interns, juniors, and experienced candidates. \*\*Remote:\*\* No \*\*Visa Sponsorship:\*\* Akuna offers sponsorship to future employees on a case-by-case basis. \*\*Technologies:\*\* At Akuna, our development teams use the language(s) best suited to their work. Our C++ development teams work primarily with modern C++ (i.e. C++ 14, C++ 17 and beyond) on Linux. Akuna’s C++ teams work on applications where C++ is used for computational heavy-lifting and for applications that have timing-critical, low-latency processes such as trading strategies. C++ provides the flexibility and ow-level control that our developers need to get maximum performance out of multi-core, super-scalar, processors. \*\*Contact:\*\* Please apply directly to the roles you are interested in being considered for on our [website](https://akunacapital.com/careers). Below are some direct links to our open C++ roles: * [C++ Senior Developer ](https://grnh.se/9e43fa031)\- Chicago * [C++ Developer ](https://grnh.se/fwy0pb1)\- Chicago * [Performance Engineer ](https://grnh.se/293c1fea1)\- Chicago * [Quant – Market Microstructure/ Low Latency Strategies ](https://grnh.se/b708ed5f1)\- Chicago * [Quantitative Developer ](https://grnh.se/2ddae6751)\- Chicago * [Junior Quantitative Developer ](https://grnh.se/00d2c8c71)\- Chicago * [C++ Senior Developer &amp; Team Lead ](https://grnh.se/251fd9f71)\- Boston * [C++ Developer ](https://grnh.se/9cc92d341)\- Sydney * [Junior Developer – C++](https://grnh.se/cbb5822a1) \- Sydney * [Development Internship – C++ ](https://grnh.se/65a80d271)\- Sydney * [Quantitative Developer ](https://grnh.se/47343e141)\- Sydney * [Junior Quantitative Developer ](https://grnh.se/51d714621)\- Sydney * [Quantitative Development Intern ](https://grnh.se/5f6b45681)\- Sydney * [C++ Developer ](https://grnh.se/a5264c601)\- Shanghai * [Junior Developer – C++ ](https://grnh.se/cb21a1aa1)\- Shanghai * [Development Internship – C++ -](https://grnh.se/0f2f2d151) Shanghai * [Quantitative Developer ](https://grnh.se/ed5000461)\- Shanghai * [Junior Quantitative Developer ](https://grnh.se/2f47f1e71)\- Shanghai
IMO C++26 is when it will feel really complete for me. Assuming we get more reflection in 23, then Metaclasses for 26, We'll be theoretically free of code generation scripts in other languages for things like data formatting protocols (e.g. protobuf).
This is not quite a complete list of optimization techniques exactly. But it does cover some of the more obscure techniques in Programming that you may be looking to use. [https://github.com/Manquia/Distillery](https://github.com/Manquia/Distillery) If you have any feedback it would be much appreciated as I am trying to refine and add topics that I've missed.
I think it boils down to whether you want to teach programming bottom up or top down. If you want to start with the basics and the details, then it's a good idea to start with something like C or C++, but if you want to start at the top level and what you can achieve.
You can use VTune it will show to your perfomance bottlenecks. https://software.intel.com/en-us/articles/intel-vtune-amplifier-tutorials
Not sure I understand what do you mean by blending mode there. It simply draws [dst-over](https://www.w3.org/TR/2009/WD-SVGCompositing-20090430/#containerElementCompositingOperators) Instead of white notepad window put there some window with black content.
You can have different performance problems. You should start from algorithms optimization. Next multithreaded problems, io. Then you can optimize work with memory. And in the end microarchitecture optimization. It can be work with cache, instructions, code alignment, branch prediction and so on. VTune is a very good tool, it can give you advice and hightlight problems.
I think there's a misunderstanding; by "not to use namespaces" I meant "put everything in the global namespace". If everything is in the global namespace, then ADL is unnecessary since all it enables is consider "other" namespaces than the current. However, the cure may be worse than the disease...
I doubt it. Template specialization, for example, require the ability to re-open a namespace to add a specialization. If in module C I specialize a template type of A for a specific type of B, there is no possibility that other users of A and B can magically divine that they need to depend on module C to get the specialization. Other languages (Haskell, Rust) have an Orphan Rule to prohibit this kind of stuff, and guarantee the coherency of specializations: either everyone uses the specialization, or nobody does.
C++ is a good language to know because it's HOW COMPUTERS WORK. It's not always the right tool for the job but C++ forces you to understand what's going on under the hood at a level sufficient for 99% of things you encounter. Understanding why things are optimized the way they are, why vectors copy the whole arrays (CPU cache lines and "read ahead") is what makes you an excellent engineer; not a programmer. You don't always need the granularity and control of C++ but when you're programming in another language, you understand the cost/benefit of your decisions and can make an engineering decision knowing all the facts. This, I think, is what separates engineers from programmers. Programmers make computers do "what" they want. Engineer also consider the "how".
also "programming" is considered to be the same thing as making websites
I agree, C has save my educational journey as an embedded systems student . I love C and it's got to be the easiest to get.
I agree to a huge extent. Learning C has been an enjoyable experience so far and it taught me more than Python. I am an embedded systems engineer.
Don't know if that applies to Haskell. I knew C++ somewhat well before picking up FP, and it was still very foreign.
I am very sad to hear that C/C++ are getting old and it seems that there is a huge push to "easier" languages . Imo learning C/C++ really helps to cover fundamental concepts and C is the great choice for embedded systems
your comment hit hard on me ! I think thats what many people think nowadays
What skill or discipline, can you point to where the progression is top down? Medicine: learn organic chemistry first, work your way up from there. Sports: learn the rudiments of the game first, work your way up from there Music: learn the rudiments first, work your way up from there Let's think about your concept of top down learning from the point of music: You'd have a budding pianist start with Chopin's Étude Op. 10 No. 4 and then figure out how to play scales. From medicine: you'd have a budding surgeon start with removing a brain tumor and then learn anatomy. From Sports: you'd have a hockey player start out in the Stanley cup and then learn how to skate.
Look up arguments for practice vs theory.
learning to program c++ vs say python or js for a newb is kinda like to start out in the stanley cup lul
I don't necessarily agree. I think at some point a programmer should learn C (or C++), but I don't think that starting from something a little less overwhelming like Python, where things move a bit faster (in the sense that it's easier to get a taste of what programming can do), is a mistake.
Learning C++ with Bjarne Stroustrups book was the first time I didn’t abandon a tutorial immediately after the first couple lessons. I won’t chalk that entirely up to it being C++ but I always do better when I feel like I am embarking on a meaningful path of learning an entire body of knowledge from a tradition of inquiry versus a quick and dirty intro to a scripting lang.
I disagree. C is probably the closest thing to portable assembly language. C++ has too many higher level constructs IMO. Just the concept of a class alone, as an example.
Functional is a whole different universe. Functional programming is so high level that it's more about figuring out how to describe the solution to your problem in mathy terms than it is describing the sequence of steps to take to solve the problem. I suppose that why functional and imperative programming are considered different paradigms.
But... The speed...
No, `hana::type&lt;T&gt;` is not an internal helper function, but a public type. Suppose I have my library in `namespace animals` and I have a `cat` type in that namespace. Suppose I also have an unrestrained `template &lt;typename T&gt; std::string speak(T&amp;&amp; animal)` inside `animals`. Now imagine a user of my library wrote their own entirely different `sound speak(hana::type&lt;animals::cat&gt;)` in their own namespace. With regular ADL, `speak(hana::type_c&lt;animals::cat&gt;)` will also find `animals::speak`, not just the one the user intended. With Hana's protection, `animals::speak` is not found by ADL.
fair, but if you just build it once then you're set! you don't even necessarily need the same build system header only means bigger binaries too. ever tried using a node module? it's not even c++ but it's the same concept taken to the extreme
you can write c++ this way... and even should, right? isn't that the point of zero and negative cost abstractions?
optimization just means not doing something the slow way. since there are always slower ways to accomplish the same thing, it's clear that there are an infinite number of optimizations
sounds like c. this is one of the pleasures of c: you can usually tell from the callsite what changes. the function can't decide it wants to take a reference either -- you have to pass in the address of something if it might change. or you could pass a const ptr
In computer science, you typically start out as a user, then you turn into an implementer. You could approach programming the same way, and start out by calling a lot of ready made functions without needing to be able to understand all the details of how it works. They say that C comes without batteries. Some people might want to play around with batteries to be motivated enough to figure out how to make batteries.
I still get confused sometimes and accidentally call it Koenig lookup. I also still call abdominal thrusts "the Heimlich".
&gt;C++ is a good language to know because it's HOW COMPUTERS WORK. https://words.steveklabnik.com/should-you-learn-c-to-learn-how-the-computer-works
Especially if you've also never used `std::end`.
Wrong subreddit, this is C++. Different language.
Initialization comes to mind.
That's like saying that the patient of a brain surgeon, is beginning the process of learning neurosurgery because they are experiencing it. That is ridiculous. If a person has brain surgery and the results inspire them to become a neurosurgeon. They don't begin the process of learning neurosurgery until they enroll in pre-med and start learning organic chemistry. Likewise, if someone hears Esperanza Spaulding playing bass guitar and is blown away and inspired to learn bass, they haven't actually started learning bass until they begin learning scales. And so it is with computer science. If you begin (say) playing a game and getting interested in programming, you don't actually begin learning programming until you begin to learn how to program in machine language. Once you understand how the machine you are programming works, you then have the fundamentals (the rudiments) of software engineering and you can work your way up from there.
I know that `hana::type&lt;T&gt;` is not a helper function. It is not a function at all. But the problem is not that type is found by adl, but I assumed that `helper` represents some hana internal helper function and the problem is that that unqualified call to `helper` might instead resolve to some user function with the same name that is in the same namespace as `T`. So either helper is called from within hana and one could just qualify the call or it is called by the user outside of hana and one needs to qualify the call anyway to find it.
Sorry I meant both languages for embedded systems
It's because programmers are getting dumber and they can't solve problems without being handheld all the way. Look at Rust, for example, and how many of those programmers would be running around like headless chickens without that cargo thing.
Yes, lots of people divide programmers into front-end, back-end, full stack, and generalist, with generalist being the only non-web tech stack.
&gt;Look at Rust, for example, and how many of those programmers would be running around like headless chickens without that cargo thing. gave me a chuckle but it's true though
And apparently that idiocy is starting to rub off onto the C++ community one bit at a time (see: modules). God knows what else is in store over the next decade.
Knew it , that link had to be Agner Fog's website!!
C++ is an amazing language for functional programming. I'm not a functional programming puritan myself. I think every tool has its time and place, and FP is no exception. But that's what's so beautiful about C++. If you wanna do OOP, do OOP. If you feel like a section of your application needs FP, use FP. I do agree that some of the concepts might not translate well to some less popular languages like Haskell though.
C++ template metaprogramming is basically writing in a shitty verbose functional programming language, so yes.
Please refer to the source link in my top comment. I'm using \`WS\_EX\_NOREDIRECTIONBITMAP\`, but then I \`CreateSwapChainForComposition\` which could only use \`DXGI\_ALPHA\_MODE\_PREMULTIPLIED\`. \[Here's another link\]([https://imgur.com/4m8XhCq](https://imgur.com/4m8XhCq)) showing the problem. Even though I'm setting #0074FFFF for FrameBg, it still shows underlying visual studio window. So I guess I need another API for that. Layered windows maybe?
The idea here is that precompiled headers trade space for speed. You can change the setting or disable AuotPCH using the C\_Cpp.intelliSenseCachePath setting as the post indicates. We are still accepting feedback, so looking to get more information on your experience. This thread has been our central place for gathering opinions - [https://github.com/Microsoft/vscode-cpptools/issues/3347](https://github.com/Microsoft/vscode-cpptools/issues/3347). You can also see the responses by @bobbrow and @sean-mcmanus that detail our design decisions
He knows.
thx, also there is [cppgir](https://gitlab.com/mnauw/cppgir) which is a tool to generate GTK binding.
How about driving? Pretty much everyone does it every day without understanding the fundamental principles that underlie the automobile itself. Later on, if something in the car breaks, then people may become interested in how to fix it. Or if their oil change is due, then they can try to do it themselves. They can drill down progressively into the inner workings of the car from them on. No one tries to understands the firing order of their V6 before learning how to drive.
I’m 32, i’ve been to Uni and completed a degree in Professional Broadcasting but out of not really knowing what i wanted to be, i’ve always found programming interesting but always thought it was beyond my intellectual range, that said i picked up a book 2 weeks ago on learning C++ and have barely put it down, it’s awesome, yes it’s hard having no understanding whatsoever when i started but it’s starting to click, seriously amazing thing to study, wish i’d have started 10 years ago but there we are
It's 2019 - if you aren't writing things for **WEB-SCALE**, you're a dinosaur.
The are some vocal high-level-only language advocates that love to trumpet about how C, C++ and ASM are dead end languages, but with Moore's law effectively dead now, the trend toward more highly optimized code running in datacenters, on mobile, embedded and IoT devices, they are still the right tools to solve many difficult problems. Ask yourself, what language do they use to implement your favorite operating systems, compilers and programming language runtimes? I'm not saying the answer is 100% C or C++, but the fraction is pretty damn high and its not because those project's creators were stuck in the past.
Thanks for the info. I will definitely give it a try. I think that the most interesting thing about Swiss Tables is how it sidesteps all the research that has been done in past years about making open addressing fast. Double hashing, hopping heuristics, who cares about that if you can just check 16 slots at a time? Sometimes brute-forcing just works :) The interesting thing about the Swiss Tables algorithm is that it compl
Avoid unnecessary work.
Ahh, I see what you mean now. `helper` is user code, not Hana code.
I disagree with the last part of your argument. First of all I'm nothing but a hobbyist as my profession only involves superficial amounts of programming, if that. When I first got into programming I played around with languages like Python and JavaScript but didn't really learn much other than to copy the code I was given and combine the pieces I was shown. I eventually decided that I wanted to learn something more powerful and flexible so I picked up a copy of Jumping into C++ and it's like a whole new world opened up. I had tinkered with Java before so OOP was nothing new to me and pointers, references, and manual memory management weren't as hard as people had claimed they would be. But it want as hard to get into as people think because I found that you can stick to the higher level features of the language until you learn enough to delve deeper. With interpreted and VM languages you can't really do that. So I personally think C++ is a perfectly fine teaching language. I certainly learned more from working with it than I did from anything else and other than 2 CS courses in college I'm completely self taught.
well idk for me i used Qt for long time very mature not that heavy if you install only the modules you need and if you didn't find any gui system that suit you you can create your's using SDL well god help you with that
&gt;What skill or discipline, can you point to where the progression is top down? Any sort of engineering. It's called abstraction. I agree with you that every developer should eventually learn computer architecture and memory management, kind of like every electrical engineer should eventually learn semi-conductor physics, every mechanical engineer should eventually learn classical mechanics, and every quantum theorist should eventually learn mathematical analysis. But the python programming environment has become sophisticated enough that a developer doesn't *need* to know how everything is working under the hood. It will help, obviously, particularly when it comes to writing efficient software, but most python applications don't require the sort of hyper-efficiency that C programmers are accustomed to dealing with. This said, if I want to teach a beginner functions and looping through an array, I'm not going to start lecturing him on rvalues/lvalues and pointers right out of the gate. Your argument that every developer should start with something like C or C++ is biased because it's *your* niche. If we really cared about the ground up approach, why not start from assembly in a CS101 class? In fact, have all the freshmen sit and look at machine code for a semester; don't let them near a function till they are at least two years into school. Incidentally, this is what physicists did to keep quantum theory locked away in the ivory tower that is academia: they shrouded the entire theory in obscure notation that requires years of study to crack. Eventually, once you're "in the fold", you discover that it's the same math used in a standard 300 level physics class. The CS field would never stand for this because anyone can start programming, today, from his computer. Not so with physics: students are told they *need* to do all this prerequisite math and physics before touching a quantum mechanics text. And, unlike CS, you can't "do" physics till you get the blessing of academia, so there's no reason to believe otherwise. Yet, back when I was a quantum theorist, as an experiment I successfully taught my brother basic QM when he was in highschool and had only taken calculus, by supplementing his background with the relevant linear algebra. &gt;They don't begin the process of learning neurosurgery until they enroll in pre-med and start learning organic chemistry. I agree. I think the way medical students are educated is stupid, considering that most surgeons are glorified plumbers. The only one in the operating room who needs to keep track of all the variables is the anesthesiologist, but, as an academic discipline, medicine suffers from the same problem as physics. These are dissimilar to music or sports, however, since those rely on *movement patterns* which cannot be abstracted away. (The theory can be, though, which is why an NFL quarterback doesn't need to understand the physics of movement and a musician doesn't need to know harmonic anaylsis.) It is the difference between a *physical* skill, which requires a strong foundation, and an *intellectual* one, which allows you to abstract away the details. You can be a great electrician without knowing the first thing about Maxwell's equations, but I would not trust an EE to do the wiring in my kitchen.
You can write functional C++ but C++ doesn't have a type system that's well suited to working with the kinds of higher level abstractions that make functional programming powerful. Rust takes inspiration from functional languages but even it lacks the power of a functional-first language.
A lot of math is taught by gospel first, with proofs and justifications coming later. For example, it took until college for a teacher to explain why negative powers work the way they do instead of just drilling it into my head to make the exponent positive and then take the inverse.
Drivers don't claim to be mechanical engineers simply because they can drive the product of a mechanical engineers work.
I only skimmed an article about modules but it looks like c++20 is just python now. Is that what is happening? And follow up: why?
1. Calculator with menu, ask the user for 2 numbers and the operation 2. If you can use C++17, use std::filesystem and print to screen a table with contents like filename, fie extension, file size 3. Create your own implementation of std::vector and std::map 4. Make a Library application, where someone can manage a list of books. * Book has title, author, editor. * can find book by title, author or editor * insert/delete book * print list of books sorted by title, author or artist * load/store list from/to a file 5. Calculator again, but this time the user inserts an expression like `1+3(44/21)^3`. You can implement any operation you want, start with a simple addition and then add more.
Abstraction has absolutely nothing to do with how you learn to program, it is a tool used once you have obtained the skills of a programmer. Of course, once you are a programmer you might code at a high level of abstraction, but that is a tool for productivity, nothing more, it has no bearing on how you became a programmer in the first place. Likewise, professional musicians don't compose music using rudimentary scales, they use far more abstract constructs.
C++/CX and C++/WinRT are completely different things.
I'll give these a shot, I haven't learned the usage of vector and map yet, but I'll do the other ones for now, thanks \^\^
You aren't a mathematician until you understand how negative powers work, right?
Point 3 is important because data structures and algorithms are needed for everything
Yeah I know, currently I'm taking an online course of C++, structures will be the next lesson
\&gt; It's because programmers are getting dumber and they can't solve problems without being handheld all the way. What a stupid comment. You do understand that different languages have different development times, defect density and levels of comprehensibility? Just because you get off on writing ILP assembly doesn't mean businesses should do the same. It's not a fucking ego contest. &amp;#x200B; How people form such misguided opinions is beyond me.
It's all about where you draw the line for necessary complexity. Would you start teaching someone piano with Chopin? Obviously not. But you also wouldn't start by teaching them about acoustics and harmonics and how the length of a piano wire relates to the sound it makes. The whole point of the keyboard is to be a convenient abstraction on top of all that and let you concentrate on playing music. The goal in teaching any skill is to find a good entry point in all the levels of complexity and abstraction, where a beginner can grasp what they need to do and feel motivated to do it. There's almost always going to be more detail they can learn or a simpler tool they can use.
So you plan on writing compilers for Ada, JavaScript, Lua, Python, Forth, C, Rust and Haskell? I imagine you have your work cut out for you. I noticed you didn't include C++ in the list, though you did include C++ in the example -- writing a C++ standard-compliant compiler from scratch takes man-years of work.
Introduction to High-Performance Scientific Computing, http://pages.tacc.utexas.edu/~eijkhout/istc/html/index.html.
Agreed, this is just like the driving/mechanical engineering example above. The problem I have is with someone driving a car and claiming that means they have begun learning to be a mechanical engineer (which I have never seen anyone do btw, which is why I don't think people should do that wrt software engineering). There are two different disciplines here, if you drive a car you *have* begun the process of learning to be an F1 driver (although you may never achieve that goal, learning the rudiments of driving *is* a prerequisite toward that goal) you have not, however, begun to learn how to be a mechanical engineer (not in any capacity whatsoever). The original point I am disputing is that using computer software is a first step in learning the discipline of programming, it is not. Being a user who as part of using some software might need to write some scripts does not make you a programmer any more than a driver reattaching a loose belt in the engine bay makes them a mechanical engineer. My original point that all professional disciplines are learned from the bottom up stands.
Yeah, but Rust pattern matching switch gets a lot closer to Haskell than anything in c++.
All resource-critical stuff is still written in C/C++ and it’s not going to change anytime soon, especially that hardware is no longer becoming any faster.
Not. Really. Functional languages are different to name a different paradigm.
from this former assembly language programmer's point of view, the gap between assembly and C is orders of magnitude wider than the gap between C and any other high-level programming language.
&gt;I haven't learned the usage of vector Find a C++ course instead of whatever you've spent "a few months" on.
This is full of different difficulty challenges you can practice on. /r/dailyprogrammer
My uni had Java, then python, and now C as the teaching language. The choice of Java was that engineers need Matlab for many of the basic stuff. The switch to python was because numpy etal meant engineers no longer needs Matlab but python for this stuff. The switch to C was because engineers need to program their custom hardware anyways so they need it in the end, and from C to python is easier than the other way around. In a few years, maybe C++ will take over but compilers for the custom hardware needs perhaps improve? But since production+desktop operating systems -- FWIW Ubuntu for most people I know, at both uni and my past three countries of work -- will have c++11 finally this summer in their default compilers, this might soon become a reality.
Oh agreed, despite being appreciate hobbyist I quite enjoy Rust and even bought a hard copy of the book to support it's foundation. That said, having enums that are ADTs, tuples built into the language, and destructuring in patterns all make Rust's pattern matching incredibly useful for modelling things in a variety of domains far better then the if-else hell you'd have to endure in other languages but overall Rust still isn't quite as abstract and functional as Haskell, ML, or F#(none of which I know well). I've been meaning to pick up a functional language eventually, most likely F#, but haven't come up with a project or other reason to actually get started.
Well if we're talking compiler optimisation options, that's pretty easy - just look at the gcc/clang documentation. There are lots of things you can do beyond `-O3`, for instance `-fgcse-las`, `-fno-stack-protector`, `-funsafe-loop-optimizations`, `-ffast-math`. Obviously these are disabled by default because they aren't safe for all code, so you need to be careful that your code can safely use these. But the language optimisations for C++ are hard to find good guides for, imo. Some good material is in video format, in videos of lectures at conferences - but you need to skim through each video in order to tell if it is probably good or not. Some on StackOverflow, but you need to scroll past pages of optimisation questions where all answers are simply people complaining about "premature" optimisations.
Using xcopy i barely half a step above manual copying. I'm agnostic, it's an expression.
Next step, combine with Assembly/ASM ;)
Yeeppp, it's basically human readable assembly. I've always found when using other languages that my experience with C/C++ has helped me understand the cost of my actions.
Yes that was the one, thank you! Bookmarked it now so I'll find it again in the future........ :-) Would be really awesome to see CPS gain traction. If CMake could output them, and other build systems would also start outputting/be able to read them, that would be fantastic.
Then you tell them real programmers use c, then you tell them they use assembler. It's a lazy argument usually made by people who haven't taught either language and love pretending they're gurus because they can use pointers. You don't need to know everything when learning something. In fact, you accept abstractions in order to focus on specific concepts. The important thing is dealing with those other concepts that you might need in time. Using python as a first language allows you to abstract away some things in order to do others. It's great in that it favours readability, testability, has decent module support and a friendly community. You can learn other languages and concepts as you advance.
Compiler just have to check with both the old an new rule, and if they resolved differently, emit a warning.
For #2 I'd suggest implementing file based commands from GNU coreutils using std::filesystem and integrate Boost.program\_options for command line flags passed to the commands. Also build all of them using CMake/Meson so that OP can learn build systems and building a full C++ codebase than just a single file.
Reminds me about the Builder pattern
I'm not sure what your point is. I didn't say C wasn't a high level language. It certainly is. But I did say, "C is probably the closest thing to portable assembly language".
And when it falls, what then? Noise is useless both on the way up and on the way down. Be disciplined.
idk i think you can get really far with specific types. it just feels cumbersome and unnecessary for many applications
The whole problem here is the reliance upon abstractions to teach programming. It results in way in too many people not understanding how their code works.
C++ has long been my main language and with all the new standards from C++11 onwards it’s rapidly getting better and more modern. I’m a PhD student currently at a robotics research centre and it’s the go to language for implementing robotic/autonomous systems. I also teach an undergraduate subject called “programming for mechatronic systems” where we teach C++ and ROS. C++ is not going away any time soon. It can be challenging to learn/teach because it forces you to understand how computers work but this is a plus in my opinion.
Yep! Bottle m up isthe way to go. Top down generally results in people never really learning the basics.
Here's a four part list that is much more than most people will ever need. You will notice that almost all of it comes down to memory layout and architecture. -1. Avoid using pointers to classes, arrays of pointers to classes, polymorphism, etc. I essentially never use inheritance anymore. 0. Profile 1. Take out memory allocations inside loops - ~7x faster 2. Access memory in a linear order. - 10x-50x faster 3. Multi-thread with atomics and minimal synchronization 4. Use SIMD with a structure of arrays or hybrid memory ordering That's it. None of these have to do with dropping down to assembly. My experience is that most software around does nothing on this list and can run 10x to 100x faster or more without doing anything that has to do with assembly.
&gt; You can write functional C++ You say that, but what I really would like is the ability to declare a pure function, i.e. a function that cannot use global variables. Bonus points if all variables in that function scope are const by default and you have to explicitly say which ones are mutable. How do we have all this wild new stuff and not such a simple and important thing?
I only programmed in Basic growing up because it's the only language that I had available on my computers at the time. When I became an adult, bought my first PC and got connected to the internet I started researching languages. I chose to teach myself C++ and it wasn't a mistake. I have tackled many other languages since (many of them professionally) and it's been a relative breeze. I think I've programmed in Python, PHP, Netlinx, C++, C#, [VB.NET](https://VB.NET), VBA, JavaScript, and possibly a couple of others in a professional environment. The only formal programming classes that I had in all of that was two weeks for Netlinx that basically taught me how to use their tools. I've taken some classes more recently but only because a degree looks good on the resume. I credit having taught myself C++ years ago for my success though.
Right but straight C programs are rare nowadays unless they deal directly with the hardware. I did not mean to exclude C when I mentioned C++ and OP referred to it as C/C++. I think the average reader of this sub understands that there are no classes in the CPU. There are some parts of C++ that explain how things work in a way C (out of the box) can't. For example blah.begin() and blah.end() makes it clear how it it traverses memory, what it considers the upper bound, how pointer arithmetic works, etc. But yes, C/C++ teaches you how the computer works (Hardware + Kernel) and ASM teaches you how the CPU chip works (Or used to, 40 years ago).
constexpr is what you're looking for. You still have mutable variables inside the function, but the function itself is guaranteed not to have side effects.
&gt; Added support for Universal Windows Platform (UWP). Just curious, what did you have to do to support UWP? Had a quick look at your commit log but couldn't find anything specifically.
Good list. It's not the common advice, but personally I'd put 4 before 3 if it's an option. SIMD can be a pain (or fun depending on your attitude), but it doesn't require synchronization, doesn't fight over the cache, it opens up a huge amount of otherwise neglected register space and ALU capacity, and it leads to designs with less branching and chunkier load/stores.
If you take a random problem and implement the "correct" solution for it, in C, C++, Java and Python. I suspect the majority of the time the C solution will in fact be the closest to what the actual computer is doing. I suspect that most answers involving C++/Java/Python will all be more like each other, than like C.
I think that's pretty fair, muti-threading is probably the biggest rabbit hole to go down for most people.
Actually that's not true. You can have side effects in a constexpr function. There is no pure function specifier in C++. There was a good discussion on pure function here a few months ago: https://www.reddit.com/r/cpp/comments/a30yme/whats_the_current_state_of_pure_no_side_effect/
Java runs in a VM...
**Company:** [Constraint Technologies](http://www.constrainttec.com) **Type:** Full time **Description:** We provide leading-edge optimisation, disruption resolution and visualisation solutions to some of the world’s most recognisable companies in the transport and logistics industries. We are looking for 3-4 C++ developers to expand our existing teams, with roles ranging from graduate through to senior level. These roles have flexibility to be adapted to the skills and experience of the successful candidates. * Development work will generally be with C++11. * The roles will focus mostly on back-end systems including web servers, custom optimisers/solvers, messaging systems and data translation tools. * Multi-threading experience will be expected for senior roles. * There are opportunities for those interested in DevOps to get involved with build/release processes and deployment (dev, test and production). * Junior roles will likely include a support component. A computer science or software engineering degree is preferred, but candidates with equivalent relevant experience will be considered. **Location:** Melbourne, Australia **Remote:** No **Visa Sponsorship:** No **Technologies:** We work across Linux, Windows, Mac, iOS and Android, but Linux will be the main platform for these roles. We use a variety of tools and infrastructure, but experience with any of the following would be useful: CMake, Poco, GoogleTest, Oracle/Postgres/SOCI, Boost, Ansible, Gitlab, clang tools and other code checkers. **Contact:** For all enquiries or to apply, please email [hiring@constrainttec.com](mailto:hiring@constrainttec.com)
Lolwat. C++ is full of abstractions too. In fact, if you teach c++ and you don't use the proper abstractions you'll be teaching it wrong. I haven't been browsing much of programming subs lately but if the cpp sub is seriously suggesting not to teach abstractions to teach programming then everything has gone to hell. Wtf.
not even assembler is close to "what the computer is doing", microcode, out-of-order execution, prefetching, etc. There's a bunch of stuff happening in modern CPUs that aren't anywhere in the language
The reason why you're getting these responses is because your comment is reflective of an IMO irrationally negative (there, I said it) sentiment in the C++ community about any build system other than cmake. In the normal, rational scenario, when you find out about a (perceived) useless project, you ignore it. Yet when finding out about a new build system, people are *offended* by it! This comment thread is a perfect example. Xmake is a truly awesome, well thought out, well liked, well documented, and well supported project. Much more effort went into it than 90% of the projects you'll see pass the venue in r/cpp. Yet, it is only 75% upvoted. The comment that got the most upvotes, literally starts with "Yet another build system". My bake thread got 7(!) upvotes on r/cpp, and was only 63% upvoted. Sure, I get the notion that the C++ world would be much better if there was a single build system. The thing is, cmake is not *that* good. It is not nearly as universally liked as a tool like cargo for Rust. The reason we keep seeing all these projects pop up is because the downsides/quirkiness/complexity of cmake lower the barrier for people to start their own project. I want Cargo / NPM style ease of use when I'm building, and cmake doesn't give me that. Xmake and bake do, in different, unique and interesting ways that would be infinitely more interesting to discuss than the back and forth on why YAB.
It's a serrated lisp! :-)
and python is interpreted. Ok? that has nothing to do with the point.
Yeah my opinion is probably a little more dated. I used glide. I hated glide.
That's missing the point.
Yeah well you're not going to get that in a language like C++. Not unless you want to write a compiler extension that adds that kind of function and enforces the behavior you want. Rust could work for what you want if it were a more mature language. It has almost all of what you want(except no access to global variables). All variable bindings are immutable by default including function arguments and it has higher order functions that can be treated as objects.
DXGI_ALPHA_MODE_PREMULTIPLIED has absolutely nothing with blend modes. It just defines [format of alpha values](https://microsoft.github.io/Win2D/html/PremultipliedAlpha.htm) in RGBA representation.
touche!
That README is hard to read because its all monospaced. Take advantage of markdown (or point GH at a specific markdown'd file, if possible) to leverage all that formatting.
Well, the idea behind modules is to reduce compilation time. Right now `#include` just copies the whole file on top of your current file. This means including the same file multiple times copies it multiple times at compile time. It's the whole reason behind preprocessor definitions being at the top of headers (or `pragma once`). Even if they're copied multiple times, the compiler won't need to do anything with them multiple times since they can only be "defined" once. That doesn't mean they aren't copied multiple times, and that doesn't mean the compiler doesn't need to read through it until it finds the end of the preprocessor definition. Modules will fix that, by letting the compiler include it once and be done with it.
The nice thing about Haskell is that you're just learning math, not a bunch of committee decisions and library corner cases.
Don't you just end up p/invoking your own library? I've had to do this on occasion and some p/involving in C# is tons more difficult to get the structs translated right, so I agree C++ is better. But as far as I know, you need to dllimport, unless I've missed some cool feature I never knew.
I'm looking forward to C++50.
I agree with the other poster, making it markdown would help immensely.
Well, we’re discussing being close to the hardware. Java runs in a VM so it’s pretty far from hardware controls, right?
Expertip: buy icc and use `-fast`
&gt; C++ is a good language to know because it's HOW COMPUTERS WORK The point is to understand how computers work. So whether JVM, Interpreted, traditional compilation is irrelevant.
Yes, it is quite a good hash implementation. As far as I can tell there is no other hash implementation that can match both its speed and low memory usage (memory usage is a big factor for my use case because it is typically what limits the size of the models I can use). And I liked the fact that it is really well coded. I ran the lookup benchmark yesterday... here are the results. Various hash maps tested with 5 different hash functions. My phmap is a little bit slower than Abseil because I added a "mixing" of the hash key that helps with the hash function is bad (the benefit is not apparent in this "lookup" test, but very visible in the "insertion" test). see https://greg7mdp.github.io/parallel-hashmap/html/Lookup.html
UWP needed `CreateFile2` instead of `CreateFileA`, and previous Windows versions only have `CreateFileW`. So the result can be seen in [`include/tao/pegtl/internal/file_mapper_win32.hpp`](https://github.com/taocpp/PEGTL/blob/master/include/tao/pegtl/internal/file_mapper_win32.hpp#L73-L97). Relevant: * [https://github.com/taocpp/PEGTL/pull/138](https://github.com/taocpp/PEGTL/pull/138) * [https://github.com/taocpp/PEGTL/issues/155](https://github.com/taocpp/PEGTL/issues/155)
Sure, it is closer to what computer is actually doing, but assembly is what actually computer is doing, so... For similar reasons C can be preferred over assembly, some other higher level language can be preferred over C. IMHO, C++ is a good compromise between high level abstractions vs lower level mechanisms nowadays. Take reference counting, move semantics or meta programming for example. You still need to grasp what's happening under the hood to use these abstractions correctly, otherwise things can get messy real quick.
For teaching, are you talking about an intern, or school ? I'm relatively old. When I was a kid I first got into basic. Then I moved to regular c. Obviously as a self-taught (at the time) kid, I didn't understand everything. It does get you into concepts about data types/sizes, memory leaks, other memory management, raw pointers, segmentation faults, etc. Sometime later, boost was popular for smart_pointers (for c++), and huge, but c+11 finally added `std::shared_ptr` and `std::weak_ptr`. Some schools are instructing data structures and algorithms with python. Even when I was in a "c++" class, they essentially taught c with classes. Not even necessarily classes. No `std::string` or `std::vector` usage for sure. I think I would have had a harder time understanding what's going on if I hadn't touched c and asm, instead jumping straight to python. On the other hand, I did start with basic, so maybe it's not a bad idea? One of the biggest changes was availability to resources, whether it's people or books. On the other hand, a book can guide you through a bunch of angles on programming. You were forced to try more things yourself, because you might not get good information from google. Quality was random, and split into small bytes like a blog post compared to books. Man, if I had access to these , I'd probably die in amazement. - Regex REPL like https://regexr.com/ while using perl - code beautifier for every language in existence I think javascript is used quite a bit as a new language as well. I'm not sure this is the greatest idea. Unless you make sure they know - variables can implicitly become globals - what `this` is, and scope related issues - what and why do you use module patterns - real-time linters - git - stackexchange over mailing lists (for dozens of reasons) - wikis - how much text editors and IDE's have improved - exact equality test vs coercion - despite the syntax, JavaScript uses function-level scope, not block-level. So code in c does not work the same. Such as for (var i = 0; i &lt; 10; i++ ) { // ... } // `i` still exists here At least `let` and `const` now exist.
You're kind of freaking out over something he's not said. C and c++ makes you deal with memory in ways python alone will not teach you. And yes, teaching assembler is a good thing. You're not going to use it at work, but it's useful to understand hardware.
 inline static uint64_t microsecs() { return static_cast&lt;uint64_t&gt;( std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( std::chrono::high_resolution_clock::now().time_since_epoch()) .count()); } Why???
Javascript is a programming language. Both client-side and server-side.
Too many people still use c-style C++. Even using raw pointers when there's no need. There's lots of old information out there for that language. c is 1972, and c++ 1980. But they have changed so much since then, they might as well be new languages. If they are focused on web-technologies -- large changes can happen even in 5 years.
I'm not sure if that's meant to be sarcasm or not.
He's probably younger. Abstractions change over time. Resources have too. Is it worth cramming 8 booleans into a single byte, extracting with bit-wise operators? No, that's a waste of time. It's less typed, so you can get edge case errors. It won't be able to tell if you accidentally grab the wrong bit. Is 256^3 enough values to store color? It sure was overkill for a long time. Even starcraft1 was still using palett swapping. Now we're making the usage even higher for better visuals.
&gt; majority of the time the C solution will in fact be the closest to what the actual computer is doing That's not always a good thing. You should learn to be competent in c, if no other reason to better understand languages that abstract memory.
I wouldn't worry about the age. You can ask guys who have been programming 40 years. Even they will tell you can't "master" one language. Hardware and programming are too much knowledge for one person to learn or memorize. If I had to choose between 2 hires: One who has memorized a lot of the language of choice -- or one that knows they don't know everything but they know how to find out. I'd take the second one. You just started c++ so I wouldn't worry about smart pointers yet. It's useful to learn about them. But later, make sure you check out "smart-pointers". They are part of the c++ standard. Basically it ends up preventing a class of bugs that you can get using raw pointers. What IDE or editor are you using? At a minimum, use an editor with syntax highlighting.
There's definite value in that. Lots of information on programming on the web are in discrete chunks. A book gives you a consistent path to follow.
Lion was needlessly rude. However it's important to distinguish c++ from "c with classes". Because of that, people assume someone saying `c/c++` automatically doesn't know the reasons -- when they very well might.
The compiler makes the native/managed crossing itself. Code calls one or the other at will and you make managed types public so that you can call them from C#, VB.NET as if they *were* C#/.VB.NET.
&gt; I am very sad to hear that C/C++ are getting old and it seems that there is a huge push to "easier" languages . Imo learning C/C++ really helps to cover fundamental concepts and C / C++ is the greatest choice for embedded systems I mean, you're not wrong but there is a greatness in the way a simple language, like JavaScript, can help someone go from zero to making just about any app they want. Sure, it may not be perfect. Hell, it might be terrible. But C++ hasn't focused a ton in the dev experience whereas other languages like JS really embraced it. I love C++ but I think it could learn a thing or two about tooling and overall developer experience from looking at "easier" languages.
Yeah i’ll definitely check them out, i’m sure they’ll pop up at some point, i’ve just finished learning while and do loops and just starting on for loops so we’ll see how that goes! Using Visual Studio 2017, it seems perfectly fine for what i need it for and the errors are semi understandable after a little google search to find out what they mean 😂 I’ll look into Git 🤘, i keep hearing it mentioned but thought it best to keep my mind focused on one thing at a time to avoid a mental implosion Nice one bud
&gt; I think I found my passion because of this subreddit What are those resources that you use that are from this subreddit? I don't program in C++ btw.
Programmers are engineers as well, to write the logic needs engineering for sure.
&gt; I am very sad to hear that C/C++ are getting old and it seems that there is a huge push to "easier" languages . The problem with C and C++ is the (lack of ecosystem). For example, I can copy a JAR file or .Net DLL to another machine and just use it in the build. Or I can build a .Net DLL on a Windows machine and copy it verbatim to an OSX machine to fix a bug and it just works. This is science fiction in the C++ world.
What's the title of the book?
Beginning C++ through game programming 4th edition. Regarding Git &amp; Github, what’s the difference? Do i download just Git for writing the code if i want to have a mess or does Github include Git already :-/
Why is it labeled insanity? The compiler tries to find the function that best matches the arguments. Templated code wouldn't really work without ADL. The alternatives would be: 1) all functions should be bound to the namespace defined by the first argument of a function. e.g. operator &lt; to always be a member of the type of its first argument. 2) all functions with the same semantics shall be in the same namespace, .e.g. operator &lt; shall always be in namespace std. Personally I'd go for #1, and any function would belong to the scope of its first argument. E.g. operator &lt; (A, B) would belong in ::A and operator &lt; (B, A) would belong in ::B. That would be a quite elegant object-oriented solution, in my opinion (of course my language wouldn't have implicit conversions to complicate things, because with implicit conversions defining which version of a function to invoke would be very difficult).
Alright, thanks for the info. I still don't understand why my fully opaque black text is invisible over white notepad window.
Worth mentioning: http://www.stroustrup.com/terminology.pdf
Not at all. CLR was designed for multiple language support, C++ being one of them. So if you have the full source code available, it just becomes 100% straight MSIL (when compiled with /clr). As for binary libraries and COM/UWP written in C++/CX (C++/WinRT), the compiler takes care of the proper metadata, instead of you having to figure it out how to write it manually.
Hm, perhaps an implicit conversions problem? Is [this](https://dbj.org/how-to-avoid-implicit-conversion-in-c/) completely unrelated? Can't help much with cin, as I am avoiding iostreams for at least last 10 years.
One of the [better texts on the subject](https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/cpp-value-categories). With pictures too.
Denis Ritchie: "Lvalues and Not-Lvalues" ... Priceless.
Like?
# [CallStream](https://dbj.org/callstream-interfacing-and-application-architecture-pattern/) aka "Why the dot's ?" :) Nothing wrong with a bit of JavaScript to invent new and important concepts. Perfectly doable in C++, too. I think it is mostly related to the "Facade" pattern, but yes, it is related to a "Builder pattern". And it seems it survived the "Monads" too.
Are you talking about package config, which is nothing else but build system agnostic? I'm messing with Deb and Rpm packaging and no official distribution provides real documentation on what to do with, for example, package config CMake modules. However all of them support *.pc files...
As one of my professors used to say to encourage us to learn C/C++ and OS theory, it's much thougher to build a pyramid from the tip than from the base.
First of all I doubt that the natural reaction to things on reddit that you don't like is to ignore them. The reason why "yet another build system " is imho hard to ignore is because the more build systems there are, the more likely it is I find a library that I would like to use, but is hard to integrate into/use with my project, package management system, ci infrastructure or development tool due to build system incompatibilities. Fragmentation above a certain level is what I dislike not "everything that is not cmake". In fact, I don't have anything against 2-3 good alternatives to cmake, but I am annoyed by 10 (or whatever the current number is) Finally, I have to admit, I just don't see the need. Cmake syntax is ugly sure, but on the semantic level, it does almost all I want and I usually spend so little time on my build scripts that I just don't care if this can be made a bit easier. As I said, I'm not telling anybody what to do, but if someone puts his project on reddit, I don't see why I shouldn't post my thoughts about it.
&gt; Using xcopy i barely half a step above manual copying. Well, batch files are used on Windows to script task, `xcopy` is one of the "tools." &gt; I'm agnostic, it's an expression. Yes, I know. I quote from wikipedia: "Agnosticism is the view that the existence of God, of the divine or the supernatural is unknown or unknowable." This is not my point of view, there is no god, it's all BS. I'm an atheist, I do not think there is a god or any other high being, in my mind there is no doubt, I know that. Before you attack that as well, that's useless, philosophically speaking [i.e. generically, regardless the subject], it is impossible to prove a negation, so no, I cannot prove that.
Great, thanks for the explanation!
What is wrong with you? I've said that the 'actual argument made' is invalid. I've analyzed to you why it is invalid. All you do is reject my analysis because "I am nobody" and because "the majority thinks otherwise". Well, sorry bud, those two aren't arguments, they are logical fallacies: argument from authority and argument from popularity. If you don't like it that someone destroyed your view, it's your problem, not mine.
Speaking as the guy who has to go fix these includes everywhere so that hundreds of my users can have faster compilation times, yes totally worth it, not even a fair comparison of impact! Please keep going!
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
https://github.com/jeaye/value-category-cheatsheet Also helpful.
[of course it is](https://www.meme-arsenal.com/memes/eb7ae03128ac120867e336ce8bd3ab88.jpg)
You know you are at king wizard level when you write `std::end` when you intended to use `std::endl` and managed to understand the error message.
While this is a valuable tutorial for someone stuck in hell, you really have to realize the insanity of what's presented here... For a simple hello world we have a rigid tree that goes 4 levels down involving about 20 entries that make absolutely no sense unless you swallow hundreds of pages of nonsensical (mostly Java) conventions. CMake may be far from perfect but at least hello world is a single 3-liner build file.
Sure for hello world it’s to verbose. But the point is not the application but how to build it with gradle. Why having a more complex application if that’s not the point of the post?
&gt; so that's a plus Somone would say it's C+++
Also interested in this!
&gt; If you know C++ inside and out If you think you know C++ inside and out, you are almost certainly wrong.
Yes?
Are you saying you're somehow better than Javascript developers? But you link a meme about raw pointers...
It is not because they are "easier" languages, C/C++ can be if you want, the real problem is the overhead C/C++ has, the kinds of things waste time that other has granted, the build system for example is a nigthmare, dealing with CMake or similar vs making an import and telling the IDE where it is in the hard drive like an external jar or figuring it by itself where it is like in python is a huge time saving And of course the language itself, in Java/C#/Python/JS-Node you has pretty much anything you can need and if not you can extend easily, thats not the case with C/C++, you will have to do yourself or research wich lib to use and learn to use, the STL is not as full as you may need in your every day programming vs others where it is It is a real problem and C++ it is not pushing fordward so it is getting old, i am using it because performance reason and compability among any other OS, if not i will switch to .Net long ago, it will make my life more easier
No, it is because no one likes to waste time dealing with things that rivals doesnt need to, build system, compiling times, STL not as good as any other default library where you has more than you need but there are more things that C++ is behind C++ means trouble so it is normal that now that the market has other options people use it to avoid all the inherit problems you will have with C++, it is only a matter of making your life easier if you dont need critical performance it is the wise move, the dumb move is using C++ where any other can do the job easier and quicker without any good reason to do it
Spirit uses expression template, while PEGTL uses class template. Spirit is easy to use but the compile time/space cost could be huge. PEGTL is light on compile but cumbersome in use. PEGTL may be slightly faster.
C++3000!
hey, this is /r/cpp!
I upvote you because i think like you but with a catch, things in IT change so fast that you cant even notice it and only does when it is too late I am refering to JS performance closing to C++ or Rust or Go or new things that will come. Todays world relays on software from so long because the computers are still x86 based but in the future they may become other so legacy code will be no longer useful and the rewrite process can be done in other language, or a new OS like fuchsia (i am using as an example of future OS) where using [X] will grant you almost the same performance without all the drawbacks of C++ Trusting that it is a huge mistake, there are so many options and one of then can be the one who kill C++ as has happened with other now residual languages like Pascal, Basic or Cobol, top of their times and now, well, only because legacy code they are still alive but even that is changing, even banks are rewritting the Cobol parts to other options I see what it is coming as coments so an aclaration, the performance of C++ will not be catched by any other option but i think as we are smart people can figoure out that i am refering to points where doesnt matter that much, not 50 times faster, only 2 or 50%, numbers that meh to the normal user as they will not be able to tell a difference, the new calc of windows is an example, is need TWICE as RAM as the old one and for sure it is slower but it is still fast that you get the result instant and the under 10 MB has not important at all even the old one uses only 4-5MB, this scenario is where C++ is facing today so imagine in the future what could be
C++ actually seems to slowly be approaching Haskell. This is generally an amazing thing, but you should look up Cabal Hell. Also, it looks like Java style OOP might actually be the best way of doing GUIs in general purpose code, so it's a little scary that that's falling out of fashion in C++.
Domain errors are misapplications of the equations and not related to the accuracy of the float. The floating point accuracy only changes when you have to apply your limits, not that you have to apply your limits, in regards to domain errors. No one needs to know anything better than what 128 bit accuracy implies. (Though it would be useful if they defined this accuracy so that the 7-odd physical constants in May's SI update can be represented exactly.)
The worst part is that these categories continue to change over time, so learning them once (e.g. in C++03), does not really help you in C++11.
I really enjoy the talks Sankel delivers... they are pretty easy to follow and also captivating. The talk he gave about Software Value a few years ago should be up there with other mandatory materials one has to make sure they've seen.
\&gt; The cheatsheet is generated by running an HTTP server using [Clojure](https://clojure.org/) and [Ring](https://github.com/ring-clojure/ring) and then converting the produced web page to a PDF using [wkhtmltopdf](https://wkhtmltopdf.org/). jesus
Rust just has different names for it
This looks fantastic. I had a similar idea to generate C++ wrappers from GIR information a few years ago (back when I used GObject-based libraries a lot) and did some experiments, but I never got very far. This project looks to have done everything I had in mind then and much more. I particularly like the way that the user can choose whether to inline the (C++) implementation or put it into a separately-compiled file.
Sounds like the guy with his bash script sending auto-replies, brewing coffee and such based on his PC activities
Maybe a stupid question. I'm a C++ beginner. Does knowing all these sub-categories really make a difference in the everyday life? So far, I've found that knowing the difference between an lvalue and an rvalue was good enough. Maybe there are some subtle cases where it does help to know the difference. I'm going to read the article because I'm interested anyway.
You could commit some code that causes problems for users, but builds fine because of that flag.
That's a dishonest take. The claim is "using python instead of c++ as a first language to learn programming is a big mistake". When people ask for reasons the answers are "with python you don't know how computers work" and "people rely on abstractions to teach and that's a problem". Both statements are frankly ridiculous and talking about memory management when you should probably should not be using free/delete directly anyway is absurd. I originally wrote a far more scathing comment that talked precisely about pointers and malloc/new because I absolutely knew this was gonna be the talking point but I decided to be less blunt. No one is saying students can't be exposed to c or c++ for their data structures and algorithms course but it's been shown to be a bad idea for it to be the first language. Python has been way better at it. That's not a debate but it has been proven by nearly everyone who has taught either. Same goes for assembler. Would you make it a first language to teach programming? If you won't, then you're changing the argument.
For me - in game development - no. Knowing what forwarding references are and what things are movable and not is mostly "enough".
Place expressions and value expressions, also it avoids the need for an xvalue equivalent by being move by default.
Just look here for a basic "Hello World" example mixing up C#, C++/CX and Rust. https://github.com/pjmlp/WinRT-Rust
Those few months dont mean I've had that course for that long... And also you can't know how many lessons I've already took, like I'm often busy because atm I'm moving and I'm also a student so I can take lessons rarely. If I'm correct I've been learning C++ for 3 months, but in the first 2 months I wasn't actually learning that much, just watched 1-2 videos a week about basic stuff. I started the course like a month ago, but it is pretty good I just don't have the time to finish it in days lol
Thanks! I'll check that out for sure!
Rust has places and values, and there are expressions producing both, that's all there is to it.
Thank you!
For me - not in game development - the same applies.
IIRC, we wanted buy-in from other setups (build tools, pkg-config, etc.) before we went down a yet-another-package-metadata-description road.
Replied the wrong comment?
I hate you people
Thanks. If you're using Mac git should already be in your machine. GitHub is like a nice add-on application around git with nice ui to look at your tree, commits, pr etc. I've mostly used git CLI to push changes to remote.
I understand. However it might be worth considering CMake's current role as "de-facto" standard build system for C++. I am not sure any other build tools/systems would buy into it before cmake can generate/output it. Perhaps you guys could talk with some of the guys and see if there's general interest? There's quite a few people from the "build-system world" around here on reddit (from b2, meson, ...).
Yeah, I'm working with them on modules. First up is getting them built. Once we can build them, we can start to look at how modules are declared on an installed package. CMake has usage requirements which is an easy place to stick the information. pkg-config is a harder answer since it is just a key/string lookup table (at its core).
In another comment you said "structures will be the next lesson" If your course didn't explain how to use strings, vectors, and other basic stuff, it's only taking you farther away from learning about C++.
I am not sure that I understand. No matter how many bits of FP accuracy you have, you can still run into underflow, which can lead to errors if you use FP calculation for discrete decisions. A classical geometrical problem is deciding orientation of thee points in a plain (i.e.whether a point lies to the left or to the right of a line drawn through the other two), this is solved by computing a determinant and checking it's sign. For this, it is essential that the result is computed correctly, without rounding. If your application involves dynamic geometry subdivision, it's only a matter of time until you get an underflow and make a wrong decision = logical inconsistency. What you need to do here is compute the determinant at higher precision than you use to store the coordinates.
Well, vector explaining should happen soon too then. I'm okay with string, pointers, functions, conditions, loops and other basic things.
fair enough. Just reacting to the "portable assembly" trope.
Nice one, i’m using windows so i’ll just look into Git
A plus plus?
OK, sorry if I misunderstood it. The first sentence lead me to look at it in an overly negative way.
Great list... what about [WinLamb](https://github.com/rodrigocfd/winlamb), /u/pgroarke ?
In addition to that: it seems to be mostly important for performance critical library developers (like Boost). Your typical user can most likely stop at knowing when to move, unless they themselves are writing extremely performance critical code (but that doesn't happen often to the average user).
Finally, someone noticed :-)
Cool. I've seen, in my experience, it's much helpful if you learn git CLI first and then jump on to using desktop application to improve the experience. So when you navigate through the application you understand the underlying mechanism
Could you send me a link for Git cli download, better safe than sorry
https://git-scm.com/download/win
prvalues reaaaally aren't moveable anymore
so by the end, how do you fix long link time problem? this always troubled me
No. I'm more talking about I want to use libraries X, Y, Z in my project and they all use a different build tool. Like X uses make, Y uses premake, Z uses gradle native.
The whiteboard photos in that paper are terrifying.
I wanted to share and request comments/feedback on my set of "fancy" arrays. These are largely intended for resource storage and access in environments with well-known bounds or hard limitations. Currently the API exists as a minimum reduction to stay focused and avoid bloat but the interfaces for each structure could be added upon over time. The process of safely emplacing data into and accessing data from a fixed sized memory buffer while following the rules for object creation and avoid UB (as best as possible) is less than straightforward in C++, as I've found. I wanted to create and "solve" some of the boilerplate for doing so, and here is my effort towards that process (particularly in `raw_buffer.h`).
This article reflects the C++11 model of value categories. However, C++17 cleaned up the model for the purposes of “mandatory copy elision” (the latter is really a bit of misnomer in C++17; there are no longer copies to elude). Specifically, a prvalue is now an initializing value, a builtin operator operand, or a void expression. The rest more or less ensues from that.
The user will maybe not feel a difference of 2~50%. But if a company is paying 1 million for an electricity bill each month, then that is a saving of minimum of 20'000 each month. If you're trying to get those few extra frames per second, that 2~50% makes a difference. The right tool has to be used for the job.
&gt;a prvalue is now an initializing value, a builtin operator operand, or a void expression ...or a pending member function call?
Should there be a ':' between FlatBuffersVTableOffset and FLATBUFFERS\_VTABLE\_UNDERLYING\_TYPE?
That’s the second case: “a builtin operator operand”.
Are you using vcpkg and cmake? If no, disregard the rest of this post. Flatbuffer cmake for vcpkg is missing some includes. We had to manually specify all the cmake variables. I'll check what exactly we did at work tomorrow if you need.
Exactly, thank you for pointing that out
lol I definitely did
\[This\]([https://stackoverflow.com/a/11540204](https://stackoverflow.com/a/11540204)) is a very good explanation
I would like to know what the benefits are compared to std::array and std::vector.
How about builtin operator &amp;? Its arguments are never (p)rvalues. &amp;#x200B; (I think the only real way to define them is by enumeration, as in [cppreference](https://en.cppreference.com/w/cpp/language/value_category))
Nah, you have to try out the combination of Gradle, CMake and ndk-build on Android NDK projects, and be willing to throw Blaze into the mix if one happens to depend on a Google library like Skia or TensorFlow.
Sure! All of these structures are backed by an `std::array` in some form (via `raw_buffer`). Some of these structures provide novel functionality, and others exist just for in-place storage. The repo's readme goes over each structure's qualities, but I'll break it down a little bit here. `nonstd::push_array&lt;T, N&gt;` This is just an array and a number. Nothing special here. It's good if you want a trivially copyable in-place structure that counts its contents. `nonstd::slot_array&lt;T, N&gt;` For this I would recommend watching [this video](https://www.youtube.com/watch?v=SHaAR7XPtNU) of what a slot map is. Slot maps give you fast iteration, fast access, and reasonably fast insertion at the cost of unordered storage and slightly slower removal (since it performs a swap). It also uses generational keys to protect access to its members. If a member is destroyed the key will be invalidated and will no longer work, which avoids dangling pointer issues. `nonstd::keyed_array&lt;T, N&gt;` Similar to a slot array with two differences. One, there is no direct iteration, period. The data is not stored contiguously. Two, removal is cheaper because there's no swap required for data compaction. They're also a little smaller than `slot_arrays` since they need less structural overhead. `nonstd::packed_array&lt;T, N&gt;` This is really just a static vector or fixed vector. It behaves like a vector but is in-place in memory. This is nice if you want control over where the memory lives so it isn't off floating in the heap somewhere, and also don't want to mess with custom allocators. *But why arrays?* Mostly for memory control without custom allocators. If you want your collection to live in-place inside of a structure or to be temporarily placed on the stack, it can be particularly tricky in C++ to do this with vector-like functionality. There are also some optimization gains to be had from fixed-sized structures.
I think it's safe to say that probably 0.0000000000% of C++ developers actually understand all of the details of the language and associated libraries. It's become far too complex really. The only people who really probably understand it are people whose primary job is to understand it, which is probably why it's become far too complex.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
You can get a pretty good idea by browsing through the list of gcc optimization flags: https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html
this is the canonical representation of the same picture
Right. I didn’t mean to say that all builtin operator operand are rvalues. Sorry for the confusion. The specific operator contexts indeed have to be specified.
You should know that if you have `foo(bar())`, then an r-value overload of `foo` will be selected, but if you have `auto x = bar(); foo(x)`, then an l-value overload will be selected. All these values categories are a precise analysis of how exactly this works, but a "common sense" understanding is virtually always enough.
However, I don’t think the enumeration in the link you provide captures the notion accurately. Consider: int x = 42, y = x; That second x as an initializer is a prvalue because it initializes y (i.e., lvalue-to-rvalue conversion is applied). However in: auto p = &amp;x; expression x is an lvalue.
&gt; lvalue-to-rvalue conversion is applied) ..to the expression `x`, an lvalue expression. Or, as clang puts it (note 'lvalue' on the line with 'x') `-VarDecl 0x23978e8 &lt;col:4, col:20&gt; col:16 y 'int' cinit `-ImplicitCastExpr 0x2397970 &lt;col:20&gt; 'int' &lt;LValueToRValue&gt; `-DeclRefExpr 0x2397948 &lt;col:20&gt; 'int' lvalue Var 0x2397850 'x' 'int'
Are you using any of these in a serialization context? I'm open to adding serialization support to my software for some of them.
\&gt; if someone puts his project on reddit, I don't see why I shouldn't post my thoughts about it. Of course, by all means do. However, \&gt; I have to admit, I just don't see the need. Have you looked into the features/designs of other build systems? They rarely are cmake clones with a different syntax, but are genuinely different (and often more productive) approaches. There is so much a build system can do, and there is so much that cmake cannot and will never do, due to its inherent design. That is what I meant- it would be much more interesting to discuss those features and approaches, and learn why (at least some) people prefer it, but YAB is sucking the air out of that discussion. \&gt; but I am annoyed by 10 Your argument is contradicting; on one hand you encourage innovation, yet on the other hand you are intolerant against more than 3 approaches. Those statements are not compatible. You cannot have your cake and eat it too ;) IMO the reason we are seeing so much fuss around C/C++ build systems these days is because people are inspired by the innovation seen for other languages (Go, Rust, NPM). Coming from those tools, it is hard to use cmake and not wonder how things could be better.
I am not personally but I imagine they would lend themselves reasonably well to it due to being backed by `std::aligned_storage`. What else would that entail?
I started reading but I think you could catch a lot of stuff yourself if you reread. there are lots of style guides/oop guides... also, take a look at https://www.boost.org/doc/libs/1_66_0/doc/html/boost_asio/reference/thread_pool/thread_pool.html. the thread pool takes a parameter for the size of the pool. that's pretty much the main point of thread pools. calling std thread from a class isn't really helpful because your library doesn't add any value in that case maybe I missed it (on my phone), but where's the pub/sub? I would expect something like `pubsub::publish(...)` and `pubsub::read_subscription()`. idk maybe some other interface, but still... something to push values and something to get them on the other end.
That's my point: `x` without context is usually assumed to be an lvalue, but in context it becomes a prvalue. (Note that the _initializer_ `x` is spelled exactly the same as the original _id-expression_ `x`. In fact, the _initializer_ is technically still an _id-expression_ as well.) If you just enumerate the value categories of the various expression grammar constructs, that subtlety is missing.
&gt; Have you looked into the features/designs of other build systems? I have looked at some and saw very little what I considered significantly different beyond a few outstanding features that could easily be ported to cmake (modules support in b2 for example). One caveat: We don't need distributed builds. &gt; Your argument is contradicting; on one hand you encourage innovation, yet on the other hand you are intolerant against more than 3 approaches. Those statements are not compatible. You cannot have your cake and eat it too ;) I absolutely don't see how they are incompatible. I'd even go so far to say, that you can have innovation with a single system, but obviously there are limits when you are concerned with backwards compatibility. What I' saying is that I'd prefer a few widely used systems over a dozen (or dozens) of incompatible systems without substantial different feature sets.
How come?
I can't say anything useful about the experience, since I don't notice any difference in speed (yet). I'm coding C++ more as a hobby, and my projects aren't that big. However, I am just curious why the precompiled headers are that huge. I have a rather simple C++ project right now, with 12 headers, totaling 577 lines (including comment lines and other include directives), and the ipch folder is 2.4 Gb in size. In any case thanks for the plugin, it's certainly very useful!
Thanks for your references suggestions. I will really try to read them. &amp;#x200B; The header file that contains the publisher/subscriber declaration is \`dispatcher.h\` &amp;#x200B; Thanks for your time!
[removed]
&gt; `nonstd::slot_array&lt;T, N&gt;` Sorry, I don't have time to look at your code in depth right now. Is it "a slot map" or "a slot set"? I would have a use case for a slot map with good performance, but I haven't yet sat down to read enough about them.
Udemy has a beginner C++ course for free at [https://www.udacity.com/course/c-for-programmers--ud210](https://www.udacity.com/course/c-for-programmers--ud210) that you may want to try first. There is also a free udemy course at [https://www.udemy.com/c-plus-plus-programming-basics/](https://www.udemy.com/c-plus-plus-programming-basics/) and [https://www.udemy.com/beg-cpp-temp/](https://www.udemy.com/beg-cpp-temp/) that will give you some good basics to get you started. Outside of Udemy there is [https://www.learn-cpp.org/](https://www.learn-cpp.org/) and [https://www.codecademy.com/learn/learn-c-plus-plus](https://www.codecademy.com/learn/learn-c-plus-plus) . You might want to begin with these free courses, then you will be in a better position to evaluate the value of paid courses yourself and you will meet many others that may have already taken those courses and can also help you evaluate them. &amp;#x200B; Good luck on your journey!
I would research each array with an eye toward serialization related optimizations. Then add support for the arrays to my code generator. Sometimes that support is limited to the private/closed part of my code generator, other times it spills over to my open source code. I have support for plf::colony already. Is that somewhat similar to one of your arrays?
No, in _normal_ programming, day-to-day job this barely ever comes up. You have plenty of problems but this one is vary rarely one of them.
prvalues are initalizers. No need to move them, since they can be used to directly initialize an object. If you were to bind one to a rvalue reference, the temporary materialization takes place, which converts the prvalue to an xvalue.
I fully agree that it can help make the domain within which an algorithm works increase. I also agree that it helps in many problems to simplify the logic. However, a point does not need to be to the left or to the right of the line the other two describes. A point can also lie on the line, and this is where floating point error applies. The domain error therefore is about the asking only for the right-or-left property of a point.
Innovation thrives in the absence of restrictions. I'll refer to my earlier argument: if it's not fun, there's not going to be much innovation (at least not in open source), and it is undeniably fun to create a better build experience *from* *scratch*. Besides that, I wouldn't even know how to implement some of bake's features in cmake, and others I'm pretty sure would never be accepted by the community. But *I* want it, so *I* build it. A few examples from bake: \- API for dynamically discovering packages @ runtime \- Automatically include header files \- Forward-declare project settings for dependee projects \- Recursive building (single command, build all dependencies, for a given configuration like release/debug) \- Distribute a project &amp; all its deps by simply copying a directory on your machine \- Interactively run code (run app, rebuild on code change, for the current project &amp; all its dependencies) \- Automatic project discovery and building of projects in the right dependency order \- Automatically rebuilding code &amp; all deps when running tests, with code coverage enabled \- A platform abstraction API \- A parseable project configuration so other tools can easily read it \- Run code directly from a git repo with a single command \- Create new projects from templates or run a template directly You could argue for each one of those features that they are not important, that you've never felt the need for them, that you *could* implement them in cmake (even though that will never make it to the main branch) etc. But I do, and it makes my build work flow several times faster which to me is the most important thing in the world. Apparently others like it too, so I help *their* workflow as well. Will it fragment projects? Nah, things have always been fragmented. Cmake has undeniably consolidated it somewhat but the C/C++ world has always been fragmented, and until there is a tool that is both easy to use *and* does everything *any* C/C++ developer needs, it always will be.
For me, doing low-latency trading stuff - yes. In part because interviewers LOVE to ask this shit now. But also because copying things takes time, especially when 10 microseconds is an eternity.
Thank you for sharing. Indeed it was probably the best one I've ever read on the topic.
Jesus indeed.
OT: When I look at this page on mobile in portrait mode only the menu and ads are shown and the content is missing since it apparently doesn't fit. Maybe instead of value categories advancements in CSS since the late nineties would be a topic worth studying...
The right tool need the right people, C++ as a language is one where developers earns more money compared to others, is among the top well payed so the team will cost much more that 20k€ per month for sure And because it is C++ developement will take longer, not be as easier and has much more bugs so that extra months is something to deal with it and will be an increased cost, at 10 extra months could be the point of which C++ is no longer a good option, yes, servers will waste less but the money spend on developing will be more than the saving in the proyected use of the software Or electric bills doesnt matter at all where future is leading us, cloud servers dont bill for watts consumption and it is the future for mostly all servers, i think few companys will retain it data centers as they do today, everyone on the industry knows that more and more companys are going to the cloud, even if it is a more expensive option that having local hardware on the company Another option is that hardware is cheaper that developers, maybe the actual servers waste 10KWatts to say a number but if you make an invested in new hardware it could be 5KWatts plus the extra performance it could deliver, i can thing that now you have Xeons servers and change for AMD, cheaper, faster and more power efficient but ARM is trying hard to enter here, maybe in the near future does and well, in that case electric bill will no longer be a huge concern. The future is uncertain so who knows Or we can finally has the fusion reactors working so energy is so cheap that who cares, the European Union has one that works, it was 2 years ago and it runned for 90 seconds until it has to be shut down, i lost track but you can bet they has improved. And the EU is only one of many tries the world is working on, sooner or later this will arrive and energy will not be a concern to anyone Or new devs doesnt care more of C++ because they always learn easier languages which they dont has to care of anything that C++ does and more that 90% will not even try to use a much more complex thing to do the same. I learned Java at the university but now they has switched to Python, how many are going to try C++? Not many and less will try to use as regular basic. With Java i was the only one who looked so imagine if the transition is much more hard. And if new people dont learn this the market will be forced to use any other option as we has to did with ASM back in the days In the end is a balance, the company will has to run the numbers to see what could get but because there is or will be that uncertain of few or none performance gain i will think most will use the no C++ option, it is more secure one. Only imagine the real problem of finding a good team to the job, the future will be one which [X] is easy to use and close performer, a huge devs will switch to it and not look back, specially if that new option is well payed too so few hardcore programers will be avaliable to take the job, it could be a problem If you asume that the world would remain as it is today yes but we all know it will not be the case and lossing that tiny performance would not matter that much, there are so many variables in the near years that i couldnt trust that C++ will be the king of the hill in the coming years
&gt; backed by a `std::array` Why not make your classes adapters, like `std::queue`? That way, if I have some custom type that acts like a `std::array`, I could just say `nonstd::push_array&lt;int, 50, my_array&lt;int&gt;&gt;` and your template arguments would be `template&lt;typename T, size_t N, typename Container = std::array&lt;T&gt;&gt;`.
Slot Map is not really the best name for the structure IMO since it doesn't map user-defined keys to user-defined values in a traditional sense. This `slot_array` structure works as follows: - You insert a data element into the array, and are given a small versioned key. - The contents of that key are a black box to you. - If you want to retrieve your element, you give the key to the `slot_array` and are given a reference to your data element. - If the data element is deleted later, and you hand the old key to the `slot_array` to access it, the `slot_array` will safely detect that the key is outdated and the operation will soft fail (you'll receive a `nullptr`). - All existing data in the `slot_array` can be iterated contiguously but unordered via standard iteration without the use of keys. Because this is backed by an array, it's of fixed size. There are some variable length implementations floating around but I don't know which is the most complete or well tested.
I could look into doing that. The array "backing" is a little more complicated because the core structure under the hood is `nonstd::raw_buffer`, which is an array of `aligned_storage` designed for placement new and placement destruction. This is what allows vector-like forwarding emplacement, and so any adapted container would need to support the same. Heap-allocated growing containers would also significantly complicate some of the metadata management, particularly within `slot_array`. It's worth looking at though.
This is a sort of reaction to `plf::colony` (of which I'm a fan and user). The colony structure is great for its stable pointers, but doesn't provide protection against access of explicitly deleted elements. So I turned to the Slot Map approach (and some older approaches, like [this data array](https://gamedev.stackexchange.com/a/33918/125027)) to add dangling safety. I think if something can serialize the `raw_buffer` structure then it should be able to serialize anything else. It's the only thing I use that isn't a built-in type or an array of built-in types.
I'm not saying you should support heap allocated, dynamically sized containers. Just, instead of using `std::array&lt;T&gt;`, you would require a [`ContiguousContainer`](https://en.cppreference.com/w/cpp/named_req/ContiguousContainer). You can put a couple `static_asserts` inside your `raw_buffer` to make sure that the container you are given satisfies `ContiguousContainer`. Support for all of this would mostly be localized to `raw_buffer` and only the extra, defaulted template parameter would be needed in other files.
I have most of the other feedback you provided done, great stuff. Thank you. &amp;#x200B; Having done devops before with juju. I've been bit hard by assuming state. If it's not under the control of your "charm" you just can't assume it's there. That's why I went out of my way to copy the include dir into the build directory so I know it's there without a doubt when I'm in the package() step which implies I'm working out of the build dir. Conan appears to be changing the behavior of the packaging step depending on whether it's run all at once under the context of `conan create.` It looks like it borrows NANA\_INCLUDE\_DIR from the build() step and makes and uses is during the package() step. Project: Running build() The compiled Nana library will be installed in /home/ppetraki/Sandbox/conan-nana-meson/tmp/build/package/lib The Nana include files will be installed in /home/ppetraki/Sandbox/conan-nana-meson/tmp/build/package/include The invocation of the build step is this: conan build . --source-folder=tmp/source --build-folder=tmp/build It couldn't possibly know where the package dir would be somehow it's knows or more likely \*it assumes\*. It may be ignored in the testing phase where you'll invoking each step manually but that doesn't appear to be the case when it's really installed (and under a single process). As once you're under .conan it presumes a directory layout of (source, build, package). &amp;#x200B; I think `conan create` is peaking at these variables and using them in the package() stage. The same conanfile.py code should work in both instances, but it doesn't. It only works in the real deal. Which makes the other workflow useless for testing. &amp;#x200B; just package step ppetraki@vanguard:~/Sandbox/conan-nana-meson$ make package conan package . -bf=tmp/build -pf=tmp/package Python 2 will soon be deprecated. It is strongly recommended to use Python 3 with Conan: https://docs.conan.io/en/latest/installation.html#python-2-deprecation-notice PROJECT: Generating the package PROJECT: Package folder /home/ppetraki/Sandbox/conan-nana-meson/tmp/package PROJECT: Calling package() *** PATH /home/ppetraki/Sandbox/conan-nana-meson total 28 -rw-rw-r-- 1 ppetraki ppetraki 3279 Apr 11 15:54 conanfile.py -rw-rw-r-- 1 ppetraki ppetraki 63 Apr 9 16:55 COPYING drwxrwxr-x 2 ppetraki ppetraki 4096 Feb 27 13:22 debs -rw-rw-r-- 1 ppetraki ppetraki 791 Apr 11 15:47 Makefile drwxrwxr-x 5 ppetraki ppetraki 4096 Apr 11 15:42 nana-test -rw-rw-r-- 1 ppetraki ppetraki 1505 Apr 10 11:55 README.md drwxrwxr-x 5 ppetraki ppetraki 4096 Apr 11 15:56 tmp *** PROJECT: WARN: No files copied from source folder! *** PATH /home/ppetraki/Sandbox/conan-nana-meson/tmp/build total 8304 -rw-rw-r-- 1 ppetraki ppetraki 17825 Apr 11 15:56 CMakeCache.txt drwxrwxr-x 5 ppetraki ppetraki 4096 Apr 11 16:03 CMakeFiles -rw-rw-r-- 1 ppetraki ppetraki 2104 Apr 11 15:56 cmake_install.cmake -rw-rw-r-- 1 ppetraki ppetraki 23339 Apr 11 15:56 conanbuildinfo.cmake -rw-rw-r-- 1 ppetraki ppetraki 161 Apr 11 15:56 conanbuildinfo.txt -rw-rw-r-- 1 ppetraki ppetraki 392 Apr 11 15:56 conaninfo.txt -rw-rw-r-- 1 ppetraki ppetraki 8351108 Apr 11 16:03 libnana.a -rw-rw-r-- 1 ppetraki ppetraki 87721 Apr 11 16:02 Makefile *** PROJECT package(): Copied 1 '.a' file: libnana.a PROJECT: Package 'package' created No nana dir right? Now this is the python code, unchanged between the two development workflow 60 def package(self): 61 # the PWD is actually the root of the repository 62 self._show_pwd() 63 #self._show_env() 64 self.copy("*", dst="include", src="nana/include") 65 66 # self.copy("*", dst="include", src="../source/%s/include" % self._source_folder) 67 # self.copy("*", dst="include", src="../source/nana/include") 68 # self.copy("*", dst="include", src="tmp/source/nana/include/") 69 # self.copy("*nana.lib", dst="lib", keep_path=False) 70 # self.copy("*.dll", dst="bin", keep_path=False) 71 # self.copy("*.so", dst="lib", keep_path=False) 72 # self.copy("*.dylib", dst="lib", keep_path=False) 73 self.copy("*.a", dst="lib", keep_path=False) OK, lets install it for real. [RUN_REAL_PACKAGE_INSTALL 1] nana/1.6.2@ppetraki/nana: Package folder /home/ppetraki/.conan/data/nana/1.6.2/ppetraki/nana/package/69f10d1e6d78c1962fbe8fb80440f32b1fdf8423 nana/1.6.2@ppetraki/nana: Calling package() *** PATH /home/ppetraki/.conan/data/nana/1.6.2/ppetraki/nana/build/69f10d1e6d78c1962fbe8fb80440f32b1fdf8423 total 83236 -rw-rw-r-- 1 ppetraki ppetraki 18108 Apr 11 15:58 CMakeCache.txt drwxrwxr-x 5 ppetraki ppetraki 4096 Apr 11 15:59 CMakeFiles -rw-rw-r-- 1 ppetraki ppetraki 2341 Apr 11 15:58 cmake_install.cmake -rw-rw-r-- 1 ppetraki ppetraki 23337 Apr 11 15:58 conanbuildinfo.cmake -rw-rw-r-- 1 ppetraki ppetraki 161 Apr 11 15:59 conanbuildinfo.txt -rw-rw-r-- 1 ppetraki ppetraki 424 Apr 11 15:59 conaninfo.txt -rw-rw-r-- 1 ppetraki ppetraki 85073766 Apr 11 15:59 libnana_d.a -rw-rw-r-- 1 ppetraki ppetraki 87965 Apr 11 15:58 Makefile drwxrwxr-x 8 ppetraki ppetraki 4096 Apr 11 15:58 nana *** nana/1.6.2@ppetraki/nana package(): Copied 2 files: push_ignore_diagnostic, pop_ignore_diagnostic nana/1.6.2@ppetraki/nana package(): Copied 1 '.a' file: libnana_d.a nana/1.6.2@ppetraki/nana package(): Copied 114 '.hpp' files: nana/1.6.2@ppetraki/nana: Package '69f10d1e6d78c1962fbe8fb80440f32b1fdf8423' created # THIS IS RIGHT ppetraki@vanguard:~/Sandbox/conan-nana-meson$ ls /home/ppetraki/.conan/data/nana/1.6.2/ppetraki/nana/package/69f10d1e6d78c1962fbe8fb80440f32b1fdf8423 conaninfo.txt conanmanifest.txt include lib Oh look, a nana dir, how did that get there. \*I\* didn't do it. Same python code! Broken in my sandbox, works in the system dir. &amp;#x200B; This makes the whole segmented workflow broken. Because it's retaining state from one build step to the next probably because it's all in the same process. It's probably using those environmental variables in the build() step in the package() step. &amp;#x200B; I'm going to back to my paranoid copy in the build step. This is clearly a bug, conan 1.10. &amp;#x200B; This would all be moot point if the package had an installer, but it's cmake... and no one knows how to do it \*all\* right.
Seems reasonable. Do you have an example of some other structure that should be considered to back the `raw_buffer`?
 &gt; And because it is C++ developement will take longer, not be as easier and has much more bugs so that extra months is something to deal with it and will be an increased cost,... It would be very useful to me, if I could see the source of this type of information. Otherwise it's just assumptions, which are hard to believe.
Abseil's `FixedArray` and `InlinedVector` satisfy, I believe, `ContiguousContainer` requirements.
I'll take a look. Thank you!
Boost.Compute also has its own array type for use by OpenCL. I suspect most GPU computing libraries do.
Do we need a submission for each "keynote announcement" of a particular conference?
It bothers me that I have to build it :/
Now, that's a hell of an answer!
What's wrong with the PDF?
&gt; "using python instead of c++ as a first language to learn programming is a big mistake". I never said this, and that extreme is wrong. In-fact I even said elsewhere I started with Basic before c. &gt; "people rely on abstractions to teach and that's a problem". I never said this. There's **always** abstractions. Whether that is good or bad depends &gt; then you should probably should not be using free/delete directly anyway is absurd In real c++ you don't use raw pointers. But you do when learning. &gt; students can't be exposed to c or c++ for their data structures and algorithms course I said they can better understand if they know what's going on at a lower level. Which language they use can be different depending on what their previous knowledge is. That could be c, c++, or even python. &gt; Same goes for assembler. Would you make it a first language to teach programming? If you won't, then you're changing the argument. This makes no sense. Changing what argument? You're claiming I said things I never said -- but you appear to agree with me on. So I'm not sure why you're taking that angle. This is why I first said it seems like you're misinterpreting people.
I didn't even realize there was a PDF ready to download among the source files. Thanks!
&gt;I can't say anything useful about the experience, since I don't notice any difference in speed (yet). I'm coding C++ more as a hobby, and my projects aren't that big. However, I am just curious why the precompiled headers are that huge. &gt; &gt;I have a rather simple C++ project right now, with 12 headers, totaling 577 lines (including comment lines and other include directives), and the ipch folder is 2.4 Gb in size. &gt; &gt;In any case thanks for the plugin, it's certainly very useful! The ipch folder size is highly dependent on which headers you have. It's a matter of which header files and how many. Hard for me to say without knowing the exact headers you're using. &amp;#x200B; Glad to hear you like the extension! Thanks for using it :)
Hi! &amp;#x200B; I think you might need to provide the "--source-folder" argument to "conan package" command, because in the cache, conan copies the source code to the build folder (you can have a look at the internals of the cache, it is relatively simple layout), but when you are in the local user folder this copy can't be done, as it would be very annoying for the user to have an extra copy of the source code which is the one being compiled but not the one in source control typically. So yes, the cache and the user-space layouts and flows are not exactly identical. &amp;#x200B; I'd recommend trying adding the "--source-folder" and if not, the best would be to file an issue in github, that is a better place for support.
Thanks!
Cool to hear, thanks for the info! Modules are of course quite a bit away (though I know - experimental implementations in the major compilers exist), and it would be nice to have the CPS functionality as well for C++14/17 projects. But perhaps modules are the needed incentives to start this initiative and to make it work for non-module projects as well.
What if you use auto&amp;&amp; x = bar() ?
In c++17 they have been modified as well.
Then you _also_ get the l-value overload! The reason is that the name of a variable declared as an r-value reference is always an l-value reference. The principle is that anything with a name could be referred to later on so the name is always an l-value reference. There are two arguments for this: it avoids use-after-move errors, and since an object can be used as an l-value multiple times, but it usually only moved from once, making the move explicit instead of the l-value uses requires less syntax. The only exception is returning the name of a local variable, where it can't be used later so it an r-value overload is tried first.
&gt; Also, it looks like Java style OOP might actually be the best way of doing GUIs in general purpose code Can you elab?
C++11 is almost a new language in an of itself. C99 (which still hasn't been universally adopted) was more of a language update. &amp;#x200B; I agree with you on pointers. Maybe the first time teaching a linked list in a Data Structures class. Definitely when writing to memory on embedded. Otherwise smart pointers or references seem to be the way to go.
&gt; the name of a variable declared as an r-value reference is always an l-value reference. It's just an lvalue, not a reference.
template&lt;class T&gt; void beetlejuice();
There are two lions (and a monkey) in this thread. It's a zoo out there.
It's value category is an l-value. It's type is an l-value reference.
I was literally just about to post this. I think that this is an incredible resource for two reasons: &amp;#x200B; 1. It gives a succinct definition of the terms, but **more important**, 2. It gives a history of the creation of the terms which helps set the stage for a better understanding, in my opinion. Thanks for posting!
Makes a difference if performance matters for you. Xvalues are necessary to define move constructors and move assignment operators.
like
c++大法好啊
nice
Welcome to China!
meet you with c++11/14/17/20 .
Aren't just rvalues in general needed for those two? From my understanding, xvalues only determine *what you get an rvalue out of*: an lvalue in this case.
 **That's awesome!**
nice
Thanks!
autotools?
An awesome meeting, the topics is very useful.
Hilarious that all the comments so far are from bots. Really gives some good Chinese vibes!
You can't ask bots to do that.
What is with all the bots? I haven't seen this happen before in this sub.
I searched their ID on IM and found they are all software engineers. Maybe they are just PureCPP participants with poor English
If someone lives in China, why would you welcome them to China?
Yes, you are right. They are C++ enthusiasts from purecpp.
Their content-free comments are contrary to [reddiquette](https://www.reddit.com/wiki/reddiquette).
Asking the hard-hitting questions, I see.
curiously recurring country pattern?
Are you going to speak Chinese? Ching Chong Cheng?
I think they were welcoming the invited speaker(s).
Yes.
OK, got it.
Yeah, that makes sense in hindsight. I've approved this comment.
thank you for your service
Yes, of course, I left that one out so that the post doesn't get too long. At any rate, my point is that there are situations where you absolutely need to avoid rounding errors, which means requiring more precision for the result than your operands can offer. So if you are using 128bit precision for your coordinates (for whatever reason), for computing these kind of geometric properties 128bit is not going to be enough. Anyway, in my code I solve this by using adaptive precision values that rely on FP expansions (based on excellent work by Jonathan Shewchuk).
Thanks you for posting this! Been hoping to find a nice write-up to get me started with AFL, and this is precisely what I was looking for!
The problem is that git/cmake require a totally different mental model than C++ and that C++ takes all the mental capacity of the developer, leaving no room for other things. Git/cmake are actually two more C++s that the developer needs to learn. Having to know 3 C++s is a big stretch for the mind.
I think it would be nice if we could have a C++ library that could be used to writing standalone C++ programs that, when executed, build our project environments. At least we wouldn't have to learn a 2nd programming language to use our 1st programming language. We don't need that much for such a thing, do we? After all, a build system's only task is to invoke tasks which invoke other tasks in a specific order. Build tasks are compiling, linking, installing/deploying, unistalling, which means invoking the compiler, linker, the copy command of the system (or the network variation of it), and the delete command of the system. Also, a few folder/VCS commands. This C++ library would actually provide the DSL that makes the tasks super-easy to invoke, test for errors, print errors.
On the other hand, learning Haskell is seriously helpful when coding C++. Both have very strong type systems, and C++ templates are also a [pure, lazy functional language](https://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/). If you ever open the box dark magic that is Boost Hana, knowing Haskell is almost a requirement.
&gt; PEGTL is [...] cumbersome in use. Could you give a specific example or similar of where you find the PEGTL to be "cumbersome", it might help us to improve things.
It makes no sense to treat GUI elements as values, so you always want a pointer / reference to it. You also don't worry about it's internals since it's far more than just the sum of its parts. You also don't want to delete it just because you've left the scope you created it in, since you need it till the window it's in has closed. This means you really need either garbage collection or manual memory management (or the Qt memory model where each widget has a parent). Inheritance based runtime polymorphism also makes a lot of sense, since it's very natural to use a different type of compatible widget based on runtime conditions, while you're running at the user's pace, so you don't need the performance benefits of avoiding the pointer indirection. Declarative languages like QML or graphical UI designers like Qt Designer are probably the best way (with the code using OOP), but if you really want to write the UI creation in code, OOP seems to be the way to go.
Yes, but the problem is that you don't want to program in other languages. And this is especially painful for remote devs - 90s C++ apps dev market is gone, now C++ is mostly a corporate/industry language, where it is used for OS/embedded/systems/engine software - unfortunately, such jobs are mostly onsite.
Nana has an install: just set -DNANA_CMAKE_INSTALL=ON https://github.com/cnjinhao/nana/blob/b0392bfa3c9542dcc5c402da917160ae97d79c59/build/cmake/install_nana.cmake#L12
&gt;the new calc of windows is an example, is need TWICE as RAM as the old one and for sure it is slower but it is still fast that you get the result instant and the under 10 MB has not important at all even the old one uses only 4-5MB, this scenario is what C++ is facing today so imagine in the future what could be I'll have to disagree with you. I find the longer startup time of the new calculator very annoying. On windows 7 it was just "Windows+R calc" and I could directly start typing. Now I have to wait, and even if it's just for a few seconds I am surely annoyed by it because I know it could be faster.
 Use updated nana: # [Nana C++ Library 1.7 Available Now](http://nanapro.org/en-us/blog/2019/03/nana-c-library-1-7-available-now/) Posted by [Jinhao](http://nanapro.org/en-us/blog/author/jinhao/) on [11 March 2019, 8:48 pm](http://nanapro.org/en-us/blog/2019/03/nana-c-library-1-7-available-now/)
Note this is "a compilation of two articles with extended descriptions, more examples and corrections" which were discussed previously in https://www.reddit.com/r/cpp/comments/auwicw/lambdas_from_c03_to_c20_part_1/ and https://www.reddit.com/r/cpp/comments/azt391/lambdas_from_c11_to_c20_part_2/
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/functionalprogramming] [Monadic parsing in C++ (Free-monads based)](https://www.reddit.com/r/functionalprogramming/comments/bcbkw2/monadic_parsing_in_c_freemonads_based/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Hey everyone! For my first reddit post I thought I’d share an old, but very useful project. I’ve recently refactored it for C++17, using cleaner code and better CMake support. It doesn’t do compile-time parsing, but I’ve found it great for rapid prototyping and it’s still fast enough for many real-world purposes. Would love to hear your thoughts and feedback!
Oh god, the change log for `beast` is just awful, how is it even allowed? Emojis and explanation marks all over the place, 50% of the text is begging for "like, share and subscribe"
}
Where's people's sense of humor? Could the changelog use a bit less hyperbole / exclamation marks / different font sizes / invitations to join the project? Sure. But it's a legitimate high-quality library. It's up to the Boost maintainers to curate their changelog.
This, end brace is seriously over-powered in C++.
It's the same reason that some people like onions and some people don't. It's called personal preference.
I guess so but that wouldn't really be a reason for hate. Like, if I don't like a certain music genre, I will just not listen to it, I will not go out of my way to hate on it.
Welcome to the Internet!
Things that are popular but not perfect often get hated.
Yeah, that's true actually.. makes sense..
Believe me, people can give you a hundred reasons why they hate C++ but in the end it all boils down to their personal preference. Some people seem to forget that programming languages are tools and some people are more comfortable using one specific tool even if their work would be easier or better using another tool. I don't really think it's useful to argue why your preferred language is supposedly better than any other or why C++ is bad or why any other language is bad. I mean what is even the point?
#**⚡ BIG Update!!!**
&gt; If you think you know C++ inside and out: a) your name is Bjarne. b) you don't know C++ inside and out.
If I send you flowers will you implement composite widget templates for it?
It's already pretty good to be honest, I like how I have more flexability in multi-language projects, and it's easier to just pop it open whenever I need it. Even uses less memory than emacs! VSCode is a great example of an electron/cef app that's not bloated and really leverages the work that's gone into web engines.
The more I use C++ the more I like C.
Easily this: [https://www.ioccc.org/1994/smr.hint](https://www.ioccc.org/1994/smr.hint) &amp;#x200B; Really hard to beat that denominator.
It's totally fine to use C++ as C plus some other bits. There's no need to delve into template black magic for every program you write. Use what works for you.
&gt; I never found anything in C++ or C that I thought was complicated and convoluted. I'm kinda curious about your level of expertise of C++. If you only do basic things (no template programming, no multiple inheritance, no ownership passing, etc.) then it's a pretty straight forward language. Still, it falls short of the simplicity of Python and the safety of Rust. If you are new to C++, you probably didn't get burned by some of C++'s bad design. Let's take the "variable++" as an example. Do you know the result of the following code just by looking at it? int i = 5; i += (++i)++; If you knew that the answer is 13, then congratulations. I had to compile and print it to check out the result. There are a LOT of things that are more complicated than it should be in C++. Maybe it's not complicated for you because you are writing C++ for a decade or two, but for a newcomer C++ is really intimidating and has a ton of pitfalls. Saying that C++ has no problem is kinda ignorant to me. &gt; It feels like it is a really simple language that just needs a good programmer to shine. This is like saying that piloting an airplane is simple, it just needs a good pilot. I'm still not sure if you are serious or not.
It's fine as long as we get quality lib. Also boost needs more fresh blood like beast.
 [🔥](https://emojipedia.org/fire/) Don't miss out! [🔥](https://emojipedia.org/fire/)
In what sense is it odd/sleazy?
C++ was very easy, modern C++ is not
**Company:** [ViewRay Technologies, Inc](https://viewray.com/) **Type:** Full time **Description:** We're currently seeking a senior C++ programmer for our world class Science team who will share our passion for conquering cancer and help us develop our ground breaking MRI guided Radiation Therapy system. You can find more info about the product in the link above. We're creating the software for our next generation cancer treatment system. This is a greenfield project in its early stages of development, thus any people who join now have the prospect of making key contributions to the architecture and design. The job includes: * Creating algorithms for processing MRI imaging data in real time and identifying anatomical features. * Working on a data processing framework which runs those algorithms and maintains a coherent system state. * Creating powerful visualizations for the users: graphs, charts, volumetric imaging renders, and more. We don't have any specific requirements other than 5 or more years of professional experience with C++. The project covers many fields and we feel that any C++ expert can find their place in it.. **Location:** Sofia, Bulgaria **Remote:** No **Visa Sponsorship:** No **Technologies:** C++17. Windows and Linux. The project also includes: * Custom high-performance algorithms running on multiple threads * Networking and network communications between nodes * Databases storing patient data * UI with complex graphical presentation and editing capabilities **Contact:** For questions and applications you can email me: [bstanimirov@viewray.com](mailto:bstanimirov@viewray.com) or apply at [https://viewray.com/careers/](https://viewray.com/careers/)
It's open source. It works. It's good quality. He can market it however he likes.
Actually its UB
Does your parser support the visitor pattern found in Antlr4? I have found this useful in building ASTs. If not is it on the roadmap?
He's rubbed me the wrong way on multiple occasions, but if his librarydoes what it says on the tin, I don't give a toss what he's like personally.
Ahh, sorry. I just compiled it with MSVC and totally forgot that it's UB. Thanks. It's now even clearer that C++ is simple /s
The way I see it, it is more about being consistent with the rest of the release notes than actual emojis or formatting. It is very distracting when only a single library is very different than the rest. Imagine reading a newspaper where suddenly one of the news is formatted completely different than the others... And of course they can do whatever they want, it is their release, but that does not mean people cannot give an opinion on formatting.
I'm not very advanced in C++.I have learned templates to a degree, I have also learned about inheritance etc. As I have stated I'm new to more serious programming as I just got into college. It seems simple to me. It really doesn't feel intimidating at all. This is the opinion of a new programmer. I feel more intimidated by a higher level language just because of the sheer amount you have to know about it. And I also don't find the pilot analogy exactly accurate since you have to be a pilot in order to pilot a plane anyway. I do not know enough about planes to further explain why I don't find this analogy accurate but I think you get my point.
And my experience is the exact reverse. The more I work with both C and C++ projects the more I like C++ particularly C++17 and the future is looking so much brighter than what we already have.
Well, I find it a tad annoying too, but it seems to work (there is not bad publicity) and apparently it isn't a case of marketing trying to compensate for a lack of quality, so there isn't a real reason to complain I guess.
the more I use C++, the more I think, that C should be eradicated everywhere.
Knowing these subcategories is valuable for a better understanding of the science and history behind the language. This knowledge is not of significant value for the purpose of code creation. At least not for the vast majority of coders. Knowing if your values are l or r, and how you treat l or r values differently is what helps when creating code. The biggest deficit in the majority of even seasoned C++ coders from what I've observed are the type deduction rules regarding auto&amp;&amp;.
&gt; Dynamic Bitset: Disabled hardware-assisted popcount (added in 1.69.0) on MSVC due to undefined behavior on older CPUs.
Knowing these subcategories is valuable for a better understanding of the science and history behind the language. This knowledge is not of significant value for the purpose of code creation. At least not for the vast majority of coders. Knowing if your values are l or r, and how you treat l or r values differently is what helps when creating code. The biggest deficit in the majority of even seasoned C++ coders from what I've observed are the type deduction rules regarding auto&amp;&amp;.
"These release notes are sponsored by Squarespace!"
🤤😲🤤😲 YOU WON'T BELIEVE ON THE LAST COMMIT!!! 🤤😲🤤😲
It is really exciting to see all the work going into fuzzing tools and infrastructure! I fully expect fuzzing to become a lot more common place in the near future.
&gt; I've never seen anyone market an open source project Iike that. &amp;#x200B; There’s a first time for everything. &amp;#x200B; If it surprises you that an open source software project is aiming for commercial success, perhaps you should revisit your understanding of Open Source Software.
"There are only two kinds of languages: the ones people complain about and the ones nobody uses." Bjarne Stroustrup
You should have seen it before I toned it down!
Interesting indeed.
Rust is nice (usual reasons; strongly prevents UB, etc.) but *some* of its adepts are insane. And that being said Rust safety has pretty much nothing to do with the lack of ++. Nevertheless, on my side I do thing that C++ is complicated and convoluted. The standard is what? 1700 pages? And even just the core language is sometimes crazy. See for example the recent post on ADL madness. But there are tons of things like that. Like the 6 different rule sets for type deduction. Etc. I've kind of a love / hate relationship with the C++: I know it quite well, and it took years to get to that; at the same time I find some aspect of the culture disturbing, in particular the persistence that UB are great because it is possible to "optimize" with them. Well it is also possible to optimize without. And I would rather not amplify the inevitable bugs to potential security vulns... That cultural aspect is crucially important IMO, and some C++ aficionados are too quick to dismiss the importance of strong guarantees against UB. Despite the experts knowing that it is impossible to avoid them currently in C++, and despite the stats telling us that roughly half of vulns coming from that. I honestly think this will either somehow change or (slowly) bring C++ to a decrease and even possibly a death in some fields (but very probably not all: it's not really important for most part of video games, for example, and some software can be structured using sandboxes to decrease the security impact of such bugs)
&gt; I never found anything in C++ or C that I thought was complicated and convoluted Innocence is bliss! ;)
Good point! I haven’t used Antlr4 before, so correct me if I'm wrong, but afaik can easily define grammars that are evaluated with a visitor pattern. The idea is to pass your visitor class as a custom argument to the parser. Syntax trees are traversed lazily and only evaluated by calling the `Expression.evaluate()` method. To illustrate, see the example below that evaluates sentences with a visitor pattern. struct Visitor; using Expression = lars::Interpreter&lt;void, Visitor &amp;&gt;::Expression; struct Visitor{ void visitSentence(Expression e){ /* visit sentence */ for(auto v:e) v.evaluate(*this); // traverse all words [...] } void visitWord(Expression e){ /* visit word */ [...] } }; lars::ParserGenerator&lt;void, Visitor &amp;&gt; program; program["Sentence"] &lt;&lt; "Word (' ' Word)* [.?!]" &gt;&gt; [](auto e, Visitor &amp;v){ v.visitSentence(e); }; program["Word"] &lt;&lt; "[a-zA-Z0-9]+" &gt;&gt; [](auto e, Visitor &amp;v){ v.visitWord(e); }; program.setStart(program["Sentence"]); Visitor visitor; program.run("Hello World!", visitor);
I brought up the ++ as an example for some of the people's extreme reactions which I really found hostile and borderline toxic. I actually like Rust I find it a very interesting language, even from my perspective (I do not have much experience with it). That is actually very insightful. Thank you for your reply It clears things up a lot. I'm new so I don't know how things work at a professional level all that much and I was just asking some things that came to mind.
&gt; ... it was noted that the implementation for MSVC failed to check for CPU support ... That seems rather logical, aren't you supposed to check this once and then thereafter follow the 'correct' code-path, checking that every time you call this function will defeat the purpose [to be faster, due to hardware-support].
Are you nuts? I upgraded Beast from 1.69 to 1.70 and experienced Huge Wins. It compiles faster, takes up less source code and is easier to write correctly!
This is really cool, thank you!
People still use Boost in the year of our lord 2019?
Since `auto` type deduction follows the same set of rules as template type deduction, I guess it's the same as when you write `T&amp;&amp;`; with `T` being a template parameter.
These reply on boost and are parallel by wrapping them in a mutex, is that correct?
If one wants a deque that delivers some speed using the VC-STL, there's only `boost::container::deque`to choose from (or eastl, I guess), so yes. That dynamic bit-set is another one [see other post elsewhere in this thread], as the std one is static.
Boost Asio and Boost Beast are good networking libraries. STL does not have networking yet.
No problem! Be careful that some people have very strong opinion (including myself :p ) and that sometimes that makes them seem (or even be) upset toward others. While this is not often very productive, my observation of the internet makes me think this is unfortunately ineluctable. The strictness of some languages usually comes from an attempt to avoid bugs -- and if it does not then it might be considered a design mistake. Given the difficulty (and fragility in presence of further modifications) of abstract interpretation, radical solutions like types (or functional programing where nothing is mutable, but it is often on top of types) are often used. A type restrict what can be put in variable of such type. But we do not do that to be gratuitously insulted by the compilers; rather, it allows to reason more easily about what can happen, both ourselves and compilers plus other tools, so that we can deduce some properties without having to know the context: it is way easier to know that a[i] never goes out of bound when the type of a gives its number of element, and the type of i covers a smaller space, than to check that all code paths leading to a[i] can never dynamically produce values that are out of bounds for a. The same goes for lifetimes, one of the core Rust value proposition. But obviously types restrict what a programmer can write, even in some case for some legitimate programs. So there is not ultimate solution, neither is there a (practical) solution where types could be so evolved that all bugs would disappear: because then major part of the complexity would fall into the definition of types, and the mistakes would simply be in there. In consequence, as there is no silver bullet, it is all about trade-offs. And some people value some aspects more than others, plus all projects are not the same. So it's just "use the right tool for the job", in the end.
you could still using [A.C.E.](https://www.dre.vanderbilt.edu/~schmidt/ACE.html)
This really helped me understand the thought behind it. Seems like I have kind of misunderstood the purpose of strictness! Thank you very much again!! Have a great day!
They don't rely on anything, the repository is self contained. It does use code from the Google Abseil library though. If you want internal synchronization (which is optional), you can specify a mutex class. You can use `std::mutex`, but if you want to use a boost mutex instead then yes you need the boost libs.
&gt;Sav ??&gt;
So why did you do that?
its Ok, we already had one "subscribe to pewdiepie" commit message at my place.
A big downside of Nana is that it uses some sort kind of hacked together text markup for layout. It is hard to get things to work right and hard to debug.
C++ like it's 1993 ;)
Some of my colleagues actually like nana because of that markup. I guess it's about preference to some degree?
&gt; Rust not being like older "BAD" "UNSAFE" "COMPLICATED" and with "TERRIBLE SYNTAX" languages like C++ and C Programmers, supposedly very rational creatures, are actually very emotional and passionate about their toys. If you feel too much emotion in a comment, take it with a grain of salt, it's probably exaggerated. &gt; lets you compile things that might turn out like shit but I think that's why it is good. When working in a team, in a large project, the less options you have to do something, the better. Stuff tends to be more standard, easier to follow. Experience taught me that maintainability is the *single most important thing* in a large team codebase. Personally, I prefer to have a highly restricted language that protects everyone from writing defective code, even if it's more cumbersome to write. It pays off. But yeah, if you're working alone in a hobby project, freedom may be more pleasurable. &gt; Why should a programming language be so restrictive? Imagine driving a car with unlimited speed, individual brakes for each wheel, no bodywork and no suspension: a car that *doesn't protect you* from doing bad things. Now imagine not only you, but *everyone* around you driving this car. Scary? &gt; I never found anything in C++ or C that I thought was complicated and convoluted. You will... &gt; Sorry if this feels like a rant It doesn't. It's pretty normal, and it's good for your own development (pun intended) to question things. C and C++ a great languages, I love them both, and I hate them both. I also love Rust, and I hate Rust too. The right tool for the right job is the wisest thing I learned, after spreading love and hate for a long time.
Is it parallel without the mutex?
Thank you for your reply! It helps me see this from an other perspective. I've only worked in very small teams and with very small projects so I haven't encountered problems but I can definitely understand how difficult it can be when working on bigger stuff. Your analogies are great I really understand the thought process now. Thank you again! You really helped me understand the situation more!!
Indeed, Stroustrup himself famously rates his own knowledge of C++ as "7 out of 10". If OP genuinely believes C++ is easy to learn, this is surely a case of [the Dunning-Kruger effect.](https://en.wikipedia.org/wiki/Dunning–Kruger_effect)
I can see why someone would say that initially. At first I wondered if it was better, worse, or just different. The fundamental aspect though, is that an invented markup is the worst of all worlds. You can't see or affect any sort of state or layout data directly. If you could pass a data structure to it or use some function calls it would be much different, but because it is text that gets embedded into a program, it just creates an opaque layer between the program and the layout for no reason.
You could use the standalone version of both of those libraries as well.
I guess parallel may give a wrong impression. The repo includes regular hash maps (like phmap::flat_hash_map) and a parallel version (phmap::parallel_flat_hash_map) which internally contains multiple flat_hash_maps. Please read this (https://greg7mdp.github.io/parallel-hashmap/) for a full explanation.
So how does the parallel hash map synchronize?
But can it parse C++ itself?
Beast depends on Boost.
It's a period of strife in the C++ community. Printf-style formatting, striking from a hidden base deep inside Boost, have won a major victory for followers of the %. Armed with spdlog, the printf warriors threaten to take over logging subsystems across the cloud. They are pursued by forces of stream logging, who have fortified Boost.Log2 and have a strong presence in log4cpp.
Are you asking me why I am promoting Beast, and reaching out to users for feedback?
Effective C++ rules aren't about formatting but about programming style or common patterns and mistakes to avoid. Thus, they aren't relevant to clang-format, which is only about formatting (e.g. which line to put the open brace), they are for clang-tidy (and some of some are hard/impossible to enforce by a tool)
Because you spend all your time trying to solve problems in the language domain (C++) rather than in the problem domain. A good language should allow you to solve problems. Most of the C++ blog posts are not 'look at this cool product I built', but rather 'look at this cool obscure new use of templates'.
I tend to deviate from this discussion. I dont think style really matter. As long as it does it thing like log a useful message to a route of your choice and does it fast then that is enough for me. But again thats me, cant say the same for other people. Perhaps they really care about format that much. But I think at the end of the day, you only look at the output, so why bother in the format dilemma? Just my 2 cents
Yes, and some people are making nice high level libraries with it. https://github.com/LeonineKing1199/foxy
In a multithreaded app, you can either provide a mutex type (for internal synchronization), synchronise yourself, or most efficiently manage the mutable operations so that each thread uses a different set of internal submaps. Example are provided in https://greg7mdp.github.io/parallel-hashmap.
It's got some fantastic libraries. If you can afford inclusion of a heavier library, why would you not?
Unfortunately on a large scale, yes. I would hope that boost would do a major redesign by rebasing to e.g. to C++14. That would remove boost::shared_ptr, weak_ptr, lost of boost random, boost::function, boost::noncopyable, BOOST_STATIC_ASSERT, BOOST_STATIC_ASSERT_MSG, boost::thread, boost::mutex, BOOST_FOREACH, boost::regex, boost::array, boost::tuple and likely more. The fact that many developers still add these kind of types instead of using the std counterparts is very sad. From this perspective, boost keeping compatibility with old compilers and source compatibility with itself is a sad story :-)
Yes. Many useful libraries: you should check them out.
I think is possible, but honestly sounds like a nightmare to do correctly. :D FYI I’ve made an [example](https://github.com/TheLartians/Parser/blob/master/examples/type_checker.cpp) that shows one of the horrors of c-style type parsing.
&gt;Reply \`boost::shared\_ptr\` is better than \`std::shared\_ptr\`
I think you underestimate the importance of inclusivity in such a large project.
Indeed. What about Python and it's semantically significant indentation?
I think people see it as unprofessional and they’re asking why you chose to do it the way you did.
That works. Thanks. I did look through the nana cmake but I guess not closely enough. I'll chalk that up to climbing several learning curves simultaneously. When cmake install fails, I don't think it's often a developer says to himself 'maybe it's an option?' because standard practices dictate that a good library have an installer. Tests I can see as optional, but an install? &amp;#x200B; For the record, the relevant part of the installer looks like this now: def build(self): cmake = CMake(self) # cmake install target is not enabled by default. It installs # everything into package/ under the build dir. cmake.definitions["NANA_CMAKE_INSTALL"] = "ON" cmake.configure(source_folder=self._vcs_folder) cmake.build() cmake.install() # BTW self.source_folder ceases to exist in this step def package(self): self.copy("*", dst="include", src="package/include") self.copy("*nana.lib", dst="lib", src="package/lib", keep_path=False) self.copy("*.dll", dst="bin", src="package/bin", keep_path=False) self.copy("*.so", dst="lib", src="package/lib", keep_path=False) self.copy("*.dylib", dst="lib", src="package/lib", keep_path=False) self.copy("*.a", dst="lib", src="package/lib", keep_path=False) Just a little cleaner :)
Now that’s a challenge! I think with a bit of manual filtering it could work. I’ll try later and let you know. :D
I disagree that it is unprofessional. And it achieved one of the intended purposes: to raise awareness of Beast. Critics are calling the improvements in this version "a game changer." Automatic timeouts, websocket idle pings, bandwidth limits, much much more - this is a radical transformation in terms of ease of use and expressive power, and I want people to know about it. There exists considerable opposition to Networking TS (which is fundamentally the same as Asio and Boost.Asio) and I need the entire C++ community to rise up and get behind both Networking TS and Beast. Thus I am making a lot of noise.
What are you? A fucking retard?
Tone it down, i meant.
Well, the final release notes use a different .css stylesheet than the one which is used when you build locally or preview the built HTML here ( [https://www.boost.org/users/history/in\_progress.html](https://www.boost.org/users/history/in_progress.html)). The first iteration had too many emojis and style changes and it took too much attention away from the important parts (the features). I was also surprised that emphasized text used the equivalent of black rather than bold (in other words the font stroke was ridiculously heavy). I adjusted it to try to get just the right balance between standing out and staying tasteful, I think it was a success.
It shows your enthusiastic [good].
You might also try astyle, but it doesn't seem to understand some C++11 syntax. I also haven't been able to get it to handle the alignment for multiline parameter lists the way I want.
The special treatment / promotion of Beast in the release notes is not going to be a regular thing for a few reasons. First of all if it is in every version (and/or every library does it) then it loses its value. Second, because there won't be such a large update for a while. I'm working on some other exciting Beast-related open source stuff. And I think that in 1.70 I put a little bit too much into it, I should have spread it out over two Boost releases because bugs were being found right up until the last hours before the release - it needed more time to bake and since the release dates are fixed the only way to do that is to introduce less change per version.
Hmmm.... on desktop Chrome the black face is still there (way too bold in my opinion) but on iOS Chrome it has a lighter weight.
Now that I’ve actually looked at the notes, I don’t think they are or were unprofessional. I thought it was more like the commenters above who used tons of emoji. I think you only have 3 emoji out of the ~100 words. I’m not good at estimating number of words but your ratio of emoji to relevant content is fine. My apologies for the accusation since the original comment or was talking about something different entirely.
What makes it better?
clang-format is just code formatting and has nothing to do with static analysis. It will set your braces and indentation straight and stop there. What you're looking for is [clang-tidy](https://clang.llvm.org/extra/clang-tidy/checks/list.html). You won't find everything as a check because some things are either not checkable or have too high false positive rate. I never implemented a check myself but I have [this](https://bbannier.github.io/blog/2015/05/02/Writing-a-basic-clang-static-analysis-check.html) blogpost lying around in case I need to.
* [F.17: For “in-out” parameters, pass by reference to non-const](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-inout) * [E.2: Throw an exception to signal that a function can’t perform its assigned task](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-throw)
What makes it better?
it has additional features such as acquiring a "local" pointer (not atomically ref-counted), there is also \`raw\_from\_this\` and an extra constructor. Note that \`boost::shared\_ptr\` came first, \`std::shared\_ptr\` is based on the Boost one.
&gt;boost keeping compatibility with old compilers and source compatibility with itself hinders the evolution of modern C++ :-) You have it backwards. People don't stay on their "old compilers" because Boost continues to support them, they stay on those old versions because of business requirements that cannot be changed. Every individual developer (myself included) would of course like to use the latest C++, so if it was up to them more projects would be updated.
Why are people so shaken by the presence of emojis in the changelog?
I was aware of the pedigree but not the additional features. Thanks for the info.
It's even more complicated, it's UB in C, but in C++ it was UB before C++17, but ok now.
I'm a little hesitent to throw exceptions unnecessarily. Ideally I'd like to use an `expected` library. Maybe I'm way off on this topic
Also, \`boost::shared\_ptr\` tracks the C++17 \`std::shared\_ptr\`, so I can use it in Beast which only requires C++11.
If you’re using Visual Studio, there’s the clang powertools extension that wraps up both format and tidy and has a bunch of tests built into it. There’s also cppcheck, which also has a VS extension. And if you’re using VS2017+, it’s also worth having a look at the code analysis settings for each project. They reference the cpp-core guidelines.
A few of the features of boost.math can be found nowhere else. For instance, the Lanczos denoising derivatives based on McDevitt 's 2012 paper is only to be found there. The univariate and bivariate statistics based on Pebay's 2009 paper is the only place where you can compute a covariance using a single pass through the data. Two new measures of sparsity are provided; I believe no other library provides these nor have I talked to anyone who recognizes how important a problem this is. For a more pedestrian problem, accurately finding the roots of a quadratic function is now implemented; this problem was only satisfactorily solved in 2013 by judicious use of a fused-multiply instruction.
Do you have any performance comparision of functional parsers vs more traditional approaches? We did some monadic parsers using haskell in university and I reimplemented it in c++ to learn. I did it really badly, including using a lot of in std::function, and ended up with the most horrible performance I've ever encountered. It would surly do way better if implemented by competent people. Is your library (or monadic C++ parsers in general) comparable in terms of throughput to things like boost::spirit (or whatever)? Or is it *just* offering better ways to build grammers?
https://www.boost.org/libs/outcome/
Cannot agree more. All of us (both lib's developers and users) should get benefit from the new C++ features. Even OS(Windows/Linux...) and the C++ language itself are moving forward and cannot get rid of API/ABI break, why a lib should insist on stubbornly?
Neat.
I don't think the decision itself matters, but I think a single codebase/org needs to chose one and enforce it mercilessly.
Very much agree. It would also significantly flatten/disentangle the boost internal dependency tree. But realistically, hell will freeze over before that happens, because many boost libraries don't have an active maintainer anymore that would do the work. I've been wondering for some time now, if it would be realistic to create a boost fork or boost2.0, that only contains functionality not provided by c++17 - either in the standard library or via language features (which is still a a lot) . My guess is that creating such a fork is possible, but keeping it up to date is probably not.
You don't need the `using` declaration. I am comfortable relying on the convention that if one output is a by-reference input, they all are, and any result is for success/error status. It helps if you give your function a more meaningful name than `foo`. Seriously, it seems bizarre to me that you go to the trouble of naming a class for the return value, but use meaningless names for everything else. Sometimes an alternative is to return multiple values in an object. Some people will use a `std::pair` or a tuple, but a custom class is usually clearer.
clang-tidy is very useful - we implemented a code checking regime around it. Note that you will want to suppress many of the warnings depending on your standards and what you deem important. In some cases you may want to implement additional checks, as we did.
If they refused to upgrade their own code, why you think they would be willing to upgrade the dependent code?
Actually, I've seen the fact that boost provides some of the benefits that using a newer standard would used as an exuse to further delay the upgrade of the toolchains a couple of times now (less so in last 1-2 years). It is a two way street: Those "buissness requirements" are very often no hard requireents, but tradeoffs being made: How much would it cost us to upgrade vs how much do we benefit? And in some cases, the only reason, why staying on the older standard is a viable/cost-effective choice is thanks to boost (which is - just to be clear - a good thing). Of course that doesn't deny the fact that there are industries where an upgrade is really not possible due to other reasons, but I believe that most of the time it just comes down to cost extimates. And whearas the cost of upgrading can often be quantified relatively easily (e.g. certification of new toolchains), quantifying the benefits of such an upgrade in hard numbers is much more difficult.
Oh, that's piece of code looks a bit suspicious: ``` auto p = bind&lt;Char, R&gt;(digit, [=](Char dg0) { return bind&lt;Char, R&gt;(lower, [=](Char ch1) { return bind&lt;Char, R&gt;(symbol('2'), [=](Char ch2) { return pure&lt;R&gt;(R{dg0, ch1, ch2}); }); }); }); ``` If I reformat it slightly via `clang-format` it becomes ``` auto p = bind&lt;Char, R&gt;(digit, [=](Char dg0) { return bind&lt;Char, R&gt;(lower, [=](Char ch1) { return bind&lt;Char, R&gt;(symbol('2'), [=](Char ch2) { return pure&lt;R&gt;(R{dg0, ch1, ch2}); }); }); }); ``` it reveals going into the depths structure, which is not nice, IMHO. It would be better to keep flat structure, like ``` autoo p = bind&lt;...&gt;(.., [=]{ ... }) .bind&lt;...&gt;(.., [=]{ ... }) .bind&lt;...&gt;(.., [=]{ ... }); ```
I think the main problem is the way people are introduced to C/C++. The first exposure is usually in high school, or university. It is done by a teacher who has no clue what he is doing, and then goes, and explains some kind of zombified object version of K&amp;R C. The first lecture contains "you will need to understand pointers first, but that's to complicated for 80% of you anyway" within the first 15 minutes; And that's the end of it. The teacher manged to anchor the students on "this is hard" -- for good. If you don't believe me go to a few C/C++ intro courses, and you will understand. &amp;#x200B; It's very rare that the teacher goes "70% of everything run on this" or "it uses less than 50% of energy as the same thing in {Java/C#/Python}" or even "just read these 5 lines \[of hello-world\], and guess what they do". If you put the idiomatic Hello-World in 5 languages in front of students who never programmed before, and never got scared by a bad teacher, and ask them which one is easiest to understand C always wins - I did that for years in my Java-Intro course. Pure and simple: It's brainwashing.
What do you mean by "supporting grammar ambiguity"? PEG is unambiguous by design.
&gt; It helps if you give your function a more meaningful name than `foo` That was just a placeholder, the "real" function wouldn't have that. &gt; Sometimes an alternative is to return multiple values in an object. Hmm how would that work? Something like this? tuple&lt;A, B, Error&gt; foo(A a, B b); tie(a, b, error) = foo(a, b);
Because it looks pretty lame.
Oh dear. The original submitter wrote : &gt; TODO: &gt; I don't have Windows to test its code (the Windows code in the PR I wrote looking at other libraries' code and using common sense). Apparently it has to have runtime checks calling __cpuid - docs: To determine hardware support &lt;...&gt; If you run code that uses this intrinsic on hardware that does not support the popcnt instruction, the results are unpredictable. But the maintainers merged the PR without addressing that TODO, and no one noticed. Still, easily done, and I doubt there's much danger . Should just be a SIGILL on any machine old enough not to have popcnt.
I've extended PEG grammars by means of "filtering" input through a callback. That makes it possible to parse grammars that typical PEGs wouldn't be able to handle. For example, in C style languages the expression `a * b;` could be either a pointer definition or a multiplication depending on the context. With help of the callback this can be [resolved](https://github.com/TheLartians/Parser/blob/master/examples/type_checker.cpp). Maybe "context-dependent" would be a better description than "ambiguous" though.
Does it manage the internal submaps itself? If so, how does one thread get a key that was put in by a different thread?
Maybe they could encourage the other library maintainers to be more overtly enthusiastic 🎉? This is the world 🌍 we live in.
Let me guess, your work may involve embedded systems in automotive industry and it may follow MISRA code guidelines for safety critical systems. A big problem of C++ is that it is hard to build tools for it since the language grammar is pretty complex and the C++ ISO standard has more than thousands of pages. I've seen lots of commercial tools for C and C++ code static analysis for ensuring compliance with MISRA code guidelines, I guess that it may be the reason why they exist.
Thank you too!
The parallel_flat_hash_map is seen by the app as a single hash map. Any thread can access all the keys that were inserted into it. If you mutate the hash map from a multithreaded app you need to synchronize these mutations, or make sure that different threads mutate different submaps.
A person might (only half-jokingly) argue that everyone hates C++, even the people who use it. Hence, why the past decade has seen a systematic attempt to make it into something completely different. If you brought someone forward from 1990 and showed them a piece of over the top 'modern' C++, they might well think it's a completely different language. As to why programming languages should be so restrictive, it's because time it VERY expensive and really pissed off customers are VERY dangerous to your company's reputation and non-trivial software is VERY difficult to write to begin with much less keep stable over many years and likely fundamental changes. It is orders of magnitude better to put in more time up front to be as explicit and typesafe as you reasonable can, than to deal with silent but deadly errors in the field that are mind-numbingly hard to figure out.
Unhelpful and pretty verbose error messages, pretty slow compile-time, very verbose syntax, code duplication and separation of header and source, easier to shoot your own foot as any runtime error can make you spend hours tracking bugs in a debugger. But there are still lots of situations where C++ is the only solution possible or the most convenient one. I guess that another problem is the value semantics that treats all types and even composite types such as classes like values that are copied when passed by value. SomeFunction(object A), In other languages like Java and C#, all class instances are passed by reference by default. This C++ behavior can cause bad surprises for developers coming from other languages.
It seems that all Intel CPU's since Nehalem (released in 2008) and AMD cpus since Barcelona(released in 2007) support popcnt. [https://en.wikipedia.org/wiki/SSE4#POPCNT\_and\_LZCNT](https://en.wikipedia.org/wiki/SSE4#POPCNT_and_LZCNT) I am not sure how many 10+ year old CPU's are still actively running code that will be compiled with MSVC and Boost 1.70. It seems like this change will slow down the code of the vast majority of people for the benefit of very few.
Unfortunately, I didn't do a such comparison, and don't know if someone did. I think, the parsers in Haskell are made well and behave with a good performance. However, I guess parsing with a specially configured state machine will be much more performant. But who knows. &amp;#x200B; I wish I had a time to make comparison with boost::spirit, but there are several things to consider here: * Boost::spirit is a collectively created library that's being tweaked and optimised for tenths of years or so. * I've created my library for two weeks as an MVP just for the presentation. Don't expect it to be performant. &amp;#x200B; BUT. After I created the STM library on the normal form of the Free monad, it was unnecessary slow because of the nature of this monad. Later, I've moved it to the Church-encoded Free monad, and the performance is increased by an order of magnitude. The parsers library is based on the normal form for now. I started with the Church encoding initially, but the complexity went out of my brain too soon, and this could end badly for my plan of talk preparation. So for now the library is much slower than it could be. &amp;#x200B; And yes, my library is intended to show that there are another ways of doing parsing, not only boost::spirit (that I seem to be very complex and verbose).
The type alias Error is not very meaningful, since the type optional&lt;string&gt; can be either empty on error or return a string as a value. The best way to pass variables is: pass primitive types such as integers, float, double and pointers such as int\* by value and complex types such as instances of classes, std::string, std::vector by const reference if the function is not supposed to change the parameter or by reference for avoiding copy overhead. This type of error will also fail if there are many types of errors.
Quite the opposite.
That's for sure, fluent interface can be much better. However, we'd be more happy if C++ had a support for monads, for example like it's in Haskell. Pseudocode: auto p = do ( Char dg0 &lt;- digit; Char ch1 &lt;- lower; Char ch2 &lt;- symbol('2'); ); I have a long history of trying to implement a \`do notation\` in C++, and all my attempts are failed so far. It's all not behave well and often the main problem is type deducing which is really bad in C++.
We've had issues with popcnt in our software on extremely old cpus and resorted to use std::bitset::count() It wasn't performance critical in our case but I definitely can second that popcnt will cause crashes on old hardware.
rustaceans are a zealous bunch, frankly their language in't even worth paying attention to, let alone caring about their ridiculous opinions.
Bravo!
Beast release notes: &gt; On Windows, Visual Studio 2017 or later is required /u/VinnieFalco out of curiosity, what's the story on this?
Like this? [https://github.com/ppetraki/conan-nana](https://github.com/ppetraki/conan-nana) Development of the actual conan package will be focused here moving forward.
The [C++ Middleware Writer](https://github.com/Ebenezer-group/onwards) has serialization support for a number of containers in Boost. I'm open to adding support for more things in Boost if there's interest.
What did I do?
Technically, Parallelism is not the same as Concurrency. In short, concurrency is for correctness, parallelism for speed. E.g. using vector instructions is parallel without using threads/mutexes or the like.
That's a rare thing when someone thanks me for my work :)
I mean Linus rubs me the wrong way sometimes and I saw Stallman eat his own foot once (I'll never look at the Gnome logo the same way again), but that hasn't stopped me from using GNU/Linux. &amp;#x200B; This industry has egos, big ones. Try not to spend too much energy dealing with it. &amp;#x200B; I've seen a few of Vinnie's presentations; he has strong opinions sure, he created it. I'm sure we've all also met humble architects in our time. However having no first hand experience using Boost beast, I don't know what you're talking about. &amp;#x200B; Also, without examples of what "odd marketing" \*is\*, this comes off as a smear IMHO.
&gt; I will introduce two new warnings I’ve implemented for GCC 9 that deal with incorrect usage of std::move GCC9 keeps sounding better and better
I'm still not getting this. If different threads are writing to different parts of the maps, but all threads can read the whole map, how do you prevent a thread from reading in the middle of a write? Are you using a mutex or doing it with atomics?
No one is forcing boost on you...
You are right, if you decide to not synchronize, then each thread must read and write their own submaps while mutation occurs. Afterwards if there is no mutation then the map can be accessed as a whole.
Oh. Well no need to thank me for thanking you for good work :-) Have you considered doing applicative parsers as a next step?
Ok, but where does that synchronization occur? Does the user need to keep track of which threads are doing what?
Also clang-tidy has the capability of *editing* your code - on request - if it knows how to fix the problem it has found. Use to **-fix** option to do that.
&gt; Does the user need to keep track of which threads are doing what? yes
There was an annoying compiler bug which I finally found a workaround for, but I forgot to update the release notes - Beast should work fine on VS2015: [https://ci.appveyor.com/project/vinniefalco/beast](https://ci.appveyor.com/project/vinniefalco/beast)
That's a bit of a relief! Thank you!
So I've managed to get a proof of concept working [here](https://github.com/TheLartians/Parser/blob/master/examples/python_indentation.cpp). But it feels somewhat hacky. Finding a more elegant solution is definitely on the roadmap now.
&gt;I would hope that boost would do a major redesign by rebasing to e.g. to C++14. That would remove \`boost::system::error\_code\` (part of Boost.System) is ahead of \`std::error\_code\`, and the C++ committee rejected the improvements at the San Diego meeting. So "rebasing to C++14" would be a backward step.
C++ is probably the only language you can't have enough conferences for.
Oh, nice. I don't even know how to write a clean grammar that describe the Python scoping rules. Probably it's described a little bit like you implemented it, so you might not be so far off.
because it will make easy thinks very hard sometimes. and it smells very bad. \- i have to maintain \*.h files and \*.cpp files. when I write a class and add a function. I have to open 2 files. \- compare adding a library code from github with java. really i have to compile the cpp lib for my project? so people start writing header only Libraries. \- Makros \- lack of proper string function i can't get the length of a string in cpp. and i don't understand why std::string exist when any STLcontainer basically will do the same. \- i still have to write std::begin(v),std::end(v) // std::copy(from\_vector.begin(), from\_vector.end(), [std::back\_inserter](http://en.cppreference.com/w/cpp/iterator/back_inserter)(to\_vector)); \- a lot of basic stuff is not part of the standard. so everything is library we don't have std::net, std::gui, std::sql, std::crypto, std::xml etc using library code is hard. \- template error messages is nightmare good luck finding the source of error compiler will only tell me it is std::vector&lt;&gt; but not in which cpp file. \- std::visit exist \- &amp;&amp; exists \- int i = 5; exist why not enforce int i {5}; \- std::reference\_wrapper exists \- reflection is not in. How many people want the name from enum err\_c : int { invalid\_msg} invalid\_msg.c\_str() ??? \- constexpr is missing on some many things \- explain a beginner while type&amp; and type\* exists
is smr.c empty?
Don't forget the worst of the lot, MPL. So many Boost libraries pull in MPL, and it causes many annoying problems. And it's completely unnecessary with variadic templates since C++11.
Aw man, VS2017. I'm still on VS2013, but the idea of live editing C++ is amazing. Good work.
Yeah, indentation-based scoping rules are totally weird, at least from a PEG point of view.
Honestly I would not involve myself in China at this point in time. Sadly the government there seems to have fallen off the rails and is resorting to widely applied oppression of its citizens. It is a shame really because China has come far in a couple of decades just to see things go evil again. This may sound political but it is also reality.
Will we also be seeing warnings the other way around? I.e. "you should consider moving here"?
I'm aware about their existence, but this is all I know. Yes, that would be very interesting to research. &amp;#x200B; In the current implementation, I'll create some 'applicative-like' combinators that will allow to use the monadic parsers in applicative style. But AFAIK, this is not the same thing as applicative parsers.