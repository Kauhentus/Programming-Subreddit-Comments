I agree. Just for the fun of it, I took your solution and added the string to id conversion. Using C++17 stdlib, it was pretty simple (try\_emplace works really well for this). Except for renaming the original struct and data to \_raw, and calling string\_to\_id, the logic is pretty much unchanged, except for the output which converts the id back to a string for display #include &lt;cstddef&gt; #include &lt;cstdint&gt; #include &lt;vector&gt; #include &lt;array&gt; #include &lt;tuple&gt; #include &lt;map&gt; #include &lt;unordered_map&gt; #include &lt;string&gt; #include &lt;string_view&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; std::uint64_t string_to_id(const std::string&amp; s, std::unordered_map&lt;std::string,std::size_t&gt;&amp; string_to_id, std::vector&lt;std::string_view&gt;&amp; id_to_string){ auto id = string_to_id.try_emplace(s,id_to_string.size()).first-&gt;second; if(id == id_to_string.size()) id_to_string.push_back(s); return id; } int main() { struct access_raw_t { std::string customer_id; std::string page_url; std::uint32_t timestamp; }; std::vector&lt;access_raw_t&gt; accesses_raw = { {"Carly Gauss" , "https://bogusworld.net/home.html" , 20}, {"Lenny Oiler" , "http://bigeyedfish.net/index.html" , 5}, {"Lenny Oiler" , "http://bigeyedfish.net/signup.php" , 45}, {"Stevie Hawkley", "http://makebigbucks.com/login.php?id=none" , 60}, {"Stevie Hawkley", "http://makebigbucks.com/login.php?id=644" , 68}, {"Stevie Hawkley", "http://makebigbucks.com/ripoff.php" , 48}, {"Lenny Oiler" , "http://bigeyedfish.net/Walleye.html" , 45}, {"Carly Gauss" , "http://bogusworld.net/interviews.html?v=43", 20}, {"Carly Gauss" , "http://bogusworld.net/interviews.html?v=53", 24}, {"Stevie Hawkley", "http://makebigbucks.com/ripoff.php" , 58}, {"Lenny Oiler" , "http://bogusworld.net/signup.php" , 20}, {"Lenny Oiler" , "http://bigeyedfish.net/Nemoids.html" , 92}, }; struct access_t { std::uint64_t customer_id; std::uint64_t page_url; std::uint32_t timestamp; }; std::unordered_map&lt;std::string,std::size_t&gt; customer_to_index; std::unordered_map&lt;std::string,std::size_t&gt; url_to_index; std::vector&lt;std::string_view&gt; index_to_customer; std::vector&lt;std::string_view&gt; index_to_url; std::vector&lt;access_t&gt; accesses; accesses.reserve(accesses_raw.size()); for(auto&amp; ar:accesses_raw){ auto customer_id = string_to_id(ar.customer_id,customer_to_index,index_to_customer); auto page_url = string_to_id(ar.page_url,url_to_index,index_to_url); accesses.push_back({customer_id,page_url,ar.timestamp}); } std::sort(accesses.begin(), accesses.end(), [](auto&amp; a, auto&amp; b) { static auto const key = [](auto&amp; x) { return std::tie(x.customer_id, x.timestamp); }; return key(a) &lt; key(b); }); std::map&lt;std::array&lt;std::uint64_t, 3&gt;, std::size_t&gt; histogram; for (std::size_t i = 2; i &lt; accesses.size(); ++i) { auto&amp; a = accesses[i - 2]; auto&amp; b = accesses[i - 1]; auto&amp; c = accesses[i ]; if (a.customer_id == b.customer_id) { ++histogram[{a.page_url, b.page_url, c.page_url}]; } } auto top = std::max_element(histogram.begin(), histogram.end(), [](auto&amp; a, auto&amp; b) { return a.second &lt; b.second; }); if (top == histogram.end()) { std::cout &lt;&lt; "\nNo top three page sequence exists." &lt;&lt; std::endl; return 0; } auto&amp; [a, b, c] = top-&gt;first; std::cout &lt;&lt; "\nTop three page sequence is :\n" &lt;&lt; " 1. " &lt;&lt; index_to_url[a] &lt;&lt; "\n" &lt;&lt; " 2. " &lt;&lt; index_to_url[b] &lt;&lt; "\n" &lt;&lt; " 3. " &lt;&lt; index_to_url[c] &lt;&lt; std::endl; }
That's a very reasonable option, I may end up taking that approach, but it'll likely be something that's disabled by default, and needs to be explicitly enabled should the user care for it. Also, just figured I'd let you know that I've significantly expanded the benchmark section, and have added a test case for benchmarking key prefix collisions: [https://github.com/target/libdart/blob/master/PERFORMANCE.md](https://github.com/target/libdart/blob/master/PERFORMANCE.md). It seems like Dart can handle up to 15-20% collisions without significant performance degradation, which is what I expected from my own testing outside of this, but some test configurations actually make it as far as 50% without *significant* losses, which I was amazed by. Interestingly enough, larger packet sizes actually appear to be *more* collision tolerant, which was not my initial expectation, and I'm still working to fully explain it.
Isn't it a pessimization to make stateless lambda `static` ? There's no runtime storage or instructions associated with constructing an automatic stateless lambda; but adding `static` might cause the compiler to actually allocate static storage and have the static construction flag.
Why is it a.customer_id == b.customer_id? I would expect c instead of b.
I image this is determined by contracts of long standing, but I don't know the details.
You can simply put a `#ifndef` and error out if the macro doesn't exist. Doesn't need fancy function-like macros.
I've not heard any other reports of individuals not being able to read it. Can you explain the problem? Is it a permissions issue?
unfortunately i think languages like rust are just going to make this worse. students are going to be so brainrotted that they won't be able to handle these kinds of concepts anymore
&gt; The real beauty in this feature though, is that the programmer can tell the compiler he/she intends to handle all possible enumerations, and if in the future this is no longer true, the compiler can raise an error. This is already handled as a compiler warning. E.g. clang: &lt;source&gt;:11:8: warning: enumeration value 'Floating' not handled in switch [-Wswitch] switch(mode) ^ GCC: &lt;source&gt;:11:7: warning: enumeration value 'Floating' not handled in switch [-Wswitch] 11 | switch(mode) | ^ And you can make them errors with -Werror=switch. &gt; The closest I've gotten to this feature IRL is something like Having that `default` case in your IRL example turns off the compiler checks.
Huh, I use GCC all the time, and I haven't seen this before. MSVC is what I use every day, but even it has two variants on this -- one for if the user doesn't have a default, and one for for if they do. I'll have to see why I've never seen either of them; I know I've got the warning level turned up. Thanks!
*Type* - Full Time, Junior Engineer *Location* - India, Remote, Willing to relocate if Visa sponsored *Description* - Working in a fintech firm on a Crypto Trading Platform. Primary role is C, C++11/14 development and optimisations for low latency and high throughput. Apart managing database(Postgres) development and administration. *Technology* - C99, C++11/14, Postgres, GDB, GCC Toolchain *Others* - Multithreading, Distributed Systems, Fault tolerant systems *Contact* - DM *Experience* - 1.4y in C++, 5 months in C# .NET internship
and if more than one enum is mapped to the same integral value..
I don't see the problem. If you have two enum entries for the same value, I'd certainly hope you intend for them to be handled the same (e.g. None &amp; Invalid in some cases I've seen). To OP's suggestion, in that case only one of them would need to be present; both present can be valid if and only if one case immediately falls through to the other. Alternatively, require the latter case for consistency; if they don't represent the same concept, and thus would be confusing, that's an abuse of enums imo.
I can't see any other submissions by you under your current username, but I think you should keep up what you are doing. Looking for limitations and/or flaws in languages is the principle method of improving said languages.
Something similar was previously proposed in [P0375](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0375r0.html) (suggesting an attribute on enums to indicate them as being exhaustive - to encourage compilers to warn on non-exhaustive switching), which was rejected in 2016. The main objection brought up at the time is that enums are _typically_ exhaustive, so this is annotating the common case rather than the uncommon one... And since compilers can and do warn on this already (as pointed out by bames53), it further confirms that as having been the correct decision in my opinion.
The implementations of Fraction are different, in violation if the ODR(one definition rule). Structs are packed into registers based on availability, so the sender is passing the last parameter in a different location than is expected by the function. This, oper in multiplication () isn't in the memory location that main is placing it. Make the Definition of Function in the header file
This is actually my first submission on reddit, the others were on the cpp standards google group/forum/thing, but to my dismay when I went to post this idea yesterday it looked like it was closed. Thanks for the encouragement though! I really enjoy doing this -- it's a bit of a brain teaser, and each time I learn something new, and maybe one day I'll come up with something. So long as I've done my due diligence and I'm not wasting people's time, it's a win-win!
I basically do this myself with enums as well.
Would be nice to have some way of handling MAX_VALUE-type enum values, that you never want to actually have a case for.
That's definitely true too -- maybe it'd be an attribute or something. I've been trying to see if I can figure out what a nice syntax would be for those things so they don't have to be formal enumerators at all... some sort of sizeof(WindowMode) sort of thing would be cool, but there are tons of edgecases with that too, so I'll have to keep tossing the idea around in my head... (what if you have gaps in your values? What if your values don't start at 0? ...)
std-proposals moved away from Google Groups: http://lists.isocpp.org/mailman/listinfo.cgi/std-proposals
I saw that, but for some reason sending emails to a list a limited number of people are subscribed to seemed scarier than just posting something on reddit that everyone can see. In hindsight, that seems like an odd (mis)calculation on my brain's side. Maybe I have a deep, secret fear of email chains..? Anyway, so the iso website linked to the google groups, that email chain, and reddit, so I chose to hop over to reddit and actually put this account to good use.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bu9f4m/function_return_different_value_when_i_pass/ep8yk2w/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
C4062 is off-by-default; i.e. it is enabled by /Wall, but not by /W4. (It can also be individually enabled, e.g. /w14062.) Note that while the CRT and STL are /W4 clean, they currently do not attempt to be /Wall clean (although we are making changes in that direction).
You recover the default case by having default as an enum value. So now you have two different ways of doing a normal switch and a way of defeating the requirement of no default, neutering the construct. Now what do we gain from this mess? Only that the switch must be exhaustive, which is the job of a linter, not a language feature, even if compilers didn’t emit warnings for this case. I agree with the others encouraging you to keep doing this. It’s challenging, educational, and great fun.
That would do it! Thanks for the heads up -- I'll definitely have to add "check compiler docs for warnings" to my usual research phase for this kind of thing (I usually just write some test code and play with it). I use /W4 at work and home, so I'll definitely look into getting this turned on at the office.
Moderator warning to you and /u/byrongo - that's enough hissing for this thread. Everyone can stop escalating now.
I actually thought about something like this, but isn't the word default reserved, and thus not allowed as the name of an enumerator, meaning that we can reject a default case, since it can't be the name of an enumerator... I can see your point about this being the job of a linter though. I've been on a roll lately trying to get the compiler to throw errors when I break assumptions, instead of the runtime (stuff like static assert), but I need to look into linters for common cases like this one as well. That being said, I think more compile time error checking would be nice to see as a first-class language feature, though I'm not sure I've got a good handle on what I'd like that to exactly look like myself (concepts are a great start though!)
I took another shot at mine, and was able to make it considerably less verbose without losing any efficiency, actually it's more so really. Still can't get it into one post, at least not with reasonable comments anyway.
https://atomgalaxy.github.io/using-enum/using-enum.html
@ /u/codesmith512 I just do something like this: #include &lt;cstdio&gt; #include &lt;cassert&gt; #define AUTOTESTING enum WindowMode { minimized, floating, maximized, fullscreen, // ^ add new values here -- 'size' must be the last element! size }; void f( WindowMode mode ) noexcept { switch( mode ) { case minimized: printf( "Minimized!" "\n" ); break; case floating: printf( "Floating!" "\n" ); break; case maximized: printf( "Maximized!" "\n" ); break; default: assert( false and "Unaccounted for enum value!" ); } } #ifdef AUTOTESTING namespace autotests { struct test_f { test_f() { for ( auto i=0; i &lt; WindowMode::size; ++i ) f( static_cast&lt;WindowMode&gt;(i) ); } } autorun_test_f; // will fail at compile time since WindowMode::fullscreen doesn't have a switch case in f } // namespace end // "void f(WindowMode): Assertion `false and "Unaccounted for enum value!"' failed." #endif int main() { f( WindowMode::minimized ); // OK! f( WindowMode::floating ); // OK! f( WindowMode::maximized ); // OK! // f( 32 ); // "error: invalid conversion from 'int' to 'WindowMode' [-fpermissive]" // f( static_cast&lt;WindowMode&gt;(32) ); // static_casts like this shouldn't even be a consideration IMO, but: "void f(WindowMode): Assertion `false and "Unaccounted for enum value!"' failed." // f( WindowMode::fullscreen ); // "void f(WindowMode): Assertion `false and "Unaccounted for enum value!"' failed." return 0; }
That's a cool way of doing that -- though it's a bit combersome, and it looks like your autotest static would actually fail on runtime, but with certainty, and before main entered..? unless I missed something, I don't see anything that will actually error out on compile time. Even still, it does serve the purpose, especially for unit testing.
That's also a good point (that we should try to annotate the rare cases). But after looking at MSVC's warnings, I don't see a way to actually fix the warning short of including all enumerators, which isn't always feasible (for large enumeration), or pushing/popping warnings, which isn't cross-platform... Time to look at gcc and/or linters, and then maybe propose some sort of sparse enum/switch attribute so compilers can always warn on this behavior, but we've got a way to override it in the uncommon cases that a specific enum or switch statement doesn't need all enumerators...
OK, I took another shot at mine and got it down to 1 page finally, and it's still as efficient as before.
I had a blank page when I tried it but it worked this time...
When switching over Enums my default way to go is to throw some heavy shit in the default branch switch (direction) { case LEFT: left();break; case RIGHT: right();break; default: throw Exception(...); }
Yeah, it's just runtime, sadly. It might be possible to constexpify somehow? I'm ot sure, I haven't looked into that. As for the cumbersomeness, that's true; but if you find yourself needed the functionality in multiple places you could always do something like: #ifdef AUTOTESTING #define AUTOTEST_ENUMS_IN_FUNCTION(Enum,Function) \ namespace autotests { \ struct _autotest_##Enum##_in_##Function { \ _autotest_##Enum##_in_##Function() { \ for ( auto i=0; i &lt; Enum::size; ++i ) \ Function( static_cast&lt;Enum&gt;(i) ); \ } \ } _autorun_autotest_##Enum##_in_##Function; \ } #else #define AUTOTEST_ENUMS_IN_FUNCTION(Enum,Function) /* do nothing */ #endif AUTOTEST_ENUMS_IN_FUNCTION( WindowMode, f ); // only runs if 'AUTOTESTING' is defined There's a caveat here though, and that is that AUTOTEST_ENUMS_IN_FUNCTION(e,f) only works on functions that take a single argument of the supplied enum type. But you could always make it so that it accepts a lambda that wraps the other arguments. But I'm definitely with you in hoping that C++ gets some enum improvements and your proposal is interesting. :) And while on the subject of enums, while MetaEnum, Better Enums, etc are nice they all have their shortcomings. I'd love to be able to iterate enums with for each loops, and to opt into being able to convert to or from strings. So here's to hoping that the commitee decides to give enums some more love before we all die.
Fixed, thanks.
Pretty sure the generated code would be identical either way, but I removed it for your peace of mind ;)
Nicely summarized. I'd add that `-Wswitch` is enabled by `-Wall`.
https://docs.microsoft.com/en-us/cpp/preprocessor/compiler-warnings-that-are-off-by-default There are some hidden pearls, like `-Wconversion` style warnings.
I wonder why, gcc enables it even with `-Wall`.
Different ecosystems, different tolerances for cleaning up warnings, path dependence, randomness. I personally think that warning without default is desirable, warning with default is obnoxious (as I recently encountered).
Yeah sure, not talking about `C4061` resp. `-Wswitch-enum`, those are not really useful. But the other one should be part of `-W4` imho. CMake defaults to `-W3`, I think the VS project generator did too. I've seen few people manually turning it up to `-W4`, let alone enable `-WX`.
A few hidden pearls like `-Wswitch` and `-Wsign-conversion` equivalents.
I have top say, I find the concept of "This warning has a warning level of 2, but is still disabled when I set the warning level to 4" a bit strange.
Yes indeed. Probably for `#pragma warning(default: 1234)` and then it still depends on the global warning level, very confusing.
This kind of functionality should be part of a general pattern matching facility. Like the one found in Rust.
Is `/Wall` newly introduced in recent MSVC? It was used in GCC a lot but I can't remember I saw it in VC.
FYI, the VC Libraries position has always been that we’re /W4 clean, but we don’t attempt to be /Wall clean. However, after overhauling our warning suppression infrastructure, being /Wall clean is now within the realm of feasibility. I’ve checked in changes for VS 2019 16.3 that improve our /Wall cleanliness in the STL, although we’re not totally clean yet and I can’t promise that we’ll spend more time on this. (Also, there’s the CRT, WinSDK, etc. to consider.)
No, it’s ancient. MSVC /Wall is literally all, like Clang -Weverything. GCC -Wall is “all of the important, easy to fix warnings”.
Thanks for the clarify.
How does that work with warnings like "This structure contains padding" which can't be removed due to ABI constraints? Would you just suppress them where intended via #pragma? &amp;#x200B; I tried compiling my projects with /Wall and suppress warnings like padded C4820 before the #include and pop the warning state after, but this doesn't always work as expected with templates.
Unit tests are for checking business logic. In fact when we are creating templates then we shall apply some sort of a concepts to that. C++ Concepts will be available in c++20, yet as others said before use static assertions along with type traits, this way you can create your own Concepts in pre-C++20 code.
https://wandbox.org/ is pretty good. :) (and even has Boost support)
The first example [24.7.8.1](http://eel.is/c++draft/range.split#overview) uses for cycle to write word character by character which is hardly convenient. Am I right word there is a range that's why it can't be send to std::cout directly? And I can't use std::string(word) either because range constructors have been rejected right? If it is true it these general range helpers won't help here at all.
I wish that something like this could be in C++ standard. Or at least compiler could give warning about implicit conversion between different typedefs of the same type.
It has been my observation, that most of the time, when a strong typedef seems like a reasonable solution at a first glance, what I actually want are either class enums (just some opaque value), custom structs/classes (e.g. path instead of string) or a full blown unit system where you can multiply type A with type B and get type C. typedefs for strings have been more useful than typedefs of simple numeric types, but again, you very quickly end up with actually wanting a full blown custom type (e.g. a path) or wanting to perform all the typical string operations which are usually not supported by the strong typedef (e.g. splitting the string).
+1 from me. Thanks for sharing. One thing I have a problem with when it comes to strong typing, is the question of where exactly the cut-off point is. When dealing with things like filenames or time units, it's pretty clear. But one can't possibly strong-type everything. What do people here use to decide when to strong-type something?
Hahaha, pen and paper. I like that hahahahah 😂😂😂😂😂
Pascal had Type operator for that purpose. I do not understand why C++ does not have it. For many years C++ had "enum" then they added "enum class." Class is a too heavy tool to make simple types. For example, if I want to make coordinate type for GUI library. It may be absolutely the same as long, but I do not want to pass long variable containing something else instead of coordinate to a function expecting coordinate.
strong typedef is ill defined because of operators. Most strong typedef implementations allow one to use the operators of the underlying type. However, it's not clear is this is always wanted, especially in a language like C++, where operators are just normal functions. I think it is better to force the programmer to specify what the new type can do in a more concise way.
Why don't ask on the `cfe-dev` list?
I love seeing these reimplementation projects. I first got involved with them through [OpenRCT2](https://github.com/LRFLEW/OpenRCT2), and have started my own (that I really need to get back to at some point). There are so many of these, but I always love hearing about more and what improvements they are able to bring to the original games.
Yeah the padding one is pretty useless, even for one-off checks.
&gt; ... since you have to pay the severe NTFS perf hit for anything you do ... Isn't that just because it's badly implemented [as no nix-people are really interested to make this [NTFS] work properly]?
Nice, though it would be less of an issue if the `-external:I` includes feature got some more love. I haven't heard anything about it since it was announced.
An interesting "concept". There should be a name for it!
No, NTFS is slow under windows, and you also can't run windows containers on Linux, so that's not the case. Windows folks often don't know how slow that filesystem is.
So, you claim `NTFS` is slow [under Windows-10], no matter what [i.e. slower than common nix-file-systems on let's say Fedora or BSD]? I would like you to come up with some justification [i.e. documentation of that] for that claim.
Really cool :)
&gt; ... and you also can't run windows containers on Linux, so that's not the case. Whose fault is that, Microsoft?
These "labors of love" are my favorite kinds of projects. I did something similar with ZZT years ago and I think the reverse engineering was more fun then the implementation. Great Job :)
Some functions require a container continuous in memory to make some optimisations, for example count() has an optional dependancy on libpopcnt that require the data to be continuous to make the population count. I could have put the container in template but there is no compile time trait (in C++17) to check if a container uses continuous memory so I choose to use one that the standard require to be continuous. I don't think it is safe to put the container in template without being able to check at compile time if it is appropriate, if you really need to uses another container you can still change it in the code. &amp;#x200B; The number of bits can not be deduced from the vector size, if the vector contains two uint64\_t then the bitset current size can be any number from 65 to 128.
Vim :)
Because I completely forgot about the mailing list. Thanks for the reminder.
KDevelop
Yes! How could I forget?
Depends on what you mean by simple. I think some people like CLion on linux(simple as in easy to use), but there's still always Emacs and vim if you don't mind a little bit of learning and setup(simple as in low software complexity).
CLion isn't free.
CLion isn't free. And I'm not sure in which world Vim and _especially_ emacs would be considered simple software.
QtCreator is pretty nice. But I prefer vim =)
Just a single file? g++ and vim on shell of your choice. Few plugins and personal scripts of choice. You want to add script that runs g++ for open file, reads the output to stderr for line numbers then executes ":&lt;number&gt;" on vim and prints that error text on another split. If no errors, then run the program and pipe output to another split if it is not interactive, if it is, then you might want to open another terminal for executing it, so that you have code reference. Anyone have good options for gdb + vim integration?
I'm sure the good people there know the answer.
Clang/clang++ will work in 3.15.0.
VS Code plus clangd as a language server or emacs plus lsp-mode with clangd as same.
It's not a matter of pointing fingers, I just stated the facts. But if you are asking, WSL is possible because Linux is open source. If Microsoft released an open core that could be used to run docker containers, I'm sure a port would happen very quickly.
&gt;One thing I have a problem with when it comes to strong typing, is the question of where exactly the cut-off point is. If the purpose of your new strong type is to represent a value with invariants, then those should be implemented in the class. \&gt; What do people here use to decide when to strong-type something? As an example, imagine two functions that each takes an int parameter. I would probably do something as simple as: &amp;#x200B; `struct SampleCount final { int value; };` `struct PixelCount final { int value; };` &amp;#x200B; If I had domain restrictions ("SampleCount is always an even number") I would implement an explicit constructor that issued an exception. &amp;#x200B; For most functions though, I would leave it at a native type (I use strong typing when I have a function take 2-4 int arguments that are could be confused. Consider: `auto d1 = calendar::date(1, 2, 1975);` vs `auto d2 = calendar::date(calendar::day{1}, calendar::month{2}, calendar::year{1975});`
&gt; The parameter of the first function means "amount of audio samples", That should definitely be strong typed. In fact, for my digital audio program, I had a generic type much like this: template &lt;int SAMPLES_PER_SECOND&gt; struct SampleCount { long long count; double toSeconds() const { return count / static_cast&lt;double&gt;(SAMPLES_PER_SECOND); } // lots of conversions }; Because it was simply too easy to add "samples at 44.1Kz" and "samples at 48KHz" and get an almost right number. Indeed, when I put this in in response to a bug, I found a second bug which had never actually been expressed - totally worth my time (which wasn't much time anyway).
&gt; I just stated the facts. No, you don't, you state an opinion, I asked you to give me (and all the rest of us) a link to the facts, no go nike, "Just do it".
What? Do you imply that running windows containers on linux is in fact possible?
Unit tests are for testing any logic you can isolate, which includes business logic. If you have a template class it's most probably possible to test in isolation, so you should.
CLion is basically perfect for what you want, but it’s not free. The EAP version is free though and you can get a free license if you’re a student. A free alternative would be VSCode. If you’d install the [CMake](https://marketplace.visualstudio.com/items?itemName=vector-of-bool.cmake-tools) and [Microsoft C++](https://code.visualstudio.com/docs/languages/cpp) extension I think you’re good to go. With VSCode you would still need to create a CMakeLists.txt (although that is far easier than writing Makefiles imo), CLion does this automatically for you. Another good alternative is QtCreator. I prefer CLion, but QtCreator is among the better IDEs in my opinion.
C++ tool chains are more complex. Maybe start with an online editor.
The only IDE that I ever got to work reliably on Linux is QtCreator with CMake.
It doesn’t have to be named default. Another commenter mentioned MAX_VALUE-type enum values that you never intend to have a case for. The default value would be one of those. Call it default_ or something. &gt; I think more compile time error checking would be nice to see as a first-class language feature Yes, you want to maximize this property (subject to constaints imposed by the rest of the language design). But in C++ especially, it’s really hard to pul this off by adding additional backwards compatible language features, because the existing language features allow so much tomfoolery.
Fantastic!
I am using Geany, but there are currently some issues with GDB plugin on Ubuntu.
No, I was erroneously responding to what I thought was the other post.
Very good to hear - thanks.
I've used both NetBeans and Eclipse for C++ under Linux. Eclipse has better understanding of the language, but it was a PITA to configure for C++11 [1]. NetBeans worked nice. [1] You may have more luck with https://cevelop.com/ instead. Also built on Eclipse. They probably don't qualify as "simple" though...
And this is the problem in the Linux world. A decent IDE. Eclipse hasn't incorporated C++ standard after C+11 and doesn't have integrated CMake editing despite what the Eclipse Marketplace tells you. Netbeans is in upheaval with the move of sources to Apache - but it works. The catch is that both are Java-based IDE's. For non-java IDE's? Anjunta expects to be run under a Gnome environment (pulls in vast number of dependencies). KDevelop expects to run in a KDE environment (install pulls in tonnes of dependencies). Not thrilled with what is left over: vim (with a huge learning curve just to use it), Qt Creator, and now MS Visual Studio. Linux IDE situation could very much be improved.
https://gitlab.com/cppit/jucipp
I by myself have played for some time playing around with dosbox, but finally gave up, as it eat a lot of my time, and it was difficult to turn my work into something that could be sold. Well, still haven't done anything commercial, so currently I'm looking into making c++ run-time compilable. &amp;#x200B; But I think implementing something new and borrowing new techniques, new features, new effects might produce more pleasant outcome than reverse-engineering existing game. &amp;#x200B; Generic game frameworks like for instance godot can provide you some sample game to start from and portability to any OS. (but of course odd custom scripting language like GDScript) &amp;#x200B; But I raise my hat on your reverse engineering skills, I have once upon a time tried to reverse engineer compression used in alone in the dark, but boy it's expensive in terms of wasted time and slowness of analysis. &amp;#x200B; Did you know that [https://www.scummvm.org/](https://www.scummvm.org/) is focusing on reverse engineer and rewrite existing games, but some of newest ports are made even by companies - like Day Of The Tentacle by Double Fine. ( [http://dott.doublefine.com/](http://dott.doublefine.com/) ) I suspect that Day Of The Tentacle was completely re-written from scratch with better graphics, better audio, better everything. So DOTT of DoubleFine looks better over DOTT from ScummVM. &amp;#x200B; But I think none of your work is wasted, better looking graphics &amp; audio can be always used on top of your game engine. :)
QtCreator is by far my favorite IDE. KDevelop also looks decent, but I have found QtCreator is far easier to set up and use.
Amazing work! Reverse engineering must have been a nightmare.
First one Also see r/cpp_questions
&gt; (install pulls in tonnes of dependencies) Are we assuming a system with a 64GiB SSD only? Also there is enough other KDE applications you may want to use even without using KDE itself.
The C++ version of this could be a simple program that simply executes your query. Could be useful in and of itself to demonstrate using an SQL DB from C++.
Templates follow 2 phases, called **2 Phase Translation**: 1. Definition Time 2. Instantiation Time At **definition time**, the following operations are made: * syntax error checking * static assertions are resolved, but only if they don't depend on template parameters * checking on unknown names usage At **instantiation time**, the template is *instantiated* with the given template parameters. Only here code is generated. --- &gt; Do they track which arguments the template is called with and only instantiate the types that are actually used Yes &gt; Or do they instantiate it with all possible types? Of course not, how is that even possible?
For free Vim is the best you can get. For a price, CLion is the best. There is also Eclipse, but it creates more problem then solves.
Would it work with structured bindings instead of `std::tie`? bool operator()(const people &amp; a, const people &amp; b) { return [a.salary,a.age] &gt; [b.salary,b.age]; }
Try KDevelop. It's a good IDE.
The only problem with KDevelop under non-KDE environment is theming. The rest works just fine, and yes, you install few dozen libraries, is that such a big deal? And if you do not want to install these dependencies, you can use KDev's app image.
When I'm not in Tmux with NVim, my choice is Sublime Text 3. With my ST3 setup I have error messages shown inline (and can jump to the line of an error by clicking the error in the build output), static analysis, linting, code completion (via LSP), etc. Not to mention git commit messages inline at the end of the current line. And I can debug with the GDB plugin, build and run with a single key press and much more. Here's some screenshots of it: https://photos.app.goo.gl/ZCHXBXR4Ne8nAzrt6
Units systems are incredible. Boost::units has been a godsend for me.
My variation on strong integrals. [http://ebasoft.com.pl/cxx\_guide/sources/strong\_type.html](http://ebasoft.com.pl/cxx_guide/sources/strong_type.html) [http://ebasoft.com.pl/cxx\_guide/sources/language\_guidelines.html#c2-encapsulation-strong-types](http://ebasoft.com.pl/cxx_guide/sources/language_guidelines.html#c2-encapsulation-strong-types)
That's more than a strong typedef though - more of a unit system.
That's more than a strong typedef though - more of a unit system.
That's more than a strong typedef though - more of a unit system.
Ada has strong typedefs, with a culture that uses them liberally. From my (limited) experience with Ada, it feels like an overall win for expressiveness and safety. But I think it might be because of another Ada feature, the ability to restrict the allowed range of a variable. So not only are you creating a special type for some property, but you also say that it can only hold values in some meaningful range for that property. You can create a type that represents the index into an array, and can only hold valid indexes. (The downside is this is enforced with a runtime check.)
Didn't Ada even allow the definition of units? I'm not saying strong types are bad- I'm just saying that most of the time I either want more than what such a generic mechanism/ library offers or a class enum is enough.
Thus lib let's you explicitly specify, which ops are allowed.
What are “all possible types”?
I had a use for `-Wpadded` when I tried to find a way to reduce memory usage. I managed to remove 7 or 8 bytes of padding in a class that is instantiated many times, resulting in, if I remember correctly, between 5% and 10% lower memory usage.
There's no built-in units feature, nor anything that approaches Boost.Units that I'm aware of. I get what you're saying, which is why I brought up restricted ranges as one of those mechanisms that makes strong typedefs more usable.
&gt; Class is a too heavy tool to make simple types. Why?
D did the same thing with strong typedefs and the keyword alias for 'weak' C style aliases. I'm not sure if C++11 'using' type definitions are strong or weak. I think the windows API would wrap integers inside of structs to create strong typedefs.
Would you kindly resources where one can learn more about c++ compilation and it’s phases?
It reflects a bug in the PDP-11 hardware, where C was born. The instruction to load an 8-bit byte into a 16-bit machine register or 16-bit memory location did a sign extension rather than a zero extension, so for arithmetic purposes the range of bytes was -128 to 127. This was changed on later implementations of C, leaving a machine-specific result shining through. Plain 'char' is really obsolete: you should always use 'unsigned char'.
Strong typedefs are mostly for ID types in my usage. A family of inter-convertible unit types isn't relevant for this, nor do I care about adding additional operations, nor would a fixed set of enum class values work.
I also use Geany but I don't really know how good the project feature is. I always configure my own makefiles for my multi-file projects.
GCC + terminal , there is nothing more simple
Interesting. I prefer NOT to have a `default`, and benefit from `-Wswitch -Werror` to fail compilation if one case is not handled. Of course, you still need a default case (outside the `switch`), for when you receive a value which fits into the `enum` but has no enumerator assigned.
A class enum can have arbitrary values. In fact std::byte is defined as a class enum IIRC (at least gsl::byte was defined this way. And the nice thing is: it is a language feature- no need to depend on a library or worry about how it affects compilation time or ABI.
This is close to being correct as to the theory; it's important to note that non-dependent names (ie ones that don't depend on template parameters) are resolved at definition time, not at instantiation time. So if the template refers to a global function by name, the template calls the version that's in scope at the declaration, not at the instantiation. You should also be aware that some versions of MSVC++ don't do it this way. I haven't used MSVC++ since the 2017 edition, but at least at that point, the compiler compiled templates in the following way: * When a template declaration is encountered, copy the text of the declaration into an internal buffer. * When that template is instantiated, substitute the template arguments into the declaration and parse the result in the context of the instantiation. This has some important implications, including that it gets non-dependent names wrong (you'll get the ones that are in scope at the instantiation, not at the declaration), and that the content of the template is not syntax-checked until the template is instantiated; if the template is never instantiated (eg it's part of a library that your code base doesn't use) then the compiler won't detect even the grossest syntax errors in it.
In my experience: don't forget you can write a Python script to *generate* a little C++ code. Not everything has to be done in the compiler itself.
Im having a hard time using -Werror because a lot of libs and frameworks throw hundreds of warnings
Don't forget [\#include C++ discord server](https://discord.gg/ZPErMGW) and [C++ Slack](https://cpplang.slack.com/messages/cppchat/)
Better is: void f( WindowMode mode ) noexcept { switch( mode ) { case minimized: printf( "Minimized!" "\n" ); return; case floating: printf( "Floating!" "\n" ); return; case maximized: printf( "Maximized!" "\n" ); return; } assert( false and "Unaccounted for enum value!" ); } Removing the `default:` will get you compiler warnings, if they are enabled.
I actually didn't have a good experience in that one, the mods were a bit "up their ass". Though, I haven't used slack so can't really judge about C++ Slack
Hm, because I would like to write something like: type Coord = long Instead of creating a class. By heavy I mean a lot of source code, not performance. &amp;#x200B; It also would be good to have types like this: type Percent = int restrict n &gt;=-0 &amp;&amp; n &lt;= 100 Shorter and cleaner code means more readability. Readability means faster and safer codding.
Wait...what distro are you on where Code::Blocks didn't like it? What kinds of errors were you getting?
Nope since the expensive static initialization you're thinking about is when you can't construct the object at compile time, which you can in this case since the lambda has no state.
This is what references are for. https://www.tutorialspoint.com/cplusplus/cpp_references.htm Next time, ask at /r/cpp_questions
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bui7j6/substitution_for_array_namesize/epchipc/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Using C++11's `auto` feature, you can write: `auto&amp; r = SomeArrayName[i]` and then you can both read through and write through `r`.
I would read the C++ standard, you can find free drafts here: [eel.is/c++draft/](http://eel.is/c++draft/) What I've written is taken from *C++ Templates The Complete Guide 2nd Edition*.
MSVC is now capable of storing the template's abstract syntax tree and performing two-phase name lookup, fixing all of those issues. This is enabled under `/permissive-`.
Oh.... THANK YOu, you are a lifesaver. I can finally sleep! And sorry for posting this in the wrong thread it can be closed cheers\~
Yeah, we just suppress them. Same for "function not inlined" and other warnings that aren't intended to be regularly compiled with. MSVC's warning suppression behavior around templates has improved.
I've been tempted by this too... I just don't know where to start when it comes to C++. This might be one worth paying for. Here's the syllabus, if anyone wants to look: https://s3-us-west-2.amazonaws.com/udacity-email/C%2B%2BND/C%2B%2B+ND+-+Syllabus+.pdf
I agree that clarity is important but I don’t think the class version is much harder to understand. And when your strong typeset needs to get more powerful and it becomes a class now everything is more consistent.
Sorry about that.
Note to self, thx!
I may admit that my experience may be atypical; in general on the codebases I have worked with there was only a handful of open-sources libraries that we depended on: - Most warnings could be fixed by submitting patches to the libraries. - Those that couldn't could be worked around by either using pragmas to temporarily deactivate the warnings in the included headers OR, when blunt force was necessary, by using `-isystem` to specify the include path. Also, having done a fair share of work to activate *more* warnings on those codebases, I would advise a piecemeal approach: - Activate one warning. - Fix/isolate issues. - Rinse and repeat as time permit. Attempting to activate `-Wall` or `-Wextra` on a codebase with no prior exposure is just too overwhelming. One step at a time, one step at a time.
I was checking [this](https://quuxplusone.github.io/blog/2018/06/05/libcpp-memory-resource/) repeatedly. There's a list of patches in it. Looks like at least three are still in review.
The "other types with no user-provided default ctor" row doesn't make much sense to me. Consider the type: struct X { X(int); int j; }; And some declarations: X a; auto b = X(); X c{}; auto d = X{}; The table suggests that for `a`, the `j` member is default-initialized and for `b,c,d`, the `j` member is zero-initialized. But actually all of these are ill-formed.
I use QtCreator for editing and source navigation, but the terminal for actual compiling
I think that, if we just had this: 1. Ability to define a strongly typed numeric variation with range 2. Compiler checks constants of that type to being within the range at compile time (and presumably the result of any constant expression that results in one.) 3. A method we can call to validate the value at runtime 4. Since it would be a strict subset of the type it's derived from, automatic conversion to the base type (or anything the base type can be automatically converted to.) The other way would have be manually done. 5. Though, the above would make it trivial to create a little template that does cast, assign, validate and throw if invalid, for a runtime safe conversion from the underlying type to the derived type. &amp;#x200B; That would be a very useful step. You can play all kinds of tricks with classes. But there are lots of reasons you'd want to do something like this for numeric values but avoid making them much heavier weight in the process (and adding a lot of grunt work code to make all the interactions work right.)
Are you actually taking about gcc's `-Wpadded`?
The best/simple IDE for Linux/Unix are QT Creator + CMake or KDevelop + CMake. However, QT Creator is the most reliable solution thanks to the backing of QT company. No much configuration is need to use QT Creator, just a CMakeLists.txt file that works as a project file.
Yes this is also my configuration, quite powerful
&gt; The Properties parameter specifies behavioural properties for the new type. It must be one of the values of jss::strong_typedef_properties, or a value obtained by or-ing them together (e.g. jss::strong_typedef_properties::hashable | jss::strong_typedef_properties::streamable | jss::strong_typedef_properties::comparable). Each property adds some behaviour. The available properties are: This is pretty disappointing, and IMHO not the right way to go about it. This means that it's not easily extensible. IMHO, the correct way to go about it is to have policy classes that provide the functionality, then you can easily write new policy classes. You would specify these policies variadically at the end: using my_type = strong_typedef&lt;my_tag, int, comparable_policy, hashable_policy&gt;; Etc. Since Anthony Williams is obviously more than aware of such techniques I'd be curious to know why he elected to use the approach that he did.
A Swiss knife choice: QrCreator + CMake
Either gcc's or clang's, but yes.
That row is referring to types that have either no declared constructors at all (and not a deleted default constructor) or a defaulted default constructor.
That's not what it says.
[https://github.com/pjasicek/OpenClaw](https://github.com/pjasicek/OpenClaw) They're remaking a 1997 masterpiece
No, but that's what they mean.
If that's what Timur means, that's what Timur should say. Right now, it says something very different than what you're claiming it is intending to say. And debating what it may or may not intend to say is totally pointless. It is incorrect as written, which is what I'm pointing out, and should be corrected... because it will confuse people.
Is it created with C++ though?
No, it's honestly pretty obvious what's meant if you read the text like a human instead of like a robot. This is just a reference table, not a machine specification.
OK, well one of the huge benefits of owning your own system is that you don't need an act of congress to make changes. Since unique string/id management was a considerable bit of my code here, and since it's not an uncommon thing, I created a TUniqueString class to encapsulate that functionality. That collapsed mine down quite a bit and makes it more readable.
The best C++ IDE probably is Visual Studio but it's Windows only. The only one that even comes close to it is Qt Creator. Unlike VS, Qt Creator is available on Windows, Linux and macOS. I have primarily dealt with Qt Creator on Windows so am not sure how helpful my answer would be but it's wonderful. Any-day, I'd tell you to just close your eyes and download Qt Creator. (The only major issue with Qt Creator was that the download link was difficult to find on Qt's site. Maybe your Distro's Repo Manager has Qt Creator though?) &amp;#x200B; There's also Visual Studio Code( separate from VS) and Vim... Didn't like VS Code for C++ though... Excellent for TypeScript/Python though
Everything clean and simple to grasp. Until we reach our friend initializer_list
I really wish I could afford this
Linux is an IDE. No joke. It was designed hand in hand with the C language as a development environment.
Example C++ with SQL and without ORM or code generator tools ///////////////////////////////////////////////////////////////////////////// #include &lt;teroxLibrary&gt; using namespace terox; using namespace terox::linsql; ///////////////////////////////////////////////////////////////////////////// auto executeExample() { procedure::connect("sqlite:/@:memory:"_text); auto initializeDatabase sqls ( create table visits ( user text, url text, timestamp integer ); insert into visits ( user, url, timestamp ) values ('bob', 'a', 0), ('bob', 'b', 1), ('bob', 'c', 2), ('bob', 'd', 3), ('joe', 'c', 4), ('joe', 'd', 5), ('bob', 'a', 5), ('bob', 'b', 6), ('joe', 'a', 6), ('bob', 'c', 7), ('bob', 'e', 8), ('joe', 'c', 8), ('joe', 'd', 9), ('joe', 'e', 10), ('bob', 'a', 10), ('bob', 'b', 11), ('bob', 'c', 12), ('joe', 'c', 12), ('joe', 'd', 13), ('joe', 'c', 14), ('joe', 'd', 15), ('joe', 'e', 16), ('bob', 'b', 14), ('bob', 'c', 15), ('bob', 'e', 17); ) auto selectRows sql ( with sequences as // generate sequences of three urls ( select user, lag(url, 1) over sorted as url_1, url as url_2, lead(url, 1) over sorted as url_3 from visits window sorted as (partition by user order by timestamp) ), counted as // count repeats ( select user, url_1, url_2, url_3, count(*) as num from sequences where url_1 is not null and url_3 is not null // filter out the end rows group by user, url_1, url_2, url_3 ), ranked as // and number them in order of count ( select user, url_1, url_2, url_3, num, row_number() over (partition by user order by num desc) as rn from counted ) // select the top sequence per user select user, url_1, url_2, url_3, num from ranked where rn = 1 order by user, rn ) initializeDatabase(); for(auto&amp; row : selectRows[{}]) { log::info("%", row); } } ///////////////////////////////////////////////////////////////////////////// class ConsoleLog final : log { auto operator () (Severity severity, text const* message) -&gt; void override { std::printf("\n%s - %s : %s", Timestamp::now().toText(), log::nameOf(severity), message); } }; ///////////////////////////////////////////////////////////////////////////// #include &lt;teroxMain&gt; auto teroxMain() -&gt; int { ConsoleLog consoleLog; try { executeExample(); return kExitSuccess; } catch(Exception&amp; ex) { log::error("exception: %", ex.message()); return kExitFailure; } } ///////////////////////////////////////////////////////////////////////////// Result set 2019-05-29 22:56:21.116 - Info : { user:bob, url_1:a, url_2:b, url_3:c, num:3 } 2019-05-29 22:56:21.116 - Info : { user:joe, url_1:c, url_2:d, url_3:e, num:2 }
I'm starting to really like VSCode + a few plugins (including MS proprietary C/C++ IntelliSense plugin), although I don't really care about build errors because modern code editors are so good at parsing things in a front-end that (at least for the projects I work on) once you fix all your squiggles it also build for real. I also don't care about running from the GUI, but I'm sure there are plugins too (I tried only one or two a few months ago, they were not great but at least it is doable, and there might be other better ones). On the minus side the settings and shortcuts are sometimes harder to find than in a more traditional IDE, and given you depend more on plugins the out-of-box experience is not great and the learning + configuration curve might be somewhat slower than other solutions (but in the end, if you use it for extensive periods of time, a few hours going marginally slower and looking for stuff is negligible). But I find the indexing of MS C/C++ IntelliSense excellent, and that's what matters most for me.
Oh, right. Good point. Cheers!
Of course ;)
Visual Studio Code. You can also download just open-source version which doesn't has all those fancy stuff from Microsoft
270 source files for 25k LOC? This man loves them some short file.
[https://www.reddit.com/r/cpp/comments/b6llmw/new\_clion\_release\_20191\_bringing\_embedded/ejoctxj/](https://www.reddit.com/r/cpp/comments/b6llmw/new_clion_release_20191_bringing_embedded/ejoctxj/)
YouTube. That's how I learned it. I took Udacity self driving course and was not happy with it. Edit... In fact that's how I learned most of the languages I know. Java (YouTube), JavaScript (YouTube) SQL (YouTube) I could go on and on but I think you get the idea.
Vanilla VIM? what about vim with you complete me and some other c++ plugins?
So I should go watch all thenewboston videos and I should be good to at least attempt a production system with confidence?
Dash - Offline API Docs de Bogdan Popescu https://itunes.apple.com/br/app/dash-offline-api-docs/id1239167694?mt=8
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Thanks!
I had no problem using Code::Blocks, I used it for years to build, test and debug my tools under Linux.
I put together a slightly improved version: https://onlinegdb.com/B1jHrY3a4 In this one, the code generated by 'AUTOTEST_ENUMS_IN_FUNCTION(Enum,Function);' works with both traditional enums and C++11 enum classes, and a lambda can now be passed in lieu of the function name if one needs to wrap any of the other parameters with dummy values. :)
Do this one first: [https://youtu.be/Rub-JsjMhWY](https://youtu.be/Rub-JsjMhWY) &amp;#x200B; Do you know how to program? If so then doing that one first then I would do Bucky. To answer your question: Yes, you will be able to. With the Udacity self driving course they "taught python and C++". In my opinion if I didn't know it ahead of time I would've never understood it.
This is pretty useful! Thanks!
I saw this linked on another subreddit. I have to say the amount of work you've put into this is pretty impressive. I'm not really a c++ developer, but I'd definitely mess around with this if it worked on Linux (I saw you mention, in one of the docs or something, that linux support kinda died or got left behind). Anyway, I see where the other questions/comments are coming from (license, modularity) but the bottom line is you made this to suit your own needs. You don't owe anyone anything just because you posted the code on GitHub.
There's a reddit for discussion /r/cidlib, if you want to discuss anything. I also made another post here with an update just a bit ago. I've been looking into the Linux thing. https://www.reddit.com/r/cpp/comments/bth5e5/cidlib_project_update/
What did the mods do?
**Company:** [Shield AI](https://www.shield.ai/) **Type:** Full-Time **Description:** At Shield AI, we build the artificially intelligent products of tomorrow that solve the greatest security challenges of today on land, in the sky and deep underground. From one robot working alone to teams of robots working together to achieve a mission, Shield AI is creating AI on the edge at the speed of the state of the art. Please see the full [job description](https://jobs.lever.co/shieldai/49f60c9e-fde7-4ab9-ace2-f58257e64196) for details on the teams and projects you could work on here! **Requirements** +Exceptional modern C++ skills from experience in industry or graduate degree research. B.S. or advanced degree in Computer Science or similar, or equivalent practical experience. Strong knowledge of modern software engineering best practices in algorithms, data structures, concurrency, clean code, code documentation, unit testing (e.g., Google Test, Nose), debugging (e.g., GDB), and bug tracking (e.g., JIRA). Team player with strong communication skills and a demonstrated record of working hard, being trustworthy, holding yourself and others to high standards, and being kind to others. **Location:** San Diego, CA **Visa Sponsorship:** To conform to U.S. Government regulations, applicant must be a U.S. citizen, lawful permanent resident of the U.S., protected individual as defined by 8 U.S.C. 1324b(a)(3), or eligible to obtain the required authorizations from the U.S. Department of State. **Technologies:** Required: C++11 or later, Linux environment. Preferred: Git, Bazel, CMake, Docker, Kubernetes, ROS, CUDA, Unreal Engine 4, computer vision, applied machine learning **Contact:** Please apply online www.shield.ai/careers or email talent@shield.ai
You can have the offline version of cppreference, and many other libraries and languages, in your browser with DevDocs.. https://devdocs.io/cpp/
???. You think it's any harder for people using the standard library to create new classes?
I’m a huge fan of ZZT—funny to think that was Tim Sweeney, who’s been getting so much hate lately. MegaZeux was pretty fun, as well. It was an improvement in every way.
Thanks, any major updates to C++ I should read up on since these tutorials were first released? And yes I know how to program.
that's great!
Obviously you can. But, in my case, it's now part of my public standard libraries, not built on top of them as part of my own code base.
`auto d3 = 1 / std::chrono::Feburary / 1975`.
You didn't write that, you're using various APIs which in your specific use-case optimize down to that. Heap to stack promotion is a totally valid and useful optimization. Optimizations often look funny when you strip them down to the minimum necessary to demonstrate the transformation. When evaluating these types of optimizations you need to think like a compiler. They take thousands of tiny steps for each function, basic block, and instruction. They don't look at the entire thing and in a single step (or even a few) output the "right" way to do it. This means that a transformation has no idea if the code was written that way to begin with, or is the result of iterating over the program thousands of times.
&gt; no declared constructors at all (and not a deleted default constructor) That's covered by the "Aggregates" row.
I don't know about Bucky's video but not to the one I gave you. I was able to make my own programming language in C++ after doing the video I gave you. When you get done take a crack at this: http://craftinginterpreters.com/
I fail to see the difference - your public library *is* your code base. Regardless of what you call it or where you stash it it's code you have to maintain.
`using` is weak, it's another way to spell `typedef` that also supports template parameters.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/buhwqn/udacity_c_nanodegree_reviews_other_c_resource/epe7f7j/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I'm not saying that these views are sufficient, but lack of operator&lt;&lt; is only a minor problem.
Might also be worth noting which types of initializations will enforce narrowing conversion errors.
Well, the difference in this context is just that it's about tool sets. My tool set is CIDLib. If it wasn't part of CIDLib, then it would have to be in the code of this example. The folks using the STL can't do that. If the STL is their tool set being used here, they have to use what's there or add it to the code here in their solution.
In large existing MSVC code bases, man, that can generate an almost insurmountable raft of errors because suddenly an enormous set of order of inclusion issues occur that might require years to untangle. They have a less non-permissive non-permissive mode which turns enables some other compliances without that two-phase thing, which isn't bad. But the two-phase one is a bear to suddenly turn on.
Why do this... the [\#include cpp](https://www.includecpp.org/) Discord server is already well-subscribed and well-moderated. I've spent plenty of time there and, compared to other places where I've discussed C++, it's very welcoming and feels like a real community. I can only assume based on your other comment in this thread that you've made this as some kind of petty retaliation because you couldn't get away with some or other disrespectful behavior.
There's a separate list for libc++ specifically now.
Hey. Following some instructions from /u/STL and others I created a Developer Community bug report here: [https://developercommunity.visualstudio.com/content/problem/588576/internal-compiler-error-c1001-when-using-sol3-with.html](https://developercommunity.visualstudio.com/content/problem/588576/internal-compiler-error-c1001-when-using-sol3-with.html) This is affecting a lot of my new users with Visual Studio 2017 and 2019, so anything you can do would be fantastic (and anything you need from me, I'll do my best). Sorry it's not a minimal repro, I can't seem to simplify it at all. :/
I like that for integral IDs, but sometimes the IDs are strings which have no semantics in their structure. A good example is the new module names--the dots are merely a user facing convention (at least for now).
gcc -dU
The problem is it's too noisy. They should split it up at least, the message already distinguishes between aligning an element of the structure and the whole structure.
The problem is it's too noisy. They should split it up at least, the message already distinguishes between aligning an element of the structure and the whole structure.
I get a lot of warnings related to two-phase when using OpenMP. Do you know what the plans are regarding omp support?
Sure, and I think I mentioned that strong typedefs for strings are useful more often. I guess it depends on the kind of application you are working on whether it is a common need or not.
I think this may be related to my first post: If you really need so much customization power, why don't you just write a full blown class by hand?
"C and C++" is enough for anyone to believe that it's going to be shit.
And you probably didn't read the full comment, because any relevant software should have at least minimal customer support and your users (which are nonexistent, otherwise you'd know) could easily request something being done about it. There's no one time solution that will catch all possible cases.
I’m not familiar with the backend team’s current plans there.
The entry "Aggregates - default init" is incorrect. The actual behaviour is that each member of the aggregate is default-initialized (with this rule being applied recursively for sub-aggregates). If the aggregate only contains built-in types then yeah, they're uninitialized. But if it contains a `std::string` for example, that string is initialized via its default constructor.
Incredible. &amp;#x200B; what rules apply to std::array&lt;int,10&gt;?
No it isn't. For example: struct S { int f; virtual void g(); }; This is not an aggregate and is covered by the row in question.
That's *Aggregates* (the standard requires it to be an aggregate)
Suppose I were to say struct S { int x = 0; int y }; S s; Does this mean that s.x is 0 but s.y is uninitialised?
Or you could try and be less toxic, I do have an idea of C++, I know my way around it, and I've used it for a while already, I'd say I'm in a position where I can help people out, and next to that, we've already had a few guys join that know their way around C++ aswell. For C, no I myself don't know about C, but as I said, I made this server with my friend, and he does have an idea about C. Also, looking at your past posts, chill with the toxicity ;)
Yes
Explains why you lump C and C++ together.
Use a vector. Partition the vector so the no longer used items are at the back. Shorten the vector.
I'm sorry but if a compiler doesn't pool string in a c++17 project with LTO I'm filing a bug report, or it must have a very specific optimization reason to not do it. It looks cool though for older compilers or for embeded projects.
Do you also debug with LTO? I wrote the initial version of this because I needed to reliably compare address in both debug and release mode.
Fair enough. I'm still a little on the hedge about this. I'm not exactly shure what compilers or usecases/workflows make this a better solution than relying on the compiler. I'm just not shure.
Totally understandable. Honestly, I'm posting it not because I think everyone will find the same utility I do, but because it's one of the quirkier things I've written. It's not every day you need a variable with type `const char***[]`. There's also some machinery involved with integrating a custom preprocessor to condition files sanely in cmake that took a while to get right (I'm no cmake expert)
It seems to me that everyone is missing the real solution, which is to stop doing lots of little 'objects' and starting focusing on the actual data you are trying to store. If you do that, you can store multiple arrays. If you think about an SQL database you would just have a unique I'd that always increases. You would use the unique id to get to the items. If you want to reorder them but have random access, then you will need indirection that maps the Id to the current position in an array.
That's cool! Props for sharing it underneath a highly compatible license too. Good luck with your project.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/burcpk/just_a_lot_of_questions/epgbob4/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
if the algorithms were a c++ compiled part of my program how is an user supposed to let HIS algorithm run "moron"?
dash for iOS
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/burydk/interesting_projects_to_learn_c/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
That is a meaningless distinction. &gt;My tool set is CIDLib. If it wasn't part of CIDLib, then it would have to be in the code of this example. The folks using the STL can't do that. Can't do what? Modify the STL? Sure (well not easily), but that's because the STL is not intended to be the last toolset you'll ever need. No one is impressed by your ability to add SolveChallenege1() to CIDLib. &gt;If the STL is their tool set being used here, they have to use what's there or add it to the code here in their solution. Some (all?) of the solutions presented here using the STL are shorter than your code anyway.
thanks
Oh, thanks anyway.
Too bad :( Frankfurt hiring came somewhat unexpected and it seems the their positions filled faster than usual. I hope I won't be late next time. Thank you.
oh good source. thank you for sharing.
Why are buttons and windows `shared_ptr`s?
Thank you! It's first on my list this morning. Don't fret too much about it but being a minimal repro, reducing these types of things are what we're best at :).
In my opinion, using Facebook’s flexbox as the drawing backend then called it “native” is a bit of a stretch. It will look like React Native where it uses native elements some of the time (e.g popup, notifications) but most of the time it use flexbox to draw. I would prefer a C++ backend using Dropbox’s Djnini and truly native UI using interface builder in platform native SDK. Or you could just stick with Qt and Qml.
Boden author here. We do not use any non-native code for drawing at the moment. Facebooks yoga library is only used for Layouts.
Well, it wasn't solve challenge, it was a completely general purpose utility that will be useful in many other contexts in the future. Did your mother work on the STL or something? Why are you so triggered?
Interesting; thanks for introducing the concept here. The links on your repo homepage give a good round-up; I enjoyed reading John Baez's torsor blog post: &gt;So call up your old calculus teacher and tell them this: *"You should have told us about torsors!"* The need for the distinction is important in concept and in practice. In C++ it comes up in std::chrono `time_point` vs `duration`. In linear algebra it is the affine-space vs vector-space distinction e.g. absolute point position vs. relative position in geometry (the standard linear algebra proposers mention this in talks; I don't see the distinction made in the proposed API yet) The distinction can be made implicit in values, going up a dimension; add a coordinate that is 1 for position and 0 for relative position (projective 'homogeneous' coordinates). A better explicit alternative is to use a system that expands the 'menagerie' of things that can be represented; Geometric Algebra shows great promise in this regard. As for testing compilation failures, I do use such a test framework (you can PM me if you want) but your use of requires clauses to check for expression validity seems fine for this use case.
Looks nice! But does it allow to access the hardware (camera, accelerometer, etc...)
Very nice. Sadly, my aspirations for app development have died a few years ago.
That way there's no lifetime issues nor memory leaks! ^/s
Not yet, but its on the roadmap.
Now this would be really great!
Looks very interesting, but why alias std::string to String?
~~Ah yes, you can't dispute what I said so let's just turn it into emotions and sarcasm.~~ Edit: Just saw your edit. Feel free to quantify the performance gain beyond "pretty sure". I have no doubt you can implement a faster solution than the ones implemented here given enough effort. But I also never said that a solution using the STL would be the most performant.
What's this, has /r/cpp finally turned on smart pointers?
Ha! Apparently this was fixed very recently in our compiler, in fact, I'm the one who fixed the error case which caused this code to crash the compiler. The test essentially reduced to the following: ```cpp template&lt;typename T&gt; struct S1 { auto get() { return nullptr; } decltype(auto) get_ref() { return nullptr; } }; int f(void*); struct S2 : public S1&lt;int&gt; { template&lt;typename&gt; void sym() { int err = f(get()); int err = f(get_ref()); } }; ``` In any case, you should be expecting a fix in an upcoming release, likely after 16.2.
C++ is really not a great language to make UIs, but those system programming languages are good to create underlying engines (like Skia, which is used by Android UI Toolkits and Flutter). C++ is lack of dynamic, this can make some features (like data-binding) more difficult to be implemented. And Qt as a C++ UI framework is using `moc` to generate codes to accomplish this. And I took a look at the library, it has 1:1 implementation from C++ to the platform, every control is implemented twice (so far), it is not a good idea to do so today.
Yoga is native though, it’s written in objective C++ on iOS, and I assume java on Android
Qt Quick is great, it just uses C++ as a graphics backend and provides another dynamic language QML to actually draw the UIs.
I'm assuming they want to have `weak_ptr` objects. Sure, `unique_ptr` might offer some protection but then your code is littered with std::move and/or raw pointers that another object owns. I haven't looked at the code but there is a use case for using `shared_ptr` as a `unique_ptr` that provides a `weak_ptr`.
You know nothing I say is going to change your mind and only an actual test on real data would do that, and that's not likely to happen. But (comparing to the most compact STL one) it's a sort based on string comparisons, via a generic sorting algorithm that uses iterators (and I assume moves the actual elements?) vs a single pass to find unique strings, then a sort of pointers directly on the list of pointers and using a number for comparison. Then it's a histogram thing using all three strings as the key for every update of the counts (as best I can tell), vs a pass just doing basic bit masking of a 64 bit value and then a sort of the resulting 64 bit values. Both then find the most dups. Mine is a straight iteration through an array vs. a generic one done via iterators. I'm pretty sure in each case my choices are lighter weight to one degree or another. But of course without a real test that cannot be absolutely said for sure. Anyway, I'm not going to get into yet another negativity cycle. If some disinterested third party wants to set up a test, I'll happily provide a built version for it, though we'd all need to update them to take the data from a file in that case. That's easily done though. If it's not actually a good bit faster, I'll probably still manage to survive.
They do justify by saying: &gt;No custom containers, smart pointers, or reinvented basics. This allows you to reuse your existing knowledge and focus on what's most important: your app. Maybe they just want a std::string but with a class name that follows their naming convention
Only on overuse of shared_ptr. And overuse on pointers of any kind, versus just using values.
See Herb's video. In particular, the slide at this frame: https://youtu.be/JfmTagWcqoE?t=270
Let's take a step back here. I'm sorry if my posts come across as negative. But I feel we have lost the plot of the original comment - your assertation that there is some implicit advantage of implementing a piece of your solution directly in CIDLib, vs somewhere else (whether in a helper library, in the challenge source code itself, whatever). I'm sure you realize that whatever algorithm you implement can be implemented in terms of Boost, STL, plain old C, whatever. But also vice-versa! Which leaves the real question: what advantage you see of having it directly in CIDLib. I know the answer, based on other posts you've made: You dislike external dependencies because you can't control them, and you prefer a more tightly integrated toolchain. I don't think anyone faults you for that. But 99.99% (maybe more like 95%, who knows what Google and Facebook are up to) of us don't have the willingness, time, expertise, budget, whatever of building every tool and library we need from scratch. That's all I have to say. Again, sorry if I was being a jerk.
The tests assert that two torsors can be added: ALLOWED( _torsor + _torsor ) I assume it results in a type like `torsor&lt;torsor&lt;int&gt;&gt;`, but why is it allowed in the first place? As mentioned, adding points in time doesn't really make sense.
Not bad, finally some real alternative to Qt is rising up
Adding points in time doesn't make sense if you expect to get a point in time as a result, and you don't. Preventing the addition would have taken effort, and I am not sure there isn't some meaning in it. For instance, when you add two points in time, and then subtract a point in time from the result, you get a point in time. I wish I had a way to enable ( P + P ) / 2 -&gt; P, but the result type of the divison would depend on the value of 2. Maybe with if constexpr ....
I found JB's blog very readable too, most of the more math-oriented references are way over my head. I'll read up on affine spaces; what kind of effect would that have on the API? Is your test framework something outside the language or does it work in the language itself? I think it can be done with SFINAE, catch2 seems to be able to decompose an expression (although I haven't deciphered the mechanism they use).
wat
I'm in the process of setting up conan right now and I've got a library built for windows and linux in my local conan cache. However the linux version is 2018.3.222 and the windows version is 2018. 3.210 In my conanfile I require library/[2018.3] which works if I am building for linux but fails when I am building for windows as conan says that the 2018.3.222 version is not built for windows. How can I specify that either minor version is fine and to just use whatever version I have built for the system I am on?
Hi, I just noticed your comment. Can you file a bug on Developer Community with this issue? [https://developercommunity.visualstudio.com/spaces/8/index.html](https://developercommunity.visualstudio.com/spaces/8/index.html) &amp;#x200B; I also let one of our engineers know to investigate.
We fix IntelliSense bugs and maintain conformance with the latest standard features every release, so there are always some improvements. In terms of feature work we have IntelliCode, which provides more context-aware IntelliSense completion suggestions: [https://devblogs.microsoft.com/cppblog/improved-c-intellicode-now-ships-with-visual-studio-2019/](https://devblogs.microsoft.com/cppblog/improved-c-intellicode-now-ships-with-visual-studio-2019/)
In the future, if you encounter a performance issue it's a good idea to go to Help &gt; Send Feedback &gt; Report A Problem in the IDE to file a bug. This will help us track it and resolve it as quickly as possible. We're always on the lookout for performance issues.
Yeah it's probably useful if it makes the normal mathematical rules work, like associativity P + (P - P) == (P + P) - P. It would be a bit awkward if that wasn't possible anymore. If that works out correctly it's definitely an upside.
I recommend [C++ Primer] (https://www.amazon.com/Primer-5th-Stanley-B-Lippman/dp/0321714113) by Stanley Lippman.
Not trying to steal the show here, but if you guys are looking for a WPF-like UI framework (for all Desktop and mobile platforms) and don't mind writing C#, I highly recommend Avalonia (https://github.com/AvaloniaUI/Avalonia). It uses Skia for rendering. I really think that using a language with reflection support and a more dynamic type system makes UI programming much better.
Because widgets often form an acyclic graph whose ownership isn't deterministic and that use case is specifically the one that ```shared_ptr```s are intended for. The non-determinism of the object graph comes from the fact that widgets have to respond to asynchronous events that are dispatched by an event loop. That means it's possible for the parent of an object to be deleted but the child widget needs to stay alive to handle a future pending event. Its ownership is basically shared with the event loop.
I listened to your episode of Cppcast last week. Has the framework changed appreciably since you recorded that podcast? It didn't sound like it was ready to use and you mentioned you were still ironing out some licensing bugs?
If the interface to your library does not change, you should not have different version numbers for the generated libs. The fact that the libs are created for different platforms doesn't matter when it comes to SemVer. Here's the [standard for SemVer 2.0](https://semver.org/). If you really need to you could add this as metadata in the form of `2018.3.0+gcc5` or `2018.3.0+msvc17` or something similar. Conan can handle that when using `library/[2018.3]` then. Haven't tried that exact solution, but had a similar case in the recent days.
That's sad. May I ask why? Even as a side project in your free time? For instance, I'm planning to make my own framework built on top of SDL2, but as a hobby.
The API for vector values should be similar as for scalars, as long as operator+ is addition of the thing represented, but it may take some effort to be generic and efficient. Then again, you might decide to write scalar multiplication; scalar \* torsor&lt;vector&gt;, and from there get pulled in to doing a full linear algebra library... Since you're already using concepts from C++20, std::span is probably the way to go for generic Vector arguments. I'm not sold on the idea of torsor as a library template, btw. Better if the distinction unfolds from a richer type representation. For example... Some things that look like vectors should not be accepted. E.g. a quaternion looks like 4-vector, but... when it represents relative orientation, i.e. rotation, then addition of rotations is multiplication of quaternions, and torsor&lt;rotation&gt; is 'attitude' - a cool term for absolute orientation, and "you can't add attitudes" as my mama used to say. The test framework I use is outside the language.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
One minor downside is the lack of IDE autocomplete. I don't quite get why the macro categorization is needed. E.g instead of `BMBF_TARGET_OS(MAC)` one could also write `BMBF_TARGET_OS_MAC()` with works the same but now you can use IDE autocomplete, and the `PRIVATE_DEFINITION` names are also not needed. The only downside I see is that the categorization is not so explicit and more convention Having said that, I really like the idea to use function-like macros and poisoning of old macros! I'll definitely use these.
Tbh, that all looks like React Native, but with C++ API. What does it bring? The former is used when you want iterate on all platforms very fast, and jokes on me, C++ is not fast to develop with.
Yup, I never claimed that they should be even put into the same category, feel free to come take a look ;)
You need some kind of method to guarantee that an object created with std::make\_unique() will not be deleted from the time you start interacting with it until you finish interacting with it. Many of us work in multi-threaded environments where paint events take a significant amount of CPU time, and there's no guarantees on the order some events will be signaled. When a progress bar hits 100% does the progress bar get repainted or does the owning container delete it first? What if it's still in the middle of repainting the bar at 99% when delete() gets called on its owner? Some example solutions are to call std::move() a billion times, use raw pointers and make\_unique() with custom deleters for lifetime safety, or use guarded pointers. One solution already exists because shared\_ptr/weak\_ptr is already in the standard library. Holding onto a weak\_ptr&lt;T&gt; object instead of a T\* object makes things a lot safer, and only having one shared\_ptr (except during `if(ptr.lock())`) prevents circular dependencies. No matter what you do, there's some level of added resource requirements for tracking the pointers.
I'm joining thanks !
Any Boost or QT people want to show how they might be used?
Exactly. I by default dont allow any operators for strong type, except explicilty specified in traits. [http://ebasoft.com.pl/cxx\_guide/sources/strong\_type.html](http://ebasoft.com.pl/cxx_guide/sources/strong_type.html)
It is the only safe way to use polymorphic objects allocated at runtime and shared\_ptr works as reference counted garbarge collector. If they were unique\_ptr, it would not be possible to multiple objects refer to the widgets wrapped by the smart pointer. In addition, it is not possible to return polymorphic objects from functions by value with std::make\_shared, std::make\_unique or new Object due to object slicing.
Thank you for doing this! I really hope it goes well and gets support from google/apple, and hopefully becomes somewhat of a standard.
Assuming the rest of your project is in C++, the advantage of having a single language throughout your codebase, especially if your targeting multiple platforms, is a very huge plus compared to whatever C# reflection brings.
It brings seamless integration with the rest of your C++ codebase. Very convenient if you are targeting multiple platforms.
Interesting. Can I ask why the Android system is using a Java activity instead of ANativeActivity?
The best choice is Python + LibClang bindings. It allows controlling libClang parser and iterate over the code. You don't need to build clang to use this choice, just use the Anaconda Python distribution and the pip or conda installer to install libClang Python bindings.
Looks neat, but GPL 2/3 and no info on pricing for a commercial license? I'll pass.
Pre-Concepts version: struct TakesAnything { // constructed from anything: template&lt;typename T&gt; TakesAnything(T) { } }; TakesAnything operator+=(TakesAnything, TakesAnything) { return 0; } then use static_assert auto pluseq = moment_in_time += moment_in_time; static_assert(std::is_same&lt;TakesAnything, decltype(pluseq)&gt;::value, "shouldn't be able to add moments"); but no, I haven't seen a library for this
O.o, this looks very promising! I'll give it a shot. I ended up sending out a very basic report today using just grep. I found that all the macros definitions had the same prefix, but this looks like a much better solution! Thanks again!
https://blog.regehr.org/archives/268
You can install LibClang and Clang compiler standalone for any major Desktop/Server OS as LLVM project provide binaries: [http://releases.llvm.org/download.html](http://releases.llvm.org/download.html)
Size returns an unsigned number. Hence -1 is promoted (or converted, I forgot which) to unsigned. -1 happens to be all-bits-set-to-1. So it’s the largest possible unsigned number. Does this make sense?
Could you elaborate what a ratio scale and interval scale are? I tried the wikipedia article, but graduate level pure math takes me a while to decode.
Furthermore, you could just typecast it in the first code. cout &lt;&lt; (-1 &lt; (int)s.size() ) &lt;&lt; ". ";
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
this is great. thanks for sharing!
This is a rotate!
I did something similar a year ish ago, literally just reorder your structs variables by size (largest to smallest) and it'll help a surprising amount with memory usage and even speed do to caching.
I recommend adding a license to your repository.
Looks similar to what I built https://github.com/rigtorp/MPMCQueue Facebook folly also have a similar queue that supports using futexes for blocking operations. What you need depends on your latency and power budget.
I see you handle the case of more threads than queue elements correctly without ABA problems. That's great. Have you tried first doing a load loop checking the condition before attempting CAS? Something I've wanted to investigate when I have time. It could reduce memory bus contention when the queue is contended.
Thanks. Done.
A spin lock is still a lock. Also you should compare it to the moodycamel lock free queue.
`unique_ptr`s that can be converted to `weak_ptr`s is a very useful thing. I've rolled my own by wrapping a `shared_ptr` and disallowing copies.
The moodycamel queue is really just a spsc queue per thread. The fifo semantics are quite different. Performance can also be worse in real-world scenarios since it will use more cache.
Will do. `moodycamel::ReaderWriterQueue` dead-locks in my unit test which other queues pass, may be I am not using it correctly...
Are there no issues with no periodically injecting a yield instruction during a busy atomic exchange loop
 bool try_push(T&amp;&amp; element) noexcept { auto head = head_.load(X); do { if(static_cast&lt;int&gt;(head - tail_.load(X)) &gt;= static_cast&lt;int&gt;(Derived::size)) return false; // ****** } while(!head_.compare_exchange_strong(head, head + 1, A, X)); What happens is the queue becomes full at ******
The queue becoming full would imply `head` changing, which would make the CAS fail..?
yep (I deleted the question before I saw your answer). The odd part is that the queue can become full before the item is actually pushed. But order doesn't really matter because it is MPMC (so a later push or pull can actually happen before an earlier one) The only problem I see is that a push could pause so long that the queue wraps around and a future push writes to the same spot as the currently attempted push. But it will eventually get there!
Worse than what? This? I would need some benchmarks to start to believe that.
What is this syntax? It almost looks like a designated initializer but it's a string as the key, like a python dictionary? _window-&gt;stylesheet = FlexJsonStringify({ "justifyContent": "Center", "alignItems": "Center" });
I don't think there's much need for yet another one.
It is `std::map&lt;std::string, json&gt;` initializer. Where json is from [nlohmann/json](https://github.com/nlohmann/json) library (check the "JSON as first-class data type" section in readme).
Thanks for sharing, very nice presentation of the results! Just a theory question, why those queues doesn't "work" in a CPU with a single core?
&gt; FlexJsonStringify Oh, I took a deeper look. It is not exactly what you said. `FlexJsonStringify` is a macro for `JsonStringify` which is a macro to stringify that "json". It is *not* C++ syntax, which is what I guessed.
Oh, you're right. I missed that # in JsonStringify... :)
:-)
I also don't bother any more. HTML/CSS/JS -&gt; Ajax/C++ backend provides a system which just works anywhere for all of my use cases.
Just a small suggestion: \`first\_less\_than\_range\` should be called \`first\_less\_than\_sorted\_range\` since it assumes the input range is sorted.
Well said
[removed]
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/buu2t3/truly_native_c_crossplatform_framework_for/epl3uhg/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Artificial intelligence. Train it to play simple games
can you still access to camera / accelerometer etc using some other library right?
Episode 200. Well done!
Take a look at Clang (http://clang.llvm.org/). Is there a better way of becoming familiar with a language than looking at a compiler?
try_push() does not use a spin lock, hence deserves the lock-free naming. While push() spins if the queue is full (which is normal since this is a a bounded queue).
Your implementation does not suffer from this severe limitation: "the maximum queue size must be set at compile time".
Just keep doing what you are doing, learn, read but it will take time. You also can’t learn all techniques by just using c++. Be proficient also with Java, Javascript, SQL, Web, C. Invest your time and effort. There’s no shortcut to it
&gt; Tim Sweeney, who’s been getting so much hate lately. Why what's going on?
&gt;Take a look at Stare at a compiler and become a C++ expert.
I can't read your blog post now, so I don't know if you mention it, but does it work well with the asio library?
Are your talking about `pthread_yeild` or `_mm_pause`? `_mm_pause` makes throughput in benchmarks lower, this is why it is commented it out.
&gt;Just a theory question, why those queues doesn't "work" in a CPU with a single core? They may work with single CPU with non-fifo scheduling, the busy waiting is going to be useless though.
&gt;I see you handle the case of more threads than queue elements correctly without ABA problems. That's great. That was the first thing the unit test uncovered. &gt;Have you tried first doing a load loop checking the condition before attempting CAS? Something I've wanted to investigate when I have time. It could reduce memory bus contention when the queue is contended. Yes, it does a relaxed load before doing CAS in \`try\_push\`/\`try\_pop\`. It is an implementation artefact but also happens to be the best practice.
I'm quite sure that for spinlocks it's better to spin on the read rather than the compare\_and\_exchange.
[https://www.reddit.com/r/cpp/comments/b8mxiy/c\_jobs\_q2\_2019/](https://www.reddit.com/r/cpp/comments/b8mxiy/c_jobs_q2_2019/)
That's true and that's what it does.
Thank you! :)
On this line?: [https://github.com/max0x7ba/atomic\_queue/blob/09240f9ac512e0e90062cfd05be5a77bc1d5427b/spinlock.h#L59](https://github.com/max0x7ba/atomic_queue/blob/09240f9ac512e0e90062cfd05be5a77bc1d5427b/spinlock.h#L59)
You still eventually are going to run out of memory if the queue is not drained fast enough. Having to specify the maximum queue size at compile time just makes you think ahead what your limits are.
Boden team member here: We are currently moving to LGPL Licensing and are still in the process of determining commercial licensing.
Yes. We're actually using the library for/with asio. Additionally, asio returns std::future&lt;&gt; when its "async" methods are called with "boost::asio:::use\_future" instead of a callback. &amp;#x200B; There's also a small section in the README specifically about using the library with asio: [https://github.com/thousandeyes/thousandeyes-futures#using-the-library-with-boostasio](https://github.com/thousandeyes/thousandeyes-futures#using-the-library-with-boostasio)
Thank you, we are glad to hear all the positive support.
We are close to ironing out the licensing issues. The framework has matured a lot since the interview, but there are still use-cases that are not fully supported which we are working on.
The String alias is just a convenience for us while we are waiting for std::u8string to become available ( so we can switch over easily )
Absolutely, there is nothing to prevent you from writing your own views and interface with the underlying platform.
That's a hardware lock elision version, it must proceed optimistically. This version is not benchmarked and not currently used.
Spinlocks can still be significantly lighter then a jump into the kernel for a semaphore wait. But they have a catch. In general I prefer a short spinlock with a maximum loop count. And if this count is reached triggers a semaphore/mutex wait. That prevents nasty CPU cycle burning via spinlocking if the locking thread happens to be suspended by the OS on a system under heavy load.
We gain a bit more flexibility from not relying on NativeActivity as to which type of Activity we want to use ( In our case we derive from AppCompatActivity for instance )
&gt; Spinlocks can still be significantly lighter then a jump into the kernel for a semaphore wait. And they are often more efficient than elaborate lock-free versions because the latter often do many more atomic operations.
I imagine that _mm_pause only waits for the cacheline to be invalidated and then do one test of the value. So unless you have something else writing to the same cacheline, the core should be close to idling.
Cool projects that can teach things: A Compiler for a toy language (fairly hard), quite fun. Will give knowledge about data structures and tree/graph transformations A Chip-8 emulator. Basically the hello-world of emulators, can be done in a weekend. Knowledge about how CPUs work and bitwise logic. A Small game, Pong/snake, using SFML (2d rendering library). Good to learn structuring projects. A Raytracer. Knowledge about linear algebra and performance. Small robotics stuff using Arduino (needs $ to buy arduino board :( ) . Low level to-the-metal programming. Artificial intelligence stuff. You could create a small game of some kind, and make AI that does it. For example a basic football game, or maybe a racer. Those tend to be good options. For just pure algorithm practise, maybe try CodinGame or hackerrank excersises. They are pretty good to learn small-scale C++
Don't mutexes do that anyway (first soin a couple of times and then take a OS lock)? But maybe common implementations do that behind a function call because they delegate lock/unlock to a c-linrary with a stable ABI and that's where the overhead cones from.
Yaaay! Thank you; this will make everyone who uses permissive- and sol3 very happy!
Two things I'm wondering from the benchmark: 1. Is just pushing millions of individual integers really a realistic scenario? 2. Why is boost::lockfree::queue so slow and would another boost::lockfree datastructure be better?
I would not expect them to implement this as a default behaviour. It would just waste cycles if the lock always was longer then the spinlock wait. When I use this kind of lock, I know that the code has a very short duration. I mostly use it like a "large atomic" for transaction like changes.
&gt;Is just pushing millions of individual integers really a realistic scenario? In a production setting the messages are allocated from a memory pool. An index to the message is then posted through the queue. On x86\_64 architecture pointers are 8 bytes (the upper 2 bytes are unused, so they can be reduced to 6 bytes), so that using 4-byte indexes reduces memory footprint. &gt;Why is boost::lockfree::queue so slow and would another boost::lockfree datastructure be better? I am not sure why, will have another look into that. Will add boost::lockfree::spsc\_queue for 1-producer-1-consumer scenario for reference. What are your throughput expectations for boost::lockfree::queue? What other boost::lockfree data structures do you suggest benchmarking?
&gt; It is the only safe way to use polymorphic objects allocated at runtime That's a very misleading statement. Polymorphism simply has nothing to do with the choice between `unique_ptr` and `shared_ptr`, it's just a matter of single vs multiple owners.
There are 4 possibilities here: 1. Compile-time. 2. Run-time, at construction. 3. Run-time, resizable, bounded. 4. Run-time, resizable, infinite. I personally prefer option (2), as it allows an easier work-around when a queue overflows due to spikes in production without the additional complexity of handling resizing. Still, (1), (2) and (3) all involve back-pressure at some point.
Great hearing about things which will only be becoming mainstream in ten years' time! I hope C++23 meets expectations!
that's cool
Look into some of [these books](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list)
&gt;Run-time, at construction. I guess your scenario is when you may like to increase the queue size in the config file without recompiling. This is trivial to implement, will probably add such a version. However, those power-2 optimizations may be unavailable in this case.
pthread adaptive mutex is supposed to do that, but I am not sure what the current state of it. You can experiment and benchmark it with any mutex you like using `AtomicQueueMutex` template.
**Company:** [Canon Medical Research Europe](https://research.eu.medical.canon/) **Type:** Full time **Description:** We have vacancies for a Software Engineer and a Scientist at our R&amp;D centre of excellence in Edinburgh. This is an excellent opportunity to work in an intellectually stimulating environment, with exposure to leading edge technology within the medical imaging industry. We strive to create technology that makes a meaningful difference to people’s lives, helping doctors to help restore their patients’ health and well-being. You will be working within the Visualisation Team, an agile software development team that creates innovative real-time rendering and visualisation tools for Canon Medical Systems. You will be responsible for coding, testing, documenting and supporting advanced high-performance rendering algorithms for medical imaging software systems. You will take responsibility for the completion of designated software features, designing suitable solutions to complex problems with assistance from domain experts and technical specialists, and will be involved in all aspects of the development lifecycle. To be successful, candidates should have an excellent academic record, holding a 1st class or upper 2nd class honours degree in a Computing or a numerate discipline, such as Mathematics or Physics. They should also have proven practical experience of working with C++, strong mathematics skills (3D geometry and associated vector/matrix linear algebra in particular) and knowledge of computer graphics techniques and algorithms for rendering, as this is a core component of the role. Additionally, knowledge of parallel programming techniques (multicore and SIMD), GPU programming (using a shader language or CUDA/OpenCL, for example) and low-level optimization tools and techniques is desirable, but not essential. We aim to offer an inclusive, flexible and balanced working environment, by being an employer that cares for and respects its employees. We are part of a global family, that works closely with other development teams based in Japan, America, Canada and France; giving the opportunity of work placements at partner sites. As an employer, we want to provide you the right environment to allow you to develop your career, by giving you time to learn new skills and pursue your own creative projects. **Location:** Edinburgh, Scotland. **Remote:** No **Visa Sponsorship:** No **Technologies:** Required: We work primarily with C++ Visual Studio (2010, 2013 and 2017) for our CPU rendering, and CUDA for our GPU rendering. SVN, GIT and Windows familiarity is useful. **Contact:** [Use our recruitment page](https://www.cloudonlinerecruitment.co.uk/CanonMedicalEdinburgh/home.aspx) or PM me for details.
I agree about using 'unsigned char'. However the STL uses char/char\* so a cast is needed. Why doesn't the STL use unsigned char?
That's good
&gt;In a production setting the messages are allocated from a memory pool. An index to the message is then posted through the queue. On x86_64 architecture pointers are 8 bytes (the upper 2 bytes are unused, so they can be reduced to 6 bytes), so that using 4-byte indexes reduces memory footprint. Sure, I'm familiar with such schemes, but that also means you have other shared state (the pool) and the threads are doing much more than just creating ints an putting them into the queue (or read from then) Not saying it is a bad benchmark. Just curious as I have never worked on applications with such extremely high performance requirements. What I do wonder is if there are any good ways to measure the actual latency (and in particular the distribution) and not throughput. My impression was that that is usually the more important metric. &gt;What are your throughput expectations for boost::lockfree::queue? None. I've used it in a few applications, where it was "good enough" and used a custom one in some embedded applications (again, good enough). Just sad to see, that standard / of the shelf solutions perform so "badly" and I wondered if their design is just outdated somehow, or if they just make different tradeoffs.
So far everyone has told me that regular mutexes (on linux) do spin a couple of times. But I've no idea, if that is a fact or just an often repeated urban myth.
It seems glibc mutex use a spinlock: https://github.com/lattera/glibc/blob/master/nptl/pthread_mutex_lock.c
\&gt; Sure, I'm familiar with such schemes, but that also means you have other shared state (the pool) and the threads are doing much more than just creating ints an putting them into the queue (or read from then) There is shared constant pointer to the array that the pool allocates from, the receivers do \`auto&amp; msg = msg\_pool\[msg\_index\];\`. \&gt; What I do wonder is if there are any good ways to measure the actual latency (and in particular the distribution) and not throughput. My impression was that that is usually the more important metric. There is a ping-pong benchmark that measures exactly that, see the github page. The interactive chart for that is due.
I wanted to leave a comment about this: moveable_optional(moveable_optional&amp;&amp;other) { if (other.has_value()) { value_ = std::exchange(other.value_, T{}); } valid_ = std::exchange(other.valid_, false); } Take a look at Howard Hinnant's answer [here](https://stackoverflow.com/a/51809349/2069064). The point of move semantics is performance, so you should not add extra work that client's don't need... and client's shouldn't assume extra semantics that aren't necessary. While it is important, for instance, that a moved-from `unique_ptr` is empty, it is not important what a moved-from `int`'s value is. In this case, you are either (`!other.has_value()`) default-constructing a `T` (`other.has_value()`) default-constructing a `T`, then default-constructing another `T`, then moving the old value to a temporary, then moving the default-constructed temporary into the old value, then moving the temporary into our current value. In short, two default constructions and three moves. Given that you _always_ have objects of type `T` in this optional, this implementation should be: moveable_optional(moveable_optional&amp;&amp; other) : value_(std::move(other).value_) , valid_(other.valid_) { other.valid_ = false; } I guess you could use `std::exchange()` on the `valid_`s if you want. But the one move construction on `T` should already do the right thing for `T`. The only extra work you _need_ to do is mark the right-hand side invalid. Of course the next step would be to allow me to use your optional implementation with a type that is not default-constructible.
I am aware that these functions exist, but "creating a date class" is a good theoretical example for when you have to call a function with multiple int arguments, and you should do \_something\_ to differentiate between them. &amp;#x200B; The solution in std::chrono is more complete and explicit than mine, but I stand by what I said: the easiest way to make it explicit in client code what you are calling is to use artificial structures for strong-typing.
I’m considering cases where only one core is available or the OS is starved for cpus because too many threads enter a busy cycle. Not have a schedule yield may lock things up
I'm sure you'll find many people willing to help. Just PM me and I'd be happy to discuss my work/career/anything.
&gt; I guess your scenario is when you may like to increase the queue size in the config file without recompiling. Exactly :) &gt; This is trivial to implement, will probably add such a version. From experience, yes, it is extremely easy. It does require using heap-allocated storage, which is a slight downside, but there is no performance degradation so I generally go with the additional flexibility/encapsulation benefits. &gt; However, those power-2 optimizations may be unavailable in this case. I've seen two ways of guaranteeing power-of-2 optimizations: - Reject any non-power-of-2 size, period. Either with a run-time check + exception, or by accepting the log2 of the size. - Round-up to the nearest power-of-2. If using the exception mechanism, I suggest to inform the user of the nearest lower/upper power-of-2 in the exception message so they can quickly correct their configuration. (As for validation, `size &gt; 0 &amp;&amp; popcnt(size) == 1`)
These queues are for ultra-low-latency applications that people run on dedicated hardware, CPUs isolated specifically for your application, threads pinned to specific cores / NUMA nodes, threads with different and specific priorities, FIFO real-time scheduling policies. If you cannot provision enough CPU cores solely for your application lock-free solutions are not applicable, you should use regular blocking solutions.
Looking forward to seeing you around champ &lt;3
&gt;I've seen two ways of guaranteeing power-of-2 optimizations: Didn't think about that. I like the idea.
I’ve written these data structures myself and have occasionally notices cases where the occasional yield is significant. Even on higher powered machines it’s not uncommon to have thread domains pinned to fewer cores. For example rendering threads in console game engines tend to be pinned to only two or three cores (fourth core on the cpu complex is reserved for the system os)
indeed i did the first for a personal project; but by the time i had to implement classes and inheritance and translate the executable tree into bytecode i surrendered and switched to angelscript in my program. Maybe i was going too far with my interpreter
Fair enough. Looks like there is need for a version with limited spinning followed by `pthread_yeild`.
Yea that might be wise. In principle there might even be cases where performance is improved in a conventional use case as it frees up more cores to eventually process the code that is obstructing progress on the yielding thread. Personally I’ve been meaning to design data structures that “learn” based on access patterns to choose the correct code path
You had me at Sutter.
True, Intel documentation recommends using `_mm_pause`/`PAUSE` for spin loops in https://software.intel.com/en-us/articles/benefitting-power-and-performance-sleep-loops However, `PAUSE` instruction latency on Skylake increased from around 10 cycles to 140 cycles. This is what I benchmark on and `PAUSE` seems to be detrimental to throughput and latency in my benchmarks.
I think he meant to read and try to understand the source code for clang. Lol though
You're better of using pdcurses/ncurses for a roguelike.
I'm currently an intern in the game audio industry and am a senior at DigiPen Institute of Technology. Im not sure if I'm the type of person you're looking for, but id love to chat! Feel free to pm me :)
&gt; literally just reorder your structs variables by size (largest to smallest) Usually yes, but only because the fundamental types have `alignof(x) == sizeof(x)`. You should be ordering by alignment. If you have `alignas(8) char x;` it should go before `short y;`.
Visual Studio has themes? I mean, other than the default ones? By the way, Dark Theme. White is too bright even during the day, let's not talk about afternoon/evening. Blue feels strange o.O
.... I just realized that VS you can't download themes from the internet. The light themes are so bad, oh well :(
I enjoy white theme and find the color scheme in dark less appealing and readable, but then again I usually run with a low brightness on my monitor and Flux all day.
If you go to r/engineering (or r/askengineers, can't remember) you'll find a nice list of engineers who volunteered for this kind of interviews. List includes degree and industry.
My favorite one is the Monokai pro, either Filter Octogon or Filter machine. They're both dark themes I honestly can't stand white themes.
I know what he/she meant. :)
I’ve always used [this](https://studiostyl.es/schemes/wekeroad-ink) one
I definitely remember changing it on my computer, so there must be. Can't remember a link though.
He runs Epic Games, which has been doing all kinds of nasty anti-competitive stuff with their Epic Games store, like buying exclusivity for games that have already made promises to release on Steam. Also, people hate how the Epic store still isn’t a viable alternative to Steam, given how many options it’s still missing, like a shopping cart feature. In addition, Epic is partially owned by the Chinese government.
Are you British, by any chance?
Will do as soon as I'm home from school 😂
I'd love to chat with you regardless, expect me to contact you some time today! (Kind of in school right now)
I'm a Software Engineer. I worked for the past 3 years in the ADAS domain. Lemme know if you have any questions :).
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bv4fip/good_c_projects_to_have_in_depth_proficiency_and/epmxlca/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!remove
OP, A human moderator (u/blelbach) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bv55t7/c_roles_in_west_london/epmxppg/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bv7y60/visual_studio_themes/epmxs1x/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; Epic is partially owned by the Chinese government. Ugh. I really don't like how some people justify money at all cost.
Hey I go to digipen too!
Yes. The idea is to get a perfectly matching tool for UE4 developers, who are mostly in Windows environment, so ReSharper C++ can cover it nicely. Most of the coding assistance features will also be available in ReSharper C++ (that's why it actually got a few already in 2019.1 release).
If would be useful if the return could be such that it works with range-for to iterate over the delimited elements.
This is semi-unrelated to your request and I'm not professional by any means, but if it interests you, you should look into full stack development with javascript frameworks. I personally familiarized myself with the MERN stack (MongoDB, ExpressJS, React and NodeJS). I as well felt like my high school's computer science class was too slow and I started dabbling in full stack development and ended up loving it, so maybe you will too. Have fun and good luck!
Been following this for a while. Using Qt currently to target Android and iOS from the same codebase. But the lack of native controls in Qt is rather annoying. I have high hopes for this one.
Windows 10 has an embedded flux like functionality. If you have low brightness, Dark Theme is impossible to use xD
Congrats guys, on episode 200! Enjoyed this one even more than usual, thanks!
I have updated the [theoretical background section](https://github.com/wovo/torsor#theoretical-background), ao. with a description and examples of the four classic scales. The wiki page is almost unreadable for me. I suggest reading the [torsors made easy](http://math.ucr.edu/home/baez/torsors.html) page.
Tons and tons of people still argue for implementing default construction, copy construction, and swap, and then implementing everything else in terms of these, which causes lots of waste of the kind you point out. It drives me bonkers. You rarely need to write special member functions in the first place; when you do it's usually for a fairly generic, lower-level, resource managing class. Why not do it right?
Why din't I think of that approach! I will surely try it.
Just when I thought I understood things to a certain extent, something new just comes right out of left field with no warning.
Boost supports memory\_resource wonderfully: [https://github.com/boostorg/container/blob/9e2913d4e367e98316875bf52e63a0e389666e06/include/boost/container/pmr/memory\_resource.hpp](https://github.com/boostorg/container/blob/9e2913d4e367e98316875bf52e63a0e389666e06/include/boost/container/pmr/memory_resource.hpp)
I've been coding and/or managing engineers for over 20 years, currently a co-founder at a small game company. Always happy to chat about this kind of thing, feel free to PM me as well.
Fixed, text. Actually what I would write was: . In addition, it is not possible to return polymorphic objects from functions by value. It is only possible to return those objects by pointer with std::make\_shared, std::make\_unique or new Object due to object slicing. &amp;#x200B; What I said is that is not possible to return polymorphic objects allocated by value like in this case: &amp;#x200B; class A{}; class B: public A{}; class C: public A{}; // Does not work A factoryFunction(char x){ if(x == 'b') return B{}; if(x == 'c') return C{}; return A{}; } When I said about return by pointer, is that it is only possible to return them with: A* factoryFunction(char){ if(x == 'b') return new (std::nothrow) B{}; ... } // Or std::unique_ptr&lt;A&gt; factoryFunction(char){ if(x == 'b') return std::make_unique&lt;B&gt;{}; ... } // Or std::shared_ptr&lt;A&gt; factoryFunction(char){ if(x == 'b') return std::make_shared&lt;B&gt;{}; ... } \&gt; Polymorphism simply has nothing to do with the choice between unique\_ptr and shared\_ptr , it's just a matter of single vs multiple owners. &amp;#x200B; My point was that polymorphism in C++ does not have value semantics and it is only possible with pointer or smart pointers and obviously smart pointers are the safest way to deal with this case. When I said "referred" by multiple objects, I meant multiple objects holding references to a dynamically allocated polymorphic object which is the same as multiple or shared ownership, in this case shared\_ptr is the most sane choice.
(somewhat tongue-in-cheeck) As a small-embedded programmer I feel a bit excluded by your direct use of ostream in the operator&lt;&lt;. (My systems generally don't have an std::ostream, but do have something that walks and quacks alike). I define my operator&lt;&lt;'s in this way, which doesn't discriminate: template&lt; typename COUT, typename W &gt; concept bool can_be_printed_to = requires( COUT cout, char c, W w ){ ( cout &lt;&lt; c ); ( cout &lt;&lt; w ); }; template&lt; typename COUT, typename T &gt; requires torsor_concepts::can_be_printed_to&lt; COUT, T &gt; COUT &amp; operator&lt;&lt;( COUT &amp; cout, const torsor&lt; T &gt; &amp; right ){ cout &lt;&lt; '@'; cout &lt;&lt; ( (T)( right - torsor&lt; T &gt;() ) ); return cout; }
&gt; Also you should compare it to the moodycamel lock free queue. Just a quick update. `moodycamel::ConcurrentQueue` performance is similar to that of `pthread_spinlock` on 7700k. Will include it in the benchmarks.
g++ worked fine. gCC did not.
Post the command line you’re using to compile it. It looks like it can’t find the standard library.
https://lists.llvm.org/mailman/listinfo/libcxx-dev for those wondering where said list can be found.
I'm proficient in Java, C, and SQL, just not web tehnologies since most my classes were low level. I'm not really looking for shortcuts, I've just found that simply reading about a language is inadequate for gaining proficiency in it, and I figured people here would have some good resources for getting hands on.
It is a bit more involved than that. `do_push` is going to spin on the element because a reader might get behind and not consume the element in so much time, that a producer stumbles upon an unread element that is `SIZE` elements behind. My unit stress-test catches that. That probably only happens in extreme conditions like the stress-test unit test. Normally, `do_push` succeeds immediately.
Thanks, I'll look into this. I've done a compiler, games, and ai in other languages so I might try my hand at those first to see how they compare. Would you happen to have any recommendations for projects that are a bit more low level along the lines of reinforcing concepts for concurrency, low latency i/o or socket programming/networking?
... what is it?
This isn’t *super* on topic but I’ll allow it today. 😸
&gt; literally just reorder your structs variables by size (largest to smallest) no. actually think about the layout. largest to smallest can bloat up your size even without special alignment members (eg struct {char[7]; int; char;} (largest to smallest) is 16 bytes, whereas you could reorder it to be 12)
See the main page of the GitHub repo above. It has a good overview of CIDLib.
Something like GCCs -Wall “all of the important, easy to fix warnings” would be great to have in MSVC. /W4 is missing some pretty useful warnings and /Walls "Hey there is padding :O" is too noisy.
ReSharper C++ supports doctest, so there's IDE integration with at least Visual Studio.
The table says Aggregates/Copy init doesn't compile. Presttu sure that is incorrect, since struct X { int a, b; }; X x = X{}; Works just fine.
Why? Because it is arcane magic built up by people over the years, and there should be an easier way.
God bless your soul.
I'm a developer at a trading firm doing a lot of low latency C++. I started coding for fun back in high school, got my bachelor's in it, and I've been in the trading game for most of my career. I'm coming up on 10 years of professional development. I'd be happy to chat, you can PM me for discord account info if you want
I am sure that almost everyone on the cpp subreddit would disagree vigorously with the idea that a beginner learning JavaScript has any value at all. A beginner who wants to work at google one day needs to start with the basics. Learn assembly, write an O/S boot loader for an opensource executive, then write your own small executive, then create some shell code exploits, download Ghidra and reverse engineer a bunch of binaries, then learn modern c++. Then go out and get a job and write a bunch of stuff professionally, and then, and only then, determine if you really feel like working in JavaScript and if you do, that's awesome (not bashing JavaScript at all) then go and learn it, but if you learn JavaScript first, you'll be shortchanging yourself badly.
I only state can be worse. Agree benchmark is needed. I have usecase where I basically only use L3 cache. My event loop prefetches memory it expects to use when there are no actionable events. Moodycamel type queue will use more cache I might not be able to spare.
Worse is a relative term. What is it worse than?
That's like telling someone to learn mechanical engineering by designing a car. I think there are more productive ways to go about it, such as finding a motivation to code and expanding your knowledge base outwards from there in the directions that appeal to you. I certainly wouldn't recommend writing a bootloader or an OS as a beginner; it's a hefty job even for an intermediate or advanced programmer.
That's how I learned. First thing I wrote ever was an executive. It's how almost everyone I know who's a professional learned. It is the great lie of software engineering that one should learn high level languages first and it is the reason we suffer the huge shortage of the actual talent we actually need
That's it's slower than C.
constexpr FTW
That it is automatically fast. You layer bad algorithms on top of bad data structures and you can make code in any language slow as hell. (See the conflict between OOP and data oriented design.)
That there is a difference between i++ and ++i in a for loop when it comes to the logic. University lecturer taught us that if you went i++ it was incremented at the end of the loop where as ++i was incremented at the start of a loop. Took a few hours on StackOverflow to unlearn that.
&gt; when it comes to the logic. They're logically equivalent, but that's not the important part. For non-trivial types, the [post-increment returns a copy of the object](https://stackoverflow.com/questions/30941980/why-post-increment-needs-to-make-a-copy-while-pre-increment-does-not), which can be very expensive.
Actually, there is a difference. 1. I can be of user-defined class. And that class can overload operators ++. And these are two different operators. 2. You can write loop condition is such a way it will be a difference even for int type.
that it's incredibly difficult.
That you don’t need to understand pointers and the underlying memory model
... what? Do people really think that?
As other commenters have mentioned, for user-defined types, i++ can actually be substantially slower bc it involves a copy. For built-in types, they compile to the same thing bc the copy is optimized out.
Yeah but probably there are better ways to learn the basics and so. Maybe doing your own ```malloc()``` or learning how it works, as well as getting to know the standard library and why it works that way (I mean in C++). Also, creating games from the ground up (simple ones) help understand other concepts, as well as doing your own tools for other kind of tasks, like processing an image of a certain extension and so. Maybe try to connect two computers via C++, or use C++ in one and another language in another to see the differences of what has to be implemented in one and not in the other, etc.
I hope they specify owning smart pointer.
&gt; For built-in types More like "when the operator is inlined" I think. If the compiler can figure out that the copy in `i++` is unnecessary it can get rid of it, but that can't happen if other people might call the function. &gt; But it still ends up relying on a compiler optimization This is really a sliding scale. Just about everything in the STL relies on compiler optimisations to run as fast as the equivalent C. Often enough we'd consider it a bug if those optimisations *didn't* happen, and the difference between preincrementing and post-incremeting an integer falls *well* below that threshold.
That it’s a hard language. I don’t know how this one got started, but it wasn’t considered any more difficult than Java or anything else back when I was in college.
Not sure if it qualifies as a 'myth' per se, but "C++ was better before and gets more and more complex with each iteration" if anything the language feels less complex and far more easy to use than ever before...
Everything you said is true and fair, but when it's the difference between putting ++ before or after the variable, I'd personally rather play it safe and not even give the compiler the chance to not optimize it.
Well you can go a long way without them, but at some point they are required
I always enjoy listening to Herb Sutter &amp; learning something!
I don't think so. You'd lack the internalized context for why a malloc needs to exist in the first place or how code gets loaded on a processor and how it is scheduled. Writing an executive with a scheduler teaches you about register contexts and switching. A basic executive can be implemented in less that 10,000 lines of C code (if writing 10,000 lines of code scares you, you need to get over that if you want to work in this field). Next you can look at a full MMU implementation (you don't need to code that, but having done a basic executive will allow you to understand what is happening in a full VM system. At that point you have a reasonable understanding about how it is that your code actually runs. Assuming that the OP is going to a good college after high school they'll then take OS and compiler design courses and at that point they'll have sufficient knowledge to understand what is happening under the covers. Then they should work for a while in c/c++ (plenty of jobs out there) and after doing that for a couple of year then get serious about JavaScript (or python or whatever of the other myriad of high level languages interest you). By learning a high level language at that point, you'll be in a position to appreciate what high level languages bring to the table, what sacrifices are made and then you are in a position to decide whether you want to write in high level languages or not. If you learn high level languages first you'll not appreciate what they bring to the table and neither will you understand what lower level languages bring to the table. The bottom line is, if your college is teaching you JavaScript, find another college (not because there's anything wrong with JavaScript, but because there is something wrong with *teaching* JavaScript).
I just meant it as a recommendation for a side hobby that I thought might interest him. Wasn’t thinking about that. My bad.
The reason ++i is used so much in the STL is that user defined types may implement only one of the operators so they make sure that you don’t require both.
There's very little you can write in C that won't compile as C++ almost identically. But C++ offers additional abstractions and features that can make life easier ... some of which are slower, and some are faster.
I see why an executive now. Before I thought it might be too much to work forward from the beginning with tons of frustration and it wouldn't help that much. Now with your point of view it's clear that despite the time it could take, it's completely worth it. And I agree, it's not good to teach something like JavaScript as a first Programming language because of the reasons you spoke as well as all the bad habits and bad practices that could come along. Even without them, by not taking into account how the computer works, code might be lousy and slow despite being ok respect to the syntactic sugar that's furor of the moment. Thanks too for widening my view.
* That volatile is useful for multithreading. * That floating-point values are fuzzy or nondeterministic. * That lambdas are `std::function`s.
That exceptions are slow.
I thought I'd try out porting this solution to Rust and the result turned out pretty well. Unfortunately, I needed to drop the named members of the struct because otherwise initializing the data was overly verbose. use std::collections::HashMap; fn main() { let mut accesses = vec![ ("Carly Gauss" , "https://bogusworld.net/home.html" , 20), ("Lenny Oiler" , "http://bigeyedfish.net/index.html" , 5), ("Lenny Oiler" , "http://bigeyedfish.net/signup.php" , 45), ("Stevie Hawkley", "http://makebigbucks.com/login.php?id=none" , 60), ("Stevie Hawkley", "http://makebigbucks.com/login.php?id=644" , 68), ("Stevie Hawkley", "http://makebigbucks.com/ripoff.php" , 48), ("Lenny Oiler" , "http://bigeyedfish.net/Walleye.html" , 45), ("Carly Gauss" , "http://bogusworld.net/interviews.html?v=43", 20), ("Carly Gauss" , "http://bogusworld.net/interviews.html?v=53", 24), ("Stevie Hawkley", "http://makebigbucks.com/ripoff.php" , 58), ("Lenny Oiler" , "http://bogusworld.net/signup.php" , 20), ("Lenny Oiler" , "http://bigeyedfish.net/Nemoids.html" , 92), ]; accesses.sort_by_key(|x| (x.0, x.2)); let mut histogram = HashMap::new(); for i in 2..accesses.len() { let a = &amp;accesses[i - 2]; let b = &amp;accesses[i - 1]; let c = &amp;accesses[i ]; if a.0 == c.0 { *histogram.entry((a.1, b.1, c.1)).or_insert(0) +=1; } } let top = histogram.iter().max_by_key(|x| x.0); match top { Some(((a, b, c), _)) =&gt; { println!("Top three page sequence is:"); println!(" 1. {}", a); println!(" 2. {}", b); println!(" 3. {}", c); } None =&gt; { println!("No top three page sequence exists."); } } }
Can you expand on the third point? I understand the syntax difference amd the capturing mechanism of lamdas, but how else do these differ from a std::function?
On top of this: It’s optimized out. Compiling with anything above O2 and it is all the same.
Noob programmer here. I've got the basic concept of pointers down but what would be a good resource (or even exercise) to really dig into them?
Each lambda is of an unique type. A std::function can be used to "store" any function-like construct - like function pointers, lambdas etc. (They achieve this through something called a "type erasure" - an advanced but interesting C++ concept).
Bjarne Stroustrup wrote a great article about this topic -- Five Popular Myths about C++: www.stroustrup.com/Myths-final.pdf For those averse to PDF: https://isocpp.org/blog/2014/12/myths-1
Exceptions are slow when an exception occurs, but faster when no exception happens. It really depends on implementation.
Each lambda is a distinct type, even if they look identical. auto a = []{}; auto b = []{}; static_assert( std::is_same_v&lt;decltype(a), decltype(b)&gt;, "This assert will fire."); std::function&lt;void()&gt; c = a; std::function&lt;void()&gt; d = b; static_assert( std::is_same_v&lt;decltype(c), decltype(d)&gt;, "This assert will not fire."); I can't store an array of lambdas because they're all distinct types, but I can store an array of `std::function`s because they are the same type.
I’m curious about the second one. I’m assuming you are restricting it to the same architecture?
happy to talk :) some game and web dev experience in several languages and environments. very friendly. pm me for my discord :)
How much memory is your application consuming? At some point a few coworkers were talking about the need to optimize some time spent in an application and it turned out it was about 1ms every 10s that was getting "wasted". A few times I have started down the path of trying to optimize some memory and then realized that it would at best free up \~10kB in a program consuming \~100GB and so stopped. In the original post: &gt; What I have is a loop where I need to allocate and construct N objects where each one is some 6,000 bytes. How much RAM does the target platform have and how large is N here? If the target platform has 4 GB and N is 20, you have plenty of free space, OTOH if the platform has 5 MB and N is 1000, you will overflow. Another thing you could do is have a small list of available memory blocks. When something is done with an object it pushes the pointer into the list. When it needs a memory block, it pulls a pointer from the list. When the free blocks exceeds some limit, a thread wakes up and releases some. If it drops below some limit, it wakes up and allocates them. &amp;#x200B; That said, however you design this, there will be some tradeoff between time spent on allocation/deallocation and memory wasted by your application. &amp;#x200B; Another possibility is to use `alloca` with placement `new`. This allocates memory on the stack rather than the heap/free store. It consumes no extra time to allocate memory (there is probably some when you drag the MMU/page table in). However, the memory can only be used inside the scope that allocates it as it automatically gets freed at the end of the scope.
&gt;That it’s a hard language. I don’t know how this one got started, but it wasn’t considered any more difficult than Java or anything else back when I was in college. It was a fair criticism back then. We expected first semester students to be able to use char arrays (along with all the attendant problems), C-style arrays, and so forth. Nowadays we have strings and vectors, and they're arguably easier to use than Java's equivalents.
It's not called the ++C language
Some people think that removing almost all unnecessary whitespace is a good idea.
200! Great job to my favorite YouTubers. ;)
This is one of my pet peeves. Yes the compiler will optimize it out 99% of the time, but it really it shows a fundamental misunderstanding of how for loops work when people use post increment in that context.
Honestly, I would recommend making sure you understand how a computer actually works. It's more work, but it is both satisfying and useful to (more or less) know how a computer works from the transistor up.
For a given representation (IEEE 32-bit and 64-bit being popular), each finite floating point value is an exact real number. Converting numbers to floating-point can involve rounding, introducing what is essentially quantization error, but once in floating-point form, the value is precise. What happens during math is more complicated (addition etc. can involve further rounding, transcendental functions aren’t required to produce mathematically correct rounded answers in general), but that’s separate from the floating representation.
&gt; aster when no exception happens. With branch prediction and out of order execution, even this is debatable. If your exception fires rarely enough for it to not "confuse" your branch prediction were you to switch to error codes, then the "happy" path would be the same, not faster. &amp;nbsp; The bigger problem of exceptions is their indeterministic nature which is why they are simply unusable in hard real time systems.
Lambdas stamp out classes with data members and a function call operator. They don’t allocate memory (unless their data members do), and they can now have templated function call operators. std::function is a library class which can store lambdas and other callable objects, with runtime expenses.
Yes, but what makes you ask?
From the Father of C++: http://www.stroustrup.com/Myths-final.pdf From me: 1. C++ is mainly/mostly/only/actually/unsuitable for &lt;insert software domain here&gt;. 2. &lt;insert whatever bad here&gt; is C++'s faults. 3. C++ encourages bad code. 4. Good C++ code is not true C++ code. (3 and 4 together form circular logic.) 5. C++ is an OOP language. (for some definition of OOP) 6. C++ is not an OOP language. (for some definition of OOP) 7. C++ is unusable/difficult/broken because &lt;insert laughable "reasons" here&gt;. (There are legit problems in C++. But those who emphasize their laughable arguments have stopped learning far before they understand the real issues.)
That C++ is a strict superset of C. Most modern C code actually won't compile as C++. You may be able to get it through the compiler by selectively disabling flags and adding `-fpermissive` etc., but many standard practices in modern C are at most "not great" in C++, at worst a compiler error. In particular, implicit conversion of `void*` to any other pointer type is valid C, generates a compiler error on all modern C++ compilers: ``` MyStruct* foo = malloc(sizeof(MyStruct)); // C: OK, C++: error ```
Actually, I believe most modern C code will not compile as C++. [See comment here.](https://www.reddit.com/r/cpp/comments/bvf78q/myths/epp6q7i/)
&gt;That floating-point values are fuzzy or nondeterministic. That's because they sort of are. * SSE and non-SEE math produces different results. Consider the following snippet which you can run in the current version of Visual Studio. #include &lt;iostream&gt; float f2(float a, float b) { return a / b + b / a; // Nothing special about this one, I'm just trying to produce interesting tails in 80bit registers. } int main() { int aInt = 10043275; int bInt = 10231720; float a; float b; memcpy(&amp;a, &amp;aInt, 4); memcpy(&amp;b, &amp;bInt, 4); float c = f2(a, b); uint32_t cInt; memcpy(&amp;cInt, &amp;c, 4); std::cout &lt;&lt; cInt &lt;&lt; '\n'; return 0; } With default VS2019 settings it will print 1073743274. With /arch:IA32 it will print 1073743273. Ofc. as the time passes, the results on two synchronized systems (SSE and non-SSE) diverge more and more. Also, this shouldn't matter, but I feel obliged to add "I'm using an Intel CPU". Fun fact: /fp:strict doesn't change the outcome, because VS can't generate proper instructions to actually do the rounding as it is required by the standard. Tails of 80-bit floats add up just enough to produce a different result. Fun fact #2: VS just changed the default at some point. But wait, there is more (this time not related to the compiler). * Transcendental functions are not unified between the vendors. They are almost consistent between new Intels and AMDs, but between x86 and ARM the results are massively different (and I'm not aware of a library implementation for ARM that would even attempt to emulate, let's say, the behavior of Intel's microcode). The situation is worse with entirely vendor-specific stuff like _mm_rsqrt_ps(). Many game studios had subtle bugs with desynchronization of multiplayer games specifically because of issues like this (and many eventually decided to never use floats in net code). So no, unfortunately floating-points values are very unreliable, and will stay unreliable until the industry as a whole does something about this mess. And let's not even talk about various [library implementation bugs](https://www.exploringbinary.com/incorrect-round-trip-conversions-in-visual-c-plus-plus/). While they are easiest to fix, they are definitely not helping with the reputation of floats.
The devil is in the details, here. If your iterator is non-trivial (which many iterators are; `std::map::iterator`, for example), it must have separate definitions for `++i` and `i++`. The compiler isn't guaranteed to be able to elide the copy here, especially not if the call to `i++` is not completely inlined.
I make a distinction between functions that produce floating-point values (where you are correct) and the values themselves. I'm also working to fix those library implementation bugs :-)
&gt; I’m assuming you are restricting it to the same architecture? Not /u/STL, but I believe he's restricting the claim to "all architectures that implement floats the same way", or maybe "all IEEE-754 implementations". Either way, there's a big difference between a non-deterministic and imprecise.
&gt; That floating-point values are fuzzy or nondeterministic. I've had a little argument about the better way to scale an integer (in a fixed range) to the 2^(-34). I think the integer division is fine (`return static_cast&lt;double&gt;(value) / (1ull &lt;&lt; 34);`), but he is afraid of the rounding errors and proposes the `std::ldexp(value, -34)`. Can you help and tell, who is correct on this one?
On modern architectures, exceptions are zero-cost for the happy path. There is no error code checking - the branch predictor plays no role. Instead, when an exception is thrown, the stack is unwound using metadata compiled into the binary similar to debug info (on Linux x86-64, it is actually DWARF metainstructions indicating how to properly unwind the stack and call destructors along the way). Interpreting this metadata can be much slower than normal control flow, but it only happens when an exception is actually thrown. The only performance impact of using exceptions when no exceptions occur is that it can potentially prevent some optimizations, and of course increases code size.
That people who use C++ are dinosaurs, rather than people who know the best tool for the job.
This was awesome. Herb can communicate and he is great to listen too. Otherwise most interviews tend to feel too long. This was in a way deep dive into C++ which was awesome. We need more episodes like this. Get Andre back.
I've spoken to multiple people who ostensibly took a C++ class in college, but didn't understand pointers, data structures, or even the underlying bitness of their platform. If you don't even know what size your pointers are you probably aren't going to form a useful mental model of the machine.
Oh I see I read your comment as floating point math, not floating point representation. Yea I agree with that
That there are zero cost abstractions. Of course it refers to the runtime costs but even that heavily relies on the compiler optimizing it all away. We've become so dependent on this that a traditional debug build without any optimizations is quite infeasible these days for larger projects. And of course we put more and more burden on the compiler, esp. with heavy template magic. The compile-time costs are often neglected when a new fancy abstractions is presented.
A basic exercise in teaching the application of pointers is implementing a linked list.
I knew someone would misunderstand what I tried to say. Let me rephrase. For the happy path, exceptions are zero cost, but on modern CPUs error code checking for the happy path would also be zero cost while providing a much more efficient error path.
But how big is the spec? The reason many people don't think it's hard is because is probably more because they don't know what they know. I imagine that few of us could pass a real grilling on the trickier details of the language, even most folks considerably more language lawyery than me.
But it clearly is getting more complex. It's more maybe that as set of complexities existed before that weren't addressed by the language, then in the process of trying to address those things, a new set of complexities replaced those, but in the language itself this time. Partly, IMO, a lot of this complexity comes from the fact that some of the things required to address those issues aren't native to the language, so they require a lot of extra complexity on our part to accommodate them.
I think that Modern C++ discourages understanding them, because of the fairly widespread belief these days that actually having a raw pointer in your program is a sign of a fundamental implementation flaw.
Mpmc queue like OP
I think that previous comment meant that resulting assembly will be pretty much the same.
If you don't know what you're doing it's probably easier to create slow code in C++ than most other languages because it uses value semantics by default.
90% of the time it just doesn't matter - even in debug code, because you are working on native types. If that is the biggest problem you spot in a code review, your code base is in very good shape.
I disagree with that. Complexity is not the same thing as "number of features" or "number of pages in the standard" - if that were the case Perl ("there's more than one way to do it") and Java (with its huge library) would, or _should_, be considered far more complex languages. New features causes the language to grow in size, but it may very well decrease its complexity by making it easier to express common idioms. Think range-based for loops, optional, auto, etc.
Half of your myths could be applied to literally anything. Ex. Ferrari is mainly/mostly/only/actually/unsuitable for &lt;insert driving domain here&gt;.
Ah, interesting argument. I think you are probably right. A pipeline stall is much cheaper than unwinding the stack. FWIW, I tried to investigate this at one point, comparing C++ exception handling (without actually throwing any exceptions) with C++ `std::error_code` and Rust's `Result&lt;T, E&gt;`. They were quite equivalent when no errors were happening, but exceptions were much slower when errors started happening. I don't think exceptions should necessarily be avoided for this reason, as long as we only use the for truly exceptional errors.
I guess that might be me or Joaquín. I like it that way in terms of readability. I also want to minimize the amount of code needed to download and build my software. I think some aren't aware of how competitive things are. Being small is part of my strategy. When David took on Goliath he rejected Saul's armor after trying it on. David fought in his own nimble way. I hope people will find my software nimble to build and use.
&gt; A pipeline stall is much cheaper than unwinding the stack. If I remember correctly, we're talking orders of magnitude difference in CPU cycles, but take that with a grain of salt. &gt; I don't think exceptions should necessarily be avoided for this reason, as long as we only use the for truly exceptional errors. I'm not arguing that one should stop using exceptions because of this. If you don't have a good reason (read: hard realtime, safety critical, really tiny systems) to disable exception in the first place, then, once an error occurs, chances are that you're not in a performance critical path and can take your time to throw if you find that more appropriate than error codes.
Right. "For any valid C code, you can write C++ code that compiles to the same thing" is correct, as far as I know. :-)
Code portability. While it's true on a pure level of source code, try to use something that doesn't exist on other platforms see std:: filesystem or parallel executors for algorithms
Restrict though.
What was it before?
As long as the integer is smaller than 2^53, the values on both sides of the division are exactly representable as a double-precision float (values greater than 2^53 would cause you to lose the lowest bits in *both* cases). If the platform is IEEE-754 compliant, division is required to give the closest-to-exact result possible. In this case the result is also guaranteed to be exactly representable since the division is by a power of two and the result can't exceed the range of normal double-precision floats, which means there is no rounding happening anywhere. Tip: If you have only one input within a reasonable fixed range (e.g. just one 32-bit integer or float), just exhaustively test it. It took me about 3 minutes to test all integers from 0 to 2^34 and show that both functions always return the same result.
That is not what modern C++ is about. Raw pointers normally shouldn‘t be owning, but nobody is saying don‘t use them at all. Certainly CPPCoreGuidelines aren‘t.
IIRC at least some special math functions where licensed from boost.
Can you suggest how I do that (e-book/online course/YouTube playlist etc)
A specification of some sort is standardized, not the existing library (though the specification may be based on the existing library's API). Compiler developers would then implement that specification in each of their standard library implementations. If the licence allows, this implementation could be based on the existing library.
I don't know, being able to see go to cppreference and see something that's been available since c++11, had a behavior changing defect that got fixed in c++14, and then deprecated in c++17 doesn't help.
&gt; Regardless of that, the existing “DefaultExecutor” with a “q” value of 10 ms appears to be a very good compromise between raw, real-world performance and resource utilization. In typical usage scenarios, where there will be a few hundred “std::future” instances active at any given time, mostly independent, the worst possible latency will only be a few seconds. Is it just me, or is a "few seconds" not pretty bad?
The "They don’t allocate memory (...)" part means that careful use of lambda's is OK in a no-heap (small-embedded) context, unlike std::function, which can't be used at all.
C++ is a very hard language to *lean completely*. On the other hand, to use it effectively to solve a particular problem, it might be easier (to lean and use) than for instance C.
For me (as a small-embedded programmer) the main problem with exceptions is that they won't build without a heap. And I definitely don't want no heap!
One that I have heard recently and infuriated me (looking at you Jonathan Blow &lt;.&lt;): That using smart pointers or RAII stops you from understanding memory allocations, pointers, pointer arithmetic and generally promote laziness. I would argue the exact opposite: it forces you to think twice about the lifetime of your objects, the ownership, the coupling of your classes...
That's a good reason to have P0709 at the top of my wishlist.
I’ve found this very useful http://cslibrary.stanford.edu/102/PointersAndMemory.pdf
You can start here. Might know a lot of stuff but it’s a good summary http://cslibrary.stanford.edu/102/PointersAndMemory.pdf
No worries!
Yes. That's exactly why they are annoying.
( 。・\_・。)人(。・\_・。 )
Interesting. By no means I'm an expert in c++, but I used pointers thousands of times, but I never needed to know their size. Could you please explain in details if you have time?
All iterators aren't template classes that are inlined and compiler can't optimize those copies away without link-time optimizations. Think about eg. filesystem directory iterator or some other complex iterator. Their copying may not be trivial and may require reference counting etc.
I really don't understand why the standard library doesn't have a reference implementation. Compilers would still be allowed to deviate, and would have to implement some of it themselves, but having a reference implementation would make it much easier for new compilers to enter the field, or existing compilers to keep up to date. There's a chart I cannot immediately find that shows how many compilers support C++98, 11, 14, and 17. It seems for each generation we lose around three compilers! Down from a thriving ecosystem, to only MSVC, gcc, and clang hanging in there. This situation would be far less dire if those compilers could focus on the language stuff, and use the library stuff from the reference implementation. A reference implementation would also demonstrate that the required features are actually feasible, and allow experimentation and tentative use before the actual standardisation process takes place.
It's worth noting that some architectures have special instructions to use in busy loop bodies. Otherwise these loops may produce side effects such as polluting the branch predictor, increase cpu consumption, etc. I remember intel has the special instruction `pause` and I think ARM had something similar. In fact arm has an implementation of the spin lock in their GitHub repository which is optimized for their platform.
I'm not sure there is much to dig into once you understand the basic concept, but just in case: leave your house, and find a signpost. There's probably the name of a city on it. Would you say the signpost \_is\_ a city, or just that it \_points to\_ a city? Would you agree that the signpost takes up less space than an actual city? Would you agree that removing the signpost does not also remove the city, but only your ability to find it? Congrats, you understand most there is to know about pointers. I'm still working on extending the metaphor to include arrays...
It could be some truth to it. Most of us understand what is going on being the scene (with pointer and new) because we have been doing it for years. New programmers that only know the smart pointer and RAII will probably have a harder time understanding what they do and what the advantages are because they have never experienced how it was programming without them.
Thanks for such a thorough answer. That's exactly my point of view, just wanted to confirm it.
Someone measured this a while ago, and found that it was not true. The error code path was clearly slower than the exception path, as long as no error occurred.
https://www.nand2tetris.org/#
What’s a valarray?
That undefined behaviour is required for optimisation. The vast majority of optimisation strategies do not rely on UB, as witnessed by their presence in languages that don't even have the concept of UB.
The results of that measurement really depend on too many factors like how predictable was the behaviour, the architecture of the system, the cpu model, the speculative execution attack mitigations...
Some people still use them. However I personally use expression templates to do the same kinda thing, and how I've written mine, it's a little easier to use with existing structures.
Who would maintain it? For which platforms would it be implemented? Considerable chunks of stdlib are OS and HW dependent. Not to mention that it'll likely be wrose than existing implementations simply because of the amount of battle-testing and dev time spent.
https://en.cppreference.com/w/cpp/numeric/valarray
Most major library proposals come with a reference implementation if they have any chance of being standardized. If the standard library implementors think reimplementing the library in their STLs will be unproblematic, it usually goes straight into the standard. Fmt or Span are examples of this. If standard library implementors think reimplementing the library might be surprising, then the major library proposal will go into TS form. It will be implemented as experimental, and that experience will cause reshaping of the final standardised library, which then may be reimplemented completely from scratch. Filesystem is the classic example of this, Microsoft implemented it at least twice, Boost implemented it three times. Ranges will have been implemented at least five times before it is done (I include the original Ranges v1 etc).
&gt; I make a distinction between functions that produce floating-point values (where you are correct) and the values themselves. Well, a value that doesn't get used in any function isn't terribly useful.
restrict...
Actually some of the template magic and compile-time costs are due to library optimizations to have decent performance even in debug builds.
So `float`s are precise as long as you don't use them?
There's a [DR about valarray](https://cplusplus.github.io/LWG/issue3074) not long ago, but since the maintainer has apparently forgotten valarray, the DR probably cannot be applied.
Mmm. Even that is a bit problematic if you're including implementations from the early 90s and consider NaNs and INFs part of the claim.
&gt; But it still ends up relying on a compiler optimization, which feels dirty to me. Oof, then I'm a dirty, dirty man.
I keep forgetting about NaNs and INFs.
&gt; for each generation we lose around three compilers Even if that's true, did these compilers ever have their own standard library implementations? As far as I know multiple compilers just use libstdc++.
A lot of the standard library is not implementable without compiler support (some type traits, initializer_list, reflection etc) - so you would need a reference compiler implementation too
`std::valarray` was supposed to be highly optimized by the compiler and allow batch operations on whole arrays. If I'm not mistaken, FORTRAN can do something like that. `std::valarray`'s design didn't get polished when it got standardized and it was always pretty hard to use. Just look at the "Helper classes" section on the cppreference about `valarray` class. Alexander Stepanov called C style enums "ungood" in his email to Bjarne, to which Bjarne responded with "And valarray is double plus ungood?". Historically there was also something about the maintainer of valarray giving up on them, which lead to premature standardization. Today, intel's compiler can optimize them better than `std::vector`, but gcc compiles them to something "close enough" if not the same thing as `std::vector`.
Contracts...
C++ is getting contracts.
This makes sense, but I don't think branch prediction is the only issue with error codes. Unless the compiler code has some smart way to refactor the code you also have the added cost of extra local variables. If these have to propagate across tens of function calls they add up. They might cause more cache misses or they might eat up a valuable register and push another local variable to RAM. To my understanding the necessary data for exception handling is stored out of the way so it doesn't cause the same problems.
Implementations of `std::function` are allowed to implement small object implementation, so depending on your toolchain, even `std::function` might not allocate.
Can you explain how that would work?
That's a fair point. Keep in mind that, if the error code is always some integral type, you can reuse those too. Also, debating how out-of-order execution, branch prediction and speculative execution affect code is very problematic. Which CPU? What speculative execution vulnerabilities have been patched on this system? Patched in hardware or in software? If you've measured on your own system, how do you know that what you have in your computer is representative of what your users have with regards to these CPU capabilities and attack vector mitigations? It's really hard to give a definitive answer given today's CPUs.
Allocating a function scope array of size, where size is a function argument is valid in C, not in C++
Is this /s?
And that's fantastic, but I'm really not sure if it's relevant? You can't express `restrict` with contracts.
You can? void xor_swap(int* x, int* y) [[expect: x != y]];
That's true. Besides the facts that exceptions are commonly implemented to be low cost on not throwing and that they use the heap, most statements in discussions such as this are based on personal experience and word of mouth. They are not universal.
&gt; [exceptions] use the heap Except that MSVC contructs them on the stack, then copies to heap to do unwinding and then copies back to stack to `catch`... I think. Anyway, here's the full story: https://quuxplusone.github.io/blog/2019/05/11/msvc-what-are-you-doing/
Yes :)
How would you express that two arrays don't overlap? Such an expression would be complicated enough that I suspect it could never be used for optimization.
Seems production quality linear algebra libraries just work with CRTP and expression templates. Once you get used to TMP I personally find expression templates to be intuitive to work with (unlike valarray)
Arrays as in `std::array`, `std::vector` or C-style array? Anyway, you only need to check if either begin or end of the first array is somewhere within the second array. template&lt;size_t N, size_t M&gt; void f(int (&amp;x)[N], int (&amp;y)[M]) [[expect: x &lt; y ? x + N &lt; y : x &gt; y ? x &gt; y + M : false]];
At least with ReSharper extension for Visual Studio, but it would still a trouble to use Doctests easily as other test frameworks with other IDEs such as Visual Studio without ReSharper, CLion or QTCreator. GTest may not be the best test framework, but at least, it is supported by many IDEs.
**&gt;&gt;** vs. **getline**
Some parts of the STL (well, if you consider the problem transitively, all of them) depend on the underlying platform. So you would have to define a reference platform first, that would provide well-defined primitive. What do you use for that: Posix? Win32? At this point you can as well declare that libc++ and MSVC STL are reference implementations...
This post is a bit ironic since constexpr having a big performance impact is another misconception.
COBOL programmers are dinosaurs, C++ programmers are not.
Hope so
I could... but you're better off just Googling it.
Could you give evidence that icc optimizes them better than std::vector? Show me a godbolt.
That doesn't at all mean the same thing as restrict.
&gt; Can you explain how that would work? https://github.com/QuantStack/xtensor is state of the art
Unfortunately I can't give you a compiler explorer link, but I can give you a reference where I have read that claim. https://stackoverflow.com/questions/1602451/c-valarray-vs-vector/1602787#1602787
`restrict` means "no alias". The above contract specifies that `x` and `y` can't alias. What's the difference?
[removed]
To expand on this: Fortran is heavily optimized towards linear algebra, and there's a lot of language features that permit fast code and give the compiler freedom for optimization. Slicing, masking, … are all built-in features to Fortran arrays and that's why `valarray` has these, too. The key advantage of Fortran arrays is however that in Fortran most arguments are alias-free, and as of such permit more efficient code generation. If you implement a matrix-vector multiplication, you have a function taking a matrix M and two vectors x, y - i.e. you'd want to calculate y = Mx. By implementing the vectors as two `std::vector&lt;…&gt;&amp;`, y and x could be the same object (which mathematically makes no sense) and thus writing the output could change the input. For reasons of correctness, a compiler might need to reload the input after every iteration, thus creating inefficient assembly. In Fortran, two dummy arguments may not alias each other, therefore forbidding such a situation. Similarly, `valarray` have a special provision that defines them to be alias-free: § 29.7.1, paragraph 2. Note that C++ has no language feature to define an object as alias-free and so, `valarray` requires some special compiler trickery for it to be fast.
They overlay the `&lt;valarray&gt;` header with their own implementation that uses Intel Performance Primitives.
"Plusplusy"... has an interesting ring to it. It's like saying is something is just ever so slightly one up than something else... it's plusplusy.
is this email exchange available somewhere?
Only a short anecdotal preview in one of Stepanov's lessons [here](https://www.youtube.com/watch?v=aIHAEYyoTUc&amp;list=PLHxtyCq_WDLXryyw91lahwdtpZsmo4BGD)
Thank you. I know about this one (Bjarne replies that enums were introduced in C in a rush) from when I followed the course. I did not remember about the reference to valarray. I was curious because I thought it was an email exchange happened at the time of the standardization process.
Volatile is necessary for some multithreaded scenarios. Obv it doesn't automatically make it thread safe or anything, but if you have, for example, a spin lock on a variable that another thread is modifying (which can be a useful method of synchronization in some specific scenarios), you can't really get around using volatile. Unless I'm misunderstanding what that point means?
Ik it's dirty, but I wish that particular example you posted was an exception to that rule. It's a bit tedious to manually cast malloc'd pointers when 90% of the time, that's exactly what you want to do.
Neither clang nor gcc has experimental support for contracts yet...
I would _slightly_ disagree with you on smart pointers, or at least the way you worded this. I don't think anyone is arguing that smart pointers _prevent_ you from understanding memory allocations, but they can certainly allow someone who doesn't completely understand their ownership model to write functional code. Essentially they allow for a problematic practice, but that isn't necessarily a bad thing. Especially in C++.
Yep, absolutely precise so long you: * Don't compile them with real-world compilers (I'm actually not sure if there was a point in time before SSE-math-by-default where VS was producing correct code with /fp:strict). * Don't use them on real-world CPUs (see the examples above). * Don't serialize/deserialize them with real-world libraries. I'm honestly shocked that we don't have something like a "ALL library functions are required to produce some well-defined canonical shortest form, and MUST round-trip to binary-identical float after using deserializing functions". Moreover, dumping an integer payload for NaNs is not even in the standard, so if you want two machines to produce a human-readable file where identical inputs always produce identical outputs, and identical outputs always mean the same inputs, you just have to discard the standard library ways to do that. * Don't rely on consistent results **even within one run of your code** if you have to interact with code that you don't control. If, let's say you are releasing a library which you compiled yourself for one specific platform (or wrote a program that uses someone else's library as a binary, the situation is symmetrical). Some of your customers (maybe even the majority) will run your library after switching the CPU flag that flushes denormals to 0. Some of them will attempt to switch the flag on and off before calling 3rd party libraries, and sometimes it will be inconsistent. So one time your "a*b" produces zero, half a second later it produces non-zero. * **Don't ever use them as keys**, especially in hash maps (unless you know exactly what you are doing). So many collections become broken in spectacular ways the moment one of your keys becomes a float. There are so many glorious DoS attacks you can do... Because NaN != NaN, even if two NaNs are binary identical. The following code nukes std::unordered_map in spectacular ways: int main() { float zero = 0; float key = 0 / zero; // good compilers may complain, but let's just pretend you got this NaN in less obvious way. std::unordered_map&lt;float, uint32_t&gt; m; for (int i = 0; i &lt; 100; ++i) ++m[key]; std::cout &lt;&lt; m.size() &lt;&lt; '\n'; // outputs 100 instead of 1 return 0; }
Restrict means that the pointer is the _only_ thing that can access the object that's being pointed to in this scope. This also applies to parameters, pointer arithmetic, struct components and what have you. All that precondition means is that you can't pass in the same pointer twice.
It's a "conditional feature" so a conforming C implementations is not required to support it.
cmake is the worst tool i ever used, such a waste of time and effort to me it is one of the reason why c++ is getting less and less popular over the years, tooling is ABSOLUTE SHIT
xtensor is awesome.
&gt;I don't think exceptions should necessarily be avoided for this reason, as long as we only use the for truly exceptional errors. The problem is that you might not know if an error is "exceptional" or not because it depends on the context. Is a failure in std::stoi exceptional? I guess it could be, but not if I just want to try and see if it succeeds and then try something else if fails. Exceptions would have been much more useful if they could be used for all types of errors.
What other method of determining performance, other than measurement, would you propose?
It's not the same.
Check it out here: https://en.cppreference.com/w/cpp/compiler_support (and please don't say it isn't exactly three per generation and therefore I'm wrong, I'm talking about the general trend, which is that the number of C++ compilers is rapidly dwindling)
No.
I see.
No, measuring is the right thing to do. I'm saying that measuring something where speculative execution plays a big role on *just a single machine* is wrong, because of wildly different mitigations applied. So to correctly measure this, you'd need to mess around with these mitigations, turning them on and off in different ways and test on at least one Intel and one AMD CPU.
The concept of `volatile` is separate from multithreading entirely and does not provide *any* guarantees with regards to multithreading. Let's clear up the misconceptions. `volatile` only means that any read and write to a glvalue is regarded as a *side effect*. Side effects alone are relevant for defining allowed optimizations within a *single thread* of execution, side effects can not be reordered with respect to the defined *sequencing* of each other which is guaranteed by the defined evaluation order of some operations. Note however that `volatile` only provides such guarantees about side effects of the current thread. Contrast this with `&lt;atomic&gt;` and `memory_order` which define side effects with respect to *different* threads of execution. Atomic operation order defines when writes and read of other threads can be depended on by a thread. That is, it is **wrong** to only use `volatile` for multi threaded locks because the writes and reads of one thread would have indeterminate sequencing in becoming visible to the other thread. For example given `volatile bool * flag`, two writes (`false` then `true`) by thread A to the supposed lock flag could become visible in the order (`true` then `false`) to thread B. Even though the sequencing for thread A is *guaranteed* to be as assumed that guarantee does not extend to reads by thread B. That is, the write of `true` does not not need to *happen before* the write of `false` from Bs standpoint. And it goes further: Without proper atomics reads from other variables need not be sequenced as expected. If the flag is used to protect a shared resource from data races (i.e. Mutex) you **must** use release and consume. Effectively, only a release operation on the flag guarantees that the evaluation that modifies the shared resource in thread A is dependency-ordered before the read and modification evaluations that happen in thread B after the consume operation of the same flag.
Armed with nothing more than `new` (which ultimately has to call some kind of OS function) you can build all the containers, things like variant, optional, {fmt}, strings, algorithms, regex, etc. That's quite a significant body of code, and I'd rather see a high quality implementation being used by everyone than everyone building their own broken version (as happened with regex, for example). Of course there are parts that are system-dependent. It wasn't my intention to suggest that there wouldn't be any, I just think a significant amount of code (and probably the more complex parts of it, at that) are not.
You can check for yourself. https://godbolt.org/z/dlf_sv
It seems to generate the exact same code. [https://godbolt.org/z/W\_0O86](https://godbolt.org/z/W_0O86)
Volatile doesn't guarantee atomicity of variable updates afaik so it's useless theoretically I think, but on xyz platforms itll work in practice up to sizes of N
What specific scenario are you envisioning? AFAIK `volatile` provides some of the necessary semantics for multithreading and synchronization, but does not have all the necessary pieces. It is not atomic, and it does not issue memory fences. The ordering of volatile read/writes are preserved *within* a thread, but not necessarily *between* threads. If you google around you can find lots of people trying to get the world to stop attempting to use volatile for multithreaded programs, but here's one of the nicer summaries I found (with links to other things) https://sites.google.com/site/kjellhedstrom2/stay-away-from-volatile-in-threaded-code Here also is a paper from Herb and Andrei demonstrating volatile as something that appears like it could/should work, but in practice is actually woefully insufficient. https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf From the paper, near the top of page 10, you can also find a quote supporting my statement that volatile implies nothing about the order of read/write as seen by two different threads. &gt; " As a result, though the Standard prevents compilers from reordering reads and writes to volatile data within a thread, it imposes no constraints at all on such reorderings across threads."
To be fair most languages are terribly slow in comparison, and even the fast ones can't autovectorise properly (was a good article on this a while back) That said there's quite a lot of UB that is only useful for incredibly niche cases and should be opt in - signed overflow, and variable initialization in particular
It's not about atomicity, it's about preventing the compiler from optimizing out accesses to the variable when another thread may modify it. If all you're looking for is variable != 0, atomicity doesn't matter.
Go on...
As someone who's ported a GCC (with libstdc++) to a niche platform, there's actually very little that's platform-dependent that isn't already addressed by having the C++ standard library depend on the C standard library (plus a little bit of POSIX for things like threading).
I'm very interested in your experience with it as an implementor -- what makes it a "failure" such that you wish it didn't exist?
Philosophical answer: Why would it be? I'm not trying to be flippant. Do really think about my question: Under what circumstances would it make sense for a more specialised, structured language construct to be less efficient than equivalent, more general code? If it were then the compiler could always trivially transform the more specialised into the more general construct.
I think compilers were doing it already, most of the time. At least now it's guaranteed.
Typying .view() seems redundant. Is there a way how to avoid it?
Digital Computer Electronics by Malvino and Brown takes you from "this is a transistor" to building a full microcontroller in under 100 pages. I heartily recommend it. I have fond memories of implementing the "SAP-1" architecture from that book in Logisim while I was an undergrad - it computed hailstone sequences with its 16 bytes of memory! (I am told the second edition is best; its the one I had.) (I can't remember how well Malvino&amp;Brown covers foundational topics on 'digital logic'. You may want to read up on DeMorgan's laws, K-maps, and SoP/PoS forms.) That is probably enough, as long as you go out of your way to read about all the ways modern computers are not like antideluvian microcontrollers. **Caches**, OoOE, micro-op fusion, super-scalar execution, pipelining, vectorization, etc. Did I mention *caches*? More exotic things like VLIW become useful when you least expect it. Caches. You could read a textbook on computer architecture. "Computer architecture: A quantitative approach" is pretty popular. There is also a Coursera class. NAND2Tetris is a *lot* but its good. If you're going half that deep you need to read "what every programmer should know about memory". I understand there are follow-up documents but I've not read them.
Added `moodycamel::ConcurrentQueue` to benchmarks.
It's not even guaranteed -- just possible; it's just a way of the complier warning you when it's not possible.
&gt; by having the C++ standard library depend on the C standard library By extension we'd also need a "C reference library".
I'm not sure what you are referring to here.
You'll certainly find many people around here taking that sort of position. That if you even have a raw pointer as a member of a class that owns it (and can therefore easily track it and clean it up) that that's a fundamental design flaw. And, ultimately, that probably matters more than the C++ spec and such, which newbies aren't going to be going out and reading. They'll get their ideas from discussion in places like this more likely.
How is this a philosophical question?
What about `[[expect: std::restrict(x, y)]]`?
"There is a conflict between OOP and data-oriented design" is another myth although.
Well, it's not just features, but complex rules that come along with them, which probably few people really understand. I.e. if something doesn't fail to fail, then it works. Which isn't the same as really understanding why it works. Or doing something that they see others do, without understanding the details behind it. I'm willing to bet that few of us here could really pass if they were grilled by a serious language lawyer type on the fine details of the language. Obviously, in the past, if you made some call to a library thingie and you had no source code for it, it was a black box to you, because you didn't know what it was doing in side. Now, with the massive templatization and use of failure as a tool, it can be tricky to figure out what you will end up actually calling and why. And there are significant implementation complexities added in order to support new stuff like move semantics, which weren't there before at all.
Good point, as I mentioned in my previous post, I'm extremely lazy: I use to prototype with std::exchange because I'm confident that this works just fine, but I then I didn't polish it before publishing. Your solution is definitely a better example (and also shorter). I'll change my post, adding a link to your post here. I'll also change the other functions accordingly. There's Just one thing where I need help: in the initializer, I would have wrote `value_(std::move(other.value_))`, but you wrote `value_(std::move(other).value_)`. Do you see any difference between the two? I would rather use the former, which I find clearer.
&gt; That is not what modern C++ is about. But that _is_ what modern C++ advocates keep harping about. "You should never own a raw pointer" (paraphrasing from memory) has been said many times in this sub for example.
Eh? GCC has had for some years.
 [https://gcc.gnu.org/projects/cxx-status.html](https://gcc.gnu.org/projects/cxx-status.html) [P0542R5](http://wg21.link/p0542r5) [P1289R1](http://wg21.link/p1289r1) [P1323R2](http://wg21.link/p1323r2)No ([PR 88102](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=88102)) |Support for contract based programming in C++|[P0542R5](http://wg21.link/p0542r5)|| |:-|:-|:-| ||||
Sorry, misread it as concepts! Oops
I think that one clear myth is that using such things ultimately makes all the problems go away, when really they just create a different set of problems that are almost as complicated to deal with, partly because they are spooky action at a distance, which in general terms is something widely argued against because it's not obvious what is actually going on. If you are just talking about scope based cleanup, then yeh. I don't think anyone would argue with that and it's been a thing for decades, nothing new. But smart pointers in general are similar to garbage collection. Garbage collection gets rid of one category of problems, but introduces a completely different set, which are often just as difficult to understand if not sometimes even harder because they usually aren't immediately terminal. Smart pointers have some of those same problems. As long as the language doesn't allow you to really express a lot of semantics about lifetime and ownership, things like smart pointers are more of a bandage than a cure. A bandage is better than nothing obviously, and I use them as well, But I've been bitten by them often enough. Rust is ultimately the only language that really allows that kind of lifetime/ownership semantic expression. I'm not arguing for Rust in general, since I think they've made some weird choices. But in that at least they have made a fundamental shift that provides a real cure for this whole family of problems, without the overhead of GC type solutions.
Ah. Yes, at one point, gcc even supported *real* Concepts. *^(sigh)*
To be fair, if you could pick up super-models with C++ a lot more people would ignore whatever issues it has.
No, type_traits and initializer_list cannot be implemented by pure library, and thus neither can containers etc.
Actually the .view() is not required in this example. I used it as an example to show the sub_match can also return a string_view instead of a string.
I mentioned in https://www.reddit.com/r/cpp/comments/bv0r1z/lockfree_c_queues/epm7unb?utm_source=share&amp;utm_medium=web2x that `PAUSE` instruction latency on Skylake increased from around 10 cycles to 140 cycles. This is what I benchmark on and `PAUSE` seems to be detrimental to throughput and latency in my benchmarks.
So the view that's returned points to a sub string of the input view?
I think the question they wanted to ask was whether they're smarter than the person who designed the compiler which is a uniform "no"
qt creator. kdevelop. netbeans and eclipse have c++ plugins. you can go stupid with clion if you really want to, but i don't see the point.
It is not, but yours is.
Clion, if build system is cmake-based
I use VS Code on Windows and recently starting on Linux. It is pretty much identical on both and works well. It struggles a bit sometimes with my large code base, but overall it works quite well. It has some features that are about 50% really nice and 50% really annoying.
I mean result[0] is essentially a string_view. It holds two iterators it was just specified before the string_view was a thing that's why it's instance of some other class. But for the user this is irrelevant he doesn't know the history of regex in std lib and he wants to use result[0] directly. No view() and no str() that can stay there only because of backward compatibility. Would it be possible to provide implicit conversion to string_view? Simple things should stay simple
&gt; - Intel does not ship an implementation of the C++ standard library, except for PSTL &gt; - EDG does not ship an implementation of the C++ standard library &gt; - IBM does not ship an implementation of C++ standard library for Linux (uses GNU libstdc++) &gt; - PGI does not ship an implementation of C++ standard library &gt; - NVCC does not ship an implementation of C++ standard library So do you think they don't "focus on the language stuff"? And that's the reason they can't advance?
Would you have any example of smart pointers issues akin to garbage collectors? By scope-based cleanup, would you also consider unique_ptr? Which is cleaning one and only allocation based on scope, is a smart pointer and the recommended one in 99% of the cases.
There is a third-party (non-upstream) fork of GCC with Contracts support, but I haven't tried it. See https://gitlab.com/lock3/gcc-new/wikis/contract-assertions
Yes, and this is also the case when matching on `std::string`. Consider the C++11 equivalent of the posted code: void foo(std::string const&amp; input) { std::regex re{"foo"}; std::smatch m; if(std::regex_match(input, m, re)) { std::cout &lt;&lt; m[0].str() &lt;&lt; '\n'; } } `m` has type `std::smatch`, which is [`std::match_results&lt;std::string::const_iterator&gt;`](https://en.cppreference.com/w/cpp/regex/match_results). `m[0]` has type `std::ssub_match`, which is [`std::sub_match&lt;std::string::const_iterator&gt;`](https://en.cppreference.com/w/cpp/regex/sub_match). It has an iterator to the begin and end iterators of the input string which matched that group. (It also has a `bool` field marking whether the match was successful or not.) The `m[0].str()` call constructs a string from this iterator pair if the match was successful, or a default-constructed string if not. It's already possible to create a `string_view` that points to a sub-string of the input view before this proposal - but you have to write `std::string_view{m[0].begin(), m[0].end()}`. With this proposal you can write `m[0].view()` instead (which neatly matches `m[0].str()`) - or in some cases you can just write `m[0]`, as `std::sub_match` is made implicitly convertible to `std::string_view`.
This proposal *does* provide an implicit conversion to `string_view` (alongside the existing implicit conversion to `string`) - as u/__Mark___ says above it's not required in this example. But in cases where implicit conversion isn't sufficient, it's more ergonomic to be able to say `m[0].view()` than `std::string_view{m[0]}`. (In fact, to be fully general, it'd be something like `std::basic_string_view&lt;decltype(m)::value_type::value_type&gt;{m[0]}`.)
Yeah but that was only an example. You need a ton of other primitives. Other examples: filesystem access and multithreaded things. And then it will merely be a 4th major implementation (counting libstdc++, libc++ and msvc as the 3 major ones) and it would be a huge pain to migrate because of backward compat, both binary and source level (dependencies on implementation details and extensions) And I'm not even talking about the whole libC, which also has several variant on some family of platforms. So maybe there are some *specific* parts that could be shared between implementations (templated algorithms + regex + numerics library maybe - anything else?) -- if that's even possible because of backward compat considerations -- but for the bulk of it I don't think this would make much sense.
Use an atomic for that, not a volatile. Volatile is for changes that happen from outside the C++ bubble. Threads are inside the C++ bubble; you shouldn't use volatile for communication inside the bubble. It probably works because of the way compilers treat volatile, but it is not guaranteed to work. Also, no one knows what the rules to volatile actually are (ie not even the committee).
An obvious type of scenario where it might happen is, say, an object pool which lets you maintain a pool of pre-allocated objects and rent them out to other code which has to give them back. A very obvious way to deal with that is to return a smart pointer that will release the object back to the pool when it is destroyed. I have exactly this kind of setup in my system. And it's obviously helpful. But the compiler isn't remotely going to help you be sure that all of those smart pointer objects holding pool objects are going to be released correctly before the pool is destroyed. Of course that's similar to not using the smart pointer, but in that sense it's not doing anything to prevent the same problem. So then the obvious answer to that might be, well, just put the pool itself in a smart pointer. Then give the object renter smart pointers a smart pointer to the pool. That insures that the pool cannot go away until all of the smart pointers that have rented objects from it go away. But then you get into the same sort of situation that GC does. If there's a single object renting smart pointer out there that gets store away, it's going to hold that entire pool in memory, potentially forever. And that might be a lot of memory. And of course if the object that creates such pool gets created again the process happens again, it could easily happen again and now you are eating up memory. But in a GC sort of way it never actually causes a failure, which would really be better in some ways since you'd be more likely to catch it during development. With unique type pointers, if someone gives you one (maybe a return from a method to pass ownership to you), and you store it away, it would be fairly trivially easy to accidentally assign it to something in some uncommonly traveled part of the code. And now you will have a null pointer error at some later point. And that's sort of the down side of smart pointers. They blatantly do things that are well known to be bad. In this case, they change the right side of an assignment operator, which if you did in any other scenario would probably get you spanked badly in code review. And for good reason because no one scanning code sees an assignment operator and immediately thinks that the thing being assigned is going to change. Again, not that they are bad, they do help. But they have their own problems and they are also easy to mess up in their own ways, because all these types of devices are likely to be either doing magical things behind your back, or creating connections between things in bits of code that are far removed from each other and in which it is easy to get uncoordinated in control over the lifetimes of those things.
If u build your code with cmake u can use pretty much everything. Even Visual Studios support of cmake improved. I like to use VS code and build the code with the terminal or withe cmake - tools Plugin of vs code. Qt is also a good choice, quite fast und lot of stuff. But I don't like the Git integration of Qt creator
Alright, so they basically share a subset (albeit big) of issues that manual memory management has: it brings pointer semantic to your code, I will certainly not disagree on that. Note that I avoid speaking of raw pointers as you can have perfectly safe *non-owning* raw pointers, which also a common myth: smart pointers implies no raw pointers. From what I understand from you and your sibling post, the only drawback that smart pointers bring over manual deallocation is a false sense of security that can lead you to bad design. I can appreciate that.
"Don't use owning raw pointer" isn't the same thing as "don't use raw pointers in any contexts".
Many things he says make sense but I don't agree with his absolute distinction of byte - char - char8_t. I don't know anyone who would use byte because as soon as u do you have to typecast bit literals everywhere. Then he says char would be for ascii chars. Do you know how to uppercase ascii letters without branching? Just or it with 0x40. Disallowed? And what about char8_t? Well decoding a code point requires a fair bit of bit manipulation as well. So to me such absolute distinction would just make the code uglier.
Ok, this is news to me. I always thought to be called a C++ compiler it would implement the C++ standard, which includes the standard library. Are there really so many compilers out there that give you... what? nothing at all? or do they piggyback on the standard library of another compiler?
A pointer is sized to represent your address space, so on a 64 bit machine you have 8-byte pointers. When I say someone "doesn't know what size their pointers are," I mean they thought most computers were still 32 bit in 2019, when in fact it's been difficult to buy a 32-bit consumer CPU for nearly fifteen years now. This was surprising to me since you usually can't even install a printer driver without knowing what bitness you're using, much less make it through an introductory programming class in a C-family language. Day-to-day such a thing might not be essential knowledge since your compiler handles your struct layout, stack frames, etc for you. Might run into trouble if you try to `mmap` a large file, do pointer arithmetic, add large numbers, etc. On a practical level, pointer size matters for efficiency of memory space and bandwidth. E.g. if you have a linked list (or a tree, chained hash map, etc) that stores integers, potentially a third to half of that memory is consumed by pointers by default. That's a lot of metadata overhead. Replacing a pointer-heavy data structure with something more continuous, or replacing pointers with smaller array indicies, can result in dramatic space savings.
I took it as an attempt to avoid the sophomoric non-answer of "just don't use goto." Imagine the responses if everything before the colon in that title was left out. Long-winded lectures about style at best.
&gt; I like it that way in terms of readability. How is less space between characters readable. I don't get it. &gt; I also want to minimize the amount of code needed to download and my software. Are you kidding me? You're doing it *once*. This is basically premature optimization.
Amusingly, I implemented an LWG issue resolution for valarray on Friday before seeing this thread.
Nice work! I'd have use for this in my day job if it existed. One issue with this proposal is that the `T` in `sub_match&lt;T&gt;` only has to be a bidirectional iterator, not necessarily a contiguous iterator. The proposal as written gives a `string_view` to invalid memory when the iterator isn't contiguous: std::list&lt;char&gt; input; for (char c : "hello world") { input.push_back(c); } std::match_result&lt;typename decltype(input)::const_iterator&gt; m; if (std::regex_match(input.begin(), input.end(), m, re)) { std::cout &lt;&lt; m[0].view() &lt;&lt; '\n'; // segfault! } This is a tricky problem to solve as [it's not possible to deduce whether a given iterator type is contiguous or not](https://stackoverflow.com/questions/47642228/how-to-deduce-contiguous-memory-from-iterator). A contiguous iterator is convertible to a pointer, so one possible design would be to specialize only `std::sub_match&lt;T*&gt;` to add the string view conversions. Then for the regex algorithms, we'd want to be able to call `regex_match(std::string_view, std::svmatch&amp;, ...)` and relatives as well as `regex_match(std::string const&amp;, std::svmatch&amp;, ...)` and relatives. (This second overload doesn't exist in the proposal.) To expand this to support more contiguously iterable types, the proposal could instead specify a function template `regex_match(T const&amp;, std::svmatch&amp;, ...)` (and relatives) for any T which supports [`std::data`](https://en.cppreference.com/w/cpp/iterator/data) and [`std::size`](https://en.cppreference.com/w/cpp/iterator/size). This would then allow, as your proposal does, getting a `string_view` when searching a `vector&lt;char&gt;`. I'm not sure if this is a good idea or not, as I believe there's nothing in the standard library that follows this design so far. (
Can VS code integrate with a C++ compiler and debugger? That would be ideal if I could use the exact same tool for both.
Do you know any language besides C and C++ that can run on an 8bit AVR and can be used for highly parallelized workloads with massive data and dozens of threads?
I'm not a good person to ask about that. I use it purely as an editor slash syntax highlighter. It does integrate with GIT. But, if you have more than one GIT repo, it can't understand that. So you could only use it to work with one at a time by starting it up in each repo's top directory. I think that this is a fundamental lacking of GIT since many people will have multi-repository setups, and there's just not good coordination of those with GIT. I absolutely want to see my code all at once, so I have to give up GIT integration. So I don't get shown in VSC what files have changed.
/r/cpp_questions already got used to OP :)
Thanks for the feedback. I see the problem. Not sure how likely it is somebody would use a regex on a list. But if somebody does, it should not result in a segfault, instead it should fail to compile. I haven't looked closely at ranges yet, but it offers a ContiguousIterator concept. So I'll have to see whether I can use that to solve the issue.
[Building a Dynamic Library from the Command Line](https://www.oreilly.com/library/view/c-cookbook/0596007612/ch01s05.html) (from the "C++ Cookbook", O'Reilly)
&gt; Looks similar to what I built [https://github.com/rigtorp/MPMCQueue](https://github.com/rigtorp/MPMCQueue) You may like to benchmark it. Feel free to submit a merge request that adds your queue to the benchmarks.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bvowob/linkcreate_dynamic_library/epr9r7m/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bvnjym/tview_for_cpp/epr9sc8/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bvmnxn/how_does_qt_feature_work_in_eclipse_cdt/epr9tkl/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Nobody uses it, for reasons explained by other comments here. However, it doesn't attract bug reports, so I mostly don't mind its existence (unlike, say, iostreams).
The problem with both is the same: The assumption that you somehow know in _every single occurrence_ that a raw pointer would not be the right solution - even though you have no idea about the code or what it does!
The joke is that I'm a Standard Library maintainer who edits `&lt;valarray&gt;` every few years, so I know what it is (although I haven't used it myself).
What language doesn't have undefined behavior? Even Haskell has undefined behavior.
The compiler backend deals with a control flow graph, which will be the same whichever way you express it. A poorly written program will usually collect other errors which may lead to performance issues.
It makes you wonder doesn't it if there ought to be a part of the C++ committee dedicated to ensuring complete orthogonality in forward developments, because as it is there always seem to be obvious bits missing, such as regexp over string\_view. Just yesterday I found myself frustrated by the fact that std::filesystem::path does not have a length() or size() method; you have to cast to std::string and get the size of that.
&gt; I'm honestly shocked that we don't have something like a "ALL library functions are required to produce some well-defined canonical shortest form, and MUST round-trip to binary-identical float after using deserializing functions". C++17 &lt;charconv&gt; provides this (shortest decimal round-trip), and that part is now shipping in VS, with the exception that NaN payloads don't round-trip. The round-trip is guaranteed for a given implementation, and in practice is guaranteed across implementations as long as they are using the same representation (e.g. IEEE 32-bit float and 64-bit double; long double varies across implementations). It is also "easy" to round-trip with printf (or iostreams if you like manipulator pain), as long as you know how many digits of precision are needed in the worst case for round-tripping (numeric_limits can tell you if you don't know). For IEEE floats and doubles it's `%.8e` and `%.16e` because you need 9 and 17 digits in the worst case, and the precision is the number of digits after the decimal point (with one before). Hexfloats are a faster way to round-trip, with less human-readability, unless the human brains have been suitably modified.
Yes it can and the documentation is good: https://code.visualstudio.com/docs/editor/debugging I would recommend going through there for most questions, it is really quite complete. FYI you can even go fancy and use Windows Subsystem for Linux, but that's more for playing around IMO
Having a class store two owning raw pointers is already a risk; there's a reason they should be avoided.
You already don't need a check for this function due strict aliasing, IRC.
My understanding may be faulty, but the only reasons mentioned are 1) compilers besides icc don't aren't optimized for it 2) c++ has no language to guarantee no-aliasing Aren't both of these things fixable? Even if you just say "aliasing valarray is UB?" I suspect that the real problem is the perf increase you'd get isn't perceived to be worth the effort. CPU vectorisation us getting better, and GPU vectorisation is still batch oriented -- and you're probably already using eigen any way...
What are you even trying to accomplish with the inline keyword here. It makes zero sense on a static variable which has a singly defined point in exactly one translation unit already.
What if `N` and `M` are equal? Do strict aliasing rules still make those distinct?
A definition of `size()` would be the number of components (e.g. directories) in the path, but you seem to be wanting the number of characters in the string format of the path (and specifically, which format? A path may have generic or native format, and currently there's no guarantee that they have the same length.)
In a similar vein, what about `string_view` overloads for fstream?
&gt;A spin lock is still a lock. You may like to learn the difference between blocking, lock-free and wait-free algorithms.
Likely not, since it'll be the same type. Your example is also always invokes unspecified behavior due to pointer comparison rules.
You don't want to optimize out a dead write into a memory mapped register, for example. Volatile is your tool for that.
That's correct, we're currently using Boost's implementation of Special Math.
&gt; you just have to discard the standard library ways to do that. What about to/from_chars?
There's no particular risk for a class to allocate private members for their internal use and free them when they are destructed. It's not much different from having non-allocated private members, other than just cleaning them up during their own dtor. That's been done since the beginning of OOP time and it's just not that big a deal. And of course it also means you can catch and log errors that occur in the destruction of those objects, which you can't if you depend on just letting them go out of scope and be cleaned up by a smart pointer. That's saved my bacon more than once. I don't know specifically what you mean by an 'owning pointer' though. I'm talking about OWNED pointers. The class that allocates them owns them, no one ever ever sees them outside of that class, and cannot therefore every create second copy of the pointer, and the owning class cleans them up when it goes away.
[Keep up.](https://stackoverflow.com/questions/38043442/how-do-inline-variables-work)
Are you sure you're compiling with the right language version set?
I personally wouldnt rely on any suspicious looking error from intellisense. Get the actual compiler to weigh in before you further analyze this.
90 (or 99, depends on your field)% of time you don't even want to use `malloc`.
My perspective as a library implementer is very different: * Compiler devs and library devs are usually different people with different skills. Some compiler features are integrated with library features (it seems like a slowly increasing number), but in general, compiler development isn't blocked by library development. * The thing preventing new compilers from entering the field is that implementing a C++ compiler is very hard, and the existing compilers are very good. (Much like web browser engines.) Clang was a novel development, and now that it's established, there's even less reason for another compiler to appear - unless one of the existing ones stagnates. Notably, Clang can be ABI-compatible with GCC and MSVC, so it can compile libstdc++ and MSVC's STL - it's virtually an existence proof that compiler development is separate from library development. * I think that having three solid compilers paired with STL implementations, with a few specialty implementations (e.g. the EDG front-end, the ICC compiler, etc.) is a thriving ecosystem - better than the early days when there were more compilers but they were all highly incomplete and flaky. * For standardization, anyone can implement a feature in an open-source library. Often it can be completely standalone (many library features are pure additions, not modifying existing code).
It'd really be if not for uniform_init/init_list fiasco...
I was aware of unspecified behaviour when I was writing that. Keep in mind that "unspecified" doesn't mean "undefined". My code doesn't care if `x` is stored earlier in memory than `y` or the other way around. The only case not explicitly covered is `x == y` which definitely means they alias. On the other hand... https://godbolt.org/z/lUyM3T GCC always returns `false`, while `clang` does what I expected.
Yes, you are right. But given that the class provides begin() and end(), I find it hard to understand why size() as you have defined it isn't there. A method (with a different name, obviously) which tells the size of a string representation (to prepare for serialization, for example), just seems like something people will want and will end up rolling their own, so ought to be there. Anyway, the comment was not meant to be specific to filesystem::path; I bet lots of people can recount times when they've looked for an expected feature of the library and found it missing.
If you use CMake and Windows, try Visual Studio and make a Linux build by connecting to a WSL, a Linux VM or a remote Linux machine. Just configure remote connections. You can even debug a Linux binary from VS on Windows. I used that for months and works nice. If your PC is Linux, then CLion or QtCreator would be my choices.
Didn't know that the standard finally did the right thing in &lt;charconv&gt;, thanks for the info! That's absolutely amazing if it actually works in a consistent way between the compilers. Too bad it doesn't preserve NaNs, but I guess it's easy to make a workaround now. I remember there were multiple differences with printf("%.8e", x) between the library implementations, so it was always the wrong thing to use if the output had to be the same between VS and the rest of the world (plus VS didn't round trip even with its own output, I think it was finally fixed recently). I'm looking forward to never touch it again and use to_chars instead.
Welp, I feel dumb. Haha. That was it. I assumed it would default to 17 in VS 2019 default environment. I was wrong and had to add the appropriate Cmake option target\_compile\_features(tuvok INTERFACE cxx\_std\_17)
&gt; There's no particular risk for a class to allocate private members for their internal use and free them when they are destructed Modern C++ says to use unique_ptr for this case. Raw pointers are fine if they are non owning.
That was the compiler haha. I think it was parsed from compiler output. The compiler was not defaulting to 17. Thanks everyone!!!
My code as shown here is in a state of flux due to my confusion. But essentially, I am building a header-only library. The Microsoft errors are not exactly friendly or sensible in my experience. I tried to use Clang Power Tools to figure it out and get better hints, but after upgrading to 2019, that extension fails to show up in the interface of my IDE anymore anywhere :(.
EDIT: I'm dumb and forgot to set cxx\_std\_17 or similar in CMAKE after switching from a native Visual Studio project in VS 2017. I assumed the default was 17 in 2019 but apparently not. I should have set the option either way. Thanks everyone!
I can share my experience with charconv. Regarding licensing, I am not a lawyer, so I'm comfortable saying only a couple of obvious things: we've started shipping Boost-licensed source code in MSVC's STL, and the GPL family of licenses is not usable for our purposes. Integrating Ulf Adams' amazing Ryu codebase into our STL has involved months of work. First, I reviewed the upstream codebase, contributing minor correctness improvements and more significant performance improvements. There were some changes to improve behavior for MSVC and Clang targeting Windows. I also improved the benchmark to guide the performance tuning. At the same time, I worked on changes to adapt Ryu to the STL's requirements - I wanted the code to be header-only (requiring uglification), to use C++ casts, and to use charconv's interface (which is bounds-checked and non-null-terminated). Since I don't want to permanently diverge from upstream, I've layered my STL-specific changes as a series of git commits that I rebase. Ulf has made my life a lot easier by accepting pull requests for things that improve C++ compatibility, even when they aren't strictly needed for Ryu's C codebase. (e.g. I'm smashing everything into a single header, so I can't have duplicate function names with identical signatures but different behavior). Along the way, I've also written comprehensive tests (contributing most of that upstream). For other libraries like fmt, it's hard to say what approach we'll take, especially if it requires modifying existing code (e.g. if fmt needs to modify charconv's behavior). Separate compilation provides more isolation, but has its own downsides (e.g. if I had chosen to separately compile Ryu for to_chars(), then users couldn't use Clang/LLVM to get superior-for-now optimizations).
Some people think that notusingspacesmakestheirprogramsrunfaster.
Nice work, I look forward to your proposal coming to WG21 for formal review.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bvp9q9/inline_keyword_confusing_as_hell_i_thought_i/eprk0sn/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; There's no particular risk for a class to allocate private members `: m_ptr1(new X), m_ptr2(new Y)` is a memory leak that many programmers miss.
See my reply to /u/STL. I didn't know that &lt;charconv&gt; does almost the right thing now, and it's amazing if it's actually consistent between the compilers. Still requires some manual tinkering to preserve NaNs though. Looking forward to std::to_chars_for_real_this_time() in C++38.
Yes, VS's CRT was overhauled in 2015 for correctness. (Previously its printf() would "get tired" and just print 0s, even if the actual digits were nonzero.) After the overhaul, its printf() had one more rounding bug, where it didn't perform ties-to-even (e.g. affecting .125 rounding to two digits; I believe this would also affect `%.8e` and `%.16e` although I haven't checked whether it damages round-trip). That was recently fixed, although shipping it will take a while. Our to_chars() implementation, powered by Ryu, performs rounding correctly (as I have carefully verified). Our from_chars() is derived from the UCRT's overhauled strtod(), with additional auditing and correctness fixes; I believe it is very solid, with the exception of extremely pathological cases (I believe that it doesn't handle something like a million digits followed by e-1000000 to counterbalance). In VS 2019 16.1, all of charconv is available except for decimal precision, so you can use decimal shortest. In VS 2019 16.2, fixed/scientific precision will be available, with further speed improvements for fixed shortest. Only general precision remains to be implemented now.
I implemented GCC’s `valarray` back in 1997 out of my and my colleagues’ needs. It performed quite well (given EGCS optimization wonders at the time) and it still does. Last I checked, it is still in use in the areas it was designed for (heavy number crunching scientific computing). One of the tragedies of `valarray` is uninformed categorical statements on the internet such as “nobody uses valarray”. We need less of those. I know Bjarne is well aware of valarray intricacies and its uses — I was there when he was developing his book on Principles and Practice of Programming with C++. For a while, I was also the LWG “maintainer person” of valarray, I just didn’t find new functionalities necessary to add. (See also my LWG fixes back in early 2000s).
Citation needed.
I very much would consider the ability to log the context of any cleanup failure in the field well worth that risk. I'm sure I have some of those, but they can be weeded out via some search and replace. OTOH, cleanup failures in the field, in some unknown context, can't be so easily dealt with.
I disagree with Modern C++. You can tell him that for me if you meet him. There's nothing wrong with using yet another template if you want, but it's not remotely required, and you lose the important capability of catching the context of a cleanup failure in such wrapped objects, which is very important in the field.
Pretty sure you can't implement std::vector in pure c++.
I lament the paucity of compiler-backed optimizations for valarray. Part of it may be that expression templates (which were invented around the same time) help get pretty good performance. Part of it may be its specialized nature compared to the general C++ programmers population — to be contrasted with Fortran.
I'm so happy I tuned in to this thread, this is one of the features I was waiting for for many years. Thanks for your hard work.
`valarray` is expressly specified to permit expression templates implementation. And that is the technology I used in the GCC’s implementation. I rewrote that thing a few times, ending with uses of template template-parameters to reduce code duplication — which Scott McPeak blamed as the only roadblock to his parsing the entire libstdc++ with his new parser back in 2004. I wish there were more compiler support. There are poorer implementations around that may lead their authors or maintainers to believe nobody uses them. :-(
First of all, thanks for replying. &amp;nbsp; &gt; One of the tragedies of valarray is uninformed categorical statements on the internet such as “nobody uses valarray”. We need less of those. I was tempted to say "nobody uses valarray:, but refrained from that, because I was thinking I might find a ton of people using `valarray` in this thread. &gt; I implemented GCC’s valarray back in 1997 out of my and my colleagues’ needs. It performed quite well (given EGCS optimization wonders at the time) and it still does. Last I checked, it is still in use in the areas it was designed for (heavy number crunching scientific computing). That might be true. The SO question about `valarray`, if I remember correctly, said that GCC just got better at optimizing `std::vector` that it significantly closed the gap. I personally haven't measured the performance of `valarray` and can only say what I've read before.
&gt; That there are zero cost abstractions. There are. `a[i]` is a zero cost abstraction over `*(a + i)`. No extra cost involved anywhere, unless you want to be really nitpicky (as I am replying to you ;P).
That's not a good guarantee for the use-case above.
You're welcome, and when you try out charconv, let me know what you think. IIRC, my perf measurements indicate that to_chars() shortest is 10x to 36x faster (yes, times, not percent) than sprintf `%.8e` or `%.16e` depending on the type and platform, to_chars() precision is also an order of magnitude faster, and from_chars() is 40% faster. Compared to the previous best known algorithm Grisu3, Ryu is approximately 3x faster.
Well, it's not a guarantee at all. You'd have to check the assembly every time you compiled the `std::function`.
Not sure if it really saves you anything, but you don't need to access b unless you get a hit. So, does sort\_by\_key() assume the target members have implemented some specific trait?
Thank you for the answer :)
There’s nothing wrong with starting with a high-level language to learn how to write code, though. Using a language like Python or JavaScript to learn the essentials of writing a program is immensely easier than using assembly, and won’t preclude you from then learning lower-level languages and assembly. Top-tier computer science colleges take that approach (Berkeley starts with Python and Stanford starts with JavaScript) so your “find another college” advice is pretty bad.
If you have a reference implementation, all the bugs become de facto standard. Can't be fixed because people expect it to work that way, code relies on it, etc. With multiple implementations, if there is divergence of behaviour we can figure out if one of them has a bug, or if something was ambiguously specified. Note that we are starting to see shared test suites - which can also lead to de facto standard behaviour. Imagine if one of the tests interpreted the standard wrong - doesn't matter, all implementations passed the test, the behaviour will become relied upon, etc...
Yes I am aware and use inline variables. This is a static variable
std::optional _is_ moveable. And "optionals don’t move their content" is wrong. std::optional move calls move on T. It is just that your T (a handle) doesn't move any differently than copy. Sounds more like you want something similar to a unique_ptr with a custom deleter. Basically, "move" - "You keep using that word; I do not think it means what you think it means." (We may not have a good word in the std yet for this concept - unique isn't always the right word - we currently have a discussion about this with the new moveable function thingy (std::mofun or whatever it is called)
\&gt; They are both supposed to generate the exact same binary Is this true?
I noticed this is also the case with vcpkg!
From the [documentation](https://docs.microsoft.com/en-us/cpp/build/how-to-enable-a-64-bit-visual-cpp-toolset-on-the-command-line?view=vs-2019): &gt; The 32-bit and 64-bit tools generate identical code
Interesting. That means pointers are 64-bit in the 32-bit version
I believe it means just that the 32- and 64-bit _executables_ of compiler will generate identical code.
I don't write variables like that. And a program can be run/tested faster if it builds faster. I just checked Boost 1.70 and there are over 22,000 files with trailing white space. I try not to do that with my code.
We've disproven this myth before, the context isn't lost: https://www.reddit.com/r/cpp/comments/b247ww/z/eirpf4q
Ah! I completely glazed over that in the OP! Very strange indeed to have a 32-bit compiler. I suppose for legacy reason?
This lie is the very reason we have a dearth of qualified programmers even though there are thousands of graduates. Programming in assembly is simple. Sure you can write bad code in python easily, but the purpose of education shouldn't be to teach students to code badly. Just like learning any skill you start with the rudiments and then build on that. Writing good Python is *harder* than writing good assembly. Much harder, in fact. The mechanics of launching a python command prompt, importing a module and calling a function is easier than than mechanics of assembling some code writing it to a flash and resetting a processor, but don't confuse the ease of use of the tool (the interpreter or the assembler) with the ease of programming in the language that those tools implement. If someone has a hard time with assembly, it isn't the assembly language they are finding difficult, it is that they don't understand the instruction set, and knowing an instruction set is the first step in becoming a programmer. Python hides the very thing that you need to learn (how to prgram a machine)from you whereas assembly doesn't. That abstraction of what happens under the covers is a useful tool in the hands of a skilled programmer but us nothing but an entirely unnecessary and unhelpful obfuscation to someone trying to become a skilled programmer.
Might be because it's fairly new.
IIRC, someone from MS said the 32 bit compiler was actually faster than the 64 bit compiler.
Ok, guy. The point of starting with a high-level language is to focus on abstractions and design patterns rather than getting stuck in the nitty-gritty of dealing with every student individually to get their assembly code to work on their machine. (I’ve been in a class that used assembly – even with a simple instruction set, RISC, most of the issues were with getting the emulator to work rather than the code.) Go ahead and try to teach people with no programming experience recursion, data structures, and algorithms using only ~25 global variables and ~30 instructions and you’ll realize why it’s much simpler and more straightforward to write pseudocode or python. Nobody is taking one intro class and going straight into industry, and if they are, that’s their own fault, not the fault of the school. And *even if they were*, they would be much better-prepared for an entry-level programming job (i.e. web-dev, data science, etc.) if they knew Python or JavaScript than if they knew x86. Not everyone has to be a kernel developer or work with micro-electronics.
For very lax definitons of 'fairly'.
Yes, it can. I use it as my primary c++ ide now.
I am a Windows developer using Vim emulators in Visual Studio. It's not great, and I'm passively looking for a way out of Visual Studio and into Vim (gvim atm). While we're on topic, if anyone else has any tips/experiences/resources to share: I'm very interested to learn more!
Nothing was disproven. You were talking about one thing and I was talking about another. A stack dump to the console is worthless in the field for the most part. I'm talking about the ability to log this type of information to a central log server where it can get diagnosed after the fact for all clients at a site.
If something can be done at compile time, it's not actually part of your business logic, and you could do it at compile time already via macros, code generation, or manually, just less conveniently.
volatile *is* useful for multithreading, it's just not sufficient.
K, but in practice... you *could* do that, but many/most won't, whereas constexpr gets used a lot.
https://libcxx.llvm.org/atomic_design_c.html `&lt;atomic&gt;` is implemented using `volatile`. Therefore it is useful for multithreading.
The only difference I noticed is that for some reason the 64-bit compiler generates a significantly larger PCH file (125 vs 75 MB in my case).
`constexpr` mostly just expands the power of templates though. I really doubt any performance gains from it are actually significant.
&gt; I really doubt any performance gains from it are actually significant. :|
It's the same information a runtime logger has access to.
OK, maybe on Linux, but I need something portable.
Yeah, so it's more or less useless when you avoid allocating at all cost (no-heap). Or rather, it's counterproductive, compared to, say, even custom `function_sbo&lt;8, type&gt;` or something.
The 32 bit linker runs out of memory in many cases, especially with unity builds.
In my experience, this is true. The 32 bit toolchain has much better build throughput... at least until it runs out of virtual address space and crashes, forcing you into the 64 bit toolchain.
This is my guess. For a lot of workloads, the extra registers in x64 don’t make up for the fact that pointers are 2x as big and mostly zeros. There’s some noises about specifying a “x64 but with 32bit pointers” abi.
Abstraction and design patterns is more computer science, and less software engineering (it is a spectrum of course). The massive shortage we have is in cyber security software engineers not computer scientists (there is a shortage there as well, it is just not as severe). I never mentioned taking a single class. There are tons of colleges where the vast majority of coursework is in high level languages with only a bare minimum of the fundamentals. Designing the program to produce the wrong type of candidates *is* the schools fault. There are good schools out there producing good candidates, just precious few of them, and for the most part they are the premier universities with a long history in engineering. There is no reason that the people who don't get into the premier schools (i.e. they don't have an Aunt Becky to buy their way in) can't become first class software engineers, if only the schools they are able to attend were doing a better job.
When people go to university to study programming, they generally study computer science, which is why starting with higher level languages generally makes sense. If someone wanted to self study to become a cyber security software engineer, sure, start with the lowest level and build your way up – that’s how you understand where the exploits emerge. But that’s not the majority of programmers, and changing the general curriculum to teach things this way would probably turn more people away from programming. Machine structures and operating systems classes are generally dreaded (in my experience) by otherwise fine programmers because it’s simply not what interests them. So yes, this is a good learning plan for someone who plans to work in cybersecurity – but it is a rare candidate indeed who knows nothing about programming and also is certain they want to pursue this field.
That's correct, because a PCH is a memory dump of the compiler's data structures, and the x64-hosted compiler consumes more memory. (When I am elected World Controller, I will ban 32-bit hosted tools, followed by puppies.)
If the program and data fits in cache, it will run much faster. 32 bit programs fit better into cache than 64 bit. [Here](https://www.prowesscorp.com/computer-latency-at-a-human-scale/) are some cache timings to compare to.
Who even needs 32-bit code in 2019 outside of embedded systems?
clion by a mile.
Yeah, I have noticed this issue with the linker but the good thing about the 32 bit linker is that it falls back to the 64 bit linker but it's not the case for the compiler, when it runs out of space it just crashes the whole thing.
TIL 16 years ago is new
Or people running 32-bit version of Windows
Coding for people who use Windows XP
And `std::o/ifstream` don't accept string_views. But some say that's because of OS APIs, even though Win32 will convert to Unicode anyway.
Hmm that's provided by the language and is just syntactic sugar, a bit of a stretch 😅
But the compiler running out of space should be much more rare. The linker fallback just halves your throughput. You can hand-edit your msbuild file to force the 64 bit toolset. But the team hasn’t yet prioritized adding UI to choose the toolset host.
C is not a subset of C++, as you said. However, they do share a common subset. If you stay within this common subset, both languages will produce the same assembly (there's probably exceptions, but none I'm aware of) and have the same performance. This common subset consists of almost all of C, which is why that myth exists in the first place. There are some differences (a section of the C++ standard enumerates them), but very few have a significant impact on performance. `restrict` is the most notable exception, as others have pointed out. VLAs might be another (though that feature is a bit controversial). But these are the exception, not the rule.
Unity builds should actually reduce the load on the linker because of less data duplication. 🤔
Inline and static keywords are horribly overloaded in C++ from the philosophy that we should prefer to minimize new keywords at the expense of making C++ too hard for most humans to grok, haha. In modern use, "inline." as far as I think of it, mostly means, "Hey, I'm going to define this thing multiple times identically, in multiple translation units. Don't get mad at me for breaking the O.D.R." It shouldn't be necessary, imo, because if you define something multiple times and the definitions don't match, in a magical world, that would just create an error, which it basically has to anyway. C++ is warty. The code I posted was in fact wonky because I had edited it to try to figure out why "static inline" was being seeing as not static by the broken-ass MS compiler error messages that make bad assumptions and don't really grok your code before barfing out their non-sense. The reason I was playing around with the static keyword at all really is because I was getting bizarre messages telling me i couldn't inline without the static, but then I added the static keyword and it said it wasn't static, which was really frustrating and strange.
&gt; “x64 but with 32bit pointers” abi. funny, linux may be deprecating x32 because nobody actually uses it lol
For the record, CMake has switched recently: https://cmake.org/cmake/help/latest/generator/Visual%20Studio%2016%202019.html VS can be convinced with `setx PreferredToolArchitecture=x64`. Others have already explained why the 32bit executables can be faster due to lower memory footprint and hence better cache efficiency.
you are banning puppies? You might not want to run on that platform. Save it for after you are elected.
Well there is/was https://en.m.wikipedia.org/wiki/X32_ABI but I've never seen anything similar on Windows.
Source?
By Mr. Torvalds himself: https://lkml.org/lkml/2018/12/10/1151
- Don't go head-first into vim. It requires a noticeable effort to become as efficient as what you are used to right now. - Start with the vimtutor's lessons, then proceed to read (not glance over) the user manual. - Use vim on the side and use VS for actual work, so your productivity wouldn't take a hit. - Once you feel as comfortable in vim as you are in VS, assuming that ever happens, you can effortlessly switch.
I'm surprisingly impressed how bad it is. For UI programming, it lacks the layout functionality from Qt. And ridiculously, code compiled by the classic compiler is not compatible with the one compiled by the new clang-based compiler, you can't link them together. As an IDE, it feels like a downgraded Visual Studio. I don't recommend it.
Xtensor has such a nice API. I just wish the lazyness didn't kill performance (compared to Eigen or Armadillo)
I remember seeing [this on hacker news](https://www.phoronix.com/scan.php?page=news_item&amp;px=Linux-Potentially-Drops-x32) and was able to find it after a quick search, but it looks like they were just "discussing" it, and hadn't actually done it yet afaik.
Individual object files are easier on the linker. Unity builds are better than LTO, in part for the reason you state, but not optimizing across object files is the easiest on memory.
... I was talking about the 64-bit tooling, dude.
Do you have an example of what you're trying?
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bvu8s0/is_this_just_my_problem_or_stdvariants_problem/epsmbm2/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
A real politician would be able to convince the electorate puppies are bad. If you can convince the poor that taxes and health care are bad, you can convince anyone of anything.
Nooooo. this is not a help. It is for expiring my feeling! How can a library not handle a pointer? It is even an std library. If you do not understand this post is not about help, that is fine. You should understand my feeling that using a c++ std library does not support the address of an orginal variable. If so, could you undelete my post?
Visual Studio Code hands down. Runs everywhere and has lots of language, debugger and build tools support. Very customizable with project wide settings that can go under source control.
Or using cheap laptops on the go, usually sold with Windows 10 Home 32 bits edition.
I agree QT’s layouts are nice, however if you use panels and dock properties, you can have the same effect. As far as the compiler compatibilities, I just build old source with the clang compiler. What I really like is the build speed and the debugger. Also, I like being able to build static executables for deployment. However, you can definitely tell not much work has been put into the IDE by Embarcadero. Also, Embarcadero’s documentation absolutely sucks (most examples are in Delphi), which is why I recommended reading old Borland books. If you haven’t used this in a while, I would recommend you at least give the free community edition a try. BTW, I have absolutely no affiliation with this product!
It's like arguing "containers cannot be implemented by pure library, and thus you cannot make your own containers without special compiler support". Boost would like to disagree with you on that.
If a test suite gets a test wrong, and it passes on all implementations, then apparently everyone is in agreement that this is how it is supposed to be...
Just as info one of the goals of UWP (nee WinRT) was to be just like VCL from Microsoft. Hence why come tide or high water, UWP is the future of Windows APIs. https://github.com/microsoft/microsoft-ui-xaml/blob/master/docs/roadmap.md While using C++/CX you can get an experience similar to C++ Builder, although they are slowing migrating to C++/WinRT, which is based on standard C++20, instead of using language extensions.
The irony is that before Borland messed up their business strategy, Visual Studio couldn't hold a candle to Borland C++ and Delphi offerings.
Stashed is great, but OP was asking about distributed compilation I think. Incredibuild specializes in that and does it really well. Stashed will distribute the cache so machines that have not yet built changes that others have will use the remote cached output. Stashed also works with Incredibuild, but the cache check is farmed out to a remote agent first, which is not optimal, but it does speed up Incredibuild times. For some free software projects, they seem open to giving seats away.
Stashed is mostly install and forget about it, which is nice if you do not want to change your build system to accommodate a tool. I tried clcache and others and it was pretty configuration and manual installation heavy. Fine for solo work and new projects I suppose. If your builds are not cache friendly (lots of code changes between builds) and you want more of a distcc style tool, Incredibuild is really a good bet. Depending on your project and budget, you may want to see if they can work with you on licensing. Same for Stashed.
Yeah. I was huge fan of the X32 ABI. I've been planning, well for quite a few years now, to try something like that on Windows. You see, on Windows even 64-bit executable can have LARGEADDRESSAWARE flag OFF and then all allocations are restricted to lower 2 GBs of address space. And handles are already 32-bit. So... it should be trivial to write *smart* pointer that's stored as **long** and sign extended only when dereferenced (or converted to normal pointer when necessary). I wonder what kind of instructions would MSVC compiler generate. Also the performance should be easy to compare. Just generating random graph or tree and traversing it, or sorting. Ghhh, firing up Visual Studio now...
How long do you suppose that's been around? ;-]
32 bit loads on x64 sign extend implicitly IIRC so you don't use any extra instructions.
I have a 32 bit Windows 10 tablet. It's a pile of shite, I definitely wouldn't run VS on it - who knows how long it would take to build an optimised build!
`std::get` / `std::get_if` ( / `reinterpret_cast`) can give you the stored value's reference or address, maybe I have misunderstood your question ?
 std::variant&lt;int, float&gt; v = 123; int* ptr = &amp;std::get&lt;int&gt;(v); // pointer to the int inside the variant
Posts for help should go to cpp_questions. This includes when you’re XY mad because you don’t know what you’re doing.
Please don’t post “opinions” that are just thinly veiled requests for help because you don’t understand the library.
I think it gets a little bit better in C++20 because `()` and `{}` will essentially do the same thing except that: – `{}` does not allow narrow conversions. – `()` will never call the initializer\_list constructor. This essentially means I will be able to use `()` for "uniform initialization" and don't have to worry about it accidentally calling the initializer\_list constructor.
A class member variable can declared both inline and static. It means it does not need to be separately defined like a regular static member variable.
I really wish those podcasters would stop constantly yammering about their multitude of conferences and insider gossip. It makes the whole podcast difficult to like. Nothing against that stuff otherwise, but I want to learn about the subject matter - you know, ```constexpr``` and coroutines and whatnot. Like probably most listeners, I don't attend standards committee meetings or conferences, I just want to understand C++. It bugs me that I have to keep skipping every 10 minutes because the hosts have again trailed off into personal conference anecdotes and buddy talk which has almost nothing to do with the topic as advertised in the title. I get it, you guys all know eachother, you like to shoot the shit casually. I can relate. Just wanted to point out how harmful that sort of unstructured small talk can be if the purpose is to provide insightful C++ podcasting to the average coder. Hope I didn't poop your party, I appreciate what you're doing nevertheless.
As this is about concrete applications, the only relevant question is imho, if the x86 toolchain actually runs faster (which may very well be the case) and not if there are any potential benefits.
This is about the toolchain version not the target architecture.
Because a) boost containers are not standard containers b) boost still relies on compiler-supplied standard library for type traits and initializer list among other things
I want something (testing what is invalid, without having to compiler for each test separately). I have found a way to do that, but with some limitations (like I can test operator*). If another approach exists (maybe without the limitations of my approach), I'll try it.
The increased latency is here for a reason though, see https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf 2.2.4 While it indeed says "As the PAUSE latency has been increased significantly, workloads that are sensitive to PAUSE latency will suffer some performance loss" it also says "The increased latency (allowing more effective utilization of competitively-shared microarchitectural resources to the logical processor ready to make forward progress) has a small positive performance impact of 1-2% on highly threaded applications." I think that not having this PAUSE is only good for your micro-benchmarks, not actual code
&gt; moodycamel I would also love to see https://github.com/GameTechDev/GTS-GamesTaskScheduler in the comparison.
I think that can work for all operators that can be defined outside a class, but not for operator=. Or am I missing something?
Some will just handle the lexing/parsing and use another stdlib implementation as much as possible. Others take something like GCC and extend it (like the Microchip XC32 compiler).
It’s a bit different than what you asked for, but check out JUCE. It’s one of the best modern C++ codebases around, but it’s also really useful for cross platform development (and you don’t need to use any of the JUCE codebase to get the cross platform benefits). There is a tool called the Projucer that will maintain settings for your app across any platform (iOS, Android, Mac, Windows, Linux, cmake). It then will automatically generate a project for the native toolset for your platform. For instance, you can make a library project (static or dynamic) in the Projucer, and it will automatically create on the fly a visual studio solution for windows or Xcode on iOS/Mac (or cmake, regular makefile, CLION or Code::Blocks on Linux, or Android studio for Android). It also can easily set up a cross-platform GUI app, using either the built-in JUCE tools, native windows/Mac/etc tools, or any other GUI library you want. I use it all the time to make a shared core library that all the other apps reference, and then depending on the project use React Native or the built in JUCE GUI tools for the GUI part. Any project that tries to do everything in one place always ends up less than ideal. I like managing a single project that can then be exported into any native build format as necessary instead.
Longer than I thought, for sure. Though MS doesn't really seem to have been telling people about it much until recently (VS2015/2017?). Earliest I could find was 2013. Regardless, my point was that it not being tested much could be a reason for it not being default.
At the same time absolutely feel free to ask for help
The objects which satisfy the "Allocator" concept/requirements are not supposed to manage allocation. They are supposed to be *references* to allocation managers. Move semantics shouldn't be a big deal for references, although for reference counting you do have a point. The whole Allocator spec is pretty crappy. I'd suggest ignoring that if needed, and submit a defect report if you feel civic.
IMHO, CppChat is far worse in that regard than CppCast. It’s the #1 reason I stopped listening to CppChat. The occasional conference talk on CppCast does keep me up to speed on the conferences that exist. And new ones keep popping up lately. For example: CPPP.
Exactly! Good point.
Let's talk about bad naming scheme. Allocators don't allocate memory. Memory resources do. The default allocator, `std::allocate&lt;T&gt;` does not allocate memory, it defers to `new` and `delete` operators. The C++17 `std::pmr::polymorphic_allocator&lt;T=std::byte&gt;` also doesn't allocate memory, but defers to a `std::pmr::memory_resource*` that may or may not go through `new`. &amp;nbsp; With that out of the way, that named requirement is about the allocator, not the memory resource. &gt; Does that mean stateful allocators effectively can't be moved in C++20 and have to be copied instead? I think your interpretation (effectively turning a move into a copy) is correct. I'm trying to think hard of a way to make that move constructor different from a copy. I'm also trying to find a reason for that change.
If I'm not mistaken, 2005 already had the x64 target.
Indeed. It's good to remember that 32-bit Windows 10 is still an officially supported and maintained platform. I guess it mainly exists because back in the day Windows 10 was a free upgrade from Windows 7 and some of the 64-bit machines were running a 32-bit version of Windows 7. At the release of Windows 10 (in 2015) all new machines were 64-bit after all. I still wonder when Microsoft will drop the 32-bit build of Windows 10. The customer hardware base is mainly 64-bit, and I think it's quite burdensome to separately build and test everything for a bunch of crusty 32-bit installations. 🙂
Indeed my custom allocator's only state is a shared_ptr to the actual allocator, so the cost isn't significant. But doesn't this requirement make writing "MyAlloc(MyAlloc&amp;&amp;) = default" a huge trap? To be correct, don't I have to either delete the move constructor/assignment or implement them explicitly as copying?
You're confusing target and tooling.
Yes, indeed. My bad!
Here's a diff of the change that introduced `a == a1`: https://en.cppreference.com/mwiki/index.php?title=cpp%2Fnamed_req%2FAllocator&amp;diff=95609&amp;oldid=95081
Well, there is already someone [successfully] convincing everybody [in the USoA] that import duties [and fake hair] are good for you, so this is not a stretch.
After further searching I think I tracked it down to https://cplusplus.github.io/LWG/issue2593 If I understood it correctly, a moved-from container still needs to be able to use its allocator, so the entire idea of a moved-from allocator is pointless. That makes sense, but also makes my "= default" reaction a trap...
I was thinking something like that might be the reason. If your `Allocator` becomes "empty" and doesn't have an associated memory resource, what happens in the following case? std::vector&lt;int, CustomNullableAllocator&gt; v1{1}; std::vector&lt;int, CustomNullableAllocator&gt; v2 = std::move(v1); v1.reserve(100); // ???
That's sort of correct, yet when you are unit testing templates then this is only checking some subset of specializations. It's darn hard to find all use cases which might go wrong. Therefore I would advise to create some constraints for template classes, algorithms. Even if our template is not suppose to support some constructions, then its better to inform user about it using static assert with correct error message than 10 pages of template errors. Especially if our implementation is more complex than simple add function. Take a look at Vinnie Falco presentation on CppCon. Would link it later. He explained how he created his library error proof, by using type traits.
The program in this case is the x86 tool chain, not the program being compiled.
I know what you mean, but I also appreciate hearing about talks so I know to look for them when they’re posted on youtube.
Well, lambdas are provided by the languages, as range-for loops are as countless other things are. Sugar IS an abstraction. There are even negative-cost abstractions, i.e. when you can express your intent at higher level which allows for much more optimizations. Doesn't take away that not all zero-runtime-cost abstractions have no other hidden costs, especially when they've implemented in the library with some arcane template magic.
Take a look at Google Breakpad: https://github.com/google/breakpad/blob/master/docs/getting_started_with_breakpad.md. It's really neat and works on Linux and windows.
I know, why did you think I meant something else?
Technically yeah, but practically not at all.
Not sure, I just woke up. Re-reading I see you are asking "is it actually faster, or just potentially faster"
&gt; Ghhh, firing up Visual Studio now... :D Let us know the results.
Lambdas are actually a good example of a very nice language abstraction that comes at a cost if optimizations are disabled. But I was primarily talking about user abstractions. I've implemented a D scope guard emulation on top of lambdas, very elegant to use but the code it generates with `-O0` is awful.
I'm not sure that you can really separate the two given that what they are mostly covering (new and proposed stuff) is being covered at those conferences, and people they are interviewing are frequently discussing what they presented / observed at those conferences. I also doubt that they actually all know each other, particular the one host who doesn't go to all the conferences. And you don't in this day and age need to attend those conferences with most of the talks available on YouTube within weeks. It really sounds like you more want a learning cpp type podcast, and so perhaps the YouTube channel the one host has might be more to your liking.
I imagine initally it would be due to compatibility (possible bugs in the x64 build). &amp;#x200B; Also x64 can be slower for (very) pointer heavy applications due to 2x memory usage (bigger difference on non-x86 arches though, since x64 comes with moree registers and other performance wins).
Another typical solution is to delete connections when uniquely owned objects are deleted.
This copying "move" constructor is there to keep you safe when you reuse a moved from object. As long as you don't do that, `= default;` is fine.
On the [correct subreddit](https://www.reddit.com/r/cpp_questions/).
Your SO question has already been given the answer that your loop is taking the address of a local variable instead of a reference to the actual list element, which is a completely unrelated problem to variants. The answerer showed that using a reference gives addresses corresponding to each list element. You can even take the address of the list element directly and compare it to see they're the same. You had some problem with that answer, but never properly clarified why it doesn't answer your question. The best you're going to get from reddit is that same answer.
Hey. Just wanted to say that I read this feedback and the other replies and we'll try to keep it in mind. I hope that talking about a conference's existence is at least somewhat valuable, there are lot's of new ones popping up like CPPP, CoreCpp, that listeners might not know about even if they're in the area.
It's nice to know what's actually happening
Although I could never figure out how to use an IDE to compile C++ , it's just so easy to use the command line and a make file
LOL, I'm the guy who submitted that, and it contradicts the answer I gave here earlier!
A defaulted move constructor won't (introduce a) copy. The requirement in question specifies that it's OK to reuse the moved-from object.
Can I interest you in a Linux distro with Vim as your text editor? :P. More seriously, there is a lot to be said about simplifying the tooling fluff, and getting closer to the things you actually need. (Of course the opposite arguments are just as valid, IDEs and other candy tools reduce cognitive load when working). Pretty sure you can have Vim on any OS. Modal editors are really powerful.
Yes, but /u/ExeuntTheDragon was asking if it's a huge trap if he deviates from the specification on this. I was just saying that if he doesn't reuse a moved from object, he would be fine with a defaulted move constructor.
Disclaimer: I'm a nobody who enjoys cppcast. ---- You are looking for a tutorial/article/book or a different podcast altogether. As a counter anecdote, I enjoy the balance cppcast maintains between language theory, new features, events etc and the guests themselves. Without personal anecdotes and current events etc, you are left with a dry, single purpose podcast. Nothing wrong with that, but it is not what cppcast is right now. And I'm glad it isn't. I enjoy listening in to keep up with what goes on in the community and hearing informal discussions at the same time. I didn't watch the shows Top Gear/The Grand Tour to master how to drive/make a buying decision for a car.
If the container, for example, uses its stateful allocator to obtain a root node, and its destructor tries to free that node after the allocator is invalidated, bad things could still happen.
Or emacs! :)
True, but if the whole container is in its default state after a move, there shouldn't be a root node and it could work. However, a moving move constructor of an Allocator is a bigger foot-gun than I though and shouldn't be used.
Can't you log cleanup failures using the custom deleter of a smart pointer? Besides writing your own smart pointer, using a private owned pointer just sounds like a lot of boiler plate code for no reason. Why continuously rewrite the same `delete p` destructor and hand written moves? plus the exception safety nuance and risk that was already mentioned. I'm not saying never use owning ptrs in your class. But it seems like the capabilities of smart pointers cover more use cases than you give them credit for. Imo the only use case for a private owning pointer is "there is no existing smart pointer that has the ownership/lifetime semantics that I want". Maybe the cleanup thing but I'm over 90% sure a custome deleter can do that job better. Anyway, I am not "scared of raw pointers" but it seems that almost always an existing smart pointer has only upsides compared to a raw pointer so I figure why do extra work and take on extra risk for no reason?
I have done the same thing. Although for me it was bash and nano on Linux. If you like working with a terminal you should learn bash and come to Linux.
Sorry, I meant a sentry node, not a root node. For example, iterators of a `std::list` instance are supposed to be transferable to another instance by swapping the containers. (This may be implementation-specific, but still the committee won't change the standard to make the capability nonconforming.) Therefore - `std::list::end` returns a sentry node which is not part of the container itself - the constructor of `std::list` is not `noexcept` - the destructor performs a deallocation from any valid state, including the default state
Check out a book called Web bots, spiders, and screen scrapers
Apparently, [UWP is dead](https://www.theverge.com/2019/5/30/18645609/microsofts-universal-windows-app-dead-microsoft-store-windows-store).
I really don't want a third party thing that would have to be installed with the product on every client system in the field and that would include having to push out symbolic info with the product. That would be crazy to even try to get individual home owners to install such a thing, and it would vastly complicate commercial installations for no benefit. I've already solved this problem portably and cleanly in a way that inherently is there along with the product.
Well, for one thing on a small percentage of classes actually even have this issue. In other cases, it's not one or two it's a whole list of them which means that they are in an owning collection of pointers so it's also not relevant there. And nothing that's not there in the actual context location is going to know what to log to give good information. Anything attached to the actual thing being deleted cannot know the context in which the problem occurred and log other information such as state of the containing object, and things like that. It just isn't that much code in return for the benefits gained. I think you guys just get hysterical over this stuff.
Do you have to use C++? I have found Beautifulsoup in Python to work well for this.
My department at work. We still have components going back and forth over COM between C++ and VB6. Yes you read that right, and yes it's as horrible as it sounds.
With evil mode!
You can skip non-practical exercises and you won't miss anything important for learning to program in C++.
I meant you could perhaps look at how they do backtraces for inspiration.
I do understand your point of view. I may simply have misaligned expections regarding the basic style of the podcast.
Hahahaha nope
&gt;Can't you log cleanup failures using the custom deleter of a smart pointer? Yes this. And if destructors are throwing exceptions then that's a bigger problem anyway.
I already know how to do that on Windows, which is why I do what I do now. It's stupidly heavy and requires linking in more stuff that, once it ever kicks in, you pretty much need to stop the program and restart it because it just bloats up like crazy in a system as large as mine due to the symbol loading. So I threw it out long ago. My scheme is very light weight, will come along for totally free to any system CIDLib is ported to, can provide context sensitive information at each step if desired that stack trace could never know, and also works for just regular old exception scenarios that aren't fatal. So I just can't see any real benefits to do it otherwise.
I use Visual Studio Code as an editor/syntax highlighter, but I use a command line build. It's almost a necessity if you are going to code you want to be portable. Otherwise, you will end up with a mess trying to keep IDE based (GUI configured) build infrastructure consistent across a large code base with many separate modules. And if you also have a layered system with more than one code base involved, as I do, the IDE won't generally deal well with that.
Well the reason I referenced it is because you suggested your scheme has difficulty understanding stacktraces of smart pointer destruction. I linked to this to show that it's not some fundamental problem with smart pointers themself. If I'm mistaken then please disregard.
It's a podcast, not a formal lecture. Podcast's (as I understand them) are based around listening to other people have a relatively casual conversation on a topic that interests you. Considering how wide the range of abilities of their listeners could be I feel like cppcast does a good job balancing fun patter and discussion of the more salient programming stuff. I've listened to a half dozen cppcast episodes and never felt the need to skip over sections. If I want formal, instructional stuff I download lectures or audiobooks. With podcast you can zone out for a moment or two and not have to scramble back to figure out what you missed.
Have you considered implementing your own shared pointer classes that interface with your custom "stack trace" system? That could give you best of both worlds.
The only reason that comes in mind is the fact that: - You are *forcing* the compiler to inline the function call - Without optimizations, the function will not be optimized - Inline a non optimized function might generate a lot of assembly instructions - Instruction cache misses, bad cache locality, bad code alignment etc.
There is a [`native()`](https://en.cppreference.com/w/cpp/filesystem/path/native) method that returns a reference to an internal representation of the path. So `p.native().size()` should work without any overhead.
Or one person wrote the test, and no one else noticed. So we are left with one person's interpretation of the standard.
It may be due to the debugger that can't recognize the inlined function in debug mode. But the function is not inlined for me: https://godbolt.org/z/19EIWz Personnally, I would like to have the __forceinline function always inlined because it can otherwise break the code (due to stack allocated memory, inline assembly "ret" or other nebulous things)
Fair enough but the target architecture is also 32-bit by default. I always have to delete the x86 configuration for fear of accidentally building with it.
If the test is wrong, but it passes on gcc, clang, msvc, and whatever other compiler you try, then those compilers also got it wrong. That's four separate entities all getting it wrong, and apparently all in the same way. The only danger is if the test is written first and compiler authors try to conform to it. But who in their right mind would write a test case before even writing the code? ;-)
You know it's more than "delete p" it's also the destructor definition and also your moves. With a unique ptr I can just = default those 3. I agree you don't always want copies and those will usually be deleted or explicitly defined anyway. &gt; an owning collection of pointers I don't have any experience with that but it sounds horrible, or at the very least super situational. Maybe that's a use case for private pointers that I was not aware if. For clarity, my point is not that you never use owning ptrs in your class, just that it's at best incredibly situational and you should still default to smart pointers over owning raw pointers. &gt; Anything attached to the actual thing being deleted cannot know the state of the containing object in order to report it. And if I'm understanding the custom deleter, that's as much or more code because it has to do the same stuff plus the lamba and deleter syntax. Actually, I'd have to see the code but there's a chance you could capture references the external info you need in your lambda so you have it later to log. Also as far as the boiler plate in this case, the way I think about it you're writing something like "try, delete, catch, log" somewhere no matter what so I don't see how the lambda is much different from a destructor. &gt; It just isn't that much code in return for the benefits gained. Ill agree it's not much more in terms of raw lines but the #1 issue for me is that the raw ptr route is easier to mess up especially with the exception safety. And I'm still not realising many "benefits" of using a raw owning ptr unless you're basically writing a smart pointer.
UWP is very much alive. https://github.com/microsoft/microsoft-ui-xaml/blob/master/docs/roadmap.md And React Native for Windows is being rewritten on top of UWP. https://github.com/microsoft/react-native-windows Some people would like to see it die, but have yet to understand that Win32 is in maintenance mode since Windows 7.
Yeah, I am trying to see if it's possible in C++ but if it requires more work than I might look into python
The problem is just that, if you depend on a smart pointer, by the time a problem occurs during cleanup, it's too late to capture any information about the context of the class it is in. A system driven stack trace could of course tell me I was there when the failure occurred. But it can't provide any other context information about that containing class. So, leaving aside the non-portability and such, it still limits the amount of information I can get. The same thing would apply, in any scenario I can think of right off hand, with anything that's actually in the smart pointer class itself. The parent class context wouldn't be anything that it would understand, so it couldn't really easily gather information. You could spin it around and push a bunch of information into it, but that would be a pretty bad "pay for it even if you don't use it" scenario. Ultimately, I think that handling the failure within the containing class dtor is the only way to get context information beyond just 'I was here when it went down.' And, I just don't see how that's a big problem relative to the benefit. As I said elsewhere, most classes don't have pointer members to begin with. Some that do aren't doing members but are storing objects in a collection that owns them so they are already sort of 'smart pointered' basically. You can choose to let them be cleaned up by the collection, or you can do what I typically do which is iterate and delete and catch errors for reporting. That's only a few lines more than what is done with a single pointer.
Learning the rudiments and building layers of knowledge on top of that is the proper way to learn any skill, period. Since cybersecurity requires actually working at the low level (as do other fields like video games and high frequency trading btw) that is why the people coming from the schools are incapable of handling these. If you think that having gone to school for 4 years only to come out unable to handle an entry level position in any of the aforementioned fields represents a good education, then it seems you simply don't understand what a good education provides. If you were to go to a premier engineering school and study software engineering you will be equipped properly for an entry-level position in any of those fields, so clearly it is possible. My point is that *all* schools should be teaching software engineering the same way, but since I know that many of them don't, my advice to the OP was to learn some of this stuff themselves before going to college (you'll never has as much time available for learning in your life as you do at the high school level). This "teaching programming backwards" approach is one reason (not the only reason for sure) why we have such a shortage of cybersecurity professionals, so much so that there is serious talk about instituting a draft of people with cybersecurity skills (up until the age of 45). Right now the government has practically zero cybersecurity folks because those people can earn 3x what the government pays by working in the civilian sector, but if there is a draft, the situation with be reversed and there'll be effectively no cybersecurity people in the civilian sector, and that will be very bad for the world in general.
&gt; Lambdas are actually a good example of a very nice language abstraction that comes at a cost if optimizations are disabled Which cost (over what they abstract over)? &gt;very elegant to use but the code it generates with -O0 is awful. That's true for any code with `-O0`.
Seems really useful. Thanks
I you find a good resource, please post it. I've got a similar problem, which I'd like to automate. I want to scrap the user data frok our Jira.
&gt; So, does sort_by_key() assume the target members have implemented some specific trait? Yep, the key needs to implement the `Ord` trait.
Pushing stuff into something for use later is very much "pay for it even if you never use it", so that's not really a good choice. Anyhoo... It's not my job to convince you. All I can say is that i have 1.1M lines of personal code that's very robust and very diagnosable in the field, and I find my scheme works very well for the large and complex systems I do. I put compactness well below a number of other considerations. My views on these things are not driven by language philosopy but by decades of dealing with hairy problems in the field and what it takes to deal with them. Since my main product (CQC) is an automation system that deals very much with the real world and is very active, multi-threaded, distributed and multi-user, they can get hairy indeed.
I'm a fan of Qt Creator, but most of the other tools listed in this thread are also decent options.
If you profile and a significant amount of time is spent entering the function, it might be worth forcing inlining. There's a lot of advice on the internet telling people "never profile in debug" or "never use inline/forceinline", but if debug build performance is important and forcing the compiler to do something improves performance, go for it. I've personally obvserved performance gains of 25%+ just from forcing a few simple functions to be inlined.
You sound confused. It's probably all the vaccines. I have a bleach cleanse that'll fix you right up.
It definitely requires more work than Python. But when you say C++, do you want modern C++ or are you comfortable with C-ish?
Re your edit, I agree. If a container needs a valid allocator in its moved-from state, I think it makes more sense for the container to copy the allocator instead of moving it. I'll see about reporting a defect and we'll see if it gets any traction.
Either is fine but I'm more comfortable with modern c++
I actually did this to learn about nerwork programming some years ago. To my knowledge there isn't anything you can do in any language that you can't do in C++. Communicating with a web server is just a bunch of HTTP requests, then all you have to do is parse the body of the replies for whatever info you need. Boost.asio is what I used (also available stand-alone). The Qt framework also has a network library that handles HTTP requests natively. There are tons of other options with various levels of abstraction out there. I'd google "c++ [network/sockets/tcp/http] library" and look at a few libraries' example code to see which one I like best.
&gt; Pushing stuff into something for use later is very much "pay for it even if you never use it", so that's not really a good choice. The code in the destructor and the code in the custom deleter would be basically identical. how would they be different in terms of paying for what you dont use? &gt; Anyhoo... It's not my job to convince you. why give up when you still havent even explained why a raw pointer is the only way to log cleanup failures, or explain why your "collection of owning pointers" is an essential design choice. I dont think its our job to convince eachother, im just trying to understand different approaches. Like I said the only use case, in my mind, for a raw owning ptr is a smart ptr class or something similar. I am still interested in knowing about other ways owning ptrs are used. But even in the use cases you've described a smart ptr still seems to have no downsides.
Thanks. And i definitely agree cleanup operators throwing exceptions is nasty af. I was just entertaining it for the sake of the argument, but i def should have mentioned how bad of a practice it can be.
I've pretty much said it a number of times. A destructing smart pointer cannot know anything about the state of the class that contains it, and hence cannot log anything about that containing object to provide context of the cleanup failure. That can be crucial to understanding an error in the field. Pushing stuff in during the constructor will require copying data every time that method is entered. Dealing with it in a catch block in the destructor only requires that overhead if an error actually occurs. The collection of owning pointers wasn't anything strongly related. The point there is that sometimes you have a class that might allocate a member or two. Other times, you have a class that allocates a number of other things, but not as members, just as owned objects in a collection of some sort that is a member. In my system, I have separate 'by value' and 'by reference' collections. The latter can be told that they own the objects and will clean them up when they are destructed. That sort of makes the 'meta smart pointers' in that sense. So I was just saying, in those cases, they already are effectively smart pointer'd. And I don't have to deal use smart pointers inside a collection in order to insure they get cleaned up. The collection already knows to do that. I CAN put smart pointers in a by value collection if there's a need for that, and of course that happens as well. So that only leaves the cases where they have actual allocated members. That isn't that large a percentage of classes and in those it's typically one or two members. So it's not like it's some great burden to deal with.
Just another nobody liking a bit of chat in a podcast...
&gt; A destructing smart pointer cannot know anything about the state of the class that contains it, `[this](){...}` in your custom deleter like I said. Or just use a freaking member function as your custom deleter. im pretty sure there are tons of way to accomplish what you want as a smart ptr deleter. &gt; Pushing stuff in during the constructor will require copying data every time that method is entered I dont think so. just capture by reference, or capture `this`. how is a copy required? &gt; So it's not like it's some great burden to deal with. i dont think the point is that is a "great" burden but the fact that its a burden at all. if there are *only* downsides then what is the point? yes you can still clean up owning ptrs in a class but i dont think anyone is arguing against that, its just that cleaning up the ptrs yourself offers only downsides. I already said implementations of smart ptrs or smart ptr like things would have raw ptrs, but is there anything else where an owning raw ptr is actually the better choice?
I did something similar when C++11 was relatively new: make the http request using boost.asio and then parse the html however you like (I just used regex to extract the parts I needed) but be aware that many websites still ship with broken html that doesn't pass a strict parser.
But the custom deleter is far more messy, because all that stuff has to be slapped into the member initialization. Having to push it out to private members is just a bunch more work than what I'm already doing. And, unless I'm missing something, that stuff cannot actually access any local state with the dtor itself either because it doesn't exist at the point of installing the lamba. It can only see class members, which may or may not be relevant or all you want to report. Otherwise, it's pushing stuff into the smart pointer itself, which is what I was talking about wrt to the overhead, and also has the same limitation as above wrt to local state within the dtor. I mean, it's like you are so convinced that humans cannot delete a pointer that you are willing to jump throw way more hoops than I'm doing by just deleting the dang pointer.
I remember reading that's the case *because* of it being the default with VS. I'm sure whenever VS changes default so will vcpkg.
I'm super happy that some shortcuts are now shown in the menu. I had no idea that ctrl+shift+b existed already in 2017, but just wasn't shown.
&gt; because all that stuff has to be slapped into the member initialization. I dont think so, you can use a member function if you want. &gt; cannot actually access any local state with the dtor itself if youre talking about local variables in your destructors scope then no, you could only capture member variables. if you really need to capture local destructor variables and handle cleanup failures the i dont think there is any other way. but thats really more of a forced and very specific scenario than an argument for raw owning ptrs in any sort of general way. &gt; I mean, it's like you are so convinced that humans cannot delete a pointer that you are willing to jump throw way more hoops than I'm doing by just deleting the dang pointer. no lol. first off, youre not just "deleting the dang pointer" youre catching failures during cleanup, and creating a log including the potential status/states of other objects being cleaned up at the same time. Anyway, when your cleanup operation is that complicated, how are you handling the case mentioned earlier? `: m_ptr1(new X), m_ptr2(new Y)` idk how to handle that without the custom deleter solution.
I re-run the benchmarks with `PAUSE` instructions and it helps indeed: latencies got smaller, throughput slightly higher. Updated the charts.
Thout I may have a couple inadvertent setting of multiple allocated members in the initialization list like that, it's not purposeful. My normal scheme, if more than one such, is to set them to null in the initialization list and then allocate them in the body, dealing with failures there. And I often want to log something beyond just the underlying exception, i.e. something specific to the containing class in addition to the underlying exception. Or I may want to log and eat the underlying exception and throw something specific to the containing class instead, to provide a more context sensitive exception to the callers. In some cases I'd be allocating in the body anyway, because I need to gen up more info in order to construct them than is convenient to do in the member init. And in some cases I'd likely do it even if it's a single member, if there's nothing immediately upstream that's going to provide context for a failure. And of course some failures to create some allocated member may not be fatal (remote resource isn't available now, we'll keep trying.) So, for me, most things argue towards handling those things in the ctor body in general.
Or just declare some local lambdas.
There's no absolute way to learn a language.
Something like that but I think the problem was a bit more complicated, maybe even semantically incorrect codegen or at least that direction.
3d array? my string arrays are just 2d arrays... what do you need the extra level for?
okay so if you are willing to explicitly handle all potential initialization failures in your constructor body, and you must log local variables in your destructor during potential cleanup failures, then i dont see any way around your solution. But with that said, now that we've defined this use case for owning pointers so specifically, hopefully you will agree that there is indeed a greater risk and more code required when using owning ptrs compared to smart ptrs, but in your specific use case, due to how closely and carefully you have to error handle your memory management anyway, owning ptrs make sense despite their safety/simplicity drawbacks. Also i hope you dont take it as personally when ppl recommend against raw owning ptrs. Most of that advice that i've seen just says e.g. "avoid" so it acknowledges that there are some situations to use raw owning ptrs and they should just never be the default, and those situations that call for raw owning ptrs are very specific and specialized (like the one you've been describing). so in conclusion, I still believe raw owning ptrs, in general, require more code and are more error prone compared to smart ptrs to get the same result, but for your specific use case i agree that raw ptrs are the right call assuming everything else you've said about the situation.
Can't use type inference though if you rely on conversion operators. Might cause some surprises for people that regularly use `auto`.
The casual conference talk is what keeps me engaged. If I wanted to learn explicitly about a feature, I'll go read the million blog posts or Jason's YT videos on it. When you guys drift about the conferences and whose talks we're good, it makes it feel like there's a real community behind C++, and I end up watching those conference talks. Don't kill this aspect of it.
Not modern at all, actually written in c, but since nobody has yet given any alternative you can at least practice with glut
On 64 bit machine pointers are 8 byte only if bytes are 8 bit and memory is not segmented.
Obviously you have to be careful. But that's sort of true of a lot of things, including smart pointers, which can get you into a whole other different set of problems. IMO, a certain amount of modern C++ 'dogma' (for lack of a less offensive word at the moment) is predicated on making the language safer for less knowledgeable programmers, in order to compete with other languages that would typically be seen as more appropriate for them. I'm not sure that's worth it, given that nothing really makes it safe for less knowledgeable programmers ultimately, IMO. But, in that light, probably it makes more sense to just say 'no do dis', and leave it at that.
I've played with SFML a fair bit. It's maybe a bit more on the classic side of C++, but I haven't had trouble integrating it into a C++11 project.
What did you find when you googled it?
&gt;without changing the calling convention. ???
I would use curl and libxml2. Both are C, but you can wrap them in your own modern C++ classes. Boost.asio + libxml2 is another good option.
If you can't find it in a google or github search, then it's not popular enough to use or you may need to improve searching skills. Skia might not have been written in C++17, but it will definitely compile in a C++17 project.
Isn't Qt a C++ framework?
good point. Thoroughly invalid now.
I quite a few libraries and they are all 3D mainly. Working in 2D is much simpler as there is kind of no camera involved, only 2 planes to make things work. The ones i found include bs::framework, Magnum, Acid and Halley, Banshee 3D
I found quite a few (all 3D) and came to reddit to get a better recommendation from experienced.
&gt; including smart pointers, which can get you into a whole other different set of problems. yea definitely, which is a reason why I would say prefer regular automatic storage objects by default over a smart ptr. &gt; I'm not sure that's worth it, given that nothing really makes it safe for less knowledgeable programmers ultimately, IMO. Definitely not 100% safe but I would definitely say, at least if youre talking about RAII smart ptr memory management type stuff, that the language is more simple and safer now. If you ask me, even in general I cant think of many additions I am upset for, and I am eagerly awaiting some of the new c++20 features (more constexpr, contracts, concepts). These new features dont really make the language seem more complicated, sure there are more things in total, but if one new thing means you no longer need to know two other old things, that makes the language seem simpler for me. Also pretty much all of the old features are still there if you still want/need to use them. In the end i think the language was made safer and I dont really see a significant cost
Honorable mention to IO2D, https://github.com/cristianadam/io2d The proposal itself: http://open-std.org/JTC1/sc22/wg21/docs/papers/2016/p0267r0.pdf
A better method: define local lambdas. int f(int x) { auto g = [] { return 5; }; return x + g(); }
Try [Raylib](https://www.raylib.com/)
I've never used any of the ones I found, but I did find quite a few before making this comment after reading your post. I don't know what to tell you, but the internet is littered with them. If you want to know what a good one is, check it's popularity on github. You could also use unity, unreal or godot for 2d rendering depending on your needs.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bvy55r/c_web_scraping/epub2bh/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Not specifically modern c++ but I think this is the simplest graphics library yet, C style.
[nanovg](https://github.com/memononen/nanovg)?